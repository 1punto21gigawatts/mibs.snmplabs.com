#
# PySNMP MIB module BayNetworks-DHCP-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/BayNetworks-DHCP-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:42:38 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, SingleValueConstraint, ConstraintsIntersection, ConstraintsUnion, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "SingleValueConstraint", "ConstraintsIntersection", "ConstraintsUnion", "ValueRangeConstraint")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Gauge32, iso, MibScalar, MibTable, MibTableRow, MibTableColumn, Integer32, Counter64, Counter32, TimeTicks, Unsigned32, NotificationType, Bits, ObjectIdentity, ModuleIdentity, MibIdentifier, IpAddress = mibBuilder.importSymbols("SNMPv2-SMI", "Gauge32", "iso", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Integer32", "Counter64", "Counter32", "TimeTicks", "Unsigned32", "NotificationType", "Bits", "ObjectIdentity", "ModuleIdentity", "MibIdentifier", "IpAddress")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
wfDhcpServerGroup, = mibBuilder.importSymbols("Wellfleet-COMMON-MIB", "wfDhcpServerGroup")
wfDhcpSvrGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 24, 1))
wfDhcpSvrGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 24, 1, 1))
wfDhcpSvrDelete = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 24, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfDhcpSvrDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfDhcpSvrDelete.setDescription('Created/Deleted: if set to Deleted, the DHCP server is removed from this platform.')
wfDhcpSvrDisable = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 24, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfDhcpSvrDisable.setStatus('mandatory')
if mibBuilder.loadTexts: wfDhcpSvrDisable.setDescription('Enable/Disable: controls whether the DHCP server is enabled or disabled on this platform.')
wfDhcpSvrMgrIpAddr = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 24, 1, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfDhcpSvrMgrIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: wfDhcpSvrMgrIpAddr.setDescription('IP Address of the NetID DHCP Server Manager serving this platform instance.')
wfDhcpSvrMgrTcpPort = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 24, 1, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfDhcpSvrMgrTcpPort.setStatus('mandatory')
if mibBuilder.loadTexts: wfDhcpSvrMgrTcpPort.setDescription('The remote TCP port number over which the DHCP Server communicates with the NetID DHCP Server Manager.')
wfDhcpSvrConfDetPings = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 24, 1, 1, 5), Integer32().clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfDhcpSvrConfDetPings.setStatus('mandatory')
if mibBuilder.loadTexts: wfDhcpSvrConfDetPings.setDescription('Number of ping attempts that should be made to a prospective client IP address to detect a possible conflict before declaring it unused and therefore available.')
wfDhcpSvrIcmpTmo = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 24, 1, 1, 6), Integer32().clone(750)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfDhcpSvrIcmpTmo.setStatus('mandatory')
if mibBuilder.loadTexts: wfDhcpSvrIcmpTmo.setDescription('Amount of time, in milliseconds, to wait for a conflict detection ping to time out.')
wfDhcpSvrSafeModeDisable = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 24, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfDhcpSvrSafeModeDisable.setStatus('mandatory')
if mibBuilder.loadTexts: wfDhcpSvrSafeModeDisable.setDescription('Specifies whether the DHCP Server should wait until it gets acknowledgment of successful commitment of a lease from the NetID DHCP Server Manager before sending a lease-granted acknowledgment back to the DHCP Client. If set to Enabled, the DHCP Server will wait for the NetID DHCP Server Manager to confirm successful commit. If set to Disabled, the DHCP Server will immediately send back a lease-granted acknowledgement to the DHCP Client, without awaiting a commit-succeeded acknowledgment from the NetID DHCP Server Manager.')
wfDhcpSvrMaxPendingLeases = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 24, 1, 1, 8), Integer32().clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfDhcpSvrMaxPendingLeases.setStatus('mandatory')
if mibBuilder.loadTexts: wfDhcpSvrMaxPendingLeases.setDescription('Maximum number of lease requests to the DHCP Server which are pending commitment by the NetID DHCP Server Manager. Once there are wfDhcpSvrMaxPendingLeases lease requests pending, all new lease requests will be dropped until the number of requests pending decreases to wfDhcpSvrMaxPendingLeases/2.')
wfDhcpSvrDebugLevel = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 24, 1, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfDhcpSvrDebugLevel.setStatus('mandatory')
if mibBuilder.loadTexts: wfDhcpSvrDebugLevel.setDescription('Maximum debug level for optional debug messages from the DHCP Server. Normally, only messages with a debug level of 0 will be logged. The higher this attribute is made (up to a maximum of 10), the more messages will be logged. Since the logging of additional information can fill the log very rapidly and cause loss of other information, this attribute should only be changed to resolve critical problems.')
wfDhcpSvrMgrLocIpAddr = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 24, 1, 1, 10), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfDhcpSvrMgrLocIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: wfDhcpSvrMgrLocIpAddr.setDescription('IP Address the DHCP Server uses to identify itself to NetID DHCP Server Manager serving this platform instance. Should correspond to an actual local interface address on the router.')
wfDhcpSvrIntfTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 24, 1, 2), )
if mibBuilder.loadTexts: wfDhcpSvrIntfTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfDhcpSvrIntfTable.setDescription('This table contains per-interface status information for DHCP Server operation.')
wfDhcpSvrIntfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 24, 1, 2, 1), ).setIndexNames((0, "BayNetworks-DHCP-MIB", "wfDhcpSvrIntfAddress"))
if mibBuilder.loadTexts: wfDhcpSvrIntfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfDhcpSvrIntfEntry.setDescription('A DHCP Server network interface status description.')
wfDhcpSvrIntfAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 24, 1, 2, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDhcpSvrIntfAddress.setStatus('mandatory')
if mibBuilder.loadTexts: wfDhcpSvrIntfAddress.setDescription('Address of this network interface.')
wfDhcpSvrIntfState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 24, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDhcpSvrIntfState.setStatus('mandatory')
if mibBuilder.loadTexts: wfDhcpSvrIntfState.setDescription('The state of the DHCP Server on this network interface.')
wfDhcpSvrIntfPendLsCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 24, 1, 2, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDhcpSvrIntfPendLsCnt.setStatus('mandatory')
if mibBuilder.loadTexts: wfDhcpSvrIntfPendLsCnt.setDescription('Number of DHCP leases pending commitment by the NetID Server Manager on this network interface.')
wfDhcpSvrIntfActLsCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 24, 1, 2, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDhcpSvrIntfActLsCnt.setStatus('mandatory')
if mibBuilder.loadTexts: wfDhcpSvrIntfActLsCnt.setDescription('Number of DHCP leases currently active and committed by the NetID Server Manager on this network interface.')
wfDhcpSvrIntfCommits = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 24, 1, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDhcpSvrIntfCommits.setStatus('mandatory')
if mibBuilder.loadTexts: wfDhcpSvrIntfCommits.setDescription('Number of Commit requests made by the DHCP Server for clients on this network interface.')
wfDhcpSvrIntfCommitFails = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 24, 1, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDhcpSvrIntfCommitFails.setStatus('mandatory')
if mibBuilder.loadTexts: wfDhcpSvrIntfCommitFails.setDescription('Number of Commit-failed responses to the DHCP Server for clients on this network interface.')
wfDhcpSvrIntfCommitTmos = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 24, 1, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDhcpSvrIntfCommitTmos.setStatus('mandatory')
if mibBuilder.loadTexts: wfDhcpSvrIntfCommitTmos.setDescription('Number of times the NetID DHCP Server Manager did not respond to a commit request from the DHCP Server for clients on this network interface.')
wfDhcpSvrIntfIllegPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 24, 1, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDhcpSvrIntfIllegPkts.setStatus('mandatory')
if mibBuilder.loadTexts: wfDhcpSvrIntfIllegPkts.setDescription('Number of DHCP packets with no legal type sent to the DHCP Server for clients on this network interface.')
wfDhcpSvrIntfDiscovers = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 24, 1, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDhcpSvrIntfDiscovers.setStatus('mandatory')
if mibBuilder.loadTexts: wfDhcpSvrIntfDiscovers.setDescription('Number of DISCOVER packets sent to DHCP Server by clients on this network interface.')
wfDhcpSvrIntfBadDiscovers = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 24, 1, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDhcpSvrIntfBadDiscovers.setStatus('mandatory')
if mibBuilder.loadTexts: wfDhcpSvrIntfBadDiscovers.setDescription('Number of badly-formed DISCOVER packets sent to DHCP Server for clients on this network interface.')
wfDhcpSvrIntfReassgnLeases = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 24, 1, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDhcpSvrIntfReassgnLeases.setStatus('mandatory')
if mibBuilder.loadTexts: wfDhcpSvrIntfReassgnLeases.setDescription('Number of client requests for leases already reassigned to another client of DHCP Server on this network interface.')
wfDhcpSvrIntfNoFreeLeases = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 24, 1, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDhcpSvrIntfNoFreeLeases.setStatus('mandatory')
if mibBuilder.loadTexts: wfDhcpSvrIntfNoFreeLeases.setDescription('Number of times DHCP Server had no leases available to offer a client in response to a DHCPDISCOVER request on this network interface.')
wfDhcpSvrIntfDropdLeaseRqs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 24, 1, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDhcpSvrIntfDropdLeaseRqs.setStatus('mandatory')
if mibBuilder.loadTexts: wfDhcpSvrIntfDropdLeaseRqs.setDescription('Number of DHCP client requests for a lease on this interface which were dropped by the DHCP Server because the total number of leases pending commitment exceeded the threshhold for accepting new leases at the time the client made the request.')
wfDhcpSvrIntfOffers = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 24, 1, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDhcpSvrIntfOffers.setStatus('mandatory')
if mibBuilder.loadTexts: wfDhcpSvrIntfOffers.setDescription('Number of offers (DHCPOFFER messages) sent out by DHCP Server for clients on this network interface.')
wfDhcpSvrIntfRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 24, 1, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDhcpSvrIntfRequests.setStatus('mandatory')
if mibBuilder.loadTexts: wfDhcpSvrIntfRequests.setDescription('Number of DHCPREQUEST packets sent to DHCP Server by clients on this network interface.')
wfDhcpSvrIntfBadRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 24, 1, 2, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDhcpSvrIntfBadRequests.setStatus('mandatory')
if mibBuilder.loadTexts: wfDhcpSvrIntfBadRequests.setDescription('Number of badly-formed DHCPREQUEST packets sent to DHCP Server by clients on this network interface.')
wfDhcpSvrIntfReleases = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 24, 1, 2, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDhcpSvrIntfReleases.setStatus('mandatory')
if mibBuilder.loadTexts: wfDhcpSvrIntfReleases.setDescription('Number of DHCPRELEASE packets sent to DHCP Server by clients on this network interface.')
wfDhcpSvrIntfBadReleases = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 24, 1, 2, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDhcpSvrIntfBadReleases.setStatus('mandatory')
if mibBuilder.loadTexts: wfDhcpSvrIntfBadReleases.setDescription('Number of badly-formed DHCPRELEASE packets sent to DHCP Server by clients on this network interface.')
wfDhcpSvrIntfDeclines = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 24, 1, 2, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDhcpSvrIntfDeclines.setStatus('mandatory')
if mibBuilder.loadTexts: wfDhcpSvrIntfDeclines.setDescription('Number of DHCPDECLINE packets sent to DHCP Server by clients on this network interface.')
wfDhcpSvrIntfBadDeclines = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 24, 1, 2, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDhcpSvrIntfBadDeclines.setStatus('mandatory')
if mibBuilder.loadTexts: wfDhcpSvrIntfBadDeclines.setDescription('Number of badly-formed DHCPDECLINE packets sent to DHCP Server by clients on this network interface.')
wfDhcpSvrIntfInforms = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 24, 1, 2, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDhcpSvrIntfInforms.setStatus('mandatory')
if mibBuilder.loadTexts: wfDhcpSvrIntfInforms.setDescription('Number of DHCPINFORM packets sent to DHCP Server by non-lease clients on this network interface.')
wfDhcpSvrIntfBadInforms = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 24, 1, 2, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDhcpSvrIntfBadInforms.setStatus('mandatory')
if mibBuilder.loadTexts: wfDhcpSvrIntfBadInforms.setDescription('Number of badly-formed DHCPINFORM packets sent to DHCP Server by non-lease clients on this network interface.')
wfDhcpSvrIntfAddrConflict = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 24, 1, 2, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDhcpSvrIntfAddrConflict.setStatus('mandatory')
if mibBuilder.loadTexts: wfDhcpSvrIntfAddrConflict.setDescription("Number of times the conflict detection phase of DHCP lease assignment detected a host using the IP address the DHCP Server was working to assign. This normally indicates that the detected host is using an IP address which it doesn't own.")
wfDhcpSvrLeaseTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 24, 1, 3), )
if mibBuilder.loadTexts: wfDhcpSvrLeaseTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfDhcpSvrLeaseTable.setDescription('This table contains per-interface, per-lease status information for DHCP Server operation.')
wfDhcpSvrLeaseEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 24, 1, 3, 1), ).setIndexNames((0, "BayNetworks-DHCP-MIB", "wfDhcpSvrLeaseAddress"))
if mibBuilder.loadTexts: wfDhcpSvrLeaseEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfDhcpSvrLeaseEntry.setDescription('A DHCP Server lease description.')
wfDhcpSvrLeaseState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 24, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("committed", 1), ("pending", 2), ("pendingfail", 3), ("pendingtmo", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDhcpSvrLeaseState.setStatus('mandatory')
if mibBuilder.loadTexts: wfDhcpSvrLeaseState.setDescription('The current state of a lease. It may be committed in the NetID Server Manager, pending commitment, or pending with an already failed or timed-out commitment attempt.')
wfDhcpSvrLeaseRetries = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 24, 1, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDhcpSvrLeaseRetries.setStatus('mandatory')
if mibBuilder.loadTexts: wfDhcpSvrLeaseRetries.setDescription('Number of lease commit retries for this lease either because of reported commit fail from NetID Server Manager or because of timeout on commit request. Zero if lease pending or committed.')
wfDhcpSvrLeaseAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 24, 1, 3, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDhcpSvrLeaseAddress.setStatus('mandatory')
if mibBuilder.loadTexts: wfDhcpSvrLeaseAddress.setDescription('Leased IP Address of client.')
wfDhcpSvrLeaseExpir = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 24, 1, 3, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDhcpSvrLeaseExpir.setStatus('mandatory')
if mibBuilder.loadTexts: wfDhcpSvrLeaseExpir.setDescription('Time when lease will expire. Expressed as number of seconds since beginning of January 1, 1970.')
wfDhcpSvrLeaseDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 24, 1, 3, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDhcpSvrLeaseDuration.setStatus('mandatory')
if mibBuilder.loadTexts: wfDhcpSvrLeaseDuration.setDescription('Agreed-upon duration of lease, in seconds.')
wfDhcpSvrLeaseHwId = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 24, 1, 3, 1, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDhcpSvrLeaseHwId.setStatus('mandatory')
if mibBuilder.loadTexts: wfDhcpSvrLeaseHwId.setDescription('Hardware identifier of client holding the lease.')
wfDhcpSvrLeaseClId = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 24, 1, 3, 1, 7), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDhcpSvrLeaseClId.setStatus('mandatory')
if mibBuilder.loadTexts: wfDhcpSvrLeaseClId.setDescription('Client identifier of client holding the lease.')
wfDhcpSvrLeaseFqdn = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 24, 1, 3, 1, 8), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDhcpSvrLeaseFqdn.setStatus('mandatory')
if mibBuilder.loadTexts: wfDhcpSvrLeaseFqdn.setDescription('Fully qualified domain name of client holding the lease, for DNS update management.')
mibBuilder.exportSymbols("BayNetworks-DHCP-MIB", wfDhcpSvrIntfActLsCnt=wfDhcpSvrIntfActLsCnt, wfDhcpSvrIntfDiscovers=wfDhcpSvrIntfDiscovers, wfDhcpSvrIntfBadInforms=wfDhcpSvrIntfBadInforms, wfDhcpSvrIcmpTmo=wfDhcpSvrIcmpTmo, wfDhcpSvrIntfInforms=wfDhcpSvrIntfInforms, wfDhcpSvrLeaseTable=wfDhcpSvrLeaseTable, wfDhcpSvrIntfOffers=wfDhcpSvrIntfOffers, wfDhcpSvrMgrTcpPort=wfDhcpSvrMgrTcpPort, wfDhcpSvrIntfCommitFails=wfDhcpSvrIntfCommitFails, wfDhcpSvrIntfCommitTmos=wfDhcpSvrIntfCommitTmos, wfDhcpSvrIntfCommits=wfDhcpSvrIntfCommits, wfDhcpSvrIntfBadDeclines=wfDhcpSvrIntfBadDeclines, wfDhcpSvrLeaseState=wfDhcpSvrLeaseState, wfDhcpSvrIntfDeclines=wfDhcpSvrIntfDeclines, wfDhcpSvrLeaseAddress=wfDhcpSvrLeaseAddress, wfDhcpSvrIntfRequests=wfDhcpSvrIntfRequests, wfDhcpSvrIntfEntry=wfDhcpSvrIntfEntry, wfDhcpSvrConfDetPings=wfDhcpSvrConfDetPings, wfDhcpSvrLeaseClId=wfDhcpSvrLeaseClId, wfDhcpSvrIntfBadRequests=wfDhcpSvrIntfBadRequests, wfDhcpSvrMgrLocIpAddr=wfDhcpSvrMgrLocIpAddr, wfDhcpSvrGeneral=wfDhcpSvrGeneral, wfDhcpSvrIntfBadDiscovers=wfDhcpSvrIntfBadDiscovers, wfDhcpSvrIntfIllegPkts=wfDhcpSvrIntfIllegPkts, wfDhcpSvrLeaseDuration=wfDhcpSvrLeaseDuration, wfDhcpSvrLeaseFqdn=wfDhcpSvrLeaseFqdn, wfDhcpSvrLeaseRetries=wfDhcpSvrLeaseRetries, wfDhcpSvrDelete=wfDhcpSvrDelete, wfDhcpSvrIntfReleases=wfDhcpSvrIntfReleases, wfDhcpSvrIntfPendLsCnt=wfDhcpSvrIntfPendLsCnt, wfDhcpSvrIntfReassgnLeases=wfDhcpSvrIntfReassgnLeases, wfDhcpSvrMgrIpAddr=wfDhcpSvrMgrIpAddr, wfDhcpSvrDebugLevel=wfDhcpSvrDebugLevel, wfDhcpSvrGroup=wfDhcpSvrGroup, wfDhcpSvrIntfNoFreeLeases=wfDhcpSvrIntfNoFreeLeases, wfDhcpSvrIntfState=wfDhcpSvrIntfState, wfDhcpSvrLeaseHwId=wfDhcpSvrLeaseHwId, wfDhcpSvrDisable=wfDhcpSvrDisable, wfDhcpSvrMaxPendingLeases=wfDhcpSvrMaxPendingLeases, wfDhcpSvrIntfAddrConflict=wfDhcpSvrIntfAddrConflict, wfDhcpSvrLeaseEntry=wfDhcpSvrLeaseEntry, wfDhcpSvrIntfDropdLeaseRqs=wfDhcpSvrIntfDropdLeaseRqs, wfDhcpSvrLeaseExpir=wfDhcpSvrLeaseExpir, wfDhcpSvrIntfBadReleases=wfDhcpSvrIntfBadReleases, wfDhcpSvrSafeModeDisable=wfDhcpSvrSafeModeDisable, wfDhcpSvrIntfAddress=wfDhcpSvrIntfAddress, wfDhcpSvrIntfTable=wfDhcpSvrIntfTable)

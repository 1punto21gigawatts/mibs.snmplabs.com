#
# PySNMP MIB module COM21-HCXTOP-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/COM21-HCXTOP-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:26:23 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint", "ConstraintsIntersection")
com21Reg, com21, com21Traps, com21Hcx = mibBuilder.importSymbols("COM21-HCX-MIB", "com21Reg", "com21", "com21Traps", "com21Hcx")
hcxEventLogTime, hcxAlmSeverity = mibBuilder.importSymbols("COM21-HCXALM-MIB", "hcxEventLogTime", "hcxAlmSeverity")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Integer32, IpAddress, Unsigned32, ModuleIdentity, ObjectIdentity, Bits, MibIdentifier, iso, Counter64, NotificationType, Gauge32, TimeTicks, Counter32, MibScalar, MibTable, MibTableRow, MibTableColumn = mibBuilder.importSymbols("SNMPv2-SMI", "Integer32", "IpAddress", "Unsigned32", "ModuleIdentity", "ObjectIdentity", "Bits", "MibIdentifier", "iso", "Counter64", "NotificationType", "Gauge32", "TimeTicks", "Counter32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn")
DisplayString, MacAddress, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "MacAddress", "TextualConvention")
com21HcxCtrl = ModuleIdentity((1, 3, 6, 1, 4, 1, 1141, 2, 1))
if mibBuilder.loadTexts: com21HcxCtrl.setLastUpdated('9701080000Z')
if mibBuilder.loadTexts: com21HcxCtrl.setOrganization('Com21, Inc.')
if mibBuilder.loadTexts: com21HcxCtrl.setContactInfo(' Network Management Postal: Paul Gordon Com21, Inc. 750 Tasman Drive Milpitas, California 95035 USA Tel: +1 408 953 9100 Fax: +1 408 953 9299 E-mail: pgordon@com21.com')
if mibBuilder.loadTexts: com21HcxCtrl.setDescription('This is the Com21 ComController Unit Control MIB module. It provides for overall, high-level control of the ComController and comUNITY system. COM21 Part# 005-0025-00')
com21HcxControlGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 1141, 2, 2))
com21HcxAcqCnfgGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 1141, 2, 3))
com21HcxAlmOverGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 1141, 2, 4))
com21HcxStuOverGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 1141, 2, 5))
com21HcxTrapRcvrGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 1141, 2, 6))
com21HcxShelfGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 1141, 2, 7))
com21HcxSlotGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 1141, 2, 8))
com21HcxImageListGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 1141, 2, 9))
com21HcxServTypeGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 1141, 2, 10))
com21HcxArpFiltTrapGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 1141, 2, 12))
com21HcxStuDefaultGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 1141, 2, 13))
com21HcxDbControlGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 1141, 2, 14))
com21HcxBootControlGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 1141, 2, 18))
com21HcxPhase30 = MibIdentifier((1, 3, 6, 1, 4, 1, 1141, 6, 1))
com21HcxCompact = MibIdentifier((1, 3, 6, 1, 4, 1, 1141, 6, 2))
class UpstrmFreqKhz(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(5000, 40000)

class StuGain(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(18, 58)

class EpochTime(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 2147483647)

class PrimServiceState(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("is", 1), ("oos", 2))

class Com21RowStatus(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("active", 1), ("create", 2), ("destroy", 3), ("deactive", 4))

class HcxCardType(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17))
    namedValues = NamedValues(("rx", 1), ("tx", 2), ("ethDual10bT", 3), ("ethQuad10bT", 4), ("eth100bT", 5), ("tele", 6), ("cc", 7), ("oc3", 8), ("atm25", 9), ("empty", 10), ("txRf", 11), ("txDig", 12), ("eth10bT8k", 13), ("intConn", 14), ("rxm", 15), ("atmlSw", 16), ("compactSw", 17))

hcxMacAddress = MibScalar((1, 3, 6, 1, 4, 1, 1141, 2, 2, 1), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hcxMacAddress.setStatus('current')
if mibBuilder.loadTexts: hcxMacAddress.setDescription(' Contains IEEE 802 medium access control address of the ComController device.')
hcxEncryptionEnable = MibScalar((1, 3, 6, 1, 4, 1, 1141, 2, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hcxEncryptionEnable.setStatus('current')
if mibBuilder.loadTexts: hcxEncryptionEnable.setDescription(' Used to enable or disable encryption on a system basis. Default is true.')
hcxPartNumber = MibScalar((1, 3, 6, 1, 4, 1, 1141, 2, 2, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readonly")
if mibBuilder.loadTexts: hcxPartNumber.setStatus('current')
if mibBuilder.loadTexts: hcxPartNumber.setDescription(' The ComController Part Number is a display string .')
hcxEpochTime = MibScalar((1, 3, 6, 1, 4, 1, 1141, 2, 2, 4), EpochTime()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hcxEpochTime.setStatus('current')
if mibBuilder.loadTexts: hcxEpochTime.setDescription(' The Epoch Time is a 31 bit signed positive integer containing the number of seconds since 1970.')
hcxUserText = MibScalar((1, 3, 6, 1, 4, 1, 1141, 2, 2, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hcxUserText.setStatus('current')
if mibBuilder.loadTexts: hcxUserText.setDescription(" The User Text is a non-volatile string which is set by the management system with an arbitrary value. This value does not have to be unique. It's purpose is solely to assist the carrier personnel with identifying the ComController device.")
hcxSerialNumber = MibScalar((1, 3, 6, 1, 4, 1, 1141, 2, 2, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readonly")
if mibBuilder.loadTexts: hcxSerialNumber.setStatus('current')
if mibBuilder.loadTexts: hcxSerialNumber.setDescription(' The Serial Number is a 32 character number used by COM21 to uniquely identify the device.')
hcxIpAddress = MibScalar((1, 3, 6, 1, 4, 1, 1141, 2, 2, 7), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hcxIpAddress.setStatus('current')
if mibBuilder.loadTexts: hcxIpAddress.setDescription(' IP address of the ComController SNMP Agent.')
hcxIpMask = MibScalar((1, 3, 6, 1, 4, 1, 1141, 2, 2, 27), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hcxIpMask.setStatus('current')
if mibBuilder.loadTexts: hcxIpMask.setDescription(' IP mask of the ComController SNMP Agent.')
hcxGatewayAddress = MibScalar((1, 3, 6, 1, 4, 1, 1141, 2, 2, 8), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hcxGatewayAddress.setStatus('current')
if mibBuilder.loadTexts: hcxGatewayAddress.setDescription(' IP address of any IP Gateway. Default is 0.0.0.0.')
hcxRestartAction = MibScalar((1, 3, 6, 1, 4, 1, 1141, 2, 2, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("nil", 1), ("warmStart", 2), ("coldStart", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hcxRestartAction.setStatus('current')
if mibBuilder.loadTexts: hcxRestartAction.setDescription(' The Restart Action is an active-value. The setting of this value to warmStart(2) causes the ComController to restart utilizing the present active software load. The setting of this value to coldStart(3) causes the ComController to restart, refreshing the current active firmware images and the active configuration file from the NMAPS. This completion of the reboot shall be indicated by the standard SNMP warmStart or coldStart trap.')
hcxRestartNotify = NotificationType((1, 3, 6, 1, 4, 1, 1141, 4, 59)).setObjects(("COM21-HCXALM-MIB", "hcxAlmSeverity"), ("COM21-HCXALM-MIB", "hcxEventLogTime"))
if mibBuilder.loadTexts: hcxRestartNotify.setStatus('current')
if mibBuilder.loadTexts: hcxRestartNotify.setDescription(' this trap is generated upon HCX initialization after a restart. This trap indicates to a management system that the HCX SNMP Agent, and the system generally, is ready. Only severity is WARNING.')
hcxMajorAlarmStatusLed = MibScalar((1, 3, 6, 1, 4, 1, 1141, 2, 2, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hcxMajorAlarmStatusLed.setStatus('current')
if mibBuilder.loadTexts: hcxMajorAlarmStatusLed.setDescription(' The Major Alarm Status LED is a read-only variable which describes the condition of the ComController Major Alarm Status light emitting diode located on the CC board. A value of on(1) indicates that a Major alarm exists and that the LED is illuminated. A value of off(2) indicates that no major alarm condition is detected.')
hcxMajorStatusLedChange = NotificationType((1, 3, 6, 1, 4, 1, 1141, 4, 40)).setObjects(("COM21-HCXALM-MIB", "hcxAlmSeverity"), ("COM21-HCXALM-MIB", "hcxEventLogTime"), ("COM21-HCXTOP-MIB", "hcxMajorAlarmStatusLed"))
if mibBuilder.loadTexts: hcxMajorStatusLedChange.setStatus('current')
if mibBuilder.loadTexts: hcxMajorStatusLedChange.setDescription(' generated whenever there is a change in major alarm LED status. This an event with no clear condition. Only severity is WARNING.')
hcxMinorAlarmStatusLed = MibScalar((1, 3, 6, 1, 4, 1, 1141, 2, 2, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hcxMinorAlarmStatusLed.setStatus('current')
if mibBuilder.loadTexts: hcxMinorAlarmStatusLed.setDescription(' The Minor Alarm Status LED is a read-only variable which describes the condition of the ComController Minor Alarm Status light emitting diode located on the CC board. A value of on(1) indicates that a Minor alarm exists and that the LED is illuminated. A value of off(2) indicates that no minor alarm condition is detected.')
hcxMinorStatusLedChange = NotificationType((1, 3, 6, 1, 4, 1, 1141, 4, 41)).setObjects(("COM21-HCXALM-MIB", "hcxAlmSeverity"), ("COM21-HCXALM-MIB", "hcxEventLogTime"), ("COM21-HCXTOP-MIB", "hcxMinorAlarmStatusLed"))
if mibBuilder.loadTexts: hcxMinorStatusLedChange.setStatus('current')
if mibBuilder.loadTexts: hcxMinorStatusLedChange.setDescription(' generated whenever there is a change in minor alarm LED status. This an event with no clear condition. Only severity is WARNING.')
hcxAutoLoadBalancing = MibScalar((1, 3, 6, 1, 4, 1, 1141, 2, 2, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hcxAutoLoadBalancing.setStatus('current')
if mibBuilder.loadTexts: hcxAutoLoadBalancing.setDescription(' This attribute controls whether the ComController shall perform automatic load balancing after an RX resource is added (or restored to the system). Default is on.')
hcxAutoFreqHopping = MibScalar((1, 3, 6, 1, 4, 1, 1141, 2, 2, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hcxAutoFreqHopping.setStatus('current')
if mibBuilder.loadTexts: hcxAutoFreqHopping.setDescription(' This attribute controls whether the ComController shall perform automatic frequency hopping. Note that the auto frequency hopping can also be controlled on a specific RX port basis. Turning this attribute off will override the individual ComPort configurations. Default will be on.')
hcxKeyRenewalPeriod = MibScalar((1, 3, 6, 1, 4, 1, 1141, 2, 2, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8784))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hcxKeyRenewalPeriod.setStatus('current')
if mibBuilder.loadTexts: hcxKeyRenewalPeriod.setDescription(' Contains the period at which encryption keys should be renewed. This attribute is expressed in hours. i.e. value of 48 indicates a 48hour renewal frequency. Default is 24. 0 disables renewal.')
hcxHcxSwRelease = MibScalar((1, 3, 6, 1, 4, 1, 1141, 2, 2, 16), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readonly")
if mibBuilder.loadTexts: hcxHcxSwRelease.setStatus('current')
if mibBuilder.loadTexts: hcxHcxSwRelease.setDescription(' This attribute details the current, active CC software revision. Format is a.b.c.ddd.')
hcxHcxAlternateSwRel = MibScalar((1, 3, 6, 1, 4, 1, 1141, 2, 2, 31), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hcxHcxAlternateSwRel.setStatus('current')
if mibBuilder.loadTexts: hcxHcxAlternateSwRel.setDescription(' This attribute details the alternate software revision. It is written after cold boot by the CC and later can be written by the user. If this value is written by the user - note that the release need not necessarily change - then the CC shall retrieve a new set of alternate images from the boot server. Format is a.b.c.ddd.')
hcxHcxImageControl = MibScalar((1, 3, 6, 1, 4, 1, 1141, 2, 2, 32), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hcxHcxImageControl.setStatus('current')
if mibBuilder.loadTexts: hcxHcxImageControl.setDescription(' This attribute is used to activate a given revision of software images. The CC shall automatically reboot if this field is changed by the user and the version input is valid. Format is a.b.c.ddd.')
hcxImageTransfer = MibScalar((1, 3, 6, 1, 4, 1, 1141, 2, 2, 34), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hcxImageTransfer.setStatus('current')
if mibBuilder.loadTexts: hcxImageTransfer.setDescription(' This attribute is used tell the CC to download an individual ComController software image from the boot server (NMAPS) to PCMCIA disk. Images transfered as a result of this command are not loaded to the corresponding card - to do this, the uploaded image must be made to be the primary image and the card must be rebooted. The images are specified via <image type> <revision>, where the revision is of the a.b.c.ddd format and the image type is one of the following: rx - RX card rxm - RXM card tx - TX card cc - CC card 10bt - 10bT card 100bt - 100bT card oc3 - OC3 card atm - ATM switch comp - compact HCX image stu3com - 3COM modem image(s) stu - COM21 ComPort images The CC will check the validity of the revision number against the hcxHcxSwRelease and hcxHcxAlternateSwRel values.')
hcxHcxSwDnldResult = MibScalar((1, 3, 6, 1, 4, 1, 1141, 2, 2, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("inprogress", 1), ("success", 2), ("serverNoResponse", 3), ("imageNotFound", 4), ("versionMismatch", 5), ("serverConnectionLost", 6), ("uninitiated", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hcxHcxSwDnldResult.setStatus('current')
if mibBuilder.loadTexts: hcxHcxSwDnldResult.setDescription(' This attribute contains the result of the last ComController software image download from the boot server.')
hcxHcxSwDnldComplete = NotificationType((1, 3, 6, 1, 4, 1, 1141, 4, 42)).setObjects(("COM21-HCXALM-MIB", "hcxAlmSeverity"), ("COM21-HCXALM-MIB", "hcxEventLogTime"), ("COM21-HCXTOP-MIB", "hcxHcxSwDnldResult"))
if mibBuilder.loadTexts: hcxHcxSwDnldComplete.setStatus('current')
if mibBuilder.loadTexts: hcxHcxSwDnldComplete.setDescription(' This notification is generated whenever the CC completes the ComController software image download. This an event with no clear condition. Only severity is WARNING.')
hcxCnfgBackupAction = MibScalar((1, 3, 6, 1, 4, 1, 1141, 2, 2, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("nil", 1), ("backupToSaved", 2), ("revertToSaved", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hcxCnfgBackupAction.setStatus('current')
if mibBuilder.loadTexts: hcxCnfgBackupAction.setDescription(' This attribute is provided to allow a user to trigger a backup of ComController configuration data on to the boot server. backupToSaved is used to create a user controlled backup on NMAPS. revertToSaved is used retrieve a saved database from NMAPS.')
hcxCnfgBackupComplete = NotificationType((1, 3, 6, 1, 4, 1, 1141, 4, 44)).setObjects(("COM21-HCXALM-MIB", "hcxAlmSeverity"), ("COM21-HCXALM-MIB", "hcxEventLogTime"), ("COM21-HCXTOP-MIB", "hcxCnfgBackupResult"))
if mibBuilder.loadTexts: hcxCnfgBackupComplete.setStatus('current')
if mibBuilder.loadTexts: hcxCnfgBackupComplete.setDescription(' This notification is generated whenever the CC completes the configuration data backup. This an event with no clear condition. Only severity is WARNING.')
hcxCnfgBackupResult = MibScalar((1, 3, 6, 1, 4, 1, 1141, 2, 2, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("inprogress", 1), ("success", 2), ("serverNoResponse", 3), ("writeFailed", 4), ("uninitiated", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hcxCnfgBackupResult.setStatus('current')
if mibBuilder.loadTexts: hcxCnfgBackupResult.setDescription(' This attribute contains the result of the last configuration data backup operation.')
hcxPhyConfigType = MibScalar((1, 3, 6, 1, 4, 1, 1141, 2, 2, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("singleShelf", 1), ("fullConfig", 2), ("compactShelf", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hcxPhyConfigType.setStatus('current')
if mibBuilder.loadTexts: hcxPhyConfigType.setDescription(' This attribute details the physical configuration type of the ComController.')
hcxNumOfShelves = MibScalar((1, 3, 6, 1, 4, 1, 1141, 2, 2, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hcxNumOfShelves.setStatus('current')
if mibBuilder.loadTexts: hcxNumOfShelves.setDescription(' This attribute specifies the number of shelves in the system. Presently one or two.')
hcxBootpServer = MibScalar((1, 3, 6, 1, 4, 1, 1141, 2, 2, 25), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readonly")
if mibBuilder.loadTexts: hcxBootpServer.setStatus('current')
if mibBuilder.loadTexts: hcxBootpServer.setDescription(' This attribute contains bootp server hostname.')
hcxBootpFailed = NotificationType((1, 3, 6, 1, 4, 1, 1141, 4, 45)).setObjects(("COM21-HCXALM-MIB", "hcxAlmSeverity"), ("COM21-HCXALM-MIB", "hcxEventLogTime"), ("COM21-HCXTOP-MIB", "hcxBootpResult"))
if mibBuilder.loadTexts: hcxBootpFailed.setStatus('current')
if mibBuilder.loadTexts: hcxBootpFailed.setDescription(' This notification is generated whenever the CC fails to successfully complete a bootp operation. Only severity is WARNING.')
hcxBootpResult = MibScalar((1, 3, 6, 1, 4, 1, 1141, 2, 2, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("inprogress", 1), ("success", 2), ("serverNoResponse", 3), ("serverUnknown", 4), ("imageNotFound", 5), ("versionMismatch", 6), ("serverConnectionLost", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hcxBootpResult.setStatus('current')
if mibBuilder.loadTexts: hcxBootpResult.setDescription(' This attribute contains the result of the last bootp operation.')
hcxPowerFailDetected = NotificationType((1, 3, 6, 1, 4, 1, 1141, 4, 46)).setObjects(("COM21-HCXALM-MIB", "hcxAlmSeverity"), ("COM21-HCXALM-MIB", "hcxEventLogTime"), ("COM21-HCXTOP-MIB", "hcxShelfId"))
if mibBuilder.loadTexts: hcxPowerFailDetected.setStatus('current')
if mibBuilder.loadTexts: hcxPowerFailDetected.setDescription(' This notification is generated whenever a power failure condition is detected. Default severity is MAJOR.')
hcxPowerFailClear = NotificationType((1, 3, 6, 1, 4, 1, 1141, 4, 47)).setObjects(("COM21-HCXALM-MIB", "hcxAlmSeverity"), ("COM21-HCXALM-MIB", "hcxEventLogTime"), ("COM21-HCXTOP-MIB", "hcxShelfId"))
if mibBuilder.loadTexts: hcxPowerFailClear.setStatus('current')
if mibBuilder.loadTexts: hcxPowerFailClear.setDescription(' This notification is generated whenever a power failure condition is removed. Severity is CLEARED.')
hcxFanFailDetected = NotificationType((1, 3, 6, 1, 4, 1, 1141, 4, 48)).setObjects(("COM21-HCXALM-MIB", "hcxAlmSeverity"), ("COM21-HCXALM-MIB", "hcxEventLogTime"), ("COM21-HCXTOP-MIB", "hcxShelfId"))
if mibBuilder.loadTexts: hcxFanFailDetected.setStatus('current')
if mibBuilder.loadTexts: hcxFanFailDetected.setDescription(' This notification is generated whenever a fan failure condition is detected. Default severity is MAJOR.')
hcxFanFailClear = NotificationType((1, 3, 6, 1, 4, 1, 1141, 4, 49)).setObjects(("COM21-HCXALM-MIB", "hcxAlmSeverity"), ("COM21-HCXALM-MIB", "hcxEventLogTime"), ("COM21-HCXTOP-MIB", "hcxShelfId"))
if mibBuilder.loadTexts: hcxFanFailClear.setStatus('current')
if mibBuilder.loadTexts: hcxFanFailClear.setDescription(' This notification is generated whenever a fan failure condition is removed. Severity is CLEARED.')
hcxFreqHopPause = MibScalar((1, 3, 6, 1, 4, 1, 1141, 2, 2, 28), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 300))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hcxFreqHopPause.setStatus('current')
if mibBuilder.loadTexts: hcxFreqHopPause.setDescription(' This attribute defines the number of seconds between a failed frequency hopping operation and a subsequent attempt. If a given upstream frequency is found to be in an error state, then the HCX will cycle through the configured alternates. If all these alternates are also found to be in a degraded state, then the HCX shall pause for the number of seconds defined by this attribute before attempting another hop. Default 30secs.')
hcxMaxDnstrmCBRAlloc = MibScalar((1, 3, 6, 1, 4, 1, 1141, 2, 2, 29), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hcxMaxDnstrmCBRAlloc.setStatus('current')
if mibBuilder.loadTexts: hcxMaxDnstrmCBRAlloc.setDescription(' This attribute defines the maximum percentage of downstream bandwidth that can be allocated to CBR traffic. This control mechanism will denied service to acquiring ComPorts if the addition of the configured CBR bandwidth would exceed the defined percentage. Note that this is a limit. i.e. if this attribute is set to 50%, then UP TO half the bandwidth can be CBR. It does not mean that half WILL be CBR. 100%, the default, means in effect there is no control.')
hcxMaxUpstrmCBRAlloc = MibScalar((1, 3, 6, 1, 4, 1, 1141, 2, 2, 30), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hcxMaxUpstrmCBRAlloc.setStatus('current')
if mibBuilder.loadTexts: hcxMaxUpstrmCBRAlloc.setDescription(' This attribute defines the maximum percentage of upstream bandwidth that can be allocated to CBR traffic. Default 100.')
hcxStatsControl = MibScalar((1, 3, 6, 1, 4, 1, 1141, 2, 2, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("previousCounts", 1), ("wrapCurr", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hcxStatsControl.setStatus('current')
if mibBuilder.loadTexts: hcxStatsControl.setDescription(' This attribute controls the statistics collection mechanism. If previousCounts is selected then the current stats shall be copied into the previous stats counts every 15minutes. If wrapCurr is selected, then there shall be no copying in to previous counts and the current counters shall wrap. If NMAPS is utilized then previousCounts MUST be selected. Default previousCounts.')
hcxTrapFormat = MibScalar((1, 3, 6, 1, 4, 1, 1141, 2, 2, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("snmpv1", 1), ("snmpv2", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hcxTrapFormat.setStatus('current')
if mibBuilder.loadTexts: hcxTrapFormat.setDescription(' specifies the format of the traps generated by the Common Controller. Default is snmpv1.')
hcxSyncClkConfigure = MibScalar((1, 3, 6, 1, 4, 1, 1141, 2, 2, 36), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("internalClk", 1), ("networkClk", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hcxSyncClkConfigure.setStatus('current')
if mibBuilder.loadTexts: hcxSyncClkConfigure.setDescription(' specifies the clock used for synchronization. if networkClk is selected, one of the OC3 card should be selected as the primary source. Optionally secondary source can also be selected. The behaviour is as follows: If no Oc3 card exists ClockSelect is internalClk if priOc3Card is Online ClockSelect is priNetworkClk if secOc3Card is Online and priOc3Card is Offline ClockSelect is secNetworkClk Default is internalClk.')
hcxSyncClkSelect = MibScalar((1, 3, 6, 1, 4, 1, 1141, 2, 2, 37), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("internalClk", 1), ("priNetworkClk", 2), ("secNetworkClk", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hcxSyncClkSelect.setStatus('current')
if mibBuilder.loadTexts: hcxSyncClkSelect.setDescription(' specifies the clock selected for synchronization. Default is internalClk.')
hcxSyncClkChange = NotificationType((1, 3, 6, 1, 4, 1, 1141, 4, 181)).setObjects(("COM21-HCXALM-MIB", "hcxAlmSeverity"), ("COM21-HCXALM-MIB", "hcxEventLogTime"), ("COM21-HCXTOP-MIB", "hcxSyncClkSelect"))
if mibBuilder.loadTexts: hcxSyncClkChange.setStatus('current')
if mibBuilder.loadTexts: hcxSyncClkChange.setDescription(' This notification is generated whenever there is a change in Clock used for Synchronization ')
hcxAcquisitionFreq = MibScalar((1, 3, 6, 1, 4, 1, 1141, 2, 3, 1), UpstrmFreqKhz()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hcxAcquisitionFreq.setStatus('deprecated')
if mibBuilder.loadTexts: hcxAcquisitionFreq.setDescription(' No longer supported.')
hcxAcqMinPower = MibScalar((1, 3, 6, 1, 4, 1, 1141, 2, 3, 6), StuGain()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hcxAcqMinPower.setStatus('current')
if mibBuilder.loadTexts: hcxAcqMinPower.setDescription(' Contains the minimum power setting to be used by the ComPort when hunting for upstream channel. This data is used in the INVITE_CONFIG message. Default 18.')
hcxAcqMaxPower = MibScalar((1, 3, 6, 1, 4, 1, 1141, 2, 3, 7), StuGain()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hcxAcqMaxPower.setStatus('current')
if mibBuilder.loadTexts: hcxAcqMaxPower.setDescription(' Contains the maximum power setting to be used by the ComPort when hunting for upstream channel. This data is used in the INVITE_CONFIG message. Default 58.')
hcxAcqPowerStepSize = MibScalar((1, 3, 6, 1, 4, 1, 1141, 2, 3, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hcxAcqPowerStepSize.setStatus('current')
if mibBuilder.loadTexts: hcxAcqPowerStepSize.setDescription(' Contains the power step size to be used by the ComPort when hunting for upstream channel. This data is used in the INVITE_CONFIG message. Default 1.')
hcxAltAcqFreq = MibScalar((1, 3, 6, 1, 4, 1, 1141, 2, 3, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 40000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hcxAltAcqFreq.setStatus('deprecated')
if mibBuilder.loadTexts: hcxAltAcqFreq.setDescription(' No longer supported.')
hcxActiveAcqFreq = MibScalar((1, 3, 6, 1, 4, 1, 1141, 2, 3, 10), UpstrmFreqKhz()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hcxActiveAcqFreq.setStatus('deprecated')
if mibBuilder.loadTexts: hcxActiveAcqFreq.setDescription(' No longer supported.')
hcxNoCurrAlarms = MibScalar((1, 3, 6, 1, 4, 1, 1141, 2, 4, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hcxNoCurrAlarms.setStatus('current')
if mibBuilder.loadTexts: hcxNoCurrAlarms.setDescription(' Contains the number of active ComController alarms.')
hcxEventLogSize = MibScalar((1, 3, 6, 1, 4, 1, 1141, 2, 4, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 1000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hcxEventLogSize.setStatus('current')
if mibBuilder.loadTexts: hcxEventLogSize.setDescription(' Contains the maximum number of events to be stored in the log. Default is 200. Upper limit will be controlled by the available memory. Set to 1000 for now.')
hcxNumConfiguredStus = MibScalar((1, 3, 6, 1, 4, 1, 1141, 2, 5, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hcxNumConfiguredStus.setStatus('current')
if mibBuilder.loadTexts: hcxNumConfiguredStus.setDescription(' This value contains the number of configured ComPorts for this ComController.')
hcxNumAcquiredStus = MibScalar((1, 3, 6, 1, 4, 1, 1141, 2, 5, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hcxNumAcquiredStus.setStatus('current')
if mibBuilder.loadTexts: hcxNumAcquiredStus.setDescription(' This value contains the number of acquired ComPorts for this ComController.')
hcxLastStuTopolgyChng = MibScalar((1, 3, 6, 1, 4, 1, 1141, 2, 5, 3), EpochTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hcxLastStuTopolgyChng.setStatus('current')
if mibBuilder.loadTexts: hcxLastStuTopolgyChng.setDescription(' Contains the last time (epoch) that a change occurred in the ComPort topology.')
stuTopologyChange = NotificationType((1, 3, 6, 1, 4, 1, 1141, 4, 50)).setObjects(("COM21-HCXALM-MIB", "hcxAlmSeverity"), ("COM21-HCXALM-MIB", "hcxEventLogTime"), ("COM21-HCXTOP-MIB", "hcxNumAcquiredStus"))
if mibBuilder.loadTexts: stuTopologyChange.setStatus('current')
if mibBuilder.loadTexts: stuTopologyChange.setDescription(' This trap is sent at a maximum rate of once every 5seconds or when 100 ComPort acquisition/deacquisitions have occured, which ever is first. This an event with no clear condition. Only severity is WARNING.')
hcxNumEnabledStus = MibScalar((1, 3, 6, 1, 4, 1, 1141, 2, 5, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hcxNumEnabledStus.setStatus('current')
if mibBuilder.loadTexts: hcxNumEnabledStus.setDescription(' This value contains the number of enabled and active ComPorts on this ComController. Note that we assume all ComPort support ethernet if.')
hcxStuAggrUpStrmCbrRate = MibScalar((1, 3, 6, 1, 4, 1, 1141, 2, 5, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hcxStuAggrUpStrmCbrRate.setStatus('current')
if mibBuilder.loadTexts: hcxStuAggrUpStrmCbrRate.setDescription(' This attribute defines the aggregate of all ComPort upstream CBR rates in the ComController. This includes both acquired and unacquired ComPorts. Defined in Kbps.')
hcxStuAggrUpStrmMinRate = MibScalar((1, 3, 6, 1, 4, 1, 1141, 2, 5, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hcxStuAggrUpStrmMinRate.setStatus('current')
if mibBuilder.loadTexts: hcxStuAggrUpStrmMinRate.setDescription(' This attribute defines the aggregate of all ComPort upstream minimum PCR rates in the ComController. This includes both acquired and unacquired ComPorts. Defined in Kbps.')
hcxStuAggrUpStrmMaxRate = MibScalar((1, 3, 6, 1, 4, 1, 1141, 2, 5, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hcxStuAggrUpStrmMaxRate.setStatus('current')
if mibBuilder.loadTexts: hcxStuAggrUpStrmMaxRate.setDescription(' This attribute defines the aggregate of all ComPort upstream maximum rates in the ComController. This includes both acquired and unacquired ComPorts. Defined in Kbps.')
hcxStuResourceExhausted = NotificationType((1, 3, 6, 1, 4, 1, 1141, 4, 51)).setObjects(("COM21-HCXALM-MIB", "hcxAlmSeverity"), ("COM21-HCXALM-MIB", "hcxEventLogTime"))
if mibBuilder.loadTexts: hcxStuResourceExhausted.setStatus('current')
if mibBuilder.loadTexts: hcxStuResourceExhausted.setDescription(' generated whenever an ComPort must be denied acquisition due to a lack of CC resources. This includes an exhaustion of SIDs, leck of database capacity, etc. Only severity is WARNING.')
hcxStuAltDownFreq = MibScalar((1, 3, 6, 1, 4, 1, 1141, 2, 5, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(88000, 800000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hcxStuAltDownFreq.setStatus('current')
if mibBuilder.loadTexts: hcxStuAltDownFreq.setDescription(' This attribute defines an alternate ComController downstream frequency. This attribute would be utilized if an unrecognized ComPort is acquired and the hcxStuAltDownFreqEnable is set to enable. Minimum step size is 200. i.e. 200000hz. Default is 0, indicating no alternate frequency.')
hcxStuAcqTrapEnable = MibScalar((1, 3, 6, 1, 4, 1, 1141, 2, 5, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("topoChgTrapOnly", 1), ("acqTrapOnly", 2), ("bothTopoAndAcqTrap", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hcxStuAcqTrapEnable.setStatus('current')
if mibBuilder.loadTexts: hcxStuAcqTrapEnable.setDescription(' Indicates whether the topology change trap mechanism should be used, or a trap per STU acq, or both. Note that NMAPS is dependant upon the topology change mechanism, so should be disabled only when NMAPS is not in use. Also be aware that a high number of traps will occur if the per acq trap is selected. Default is topoChgTrapOnly.')
hcxStuRpcEnable = MibScalar((1, 3, 6, 1, 4, 1, 1141, 2, 5, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hcxStuRpcEnable.setStatus('current')
if mibBuilder.loadTexts: hcxStuRpcEnable.setDescription(' Controls whether the system offers an RPC based interface for statistics and ComPort status. Default is true.')
hcxStuAutoDiscEnable = MibScalar((1, 3, 6, 1, 4, 1, 1141, 2, 5, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hcxStuAutoDiscEnable.setStatus('current')
if mibBuilder.loadTexts: hcxStuAutoDiscEnable.setDescription(' Controls whether the system performs auto discover of telephone return ComPorts. Default is true.')
hcxStuAutoDiscIpAddr = MibScalar((1, 3, 6, 1, 4, 1, 1141, 2, 5, 14), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hcxStuAutoDiscIpAddr.setStatus('current')
if mibBuilder.loadTexts: hcxStuAutoDiscIpAddr.setDescription(' The IP address of the return path interface of a PC that will enable autodiscovery of a ComPORT operating in Telephone Return mode. A PC must be present with this address on an established return path connection to allow telephone return autodiscovery to take place.')
hcxStuAutoGainAdjust = MibScalar((1, 3, 6, 1, 4, 1, 1141, 2, 5, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hcxStuAutoGainAdjust.setStatus('current')
if mibBuilder.loadTexts: hcxStuAutoGainAdjust.setDescription(' This attribute is used to control the automatic adjustment of ComPort gain after acquisition. Default is disable.')
hcxStuAltDownFreqEnable = MibScalar((1, 3, 6, 1, 4, 1, 1141, 2, 5, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hcxStuAltDownFreqEnable.setStatus('current')
if mibBuilder.loadTexts: hcxStuAltDownFreqEnable.setDescription(' This attribute is used to control the automatic setting of an alternate downstream frequency. If enabled, the hcxStuAltDownFreq shall be set in any unconfigured ComPort acquired by an HCX. Note that this feature CANNOT be enabled if hcxStuDefaultAuth is set to true or hcxStuAltDownFreq is set to 0. Default is disabled.')
hcxStuPcMacAddress = MibScalar((1, 3, 6, 1, 4, 1, 1141, 2, 5, 17), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hcxStuPcMacAddress.setStatus('current')
if mibBuilder.loadTexts: hcxStuPcMacAddress.setDescription(' This attribute is used to set the mac address of the PC. Setting this attribute starts a search for the mac address of the ComPort that is connected to this PC.')
hcxStuPcToStuMacAddressResult = MibScalar((1, 3, 6, 1, 4, 1, 1141, 2, 5, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("inprogress", 1), ("success", 2), ("failure", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hcxStuPcToStuMacAddressResult.setStatus('current')
if mibBuilder.loadTexts: hcxStuPcToStuMacAddressResult.setDescription(" This attribute contains the result of the last PC to ComPort mac address search. It changes to 'inprogress' when hcxStuPcMacAddress is set. When the search completes this attribute will display either 'success' or 'failure'.")
hcxStuOverMacAddress = MibScalar((1, 3, 6, 1, 4, 1, 1141, 2, 5, 19), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hcxStuOverMacAddress.setStatus('current')
if mibBuilder.loadTexts: hcxStuOverMacAddress.setDescription(' This attribute displays the mac address of the ComPort that is connected to the PC with mac address hcxStuPcMacAddress. The value is valid only if hcxStuPcToStuMacAddressResult displays success.')
hcxStuGlobalSwImage = MibScalar((1, 3, 6, 1, 4, 1, 1141, 2, 5, 20), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hcxStuGlobalSwImage.setStatus('current')
if mibBuilder.loadTexts: hcxStuGlobalSwImage.setDescription(' This attribute provides an easy way to change the configured software image for all configured ComPorts without having to modify hcxStuConfSwImage of individual ComPorts. When this attribute is written to by the user, the hcxStuConfSwImage attribute for all configured ComPorts will be automatically modified to reflect this value. However, this is only a one-time action. The user is free to modify the hcxStuConfSwImage attribute of individual ComPorts to other values. Since this attribute only affects configured ComPorts, it does not interfere with hcxStuDefCom21SwImage or hcxStuDef3ComSwImage from com21HcxStuDefaultGroup. Default is 0.0.0.0. Also, it will reset back to 0.0.0.0 upon a ComController reboot.')
hcxStuDefaultAuth = MibScalar((1, 3, 6, 1, 4, 1, 1141, 2, 13, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hcxStuDefaultAuth.setStatus('current')
if mibBuilder.loadTexts: hcxStuDefaultAuth.setDescription(' Indicates whether the default authorization of a previously unconfigured and unauthorized ComPort should be permitted. If true, then all other attributes in this group must be set. Note that this feature CANNOT be enabled if hcxStuAltDownFreqEnable is set to true. Default false.')
hcxStuDefaultServType = MibScalar((1, 3, 6, 1, 4, 1, 1141, 2, 13, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hcxStuDefaultServType.setStatus('current')
if mibBuilder.loadTexts: hcxStuDefaultServType.setDescription(' Contains the default QoS group for an acquired but unconfigured/unauthorized ComPort. Once configured, then the appropriate service type defined for the particular ComPort shall be used. 0 indicates no default QoS group to be used. Default 0.')
hcxStuDefaultVlan = MibScalar((1, 3, 6, 1, 4, 1, 1141, 2, 13, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hcxStuDefaultVlan.setStatus('current')
if mibBuilder.loadTexts: hcxStuDefaultVlan.setDescription(' Contains the default VLAN id for an acquired but unconfigured/unauthorized ComPort. Once configured, then the appropriate VLAN id defined for the particular ComPort shall be used. 0 indicates no default VLAN id to be used. Default 0.')
hcxStuDefCom21SwImage = MibScalar((1, 3, 6, 1, 4, 1, 1141, 2, 13, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hcxStuDefCom21SwImage.setStatus('current')
if mibBuilder.loadTexts: hcxStuDefCom21SwImage.setDescription(' Contains the default software image for an acquired but unconfigured/unauthorized ComPort. Once configured, then the appropriate software image defined for the particular ComPort shall be used. Null string indicates no default software image to be used. Default null string.')
hcxStuDef3ComSwImage = MibScalar((1, 3, 6, 1, 4, 1, 1141, 2, 13, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hcxStuDef3ComSwImage.setStatus('current')
if mibBuilder.loadTexts: hcxStuDef3ComSwImage.setDescription(' Contains the default software image for an acquired but unconfigured/unauthorized 3COM modem. Once configured, then the appropriate software image defined for the particular 3COM modem shall be used. Null string indicates no default software image to be used. Default null string.')
hcxArpServerTrapEnable = MibScalar((1, 3, 6, 1, 4, 1, 1141, 2, 12, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hcxArpServerTrapEnable.setStatus('current')
if mibBuilder.loadTexts: hcxArpServerTrapEnable.setDescription(' specifies if traps should be generated when user impersonation of ComController server IP addresses is detected. Default false.')
hcxArpUserTrapEnable = MibScalar((1, 3, 6, 1, 4, 1, 1141, 2, 12, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hcxArpUserTrapEnable.setStatus('current')
if mibBuilder.loadTexts: hcxArpUserTrapEnable.setDescription(' controls if traps should be generated when user specifies an incorrect IP address in an ARP message. Default false.')
hcxTrapReceiverTable = MibTable((1, 3, 6, 1, 4, 1, 1141, 2, 6, 1), )
if mibBuilder.loadTexts: hcxTrapReceiverTable.setStatus('current')
if mibBuilder.loadTexts: hcxTrapReceiverTable.setDescription('Table containing list of NMAPS or other management systems that are to receive traps generated by this NMM. There must be an entry for each connected NMAPS.')
hcxTrapReceiverEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1141, 2, 6, 1, 1), ).setIndexNames((0, "COM21-HCXTOP-MIB", "hcxTrapRcvrNetAddress"))
if mibBuilder.loadTexts: hcxTrapReceiverEntry.setStatus('current')
if mibBuilder.loadTexts: hcxTrapReceiverEntry.setDescription('A destination address and community string to a particular trap server, along with a trap filter and entry aging capability.')
hcxTrapRcvrStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1141, 2, 6, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2), ("delete", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hcxTrapRcvrStatus.setStatus('current')
if mibBuilder.loadTexts: hcxTrapRcvrStatus.setDescription('Setting this object to the value invalid(2) has the effect of invalidating the corresponding entry in the hcxTrapReceiverTable. That is, it effectively disassociates the address identified with the entry by removing the entry from the table. On a read the value of valid(1) should be returned if the entry contains a valid record, or invalid(2) should be returned if the entry contains an invalid record. Default is valid.')
hcxTrapRcvrNetAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 1141, 2, 6, 1, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hcxTrapRcvrNetAddress.setStatus('current')
if mibBuilder.loadTexts: hcxTrapRcvrNetAddress.setDescription('IP address for trap server that is to receive the trap.')
hcxTrapRcvrComm = MibTableColumn((1, 3, 6, 1, 4, 1, 1141, 2, 6, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hcxTrapRcvrComm.setStatus('current')
if mibBuilder.loadTexts: hcxTrapRcvrComm.setDescription('Community string used for traps sent to this trap receiver. Note that this string is writable only by the CC CUI.')
hcxTrapRcvrAgeTime = MibTableColumn((1, 3, 6, 1, 4, 1, 1141, 2, 6, 1, 1, 4), TimeTicks()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hcxTrapRcvrAgeTime.setStatus('current')
if mibBuilder.loadTexts: hcxTrapRcvrAgeTime.setDescription('This is the time interval used to age entries out of the trap receiver table. The default value if not specified will be 0, or infinite, never to be aged out. At least initially, there will be no transient management devices in the comUNITY system. Therefore this attibute will always be set to 0.')
com21HcxShelfTable = MibTable((1, 3, 6, 1, 4, 1, 1141, 2, 7, 1), )
if mibBuilder.loadTexts: com21HcxShelfTable.setStatus('current')
if mibBuilder.loadTexts: com21HcxShelfTable.setDescription('TBD.')
com21HcxShelfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1141, 2, 7, 1, 1), ).setIndexNames((0, "COM21-HCXTOP-MIB", "hcxShelfId"))
if mibBuilder.loadTexts: com21HcxShelfEntry.setStatus('current')
if mibBuilder.loadTexts: com21HcxShelfEntry.setDescription('.')
hcxShelfId = MibTableColumn((1, 3, 6, 1, 4, 1, 1141, 2, 7, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hcxShelfId.setStatus('current')
if mibBuilder.loadTexts: hcxShelfId.setDescription(' contains ComController shelf id.')
hcxShelfNoSlots = MibTableColumn((1, 3, 6, 1, 4, 1, 1141, 2, 7, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hcxShelfNoSlots.setStatus('current')
if mibBuilder.loadTexts: hcxShelfNoSlots.setDescription(' contains number of slots in this shelf.')
com21HcxSlotTable = MibTable((1, 3, 6, 1, 4, 1, 1141, 2, 8, 1), )
if mibBuilder.loadTexts: com21HcxSlotTable.setStatus('current')
if mibBuilder.loadTexts: com21HcxSlotTable.setDescription('TBD.')
com21HcxSlotEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1141, 2, 8, 1, 1), ).setIndexNames((0, "COM21-HCXTOP-MIB", "hcxShelfNo"), (0, "COM21-HCXTOP-MIB", "hcxSlotId"))
if mibBuilder.loadTexts: com21HcxSlotEntry.setStatus('current')
if mibBuilder.loadTexts: com21HcxSlotEntry.setDescription('.')
hcxShelfNo = MibTableColumn((1, 3, 6, 1, 4, 1, 1141, 2, 8, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hcxShelfNo.setStatus('current')
if mibBuilder.loadTexts: hcxShelfNo.setDescription(' contains ComController shelf id.')
hcxSlotId = MibTableColumn((1, 3, 6, 1, 4, 1, 1141, 2, 8, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 11))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hcxSlotId.setStatus('current')
if mibBuilder.loadTexts: hcxSlotId.setDescription(' contains ComController slot id.')
hcxSlotSupportedTypes = MibTableColumn((1, 3, 6, 1, 4, 1, 1141, 2, 8, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("rx", 1), ("tx", 2), ("cc", 3), ("com21Exp", 4), ("txDig", 5), ("intConn", 6), ("rxIntConn", 7), ("noCard", 8), ("rxCom21Exp", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hcxSlotSupportedTypes.setStatus('current')
if mibBuilder.loadTexts: hcxSlotSupportedTypes.setDescription(' contains card types supported for this slot. com21Exp specifies 10baseT or 100baseT or oc3. intConn is the interconnect card used on the expansion shelf (Shelf2). rxIntConn is used to indicate a slot that can be used for an RX, 100bT or 10bT card in the single shelf configuration or for the interconnect card when an expansion shelf is present. rx indicates either RX or RXM cards. On the expansion shelf there is support of up to 8 rx cards. rxCom21Exp defines RX, oc3, 10bT or 100bT card for slots 3 and 4. For all other slots it defines Rx, 10bT or 100bT cards (This implies that oc3 card is supported only in slots 2,3 and 4). Note that there is a maximum of 5x10bT/100bT and 12xRX in the system. maximum number of oc3 cards supported is 2 Release 2.3 software shall support the following slot designations. if hcxPhyConfigType = singleShelf: Shelf 1 Slot 1 - cc Slot 2 - com21Exp Slot 3 - rxCom21Exp Slot 4 - rxCom21Exp Slot 5 - rxIntConn Slot 6 - rxCom21Exp Slot 7 - rxCom21Exp Slot 8 - rx Slot 9 - rx Slot 10 - txDig Slot 11 - tx if hcxPhyConfigType = fullShelf: Shelf 1 Shelf2 Slot 1 - cc Slot 1 - intConn Slot 2 - com21Exp Slot 2 - rx Slot 3 - rxCom21Exp Slot 3 - rx Slot 4 - rxCom21Exp Slot 4 - rx Slot 5 - rxIntConn Slot 5 - rx Slot 6 - rxCom21Exp Slot 6 - rx Slot 7 - rxCom21Exp Slot 7 - rx Slot 8 - rx Slot 8 - rx Slot 9 - rx Slot 9 - rx Slot 10 - txDig Slot 10 - noCard Slot 11 - tx Slot 11 - noCard if hcxPhyConfigType = compactShelf: Shelf 1 Slot 1 - cc Slot 2 - com21Exp Slot 3 - rxCom21Exp Slot 4 - rx Slot 5 - txDig Slot 6 - tx')
hcxSlotConfigCardType = MibTableColumn((1, 3, 6, 1, 4, 1, 1141, 2, 8, 1, 1, 4), HcxCardType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hcxSlotConfigCardType.setStatus('current')
if mibBuilder.loadTexts: hcxSlotConfigCardType.setDescription(' contains card type configured for this slot. This attribute will be checked against the set of supported card types and rejected if not present. Note that the cardtype of ethDual10bT can be used to specify either the 4k or 8k CAM versions of the 10bT card. Note that a 10bT or 100bT or oc3 card CANNOT be unconfigured if an STU on an associated VLAN is acquired.')
hcxSlotInsertCardType = MibTableColumn((1, 3, 6, 1, 4, 1, 1141, 2, 8, 1, 1, 5), HcxCardType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hcxSlotInsertCardType.setStatus('current')
if mibBuilder.loadTexts: hcxSlotInsertCardType.setDescription(' contains card type inserted in the ComController slot. A value of empty shall be stored if there is no card.')
hcxInsertChange = NotificationType((1, 3, 6, 1, 4, 1, 1141, 4, 52)).setObjects(("COM21-HCXALM-MIB", "hcxAlmSeverity"), ("COM21-HCXALM-MIB", "hcxEventLogTime"), ("COM21-HCXTOP-MIB", "hcxSlotInsertCardType"), ("COM21-HCXTOP-MIB", "hcxShelfNo"), ("COM21-HCXTOP-MIB", "hcxSlotId"))
if mibBuilder.loadTexts: hcxInsertChange.setStatus('current')
if mibBuilder.loadTexts: hcxInsertChange.setDescription(' generated whenever a card is inserted for the first time, or during restart of the ComController. Only severity is WARNING.')
hcxCardRemoved = NotificationType((1, 3, 6, 1, 4, 1, 1141, 4, 120)).setObjects(("COM21-HCXALM-MIB", "hcxAlmSeverity"), ("COM21-HCXALM-MIB", "hcxEventLogTime"), ("COM21-HCXTOP-MIB", "hcxShelfNo"), ("COM21-HCXTOP-MIB", "hcxSlotId"))
if mibBuilder.loadTexts: hcxCardRemoved.setStatus('current')
if mibBuilder.loadTexts: hcxCardRemoved.setDescription(' generated whenever an inserted and correctly configured card is removed. Default severity is MAJOR.')
hcxCardRemClear = NotificationType((1, 3, 6, 1, 4, 1, 1141, 4, 121)).setObjects(("COM21-HCXALM-MIB", "hcxAlmSeverity"), ("COM21-HCXALM-MIB", "hcxEventLogTime"), ("COM21-HCXTOP-MIB", "hcxShelfNo"), ("COM21-HCXTOP-MIB", "hcxSlotId"))
if mibBuilder.loadTexts: hcxCardRemClear.setStatus('current')
if mibBuilder.loadTexts: hcxCardRemClear.setDescription(' generated whenever a card is reinserted in a slot or when a slot is configured to empty or when a slot is reassigned, and that slot has a previously generated hcxCardRemoved trap. If the inserted card is of the incorrect type, then a subsequent hcxMismatchDetect trap will be generated. Severity is CLEARED.')
hcxMismatchDetect = NotificationType((1, 3, 6, 1, 4, 1, 1141, 4, 53)).setObjects(("COM21-HCXALM-MIB", "hcxAlmSeverity"), ("COM21-HCXALM-MIB", "hcxEventLogTime"), ("COM21-HCXTOP-MIB", "hcxSlotInsertCardType"), ("COM21-HCXTOP-MIB", "hcxShelfNo"), ("COM21-HCXTOP-MIB", "hcxSlotId"))
if mibBuilder.loadTexts: hcxMismatchDetect.setStatus('current')
if mibBuilder.loadTexts: hcxMismatchDetect.setDescription(' generated when the inserted card does not match the configured card type. Default severity is MAJOR.')
hcxMismatchClear = NotificationType((1, 3, 6, 1, 4, 1, 1141, 4, 54)).setObjects(("COM21-HCXALM-MIB", "hcxAlmSeverity"), ("COM21-HCXALM-MIB", "hcxEventLogTime"), ("COM21-HCXTOP-MIB", "hcxSlotInsertCardType"), ("COM21-HCXTOP-MIB", "hcxShelfNo"), ("COM21-HCXTOP-MIB", "hcxSlotId"))
if mibBuilder.loadTexts: hcxMismatchClear.setStatus('current')
if mibBuilder.loadTexts: hcxMismatchClear.setDescription(' this mismatch clear is submitted when an incorrect card is removed from a slot. Severity is CLEARED.')
hcxCardNoRespond = NotificationType((1, 3, 6, 1, 4, 1, 1141, 4, 55)).setObjects(("COM21-HCXALM-MIB", "hcxAlmSeverity"), ("COM21-HCXALM-MIB", "hcxEventLogTime"), ("COM21-HCXTOP-MIB", "hcxSlotInsertCardType"), ("COM21-HCXTOP-MIB", "hcxShelfNo"), ("COM21-HCXTOP-MIB", "hcxSlotId"))
if mibBuilder.loadTexts: hcxCardNoRespond.setStatus('current')
if mibBuilder.loadTexts: hcxCardNoRespond.setDescription(' generated when an inserted card fails to respond to a CC generated message. This an event with no clear condition. Only severity is WARNING.')
hcxCardPollFail = NotificationType((1, 3, 6, 1, 4, 1, 1141, 4, 56)).setObjects(("COM21-HCXALM-MIB", "hcxAlmSeverity"), ("COM21-HCXALM-MIB", "hcxEventLogTime"), ("COM21-HCXTOP-MIB", "hcxSlotInsertCardType"), ("COM21-HCXTOP-MIB", "hcxShelfNo"), ("COM21-HCXTOP-MIB", "hcxSlotId"))
if mibBuilder.loadTexts: hcxCardPollFail.setStatus('current')
if mibBuilder.loadTexts: hcxCardPollFail.setDescription(' generated when an inserted card fails to respond to a CC polling. Default severity is MAJOR.')
hcxCardPollFailClear = NotificationType((1, 3, 6, 1, 4, 1, 1141, 4, 57)).setObjects(("COM21-HCXALM-MIB", "hcxAlmSeverity"), ("COM21-HCXALM-MIB", "hcxEventLogTime"), ("COM21-HCXTOP-MIB", "hcxSlotInsertCardType"), ("COM21-HCXTOP-MIB", "hcxShelfNo"), ("COM21-HCXTOP-MIB", "hcxSlotId"))
if mibBuilder.loadTexts: hcxCardPollFailClear.setStatus('current')
if mibBuilder.loadTexts: hcxCardPollFailClear.setDescription(' generated when a card successfully responses to CC polling after a previous failure. Only severity is CLEARED.')
hcxCardDnldFailNoImage = NotificationType((1, 3, 6, 1, 4, 1, 1141, 4, 58)).setObjects(("COM21-HCXALM-MIB", "hcxAlmSeverity"), ("COM21-HCXALM-MIB", "hcxEventLogTime"), ("COM21-HCXTOP-MIB", "hcxSlotInsertCardType"), ("COM21-HCXTOP-MIB", "hcxShelfNo"), ("COM21-HCXTOP-MIB", "hcxSlotId"))
if mibBuilder.loadTexts: hcxCardDnldFailNoImage.setStatus('current')
if mibBuilder.loadTexts: hcxCardDnldFailNoImage.setDescription(' generated when a card cannot be download due to a lack of the correct image. Only severity is WARNING.')
com21HcxImageListTable = MibTable((1, 3, 6, 1, 4, 1, 1141, 2, 9, 1), )
if mibBuilder.loadTexts: com21HcxImageListTable.setStatus('current')
if mibBuilder.loadTexts: com21HcxImageListTable.setDescription('table of all ComController and ComPort images loaded on the CC.')
com21HcxImageListEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1141, 2, 9, 1, 1), ).setIndexNames((0, "COM21-HCXTOP-MIB", "hcxImageId"))
if mibBuilder.loadTexts: com21HcxImageListEntry.setStatus('current')
if mibBuilder.loadTexts: com21HcxImageListEntry.setDescription('.')
hcxImageId = MibTableColumn((1, 3, 6, 1, 4, 1, 1141, 2, 9, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hcxImageId.setStatus('current')
if mibBuilder.loadTexts: hcxImageId.setDescription(' contains image list reference.')
hcxImageType = MibTableColumn((1, 3, 6, 1, 4, 1, 1141, 2, 9, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("hcxCC", 1), ("hcxTx", 2), ("hcxRx", 3), ("hcxEth10baseT", 4), ("hcxEth100baseT", 5), ("hcxTele", 6), ("stu", 7), ("stu3com", 8), ("hcxRxm", 9), ("atmlSwitch", 10), ("compCfg", 11), ("compSwitch", 12), ("hcxOc3", 13)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hcxImageType.setStatus('current')
if mibBuilder.loadTexts: hcxImageType.setDescription(' contains image type.')
hcxImageState = MibTableColumn((1, 3, 6, 1, 4, 1, 1141, 2, 9, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("alternate", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hcxImageState.setStatus('current')
if mibBuilder.loadTexts: hcxImageState.setDescription(' this attribute specifies the state of an image. An image is either part of the active set of ComController and ComPort images, or is a part of the alternate set.')
hcxImageFilename = MibTableColumn((1, 3, 6, 1, 4, 1, 1141, 2, 9, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(64, 64)).setFixedLength(64)).setMaxAccess("readonly")
if mibBuilder.loadTexts: hcxImageFilename.setStatus('current')
if mibBuilder.loadTexts: hcxImageFilename.setDescription(' contains image filename. This shall be used to retrieve the image from the boot server.')
hcxSwRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 1141, 2, 9, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readonly")
if mibBuilder.loadTexts: hcxSwRevision.setStatus('current')
if mibBuilder.loadTexts: hcxSwRevision.setDescription(' contains image software revision.')
hcxHwRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 1141, 2, 9, 1, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readonly")
if mibBuilder.loadTexts: hcxHwRevision.setStatus('current')
if mibBuilder.loadTexts: hcxHwRevision.setDescription(' contains hardware revision supported by this image. Note that in the future, we may define a range of hardware revisions supported.')
hcxFwRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 1141, 2, 9, 1, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readonly")
if mibBuilder.loadTexts: hcxFwRevision.setStatus('current')
if mibBuilder.loadTexts: hcxFwRevision.setDescription(' contains firmware boot revision supported by this image. Note that in the future, we may define a range of hardware revisions supported.')
hcxDbAction = MibScalar((1, 3, 6, 1, 4, 1, 1141, 2, 14, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("nil", 1), ("saveDb", 2), ("deleteSavedDb", 3), ("deletePeriodicDb", 4), ("revertToPeriodicDb", 5), ("revertToSavedDb", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hcxDbAction.setStatus('current')
if mibBuilder.loadTexts: hcxDbAction.setDescription(' This attribute is used to control various database actions. saveDb causes the present active database to be saved to disk. This will overwrite any previously saved database. revertToPeriodicDb causes the periodically saved database to become the active database. revertToSavedDb causes the user saved database to become the active database. deleteSavedDb and deletePeriodicDb simply delete the current saved and periodic database respectively. In the case of these last two options, the CC shall reboot.')
hcxDbActionResult = MibScalar((1, 3, 6, 1, 4, 1, 1141, 2, 14, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("inprogress", 1), ("success", 2), ("diskFailure", 3), ("noDatabaseFound", 4), ("invalidDatabase", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hcxDbActionResult.setStatus('current')
if mibBuilder.loadTexts: hcxDbActionResult.setDescription(' This attribute contains the result of the last hcxDbAction.')
hcxDbActionComplete = NotificationType((1, 3, 6, 1, 4, 1, 1141, 4, 19)).setObjects(("COM21-HCXALM-MIB", "hcxAlmSeverity"), ("COM21-HCXALM-MIB", "hcxEventLogTime"), ("COM21-HCXTOP-MIB", "hcxDbActionResult"))
if mibBuilder.loadTexts: hcxDbActionComplete.setStatus('current')
if mibBuilder.loadTexts: hcxDbActionComplete.setDescription(' this notification is generated whenever the CC completes the database action. This an event with no clear condition. Only severity is WARNING.')
hcxDbBackupPeriod = MibScalar((1, 3, 6, 1, 4, 1, 1141, 2, 14, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 24))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hcxDbBackupPeriod.setStatus('current')
if mibBuilder.loadTexts: hcxDbBackupPeriod.setDescription(' the period, in hours, at which the database will be automatically saved on the disk. 0 will disable the auto backup. Default 24.')
com21HcxServTypeTable = MibTable((1, 3, 6, 1, 4, 1, 1141, 2, 10, 1), )
if mibBuilder.loadTexts: com21HcxServTypeTable.setStatus('current')
if mibBuilder.loadTexts: com21HcxServTypeTable.setDescription('TBD.')
com21HcxServTypeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1141, 2, 10, 1, 1), ).setIndexNames((0, "COM21-HCXTOP-MIB", "hcxServiceTypeId"))
if mibBuilder.loadTexts: com21HcxServTypeEntry.setStatus('current')
if mibBuilder.loadTexts: com21HcxServTypeEntry.setDescription('.')
hcxServiceTypeId = MibTableColumn((1, 3, 6, 1, 4, 1, 1141, 2, 10, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hcxServiceTypeId.setStatus('current')
if mibBuilder.loadTexts: hcxServiceTypeId.setDescription(' contains service type id.')
hcxServTypeDesc = MibTableColumn((1, 3, 6, 1, 4, 1, 1141, 2, 10, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hcxServTypeDesc.setStatus('current')
if mibBuilder.loadTexts: hcxServTypeDesc.setDescription(' contains service type description string. This string must be unique.')
hcxDnStrmType = MibTableColumn((1, 3, 6, 1, 4, 1, 1141, 2, 10, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("cbr", 1), ("ondemand", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hcxDnStrmType.setStatus('current')
if mibBuilder.loadTexts: hcxDnStrmType.setDescription(' defines CBR or ondemand (UBR) traffic in the downstream direction. Default is ondemand.')
hcxDnStrmRate = MibTableColumn((1, 3, 6, 1, 4, 1, 1141, 2, 10, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 11560000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hcxDnStrmRate.setStatus('current')
if mibBuilder.loadTexts: hcxDnStrmRate.setDescription(' peak bits per second in the downstream direction. Policing/shaping of this attribute is the responsibility of the appropriate Ethernet card. Setting this value to 0 will have the effect of stopping downstream traffic.')
hcxUpStrmType = MibTableColumn((1, 3, 6, 1, 4, 1, 1141, 2, 10, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("cbr", 1), ("ondemand", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hcxUpStrmType.setStatus('current')
if mibBuilder.loadTexts: hcxUpStrmType.setDescription(' defines CBR or ondemand in the upstream direction. This attribute controls the type of minimum cell traffic. Default is ondemand.')
hcxUpStrmMinRate = MibTableColumn((1, 3, 6, 1, 4, 1, 1141, 2, 10, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1650000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hcxUpStrmMinRate.setStatus('current')
if mibBuilder.loadTexts: hcxUpStrmMinRate.setDescription(' bits per second in the upstream direction. Policing/shaping of this attribute is the responsibility of the appropriate RX card.')
hcxUpStrmMaxRate = MibTableColumn((1, 3, 6, 1, 4, 1, 1141, 2, 10, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1650000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hcxUpStrmMaxRate.setStatus('current')
if mibBuilder.loadTexts: hcxUpStrmMaxRate.setDescription(' peak bits per second in the upstream direction. This is a best-effort rate. Policing/shaping of this attribute is the responsibility of the appropriate RX card.')
hcxServTypeDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 1141, 2, 10, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("nil", 1), ("execute", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hcxServTypeDelete.setStatus('current')
if mibBuilder.loadTexts: hcxServTypeDelete.setDescription(' The ComController Service Type Delete is an active-value. The setting of this value to execute(2) causes the multicast list entry to be deleted.')
hcxFileTransProt = MibScalar((1, 3, 6, 1, 4, 1, 1141, 2, 18, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ftp", 1), ("tftp", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hcxFileTransProt.setStatus('current')
if mibBuilder.loadTexts: hcxFileTransProt.setDescription(' specifies the type of protocol used for file transfer. i.e. for config_db and images. This information is stored in NVRAM. Note that a upon boot, if there is no valid CC image, an TFTP will be attempted regardless of the setting of this attribute. Default is ftp.')
hcxFileServerCntrl = MibScalar((1, 3, 6, 1, 4, 1, 1141, 2, 18, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("bootp", 1), ("mibSpecified", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hcxFileServerCntrl.setStatus('current')
if mibBuilder.loadTexts: hcxFileServerCntrl.setDescription(' specifies how the file server address is obtained. This parameter is controlled by CC Boot shell line. Can elect to use bootp or allow the operator to explicitly specify. Note that if this attribute is set to mibSpecified then no bootp should be generated by the boot or runtime code. This information is stored in NVRAM. Default is bootp.')
hcxImageServerIpAddr = MibScalar((1, 3, 6, 1, 4, 1, 1141, 2, 18, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hcxImageServerIpAddr.setStatus('current')
if mibBuilder.loadTexts: hcxImageServerIpAddr.setDescription(' IP address of the image file server. This attribute is writeable only if hcxFileServerCntrl is set to mibSpecified. Otherwise it is a read-only attribute detailing the IP address returned by bootp. This attribute is held in NVRAM. Default is 0.0.0.0.')
hcxImageServerPath = MibScalar((1, 3, 6, 1, 4, 1, 1141, 2, 18, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hcxImageServerPath.setStatus('current')
if mibBuilder.loadTexts: hcxImageServerPath.setDescription(' specifies path to the image files. This attribute is writeable only if hcxFileServerCntrl is set to mibSpecified. Otherwise it is a read-only attribute detailing the path returned by bootp. This attribute is held in NVRAM. Default is null string.')
hcxImageServerLogin = MibScalar((1, 3, 6, 1, 4, 1, 1141, 2, 18, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hcxImageServerLogin.setStatus('current')
if mibBuilder.loadTexts: hcxImageServerLogin.setDescription(' specifies a login to the image server. This attribute is only applicable if hcxFileServerCntrl is set to mibSpecified and hcxFileTransProt is set to ftp. This attribute is held in NVRAM. Default is ftp.')
hcxImageServerPassword = MibScalar((1, 3, 6, 1, 4, 1, 1141, 2, 18, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hcxImageServerPassword.setStatus('current')
if mibBuilder.loadTexts: hcxImageServerPassword.setDescription(' specifies a password to the image server. This attribute is only applicable if hcxFileServerCntrl is set to mibSpecified and hcxFileTransProt is set to ftp. This attribute is held in NVRAM. Default is anonymous.')
hcxDatabaseServerIpAddr = MibScalar((1, 3, 6, 1, 4, 1, 1141, 2, 18, 7), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hcxDatabaseServerIpAddr.setStatus('current')
if mibBuilder.loadTexts: hcxDatabaseServerIpAddr.setDescription(' IP address of the server on which to save and retrieve the config database. This attribute is only applicable if hcxFileServerCntrl is set to mibSpecified. Default is 0.0.0.0.')
hcxDatabaseServerPath = MibScalar((1, 3, 6, 1, 4, 1, 1141, 2, 18, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hcxDatabaseServerPath.setStatus('current')
if mibBuilder.loadTexts: hcxDatabaseServerPath.setDescription(' specifies path and the name of the config database file. This attribute is only applicable if hcxFileServerCntrl is set to mibSpecified. Default is null string.')
hcxDatabaseServerLogin = MibScalar((1, 3, 6, 1, 4, 1, 1141, 2, 18, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hcxDatabaseServerLogin.setStatus('current')
if mibBuilder.loadTexts: hcxDatabaseServerLogin.setDescription(' specifies a login to the Database server. This attribute is only applicable if hcxFileServerCntrl is set to mibSpecified and hcxFileTransProt is set to ftp. Default is ftp.')
hcxDatabaseServerPassword = MibScalar((1, 3, 6, 1, 4, 1, 1141, 2, 18, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hcxDatabaseServerPassword.setStatus('current')
if mibBuilder.loadTexts: hcxDatabaseServerPassword.setDescription(' specifies a password to the Database server. This attribute is only applicable if hcxFileServerCntrl is set to mibSpecified and hcxFileTransProt is set to ftp. Default is anonymous.')
mibBuilder.exportSymbols("COM21-HCXTOP-MIB", hcxSyncClkConfigure=hcxSyncClkConfigure, hcxImageId=hcxImageId, hcxPowerFailClear=hcxPowerFailClear, hcxTrapReceiverEntry=hcxTrapReceiverEntry, hcxTrapRcvrAgeTime=hcxTrapRcvrAgeTime, hcxMaxDnstrmCBRAlloc=hcxMaxDnstrmCBRAlloc, hcxDnStrmType=hcxDnStrmType, hcxAcqMinPower=hcxAcqMinPower, EpochTime=EpochTime, com21HcxArpFiltTrapGroup=com21HcxArpFiltTrapGroup, hcxTrapRcvrComm=hcxTrapRcvrComm, hcxDnStrmRate=hcxDnStrmRate, hcxDbActionResult=hcxDbActionResult, hcxStuAggrUpStrmMaxRate=hcxStuAggrUpStrmMaxRate, hcxDatabaseServerPath=hcxDatabaseServerPath, stuTopologyChange=stuTopologyChange, hcxHcxSwDnldComplete=hcxHcxSwDnldComplete, com21HcxSlotTable=com21HcxSlotTable, hcxServTypeDesc=hcxServTypeDesc, hcxBootpResult=hcxBootpResult, hcxImageServerPath=hcxImageServerPath, hcxTrapReceiverTable=hcxTrapReceiverTable, com21HcxSlotEntry=com21HcxSlotEntry, com21HcxServTypeGroup=com21HcxServTypeGroup, com21HcxCtrl=com21HcxCtrl, hcxHcxSwDnldResult=hcxHcxSwDnldResult, hcxTrapRcvrStatus=hcxTrapRcvrStatus, hcxGatewayAddress=hcxGatewayAddress, com21HcxPhase30=com21HcxPhase30, hcxUpStrmMaxRate=hcxUpStrmMaxRate, hcxShelfNo=hcxShelfNo, hcxStuDef3ComSwImage=hcxStuDef3ComSwImage, hcxSlotInsertCardType=hcxSlotInsertCardType, hcxImageServerIpAddr=hcxImageServerIpAddr, com21HcxAlmOverGroup=com21HcxAlmOverGroup, hcxTrapRcvrNetAddress=hcxTrapRcvrNetAddress, hcxStuDefaultServType=hcxStuDefaultServType, hcxCardPollFailClear=hcxCardPollFailClear, hcxPhyConfigType=hcxPhyConfigType, PYSNMP_MODULE_ID=com21HcxCtrl, hcxKeyRenewalPeriod=hcxKeyRenewalPeriod, hcxDatabaseServerIpAddr=hcxDatabaseServerIpAddr, hcxNumOfShelves=hcxNumOfShelves, hcxCardDnldFailNoImage=hcxCardDnldFailNoImage, hcxMinorAlarmStatusLed=hcxMinorAlarmStatusLed, hcxSwRevision=hcxSwRevision, hcxStuAcqTrapEnable=hcxStuAcqTrapEnable, com21HcxImageListTable=com21HcxImageListTable, hcxUpStrmMinRate=hcxUpStrmMinRate, com21HcxStuOverGroup=com21HcxStuOverGroup, hcxNumAcquiredStus=hcxNumAcquiredStus, hcxMajorStatusLedChange=hcxMajorStatusLedChange, hcxStuAltDownFreqEnable=hcxStuAltDownFreqEnable, hcxAcquisitionFreq=hcxAcquisitionFreq, hcxShelfId=hcxShelfId, com21HcxImageListGroup=com21HcxImageListGroup, com21HcxServTypeTable=com21HcxServTypeTable, com21HcxTrapRcvrGroup=com21HcxTrapRcvrGroup, PrimServiceState=PrimServiceState, hcxMacAddress=hcxMacAddress, hcxImageServerLogin=hcxImageServerLogin, hcxStuResourceExhausted=hcxStuResourceExhausted, hcxFanFailDetected=hcxFanFailDetected, hcxStuDefCom21SwImage=hcxStuDefCom21SwImage, hcxIpMask=hcxIpMask, hcxShelfNoSlots=hcxShelfNoSlots, hcxImageServerPassword=hcxImageServerPassword, com21HcxShelfGroup=com21HcxShelfGroup, HcxCardType=HcxCardType, com21HcxCompact=com21HcxCompact, hcxAcqMaxPower=hcxAcqMaxPower, hcxStuGlobalSwImage=hcxStuGlobalSwImage, hcxBootpFailed=hcxBootpFailed, hcxBootpServer=hcxBootpServer, hcxStuDefaultVlan=hcxStuDefaultVlan, hcxAcqPowerStepSize=hcxAcqPowerStepSize, hcxStuAggrUpStrmMinRate=hcxStuAggrUpStrmMinRate, hcxSlotConfigCardType=hcxSlotConfigCardType, hcxMajorAlarmStatusLed=hcxMajorAlarmStatusLed, com21HcxAcqCnfgGroup=com21HcxAcqCnfgGroup, com21HcxSlotGroup=com21HcxSlotGroup, hcxFileTransProt=hcxFileTransProt, hcxStuOverMacAddress=hcxStuOverMacAddress, hcxRestartAction=hcxRestartAction, hcxMismatchDetect=hcxMismatchDetect, hcxStuAutoDiscIpAddr=hcxStuAutoDiscIpAddr, hcxUserText=hcxUserText, hcxCardRemClear=hcxCardRemClear, hcxInsertChange=hcxInsertChange, hcxEventLogSize=hcxEventLogSize, hcxDbAction=hcxDbAction, hcxStuAutoDiscEnable=hcxStuAutoDiscEnable, hcxRestartNotify=hcxRestartNotify, hcxNumConfiguredStus=hcxNumConfiguredStus, hcxDatabaseServerPassword=hcxDatabaseServerPassword, hcxCnfgBackupAction=hcxCnfgBackupAction, com21HcxDbControlGroup=com21HcxDbControlGroup, com21HcxServTypeEntry=com21HcxServTypeEntry, hcxStuPcToStuMacAddressResult=hcxStuPcToStuMacAddressResult, hcxFileServerCntrl=hcxFileServerCntrl, hcxStuAggrUpStrmCbrRate=hcxStuAggrUpStrmCbrRate, hcxPartNumber=hcxPartNumber, hcxMismatchClear=hcxMismatchClear, hcxImageType=hcxImageType, hcxSlotId=hcxSlotId, hcxTrapFormat=hcxTrapFormat, hcxSlotSupportedTypes=hcxSlotSupportedTypes, hcxNumEnabledStus=hcxNumEnabledStus, StuGain=StuGain, hcxDbBackupPeriod=hcxDbBackupPeriod, hcxActiveAcqFreq=hcxActiveAcqFreq, hcxFwRevision=hcxFwRevision, hcxUpStrmType=hcxUpStrmType, hcxEncryptionEnable=hcxEncryptionEnable, hcxAutoFreqHopping=hcxAutoFreqHopping, hcxIpAddress=hcxIpAddress, hcxSerialNumber=hcxSerialNumber, hcxMaxUpstrmCBRAlloc=hcxMaxUpstrmCBRAlloc, hcxStuDefaultAuth=hcxStuDefaultAuth, hcxMinorStatusLedChange=hcxMinorStatusLedChange, com21HcxImageListEntry=com21HcxImageListEntry, hcxHwRevision=hcxHwRevision, hcxHcxSwRelease=hcxHcxSwRelease, hcxServTypeDelete=hcxServTypeDelete, hcxAutoLoadBalancing=hcxAutoLoadBalancing, hcxDatabaseServerLogin=hcxDatabaseServerLogin, hcxPowerFailDetected=hcxPowerFailDetected, hcxSyncClkChange=hcxSyncClkChange, hcxCnfgBackupResult=hcxCnfgBackupResult, com21HcxShelfEntry=com21HcxShelfEntry, hcxStuPcMacAddress=hcxStuPcMacAddress, hcxServiceTypeId=hcxServiceTypeId, hcxNoCurrAlarms=hcxNoCurrAlarms, hcxArpUserTrapEnable=hcxArpUserTrapEnable, com21HcxShelfTable=com21HcxShelfTable, hcxFanFailClear=hcxFanFailClear, UpstrmFreqKhz=UpstrmFreqKhz, hcxAltAcqFreq=hcxAltAcqFreq, hcxImageFilename=hcxImageFilename, hcxStuAltDownFreq=hcxStuAltDownFreq, hcxHcxAlternateSwRel=hcxHcxAlternateSwRel, com21HcxControlGroup=com21HcxControlGroup, hcxLastStuTopolgyChng=hcxLastStuTopolgyChng, hcxFreqHopPause=hcxFreqHopPause, hcxCnfgBackupComplete=hcxCnfgBackupComplete, hcxArpServerTrapEnable=hcxArpServerTrapEnable, hcxEpochTime=hcxEpochTime, hcxStuRpcEnable=hcxStuRpcEnable, Com21RowStatus=Com21RowStatus, hcxSyncClkSelect=hcxSyncClkSelect, com21HcxBootControlGroup=com21HcxBootControlGroup, hcxImageState=hcxImageState, com21HcxStuDefaultGroup=com21HcxStuDefaultGroup, hcxCardPollFail=hcxCardPollFail, hcxDbActionComplete=hcxDbActionComplete, hcxStuAutoGainAdjust=hcxStuAutoGainAdjust, hcxCardNoRespond=hcxCardNoRespond, hcxStatsControl=hcxStatsControl, hcxCardRemoved=hcxCardRemoved, hcxHcxImageControl=hcxHcxImageControl, hcxImageTransfer=hcxImageTransfer)

#
# PySNMP MIB module BIANCA-BRICK-ATM2-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/BIANCA-BRICK-ATM2-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:37:59 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ValueRangeConstraint, ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint")
DisplayString, = mibBuilder.importSymbols("RFC1158-MIB", "DisplayString")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
iso, Unsigned32, Counter64, MibScalar, MibTable, MibTableRow, MibTableColumn, enterprises, Bits, MibIdentifier, ModuleIdentity, ObjectIdentity, IpAddress, Counter32, Integer32, Gauge32, TimeTicks, NotificationType = mibBuilder.importSymbols("SNMPv2-SMI", "iso", "Unsigned32", "Counter64", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "enterprises", "Bits", "MibIdentifier", "ModuleIdentity", "ObjectIdentity", "IpAddress", "Counter32", "Integer32", "Gauge32", "TimeTicks", "NotificationType")
PhysAddress, DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "PhysAddress", "DisplayString", "TextualConvention")
bintec = MibIdentifier((1, 3, 6, 1, 4, 1, 272))
bibo = MibIdentifier((1, 3, 6, 1, 4, 1, 272, 4))
atm = MibIdentifier((1, 3, 6, 1, 4, 1, 272, 4, 16))
atmIfTable = MibTable((1, 3, 6, 1, 4, 1, 272, 4, 16, 10), )
if mibBuilder.loadTexts: atmIfTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfTable.setDescription('The atmIfTable displays all available ATM capable interfaces.')
atmIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 272, 4, 16, 10, 1), ).setIndexNames((0, "BIANCA-BRICK-ATM2-MIB", "atmIfIndex"))
if mibBuilder.loadTexts: atmIfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfEntry.setDescription('An interface entry containing objects at the subnetwork layer and below for a particular interface.')
atmIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 10, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfIndex.setDescription('The interface index of the associated ATM hardware.')
atmIfType = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("adsl", 2), ("shdsl", 3), ("vdsl", 4))).clone('other')).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfType.setDescription('This object contains an interface type.')
atmIfDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 10, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfDescr.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfDescr.setDescription('Short description for this object.')
atmIfAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfAdminStatus.setDescription('This object contains the desired state of the ATM interface.')
atmIfOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 10, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2))).clone('down')).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfOperStatus.setDescription('The current operational state of the ATM interface.')
atmIfLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 10, 1, 6), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfLastChange.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfLastChange.setDescription('The value of sysUpTime at the time the interface entered its current operational state. If the current state was entered prior to the last re-initialization of the local network management subsystem, then this object contains a zero value.')
atmIfMaxTxRate = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 10, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfMaxTxRate.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfMaxTxRate.setDescription('This object enables traffic shaping on the related ATM interface. If set to zero (0) there is no shaping active. Otherwise this variable defines the maximum amount of bits per second to be transmitted. Note that the maximum transmit rate is also determined by the capabilities of the ATM hardware.')
atmIfOperMode = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 10, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("atm", 1), ("efm", 2))).clone('atm')).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfOperMode.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfOperMode.setDescription('The current operational mode of the ATM interface. The value atm(1) means ATM is used on the line. The value efm(2) means ATM is used only internally and Ethernet with HDLC framing is used on the line.')
atmIfInPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 10, 1, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfInPkts.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfInPkts.setDescription('The number of reassembled received packets.')
atmIfOutPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 10, 1, 23), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfOutPkts.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfOutPkts.setDescription('This number of transmitted packets.')
atmIfRxSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 10, 1, 24), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfRxSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfRxSpeed.setDescription('This object contains the receive interface speed.')
atmIfTxSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 10, 1, 25), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfTxSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfTxSpeed.setDescription('This object contains the transmit interface speed.')
atmIfInOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 10, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfInOctets.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfInOctets.setDescription('The total number of octets received on the interface, including framing characters.')
atmIfInDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 10, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfInDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfInDiscards.setDescription('The number of inbound packets which were chosen to be discarded even though no errors had been detected to prevent their being deliverable to a higher-layer protocol. One possible reason for discarding such a packet could be to free up buffer space.')
atmIfInErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 10, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfInErrors.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfInErrors.setDescription('The number of inbound packets that contained errors preventing them from being deliverable to a higher-layer protocol.')
atmIfOutOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 10, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfOutOctets.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfOutOctets.setDescription('The total number of octets transmitted out of the interface, including framing characters.')
atmIfOutDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 10, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfOutDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfOutDiscards.setDescription('The number of outbound packets which were chosen to be discarded even though no errors had been detected to prevent their being transmitted. One possible reason for discarding such a packet could be to free up buffer space.')
atmIfOutErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 10, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfOutErrors.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfOutErrors.setDescription('The number of outbound packets that could not be transmitted because of errors.')
atmVpcTable = MibTable((1, 3, 6, 1, 4, 1, 272, 4, 16, 11), )
if mibBuilder.loadTexts: atmVpcTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmVpcTable.setDescription('A table of status and parameter information on the virtual path connections which cross this UNI. There is one entry in this table for each permanent virtual path connection. This is the lite version of ATM-FORUM-MIB DEFINITIONS ')
atmVpcEntry = MibTableRow((1, 3, 6, 1, 4, 1, 272, 4, 16, 11, 1), ).setIndexNames((0, "BIANCA-BRICK-ATM2-MIB", "atmVpcPortIndex"), (0, "BIANCA-BRICK-ATM2-MIB", "atmVpcVpi"))
if mibBuilder.loadTexts: atmVpcEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmVpcEntry.setDescription('An entry in the table, containing information about a particular virtual path connection.')
atmVpcPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 11, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpcPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmVpcPortIndex.setDescription('The interface index of the associated ATM hardware.')
atmVpcVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 11, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpcVpi.setStatus('mandatory')
if mibBuilder.loadTexts: atmVpcVpi.setDescription('The VPI value of this Virtual Path Connection.')
atmVpcOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 11, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unknown", 1), ("end2endUp", 2), ("end2endDown", 3), ("localUpEnd2endUnknown", 4), ("localDown", 5))).clone('unknown')).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpcOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmVpcOperStatus.setDescription('The present actual operational status of the VPC. A value of end2endUp(2) or end2endDown(3) would be used if the end-to-end status is known. If only local status information is available, a value of localUpEnd2endUnknown(4) or localDown(5) would be used.')
atmVccTable = MibTable((1, 3, 6, 1, 4, 1, 272, 4, 16, 12), )
if mibBuilder.loadTexts: atmVccTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmVccTable.setDescription('A table of status and parameter information on the virtual channel connections which are visible at this UNI. There is one entry in this table for each permanent virtual channel connection, including reserved VCCs that are supported; e.g., signalling, OAM flows, and ILMI, but not unassigned cells. This is the lite version of ATM-FORUM-MIB DEFINITIONS ')
atmVccEntry = MibTableRow((1, 3, 6, 1, 4, 1, 272, 4, 16, 12, 1), ).setIndexNames((0, "BIANCA-BRICK-ATM2-MIB", "atmVccPortIndex"), (0, "BIANCA-BRICK-ATM2-MIB", "atmVccVpi"), (0, "BIANCA-BRICK-ATM2-MIB", "atmVccVci"))
if mibBuilder.loadTexts: atmVccEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmVccEntry.setDescription('An entry in the table, containing information about a particular virtual channel connection.')
atmVccPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 12, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVccPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmVccPortIndex.setDescription('The interface index of the associated ATM hardware.')
atmVccVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 12, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVccVpi.setStatus('mandatory')
if mibBuilder.loadTexts: atmVccVpi.setDescription('The VPI value of this Virtual Channel Connection.')
atmVccVci = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 12, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVccVci.setStatus('mandatory')
if mibBuilder.loadTexts: atmVccVci.setDescription('The VCI value of this Virtual Channel Connection.')
atmVccOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 12, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unknown", 1), ("end2endUp", 2), ("end2endDown", 3), ("localUpEnd2endUnknown", 4), ("localDown", 5))).clone('unknown')).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVccOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmVccOperStatus.setDescription('The present actual operational status of the VCC. A value of end2endUp(2) or end2endUp(3) is used if the end-to-end status is known. If only local status is known a value of localUpEnd2endUnknown(4) or localDown(5) is used.')
atmOamTable = MibTable((1, 3, 6, 1, 4, 1, 272, 4, 16, 13), )
if mibBuilder.loadTexts: atmOamTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmOamTable.setDescription('This tables contains all OAM configuration parameters.')
atmOamEntry = MibTableRow((1, 3, 6, 1, 4, 1, 272, 4, 16, 13, 1), ).setIndexNames((0, "BIANCA-BRICK-ATM2-MIB", "atmOamAtmIfIndex"), (0, "BIANCA-BRICK-ATM2-MIB", "atmOamVpi"), (0, "BIANCA-BRICK-ATM2-MIB", "atmOamVci"))
if mibBuilder.loadTexts: atmOamEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmOamEntry.setDescription('')
atmOamAtmIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 13, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmOamAtmIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmOamAtmIfIndex.setDescription('The interface index of the associated ATM hardware.')
atmOamVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 13, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmOamVpi.setStatus('mandatory')
if mibBuilder.loadTexts: atmOamVpi.setDescription('The VPI value of this Virtual Path/Channel Connection.')
atmOamVci = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 13, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(32)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmOamVci.setStatus('mandatory')
if mibBuilder.loadTexts: atmOamVci.setDescription('The VCI value of this Virtual Channel Connection.')
atmOamFlowLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 13, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 10))).clone(namedValues=NamedValues(("f5", 1), ("f4", 2), ("delete", 10))).clone('f5')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmOamFlowLevel.setStatus('mandatory')
if mibBuilder.loadTexts: atmOamFlowLevel.setDescription('The OAM hierarchical flow levels : VC (F5) or VP (F4).')
atmOamLoopbackEnd2End = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 13, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmOamLoopbackEnd2End.setStatus('mandatory')
if mibBuilder.loadTexts: atmOamLoopbackEnd2End.setDescription('Indicates wether OAM loopback is enabled onto the end-to-end connection.')
atmOamLoopbackSegment = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 13, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmOamLoopbackSegment.setStatus('mandatory')
if mibBuilder.loadTexts: atmOamLoopbackSegment.setDescription('Indicates wether active OAM loopback is enabled onto the segment connection.')
atmOamLoopbackEnd2EndInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 13, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 999)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmOamLoopbackEnd2EndInterval.setStatus('mandatory')
if mibBuilder.loadTexts: atmOamLoopbackEnd2EndInterval.setDescription('OAM loopback transmit interval (in seconds) for end-to-end context.')
atmOamLoopbackSegmentInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 13, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 999)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmOamLoopbackSegmentInterval.setStatus('mandatory')
if mibBuilder.loadTexts: atmOamLoopbackSegmentInterval.setDescription('OAM loopback transmit interval (in seconds) for segment context.')
atmOamLoopbackEnd2EndMaxPending = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 13, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 999)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmOamLoopbackEnd2EndMaxPending.setStatus('mandatory')
if mibBuilder.loadTexts: atmOamLoopbackEnd2EndMaxPending.setDescription('Specifies the maximum number of outstanding OAM loopback responses after which the associated F4/F5 instance will be set into the end-to-end operational down status.')
atmOamLoopbackSegmentMaxPending = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 13, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 999)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmOamLoopbackSegmentMaxPending.setStatus('mandatory')
if mibBuilder.loadTexts: atmOamLoopbackSegmentMaxPending.setDescription('Specifies the maximum number of outstanding OAM loopback responses after which the associated F4/F5 instance will be set into the segment operational down status.')
atmOamCCEnd2EndActivation = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 13, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("passive", 1), ("active", 2), ("both", 3), ("no-negotiation", 4), ("none", 5))).clone('passive')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmOamCCEnd2EndActivation.setStatus('mandatory')
if mibBuilder.loadTexts: atmOamCCEnd2EndActivation.setDescription('Determines wether OAM continuity check activation request will be activated and/or accepted for the associated end-to-end connection. If set to passive(1) or both(3) CC activation requests will be confirmed. If set to active(2) or both CC will be requested. If set to no-negotiation(4) - depending on the settings in atmOamCCEnd2EndDirection - CC cells will be send and/or expected periodically without any previous CC activation negotiation. If set to none(5) neither CC activation will be requested/confirmed nor any CC cells will be generated/expected.')
atmOamCCSegmentActivation = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 13, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("passive", 1), ("active", 2), ("both", 3), ("no-negotiation", 4), ("none", 5))).clone('passive')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmOamCCSegmentActivation.setStatus('mandatory')
if mibBuilder.loadTexts: atmOamCCSegmentActivation.setDescription('Determines wether OAM continuity check activation request will be activated and/or accepted for the associated segment connection. If set to passive(1) or both(3) CC activation requests will be confirmed. If set to active(2) or both CC will be requested. If set to no-negotiation(4) - depending on the settings in atmOamCCSegmentDirection - CC cells will be send and/or expected periodically without any previous CC activation negotiation. If set to none(5) neither CC activation will be requested/confirmed nor any CC cells will be generated/expected.')
atmOamCCEnd2EndDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 13, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("sink", 1), ("source", 2), ("both", 3), ("none", 4))).clone('both')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmOamCCEnd2EndDirection.setStatus('mandatory')
if mibBuilder.loadTexts: atmOamCCEnd2EndDirection.setDescription('Determines OAM continuity check direction (for end-to-end). If set to sink(1) CC cells will be received only, if set to source(2) CC cells will be generated periodically, if set to both(3) CC cells will be received from the source as well as send to the sink.')
atmOamCCSegmentDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 13, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("sink", 1), ("source", 2), ("both", 3), ("none", 4))).clone('both')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmOamCCSegmentDirection.setStatus('mandatory')
if mibBuilder.loadTexts: atmOamCCSegmentDirection.setDescription('Determines OAM continuity check direction (for segment). If set to sink(1) CC cells will be received only, if set to source(2) CC cells will be generated periodically, if set to both(3) CC cells will be received from the source as well as send to the sink.')
atmOamStatTable = MibTable((1, 3, 6, 1, 4, 1, 272, 4, 16, 14), )
if mibBuilder.loadTexts: atmOamStatTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmOamStatTable.setDescription('This tables displays all used VCs.')
atmOamStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 272, 4, 16, 14, 1), ).setIndexNames((0, "BIANCA-BRICK-ATM2-MIB", "atmOamStatAtmIfIndex"), (0, "BIANCA-BRICK-ATM2-MIB", "atmOamStatVpi"), (0, "BIANCA-BRICK-ATM2-MIB", "atmOamStatVci"))
if mibBuilder.loadTexts: atmOamStatEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmOamStatEntry.setDescription('')
atmOamStatAtmIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 14, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmOamStatAtmIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmOamStatAtmIfIndex.setDescription('The interface index of the associated ATM hardware.')
atmOamStatVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 14, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmOamStatVpi.setStatus('mandatory')
if mibBuilder.loadTexts: atmOamStatVpi.setDescription('The VPI value of this Virtual Path Connection.')
atmOamStatVci = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 14, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmOamStatVci.setStatus('mandatory')
if mibBuilder.loadTexts: atmOamStatVci.setDescription('The VCI value of this Virtual Channel Connection.')
atmOamStatFlowType = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 14, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("f5-segment", 1), ("f5-end2end", 2), ("f4-segment", 3), ("f4-end2end", 4))).clone('f5-end2end')).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmOamStatFlowType.setStatus('mandatory')
if mibBuilder.loadTexts: atmOamStatFlowType.setDescription('The OAM hierarchical flow levels: see ITU I.610')
atmOamStatLoopbackTxCells = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 14, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmOamStatLoopbackTxCells.setStatus('mandatory')
if mibBuilder.loadTexts: atmOamStatLoopbackTxCells.setDescription('The number of OAM loopback cells that have been sent to the target in this sequence.')
atmOamStatLoopbackRxCells = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 14, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmOamStatLoopbackRxCells.setStatus('mandatory')
if mibBuilder.loadTexts: atmOamStatLoopbackRxCells.setDescription('The number of OAM loopback cells that have been received from the target in this sequence.')
atmOamStatLoopbackPending = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 14, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmOamStatLoopbackPending.setStatus('mandatory')
if mibBuilder.loadTexts: atmOamStatLoopbackPending.setDescription('The number of currently outstanding OAM loopback responses.')
atmOamStatLoopbackCorr = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 14, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmOamStatLoopbackCorr.setStatus('mandatory')
if mibBuilder.loadTexts: atmOamStatLoopbackCorr.setDescription('The correlation of the last sent loopback message.')
atmOamStatAisState = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 14, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmOamStatAisState.setStatus('mandatory')
if mibBuilder.loadTexts: atmOamStatAisState.setDescription('The AIS state is set to on(2) after receiving an AIS cell or detection of LOC (Loss of Continuity). The Ais state is set to off(1) either when receiving user cells (same VCC context) or via timeout.')
atmOamStatAisTxCells = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 14, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmOamStatAisTxCells.setStatus('mandatory')
if mibBuilder.loadTexts: atmOamStatAisTxCells.setDescription('The number of OAM alarm indication signal (AIS) cells that have been transmitted since last change of AisState.')
atmOamStatAisRxCells = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 14, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmOamStatAisRxCells.setStatus('mandatory')
if mibBuilder.loadTexts: atmOamStatAisRxCells.setDescription('The number of OAM alarm indication signal (AIS) cells that have been received since last change of AisState.')
atmOamStatTotalAisTxCells = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 14, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmOamStatTotalAisTxCells.setStatus('mandatory')
if mibBuilder.loadTexts: atmOamStatTotalAisTxCells.setDescription('The total number of OAM alarm indication signal (AIS) cells that have been transmitted.')
atmOamStatTotalAisRxCells = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 14, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmOamStatTotalAisRxCells.setStatus('mandatory')
if mibBuilder.loadTexts: atmOamStatTotalAisRxCells.setDescription('The total number of OAM alarm indication signal (AIS) cells that have been received.')
atmOamStatRdiState = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 14, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmOamStatRdiState.setStatus('mandatory')
if mibBuilder.loadTexts: atmOamStatRdiState.setDescription('The RDI state is set to on(2) after receiving a RDI cell. The RDI state is to off(1) via timeout.')
atmOamStatRdiTxCells = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 14, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmOamStatRdiTxCells.setStatus('mandatory')
if mibBuilder.loadTexts: atmOamStatRdiTxCells.setDescription('The number of OAM remote defect indication (RDI) cells that have been transmitted since last change of RdiState.')
atmOamStatRdiRxCells = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 14, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmOamStatRdiRxCells.setStatus('mandatory')
if mibBuilder.loadTexts: atmOamStatRdiRxCells.setDescription('The number of OAM remote defect indication (RDI) cells that have been received since last change of RdiState.')
atmOamStatTotalRdiTxCells = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 14, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmOamStatTotalRdiTxCells.setStatus('mandatory')
if mibBuilder.loadTexts: atmOamStatTotalRdiTxCells.setDescription('The totoal number of OAM remote defect indication (RDI) cells that have been transmitted.')
atmOamStatTotalRdiRxCells = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 14, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmOamStatTotalRdiRxCells.setStatus('mandatory')
if mibBuilder.loadTexts: atmOamStatTotalRdiRxCells.setDescription('The total number of OAM remote defect indication (RDI) cells that have been received.')
atmOamStatCCActivatorState = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 14, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("inactive", 1), ("wait-act-con", 2), ("active", 3), ("wait-deact-con", 4))).clone('inactive')).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmOamStatCCActivatorState.setStatus('mandatory')
if mibBuilder.loadTexts: atmOamStatCCActivatorState.setDescription('The status of the initiated CC negotiation, inactive(1) is the initial status, wait-act-con(2) is set after sending an CC activation request, active(3) is reached after receiving the CC activation confirmation whereas wait-deact-con(4) is used to indicate awaiting the CC deactivation confirmation.')
atmOamStatCCActivatorDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 14, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("sink", 1), ("source", 2), ("both", 3), ("not-applicable", 4))).clone('not-applicable')).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmOamStatCCActivatorDirection.setStatus('mandatory')
if mibBuilder.loadTexts: atmOamStatCCActivatorDirection.setDescription("The direction of action indicated by a received CC activation confirmation, source(1) correlates with 'A-B', sink(2) with 'B-A' and both(3) with 'A-B' and 'B-A'.")
atmOamStatCCActivatorCorr = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 14, 1, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmOamStatCCActivatorCorr.setStatus('mandatory')
if mibBuilder.loadTexts: atmOamStatCCActivatorCorr.setDescription('The correlation of the last CC activation message sent to the responder.')
atmOamStatCCResponderState = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 14, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 4))).clone(namedValues=NamedValues(("inactive", 1), ("active", 3), ("wait-deact-con", 4))).clone('inactive')).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmOamStatCCResponderState.setStatus('mandatory')
if mibBuilder.loadTexts: atmOamStatCCResponderState.setDescription('The status of the passive CC negotiation, inactive(1) is the initial status, active(3) is reached after receiving an CC activation request whereas wait-deact-con(4) is used to indicate awaiting the CC deactivation confirmation.')
atmOamStatCCResponderDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 14, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("source", 1), ("sink", 2), ("both", 3), ("not-applicable", 4))).clone('not-applicable')).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmOamStatCCResponderDirection.setStatus('mandatory')
if mibBuilder.loadTexts: atmOamStatCCResponderDirection.setDescription("The direction of action indicated by a received CC activation request, source(1) correlates with 'B-A', sink(2) with 'A-B' and both(3) with 'A-B' and 'B-A'.")
atmOamStatCCResponderCorr = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 14, 1, 25), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmOamStatCCResponderCorr.setStatus('mandatory')
if mibBuilder.loadTexts: atmOamStatCCResponderCorr.setDescription('The correlation of the received CC activation message.')
atmOamStatCCTxCells = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 14, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmOamStatCCTxCells.setStatus('mandatory')
if mibBuilder.loadTexts: atmOamStatCCTxCells.setDescription('The number of OAM continuity check cells that have been sent to the target in this sequence.')
atmOamStatCCRxCells = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 14, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmOamStatCCRxCells.setStatus('mandatory')
if mibBuilder.loadTexts: atmOamStatCCRxCells.setDescription('The number of OAM continuity check cells that have been received from the target in this sequence.')
ethoaPvcTable = MibTable((1, 3, 6, 1, 4, 1, 272, 4, 16, 15), )
if mibBuilder.loadTexts: ethoaPvcTable.setStatus('mandatory')
if mibBuilder.loadTexts: ethoaPvcTable.setDescription('The ethoaPvcTable displays all virtual ethernets defined for a VCI/VPI on a specified hardware.')
ethoaPvcEntry = MibTableRow((1, 3, 6, 1, 4, 1, 272, 4, 16, 15, 1), ).setIndexNames((0, "BIANCA-BRICK-ATM2-MIB", "ethoaPvcVpi"), (0, "BIANCA-BRICK-ATM2-MIB", "ethoaPvcVci"), (0, "BIANCA-BRICK-ATM2-MIB", "ethoaPvcAtmIfIndex"))
if mibBuilder.loadTexts: ethoaPvcEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ethoaPvcEntry.setDescription('')
ethoaPvcIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 15, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethoaPvcIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ethoaPvcIfIndex.setDescription('This object contains an interface index and assigns the row to an entry in ifTable. When creating new entries in the table, the value of this object shall be set to 0. The next free ifIndex value is than allocated and assigned to the object. At the same time a new interface is created in the IfTable.')
ethoaPvcDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 15, 1, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethoaPvcDescr.setStatus('mandatory')
if mibBuilder.loadTexts: ethoaPvcDescr.setDescription('Short description of the configured PVC')
ethoaPvcAtmIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 15, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethoaPvcAtmIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ethoaPvcAtmIfIndex.setDescription('The Index to the ATM hardware.')
ethoaPvcVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 15, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethoaPvcVpi.setStatus('mandatory')
if mibBuilder.loadTexts: ethoaPvcVpi.setDescription('The VPI value of this Virtual Path Connection.')
ethoaPvcVci = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 15, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(32)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethoaPvcVci.setStatus('mandatory')
if mibBuilder.loadTexts: ethoaPvcVci.setDescription('The VCI value of this Virtual Channel Connection.')
ethoaPvcEncapsulation = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 15, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 10))).clone(namedValues=NamedValues(("bridged-no-fcs", 1), ("bridged-fcs", 2), ("vc-multiplexed", 3), ("delete", 10))).clone('bridged-no-fcs')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethoaPvcEncapsulation.setStatus('mandatory')
if mibBuilder.loadTexts: ethoaPvcEncapsulation.setDescription('This values decides whether frames are send without FCS(1), with FCS(2) or wether VC multiplexing is used.')
ethoaPvcPhysAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 15, 1, 7), PhysAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethoaPvcPhysAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ethoaPvcPhysAddress.setDescription('The MAC-Address used for the virtual interface.')
rpoaPvcTable = MibTable((1, 3, 6, 1, 4, 1, 272, 4, 16, 16), )
if mibBuilder.loadTexts: rpoaPvcTable.setStatus('mandatory')
if mibBuilder.loadTexts: rpoaPvcTable.setDescription('This table configures Vpi/Vci for raw protocols (IP, IPX, etc.)')
rpoaPvcEntry = MibTableRow((1, 3, 6, 1, 4, 1, 272, 4, 16, 16, 1), ).setIndexNames((0, "BIANCA-BRICK-ATM2-MIB", "rpoaPvcVpi"), (0, "BIANCA-BRICK-ATM2-MIB", "rpoaPvcVci"), (0, "BIANCA-BRICK-ATM2-MIB", "rpoaPvcAtmIfIndex"))
if mibBuilder.loadTexts: rpoaPvcEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rpoaPvcEntry.setDescription('')
rpoaPvcIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 16, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpoaPvcIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rpoaPvcIfIndex.setDescription('This object contains an interface index and assigns the row to an entry in ifTable. When creating new entries in the table, the value of this object shall be set to 0. The next free ifIndex value is than allocated and assigned to the object. At the same time a new interface is created in the IfTable.')
rpoaPvcDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 16, 1, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rpoaPvcDescr.setStatus('mandatory')
if mibBuilder.loadTexts: rpoaPvcDescr.setDescription('Short description of the configured PVC')
rpoaPvcAtmIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 16, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rpoaPvcAtmIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rpoaPvcAtmIfIndex.setDescription('The Index to the ATM hardware.')
rpoaPvcVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 16, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rpoaPvcVpi.setStatus('mandatory')
if mibBuilder.loadTexts: rpoaPvcVpi.setDescription('The VPI value of this Virtual Path Connection.')
rpoaPvcVci = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 16, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(32)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rpoaPvcVci.setStatus('mandatory')
if mibBuilder.loadTexts: rpoaPvcVci.setDescription('The VCI value of this Virtual Channel Connection.')
rpoaPvcEncapsulation = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 16, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 10))).clone(namedValues=NamedValues(("non-iso", 1), ("iso", 2), ("vc-multiplexed", 3), ("delete", 10))).clone('non-iso')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rpoaPvcEncapsulation.setStatus('mandatory')
if mibBuilder.loadTexts: rpoaPvcEncapsulation.setDescription('This values decides whether frames are send codes with LLC 0xAA 0xAA (non-ISO), LLC 0xFE 0xFE (ISO) or wether VC multiplexing is used.')
pppoaPvcTable = MibTable((1, 3, 6, 1, 4, 1, 272, 4, 16, 17), )
if mibBuilder.loadTexts: pppoaPvcTable.setStatus('mandatory')
if mibBuilder.loadTexts: pppoaPvcTable.setDescription('This table configures Vpi/Vci for PPP oaver AAL5 (PPPoA) permanent and on-demand sessions.')
pppoaPvcEntry = MibTableRow((1, 3, 6, 1, 4, 1, 272, 4, 16, 17, 1), ).setIndexNames((0, "BIANCA-BRICK-ATM2-MIB", "pppoaPvcVpi"), (0, "BIANCA-BRICK-ATM2-MIB", "pppoaPvcVci"), (0, "BIANCA-BRICK-ATM2-MIB", "pppoaPvcAtmIfIndex"))
if mibBuilder.loadTexts: pppoaPvcEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pppoaPvcEntry.setDescription('')
pppoaPvcIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 17, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pppoaPvcIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pppoaPvcIfIndex.setDescription('This object contains an interface index and refers to an entry in ifTable. When creating new entries in the table, the next free ifIndex value is than allocated and assigned to the object. At the same time a new interface is created in the IfTable with that very index.')
pppoaPvcDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 17, 1, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppoaPvcDescr.setStatus('mandatory')
if mibBuilder.loadTexts: pppoaPvcDescr.setDescription('Short description of the configured PVC')
pppoaPvcAtmIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 17, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppoaPvcAtmIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pppoaPvcAtmIfIndex.setDescription('The Index to the ATM hardware.')
pppoaPvcVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 17, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppoaPvcVpi.setStatus('mandatory')
if mibBuilder.loadTexts: pppoaPvcVpi.setDescription('The VPI value of this Virtual Path Connection.')
pppoaPvcVci = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 17, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(32)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppoaPvcVci.setStatus('mandatory')
if mibBuilder.loadTexts: pppoaPvcVci.setDescription('The VCI value of this Virtual Channel Connection.')
pppoaPvcEncapsulation = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 17, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 10))).clone(namedValues=NamedValues(("vc-multiplexed", 1), ("llc", 2), ("delete", 10))).clone('vc-multiplexed')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppoaPvcEncapsulation.setStatus('mandatory')
if mibBuilder.loadTexts: pppoaPvcEncapsulation.setDescription('This value decides whether VC multiplexing or LLC encapsulation is used.')
pppoaPvcClientType = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 17, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("permanent", 1), ("on-demand", 2))).clone('on-demand')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppoaPvcClientType.setStatus('mandatory')
if mibBuilder.loadTexts: pppoaPvcClientType.setDescription('This variable defines whether the PPP over AAL5 session will be established permanent(1) or initiated on-demand(2).')
atmQosVccTable = MibTable((1, 3, 6, 1, 4, 1, 272, 4, 16, 19), )
if mibBuilder.loadTexts: atmQosVccTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmQosVccTable.setDescription('This table provides QoS information for each active ATM VC on the related ATM interface')
atmQosVccEntry = MibTableRow((1, 3, 6, 1, 4, 1, 272, 4, 16, 19, 1), ).setIndexNames((0, "BIANCA-BRICK-ATM2-MIB", "atmQosVccAtmIfIndex"), (0, "BIANCA-BRICK-ATM2-MIB", "atmQosVccVpi"), (0, "BIANCA-BRICK-ATM2-MIB", "atmQosVccVci"))
if mibBuilder.loadTexts: atmQosVccEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmQosVccEntry.setDescription('An entry in the table, containing ATM QoS parameters about a particular virtual connection.')
atmQosVccAtmIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 19, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmQosVccAtmIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmQosVccAtmIfIndex.setDescription('The interface index of the associated ATM hardware.')
atmQosVccVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 19, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmQosVccVpi.setStatus('mandatory')
if mibBuilder.loadTexts: atmQosVccVpi.setDescription('The VPI value of this Virtual Channel Connection.')
atmQosVccVci = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 19, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmQosVccVci.setStatus('mandatory')
if mibBuilder.loadTexts: atmQosVccVci.setDescription('The VCI value of this Virtual Channel Connection.')
atmQosVccService = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 19, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 8, 20))).clone(namedValues=NamedValues(("cbr", 1), ("vbr", 2), ("vbr3", 4), ("ubr", 8), ("delete", 20))).clone('ubr')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmQosVccService.setStatus('mandatory')
if mibBuilder.loadTexts: atmQosVccService.setDescription('The ATM service category of this virtual circuit connection: cbr vbr vbr2 vbr3 VBR1 + Best Effort vbr-rt real-time vbr2-rt real-time vbr3-rt real-time ubr Best Effort ubr2 Best Effort abr delete ')
atmQosVccOutPcr = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 19, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmQosVccOutPcr.setStatus('mandatory')
if mibBuilder.loadTexts: atmQosVccOutPcr.setDescription('Output Peak Cell Rate (PCR) in bps.')
atmQosVccOutScr = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 19, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmQosVccOutScr.setStatus('mandatory')
if mibBuilder.loadTexts: atmQosVccOutScr.setDescription('Output Sustained Cell Rate (SCR) in bps.')
atmQosVccOutMbs = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 19, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmQosVccOutMbs.setStatus('mandatory')
if mibBuilder.loadTexts: atmQosVccOutMbs.setDescription('Output Maximum Burst Size (MBS) in Bytes, only for atmQosVccService vbr-rt(2) and vbr-nrt(3) (ATM service service category VBR).')
atmQosVccOutMcr = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 19, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmQosVccOutMcr.setStatus('mandatory')
if mibBuilder.loadTexts: atmQosVccOutMcr.setDescription('Output Minimum Cell Rate (MCR) in bps for connection with vbr-nrt(3).')
atmAturPerfDataTable = MibTable((1, 3, 6, 1, 4, 1, 272, 4, 16, 20), )
if mibBuilder.loadTexts: atmAturPerfDataTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmAturPerfDataTable.setDescription('')
atmAturPerfDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 272, 4, 16, 20, 1), ).setIndexNames((0, "BIANCA-BRICK-ATM2-MIB", "atmAturPerfIfIndex"))
if mibBuilder.loadTexts: atmAturPerfDataEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmAturPerfDataEntry.setDescription('An entry in atmAturPerfDataTable.')
atmAturPerfIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 20, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmAturPerfIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmAturPerfIfIndex.setDescription('Specifies the ATM interface index.')
atmAturPerfIdleCells = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 20, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmAturPerfIdleCells.setStatus('mandatory')
if mibBuilder.loadTexts: atmAturPerfIdleCells.setDescription('The number of ATM idle cells.')
atmAturPerfDataCells = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 20, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmAturPerfDataCells.setStatus('mandatory')
if mibBuilder.loadTexts: atmAturPerfDataCells.setDescription('The number of ATM data cells.')
atmAturPerfLcds = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 20, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmAturPerfLcds.setStatus('mandatory')
if mibBuilder.loadTexts: atmAturPerfLcds.setDescription('Count of the number of Loss of Cell Delineation failures since agent reset.')
atmAturPerfHecs = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 20, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmAturPerfHecs.setStatus('mandatory')
if mibBuilder.loadTexts: atmAturPerfHecs.setDescription('Count of the number of Header Error Check failures since agent reset.')
atmAturPerfCurr15MinTimeElapsed = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 20, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 899))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmAturPerfCurr15MinTimeElapsed.setStatus('mandatory')
if mibBuilder.loadTexts: atmAturPerfCurr15MinTimeElapsed.setDescription('Total elapsed seconds in this interval.')
atmAturPerfCurr15MinIdleCells = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 20, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmAturPerfCurr15MinIdleCells.setStatus('mandatory')
if mibBuilder.loadTexts: atmAturPerfCurr15MinIdleCells.setDescription('The number of ATM idle cells in the mandatory 15 minute interval.')
atmAturPerfCurr15MinDataCells = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 20, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmAturPerfCurr15MinDataCells.setStatus('mandatory')
if mibBuilder.loadTexts: atmAturPerfCurr15MinDataCells.setDescription('The number of ATM data cells in the mandatory 15 minute interval.')
atmAturPerfCurr15MinLcds = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 20, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmAturPerfCurr15MinLcds.setStatus('mandatory')
if mibBuilder.loadTexts: atmAturPerfCurr15MinLcds.setDescription('Count of seconds in the mandatory 15 minute interval when there was Loss of Cell Delineation.')
atmAturPerfCurr15MinHecs = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 20, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmAturPerfCurr15MinHecs.setStatus('mandatory')
if mibBuilder.loadTexts: atmAturPerfCurr15MinHecs.setDescription('Count of seconds in the mandatory 15 minute interval when there was Header Error Check failures.')
atmAturPerfCurr1DayTimeElapsed = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 20, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 86399))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmAturPerfCurr1DayTimeElapsed.setStatus('mandatory')
if mibBuilder.loadTexts: atmAturPerfCurr1DayTimeElapsed.setDescription('Number of seconds that have elapsed since the beginning of the mandatory 1-day interval.')
atmAturPerfCurr1DayIdleCells = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 20, 1, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmAturPerfCurr1DayIdleCells.setStatus('mandatory')
if mibBuilder.loadTexts: atmAturPerfCurr1DayIdleCells.setDescription('The number of ATM idle cells during the mandatory day as measured by atmAturPerfCurr1DayTimeElapsed.')
atmAturPerfCurr1DayDataCells = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 20, 1, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmAturPerfCurr1DayDataCells.setStatus('mandatory')
if mibBuilder.loadTexts: atmAturPerfCurr1DayDataCells.setDescription('The number of ATM data cells during the mandatory day as measured by atmAturPerfCurr1DayTimeElapsed.')
atmAturPerfCurr1DayLcds = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 20, 1, 21), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmAturPerfCurr1DayLcds.setStatus('mandatory')
if mibBuilder.loadTexts: atmAturPerfCurr1DayLcds.setDescription('Count of the number of seconds when there was Loss of Cell Delineation during the mandatory day as measured by atmAturPerfCurr1DayTimeElapsed.')
atmAturPerfCurr1DayHecs = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 20, 1, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmAturPerfCurr1DayHecs.setStatus('mandatory')
if mibBuilder.loadTexts: atmAturPerfCurr1DayHecs.setDescription('Count of the number of seconds when there was Header Error Check failures during the mandatory day as measured by atmAturPerfCurr1DayTimeElapsed.')
atmAturPerfPrev1DayIdleCells = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 20, 1, 26), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmAturPerfPrev1DayIdleCells.setStatus('mandatory')
if mibBuilder.loadTexts: atmAturPerfPrev1DayIdleCells.setDescription('The number of ATM idle cells within the most recent previous 1-day period.')
atmAturPerfPrev1DayDataCells = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 20, 1, 27), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmAturPerfPrev1DayDataCells.setStatus('mandatory')
if mibBuilder.loadTexts: atmAturPerfPrev1DayDataCells.setDescription('The number of ATM data cells within the most recent previous 1-day period.')
atmAturPerfPrev1DayLcds = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 20, 1, 28), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmAturPerfPrev1DayLcds.setStatus('mandatory')
if mibBuilder.loadTexts: atmAturPerfPrev1DayLcds.setDescription('Count of seconds in the interval when there was Loss of Cell Delineation within the most recent previous 1-day period.')
atmAturPerfPrev1DayHecs = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 20, 1, 29), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmAturPerfPrev1DayHecs.setStatus('mandatory')
if mibBuilder.loadTexts: atmAturPerfPrev1DayHecs.setDescription('Count of seconds in the interval when there was Header Error Check within the most recent previous 1-day period.')
atmAtucPerfDataTable = MibTable((1, 3, 6, 1, 4, 1, 272, 4, 16, 21), )
if mibBuilder.loadTexts: atmAtucPerfDataTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmAtucPerfDataTable.setDescription('')
atmAtucPerfDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 272, 4, 16, 21, 1), ).setIndexNames((0, "BIANCA-BRICK-ATM2-MIB", "atmAtucPerfIfIndex"))
if mibBuilder.loadTexts: atmAtucPerfDataEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmAtucPerfDataEntry.setDescription('An entry in atmAtucPerfDataTable.')
atmAtucPerfIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 21, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmAtucPerfIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmAtucPerfIfIndex.setDescription('Specifies the ATM interface index.')
atmAtucPerfIdleCells = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 21, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmAtucPerfIdleCells.setStatus('mandatory')
if mibBuilder.loadTexts: atmAtucPerfIdleCells.setDescription('The number of ATM idle cells.')
atmAtucPerfDataCells = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 21, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmAtucPerfDataCells.setStatus('mandatory')
if mibBuilder.loadTexts: atmAtucPerfDataCells.setDescription('The number of ATM data cells.')
atmAtucPerfLcds = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 21, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmAtucPerfLcds.setStatus('mandatory')
if mibBuilder.loadTexts: atmAtucPerfLcds.setDescription('Count of the number of Loss of Cell Delineation failures since agent reset.')
atmAtucPerfHecs = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 21, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmAtucPerfHecs.setStatus('mandatory')
if mibBuilder.loadTexts: atmAtucPerfHecs.setDescription('Count of the number of Header Error Check failures since agent reset.')
atmAtucPerfCurr15MinTimeElapsed = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 21, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 899))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmAtucPerfCurr15MinTimeElapsed.setStatus('mandatory')
if mibBuilder.loadTexts: atmAtucPerfCurr15MinTimeElapsed.setDescription('Total elapsed seconds in this interval.')
atmAtucPerfCurr15MinIdleCells = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 21, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmAtucPerfCurr15MinIdleCells.setStatus('mandatory')
if mibBuilder.loadTexts: atmAtucPerfCurr15MinIdleCells.setDescription('The number of ATM idle cells in the mandatory 15 minute interval.')
atmAtucPerfCurr15MinDataCells = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 21, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmAtucPerfCurr15MinDataCells.setStatus('mandatory')
if mibBuilder.loadTexts: atmAtucPerfCurr15MinDataCells.setDescription('The number of ATM data cells in the mandatory 15 minute interval.')
atmAtucPerfCurr15MinLcds = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 21, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmAtucPerfCurr15MinLcds.setStatus('mandatory')
if mibBuilder.loadTexts: atmAtucPerfCurr15MinLcds.setDescription('Count of seconds in the mandatory 15 minute interval when there was Loss of Cell Delineation.')
atmAtucPerfCurr15MinHecs = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 21, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmAtucPerfCurr15MinHecs.setStatus('mandatory')
if mibBuilder.loadTexts: atmAtucPerfCurr15MinHecs.setDescription('Count of seconds in the mandatory 15 minute interval when there was Header Error Check failures.')
atmAtucPerfCurr1DayTimeElapsed = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 21, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 86399))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmAtucPerfCurr1DayTimeElapsed.setStatus('mandatory')
if mibBuilder.loadTexts: atmAtucPerfCurr1DayTimeElapsed.setDescription('Number of seconds that have elapsed since the beginning of the mandatory 1-day interval.')
atmAtucPerfCurr1DayIdleCells = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 21, 1, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmAtucPerfCurr1DayIdleCells.setStatus('mandatory')
if mibBuilder.loadTexts: atmAtucPerfCurr1DayIdleCells.setDescription('The number of ATM idle cells during the mandatory day as measured by atmAtucPerfCurr1DayTimeElapsed.')
atmAtucPerfCurr1DayDataCells = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 21, 1, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmAtucPerfCurr1DayDataCells.setStatus('mandatory')
if mibBuilder.loadTexts: atmAtucPerfCurr1DayDataCells.setDescription('The number of ATM data cells during the mandatory day as measured by atmAtucPerfCurr1DayTimeElapsed.')
atmAtucPerfCurr1DayLcds = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 21, 1, 21), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmAtucPerfCurr1DayLcds.setStatus('mandatory')
if mibBuilder.loadTexts: atmAtucPerfCurr1DayLcds.setDescription('Count of the number of seconds when there was Loss of Cell Delineation during the mandatory day as measured by atmAtucPerfCurr1DayTimeElapsed.')
atmAtucPerfCurr1DayHecs = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 21, 1, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmAtucPerfCurr1DayHecs.setStatus('mandatory')
if mibBuilder.loadTexts: atmAtucPerfCurr1DayHecs.setDescription('Count of the number of seconds when there was Header Error Check failures during the mandatory day as measured by atmAtucPerfCurr1DayTimeElapsed.')
atmAtucPerfPrev1DayIdleCells = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 21, 1, 26), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmAtucPerfPrev1DayIdleCells.setStatus('mandatory')
if mibBuilder.loadTexts: atmAtucPerfPrev1DayIdleCells.setDescription('The number of ATM idle cells within the most recent previous 1-day period.')
atmAtucPerfPrev1DayDataCells = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 21, 1, 27), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmAtucPerfPrev1DayDataCells.setStatus('mandatory')
if mibBuilder.loadTexts: atmAtucPerfPrev1DayDataCells.setDescription('The number of ATM data cells within the most recent previous 1-day period.')
atmAtucPerfPrev1DayLcds = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 21, 1, 28), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmAtucPerfPrev1DayLcds.setStatus('mandatory')
if mibBuilder.loadTexts: atmAtucPerfPrev1DayLcds.setDescription('Count of seconds in the interval when there was Loss of Cell Delineation within the most recent previous 1-day period.')
atmAtucPerfPrev1DayHecs = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 16, 21, 1, 29), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmAtucPerfPrev1DayHecs.setStatus('mandatory')
if mibBuilder.loadTexts: atmAtucPerfPrev1DayHecs.setDescription('Count of seconds in the interval when there was Header Error Check within the most recent previous 1-day period.')
mibBuilder.exportSymbols("BIANCA-BRICK-ATM2-MIB", atmQosVccTable=atmQosVccTable, atmOamStatCCRxCells=atmOamStatCCRxCells, atmOamStatAisState=atmOamStatAisState, ethoaPvcEntry=ethoaPvcEntry, atmAtucPerfCurr15MinDataCells=atmAtucPerfCurr15MinDataCells, atmOamStatVci=atmOamStatVci, ethoaPvcAtmIfIndex=ethoaPvcAtmIfIndex, atmOamEntry=atmOamEntry, atmOamStatTotalAisRxCells=atmOamStatTotalAisRxCells, atmIfDescr=atmIfDescr, atmAturPerfCurr1DayTimeElapsed=atmAturPerfCurr1DayTimeElapsed, atmVpcTable=atmVpcTable, atmOamStatAisTxCells=atmOamStatAisTxCells, atmOamFlowLevel=atmOamFlowLevel, atmAturPerfCurr1DayHecs=atmAturPerfCurr1DayHecs, atmQosVccEntry=atmQosVccEntry, atmVccEntry=atmVccEntry, atmAturPerfLcds=atmAturPerfLcds, ethoaPvcIfIndex=ethoaPvcIfIndex, atmIfAdminStatus=atmIfAdminStatus, atmAturPerfCurr1DayDataCells=atmAturPerfCurr1DayDataCells, atmAturPerfHecs=atmAturPerfHecs, atmOamCCEnd2EndDirection=atmOamCCEnd2EndDirection, atmIfRxSpeed=atmIfRxSpeed, atmOamLoopbackEnd2EndMaxPending=atmOamLoopbackEnd2EndMaxPending, atmAtucPerfCurr1DayDataCells=atmAtucPerfCurr1DayDataCells, rpoaPvcEntry=rpoaPvcEntry, atmAtucPerfHecs=atmAtucPerfHecs, atmOamStatTotalAisTxCells=atmOamStatTotalAisTxCells, atmAtucPerfLcds=atmAtucPerfLcds, atmOamStatRdiTxCells=atmOamStatRdiTxCells, atmOamCCSegmentDirection=atmOamCCSegmentDirection, atmIfInErrors=atmIfInErrors, atmOamVpi=atmOamVpi, atmOamStatTotalRdiTxCells=atmOamStatTotalRdiTxCells, atmQosVccOutScr=atmQosVccOutScr, atmAtucPerfIdleCells=atmAtucPerfIdleCells, bintec=bintec, atmVpcOperStatus=atmVpcOperStatus, atmAtucPerfPrev1DayIdleCells=atmAtucPerfPrev1DayIdleCells, atmOamLoopbackEnd2EndInterval=atmOamLoopbackEnd2EndInterval, ethoaPvcTable=ethoaPvcTable, pppoaPvcVpi=pppoaPvcVpi, rpoaPvcDescr=rpoaPvcDescr, atmAturPerfDataCells=atmAturPerfDataCells, atmAturPerfPrev1DayIdleCells=atmAturPerfPrev1DayIdleCells, atmIfInDiscards=atmIfInDiscards, pppoaPvcAtmIfIndex=pppoaPvcAtmIfIndex, atmOamLoopbackSegmentMaxPending=atmOamLoopbackSegmentMaxPending, rpoaPvcVpi=rpoaPvcVpi, atmQosVccVci=atmQosVccVci, atmAtucPerfIfIndex=atmAtucPerfIfIndex, atmOamStatLoopbackCorr=atmOamStatLoopbackCorr, atmOamStatRdiState=atmOamStatRdiState, atmOamLoopbackSegment=atmOamLoopbackSegment, atmAtucPerfCurr15MinTimeElapsed=atmAtucPerfCurr15MinTimeElapsed, atmAturPerfPrev1DayLcds=atmAturPerfPrev1DayLcds, atmQosVccOutPcr=atmQosVccOutPcr, atmQosVccOutMcr=atmQosVccOutMcr, atmVccVci=atmVccVci, atmAtucPerfPrev1DayHecs=atmAtucPerfPrev1DayHecs, atmIfTable=atmIfTable, atmAturPerfPrev1DayHecs=atmAturPerfPrev1DayHecs, atm=atm, atmOamStatLoopbackPending=atmOamStatLoopbackPending, atmOamStatVpi=atmOamStatVpi, atmAturPerfCurr15MinTimeElapsed=atmAturPerfCurr15MinTimeElapsed, pppoaPvcEncapsulation=pppoaPvcEncapsulation, atmVpcEntry=atmVpcEntry, atmAturPerfIfIndex=atmAturPerfIfIndex, rpoaPvcTable=rpoaPvcTable, atmOamStatLoopbackRxCells=atmOamStatLoopbackRxCells, atmOamStatCCResponderState=atmOamStatCCResponderState, atmAtucPerfCurr1DayHecs=atmAtucPerfCurr1DayHecs, pppoaPvcIfIndex=pppoaPvcIfIndex, atmAtucPerfCurr15MinHecs=atmAtucPerfCurr15MinHecs, atmIfOutErrors=atmIfOutErrors, atmAtucPerfCurr1DayTimeElapsed=atmAtucPerfCurr1DayTimeElapsed, atmAtucPerfPrev1DayLcds=atmAtucPerfPrev1DayLcds, pppoaPvcEntry=pppoaPvcEntry, atmVccTable=atmVccTable, atmIfInPkts=atmIfInPkts, atmOamVci=atmOamVci, atmQosVccAtmIfIndex=atmQosVccAtmIfIndex, atmIfTxSpeed=atmIfTxSpeed, atmOamStatCCResponderDirection=atmOamStatCCResponderDirection, atmOamStatCCActivatorCorr=atmOamStatCCActivatorCorr, atmAturPerfCurr1DayIdleCells=atmAturPerfCurr1DayIdleCells, atmOamTable=atmOamTable, atmIfOperStatus=atmIfOperStatus, pppoaPvcVci=pppoaPvcVci, atmAturPerfCurr15MinDataCells=atmAturPerfCurr15MinDataCells, atmAturPerfDataEntry=atmAturPerfDataEntry, rpoaPvcEncapsulation=rpoaPvcEncapsulation, atmIfMaxTxRate=atmIfMaxTxRate, atmVpcPortIndex=atmVpcPortIndex, atmIfIndex=atmIfIndex, atmAturPerfCurr15MinIdleCells=atmAturPerfCurr15MinIdleCells, atmAtucPerfPrev1DayDataCells=atmAtucPerfPrev1DayDataCells, atmIfInOctets=atmIfInOctets, atmOamCCEnd2EndActivation=atmOamCCEnd2EndActivation, atmOamStatCCActivatorState=atmOamStatCCActivatorState, ethoaPvcVci=ethoaPvcVci, atmQosVccOutMbs=atmQosVccOutMbs, atmAtucPerfCurr1DayIdleCells=atmAtucPerfCurr1DayIdleCells, atmAtucPerfCurr1DayLcds=atmAtucPerfCurr1DayLcds, atmVccPortIndex=atmVccPortIndex, atmOamStatTotalRdiRxCells=atmOamStatTotalRdiRxCells, atmAturPerfCurr15MinLcds=atmAturPerfCurr15MinLcds, atmIfEntry=atmIfEntry, atmOamStatFlowType=atmOamStatFlowType, atmOamStatCCActivatorDirection=atmOamStatCCActivatorDirection, atmOamStatEntry=atmOamStatEntry, atmOamStatCCResponderCorr=atmOamStatCCResponderCorr, rpoaPvcVci=rpoaPvcVci, ethoaPvcPhysAddress=ethoaPvcPhysAddress, rpoaPvcAtmIfIndex=rpoaPvcAtmIfIndex, atmVccVpi=atmVccVpi, atmOamStatAisRxCells=atmOamStatAisRxCells, ethoaPvcVpi=ethoaPvcVpi, atmAtucPerfCurr15MinLcds=atmAtucPerfCurr15MinLcds, atmQosVccService=atmQosVccService, atmAturPerfCurr15MinHecs=atmAturPerfCurr15MinHecs, atmAturPerfCurr1DayLcds=atmAturPerfCurr1DayLcds, atmVccOperStatus=atmVccOperStatus, atmOamStatLoopbackTxCells=atmOamStatLoopbackTxCells, atmAturPerfIdleCells=atmAturPerfIdleCells, ethoaPvcDescr=ethoaPvcDescr, atmIfOutPkts=atmIfOutPkts, atmAturPerfPrev1DayDataCells=atmAturPerfPrev1DayDataCells, pppoaPvcDescr=pppoaPvcDescr, atmOamAtmIfIndex=atmOamAtmIfIndex, ethoaPvcEncapsulation=ethoaPvcEncapsulation, atmAturPerfDataTable=atmAturPerfDataTable, rpoaPvcIfIndex=rpoaPvcIfIndex, atmAtucPerfCurr15MinIdleCells=atmAtucPerfCurr15MinIdleCells, atmIfOutOctets=atmIfOutOctets, atmOamStatCCTxCells=atmOamStatCCTxCells, atmAtucPerfDataEntry=atmAtucPerfDataEntry, atmOamLoopbackSegmentInterval=atmOamLoopbackSegmentInterval, atmAtucPerfDataCells=atmAtucPerfDataCells, bibo=bibo, atmIfLastChange=atmIfLastChange, atmIfOperMode=atmIfOperMode, atmOamStatRdiRxCells=atmOamStatRdiRxCells, atmOamStatTable=atmOamStatTable, atmAtucPerfDataTable=atmAtucPerfDataTable, pppoaPvcClientType=pppoaPvcClientType, atmIfOutDiscards=atmIfOutDiscards, atmOamLoopbackEnd2End=atmOamLoopbackEnd2End, atmIfType=atmIfType, atmVpcVpi=atmVpcVpi, pppoaPvcTable=pppoaPvcTable, atmOamStatAtmIfIndex=atmOamStatAtmIfIndex, atmQosVccVpi=atmQosVccVpi, atmOamCCSegmentActivation=atmOamCCSegmentActivation)

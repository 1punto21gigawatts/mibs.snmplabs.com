#
# PySNMP MIB module A3COM0420-SWITCH-EXTENSIONS (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/A3COM0420-SWITCH-EXTENSIONS
# Produced by pysmi-0.3.4 at Wed May  1 11:09:05 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
brasica2, = mibBuilder.importSymbols("A3COM0004-GENERIC", "brasica2")
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ValueSizeConstraint, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ValueSizeConstraint", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint")
ifIndex, = mibBuilder.importSymbols("IF-MIB", "ifIndex")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
TimeTicks, Gauge32, ObjectIdentity, Integer32, Counter64, MibScalar, MibTable, MibTableRow, MibTableColumn, Unsigned32, iso, Counter32, IpAddress, MibIdentifier, NotificationType, Bits, ModuleIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "TimeTicks", "Gauge32", "ObjectIdentity", "Integer32", "Counter64", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Unsigned32", "iso", "Counter32", "IpAddress", "MibIdentifier", "NotificationType", "Bits", "ModuleIdentity")
TextualConvention, MacAddress, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "MacAddress", "DisplayString")
stackConfigGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 34, 1))
prConStackFwdingMode = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 34, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("fastForward", 1), ("fragmentFree", 2), ("storeAndForward", 3), ("intelligent", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prConStackFwdingMode.setStatus('mandatory')
if mibBuilder.loadTexts: prConStackFwdingMode.setDescription("This object controls whether cut-thru is enabled on the stack. Enabling cut-through can help to minimise the delay experienced by packets before they are forwarded to their destination. Setting the mode to 'fastForward' causes frame forwarding to begin as soon as 32 bytes of the frame have been received. Setting it to 'fragmentFree' causes frame forwarding to begin when 64 bytes have been received. This is slower, but eliminates the risk of forwarding an illegally short frame to the destination port, however a valid length frame might still be forwarded even though it had a CRC error. Setting this object to 'storeAndForward' disables the cut-through completely, and frames will not be forwarded until they have been received in their entirety. When the mode is set to intelligent, the effective switching mode is set initially to fast forward. The switch then monitors the total error rate of frames received on each port, and if it exceeds, say 20 error frames a second, it changes the effective mode for the port to store and forward. If the error rate then drops to zero the effective mode is restored to fast forward. The actual error rates may differ for different switches. Whatever forwarding mode is selected, cut-through cannot operate if the destination port is currently involved in 'cut-through' from another port. In this case the device will process the frame in store and forward mode.")
prConStackPaceMode = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 34, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("normalEthernet", 2), ("lowLatency", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prConStackPaceMode.setStatus('mandatory')
if mibBuilder.loadTexts: prConStackPaceMode.setDescription('This object specifies the type of backoff algorithm used on the units in the stack. Any suitable port can use the standard ethernet algorithm or, for PACE applications, it can be set into low latency mode. In this mode, the backoff algorithm is optimised to minimise the possibility of collisions. The value of this object defines the setting that those ports will use which have prConPortPaceMode set to useDefault(2). PACE mode can be set for the whole stack or for individual ports. When a unit is initialised to factory defaults, prconPortPaceMode for every port is set to useDefault(2), and the actual setting for the port is decided by the value of this object. The manager has the choice, therefore, of varying the mode for every port in the stack, or for individual ports only.')
prConStackVLANConfigMode = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 34, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("portMode", 2), ("autoSelect", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prConStackVLANConfigMode.setStatus('mandatory')
if mibBuilder.loadTexts: prConStackVLANConfigMode.setDescription("This object specifies the VLAN mode to be used. Setting it to portMode(2) requires the user to configure each port's VLAN membership individually, whereas autoSelect(3) causes it to acquire its membership from the VLAN Server. The value of this object defines the setting that those ports will use which have prConPortVLANConfigMode set to useDefault(2). VLAN mode can be set for the whole stack or for individual ports. When a unit is initialised to factory defaults, prconPortVLANConfigMode for every port is set to useDefault(2), and the actual setting for the port is decided by the value of this object. The manager has the choice, therefore, of varying the mode for every port in the stack, or for individual ports only.")
prConStackRAPStudyPort = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 34, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prConStackRAPStudyPort.setStatus('mandatory')
if mibBuilder.loadTexts: prConStackRAPStudyPort.setDescription('This determines the ifIndex of the port a user wishes to monitor on the copy port. Monitoring causes all data from the study port to be copied to the copy port. The port is specified using its ifIndex because that uniquely identifies a single port in the stack.')
prConStackRAPCopyPort = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 34, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prConStackRAPCopyPort.setStatus('mandatory')
if mibBuilder.loadTexts: prConStackRAPCopyPort.setDescription('This is the value of ifIndex specifying the port to which data will be copied (mirrored), and must be set to a valid value, along with the study port, before monitoring can be enabled.')
prConStackRAPEnable = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 34, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prConStackRAPEnable.setStatus('mandatory')
if mibBuilder.loadTexts: prConStackRAPEnable.setDescription('This object controls the Roving Analysis Port (RAP) feature in conjunction with prConStackRAPStudyPort and prConStackRAPCopyPort. The RAP feature allows all frames sent and received on the study port to be copied to the copy port, where they can be observed. Setting this object to on(2) will enable monitoring. To succeed both prConStackRAPStudyPort and prConStackRAPCopyPort must have been set to the ifIndex values of suitable ports, and if either are invalid this operation will fail.')
prConStackBridgeMode = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 34, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("single", 1), ("multiple", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prConStackBridgeMode.setStatus('mandatory')
if mibBuilder.loadTexts: prConStackBridgeMode.setDescription('The value of this object determines whether the switch is to operate as a single bridge or as a bridge per VLAN (the default). In multiple bridge mode the switch maintains a separate filtering database for each VLAN, whereas in single bridge mode it uses a single database for them all. Thus in multiple bridge mode the MAC address of a station can be learnt on more than one port provided they are in separate VLANs, while in single bridge mode the switch makes just one entry for each address. Multiple bridge mode is useful in that separate VLANs may be joined by a bridge external to the switch, whereas in single bridge mode VLANs may only be connected by routers. Not all switches will support both modes, and any attempt to set the mode to an unsupported value will be rejected. Note: This object only applies to bridges operating in the dot1Qmode.')
prConStackIpTos = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 34, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("enable", 2), ("disable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prConStackIpTos.setStatus('mandatory')
if mibBuilder.loadTexts: prConStackIpTos.setDescription("This object is used to enable the classification of packets based upon the value of their IPToS field. When enabled, the packet's Traffic Classification will be derived from both the 802.1D user_priority and the IPToS field. Where the two methods indicate different Traffic Classifications, then higher of the two will be selected. Each device will only support the enumerations that are applicable to that device. Attempting to set the object to a non-supported mode will be rejected.")
prConStackPktRateControl = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 34, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("notApplicable", 1), ("disable", 2), ("limitUnknownDAs", 3), ("limitMcasts", 4), ("limitMcastsAndUnknownDAs", 5), ("limitBcasts", 6), ("limitBcastsAndUnknownDAs", 7), ("limitBcastsAndMcasts", 8), ("limitBcastsMcastsAndUnknownDAs", 9)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prConStackPktRateControl.setStatus('mandatory')
if mibBuilder.loadTexts: prConStackPktRateControl.setDescription('This object controls whether the packet rate control feature is enabled or disabled. Products which do not support this feature will return notApplicable(1) and reject any attempt to set it to a different value. When set to disable(2) the switch will not perform any rate limiting. If set to any of the remaining values the switch will monitor the throughput of the specified type(s) of frame and discard some if necessary to reduce the throughput to the amount specified by the value of prConStackPktRateLimit. The enumerations select which types of packet are to be rate limited as follows:- limitUnknownDAs(3) Unicast Frames with a destination address not in the filtering database limitMcasts(4) Multicasts limitMcastsAndUnknownDAs(5) Multicasts, and unicasts with unknown destination addresses limitBcasts(6) Broadcasts limitBcastsAndUnknownDAs(7) Broadcasts, and unicasts with unknown destination addresses limitMcastsAndBcasts(8) Multicasts and Broadcasts limitMcastsBcastsAndUnknownDAs(9) All the above types of frame')
prConStackPktRateLimit = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 34, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 262143))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prConStackPktRateLimit.setStatus('mandatory')
if mibBuilder.loadTexts: prConStackPktRateLimit.setDescription('This object specifies the maximum rate at which the selected types of packet may be received from a port before excess packets are discarded. The limit is specified in packets per second. To assist in calculating a suitable limit, note that the absolute maximum transmission rates of packets on an ethernet network is 10Mbps: 14880 and 100Mbps: 148800')
prConStackStpProtocolVersion = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 34, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2))).clone(namedValues=NamedValues(("stpVersion0", 0), ("rstpVersion2", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prConStackStpProtocolVersion.setStatus('mandatory')
if mibBuilder.loadTexts: prConStackStpProtocolVersion.setDescription('The version of the Spanning Tree Protocol that is to be used by this Bridge. stpVersion0(0) The original version of Spanning Tree, defined by IEEE Std. 802.1D-1998. stpVersion2(2) The Rapid Spanning Tree Protocol, defined by IEEE Std. 802.1w.')
prConStackStpPathCostDefault = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 34, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("stp8021d1998", 1), ("stp8021t2000", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prConStackStpPathCostDefault.setStatus('mandatory')
if mibBuilder.loadTexts: prConStackStpPathCostDefault.setDescription('The version of the Spanning Tree default Path Costs that are to be used by this Bridge. stp8021d1998(1) Path Costs from IEEE Std. 802.1D-1998. stp8021t2000(2) Path Costs from IEEE Std. 802.1t-2000.')
prConStackLacpOperInfo = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 34, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notOperational", 1), ("operational", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prConStackLacpOperInfo.setStatus('mandatory')
if mibBuilder.loadTexts: prConStackLacpOperInfo.setDescription("This object shall contain a value indicating that LACP is operational, or not operational. If not operational, all units need to be upgraded to the latest agent version. For example, this value shall be set to 'not operational' if any unit in the stack does not have the capability to support LACP.")
switchConfigGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 34, 2))
prConfigPortTable = MibTable((1, 3, 6, 1, 4, 1, 43, 10, 34, 2, 1), )
if mibBuilder.loadTexts: prConfigPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: prConfigPortTable.setDescription('Table providing configuration information about a port on a Switch unit.')
prConfigPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 10, 34, 2, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: prConfigPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prConfigPortEntry.setDescription('Configuration options for a single port.')
prConPortVLANConfigMode = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 34, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("useDefault", 2), ("portMode", 3), ("autoSelect", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prConPortVLANConfigMode.setStatus('mandatory')
if mibBuilder.loadTexts: prConPortVLANConfigMode.setDescription("This object specifies the VLAN mode to be used. Setting it to portMode(3) requires the user to configure the port's VLAN membership explicitly, whereas autoSelect(4) causes it to acquire its membership from the VLAN Server. VLAN mode can be set for the whole stack or for individual ports. When a unit is initialised to factory defaults, prConPortVLANConfigMode for every port is set to useDefault(2), and the actual setting for the port is decided by the value of prConStackVLANConfigMode. The other values of this object allow the setting to be varied for the individual port.")
prConPortIFM = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 34, 2, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("notApplicable", 1), ("off", 2), ("maxJams6", 3), ("maxJams7", 4), ("maxJams8", 5), ("maxJams9", 6), ("maxJams10", 7), ("maxJams11", 8), ("maxJams12", 9), ("maxJams13", 10)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prConPortIFM.setStatus('mandatory')
if mibBuilder.loadTexts: prConPortIFM.setDescription('This object controls Intelligent Flow Management for the port, which specifies what action the port takes whenever it is unable to receive a packet because its buffers are full. When set to off(2), the packet is dropped immediately. If it is set to any of the values maxJams6(3) to maxJams13(10), a jam signal is transmitted to the segment attached to the port to force a collision so that the originator will stop and retransmit the frame. This will be repeated a maximum of 6 to 13 times depending on the setting. If the port is then still unable to receive the packet it is dropped. Intelligent Flow Management should be disabled on ports which are connected to ree Rapid Spanning Tree Protocol, defined by IEEE Std. 802.1w.')
prConPortLacp = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 34, 2, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prConPortLacp.setStatus('mandatory')
if mibBuilder.loadTexts: prConPortLacp.setDescription('This object specifies whether a port will use LACP. When enabled LACP will be active on the port. When disabled LACP will cease this may cause a port to be taken out of an aggregation.')
prConPortStpAdminPathCost = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 34, 2, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 200000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prConPortStpAdminPathCost.setStatus('mandatory')
if mibBuilder.loadTexts: prConPortStpAdminPathCost.setDescription("The administratively assigned value of the path cost for this port. The contribution of this port to the path cost of paths towards the spanning tree root which include this port. 802.1D-1990 recommends that the default value of this parameter be in inverse proportion to the speed of the attached LAN. This is similar to the dot1dStpPortPathCost MIB item, except that writing a value of '0' assigns the port to use the automatically calculated default Path Cost value. If the default Path Cost is being used, this item returns '0'.")
prConPortCascadeMode = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 34, 2, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prConPortCascadeMode.setStatus('mandatory')
if mibBuilder.loadTexts: prConPortCascadeMode.setDescription('This object specifies whether the port is a cascade port or not. If enabled, the port is operating as a cascade port. If disabled, the port is not operating as a cascade port.')
prConPortFdbTable = MibTable((1, 3, 6, 1, 4, 1, 43, 10, 34, 2, 2), )
if mibBuilder.loadTexts: prConPortFdbTable.setStatus('mandatory')
if mibBuilder.loadTexts: prConPortFdbTable.setDescription('This table provides the same information as that held in the dot1qTpFdbTable in the Bridge Extension MIB.')
prConPortFdbEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 10, 34, 2, 2, 1), ).setIndexNames((0, "A3COM0420-SWITCH-EXTENSIONS", "prConPortFdbPort"), (0, "A3COM0420-SWITCH-EXTENSIONS", "prConPortFdbId"), (0, "A3COM0420-SWITCH-EXTENSIONS", "prConPortFdbAddress"))
if mibBuilder.loadTexts: prConPortFdbEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prConPortFdbEntry.setDescription('Information about a specific unicast MAC address.')
prConPortFdbPort = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 34, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: prConPortFdbPort.setStatus('mandatory')
if mibBuilder.loadTexts: prConPortFdbPort.setDescription('This contains the port number that this address has been seen on. It is similar to dot1qTpFdbPort in the Bridge Extensions MIB but may not be the value zero.')
prConPortFdbId = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 34, 2, 2, 1, 2), Integer32())
if mibBuilder.loadTexts: prConPortFdbId.setStatus('mandatory')
if mibBuilder.loadTexts: prConPortFdbId.setDescription('The identity of this filtering database. This shall have the same value as is defined for dot1qFdbId in the bridge MIB extensions MIB.')
prConPortFdbAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 34, 2, 2, 1, 3), MacAddress())
if mibBuilder.loadTexts: prConPortFdbAddress.setStatus('mandatory')
if mibBuilder.loadTexts: prConPortFdbAddress.setDescription('This object contains the unicast MAC address of the entry. This contains the same value as dot1qTpFdbAddress in the Bridge Extensions MIB.')
prConPortFdbStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 34, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("invalid", 2), ("learned", 3), ("self", 4), ("mgmt", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prConPortFdbStatus.setStatus('mandatory')
if mibBuilder.loadTexts: prConPortFdbStatus.setDescription('This contains the same information as dot1qTpFdbStatus in the Bridge Extensions MIB.')
prConTrunkMulticastTable = MibTable((1, 3, 6, 1, 4, 1, 43, 10, 34, 2, 3), )
if mibBuilder.loadTexts: prConTrunkMulticastTable.setStatus('mandatory')
if mibBuilder.loadTexts: prConTrunkMulticastTable.setDescription('Table for distributing multicast addresses on trunks across a stack.')
prConTrunkMulticastEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 10, 34, 2, 3, 1), ).setIndexNames((0, "A3COM0420-SWITCH-EXTENSIONS", "prConTrunkMulticastFdbId"), (0, "A3COM0420-SWITCH-EXTENSIONS", "prConTrunkMulticastAddress"))
if mibBuilder.loadTexts: prConTrunkMulticastEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prConTrunkMulticastEntry.setDescription('Information associated with a single multicast entry.')
prConTrunkMulticastFdbId = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 34, 2, 3, 1, 1), Integer32())
if mibBuilder.loadTexts: prConTrunkMulticastFdbId.setStatus('mandatory')
if mibBuilder.loadTexts: prConTrunkMulticastFdbId.setDescription('The identity of the filtering database. This contains the same value as dot1qFdbId in the Bridge Extensions MIB.')
prConTrunkMulticastAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 34, 2, 3, 1, 2), MacAddress())
if mibBuilder.loadTexts: prConTrunkMulticastAddress.setStatus('mandatory')
if mibBuilder.loadTexts: prConTrunkMulticastAddress.setDescription('This object contains the multicast MAC address of the entry. This contains the same value as the dot1qTpGroupAddress in the Bridge Extensions MIB')
prConTrunkMulticastPortlist = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 34, 2, 3, 1, 3), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prConTrunkMulticastPortlist.setStatus('mandatory')
if mibBuilder.loadTexts: prConTrunkMulticastPortlist.setDescription("The set of trunk ports to which frames destined for this multicast address should be forwarded. Each octet within the value of this object specifies a set or eight trunk ports, with the first octet specifiying trunk ports 1 through 8, the second octet specifying ports 9 through 16, etc. Within each octet the most significant bit represents the lowest numbered port, and the least significant bit represents the highest numbered port. Thus, each trunk port is represented by a single bit within the value of this object. If that bit has a value of '1' then that trunk port is included in the set of ports; the trunk port is not included if its bit has a value of '0'. The default value of this object is a string of ones of appropriate length.")
prConTrunkMulticastStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 34, 2, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("invalid", 2), ("permanent", 3), ("deleteOnReset", 4), ("deleteOnTimeout", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prConTrunkMulticastStatus.setStatus('mandatory')
if mibBuilder.loadTexts: prConTrunkMulticastStatus.setDescription('This object specifies the status of the entry. The default value is other(1). This object contains the same information as dot1dStaticStatus in RFC1493.')
prConTrunkMulticastType = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 34, 2, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("invalid", 2), ("learned", 3), ("self", 4), ("mgmt", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prConTrunkMulticastType.setStatus('mandatory')
if mibBuilder.loadTexts: prConTrunkMulticastType.setDescription('This object contains the same information as dot1qTpFdbStatus in the Bridge Extensions MIB.')
prConTrunkMulticastRobp = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 34, 2, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prConTrunkMulticastRobp.setStatus('mandatory')
if mibBuilder.loadTexts: prConTrunkMulticastRobp.setDescription('This object contains the Receive on Blocked port setting.')
prConIfIndexTable = MibTable((1, 3, 6, 1, 4, 1, 43, 10, 34, 2, 4), )
if mibBuilder.loadTexts: prConIfIndexTable.setStatus('mandatory')
if mibBuilder.loadTexts: prConIfIndexTable.setDescription('Table for translating between unit.port and ifIndex or bridge port number.')
prConIfIndexEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 10, 34, 2, 4, 1), ).setIndexNames((0, "A3COM0420-SWITCH-EXTENSIONS", "prConIfIndexGroupIndex"), (0, "A3COM0420-SWITCH-EXTENSIONS", "prConIfIndexPortIndex"))
if mibBuilder.loadTexts: prConIfIndexEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prConIfIndexEntry.setDescription('The IfIndex and bridge port number associated with a port entry.')
prConIfIndexGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 34, 2, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024)))
if mibBuilder.loadTexts: prConIfIndexGroupIndex.setStatus('mandatory')
if mibBuilder.loadTexts: prConIfIndexGroupIndex.setDescription('This object identifies the group, unit or blade containing the port for which this entry contains information.')
prConIfIndexPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 34, 2, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024)))
if mibBuilder.loadTexts: prConIfIndexPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: prConIfIndexPortIndex.setDescription('This object identifies the port within the group for which this entry contains information.')
prConIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 34, 2, 4, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prConIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: prConIfIndex.setDescription('This object contains the corresponding ifIndex value.')
prConIfIndexBridgePort = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 34, 2, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prConIfIndexBridgePort.setStatus('mandatory')
if mibBuilder.loadTexts: prConIfIndexBridgePort.setDescription('The corresponding bridge port number, which is the number of the port as defined by RFC1493. If a port is a member of an aggregation, the value will be that of the aggregation rather than the port itself.')
prConfigAggTable = MibTable((1, 3, 6, 1, 4, 1, 43, 10, 34, 2, 5), )
if mibBuilder.loadTexts: prConfigAggTable.setStatus('mandatory')
if mibBuilder.loadTexts: prConfigAggTable.setDescription('Table providing configuration information about an aggregation on a Switch unit.')
prConfigAggEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 10, 34, 2, 5, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: prConfigAggEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prConfigAggEntry.setDescription('Configuration information for a single aggregation.')
prConfigAggStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 34, 2, 5, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unused", 1), ("autoInUse", 2), ("autoAgeing", 3), ("autoReusable", 4), ("manual", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prConfigAggStatus.setStatus('mandatory')
if mibBuilder.loadTexts: prConfigAggStatus.setDescription('This object specifies the aggregation status. The status is indicated as follows: unused(1) the aggregation is not presently in use. autoInUse(2) the aggregation was selected as a result of receiving LACP Partner ID information from a remote partner, and currently has ports. autoAgeing(3) the aggregation was selected as a result of receiving LACP Partner ID information from a remote partner, and is currently within its ageing timeout period (typically 10 minutes). autoReusable(4) the aggregation was selected as a result of receiving LACP Partner ID information from a remote partner, and its ageing timeout period (typically 10 minutes) has expired. manual(5) the aggregation was pre-configured using administrative Partner ID information.')
mibBuilder.exportSymbols("A3COM0420-SWITCH-EXTENSIONS", prConTrunkMulticastPortlist=prConTrunkMulticastPortlist, prConPortFdbTable=prConPortFdbTable, prConStackPaceMode=prConStackPaceMode, prConTrunkMulticastEntry=prConTrunkMulticastEntry, prConPortVLANConfigMode=prConPortVLANConfigMode, prConStackRAPCopyPort=prConStackRAPCopyPort, prConPortFdbEntry=prConPortFdbEntry, prConIfIndexEntry=prConIfIndexEntry, prConPortLacp=prConPortLacp, prConStackRAPEnable=prConStackRAPEnable, prConPortStpAdminPathCost=prConPortStpAdminPathCost, prConfigAggStatus=prConfigAggStatus, prConStackPktRateControl=prConStackPktRateControl, prConTrunkMulticastRobp=prConTrunkMulticastRobp, prConStackFwdingMode=prConStackFwdingMode, prConfigAggEntry=prConfigAggEntry, prConStackPktRateLimit=prConStackPktRateLimit, switchConfigGroup=switchConfigGroup, prConStackIpTos=prConStackIpTos, prConPortFdbAddress=prConPortFdbAddress, prConTrunkMulticastFdbId=prConTrunkMulticastFdbId, prConIfIndexTable=prConIfIndexTable, prConIfIndex=prConIfIndex, prConPortIFM=prConPortIFM, prConTrunkMulticastAddress=prConTrunkMulticastAddress, prConfigPortTable=prConfigPortTable, prConStackStpPathCostDefault=prConStackStpPathCostDefault, prConTrunkMulticastStatus=prConTrunkMulticastStatus, prConStackRAPStudyPort=prConStackRAPStudyPort, prConPortCascadeMode=prConPortCascadeMode, prConPortFdbId=prConPortFdbId, prConIfIndexPortIndex=prConIfIndexPortIndex, stackConfigGroup=stackConfigGroup, prConIfIndexGroupIndex=prConIfIndexGroupIndex, prConPortFdbPort=prConPortFdbPort, prConTrunkMulticastType=prConTrunkMulticastType, prConfigAggTable=prConfigAggTable, prConStackBridgeMode=prConStackBridgeMode, prConStackLacpOperInfo=prConStackLacpOperInfo, prConTrunkMulticastTable=prConTrunkMulticastTable, prConStackStpProtocolVersion=prConStackStpProtocolVersion, prConPortFdbStatus=prConPortFdbStatus, prConStackVLANConfigMode=prConStackVLANConfigMode, prConfigPortEntry=prConfigPortEntry, prConIfIndexBridgePort=prConIfIndexBridgePort)

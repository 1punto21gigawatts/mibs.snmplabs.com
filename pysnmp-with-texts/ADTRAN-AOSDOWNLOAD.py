#
# PySNMP MIB module ADTRAN-AOSDOWNLOAD (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/ADTRAN-AOSDOWNLOAD
# Produced by pysmi-0.3.4 at Wed May  1 11:14:21 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
adGenAOSCommon, adGenAOSConformance = mibBuilder.importSymbols("ADTRAN-AOS", "adGenAOSCommon", "adGenAOSConformance")
adIdentity, = mibBuilder.importSymbols("ADTRAN-MIB", "adIdentity")
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ValueRangeConstraint, SingleValueConstraint, ConstraintsIntersection, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsIntersection", "ConstraintsUnion")
ModuleCompliance, ObjectGroup, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "ObjectGroup", "NotificationGroup")
Integer32, NotificationType, iso, ObjectIdentity, MibIdentifier, Unsigned32, Gauge32, ModuleIdentity, IpAddress, Counter64, MibScalar, MibTable, MibTableRow, MibTableColumn, Bits, TimeTicks, Counter32 = mibBuilder.importSymbols("SNMPv2-SMI", "Integer32", "NotificationType", "iso", "ObjectIdentity", "MibIdentifier", "Unsigned32", "Gauge32", "ModuleIdentity", "IpAddress", "Counter64", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Bits", "TimeTicks", "Counter32")
TextualConvention, DisplayString, RowStatus, TDomain, TAddress = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString", "RowStatus", "TDomain", "TAddress")
adAOSDownloadMib = ModuleIdentity((1, 3, 6, 1, 4, 1, 664, 6, 10000, 53, 1, 3))
adAOSDownloadMib.setRevisions(('2004-09-21 22:16',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: adAOSDownloadMib.setRevisionsDescriptions(('Initial version of this MIB module.',))
if mibBuilder.loadTexts: adAOSDownloadMib.setLastUpdated('200409212216Z')
if mibBuilder.loadTexts: adAOSDownloadMib.setOrganization('ADTRAN, Inc.')
if mibBuilder.loadTexts: adAOSDownloadMib.setContactInfo(' Technical Support Dept. Postal: ADTRAN, Inc. 901 Explorer Blvd. Huntsville, AL 35806 Tel: +1 800 726-8663 Fax: +1 256 963 6217 E-mail: support@adtran.com')
if mibBuilder.loadTexts: adAOSDownloadMib.setDescription('This MIB defines how the method for commanding an ADTRAN OS device to initiate a download or upload of configuration or firmware from a TFTP server ')
adAOSDownload = MibIdentifier((1, 3, 6, 1, 4, 1, 664, 5, 53, 1, 3))
adAOSDownloadTable = MibTable((1, 3, 6, 1, 4, 1, 664, 5, 53, 1, 3, 1), )
if mibBuilder.loadTexts: adAOSDownloadTable.setStatus('current')
if mibBuilder.loadTexts: adAOSDownloadTable.setDescription('A table of firmware downloads to this device. There will at any time be either 0 or 1 rows in this table, and the only valid index for this table is 1. It is only a table so that we may take advantage of the RowStatus textual convention for configuring the download parameters.')
adAOSDownloadEntry = MibTableRow((1, 3, 6, 1, 4, 1, 664, 5, 53, 1, 3, 1, 1), ).setIndexNames((0, "ADTRAN-AOSDOWNLOAD", "adAOSDownloadIndex"))
if mibBuilder.loadTexts: adAOSDownloadEntry.setStatus('current')
if mibBuilder.loadTexts: adAOSDownloadEntry.setDescription('The row in the adAOSDownloadTable containing the download parameters.')
adAOSDownloadIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 664, 5, 53, 1, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("dlInstance", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: adAOSDownloadIndex.setStatus('current')
if mibBuilder.loadTexts: adAOSDownloadIndex.setDescription('The index which uniquely identifies this row. The only legal value for this object is 1.')
adAOSDownloadOwnerAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 664, 5, 53, 1, 3, 1, 1, 2), TAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: adAOSDownloadOwnerAddress.setStatus('current')
if mibBuilder.loadTexts: adAOSDownloadOwnerAddress.setDescription('The transport address of the management station that initiated this download attempt, formatted according to the value of the associated instance of adAOSDownloadOwnerDomain.')
adAOSDownloadOwnerDomain = MibTableColumn((1, 3, 6, 1, 4, 1, 664, 5, 53, 1, 3, 1, 1, 3), TDomain()).setMaxAccess("readonly")
if mibBuilder.loadTexts: adAOSDownloadOwnerDomain.setStatus('current')
if mibBuilder.loadTexts: adAOSDownloadOwnerDomain.setDescription('The kind of transport service used by the management station that initiated this download attempt.')
adAOSDownloadTAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 664, 5, 53, 1, 3, 1, 1, 4), TAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: adAOSDownloadTAddress.setStatus('current')
if mibBuilder.loadTexts: adAOSDownloadTAddress.setDescription("The transport address of the node to download firmware from, formatted according to the value of the associated instance of adAOSDownloadTDomain. An attempt to modify this value will fail if the associated adAOSDownloadStatus object would be equal to 'active' both before and after the modification attempt.")
adAOSDownloadTDomain = MibTableColumn((1, 3, 6, 1, 4, 1, 664, 5, 53, 1, 3, 1, 1, 5), TDomain()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: adAOSDownloadTDomain.setStatus('current')
if mibBuilder.loadTexts: adAOSDownloadTDomain.setDescription("The kind of transport service to be used for the download. Currently supports snmpUDPDomain and snmpIPXDomain. An attempt to modify this value will fail if the associated adAOSDownloadStatus object would be equal to 'active' both before and after the modification attempt.")
adAOSDownloadFilename = MibTableColumn((1, 3, 6, 1, 4, 1, 664, 5, 53, 1, 3, 1, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: adAOSDownloadFilename.setStatus('current')
if mibBuilder.loadTexts: adAOSDownloadFilename.setDescription("Filename and path of file to download (maximum length of 63 characters + NULL). An attempt to modify this value will fail if the associated adAOSDownloadStatus object would be equal to 'active' both before and after the modification attempt.")
adAOSDownloadResetType = MibTableColumn((1, 3, 6, 1, 4, 1, 664, 5, 53, 1, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noReset", 1), ("warmReset", 2), ("factoryReset", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: adAOSDownloadResetType.setStatus('current')
if mibBuilder.loadTexts: adAOSDownloadResetType.setDescription('The type of reset to perform after completion of the firmware download. Note that not all agents will support all possible values, and there may be other agent-specific values for this object.')
adAOSDownloadErrorStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 664, 5, 53, 1, 3, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21))).clone(namedValues=NamedValues(("fileNotFound", 1), ("accessViolation", 2), ("diskFull", 3), ("illegalOperation", 4), ("unknownTID", 5), ("fileExists", 6), ("noSuchUser", 7), ("notDefined", 8), ("corruptFile", 9), ("noServer", 10), ("tftpTimeout", 11), ("hardwareError", 12), ("success", 13), ("aborted", 14), ("inProgress", 15), ("idle", 16), ("erasingEeprom", 17), ("incompleteFirmware", 18), ("requirePowerCycle", 19), ("cannotUpgrade", 20), ("cannotDowngrade", 21)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: adAOSDownloadErrorStatus.setStatus('current')
if mibBuilder.loadTexts: adAOSDownloadErrorStatus.setDescription("Status of download. The first seven codes are equal to the codes defined by the TFTP protocol. 'notDefined' is the same as TFTP protocol error 0. The following are the other possible values for this object: corruptFile - the agent detected a problem with the download file format. noServer - the TFTP server at adAOSDownloadTAddress did not respond to the TFTP request. tftpTimeout - the download was aborted due to excessive timeouts. hardwareError - there was a hardware problem on the agent that forced an abort of the download (see adAOSDownloadErrorText for more detailed information). success - the download has completed successfully. aborted - the download was aborted by setting the adAOSDownloadStatus to 'notInService' or 'delete'. inProgress - the TFTP transfer is currently active. idle - means that the download has not yet started (i.e. the value of adAOSDownloadStatus has not yet been set to 'active'). erasingEeprom - the agent is currently erasing the EEPROM device. incompleteFirmware - the agent is running an incomplete version of firmware and requires a download. requirePowerCycle - the agent must be power cycled to run the newly downloaded firmware. cannotUpgrade - the agent's current firmware revision cannot be upgraded to the revision in the download file. cannotDowngrade - the agent's current firmware revision cannot be downgraded to the revision in the download file.")
adAOSDownloadErrorText = MibTableColumn((1, 3, 6, 1, 4, 1, 664, 5, 53, 1, 3, 1, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: adAOSDownloadErrorText.setStatus('current')
if mibBuilder.loadTexts: adAOSDownloadErrorText.setDescription('A textual description of the current error status of the firmware download.')
adAOSDownloadStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 664, 5, 53, 1, 3, 1, 1, 10), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: adAOSDownloadStatus.setStatus('current')
if mibBuilder.loadTexts: adAOSDownloadStatus.setDescription("The status of this download entry. This object may not be set to 'active' unless the following columnar objects exist in this row: adAOSDownloadTAddress, adAOSDownloadTDomain, adAOSDownloadFilename, and adAOSDownloadResetType.")
adAOSDownloadPassesLeft = MibTableColumn((1, 3, 6, 1, 4, 1, 664, 5, 53, 1, 3, 1, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: adAOSDownloadPassesLeft.setStatus('current')
if mibBuilder.loadTexts: adAOSDownloadPassesLeft.setDescription("The number of passes remaining in the current download attempt. Some agents require multiple passes through the download file in order to download a firmware image. This object indicates the number of passes remaining, including the current pass. The object is initialized by the agent to the number of passes required to complete the download when the corresponding instance of adAOSDownloadStatus is set to 'active'. It is decremented by one each time a pass completes.")
adAOSDownloadOctetCount = MibTableColumn((1, 3, 6, 1, 4, 1, 664, 5, 53, 1, 3, 1, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: adAOSDownloadOctetCount.setStatus('current')
if mibBuilder.loadTexts: adAOSDownloadOctetCount.setDescription("The number of octets that have been transferred during the current pass. This object is initialized to zero by the agent when the corresponding instance of adAOSDownloadStatus is set to 'active', and reinitialized to zero at the beginning of each pass.")
adAOSDownloadDestination = MibTableColumn((1, 3, 6, 1, 4, 1, 664, 5, 53, 1, 3, 1, 1, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 63)).clone('/os/primary')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: adAOSDownloadDestination.setStatus('deprecated')
if mibBuilder.loadTexts: adAOSDownloadDestination.setDescription("The destination of the download file. The allowable destination names depend on the type of agent being downloaded. In all cases, a destination of '/os/primary' or '/os/secondary' indicates that this is a download of the agent's firmware image. The agent will use '/os/primary' as the default value for this object when the row is created. ICF router agents also allow a download of a config file. Currently, the name of the config file on the agent is '/config'. An agent should reject an attempt to set this object to a destination name that does not make sense for this type of agent.")
adAOSDownloadDestinationType = MibTableColumn((1, 3, 6, 1, 4, 1, 664, 5, 53, 1, 3, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("primary", 1), ("secondary", 2), ("config", 3), ("remote", 4), ("other", 5))).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: adAOSDownloadDestinationType.setStatus('current')
if mibBuilder.loadTexts: adAOSDownloadDestinationType.setDescription("The destination of the download file. The allowable destination names depend on the type of agent being downloaded. In all cases, a destination of 'primary(1)' or 'secondary(2)' indicates that this is a download of the agent's firmware image. The agent will use 'primary(1)' as the default value for this object when the row is created. ICF router agents also allow a download of a config file. Currently, the name of the config file on the agent is 'config(3)'. ICF router agents also allow a download of a file to a remote server. A destination of 'remote(4)' indicates that this is a download to a remote server. An agent should reject an attempt to set this object to a destination name that does not make sense for this type of agent.")
adAOSDownloadLogMaxSize = MibScalar((1, 3, 6, 1, 4, 1, 664, 5, 53, 1, 3, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: adAOSDownloadLogMaxSize.setStatus('current')
if mibBuilder.loadTexts: adAOSDownloadLogMaxSize.setDescription('The maximum number of the download log entries supported by this agent. Note that 0 is a legal value for this variable.')
adAOSDownloadLogSize = MibScalar((1, 3, 6, 1, 4, 1, 664, 5, 53, 1, 3, 3), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: adAOSDownloadLogSize.setStatus('current')
if mibBuilder.loadTexts: adAOSDownloadLogSize.setDescription('The number of download log entries currently in the adAOSDownloadLogTable.')
adAOSDownloadLogTable = MibTable((1, 3, 6, 1, 4, 1, 664, 5, 53, 1, 3, 4), )
if mibBuilder.loadTexts: adAOSDownloadLogTable.setStatus('current')
if mibBuilder.loadTexts: adAOSDownloadLogTable.setDescription('A log of the adAOSDownloadSize most recent download attempts to this device. The first entry in the table is the oldest.')
adAOSDownloadLogEntry = MibTableRow((1, 3, 6, 1, 4, 1, 664, 5, 53, 1, 3, 4, 1), ).setIndexNames((0, "ADTRAN-AOSDOWNLOAD", "adAOSDlLogIndex"))
if mibBuilder.loadTexts: adAOSDownloadLogEntry.setStatus('current')
if mibBuilder.loadTexts: adAOSDownloadLogEntry.setDescription('An entry in the adAOSDownloadLogTable containing information about a single download attempt.')
adAOSDlLogIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 664, 5, 53, 1, 3, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: adAOSDlLogIndex.setStatus('current')
if mibBuilder.loadTexts: adAOSDlLogIndex.setDescription('The index of this entry in the download log table. Index 1 will always contain the oldest entry. If the table is full when a download attempt is made, the new entry becomes the last entry (adAOSDownloadLogMaxSize), and all earlier entries are shifted down by one entry, removing the old index 1.')
adAOSDlLogOwnerAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 664, 5, 53, 1, 3, 4, 1, 2), TAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: adAOSDlLogOwnerAddress.setStatus('current')
if mibBuilder.loadTexts: adAOSDlLogOwnerAddress.setDescription('The transport address of the management station that attempted to initiate a download of this device, formatted according to the value of adAOSDlLastOwnerDomain.')
adAOSDlLogOwnerDomain = MibTableColumn((1, 3, 6, 1, 4, 1, 664, 5, 53, 1, 3, 4, 1, 3), TDomain()).setMaxAccess("readonly")
if mibBuilder.loadTexts: adAOSDlLogOwnerDomain.setStatus('current')
if mibBuilder.loadTexts: adAOSDlLogOwnerDomain.setDescription('The kind of transport service used by the management station that attempted to initiate a download of this device.')
adAOSDlLogTAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 664, 5, 53, 1, 3, 4, 1, 4), TAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: adAOSDlLogTAddress.setStatus('current')
if mibBuilder.loadTexts: adAOSDlLogTAddress.setDescription('The transport address of the node from which this device attempted to download firmware, formatted according to the value of adAOSDlLastTDomain.')
adAOSDlLogTDomain = MibTableColumn((1, 3, 6, 1, 4, 1, 664, 5, 53, 1, 3, 4, 1, 5), TDomain()).setMaxAccess("readonly")
if mibBuilder.loadTexts: adAOSDlLogTDomain.setStatus('current')
if mibBuilder.loadTexts: adAOSDlLogTDomain.setDescription('The kind of transport service which was used for the attempt to download firmware to this device.')
adAOSDlLogFilename = MibTableColumn((1, 3, 6, 1, 4, 1, 664, 5, 53, 1, 3, 4, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: adAOSDlLogFilename.setStatus('current')
if mibBuilder.loadTexts: adAOSDlLogFilename.setDescription('The filename from which this device attempted to download firmware.')
adAOSDlLogResetType = MibTableColumn((1, 3, 6, 1, 4, 1, 664, 5, 53, 1, 3, 4, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noReset", 1), ("warmReset", 2), ("factoryReset", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: adAOSDlLogResetType.setStatus('current')
if mibBuilder.loadTexts: adAOSDlLogResetType.setDescription('The type of reset requested to be performed after completion of the firmware download attempt.')
adAOSDlLogErrorStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 664, 5, 53, 1, 3, 4, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14))).clone(namedValues=NamedValues(("fileNotFound", 1), ("accessViolation", 2), ("diskFull", 3), ("illegalOperation", 4), ("unknownTID", 5), ("fileExists", 6), ("noSuchUser", 7), ("notDefined", 8), ("corruptFile", 9), ("noServer", 10), ("tftpTimeout", 11), ("hardwareError", 12), ("success", 13), ("aborted", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: adAOSDlLogErrorStatus.setStatus('current')
if mibBuilder.loadTexts: adAOSDlLogErrorStatus.setDescription('The result of the attempt to download firmware to this device. The values are the same as the corresponding values of adAOSDownloadErrorStatus.')
adAOSDlLogErrorText = MibTableColumn((1, 3, 6, 1, 4, 1, 664, 5, 53, 1, 3, 4, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: adAOSDlLogErrorText.setStatus('current')
if mibBuilder.loadTexts: adAOSDlLogErrorText.setDescription('A textual description of the final error status of the attempt to download firmware to this device.')
adAOSDownloadConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 664, 5, 53, 99, 3))
adAOSDownloadCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 664, 5, 53, 99, 3, 1))
adAOSDownloadGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 664, 5, 53, 99, 3, 2))
adAOSDownloadConfigCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 664, 5, 53, 99, 3, 1, 1)).setObjects(("ADTRAN-AOSDOWNLOAD", "adAOSDownloadConfigGroup"), ("ADTRAN-AOSDOWNLOAD", "adAOSDownloadLogGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    adAOSDownloadConfigCompliance = adAOSDownloadConfigCompliance.setStatus('current')
if mibBuilder.loadTexts: adAOSDownloadConfigCompliance.setDescription('New version of the compliance statement for network downloadable devices that allows for monitoring in-progress downloads and for directing a download to different destinations on the device.')
adAOSDownloadLogGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 664, 5, 53, 99, 3, 2, 1)).setObjects(("ADTRAN-AOSDOWNLOAD", "adAOSDlLogIndex"), ("ADTRAN-AOSDOWNLOAD", "adAOSDlLogOwnerAddress"), ("ADTRAN-AOSDOWNLOAD", "adAOSDlLogOwnerDomain"), ("ADTRAN-AOSDOWNLOAD", "adAOSDlLogTAddress"), ("ADTRAN-AOSDOWNLOAD", "adAOSDlLogTDomain"), ("ADTRAN-AOSDOWNLOAD", "adAOSDlLogFilename"), ("ADTRAN-AOSDOWNLOAD", "adAOSDlLogResetType"), ("ADTRAN-AOSDOWNLOAD", "adAOSDlLogErrorStatus"), ("ADTRAN-AOSDOWNLOAD", "adAOSDlLogErrorText"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    adAOSDownloadLogGroup = adAOSDownloadLogGroup.setStatus('current')
if mibBuilder.loadTexts: adAOSDownloadLogGroup.setDescription('A collection of objects for maintaining a log of network download attempts to ICF devices.')
adAOSDownloadConfigGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 664, 5, 53, 99, 3, 2, 2)).setObjects(("ADTRAN-AOSDOWNLOAD", "adAOSDownloadIndex"), ("ADTRAN-AOSDOWNLOAD", "adAOSDownloadOwnerAddress"), ("ADTRAN-AOSDOWNLOAD", "adAOSDownloadOwnerDomain"), ("ADTRAN-AOSDOWNLOAD", "adAOSDownloadTAddress"), ("ADTRAN-AOSDOWNLOAD", "adAOSDownloadTDomain"), ("ADTRAN-AOSDOWNLOAD", "adAOSDownloadFilename"), ("ADTRAN-AOSDOWNLOAD", "adAOSDownloadResetType"), ("ADTRAN-AOSDOWNLOAD", "adAOSDownloadErrorStatus"), ("ADTRAN-AOSDOWNLOAD", "adAOSDownloadErrorText"), ("ADTRAN-AOSDOWNLOAD", "adAOSDownloadStatus"), ("ADTRAN-AOSDOWNLOAD", "adAOSDownloadPassesLeft"), ("ADTRAN-AOSDOWNLOAD", "adAOSDownloadOctetCount"), ("ADTRAN-AOSDOWNLOAD", "adAOSDownloadDestination"), ("ADTRAN-AOSDOWNLOAD", "adAOSDownloadLogMaxSize"), ("ADTRAN-AOSDOWNLOAD", "adAOSDownloadLogSize"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    adAOSDownloadConfigGroup = adAOSDownloadConfigGroup.setStatus('current')
if mibBuilder.loadTexts: adAOSDownloadConfigGroup.setDescription('A collection of objects for controlling and monitoring network download of device firmware to ICF devices.')
mibBuilder.exportSymbols("ADTRAN-AOSDOWNLOAD", adAOSDownloadIndex=adAOSDownloadIndex, adAOSDownloadErrorStatus=adAOSDownloadErrorStatus, adAOSDlLogIndex=adAOSDlLogIndex, adAOSDlLogOwnerDomain=adAOSDlLogOwnerDomain, adAOSDownloadStatus=adAOSDownloadStatus, adAOSDownloadErrorText=adAOSDownloadErrorText, adAOSDownloadResetType=adAOSDownloadResetType, adAOSDownloadOwnerDomain=adAOSDownloadOwnerDomain, adAOSDownloadConfigCompliance=adAOSDownloadConfigCompliance, adAOSDlLogOwnerAddress=adAOSDlLogOwnerAddress, adAOSDownloadLogSize=adAOSDownloadLogSize, adAOSDownloadTAddress=adAOSDownloadTAddress, adAOSDownloadEntry=adAOSDownloadEntry, adAOSDownloadLogTable=adAOSDownloadLogTable, adAOSDownloadDestination=adAOSDownloadDestination, adAOSDownloadLogMaxSize=adAOSDownloadLogMaxSize, adAOSDlLogResetType=adAOSDlLogResetType, adAOSDownloadLogGroup=adAOSDownloadLogGroup, adAOSDownloadConfigGroup=adAOSDownloadConfigGroup, adAOSDownloadCompliances=adAOSDownloadCompliances, adAOSDownloadOctetCount=adAOSDownloadOctetCount, adAOSDownloadOwnerAddress=adAOSDownloadOwnerAddress, adAOSDlLogTDomain=adAOSDlLogTDomain, adAOSDownloadTDomain=adAOSDownloadTDomain, adAOSDlLogErrorText=adAOSDlLogErrorText, PYSNMP_MODULE_ID=adAOSDownloadMib, adAOSDownloadPassesLeft=adAOSDownloadPassesLeft, adAOSDownloadLogEntry=adAOSDownloadLogEntry, adAOSDlLogTAddress=adAOSDlLogTAddress, adAOSDownloadMib=adAOSDownloadMib, adAOSDlLogErrorStatus=adAOSDlLogErrorStatus, adAOSDlLogFilename=adAOSDlLogFilename, adAOSDownloadDestinationType=adAOSDownloadDestinationType, adAOSDownloadTable=adAOSDownloadTable, adAOSDownloadFilename=adAOSDownloadFilename, adAOSDownloadConformance=adAOSDownloadConformance, adAOSDownloadGroups=adAOSDownloadGroups, adAOSDownload=adAOSDownload)

#
# PySNMP MIB module JUNIPER-USER-AAA-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/JUNIPER-USER-AAA-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:01:22 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsIntersection, ValueSizeConstraint, ValueRangeConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsIntersection", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsUnion")
InetAddressPrefixLength, InetAddressType, InetAddress = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddressPrefixLength", "InetAddressType", "InetAddress")
Ipv6AddressIfIdentifier, Ipv6Address, Ipv6AddressPrefix = mibBuilder.importSymbols("IPV6-TC", "Ipv6AddressIfIdentifier", "Ipv6Address", "Ipv6AddressPrefix")
EnabledStatus, = mibBuilder.importSymbols("JUNIPER-MIMSTP-MIB", "EnabledStatus")
jnxUserAAAMibRoot, = mibBuilder.importSymbols("JUNIPER-SMI", "jnxUserAAAMibRoot")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
iso, Counter64, Unsigned32, ObjectIdentity, MibIdentifier, Gauge32, TimeTicks, NotificationType, Bits, Counter32, Integer32, ModuleIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, IpAddress = mibBuilder.importSymbols("SNMPv2-SMI", "iso", "Counter64", "Unsigned32", "ObjectIdentity", "MibIdentifier", "Gauge32", "TimeTicks", "NotificationType", "Bits", "Counter32", "Integer32", "ModuleIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "IpAddress")
TextualConvention, RowStatus, TruthValue, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "RowStatus", "TruthValue", "DisplayString")
jnxUserAAAMib = ModuleIdentity((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1))
jnxUserAAAMib.setRevisions(('2013-07-10 00:00', '2013-03-18 00:00', '2012-12-29 00:00', '2010-12-08 00:00', '2010-11-23 00:00', '2010-02-09 11:10', '2007-08-21 00:00', '2007-05-14 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: jnxUserAAAMib.setRevisionsDescriptions(('Adding jnxUserAAADomainStripUsername and jnxUserAAADomainOverridePassword to jnxUserAAADomain', 'jnxAccessAuthServerEnabled, corrected description', 'jnxUserAAADomainDynamicPorfile object has been deprecated and replaced by jnxUserAAADomainDynamicProfile', 'Updates related to adding address pool display', 'Updates related to adding address pool traps', 'Added jnxUserAAAAssignment, jnxUserAAAGeneral, jnxUserAAADomainDelimiters, jnxUserAAADomainParseDirection, jnxUserAAADomain, jnxUserAAADomainTable, jnxUserAAADomainEntry, jnxUserAAADomainName, jnxUserAAADomainStripDomain, jnxUserAAADomainLogicalSystem, jnxUserAAADomainRoutingInstance, jnxUserAAADomainAddrPoolName, jnxUserAAADomainDynamicPorfile, jnxUserAAADomainTargetLogicalSystem, jnxUserAAADomainTargetRoutingInstance, jnxUserAAADomainTunnelProfile, jnxUserAAADomainTunnelTable, jnxUserAAADomainTunnelEntry, jnxUserAAADomainTunnelName, jnxUserAAADomainTunnelDefId, jnxUserAAADomainTunnelPreference, jnxUserAAADomainTunnelRemoteGwName, jnxUserAAADomainTunnelRemoteGwAddress, jnxUserAAADomainTunnelSourceGwName, jnxUserAAADomainTunnelSourceGwAddress, jnxUserAAADomainTunnelSecret, jnxUserAAADomainTunnelLogicalSystems, jnxUserAAADomainTunnelRoutingInstance, jnxUserAAADomainTunnelMedium, jnxUserAAADomainTunnelType, jnxUserAAADomainTunnelId, jnxUserAAADomainTunnelMaxSessions, jnxUserAAADomainPadnTable, jnxUserAAADomainPadnEntry, jnxUserAAADomainPadnIpAddress, jnxUserAAADomainPadnIpMask, jnxUserAAADomainPadnDistance, jnxUserAAAAccessProfile, jnxUserAAAAccessProfileGeneral, jnxUserAAAAccessProfileTable, jnxUserAAAAccessProfileEntry, jnxUserAAAAccessProfileName, jnxUserAAAAccessProfileAuthenticationOrder, jnxUserAAAAccessProfileAccountingOrder, jnxUserAAAAccessProfileAuthorizationOrder, jnxUserAAAAccessProfileProvisioningOrder, jnxUserAAAAccessProfileAccStopOnFailure, jnxUserAAAAccessProfileAccStopOnDeny, jnxUserAAAAccessProfileImmediateUpdate, jnxUserAAAAccessProfileCoaImmediateUpdate, jnxUserAAAAccessProfileInterval, jnxUserAAAAccessProfileStatType.', 'Updates related to SecurID authentication', 'Creation Date',))
if mibBuilder.loadTexts: jnxUserAAAMib.setLastUpdated('201307100000Z')
if mibBuilder.loadTexts: jnxUserAAAMib.setOrganization('Juniper Networks, Inc.')
if mibBuilder.loadTexts: jnxUserAAAMib.setContactInfo('Juniper Technical Assistance Center Juniper Networks, Inc. 1194 N. Mathilda Avenue Sunnyvale, CA 94089 E-mail: support@juniper.net HTTP://www.juniper.net')
if mibBuilder.loadTexts: jnxUserAAAMib.setDescription('This module defines the objects pertaining to User authentication, authorization and accounting')
jnxUserAAANotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 0))
jnxUserAAAObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1))
jnxUserAAAGlobalStats = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 1))
jnxUserAAAAccessAuthStats = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 2))
jnxUserAAATrapVars = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 3))
jnxUserAAAAccessPool = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 4))
jnxUserAAAAssignment = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 5))
jnxUserAAAAccessProfile = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 6))
class JnxAuthenticateType(TextualConvention, Integer32):
    description = "There several way to authenticate a user, these are the types: radius - authentication via a radius server. local - local authenticaiton. ldap - authentication via a LDAP server. securid- authentication via RSA's SecurID authentication server jsrc - authentication via jsrc"
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))
    namedValues = NamedValues(("none", 0), ("radius", 1), ("local", 2), ("ldap", 3), ("securid", 4), ("jsrc", 5))

class JnxAccountingType(TextualConvention, Integer32):
    description = "There several choices for accounting, these are the types: radius - accounting via a radius server. local - local accounting. ldap - accounting via a LDAP server. securid- accounting via RSA's SecurID accounting server jsrc - accounting via jsrc"
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))
    namedValues = NamedValues(("none", 0), ("radius", 1), ("local", 2), ("ldap", 3), ("securid", 4), ("jsrc", 5))

class JnxAuthorizationType(TextualConvention, Integer32):
    description = "There several choices for authorization, these are the types: radius - authorization via a radius server. local - local authorization. ldap - authorization via a LDAP server. securid- authorization via RSA's SecurID authorization server jsrc - authorization via jsrc"
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))
    namedValues = NamedValues(("none", 0), ("radius", 1), ("local", 2), ("ldap", 3), ("securid", 4), ("jsrc", 5))

class JnxProvisioningType(TextualConvention, Integer32):
    description = "There several choices for provisioning, these are the types: radius - provisioning via a radius server. local - local provisioning. ldap - provisioning via a LDAP server. securid- provisioning via RSA's SecurID provisioning server jsrc - provisioning via jsrc"
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))
    namedValues = NamedValues(("none", 0), ("radius", 1), ("local", 2), ("ldap", 3), ("securid", 4), ("jsrc", 5))

jnxTotalAuthenticationRequests = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 1, 1), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxTotalAuthenticationRequests.setStatus('current')
if mibBuilder.loadTexts: jnxTotalAuthenticationRequests.setDescription('Total authentication requests received.')
jnxTotalAuthenticationResponses = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxTotalAuthenticationResponses.setStatus('current')
if mibBuilder.loadTexts: jnxTotalAuthenticationResponses.setDescription('Total authentication responses.')
jnxUserAAAStatTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 2, 1), )
if mibBuilder.loadTexts: jnxUserAAAStatTable.setStatus('current')
if mibBuilder.loadTexts: jnxUserAAAStatTable.setDescription('This table exposes the user authentication statistics.')
jnxUserAAAStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 2, 1, 1), ).setIndexNames((0, "JUNIPER-USER-AAA-MIB", "jnxUserAAAStatAuthType"))
if mibBuilder.loadTexts: jnxUserAAAStatEntry.setStatus('current')
if mibBuilder.loadTexts: jnxUserAAAStatEntry.setDescription('Statistic entry collects for authentication.')
jnxUserAAAStatAuthType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 2, 1, 1, 1), JnxAuthenticateType())
if mibBuilder.loadTexts: jnxUserAAAStatAuthType.setStatus('current')
if mibBuilder.loadTexts: jnxUserAAAStatAuthType.setDescription('The entry indicates the authentication type. It uniquely identifies the statistics counters related to its authentication.')
jnxUserAAAStatRequestReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 2, 1, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxUserAAAStatRequestReceived.setStatus('current')
if mibBuilder.loadTexts: jnxUserAAAStatRequestReceived.setDescription('The number of request received.')
jnxUserAAAStatAccessAccepted = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 2, 1, 1, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxUserAAAStatAccessAccepted.setStatus('current')
if mibBuilder.loadTexts: jnxUserAAAStatAccessAccepted.setDescription('The number of access granted. It is an aggregated statistics for this type of authenticaiton.')
jnxUserAAAStatAccessRejected = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 2, 1, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxUserAAAStatAccessRejected.setStatus('current')
if mibBuilder.loadTexts: jnxUserAAAStatAccessRejected.setDescription('This number of access request rejected. It is an aggregated statistics for this type of authentication.')
jnxUserAAAServerName = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 3, 1), DisplayString()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: jnxUserAAAServerName.setStatus('current')
if mibBuilder.loadTexts: jnxUserAAAServerName.setDescription('The server name which identifies the authentication server.')
jnxUserAAAAddressPoolName = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 3, 2), DisplayString()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: jnxUserAAAAddressPoolName.setStatus('current')
if mibBuilder.loadTexts: jnxUserAAAAddressPoolName.setDescription('The address pool name which identifies the local address pool.')
jnxAccessAuthServiceUp = NotificationType((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 0, 1))
if mibBuilder.loadTexts: jnxAccessAuthServiceUp.setStatus('current')
if mibBuilder.loadTexts: jnxAccessAuthServiceUp.setDescription('An access authentication trap signifies that the specified service has started. ')
jnxAccessAuthServiceDown = NotificationType((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 0, 2))
if mibBuilder.loadTexts: jnxAccessAuthServiceDown.setStatus('current')
if mibBuilder.loadTexts: jnxAccessAuthServiceDown.setDescription('An access authentication trap signifies that the specified service has been stopped.')
jnxAccessAuthServerDisabled = NotificationType((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 0, 3)).setObjects(("JUNIPER-USER-AAA-MIB", "jnxUserAAAServerName"))
if mibBuilder.loadTexts: jnxAccessAuthServerDisabled.setStatus('current')
if mibBuilder.loadTexts: jnxAccessAuthServerDisabled.setDescription('An access authentication trap signifies that the External authentication server is not responding.')
jnxAccessAuthServerEnabled = NotificationType((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 0, 4)).setObjects(("JUNIPER-USER-AAA-MIB", "jnxUserAAAServerName"))
if mibBuilder.loadTexts: jnxAccessAuthServerEnabled.setStatus('current')
if mibBuilder.loadTexts: jnxAccessAuthServerEnabled.setDescription('An access authentication trap signifies that the AAA client has changed the status of the External authentication server to UP.')
jnxAccessAuthAddressPoolHighThreshold = NotificationType((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 0, 5)).setObjects(("JUNIPER-USER-AAA-MIB", "jnxUserAAAAddressPoolName"))
if mibBuilder.loadTexts: jnxAccessAuthAddressPoolHighThreshold.setStatus('current')
if mibBuilder.loadTexts: jnxAccessAuthAddressPoolHighThreshold.setDescription('An access authentication trap signifies that the address pool has reached its high threshold.')
jnxAccessAuthAddressPoolAbateThreshold = NotificationType((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 0, 6)).setObjects(("JUNIPER-USER-AAA-MIB", "jnxUserAAAAddressPoolName"))
if mibBuilder.loadTexts: jnxAccessAuthAddressPoolAbateThreshold.setStatus('current')
if mibBuilder.loadTexts: jnxAccessAuthAddressPoolAbateThreshold.setDescription('An access authentication trap signifies that the address pool has reached its abate threshold')
jnxAccessAuthAddressPoolOutOfAddresses = NotificationType((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 0, 7)).setObjects(("JUNIPER-USER-AAA-MIB", "jnxUserAAAAddressPoolName"))
if mibBuilder.loadTexts: jnxAccessAuthAddressPoolOutOfAddresses.setStatus('current')
if mibBuilder.loadTexts: jnxAccessAuthAddressPoolOutOfAddresses.setDescription('An access authentication trap signifies that an Out Of Addresses event occured on the pool.')
jnxAccessAuthAddressPoolOutOfMemory = NotificationType((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 0, 8)).setObjects(("JUNIPER-USER-AAA-MIB", "jnxUserAAAAddressPoolName"))
if mibBuilder.loadTexts: jnxAccessAuthAddressPoolOutOfMemory.setStatus('current')
if mibBuilder.loadTexts: jnxAccessAuthAddressPoolOutOfMemory.setDescription('An access authentication trap signifies that an Out Of Memory event occured on the pool.')
jnxUserAAAAccessPoolGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 4, 1))
jnxUserAAAAccessPoolTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 4, 1, 1), )
if mibBuilder.loadTexts: jnxUserAAAAccessPoolTable.setStatus('current')
if mibBuilder.loadTexts: jnxUserAAAAccessPoolTable.setDescription('The entries in this table specify the address pools.')
jnxUserAAAAccessPoolEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 4, 1, 1, 1), ).setIndexNames((0, "JUNIPER-USER-AAA-MIB", "jnxUserAAAAccessPoolIdent"))
if mibBuilder.loadTexts: jnxUserAAAAccessPoolEntry.setStatus('current')
if mibBuilder.loadTexts: jnxUserAAAAccessPoolEntry.setDescription('A read-only description of the local address pools.')
jnxUserAAAAccessPoolIdent = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 4, 1, 1, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: jnxUserAAAAccessPoolIdent.setStatus('current')
if mibBuilder.loadTexts: jnxUserAAAAccessPoolIdent.setDescription('The address identifier key.')
jnxUserAAAAccessPoolRoutingInstance = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 4, 1, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxUserAAAAccessPoolRoutingInstance.setStatus('current')
if mibBuilder.loadTexts: jnxUserAAAAccessPoolRoutingInstance.setDescription('The routing instance of the address pool.')
jnxUserAAAAccessPoolName = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 4, 1, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxUserAAAAccessPoolName.setStatus('current')
if mibBuilder.loadTexts: jnxUserAAAAccessPoolName.setDescription('The address pool name.')
jnxUserAAAAccessPoolLinkName = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 4, 1, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxUserAAAAccessPoolLinkName.setStatus('current')
if mibBuilder.loadTexts: jnxUserAAAAccessPoolLinkName.setDescription('The address pool link name.')
jnxUserAAAAccessPoolFamilyType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 4, 1, 1, 1, 5), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxUserAAAAccessPoolFamilyType.setStatus('current')
if mibBuilder.loadTexts: jnxUserAAAAccessPoolFamilyType.setDescription('The family type of this pool.')
jnxUserAAAAccessPoolInetNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 4, 1, 1, 1, 6), InetAddress().subtype(subtypeSpec=ValueSizeConstraint(2, 48))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxUserAAAAccessPoolInetNetwork.setStatus('current')
if mibBuilder.loadTexts: jnxUserAAAAccessPoolInetNetwork.setDescription('The Match criteria for this pool. Network or Prefix')
jnxUserAAAAccessPoolInetPrefixLength = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 4, 1, 1, 1, 7), InetAddressPrefixLength()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxUserAAAAccessPoolInetPrefixLength.setStatus('current')
if mibBuilder.loadTexts: jnxUserAAAAccessPoolInetPrefixLength.setDescription('The Prefix Length for an IPv6 pool')
jnxUserAAAAccessPoolOutOfMemory = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 4, 1, 1, 1, 8), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxUserAAAAccessPoolOutOfMemory.setStatus('current')
if mibBuilder.loadTexts: jnxUserAAAAccessPoolOutOfMemory.setDescription('The Number of times this pool has flagged an Out of Memory condition.')
jnxUserAAAAccessPoolOutOfAddresses = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 4, 1, 1, 1, 9), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxUserAAAAccessPoolOutOfAddresses.setStatus('current')
if mibBuilder.loadTexts: jnxUserAAAAccessPoolOutOfAddresses.setDescription('The Number of times this pool has flagged an Out of Address condition.')
jnxUserAAAAccessPoolAddressTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 4, 1, 1, 1, 10), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxUserAAAAccessPoolAddressTotal.setStatus('current')
if mibBuilder.loadTexts: jnxUserAAAAccessPoolAddressTotal.setDescription('The total number of Addresses or prefixes in this pool.')
jnxUserAAAAccessPoolAddressesInUse = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 4, 1, 1, 1, 11), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxUserAAAAccessPoolAddressesInUse.setStatus('current')
if mibBuilder.loadTexts: jnxUserAAAAccessPoolAddressesInUse.setDescription('The total number of Addresses or prefixes given out from this pool.')
jnxUserAAAAccessPoolAddressUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 4, 1, 1, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxUserAAAAccessPoolAddressUsage.setStatus('current')
if mibBuilder.loadTexts: jnxUserAAAAccessPoolAddressUsage.setDescription('The percentage of addresses used in this pool or linked pool. If this pool is the head of a linked chain of pools, this number reflects the Usage for the whole chain. Conversely, if this pool it part of a linked chain of pools but not the head of the chain, the value will not be used.')
jnxUserAAAAccessPoolAddressUsageHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 4, 1, 1, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxUserAAAAccessPoolAddressUsageHigh.setStatus('current')
if mibBuilder.loadTexts: jnxUserAAAAccessPoolAddressUsageHigh.setDescription('The configured high percentage threshold of addresses used in this pool or linked pool. An SNMP trap is generated when this threshold is exceeded. This trap will only be generated for unlinked pools or pools that are the head of a linked chain of pools Conversely, if this pool it part of a linked chain of pools but not the head of the chain, then no traps will be generated.')
jnxUserAAAAccessPoolAddressUsageAbate = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 4, 1, 1, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxUserAAAAccessPoolAddressUsageAbate.setStatus('current')
if mibBuilder.loadTexts: jnxUserAAAAccessPoolAddressUsageAbate.setDescription('The configured abate percentage threshold of addresses used in this pool or linked pool. An SNMP trap clear is generated when address use falls below this threshold percentage. This trap will only be generated for unlinked pools or pools that are the head of a linked chain of pools Conversely, if this pool it part of a linked chain of pools but not the head of the chain, then no traps will be generated.')
jnxUserAAAGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 5, 1))
jnxUserAAADomainDelimiters = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 5, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxUserAAADomainDelimiters.setStatus('current')
if mibBuilder.loadTexts: jnxUserAAADomainDelimiters.setDescription("The list of delimiters used to separate the user's name from the user's domain in the username field. The default is '@'.")
jnxUserAAADomainParseDirection = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("rightToLeft", 1), ("leftToRight", 2))).clone('rightToLeft')).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxUserAAADomainParseDirection.setStatus('current')
if mibBuilder.loadTexts: jnxUserAAADomainParseDirection.setDescription("The direction in which the user's name is parsed: either search for domain delimiter from left to right or right to left; first delimiter marks boundry. The default is right to left.")
jnxUserAAADomain = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 5, 2))
jnxUserAAADomainTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 5, 2, 1), )
if mibBuilder.loadTexts: jnxUserAAADomainTable.setStatus('current')
if mibBuilder.loadTexts: jnxUserAAADomainTable.setDescription("The entries in this table specify the assignment of a remote access user to a logical system, based on the user's domain.")
jnxUserAAADomainEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 5, 2, 1, 1), ).setIndexNames((1, "JUNIPER-USER-AAA-MIB", "jnxUserAAADomainName"))
if mibBuilder.loadTexts: jnxUserAAADomainEntry.setStatus('current')
if mibBuilder.loadTexts: jnxUserAAADomainEntry.setDescription('A specification of the logical system to which users on a specified domain should be assigned.')
jnxUserAAADomainName = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 5, 2, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 63)))
if mibBuilder.loadTexts: jnxUserAAADomainName.setStatus('current')
if mibBuilder.loadTexts: jnxUserAAADomainName.setDescription('The domain name uniquely identifying this entry.')
jnxUserAAADomainStripDomain = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 5, 2, 1, 1, 2), TruthValue().clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxUserAAADomainStripDomain.setStatus('current')
if mibBuilder.loadTexts: jnxUserAAADomainStripDomain.setDescription('Enables/disables the domain name stripping feature, which causes the system to strip the domain name before sending the access-request to RADIUS for authentication.')
jnxUserAAADomainLogicalSystem = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 5, 2, 1, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxUserAAADomainLogicalSystem.setStatus('current')
if mibBuilder.loadTexts: jnxUserAAADomainLogicalSystem.setDescription('The name of the logical system, which will be used by the AAA subsystem for this session. If not specified, will be mapped to default.')
jnxUserAAADomainRoutingInstance = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 5, 2, 1, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxUserAAADomainRoutingInstance.setStatus('current')
if mibBuilder.loadTexts: jnxUserAAADomainRoutingInstance.setDescription('The name of the routing instance, which will be used by the AAA subsystem for this session. If not specified, will be mapped to default.')
jnxUserAAADomainAddrPoolName = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 5, 2, 1, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxUserAAADomainAddrPoolName.setStatus('current')
if mibBuilder.loadTexts: jnxUserAAADomainAddrPoolName.setDescription('The configured the address-pool-name for the domain name.')
jnxUserAAADomainDynamicPorfile = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 5, 2, 1, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxUserAAADomainDynamicPorfile.setStatus('deprecated')
if mibBuilder.loadTexts: jnxUserAAADomainDynamicPorfile.setDescription('The configured dynamic-profile which will be used for this session upon succeeding validation.')
jnxUserAAADomainTargetLogicalSystem = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 5, 2, 1, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxUserAAADomainTargetLogicalSystem.setStatus('current')
if mibBuilder.loadTexts: jnxUserAAADomainTargetLogicalSystem.setDescription('The configured target logical-system that this session will need to be mapped to. If not specified, will be mapped to default.')
jnxUserAAADomainTargetRoutingInstance = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 5, 2, 1, 1, 8), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxUserAAADomainTargetRoutingInstance.setStatus('current')
if mibBuilder.loadTexts: jnxUserAAADomainTargetRoutingInstance.setDescription('The configured routing-instance that this session will need to be mapped to.')
jnxUserAAADomainTunnelProfile = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 5, 2, 1, 1, 9), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxUserAAADomainTunnelProfile.setStatus('current')
if mibBuilder.loadTexts: jnxUserAAADomainTunnelProfile.setDescription('The associated tunnel profile.')
jnxUserAAADomainDynamicProfile = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 5, 2, 1, 1, 10), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxUserAAADomainDynamicProfile.setStatus('current')
if mibBuilder.loadTexts: jnxUserAAADomainDynamicProfile.setDescription('The configured dynamic-profile to be used for this session.')
jnxUserAAADomainStripUsername = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 5, 2, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("disabled", 0), ("leftToRight", 1), ("rightToLeft", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxUserAAADomainStripUsername.setStatus('current')
if mibBuilder.loadTexts: jnxUserAAADomainStripUsername.setDescription('Displays the strip-username configuration.')
jnxUserAAADomainOverridePassword = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 5, 2, 1, 1, 12), TruthValue().clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxUserAAADomainOverridePassword.setStatus('current')
if mibBuilder.loadTexts: jnxUserAAADomainOverridePassword.setDescription('Displays the override-password configuration.')
jnxUserAAADomainTunnelTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 5, 2, 2), )
if mibBuilder.loadTexts: jnxUserAAADomainTunnelTable.setStatus('current')
if mibBuilder.loadTexts: jnxUserAAADomainTunnelTable.setDescription('The entries in this table specify the tunnels associated with a domain.')
jnxUserAAADomainTunnelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 5, 2, 2, 1), ).setIndexNames((0, "JUNIPER-USER-AAA-MIB", "jnxUserAAADomainTunnelName"), (0, "JUNIPER-USER-AAA-MIB", "jnxUserAAADomainTunnelDefId"))
if mibBuilder.loadTexts: jnxUserAAADomainTunnelEntry.setStatus('current')
if mibBuilder.loadTexts: jnxUserAAADomainTunnelEntry.setDescription('A specification of the tunnels associated with a domain.')
jnxUserAAADomainTunnelName = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 5, 2, 2, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 63)))
if mibBuilder.loadTexts: jnxUserAAADomainTunnelName.setStatus('current')
if mibBuilder.loadTexts: jnxUserAAADomainTunnelName.setDescription('The domain name associated with this entry.')
jnxUserAAADomainTunnelDefId = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 5, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 31)))
if mibBuilder.loadTexts: jnxUserAAADomainTunnelDefId.setStatus('current')
if mibBuilder.loadTexts: jnxUserAAADomainTunnelDefId.setDescription('The tunnel definition id value associated with this entry.')
jnxUserAAADomainTunnelPreference = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 5, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxUserAAADomainTunnelPreference.setStatus('current')
if mibBuilder.loadTexts: jnxUserAAADomainTunnelPreference.setDescription("The tunnel's preference value associated with this entry. ")
jnxUserAAADomainTunnelRemoteGwName = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 5, 2, 2, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxUserAAADomainTunnelRemoteGwName.setStatus('current')
if mibBuilder.loadTexts: jnxUserAAADomainTunnelRemoteGwName.setDescription('This name specifies the hostname expected from the peer (the LNS) when a tunnel is setup.')
jnxUserAAADomainTunnelRemoteGwAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 5, 2, 2, 1, 5), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxUserAAADomainTunnelRemoteGwAddress.setStatus('current')
if mibBuilder.loadTexts: jnxUserAAADomainTunnelRemoteGwAddress.setDescription('IP address of LNS tunnel endpoint')
jnxUserAAADomainTunnelSourceGwName = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 5, 2, 2, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxUserAAADomainTunnelSourceGwName.setStatus('current')
if mibBuilder.loadTexts: jnxUserAAADomainTunnelSourceGwName.setDescription('This name specifies the hostname expected from the peer (the LNS) when a tunnel is setup.')
jnxUserAAADomainTunnelSourceGwAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 5, 2, 2, 1, 7), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxUserAAADomainTunnelSourceGwAddress.setStatus('current')
if mibBuilder.loadTexts: jnxUserAAADomainTunnelSourceGwAddress.setDescription('The source address of the tunnel (overrides the default address for this LS/RI.) ')
jnxUserAAADomainTunnelSecret = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 5, 2, 2, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxUserAAADomainTunnelSecret.setStatus('current')
if mibBuilder.loadTexts: jnxUserAAADomainTunnelSecret.setDescription('The tunnel password associated with this entry.')
jnxUserAAADomainTunnelLogicalSystems = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 5, 2, 2, 1, 9), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxUserAAADomainTunnelLogicalSystems.setStatus('current')
if mibBuilder.loadTexts: jnxUserAAADomainTunnelLogicalSystems.setDescription('The logical systems associated with this entty.')
jnxUserAAADomainTunnelRoutingInstance = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 5, 2, 2, 1, 10), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxUserAAADomainTunnelRoutingInstance.setStatus('current')
if mibBuilder.loadTexts: jnxUserAAADomainTunnelRoutingInstance.setDescription('The routing instance associated with this entty.')
jnxUserAAADomainTunnelMedium = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 5, 2, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("tunnelMediumIPv4", 1), ("tunnelMediumUnknown", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxUserAAADomainTunnelMedium.setStatus('current')
if mibBuilder.loadTexts: jnxUserAAADomainTunnelMedium.setDescription('The tunnel medium associated with this entry. The medium dictates the format of the tunnel address.')
jnxUserAAADomainTunnelType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 5, 2, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("tunnelL2tp", 1), ("tunnelUnknown", 2), ("tunnelL2f", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxUserAAADomainTunnelType.setStatus('current')
if mibBuilder.loadTexts: jnxUserAAADomainTunnelType.setDescription('The tunnel type associated with this entry.')
jnxUserAAADomainTunnelId = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 5, 2, 2, 1, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxUserAAADomainTunnelId.setStatus('current')
if mibBuilder.loadTexts: jnxUserAAADomainTunnelId.setDescription('The tunnel identifier associated with this entry.')
jnxUserAAADomainTunnelMaxSessions = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 5, 2, 2, 1, 14), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxUserAAADomainTunnelMaxSessions.setStatus('current')
if mibBuilder.loadTexts: jnxUserAAADomainTunnelMaxSessions.setDescription('The maximum number of tunnel sessions allowed in this tunnel entry.')
jnxUserAAADomainPadnTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 5, 2, 3), )
if mibBuilder.loadTexts: jnxUserAAADomainPadnTable.setStatus('current')
if mibBuilder.loadTexts: jnxUserAAADomainPadnTable.setDescription('The entries in this table specify the PPPoE active discovery network (PADN) parameters associated with a domain.')
jnxUserAAADomainPadnEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 5, 2, 3, 1), ).setIndexNames((0, "JUNIPER-USER-AAA-MIB", "jnxUserAAADomainName"), (0, "JUNIPER-USER-AAA-MIB", "jnxUserAAADomainPadnIpAddress"), (0, "JUNIPER-USER-AAA-MIB", "jnxUserAAADomainPadnIpMask"))
if mibBuilder.loadTexts: jnxUserAAADomainPadnEntry.setStatus('current')
if mibBuilder.loadTexts: jnxUserAAADomainPadnEntry.setDescription('A specification of the PPPoE active discovery network parameters associated with a domain.')
jnxUserAAADomainPadnIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 5, 2, 3, 1, 1), IpAddress())
if mibBuilder.loadTexts: jnxUserAAADomainPadnIpAddress.setStatus('current')
if mibBuilder.loadTexts: jnxUserAAADomainPadnIpAddress.setDescription('The IP address of this entry.')
jnxUserAAADomainPadnIpMask = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 5, 2, 3, 1, 2), IpAddress())
if mibBuilder.loadTexts: jnxUserAAADomainPadnIpMask.setStatus('current')
if mibBuilder.loadTexts: jnxUserAAADomainPadnIpMask.setDescription('The IP mask of this entry.')
jnxUserAAADomainPadnDistance = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 5, 2, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxUserAAADomainPadnDistance.setStatus('current')
if mibBuilder.loadTexts: jnxUserAAADomainPadnDistance.setDescription('The administrative distance metric of this entry.')
jnxUserAAAAccessProfileGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 6, 1))
jnxUserAAAAccessProfileTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 6, 1, 1), )
if mibBuilder.loadTexts: jnxUserAAAAccessProfileTable.setStatus('current')
if mibBuilder.loadTexts: jnxUserAAAAccessProfileTable.setDescription('The entries in this table specify the assignment of authentication methods for a particular subscriber type.')
jnxUserAAAAccessProfileEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 6, 1, 1, 1), ).setIndexNames((1, "JUNIPER-USER-AAA-MIB", "jnxUserAAAAccessProfileName"))
if mibBuilder.loadTexts: jnxUserAAAAccessProfileEntry.setStatus('current')
if mibBuilder.loadTexts: jnxUserAAAAccessProfileEntry.setDescription('A specification of the authentication methods for a particular subscriber type.')
jnxUserAAAAccessProfileName = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 6, 1, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 63)))
if mibBuilder.loadTexts: jnxUserAAAAccessProfileName.setStatus('current')
if mibBuilder.loadTexts: jnxUserAAAAccessProfileName.setDescription('The access profile name.')
jnxUserAAAAccessProfileAuthenticationOrder = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 6, 1, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 5))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxUserAAAAccessProfileAuthenticationOrder.setStatus('current')
if mibBuilder.loadTexts: jnxUserAAAAccessProfileAuthenticationOrder.setDescription('The set of authentication mechanisms configured on this system. Each octet in this object contains one of the values defined in the JnxAuthenticateType TEXTUAL-CONVENTION. The system will sequence through each octet of this object starting at octet 1 and attempt to use the corresponding authentication protocol defined by JnxAuthenticateType. If an authentication protocol is configured and attempts to reach the authentication server fail, the system will move to the next octet in this object and retry the authentication in the form dictated by the corresponding authentication protocoltype. The process of sequencing thru each octet will stop if the authentication server is successfully contacted, or there are no more configured octets in this object.')
jnxUserAAAAccessProfileAccountingOrder = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 6, 1, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 5))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxUserAAAAccessProfileAccountingOrder.setStatus('current')
if mibBuilder.loadTexts: jnxUserAAAAccessProfileAccountingOrder.setDescription('The set of accounting mechanisms configured on this system. Each octet in this object contains one of the values defined in the JnxAccountingType TEXTUAL-CONVENTION. The system will sequence through each octet of this object starting at octet 1 and attempt to use the corresponding accounting protocol defined by JnxAccountingType. If an accounting protocol is configured and attempts to reach the accounting server fail, the system will move to the next octet in this object and retry the accounting in the form dictated by the corresponding accounting protocoltype. The process of sequencing thru each octet will stop if the accounting server is successfully contacted, or there are no more configured octets in this object.')
jnxUserAAAAccessProfileAuthorizationOrder = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 6, 1, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 5))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxUserAAAAccessProfileAuthorizationOrder.setStatus('current')
if mibBuilder.loadTexts: jnxUserAAAAccessProfileAuthorizationOrder.setDescription('The set of accounting mechanisms configured on this system. Each octet in this object contains one of the values defined in the JnxAuthorizationType TEXTUAL-CONVENTION. The system will sequence through each octet of this object starting at octet 1 and attempt to use the corresponding accounting protocol defined by JnxAuthorizationType. If an accounting protocol is configured and attempts to reach the accounting server fail, the system will move to the next octet in this object and retry the accounting in the form dictated by the corresponding accounting protocoltype. The process of sequencing thru each octet will stop if the accounting server is successfully contacted, or there are no more configured octets in this object.')
jnxUserAAAAccessProfileProvisioningOrder = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 6, 1, 1, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 5))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxUserAAAAccessProfileProvisioningOrder.setStatus('current')
if mibBuilder.loadTexts: jnxUserAAAAccessProfileProvisioningOrder.setDescription('The set of provisioning mechanisms configured on this system. Each octet in this object contains one of the values defined in the JnxProvisioningType TEXTUAL-CONVENTION. The system will sequence through each octet of this object starting at octet 1 and attempt to use the corresponding accounting protocol defined by JnxProvisioningType. If an accounting protocol is configured and attempts to reach the accounting server fail, the system will move to the next octet in this object and retry the accounting in the form dictated by the corresponding accounting protocoltype. The process of sequencing thru each octet will stop if the accounting server is successfully contacted, or there are no more configured octets in this object.')
jnxUserAAAAccessProfileAccStopOnFailure = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 6, 1, 1, 1, 6), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxUserAAAAccessProfileAccStopOnFailure.setStatus('current')
if mibBuilder.loadTexts: jnxUserAAAAccessProfileAccStopOnFailure.setDescription('Enables/disables the Acct-Stop message if a user fails authentication, but AAA-server grants access.')
jnxUserAAAAccessProfileAccStopOnDeny = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 6, 1, 1, 1, 7), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxUserAAAAccessProfileAccStopOnDeny.setStatus('current')
if mibBuilder.loadTexts: jnxUserAAAAccessProfileAccStopOnDeny.setDescription('Enables/disables the Acct-Stop message if AAA-server denies access.')
jnxUserAAAAccessProfileImmediateUpdate = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 6, 1, 1, 1, 8), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxUserAAAAccessProfileImmediateUpdate.setStatus('current')
if mibBuilder.loadTexts: jnxUserAAAAccessProfileImmediateUpdate.setDescription('Enables/disables the Acct-Update message on receipt of a Acct-response for the Acct-Start message.')
jnxUserAAAAccessProfileCoaImmediateUpdate = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 6, 1, 1, 1, 9), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxUserAAAAccessProfileCoaImmediateUpdate.setStatus('current')
if mibBuilder.loadTexts: jnxUserAAAAccessProfileCoaImmediateUpdate.setDescription('Enables/disables the Acct-Update message on completion of processing a change of authorization.')
jnxUserAAAAccessProfileInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 6, 1, 1, 1, 10), Integer32()).setUnits('minutes').setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxUserAAAAccessProfileInterval.setStatus('current')
if mibBuilder.loadTexts: jnxUserAAAAccessProfileInterval.setDescription('The interval in minutes between accounting updates(Interim-stats off, if not specified).')
jnxUserAAAAccessProfileStatType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 51, 1, 1, 6, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("time", 0), ("volume-time", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxUserAAAAccessProfileStatType.setStatus('current')
if mibBuilder.loadTexts: jnxUserAAAAccessProfileStatType.setDescription('The type of statistics are collected. These are the configured types: time - the option to report only uptime volume-time - the option to report both volume and uptime')
mibBuilder.exportSymbols("JUNIPER-USER-AAA-MIB", jnxAccessAuthServiceDown=jnxAccessAuthServiceDown, JnxProvisioningType=JnxProvisioningType, jnxUserAAAStatAccessAccepted=jnxUserAAAStatAccessAccepted, jnxAccessAuthAddressPoolOutOfAddresses=jnxAccessAuthAddressPoolOutOfAddresses, jnxUserAAADomainTable=jnxUserAAADomainTable, jnxUserAAANotifications=jnxUserAAANotifications, jnxUserAAAAccessProfileAccStopOnFailure=jnxUserAAAAccessProfileAccStopOnFailure, JnxAuthenticateType=JnxAuthenticateType, jnxUserAAAObjects=jnxUserAAAObjects, jnxUserAAAAccessProfileImmediateUpdate=jnxUserAAAAccessProfileImmediateUpdate, jnxUserAAADomainTunnelName=jnxUserAAADomainTunnelName, jnxUserAAAAccessPoolEntry=jnxUserAAAAccessPoolEntry, jnxUserAAAAssignment=jnxUserAAAAssignment, jnxUserAAAAccessPoolIdent=jnxUserAAAAccessPoolIdent, jnxTotalAuthenticationRequests=jnxTotalAuthenticationRequests, jnxUserAAADomainPadnIpAddress=jnxUserAAADomainPadnIpAddress, jnxUserAAADomainRoutingInstance=jnxUserAAADomainRoutingInstance, jnxTotalAuthenticationResponses=jnxTotalAuthenticationResponses, jnxUserAAADomainTunnelRemoteGwAddress=jnxUserAAADomainTunnelRemoteGwAddress, jnxUserAAAAccessProfileStatType=jnxUserAAAAccessProfileStatType, jnxUserAAADomainDynamicPorfile=jnxUserAAADomainDynamicPorfile, jnxUserAAADomainTunnelSourceGwAddress=jnxUserAAADomainTunnelSourceGwAddress, jnxUserAAADomainPadnDistance=jnxUserAAADomainPadnDistance, jnxUserAAADomainPadnTable=jnxUserAAADomainPadnTable, jnxUserAAADomainTunnelMedium=jnxUserAAADomainTunnelMedium, jnxUserAAAAccessPoolAddressUsageAbate=jnxUserAAAAccessPoolAddressUsageAbate, jnxUserAAADomainTunnelId=jnxUserAAADomainTunnelId, jnxUserAAAStatRequestReceived=jnxUserAAAStatRequestReceived, jnxUserAAADomainName=jnxUserAAADomainName, jnxUserAAADomainTunnelRemoteGwName=jnxUserAAADomainTunnelRemoteGwName, JnxAuthorizationType=JnxAuthorizationType, jnxUserAAAAccessProfileInterval=jnxUserAAAAccessProfileInterval, jnxUserAAADomainTunnelTable=jnxUserAAADomainTunnelTable, jnxUserAAADomainDelimiters=jnxUserAAADomainDelimiters, jnxAccessAuthAddressPoolHighThreshold=jnxAccessAuthAddressPoolHighThreshold, jnxUserAAADomainTunnelLogicalSystems=jnxUserAAADomainTunnelLogicalSystems, jnxUserAAAAccessPoolFamilyType=jnxUserAAAAccessPoolFamilyType, jnxUserAAAAccessAuthStats=jnxUserAAAAccessAuthStats, jnxAccessAuthAddressPoolOutOfMemory=jnxAccessAuthAddressPoolOutOfMemory, jnxUserAAADomainParseDirection=jnxUserAAADomainParseDirection, jnxUserAAAStatEntry=jnxUserAAAStatEntry, jnxUserAAADomainTunnelSecret=jnxUserAAADomainTunnelSecret, jnxUserAAADomainTunnelProfile=jnxUserAAADomainTunnelProfile, jnxUserAAAStatTable=jnxUserAAAStatTable, jnxUserAAAAccessPoolAddressTotal=jnxUserAAAAccessPoolAddressTotal, jnxUserAAAAccessProfileName=jnxUserAAAAccessProfileName, jnxUserAAATrapVars=jnxUserAAATrapVars, jnxUserAAAServerName=jnxUserAAAServerName, jnxUserAAAAddressPoolName=jnxUserAAAAddressPoolName, jnxUserAAADomainTunnelType=jnxUserAAADomainTunnelType, jnxUserAAAAccessProfileCoaImmediateUpdate=jnxUserAAAAccessProfileCoaImmediateUpdate, jnxUserAAAAccessProfileAccountingOrder=jnxUserAAAAccessProfileAccountingOrder, jnxUserAAAStatAuthType=jnxUserAAAStatAuthType, jnxUserAAAAccessPoolInetPrefixLength=jnxUserAAAAccessPoolInetPrefixLength, jnxUserAAAMib=jnxUserAAAMib, jnxUserAAAGlobalStats=jnxUserAAAGlobalStats, jnxUserAAAAccessPoolName=jnxUserAAAAccessPoolName, jnxUserAAAAccessPool=jnxUserAAAAccessPool, jnxUserAAADomainDynamicProfile=jnxUserAAADomainDynamicProfile, jnxUserAAAAccessPoolAddressesInUse=jnxUserAAAAccessPoolAddressesInUse, jnxAccessAuthServiceUp=jnxAccessAuthServiceUp, jnxUserAAAStatAccessRejected=jnxUserAAAStatAccessRejected, jnxUserAAAAccessProfileAccStopOnDeny=jnxUserAAAAccessProfileAccStopOnDeny, jnxUserAAADomainTunnelDefId=jnxUserAAADomainTunnelDefId, jnxUserAAAAccessProfileProvisioningOrder=jnxUserAAAAccessProfileProvisioningOrder, jnxUserAAADomainTunnelMaxSessions=jnxUserAAADomainTunnelMaxSessions, jnxUserAAADomainLogicalSystem=jnxUserAAADomainLogicalSystem, jnxAccessAuthAddressPoolAbateThreshold=jnxAccessAuthAddressPoolAbateThreshold, jnxAccessAuthServerEnabled=jnxAccessAuthServerEnabled, jnxUserAAAAccessPoolTable=jnxUserAAAAccessPoolTable, jnxUserAAAAccessPoolInetNetwork=jnxUserAAAAccessPoolInetNetwork, jnxUserAAAAccessProfileAuthenticationOrder=jnxUserAAAAccessProfileAuthenticationOrder, jnxUserAAAAccessPoolGeneral=jnxUserAAAAccessPoolGeneral, jnxUserAAADomainTargetLogicalSystem=jnxUserAAADomainTargetLogicalSystem, jnxUserAAAAccessProfile=jnxUserAAAAccessProfile, jnxUserAAAAccessPoolLinkName=jnxUserAAAAccessPoolLinkName, jnxUserAAAAccessProfileGeneral=jnxUserAAAAccessProfileGeneral, jnxUserAAADomainPadnIpMask=jnxUserAAADomainPadnIpMask, jnxUserAAAGeneral=jnxUserAAAGeneral, jnxUserAAADomainTunnelEntry=jnxUserAAADomainTunnelEntry, jnxUserAAAAccessProfileTable=jnxUserAAAAccessProfileTable, jnxUserAAAAccessPoolOutOfMemory=jnxUserAAAAccessPoolOutOfMemory, jnxUserAAADomainTunnelSourceGwName=jnxUserAAADomainTunnelSourceGwName, jnxUserAAAAccessPoolAddressUsage=jnxUserAAAAccessPoolAddressUsage, jnxUserAAAAccessPoolOutOfAddresses=jnxUserAAAAccessPoolOutOfAddresses, jnxUserAAADomainTunnelRoutingInstance=jnxUserAAADomainTunnelRoutingInstance, jnxUserAAAAccessPoolRoutingInstance=jnxUserAAAAccessPoolRoutingInstance, jnxUserAAAAccessProfileEntry=jnxUserAAAAccessProfileEntry, jnxUserAAAAccessPoolAddressUsageHigh=jnxUserAAAAccessPoolAddressUsageHigh, jnxUserAAADomainTargetRoutingInstance=jnxUserAAADomainTargetRoutingInstance, jnxUserAAADomainPadnEntry=jnxUserAAADomainPadnEntry, jnxUserAAADomain=jnxUserAAADomain, PYSNMP_MODULE_ID=jnxUserAAAMib, jnxUserAAADomainStripDomain=jnxUserAAADomainStripDomain, jnxUserAAAAccessProfileAuthorizationOrder=jnxUserAAAAccessProfileAuthorizationOrder, jnxUserAAADomainTunnelPreference=jnxUserAAADomainTunnelPreference, jnxUserAAADomainEntry=jnxUserAAADomainEntry, JnxAccountingType=JnxAccountingType, jnxUserAAADomainOverridePassword=jnxUserAAADomainOverridePassword, jnxUserAAADomainAddrPoolName=jnxUserAAADomainAddrPoolName, jnxAccessAuthServerDisabled=jnxAccessAuthServerDisabled, jnxUserAAADomainStripUsername=jnxUserAAADomainStripUsername)

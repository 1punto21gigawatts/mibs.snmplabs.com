#
# PySNMP MIB module PROTEON-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/PROTEON-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:13:40 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsUnion, ValueSizeConstraint, ValueRangeConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsUnion", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsIntersection")
ifIndex, = mibBuilder.importSymbols("IF-MIB", "ifIndex")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Bits, TimeTicks, ObjectIdentity, enterprises, iso, IpAddress, NotificationType, Unsigned32, Integer32, Counter64, ModuleIdentity, MibIdentifier, Counter32, MibScalar, MibTable, MibTableRow, MibTableColumn, NotificationType, Gauge32 = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "TimeTicks", "ObjectIdentity", "enterprises", "iso", "IpAddress", "NotificationType", "Unsigned32", "Integer32", "Counter64", "ModuleIdentity", "MibIdentifier", "Counter32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "NotificationType", "Gauge32")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
proteon = MibIdentifier((1, 3, 6, 1, 4, 1, 1))
proAdmin = MibIdentifier((1, 3, 6, 1, 4, 1, 1, 1))
proSystem = MibIdentifier((1, 3, 6, 1, 4, 1, 1, 6))
proSysObjId = MibIdentifier((1, 3, 6, 1, 4, 1, 1, 1, 1))
proStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 1, 1, 2))
proPriv = MibIdentifier((1, 3, 6, 1, 4, 1, 1, 1, 5))
proResource = MibIdentifier((1, 3, 6, 1, 4, 1, 1, 6, 1))
proEls = MibIdentifier((1, 3, 6, 1, 4, 1, 1, 6, 2))
proTemp = MibIdentifier((1, 3, 6, 1, 4, 1, 1, 6, 3))
proConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 1, 6, 4))
proResMemory = MibIdentifier((1, 3, 6, 1, 4, 1, 1, 6, 1, 1))
proResBuffers = MibIdentifier((1, 3, 6, 1, 4, 1, 1, 6, 1, 2))
proResMemHeap = MibIdentifier((1, 3, 6, 1, 4, 1, 1, 6, 1, 1, 1))
proResMemBuf = MibIdentifier((1, 3, 6, 1, 4, 1, 1, 6, 1, 1, 2))
proResBufGlobal = MibIdentifier((1, 3, 6, 1, 4, 1, 1, 6, 1, 2, 1))
proElsTrapSeqs = MibScalar((1, 3, 6, 1, 4, 1, 1, 1, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: proElsTrapSeqs.setStatus('deprecated')
if mibBuilder.loadTexts: proElsTrapSeqs.setDescription('ELS trap sequence number')
proElsTrapSubSystem = MibScalar((1, 3, 6, 1, 4, 1, 1, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: proElsTrapSubSystem.setStatus('deprecated')
if mibBuilder.loadTexts: proElsTrapSubSystem.setDescription('ELS trap subsystem number')
proElsTrapEvent = MibScalar((1, 3, 6, 1, 4, 1, 1, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: proElsTrapEvent.setStatus('deprecated')
if mibBuilder.loadTexts: proElsTrapEvent.setDescription('ELS trap event number')
proElsTrapVar1 = MibIdentifier((1, 3, 6, 1, 4, 1, 1, 1, 1, 5))
proElsTrapVar2 = MibIdentifier((1, 3, 6, 1, 4, 1, 1, 1, 1, 6))
proElsTrapVar3 = MibIdentifier((1, 3, 6, 1, 4, 1, 1, 1, 1, 7))
proElsTrapVar4 = MibIdentifier((1, 3, 6, 1, 4, 1, 1, 1, 1, 8))
proElsTrapVar5 = MibIdentifier((1, 3, 6, 1, 4, 1, 1, 1, 1, 9))
proElsTrapVar6 = MibIdentifier((1, 3, 6, 1, 4, 1, 1, 1, 1, 10))
proElsTrapVar7 = MibIdentifier((1, 3, 6, 1, 4, 1, 1, 1, 1, 11))
proElsTrapVar8 = MibIdentifier((1, 3, 6, 1, 4, 1, 1, 1, 1, 12))
proElsTrapVar9 = MibIdentifier((1, 3, 6, 1, 4, 1, 1, 1, 1, 13))
proElsGeneric = MibIdentifier((1, 3, 6, 1, 4, 1, 1, 6, 2, 1))
class ProElsMsgLogLevel(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))
    namedValues = NamedValues(("other", 1), ("proMsgLevelUIError", 2), ("proMsgLevelCIError", 3), ("proMsgLevelUEError", 4), ("proMsgLevelCEError", 5), ("proMsgLevelError", 6), ("proMsgLevelUInfo", 7), ("proMsgLevelCInfo", 8), ("proMsgLevelInfo", 9), ("proMsgLevelPTrace", 10), ("proMsgLevelUTrace", 11), ("proMsgLevelCTrace", 12), ("proMsgLevelTrace", 13), ("proMsgLevelAlways", 14), ("proMsgLevelStandard", 15), ("proMsgLevelAll", 16))

class ProElsLogStatus(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("proElsLogDisabled", 1), ("proElsLogEnabled", 2))

proSysObjIdP4100 = MibIdentifier((1, 3, 6, 1, 4, 1, 1, 1, 1, 41))
proSysObjIdP4200 = MibIdentifier((1, 3, 6, 1, 4, 1, 1, 1, 1, 42))
proSysObjIdDNX300 = MibIdentifier((1, 3, 6, 1, 4, 1, 1, 1, 1, 43))
proSysObjIdCNX400 = MibIdentifier((1, 3, 6, 1, 4, 1, 1, 1, 1, 44))
proSysObjIdCNX600 = MibIdentifier((1, 3, 6, 1, 4, 1, 1, 1, 1, 46))
proSysObjIdRBX200 = MibIdentifier((1, 3, 6, 1, 4, 1, 1, 1, 1, 47))
proSysObjIdCNX500 = MibIdentifier((1, 3, 6, 1, 4, 1, 1, 1, 1, 49))
proSysObjIdRBX250 = MibIdentifier((1, 3, 6, 1, 4, 1, 1, 1, 1, 50))
proSysObjIdBOSS3Slot = MibIdentifier((1, 3, 6, 1, 4, 1, 1, 1, 1, 53))
proSysObjIdBOSSs90 = MibIdentifier((1, 3, 6, 1, 4, 1, 1, 1, 1, 54))
proActionReset = MibScalar((1, 3, 6, 1, 4, 1, 1, 1, 5, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: proActionReset.setStatus('mandatory')
if mibBuilder.loadTexts: proActionReset.setDescription('This object, when read, returns a value of zero. A set of this object causes the router to be reset. The value represents the delay (in seconds) before the reset will take affect. This object should only be SET to 0 or a positive number')
proActionReload = MibScalar((1, 3, 6, 1, 4, 1, 1, 1, 5, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: proActionReload.setStatus('mandatory')
if mibBuilder.loadTexts: proActionReload.setDescription('This object, when read, returns a value of zero. A set of this object causes the router to be reloaded. The value represents the delay (in seconds) before the reload will take affect. This object should only be SET to 0 or a positive number')
proStatusReloadTime = MibScalar((1, 3, 6, 1, 4, 1, 1, 1, 2, 1), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: proStatusReloadTime.setStatus('mandatory')
if mibBuilder.loadTexts: proStatusReloadTime.setDescription('The time (in hundredths of a second) since the last time the router software was reloaded.')
proStatusStarts = MibScalar((1, 3, 6, 1, 4, 1, 1, 1, 2, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: proStatusStarts.setStatus('mandatory')
if mibBuilder.loadTexts: proStatusStarts.setDescription('The number of times the router has started since the last reload.')
proStatusCrashes = MibScalar((1, 3, 6, 1, 4, 1, 1, 1, 2, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: proStatusCrashes.setStatus('mandatory')
if mibBuilder.loadTexts: proStatusCrashes.setDescription('The number of times the router has crashed since the last reload. Only those crashes that caused the router to deliberately restart due to a software error are counted by this object.')
proStatusCrashMsg = MibScalar((1, 3, 6, 1, 4, 1, 1, 1, 2, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: proStatusCrashMsg.setStatus('mandatory')
if mibBuilder.loadTexts: proStatusCrashMsg.setDescription('The last crash message. The message will indicate if the router has not crashed since the last reload.')
proResMemHeapTotal = MibScalar((1, 3, 6, 1, 4, 1, 1, 6, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: proResMemHeapTotal.setStatus('mandatory')
if mibBuilder.loadTexts: proResMemHeapTotal.setDescription('The total number of bytes of heap memory available for allocation.')
proResMemHeapReserve = MibScalar((1, 3, 6, 1, 4, 1, 1, 6, 1, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: proResMemHeapReserve.setStatus('mandatory')
if mibBuilder.loadTexts: proResMemHeapReserve.setDescription('The minimum amount of memory needed by the currently configured protocols and features.')
proResMemHeapNeverAlloc = MibScalar((1, 3, 6, 1, 4, 1, 1, 6, 1, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: proResMemHeapNeverAlloc.setStatus('mandatory')
if mibBuilder.loadTexts: proResMemHeapNeverAlloc.setDescription('The memory that has never been allocated.')
proResMemHeapPermAlloc = MibScalar((1, 3, 6, 1, 4, 1, 1, 6, 1, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: proResMemHeapPermAlloc.setStatus('mandatory')
if mibBuilder.loadTexts: proResMemHeapPermAlloc.setDescription('The memory that is permanently allocated to router tasks.')
proResMemHeapTempAlloc = MibScalar((1, 3, 6, 1, 4, 1, 1, 6, 1, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: proResMemHeapTempAlloc.setStatus('mandatory')
if mibBuilder.loadTexts: proResMemHeapTempAlloc.setDescription('The memory that is temporarily allocated to router tasks.')
proResMemHeapPrevAlloc = MibScalar((1, 3, 6, 1, 4, 1, 1, 6, 1, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: proResMemHeapPrevAlloc.setStatus('mandatory')
if mibBuilder.loadTexts: proResMemHeapPrevAlloc.setDescription('The memory that was temporarily allocated and returned to the free pool.')
proResMemBufTotal = MibScalar((1, 3, 6, 1, 4, 1, 1, 6, 1, 1, 2, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: proResMemBufTotal.setStatus('mandatory')
if mibBuilder.loadTexts: proResMemBufTotal.setDescription('The total number of bytes of buffer memory available for allocation.')
proResMemBufReserve = MibScalar((1, 3, 6, 1, 4, 1, 1, 6, 1, 1, 2, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: proResMemBufReserve.setStatus('mandatory')
if mibBuilder.loadTexts: proResMemBufReserve.setDescription('The minimum amount of memory needed by the currently configured protocols and features.')
proResMemBufNeverAlloc = MibScalar((1, 3, 6, 1, 4, 1, 1, 6, 1, 1, 2, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: proResMemBufNeverAlloc.setStatus('mandatory')
if mibBuilder.loadTexts: proResMemBufNeverAlloc.setDescription('The memory that has never been allocated.')
proResMemBufPermAlloc = MibScalar((1, 3, 6, 1, 4, 1, 1, 6, 1, 1, 2, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: proResMemBufPermAlloc.setStatus('mandatory')
if mibBuilder.loadTexts: proResMemBufPermAlloc.setDescription('The memory that is permanently allocated to router tasks.')
proResBufGlobalTotal = MibScalar((1, 3, 6, 1, 4, 1, 1, 6, 1, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: proResBufGlobalTotal.setStatus('mandatory')
if mibBuilder.loadTexts: proResBufGlobalTotal.setDescription('The total number of global buffers in the system.')
proResBufGlobalFree = MibScalar((1, 3, 6, 1, 4, 1, 1, 6, 1, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: proResBufGlobalFree.setStatus('mandatory')
if mibBuilder.loadTexts: proResBufGlobalFree.setDescription('The total number of free buffers in the system.')
proResBufGlobalFair = MibScalar((1, 3, 6, 1, 4, 1, 1, 6, 1, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: proResBufGlobalFair.setStatus('mandatory')
if mibBuilder.loadTexts: proResBufGlobalFair.setDescription("The 'fair' number of buffers for each interface.")
proResBufGlobalLow = MibScalar((1, 3, 6, 1, 4, 1, 1, 6, 1, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: proResBufGlobalLow.setStatus('mandatory')
if mibBuilder.loadTexts: proResBufGlobalLow.setDescription("The low mark for free buffers. If the value of proResBufGlobalFree is less than this object then freed buffers will not be placed on any queue that has more than the 'fair' number of buffers on it.")
proResBufTable = MibTable((1, 3, 6, 1, 4, 1, 1, 6, 1, 2, 2), )
if mibBuilder.loadTexts: proResBufTable.setStatus('mandatory')
if mibBuilder.loadTexts: proResBufTable.setDescription('The per-port buffer table.')
proResBufTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1, 6, 1, 2, 2, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: proResBufTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: proResBufTableEntry.setDescription('An entry indicating the buffers allocated per interface.')
proResInputBufsReq = MibTableColumn((1, 3, 6, 1, 4, 1, 1, 6, 1, 2, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: proResInputBufsReq.setStatus('mandatory')
if mibBuilder.loadTexts: proResInputBufsReq.setDescription('The number of buffers requested for this interface.')
proResInputBufsAlloc = MibTableColumn((1, 3, 6, 1, 4, 1, 1, 6, 1, 2, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: proResInputBufsAlloc.setStatus('mandatory')
if mibBuilder.loadTexts: proResInputBufsAlloc.setDescription('The number of buffers allocated for this interface.')
proResInputBufsLow = MibTableColumn((1, 3, 6, 1, 4, 1, 1, 6, 1, 2, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: proResInputBufsLow.setStatus('mandatory')
if mibBuilder.loadTexts: proResInputBufsLow.setDescription('The low water mark for number of buffers.')
proResInputBufsCurrent = MibTableColumn((1, 3, 6, 1, 4, 1, 1, 6, 1, 2, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: proResInputBufsCurrent.setStatus('mandatory')
if mibBuilder.loadTexts: proResInputBufsCurrent.setDescription('The current number of buffers for this device. A value of zero indicates that the device is disabled. If, on receipt of a packet, the value of this object is less than proResInputBufsLow than the packet is eligible for flow control.')
proResInputBufsSize = MibTableColumn((1, 3, 6, 1, 4, 1, 1, 6, 1, 2, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: proResInputBufsSize.setStatus('mandatory')
if mibBuilder.loadTexts: proResInputBufsSize.setDescription('The size, in bytes, of each buffer allocated to this interface.')
proResInputBufsTotalBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 1, 6, 1, 2, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: proResInputBufsTotalBytes.setStatus('mandatory')
if mibBuilder.loadTexts: proResInputBufsTotalBytes.setDescription('The total number of bytes allocated to this interface. This is obtained by multiplying proResInputBufsAlloc by proResInputBufsSize.')
proElsPin = MibScalar((1, 3, 6, 1, 4, 1, 1, 6, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: proElsPin.setStatus('mandatory')
if mibBuilder.loadTexts: proElsPin.setDescription('The number of ELS enterprise specific traps which may be generated per second. A value of zero indicates no limit. This object reflects the operational pin value currently in use by ELS. A SET of this object immediately affects ELS. This variable should only be SET to a value in the range 0 to 65535.')
proElsDropped = MibScalar((1, 3, 6, 1, 4, 1, 1, 6, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: proElsDropped.setStatus('mandatory')
if mibBuilder.loadTexts: proElsDropped.setDescription('The number of ELS enterprise specific traps which were not sent because the pin had been reached.')
proElsTimestamp = MibScalar((1, 3, 6, 1, 4, 1, 1, 6, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("proTSOff", 1), ("proTSSysUpTime", 2), ("proTSTimeOfDay", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: proElsTimestamp.setStatus('mandatory')
if mibBuilder.loadTexts: proElsTimestamp.setDescription('This object indicates whether ELS messages should be timestamped and, if yes, the timebase to use. Setting the object to proTSOff(1) disables timestamping. Setting the object to proTSSysUpTime(2) uses the sysUpTime value as the timestamp. Setting the object to proTSTimeOfDay(3) uses the real-time clock value as the timestamp. This object reflects the operational timestamp value currently in use by ELS. A SET of this object immediately affects ELS.')
proElsAction = MibScalar((1, 3, 6, 1, 4, 1, 1, 6, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("proElsActionClear", 2), ("proElsActionDefault", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: proElsAction.setStatus('mandatory')
if mibBuilder.loadTexts: proElsAction.setDescription('A read of this object always returns the value other(1). Setting the object to elsActionClear(2) clears all ELS configuration. Specifically, this clears all ELS related sram records. This action is the same as entering the <clear> command at the ELS config menu in the gateway console. Setting the object to proElsActionDefault(3) turns off logging of ELS events to both the console and SNMP traps for all configured subsystems. Note that it only affects subsystem configuration and not individual event or group configuration. A SET of this object affects the configuration values defined for ELS, but not the current operational parameters. Therefore, these changes will only become active when the configuration is updated.')
proElsTrapVersion = MibScalar((1, 3, 6, 1, 4, 1, 1, 6, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("proElsTrapVersionV1", 1), ("proElsTrapVersionV2", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: proElsTrapVersion.setStatus('mandatory')
if mibBuilder.loadTexts: proElsTrapVersion.setDescription('The format of the ELS trap has been changed so that the trap info is more useful to a majority of net managers. It now contains the fully constructed ELS message text, as opposed to the values that are presented in the text. See the ELS enterprise specific trap definition for more information.')
proElsSubSysTable = MibTable((1, 3, 6, 1, 4, 1, 1, 6, 2, 2), )
if mibBuilder.loadTexts: proElsSubSysTable.setStatus('mandatory')
if mibBuilder.loadTexts: proElsSubSysTable.setDescription('The ELS sub-system table.')
proElsSubSysTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1, 6, 2, 2, 1), ).setIndexNames((0, "PROTEON-MIB", "proElsSubSysIndex"))
if mibBuilder.loadTexts: proElsSubSysTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: proElsSubSysTableEntry.setDescription('An entry corresponding to a specific subsystem.')
proElsSubSysIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1, 6, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 5, 10, 11, 12, 13, 14, 15, 17, 18, 19, 21, 22, 25, 30, 35, 40, 41, 42, 43, 53, 54, 56, 60, 72, 73, 74, 75, 81, 83, 84, 85, 88, 90, 92, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 119, 120, 121, 123, 124, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154))).clone(namedValues=NamedValues(("proElsSubSysIndexGw", 1), ("proElsSubSysIndexFlt", 2), ("proElsSubSysIndexBrs", 3), ("proElsSubSysIndexArp", 5), ("proElsSubSysIndexIp", 10), ("proElsSubSysIndexIcmp", 11), ("proElsSubSysIndexTcp", 12), ("proElsSubSysIndexUdp", 13), ("proElsSubSysIndexBtp", 14), ("proElsSubSysIndexRip", 15), ("proElsSubSysIndexSpf", 17), ("proElsSubSysIndexMspf", 18), ("proElsSubSysIndexTftp", 19), ("proElsSubSysIndexSnmp", 21), ("proElsSubSysIndexDvm", 22), ("proElsSubSysIndexDn", 25), ("proElsSubSysIndexXn", 30), ("proElsSubSysIndexIpx", 35), ("proElsSubSysIndexIso", 40), ("proElsSubSysIndexEsis", 41), ("proElsSubSysIndexIsis", 42), ("proElsSubSysIndexDnav", 43), ("proElsSubSysIndexAp2", 53), ("proElsSubSysIndexZip2", 54), ("proElsSubSysIndexR2mp", 56), ("proElsSubSysIndexVin", 60), ("proElsSubSysIndexSrt", 72), ("proElsSubSysIndexStp", 73), ("proElsSubSysIndexBr", 74), ("proElsSubSysIndexSrly", 75), ("proElsSubSysIndexEth", 81), ("proElsSubSysIndexSl", 83), ("proElsSubSysIndexTkr", 84), ("proElsSubSysIndexX25", 85), ("proElsSubSysIndexFddi", 88), ("proElsSubSysIndexSdlc", 90), ("proElsSubSysIndexFr", 92), ("proElsSubSysIndexPpp", 95), ("proElsSubSysIndexX251", 96), ("proElsSubSysIndexX252", 97), ("proElsSubSysIndexX253", 98), ("proElsSubSysIndexIsdn", 99), ("proElsSubSysIndexIppn", 100), ("proElsSubSysIndexWrs", 101), ("proElsSubSysIndexLnm", 102), ("proElsSubSysIndexLlc", 103), ("proElsSubSysIndexBgp", 104), ("proElsSubSysIndexMcf", 105), ("proElsSubSysIndexDls", 107), ("proElsSubSysIndexV25b", 108), ("proElsSubSysIndexEzstrt", 109), ("proElsSubSysIndexAi", 110), ("proElsSubSysIndexBan", 111), ("proElsSubSysIndexEnv", 112), ("proElsSubSysIndexCmp", 113), ("proElsSubSysIndexNbs", 114), ("proElsSubSysIndexAtm", 115), ("proElsSubSysIndexLec", 116), ("proElsSubSysIndexAppn", 117), ("proElsSubSysIndexIlmi", 119), ("proElsSubSysIndexSaal", 120), ("proElsSubSysIndexSvc", 121), ("proElsSubSysIndexLes", 123), ("proElsSubSysIndexLecs", 124), ("proElsSubSysIndexEvlog", 126), ("proElsSubSysIndexNot", 127), ("proElsSubSysIndexMars", 128), ("proElsSubSysIndexMcs", 129), ("proElsSubSysIndexIlec", 130), ("proElsSubSysIndexNhrp", 131), ("proElsSubSysIndexXtp", 132), ("proElsSubSysIndexEsc", 133), ("proElsSubSysIndexBbcm", 134), ("proElsSubSysIndexLcs", 135), ("proElsSubSysIndexLsa", 136), ("proElsSubSysIndexMpc", 137), ("proElsSubSysIndexRsvp", 138), ("proElsSubSysIndexVcrm", 139), ("proElsSubSysIndexScsp", 140), ("proElsSubSysIndexAllc", 141), ("proElsSubSysIndexNdr", 142), ("proElsSubSysIndexV34", 143), ("proElsSubSysIndexDout", 144), ("proElsSubSysIndexMlp", 145), ("proElsSubSysIndexDhcp", 146), ("proElsSubSysIndexSec", 147), ("proElsSubSysIndexEncr", 148), ("proElsSubSysIndexPm", 149), ("proElsSubSysIndexVlan", 150), ("proElsSubSysIndexDgw", 151), ("proElsSubSysIndexQllc", 152), ("proElsSubSysIndexAris", 153), ("proElsSubSysIndexGsmp", 154)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: proElsSubSysIndex.setStatus('mandatory')
if mibBuilder.loadTexts: proElsSubSysIndex.setDescription('This object is used to identify a specific subsystem.')
proElsSubSysDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 1, 6, 2, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: proElsSubSysDescr.setStatus('mandatory')
if mibBuilder.loadTexts: proElsSubSysDescr.setDescription('This is a textual string indicating the name of the subsystem.')
proElsSubSysNumEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 1, 6, 2, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: proElsSubSysNumEvents.setStatus('mandatory')
if mibBuilder.loadTexts: proElsSubSysNumEvents.setDescription('The number of events defined for this subsystem.')
proElsSubSysDisplayEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 1, 6, 2, 2, 1, 4), ProElsMsgLogLevel()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: proElsSubSysDisplayEnable.setStatus('mandatory')
if mibBuilder.loadTexts: proElsSubSysDisplayEnable.setDescription('A read of this object always returns the value other(1). To check the current value, use the proElsSubSysCurrDisplayLevel variable. A SET of this object to one of the other enumerated values has the effect of enabling ELS events of the specified level to the console. For 2210 platform, this SET changes the configuration parameters and also immediately affects the operational parameters in use by ELS. For other platforms, this SET only affects the configuration parameters and not the current operational parameters in use by ELS. So in order for these changes to take effect, the configuration must be updated.')
proElsSubSysDisplayDisable = MibTableColumn((1, 3, 6, 1, 4, 1, 1, 6, 2, 2, 1, 5), ProElsMsgLogLevel()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: proElsSubSysDisplayDisable.setStatus('mandatory')
if mibBuilder.loadTexts: proElsSubSysDisplayDisable.setDescription('A read of this object always returns the value other(1). To check the current value, use the proElsSubSysCurrDisplayLevel variable. A SET of this object to one of the other enumerated values has the effect of disabling ELS events of the specified level to the console. For 2210 platform, this SET changes the configuration parameters and also immediately affects the operational parameters in use by ELS. For other platforms, this SET only affects the configuration parameters and not the current operational parameters in use by ELS. So in order for these changes to take effect, the configuration must be updated.')
proElsSubSysTrapEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 1, 6, 2, 2, 1, 6), ProElsMsgLogLevel()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: proElsSubSysTrapEnable.setStatus('mandatory')
if mibBuilder.loadTexts: proElsSubSysTrapEnable.setDescription('A read of this object always returns the value other(1). To check the current value, use the proElsSubSysCurrTrapLevel variable. A SET of this object to one of the other enumerated values has the effect of enabling ELS events of the specified level to be sent via an SNMP trap. For 2210 platform, this SET changes the configuration parameters and also immediately affects the operational parameters in use by ELS. For other platforms, this SET only affects the configuration parameters and not the current operational parameters in use by ELS. So in order for these changes to take effect, the configuration must be updated.')
proElsSubSysTrapDisable = MibTableColumn((1, 3, 6, 1, 4, 1, 1, 6, 2, 2, 1, 7), ProElsMsgLogLevel()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: proElsSubSysTrapDisable.setStatus('mandatory')
if mibBuilder.loadTexts: proElsSubSysTrapDisable.setDescription('A read of this object always returns the value other(1). To check the current value, use the proElsSubSysCurrTrapLevel variable. A SET of this object to one of the other enumerated values has the effect of disabling ELS events of the specified level to be sent via an SNMP trap. For 2210 platform, this SET changes the configuration parameters and also immediately affects the operational parameters in use by ELS. For other platforms, this SET only affects the configuration parameters and not the current operational parameters in use by ELS. So in order for these changes to take effect, the configuration must be updated.')
proElsSubSysCurrDisplayLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 1, 6, 2, 2, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: proElsSubSysCurrDisplayLevel.setStatus('mandatory')
if mibBuilder.loadTexts: proElsSubSysCurrDisplayLevel.setDescription('The current event log levels that are enabled for display to console. This information reflects the configuration values not the current operational parameters in use by ELS. The value represents a bit string having a bit defined for each of the values defined in the ProElsMsgLogLevel textual convention (excluding the other(1) value, which is not relevant here.) The bit string is interpretted as follows: Bit 15 Bit 1 .............................................. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .............................................. 1 1 1 1 1 1 1 9 8 7 6 5 4 3 2 <== proElsMsgLogLevel 6 5 4 3 2 1 0 value For example: proMsgLevelUIError(2), bit 1 proMsgLevelCIError(3), bit 2 etc. Note also that the levels: proMsgLevelError proMsgLevelInfo proMsgLevelTrace proMsgLevelStandard proMsgLevelAll are aggregates of other logging levels. So, for example, turning on proMsgLogLevelError(6) will turn on (set the bits) for all sub-levels in this category (i.e values 2,3,4 and 5). Although this MIB variable can take on many values based on what combination of levels is enabled, the following represents the values of this MIB variable assuming just the given level is enabled: Level Set Value ========= ===== proMsgLevelUIError(2) 1 proMsgLevelCIError(3) 2 proMsgLevelUEError(4) 4 proMsgLevelCEError(5) 8 proMsgLevelError(6) 15 proMsgLevelUInfo(7) 16 proMsgLevelCInfo(8) 32 proMsgLevelInfo(9) 48 proMsgLevelPTrace(10) 256 proMsgLevelUTrace(11) 512 proMsgLevelCTrace(12) 1024 proMsgLevelTrace(13) 1792 proMsgLevelAlways(14) 32768 proMsgLevelStandard(15) 31 proMsgLevelAll(16) 61439 No level set 0 A value of 0 means no ELS logging is enabled.')
proElsSubSysCurrTrapLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 1, 6, 2, 2, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: proElsSubSysCurrTrapLevel.setStatus('mandatory')
if mibBuilder.loadTexts: proElsSubSysCurrTrapLevel.setDescription('The current event log levels that are enabled for sending via SNMP trap. This information reflects the configuration values not the current operational parameters in use by ELS. The value represents a bit string having a bit defined for each of the values defined in the ProElsMsgLogLevel textual convention (excluding the other(1) value, which is not relevant here.) The bit string is interpretted as follows: Bit 15 Bit 1 .............................................. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .............................................. 1 1 1 1 1 1 1 9 8 7 6 5 4 3 2 <== proElsMsgLogLevel 6 5 4 3 2 1 0 value For example: proMsgLevelUIError(2), bit 1 proMsgLevelCIError(3), bit 2 etc. Note also that the levels: proMsgLevelError proMsgLevelInfo proMsgLevelTrace proMsgLevelStandard proMsgLevelAll are aggregates of other logging levels. So, for example, turning on proMsgLogLevelError(6) will turn on (set the bits) for all sub-levels in this category (i.e values 2,3,4 and 5). Although this MIB variable can take on many values based on what combination of levels is enabled, the following represents the values of this MIB variable assuming just the given level is enabled: Level Set Value ========= ===== proMsgLevelUIError(2) 1 proMsgLevelCIError(3) 2 proMsgLevelUEError(4) 4 proMsgLevelCEError(5) 8 proMsgLevelError(6) 15 proMsgLevelUInfo(7) 16 proMsgLevelCInfo(8) 32 proMsgLevelInfo(9) 48 proMsgLevelPTrace(10) 256 proMsgLevelUTrace(11) 512 proMsgLevelCTrace(12) 1024 proMsgLevelTrace(13) 1792 proMsgLevelAlways(14) 32768 proMsgLevelStandard(15) 31 proMsgLevelAll(16) 61439 No level set 0 A value of 0 means no ELS logging is enabled.')
proElsSubSysEventTable = MibTable((1, 3, 6, 1, 4, 1, 1, 6, 2, 3), )
if mibBuilder.loadTexts: proElsSubSysEventTable.setStatus('mandatory')
if mibBuilder.loadTexts: proElsSubSysEventTable.setDescription('The ELS Sub system event table.')
proElsSubSysEventTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1, 6, 2, 3, 1), ).setIndexNames((0, "PROTEON-MIB", "proElsSubSysIndex"), (0, "PROTEON-MIB", "proElsSubSysEventIndex"))
if mibBuilder.loadTexts: proElsSubSysEventTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: proElsSubSysEventTableEntry.setDescription('An entry corresponding to a specific event in the particular subsystem.')
proElsSubSysEventIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1, 6, 2, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: proElsSubSysEventIndex.setStatus('mandatory')
if mibBuilder.loadTexts: proElsSubSysEventIndex.setDescription('The identifier of the event message for a given subsystem.')
proElsSubSysEventMsg = MibTableColumn((1, 3, 6, 1, 4, 1, 1, 6, 2, 3, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: proElsSubSysEventMsg.setStatus('mandatory')
if mibBuilder.loadTexts: proElsSubSysEventMsg.setDescription('The unformatted textual description for the message. It provides the message text related to this event and indiates where specific information will be filled in when the message is displayed on the console or sent in an SNMP trap. For example, the text for the IP.008 event is: no rte %I -> %I dsc When sent in an SNMP trap, the variable binding of the trap has this text with the specific IP addresses fillled in. The format of this string is one of the two following formats: If ELS timestamping is enabled: hr:min:sec subsys_name.event_num: message_text For example - 09:32:56 IP.008: no rte 9.7.1.8 -> 9.7.4.3 dsc If ELS timestamping is disabled: subsys_name.event_num: message_text For example - IP.008: no rte 9.7.1.8 -> 9.7.4.3 dsc')
proElsSubSysEventCount = MibTableColumn((1, 3, 6, 1, 4, 1, 1, 6, 2, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: proElsSubSysEventCount.setStatus('mandatory')
if mibBuilder.loadTexts: proElsSubSysEventCount.setDescription('The number of times this event has occurred. This number will increment even if the event is not enabled to be displayed on the console or sent in an SNMP trap.')
proElsSubSysEventLogLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 1, 6, 2, 3, 1, 4), ProElsMsgLogLevel()).setMaxAccess("readonly")
if mibBuilder.loadTexts: proElsSubSysEventLogLevel.setStatus('mandatory')
if mibBuilder.loadTexts: proElsSubSysEventLogLevel.setDescription('The pre-defined setting that classifies this message.')
proElsSubSysEventLogToConsole = MibTableColumn((1, 3, 6, 1, 4, 1, 1, 6, 2, 3, 1, 5), ProElsLogStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: proElsSubSysEventLogToConsole.setStatus('mandatory')
if mibBuilder.loadTexts: proElsSubSysEventLogToConsole.setDescription('This object indicates whether this event should be logged to the console. For 2210 platform, this SET changes the configuration parameters and also immediately affects the operational parameters in use by ELS. For other platforms, this SET only affects the configuration parameters and not the current operational parameters in use by ELS. So in order for these changes to take effect, the configuration must be updated.')
proElsSubSysEventLogToTrap = MibTableColumn((1, 3, 6, 1, 4, 1, 1, 6, 2, 3, 1, 6), ProElsLogStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: proElsSubSysEventLogToTrap.setStatus('mandatory')
if mibBuilder.loadTexts: proElsSubSysEventLogToTrap.setDescription('This object indicates whether this event should be sent as an SNMP trap. For 2210 platform, this SET changes the configuration parameters and also immediately affects the operational parameters in use by ELS. For other platforms, this SET only affects the configuration parameters and not the current operational parameters in use by ELS. So in order for these changes to take effect, the configuration must be updated.')
proElsTrapV1 = NotificationType((1, 3, 6, 1, 4, 1, 1) + (0,1)).setObjects(("PROTEON-MIB", "proElsTrapSeqs"), ("PROTEON-MIB", "proElsTrapSubSystem"), ("PROTEON-MIB", "proElsTrapEvent"))
if mibBuilder.loadTexts: proElsTrapV1.setDescription('An ELS trap event.')
proElsTrapV2 = NotificationType((1, 3, 6, 1, 4, 1, 1) + (0,2)).setObjects(("PROTEON-MIB", "proElsSubSysEventMsg"))
if mibBuilder.loadTexts: proElsTrapV2.setDescription('An ELS trap event. proElsSubSysEventMsg provides a textual description of the event.')
proTempScale = MibScalar((1, 3, 6, 1, 4, 1, 1, 6, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("celsius", 1), ("fahrenheit", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: proTempScale.setStatus('mandatory')
if mibBuilder.loadTexts: proTempScale.setDescription('Indicates the scale used when reporting temperature values. If Celsius(1), all temperature values are in degrees Celsius. If Fahrenheit(2), all temperature values are in degrees Fahrenheit.')
proMaxHwTemp = MibScalar((1, 3, 6, 1, 4, 1, 1, 6, 3, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: proMaxHwTemp.setStatus('mandatory')
if mibBuilder.loadTexts: proMaxHwTemp.setDescription('This attribute indicates the maximum temperature that the thermometer system can record. This attribute is used as an upper bound for all temperature ranges.')
proMinHwTemp = MibScalar((1, 3, 6, 1, 4, 1, 1, 6, 3, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: proMinHwTemp.setStatus('mandatory')
if mibBuilder.loadTexts: proMinHwTemp.setDescription('This attribute indicates the minimum temperature that the thermometer system can record. This attribute is used as a lower bound for all temperature ranges.')
proTempPollPeriod = MibScalar((1, 3, 6, 1, 4, 1, 1, 6, 3, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 600)).clone(60)).setMaxAccess("readonly")
if mibBuilder.loadTexts: proTempPollPeriod.setStatus('mandatory')
if mibBuilder.loadTexts: proTempPollPeriod.setDescription('This attribute determines how often the thermometer system will recalculate the current temperature and any temperature range checks. This value represents time in seconds between temperature recalculations.')
proCurrentTemp = MibScalar((1, 3, 6, 1, 4, 1, 1, 6, 3, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: proCurrentTemp.setStatus('mandatory')
if mibBuilder.loadTexts: proCurrentTemp.setDescription('The current ambient temperature of the system. This value is recalculated by the system once per proTempPollPeriod.')
proLowTempThreshold = MibScalar((1, 3, 6, 1, 4, 1, 1, 6, 3, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: proLowTempThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: proLowTempThreshold.setDescription('The temperature that will cause a Low Temperature Condition to become true. The Low Temperature Condition will become true when: proCurrentTemp <= proLowTempThreshold. The low temperature condition will reset when: proCurrentTemp > (proLowTempThreshold + proTempHysteresis). This range is checked one per proTempPollPeriod.')
proHighTempThreshold = MibScalar((1, 3, 6, 1, 4, 1, 1, 6, 3, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: proHighTempThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: proHighTempThreshold.setDescription('The temperature that will cause a High Temperature Condition to become true. The High Temperature Condition will become true when: proCurrentTemp >= proHighTempThreshold. The high temperature condition will reset when: proCurrentTemp < (proHighTempThreshold - proTempHysteresis). This range is checked one per proTempPollPeriod.')
proTempHysteresis = MibScalar((1, 3, 6, 1, 4, 1, 1, 6, 3, 8), Integer32().clone(5)).setMaxAccess("readonly")
if mibBuilder.loadTexts: proTempHysteresis.setStatus('mandatory')
if mibBuilder.loadTexts: proTempHysteresis.setDescription("The number of degrees that the current ambient temperature must drop below proHighTempThreshold or above proLowTempTheshold before the threshold's condition is deactivated.")
proHighTempCondition = MibScalar((1, 3, 6, 1, 4, 1, 1, 6, 3, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: proHighTempCondition.setStatus('mandatory')
if mibBuilder.loadTexts: proHighTempCondition.setDescription('Indicates whether a High Temperature Condition is active. This attribute will be set ON(2) if a High Temperature Condition is active.')
proLowTempCondition = MibScalar((1, 3, 6, 1, 4, 1, 1, 6, 3, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: proLowTempCondition.setStatus('mandatory')
if mibBuilder.loadTexts: proLowTempCondition.setDescription('Indicates whether a Low Temperature Condition is active. This attribute will be set ON(2) if a Low Temperature Condition is active.')
proHighestTemp = MibScalar((1, 3, 6, 1, 4, 1, 1, 6, 3, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: proHighestTemp.setStatus('mandatory')
if mibBuilder.loadTexts: proHighestTemp.setDescription('This is the highest temperature recorded by the router since last reset.')
proHighTempTime = MibScalar((1, 3, 6, 1, 4, 1, 1, 6, 3, 12), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: proHighTempTime.setStatus('mandatory')
if mibBuilder.loadTexts: proHighTempTime.setDescription('This is the time (in hundreds of seconds) that has elapsed since proHighestTemp was last recorded.')
proLowestTemp = MibScalar((1, 3, 6, 1, 4, 1, 1, 6, 3, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: proLowestTemp.setStatus('mandatory')
if mibBuilder.loadTexts: proLowestTemp.setDescription('This is the lowest temperature recorded by the router since last reset.')
proLowTempTime = MibScalar((1, 3, 6, 1, 4, 1, 1, 6, 3, 14), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: proLowTempTime.setStatus('mandatory')
if mibBuilder.loadTexts: proLowTempTime.setDescription('This is the time (in hundreds of seconds) that has elapsed since proLowestTemp was last recorded.')
proCfgLoad = MibIdentifier((1, 3, 6, 1, 4, 1, 1, 6, 4, 1))
proCfgProtocols = MibScalar((1, 3, 6, 1, 4, 1, 1, 6, 4, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: proCfgProtocols.setStatus('mandatory')
if mibBuilder.loadTexts: proCfgProtocols.setDescription('This object returns an ASCII string containing the short names of all protocol types supported in the current load.')
proCfgDatalinks = MibScalar((1, 3, 6, 1, 4, 1, 1, 6, 4, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: proCfgDatalinks.setStatus('mandatory')
if mibBuilder.loadTexts: proCfgDatalinks.setDescription('This object returns an ASCII string containing the short names of all datalink/MAC types supported in the current load.')
proCfgFeatures = MibScalar((1, 3, 6, 1, 4, 1, 1, 6, 4, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: proCfgFeatures.setStatus('mandatory')
if mibBuilder.loadTexts: proCfgFeatures.setDescription('This object returns an ASCII string containing the short names of all router features supported in the current load.')
mibBuilder.exportSymbols("PROTEON-MIB", proElsTimestamp=proElsTimestamp, proHighTempTime=proHighTempTime, proteon=proteon, proResMemory=proResMemory, proElsSubSysTrapEnable=proElsSubSysTrapEnable, proElsSubSysEventMsg=proElsSubSysEventMsg, proCurrentTemp=proCurrentTemp, proElsSubSysTableEntry=proElsSubSysTableEntry, ProElsLogStatus=ProElsLogStatus, proElsTrapVar2=proElsTrapVar2, proElsSubSysNumEvents=proElsSubSysNumEvents, proElsTrapSeqs=proElsTrapSeqs, proResource=proResource, proHighestTemp=proHighestTemp, proElsTrapVar4=proElsTrapVar4, proElsTrapEvent=proElsTrapEvent, proMaxHwTemp=proMaxHwTemp, proSysObjId=proSysObjId, proResInputBufsSize=proResInputBufsSize, proCfgFeatures=proCfgFeatures, proResBufGlobalTotal=proResBufGlobalTotal, proSysObjIdP4100=proSysObjIdP4100, proStatusStarts=proStatusStarts, proSystem=proSystem, proResInputBufsReq=proResInputBufsReq, proSysObjIdBOSS3Slot=proSysObjIdBOSS3Slot, proResMemHeap=proResMemHeap, proResMemHeapTempAlloc=proResMemHeapTempAlloc, proStatusReloadTime=proStatusReloadTime, proResMemBufNeverAlloc=proResMemBufNeverAlloc, proLowTempThreshold=proLowTempThreshold, proElsTrapVar7=proElsTrapVar7, proElsTrapVar6=proElsTrapVar6, proTemp=proTemp, proElsSubSysEventTable=proElsSubSysEventTable, proResMemBuf=proResMemBuf, proResInputBufsAlloc=proResInputBufsAlloc, proHighTempCondition=proHighTempCondition, proLowTempTime=proLowTempTime, proResBuffers=proResBuffers, proElsDropped=proElsDropped, proElsSubSysEventLogToTrap=proElsSubSysEventLogToTrap, proResBufGlobal=proResBufGlobal, proTempPollPeriod=proTempPollPeriod, proElsSubSysCurrTrapLevel=proElsSubSysCurrTrapLevel, proElsSubSysTable=proElsSubSysTable, proStatusCrashMsg=proStatusCrashMsg, proResMemHeapNeverAlloc=proResMemHeapNeverAlloc, proSysObjIdP4200=proSysObjIdP4200, proElsTrapSubSystem=proElsTrapSubSystem, proPriv=proPriv, proStatus=proStatus, proLowTempCondition=proLowTempCondition, proResMemBufTotal=proResMemBufTotal, ProElsMsgLogLevel=ProElsMsgLogLevel, proElsTrapVar5=proElsTrapVar5, proResInputBufsLow=proResInputBufsLow, proElsSubSysEventTableEntry=proElsSubSysEventTableEntry, proResBufGlobalFair=proResBufGlobalFair, proElsSubSysEventLogLevel=proElsSubSysEventLogLevel, proElsSubSysTrapDisable=proElsSubSysTrapDisable, proElsTrapVersion=proElsTrapVersion, proElsSubSysEventLogToConsole=proElsSubSysEventLogToConsole, proElsTrapV1=proElsTrapV1, proConfig=proConfig, proElsTrapVar9=proElsTrapVar9, proResMemHeapPermAlloc=proResMemHeapPermAlloc, proSysObjIdRBX250=proSysObjIdRBX250, proCfgLoad=proCfgLoad, proTempHysteresis=proTempHysteresis, proElsSubSysEventIndex=proElsSubSysEventIndex, proElsPin=proElsPin, proSysObjIdCNX400=proSysObjIdCNX400, proResBufTableEntry=proResBufTableEntry, proElsGeneric=proElsGeneric, proSysObjIdCNX500=proSysObjIdCNX500, proResMemBufPermAlloc=proResMemBufPermAlloc, proElsTrapV2=proElsTrapV2, proCfgDatalinks=proCfgDatalinks, proElsTrapVar8=proElsTrapVar8, proStatusCrashes=proStatusCrashes, proCfgProtocols=proCfgProtocols, proActionReset=proActionReset, proResInputBufsTotalBytes=proResInputBufsTotalBytes, proElsSubSysDisplayDisable=proElsSubSysDisplayDisable, proResBufGlobalLow=proResBufGlobalLow, proElsSubSysCurrDisplayLevel=proElsSubSysCurrDisplayLevel, proSysObjIdDNX300=proSysObjIdDNX300, proElsSubSysDescr=proElsSubSysDescr, proResMemHeapReserve=proResMemHeapReserve, proActionReload=proActionReload, proSysObjIdRBX200=proSysObjIdRBX200, proSysObjIdBOSSs90=proSysObjIdBOSSs90, proElsSubSysIndex=proElsSubSysIndex, proHighTempThreshold=proHighTempThreshold, proResMemBufReserve=proResMemBufReserve, proResInputBufsCurrent=proResInputBufsCurrent, proElsSubSysEventCount=proElsSubSysEventCount, proElsTrapVar1=proElsTrapVar1, proSysObjIdCNX600=proSysObjIdCNX600, proResMemHeapPrevAlloc=proResMemHeapPrevAlloc, proResBufTable=proResBufTable, proElsSubSysDisplayEnable=proElsSubSysDisplayEnable, proResBufGlobalFree=proResBufGlobalFree, proElsAction=proElsAction, proEls=proEls, proTempScale=proTempScale, proLowestTemp=proLowestTemp, proMinHwTemp=proMinHwTemp, proElsTrapVar3=proElsTrapVar3, proAdmin=proAdmin, proResMemHeapTotal=proResMemHeapTotal)

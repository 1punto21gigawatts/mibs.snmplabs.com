#
# PySNMP MIB module CISCO-NETFLOW-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCO-NETFLOW-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:08:21 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ValueRangeConstraint, ValueSizeConstraint, ConstraintsUnion, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ValueRangeConstraint", "ValueSizeConstraint", "ConstraintsUnion", "SingleValueConstraint")
ciscoMgmt, = mibBuilder.importSymbols("CISCO-SMI", "ciscoMgmt")
InterfaceIndex, ifIndex, InterfaceIndexOrZero = mibBuilder.importSymbols("IF-MIB", "InterfaceIndex", "ifIndex", "InterfaceIndexOrZero")
InetPortNumber, InetAutonomousSystemNumber, InetAddressPrefixLength, InetAddress, InetAddressType = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetPortNumber", "InetAutonomousSystemNumber", "InetAddressPrefixLength", "InetAddress", "InetAddressType")
VlanIndex, = mibBuilder.importSymbols("Q-BRIDGE-MIB", "VlanIndex")
ModuleCompliance, ObjectGroup, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "ObjectGroup", "NotificationGroup")
NotificationType, MibIdentifier, Bits, TimeTicks, MibScalar, MibTable, MibTableRow, MibTableColumn, Integer32, ObjectIdentity, Gauge32, Counter32, Counter64, iso, IpAddress, ModuleIdentity, Unsigned32 = mibBuilder.importSymbols("SNMPv2-SMI", "NotificationType", "MibIdentifier", "Bits", "TimeTicks", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Integer32", "ObjectIdentity", "Gauge32", "Counter32", "Counter64", "iso", "IpAddress", "ModuleIdentity", "Unsigned32")
DisplayString, TruthValue, TextualConvention, TimeStamp, RowStatus = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TruthValue", "TextualConvention", "TimeStamp", "RowStatus")
ciscoNetflowMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 9, 9, 387))
ciscoNetflowMIB.setRevisions(('2006-04-27 00:00', '2006-04-20 00:00', '2005-08-30 00:00', '2005-03-27 00:00', '2004-05-18 00:00', '2004-01-09 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ciscoNetflowMIB.setRevisionsDescriptions(('Added the following Group: cnfTopFlowsReportGenerateGroup', 'Added the cache type expBgpPrefix', 'Added the following Groups: cnfMcastNetflowControlGroup cnfBridgedFlowStatsCtrlGroup', 'Removed OBJECT IDENTIFIER ::= { ciscoNetflowMIBObjects 3 }.', 'Added the following objects: cnfTopFlowsGenerate cnfTopFlowsReportAvailable cnfTopFlowsVlan Deprecated the Group cnfTopFlowsGroup. Added the following Groups: cnfTopFlowsDataGroup1 cnfTopFlowsDataGroup2 cnfTopFlowsVlanGroup cnfTopFlowsControlGroup1 cnfTopFlowsControlGroup2', 'Initial version of this MIB module.',))
if mibBuilder.loadTexts: ciscoNetflowMIB.setLastUpdated('200604270000Z')
if mibBuilder.loadTexts: ciscoNetflowMIB.setOrganization('Cisco Systems, Inc.')
if mibBuilder.loadTexts: ciscoNetflowMIB.setContactInfo(' Cisco Systems Customer Service Postal: 170 W Tasman Drive San Jose, CA 95134 USA Tel: +1 800 553-NETS E-mail: cs-netflow-mib@cisco.com')
if mibBuilder.loadTexts: ciscoNetflowMIB.setDescription('The Netflow MIB provides a simple and easy method to get NetFlow cache information, current NetFlow configuration and statistics. It will enable medium to small size enterprises to take advantage of NetFlow technology over SNMP at a reduced infrastructure cost. The MIB is created to provide Netflow information in these areas: 1. Cache information and configuration. 2. Export information and configuration. 4. Export Statistics. 5. Protocol Statistics. 6. Version 9 Export Template information. 7. Top Flows information. Terminology used Flow A flow is defined as an unidirectional sequence of packets between a given source and destination endpoints. Network flows are highly granular; flow endpoints are identified both by IP address as well as by transport layer application port numbers. NetFlow also utilizes the IP Protocol type, Type of Service (ToS) and the input interface identifier to uniquely identify flows. Exporter A device (for example, a router) with NetFlow services enabled. The exporter monitors packets entering an observation point and creates flows out of these packets. The information from these flows are exported in the form of Flow Records to the collector. Flow Record A Flow Record provides information about an IP Flow that exists on the Exporter. The Flow Records are commonly referred to as NetFlow Services data or NetFlow data. Collector The NetFlow Collector receives Flow Records from one or more Exporters. It processes the received export packet, i.e. parses, stores the Flow Record information. The flow records may be optionally aggregated before storing into the hard disk. Template NetFlow Version 9 Export format is template based. Version 9 record format consists of a packet header followed by at least one or more template or data FlowSets. A template FlowSet (collection of one or more template) provides a description of the fields that will be present in future data FlowSets. Templates provide an extensible design to the record format, a feature that should allow future enhancements to NetFlow services without requiring concurrent changes to the basic flow-record format. One additional record type is also a part of Version 9 specification: an options template. Rather than supplying information about IP flows, options are used to supply meta-data about the NetFlow process itself. Top Flows. This feature provides a mechanism which allows the top N flows in the netflow cache to be viewed in real time. Criteria can be set to limit the feature to particular flows of interest, which can aid in DoS detection. Only the number of flows (TopN) and the sort criteria (SortBy) need be set. Top Flows is not intended as a mechanism for exporting the entire netflow cache. Egress flows. This feature provides a mechanism to identify a flow as either an ingress or an egress flow.')
ciscoNetflowMIBNotifs = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 387, 0))
ciscoNetflowMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 387, 1))
ciscoNetflowMIBConform = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 387, 2))
cnfCacheInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 1))
cnfExportInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 2))
cnfExportStatistics = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 4))
cnfProtocolStatistics = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 5))
cnfExportTemplate = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 6))
cnfTopFlows = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 7))
class NfInterfaceDirectionTypes(TextualConvention, Integer32):
    description = 'Defines different types of interface configuration.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))
    namedValues = NamedValues(("interfaceDirNone", 0), ("interfaceDirIngress", 1), ("interfaceDirEgress", 2), ("interfaceDirBoth", 3))

class NfCacheTypes(TextualConvention, Integer32):
    description = 'Defines different types of netflow cache.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 23))
    namedValues = NamedValues(("main", 0), ("as", 1), ("protocolPort", 2), ("sourcePrefix", 3), ("destinationPrefix", 4), ("prefix", 5), ("destinationOnly", 6), ("sourceDestination", 7), ("fullFlow", 8), ("asTos", 9), ("protocolPortTos", 10), ("sourcePrefixTos", 11), ("destinationPrefixTos", 12), ("prefixTos", 13), ("prefixPort", 14), ("bgpNexthopTos", 15), ("expBgpPrefix", 23))

class NfProtocolTypes(TextualConvention, Integer32):
    description = 'Defines different types of protocol and port combination.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22))
    namedValues = NamedValues(("tcpTelnet", 1), ("tcpFtp", 2), ("tcpFtpd", 3), ("tcpWww", 4), ("tcpSmtp", 5), ("tcpX", 6), ("tcpBgp", 7), ("tcpNntp", 8), ("tcpFrag", 9), ("tcpOther", 10), ("udpDns", 11), ("udpNtp", 12), ("udpTftp", 13), ("udpFrag", 14), ("udpOther", 15), ("icmp", 16), ("igmp", 17), ("ipInIp", 18), ("ipv6InIp", 19), ("gre", 20), ("ipOther", 21), ("all", 22))

class NfTemplateTypes(TextualConvention, Integer32):
    description = 'Defines different types of Template.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("template", 1), ("optionTemplate", 2))

class NfTopFlowsSortTypes(TextualConvention, Integer32):
    description = 'Defines different types of sort order.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("noSort", 1), ("byPackets", 2), ("byBytes", 3))

class NfFlowDirectionTypes(TextualConvention, Integer32):
    description = 'Defines different directions for a flow.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2))
    namedValues = NamedValues(("flowDirNone", 0), ("flowDirIngress", 1), ("flowDirEgress", 2))

cnfCIInterfaceTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 1, 1), )
if mibBuilder.loadTexts: cnfCIInterfaceTable.setStatus('current')
if mibBuilder.loadTexts: cnfCIInterfaceTable.setDescription('This table provides Netflow Enable information per interface.')
cnfCIInterfaceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 1, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: cnfCIInterfaceEntry.setStatus('current')
if mibBuilder.loadTexts: cnfCIInterfaceEntry.setDescription('A conceptual row in the cnfCIInterfaceEntry.')
cnfCINetflowEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 1, 1, 1, 1), NfInterfaceDirectionTypes()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cnfCINetflowEnable.setStatus('current')
if mibBuilder.loadTexts: cnfCINetflowEnable.setDescription('Indicates whether the netflow feature is enabled for this interface, and if so, in which directions.')
cnfCIMcastNetflowEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 1, 1, 1, 2), NfInterfaceDirectionTypes()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cnfCIMcastNetflowEnable.setStatus('current')
if mibBuilder.loadTexts: cnfCIMcastNetflowEnable.setDescription('Indicates whether the multicast netflow accounting feature is enabled for this interface, and if so, in which directions.')
cnfCICacheTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 1, 2), )
if mibBuilder.loadTexts: cnfCICacheTable.setStatus('current')
if mibBuilder.loadTexts: cnfCICacheTable.setDescription('A table containing configuration and statistics per cache. Cache may be main cache or an aggregation cache.')
cnfCICacheEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 1, 2, 1), ).setIndexNames((0, "CISCO-NETFLOW-MIB", "cnfCICacheType"))
if mibBuilder.loadTexts: cnfCICacheEntry.setStatus('current')
if mibBuilder.loadTexts: cnfCICacheEntry.setDescription('A conceptual row in the cnfCICacheEntry.')
cnfCICacheType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 1, 2, 1, 1), NfCacheTypes())
if mibBuilder.loadTexts: cnfCICacheType.setStatus('current')
if mibBuilder.loadTexts: cnfCICacheType.setDescription('The type of netflow cache. NetFlow aggregation maintains one or more extra flow caches with different combinations of fields that determine which traditional flows are grouped together.')
cnfCICacheEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 1, 2, 1, 2), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cnfCICacheEnable.setStatus('current')
if mibBuilder.loadTexts: cnfCICacheEnable.setDescription('Indicates whether netflow is enabled for this cache type.')
cnfCICacheEntries = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 1, 2, 1, 3), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cnfCICacheEntries.setStatus('current')
if mibBuilder.loadTexts: cnfCICacheEntries.setDescription('The number of entries that can be cached for this cache type. The accepted value could be limited based on the amount of memory available in the system.')
cnfCIActiveFlows = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 1, 2, 1, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnfCIActiveFlows.setStatus('current')
if mibBuilder.loadTexts: cnfCIActiveFlows.setDescription('Number of currently active flow entries.')
cnfCIInactiveFlows = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 1, 2, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnfCIInactiveFlows.setStatus('current')
if mibBuilder.loadTexts: cnfCIInactiveFlows.setDescription('Number of available flow entries.')
cnfCIActiveTimeOut = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 1, 2, 1, 6), Unsigned32()).setUnits('minutes').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cnfCIActiveTimeOut.setStatus('current')
if mibBuilder.loadTexts: cnfCIActiveTimeOut.setDescription('The timeout period (in minutes) for removing active flows from the cache.')
cnfCIInactiveTimeOut = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 1, 2, 1, 7), Unsigned32()).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cnfCIInactiveTimeOut.setStatus('current')
if mibBuilder.loadTexts: cnfCIInactiveTimeOut.setDescription('The timeout period (in seconds) for removing inactive flows from the cache.')
cnfCIMinSourceMask = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 1, 2, 1, 8), InetAddressPrefixLength()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cnfCIMinSourceMask.setStatus('current')
if mibBuilder.loadTexts: cnfCIMinSourceMask.setDescription("Source route's minimum configured mask bits. This is used to configure the minimum mask for Router Based Aggregation (RBA). Minimum masking capability is available only if RBA is enabled. A value of 0 indicates that this object is not applicable to this cache type.")
cnfCIMinDestinationMask = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 1, 2, 1, 9), InetAddressPrefixLength()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cnfCIMinDestinationMask.setStatus('current')
if mibBuilder.loadTexts: cnfCIMinDestinationMask.setDescription("Destination route's minimum configured mask bits. This is used to configure the minimum mask for Router Based Aggregation (RBA). Minimum masking capability is available only if RBA is enabled. A value of 0 indicates that this object is not applicable to this cache type.")
cnfCIBridgedFlowStatsCtrlTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 1, 3), )
if mibBuilder.loadTexts: cnfCIBridgedFlowStatsCtrlTable.setStatus('current')
if mibBuilder.loadTexts: cnfCIBridgedFlowStatsCtrlTable.setDescription('This table controls the reporting of bridged flow statistics per vlan.')
cnfCIBridgedFlowStatsCtrlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 1, 3, 1), ).setIndexNames((0, "CISCO-NETFLOW-MIB", "cnfCIBridgedFlowVlan"))
if mibBuilder.loadTexts: cnfCIBridgedFlowStatsCtrlEntry.setStatus('current')
if mibBuilder.loadTexts: cnfCIBridgedFlowStatsCtrlEntry.setDescription('A conceptual row in the cnfCIBridgedFlowStatsCtrlTable, containing the configuration of bridged flow statistics per vlan. When a vlan is created in a device supporting this table, a corresponding entry will be added to this table.')
cnfCIBridgedFlowVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 1, 3, 1, 1), VlanIndex())
if mibBuilder.loadTexts: cnfCIBridgedFlowVlan.setStatus('current')
if mibBuilder.loadTexts: cnfCIBridgedFlowVlan.setDescription('Indicates the Vlan number on which the reporting of bridged flow statistics is configured.')
cnfCIBridgedFlowStatsCrtEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 1, 3, 1, 2), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cnfCIBridgedFlowStatsCrtEnable.setStatus('current')
if mibBuilder.loadTexts: cnfCIBridgedFlowStatsCrtEnable.setDescription('Indicates whether the bridged flow creation is enabled for this vlan.')
cnfCIBridgedFlowStatsExpEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 1, 3, 1, 3), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cnfCIBridgedFlowStatsExpEnable.setStatus('current')
if mibBuilder.loadTexts: cnfCIBridgedFlowStatsExpEnable.setDescription('Indicates whether the export of bridged flow statistics is enabled for this vlan.')
cnfCIMcastNetflowRPFFailedEnable = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 1, 4), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cnfCIMcastNetflowRPFFailedEnable.setStatus('current')
if mibBuilder.loadTexts: cnfCIMcastNetflowRPFFailedEnable.setDescription('Indicates whether netflow accounting for multicast data that fails the reverse path forwarding (RPF) check is enabled.')
cnfEIExportInfoTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 2, 1), )
if mibBuilder.loadTexts: cnfEIExportInfoTable.setStatus('current')
if mibBuilder.loadTexts: cnfEIExportInfoTable.setDescription('A table containing information about export configuration per cache type.')
cnfEIExportInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 2, 1, 1), ).setIndexNames((0, "CISCO-NETFLOW-MIB", "cnfCICacheType"))
if mibBuilder.loadTexts: cnfEIExportInfoEntry.setStatus('current')
if mibBuilder.loadTexts: cnfEIExportInfoEntry.setDescription('A conceptual row in the cnfEIExportInfoEntry.')
cnfEIExportVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 2, 1, 1, 1), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cnfEIExportVersion.setStatus('current')
if mibBuilder.loadTexts: cnfEIExportVersion.setDescription('The NetFlow data export version.')
cnfEIPeerAS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 2, 1, 1, 2), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cnfEIPeerAS.setStatus('current')
if mibBuilder.loadTexts: cnfEIPeerAS.setDescription('This object enables collection of AS numbers from a peer autonomous system. cnfEIPeerAS, cnfEIOriginAS and cnfEIBgpNextHop are interdependent.')
cnfEIOriginAS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 2, 1, 1, 3), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cnfEIOriginAS.setStatus('current')
if mibBuilder.loadTexts: cnfEIOriginAS.setDescription('This object enables collection of AS numbers from an origin autonomous system. cnfEIPeerAS, cnfEIOriginAS and cnfEIBgpNextHop are interdependent.')
cnfEIBgpNextHop = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 2, 1, 1, 4), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cnfEIBgpNextHop.setStatus('current')
if mibBuilder.loadTexts: cnfEIBgpNextHop.setDescription('This object enables collection of BGP Next Hops. cnfEIPeerAS, cnfEIOriginAS and cnfEIBgpNextHop are interdependent.')
cnfEIMaxCollectors = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 2, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnfEIMaxCollectors.setStatus('current')
if mibBuilder.loadTexts: cnfEIMaxCollectors.setDescription("Maximum number of entries allowed in the cnfEICollectorTable for each cache type. A zero indicates export is not supported in the device. The agent should set this value during initialization, and the value for this object cannot be changed during the system's operation.")
cnfEICollectorTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 2, 3), )
if mibBuilder.loadTexts: cnfEICollectorTable.setStatus('current')
if mibBuilder.loadTexts: cnfEICollectorTable.setDescription('A control table to configure the collectors that the netflow packets are exported to. The number of entries that can be configured for the cache type is limited by the value of cnfEIMaxCollectors.')
cnfEICollectorEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 2, 3, 1), ).setIndexNames((0, "CISCO-NETFLOW-MIB", "cnfCICacheType"), (0, "CISCO-NETFLOW-MIB", "cnfEICollectorAddressType"), (0, "CISCO-NETFLOW-MIB", "cnfEICollectorAddress"), (0, "CISCO-NETFLOW-MIB", "cnfEICollectorPort"))
if mibBuilder.loadTexts: cnfEICollectorEntry.setStatus('current')
if mibBuilder.loadTexts: cnfEICollectorEntry.setDescription('A conceptual row in the cnfEICollectorEntry.')
cnfEICollectorAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 2, 3, 1, 1), InetAddressType())
if mibBuilder.loadTexts: cnfEICollectorAddressType.setStatus('current')
if mibBuilder.loadTexts: cnfEICollectorAddressType.setDescription('The type of Internet address used by this entry.')
cnfEICollectorAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 2, 3, 1, 2), InetAddress())
if mibBuilder.loadTexts: cnfEICollectorAddress.setStatus('current')
if mibBuilder.loadTexts: cnfEICollectorAddress.setDescription('The Internet address of the collector. This is the address which the Netflow data is exported to.')
cnfEICollectorPort = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 2, 3, 1, 3), InetPortNumber())
if mibBuilder.loadTexts: cnfEICollectorPort.setStatus('current')
if mibBuilder.loadTexts: cnfEICollectorPort.setDescription('The transport port of the collector which the Netflow data is exported to.')
cnfEICollectorStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 2, 3, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cnfEICollectorStatus.setStatus('current')
if mibBuilder.loadTexts: cnfEICollectorStatus.setDescription("This object is used to create or delete an entry in the cnfEICollectorTable. * A row may be created using the 'CreateAndGo' option. When the row is successfully created, the RowStatus would be set to 'active' by the agent. * A row may be deleted by setting the RowStatus to 'destroy'. ")
cnfESSampledPacket = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 4, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnfESSampledPacket.setStatus('current')
if mibBuilder.loadTexts: cnfESSampledPacket.setDescription('Number of Sampled Packet.')
cnfESExportRate = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 4, 2), Counter32()).setUnits('bytes per second').setMaxAccess("readonly")
if mibBuilder.loadTexts: cnfESExportRate.setStatus('current')
if mibBuilder.loadTexts: cnfESExportRate.setDescription('Number of Bytes exported per second.')
cnfESRecordsExported = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 4, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnfESRecordsExported.setStatus('current')
if mibBuilder.loadTexts: cnfESRecordsExported.setDescription('Number of flow statistics records which were exported.')
cnfESPktsExported = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 4, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnfESPktsExported.setStatus('current')
if mibBuilder.loadTexts: cnfESPktsExported.setDescription('Number of packets (udp datagrams) which were exported.')
cnfESPktsFailed = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 4, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnfESPktsFailed.setStatus('current')
if mibBuilder.loadTexts: cnfESPktsFailed.setDescription('Number of times a flow record could not be exported because of a pak allocation failure.')
cnfESPktsDropped = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 4, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnfESPktsDropped.setStatus('current')
if mibBuilder.loadTexts: cnfESPktsDropped.setDescription('Number of export packets which were dropped at the time of ipwrite operation. The reasons for this failure are no FIB, adjacency failure, MTU failed, enqueue failed, IPC failed etc.')
cnfPSPacketSizeDistribution = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 5, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(52, 52)).setFixedLength(52)).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnfPSPacketSizeDistribution.setStatus('current')
if mibBuilder.loadTexts: cnfPSPacketSizeDistribution.setDescription('A string contain IP Packet Size Distribution statistics. Distribution grouping are following :1-32 64 96 128 160 192 224 256 288 320 352 384 416 448 480 512 544 576 1024 1536 2048 2560 3072 3584 4096 4608. Value for each group will be expressed in 2 bytes (in Network byte order) and need to divide by 1000 to get the exact value given by CLI using show ip cache flow command.')
cnfPSLastClearElapsedTime = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 5, 2), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: cnfPSLastClearElapsedTime.setStatus('current')
if mibBuilder.loadTexts: cnfPSLastClearElapsedTime.setDescription('Object indicates time in millisecond since the last clearing time of protocol statistics.')
cnfPSProtocolStatTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 5, 3), )
if mibBuilder.loadTexts: cnfPSProtocolStatTable.setStatus('current')
if mibBuilder.loadTexts: cnfPSProtocolStatTable.setDescription("A table containing statistics per protocol. Information sorted in this table is global in nature (i.e. it's updated for all line cards where netflow is enabled) and follows the Counter64 semantics as described in RFC 2578.")
cnfPSProtocolStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 5, 3, 1), ).setIndexNames((0, "CISCO-NETFLOW-MIB", "cnfPSProtocolType"))
if mibBuilder.loadTexts: cnfPSProtocolStatEntry.setStatus('current')
if mibBuilder.loadTexts: cnfPSProtocolStatEntry.setDescription('A conceptual row in the CnfPSProtocolStatEntry.')
cnfPSProtocolType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 5, 3, 1, 1), NfProtocolTypes())
if mibBuilder.loadTexts: cnfPSProtocolType.setStatus('current')
if mibBuilder.loadTexts: cnfPSProtocolType.setDescription('This object is used as INDEX for protocol statistic table. Protocol type consists of groups based on well known ports and protocols.')
cnfPSExpiredFlows = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 5, 3, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnfPSExpiredFlows.setStatus('current')
if mibBuilder.loadTexts: cnfPSExpiredFlows.setDescription('Number of flows belonging to the same protocol and port that were expired. This counter is incremented when a flow expires due to some reason like time out of flows, event based aging etc.')
cnfPSPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 5, 3, 1, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnfPSPackets.setStatus('current')
if mibBuilder.loadTexts: cnfPSPackets.setDescription('Number of Packets belonging to the same protocol and port which were switched by netflow enabled interface(s). This counter contains the number of Packets switched by all netflow enabled line cards.')
cnfPSBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 5, 3, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnfPSBytes.setStatus('current')
if mibBuilder.loadTexts: cnfPSBytes.setDescription('Number of Bytes belonging to the same protocol and port, which were switched by netflow enabled interface(s). This counter contains the number of Packets switched by all netflow enabled line cards.')
cnfPSActive = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 5, 3, 1, 5), Counter64()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: cnfPSActive.setStatus('current')
if mibBuilder.loadTexts: cnfPSActive.setDescription('This is a summation of active time of all flows belonging to the same protocol and port in milliseconds. The time between first switched packet and last switched packet is measured as the active time of a flow.')
cnfPSInactive = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 5, 3, 1, 6), Counter64()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: cnfPSInactive.setStatus('current')
if mibBuilder.loadTexts: cnfPSInactive.setDescription('This is a summation of inactive time of all flows belonging to the same protocol and port in milliseconds. The time between the last switched packet and expiry of a flow is measured as the inactive time of a flow.')
cnfTemplateOptionsFlag = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 6, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnfTemplateOptionsFlag.setStatus('current')
if mibBuilder.loadTexts: cnfTemplateOptionsFlag.setDescription('Object to indicate Sub- technologies in option template.')
cnfTemplateTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 6, 2), )
if mibBuilder.loadTexts: cnfTemplateTable.setStatus('current')
if mibBuilder.loadTexts: cnfTemplateTable.setDescription('A control table to provide statistics of version 9 Flow and Option templates.')
cnfTemplateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 6, 2, 1), ).setIndexNames((0, "CISCO-NETFLOW-MIB", "cnfTemplateType"))
if mibBuilder.loadTexts: cnfTemplateEntry.setStatus('current')
if mibBuilder.loadTexts: cnfTemplateEntry.setDescription('A conceptual row in the cnfTemplateEntry.')
cnfTemplateType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 6, 2, 1, 1), NfTemplateTypes())
if mibBuilder.loadTexts: cnfTemplateType.setStatus('current')
if mibBuilder.loadTexts: cnfTemplateType.setDescription('Defines the structure and interpretation of fields in a data record and serves as an INDEX in this table. Version 9 has two types of Templates: Flow Templates and Option Templates.')
cnfTemplateAdded = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 6, 2, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnfTemplateAdded.setStatus('current')
if mibBuilder.loadTexts: cnfTemplateAdded.setDescription('Number of templates added.')
cnfTemplateActive = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 6, 2, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnfTemplateActive.setStatus('current')
if mibBuilder.loadTexts: cnfTemplateActive.setDescription('Number of active templates.')
cnfTemplateAgerPolls = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 6, 2, 1, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnfTemplateAgerPolls.setStatus('current')
if mibBuilder.loadTexts: cnfTemplateAgerPolls.setDescription('Number of template ager polls.')
cnfTemplateExportInfoTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 6, 3), )
if mibBuilder.loadTexts: cnfTemplateExportInfoTable.setStatus('current')
if mibBuilder.loadTexts: cnfTemplateExportInfoTable.setDescription('A control table providing information about version 9.')
cnfTemplateExportInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 6, 3, 1), ).setIndexNames((0, "CISCO-NETFLOW-MIB", "cnfCICacheType"))
if mibBuilder.loadTexts: cnfTemplateExportInfoEntry.setStatus('current')
if mibBuilder.loadTexts: cnfTemplateExportInfoEntry.setDescription('A conceptual row in the cnfTemplateExportInfoEntry.')
cnfTemplateExportVer9Enable = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 6, 3, 1, 1), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnfTemplateExportVer9Enable.setStatus('current')
if mibBuilder.loadTexts: cnfTemplateExportVer9Enable.setDescription('Object to indicate whether version 9 export is configured or not.')
cnfTemplateExportVer9TplTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 6, 3, 1, 2), Unsigned32()).setUnits('minutes').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cnfTemplateExportVer9TplTimeout.setStatus('current')
if mibBuilder.loadTexts: cnfTemplateExportVer9TplTimeout.setDescription('Export template time out. Templates are resent after this time.')
cnfTemplateExportVer9OptTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 6, 3, 1, 3), Unsigned32()).setUnits('minutes').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cnfTemplateExportVer9OptTimeout.setStatus('current')
if mibBuilder.loadTexts: cnfTemplateExportVer9OptTimeout.setDescription('Export option time out. Options are resent after this time.')
cnfTemplateExportVer9TplRefreshRate = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 6, 3, 1, 4), Unsigned32()).setUnits('packets').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cnfTemplateExportVer9TplRefreshRate.setStatus('current')
if mibBuilder.loadTexts: cnfTemplateExportVer9TplRefreshRate.setDescription('Template refresh rate. Templates are resent after this many packets.')
cnfTemplateExportVer9OptRefreshRate = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 6, 3, 1, 5), Unsigned32()).setUnits('packets').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cnfTemplateExportVer9OptRefreshRate.setStatus('current')
if mibBuilder.loadTexts: cnfTemplateExportVer9OptRefreshRate.setDescription('Option refresh rate. Options are resent after this many packets.')
cnfTopFlowsTimeStamp = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 7, 1), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnfTopFlowsTimeStamp.setStatus('current')
if mibBuilder.loadTexts: cnfTopFlowsTimeStamp.setDescription('Indicates the time when cnfTopFlowsTable was last updated.')
cnfTopFlowsTopN = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 7, 2), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cnfTopFlowsTopN.setStatus('current')
if mibBuilder.loadTexts: cnfTopFlowsTopN.setDescription('Maximum number of top flows to calculate. A value of 0 disables the Top Flows feature.')
cnfTopFlowsAvailableFlows = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 7, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnfTopFlowsAvailableFlows.setStatus('current')
if mibBuilder.loadTexts: cnfTopFlowsAvailableFlows.setDescription('The number of entries currently available in cnfTopFlowsTable.')
cnfTopFlowsMatchingFlows = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 7, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnfTopFlowsMatchingFlows.setStatus('current')
if mibBuilder.loadTexts: cnfTopFlowsMatchingFlows.setDescription('Total number of matching flows in the netflow cache.')
cnfTopFlowsTotalFlows = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 7, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnfTopFlowsTotalFlows.setStatus('current')
if mibBuilder.loadTexts: cnfTopFlowsTotalFlows.setDescription('Total number of flows in the netflow cache.')
cnfTopFlowsSortBy = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 7, 6), NfTopFlowsSortTypes()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cnfTopFlowsSortBy.setStatus('current')
if mibBuilder.loadTexts: cnfTopFlowsSortBy.setDescription("Indicates how the entries in cnfTopFLowsTable are to be sorted. A value of 'noSort' disables Top Flows.")
cnfTopFlowsCacheTimeout = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 7, 7), Unsigned32()).setUnits('milliseconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cnfTopFlowsCacheTimeout.setStatus('current')
if mibBuilder.loadTexts: cnfTopFlowsCacheTimeout.setDescription('Top Flows Cache timeout. Top flows are cached for this length of time and not recalculated. Configure a high value to ensure the cache does not change during long queries. Setting this object (to any value) will expire the cache.')
cnfTopFlowsTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 7, 8), )
if mibBuilder.loadTexts: cnfTopFlowsTable.setStatus('current')
if mibBuilder.loadTexts: cnfTopFlowsTable.setDescription('Table of flows which have accrued the highest packets or bytes. Each row in the table represents one flow from the cache.')
cnfTopFlowsTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 7, 8, 1), ).setIndexNames((0, "CISCO-NETFLOW-MIB", "cnfTopFlowsIndex"))
if mibBuilder.loadTexts: cnfTopFlowsTableEntry.setStatus('current')
if mibBuilder.loadTexts: cnfTopFlowsTableEntry.setDescription('A conceptual row in the cnfTopFlowsTable.')
cnfTopFlowsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 7, 8, 1, 1), Unsigned32())
if mibBuilder.loadTexts: cnfTopFlowsIndex.setStatus('current')
if mibBuilder.loadTexts: cnfTopFlowsIndex.setDescription('Index to select top flows. A value of 1 selects the topmost flow.')
cnfTopFlowsSrcAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 7, 8, 1, 2), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnfTopFlowsSrcAddressType.setStatus('current')
if mibBuilder.loadTexts: cnfTopFlowsSrcAddressType.setDescription('Type of source address.')
cnfTopFlowsSrcAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 7, 8, 1, 3), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnfTopFlowsSrcAddress.setStatus('current')
if mibBuilder.loadTexts: cnfTopFlowsSrcAddress.setDescription('Source address.')
cnfTopFlowsSrcAddressMask = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 7, 8, 1, 4), InetAddressPrefixLength()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnfTopFlowsSrcAddressMask.setStatus('current')
if mibBuilder.loadTexts: cnfTopFlowsSrcAddressMask.setDescription('Number of bits in source address mask.')
cnfTopFlowsDstAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 7, 8, 1, 5), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnfTopFlowsDstAddressType.setStatus('current')
if mibBuilder.loadTexts: cnfTopFlowsDstAddressType.setDescription('Type of destination address.')
cnfTopFlowsDstAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 7, 8, 1, 6), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnfTopFlowsDstAddress.setStatus('current')
if mibBuilder.loadTexts: cnfTopFlowsDstAddress.setDescription('Destination address.')
cnfTopFlowsDstAddressMask = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 7, 8, 1, 7), InetAddressPrefixLength()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnfTopFlowsDstAddressMask.setStatus('current')
if mibBuilder.loadTexts: cnfTopFlowsDstAddressMask.setDescription('Number of bits in destination address mask.')
cnfTopFlowsNhAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 7, 8, 1, 8), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnfTopFlowsNhAddressType.setStatus('current')
if mibBuilder.loadTexts: cnfTopFlowsNhAddressType.setDescription('The type of nexthop address.')
cnfTopFlowsNhAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 7, 8, 1, 9), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnfTopFlowsNhAddress.setStatus('current')
if mibBuilder.loadTexts: cnfTopFlowsNhAddress.setDescription('Nexthop address.')
cnfTopFlowsSrcPort = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 7, 8, 1, 10), InetPortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnfTopFlowsSrcPort.setStatus('current')
if mibBuilder.loadTexts: cnfTopFlowsSrcPort.setDescription('Source port number.')
cnfTopFlowsDstPort = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 7, 8, 1, 11), InetPortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnfTopFlowsDstPort.setStatus('current')
if mibBuilder.loadTexts: cnfTopFlowsDstPort.setDescription('Destination port number.')
cnfTopFlowsSrcAS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 7, 8, 1, 12), InetAutonomousSystemNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnfTopFlowsSrcAS.setStatus('current')
if mibBuilder.loadTexts: cnfTopFlowsSrcAS.setDescription('Source AS number.')
cnfTopFlowsDstAS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 7, 8, 1, 13), InetAutonomousSystemNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnfTopFlowsDstAS.setStatus('current')
if mibBuilder.loadTexts: cnfTopFlowsDstAS.setDescription('Destination AS number.')
cnfTopFlowsInputIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 7, 8, 1, 14), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnfTopFlowsInputIfIndex.setStatus('current')
if mibBuilder.loadTexts: cnfTopFlowsInputIfIndex.setDescription('Input interface index.')
cnfTopFlowsOutputIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 7, 8, 1, 15), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnfTopFlowsOutputIfIndex.setStatus('current')
if mibBuilder.loadTexts: cnfTopFlowsOutputIfIndex.setDescription('Output interface index.')
cnfTopFlowsFirstSwitched = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 7, 8, 1, 16), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnfTopFlowsFirstSwitched.setStatus('current')
if mibBuilder.loadTexts: cnfTopFlowsFirstSwitched.setDescription('Time flow was first switched.')
cnfTopFlowsLastSwitched = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 7, 8, 1, 17), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnfTopFlowsLastSwitched.setStatus('current')
if mibBuilder.loadTexts: cnfTopFlowsLastSwitched.setDescription('Time flow was last switched.')
cnfTopFlowsTOS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 7, 8, 1, 18), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnfTopFlowsTOS.setStatus('current')
if mibBuilder.loadTexts: cnfTopFlowsTOS.setDescription('Type of service.')
cnfTopFlowsProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 7, 8, 1, 19), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnfTopFlowsProtocol.setStatus('current')
if mibBuilder.loadTexts: cnfTopFlowsProtocol.setDescription('Protocol number.')
cnfTopFlowsTCPFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 7, 8, 1, 20), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnfTopFlowsTCPFlags.setStatus('current')
if mibBuilder.loadTexts: cnfTopFlowsTCPFlags.setDescription('TCP flags.')
cnfTopFlowsSamplerID = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 7, 8, 1, 21), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnfTopFlowsSamplerID.setStatus('current')
if mibBuilder.loadTexts: cnfTopFlowsSamplerID.setDescription('Netflow Sampler ID.')
cnfTopFlowsClassID = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 7, 8, 1, 22), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnfTopFlowsClassID.setStatus('current')
if mibBuilder.loadTexts: cnfTopFlowsClassID.setDescription('Netflow Class ID.')
cnfTopFlowsFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 7, 8, 1, 23), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnfTopFlowsFlags.setStatus('current')
if mibBuilder.loadTexts: cnfTopFlowsFlags.setDescription('Flow flags.')
cnfTopFlowsBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 7, 8, 1, 24), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnfTopFlowsBytes.setStatus('current')
if mibBuilder.loadTexts: cnfTopFlowsBytes.setDescription('Number of bytes in the flow.')
cnfTopFlowsPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 7, 8, 1, 25), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnfTopFlowsPackets.setStatus('current')
if mibBuilder.loadTexts: cnfTopFlowsPackets.setDescription('Number of packets in the flow.')
cnfTopFlowsVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 7, 8, 1, 26), VlanIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnfTopFlowsVlan.setStatus('current')
if mibBuilder.loadTexts: cnfTopFlowsVlan.setDescription('The VLAN-ID of this flow.')
cnfTopFlowsMatchSrcAddressType = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 7, 9), InetAddressType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cnfTopFlowsMatchSrcAddressType.setStatus('current')
if mibBuilder.loadTexts: cnfTopFlowsMatchSrcAddressType.setDescription("Source address type to match. A value of 'unknown' (ie, 0) indicates the source address is not used as a top flows match criteria, and clears the cnfTopFlowsMatchSrcAddress and cnfTopFlowsMatchSrcAddressMask configuration.")
cnfTopFlowsMatchSrcAddress = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 7, 10), InetAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cnfTopFlowsMatchSrcAddress.setStatus('current')
if mibBuilder.loadTexts: cnfTopFlowsMatchSrcAddress.setDescription('Source address prefix to match.')
cnfTopFlowsMatchSrcAddressMask = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 7, 11), InetAddressPrefixLength()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cnfTopFlowsMatchSrcAddressMask.setStatus('current')
if mibBuilder.loadTexts: cnfTopFlowsMatchSrcAddressMask.setDescription('The length of the match source address prefix. This prefix length must be consistent with the address type specified in cnfTopFlowsMatchSrcAddressType. A length of zero only matches the all-zero address of the specified type.')
cnfTopFlowsMatchDstAddressType = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 7, 12), InetAddressType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cnfTopFlowsMatchDstAddressType.setStatus('current')
if mibBuilder.loadTexts: cnfTopFlowsMatchDstAddressType.setDescription("Destination address type to match. A value of 'unknown' (ie, 0) indicates the destination address is not used as a top flows match criteria, and clears the cnfTopFlowsMatchDstAddress and cnfTopFlowsMatchDstAddressMask configuration.")
cnfTopFlowsMatchDstAddress = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 7, 13), InetAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cnfTopFlowsMatchDstAddress.setStatus('current')
if mibBuilder.loadTexts: cnfTopFlowsMatchDstAddress.setDescription('Destination address prefix to match.')
cnfTopFlowsMatchDstAddressMask = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 7, 14), InetAddressPrefixLength()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cnfTopFlowsMatchDstAddressMask.setStatus('current')
if mibBuilder.loadTexts: cnfTopFlowsMatchDstAddressMask.setDescription('The length of the match destination address prefix. This prefix length must be consistent with the address type specified in cnfTopFlowsMatchDstAddressType. A length of zero only matches the all-zero address of the specified type.')
cnfTopFlowsMatchNhAddressType = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 7, 15), InetAddressType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cnfTopFlowsMatchNhAddressType.setStatus('current')
if mibBuilder.loadTexts: cnfTopFlowsMatchNhAddressType.setDescription("Nexthop address type to match. A value of 'unknown' (ie, 0) indicates the nexthop address is not used as a top flows match criteria, and clears the cnfTopFlowsMatchNhAddress and cnfTopFlowsMatchNhAddressMask configuration.")
cnfTopFlowsMatchNhAddress = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 7, 16), InetAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cnfTopFlowsMatchNhAddress.setStatus('current')
if mibBuilder.loadTexts: cnfTopFlowsMatchNhAddress.setDescription('Nexthop address prefix to match.')
cnfTopFlowsMatchNhAddressMask = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 7, 17), InetAddressPrefixLength()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cnfTopFlowsMatchNhAddressMask.setStatus('current')
if mibBuilder.loadTexts: cnfTopFlowsMatchNhAddressMask.setDescription('The length of the match nexthop address Prefix. This prefix length must be consistent with the address type specified in cnfTopFlowsMatchNhAddressType. A length of zero only matches the all-zero address of the specified type.')
cnfTopFlowsMatchSrcPortLo = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 7, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(-1, -1), ValueRangeConstraint(0, 65535), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cnfTopFlowsMatchSrcPortLo.setStatus('current')
if mibBuilder.loadTexts: cnfTopFlowsMatchSrcPortLo.setDescription('The minimum value that the layer-4 source port number in the flow must have in order to match. A value of -1 disables this match criteria.')
cnfTopFlowsMatchSrcPortHi = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 7, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(-1, -1), ValueRangeConstraint(0, 65535), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cnfTopFlowsMatchSrcPortHi.setStatus('current')
if mibBuilder.loadTexts: cnfTopFlowsMatchSrcPortHi.setDescription('The maximum value that the layer-4 source port number in the flow must have in order to match. A value of -1 disables this match criteria.')
cnfTopFlowsMatchDstPortLo = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 7, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(-1, -1), ValueRangeConstraint(0, 65535), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cnfTopFlowsMatchDstPortLo.setStatus('current')
if mibBuilder.loadTexts: cnfTopFlowsMatchDstPortLo.setDescription('The minimum value that the layer-4 destination port number in the flow must have in order to match. A value of -1 disables this match criteria.')
cnfTopFlowsMatchDstPortHi = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 7, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(-1, -1), ValueRangeConstraint(0, 65535), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cnfTopFlowsMatchDstPortHi.setStatus('current')
if mibBuilder.loadTexts: cnfTopFlowsMatchDstPortHi.setDescription('The maximum value that the layer-4 destination port number in the flow must have in order to match. A value of -1 disables this match criteria.')
cnfTopFlowsMatchSrcAS = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 7, 22), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cnfTopFlowsMatchSrcAS.setStatus('current')
if mibBuilder.loadTexts: cnfTopFlowsMatchSrcAS.setDescription('Source AS number to match. A value of -1 disables this match criteria.')
cnfTopFlowsMatchDstAS = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 7, 23), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cnfTopFlowsMatchDstAS.setStatus('current')
if mibBuilder.loadTexts: cnfTopFlowsMatchDstAS.setDescription('Destination AS number to match. A value of -1 disables this match criteria.')
cnfTopFlowsMatchInputIf = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 7, 24), InterfaceIndexOrZero()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cnfTopFlowsMatchInputIf.setStatus('current')
if mibBuilder.loadTexts: cnfTopFlowsMatchInputIf.setDescription('Input interface to match. A value of 0 disables this match criteria.')
cnfTopFlowsMatchOutputIf = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 7, 25), InterfaceIndexOrZero()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cnfTopFlowsMatchOutputIf.setStatus('current')
if mibBuilder.loadTexts: cnfTopFlowsMatchOutputIf.setDescription('Output interface to match. A value of 0 disables this match criteria.')
cnfTopFlowsMatchTOSByte = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 7, 26), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cnfTopFlowsMatchTOSByte.setStatus('current')
if mibBuilder.loadTexts: cnfTopFlowsMatchTOSByte.setDescription('TOS byte to match. A value of -1 disables this match criteria.')
cnfTopFlowsMatchProtocol = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 7, 27), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cnfTopFlowsMatchProtocol.setStatus('current')
if mibBuilder.loadTexts: cnfTopFlowsMatchProtocol.setDescription('Protocol to match. A value of -1 disables this match criteria.')
cnfTopFlowsMatchSampler = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 7, 28), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cnfTopFlowsMatchSampler.setStatus('current')
if mibBuilder.loadTexts: cnfTopFlowsMatchSampler.setDescription('Sampler name to match. Leave blank to disable this match criteria.')
cnfTopFlowsMatchClass = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 7, 29), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cnfTopFlowsMatchClass.setStatus('current')
if mibBuilder.loadTexts: cnfTopFlowsMatchClass.setDescription('Class name to match. Leave blank to disable this match criteria.')
cnfTopFlowsMatchMinPackets = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 7, 30), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cnfTopFlowsMatchMinPackets.setStatus('current')
if mibBuilder.loadTexts: cnfTopFlowsMatchMinPackets.setDescription('Minimum packets to match. A value of 0 disables this match criteria.')
cnfTopFlowsMatchMaxPackets = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 7, 31), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cnfTopFlowsMatchMaxPackets.setStatus('current')
if mibBuilder.loadTexts: cnfTopFlowsMatchMaxPackets.setDescription('Maximum packets to match. A value of 0 disables this match criteria.')
cnfTopFlowsMatchMinBytes = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 7, 32), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cnfTopFlowsMatchMinBytes.setStatus('current')
if mibBuilder.loadTexts: cnfTopFlowsMatchMinBytes.setDescription('Minimum bytes to match. A value of 0 disables this match criteria.')
cnfTopFlowsMatchMaxBytes = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 7, 33), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cnfTopFlowsMatchMaxBytes.setStatus('current')
if mibBuilder.loadTexts: cnfTopFlowsMatchMaxBytes.setDescription('Maximum bytes to match. A value of 0 disables this match criteria.')
cnfTopFlowsMatchDirection = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 7, 34), NfFlowDirectionTypes()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cnfTopFlowsMatchDirection.setStatus('current')
if mibBuilder.loadTexts: cnfTopFlowsMatchDirection.setDescription('Flow direction to match. A value of 0 disables this match criteria.')
cnfTopFlowsGenerate = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 7, 35), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cnfTopFlowsGenerate.setStatus('current')
if mibBuilder.loadTexts: cnfTopFlowsGenerate.setDescription("A control variable used to generate the Top Flows. Setting this object to 'true' will generate the Top Flows and populate the Top Flows report in cnfTopFlowsTable unless cnfTopFlowsNextGenActionEffect is supported and the value of cnfTopFlowsNextGenActionEffect is 'noOp'. Setting this object to 'false' has no effect. When read, this object always returns 'false'.")
cnfTopFlowsReportAvailable = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 7, 36), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnfTopFlowsReportAvailable.setStatus('current')
if mibBuilder.loadTexts: cnfTopFlowsReportAvailable.setDescription("Indicates whether the Top Flows report has been successfully generated and is available in cnfTopFlowsTable. When the value of this object is 'true', the top flows report is available in cnfTopFlowsTable. When the value of this object is 'false', there is no top flows report available in cnfTopFlowsTable. For Example: 1. When top flows report has not been generated or is currently in the generation process. 2. When the top flows has been purged due to the modification of a matching criteria or the expiration of top flow cache timeout.")
cnfTopFlowsNextGenActionEffect = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 7, 37), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noOp", 1), ("generate", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnfTopFlowsNextGenActionEffect.setStatus('current')
if mibBuilder.loadTexts: cnfTopFlowsNextGenActionEffect.setDescription("Indicates the action effect on the system when the cnfTopFlowsGenerate is set to 'true'. 'noOp' -- indicate that the system will make no operation when the cnfTopFlowsGenerate is set to 'true'. Examples when this object could return 'noOp' are: 1. the system is still in the top flow generation process. 2. the system will not generate the top flows report when the value of cnfTopFlowsReportAvailable is 'true'. 'generate' -- indicates that the system will start the top flows generation process if the cntTopFlowsGenerate is set to 'true'. Examples when this object could return 'generate' are: 1. When the value of cnfTopFlowsReportAvailable is 'false'. 2. The system will always generate the top flow report when cnfTopFlowsGenerate is set to 'true'. ")
cnfTopFlowsReportSource = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 387, 1, 7, 38), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("hardware", 2), ("software", 3), ("both", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnfTopFlowsReportSource.setStatus('current')
if mibBuilder.loadTexts: cnfTopFlowsReportSource.setDescription("Indicates the source of Top Flows report generation for the entries populated in cnfTopFlowsTable. 'other' - The Top Flows are not available or the source of the Top Flows cannot be identified. 'hardware' - The Top Flows report has been generated based on the flows detected by the hardware platform with netflow capabilities. 'software' - The Top Flows report has been generated based on the flows detected by the software. 'both' - The Top Flows report is an integrated list of Top Flows detected by both the hardware platform and the software.")
cnfMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 387, 2, 1))
cnfMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 387, 2, 2))
cnfMIBCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 387, 2, 1, 1)).setObjects(("CISCO-NETFLOW-MIB", "cnfCacheInfoGroup"), ("CISCO-NETFLOW-MIB", "cnfProtocolStatGroup"), ("CISCO-NETFLOW-MIB", "cnfExportInfoGroup"), ("CISCO-NETFLOW-MIB", "cnfExportStatisticsGroup"), ("CISCO-NETFLOW-MIB", "cnfExportTemplateGroup"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cnfMIBCompliance = cnfMIBCompliance.setStatus('deprecated')
if mibBuilder.loadTexts: cnfMIBCompliance.setDescription('The compliance statement for the CISCO-NETFLOW-MIB. OBJECT cnfCollectorAddressType SYNTAX InetAddressType { ipv4(1) } DESCRIPTION An implementation is only required to support IPv4 addresses. OBJECT cnfCollectorAddress SYNTAX InetAddress (SIZE(4)) DESCRIPTION An implementation is only required to support IPv4 addresses. OBJECT cnfTopFlowsSrcAddressType SYNTAX InetAddressType { ipv4(1) } DESCRIPTION An implementation is only required to support IPv4 addresses. OBJECT cnfTopFlowsSrcAddress SYNTAX InetAddress (SIZE(4)) DESCRIPTION An implementation is only required to support IPv4 addresses. OBJECT cnfTopFlowsDstAddressType SYNTAX InetAddressType { ipv4(1) } DESCRIPTION An implementation is only required to support IPv4 addresses. OBJECT cnfTopFlowsDstAddress SYNTAX InetAddress (SIZE(4)) DESCRIPTION An implementation is only required to support IPv4 addresses. OBJECT cnfTopFlowsNhAddressType SYNTAX InetAddressType { ipv4(1) } DESCRIPTION An implementation is only required to support IPv4 addresses. OBJECT cnfTopFlowsNhAddress SYNTAX InetAddress (SIZE(4)) DESCRIPTION An implementation is only required to support IPv4 addresses. OBJECT cnfTopFlowsMatchSrcAddressType SYNTAX InetAddressType { ipv4(1) } DESCRIPTION An implementation is only required to support IPv4 addresses. OBJECT cnfTopFlowsMatchSrcAddress SYNTAX InetAddress (SIZE(4)) DESCRIPTION An implementation is only required to support IPv4 addresses. OBJECT cnfTopFlowsMatchDstAddressType SYNTAX InetAddressType { ipv4(1) } DESCRIPTION An implementation is only required to support IPv4 addresses. OBJECT cnfTopFlowsMatchDstAddress SYNTAX InetAddress (SIZE(4)) DESCRIPTION An implementation is only required to support IPv4 addresses. OBJECT cnfTopFlowsMatchNhAddressType SYNTAX InetAddressType { ipv4(1) } DESCRIPTION An implementation is only required to support IPv4 addresses. OBJECT cnfTopFlowsMatchNhAddress SYNTAX InetAddress (SIZE(4)) DESCRIPTION An implementation is only required to support IPv4 addresses.')
cnfMIBCompliance1 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 387, 2, 1, 2)).setObjects(("CISCO-NETFLOW-MIB", "cnfCacheInfoGroup"), ("CISCO-NETFLOW-MIB", "cnfProtocolStatGroup"), ("CISCO-NETFLOW-MIB", "cnfExportInfoGroup"), ("CISCO-NETFLOW-MIB", "cnfExportStatisticsGroup"), ("CISCO-NETFLOW-MIB", "cnfExportTemplateGroup"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsDataGroup1"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsDataGroup2"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsVlanGroup"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsControlGroup1"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsControlGroup2"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cnfMIBCompliance1 = cnfMIBCompliance1.setStatus('deprecated')
if mibBuilder.loadTexts: cnfMIBCompliance1.setDescription('The compliance statement for the CISCO-NETFLOW-MIB. OBJECT cnfCollectorAddressType SYNTAX InetAddressType { ipv4(1) } DESCRIPTION An implementation is only required to support IPv4 addresses. OBJECT cnfCollectorAddress SYNTAX InetAddress (SIZE(4)) DESCRIPTION An implementation is only required to support IPv4 addresses. OBJECT cnfTopFlowsSrcAddressType SYNTAX InetAddressType { ipv4(1) } DESCRIPTION An implementation is only required to support IPv4 addresses. OBJECT cnfTopFlowsSrcAddress SYNTAX InetAddress (SIZE(4)) DESCRIPTION An implementation is only required to support IPv4 addresses. OBJECT cnfTopFlowsDstAddressType SYNTAX InetAddressType { ipv4(1) } DESCRIPTION An implementation is only required to support IPv4 addresses. OBJECT cnfTopFlowsDstAddress SYNTAX InetAddress (SIZE(4)) DESCRIPTION An implementation is only required to support IPv4 addresses. OBJECT cnfTopFlowsNhAddressType SYNTAX InetAddressType { ipv4(1) } DESCRIPTION An implementation is only required to support IPv4 addresses. OBJECT cnfTopFlowsNhAddress SYNTAX InetAddress (SIZE(4)) DESCRIPTION An implementation is only required to support IPv4 addresses. OBJECT cnfTopFlowsMatchSrcAddressType SYNTAX InetAddressType { ipv4(1) } DESCRIPTION An implementation is only required to support IPv4 addresses. OBJECT cnfTopFlowsMatchSrcAddress SYNTAX InetAddress (SIZE(4)) DESCRIPTION An implementation is only required to support IPv4 addresses. OBJECT cnfTopFlowsMatchDstAddressType SYNTAX InetAddressType { ipv4(1) } DESCRIPTION An implementation is only required to support IPv4 addresses. OBJECT cnfTopFlowsMatchDstAddress SYNTAX InetAddress (SIZE(4)) DESCRIPTION An implementation is only required to support IPv4 addresses. OBJECT cnfTopFlowsMatchNhAddressType SYNTAX InetAddressType { ipv4(1) } DESCRIPTION An implementation is only required to support IPv4 addresses. OBJECT cnfTopFlowsMatchNhAddress SYNTAX InetAddress (SIZE(4)) DESCRIPTION An implementation is only required to support IPv4 addresses.')
cnfMIBCompliance2 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 387, 2, 1, 3)).setObjects(("CISCO-NETFLOW-MIB", "cnfCacheInfoGroup"), ("CISCO-NETFLOW-MIB", "cnfProtocolStatGroup"), ("CISCO-NETFLOW-MIB", "cnfExportInfoGroup"), ("CISCO-NETFLOW-MIB", "cnfExportStatisticsGroup"), ("CISCO-NETFLOW-MIB", "cnfExportTemplateGroup"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsDataGroup1"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsDataGroup2"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsVlanGroup"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsControlGroup1"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsControlGroup2"), ("CISCO-NETFLOW-MIB", "cnfMcastNetflowControlGroup"), ("CISCO-NETFLOW-MIB", "cnfBridgedFlowStatsCtrlGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cnfMIBCompliance2 = cnfMIBCompliance2.setStatus('deprecated')
if mibBuilder.loadTexts: cnfMIBCompliance2.setDescription('The compliance statement for the CISCO-NETFLOW-MIB. OBJECT cnfCollectorAddressType SYNTAX InetAddressType { ipv4(1) } DESCRIPTION An implementation is only required to support IPv4 addresses. OBJECT cnfCollectorAddress SYNTAX InetAddress (SIZE(4)) DESCRIPTION An implementation is only required to support IPv4 addresses. OBJECT cnfTopFlowsSrcAddressType SYNTAX InetAddressType { ipv4(1) } DESCRIPTION An implementation is only required to support IPv4 addresses. OBJECT cnfTopFlowsSrcAddress SYNTAX InetAddress (SIZE(4)) DESCRIPTION An implementation is only required to support IPv4 addresses. OBJECT cnfTopFlowsDstAddressType SYNTAX InetAddressType { ipv4(1) } DESCRIPTION An implementation is only required to support IPv4 addresses. OBJECT cnfTopFlowsDstAddress SYNTAX InetAddress (SIZE(4)) DESCRIPTION An implementation is only required to support IPv4 addresses. OBJECT cnfTopFlowsNhAddressType SYNTAX InetAddressType { ipv4(1) } DESCRIPTION An implementation is only required to support IPv4 addresses. OBJECT cnfTopFlowsNhAddress SYNTAX InetAddress (SIZE(4)) DESCRIPTION An implementation is only required to support IPv4 addresses. OBJECT cnfTopFlowsMatchSrcAddressType SYNTAX InetAddressType { ipv4(1) } DESCRIPTION An implementation is only required to support IPv4 addresses. OBJECT cnfTopFlowsMatchSrcAddress SYNTAX InetAddress (SIZE(4)) DESCRIPTION An implementation is only required to support IPv4 addresses. OBJECT cnfTopFlowsMatchDstAddressType SYNTAX InetAddressType { ipv4(1) } DESCRIPTION An implementation is only required to support IPv4 addresses. OBJECT cnfTopFlowsMatchDstAddress SYNTAX InetAddress (SIZE(4)) DESCRIPTION An implementation is only required to support IPv4 addresses. OBJECT cnfTopFlowsMatchNhAddressType SYNTAX InetAddressType { ipv4(1) } DESCRIPTION An implementation is only required to support IPv4 addresses. OBJECT cnfTopFlowsMatchNhAddress SYNTAX InetAddress (SIZE(4)) DESCRIPTION An implementation is only required to support IPv4 addresses.')
cnfMIBCompliance3 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 387, 2, 1, 4)).setObjects(("CISCO-NETFLOW-MIB", "cnfCacheInfoGroup"), ("CISCO-NETFLOW-MIB", "cnfProtocolStatGroup"), ("CISCO-NETFLOW-MIB", "cnfExportInfoGroup"), ("CISCO-NETFLOW-MIB", "cnfExportStatisticsGroup"), ("CISCO-NETFLOW-MIB", "cnfExportTemplateGroup"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsDataGroup1"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsDataGroup2"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsVlanGroup"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsControlGroup1"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsControlGroup2"), ("CISCO-NETFLOW-MIB", "cnfMcastNetflowControlGroup"), ("CISCO-NETFLOW-MIB", "cnfBridgedFlowStatsCtrlGroup"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsReportGenerateGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cnfMIBCompliance3 = cnfMIBCompliance3.setStatus('current')
if mibBuilder.loadTexts: cnfMIBCompliance3.setDescription('The compliance statement for the CISCO-NETFLOW-MIB. OBJECT cnfCollectorAddressType SYNTAX InetAddressType { ipv4(1) } DESCRIPTION An implementation is only required to support IPv4 addresses. OBJECT cnfCollectorAddress SYNTAX InetAddress (SIZE(4)) DESCRIPTION An implementation is only required to support IPv4 addresses. OBJECT cnfTopFlowsSrcAddressType SYNTAX InetAddressType { ipv4(1) } DESCRIPTION An implementation is only required to support IPv4 addresses. OBJECT cnfTopFlowsSrcAddress SYNTAX InetAddress (SIZE(4)) DESCRIPTION An implementation is only required to support IPv4 addresses. OBJECT cnfTopFlowsDstAddressType SYNTAX InetAddressType { ipv4(1) } DESCRIPTION An implementation is only required to support IPv4 addresses. OBJECT cnfTopFlowsDstAddress SYNTAX InetAddress (SIZE(4)) DESCRIPTION An implementation is only required to support IPv4 addresses. OBJECT cnfTopFlowsNhAddressType SYNTAX InetAddressType { ipv4(1) } DESCRIPTION An implementation is only required to support IPv4 addresses. OBJECT cnfTopFlowsNhAddress SYNTAX InetAddress (SIZE(4)) DESCRIPTION An implementation is only required to support IPv4 addresses. OBJECT cnfTopFlowsMatchSrcAddressType SYNTAX InetAddressType { ipv4(1) } DESCRIPTION An implementation is only required to support IPv4 addresses. OBJECT cnfTopFlowsMatchSrcAddress SYNTAX InetAddress (SIZE(4)) DESCRIPTION An implementation is only required to support IPv4 addresses. OBJECT cnfTopFlowsMatchDstAddressType SYNTAX InetAddressType { ipv4(1) } DESCRIPTION An implementation is only required to support IPv4 addresses. OBJECT cnfTopFlowsMatchDstAddress SYNTAX InetAddress (SIZE(4)) DESCRIPTION An implementation is only required to support IPv4 addresses. OBJECT cnfTopFlowsMatchNhAddressType SYNTAX InetAddressType { ipv4(1) } DESCRIPTION An implementation is only required to support IPv4 addresses. OBJECT cnfTopFlowsMatchNhAddress SYNTAX InetAddress (SIZE(4)) DESCRIPTION An implementation is only required to support IPv4 addresses.')
cnfCacheInfoGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 387, 2, 2, 1)).setObjects(("CISCO-NETFLOW-MIB", "cnfCINetflowEnable"), ("CISCO-NETFLOW-MIB", "cnfCICacheEnable"), ("CISCO-NETFLOW-MIB", "cnfCICacheEntries"), ("CISCO-NETFLOW-MIB", "cnfCIActiveFlows"), ("CISCO-NETFLOW-MIB", "cnfCIInactiveFlows"), ("CISCO-NETFLOW-MIB", "cnfCIActiveTimeOut"), ("CISCO-NETFLOW-MIB", "cnfCIInactiveTimeOut"), ("CISCO-NETFLOW-MIB", "cnfCIMinSourceMask"), ("CISCO-NETFLOW-MIB", "cnfCIMinDestinationMask"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cnfCacheInfoGroup = cnfCacheInfoGroup.setStatus('current')
if mibBuilder.loadTexts: cnfCacheInfoGroup.setDescription('A collection of objects providing information and configuration of the Netflow cache.')
cnfProtocolStatGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 387, 2, 2, 2)).setObjects(("CISCO-NETFLOW-MIB", "cnfPSPacketSizeDistribution"), ("CISCO-NETFLOW-MIB", "cnfPSLastClearElapsedTime"), ("CISCO-NETFLOW-MIB", "cnfPSExpiredFlows"), ("CISCO-NETFLOW-MIB", "cnfPSPackets"), ("CISCO-NETFLOW-MIB", "cnfPSBytes"), ("CISCO-NETFLOW-MIB", "cnfPSActive"), ("CISCO-NETFLOW-MIB", "cnfPSInactive"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cnfProtocolStatGroup = cnfProtocolStatGroup.setStatus('current')
if mibBuilder.loadTexts: cnfProtocolStatGroup.setDescription('A collection of objects providing statistical information of cache per protocol and port.')
cnfExportInfoGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 387, 2, 2, 3)).setObjects(("CISCO-NETFLOW-MIB", "cnfEIExportVersion"), ("CISCO-NETFLOW-MIB", "cnfEIPeerAS"), ("CISCO-NETFLOW-MIB", "cnfEIOriginAS"), ("CISCO-NETFLOW-MIB", "cnfEIBgpNextHop"), ("CISCO-NETFLOW-MIB", "cnfEIMaxCollectors"), ("CISCO-NETFLOW-MIB", "cnfEICollectorStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cnfExportInfoGroup = cnfExportInfoGroup.setStatus('current')
if mibBuilder.loadTexts: cnfExportInfoGroup.setDescription('A collection of objects providing Export information.')
cnfExportStatisticsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 387, 2, 2, 5)).setObjects(("CISCO-NETFLOW-MIB", "cnfESSampledPacket"), ("CISCO-NETFLOW-MIB", "cnfESExportRate"), ("CISCO-NETFLOW-MIB", "cnfESRecordsExported"), ("CISCO-NETFLOW-MIB", "cnfESPktsExported"), ("CISCO-NETFLOW-MIB", "cnfESPktsFailed"), ("CISCO-NETFLOW-MIB", "cnfESPktsDropped"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cnfExportStatisticsGroup = cnfExportStatisticsGroup.setStatus('current')
if mibBuilder.loadTexts: cnfExportStatisticsGroup.setDescription('A collection of objects providing statistical information of Export.')
cnfExportTemplateGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 387, 2, 2, 6)).setObjects(("CISCO-NETFLOW-MIB", "cnfTemplateOptionsFlag"), ("CISCO-NETFLOW-MIB", "cnfTemplateAdded"), ("CISCO-NETFLOW-MIB", "cnfTemplateActive"), ("CISCO-NETFLOW-MIB", "cnfTemplateAgerPolls"), ("CISCO-NETFLOW-MIB", "cnfTemplateExportVer9Enable"), ("CISCO-NETFLOW-MIB", "cnfTemplateExportVer9TplTimeout"), ("CISCO-NETFLOW-MIB", "cnfTemplateExportVer9OptTimeout"), ("CISCO-NETFLOW-MIB", "cnfTemplateExportVer9TplRefreshRate"), ("CISCO-NETFLOW-MIB", "cnfTemplateExportVer9OptRefreshRate"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cnfExportTemplateGroup = cnfExportTemplateGroup.setStatus('current')
if mibBuilder.loadTexts: cnfExportTemplateGroup.setDescription('A collection of objects providing information about export version 9.')
cnfTopFlowsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 387, 2, 2, 7)).setObjects(("CISCO-NETFLOW-MIB", "cnfTopFlowsTimeStamp"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsTopN"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsAvailableFlows"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsMatchingFlows"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsTotalFlows"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsSortBy"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsCacheTimeout"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsSrcAddressType"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsSrcAddress"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsSrcAddressMask"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsDstAddressType"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsDstAddress"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsDstAddressMask"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsNhAddressType"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsNhAddress"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsSrcPort"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsDstPort"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsSrcAS"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsDstAS"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsInputIfIndex"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsOutputIfIndex"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsFirstSwitched"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsLastSwitched"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsTOS"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsProtocol"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsTCPFlags"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsSamplerID"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsClassID"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsFlags"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsBytes"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsPackets"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsMatchSrcAddressType"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsMatchSrcAddress"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsMatchSrcAddressMask"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsMatchDstAddressType"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsMatchDstAddress"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsMatchDstAddressMask"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsMatchNhAddressType"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsMatchNhAddress"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsMatchNhAddressMask"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsMatchSrcPortLo"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsMatchSrcPortHi"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsMatchDstPortLo"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsMatchDstPortHi"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsMatchSrcAS"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsMatchDstAS"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsMatchInputIf"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsMatchOutputIf"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsMatchTOSByte"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsMatchProtocol"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsMatchSampler"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsMatchClass"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsMatchMinPackets"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsMatchMaxPackets"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsMatchMinBytes"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsMatchMaxBytes"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsMatchDirection"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cnfTopFlowsGroup = cnfTopFlowsGroup.setStatus('deprecated')
if mibBuilder.loadTexts: cnfTopFlowsGroup.setDescription('A collection of objects providing information for top flows.')
cnfTopFlowsDataGroup1 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 387, 2, 2, 8)).setObjects(("CISCO-NETFLOW-MIB", "cnfTopFlowsTimeStamp"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsTopN"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsAvailableFlows"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsTotalFlows"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsSortBy"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsSrcAddressType"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsSrcAddress"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsDstAddressType"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsDstAddress"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsSrcPort"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsDstPort"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsProtocol"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsBytes"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsPackets"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cnfTopFlowsDataGroup1 = cnfTopFlowsDataGroup1.setStatus('current')
if mibBuilder.loadTexts: cnfTopFlowsDataGroup1.setDescription('A collection of objects providing information for top flows.')
cnfTopFlowsDataGroup2 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 387, 2, 2, 9)).setObjects(("CISCO-NETFLOW-MIB", "cnfTopFlowsCacheTimeout"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsSrcAddressMask"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsDstAddressMask"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsNhAddressType"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsNhAddress"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsSrcAS"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsDstAS"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsInputIfIndex"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsOutputIfIndex"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsFirstSwitched"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsLastSwitched"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsTOS"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsTCPFlags"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsSamplerID"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsClassID"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsFlags"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cnfTopFlowsDataGroup2 = cnfTopFlowsDataGroup2.setStatus('current')
if mibBuilder.loadTexts: cnfTopFlowsDataGroup2.setDescription('A collection of objects providing additional information for Top Flows.')
cnfTopFlowsVlanGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 387, 2, 2, 10)).setObjects(("CISCO-NETFLOW-MIB", "cnfTopFlowsVlan"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cnfTopFlowsVlanGroup = cnfTopFlowsVlanGroup.setStatus('current')
if mibBuilder.loadTexts: cnfTopFlowsVlanGroup.setDescription('A collection of objects providing VLAN information about the top flows.')
cnfTopFlowsControlGroup1 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 387, 2, 2, 11)).setObjects(("CISCO-NETFLOW-MIB", "cnfTopFlowsMatchingFlows"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsMatchSrcAddressType"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsMatchSrcAddress"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsMatchSrcAddressMask"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsMatchDstAddressType"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsMatchDstAddress"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsMatchDstAddressMask"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsMatchNhAddressType"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsMatchNhAddress"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsMatchNhAddressMask"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsMatchSrcPortLo"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsMatchSrcPortHi"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsMatchDstPortLo"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsMatchDstPortHi"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsMatchSrcAS"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsMatchDstAS"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsMatchInputIf"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsMatchOutputIf"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsMatchTOSByte"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsMatchProtocol"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsMatchSampler"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsMatchClass"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsMatchMinPackets"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsMatchMaxPackets"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsMatchMinBytes"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsMatchMaxBytes"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsMatchDirection"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cnfTopFlowsControlGroup1 = cnfTopFlowsControlGroup1.setStatus('current')
if mibBuilder.loadTexts: cnfTopFlowsControlGroup1.setDescription('A collection of objects providing the match criteria control information for Top Flows.')
cnfTopFlowsControlGroup2 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 387, 2, 2, 12)).setObjects(("CISCO-NETFLOW-MIB", "cnfTopFlowsGenerate"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsReportAvailable"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cnfTopFlowsControlGroup2 = cnfTopFlowsControlGroup2.setStatus('current')
if mibBuilder.loadTexts: cnfTopFlowsControlGroup2.setDescription('A collection of objects providing the explicit control of the way top flows are generated.')
cnfMcastNetflowControlGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 387, 2, 2, 13)).setObjects(("CISCO-NETFLOW-MIB", "cnfCIMcastNetflowEnable"), ("CISCO-NETFLOW-MIB", "cnfCIMcastNetflowRPFFailedEnable"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cnfMcastNetflowControlGroup = cnfMcastNetflowControlGroup.setStatus('current')
if mibBuilder.loadTexts: cnfMcastNetflowControlGroup.setDescription('A collection of objects providing the control of multicast netflow.')
cnfBridgedFlowStatsCtrlGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 387, 2, 2, 14)).setObjects(("CISCO-NETFLOW-MIB", "cnfCIBridgedFlowStatsCrtEnable"), ("CISCO-NETFLOW-MIB", "cnfCIBridgedFlowStatsExpEnable"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cnfBridgedFlowStatsCtrlGroup = cnfBridgedFlowStatsCtrlGroup.setStatus('current')
if mibBuilder.loadTexts: cnfBridgedFlowStatsCtrlGroup.setDescription('A collection of objects providing the control of bridged flow statistics per vlan.')
cnfTopFlowsReportGenerateGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 387, 2, 2, 15)).setObjects(("CISCO-NETFLOW-MIB", "cnfTopFlowsNextGenActionEffect"), ("CISCO-NETFLOW-MIB", "cnfTopFlowsReportSource"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cnfTopFlowsReportGenerateGroup = cnfTopFlowsReportGenerateGroup.setStatus('current')
if mibBuilder.loadTexts: cnfTopFlowsReportGenerateGroup.setDescription('A collection of objects providing information about the Top Flows Report generation.')
mibBuilder.exportSymbols("CISCO-NETFLOW-MIB", cnfBridgedFlowStatsCtrlGroup=cnfBridgedFlowStatsCtrlGroup, NfTemplateTypes=NfTemplateTypes, cnfExportStatisticsGroup=cnfExportStatisticsGroup, cnfTopFlowsMatchTOSByte=cnfTopFlowsMatchTOSByte, cnfPSProtocolStatTable=cnfPSProtocolStatTable, cnfTopFlowsMatchSrcAddressType=cnfTopFlowsMatchSrcAddressType, NfCacheTypes=NfCacheTypes, cnfCIMinDestinationMask=cnfCIMinDestinationMask, cnfTopFlowsMatchSrcPortHi=cnfTopFlowsMatchSrcPortHi, cnfTopFlowsTotalFlows=cnfTopFlowsTotalFlows, cnfTopFlowsGenerate=cnfTopFlowsGenerate, cnfTopFlowsDstPort=cnfTopFlowsDstPort, cnfTopFlowsMatchDstAddressType=cnfTopFlowsMatchDstAddressType, cnfTopFlowsMatchDstAddress=cnfTopFlowsMatchDstAddress, cnfExportInfo=cnfExportInfo, cnfCIMinSourceMask=cnfCIMinSourceMask, cnfPSBytes=cnfPSBytes, cnfTopFlowsMatchSrcAS=cnfTopFlowsMatchSrcAS, ciscoNetflowMIB=ciscoNetflowMIB, cnfTopFlowsMatchMinBytes=cnfTopFlowsMatchMinBytes, ciscoNetflowMIBNotifs=ciscoNetflowMIBNotifs, cnfCIBridgedFlowStatsExpEnable=cnfCIBridgedFlowStatsExpEnable, NfProtocolTypes=NfProtocolTypes, cnfTopFlowsSrcAS=cnfTopFlowsSrcAS, cnfPSPackets=cnfPSPackets, cnfESPktsDropped=cnfESPktsDropped, cnfTemplateExportVer9Enable=cnfTemplateExportVer9Enable, cnfTopFlowsDstAS=cnfTopFlowsDstAS, cnfTopFlowsDataGroup1=cnfTopFlowsDataGroup1, NfFlowDirectionTypes=NfFlowDirectionTypes, cnfEIBgpNextHop=cnfEIBgpNextHop, cnfTopFlowsMatchInputIf=cnfTopFlowsMatchInputIf, cnfEICollectorTable=cnfEICollectorTable, cnfTopFlowsMatchingFlows=cnfTopFlowsMatchingFlows, cnfESSampledPacket=cnfESSampledPacket, cnfTopFlowsMatchSrcAddressMask=cnfTopFlowsMatchSrcAddressMask, cnfTopFlowsMatchDstPortHi=cnfTopFlowsMatchDstPortHi, cnfTopFlowsClassID=cnfTopFlowsClassID, cnfEIExportInfoEntry=cnfEIExportInfoEntry, cnfTopFlowsControlGroup2=cnfTopFlowsControlGroup2, cnfExportStatistics=cnfExportStatistics, cnfMIBCompliance1=cnfMIBCompliance1, cnfEICollectorEntry=cnfEICollectorEntry, cnfCIInactiveFlows=cnfCIInactiveFlows, cnfTopFlowsSrcAddressMask=cnfTopFlowsSrcAddressMask, cnfTopFlowsTableEntry=cnfTopFlowsTableEntry, cnfTopFlowsNhAddressType=cnfTopFlowsNhAddressType, cnfTopFlowsMatchDstAddressMask=cnfTopFlowsMatchDstAddressMask, cnfTemplateExportVer9TplTimeout=cnfTemplateExportVer9TplTimeout, cnfTemplateActive=cnfTemplateActive, cnfTopFlowsMatchMaxPackets=cnfTopFlowsMatchMaxPackets, cnfTemplateExportVer9OptRefreshRate=cnfTemplateExportVer9OptRefreshRate, cnfTopFlowsMatchOutputIf=cnfTopFlowsMatchOutputIf, cnfTemplateTable=cnfTemplateTable, cnfEIOriginAS=cnfEIOriginAS, cnfTopFlowsMatchNhAddress=cnfTopFlowsMatchNhAddress, cnfProtocolStatGroup=cnfProtocolStatGroup, cnfTopFlowsDstAddressType=cnfTopFlowsDstAddressType, cnfTopFlowsPackets=cnfTopFlowsPackets, cnfEIPeerAS=cnfEIPeerAS, cnfTemplateType=cnfTemplateType, cnfCIBridgedFlowVlan=cnfCIBridgedFlowVlan, cnfTopFlowsMatchClass=cnfTopFlowsMatchClass, cnfCIActiveTimeOut=cnfCIActiveTimeOut, cnfTopFlowsSrcAddressType=cnfTopFlowsSrcAddressType, cnfPSExpiredFlows=cnfPSExpiredFlows, cnfMIBCompliance2=cnfMIBCompliance2, cnfMcastNetflowControlGroup=cnfMcastNetflowControlGroup, cnfMIBCompliance3=cnfMIBCompliance3, cnfCIActiveFlows=cnfCIActiveFlows, NfInterfaceDirectionTypes=NfInterfaceDirectionTypes, cnfCIInterfaceEntry=cnfCIInterfaceEntry, cnfMIBCompliances=cnfMIBCompliances, cnfTopFlowsReportGenerateGroup=cnfTopFlowsReportGenerateGroup, cnfTopFlowsProtocol=cnfTopFlowsProtocol, cnfPSProtocolStatEntry=cnfPSProtocolStatEntry, cnfCINetflowEnable=cnfCINetflowEnable, NfTopFlowsSortTypes=NfTopFlowsSortTypes, cnfTopFlowsNextGenActionEffect=cnfTopFlowsNextGenActionEffect, cnfTopFlowsDataGroup2=cnfTopFlowsDataGroup2, cnfTopFlowsDstAddress=cnfTopFlowsDstAddress, cnfMIBCompliance=cnfMIBCompliance, cnfCIBridgedFlowStatsCtrlEntry=cnfCIBridgedFlowStatsCtrlEntry, cnfExportTemplateGroup=cnfExportTemplateGroup, cnfCICacheEnable=cnfCICacheEnable, cnfTopFlowsReportAvailable=cnfTopFlowsReportAvailable, cnfTopFlowsAvailableFlows=cnfTopFlowsAvailableFlows, cnfTopFlowsSrcPort=cnfTopFlowsSrcPort, cnfCICacheEntries=cnfCICacheEntries, cnfTopFlowsMatchMaxBytes=cnfTopFlowsMatchMaxBytes, cnfCIInactiveTimeOut=cnfCIInactiveTimeOut, cnfTopFlowsGroup=cnfTopFlowsGroup, cnfEICollectorStatus=cnfEICollectorStatus, cnfTemplateExportInfoEntry=cnfTemplateExportInfoEntry, cnfTopFlowsMatchDstPortLo=cnfTopFlowsMatchDstPortLo, cnfEIExportInfoTable=cnfEIExportInfoTable, cnfCIBridgedFlowStatsCtrlTable=cnfCIBridgedFlowStatsCtrlTable, cnfTopFlows=cnfTopFlows, cnfTopFlowsVlanGroup=cnfTopFlowsVlanGroup, cnfTopFlowsMatchNhAddressType=cnfTopFlowsMatchNhAddressType, cnfCICacheType=cnfCICacheType, cnfESPktsFailed=cnfESPktsFailed, cnfTopFlowsTable=cnfTopFlowsTable, cnfTopFlowsMatchProtocol=cnfTopFlowsMatchProtocol, cnfTopFlowsSortBy=cnfTopFlowsSortBy, cnfTopFlowsReportSource=cnfTopFlowsReportSource, cnfTopFlowsMatchDirection=cnfTopFlowsMatchDirection, cnfTemplateOptionsFlag=cnfTemplateOptionsFlag, cnfTopFlowsDstAddressMask=cnfTopFlowsDstAddressMask, cnfPSInactive=cnfPSInactive, cnfTopFlowsLastSwitched=cnfTopFlowsLastSwitched, ciscoNetflowMIBObjects=ciscoNetflowMIBObjects, cnfTopFlowsMatchDstAS=cnfTopFlowsMatchDstAS, cnfCIMcastNetflowEnable=cnfCIMcastNetflowEnable, cnfCIBridgedFlowStatsCrtEnable=cnfCIBridgedFlowStatsCrtEnable, cnfTopFlowsMatchSrcAddress=cnfTopFlowsMatchSrcAddress, cnfPSLastClearElapsedTime=cnfPSLastClearElapsedTime, cnfPSActive=cnfPSActive, cnfTemplateExportVer9TplRefreshRate=cnfTemplateExportVer9TplRefreshRate, cnfTopFlowsTimeStamp=cnfTopFlowsTimeStamp, cnfCICacheEntry=cnfCICacheEntry, cnfEIMaxCollectors=cnfEIMaxCollectors, cnfTemplateAgerPolls=cnfTemplateAgerPolls, cnfMIBGroups=cnfMIBGroups, cnfEICollectorAddress=cnfEICollectorAddress, cnfCacheInfoGroup=cnfCacheInfoGroup, cnfTemplateExportInfoTable=cnfTemplateExportInfoTable, cnfTopFlowsSamplerID=cnfTopFlowsSamplerID, cnfEIExportVersion=cnfEIExportVersion, cnfTemplateEntry=cnfTemplateEntry, cnfESPktsExported=cnfESPktsExported, cnfTopFlowsTopN=cnfTopFlowsTopN, cnfTopFlowsFirstSwitched=cnfTopFlowsFirstSwitched, PYSNMP_MODULE_ID=ciscoNetflowMIB, cnfEICollectorPort=cnfEICollectorPort, cnfESExportRate=cnfESExportRate, cnfTopFlowsMatchNhAddressMask=cnfTopFlowsMatchNhAddressMask, cnfProtocolStatistics=cnfProtocolStatistics, cnfTopFlowsMatchMinPackets=cnfTopFlowsMatchMinPackets, cnfTopFlowsVlan=cnfTopFlowsVlan, cnfExportInfoGroup=cnfExportInfoGroup, cnfTemplateAdded=cnfTemplateAdded, cnfPSProtocolType=cnfPSProtocolType, cnfTopFlowsMatchSampler=cnfTopFlowsMatchSampler, cnfESRecordsExported=cnfESRecordsExported, cnfTopFlowsOutputIfIndex=cnfTopFlowsOutputIfIndex, cnfTopFlowsInputIfIndex=cnfTopFlowsInputIfIndex, cnfEICollectorAddressType=cnfEICollectorAddressType, cnfCIInterfaceTable=cnfCIInterfaceTable, ciscoNetflowMIBConform=ciscoNetflowMIBConform, cnfTemplateExportVer9OptTimeout=cnfTemplateExportVer9OptTimeout, cnfTopFlowsSrcAddress=cnfTopFlowsSrcAddress, cnfTopFlowsTOS=cnfTopFlowsTOS, cnfTopFlowsBytes=cnfTopFlowsBytes, cnfPSPacketSizeDistribution=cnfPSPacketSizeDistribution, cnfTopFlowsIndex=cnfTopFlowsIndex, cnfCIMcastNetflowRPFFailedEnable=cnfCIMcastNetflowRPFFailedEnable, cnfExportTemplate=cnfExportTemplate, cnfTopFlowsCacheTimeout=cnfTopFlowsCacheTimeout, cnfTopFlowsMatchSrcPortLo=cnfTopFlowsMatchSrcPortLo, cnfTopFlowsTCPFlags=cnfTopFlowsTCPFlags, cnfCICacheTable=cnfCICacheTable, cnfTopFlowsControlGroup1=cnfTopFlowsControlGroup1, cnfCacheInfo=cnfCacheInfo, cnfTopFlowsNhAddress=cnfTopFlowsNhAddress, cnfTopFlowsFlags=cnfTopFlowsFlags)

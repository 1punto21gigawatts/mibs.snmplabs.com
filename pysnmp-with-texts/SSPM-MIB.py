#
# PySNMP MIB module SSPM-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/SSPM-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:10:52 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
AppLocalIndex, = mibBuilder.importSymbols("APM-MIB", "AppLocalIndex")
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ConstraintsIntersection, ValueSizeConstraint, SingleValueConstraint, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ConstraintsIntersection", "ValueSizeConstraint", "SingleValueConstraint", "ValueRangeConstraint")
InterfaceIndexOrZero, = mibBuilder.importSymbols("IF-MIB", "InterfaceIndexOrZero")
InetAddressType, InetAddress = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddressType", "InetAddress")
OwnerString, rmon = mibBuilder.importSymbols("RMON-MIB", "OwnerString", "rmon")
NotificationGroup, ObjectGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ObjectGroup", "ModuleCompliance")
ObjectIdentity, NotificationType, IpAddress, Gauge32, MibIdentifier, TimeTicks, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter64, ModuleIdentity, Integer32, Bits, Counter32, iso, Unsigned32 = mibBuilder.importSymbols("SNMPv2-SMI", "ObjectIdentity", "NotificationType", "IpAddress", "Gauge32", "MibIdentifier", "TimeTicks", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter64", "ModuleIdentity", "Integer32", "Bits", "Counter32", "iso", "Unsigned32")
DisplayString, TextualConvention, StorageType, RowStatus, TruthValue = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention", "StorageType", "RowStatus", "TruthValue")
Utf8String, = mibBuilder.importSymbols("SYSAPPL-MIB", "Utf8String")
sspmMIB = ModuleIdentity((1, 3, 6, 1, 2, 1, 16, 28))
sspmMIB.setRevisions(('2005-07-28 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: sspmMIB.setRevisionsDescriptions(('The original version of this MIB module, was published as RFC4149.',))
if mibBuilder.loadTexts: sspmMIB.setLastUpdated('200507280000Z')
if mibBuilder.loadTexts: sspmMIB.setOrganization('IETF RMON MIB working group')
if mibBuilder.loadTexts: sspmMIB.setContactInfo(' Carl W. Kalbfleisch Consultant E-mail: ietf@kalbfleisch.us Working group mailing list: rmonmib@ietf.org To subscribe send email to rmonmib-request@ietf.org')
if mibBuilder.loadTexts: sspmMIB.setDescription('This SSPM MIB module is applicable to probes implementing Synthetic Source for Performance Monitoring functions. Copyright (C) The Internet Society (2005). This version of this MIB module is part of RFC 4149; see the RFC itself for full legal notices.')
sspmMIBObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 28, 1))
sspmMIBNotifications = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 28, 2))
sspmMIBConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 28, 3))
class SspmMicroSeconds(TextualConvention, Unsigned32):
    description = 'A unit of time with resolution of MicroSeconds.'
    status = 'current'
    displayHint = 'd'

class SspmClockSource(TextualConvention, Integer32):
    reference = 'RFC1305.'
    description = 'An indication of the source of the clock as defined by the NTP specification RFC1305 [RFC1305] definition of stratum: Stratum (sys.stratum, peer.stratum, pkt.stratum): This is an integer indicating the stratum of the local clock, with values defined as follows: 0 unspecified 1 primary reference (e.g., calibrated atomic clock, radio clock) 2-255 secondary reference (via NTP).'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 255)

class SspmClockMaxSkew(TextualConvention, Integer32):
    reference = 'RFC1305.'
    description = 'An indication of the accuracy of the clock as defined by RFC1305. This variable indicates the maximum offset error due to skew of the local clock over the time interval 86400 seconds, in seconds.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 65535)

sspmGeneral = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 28, 1, 1))
sspmGeneralClockResolution = MibScalar((1, 3, 6, 1, 2, 1, 16, 28, 1, 1, 1), SspmMicroSeconds()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sspmGeneralClockResolution.setStatus('current')
if mibBuilder.loadTexts: sspmGeneralClockResolution.setDescription('A read-only variable indicating the resolution of the measurements possible by this device.')
sspmGeneralClockMaxSkew = MibScalar((1, 3, 6, 1, 2, 1, 16, 28, 1, 1, 2), SspmClockMaxSkew()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sspmGeneralClockMaxSkew.setStatus('current')
if mibBuilder.loadTexts: sspmGeneralClockMaxSkew.setDescription('A read-only variable indicating the maximum offset error due to skew of the local clock over the time interval 86400 seconds, in seconds.')
sspmGeneralClockSource = MibScalar((1, 3, 6, 1, 2, 1, 16, 28, 1, 1, 3), SspmClockSource()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sspmGeneralClockSource.setStatus('current')
if mibBuilder.loadTexts: sspmGeneralClockSource.setDescription('A read-only variable indicating the source of the clock. This is provided to allow a user to determine how accurate the timing mechanism is compared with other devices. This is needed for the coordination of time values between probes for one-way measurements.')
sspmGeneralMinFrequency = MibScalar((1, 3, 6, 1, 2, 1, 16, 28, 1, 1, 4), SspmMicroSeconds()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sspmGeneralMinFrequency.setStatus('current')
if mibBuilder.loadTexts: sspmGeneralMinFrequency.setDescription("A read-only variable that indicates the devices' capability for the minimum supported sspmSourceFrequency. If sspmSourceFrequency is set to a value lower than the value reported by this attribute, then the set of sspmSourceFrequency will fail with an inconsistent value error.")
sspmCapabilitiesTable = MibTable((1, 3, 6, 1, 2, 1, 16, 28, 1, 1, 5), )
if mibBuilder.loadTexts: sspmCapabilitiesTable.setStatus('current')
if mibBuilder.loadTexts: sspmCapabilitiesTable.setDescription('The table of SSPM capabilities.')
sspmCapabilitiesEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 28, 1, 1, 5, 1), ).setIndexNames((0, "SSPM-MIB", "sspmCapabilitiesInstance"))
if mibBuilder.loadTexts: sspmCapabilitiesEntry.setStatus('current')
if mibBuilder.loadTexts: sspmCapabilitiesEntry.setDescription('Details about a particular SSPM capability.')
sspmCapabilitiesInstance = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 1, 5, 1, 1), AppLocalIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sspmCapabilitiesInstance.setStatus('current')
if mibBuilder.loadTexts: sspmCapabilitiesInstance.setDescription('Indicates whether SSPM configuration of the corresponding AppLocalIndex is supported by this device. Generally, entries in this table are only made by the device when the configuration of the measurement is available.')
sspmSource = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 28, 1, 2))
sspmSourceProfileTable = MibTable((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 1), )
if mibBuilder.loadTexts: sspmSourceProfileTable.setStatus('current')
if mibBuilder.loadTexts: sspmSourceProfileTable.setDescription('The table of SSPM Source Profiles configured.')
sspmSourceProfileEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 1, 1), ).setIndexNames((0, "SSPM-MIB", "sspmSourceProfileInstance"))
if mibBuilder.loadTexts: sspmSourceProfileEntry.setStatus('current')
if mibBuilder.loadTexts: sspmSourceProfileEntry.setDescription('Details about a particular SSPM Source Profile configuration. Entries must exist in this table in order to be referenced by rows in the sspmSourceControlTable.')
sspmSourceProfileInstance = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 1, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: sspmSourceProfileInstance.setStatus('current')
if mibBuilder.loadTexts: sspmSourceProfileInstance.setDescription('An arbitrary index.')
sspmSourceProfileType = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 1, 1, 2), AppLocalIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceProfileType.setStatus('current')
if mibBuilder.loadTexts: sspmSourceProfileType.setDescription("The AppLocalIndex value that uniquely identifies the measurement per the APM-MIB. In order to create a row in this table, there must be a corresponding row in the sspmCapabilitiesTable. When attempting to set this object, if no corresponding row exists in the sspmCapabilitiesTable, then the agent should return a 'badValue' error.")
sspmSourceProfilePacketSize = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 1, 1, 3), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceProfilePacketSize.setStatus('current')
if mibBuilder.loadTexts: sspmSourceProfilePacketSize.setDescription("The size of packet to be transmitted in bytes. The size accounts for all data within the IPv4 or IPv6 payloads, excluding the IP headers, IP header options and link-level protocol headers. If the size is set smaller than the minimum allowed packet size or greater than the maximum allowed packet size, then the set should fail, and the agent should return a 'badValue' error.")
sspmSourceProfilePacketFillType = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("random", 1), ("pattern", 2), ("url", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceProfilePacketFillType.setStatus('current')
if mibBuilder.loadTexts: sspmSourceProfilePacketFillType.setDescription("Indicates how the packet is filled. 'random' indicates that the packet contains random data patterns. This is probe and implementation dependent. 'pattern' indicates that the pattern defined in the sspmSourceProfilePacketFillValue attribute is used to fill the packet. 'url' indicates that the value of sspmSourceProfilePacketFillValue should contain a URL. The contents of the document at that URL are retrieved when sspmSourceStatus becomes active and utilized in the packet. If the attempt to access that URL fails, then the row status is set to 'notReady', and the set should fail with 'inconsistentValue'. This value must contain a dereferencable URL of the type 'http:', 'https:', or 'ftp:' only.")
sspmSourceProfilePacketFillValue = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 1, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceProfilePacketFillValue.setStatus('current')
if mibBuilder.loadTexts: sspmSourceProfilePacketFillValue.setDescription("The string value with which to fill the packet. If sspmSourceProfilePacketFillType is set to 'pattern', then this pattern is repeated until the packet is sspmSourcePacketSize in bytes. Note that if the length of the octet string specified for this value does not divide evenly into the packet size, then an incomplete last copy of this data may be copied into the packet. If the value of sspmSourceProfilePacketFillType is set to 'random', then this attribute is unused. If the value of the sspmSourceProfilePacketFillType is set to 'url', then the URL specified in this attribute is retrieved and used by the probe. In the case of a URL, this value must contain a dereferencable URL of the type 'http:', 'https:', or 'ftp:' only.")
sspmSourceProfileTOS = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceProfileTOS.setStatus('current')
if mibBuilder.loadTexts: sspmSourceProfileTOS.setDescription('Represents the TOS field in the IP packet header. The value of this object defaults to zero if not set.')
sspmSourceProfileFlowLabel = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1048575))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceProfileFlowLabel.setStatus('current')
if mibBuilder.loadTexts: sspmSourceProfileFlowLabel.setDescription('This object is used to specify the Flow Label in a IPv6 packet (RFC 2460) to force special handling by the IPv6 routers; e.g., non-default quality-of-service handling. This object is meaningful only when the object sspmSourceDestAddressType is IPv6(2). The value of this object defaults to zero if not set.')
sspmSourceProfileLooseSrcRteFill = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 1, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 240))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceProfileLooseSrcRteFill.setStatus('current')
if mibBuilder.loadTexts: sspmSourceProfileLooseSrcRteFill.setDescription('In the event that the test should run over a specific route, the intent is to force the route using the Loose Source Route option in IPv4 [RFC791] and IPv6 [RFC2460]. This object contains a series of IP addresses along the path that would be put into the loose source route option in the IP header. The IPv4 addresses are to be listed as 32-bit address values, and the IPv6 addresses are to be listed as a string of 128-bit addresses. The maximum length allowed within the IPv4 source route option is 63 addresses. To simply account for IPv6 addresses as well, the maximum length of the octet string is 240. This allows up to 60 IPv4 addresses or up to 15 IPv6 addresses in the string.')
sspmSourceProfileLooseSrcRteLen = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 240))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceProfileLooseSrcRteLen.setStatus('current')
if mibBuilder.loadTexts: sspmSourceProfileLooseSrcRteLen.setDescription('In the event that the test should run over a specific route, the intent is to force the route. This attribute specifies the length of data to be copied from the sspmSourceProfileLooseSrcRteFill into the route data fields of the loose source route options in the IPv4 or IPv6 headers.')
sspmSourceProfileTTL = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceProfileTTL.setStatus('current')
if mibBuilder.loadTexts: sspmSourceProfileTTL.setDescription('If non-zero, this specifies the value to place into the TTL field on transmission.')
sspmSourceProfileNoFrag = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 1, 1, 11), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceProfileNoFrag.setStatus('current')
if mibBuilder.loadTexts: sspmSourceProfileNoFrag.setDescription("When true, the 'Don't Fragment Bit' should be set on the packet header.")
sspmSourceProfile8021Tagging = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceProfile8021Tagging.setStatus('current')
if mibBuilder.loadTexts: sspmSourceProfile8021Tagging.setDescription("IEEE 802.1Q tagging used in IEEE 802.1D bridged environments. A value of -1 indicates that the packets are untagged. A value of 0 to 65535 is the value of the tag to be inserted in the tagged packets. Note that according to IEEE 802.1Q, VLAN-ID tags with a value of 4095 shall not be transmitted on the wire. As the VLAN-ID is encoded in the 12 least significant bits on the tag, values that translate in a binary representation of all 1's in the last 12 bits SHALL NOT be configured. In this case, the set should fail, and return an error-status of 'inconsistentValue'.")
sspmSourceProfileUsername = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 1, 1, 13), Utf8String()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceProfileUsername.setStatus('current')
if mibBuilder.loadTexts: sspmSourceProfileUsername.setDescription('An optional username used by the application protocol.')
sspmSourceProfilePassword = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 1, 1, 14), Utf8String()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceProfilePassword.setStatus('current')
if mibBuilder.loadTexts: sspmSourceProfilePassword.setDescription('An optional password used by the application protocol.')
sspmSourceProfileParameter = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 1, 1, 15), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceProfileParameter.setStatus('current')
if mibBuilder.loadTexts: sspmSourceProfileParameter.setDescription('An optional parameter used by the application protocol. For DNS, this would be the hostname or IP. For HTTP, this would be the URL. For nntp, this would be the news group. For TCP, this would be the port number. For SMTP, this would be the recipient (and could assume the message is predefined).')
sspmSourceProfileOwner = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 1, 1, 16), OwnerString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceProfileOwner.setStatus('current')
if mibBuilder.loadTexts: sspmSourceProfileOwner.setDescription('Name of the management station/application that set up the profile.')
sspmSourceProfileStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 1, 1, 17), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceProfileStorageType.setStatus('current')
if mibBuilder.loadTexts: sspmSourceProfileStorageType.setDescription("The storage type of this sspmSourceProfileEntry. If the value of this object is 'permanent', no objects in this row need to be writable.")
sspmSourceProfileStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 1, 1, 18), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceProfileStatus.setStatus('current')
if mibBuilder.loadTexts: sspmSourceProfileStatus.setDescription('Status of this profile. An entry may not exist in the active state unless all objects in the entry have an appropriate value. Once this object is set to active(1), no objects in the sspmSourceProfileTable can be changed.')
sspmSourceControlTable = MibTable((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 2), )
if mibBuilder.loadTexts: sspmSourceControlTable.setStatus('current')
if mibBuilder.loadTexts: sspmSourceControlTable.setDescription('The table of SSPM measurements configured.')
sspmSourceControlEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 2, 1), ).setIndexNames((0, "SSPM-MIB", "sspmSourceControlInstance"))
if mibBuilder.loadTexts: sspmSourceControlEntry.setStatus('current')
if mibBuilder.loadTexts: sspmSourceControlEntry.setDescription('Details about a particular SSPM configuration.')
sspmSourceControlInstance = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 2, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: sspmSourceControlInstance.setStatus('current')
if mibBuilder.loadTexts: sspmSourceControlInstance.setDescription('An arbitrary index.')
sspmSourceControlProfile = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceControlProfile.setStatus('current')
if mibBuilder.loadTexts: sspmSourceControlProfile.setDescription('A pointer to the profile (sspmSourceProfileEntry) that this control entry uses to define the test being performed.')
sspmSourceControlSrc = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 2, 1, 3), InterfaceIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceControlSrc.setStatus('current')
if mibBuilder.loadTexts: sspmSourceControlSrc.setDescription('The ifIndex where the packet should originate from the probe (if it matters). A value of zero indicates that it does not matter and that the device decides.')
sspmSourceControlDestAddrType = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 2, 1, 4), InetAddressType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceControlDestAddrType.setStatus('current')
if mibBuilder.loadTexts: sspmSourceControlDestAddrType.setDescription('The type of Internet address by which the destination is accessed.')
sspmSourceControlDestAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 2, 1, 5), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceControlDestAddr.setStatus('current')
if mibBuilder.loadTexts: sspmSourceControlDestAddr.setDescription('The Internet address for the destination. The formatting of this object is controlled by the sspmSourceControlDestAddrType object above. When this object contains a DNS name, then the name is resolved to an address each time measurement is to be made. Further, the agent should not cache this address, but instead should perform the resolution prior to each measurement.')
sspmSourceControlEnabled = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 2, 1, 6), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceControlEnabled.setStatus('current')
if mibBuilder.loadTexts: sspmSourceControlEnabled.setDescription("When set to 'true', this test is enabled. When set to 'false', it is disabled.")
sspmSourceControlTimeOut = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 2, 1, 7), SspmMicroSeconds()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceControlTimeOut.setStatus('current')
if mibBuilder.loadTexts: sspmSourceControlTimeOut.setDescription('Timeout value for the measurement response. If no response is received in the time specified, then the test fails.')
sspmSourceControlSamplingDist = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("deterministic", 1), ("poisson", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceControlSamplingDist.setStatus('current')
if mibBuilder.loadTexts: sspmSourceControlSamplingDist.setDescription("When this attribute is set to 'deterministic', then packets are generated at with a fixed inter-packet injection time specified by sspmSourceFrequency. When this attribute is set to 'Poisson', then packets are generated with inter-packet injection times sampled from an exponential distribution with the single distributional parameter determined by the inverse frequency).")
sspmSourceControlFrequency = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 2, 1, 9), SspmMicroSeconds()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceControlFrequency.setStatus('current')
if mibBuilder.loadTexts: sspmSourceControlFrequency.setDescription("The inverse of this value is the rate at which packets are generated. Refer to sspmSourceSamplingDistribution. If the value set is less than the value of sspmGeneralMinFrequency, then the set will fail with an error-status of 'inconsistentValue'.")
sspmSourceControlFirstSeqNum = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 2, 1, 10), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceControlFirstSeqNum.setStatus('current')
if mibBuilder.loadTexts: sspmSourceControlFirstSeqNum.setDescription('The first sequence number of packets to be transmitted.')
sspmSourceControlLastSeqNum = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 2, 1, 11), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sspmSourceControlLastSeqNum.setStatus('current')
if mibBuilder.loadTexts: sspmSourceControlLastSeqNum.setDescription('The last sequence number transmitted. This value is updated by the agent after packet generation.')
sspmSourceControlOwner = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 2, 1, 12), OwnerString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceControlOwner.setStatus('current')
if mibBuilder.loadTexts: sspmSourceControlOwner.setDescription('Name of the management station/application that set up the test.')
sspmSourceControlStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 2, 1, 13), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceControlStorageType.setStatus('current')
if mibBuilder.loadTexts: sspmSourceControlStorageType.setDescription("The storage type of this sspmSourceControlEntry. If the value of this object is 'permanent', no objects in this row need to be writable.")
sspmSourceControlStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 2, 1, 14), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceControlStatus.setStatus('current')
if mibBuilder.loadTexts: sspmSourceControlStatus.setDescription("Status of this source control entry. An entry may not exist in the active state unless all objects in the entry have an appropriate value. When this attribute has the value of 'active', none of the read-write or read-create attributes in this table may be modified, with the exception of sspmSourceControlEnabled.")
sspmSink = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 28, 1, 5))
sspmSinkTable = MibTable((1, 3, 6, 1, 2, 1, 16, 28, 1, 5, 1), )
if mibBuilder.loadTexts: sspmSinkTable.setStatus('current')
if mibBuilder.loadTexts: sspmSinkTable.setDescription('A table configuring the sink for measurements.')
sspmSinkEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 28, 1, 5, 1, 1), ).setIndexNames((0, "SSPM-MIB", "sspmSinkInstance"))
if mibBuilder.loadTexts: sspmSinkEntry.setStatus('current')
if mibBuilder.loadTexts: sspmSinkEntry.setDescription('The details of a particular sink entry. If the measurement is a round-trip type, then the sink entry will be on the same probe as the corresponding sspmSourceEntry. If the measurement is a one-way, type then the sink entry will be on a different probe.')
sspmSinkInstance = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 5, 1, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: sspmSinkInstance.setStatus('current')
if mibBuilder.loadTexts: sspmSinkInstance.setDescription('An index. When the measurement is for a round-trip measurement, then this table entry is on the same probe as the corresponding sspmSourceEntry, and the value of this attribute should correspond to the value of sspmSourceInstance. Management applications configuring sinks for one-way measurements could define some scheme whereby the sspmSinkInstance is unique across all probes. Note that the unique key to this entry is also constructed with sspmSinkType, sspmSinkSourceAddressType, and sspmSinkSourceAddress. To make the implementation simpler, those other attributes are not included in the index but uniqueness is still needed to receive all the packets.')
sspmSinkType = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 5, 1, 1, 2), AppLocalIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSinkType.setStatus('current')
if mibBuilder.loadTexts: sspmSinkType.setDescription("The AppLocalIndex value that uniquely identifies the measurement per the APM-MIB. In order to create a row in this table, there must be a corresponding row in the sspmCapabilitiesTable. If there is no corresponding row in the sspmCapabilitiestable, then the agent will return an error-status of 'inconsistentValue'.")
sspmSinkSourceAddressType = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 5, 1, 1, 3), InetAddressType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSinkSourceAddressType.setStatus('current')
if mibBuilder.loadTexts: sspmSinkSourceAddressType.setDescription('The type of Internet address of the source.')
sspmSinkSourceAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 5, 1, 1, 4), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSinkSourceAddress.setStatus('current')
if mibBuilder.loadTexts: sspmSinkSourceAddress.setDescription("The Internet address of the source. The formatting of this object is controlled by the sspmSinkSourceAddressType object above. This object should be set only to a valid device address that has been administratively configured into the device. If a set attempts to set this object to an address that does not belong (i.e., is not administratively configured into the device), the set should fail, and the agent should return a error-status of 'inconsistentValue'.")
sspmSinkExpectedRate = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 5, 1, 1, 5), SspmMicroSeconds()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSinkExpectedRate.setStatus('current')
if mibBuilder.loadTexts: sspmSinkExpectedRate.setDescription('The expected rate at which packets will arrive.')
sspmSinkEnable = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 5, 1, 1, 6), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSinkEnable.setStatus('current')
if mibBuilder.loadTexts: sspmSinkEnable.setDescription('Indicates if the sink is enabled or not.')
sspmSinkExpectedFirstSequenceNum = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 5, 1, 1, 7), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSinkExpectedFirstSequenceNum.setStatus('current')
if mibBuilder.loadTexts: sspmSinkExpectedFirstSequenceNum.setDescription('The expected first sequence number of packets. This is used by the sink to determine if packets were lost at the initiation of the test.')
sspmSinkLastSequenceNumber = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 5, 1, 1, 8), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sspmSinkLastSequenceNumber.setStatus('current')
if mibBuilder.loadTexts: sspmSinkLastSequenceNumber.setDescription('The last sequence number received.')
sspmSinkLastSequenceInvalid = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 5, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sspmSinkLastSequenceInvalid.setStatus('current')
if mibBuilder.loadTexts: sspmSinkLastSequenceInvalid.setDescription('The number of packets that arrived whose sequence number was not one plus the value of sspmSinkLastSequenceNumber.')
sspmSinkStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 5, 1, 1, 10), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSinkStorageType.setStatus('current')
if mibBuilder.loadTexts: sspmSinkStorageType.setDescription("The storage type of this sspmSinkEntry. If the value of this object is 'permanent', no objects in this row need to be writable.")
sspmSinkStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 5, 1, 1, 11), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSinkStatus.setStatus('current')
if mibBuilder.loadTexts: sspmSinkStatus.setDescription('Status of this conceptual row. An entry may not exist in the active state unless all objects in the entry have an appropriate value. Once this object is set to active(1), no objects with MAX-ACCESS of read-create in the sspmSinkTable can be changed.')
sspmCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 28, 3, 1))
sspmGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 28, 3, 2))
sspmGeneralCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 16, 28, 3, 1, 1)).setObjects(("SSPM-MIB", "sspmGeneralGroup"), ("SSPM-MIB", "sspmSourceGroup"), ("SSPM-MIB", "sspmSinkGroup"), ("SSPM-MIB", "sspmUserPassGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    sspmGeneralCompliance = sspmGeneralCompliance.setStatus('current')
if mibBuilder.loadTexts: sspmGeneralCompliance.setDescription('A general compliance that allows all things to be optional.')
sspmSourceFullCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 16, 28, 3, 1, 2)).setObjects(("SSPM-MIB", "sspmGeneralGroup"), ("SSPM-MIB", "sspmSourceGroup"), ("SSPM-MIB", "sspmUserPassGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    sspmSourceFullCompliance = sspmSourceFullCompliance.setStatus('current')
if mibBuilder.loadTexts: sspmSourceFullCompliance.setDescription('A source compliance. Use this compliance when implementing a traffic-source-only device. This is useful for implementing devices that probe other devices for intrusive application monitoring. It is also useful for implementing the source of one-way tests used with a sink-only device.')
sspmSinkFullCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 16, 28, 3, 1, 3)).setObjects(("SSPM-MIB", "sspmGeneralGroup"), ("SSPM-MIB", "sspmSinkGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    sspmSinkFullCompliance = sspmSinkFullCompliance.setStatus('current')
if mibBuilder.loadTexts: sspmSinkFullCompliance.setDescription('A sink-only compliance. Use this compliance when implementing a sink-only device. This is useful for devices to receive one-way measurements.')
sspmGeneralGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 28, 3, 2, 1)).setObjects(("SSPM-MIB", "sspmGeneralClockResolution"), ("SSPM-MIB", "sspmGeneralClockMaxSkew"), ("SSPM-MIB", "sspmGeneralClockSource"), ("SSPM-MIB", "sspmGeneralMinFrequency"), ("SSPM-MIB", "sspmCapabilitiesInstance"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    sspmGeneralGroup = sspmGeneralGroup.setStatus('current')
if mibBuilder.loadTexts: sspmGeneralGroup.setDescription('The objects in the SSPM General Group.')
sspmSourceGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 28, 3, 2, 2)).setObjects(("SSPM-MIB", "sspmSourceProfileType"), ("SSPM-MIB", "sspmSourceProfilePacketSize"), ("SSPM-MIB", "sspmSourceProfilePacketFillType"), ("SSPM-MIB", "sspmSourceProfilePacketFillValue"), ("SSPM-MIB", "sspmSourceProfileTOS"), ("SSPM-MIB", "sspmSourceProfileFlowLabel"), ("SSPM-MIB", "sspmSourceProfileLooseSrcRteFill"), ("SSPM-MIB", "sspmSourceProfileLooseSrcRteLen"), ("SSPM-MIB", "sspmSourceProfileTTL"), ("SSPM-MIB", "sspmSourceProfileNoFrag"), ("SSPM-MIB", "sspmSourceProfile8021Tagging"), ("SSPM-MIB", "sspmSourceProfileUsername"), ("SSPM-MIB", "sspmSourceProfilePassword"), ("SSPM-MIB", "sspmSourceProfileParameter"), ("SSPM-MIB", "sspmSourceProfileOwner"), ("SSPM-MIB", "sspmSourceProfileStorageType"), ("SSPM-MIB", "sspmSourceProfileStatus"), ("SSPM-MIB", "sspmSourceControlProfile"), ("SSPM-MIB", "sspmSourceControlSrc"), ("SSPM-MIB", "sspmSourceControlDestAddrType"), ("SSPM-MIB", "sspmSourceControlDestAddr"), ("SSPM-MIB", "sspmSourceControlEnabled"), ("SSPM-MIB", "sspmSourceControlTimeOut"), ("SSPM-MIB", "sspmSourceControlSamplingDist"), ("SSPM-MIB", "sspmSourceControlFrequency"), ("SSPM-MIB", "sspmSourceControlFirstSeqNum"), ("SSPM-MIB", "sspmSourceControlLastSeqNum"), ("SSPM-MIB", "sspmSourceControlOwner"), ("SSPM-MIB", "sspmSourceControlStorageType"), ("SSPM-MIB", "sspmSourceControlStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    sspmSourceGroup = sspmSourceGroup.setStatus('current')
if mibBuilder.loadTexts: sspmSourceGroup.setDescription('The objects in the SSPM Source Group.')
sspmUserPassGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 28, 3, 2, 3)).setObjects(("SSPM-MIB", "sspmSourceProfileUsername"), ("SSPM-MIB", "sspmSourceProfilePassword"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    sspmUserPassGroup = sspmUserPassGroup.setStatus('current')
if mibBuilder.loadTexts: sspmUserPassGroup.setDescription('The objects in the SSPM Username and password group.')
sspmSinkGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 28, 3, 2, 4)).setObjects(("SSPM-MIB", "sspmSinkType"), ("SSPM-MIB", "sspmSinkSourceAddressType"), ("SSPM-MIB", "sspmSinkSourceAddress"), ("SSPM-MIB", "sspmSinkExpectedRate"), ("SSPM-MIB", "sspmSinkEnable"), ("SSPM-MIB", "sspmSinkExpectedFirstSequenceNum"), ("SSPM-MIB", "sspmSinkLastSequenceNumber"), ("SSPM-MIB", "sspmSinkLastSequenceInvalid"), ("SSPM-MIB", "sspmSinkStorageType"), ("SSPM-MIB", "sspmSinkStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    sspmSinkGroup = sspmSinkGroup.setStatus('current')
if mibBuilder.loadTexts: sspmSinkGroup.setDescription('The objects in the SSPM Sink Group.')
mibBuilder.exportSymbols("SSPM-MIB", sspmCompliances=sspmCompliances, sspmGeneralClockSource=sspmGeneralClockSource, sspmMIBNotifications=sspmMIBNotifications, sspmSourceProfileInstance=sspmSourceProfileInstance, sspmCapabilitiesEntry=sspmCapabilitiesEntry, sspmUserPassGroup=sspmUserPassGroup, sspmSourceProfilePacketFillValue=sspmSourceProfilePacketFillValue, sspmSourceProfileTable=sspmSourceProfileTable, SspmClockSource=SspmClockSource, SspmClockMaxSkew=SspmClockMaxSkew, sspmMIB=sspmMIB, sspmCapabilitiesTable=sspmCapabilitiesTable, sspmSourceProfileTOS=sspmSourceProfileTOS, sspmSourceProfileFlowLabel=sspmSourceProfileFlowLabel, sspmSourceControlInstance=sspmSourceControlInstance, sspmSourceProfileLooseSrcRteFill=sspmSourceProfileLooseSrcRteFill, sspmGeneralCompliance=sspmGeneralCompliance, sspmSourceProfileTTL=sspmSourceProfileTTL, sspmSource=sspmSource, sspmSinkGroup=sspmSinkGroup, sspmSinkStatus=sspmSinkStatus, sspmSinkStorageType=sspmSinkStorageType, sspmGeneralGroup=sspmGeneralGroup, sspmGeneralMinFrequency=sspmGeneralMinFrequency, sspmSourceGroup=sspmSourceGroup, sspmSourceProfile8021Tagging=sspmSourceProfile8021Tagging, sspmSinkInstance=sspmSinkInstance, sspmSourceProfilePacketSize=sspmSourceProfilePacketSize, sspmSourceProfileLooseSrcRteLen=sspmSourceProfileLooseSrcRteLen, sspmSourceProfileNoFrag=sspmSourceProfileNoFrag, sspmSourceControlOwner=sspmSourceControlOwner, sspmSourceControlStatus=sspmSourceControlStatus, PYSNMP_MODULE_ID=sspmMIB, SspmMicroSeconds=SspmMicroSeconds, sspmSourceControlLastSeqNum=sspmSourceControlLastSeqNum, sspmSourceControlTable=sspmSourceControlTable, sspmGroups=sspmGroups, sspmCapabilitiesInstance=sspmCapabilitiesInstance, sspmSourceControlEntry=sspmSourceControlEntry, sspmSinkSourceAddressType=sspmSinkSourceAddressType, sspmSourceControlSamplingDist=sspmSourceControlSamplingDist, sspmSinkExpectedFirstSequenceNum=sspmSinkExpectedFirstSequenceNum, sspmSinkLastSequenceNumber=sspmSinkLastSequenceNumber, sspmSourceControlSrc=sspmSourceControlSrc, sspmSourceProfilePacketFillType=sspmSourceProfilePacketFillType, sspmMIBConformance=sspmMIBConformance, sspmSourceProfileStatus=sspmSourceProfileStatus, sspmSink=sspmSink, sspmSinkType=sspmSinkType, sspmSourceControlFrequency=sspmSourceControlFrequency, sspmSourceProfileEntry=sspmSourceProfileEntry, sspmSinkEnable=sspmSinkEnable, sspmGeneralClockMaxSkew=sspmGeneralClockMaxSkew, sspmSourceProfileType=sspmSourceProfileType, sspmSinkFullCompliance=sspmSinkFullCompliance, sspmSourceProfileOwner=sspmSourceProfileOwner, sspmSourceProfilePassword=sspmSourceProfilePassword, sspmSourceControlTimeOut=sspmSourceControlTimeOut, sspmSourceControlProfile=sspmSourceControlProfile, sspmGeneral=sspmGeneral, sspmSinkSourceAddress=sspmSinkSourceAddress, sspmSinkEntry=sspmSinkEntry, sspmSourceControlDestAddr=sspmSourceControlDestAddr, sspmSourceProfileStorageType=sspmSourceProfileStorageType, sspmSourceControlEnabled=sspmSourceControlEnabled, sspmSourceControlFirstSeqNum=sspmSourceControlFirstSeqNum, sspmSourceControlStorageType=sspmSourceControlStorageType, sspmSourceProfileUsername=sspmSourceProfileUsername, sspmGeneralClockResolution=sspmGeneralClockResolution, sspmSourceProfileParameter=sspmSourceProfileParameter, sspmSinkExpectedRate=sspmSinkExpectedRate, sspmSinkTable=sspmSinkTable, sspmSinkLastSequenceInvalid=sspmSinkLastSequenceInvalid, sspmSourceFullCompliance=sspmSourceFullCompliance, sspmSourceControlDestAddrType=sspmSourceControlDestAddrType, sspmMIBObjects=sspmMIBObjects)

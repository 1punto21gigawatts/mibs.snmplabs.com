#
# PySNMP MIB module DIFF-SERV-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/DIFF-SERV-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:23:07 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueRangeConstraint, ConstraintsIntersection, ConstraintsUnion, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueRangeConstraint", "ConstraintsIntersection", "ConstraintsUnion", "ValueSizeConstraint")
ifIndex, = mibBuilder.importSymbols("IF-MIB", "ifIndex")
InetAddressType, InetAddress = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddressType", "InetAddress")
BurstSize, = mibBuilder.importSymbols("INTEGRATED-SERVICES-MIB", "BurstSize")
NotificationGroup, ObjectGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ObjectGroup", "ModuleCompliance")
Unsigned32, ModuleIdentity, MibIdentifier, mib_2, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter32, Integer32, TimeTicks, zeroDotZero, Bits, ObjectIdentity, NotificationType, Gauge32, IpAddress, iso, Counter64 = mibBuilder.importSymbols("SNMPv2-SMI", "Unsigned32", "ModuleIdentity", "MibIdentifier", "mib-2", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter32", "Integer32", "TimeTicks", "zeroDotZero", "Bits", "ObjectIdentity", "NotificationType", "Gauge32", "IpAddress", "iso", "Counter64")
DisplayString, RowStatus, TimeStamp, TextualConvention, RowPointer = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "RowStatus", "TimeStamp", "TextualConvention", "RowPointer")
diffServMib = ModuleIdentity((1, 3, 6, 1, 2, 1, 12345))
diffServMib.setRevisions(('2000-07-13 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: diffServMib.setRevisionsDescriptions(('Initial version, published as RFC xxxx.',))
if mibBuilder.loadTexts: diffServMib.setLastUpdated('200007130000Z')
if mibBuilder.loadTexts: diffServMib.setOrganization('IETF Diffserv WG')
if mibBuilder.loadTexts: diffServMib.setContactInfo(' Brian Carpenter (co-chair of Diffserv WG) c/o iCAIR 1890 Maple Ave, #150 Evanston, IL 60201, USA Phone: +1 847 467 7811 E-mail: brian@icair.org Kathleen Nichols (co-chair of Diffserv WG) Packet Design E-mail: nichols@packetdesign.com Fred Baker (author) Cisco Systems 519 Lado Drive Santa Barbara, CA 93111, USA E-mail: fred@cisco.com Kwok Ho Chan (author) Nortel Networks 600 Technology Park Drive Billerica, MA 01821, USA E-mail: khchan@nortelnetworks.com Andrew Smith (author) E-mail: ah-smith@pacbell.net')
if mibBuilder.loadTexts: diffServMib.setDescription('This MIB defines the objects necessary to manage a device that uses the Differentiated Services Architecture described in RFC 2475 and the Informal Management Model for DiffServ Routers in draft-ietf-diffserv-model-04.txt.')
diffServObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 12345, 1))
diffServTables = MibIdentifier((1, 3, 6, 1, 2, 1, 12345, 2))
diffServMIBConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 12345, 3))
class Dscp(TextualConvention, Integer32):
    description = 'The IP header Diffserv Code-Point that may be used for discriminating or marking a traffic stream. The value -1 is used to indicate a wildcard i.e. any value.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(ValueRangeConstraint(-1, -1), ValueRangeConstraint(0, 63), )
class SixTupleClfrL4Port(TextualConvention, Integer32):
    description = 'A value indicating a Layer-4 protocol port number.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 65535)

class IfDirection(TextualConvention, Integer32):
    description = "Specifies a direction of data travel on an interface. 'inbound' traffic is operated on during reception from the interface, while 'outbound' traffic is operated on prior to transmission on the interface."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("inbound", 1), ("outbound", 2))

diffServClassifierTable = MibTable((1, 3, 6, 1, 2, 1, 12345, 2, 1), )
if mibBuilder.loadTexts: diffServClassifierTable.setReference('[MODEL] section 4.1')
if mibBuilder.loadTexts: diffServClassifierTable.setStatus('current')
if mibBuilder.loadTexts: diffServClassifierTable.setDescription('The classifier table defines the classifiers that are applied to traffic arriving at this interface in a particular direction. Specific classifiers are defined by RowPointers in the entries of this table which identify entries in filter tables of specific types, e.g. Multi-Field Classifiers (MFCs) for IP are defined in the diffServSixTupleClfrTable. Other classifier types may be defined elsewhere.')
diffServClassifierEntry = MibTableRow((1, 3, 6, 1, 2, 1, 12345, 2, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "DIFF-SERV-MIB", "diffServClassifierIfDirection"), (0, "DIFF-SERV-MIB", "diffServClassifierTcb"), (0, "DIFF-SERV-MIB", "diffServClassifierId"))
if mibBuilder.loadTexts: diffServClassifierEntry.setStatus('current')
if mibBuilder.loadTexts: diffServClassifierEntry.setDescription('An entry in the classifier table describes a single element of the classifier.')
diffServClassifierIfDirection = MibTableColumn((1, 3, 6, 1, 2, 1, 12345, 2, 1, 1, 1), IfDirection())
if mibBuilder.loadTexts: diffServClassifierIfDirection.setStatus('current')
if mibBuilder.loadTexts: diffServClassifierIfDirection.setDescription('Specifies the direction for which this classifier entry applies on this interface.')
diffServClassifierTcb = MibTableColumn((1, 3, 6, 1, 2, 1, 12345, 2, 1, 1, 2), Unsigned32())
if mibBuilder.loadTexts: diffServClassifierTcb.setStatus('current')
if mibBuilder.loadTexts: diffServClassifierTcb.setDescription('Specifies the TCB of which this classifier element is a part. Lower numbers indicate an element that belongs to a classifier that is part of a TCB that is, at least conceptually, applied to traffic before those with higher numbers - this is necessary to resolve ambiguity in cases where different TCBs contain filters that overlap with each other. A manager wanting to create a new TCB should either first search this table for existing entries and pick a value for this variable that is not currently represented - some form of pseudo- random choice is likely to minimise collisions. After successful creation of a conceptual row using the chosen value, the manager should check again that there are no other rows with this value that have been created by a different manager that could, potentially, interfere with the classifier elements that are desired.')
diffServClassifierId = MibTableColumn((1, 3, 6, 1, 2, 1, 12345, 2, 1, 1, 3), Unsigned32())
if mibBuilder.loadTexts: diffServClassifierId.setStatus('current')
if mibBuilder.loadTexts: diffServClassifierId.setDescription('A classifier ID that enumerates the classifier elements. The set of such identifiers spans the whole agent. Managers should obtain new values for row creation in this table by reading diffServClassifierNextFree.')
diffServClassifierFilter = MibTableColumn((1, 3, 6, 1, 2, 1, 12345, 2, 1, 1, 4), RowPointer().clone((0, 0))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServClassifierFilter.setStatus('current')
if mibBuilder.loadTexts: diffServClassifierFilter.setDescription('A pointer to a valid entry in another table that describes the applicable classification filter, e.g. an entry in diffServSixTupleClfrTable. If the row pointed to does not exist, the classifier is ignored. The value zeroDotZero is interpreted to match anything not matched by another classifier - only one such entry may exist in this table.')
diffServClassifierNext = MibTableColumn((1, 3, 6, 1, 2, 1, 12345, 2, 1, 1, 5), RowPointer()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServClassifierNext.setStatus('current')
if mibBuilder.loadTexts: diffServClassifierNext.setDescription('This selects the next datapath element to handle packets matching the filter pattern. For example, this can point to an entry in a meter, action, algorithmic dropper or queue table. If the row pointed to does not exist, the classifier element is ignored.')
diffServClassifierPrecedence = MibTableColumn((1, 3, 6, 1, 2, 1, 12345, 2, 1, 1, 6), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServClassifierPrecedence.setStatus('current')
if mibBuilder.loadTexts: diffServClassifierPrecedence.setDescription('The relative precedence in which classifiers are applied: higher numbers represent classifiers with higher precedence. Classifiers with the same precedence must be unambiguous i.e. they must define non-overlapping patterns, and are considered to be applied simultaneously to the traffic stream. Classifiers with different precedence may overlap in their filters: the classifier with the highest precedence that matches is taken. On a given interface, there must be a complete classifier in place at all times for the first TCB (lowest value of diffServClassifierTcb) in the ingress direction. This means that there will always be one or more filters that match every possible pattern that could be presented in an incoming packet. There is no such requirement for subsequent TCBs in the ingress direction, nor for any TCB in the egress direction.')
diffServClassifierStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 12345, 2, 1, 1, 7), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServClassifierStatus.setStatus('current')
if mibBuilder.loadTexts: diffServClassifierStatus.setDescription('The RowStatus variable controls the activation, deactivation, or deletion of a classifier. Any writable variable may be modified whether the row is active or notInService.')
diffServClassifierNextFree = MibScalar((1, 3, 6, 1, 2, 1, 12345, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: diffServClassifierNextFree.setStatus('current')
if mibBuilder.loadTexts: diffServClassifierNextFree.setDescription('This object yields a value when read that is currently-unused for a diffServClassifierId instance. If a configuring system attempts to create a new row in the diffServClassifierTable using this value, that operation will fail if the value has, in the meantime, been used to create another row that is currently valid.')
diffServSixTupleClfrTable = MibTable((1, 3, 6, 1, 2, 1, 12345, 2, 2), )
if mibBuilder.loadTexts: diffServSixTupleClfrTable.setReference('[MODEL] section 4.2.2')
if mibBuilder.loadTexts: diffServSixTupleClfrTable.setStatus('current')
if mibBuilder.loadTexts: diffServSixTupleClfrTable.setDescription('A table of IP Six-Tuple Classifier filter entries that a system may use to identify IP traffic.')
diffServSixTupleClfrEntry = MibTableRow((1, 3, 6, 1, 2, 1, 12345, 2, 2, 1), ).setIndexNames((0, "DIFF-SERV-MIB", "diffServSixTupleClfrId"))
if mibBuilder.loadTexts: diffServSixTupleClfrEntry.setStatus('current')
if mibBuilder.loadTexts: diffServSixTupleClfrEntry.setDescription('An IP Six-Tuple Classifier entry describes a single filter.')
diffServSixTupleClfrId = MibTableColumn((1, 3, 6, 1, 2, 1, 12345, 2, 2, 1, 1), Unsigned32())
if mibBuilder.loadTexts: diffServSixTupleClfrId.setStatus('current')
if mibBuilder.loadTexts: diffServSixTupleClfrId.setDescription('A unique identifier for the filter. Filters may be shared by multiple interfaces in the same system. Managers should obtain new values for row creation in this table by reading diffServSixTupleClfrNextFree.')
diffServSixTupleClfrDstAddrType = MibTableColumn((1, 3, 6, 1, 2, 1, 12345, 2, 2, 1, 2), InetAddressType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServSixTupleClfrDstAddrType.setStatus('current')
if mibBuilder.loadTexts: diffServSixTupleClfrDstAddrType.setDescription('The type of IP destination address used by this classifier entry.')
diffServSixTupleClfrDstAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 12345, 2, 2, 1, 3), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServSixTupleClfrDstAddr.setStatus('current')
if mibBuilder.loadTexts: diffServSixTupleClfrDstAddr.setDescription("The IP address to match against the packet's destination IP address.")
diffServSixTupleClfrDstAddrMask = MibTableColumn((1, 3, 6, 1, 2, 1, 12345, 2, 2, 1, 4), Unsigned32()).setUnits('bits').setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServSixTupleClfrDstAddrMask.setStatus('current')
if mibBuilder.loadTexts: diffServSixTupleClfrDstAddrMask.setDescription('The length of a mask for the matching of the destination IP address. Masks are constructed by setting bits in sequence from the most-significant bit downwards for diffServSixTupleClfrDstAddrMask bits length. All other bits in the mask, up to the number needed to fill the length of the address diffServSixTupleClfrDstAddr are cleared to zero. A zero bit in the mask then means that the corresponding bit in the address always matches.')
diffServSixTupleClfrSrcAddrType = MibTableColumn((1, 3, 6, 1, 2, 1, 12345, 2, 2, 1, 5), InetAddressType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServSixTupleClfrSrcAddrType.setStatus('current')
if mibBuilder.loadTexts: diffServSixTupleClfrSrcAddrType.setDescription('The type of IP source address used by this classifier entry.')
diffServSixTupleClfrSrcAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 12345, 2, 2, 1, 6), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServSixTupleClfrSrcAddr.setStatus('current')
if mibBuilder.loadTexts: diffServSixTupleClfrSrcAddr.setDescription('The IP address to match against the source IP address of each packet.')
diffServSixTupleClfrSrcAddrMask = MibTableColumn((1, 3, 6, 1, 2, 1, 12345, 2, 2, 1, 7), Unsigned32()).setUnits('bits').setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServSixTupleClfrSrcAddrMask.setStatus('current')
if mibBuilder.loadTexts: diffServSixTupleClfrSrcAddrMask.setDescription('The length of a mask for the matching of the source IP address. Masks are constructed by setting bits in sequence from the most- significant bit downwards for diffServSixTupleClfrSrcAddrMask bits length. All other bits in the mask, up to the number needed to fill the length of the address diffServSixTupleClfrSrcAddr are cleared to zero. A zero bit in the mask then means that the corresponding bit in the address always matches.')
diffServSixTupleClfrDscp = MibTableColumn((1, 3, 6, 1, 2, 1, 12345, 2, 2, 1, 8), Dscp().clone(-1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServSixTupleClfrDscp.setStatus('current')
if mibBuilder.loadTexts: diffServSixTupleClfrDscp.setDescription('The value that the DSCP in the packet must have to match this entry. A value of -1 indicates that a specific DSCP value has not been defined and thus all DSCP values are considered a match.')
diffServSixTupleClfrProtocol = MibTableColumn((1, 3, 6, 1, 2, 1, 12345, 2, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServSixTupleClfrProtocol.setStatus('current')
if mibBuilder.loadTexts: diffServSixTupleClfrProtocol.setDescription('The IP protocol to match against the IPv4 protocol number in the packet. A value of zero means match all.')
diffServSixTupleClfrDstL4PortMin = MibTableColumn((1, 3, 6, 1, 2, 1, 12345, 2, 2, 1, 10), SixTupleClfrL4Port()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServSixTupleClfrDstL4PortMin.setStatus('current')
if mibBuilder.loadTexts: diffServSixTupleClfrDstL4PortMin.setDescription('The minimum value that the layer-4 destination port number in the packet must have in order to match this classifier entry.')
diffServSixTupleClfrDstL4PortMax = MibTableColumn((1, 3, 6, 1, 2, 1, 12345, 2, 2, 1, 11), SixTupleClfrL4Port().clone(65535)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServSixTupleClfrDstL4PortMax.setStatus('current')
if mibBuilder.loadTexts: diffServSixTupleClfrDstL4PortMax.setDescription('The maximum value that the layer-4 destination port number in the packet must have in order to match this classifier entry. This value must be equal to or greater that the value specified for this entry in diffServSixTupleClfrDstL4PortMin.')
diffServSixTupleClfrSrcL4PortMin = MibTableColumn((1, 3, 6, 1, 2, 1, 12345, 2, 2, 1, 12), SixTupleClfrL4Port()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServSixTupleClfrSrcL4PortMin.setStatus('current')
if mibBuilder.loadTexts: diffServSixTupleClfrSrcL4PortMin.setDescription('The minimum value that the layer-4 source port number in the packet must have in order to match this classifier entry.')
diffServSixTupleClfrSrcL4PortMax = MibTableColumn((1, 3, 6, 1, 2, 1, 12345, 2, 2, 1, 13), SixTupleClfrL4Port().clone(65535)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServSixTupleClfrSrcL4PortMax.setStatus('current')
if mibBuilder.loadTexts: diffServSixTupleClfrSrcL4PortMax.setDescription('The maximum value that the layer-4 source port number in the packet must have in oder to match this classifier entry. This value must be equal to or greater that the value specified for this entry in dsSixTupleIpSrcL4PortMin.')
diffServSixTupleClfrStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 12345, 2, 2, 1, 14), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServSixTupleClfrStatus.setStatus('current')
if mibBuilder.loadTexts: diffServSixTupleClfrStatus.setDescription('The RowStatus variable controls the activation, deactivation, or deletion of a classifier. Any writable variable may be modified whether the row is active or notInService.')
diffServSixTupleClfrNextFree = MibScalar((1, 3, 6, 1, 2, 1, 12345, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: diffServSixTupleClfrNextFree.setStatus('current')
if mibBuilder.loadTexts: diffServSixTupleClfrNextFree.setDescription('This object yields a value when read that is currently-unused for a diffServSixTupleClfrId instance. If a configuring system attempts to create a new row in the diffServSixTupleClfrTable using this value, that operation will fail if the value has, in the meantime, been used to create another row that is currently valid.')
diffServMeterTable = MibTable((1, 3, 6, 1, 2, 1, 12345, 2, 3), )
if mibBuilder.loadTexts: diffServMeterTable.setReference('[MODEL] section 5.1')
if mibBuilder.loadTexts: diffServMeterTable.setStatus('current')
if mibBuilder.loadTexts: diffServMeterTable.setDescription('This table enumerates generic meters that a system may use to police a stream of traffic. The traffic stream to be metered is determined by the element(s) upstream of the meter i.e. by the object(s) that point to each entry in this table. This may include all traffic on an interface. Specific meter details are to be found in diffServMeterSpecific.')
diffServMeterEntry = MibTableRow((1, 3, 6, 1, 2, 1, 12345, 2, 3, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "DIFF-SERV-MIB", "diffServMeterIfDirection"), (0, "DIFF-SERV-MIB", "diffServMeterId"))
if mibBuilder.loadTexts: diffServMeterEntry.setStatus('current')
if mibBuilder.loadTexts: diffServMeterEntry.setDescription('An entry in the meter table describing a single meter.')
diffServMeterIfDirection = MibTableColumn((1, 3, 6, 1, 2, 1, 12345, 2, 3, 1, 1), IfDirection())
if mibBuilder.loadTexts: diffServMeterIfDirection.setStatus('current')
if mibBuilder.loadTexts: diffServMeterIfDirection.setDescription('Specifies the direction for which this meter entry applies on this interface.')
diffServMeterId = MibTableColumn((1, 3, 6, 1, 2, 1, 12345, 2, 3, 1, 2), Unsigned32())
if mibBuilder.loadTexts: diffServMeterId.setStatus('current')
if mibBuilder.loadTexts: diffServMeterId.setDescription('This identifies a meter entry. Managers should obtain new values for row creation in this table by reading diffServMeterNextFree.')
diffServMeterSucceedNext = MibTableColumn((1, 3, 6, 1, 2, 1, 12345, 2, 3, 1, 3), RowPointer().clone((0, 0))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServMeterSucceedNext.setStatus('current')
if mibBuilder.loadTexts: diffServMeterSucceedNext.setDescription('If the traffic does conform to the meter, this indicates the next datapath element to handle the traffic e.g. an Action or another Meter datapath element. The value zeroDotZero in this variable indicates no further Diffserv treatment is performed on this traffic by the current interface for this interface direction. If the row pointed to does not exist, the meter element is considered inactive.')
diffServMeterFailNext = MibTableColumn((1, 3, 6, 1, 2, 1, 12345, 2, 3, 1, 4), RowPointer().clone((0, 0))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServMeterFailNext.setStatus('current')
if mibBuilder.loadTexts: diffServMeterFailNext.setDescription('If the traffic does not conform to the meter, this indicates the next datapath element to handle the traffic e.g. an Action or Meter datapath element. The value zeroDotZero in this variable indicates no further Diffserv treatment is performed on this traffic by the current interface for this interface direction. If the row pointed to does not exist, the meter element is considered inactive.')
diffServMeterSpecific = MibTableColumn((1, 3, 6, 1, 2, 1, 12345, 2, 3, 1, 5), ObjectIdentifier()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServMeterSpecific.setStatus('current')
if mibBuilder.loadTexts: diffServMeterSpecific.setDescription('This indicates the behaviour of the meter by pointing to a table containing detailed parameters. Note that entries in that specific table must be managed explicitly. One example of a valid object would be diffServTBMeterTable, whose entries are indexed by the same variables as this table, for describing an instance of a token-bucket meter.')
diffServMeterStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 12345, 2, 3, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServMeterStatus.setStatus('current')
if mibBuilder.loadTexts: diffServMeterStatus.setDescription('The RowStatus variable controls the activation, deactivation, or deletion of a meter. Any writable variable may be modified whether the row is active or notInService.')
diffServMeterNextFree = MibScalar((1, 3, 6, 1, 2, 1, 12345, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: diffServMeterNextFree.setStatus('current')
if mibBuilder.loadTexts: diffServMeterNextFree.setDescription('This object yields a value when read that is currently-unused for a diffServMeterId instance. If a configuring system attempts to create a new row in the diffServMeterTable using this value, that operation will fail if the value has, in the meantime, been used to create another row that is currently valid.')
diffServTBMeterTable = MibTable((1, 3, 6, 1, 2, 1, 12345, 2, 4), )
if mibBuilder.loadTexts: diffServTBMeterTable.setReference('[MODEL] section 5.1.3')
if mibBuilder.loadTexts: diffServTBMeterTable.setStatus('current')
if mibBuilder.loadTexts: diffServTBMeterTable.setDescription('This table enumerates specific token-bucket meters that a system may use to police a stream of traffic. Such meters are modelled here as having a single rate and a burst size. Multiple meter elements may be logically cascaded using their diffServMeterSucceedNext pointers if a multi-rate token bucket is needed. One example of this might be for an AF PHB implementation that used two-rate meters. Such cascading of meter elements of specific type of token-bucket indicates forwarding behaviour that is functionally equivalent to a multi- rate meter: the sequential nature of the representation is merely a notational convenience for this MIB. Entries in this table share indexing with a parent diffServMeterEntry although they must be managed (e.g. created/deleted) by explicit management action, independently of the associated value of diffServMeterSpecific.')
diffServTBMeterEntry = MibTableRow((1, 3, 6, 1, 2, 1, 12345, 2, 4, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "DIFF-SERV-MIB", "diffServMeterIfDirection"), (0, "DIFF-SERV-MIB", "diffServMeterId"))
if mibBuilder.loadTexts: diffServTBMeterEntry.setStatus('current')
if mibBuilder.loadTexts: diffServTBMeterEntry.setDescription('An entry that describes a single token-bucket meter, indexed by the same variables as a diffServMeterEntry.')
diffServTBMeterRate = MibTableColumn((1, 3, 6, 1, 2, 1, 12345, 2, 4, 1, 1), Unsigned32()).setUnits('kilobits per second').setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServTBMeterRate.setStatus('current')
if mibBuilder.loadTexts: diffServTBMeterRate.setDescription('The token-bucket rate, in kilobits per second (kbps).')
diffServTBMeterBurstSize = MibTableColumn((1, 3, 6, 1, 2, 1, 12345, 2, 4, 1, 2), BurstSize()).setUnits('Bytes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServTBMeterBurstSize.setStatus('current')
if mibBuilder.loadTexts: diffServTBMeterBurstSize.setDescription('The maximum number of bytes in a single transmission burst. The interval over which the burst is to be measured can be derived as diffServTBMeterBurstSize*8*1000/diffServTBMeterRate.')
diffServTBMeterStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 12345, 2, 4, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServTBMeterStatus.setStatus('current')
if mibBuilder.loadTexts: diffServTBMeterStatus.setDescription('The RowStatus variable controls the activation, deactivation, or deletion of a meter. Any writable variable may be modified whether the row is active or notInService.')
diffServActionTable = MibTable((1, 3, 6, 1, 2, 1, 12345, 2, 5), )
if mibBuilder.loadTexts: diffServActionTable.setReference('[MODEL] section 6.')
if mibBuilder.loadTexts: diffServActionTable.setStatus('current')
if mibBuilder.loadTexts: diffServActionTable.setDescription('The Action Table enumerates actions that can be performed to a stream of traffic. Multiple actions can be concatenated. For example, after marking a stream of traffic exiting from a meter, a device can then perform a count action of the conforming or non-conforming traffic. Specific actions are indicated by diffServActionSpecific which points to another object which describes the action in further detail.')
diffServActionEntry = MibTableRow((1, 3, 6, 1, 2, 1, 12345, 2, 5, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "DIFF-SERV-MIB", "diffServActionIfDirection"), (0, "DIFF-SERV-MIB", "diffServActionId"))
if mibBuilder.loadTexts: diffServActionEntry.setStatus('current')
if mibBuilder.loadTexts: diffServActionEntry.setDescription('An entry in the action table describing the actions applied to traffic arriving at its input.')
diffServActionIfDirection = MibTableColumn((1, 3, 6, 1, 2, 1, 12345, 2, 5, 1, 1), IfDirection())
if mibBuilder.loadTexts: diffServActionIfDirection.setStatus('current')
if mibBuilder.loadTexts: diffServActionIfDirection.setDescription('Specifies the direction for which this action entry applies on this interface.')
diffServActionId = MibTableColumn((1, 3, 6, 1, 2, 1, 12345, 2, 5, 1, 2), Unsigned32())
if mibBuilder.loadTexts: diffServActionId.setStatus('current')
if mibBuilder.loadTexts: diffServActionId.setDescription('This identifies the action entry. Managers should obtain new values for row creation in this table by reading diffServActionNextFree.')
diffServActionNext = MibTableColumn((1, 3, 6, 1, 2, 1, 12345, 2, 5, 1, 3), RowPointer().clone((0, 0))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServActionNext.setStatus('current')
if mibBuilder.loadTexts: diffServActionNext.setDescription('The Next pointer indicates the next datapath element to handle the traffic. For example, a queue datapath element. The value zeroDotZero in this variable indicates no further DiffServ treatment is performed on this flow by the current interface for this interface direction. If the row pointed to does not exist, the action element is considered inactive.')
diffServActionSpecific = MibTableColumn((1, 3, 6, 1, 2, 1, 12345, 2, 5, 1, 4), ObjectIdentifier()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServActionSpecific.setStatus('current')
if mibBuilder.loadTexts: diffServActionSpecific.setDescription('A pointer to an object instance providing additional information for the type of action indicated by this action table entry. For the standard actions defined by this MIB module, this should point to one of the following: a diffServDscpMarkActEntry, a diffServCountActEntry, the diffServAbsoluteDropAction OID. For other actions, it may point to an object instance defined in some other MIB.')
diffServActionStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 12345, 2, 5, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServActionStatus.setStatus('current')
if mibBuilder.loadTexts: diffServActionStatus.setDescription('The RowStatus variable controls the activation, deactivation or deletion of an action element. Any writable variable may be modified whether the row is active or notInService.')
diffServActionNextFree = MibScalar((1, 3, 6, 1, 2, 1, 12345, 1, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: diffServActionNextFree.setStatus('current')
if mibBuilder.loadTexts: diffServActionNextFree.setDescription('This object yields a value when read that is currently-unused for a diffServActionId instance. If a configuring system attempts to create a new row in the diffServActionTable using this value, that operation will fail if the value has, in the meantime, been used to create another row that is currently valid.')
diffServDscpMarkActTable = MibTable((1, 3, 6, 1, 2, 1, 12345, 2, 6), )
if mibBuilder.loadTexts: diffServDscpMarkActTable.setReference('[MODEL] section 6.1')
if mibBuilder.loadTexts: diffServDscpMarkActTable.setStatus('current')
if mibBuilder.loadTexts: diffServDscpMarkActTable.setDescription('This table enumerates specific DSCPs used for marking or remarking the DSCP field of IP packets. The entries of this table may be referenced by a diffServActionSpecific attribute that points to diffServDscpMarkActTable.')
diffServDscpMarkActEntry = MibTableRow((1, 3, 6, 1, 2, 1, 12345, 2, 6, 1), ).setIndexNames((0, "DIFF-SERV-MIB", "diffServDscpMarkActDscp"))
if mibBuilder.loadTexts: diffServDscpMarkActEntry.setStatus('current')
if mibBuilder.loadTexts: diffServDscpMarkActEntry.setDescription('An entry in the DSCP mark action table that describes a single DSCP used for marking.')
diffServDscpMarkActDscp = MibTableColumn((1, 3, 6, 1, 2, 1, 12345, 2, 6, 1, 1), Dscp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: diffServDscpMarkActDscp.setStatus('current')
if mibBuilder.loadTexts: diffServDscpMarkActDscp.setDescription('The DSCP that this Action uses for marking/remarking traffic. Note that a DSCP value of -1 is not permitted in this table. It is quite possible that the only packets subject to this Action are already marked with this DSCP. Note also that Diffserv may result in packet remarking both on ingress to a network and on egress from it and it is quite possible that ingress and egress would occur in the same router.')
diffServCountActTable = MibTable((1, 3, 6, 1, 2, 1, 12345, 2, 7), )
if mibBuilder.loadTexts: diffServCountActTable.setReference('[MODEL] section 6.5')
if mibBuilder.loadTexts: diffServCountActTable.setStatus('current')
if mibBuilder.loadTexts: diffServCountActTable.setDescription('This table contains counters for all the traffic passing through an action element.')
diffServCountActEntry = MibTableRow((1, 3, 6, 1, 2, 1, 12345, 2, 7, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "DIFF-SERV-MIB", "diffServActionIfDirection"), (0, "DIFF-SERV-MIB", "diffServActionId"))
if mibBuilder.loadTexts: diffServCountActEntry.setStatus('current')
if mibBuilder.loadTexts: diffServCountActEntry.setDescription('An entry in the count action table that describes a single set of traffic counters. Entries in this table share indexing with those in the base diffServActionTable although they must be managed (e.g. created/deleted) by explicit management action, independently of the associated value of diffServActionSpecific.')
diffServCountActOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 12345, 2, 7, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: diffServCountActOctets.setStatus('current')
if mibBuilder.loadTexts: diffServCountActOctets.setDescription('The number of octets at the Action datapath element. On high speed devices, this object implements the least significant 32 bits of diffServcountActHCOctets. Discontinuities in the value of this counter can occur at re- initialization of the management system and at other times as indicated by the value of diffServCountActDiscontTime for this entry.')
diffServCountActHCOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 12345, 2, 7, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: diffServCountActHCOctets.setStatus('current')
if mibBuilder.loadTexts: diffServCountActHCOctets.setDescription('The number of octets at the Action datapath element. This object should be used on high speed interfaces. Discontinuities in the value of this counter can occur at re- initialization of the management system and at other times as indicated by the value of diffServCountActDiscontTime for this entry.')
diffServCountActPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 12345, 2, 7, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: diffServCountActPkts.setStatus('current')
if mibBuilder.loadTexts: diffServCountActPkts.setDescription('The number of packets at the Action datapath element. On high speed devices, this object implements the least significant 32 bits of diffServcountActHCPkts. Discontinuities in the value of this counter can occur at re- initialization of the management system and at other times as indicated by the value of diffServCountActDiscontTime for this entry.')
diffServCountActHCPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 12345, 2, 7, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: diffServCountActHCPkts.setStatus('current')
if mibBuilder.loadTexts: diffServCountActHCPkts.setDescription('The number of packets at the Action datapath element. This object should be used on high speed interfaces. Discontinuities in the value of this counter can occur at re- initialization of the management system and at other times as indicated by the value of diffServCountActDiscontTime for this entry.')
diffServCountActDiscontTime = MibTableColumn((1, 3, 6, 1, 2, 1, 12345, 2, 7, 1, 5), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: diffServCountActDiscontTime.setStatus('current')
if mibBuilder.loadTexts: diffServCountActDiscontTime.setDescription("The value of sysUpTime on the most recent occasion at which any one or more of this entry's counters suffered a discontinuity. If no such discontinuities have occurred since the last re- initialization of the local management subsystem, then this object contains a zero value.")
diffServCountActStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 12345, 2, 7, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServCountActStatus.setStatus('current')
if mibBuilder.loadTexts: diffServCountActStatus.setDescription('The RowStatus variable controls the activation, deactivation, or deletion of this entry. Any writable variable may be modified whether the row is active or notInService.')
diffServAbsoluteDropAction = ObjectIdentity((1, 3, 6, 1, 2, 1, 12345, 1, 6))
if mibBuilder.loadTexts: diffServAbsoluteDropAction.setStatus('current')
if mibBuilder.loadTexts: diffServAbsoluteDropAction.setDescription('This object identifier may be used as the value of a diffServActionSpecific pointer in order to indicate that all packets following this path are to be dropped unconditionally at this point. It is likely, but not required, that this action will be preceded by a counter action.')
diffServAlgDropTable = MibTable((1, 3, 6, 1, 2, 1, 12345, 2, 8), )
if mibBuilder.loadTexts: diffServAlgDropTable.setReference('[MODEL] section 7.1.3')
if mibBuilder.loadTexts: diffServAlgDropTable.setStatus('current')
if mibBuilder.loadTexts: diffServAlgDropTable.setDescription('The algorithmic drop table contains entries describing an element that drops packets according to some algorithm.')
diffServAlgDropEntry = MibTableRow((1, 3, 6, 1, 2, 1, 12345, 2, 8, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "DIFF-SERV-MIB", "diffServAlgDropIfDirection"), (0, "DIFF-SERV-MIB", "diffServAlgDropId"))
if mibBuilder.loadTexts: diffServAlgDropEntry.setStatus('current')
if mibBuilder.loadTexts: diffServAlgDropEntry.setDescription('An entry describes a process that drops packets according to some algorithm. Further details of the algorithm type are to be found in diffServAlgDropType and may be pointed to by diffServAlgDropSpecific.')
diffServAlgDropIfDirection = MibTableColumn((1, 3, 6, 1, 2, 1, 12345, 2, 8, 1, 1), IfDirection())
if mibBuilder.loadTexts: diffServAlgDropIfDirection.setStatus('current')
if mibBuilder.loadTexts: diffServAlgDropIfDirection.setDescription('Specifies the direction for which this algorithmic dropper entry applies on this interface.')
diffServAlgDropId = MibTableColumn((1, 3, 6, 1, 2, 1, 12345, 2, 8, 1, 2), Unsigned32())
if mibBuilder.loadTexts: diffServAlgDropId.setStatus('current')
if mibBuilder.loadTexts: diffServAlgDropId.setDescription('This identifies the drop action entry. Managers should obtain new values for row creation in this table by reading diffServAlgDropNextFree.')
diffServAlgDropType = MibTableColumn((1, 3, 6, 1, 2, 1, 12345, 2, 8, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("tailDrop", 2), ("headDrop", 3), ("randomDrop", 4)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServAlgDropType.setStatus('current')
if mibBuilder.loadTexts: diffServAlgDropType.setDescription('The type of algorithm used by this dropper. A value of tailDrop(2) or headDrop(3) represents an algorithm that is completely specified by this MIB. A value of other(1) requires further specification in some other MIB module. The tailDrop(2) algorithm is described as follows: diffServAlgDropQThreshold represents the depth of the queue diffServAlgDropQMeasure at which all newly arriving packets will be dropped. The headDrop(3) algorithm is described as follows: if a packet arrives when the current depth of the queue diffServAlgDropQMeasure is at diffServAlgDropQThreshold, packets currently at the head of the queue are dropped to make room for the new packet to be enqueued at the tail of the queue. The randomDrop(4) algorithm is described as follows: on packet arrival, an algorithm is executed which may randomly drop the packet, or drop other packet(s) from the queue in its place. The specifics of the algorithm may be proprietary. For this algorithm, an associated diffServRandomDropEntry is indicated by pointing diffServAlgDropSpecific at the diffServRandomDropTable. The relevant entry in that table is selected by the common indexing of the two tables. For this algorithm, diffServAlgQThreshold is understood to be the absolute maximum size of the queue and additional parameters are described in diffServRandomDropTable.')
diffServAlgDropNext = MibTableColumn((1, 3, 6, 1, 2, 1, 12345, 2, 8, 1, 4), RowPointer()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServAlgDropNext.setStatus('current')
if mibBuilder.loadTexts: diffServAlgDropNext.setDescription('The Next pointer indicates the next datapath element to handle the traffic e.g. a queue datapath element. The value zeroDotZero in this variable indicates no further DiffServ treatment is performed on this flow by the current interface for this interface direction. If the row pointed to does not exist, the algorithmic dropper element is considered inactive.')
diffServAlgDropQMeasure = MibTableColumn((1, 3, 6, 1, 2, 1, 12345, 2, 8, 1, 5), RowPointer()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServAlgDropQMeasure.setStatus('current')
if mibBuilder.loadTexts: diffServAlgDropQMeasure.setDescription('Points to an entry in the diffServQueueTable to indicate the queue that a drop algorithm is to monitor when deciding whether to drop a packet. If the row pointed to does not exist, the algorithmic dropper element is considered inactive.')
diffServAlgDropQThreshold = MibTableColumn((1, 3, 6, 1, 2, 1, 12345, 2, 8, 1, 6), Unsigned32()).setUnits('Bytes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServAlgDropQThreshold.setStatus('current')
if mibBuilder.loadTexts: diffServAlgDropQThreshold.setDescription('A threshold on the depth in bytes of the queue being measured at which a trigger is generated to the dropping algorithm. For the tailDrop(2) or headDrop(3) algorithms, this represents the depth of the queue diffServAlgDropQMeasure at which the drop action will take place. Other algorithms will need to define their own semantics for this threshold.')
diffServAlgDropSpecific = MibTableColumn((1, 3, 6, 1, 2, 1, 12345, 2, 8, 1, 7), ObjectIdentifier()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServAlgDropSpecific.setStatus('current')
if mibBuilder.loadTexts: diffServAlgDropSpecific.setDescription('Points to a table (not an entry in the table) defined elsewhere that provides further detail regarding a drop algorithm. Entries in such a table are indexed by the same variables as this diffServAlgDropEntry but note that those entries must be managed independently of those in this table. Entries with diffServAlgDropType equal to other(1) may have this point to a table defined in another MIB module. Entries with diffServAlgDropType equal to randomDrop(4) must have this point to diffServRandomDropTable. For all other algorithms, this should take the value zeroDotzero.')
diffServAlgDropOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 12345, 2, 8, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: diffServAlgDropOctets.setStatus('current')
if mibBuilder.loadTexts: diffServAlgDropOctets.setDescription('The number of octets that have been dropped by this drop process. On high speed devices, this object implements the least significant 32 bits of diffServAlgDropHCOctets. Discontinuities in the value of this counter can occur at re- initialization of the management system and at other times as indicated by the value of ifCounterDiscontinuityTime appropriate to this interface.')
diffServAlgDropHCOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 12345, 2, 8, 1, 9), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: diffServAlgDropHCOctets.setStatus('current')
if mibBuilder.loadTexts: diffServAlgDropHCOctets.setDescription('The number of octets that have been dropped by this drop process. This object should be used on high speed interfaces. Discontinuities in the value of this counter can occur at re- initialization of the management system and at other times as indicated by the value of ifCounterDiscontinuityTime appropriate to this interface.')
diffServAlgDropPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 12345, 2, 8, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: diffServAlgDropPkts.setStatus('current')
if mibBuilder.loadTexts: diffServAlgDropPkts.setDescription('The number of packets that have been dropped by this drop process. On high speed devices, this object implements the least significant 32 bits of diffServAlgDropHCPkts. Discontinuities in the value of this counter can occur at re- initialization of the management system and at other times as indicated by the value of ifCounterDiscontinuityTime appropriate to this interface.')
diffServAlgDropHCPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 12345, 2, 8, 1, 11), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: diffServAlgDropHCPkts.setStatus('current')
if mibBuilder.loadTexts: diffServAlgDropHCPkts.setDescription('The number of packets that have been dropped by this drop process. This object should be used on high speed interfaces. Discontinuities in the value of this counter can occur at re- initialization of the management system and at other times as indicated by the value of ifCounterDiscontinuityTime appropriate to this interface.')
diffServAlgDropStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 12345, 2, 8, 1, 12), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServAlgDropStatus.setStatus('current')
if mibBuilder.loadTexts: diffServAlgDropStatus.setDescription('The RowStatus variable controls the activation, deactivation, or deletion of this entry. Any writable variable may be modified whether the row is active or notInService.')
diffServAlgDropNextFree = MibScalar((1, 3, 6, 1, 2, 1, 12345, 1, 7), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: diffServAlgDropNextFree.setStatus('current')
if mibBuilder.loadTexts: diffServAlgDropNextFree.setDescription('This object yields a value when read that is currently-unused for a diffServAlgDropId instance. If a configuring system attempts to create a new row in the diffServAlgDropTable using this value, that operation will fail if the value has, in the meantime, been used to create another row that is currently valid.')
diffServRandomDropTable = MibTable((1, 3, 6, 1, 2, 1, 12345, 2, 9), )
if mibBuilder.loadTexts: diffServRandomDropTable.setReference('[MODEL] section 7.1.3')
if mibBuilder.loadTexts: diffServRandomDropTable.setStatus('current')
if mibBuilder.loadTexts: diffServRandomDropTable.setDescription('The random drop table augments the algorithmic drop table. It contains entries describing a process that drops packets randomly. This table is intended to be pointed to by the associated diffServAlgDropSpecific in such cases.')
diffServRandomDropEntry = MibTableRow((1, 3, 6, 1, 2, 1, 12345, 2, 9, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "DIFF-SERV-MIB", "diffServAlgDropIfDirection"), (0, "DIFF-SERV-MIB", "diffServAlgDropId"))
if mibBuilder.loadTexts: diffServRandomDropEntry.setStatus('current')
if mibBuilder.loadTexts: diffServRandomDropEntry.setDescription('An entry describes a process that drops packets according to a random algorithm. Entries in this table share indexing with a parent diffServAlgDropEntry although they must be managed (e.g. created/deleted) by explicit management action, independently of the associated value of diffServAlgDropSpecific.')
diffServRandomDropMinThreshBytes = MibTableColumn((1, 3, 6, 1, 2, 1, 12345, 2, 9, 1, 1), Unsigned32()).setUnits('bytes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServRandomDropMinThreshBytes.setStatus('current')
if mibBuilder.loadTexts: diffServRandomDropMinThreshBytes.setDescription('The average queue depth in bytes, beyond which traffic has a non-zero probability of being dropped. Changes in this variable may or may not be reflected in the reported value of diffServRandomDropMinThreshPkts.')
diffServRandomDropMinThreshPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 12345, 2, 9, 1, 2), Unsigned32()).setUnits('packets').setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServRandomDropMinThreshPkts.setStatus('current')
if mibBuilder.loadTexts: diffServRandomDropMinThreshPkts.setDescription('The average queue depth in packets, beyond which traffic has a non-zero probability of being dropped. Changes in this variable may or may not be reflected in the reported value of diffServRandomDropMinThreshBytes.')
diffServRandomDropMaxThreshBytes = MibTableColumn((1, 3, 6, 1, 2, 1, 12345, 2, 9, 1, 3), Unsigned32()).setUnits('bytes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServRandomDropMaxThreshBytes.setStatus('current')
if mibBuilder.loadTexts: diffServRandomDropMaxThreshBytes.setDescription('The average queue depth beyond which traffic has a probability indicated by diffServRandomDropInvMaxProb of being dropped or marked. Note that this differs from the physical queue limit, which is stored in diffServAlgDropQThreshold. Changes in this variable may or may not be reflected in the reported value of diffServRandomDropMaxThreshPkts.')
diffServRandomDropMaxThreshPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 12345, 2, 9, 1, 4), Unsigned32()).setUnits('packets').setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServRandomDropMaxThreshPkts.setStatus('current')
if mibBuilder.loadTexts: diffServRandomDropMaxThreshPkts.setDescription('The average queue depth beyond which traffic has a probability indicated by diffServRandomDropInvMaxProb of being dropped or marked. Note that this differs from the physical queue limit, which is stored in diffServAlgDropQThreshold. Changes in this variable may or may not be reflected in the reported value of diffServRandomDropMaxThreshBytes.')
diffServRandomDropInvWeight = MibTableColumn((1, 3, 6, 1, 2, 1, 12345, 2, 9, 1, 5), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServRandomDropInvWeight.setStatus('current')
if mibBuilder.loadTexts: diffServRandomDropInvWeight.setDescription('The weighting of past history in affecting the calculation of the current queue average. The moving average of the queue depth uses the inverse of this value as the factor for the new queue depth, and one minus that inverse as the factor for the historical average. Implementations may choose to limit the acceptable set of values to a specified set, such as powers of 2.')
diffServRandomDropProbMax = MibTableColumn((1, 3, 6, 1, 2, 1, 12345, 2, 9, 1, 6), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServRandomDropProbMax.setStatus('current')
if mibBuilder.loadTexts: diffServRandomDropProbMax.setDescription('The worst case random drop probability, expressed in drops per thousand packets. For example, if every packet may be dropped in the worst case (100%), this has the value 1000. Alternatively, if in the worst case one percent (1%) of traffic may be dropped, it has the value 10.')
diffServRandomDropStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 12345, 2, 9, 1, 7), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServRandomDropStatus.setStatus('current')
if mibBuilder.loadTexts: diffServRandomDropStatus.setDescription('The RowStatus variable controls the activation, deactivation, or deletion of this entry. Any writable variable may be modified whether the row is active or notInService.')
diffServQTable = MibTable((1, 3, 6, 1, 2, 1, 12345, 2, 10), )
if mibBuilder.loadTexts: diffServQTable.setStatus('current')
if mibBuilder.loadTexts: diffServQTable.setDescription('The Queue Table enumerates the individual queues on an interface.')
diffServQEntry = MibTableRow((1, 3, 6, 1, 2, 1, 12345, 2, 10, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "DIFF-SERV-MIB", "diffServQIfDirection"), (0, "DIFF-SERV-MIB", "diffServQId"))
if mibBuilder.loadTexts: diffServQEntry.setStatus('current')
if mibBuilder.loadTexts: diffServQEntry.setDescription('An entry in the Queue Table describes a single queue in one direction on an interface.')
diffServQIfDirection = MibTableColumn((1, 3, 6, 1, 2, 1, 12345, 2, 10, 1, 1), IfDirection())
if mibBuilder.loadTexts: diffServQIfDirection.setStatus('current')
if mibBuilder.loadTexts: diffServQIfDirection.setDescription('Specifies the direction for which this queue entry applies on this interface.')
diffServQId = MibTableColumn((1, 3, 6, 1, 2, 1, 12345, 2, 10, 1, 2), Unsigned32())
if mibBuilder.loadTexts: diffServQId.setStatus('current')
if mibBuilder.loadTexts: diffServQId.setDescription('The Queue Id enumerates the Queue entry. Managers should obtain new values for row creation in this table by reading diffServQNextFree.')
diffServQNext = MibTableColumn((1, 3, 6, 1, 2, 1, 12345, 2, 10, 1, 3), RowPointer()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServQNext.setStatus('current')
if mibBuilder.loadTexts: diffServQNext.setDescription('The Next pointer indicates the next datapath element to handle the traffic e.g. a scheduler datapath element. If the row pointed to does not exist, the queue element is considered inactive.')
diffServQPriority = MibTableColumn((1, 3, 6, 1, 2, 1, 12345, 2, 10, 1, 4), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServQPriority.setStatus('current')
if mibBuilder.loadTexts: diffServQPriority.setDescription('The priority of this queue, to be used as a parameter to the next scheduler element downstream from this one.')
diffServQMinRateAbs = MibTableColumn((1, 3, 6, 1, 2, 1, 12345, 2, 10, 1, 5), Unsigned32()).setUnits('kilobits per second').setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServQMinRateAbs.setReference('ifSpeed, ifHighSpeed from [IFMIB]')
if mibBuilder.loadTexts: diffServQMinRateAbs.setStatus('current')
if mibBuilder.loadTexts: diffServQMinRateAbs.setDescription("The minimum absolute rate, in kilobits/sec, that a downstream scheduler element should allocate to this queue. If the value is zero, then there is effectively no minimum rate guarantee. If the value is non-zero, the scheduler will assure the servicing of this queue to at least this rate. Note that this attribute's value is coupled to that of diffServQMinRateRel: changes to one will affect the value of the other. They are linked by the following equation: diffServQMinRateRel = diffServQMinRateAbs * 10,000,000/ifSpeed or, if appropriate: diffServQMinRateRel = diffServQMinRateAbs * 10 / ifHighSpeed")
diffServQMinRateRel = MibTableColumn((1, 3, 6, 1, 2, 1, 12345, 2, 10, 1, 6), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServQMinRateRel.setReference('ifSpeed, ifHighSpeed from [IFMIB]')
if mibBuilder.loadTexts: diffServQMinRateRel.setStatus('current')
if mibBuilder.loadTexts: diffServQMinRateRel.setDescription("The minimum rate that a downstream scheduler element should allocate to this queue, relative to the maximum rate of the interface as reported by ifSpeed or ifHighSpeed, in units of 1/10,000 of 1. If the value is zero, then there is effectively no minimum rate guarantee. If the value is non-zero, the scheduler will assure the servicing of this queue to at least this rate. Note that this attribute's value is coupled to that of diffServQMinRateAbs: changes to one will affect the value of the other. They are linked by the following equation: diffServQMinRateAbs = ifSpeed * diffServQMinRateRel/10,000,000 or, if appropriate: diffServQMinRateAbs = ifHighSpeed * diffServQMinRateRel / 10")
diffServQMaxRateAbs = MibTableColumn((1, 3, 6, 1, 2, 1, 12345, 2, 10, 1, 7), Unsigned32()).setUnits('kilobits per second').setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServQMaxRateAbs.setReference('ifSpeed, ifHighSpeed from [IFMIB]')
if mibBuilder.loadTexts: diffServQMaxRateAbs.setStatus('current')
if mibBuilder.loadTexts: diffServQMaxRateAbs.setDescription("The maximum rate in kilobits/sec that a downstream scheduler element should allocate to this queue. If the value is zero, then there is effectively no maximum rate limit and that the scheduler should attempt to be work-conserving for this queue. If the value is non-zero, the scheduler will limit the servicing of this queue to, at most, this rate in a non-work-conserving manner. Note that this attribute's value is coupled to that of diffServQMaxRateRel: changes to one will affect the value of the other. They are linked by the following equation: diffServQMaxRateRel = diffServQMaxRateAbs * 10,000,000/ifSpeed or, if appropriate: diffServQMaxRateRel = diffServQMaxRateAbs * 10 / ifHighSpeed")
diffServQMaxRateRel = MibTableColumn((1, 3, 6, 1, 2, 1, 12345, 2, 10, 1, 8), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServQMaxRateRel.setReference('ifSpeed, ifHighSpeed from [IFMIB]')
if mibBuilder.loadTexts: diffServQMaxRateRel.setStatus('current')
if mibBuilder.loadTexts: diffServQMaxRateRel.setDescription("The maximum rate that a downstream scheduler element should allocate to this queue, relative to the maximum rate of the interface as reported by ifSpeed or ifHighSpeed, in units of 1/10,000 of 1. If the value is zero, then there is effectively no maximum rate limit and the scheduler should attempt to be work-conserving for this queue. If the value is non-zero, the scheduler will limit the servicing of this queue to, at most, this rate in a non-work-conserving manner. Note that this attribute's value is coupled to that of diffServQMaxRateAbs: changes to one will affect the value of the other. They are linked by the following equation: diffServQMaxRateAbs = ifSpeed * diffServQMaxRateRel/10,000,000 or, if appropriate: diffServQMaxRateAbs = ifHighSpeed * diffServQMaxRateRel / 10")
diffServQStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 12345, 2, 10, 1, 9), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServQStatus.setStatus('current')
if mibBuilder.loadTexts: diffServQStatus.setDescription('The RowStatus variable controls the activation, deactivation, or deletion of a queue. Any writable variable may be modified whether the row is active or notInService.')
diffServQNextFree = MibScalar((1, 3, 6, 1, 2, 1, 12345, 1, 8), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: diffServQNextFree.setStatus('current')
if mibBuilder.loadTexts: diffServQNextFree.setDescription('This object yields a value when read that is currently-unused for a diffServQId instance. If a configuring system attempts to create a new row in the diffServQTable using this value, that operation will fail if the value has, in the meantime, been used to create another row that is currently valid.')
diffServSchedulerTable = MibTable((1, 3, 6, 1, 2, 1, 12345, 2, 11), )
if mibBuilder.loadTexts: diffServSchedulerTable.setReference('[MODEL] section 7.1.2')
if mibBuilder.loadTexts: diffServSchedulerTable.setStatus('current')
if mibBuilder.loadTexts: diffServSchedulerTable.setDescription('The Scheduler Table enumerates packet schedulers. Multiple scheduling algorithms can be used on a given interface, with each algorithm described by one diffServSchedulerEntry.')
diffServSchedulerEntry = MibTableRow((1, 3, 6, 1, 2, 1, 12345, 2, 11, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "DIFF-SERV-MIB", "diffServSchedulerIfDirection"), (0, "DIFF-SERV-MIB", "diffServSchedulerId"))
if mibBuilder.loadTexts: diffServSchedulerEntry.setStatus('current')
if mibBuilder.loadTexts: diffServSchedulerEntry.setDescription('An entry in the Scheduler Table describing a single instance of a scheduling algorithm.')
diffServSchedulerIfDirection = MibTableColumn((1, 3, 6, 1, 2, 1, 12345, 2, 11, 1, 1), IfDirection())
if mibBuilder.loadTexts: diffServSchedulerIfDirection.setStatus('current')
if mibBuilder.loadTexts: diffServSchedulerIfDirection.setDescription('Specifies the direction for which this scheduler entry applies on this interface.')
diffServSchedulerId = MibTableColumn((1, 3, 6, 1, 2, 1, 12345, 2, 11, 1, 2), Unsigned32())
if mibBuilder.loadTexts: diffServSchedulerId.setStatus('current')
if mibBuilder.loadTexts: diffServSchedulerId.setDescription('This identifies the scheduler entry. Managers should obtain new values for row creation in this table by reading diffServSchedulerNextFree.')
diffServSchedulerMethod = MibTableColumn((1, 3, 6, 1, 2, 1, 12345, 2, 11, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("priorityq", 2), ("wrr", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServSchedulerMethod.setReference('[MODEL] section 7.1.2')
if mibBuilder.loadTexts: diffServSchedulerMethod.setStatus('current')
if mibBuilder.loadTexts: diffServSchedulerMethod.setDescription('The scheduling algorithm used by this Scheduler. A value of priorityq(2) is used to indicate strict priority queueing: only the diffServQPriority attributes of the queues feeding this scheduler are used when determining the next packet to schedule. A value of wrr(3) indicates weighted round-robin scheduling. Packets are scheduled from each of the queues feeding this scheduler according to all of the parameters of the diffServQueue entry.')
diffServSchedulerNext = MibTableColumn((1, 3, 6, 1, 2, 1, 12345, 2, 11, 1, 4), RowPointer().clone((0, 0))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServSchedulerNext.setStatus('current')
if mibBuilder.loadTexts: diffServSchedulerNext.setDescription('Selects the next data path component, which can be another scheduler or other TC elements. One usage of multiple scheduler elements in series is for Class Base Queueing (CBQ). The value zeroDotZero in this variable indicates no further DiffServ treatment is performed on this flow by the current interface for this interface direction. For example, for an inbound interface the value zeroDotZero indicates that the packet flow has now completed inbound DiffServ treatment and should be forwarded on to the appropriate outbound interface. If the row pointed to does not exist, the scheduler element is considered inactive.')
diffServSchedulerStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 12345, 2, 11, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: diffServSchedulerStatus.setStatus('current')
if mibBuilder.loadTexts: diffServSchedulerStatus.setDescription('The RowStatus variable controls the activation, deactivation, or deletion of a queue. Any writable variable may be modified whether the row is active or notInService.')
diffServSchedulerNextFree = MibScalar((1, 3, 6, 1, 2, 1, 12345, 1, 9), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: diffServSchedulerNextFree.setStatus('current')
if mibBuilder.loadTexts: diffServSchedulerNextFree.setDescription('This object yields a value when read that is currently-unused for a diffServSchedulerId instance. If a configuring system attempts to create a new row in the diffServSchedulerTable using this value, that operation will fail if the value has, in the meantime, been used to create another row that is currently valid.')
diffServMIBCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 12345, 3, 1))
diffServMIBGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 12345, 3, 2))
diffServMIBCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 12345, 3, 1, 1)).setObjects(("DIFF-SERV-MIB", "diffServMIBClassifierGroup"), ("DIFF-SERV-MIB", "diffServMIBSixTupleClfrGroup"), ("DIFF-SERV-MIB", "diffServMIBActionGroup"), ("DIFF-SERV-MIB", "diffServMIBAlgDropGroup"), ("DIFF-SERV-MIB", "diffServMIBQueueGroup"), ("DIFF-SERV-MIB", "diffServMIBSchedulerGroup"), ("DIFF-SERV-MIB", "diffServMIBCounterGroup"), ("DIFF-SERV-MIB", "diffServMIBHCCounterGroup"), ("DIFF-SERV-MIB", "diffServMIBVHCCounterGroup"), ("DIFF-SERV-MIB", "diffServMIBMeterGroup"), ("DIFF-SERV-MIB", "diffServMIBTokenBucketMeterGroup"), ("DIFF-SERV-MIB", "diffServMIBDscpMarkActionGroup"), ("DIFF-SERV-MIB", "diffServMIBRandomDropGroup"), ("DIFF-SERV-MIB", "diffServMIBStaticGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    diffServMIBCompliance = diffServMIBCompliance.setStatus('current')
if mibBuilder.loadTexts: diffServMIBCompliance.setDescription('This MIB may be implemented as a read-only or as a read-create MIB. As a result, it may be used for monitoring or for configuration.')
diffServMIBClassifierGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 12345, 3, 2, 1)).setObjects(("DIFF-SERV-MIB", "diffServClassifierFilter"), ("DIFF-SERV-MIB", "diffServClassifierNext"), ("DIFF-SERV-MIB", "diffServClassifierPrecedence"), ("DIFF-SERV-MIB", "diffServClassifierStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    diffServMIBClassifierGroup = diffServMIBClassifierGroup.setStatus('current')
if mibBuilder.loadTexts: diffServMIBClassifierGroup.setDescription('The Classifier Group defines the MIB Objects that describe a generic classifier element.')
diffServMIBSixTupleClfrGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 12345, 3, 2, 2)).setObjects(("DIFF-SERV-MIB", "diffServSixTupleClfrDstAddrType"), ("DIFF-SERV-MIB", "diffServSixTupleClfrDstAddr"), ("DIFF-SERV-MIB", "diffServSixTupleClfrDstAddrMask"), ("DIFF-SERV-MIB", "diffServSixTupleClfrDstAddrType"), ("DIFF-SERV-MIB", "diffServSixTupleClfrSrcAddrType"), ("DIFF-SERV-MIB", "diffServSixTupleClfrSrcAddrMask"), ("DIFF-SERV-MIB", "diffServSixTupleClfrDscp"), ("DIFF-SERV-MIB", "diffServSixTupleClfrProtocol"), ("DIFF-SERV-MIB", "diffServSixTupleClfrDstL4PortMin"), ("DIFF-SERV-MIB", "diffServSixTupleClfrDstL4PortMax"), ("DIFF-SERV-MIB", "diffServSixTupleClfrSrcL4PortMin"), ("DIFF-SERV-MIB", "diffServSixTupleClfrSrcL4PortMax"), ("DIFF-SERV-MIB", "diffServSixTupleClfrStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    diffServMIBSixTupleClfrGroup = diffServMIBSixTupleClfrGroup.setStatus('current')
if mibBuilder.loadTexts: diffServMIBSixTupleClfrGroup.setDescription('The Six-tuple Classifier Group defines the MIB Objects that describe a classifier element for matching on 6 fields of an IP and upper-layer protocol header.')
diffServMIBMeterGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 12345, 3, 2, 3)).setObjects(("DIFF-SERV-MIB", "diffServMeterSucceedNext"), ("DIFF-SERV-MIB", "diffServMeterFailNext"), ("DIFF-SERV-MIB", "diffServMeterSpecific"), ("DIFF-SERV-MIB", "diffServMeterStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    diffServMIBMeterGroup = diffServMIBMeterGroup.setStatus('current')
if mibBuilder.loadTexts: diffServMIBMeterGroup.setDescription('The Meter Group defines the objects used in describing a generic meter element.')
diffServMIBTokenBucketMeterGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 12345, 3, 2, 4)).setObjects(("DIFF-SERV-MIB", "diffServTBMeterRate"), ("DIFF-SERV-MIB", "diffServTBMeterBurstSize"), ("DIFF-SERV-MIB", "diffServTBMeterStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    diffServMIBTokenBucketMeterGroup = diffServMIBTokenBucketMeterGroup.setStatus('current')
if mibBuilder.loadTexts: diffServMIBTokenBucketMeterGroup.setDescription('The Token-Bucket Meter Group defines the objects used in describing a single-rate token bucket meter element.')
diffServMIBActionGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 12345, 3, 2, 5)).setObjects(("DIFF-SERV-MIB", "diffServActionNext"), ("DIFF-SERV-MIB", "diffServActionSpecific"), ("DIFF-SERV-MIB", "diffServActionStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    diffServMIBActionGroup = diffServMIBActionGroup.setStatus('current')
if mibBuilder.loadTexts: diffServMIBActionGroup.setDescription('The Action Group defines the objects used in describing a generic action element.')
diffServMIBDscpMarkActionGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 12345, 3, 2, 6)).setObjects(("DIFF-SERV-MIB", "diffServDscpMarkActDscp"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    diffServMIBDscpMarkActionGroup = diffServMIBDscpMarkActionGroup.setStatus('current')
if mibBuilder.loadTexts: diffServMIBDscpMarkActionGroup.setDescription('The DSCP Mark Action Group defines the objects used in describing a DSCP Marking Action element.')
diffServMIBCounterGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 12345, 3, 2, 7)).setObjects(("DIFF-SERV-MIB", "diffServCountActOctets"), ("DIFF-SERV-MIB", "diffServCountActPkts"), ("DIFF-SERV-MIB", "diffServCountActStatus"), ("DIFF-SERV-MIB", "diffServAlgDropOctets"), ("DIFF-SERV-MIB", "diffServAlgDropPkts"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    diffServMIBCounterGroup = diffServMIBCounterGroup.setStatus('current')
if mibBuilder.loadTexts: diffServMIBCounterGroup.setDescription('A collection of objects providing information specific to non- high speed (non-high speed interfaces transmit and receive at speeds less than or equal to 20,000,000 bits/second) packet- oriented network interfaces.')
diffServMIBHCCounterGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 12345, 3, 2, 8)).setObjects(("DIFF-SERV-MIB", "diffServCountActOctets"), ("DIFF-SERV-MIB", "diffServCountActHCOctets"), ("DIFF-SERV-MIB", "diffServCountActPkts"), ("DIFF-SERV-MIB", "diffServCountActStatus"), ("DIFF-SERV-MIB", "diffServAlgDropOctets"), ("DIFF-SERV-MIB", "diffServAlgDropHCOctets"), ("DIFF-SERV-MIB", "diffServAlgDropPkts"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    diffServMIBHCCounterGroup = diffServMIBHCCounterGroup.setStatus('current')
if mibBuilder.loadTexts: diffServMIBHCCounterGroup.setDescription('A collection of objects providing information specific to non- high speed (non-high speed interfaces transmit and receive at speeds less than or equal to 20,000,000 bits/second) packet- oriented network interfaces.')
diffServMIBVHCCounterGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 12345, 3, 2, 9)).setObjects(("DIFF-SERV-MIB", "diffServCountActOctets"), ("DIFF-SERV-MIB", "diffServCountActHCOctets"), ("DIFF-SERV-MIB", "diffServCountActPkts"), ("DIFF-SERV-MIB", "diffServCountActHCPkts"), ("DIFF-SERV-MIB", "diffServCountActStatus"), ("DIFF-SERV-MIB", "diffServAlgDropOctets"), ("DIFF-SERV-MIB", "diffServAlgDropHCOctets"), ("DIFF-SERV-MIB", "diffServAlgDropPkts"), ("DIFF-SERV-MIB", "diffServAlgDropHCPkts"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    diffServMIBVHCCounterGroup = diffServMIBVHCCounterGroup.setStatus('current')
if mibBuilder.loadTexts: diffServMIBVHCCounterGroup.setDescription('A collection of objects providing information specific to non- high speed (non-high speed interfaces transmit and receive at speeds less than or equal to 20,000,000 bits/second) packet- oriented network interfaces.')
diffServMIBAlgDropGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 12345, 3, 2, 10)).setObjects(("DIFF-SERV-MIB", "diffServAlgDropType"), ("DIFF-SERV-MIB", "diffServAlgDropNext"), ("DIFF-SERV-MIB", "diffServAlgDropQMeasure"), ("DIFF-SERV-MIB", "diffServAlgDropQThreshold"), ("DIFF-SERV-MIB", "diffServAlgDropSpecific"), ("DIFF-SERV-MIB", "diffServAlgDropStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    diffServMIBAlgDropGroup = diffServMIBAlgDropGroup.setStatus('current')
if mibBuilder.loadTexts: diffServMIBAlgDropGroup.setDescription('The Algorithmic Drop Group contains the objects that describe algorithmic dropper operation and configuration.')
diffServMIBRandomDropGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 12345, 3, 2, 11)).setObjects(("DIFF-SERV-MIB", "diffServRandomDropMinThreshBytes"), ("DIFF-SERV-MIB", "diffServRandomDropMinThreshPkts"), ("DIFF-SERV-MIB", "diffServRandomDropMaxThreshBytes"), ("DIFF-SERV-MIB", "diffServRandomDropMaxThreshPkts"), ("DIFF-SERV-MIB", "diffServRandomDropInvWeight"), ("DIFF-SERV-MIB", "diffServRandomDropProbMax"), ("DIFF-SERV-MIB", "diffServRandomDropStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    diffServMIBRandomDropGroup = diffServMIBRandomDropGroup.setStatus('current')
if mibBuilder.loadTexts: diffServMIBRandomDropGroup.setDescription('The Random Drop Group augments the Algorithmic Drop Group for random dropper operation and configuration.')
diffServMIBQueueGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 12345, 3, 2, 12)).setObjects(("DIFF-SERV-MIB", "diffServQPriority"), ("DIFF-SERV-MIB", "diffServQNext"), ("DIFF-SERV-MIB", "diffServQMinRateAbs"), ("DIFF-SERV-MIB", "diffServQMinRateRel"), ("DIFF-SERV-MIB", "diffServQMaxRateAbs"), ("DIFF-SERV-MIB", "diffServQMaxRateRel"), ("DIFF-SERV-MIB", "diffServQStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    diffServMIBQueueGroup = diffServMIBQueueGroup.setStatus('current')
if mibBuilder.loadTexts: diffServMIBQueueGroup.setDescription("The Queue Group contains the objects that describe an interface's queues.")
diffServMIBSchedulerGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 12345, 3, 2, 13)).setObjects(("DIFF-SERV-MIB", "diffServSchedulerMethod"), ("DIFF-SERV-MIB", "diffServSchedulerNext"), ("DIFF-SERV-MIB", "diffServSchedulerStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    diffServMIBSchedulerGroup = diffServMIBSchedulerGroup.setStatus('current')
if mibBuilder.loadTexts: diffServMIBSchedulerGroup.setDescription('The Scheduler Group contains the objects that describe packet schedulers on interfaces.')
diffServMIBStaticGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 12345, 3, 2, 14)).setObjects(("DIFF-SERV-MIB", "diffServClassifierNextFree"), ("DIFF-SERV-MIB", "diffServSixTupleClfrNextFree"), ("DIFF-SERV-MIB", "diffServMeterNextFree"), ("DIFF-SERV-MIB", "diffServActionNextFree"), ("DIFF-SERV-MIB", "diffServAlgDropNextFree"), ("DIFF-SERV-MIB", "diffServQNextFree"), ("DIFF-SERV-MIB", "diffServSchedulerNextFree"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    diffServMIBStaticGroup = diffServMIBStaticGroup.setStatus('current')
if mibBuilder.loadTexts: diffServMIBStaticGroup.setDescription('The Static Group contains readable scalar objects used in creating unique identifiers for classifiers, meters, actions and queues. These are required whenever row creation operations on such tables are supported.')
mibBuilder.exportSymbols("DIFF-SERV-MIB", diffServMeterId=diffServMeterId, diffServClassifierStatus=diffServClassifierStatus, diffServClassifierId=diffServClassifierId, diffServCountActHCPkts=diffServCountActHCPkts, diffServMeterSucceedNext=diffServMeterSucceedNext, diffServTBMeterStatus=diffServTBMeterStatus, diffServAlgDropQMeasure=diffServAlgDropQMeasure, diffServQMaxRateRel=diffServQMaxRateRel, diffServSixTupleClfrNextFree=diffServSixTupleClfrNextFree, diffServCountActPkts=diffServCountActPkts, diffServSixTupleClfrDstL4PortMin=diffServSixTupleClfrDstL4PortMin, diffServSixTupleClfrSrcAddrMask=diffServSixTupleClfrSrcAddrMask, diffServRandomDropMaxThreshPkts=diffServRandomDropMaxThreshPkts, diffServMIBHCCounterGroup=diffServMIBHCCounterGroup, diffServRandomDropMinThreshBytes=diffServRandomDropMinThreshBytes, diffServMIBSixTupleClfrGroup=diffServMIBSixTupleClfrGroup, diffServActionId=diffServActionId, diffServQNextFree=diffServQNextFree, diffServCountActHCOctets=diffServCountActHCOctets, diffServCountActOctets=diffServCountActOctets, diffServClassifierNextFree=diffServClassifierNextFree, diffServAlgDropId=diffServAlgDropId, diffServQPriority=diffServQPriority, diffServTBMeterRate=diffServTBMeterRate, diffServSixTupleClfrTable=diffServSixTupleClfrTable, PYSNMP_MODULE_ID=diffServMib, diffServCountActDiscontTime=diffServCountActDiscontTime, diffServQMaxRateAbs=diffServQMaxRateAbs, diffServSixTupleClfrDstAddr=diffServSixTupleClfrDstAddr, diffServSchedulerEntry=diffServSchedulerEntry, diffServDscpMarkActEntry=diffServDscpMarkActEntry, diffServRandomDropMaxThreshBytes=diffServRandomDropMaxThreshBytes, diffServSixTupleClfrDstAddrType=diffServSixTupleClfrDstAddrType, diffServSixTupleClfrEntry=diffServSixTupleClfrEntry, diffServSchedulerNextFree=diffServSchedulerNextFree, diffServMIBCounterGroup=diffServMIBCounterGroup, diffServSixTupleClfrDstL4PortMax=diffServSixTupleClfrDstL4PortMax, diffServAlgDropPkts=diffServAlgDropPkts, diffServMIBVHCCounterGroup=diffServMIBVHCCounterGroup, diffServSixTupleClfrSrcAddr=diffServSixTupleClfrSrcAddr, diffServMIBActionGroup=diffServMIBActionGroup, diffServAlgDropSpecific=diffServAlgDropSpecific, diffServQMinRateRel=diffServQMinRateRel, diffServMIBGroups=diffServMIBGroups, diffServSchedulerTable=diffServSchedulerTable, diffServObjects=diffServObjects, diffServSixTupleClfrSrcL4PortMax=diffServSixTupleClfrSrcL4PortMax, diffServAlgDropTable=diffServAlgDropTable, diffServClassifierEntry=diffServClassifierEntry, diffServClassifierFilter=diffServClassifierFilter, diffServRandomDropStatus=diffServRandomDropStatus, IfDirection=IfDirection, diffServAlgDropOctets=diffServAlgDropOctets, diffServActionTable=diffServActionTable, diffServAlgDropHCOctets=diffServAlgDropHCOctets, diffServSchedulerIfDirection=diffServSchedulerIfDirection, diffServRandomDropProbMax=diffServRandomDropProbMax, diffServMIBConformance=diffServMIBConformance, diffServMeterIfDirection=diffServMeterIfDirection, diffServRandomDropMinThreshPkts=diffServRandomDropMinThreshPkts, diffServActionIfDirection=diffServActionIfDirection, diffServQNext=diffServQNext, diffServCountActTable=diffServCountActTable, diffServRandomDropEntry=diffServRandomDropEntry, diffServMIBTokenBucketMeterGroup=diffServMIBTokenBucketMeterGroup, diffServTBMeterTable=diffServTBMeterTable, diffServMIBStaticGroup=diffServMIBStaticGroup, diffServAlgDropNext=diffServAlgDropNext, diffServSchedulerNext=diffServSchedulerNext, diffServMeterStatus=diffServMeterStatus, diffServQMinRateAbs=diffServQMinRateAbs, diffServSixTupleClfrSrcAddrType=diffServSixTupleClfrSrcAddrType, diffServMeterSpecific=diffServMeterSpecific, diffServMIBRandomDropGroup=diffServMIBRandomDropGroup, diffServAlgDropEntry=diffServAlgDropEntry, diffServSchedulerId=diffServSchedulerId, diffServTBMeterEntry=diffServTBMeterEntry, SixTupleClfrL4Port=SixTupleClfrL4Port, diffServClassifierNext=diffServClassifierNext, diffServSchedulerMethod=diffServSchedulerMethod, diffServDscpMarkActTable=diffServDscpMarkActTable, diffServMIBCompliance=diffServMIBCompliance, diffServAlgDropType=diffServAlgDropType, diffServAlgDropQThreshold=diffServAlgDropQThreshold, diffServCountActStatus=diffServCountActStatus, diffServQStatus=diffServQStatus, diffServClassifierIfDirection=diffServClassifierIfDirection, diffServSixTupleClfrDscp=diffServSixTupleClfrDscp, diffServClassifierTable=diffServClassifierTable, diffServSixTupleClfrDstAddrMask=diffServSixTupleClfrDstAddrMask, diffServAlgDropHCPkts=diffServAlgDropHCPkts, diffServMIBDscpMarkActionGroup=diffServMIBDscpMarkActionGroup, diffServSixTupleClfrStatus=diffServSixTupleClfrStatus, diffServMeterTable=diffServMeterTable, diffServActionNext=diffServActionNext, diffServMeterFailNext=diffServMeterFailNext, diffServActionNextFree=diffServActionNextFree, diffServActionStatus=diffServActionStatus, diffServCountActEntry=diffServCountActEntry, diffServRandomDropTable=diffServRandomDropTable, diffServSixTupleClfrSrcL4PortMin=diffServSixTupleClfrSrcL4PortMin, diffServMIBClassifierGroup=diffServMIBClassifierGroup, diffServMIBSchedulerGroup=diffServMIBSchedulerGroup, diffServClassifierPrecedence=diffServClassifierPrecedence, diffServRandomDropInvWeight=diffServRandomDropInvWeight, diffServMIBAlgDropGroup=diffServMIBAlgDropGroup, diffServSchedulerStatus=diffServSchedulerStatus, diffServQIfDirection=diffServQIfDirection, diffServMeterNextFree=diffServMeterNextFree, diffServAlgDropNextFree=diffServAlgDropNextFree, diffServDscpMarkActDscp=diffServDscpMarkActDscp, diffServTBMeterBurstSize=diffServTBMeterBurstSize, diffServQTable=diffServQTable, diffServClassifierTcb=diffServClassifierTcb, diffServTables=diffServTables, diffServMIBMeterGroup=diffServMIBMeterGroup, diffServAlgDropIfDirection=diffServAlgDropIfDirection, diffServQId=diffServQId, diffServMIBQueueGroup=diffServMIBQueueGroup, diffServMIBCompliances=diffServMIBCompliances, diffServAbsoluteDropAction=diffServAbsoluteDropAction, diffServMeterEntry=diffServMeterEntry, diffServActionSpecific=diffServActionSpecific, diffServAlgDropStatus=diffServAlgDropStatus, diffServQEntry=diffServQEntry, diffServSixTupleClfrProtocol=diffServSixTupleClfrProtocol, diffServMib=diffServMib, diffServActionEntry=diffServActionEntry, diffServSixTupleClfrId=diffServSixTupleClfrId, Dscp=Dscp)

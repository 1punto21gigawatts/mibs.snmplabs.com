#
# PySNMP MIB module MPLS-LDP-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/MPLS-LDP-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:19:44 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsUnion, ConstraintsIntersection, ValueRangeConstraint, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsUnion", "ConstraintsIntersection", "ValueRangeConstraint", "ValueSizeConstraint")
AtmVpIdentifier, = mibBuilder.importSymbols("ATM-TC-MIB", "AtmVpIdentifier")
AddressFamilyNumbers, = mibBuilder.importSymbols("IANA-ADDRESS-FAMILY-NUMBERS-MIB", "AddressFamilyNumbers")
InterfaceIndex, InterfaceIndexOrZero = mibBuilder.importSymbols("IF-MIB", "InterfaceIndex", "InterfaceIndexOrZero")
NotificationGroup, ModuleCompliance, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance", "ObjectGroup")
ModuleIdentity, iso, Counter64, MibScalar, MibTable, MibTableRow, MibTableColumn, ObjectIdentity, TimeTicks, Counter32, Bits, IpAddress, MibIdentifier, NotificationType, experimental, Integer32, Gauge32, Unsigned32 = mibBuilder.importSymbols("SNMPv2-SMI", "ModuleIdentity", "iso", "Counter64", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ObjectIdentity", "TimeTicks", "Counter32", "Bits", "IpAddress", "MibIdentifier", "NotificationType", "experimental", "Integer32", "Gauge32", "Unsigned32")
DisplayString, TruthValue, TextualConvention, RowStatus, TimeStamp, StorageType, TimeInterval = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TruthValue", "TextualConvention", "RowStatus", "TimeStamp", "StorageType", "TimeInterval")
mplsLdpMIB = ModuleIdentity((1, 3, 6, 1, 3, 97))
if mibBuilder.loadTexts: mplsLdpMIB.setLastUpdated('200008291200Z')
if mibBuilder.loadTexts: mplsLdpMIB.setOrganization('Multiprotocol Label Switching (mpls) Working Group')
if mibBuilder.loadTexts: mplsLdpMIB.setContactInfo('Joan Cucchiara (jcucchiara@brixnet.com) Brix Networks Hans Sjostrand (hans.sjostrand@ericsson.com) Ericsson James V. Luciani (jluciani@tollbridgetech.com) TollBridge Technologies')
if mibBuilder.loadTexts: mplsLdpMIB.setDescription("This MIB contains managed object definitions for the 'Multiprotocol Label Switching, Label Distribution Protocol, LDP' document.")
class MplsLsrIdentifier(TextualConvention, OctetString):
    description = 'The Label Switch Router (LSR) identifier is the first 4 bytes or the Router Id component of the Label Distribution Protocol (LDP) identifier.'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(4, 4)
    fixedLength = 4

class MplsLdpGenAddr(TextualConvention, OctetString):
    description = 'The value of an network layer or data link layer address.'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 64)

class MplsLabel(TextualConvention, Integer32):
    description = 'This value represents an MPLS label. The label contents are specific to the label being represented. The label carried in an MPLS shim header (for LDP, the Generic Label) is a 20-bit number represented by 4 octets. Bits 0-19 contain a label or a reserved label value. Bits 20-31 MUST be zero. The frame relay label can be either 10-bits or 23-bits depending on the DLCI field size and the upper 22-bits or upper 9-bits must be zero, respectively. For an ATM label the lower 16-bits represents the VCI, the next 12-bits represents the VPI and the remaining bits MUST be zero.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 2147483647)

class MplsLdpIdentifier(TextualConvention, OctetString):
    description = 'The LDP identifier is a six octet quantity which is used to identify an Label Switch Router (LSR) label space. The first four octets encode an IP address assigned to the LSR, and the last two octets identify a specific label space within the LSR.'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(6, 6)
    fixedLength = 6

class MplsLdpLabelTypes(TextualConvention, Integer32):
    description = 'The Layer 2 label types which are defined for MPLS LDP are generic(1), atm(2), or frameRelay(3).'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("generic", 1), ("atm", 2), ("frameRelay", 3))

class MplsAtmVcIdentifier(TextualConvention, Integer32):
    description = 'The VCI value for a VCL. The maximum VCI value cannot exceed the value allowable by atmInterfaceMaxVciBits defined in ATM-MIB. The minimum value is 32, values 0 to 31 are reserved for other uses by the ITU and ATM Forum. 32 is typically the default value for the Control VC.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(32, 65535)

mplsLdpObjects = MibIdentifier((1, 3, 6, 1, 3, 97, 1))
mplsLdpNotifications = MibIdentifier((1, 3, 6, 1, 3, 97, 2))
mplsLdpConformance = MibIdentifier((1, 3, 6, 1, 3, 97, 3))
mplsLdpLsrObjects = MibIdentifier((1, 3, 6, 1, 3, 97, 1, 1))
mplsLdpEntityObjects = MibIdentifier((1, 3, 6, 1, 3, 97, 1, 2))
mplsLdpLsrId = MibScalar((1, 3, 6, 1, 3, 97, 1, 1, 1), MplsLsrIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpLsrId.setStatus('current')
if mibBuilder.loadTexts: mplsLdpLsrId.setDescription("The LSR's Identifier.")
mplsLdpLsrLoopDetectionCapable = MibScalar((1, 3, 6, 1, 3, 97, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("none", 1), ("other", 2), ("hopCount", 3), ("pathVector", 4), ("hopCountAndPathVector", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpLsrLoopDetectionCapable.setStatus('current')
if mibBuilder.loadTexts: mplsLdpLsrLoopDetectionCapable.setDescription('A indication of whether this LSR supports loop detection. none(1) -- Loop Detection is not supported on this LSR. other(2) -- Loop Detection is supported but by a method other than those listed below. hopCount(3) -- Loop Detection is supported by Hop Count only. pathVector(4) -- Loop Detection is supported by Path Vector only. hopCountAndPathVector(5) -- Loop Detection is supported by both Hop Count And Path Vector. Since Loop Detection is determined during Session Initialization, an individual session may not be running with loop detection. This object simply gives an indication of whether or not the LSR has the ability to support Loop Detection and which types.')
mplsLdpEntityIndexNext = MibScalar((1, 3, 6, 1, 3, 97, 1, 2, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpEntityIndexNext.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityIndexNext.setDescription('This object contains an appropriate value to be used for mplsLdpEntityIndex when creating entries in the mplsLdpEntityTable. The value 0 indicates that no unassigned entries are available. To obtain the mplsLdpEntityIndex value for a new entry, the manager issues a management protocol retrieval operation to obtain the current value of this object. After each retrieval, the agent should modify the value to the next unassigned index.')
mplsLdpEntityTable = MibTable((1, 3, 6, 1, 3, 97, 1, 2, 2), )
if mibBuilder.loadTexts: mplsLdpEntityTable.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityTable.setDescription('This table contains information about the MPLS Label Distribution Protocol Entities which exist on this Label Switch Router (LSR).')
mplsLdpEntityEntry = MibTableRow((1, 3, 6, 1, 3, 97, 1, 2, 2, 1), ).setIndexNames((0, "MPLS-LDP-MIB", "mplsLdpEntityLdpId"), (0, "MPLS-LDP-MIB", "mplsLdpEntityIndex"))
if mibBuilder.loadTexts: mplsLdpEntityEntry.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityEntry.setDescription('An entry in this table represents an LDP entity. An entry can be created by a network administrator or by an SNMP agent as instructed by LDP.')
mplsLdpEntityLdpId = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 2, 1, 1), MplsLdpIdentifier())
if mibBuilder.loadTexts: mplsLdpEntityLdpId.setReference('LDP Specification, Section on LDP Identifiers.')
if mibBuilder.loadTexts: mplsLdpEntityLdpId.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityLdpId.setDescription('The LDP identifier. The first four octets encode an IP address assigned to the LSR, and the last two octets identify a specific label space within the LSR.')
mplsLdpEntityIndex = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 2, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: mplsLdpEntityIndex.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityIndex.setDescription("This index is used as a secondary index to uniquely identify this row. Before creating a row in this table, the 'mplsLdpEntityIndexNext' object should be retrieved. That value should be used for the value of this index when creating a row in this table. (NOTE: if a value of zero (0) is retrieved, that indicates that no rows can be created in this table at this time. A secondary index (this object) is needed by some but not all, LDP implementations. For example in an LDP implementation which uses PPP, this index may be needed.")
mplsLdpEntityProtocolVersion = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 2, 1, 3), Integer32().clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityProtocolVersion.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityProtocolVersion.setDescription('The version number of the protocol. The value of 0 on a read indicates that the version of the protocol is unknown. Otherwise, the value of this object represents the version of the LDP protocol.')
mplsLdpEntityAdminStatus = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityAdminStatus.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityAdminStatus.setDescription("The administrative status of this LDP Entity. If this object is changed from 'enable' to 'disable' and this entity has already attempted to establish contact with a Peer (which implies that the 'mplsLdpEntityRowStatus' object has been set to 'active'), then all contact with that Peer is lost and all information from that Peer needs to be removed from the MIB. At this point the user is able to change values which are related to this entity. When the admin status is set back to 'up', then this Entity will attempt to establish new sessions with the Peer.")
mplsLdpEntityOperStatus = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("unknown", 0), ("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpEntityOperStatus.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityOperStatus.setDescription('The operational status of this LDP Entity.')
mplsLdpEntityWellKnownTcpDiscoveryPort = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 2, 1, 6), Unsigned32().clone(646)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityWellKnownTcpDiscoveryPort.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityWellKnownTcpDiscoveryPort.setDescription('The well known TCP Discovery Port for LDP.')
mplsLdpEntityWellKnownUdpDiscoveryPort = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 2, 1, 7), Unsigned32().clone(646)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityWellKnownUdpDiscoveryPort.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityWellKnownUdpDiscoveryPort.setDescription('The well known UDP Discovery Port for LDP.')
mplsLdpEntityMaxPduLength = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 2, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(4096)).setUnits('octets').setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityMaxPduLength.setReference("See Section on the 'Initialization Message' in the LDP Specification.")
if mibBuilder.loadTexts: mplsLdpEntityMaxPduLength.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityMaxPduLength.setDescription('The maximum PDU Length that is sent in the Common Session Parameters of an Initialization Message. A value of 255 or less specifies the default maximum length of 4096 octets.')
mplsLdpEntityKeepAliveHoldTimer = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(40)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityKeepAliveHoldTimer.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityKeepAliveHoldTimer.setDescription('The two octet value which is the proposed keep alive hold timer for this LDP Entity.')
mplsLdpEntityHelloHoldTimer = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 2, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityHelloHoldTimer.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityHelloHoldTimer.setDescription('The two octet value which is the proposed Hello hold timer for this LDP Entity. A value of 0 means use the default, which is 15 seconds for Link Hellos and 45 seconds for Targeted Hellos. A value of 65535 means infinite.')
mplsLdpEntityFailedInitSessionTrapEnable = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityFailedInitSessionTrapEnable.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityFailedInitSessionTrapEnable.setDescription("Indicates whether the 'mplsLdpFailedInitSessionThresholdExceeded' trap should be generated. If the value of this object is 'enabled(1)' then the trap will generated. If the value of this object is 'disabled(2)' then the trap will not be generated. The DEFVAL is set to 'enabled(1)'.")
mplsLdpEntityFailedInitSessionThreshold = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 2, 1, 12), Integer32().clone(8)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityFailedInitSessionThreshold.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityFailedInitSessionThreshold.setDescription("When attempting to establish a session with a given Peer, the given LDP Entity should send out the SNMP notification, 'mplsLdpFailedInitSessionThresholdExceeded', when the number of Session Initialization messages sent exceeds this threshold. A value of 0 (zero) for this object indicates that the threshold is infinity, and the SNMP notification will never be sent when the value of this object is 0 (zero).")
mplsLdpEntityLabelDistributionMethod = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("downstreamOnDemand", 1), ("downstreamUnsolicited", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityLabelDistributionMethod.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityLabelDistributionMethod.setDescription('For any given LDP session, the method of label distribution must be specified.')
mplsLdpEntityLabelRetentionMode = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("conservative", 1), ("liberal", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityLabelRetentionMode.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityLabelRetentionMode.setDescription('The LDP Entity can be configured to use either conservative or liberal label retention mode. If the value of this object is conservative(1) then advertized label mappings are retained only if they will be used to forward packets, i.e. if label came from a valid next hop. If the value of this object is liberal(2) then all advertized label mappings are retained whether they are from a valid next hop or not.')
mplsLdpEntityPVLimitMismatchTrapEnable = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 2, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityPVLimitMismatchTrapEnable.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityPVLimitMismatchTrapEnable.setDescription("Indicates whether the 'mplsLdpPathVectorLimitMismatch' trap should be generated. If the value of this object is 'enabled(1)' then the trap will generated. If the value of this object is 'disabled(2)' then the trap will not be generated. The DEFVAL is set to 'enabled(1)'.")
mplsLdpEntityPathVectorLimit = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 2, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityPathVectorLimit.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityPathVectorLimit.setDescription("If the value of this object is 0 (zero) then Loop Dection for Path Vectors is disabled. Otherwise, if this object has a value greater than zero, then Loop Dection for Path Vectors is enabled, and the Path Vector Limit is this value. Also, the value of the object, 'mplsLdpLsrLoopDetectionCapable', must be set to either 'pathVector(4)' or 'hopCountAndPathVector(5)', if this object has a value greater than 0 (zero).")
mplsLdpEntityHopCountLimit = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 2, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityHopCountLimit.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityHopCountLimit.setDescription("If the value of this object is 0 (zero), then Loop Detection using Hop Counters is disabled. If the value of this object is greater than 0 (zero) then Loop Detection using Hop Counters is enabled, and this object specifies this Entity's maximum allowable value for the Hop Count. Also, the value of the object mplsLdpLsrLoopDetectionCapable must be set to either 'hopCount(3)' or 'hopCountAndPathVector(5)' if this object has a value greater than 0 (zero).")
mplsLdpEntityTargetedPeer = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 2, 1, 18), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityTargetedPeer.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityTargetedPeer.setDescription('If this LDP entity uses targeted peer then set this to true.')
mplsLdpEntityTargetedPeerAddrType = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 2, 1, 19), AddressFamilyNumbers()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityTargetedPeerAddrType.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityTargetedPeerAddrType.setDescription('The type of the internetwork layer address used for the Extended Discovery. This object indicates how the value of mplsLdpEntityTargetedPeerAddr is to be interpreted.')
mplsLdpEntityTargetedPeerAddr = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 2, 1, 20), MplsLdpGenAddr()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityTargetedPeerAddr.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityTargetedPeerAddr.setDescription('The value of the internetwork layer address used for the Extended Discovery.')
mplsLdpEntityOptionalParameters = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 2, 1, 21), MplsLdpLabelTypes()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityOptionalParameters.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityOptionalParameters.setDescription('Specifies the optional parameters for the LDP Initialization Message. If the value is generic(1) then no optional parameters will be sent in the LDP Initialization message associated with this Entity. If the value is atmParameters(2) then a row must be created in the mplsLdpEntityAtmParms Table, which corresponds to this entry. If the value is frameRelayParameters(3) then a row must be created in the mplsLdpEntityFrameRelayParms Table, which corresponds to this entry.')
mplsLdpEntityDiscontinuityTime = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 2, 1, 22), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpEntityDiscontinuityTime.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityDiscontinuityTime.setDescription("The value of sysUpTime on the most recent occasion at which any one or more of this entity's counters suffered a discontinuity. The relevant counters are the specific instances associated with this entity of any Counter32, or Counter64 object contained in the 'mplsLdpEntityStatsTable'. If no such discontinuities have occurred since the last re-initialization of the local management subsytem, then this object contains a zero value.")
mplsLdpEntityStorageType = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 2, 1, 23), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityStorageType.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityStorageType.setDescription('The storage type for this entry.')
mplsLdpEntityRowStatus = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 2, 1, 24), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityRowStatus.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityRowStatus.setDescription("An object that allows entries in this table to be created and deleted using the RowStatus convention. Once the 'mplsLdpEntityAdminStatus' object has the value of 'up' and this object has the value of 'active' then the Entity will atttempt to contact an LDP Peer. If the value of this object is changed to 'notInService', then the Entity looses contact with the LDP Peer and all information related to that Peer must be removed from the MIB. This has the same effect as changing 'mplsLdpEntityAdminStatus' from 'enable' to 'disable'. When this object is set to 'active' and the value of the 'mplsLdpEntityAdminStatus' is 'enable' then this Entity will attempt to contact the Peer and establish new sessions.")
mplsLdpEntityGenericObjects = MibIdentifier((1, 3, 6, 1, 3, 97, 1, 2, 3))
mplsLdpEntityConfGenericLabelRangeTable = MibTable((1, 3, 6, 1, 3, 97, 1, 2, 3, 1), )
if mibBuilder.loadTexts: mplsLdpEntityConfGenericLabelRangeTable.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityConfGenericLabelRangeTable.setDescription("The MPLS LDP Entity Configurable Generic Label Range Table. The purpose of this table is to provide a mechanism for specifying a contiguous range of generic labels, or a 'label range' for LDP Entities. LDP Entities which use Generic Labels must have at least one entry in this table.")
mplsLdpEntityConfGenericLabelRangeEntry = MibTableRow((1, 3, 6, 1, 3, 97, 1, 2, 3, 1, 1), ).setIndexNames((0, "MPLS-LDP-MIB", "mplsLdpEntityLdpId"), (0, "MPLS-LDP-MIB", "mplsLdpEntityIndex"), (0, "MPLS-LDP-MIB", "mplsLdpEntityConfGenericLabelRangeMinimum"), (0, "MPLS-LDP-MIB", "mplsLdpEntityConfGenericLabelRangeMaximum"))
if mibBuilder.loadTexts: mplsLdpEntityConfGenericLabelRangeEntry.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityConfGenericLabelRangeEntry.setDescription("A row in the LDP Entity Configurable Generic Label Range Table. One entry in this table contains information on a single range of labels represented by the configured Upper and Lower Bounds pairs. NOTE: there is NO corresponding LDP message which relates to the information in this table, however, this table does provide a way for a user to 'reserve' a generic label range. NOTE: The ranges for a specific LDP Entity are UNIQUE and non-overlapping. A row will not be created unless a unique and non-overlapping range is specified. Thus, row creation implies a one-shot row creation of LDP EntityID and LowerBound and UpperBound.")
mplsLdpEntityConfGenericLabelRangeMinimum = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 3, 1, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1048575)))
if mibBuilder.loadTexts: mplsLdpEntityConfGenericLabelRangeMinimum.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityConfGenericLabelRangeMinimum.setDescription('The minimum label configured for this range.')
mplsLdpEntityConfGenericLabelRangeMaximum = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 3, 1, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1048575)))
if mibBuilder.loadTexts: mplsLdpEntityConfGenericLabelRangeMaximum.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityConfGenericLabelRangeMaximum.setDescription('The maximum label configured for this range.')
mplsLdpEntityConfGenericIfIndexOrZero = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 3, 1, 1, 3), InterfaceIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityConfGenericIfIndexOrZero.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityConfGenericIfIndexOrZero.setDescription("This value represents either the InterfaceIndex of the 'ifLayer' where these Generic Label would be created, or 0 (zero). The value of zero means that the InterfaceIndex is not known. For example, if the InterfaceIndex is created subsequent to the Generic Label's creation, then it would not be known. However, if the InterfaceIndex is known, then it must be represented by this value. If an InterfaceIndex becomes known, then the network management entity (e.g. SNMP agent) responsible for this object MUST change the value from 0 (zero) to the value of the InterfaceIndex. If this Generic Label is being used in forwarding data, then the value of this object MUST be the InterfaceIndex.")
mplsLdpEntityConfGenericLabelRangeStorageType = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 3, 1, 1, 4), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityConfGenericLabelRangeStorageType.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityConfGenericLabelRangeStorageType.setDescription('The storage type for this entry.')
mplsLdpEntityConfGenericLabelRangeRowStatus = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 3, 1, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityConfGenericLabelRangeRowStatus.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityConfGenericLabelRangeRowStatus.setDescription("An object that allows entries in this table to be created and deleted using the RowStatus convention. There must exist at least one entry in this table for every LDP Entity that has a generic label configured. NOTE: This RowStatus object should have the same value of the 'mplsLdpEntityRowStatus' related to this entry.")
mplsLdpEntityAtmObjects = MibIdentifier((1, 3, 6, 1, 3, 97, 1, 2, 4))
mplsLdpEntityAtmParmsTable = MibTable((1, 3, 6, 1, 3, 97, 1, 2, 4, 1), )
if mibBuilder.loadTexts: mplsLdpEntityAtmParmsTable.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityAtmParmsTable.setDescription("This table contains information about the ATM specific information which could be used in the 'Optional Parameters' and other ATM specific information.")
mplsLdpEntityAtmParmsEntry = MibTableRow((1, 3, 6, 1, 3, 97, 1, 2, 4, 1, 1), ).setIndexNames((0, "MPLS-LDP-MIB", "mplsLdpEntityLdpId"), (0, "MPLS-LDP-MIB", "mplsLdpEntityIndex"))
if mibBuilder.loadTexts: mplsLdpEntityAtmParmsEntry.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityAtmParmsEntry.setDescription('An entry in this table represents the ATM parameters and ATM information for this LDP entity.')
mplsLdpEntityAtmIfIndexOrZero = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 4, 1, 1, 1), InterfaceIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityAtmIfIndexOrZero.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityAtmIfIndexOrZero.setDescription("This value represents either the InterfaceIndex of the 'ifLayer' where the ATM Labels 'owned' by this entry were created, or 0 (zero). The value of zero means that the InterfaceIndex is not known. For example, if the InterfaceIndex is created subsequent to the ATM Label's creation, then it would not be known. However, if the InterfaceIndex is known, then it must be represented by this value. If an InterfaceIndex becomes known, then the network management entity (e.g. SNMP agent) responsible for this object MUST change the value from 0 (zero) to the value of the InterfaceIndex. If an ATM Label is being used in forwarding data, then the value of this object MUST be the InterfaceIndex.")
mplsLdpEntityAtmMergeCap = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2))).clone(namedValues=NamedValues(("notSupported", 0), ("vcMerge", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityAtmMergeCap.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityAtmMergeCap.setDescription('Denotes the Merge Capability of this Entity.')
mplsLdpEntityAtmLabelRangeComponents = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 4, 1, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityAtmLabelRangeComponents.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityAtmLabelRangeComponents.setDescription('Number of LabelRange Components in the Initialization message. This also represents the number of entries in the mplsLdpLabelRangeComponentsTable which correspond to this entry.')
mplsLdpEntityAtmVcDirectionality = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("bidirectional", 0), ("unidirectional", 1)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityAtmVcDirectionality.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityAtmVcDirectionality.setDescription("If the value of this object is 'bidirectional(0)', a given VCI, within a given VPI, is used as a label for both directions independently. If the value of this object is 'unidirectional(1)', a given VCI within a VPI designates one direction.")
mplsLdpEntityAtmLsrConnectivity = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 4, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("direct", 1), ("indirect", 2))).clone('direct')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityAtmLsrConnectivity.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityAtmLsrConnectivity.setDescription('The peer LSR may be connected indirectly by means of an ATM VP so that the VPI values may be different on either endpoint so the label MUST be encoded entirely within the VCI field.')
mplsLdpEntityDefaultControlVpi = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 4, 1, 1, 6), AtmVpIdentifier()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityDefaultControlVpi.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityDefaultControlVpi.setDescription('The default VPI value for the non-MPLS connection. The default value of this is 0 (zero) but other values may be configured. This object allows a different value to be configured.')
mplsLdpEntityDefaultControlVci = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 4, 1, 1, 7), MplsAtmVcIdentifier().clone(32)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityDefaultControlVci.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityDefaultControlVci.setDescription('The Default VCI value for a non-MPLS connection. The default value of this is 32 but other values may be configured. This object allows a different value to be configured.')
mplsLdpEntityUnlabTrafVpi = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 4, 1, 1, 8), AtmVpIdentifier()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityUnlabTrafVpi.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityUnlabTrafVpi.setDescription("VPI value of the VCC supporting unlabelled traffic. This non-MPLS connection is used to carry unlabelled (IP) packets. The default value is the same as the default value of the 'mplsLdpEntityDefaultControlVpi', however another value may be configured.")
mplsLdpEntityUnlabTrafVci = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 4, 1, 1, 9), MplsAtmVcIdentifier().clone(32)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityUnlabTrafVci.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityUnlabTrafVci.setDescription("VCI value of the VCC supporting unlabelled traffic. This non-MPLS connection is used to carry unlabelled (IP) packets. The default value is the same as the default value of the 'mplsLdpEntityDefaultControlVci', however another value may be configured.")
mplsLdpEntityAtmStorageType = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 4, 1, 1, 10), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityAtmStorageType.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityAtmStorageType.setDescription('The storage type for this entry.')
mplsLdpEntityAtmRowStatus = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 4, 1, 1, 11), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityAtmRowStatus.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityAtmRowStatus.setDescription("An object that allows entries in this table to be created and deleted using the RowStatus convention. NOTE: This RowStatus object should have the same value of the 'mplsLdpEntityRowStatus' related to this entry.")
mplsLdpEntityConfAtmLabelRangeTable = MibTable((1, 3, 6, 1, 3, 97, 1, 2, 4, 2), )
if mibBuilder.loadTexts: mplsLdpEntityConfAtmLabelRangeTable.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityConfAtmLabelRangeTable.setDescription("The MPLS LDP Entity Configurable ATM Label Range Table. The purpose of this table is to provide a mechanism for specifying a contiguous range of vpi's with a contiguous range of vci's, or a 'label range' for LDP Entities. LDP Entities which use ATM must have at least one entry in this table.")
mplsLdpEntityConfAtmLabelRangeEntry = MibTableRow((1, 3, 6, 1, 3, 97, 1, 2, 4, 2, 1), ).setIndexNames((0, "MPLS-LDP-MIB", "mplsLdpEntityLdpId"), (0, "MPLS-LDP-MIB", "mplsLdpEntityIndex"), (0, "MPLS-LDP-MIB", "mplsLdpEntityConfAtmLabelRangeMinimumVpi"), (0, "MPLS-LDP-MIB", "mplsLdpEntityConfAtmLabelRangeMinimumVci"))
if mibBuilder.loadTexts: mplsLdpEntityConfAtmLabelRangeEntry.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityConfAtmLabelRangeEntry.setDescription('A row in the LDP Entity Configurable ATM Label Range Table. One entry in this table contains information on a single range of labels represented by the configured Upper and Lower Bounds VPI/VCI pairs. These are the same data used in the Initialization Message. NOTE: The ranges for a specific LDP Entity are UNIQUE and non-overlapping. For example, for a specific LDP Entity index, there could be one entry having ConfLowerBound vpi/vci == 0/32, and ConfUpperBound vpi/vci == 0/100, and a second entry for this same interface with ConfLowerBound vpi/vci == 0/101 and ConfUpperBound vpi/vci == 0/200. However, there could not be a third entry with ConfLowerBound vpi/vci == 0/200 and ConfUpperBound vpi/vci == 0/300 because this label range overlaps with the second entry (i.e. both entries now have 0/200). A row will not be created unless a unique and non-overlapping range is specified. Thus, row creation implies a one-shot row creation of LDP EntityID and ConfLowerBound vpi/vci and ConfUpperBound vpi/vci. At least one label range entry for a specific LDP Entity MUST include the default VPI/VCI values denoted in the LDP Entity Table.')
mplsLdpEntityConfAtmLabelRangeMinimumVpi = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 4, 2, 1, 1), AtmVpIdentifier())
if mibBuilder.loadTexts: mplsLdpEntityConfAtmLabelRangeMinimumVpi.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityConfAtmLabelRangeMinimumVpi.setDescription('The minimum VPI number configured for this range.')
mplsLdpEntityConfAtmLabelRangeMinimumVci = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 4, 2, 1, 2), MplsAtmVcIdentifier())
if mibBuilder.loadTexts: mplsLdpEntityConfAtmLabelRangeMinimumVci.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityConfAtmLabelRangeMinimumVci.setDescription('The minimum VCI number configured for this range.')
mplsLdpEntityConfAtmLabelRangeMaximumVpi = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 4, 2, 1, 3), AtmVpIdentifier()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityConfAtmLabelRangeMaximumVpi.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityConfAtmLabelRangeMaximumVpi.setDescription('The maximum VPI number configured for this range.')
mplsLdpEntityConfAtmLabelRangeMaximumVci = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 4, 2, 1, 4), MplsAtmVcIdentifier()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityConfAtmLabelRangeMaximumVci.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityConfAtmLabelRangeMaximumVci.setDescription('The maximum VCI number configured for this range.')
mplsLdpEntityConfAtmLabelRangeStorageType = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 4, 2, 1, 5), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityConfAtmLabelRangeStorageType.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityConfAtmLabelRangeStorageType.setDescription('The storage type for this entry.')
mplsLdpEntityConfAtmLabelRangeRowStatus = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 4, 2, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityConfAtmLabelRangeRowStatus.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityConfAtmLabelRangeRowStatus.setDescription("An object that allows entries in this table to be created and deleted using the RowStatus convention. There must exist at least one entry in this table for every LDP Entity that has 'mplsLdpEntityOptionalParameters' object with a value of 'atmSessionParameters'. NOTE: This RowStatus object should have the same value of the 'mplsLdpEntityRowStatus' related to this entry.")
mplsLdpEntityFrameRelayObjects = MibIdentifier((1, 3, 6, 1, 3, 97, 1, 2, 5))
mplsLdpEntityFrameRelayParmsTable = MibTable((1, 3, 6, 1, 3, 97, 1, 2, 5, 1), )
if mibBuilder.loadTexts: mplsLdpEntityFrameRelayParmsTable.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityFrameRelayParmsTable.setDescription('This table contains information about the Optional Parameters to specify what this Entity is going to specify for Frame Relay specific LDP Intialization Messages.')
mplsLdpEntityFrameRelayParmsEntry = MibTableRow((1, 3, 6, 1, 3, 97, 1, 2, 5, 1, 1), ).setIndexNames((0, "MPLS-LDP-MIB", "mplsLdpEntityLdpId"), (0, "MPLS-LDP-MIB", "mplsLdpEntityIndex"))
if mibBuilder.loadTexts: mplsLdpEntityFrameRelayParmsEntry.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityFrameRelayParmsEntry.setDescription('An entry in this table represents the Frame Relay optional parameters associated with the LDP entity.')
mplsLdpEntityFrIfIndexOrZero = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 5, 1, 1, 1), InterfaceIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityFrIfIndexOrZero.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityFrIfIndexOrZero.setDescription("This value represents either the InterfaceIndex of the 'ifLayer' where the Frame Relay Labels 'owned' by this entry were created, or 0 (zero). The value of zero means that the InterfaceIndex is not known. For example, if the InterfaceIndex is created subsequent to the Frame Relay Label's creation, then it would not be known. However, if the InterfaceIndex is known, then it must be represented by this value. If an InterfaceIndex becomes known, then the network management entity (e.g. SNMP agent) responsible for this object MUST change the value from 0 (zero) to the value of the InterfaceIndex. If an Frame Relay Label is being used in forwarding data, then the value of this object MUST be the InterfaceIndex.")
mplsLdpEntityFrMergeCap = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("notSupported", 0), ("supported", 1)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityFrMergeCap.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityFrMergeCap.setDescription('This represents whether or not Frame Relay merge capability is supported.')
mplsLdpEntityFrLabelRangeComponents = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 5, 1, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityFrLabelRangeComponents.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityFrLabelRangeComponents.setDescription('Number of LabelRange Components in the Initialization message. This also represents the number of entries in the mplsLdpEntityConfFrLabelRangeTable which correspond to this entry.')
mplsLdpEntityFrLen = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 5, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2))).clone(namedValues=NamedValues(("tenDlciBits", 0), ("twentyThreeDlciBits", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityFrLen.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityFrLen.setDescription('This object specifies the DLCI bits.')
mplsLdpEntityFrVcDirectionality = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 5, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("bidirectional", 0), ("unidirection", 1)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityFrVcDirectionality.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityFrVcDirectionality.setDescription("If the value of this object is 'bidirectional(0)', then the LSR supports the use of a given DLCI as a label for both directions independently. If the value of this object is 'unidirectional(1)', then the LSR uses the given DLCI as a label in only one direction.")
mplsLdpEntityFrParmsStorageType = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 5, 1, 1, 6), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityFrParmsStorageType.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityFrParmsStorageType.setDescription('The storage type for this entry.')
mplsLdpEntityFrParmsRowStatus = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 5, 1, 1, 7), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityFrParmsRowStatus.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityFrParmsRowStatus.setDescription("An object that allows entries in this table to be created and deleted using the RowStatus convention. NOTE: This RowStatus object should have the same value of the 'mplsLdpEntityRowStatus' related to this entry.")
mplsLdpEntityConfFrLabelRangeTable = MibTable((1, 3, 6, 1, 3, 97, 1, 2, 5, 2), )
if mibBuilder.loadTexts: mplsLdpEntityConfFrLabelRangeTable.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityConfFrLabelRangeTable.setDescription('This table contains information about the Optional Parameters to specify what this Entity is going to specify for Frame Relay specific LDP Intialization Messages.')
mplsLdpEntityConfFrLabelRangeEntry = MibTableRow((1, 3, 6, 1, 3, 97, 1, 2, 5, 2, 1), ).setIndexNames((0, "MPLS-LDP-MIB", "mplsLdpEntityLdpId"), (0, "MPLS-LDP-MIB", "mplsLdpEntityIndex"), (0, "MPLS-LDP-MIB", "mplsLdpConfFrMinimumDlci"))
if mibBuilder.loadTexts: mplsLdpEntityConfFrLabelRangeEntry.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityConfFrLabelRangeEntry.setDescription('An entry in this table represents the Frame Relay optional parameters associated with the LDP entity.')
mplsLdpConfFrMinimumDlci = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 5, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4194303)))
if mibBuilder.loadTexts: mplsLdpConfFrMinimumDlci.setStatus('current')
if mibBuilder.loadTexts: mplsLdpConfFrMinimumDlci.setDescription("The lower bound which is supported. This value should be the same as that in the Frame Relay Label Range Component's Minimum DLCI field.")
mplsLdpConfFrMaximumDlci = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 5, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4194303))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpConfFrMaximumDlci.setStatus('current')
if mibBuilder.loadTexts: mplsLdpConfFrMaximumDlci.setDescription("The upper bound which is supported. This value should be the same as that in the Frame Relay Label Range Component's Maximum DLCI field.")
mplsLdpConfFrStorageType = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 5, 2, 1, 3), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpConfFrStorageType.setStatus('current')
if mibBuilder.loadTexts: mplsLdpConfFrStorageType.setDescription('The storage type for this entry.')
mplsLdpConfFrRowStatus = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 5, 2, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpConfFrRowStatus.setStatus('current')
if mibBuilder.loadTexts: mplsLdpConfFrRowStatus.setDescription("An object that allows entries in this table to be created and deleted using the RowStatus convention. If the value of the object 'mplsLdpEntityOptionalParameters' contains the value of 'frameRelaySessionParameters(3)' then there must be at least one corresponding entry in this table. NOTE: This RowStatus object should have the same value of the 'mplsLdpEntityRowStatus' related to this entry.")
mplsLdpEntityStatsTable = MibTable((1, 3, 6, 1, 3, 97, 1, 2, 6), )
if mibBuilder.loadTexts: mplsLdpEntityStatsTable.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityStatsTable.setDescription('This table is a read-only table which augments the mplsLdpEntityTable. The purpose of this table is to keep statistical information about the LDP Entities on the LSR.')
mplsLdpEntityStatsEntry = MibTableRow((1, 3, 6, 1, 3, 97, 1, 2, 6, 1), )
mplsLdpEntityEntry.registerAugmentions(("MPLS-LDP-MIB", "mplsLdpEntityStatsEntry"))
mplsLdpEntityStatsEntry.setIndexNames(*mplsLdpEntityEntry.getIndexNames())
if mibBuilder.loadTexts: mplsLdpEntityStatsEntry.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityStatsEntry.setDescription('A row in this table contains statistical information about an LDP Entity. Some counters contained in a row are for fatal errors received during a former LDP Session associated with this entry. For example, an Ldp Pdu received on a TCP connection during an LDP Session contains a fatal error. That error is counted here, because the session is terminated. If the error is NOT fatal (i.e. and the Session remains), then the error is counted in the mplsLdpSessionStatsEntry.')
mplsLdpAttemptedSessions = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 6, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpAttemptedSessions.setStatus('current')
if mibBuilder.loadTexts: mplsLdpAttemptedSessions.setDescription('A count of the total attempted sessions for this LDP Entity.')
mplsLdpSessionRejectedNoHelloErrors = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 6, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpSessionRejectedNoHelloErrors.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionRejectedNoHelloErrors.setDescription('A count of the Session Rejected/No Hello Error Notification Messages sent or received by this LDP Entity.')
mplsLdpSessionRejectedAdvertisementErrors = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 6, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpSessionRejectedAdvertisementErrors.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionRejectedAdvertisementErrors.setDescription('A count of the Session Rejected/Parameters Advertisement Mode Error Notification Messages sent or received by this LDP Entity.')
mplsLdpSessionRejectedMaxPduErrors = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 6, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpSessionRejectedMaxPduErrors.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionRejectedMaxPduErrors.setDescription('A count of the Session Rejected/Parameters Max Pdu Length Error Notification Messages sent or received by this LDP Entity.')
mplsLdpSessionRejectedLabelRangeErrors = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 6, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpSessionRejectedLabelRangeErrors.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionRejectedLabelRangeErrors.setDescription('A count of the Session Rejected/Parameters Label Range Notification Messages sent or received by this LDP Entity.')
mplsLdpBadLdpIdentifierErrors = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 6, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpBadLdpIdentifierErrors.setReference('LDP Specification, Section 3.5.1.2.')
if mibBuilder.loadTexts: mplsLdpBadLdpIdentifierErrors.setStatus('current')
if mibBuilder.loadTexts: mplsLdpBadLdpIdentifierErrors.setDescription('This object counts the number of Bad LDP Identifier Fatal Errors detected by the session(s) (past and present) associated with this LDP Entity.')
mplsLdpBadPduLengthErrors = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 6, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpBadPduLengthErrors.setReference('LDP Specification, Section 3.5.1.2.')
if mibBuilder.loadTexts: mplsLdpBadPduLengthErrors.setStatus('current')
if mibBuilder.loadTexts: mplsLdpBadPduLengthErrors.setDescription('This object counts the number of Bad Pdu Length Fatal Errors detected by the session(s) (past and present) associated with this LDP Entity.')
mplsLdpBadMessageLengthErrors = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 6, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpBadMessageLengthErrors.setReference('LDP Specification, Section 3.5.1.2.')
if mibBuilder.loadTexts: mplsLdpBadMessageLengthErrors.setStatus('current')
if mibBuilder.loadTexts: mplsLdpBadMessageLengthErrors.setDescription('This object counts the number of Bad Message Length Fatal Errors detected by the session(s) (past and present) associated with this LDP Entity.')
mplsLdpBadTlvLengthErrors = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 6, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpBadTlvLengthErrors.setReference('LDP Specification, Section 3.5.1.2.')
if mibBuilder.loadTexts: mplsLdpBadTlvLengthErrors.setStatus('current')
if mibBuilder.loadTexts: mplsLdpBadTlvLengthErrors.setDescription('This object counts the number of Bad TLV Length Fatal Errors detected by the session(s) (past and present) associated with this LDP Entity.')
mplsLdpMalformedTlvValueErrors = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 6, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpMalformedTlvValueErrors.setReference('LDP Specification, Section 3.5.1.2.')
if mibBuilder.loadTexts: mplsLdpMalformedTlvValueErrors.setStatus('current')
if mibBuilder.loadTexts: mplsLdpMalformedTlvValueErrors.setDescription('This object counts the number of Malformed TLV Value Fatal Errors detected by the session(s) (past and present) associated with this LDP Entity.')
mplsLdpKeepAliveTimerExpiredErrors = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 6, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpKeepAliveTimerExpiredErrors.setReference('LDP Specification, Section 3.5.1.2.')
if mibBuilder.loadTexts: mplsLdpKeepAliveTimerExpiredErrors.setStatus('current')
if mibBuilder.loadTexts: mplsLdpKeepAliveTimerExpiredErrors.setDescription('This object counts the number of Session Keep Alive Timer Expired Errors detected by the session(s) (past and present) associated with this LDP Entity.')
mplsLdpShutdownNotifReceived = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 6, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpShutdownNotifReceived.setStatus('current')
if mibBuilder.loadTexts: mplsLdpShutdownNotifReceived.setDescription('This object counts the number of Shutdown Notfications received related to session(s) (past and present) associated with this LDP Entity.')
mplsLdpShutdownNotifSent = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 2, 6, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpShutdownNotifSent.setStatus('current')
if mibBuilder.loadTexts: mplsLdpShutdownNotifSent.setDescription('This object counts the number of Shutdown Notfications sent related to session(s) (past and present) associated with this LDP Entity.')
mplsLdpSessionObjects = MibIdentifier((1, 3, 6, 1, 3, 97, 1, 3))
mplsLdpPeerTable = MibTable((1, 3, 6, 1, 3, 97, 1, 3, 1), )
if mibBuilder.loadTexts: mplsLdpPeerTable.setStatus('current')
if mibBuilder.loadTexts: mplsLdpPeerTable.setDescription('Information about LDP peers known by Entities in the mplsLdpEntityTable. The information in this table is based on information from the Entity-Peer interaction during session initialization but is not appropriate for the mplsLdpSessionTable, because objects in this table may or may not be used in session establishment.')
mplsLdpPeerEntry = MibTableRow((1, 3, 6, 1, 3, 97, 1, 3, 1, 1), ).setIndexNames((0, "MPLS-LDP-MIB", "mplsLdpEntityLdpId"), (0, "MPLS-LDP-MIB", "mplsLdpEntityIndex"), (0, "MPLS-LDP-MIB", "mplsLdpPeerLdpId"))
if mibBuilder.loadTexts: mplsLdpPeerEntry.setStatus('current')
if mibBuilder.loadTexts: mplsLdpPeerEntry.setDescription('Information about a single Peer which is related to a Session. NOTE: this table is used to augment the mplsLdpSessionTable.')
mplsLdpPeerLdpId = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 1, 1, 1), MplsLdpIdentifier())
if mibBuilder.loadTexts: mplsLdpPeerLdpId.setStatus('current')
if mibBuilder.loadTexts: mplsLdpPeerLdpId.setDescription('The LDP identifier of this LDP Peer.')
mplsLdpPeerLabelDistributionMethod = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("downstreamOnDemand", 1), ("downstreamUnsolicited", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpPeerLabelDistributionMethod.setStatus('current')
if mibBuilder.loadTexts: mplsLdpPeerLabelDistributionMethod.setDescription('For any given LDP session, the method of label distribution must be specified.')
mplsLdpPeerLoopDetectionForPV = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpPeerLoopDetectionForPV.setStatus('current')
if mibBuilder.loadTexts: mplsLdpPeerLoopDetectionForPV.setDescription('An indication of whether loop detection based on path vectors is disabled or enabled for this Peer. If this object has a value of disabled(0), then loop detection is disabled. Otherwise, if this object has a value of enabled(1), then loop detection based on path vectors is enabled.')
mplsLdpPeerPathVectorLimit = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpPeerPathVectorLimit.setStatus('current')
if mibBuilder.loadTexts: mplsLdpPeerPathVectorLimit.setDescription("If the value of 'mplsLdpPeerLoopDetectionForPV' for this entry is 'enabled(1)', the this object represents that Path Vector Limit for this peer. If the value of 'mplsLdpPeerLoopDetectionForPV' for this entry is 'disabled(0)', then this value should be 0 (zero).")
mplsLdpHelloAdjacencyObjects = MibIdentifier((1, 3, 6, 1, 3, 97, 1, 3, 2))
mplsLdpHelloAdjacencyTable = MibTable((1, 3, 6, 1, 3, 97, 1, 3, 2, 1), )
if mibBuilder.loadTexts: mplsLdpHelloAdjacencyTable.setStatus('current')
if mibBuilder.loadTexts: mplsLdpHelloAdjacencyTable.setDescription('A table of Hello Adjacencies for Sessions.')
mplsLdpHelloAdjacencyEntry = MibTableRow((1, 3, 6, 1, 3, 97, 1, 3, 2, 1, 1), ).setIndexNames((0, "MPLS-LDP-MIB", "mplsLdpEntityLdpId"), (0, "MPLS-LDP-MIB", "mplsLdpEntityIndex"), (0, "MPLS-LDP-MIB", "mplsLdpPeerLdpId"), (0, "MPLS-LDP-MIB", "mplsLdpHelloAdjacencyIndex"))
if mibBuilder.loadTexts: mplsLdpHelloAdjacencyEntry.setStatus('current')
if mibBuilder.loadTexts: mplsLdpHelloAdjacencyEntry.setDescription('Each row represents a single LDP Hello Adjacency. An LDP Session can have one or more Hello adjacencies.')
mplsLdpHelloAdjacencyIndex = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 2, 1, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: mplsLdpHelloAdjacencyIndex.setStatus('current')
if mibBuilder.loadTexts: mplsLdpHelloAdjacencyIndex.setDescription('An identifier for this specific adjacency.')
mplsLdpHelloAdjacencyHoldTimeRemaining = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 2, 1, 1, 2), TimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpHelloAdjacencyHoldTimeRemaining.setStatus('current')
if mibBuilder.loadTexts: mplsLdpHelloAdjacencyHoldTimeRemaining.setDescription("The time remaining for this Hello Adjacency. This interval will change when the 'next' Hello message which corresponds to this Hello Adjacency is received.")
mplsLdpHelloAdjacencyType = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("link", 1), ("targeted", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpHelloAdjacencyType.setStatus('current')
if mibBuilder.loadTexts: mplsLdpHelloAdjacencyType.setDescription("This adjacency is the result of a 'link' hello if the value of this object is link(1). Otherwise, it is a result of a 'targeted' hello, targeted(2).")
mplsLdpSessionUpDownTrapEnable = MibScalar((1, 3, 6, 1, 3, 97, 1, 3, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mplsLdpSessionUpDownTrapEnable.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionUpDownTrapEnable.setDescription("Indicates whether the traps, 'mplsLdpSessionUp' and 'mplsLdpSessionDown' will be generated or not. If the value of this object is 'enabled(1)' then the traps will generated. If the value of this object is 'disabled(2)' then the traps will not be generated. The DEFVAL is set to 'disabled(2)'.")
mplsLdpSessionTable = MibTable((1, 3, 6, 1, 3, 97, 1, 3, 4), )
if mibBuilder.loadTexts: mplsLdpSessionTable.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionTable.setDescription('A table of Sessions between the LDP Entities and LDP Peers. Each row represents a single session.')
mplsLdpSessionEntry = MibTableRow((1, 3, 6, 1, 3, 97, 1, 3, 4, 1), )
mplsLdpPeerEntry.registerAugmentions(("MPLS-LDP-MIB", "mplsLdpSessionEntry"))
mplsLdpSessionEntry.setIndexNames(*mplsLdpPeerEntry.getIndexNames())
if mibBuilder.loadTexts: mplsLdpSessionEntry.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionEntry.setDescription("An entry in this table represents information on a single session between an LDP Entity and LDP Peer. The information contained in a row is read-only. Please note: the Path Vector Limit for the Session is the value which is configured in the corresponding mplsLdpEntityEntry. The Peer's Path Vector Limit is in noted in the mplsLdpPeerTable. Values which may differ from those configured are noted in the objects of this table, the mplsLdpAtmSessionTable and the mplsLdpFrameRelaySessionTable. A value will differ if it was negotiated between the Entity and the Peer. Values may or may not be negotiated. For example, if the values are the same then no negotiation takes place. If they are negotiated, then they may differ.")
mplsLdpSessionState = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 4, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("nonexistent", 1), ("initialized", 2), ("openrec", 3), ("opensent", 4), ("operational", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpSessionState.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionState.setDescription('The current state of the session, all of the states 1 - 5 are based on the state machine for session negotiation behavior.')
mplsLdpSessionProtocolVersion = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpSessionProtocolVersion.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionProtocolVersion.setDescription('The version of the LDP Protocol which this session is using.')
mplsLdpSessionKeepAliveHoldTimeRemaining = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 4, 1, 3), TimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpSessionKeepAliveHoldTimeRemaining.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionKeepAliveHoldTimeRemaining.setDescription('The keep alive hold time remaining for this session.')
mplsLdpSessionMaxPduLength = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 4, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpSessionMaxPduLength.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionMaxPduLength.setDescription('The value of maximum allowable length for LDP PDUs for this session. This value may have been negotiated during the Session Initialization.')
mplsLdpSessionDiscontinuityTime = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 4, 1, 5), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpSessionDiscontinuityTime.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionDiscontinuityTime.setDescription("The value of sysUpTime on the most recent occasion at which any one or more of this session's counters suffered a discontinuity. The relevant counters are the specific instances associated with this session of any Counter32 or Counter64 object contained in the mplsLdpSessionStatsTable. If no such discontinuities have occurred since the last re-initialization of the local management subsystem, then this object contains a zero value. Also, an NMS can distinguish when a session between a given Entity and Peer goes away and then is 're-established'. This value would change and thus indicate to the NMS that this is a different session.")
mplsLdpAtmSessionTable = MibTable((1, 3, 6, 1, 3, 97, 1, 3, 5), )
if mibBuilder.loadTexts: mplsLdpAtmSessionTable.setStatus('current')
if mibBuilder.loadTexts: mplsLdpAtmSessionTable.setDescription("A table which relates Sessions in the 'mplsLdpSessionTable' and their label range intersections. There could be one or more label range intersections between an LDP Entity and LDP Peer using ATM as the underlying media. Each row represents a single label range intersection. NOTE: this table cannot use the 'AUGMENTS' clause because there is not necessarily a one-to-one mapping between this table and the mplsLdpSessionTable.")
mplsLdpAtmSessionEntry = MibTableRow((1, 3, 6, 1, 3, 97, 1, 3, 5, 1), ).setIndexNames((0, "MPLS-LDP-MIB", "mplsLdpEntityLdpId"), (0, "MPLS-LDP-MIB", "mplsLdpEntityIndex"), (0, "MPLS-LDP-MIB", "mplsLdpPeerLdpId"), (0, "MPLS-LDP-MIB", "mplsLdpSessionAtmLabelRangeLowerBoundVpi"), (0, "MPLS-LDP-MIB", "mplsLdpSessionAtmLabelRangeLowerBoundVci"))
if mibBuilder.loadTexts: mplsLdpAtmSessionEntry.setStatus('current')
if mibBuilder.loadTexts: mplsLdpAtmSessionEntry.setDescription('An entry in this table represents information on a single label range intersection between an LDP Entity and LDP Peer. The information contained in a row is read-only.')
mplsLdpSessionAtmLabelRangeLowerBoundVpi = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 5, 1, 1), AtmVpIdentifier())
if mibBuilder.loadTexts: mplsLdpSessionAtmLabelRangeLowerBoundVpi.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionAtmLabelRangeLowerBoundVpi.setDescription('The minimum VPI number for this range.')
mplsLdpSessionAtmLabelRangeLowerBoundVci = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 5, 1, 2), MplsAtmVcIdentifier())
if mibBuilder.loadTexts: mplsLdpSessionAtmLabelRangeLowerBoundVci.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionAtmLabelRangeLowerBoundVci.setDescription('The minimum VCI number for this range.')
mplsLdpSessionAtmLabelRangeUpperBoundVpi = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 5, 1, 3), AtmVpIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpSessionAtmLabelRangeUpperBoundVpi.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionAtmLabelRangeUpperBoundVpi.setDescription('The maximum VPI number for this range.')
mplsLdpSessionAtmLabelRangeUpperBoundVci = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 5, 1, 4), MplsAtmVcIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpSessionAtmLabelRangeUpperBoundVci.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionAtmLabelRangeUpperBoundVci.setDescription('The maximum VCI number for this range.')
mplsLdpFrameRelaySessionTable = MibTable((1, 3, 6, 1, 3, 97, 1, 3, 6), )
if mibBuilder.loadTexts: mplsLdpFrameRelaySessionTable.setStatus('current')
if mibBuilder.loadTexts: mplsLdpFrameRelaySessionTable.setDescription("A table of Frame Relay label range intersections between the LDP Entities and LDP Peers. Each row represents a single label range intersection. NOTE: this table cannot use the 'AUGMENTS' clause because there is not necessarily a one-to-one mapping between this table and the mplsLdpSessionTable.")
mplsLdpFrameRelaySessionEntry = MibTableRow((1, 3, 6, 1, 3, 97, 1, 3, 6, 1), ).setIndexNames((0, "MPLS-LDP-MIB", "mplsLdpEntityLdpId"), (0, "MPLS-LDP-MIB", "mplsLdpEntityIndex"), (0, "MPLS-LDP-MIB", "mplsLdpPeerLdpId"), (0, "MPLS-LDP-MIB", "mplsLdpFrSessionMinDlci"))
if mibBuilder.loadTexts: mplsLdpFrameRelaySessionEntry.setStatus('current')
if mibBuilder.loadTexts: mplsLdpFrameRelaySessionEntry.setDescription('An entry in this table represents information on a single label range intersection between an LDP Entity and LDP Peer. The information contained in a row is read-only.')
mplsLdpFrSessionMinDlci = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4194303)))
if mibBuilder.loadTexts: mplsLdpFrSessionMinDlci.setStatus('current')
if mibBuilder.loadTexts: mplsLdpFrSessionMinDlci.setDescription('The lower bound of DLCIs which are supported.')
mplsLdpFrSessionMaxDlci = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 6, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4194303))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpFrSessionMaxDlci.setStatus('current')
if mibBuilder.loadTexts: mplsLdpFrSessionMaxDlci.setDescription('The upper bound of DLCIs which are supported.')
mplsLdpFrSessionLen = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 6, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2))).clone(namedValues=NamedValues(("tenDlciBits", 0), ("twentyThreeDlciBits", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpFrSessionLen.setStatus('current')
if mibBuilder.loadTexts: mplsLdpFrSessionLen.setDescription('This object specifies the DLCI bits.')
mplsLdpSessionStatsTable = MibTable((1, 3, 6, 1, 3, 97, 1, 3, 7), )
if mibBuilder.loadTexts: mplsLdpSessionStatsTable.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionStatsTable.setDescription('A table of statistics for Sessions between LDP Entities and LDP Peers.')
mplsLdpSessionStatsEntry = MibTableRow((1, 3, 6, 1, 3, 97, 1, 3, 7, 1), )
mplsLdpPeerEntry.registerAugmentions(("MPLS-LDP-MIB", "mplsLdpSessionStatsEntry"))
mplsLdpSessionStatsEntry.setIndexNames(*mplsLdpPeerEntry.getIndexNames())
if mibBuilder.loadTexts: mplsLdpSessionStatsEntry.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionStatsEntry.setDescription('An entry in this table represents statistical information on a single session between an LDP Entity and LDP Peer.')
mplsLdpSessionStatsUnknownMessageTypeErrors = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 7, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpSessionStatsUnknownMessageTypeErrors.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionStatsUnknownMessageTypeErrors.setDescription('This object counts the number of Unknown Message Type Errors detected during this session. Discontinuities in the value of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of mplsLdpSeeionDiscontinuityTime.')
mplsLdpSessionStatsUnknownTlvErrors = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 7, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpSessionStatsUnknownTlvErrors.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionStatsUnknownTlvErrors.setDescription('This object counts the number of Unknown TLV Errors detected during this session. Discontinuities in the value of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of mplsLdpSeeionDiscontinuityTime.')
mplsFecObjects = MibIdentifier((1, 3, 6, 1, 3, 97, 1, 3, 8))
mplsFecIndexNext = MibScalar((1, 3, 6, 1, 3, 97, 1, 3, 8, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsFecIndexNext.setStatus('current')
if mibBuilder.loadTexts: mplsFecIndexNext.setDescription('This object contains an appropriate value to be used for mplsFecIndex when creating entries in the mplsFecTable. The value 0 indicates that no unassigned entries are available. To obtain the mplsFecIndex value for a new entry, the manager issues a management protocol retrieval operation to obtain the current value of this object. After each retrieval, the agent should modify the value to the next unassigned index.')
mplsFecTable = MibTable((1, 3, 6, 1, 3, 97, 1, 3, 8, 2), )
if mibBuilder.loadTexts: mplsFecTable.setStatus('current')
if mibBuilder.loadTexts: mplsFecTable.setDescription('This table represents the FEC (Forwarding Equivalence Class) Information associated with an LSP.')
mplsFecEntry = MibTableRow((1, 3, 6, 1, 3, 97, 1, 3, 8, 2, 1), ).setIndexNames((0, "MPLS-LDP-MIB", "mplsFecIndex"))
if mibBuilder.loadTexts: mplsFecEntry.setStatus('current')
if mibBuilder.loadTexts: mplsFecEntry.setDescription('Each row represents a single FEC Element.')
mplsFecIndex = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 8, 2, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: mplsFecIndex.setStatus('current')
if mibBuilder.loadTexts: mplsFecIndex.setDescription('The index which uniquely identifies this entry.')
mplsFecType = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 8, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("prefix", 1), ("hostAddress", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsFecType.setStatus('current')
if mibBuilder.loadTexts: mplsFecType.setDescription("The type of the FEC. If the value of this object is 'prefix(1)' then the FEC type described by this row is for address prefixes. If the value of this object is 'hostAddress(2)' then the FEC type described by this row is a host address.")
mplsFecAddressLength = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 8, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsFecAddressLength.setStatus('current')
if mibBuilder.loadTexts: mplsFecAddressLength.setDescription("If the value of 'mplsFecType' is 'prefix(1)' then the value of this object is the length in bits of the address prefix represented by 'mplsFecAddress', or if the length is zero then this is a special value which indicates that the prefix matches all addresses. In this case the prefix is also zero (i.e. 'mplsFecAddress' will have the value of zero.)")
mplsFecAddressFamily = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 8, 2, 1, 4), AddressFamilyNumbers()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsFecAddressFamily.setStatus('current')
if mibBuilder.loadTexts: mplsFecAddressFamily.setDescription('The value of this object is from the Address Family Numbers.')
mplsFecAddress = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 8, 2, 1, 5), MplsLdpGenAddr()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsFecAddress.setStatus('current')
if mibBuilder.loadTexts: mplsFecAddress.setDescription("If the value of 'mplsFecType' is 'prefix(1)' then the value of this object is the address prefix. If the value of the 'mplsFecAddressLength' is object is zero, then this object should also be zero. If the value of the 'mplsFecType' is 'host(2)' then this is the host address.")
mplsFecStorageType = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 8, 2, 1, 6), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsFecStorageType.setStatus('current')
if mibBuilder.loadTexts: mplsFecStorageType.setDescription('The storage type for this entry.')
mplsFecRowStatus = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 8, 2, 1, 7), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsFecRowStatus.setStatus('current')
if mibBuilder.loadTexts: mplsFecRowStatus.setDescription('An object that allows entries in this table to be created and deleted using the RowStatus convention.')
mplsLdpSessionInLabelMapTable = MibTable((1, 3, 6, 1, 3, 97, 1, 3, 9), )
if mibBuilder.loadTexts: mplsLdpSessionInLabelMapTable.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionInLabelMapTable.setDescription("A table of Session's Ingress Labels which are Mapped to the LSR MIB's mplsInSegmentTable. Each row represents a single Ingress Label.")
mplsLdpSessionInLabelMapEntry = MibTableRow((1, 3, 6, 1, 3, 97, 1, 3, 9, 1), ).setIndexNames((0, "MPLS-LDP-MIB", "mplsLdpEntityLdpId"), (0, "MPLS-LDP-MIB", "mplsLdpEntityIndex"), (0, "MPLS-LDP-MIB", "mplsLdpPeerLdpId"), (0, "MPLS-LDP-MIB", "mplsLdpSessionInLabelIfIndex"), (0, "MPLS-LDP-MIB", "mplsLdpSessionInLabel"))
if mibBuilder.loadTexts: mplsLdpSessionInLabelMapEntry.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionInLabelMapEntry.setDescription("An entry in this table represents information on a single LDP LSP which is represented by a session's index triple (mplsLdpEntityLdpId, mplsLdpEntityIndex, mplsLdpPeerLdpId) AND the index tuple (mplsLdpSessionInLabel, mplsInSegmentIfIndex) from the LSR MIB's mplsInSegmentTable. The information contained in a row is read-only.")
mplsLdpSessionInLabelIfIndex = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 9, 1, 1), InterfaceIndex())
if mibBuilder.loadTexts: mplsLdpSessionInLabelIfIndex.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionInLabelIfIndex.setDescription("The ifIndex of the 'mplsLdpSessionInLabel' which should have the same value as the 'mplsInSegmentIfIndex' in the LSR MIB.")
mplsLdpSessionInLabel = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 9, 1, 2), MplsLabel())
if mibBuilder.loadTexts: mplsLdpSessionInLabel.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionInLabel.setDescription("The incoming label of this LSP. This has the same value as the 'mplsInSegmentLabel' in the LSR MIB.")
mplsLdpSessionInLabelType = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 9, 1, 3), MplsLdpLabelTypes()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpSessionInLabelType.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionInLabelType.setDescription("The Layer 2 Label Type for 'mplsLdpInLabel'.")
mplsLdpSessionInLabelConnectionType = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 9, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("xconnect", 2), ("terminates", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpSessionInLabelConnectionType.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionInLabelConnectionType.setDescription('The type of LSP connection. The possible values are: unknown(1) -- this may be the value if the LSP is in a state of flux. It is considered to be a temporary situation. xconnect(2) -- if the mapping between the session and the insegment is associated with an LSP which is a true cross-connection. terminates(3) -- if the mapping between the session and the insegment is associated with an LSP which terminates on this LSR and is not a cross-connection.')
mplsLdpSessionOutLabelMapTable = MibTable((1, 3, 6, 1, 3, 97, 1, 3, 10), )
if mibBuilder.loadTexts: mplsLdpSessionOutLabelMapTable.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionOutLabelMapTable.setDescription("A table of Session's Egress Labels which are Mapped to the LSR MIB. Each row represents a single Egress Label.")
mplsLdpSessionOutLabelMapEntry = MibTableRow((1, 3, 6, 1, 3, 97, 1, 3, 10, 1), ).setIndexNames((0, "MPLS-LDP-MIB", "mplsLdpEntityLdpId"), (0, "MPLS-LDP-MIB", "mplsLdpEntityIndex"), (0, "MPLS-LDP-MIB", "mplsLdpPeerLdpId"), (0, "MPLS-LDP-MIB", "mplsLdpSessionOutLabelIfIndex"), (0, "MPLS-LDP-MIB", "mplsLdpSessionOutLabel"))
if mibBuilder.loadTexts: mplsLdpSessionOutLabelMapEntry.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionOutLabelMapEntry.setDescription('An entry in this table represents information on a single session between an LDP Entity and LDP Peer. The information contained in a row is read-only.')
mplsLdpSessionOutLabelIfIndex = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 10, 1, 1), InterfaceIndex())
if mibBuilder.loadTexts: mplsLdpSessionOutLabelIfIndex.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionOutLabelIfIndex.setDescription("The ifIndex of the 'mplsLdpSessionOutLabel'.")
mplsLdpSessionOutLabel = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 10, 1, 2), MplsLabel())
if mibBuilder.loadTexts: mplsLdpSessionOutLabel.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionOutLabel.setDescription('The outgoing label of this LSP.')
mplsLdpSessionOutLabelType = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 10, 1, 3), MplsLdpLabelTypes()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpSessionOutLabelType.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionOutLabelType.setDescription("The Layer 2 Label Type for 'mplsLdpOutLabel'.")
mplsLdpSessionOutLabelConnectionType = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("xconnect", 2), ("starts", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpSessionOutLabelConnectionType.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionOutLabelConnectionType.setDescription('The type of LSP connection. The possible values are: unknown(1) -- this may be the value if the LSP is in a state of flux. It is considered to be a temporary situation. xconnect(2) -- if the mapping between the session and the outsegment is associated with an LSP which is a true cross-connection. starts(3) -- if the mapping between the session and the insegment is associated with an LSP which starts on this LSR and is considered an ingress to the LSP.')
mplsLdpSessionOutSegmentIndex = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 10, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpSessionOutSegmentIndex.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionOutSegmentIndex.setDescription("This value should contain the same value as the 'mplsOutSegmentIndex' in the LSR MIB. NOTE: this value will never be zero, because this table only maps from Sessions to true outsegments.")
mplsLdpSessionXCMapTable = MibTable((1, 3, 6, 1, 3, 97, 1, 3, 11), )
if mibBuilder.loadTexts: mplsLdpSessionXCMapTable.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionXCMapTable.setDescription("A table of Session's Labels which are Mapped to the LSR MIB 's XConnect table. Each row represents a single cross connect.")
mplsLdpSessionXCMapEntry = MibTableRow((1, 3, 6, 1, 3, 97, 1, 3, 11, 1), ).setIndexNames((0, "MPLS-LDP-MIB", "mplsLdpEntityLdpId"), (0, "MPLS-LDP-MIB", "mplsLdpEntityIndex"), (0, "MPLS-LDP-MIB", "mplsLdpPeerLdpId"), (0, "MPLS-LDP-MIB", "mplsLdpSessionInLabelIfIndex"), (0, "MPLS-LDP-MIB", "mplsLdpSessionInLabel"), (0, "MPLS-LDP-MIB", "mplsLdpSessionOutLabelIfIndex"), (0, "MPLS-LDP-MIB", "mplsLdpSessionOutLabel"))
if mibBuilder.loadTexts: mplsLdpSessionXCMapEntry.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionXCMapEntry.setDescription('An entry in this table represents information on a single session between an LDP Entity and LDP Peer. The information contained in a row is read-only.')
mplsLdpSessionXCIndex = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 11, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpSessionXCIndex.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionXCIndex.setDescription("This value should contain the same value as the 'mplsXCIndex' in the LSR MIB. NOTE: this value will never be zero, because this table only maps from Sessions to true cross connects.")
mplsXCsFecsTable = MibTable((1, 3, 6, 1, 3, 97, 1, 3, 13), )
if mibBuilder.loadTexts: mplsXCsFecsTable.setStatus('current')
if mibBuilder.loadTexts: mplsXCsFecsTable.setDescription('A table which shows the relationship between cross-connects and FECs. Each row represents a single cross connect to FEC association. This table is read-only.')
mplsXCsFecsEntry = MibTableRow((1, 3, 6, 1, 3, 97, 1, 3, 13, 1), ).setIndexNames((0, "MPLS-LDP-MIB", "mplsLdpEntityLdpId"), (0, "MPLS-LDP-MIB", "mplsLdpEntityIndex"), (0, "MPLS-LDP-MIB", "mplsLdpPeerLdpId"), (0, "MPLS-LDP-MIB", "mplsLdpSessionInLabelIfIndex"), (0, "MPLS-LDP-MIB", "mplsLdpSessionInLabel"), (0, "MPLS-LDP-MIB", "mplsLdpSessionOutLabelIfIndex"), (0, "MPLS-LDP-MIB", "mplsLdpSessionOutLabel"), (0, "MPLS-LDP-MIB", "mplsFecIndex"))
if mibBuilder.loadTexts: mplsXCsFecsEntry.setStatus('current')
if mibBuilder.loadTexts: mplsXCsFecsEntry.setDescription('An entry represents a single cross connect to FEC association.')
mplsXCFecOperStatus = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("inUse", 2), ("notInUse", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsXCFecOperStatus.setStatus('current')
if mibBuilder.loadTexts: mplsXCFecOperStatus.setDescription('An indication of the operational status of the FEC associated with this cross connect. unknown(1) - this is a temporary state which may indicate the LSP-FEC association is in a state of transition. inUse(2) - the FEC associated with the XC is currently being applied. notInUse(3) - the FEC associated with the XC is not being applied. Eventually, this entry may be aged out.')
mplsXCFecOperStatusLastChange = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 13, 1, 2), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsXCFecOperStatusLastChange.setStatus('current')
if mibBuilder.loadTexts: mplsXCFecOperStatusLastChange.setDescription('This value of sysUpTime when the mplsXCFecOperStatus last changed state.')
mplsLdpSessionPeerAddressTable = MibTable((1, 3, 6, 1, 3, 97, 1, 3, 12), )
if mibBuilder.loadTexts: mplsLdpSessionPeerAddressTable.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionPeerAddressTable.setDescription("This table 'extends' the mplsLdpSessionTable. This table is used to store Label Address Information from Label Address Messages received by this LSR from Peers. This table is read-only and should be updated when Label Withdraw Address Messages are received, i.e. Rows should be deleted as apropriate. NOTE: since more than one address may be contained in a Label Address Message, this table 'extends', rather than 'AUGMENTS' the mplsLdpSessionTable's information.")
mplsLdpSessionPeerAddressEntry = MibTableRow((1, 3, 6, 1, 3, 97, 1, 3, 12, 1), ).setIndexNames((0, "MPLS-LDP-MIB", "mplsLdpEntityLdpId"), (0, "MPLS-LDP-MIB", "mplsLdpEntityIndex"), (0, "MPLS-LDP-MIB", "mplsLdpPeerLdpId"), (0, "MPLS-LDP-MIB", "mplsLdpSessionPeerAddressIndex"))
if mibBuilder.loadTexts: mplsLdpSessionPeerAddressEntry.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionPeerAddressEntry.setDescription("An entry in this table represents information on session's for a single next hop address which was advertised in an Address Message from the LDP peer. The information contained in a row is read-only.")
mplsLdpSessionPeerAddressIndex = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 12, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: mplsLdpSessionPeerAddressIndex.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionPeerAddressIndex.setDescription('An index which uniquely identifies this entry within a given session.')
mplsLdpSessionPeerNextHopAddressType = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 12, 1, 2), AddressFamilyNumbers()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpSessionPeerNextHopAddressType.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionPeerNextHopAddressType.setDescription('The internetwork layer address type of this Next Hop Address as specified in the Label Address Message associated with this Session. The value of this object indicates how to interpret the value of mplsLdpSessionPeerNextHopAddress.')
mplsLdpSessionPeerNextHopAddress = MibTableColumn((1, 3, 6, 1, 3, 97, 1, 3, 12, 1, 3), MplsLdpGenAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpSessionPeerNextHopAddress.setReference('LDP Specification [18] defines only IPv4 for LDP Protocol Version 1, see section 3.4.3.')
if mibBuilder.loadTexts: mplsLdpSessionPeerNextHopAddress.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionPeerNextHopAddress.setDescription('The value of the next hop address.')
mplsLdpNotificationPrefix = MibIdentifier((1, 3, 6, 1, 3, 97, 2, 0))
mplsLdpFailedInitSessionThresholdExceeded = NotificationType((1, 3, 6, 1, 3, 97, 2, 0, 1)).setObjects(("MPLS-LDP-MIB", "mplsLdpEntityFailedInitSessionThreshold"))
if mibBuilder.loadTexts: mplsLdpFailedInitSessionThresholdExceeded.setStatus('current')
if mibBuilder.loadTexts: mplsLdpFailedInitSessionThresholdExceeded.setDescription("This notification is generated when the value of the 'mplsLdpEntityFailedInitSessionTrapEnable' object is 'enabled(1)' and the value of the 'mplsLdpEntityFailedInitSessionThreshold' object has been exceeded.")
mplsLdpPathVectorLimitMismatch = NotificationType((1, 3, 6, 1, 3, 97, 2, 0, 2)).setObjects(("MPLS-LDP-MIB", "mplsLdpEntityPathVectorLimit"), ("MPLS-LDP-MIB", "mplsLdpPeerPathVectorLimit"))
if mibBuilder.loadTexts: mplsLdpPathVectorLimitMismatch.setStatus('current')
if mibBuilder.loadTexts: mplsLdpPathVectorLimitMismatch.setDescription("This notification is generated when the value of the value of the 'mplsLdpEntityFailedInitSessionTrapEnable' object is 'enabled(1)' and the 'mplsLdpEntityPathVectorLimit' does NOT match the value of the 'mplsLdpPeerPathVectorLimit' for a specific Entity.")
if mibBuilder.loadTexts: mplsLdpPathVectorLimitMismatch.setReference('LDP Specification, Section 3.5.3.')
mplsLdpSessionUp = NotificationType((1, 3, 6, 1, 3, 97, 2, 0, 3)).setObjects(("MPLS-LDP-MIB", "mplsLdpSessionState"))
if mibBuilder.loadTexts: mplsLdpSessionUp.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionUp.setDescription("Generation of this trap occurs when the 'mplsLdpSessionUpDownTrapEnable' object is 'enabled(1)' and the value of 'mplsLdpSessionState' changes from any state except 'nonexistent(1)' to 'operational(5)'.")
mplsLdpSessionDown = NotificationType((1, 3, 6, 1, 3, 97, 2, 0, 4)).setObjects(("MPLS-LDP-MIB", "mplsLdpSessionState"))
if mibBuilder.loadTexts: mplsLdpSessionDown.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionDown.setDescription("Generation of this trap occurs when the 'mplsLdpSessionUpDownTrapEnable' object is 'enabled(1)' and the value of 'mplsLdpSessionState' changes from 'operational(5)' to any other state.")
mplsLdpGroups = MibIdentifier((1, 3, 6, 1, 3, 97, 3, 1))
mplsLdpCompliances = MibIdentifier((1, 3, 6, 1, 3, 97, 3, 2))
mplsLdpModuleCompliance = ModuleCompliance((1, 3, 6, 1, 3, 97, 3, 2, 1)).setObjects(("MPLS-LDP-MIB", "mplsLdpGeneralGroup"), ("MPLS-LDP-MIB", "mplsLdpNotificationsGroup"), ("MPLS-LDP-MIB", "mplsLdpGenericGroup"), ("MPLS-LDP-MIB", "mplsLdpAtmGroup"), ("MPLS-LDP-MIB", "mplsLdpFrameRelayGroup"), ("MPLS-LDP-MIB", "mplsLdpMappingGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsLdpModuleCompliance = mplsLdpModuleCompliance.setStatus('current')
if mibBuilder.loadTexts: mplsLdpModuleCompliance.setDescription('The basic implentation requirements for agents that support the MPLS LDP MIB.')
mplsLdpGeneralGroup = ObjectGroup((1, 3, 6, 1, 3, 97, 3, 1, 1)).setObjects(("MPLS-LDP-MIB", "mplsLdpLsrId"), ("MPLS-LDP-MIB", "mplsLdpLsrLoopDetectionCapable"), ("MPLS-LDP-MIB", "mplsLdpEntityIndexNext"), ("MPLS-LDP-MIB", "mplsLdpEntityProtocolVersion"), ("MPLS-LDP-MIB", "mplsLdpEntityAdminStatus"), ("MPLS-LDP-MIB", "mplsLdpEntityOperStatus"), ("MPLS-LDP-MIB", "mplsLdpEntityWellKnownTcpDiscoveryPort"), ("MPLS-LDP-MIB", "mplsLdpEntityWellKnownUdpDiscoveryPort"), ("MPLS-LDP-MIB", "mplsLdpEntityMaxPduLength"), ("MPLS-LDP-MIB", "mplsLdpEntityKeepAliveHoldTimer"), ("MPLS-LDP-MIB", "mplsLdpEntityHelloHoldTimer"), ("MPLS-LDP-MIB", "mplsLdpEntityFailedInitSessionTrapEnable"), ("MPLS-LDP-MIB", "mplsLdpEntityFailedInitSessionThreshold"), ("MPLS-LDP-MIB", "mplsLdpEntityLabelDistributionMethod"), ("MPLS-LDP-MIB", "mplsLdpEntityLabelRetentionMode"), ("MPLS-LDP-MIB", "mplsLdpEntityPVLimitMismatchTrapEnable"), ("MPLS-LDP-MIB", "mplsLdpEntityPathVectorLimit"), ("MPLS-LDP-MIB", "mplsLdpEntityHopCountLimit"), ("MPLS-LDP-MIB", "mplsLdpEntityTargetedPeer"), ("MPLS-LDP-MIB", "mplsLdpEntityTargetedPeerAddrType"), ("MPLS-LDP-MIB", "mplsLdpEntityTargetedPeerAddr"), ("MPLS-LDP-MIB", "mplsLdpEntityOptionalParameters"), ("MPLS-LDP-MIB", "mplsLdpEntityDiscontinuityTime"), ("MPLS-LDP-MIB", "mplsLdpEntityStorageType"), ("MPLS-LDP-MIB", "mplsLdpEntityRowStatus"), ("MPLS-LDP-MIB", "mplsLdpAttemptedSessions"), ("MPLS-LDP-MIB", "mplsLdpSessionRejectedNoHelloErrors"), ("MPLS-LDP-MIB", "mplsLdpSessionRejectedAdvertisementErrors"), ("MPLS-LDP-MIB", "mplsLdpSessionRejectedMaxPduErrors"), ("MPLS-LDP-MIB", "mplsLdpSessionRejectedLabelRangeErrors"), ("MPLS-LDP-MIB", "mplsLdpBadLdpIdentifierErrors"), ("MPLS-LDP-MIB", "mplsLdpBadPduLengthErrors"), ("MPLS-LDP-MIB", "mplsLdpBadMessageLengthErrors"), ("MPLS-LDP-MIB", "mplsLdpBadTlvLengthErrors"), ("MPLS-LDP-MIB", "mplsLdpMalformedTlvValueErrors"), ("MPLS-LDP-MIB", "mplsLdpKeepAliveTimerExpiredErrors"), ("MPLS-LDP-MIB", "mplsLdpShutdownNotifReceived"), ("MPLS-LDP-MIB", "mplsLdpShutdownNotifSent"), ("MPLS-LDP-MIB", "mplsLdpPeerLabelDistributionMethod"), ("MPLS-LDP-MIB", "mplsLdpPeerLoopDetectionForPV"), ("MPLS-LDP-MIB", "mplsLdpPeerPathVectorLimit"), ("MPLS-LDP-MIB", "mplsLdpHelloAdjacencyHoldTimeRemaining"), ("MPLS-LDP-MIB", "mplsLdpHelloAdjacencyType"), ("MPLS-LDP-MIB", "mplsLdpSessionUpDownTrapEnable"), ("MPLS-LDP-MIB", "mplsLdpSessionState"), ("MPLS-LDP-MIB", "mplsLdpSessionProtocolVersion"), ("MPLS-LDP-MIB", "mplsLdpSessionKeepAliveHoldTimeRemaining"), ("MPLS-LDP-MIB", "mplsLdpSessionMaxPduLength"), ("MPLS-LDP-MIB", "mplsLdpSessionDiscontinuityTime"), ("MPLS-LDP-MIB", "mplsLdpSessionStatsUnknownMessageTypeErrors"), ("MPLS-LDP-MIB", "mplsLdpSessionStatsUnknownTlvErrors"), ("MPLS-LDP-MIB", "mplsLdpSessionPeerNextHopAddressType"), ("MPLS-LDP-MIB", "mplsLdpSessionPeerNextHopAddress"), ("MPLS-LDP-MIB", "mplsFecIndexNext"), ("MPLS-LDP-MIB", "mplsFecType"), ("MPLS-LDP-MIB", "mplsFecAddressFamily"), ("MPLS-LDP-MIB", "mplsFecAddressLength"), ("MPLS-LDP-MIB", "mplsFecAddress"), ("MPLS-LDP-MIB", "mplsFecStorageType"), ("MPLS-LDP-MIB", "mplsFecRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsLdpGeneralGroup = mplsLdpGeneralGroup.setStatus('current')
if mibBuilder.loadTexts: mplsLdpGeneralGroup.setDescription('Objects that apply to all MPLS LDP implementations.')
mplsLdpGenericGroup = ObjectGroup((1, 3, 6, 1, 3, 97, 3, 1, 2)).setObjects(("MPLS-LDP-MIB", "mplsLdpEntityConfGenericIfIndexOrZero"), ("MPLS-LDP-MIB", "mplsLdpEntityConfGenericLabelRangeStorageType"), ("MPLS-LDP-MIB", "mplsLdpEntityConfGenericLabelRangeRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsLdpGenericGroup = mplsLdpGenericGroup.setStatus('current')
if mibBuilder.loadTexts: mplsLdpGenericGroup.setDescription('Objects that apply to all MPLS LDP implementations using Generic Lables.')
mplsLdpAtmGroup = ObjectGroup((1, 3, 6, 1, 3, 97, 3, 1, 3)).setObjects(("MPLS-LDP-MIB", "mplsLdpEntityAtmIfIndexOrZero"), ("MPLS-LDP-MIB", "mplsLdpEntityAtmMergeCap"), ("MPLS-LDP-MIB", "mplsLdpEntityAtmLabelRangeComponents"), ("MPLS-LDP-MIB", "mplsLdpEntityAtmVcDirectionality"), ("MPLS-LDP-MIB", "mplsLdpEntityAtmLsrConnectivity"), ("MPLS-LDP-MIB", "mplsLdpEntityDefaultControlVpi"), ("MPLS-LDP-MIB", "mplsLdpEntityDefaultControlVci"), ("MPLS-LDP-MIB", "mplsLdpEntityUnlabTrafVpi"), ("MPLS-LDP-MIB", "mplsLdpEntityUnlabTrafVci"), ("MPLS-LDP-MIB", "mplsLdpEntityAtmStorageType"), ("MPLS-LDP-MIB", "mplsLdpEntityAtmRowStatus"), ("MPLS-LDP-MIB", "mplsLdpEntityConfAtmLabelRangeMaximumVpi"), ("MPLS-LDP-MIB", "mplsLdpEntityConfAtmLabelRangeMaximumVci"), ("MPLS-LDP-MIB", "mplsLdpEntityConfAtmLabelRangeStorageType"), ("MPLS-LDP-MIB", "mplsLdpEntityConfAtmLabelRangeRowStatus"), ("MPLS-LDP-MIB", "mplsLdpSessionAtmLabelRangeUpperBoundVpi"), ("MPLS-LDP-MIB", "mplsLdpSessionAtmLabelRangeUpperBoundVci"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsLdpAtmGroup = mplsLdpAtmGroup.setStatus('current')
if mibBuilder.loadTexts: mplsLdpAtmGroup.setDescription('Objects that apply to all MPLS LDP implementations over ATM.')
mplsLdpFrameRelayGroup = ObjectGroup((1, 3, 6, 1, 3, 97, 3, 1, 4)).setObjects(("MPLS-LDP-MIB", "mplsLdpEntityFrIfIndexOrZero"), ("MPLS-LDP-MIB", "mplsLdpEntityFrMergeCap"), ("MPLS-LDP-MIB", "mplsLdpEntityFrLabelRangeComponents"), ("MPLS-LDP-MIB", "mplsLdpEntityFrLen"), ("MPLS-LDP-MIB", "mplsLdpEntityFrVcDirectionality"), ("MPLS-LDP-MIB", "mplsLdpEntityFrParmsStorageType"), ("MPLS-LDP-MIB", "mplsLdpEntityFrParmsRowStatus"), ("MPLS-LDP-MIB", "mplsLdpConfFrMaximumDlci"), ("MPLS-LDP-MIB", "mplsLdpConfFrStorageType"), ("MPLS-LDP-MIB", "mplsLdpConfFrRowStatus"), ("MPLS-LDP-MIB", "mplsLdpFrSessionMaxDlci"), ("MPLS-LDP-MIB", "mplsLdpFrSessionLen"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsLdpFrameRelayGroup = mplsLdpFrameRelayGroup.setStatus('current')
if mibBuilder.loadTexts: mplsLdpFrameRelayGroup.setDescription('Objects that apply to all MPLS LDP implementations over Frame Relay.')
mplsLdpMappingGroup = ObjectGroup((1, 3, 6, 1, 3, 97, 3, 1, 5)).setObjects(("MPLS-LDP-MIB", "mplsLdpSessionInLabelType"), ("MPLS-LDP-MIB", "mplsLdpSessionInLabelConnectionType"), ("MPLS-LDP-MIB", "mplsLdpSessionOutLabelType"), ("MPLS-LDP-MIB", "mplsLdpSessionOutLabelConnectionType"), ("MPLS-LDP-MIB", "mplsLdpSessionOutSegmentIndex"), ("MPLS-LDP-MIB", "mplsLdpSessionXCIndex"), ("MPLS-LDP-MIB", "mplsXCFecOperStatus"), ("MPLS-LDP-MIB", "mplsXCFecOperStatusLastChange"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsLdpMappingGroup = mplsLdpMappingGroup.setStatus('current')
if mibBuilder.loadTexts: mplsLdpMappingGroup.setDescription('These objects are optional and only need to be supported for LDP implementations which support the tables, mplsInSegmentTable, mplsOutSegmentTable and mplsXCTable, in the LSR MIB.')
mplsLdpNotificationsGroup = NotificationGroup((1, 3, 6, 1, 3, 97, 3, 1, 6)).setObjects(("MPLS-LDP-MIB", "mplsLdpFailedInitSessionThresholdExceeded"), ("MPLS-LDP-MIB", "mplsLdpPathVectorLimitMismatch"), ("MPLS-LDP-MIB", "mplsLdpSessionUp"), ("MPLS-LDP-MIB", "mplsLdpSessionDown"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsLdpNotificationsGroup = mplsLdpNotificationsGroup.setStatus('current')
if mibBuilder.loadTexts: mplsLdpNotificationsGroup.setDescription('The notification(s) which an MPLS LDP implemention is required to implement.')
mibBuilder.exportSymbols("MPLS-LDP-MIB", mplsLdpEntityLabelDistributionMethod=mplsLdpEntityLabelDistributionMethod, MplsLdpLabelTypes=MplsLdpLabelTypes, mplsLdpEntityHelloHoldTimer=mplsLdpEntityHelloHoldTimer, mplsLdpEntityMaxPduLength=mplsLdpEntityMaxPduLength, mplsLdpSessionObjects=mplsLdpSessionObjects, mplsFecObjects=mplsFecObjects, mplsLdpEntityFailedInitSessionThreshold=mplsLdpEntityFailedInitSessionThreshold, mplsLdpModuleCompliance=mplsLdpModuleCompliance, mplsLdpEntityConfAtmLabelRangeEntry=mplsLdpEntityConfAtmLabelRangeEntry, mplsLdpEntityAtmParmsTable=mplsLdpEntityAtmParmsTable, mplsLdpSessionStatsUnknownMessageTypeErrors=mplsLdpSessionStatsUnknownMessageTypeErrors, mplsLdpSessionInLabel=mplsLdpSessionInLabel, mplsLdpEntityFrLabelRangeComponents=mplsLdpEntityFrLabelRangeComponents, mplsLdpEntityFrLen=mplsLdpEntityFrLen, mplsLdpSessionOutLabelConnectionType=mplsLdpSessionOutLabelConnectionType, mplsLdpSessionXCMapTable=mplsLdpSessionXCMapTable, mplsLdpEntityProtocolVersion=mplsLdpEntityProtocolVersion, mplsLdpEntityConfAtmLabelRangeMinimumVpi=mplsLdpEntityConfAtmLabelRangeMinimumVpi, mplsLdpSessionOutLabelMapEntry=mplsLdpSessionOutLabelMapEntry, mplsLdpFrameRelaySessionTable=mplsLdpFrameRelaySessionTable, mplsLdpEntityFrameRelayParmsEntry=mplsLdpEntityFrameRelayParmsEntry, mplsLdpSessionPeerNextHopAddress=mplsLdpSessionPeerNextHopAddress, mplsLdpEntityAtmStorageType=mplsLdpEntityAtmStorageType, mplsLdpFrameRelayGroup=mplsLdpFrameRelayGroup, mplsLdpEntityConfGenericIfIndexOrZero=mplsLdpEntityConfGenericIfIndexOrZero, mplsLdpMappingGroup=mplsLdpMappingGroup, mplsLdpEntityFrParmsStorageType=mplsLdpEntityFrParmsStorageType, mplsLdpEntityOperStatus=mplsLdpEntityOperStatus, mplsLdpEntityLabelRetentionMode=mplsLdpEntityLabelRetentionMode, mplsLdpCompliances=mplsLdpCompliances, mplsLdpFrameRelaySessionEntry=mplsLdpFrameRelaySessionEntry, mplsLdpConfFrRowStatus=mplsLdpConfFrRowStatus, mplsLdpEntityRowStatus=mplsLdpEntityRowStatus, mplsLdpEntityConfGenericLabelRangeMinimum=mplsLdpEntityConfGenericLabelRangeMinimum, mplsLdpSessionAtmLabelRangeLowerBoundVpi=mplsLdpSessionAtmLabelRangeLowerBoundVpi, MplsLdpGenAddr=MplsLdpGenAddr, mplsLdpEntityPathVectorLimit=mplsLdpEntityPathVectorLimit, mplsLdpEntityStatsTable=mplsLdpEntityStatsTable, mplsLdpSessionOutLabelIfIndex=mplsLdpSessionOutLabelIfIndex, mplsLdpLsrObjects=mplsLdpLsrObjects, mplsLdpSessionInLabelMapEntry=mplsLdpSessionInLabelMapEntry, mplsLdpEntityConfAtmLabelRangeRowStatus=mplsLdpEntityConfAtmLabelRangeRowStatus, mplsLdpEntityTargetedPeerAddrType=mplsLdpEntityTargetedPeerAddrType, mplsLdpPathVectorLimitMismatch=mplsLdpPathVectorLimitMismatch, mplsLdpLsrLoopDetectionCapable=mplsLdpLsrLoopDetectionCapable, mplsLdpSessionKeepAliveHoldTimeRemaining=mplsLdpSessionKeepAliveHoldTimeRemaining, mplsLdpPeerEntry=mplsLdpPeerEntry, mplsLdpGeneralGroup=mplsLdpGeneralGroup, mplsLdpSessionUpDownTrapEnable=mplsLdpSessionUpDownTrapEnable, mplsLdpEntityEntry=mplsLdpEntityEntry, mplsLdpHelloAdjacencyIndex=mplsLdpHelloAdjacencyIndex, mplsLdpAttemptedSessions=mplsLdpAttemptedSessions, mplsLdpSessionProtocolVersion=mplsLdpSessionProtocolVersion, mplsLdpEntityAtmRowStatus=mplsLdpEntityAtmRowStatus, mplsLdpFrSessionMinDlci=mplsLdpFrSessionMinDlci, mplsLdpEntityIndex=mplsLdpEntityIndex, mplsLdpEntityConfGenericLabelRangeMaximum=mplsLdpEntityConfGenericLabelRangeMaximum, mplsXCsFecsEntry=mplsXCsFecsEntry, mplsLdpEntityTargetedPeer=mplsLdpEntityTargetedPeer, mplsLdpShutdownNotifReceived=mplsLdpShutdownNotifReceived, mplsFecAddressLength=mplsFecAddressLength, mplsLdpEntityStatsEntry=mplsLdpEntityStatsEntry, mplsLdpSessionDown=mplsLdpSessionDown, mplsLdpEntityWellKnownUdpDiscoveryPort=mplsLdpEntityWellKnownUdpDiscoveryPort, mplsLdpSessionRejectedMaxPduErrors=mplsLdpSessionRejectedMaxPduErrors, mplsLdpSessionPeerAddressIndex=mplsLdpSessionPeerAddressIndex, mplsLdpSessionOutSegmentIndex=mplsLdpSessionOutSegmentIndex, mplsLdpNotificationsGroup=mplsLdpNotificationsGroup, mplsLdpSessionAtmLabelRangeUpperBoundVci=mplsLdpSessionAtmLabelRangeUpperBoundVci, mplsLdpPeerLoopDetectionForPV=mplsLdpPeerLoopDetectionForPV, mplsLdpSessionMaxPduLength=mplsLdpSessionMaxPduLength, mplsLdpEntityDefaultControlVci=mplsLdpEntityDefaultControlVci, mplsLdpSessionOutLabel=mplsLdpSessionOutLabel, mplsLdpAtmGroup=mplsLdpAtmGroup, mplsLdpSessionStatsTable=mplsLdpSessionStatsTable, mplsLdpBadTlvLengthErrors=mplsLdpBadTlvLengthErrors, mplsLdpSessionInLabelMapTable=mplsLdpSessionInLabelMapTable, PYSNMP_MODULE_ID=mplsLdpMIB, mplsLdpEntityAtmObjects=mplsLdpEntityAtmObjects, mplsLdpPeerLabelDistributionMethod=mplsLdpPeerLabelDistributionMethod, mplsLdpSessionAtmLabelRangeUpperBoundVpi=mplsLdpSessionAtmLabelRangeUpperBoundVpi, mplsLdpSessionPeerAddressTable=mplsLdpSessionPeerAddressTable, mplsLdpEntityFrMergeCap=mplsLdpEntityFrMergeCap, mplsLdpFrSessionLen=mplsLdpFrSessionLen, mplsLdpSessionInLabelConnectionType=mplsLdpSessionInLabelConnectionType, mplsLdpAtmSessionEntry=mplsLdpAtmSessionEntry, mplsLdpSessionPeerAddressEntry=mplsLdpSessionPeerAddressEntry, mplsLdpEntityConfAtmLabelRangeMaximumVpi=mplsLdpEntityConfAtmLabelRangeMaximumVpi, mplsLdpSessionInLabelIfIndex=mplsLdpSessionInLabelIfIndex, mplsLdpConformance=mplsLdpConformance, mplsLdpConfFrStorageType=mplsLdpConfFrStorageType, mplsLdpSessionOutLabelMapTable=mplsLdpSessionOutLabelMapTable, mplsLdpPeerPathVectorLimit=mplsLdpPeerPathVectorLimit, mplsFecAddress=mplsFecAddress, mplsLdpLsrId=mplsLdpLsrId, mplsLdpSessionXCIndex=mplsLdpSessionXCIndex, mplsLdpEntityAtmLsrConnectivity=mplsLdpEntityAtmLsrConnectivity, mplsLdpEntityConfAtmLabelRangeTable=mplsLdpEntityConfAtmLabelRangeTable, mplsLdpEntityFrameRelayParmsTable=mplsLdpEntityFrameRelayParmsTable, mplsLdpMIB=mplsLdpMIB, mplsLdpEntityFrParmsRowStatus=mplsLdpEntityFrParmsRowStatus, mplsLdpBadPduLengthErrors=mplsLdpBadPduLengthErrors, mplsLdpPeerTable=mplsLdpPeerTable, mplsLdpSessionPeerNextHopAddressType=mplsLdpSessionPeerNextHopAddressType, mplsLdpEntityConfGenericLabelRangeTable=mplsLdpEntityConfGenericLabelRangeTable, mplsLdpGroups=mplsLdpGroups, mplsLdpEntityFrVcDirectionality=mplsLdpEntityFrVcDirectionality, mplsLdpEntityConfAtmLabelRangeMaximumVci=mplsLdpEntityConfAtmLabelRangeMaximumVci, mplsXCsFecsTable=mplsXCsFecsTable, mplsLdpHelloAdjacencyObjects=mplsLdpHelloAdjacencyObjects, mplsLdpFrSessionMaxDlci=mplsLdpFrSessionMaxDlci, mplsLdpEntityConfAtmLabelRangeStorageType=mplsLdpEntityConfAtmLabelRangeStorageType, mplsLdpSessionRejectedAdvertisementErrors=mplsLdpSessionRejectedAdvertisementErrors, mplsLdpEntityAtmMergeCap=mplsLdpEntityAtmMergeCap, mplsLdpSessionDiscontinuityTime=mplsLdpSessionDiscontinuityTime, mplsLdpSessionXCMapEntry=mplsLdpSessionXCMapEntry, mplsLdpSessionUp=mplsLdpSessionUp, mplsLdpEntityConfGenericLabelRangeRowStatus=mplsLdpEntityConfGenericLabelRangeRowStatus, mplsXCFecOperStatus=mplsXCFecOperStatus, MplsAtmVcIdentifier=MplsAtmVcIdentifier, mplsLdpObjects=mplsLdpObjects, mplsLdpKeepAliveTimerExpiredErrors=mplsLdpKeepAliveTimerExpiredErrors, mplsLdpEntityIndexNext=mplsLdpEntityIndexNext, mplsFecIndexNext=mplsFecIndexNext, mplsLdpEntityUnlabTrafVci=mplsLdpEntityUnlabTrafVci, mplsLdpHelloAdjacencyType=mplsLdpHelloAdjacencyType, mplsLdpSessionRejectedNoHelloErrors=mplsLdpSessionRejectedNoHelloErrors, mplsLdpBadMessageLengthErrors=mplsLdpBadMessageLengthErrors, mplsLdpSessionAtmLabelRangeLowerBoundVci=mplsLdpSessionAtmLabelRangeLowerBoundVci, mplsLdpSessionRejectedLabelRangeErrors=mplsLdpSessionRejectedLabelRangeErrors, mplsLdpSessionTable=mplsLdpSessionTable, mplsLdpEntityFrIfIndexOrZero=mplsLdpEntityFrIfIndexOrZero, mplsLdpEntityConfGenericLabelRangeStorageType=mplsLdpEntityConfGenericLabelRangeStorageType, mplsLdpAtmSessionTable=mplsLdpAtmSessionTable, mplsLdpEntityUnlabTrafVpi=mplsLdpEntityUnlabTrafVpi, mplsLdpEntityTable=mplsLdpEntityTable, mplsLdpEntityConfAtmLabelRangeMinimumVci=mplsLdpEntityConfAtmLabelRangeMinimumVci, mplsLdpEntityStorageType=mplsLdpEntityStorageType, mplsLdpEntityObjects=mplsLdpEntityObjects, mplsLdpEntityConfFrLabelRangeEntry=mplsLdpEntityConfFrLabelRangeEntry, mplsFecAddressFamily=mplsFecAddressFamily, mplsLdpMalformedTlvValueErrors=mplsLdpMalformedTlvValueErrors, mplsLdpHelloAdjacencyHoldTimeRemaining=mplsLdpHelloAdjacencyHoldTimeRemaining, mplsLdpSessionInLabelType=mplsLdpSessionInLabelType, mplsLdpSessionOutLabelType=mplsLdpSessionOutLabelType, mplsLdpBadLdpIdentifierErrors=mplsLdpBadLdpIdentifierErrors, mplsLdpEntityWellKnownTcpDiscoveryPort=mplsLdpEntityWellKnownTcpDiscoveryPort, mplsXCFecOperStatusLastChange=mplsXCFecOperStatusLastChange, mplsFecTable=mplsFecTable, mplsLdpNotificationPrefix=mplsLdpNotificationPrefix, mplsLdpEntityOptionalParameters=mplsLdpEntityOptionalParameters, mplsLdpEntityAdminStatus=mplsLdpEntityAdminStatus, MplsLabel=MplsLabel, mplsLdpEntityKeepAliveHoldTimer=mplsLdpEntityKeepAliveHoldTimer, mplsLdpConfFrMinimumDlci=mplsLdpConfFrMinimumDlci, mplsLdpEntityAtmParmsEntry=mplsLdpEntityAtmParmsEntry, mplsLdpPeerLdpId=mplsLdpPeerLdpId, MplsLsrIdentifier=MplsLsrIdentifier, mplsLdpEntityAtmLabelRangeComponents=mplsLdpEntityAtmLabelRangeComponents, mplsLdpShutdownNotifSent=mplsLdpShutdownNotifSent, mplsLdpSessionEntry=mplsLdpSessionEntry, mplsFecType=mplsFecType, mplsFecRowStatus=mplsFecRowStatus, mplsLdpEntityPVLimitMismatchTrapEnable=mplsLdpEntityPVLimitMismatchTrapEnable, mplsLdpHelloAdjacencyEntry=mplsLdpHelloAdjacencyEntry, mplsFecEntry=mplsFecEntry, MplsLdpIdentifier=MplsLdpIdentifier, mplsLdpHelloAdjacencyTable=mplsLdpHelloAdjacencyTable, mplsFecIndex=mplsFecIndex, mplsLdpEntityTargetedPeerAddr=mplsLdpEntityTargetedPeerAddr, mplsLdpEntityDefaultControlVpi=mplsLdpEntityDefaultControlVpi, mplsLdpGenericGroup=mplsLdpGenericGroup, mplsFecStorageType=mplsFecStorageType, mplsLdpEntityFailedInitSessionTrapEnable=mplsLdpEntityFailedInitSessionTrapEnable, mplsLdpEntityFrameRelayObjects=mplsLdpEntityFrameRelayObjects, mplsLdpNotifications=mplsLdpNotifications, mplsLdpEntityConfFrLabelRangeTable=mplsLdpEntityConfFrLabelRangeTable, mplsLdpEntityAtmVcDirectionality=mplsLdpEntityAtmVcDirectionality, mplsLdpEntityDiscontinuityTime=mplsLdpEntityDiscontinuityTime, mplsLdpEntityGenericObjects=mplsLdpEntityGenericObjects, mplsLdpEntityAtmIfIndexOrZero=mplsLdpEntityAtmIfIndexOrZero, mplsLdpFailedInitSessionThresholdExceeded=mplsLdpFailedInitSessionThresholdExceeded, mplsLdpSessionState=mplsLdpSessionState, mplsLdpEntityConfGenericLabelRangeEntry=mplsLdpEntityConfGenericLabelRangeEntry, mplsLdpSessionStatsEntry=mplsLdpSessionStatsEntry, mplsLdpSessionStatsUnknownTlvErrors=mplsLdpSessionStatsUnknownTlvErrors, mplsLdpConfFrMaximumDlci=mplsLdpConfFrMaximumDlci, mplsLdpEntityHopCountLimit=mplsLdpEntityHopCountLimit, mplsLdpEntityLdpId=mplsLdpEntityLdpId)

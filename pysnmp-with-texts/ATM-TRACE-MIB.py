#
# PySNMP MIB module ATM-TRACE-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/ATM-TRACE-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:31:27 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ConstraintsIntersection, ValueRangeConstraint, SingleValueConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ConstraintsIntersection", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsUnion")
NetworkEntityNetworkServiceCategory, ResourcePartitionNetworkServiceCategory, PolicyConstraintIndex = mibBuilder.importSymbols("ATM-POLICY-CONSTRAINT-MIB", "NetworkEntityNetworkServiceCategory", "ResourcePartitionNetworkServiceCategory", "PolicyConstraintIndex")
AtmAddr, AtmVpIdentifier, AtmTrafficDescrParamIndex, AtmConnCastType, AtmVcIdentifier, AtmServiceCategory, AtmConnKind = mibBuilder.importSymbols("ATM-TC-MIB", "AtmAddr", "AtmVpIdentifier", "AtmTrafficDescrParamIndex", "AtmConnCastType", "AtmVcIdentifier", "AtmServiceCategory", "AtmConnKind")
InterfaceIndexOrZero, InterfaceIndex = mibBuilder.importSymbols("IF-MIB", "InterfaceIndexOrZero", "InterfaceIndex")
MplsLabel, = mibBuilder.importSymbols("MPLS-TC-STD-MIB", "MplsLabel")
pnniIfEntry, PnniNodeId, PnniPortId = mibBuilder.importSymbols("PNNI-MIB", "pnniIfEntry", "PnniNodeId", "PnniPortId")
NotificationGroup, ObjectGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ObjectGroup", "ModuleCompliance")
IpAddress, MibIdentifier, iso, Bits, Unsigned32, Counter64, Counter32, Gauge32, ObjectIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, Integer32, TimeTicks, enterprises, ModuleIdentity, NotificationType = mibBuilder.importSymbols("SNMPv2-SMI", "IpAddress", "MibIdentifier", "iso", "Bits", "Unsigned32", "Counter64", "Counter32", "Gauge32", "ObjectIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Integer32", "TimeTicks", "enterprises", "ModuleIdentity", "NotificationType")
TextualConvention, TruthValue, RowStatus, DisplayString, TimeStamp = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "TruthValue", "RowStatus", "DisplayString", "TimeStamp")
atmTraceMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1))
atmTraceMIB.setRevisions(('2004-02-06 12:00', '1900-02-22 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: atmTraceMIB.setRevisionsDescriptions(('Addition of objects to support tracing of Policy Routing and ATM-MPLS Network Interworking related information.', 'Initial version of the MIB for ATM path and connection trace.',))
if mibBuilder.loadTexts: atmTraceMIB.setLastUpdated('200402061200Z')
if mibBuilder.loadTexts: atmTraceMIB.setOrganization('The ATM Forum.')
if mibBuilder.loadTexts: atmTraceMIB.setContactInfo('The ATM Forum 2570 West El Camino Real, Suite 304 Mountain View, CA 94040-1313 USA Phone: +1 650-949-6700 Fax: +1 415-949-6705 info@atmforum.com')
if mibBuilder.loadTexts: atmTraceMIB.setDescription('The MIB module for ATM path and connection trace.')
atmForum = MibIdentifier((1, 3, 6, 1, 4, 1, 353))
atmForumNetworkManagement = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5))
atmfSignalling = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 9))
atmfTrace = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 9, 2))
atmTraceMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1))
class CallReference(TextualConvention, Integer32):
    reference = 'ITU-T Recommendation Q.2931 Section 4.3'
    description = "The 24-bit Call Reference used by signalling to identify a connection. The Call Reference is structured in two parts. The most significant bit represents the Call Reference Flag and the 23 least significant bits represent the Call Reference Value. For the same call, the Call Reference Value is identical on both sides of an interface while the Call Reference Flag is different. For the side originating the Call Reference, the Call Reference Flag is set to '0' while it is set to '1' for the side not originating the Call Reference. The distinguished value zero indicates that no Call Reference value was returned in the trace transit list."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 16777215)

class AtmEndPointReference(TextualConvention, Integer32):
    reference = 'ITU-T Recommendation Q.2971 Section 8.2.1, ATM Forum PNNI v1.0 Addendum (Soft PVC MIB), af-pnni-0066.000'
    description = "For point-to-multipoint SVCs and the switched connection legs of point-to-multipoint Soft PVCs, the 16-bit Endpoint Reference used by signalling to identify a leaf of the point-to-multipoint connection. The Endpoint Reference is structured in two parts. The most significant bit represents the Endpoint Reference Flag and the 15 least significant bits represent the Endpoint Reference Value. For the same call and leaf, the Endpoint Reference Value is identical on both sides of an interface while the Endpoint Reference Flag is different. For the side originating the endpoint reference, the Endpoint Reference Flag is set to '0' while it is set to '1' for the side not originating the Endpoint Reference. For the permanent connection legs at the root of point-to-multipoint Soft PVCs, the value used to identify a leaf in the atmSoftPVccLeafReference object or the atmSoftPVpcLeafReference object from the ATM-SOFT-PVC-MIB. For the permanent connection legs at the leaf end of point-to-multipoint Soft PVCs, the value 1 shall be used (consistent with the values used for atmSoftPVccLeafReference and atmSoftPVpcLeafReference in the ATM-SOFT-PVC-MIB). The distinguished value -1 indicates that no Endpoint Reference value was returned in the Trace transit list."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(-1, 65535)

class AtmTraceRecordIndex(TextualConvention, Integer32):
    description = 'The value of this object identifies a row in the atmTraceRecordTable. The distinguished value zero signifies that no row has been identified.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 2147483647)

class AtmTraceOwnerString(TextualConvention, OctetString):
    description = "This data type is used to model an administratively assigned name of the owner of a resource. This information is taken from the NVT ASCII character set. It is suggested that this name contain one or more of the following: ASCII form of the manager station's transport address, management station name (e.g., domain name), network management personnel's name, location, or phone number. In some cases the agent itself will be the owner of an entry. In these cases, this string shall be set to a string starting with 'monitor'. SNMP access control is articulated entirely in terms of the contents of MIB views; access to a particular SNMP object instance depends only upon its presence or absence in a particular MIB view and never upon its value or the value of related object instances. Thus, objects of this type afford resolution of resource contention only among cooperating managers; they realize no access control function with respect to uncooperative parties."
    status = 'current'
    displayHint = '255a'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 127)

atmTraceBaseGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 1))
atmTraceFilterControl = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmTraceFilterControl.setStatus('current')
if mibBuilder.loadTexts: atmTraceFilterControl.setDescription("This object enables or disables the path trace filtering feature in the ATM device. When this object is modified from 'enable' to 'disable' the records in the atmTraceRecordTable are not removed but filtering is stopped in the device.")
atmTraceMaxConcurrentRequests = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmTraceMaxConcurrentRequests.setStatus('current')
if mibBuilder.loadTexts: atmTraceMaxConcurrentRequests.setDescription('The maximum number of concurrent active path or connection trace requests (i.e., connections or parties for which trace information gathering has been initiated, but for which no reply has been received yet) that are allowed by the agent. A value of 0 for this object implies that there is no limit on the number of concurrent active requests.')
atmTraceAvailableRequests = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTraceAvailableRequests.setStatus('current')
if mibBuilder.loadTexts: atmTraceAvailableRequests.setDescription('The number of new path or connection trace requests that can be initiated on the agent at this moment in time. This is equal to the maximum number of concurrent active path or connection trace requests that are allowed by the agent (i.e., atmTraceMaxConcurrentRequests), minus the current number of active path or connection trace requests.')
atmTraceTransitListMaximumSize = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1466, 65535)).clone(1466)).setUnits('octets').setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmTraceTransitListMaximumSize.setStatus('current')
if mibBuilder.loadTexts: atmTraceTransitListMaximumSize.setDescription('The maximum size in octets of the Trace transit list information element generated in any signalling message.')
atmTraceConnGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 2))
atmTraceConnTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 2, 1), )
if mibBuilder.loadTexts: atmTraceConnTable.setStatus('current')
if mibBuilder.loadTexts: atmTraceConnTable.setDescription('The table whose entries describe existing connections and parties to be traced or in the process of being traced.')
atmTraceConnEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 2, 1, 1), ).setIndexNames((0, "ATM-TRACE-MIB", "atmTraceConnIndex"))
if mibBuilder.loadTexts: atmTraceConnEntry.setStatus('current')
if mibBuilder.loadTexts: atmTraceConnEntry.setDescription('Each entry in this table specifies an existing connection or party to be traced, in the process of being traced, or that has recently been traced. The results of the connection trace are returned in the atmTraceRecordTable and the atmTraceInfoTable. A management station wishing to create an entry should first create the associated instance of the row status and row owner objects, using a value of atmTraceConnIndex that is not currently in use. It must also, either in the same or in successive PDUs, create the associated instance of the objects that identify the connection to be traced. It should also modify the default values for the other configuration objects if the defaults are not appropriate. Once the appropriate instances of all the configuration objects have been created, either by an explicit SNMP set request or by default, the row status should be set to active to initiate the request. Note that this entire procedure may be initiated via a single set request which specifies a row status of createAndGo as well as specifies valid values for the non-defaulted configuration objects. After the connection trace completes, the management station should retrieve the values of the status objects of interest from the atmTraceRecordTable, and should then delete the entry. In order to prevent old entries from clogging the table, entries will be aged out, but an entry will not be deleted within 5 minutes of the last activity.')
atmTraceConnIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 2, 1, 1, 1), Integer32())
if mibBuilder.loadTexts: atmTraceConnIndex.setStatus('current')
if mibBuilder.loadTexts: atmTraceConnIndex.setDescription('An arbitrary integer uniquely identifying a connection trace request.')
atmTraceConnOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 2, 1, 1, 2), AtmTraceOwnerString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTraceConnOwner.setStatus('current')
if mibBuilder.loadTexts: atmTraceConnOwner.setDescription('The entity that configured this entry.')
atmTraceConnTraceSourceIf = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 2, 1, 1, 3), InterfaceIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTraceConnTraceSourceIf.setStatus('current')
if mibBuilder.loadTexts: atmTraceConnTraceSourceIf.setDescription('The interface at which the connection trace is originated. This object must be specified.')
atmTraceConnOrigConnType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("atmVcc", 2), ("atmVpc", 3), ("atmCOBISigConn", 4), ("frameRelayVc", 5))).clone('atmVcc')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTraceConnOrigConnType.setStatus('current')
if mibBuilder.loadTexts: atmTraceConnOrigConnType.setDescription('The type of connection at the trace source interface.')
atmTraceConnOrigVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 2, 1, 1, 5), AtmVpIdentifier()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTraceConnOrigVpi.setStatus('current')
if mibBuilder.loadTexts: atmTraceConnOrigVpi.setDescription("Indicates the VPI value of the existing connection on the trace source interface. This object only applies when atmTraceConnOrigConnType is set to 'atmVcc' or 'atmVpc'. When this is the case, either this object or atmTraceConnCallRef must be specified. When the atmTraceConnCallRef object is specified, this object may not be set.")
atmTraceConnOrigVci = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 2, 1, 1, 6), AtmVcIdentifier()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTraceConnOrigVci.setStatus('current')
if mibBuilder.loadTexts: atmTraceConnOrigVci.setDescription("Indicates the VCI value of the existing connection on the trace source interface. This object only applies when atmTraceConnOrigConnType is set to 'atmVcc'. When this is the case, either this object or atmTraceConnCallRef must be specified. When the atmTraceConnCallRef object is specified, this object may not be set.")
atmTraceConnEndPtRef = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 2, 1, 1, 7), AtmEndPointReference()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTraceConnEndPtRef.setStatus('current')
if mibBuilder.loadTexts: atmTraceConnEndPtRef.setDescription('The Endpoint Reference value identifying a leaf of an existing point-to-multipoint connection. This object does not apply when the connection is not a point- to-multipoint connection.')
atmTraceConnCallRef = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 2, 1, 1, 8), CallReference()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTraceConnCallRef.setStatus('current')
if mibBuilder.loadTexts: atmTraceConnCallRef.setDescription('Indicates the call reference value of the existing connection on the trace source interface. For CO-BI connections, the value of this object must be specified. For other types of connections, either this object or the connection identifier objects (atmTraceConnOrigVpi, atmTraceConnOrigVpi and atmTraceConnOrigVci, or atmTraceConnOrigDlci, as appropriate for the connection type) must be specified. When any of atmTraceConnOrigVpi, atmTraceConnOrigVci, or atmTraceConnOrigDlci are specified, this object may not be set.')
atmTraceConnOrigDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 2, 1, 1, 9), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTraceConnOrigDlci.setStatus('current')
if mibBuilder.loadTexts: atmTraceConnOrigDlci.setDescription("Indicates the DLCI value of the existing connection on the trace source interface. This object only applies when atmTraceConnOrigConnType is set to 'frameRelayVc'. When this is the case, either this object or atmTraceConnCallRef must be specified. When the atmTraceConnCallRef object is specified, this object may not be set.")
atmTraceConnOrigDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("incoming", 1), ("outgoing", 2))).clone('incoming')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTraceConnOrigDirection.setStatus('current')
if mibBuilder.loadTexts: atmTraceConnOrigDirection.setDescription('Indicates whether the connection trace is to proceed in the incoming direction from the trace source interface, or in the outgoing direction from the trace source interface.')
atmTraceConnTraceConnId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 2, 1, 1, 11), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTraceConnTraceConnId.setStatus('current')
if mibBuilder.loadTexts: atmTraceConnTraceConnId.setDescription('Indicates whether the connection trace shall include connection identifier (e.g. VPI/VCI, DLCI) information.')
atmTraceConnTraceCallRef = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 2, 1, 1, 12), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTraceConnTraceCallRef.setStatus('current')
if mibBuilder.loadTexts: atmTraceConnTraceCallRef.setDescription('Indicates whether the connection trace shall include call reference information, and endpoint reference information for point-to-multipoint connections.')
atmTraceConnPassAlongRequest = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 2, 1, 1, 13), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTraceConnPassAlongRequest.setStatus('current')
if mibBuilder.loadTexts: atmTraceConnPassAlongRequest.setDescription("Indicates whether the 'pass along request' bit shall be set in the Trace transit list information element. When this object is set to 'true' and systems that do not support connection trace are present in the network, gaps may occur between successive entries in the atmTraceInfoTable identifying logical nodes and logical ports traversed by this connection or party.")
atmTraceConnFailTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 2, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100)).clone(30)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTraceConnFailTimeout.setStatus('current')
if mibBuilder.loadTexts: atmTraceConnFailTimeout.setDescription("The number of seconds left before the connection trace is declared to have failed. After this timer expires the value of this object will be zero and the atmTraceConnRecordIndex will also remain at zero. If the timer expires and atmTraceConnTrapOnCompletion is set to 'true', an atmTraceConnCompletion trap will be generated.")
atmTraceConnAgeTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 2, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 2147483647)).clone(600)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTraceConnAgeTimeout.setStatus('current')
if mibBuilder.loadTexts: atmTraceConnAgeTimeout.setDescription("The number of seconds left for this entry to age out. On expiry of this timer the display records in the atmTraceRecordTable and atmTraceInfoTable corresponding to this entry are deleted, as well as the atmTraceConnEntry. When the management station modifies this object, the currently running timer, if any, is aborted and a timer is started with the new value of this object. The value '-1' will indicate an infinite timeout value. ")
atmTraceConnRestart = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 2, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("restart", 1), ("noop", 2))).clone('noop')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTraceConnRestart.setStatus('current')
if mibBuilder.loadTexts: atmTraceConnRestart.setDescription("When the value is set to 'restart', the record for this connection trace is cleared and the connection trace is initiated. When the value is set to 'noop' no operation is performed. When read, the value 'noop' is returned.")
atmTraceConnTrapOnCompletion = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 2, 1, 1, 17), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTraceConnTrapOnCompletion.setStatus('current')
if mibBuilder.loadTexts: atmTraceConnTrapOnCompletion.setDescription('Specifies whether an atmTraceConnCompletion trap shall be issued on completion of the connection trace. If such a trap is desired, it is the responsibility of the management entity to ensure that the SNMP administrative model is configured in such a way as to allow the trap to be delivered.')
atmTraceConnRecordIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 2, 1, 1, 18), AtmTraceRecordIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTraceConnRecordIndex.setStatus('current')
if mibBuilder.loadTexts: atmTraceConnRecordIndex.setDescription('The value of this object identifies the row in the atmTraceRecordTable that was generated by this connection trace. The distinguished value zero indicates that no reply has been received yet or that no reply was received before expiry of atmTraceConnFailTimeout, so no record has been generated.')
atmTraceConnRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 2, 1, 1, 19), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTraceConnRowStatus.setStatus('current')
if mibBuilder.loadTexts: atmTraceConnRowStatus.setDescription('Used to create and delete entries in this table. When a row is activated, a connection trace is initiated.')
atmTraceConnTraceNeNsc = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 2, 1, 1, 20), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTraceConnTraceNeNsc.setStatus('current')
if mibBuilder.loadTexts: atmTraceConnTraceNeNsc.setDescription('Indicates whether the connection trace shall include Ne-NSCs supporting the connection .')
atmTraceConnTraceRpNsc = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 2, 1, 1, 21), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTraceConnTraceRpNsc.setStatus('current')
if mibBuilder.loadTexts: atmTraceConnTraceRpNsc.setDescription('Indicates whether the connection trace shall include Rp-NSCs supporting the connection.')
atmTraceConnTraceIncoming = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 2, 1, 1, 22), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTraceConnTraceIncoming.setStatus('current')
if mibBuilder.loadTexts: atmTraceConnTraceIncoming.setDescription('Indicates whether the connection trace shall record the NSCs supporting the connection at the incoming interface of the nodes. If this value is set to true and the atmTraceConnTraceNeNsc object is also true, then the trace shall include the list of Ne-NSCs supporting the connection at the incoming interface of the nodes. If this value is set to true and the atmTraceConnTraceRpNsc object is also true, then the trace shall include the list of Rp-NSCs supporting the connection at the incoming interface of the nodes. If this value is set to false, then the trace shall not record the NSCs supporting the connection at the incoming interface of the nodes.')
atmTraceConnTraceLabels = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 2, 1, 1, 23), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTraceConnTraceLabels.setStatus('current')
if mibBuilder.loadTexts: atmTraceConnTraceLabels.setDescription('Indicates whether the connection trace shall include interworking LSP labels, if applicable.')
atmTracePathTestGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 3))
atmTracePathTestTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 3, 1), )
if mibBuilder.loadTexts: atmTracePathTestTable.setStatus('current')
if mibBuilder.loadTexts: atmTracePathTestTable.setDescription('The table whose entries describe test connections and parties initiated to determine paths across the network. Typically these connections and parties are cleared when the trace destination node is reached, but the entry may be configured to leave the connections up using the atmTracePathTestClearCallAtTDest object.')
atmTracePathTestEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 3, 1, 1), ).setIndexNames((0, "ATM-TRACE-MIB", "atmTracePathTestIndex"))
if mibBuilder.loadTexts: atmTracePathTestEntry.setStatus('current')
if mibBuilder.loadTexts: atmTracePathTestEntry.setDescription('Each entry in this table specifies a test connection or test party that is initiated in order to determine a path across the network. Typically the connection or party is cleared when the trace destination node is reached, but the entry may be configured to leave the connections up using the atmTracePathTestClearCallAtTDest object. The results of the path trace are returned in the atmTraceFilterRecordTable, the atmTraceRecordTable, and the atmTraceInfoTable. A management station wishing to create an entry should first create the associated instance of the row status and row owner objects, using a value of atmTracePathTestIndex that is not currently in use. It must also, either in the same or in successive PDUs, create the associated instance of the address objects. It should also modify the default values for the other configuration objects if the defaults are not appropriate. Once the appropriate instance of all the configuration objects have been created, either by an explicit SNMP set request or by default, the row status should be set to active to initiate the request. Note that this entire procedure may be initiated via a single set request which specifies a row status of createAndGo as well as specifies valid values for the non-defaulted configuration objects. After the test connection or party completes, the management station should retrieve the values of the status objects of interest from the atmTraceRecordTable, and should then delete the entry. In order to prevent old entries from clogging the table, entries will be aged out, but an entry will not be deleted within 5 minutes of completing.')
atmTracePathTestIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 3, 1, 1, 1), Integer32())
if mibBuilder.loadTexts: atmTracePathTestIndex.setStatus('current')
if mibBuilder.loadTexts: atmTracePathTestIndex.setDescription('An arbitrary integer uniquely identifying a test connection or test party.')
atmTracePathTestOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 3, 1, 1, 2), AtmTraceOwnerString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTracePathTestOwner.setStatus('current')
if mibBuilder.loadTexts: atmTracePathTestOwner.setDescription('The entity that configured this entry.')
atmTracePathTestConnType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("atmVcc", 2), ("atmVpc", 3), ("atmCOBISigConn", 4))).clone('atmVcc')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTracePathTestConnType.setStatus('current')
if mibBuilder.loadTexts: atmTracePathTestConnType.setDescription('Indicates whether the test connection is a virtual channel connection, a virtual path connection, or a connection- oriented bearer-independent signalling connection.')
atmTracePathTestConnCastType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 3, 1, 1, 4), AtmConnCastType().clone('p2p')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTracePathTestConnCastType.setStatus('current')
if mibBuilder.loadTexts: atmTracePathTestConnCastType.setDescription('The connection topology type (e.g. point-to-point or point-to-multipoint) of the test connection or party.')
atmTracePathTestTraceSourceIf = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 3, 1, 1, 5), InterfaceIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTracePathTestTraceSourceIf.setStatus('current')
if mibBuilder.loadTexts: atmTracePathTestTraceSourceIf.setDescription('The interface at which the test connection or test party is originated.')
atmTracePathTestP2MpNewConn = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 3, 1, 1, 6), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTracePathTestP2MpNewConn.setStatus('current')
if mibBuilder.loadTexts: atmTracePathTestP2MpNewConn.setDescription("Indicates whether the test party for a point-to-multipoint connection is initiated on an existing branch (indicated by setting this object to 'false') or whether it is the first party of a new connection (indicated by setting this object to 'true'). This object does not apply when atmTracePathTestConnCastType is set to 'p2p'.")
atmTracePathTestOrigVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 3, 1, 1, 7), AtmVpIdentifier()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTracePathTestOrigVpi.setStatus('current')
if mibBuilder.loadTexts: atmTracePathTestOrigVpi.setDescription("When atmTracePathTestConnCastType is set to 'p2mpRoot' and atmTracePathTestP2MpNewConn is set to 'false' (i.e. path trace of a new party on an existing connection is requested), this object indicates the VPI value of the existing connection on the trace source interface. When atmTracePathTestClearCallAtTDest is set to 'true' and either - atmTracePathTestConnCastType is 'p2p', or - atmTracePathTestConnCastType is 'p2mpRoot' and atmTracePathTestP2MpNewConn is set to 'true', this object is not applicable. When atmTracePathTestClearCallAtTDest is set to 'false', this object indicates the VPI value to be used for the active connection. Note that if the VPI/VCI can be assigned at the other side of the interface, there may be some possibility of VPI/VCI collision for SETUP messages received on this interface, when the other side of the interface does not know that this VPI/VCI value is being used.")
atmTracePathTestOrigVci = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 3, 1, 1, 8), AtmVcIdentifier()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTracePathTestOrigVci.setStatus('current')
if mibBuilder.loadTexts: atmTracePathTestOrigVci.setDescription("When atmTracePathTestConnCastType is set to 'p2mpRoot' and atmTracePathTestP2MpNewConn is set to 'false' (i.e. path trace of a new party on an existing connection is requested), this object indicates the VCI value of the existing connection on the trace source interface. When atmTracePathTestClearCallAtTDest is set to 'true' and either - atmTracePathTestConnCastType is 'p2p', or - atmTracePathTestConnCastType is 'p2mpRoot' and atmTracePathTestP2MpNewConn is set to 'true', this object is not applicable. When atmTracePathTestClearCallAtTDest is set to 'false', this object indicates the VCI value to be used for the active connection. Note that if the VPI/VCI can be assigned at the other side of the interface, there may be some possibility of VPI/VCI collision for SETUP messages received on this interface, when the other side of the interface does not know that this VPI/VCI value is being used. If atmTracePathTestConnType is set to a value other than 'atmVcc', this value is set to zero.")
atmTracePathTestCalledParty = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 3, 1, 1, 9), AtmAddr()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTracePathTestCalledParty.setStatus('current')
if mibBuilder.loadTexts: atmTracePathTestCalledParty.setDescription('The called party number towards which the test connection or test party is to be initiated.')
atmTracePathTestCallingParty = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 3, 1, 1, 10), AtmAddr()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTracePathTestCallingParty.setStatus('current')
if mibBuilder.loadTexts: atmTracePathTestCallingParty.setDescription('The calling party number used for the test connection or test party.')
atmTracePathTestRxTrafDescrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 3, 1, 1, 11), AtmTrafficDescrParamIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTracePathTestRxTrafDescrIndex.setStatus('current')
if mibBuilder.loadTexts: atmTracePathTestRxTrafDescrIndex.setDescription("The value of this object identifies the row of the ATM Traffic Descriptor Table which applies to the receive direction of this test connection (from the point of view of the trace source interface). This object does not apply when the value of atmTracePathTestP2MpNewConn is 'false'.")
atmTracePathTestTxTrafDescrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 3, 1, 1, 12), AtmTrafficDescrParamIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTracePathTestTxTrafDescrIndex.setStatus('current')
if mibBuilder.loadTexts: atmTracePathTestTxTrafDescrIndex.setDescription("The value of this object identifies the row of the ATM Traffic Descriptor Table which applies to the transmit direction of this test connection (from the point of view of the trace source interface). This object does not apply when the value of atmTracePathTestP2MpNewConn is 'false'.")
atmTracePathTestClearCallAtTDest = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 3, 1, 1, 13), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTracePathTestClearCallAtTDest.setStatus('current')
if mibBuilder.loadTexts: atmTracePathTestClearCallAtTDest.setDescription("Indicates whether the test connection or party shall be cleared when the trace destination node is reached. When this is set to 'false', the test connection/party shall be cleared when the entry is deleted using the atmTracePathTestRowStatus object.")
atmTracePathTestTraceCrankback = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 3, 1, 1, 14), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTracePathTestTraceCrankback.setStatus('current')
if mibBuilder.loadTexts: atmTracePathTestTraceCrankback.setDescription('Indicates whether the path trace shall include crankback information. When this is set to false, as a consequence of the signalling procedures for path trace, trace information will only be returned if the connection or party succeeds.')
atmTracePathTestTraceConnId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 3, 1, 1, 15), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTracePathTestTraceConnId.setStatus('current')
if mibBuilder.loadTexts: atmTracePathTestTraceConnId.setDescription('Indicates whether the path trace shall include connection identifier (e.g. VPI/VCI, DLCI) information.')
atmTracePathTestTraceCallRef = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 3, 1, 1, 16), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTracePathTestTraceCallRef.setStatus('current')
if mibBuilder.loadTexts: atmTracePathTestTraceCallRef.setDescription('Indicates whether the path trace shall include call reference information, and endpoint reference information for point-to-multipoint connections.')
atmTracePathTestPassAlongRequest = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 3, 1, 1, 17), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTracePathTestPassAlongRequest.setStatus('current')
if mibBuilder.loadTexts: atmTracePathTestPassAlongRequest.setDescription("Indicates whether the 'pass along request' bit shall be set in the Trace transit list information element. When this object is set to 'true' and systems that do not support path trace are present in the network, gaps may occur between successive entries in the atmTraceInfoTable identifying logical nodes and logical ports traversed by this connection or party. When this object is set to 'false', trace information might not be returned unless all systems along the path support the path trace functionality.")
atmTracePathTestAgeTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 3, 1, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 2147483647)).clone(600)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTracePathTestAgeTimeout.setStatus('current')
if mibBuilder.loadTexts: atmTracePathTestAgeTimeout.setDescription("The number of seconds left for this entry to age out. On expiry of this timer the display records in the atmTraceRecordTable and the atmTraceInfoTable corresponding to this entry are deleted, as well as the atmTracePathTestEntry. When the management station modifies this object, the currently running timer, if any, is aborted and a timer is started with the new value of this object. The value '-1' will indicate an infinite timeout value. ")
atmTracePathTestRestart = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 3, 1, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("restart", 1), ("noop", 2))).clone('noop')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTracePathTestRestart.setStatus('current')
if mibBuilder.loadTexts: atmTracePathTestRestart.setDescription("When the value is set to 'restart', the test record for this connection is cleared and the test connection or party is initiated. When the value is set to 'noop' no operation is performed. When read, the value 'noop' is returned.")
atmTracePathTestTrapOnCompletion = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 3, 1, 1, 20), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTracePathTestTrapOnCompletion.setStatus('current')
if mibBuilder.loadTexts: atmTracePathTestTrapOnCompletion.setDescription('Specifies whether an atmTracePathTestCompletion trap shall be issued on completion of the path trace. If such a trap is desired, it is the responsibility of the management entity to ensure that the SNMP administrative model is configured in such a way as to allow the trap to be delivered.')
atmTracePathTestRecordIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 3, 1, 1, 21), AtmTraceRecordIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTracePathTestRecordIndex.setStatus('current')
if mibBuilder.loadTexts: atmTracePathTestRecordIndex.setDescription('The value of this object identifies the row in the atmTraceRecordTable that was generated by this test connection or party. The distinguished value zero indicates that no reply has been received yet, so no record has been generated.')
atmTracePathTestRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 3, 1, 1, 22), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTracePathTestRowStatus.setStatus('current')
if mibBuilder.loadTexts: atmTracePathTestRowStatus.setDescription('Used to create and delete entries in this table. When a row is activated, a test connection or test party is initiated. When the row is deleted, the test connection or test party is cleared (if it has not already been cleared) and the corresponding entry in the atmTraceRecordTable is deleted.')
atmTracePathTestTraceNeNsc = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 3, 1, 1, 23), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTracePathTestTraceNeNsc.setStatus('current')
if mibBuilder.loadTexts: atmTracePathTestTraceNeNsc.setDescription('Indicates whether the path trace shall include Ne-NSCs supporting the connection.')
atmTracePathTestTraceRpNsc = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 3, 1, 1, 24), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTracePathTestTraceRpNsc.setStatus('current')
if mibBuilder.loadTexts: atmTracePathTestTraceRpNsc.setDescription('Indicates whether the path trace shall include Rp-NSCs supporting the connection.')
atmTracePathTestTraceIncoming = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 3, 1, 1, 25), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTracePathTestTraceIncoming.setStatus('current')
if mibBuilder.loadTexts: atmTracePathTestTraceIncoming.setDescription('Indicates whether the path trace shall include the NSCs supporting the connection at the incoming interface of the nodes. If this value is set to true and the atmTracePathtestTraceNeNsc object is also true, then the trace shall include the list of Ne-NSCs supporting the connection at the incoming interface of the nodes. If this value is set to true and the atmTracePathTestTraceRpNsc object is also true, then the trace shall include the list of Rp-NSCs supporting the connection at the incoming interface of the nodes. If this value is set to false, then the trace shall not record the NSCs supporting the connection at the incoming interface of the nodes.')
atmTracePathTestPolicyConstraint = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 3, 1, 1, 26), PolicyConstraintIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTracePathTestPolicyConstraint.setStatus('current')
if mibBuilder.loadTexts: atmTracePathTestPolicyConstraint.setDescription('Defines the row of the policyConstraintTable that specifies the policy constraint to be used for the establishment of the test connection.')
atmTracePathTestTraceLabels = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 3, 1, 1, 27), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTracePathTestTraceLabels.setStatus('current')
if mibBuilder.loadTexts: atmTracePathTestTraceLabels.setDescription('Indicates whether the path trace shall include interworking LSP labels, if applicable.')
atmTraceFilterGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 4))
atmTraceFilterTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 4, 1), )
if mibBuilder.loadTexts: atmTraceFilterTable.setStatus('current')
if mibBuilder.loadTexts: atmTraceFilterTable.setDescription('The table whose entries describe the filtering criteria for recording of path trace information.')
atmTraceFilterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 4, 1, 1), ).setIndexNames((0, "ATM-TRACE-MIB", "atmTraceFilterIndex"))
if mibBuilder.loadTexts: atmTraceFilterEntry.setStatus('current')
if mibBuilder.loadTexts: atmTraceFilterEntry.setDescription("Each entry in this table corresponds to a filtering criteria based on which path trace is initiated for connections and parties in the process of being established. This selection criteria is applied against all connections and parties generated or detectedat this ATM device. Only connections and parties being established which match against all of the entry's criteria are recorded in the atmTraceRecordTable. A new entry can be created by specifying a atmTraceFilterIndex value that is currently not being used and also using an appropriate value (createAndGo or createAndWait) for the atmTraceFilterRowStatus object. If a particular connection or party matches multiple entries in the atmTraceFilterTable then multiple entries will be created in the atmTraceRecordTable for each of the matched entries in the atmTraceFilterTable.")
atmTraceFilterIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 50)))
if mibBuilder.loadTexts: atmTraceFilterIndex.setStatus('current')
if mibBuilder.loadTexts: atmTraceFilterIndex.setDescription('An arbitrary integer uniquely identifying a filtering criteria.')
atmTraceFilterOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 4, 1, 1, 2), AtmTraceOwnerString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTraceFilterOwner.setStatus('current')
if mibBuilder.loadTexts: atmTraceFilterOwner.setDescription('The entity that configured this entry.')
atmTraceFilterConnKind = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 4, 1, 1, 3), Bits().clone(namedValues=NamedValues(("other", 0), ("svcAndSpvcNotInitiator", 1), ("spvcInitiator", 2), ("svpAndSpvpNotInitiator", 3), ("spvpInitiator", 4), ("atmCOBISigConn", 5)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTraceFilterConnKind.setStatus('current')
if mibBuilder.loadTexts: atmTraceFilterConnKind.setDescription('This object enables the user to track the paths of switched virtual channel/path connections, soft permanent virtual channel/path connections initiated by this node, and soft permanent virtual channel/path connections initiated by other nodes.')
atmTraceFilterConnCastType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 4, 1, 1, 4), Bits().clone(namedValues=NamedValues(("p2p", 0), ("p2mp", 1)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTraceFilterConnCastType.setStatus('current')
if mibBuilder.loadTexts: atmTraceFilterConnCastType.setDescription('This object restricts the scope of the filter based on the type of topology of connections (point-to-point or point-to-multipoint).')
atmTraceFilterServiceCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 4, 1, 1, 5), Bits().clone(namedValues=NamedValues(("cbr", 0), ("rtVbr", 1), ("nrtVbr", 2), ("abr", 3), ("ubr", 4), ("gfr", 5), ("other", 6)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTraceFilterServiceCategory.setStatus('current')
if mibBuilder.loadTexts: atmTraceFilterServiceCategory.setDescription('This object restricts the scope of the filter to calls belonging to service categories represented by this object.')
atmTraceFilterInIf = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 4, 1, 1, 6), InterfaceIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTraceFilterInIf.setStatus('current')
if mibBuilder.loadTexts: atmTraceFilterInIf.setDescription('This object restricts the scope of the filter to calls which enter the ATM device through the port represented by this object, or are initiated at this port (e.g. Soft PVCs). It has the value 0, or the ifIndex value of an ATM Interface. The value zero indicates that the scope of the filter is not restricted by the incoming port.')
atmTraceFilterOutIf = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 4, 1, 1, 7), InterfaceIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTraceFilterOutIf.setStatus('current')
if mibBuilder.loadTexts: atmTraceFilterOutIf.setDescription('This object restricts the scope of the filter to calls which exit the ATM device through the port represented by this object. It has the value 0, or the ifIndex value of an ATM interface. The value zero indicates that the scope of the filter is not restricted by the outgoing port.')
atmTraceFilterCallingPartyPrefix = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 4, 1, 1, 8), AtmAddr()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTraceFilterCallingPartyPrefix.setStatus('current')
if mibBuilder.loadTexts: atmTraceFilterCallingPartyPrefix.setDescription('The combination of this object and the corresponding instance of atmTraceFilterCallingPartyLength is one selection criteria for this record. To match this selection criteria, a connection setup must have a Calling Party Address which has an initial part (of length atmTraceFilterCalledPartyLength bits) equal in value to atmTraceFilterCallingParty. When the default value for the object is retained then the call will match this filtering criteria for any calling address in the call, or if the calling party number is not present in the call. The value must be padded with zeros from atmTraceFilterCallingPartyLength to the full length of the address (8 octets for E.164 numbers and 20 octets for AESAs).')
atmTraceFilterCallingPartyLength = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 4, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 160)).clone(152)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTraceFilterCallingPartyLength.setStatus('current')
if mibBuilder.loadTexts: atmTraceFilterCallingPartyLength.setDescription('This object specifies the number of bits in atmTraceFilterCallingParty that shall be used when matching against the calling party of a new call setup.')
atmTraceFilterCalledPartyPrefix = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 4, 1, 1, 10), AtmAddr()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTraceFilterCalledPartyPrefix.setStatus('current')
if mibBuilder.loadTexts: atmTraceFilterCalledPartyPrefix.setDescription('The combination of this object and the corresponding instance of atmTraceFilterCalledPartyLength is one selection criteria for this record. To match this selection criteria, a connection setup must have a called party address which has an initial part (of length atmTraceFilterCalledPartyLength bits) equal in value to atmTraceFilterCalledParty. When the default value for the object is retained then the call will match this filtering criteria for any called address in the call. The value must be padded with zeros from atmTraceFilterCalledPartyLength to the full length of the address (8 octets for E.164 numbers and 20 octets for AESAs).')
atmTraceFilterCalledPartyLength = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 4, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 160)).clone(152)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTraceFilterCalledPartyLength.setStatus('current')
if mibBuilder.loadTexts: atmTraceFilterCalledPartyLength.setDescription('This object specifies the number of bits in atmTraceFilterCalledParty that shall be used when matching against the called party of a new call setup.')
atmTraceFilterClearCallAtTDest = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 4, 1, 1, 12), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTraceFilterClearCallAtTDest.setStatus('current')
if mibBuilder.loadTexts: atmTraceFilterClearCallAtTDest.setDescription('Indicates whether the connection or party shall be cleared when the trace destination node is reached.')
atmTraceFilterTraceCrankback = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 4, 1, 1, 13), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTraceFilterTraceCrankback.setStatus('current')
if mibBuilder.loadTexts: atmTraceFilterTraceCrankback.setDescription('Indicates whether the path trace shall include crankback information. When this is set to false, as a consequence of the signalling procedures for path trace, trace information will only be returned if the connection or party succeeds.')
atmTraceFilterTraceConnId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 4, 1, 1, 14), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTraceFilterTraceConnId.setStatus('current')
if mibBuilder.loadTexts: atmTraceFilterTraceConnId.setDescription('Indicates whether the path trace shall include connection identifier (e.g. VPI/VCI, DLCI) information.')
atmTraceFilterTraceCallRef = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 4, 1, 1, 15), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTraceFilterTraceCallRef.setStatus('current')
if mibBuilder.loadTexts: atmTraceFilterTraceCallRef.setDescription('Indicates whether the path trace shall include call reference information, and endpoint reference information for point-to-multipoint connections.')
atmTraceFilterPassAlongRequest = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 4, 1, 1, 16), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTraceFilterPassAlongRequest.setStatus('current')
if mibBuilder.loadTexts: atmTraceFilterPassAlongRequest.setDescription("Indicates whether the 'pass along request' bit shall be set in the Trace transit list information element. When this object is set to 'true' and systems that do not support path trace are present in the network, gaps may occur between successive entries in the atmTraceInfoTable identifying logical nodes and logical ports traversed by this connection or party. When this object is set to 'false', trace information might not be returned unless all systems along the path support the path trace functionality.")
atmTraceFilterMaxRecords = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 4, 1, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 214783647)).clone(20)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTraceFilterMaxRecords.setStatus('current')
if mibBuilder.loadTexts: atmTraceFilterMaxRecords.setDescription("The maximum number of entries that are desired in the atmTraceRecordTable on behalf of this filter. The agent will not create more than this number of entries in the table, but may choose to further limit the number of entries for this filter in the atmTraceRecordTable for any reason including the lack of resources. The agent will however dedicate resources for a minimum number of entries in the atmTraceRecordTable, to take care of temporary memory allocation failures in the system. In case of memory allocation failures the agent will utilize these dedicated resources for the creation of the new entries. If memory resource failures continue and the dedicated resources are exhausted then the records in the atmTraceRecordTable are pruned such that the oldest entries are removed to make way for the new entries. A value '-1' will indicate no upper limit for the number of records stored. The manager can set this object to -1 if overwriting of records is not desired. The new value for this object will take effect immediately. If this object is set to a value less than the number of entries that is currently present in the atmTraceRecordTable corresponding to this entry, then the oldest entries in the atmTraceRecordTable will be deleted so that their number equals the new value of this object. If the value of this object is changed from -1 to any other positive value then the entries will be pruned such that only the first n records collected for this entry are retained in the atmTraceRecordTable, n being the new value of this object.")
atmTraceFilterRecordCountDown = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 4, 1, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 2147483647)).clone(-1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTraceFilterRecordCountDown.setStatus('current')
if mibBuilder.loadTexts: atmTraceFilterRecordCountDown.setDescription("The number of entries left to be collected in the atmTraceRecordTable before filtering is disabled for this entry. The display records in the atmTraceRecordTable corresponding to this entry are retained. The management station can restart filtering for this entry by setting this object to a positive value (subject to atmTraceFilterRowStatus being 'active' and atmTraceFilterStopTimeout having a positive value or being set to '-1'). When the object is set to zero, filtering is stopped for this entry. When the management station modifies this object, the current value is replaced and the agent counts down from the new value of this object. The value '-1' indicates that filtering will not be automatically disabled based on the number of entries collected in the atmTraceRecordTable.")
atmTraceFilterStopTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 4, 1, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 2147483647)).clone(600)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTraceFilterStopTimeout.setStatus('current')
if mibBuilder.loadTexts: atmTraceFilterStopTimeout.setDescription("The number of seconds left for this entry to collect records. On expiry of this timer filtering is disabled for this entry. The display records in the atmTraceRecordTable corresponding to this entry are retained. When the timer expires the object will have a value zero. The management station can restart filtering for this entry by setting this object to a positive value (subject to atmTraceFilterRowStatus being 'active' and atmTraceFilterRecordCountDown having a positive value or being set to '-1'). When the object is set to zero, filtering is stopped for this entry. When the management station modifies this object, the currently running timer, if any, is aborted and a timer is started with the new value of this object. The value '-1' will indicate an infinite timeout value.")
atmTraceFilterAgeTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 4, 1, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 2147483647)).clone(600)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTraceFilterAgeTimeout.setStatus('current')
if mibBuilder.loadTexts: atmTraceFilterAgeTimeout.setDescription("The number of seconds left for this entry to age out. On expiry of this timer the display records in the atmTraceFilterRecordTable, atmTraceRecordTable and the atmTraceInfoTable corresponding to this entry are deleted, as well as the atmTraceFilterEntry. When the management station modifies this object, the currently running timer, if any, is aborted and a timer is started with the new value of this object. The value '-1' will indicate an infinite timeout value. ")
atmTraceFilterPurge = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 4, 1, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("purge", 1), ("noop", 2))).clone('noop')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTraceFilterPurge.setStatus('current')
if mibBuilder.loadTexts: atmTraceFilterPurge.setDescription("The object provides a facility for the user to purge the records in the atmTraceRecordTable corresponding to this entry. When the value is set to 'purge', the records in the atmTraceRecordTable corresponding to this entry are purged. When the value is set to 'noop' no operation is performed. When read, the value 'noop' is returned.")
atmTraceFilterTrapEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 4, 1, 1, 22), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTraceFilterTrapEnable.setStatus('current')
if mibBuilder.loadTexts: atmTraceFilterTrapEnable.setDescription("Specifies whether an atmTraceFilterTrap shall be issued the next time a record is added to the atmTraceRecordTable and the atmTraceFilterRecordTable corresponding to this filter. This object automatically resets itself to 'false' each time a trap is generated for this filter. This object must be reset to 'true' before another atmTracePathFilter trap can be generated for this filter entry. If such a trap is desired, it is the responsibility of the management entity to ensure that the SNMP administrative model is configured in such a way as to allow the trap to be delivered.")
atmTraceFilterNumMatches = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 4, 1, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTraceFilterNumMatches.setStatus('current')
if mibBuilder.loadTexts: atmTraceFilterNumMatches.setDescription('A monotonically increasing counter to keep track of the number of calls or parties that matched this entry for the entire lifetime of this entry. ')
atmTraceFilterRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 4, 1, 1, 24), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTraceFilterRowStatus.setStatus('current')
if mibBuilder.loadTexts: atmTraceFilterRowStatus.setDescription("Indicates the status of this row. Used according to the row installation and removal conventions. This object can be used to temporarily inactivate an entry in the table. When this object is set to a value 'notInService' filtering is stopped for the corresponding row. Any records that have been stored in the atmTraceRecordTable and the atmTraceFilterRecordTable corresponding to this entry will not be released. Any writeable objects in the row can be modified when the row is active. All values will take effect immediately. When this object is set to 'destroy', all corresponding records in the atmTraceFilterRecordTable and the atmTraceRecordTable are deleted.")
atmTraceFilterPolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 4, 1, 1, 25), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTraceFilterPolicy.setStatus('current')
if mibBuilder.loadTexts: atmTraceFilterPolicy.setDescription('This object restricts the scope of the filter to connection setups that include a Policy constraint information element.')
atmTraceFilterTraceNeNsc = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 4, 1, 1, 26), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTraceFilterTraceNeNsc.setStatus('current')
if mibBuilder.loadTexts: atmTraceFilterTraceNeNsc.setDescription('Indicates whether the path trace shall include Ne-NSCs supporting the connection.')
atmTraceFilterTraceRpNsc = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 4, 1, 1, 27), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTraceFilterTraceRpNsc.setStatus('current')
if mibBuilder.loadTexts: atmTraceFilterTraceRpNsc.setDescription('Indicates whether the path trace shall include Rp-NSCs supporting the connection.')
atmTraceFilterTraceIncoming = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 4, 1, 1, 28), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTraceFilterTraceIncoming.setStatus('current')
if mibBuilder.loadTexts: atmTraceFilterTraceIncoming.setDescription('Indicates whether the path trace shall include the NSCs supporting the connection at the incoming interface of the nodes. If this value is set to true and the atmTraceFilterTraceNeNsc object is also true, then the trace shall include the list of Ne-NSCs supporting the connection at the incoming interface of the nodes. If this value is set to true and the atmTraceFilterTraceRpNsc object is also true, then the trace shall include the list of Rp-NSCs supporting the connection at the incoming interface of the nodes. If this value is set to false, then the trace shall not record the NSCs supporting the connection at the incoming interface of the nodes.')
atmTraceFilterTraceLabels = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 4, 1, 1, 29), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTraceFilterTraceLabels.setStatus('current')
if mibBuilder.loadTexts: atmTraceFilterTraceLabels.setDescription('Indicates whether the path trace shall include interworking LSP labels, if applicable.')
atmTraceFilterRecordTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 4, 2), )
if mibBuilder.loadTexts: atmTraceFilterRecordTable.setStatus('current')
if mibBuilder.loadTexts: atmTraceFilterRecordTable.setDescription('The table that lists which trace records have been returned for which trace filters. This table also lists the connection characteristics for each connection record, other than those values returned in the Trace transit list information element.')
atmTraceFilterRecordEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 4, 2, 1), ).setIndexNames((0, "ATM-TRACE-MIB", "atmTraceFilterIndex"), (0, "ATM-TRACE-MIB", "atmTraceFilterRecordIndex"))
if mibBuilder.loadTexts: atmTraceFilterRecordEntry.setStatus('current')
if mibBuilder.loadTexts: atmTraceFilterRecordEntry.setDescription('An entry containing the index of a record associated with a given trace filter. This table also lists some of the connection characteristics.')
atmTraceFilterRecordIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 4, 2, 1, 1), AtmTraceRecordIndex())
if mibBuilder.loadTexts: atmTraceFilterRecordIndex.setStatus('current')
if mibBuilder.loadTexts: atmTraceFilterRecordIndex.setDescription('The value of this object identifies a row in the atmTraceRecordTable that was generated by the trace filter identified by atmTraceFilterIndex.')
atmTraceFilterRecordConnKind = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 4, 2, 1, 2), AtmConnKind()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTraceFilterRecordConnKind.setStatus('current')
if mibBuilder.loadTexts: atmTraceFilterRecordConnKind.setDescription('This object represents the use of call control (e.g. switched virtual connection or soft permanent virtual connection) of the connection or party on the incoming interface.')
atmTraceFilterRecordConnCastType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 4, 2, 1, 3), AtmConnCastType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTraceFilterRecordConnCastType.setStatus('current')
if mibBuilder.loadTexts: atmTraceFilterRecordConnCastType.setDescription('This object represents the type of topology of the connection (point-to-point or point-to-multipoint) on the incoming interface.')
atmTraceFilterRecordServiceCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 4, 2, 1, 4), AtmServiceCategory()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTraceFilterRecordServiceCategory.setStatus('current')
if mibBuilder.loadTexts: atmTraceFilterRecordServiceCategory.setDescription('This object represents the service category used by the call.')
atmTraceFilterRecordInIf = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 4, 2, 1, 5), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTraceFilterRecordInIf.setStatus('current')
if mibBuilder.loadTexts: atmTraceFilterRecordInIf.setDescription('The IfIndex of the incoming port on which this call was received by the ATM device.')
atmTraceFilterRecordOutIf = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 4, 2, 1, 6), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTraceFilterRecordOutIf.setStatus('current')
if mibBuilder.loadTexts: atmTraceFilterRecordOutIf.setDescription('The IfIndex of the outgoing port, if available, through which this call was routed to the network. The distinguished value zero indicates that the call was rejected before any outgoing interface was chosen.')
atmTraceFilterRecordCallingParty = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 4, 2, 1, 7), AtmAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTraceFilterRecordCallingParty.setStatus('current')
if mibBuilder.loadTexts: atmTraceFilterRecordCallingParty.setDescription('Indicates the ATM adddress of the calling party in the connection or party.')
atmTraceFilterRecordCalledParty = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 4, 2, 1, 8), AtmAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTraceFilterRecordCalledParty.setStatus('current')
if mibBuilder.loadTexts: atmTraceFilterRecordCalledParty.setDescription('Indicates the ATM address of the called party in the connection or party.')
atmTraceRecordGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 5))
atmTraceRecordTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 5, 1), )
if mibBuilder.loadTexts: atmTraceRecordTable.setStatus('current')
if mibBuilder.loadTexts: atmTraceRecordTable.setDescription('This table and the atmTraceInfoTable are used to display the path or connection trace results. Trace information that is not repeated at each hop is shown in this table.')
atmTraceRecordEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 5, 1, 1), ).setIndexNames((0, "ATM-TRACE-MIB", "atmTraceRecordIndex"))
if mibBuilder.loadTexts: atmTraceRecordEntry.setStatus('current')
if mibBuilder.loadTexts: atmTraceRecordEntry.setDescription('An entry representing a trace record for one new or existing connection or party.')
atmTraceRecordIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 5, 1, 1, 1), AtmTraceRecordIndex())
if mibBuilder.loadTexts: atmTraceRecordIndex.setStatus('current')
if mibBuilder.loadTexts: atmTraceRecordIndex.setDescription('An arbitrary integer used to distinguish between multiple trace records. ')
atmTraceRecordStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("traceInProgress", 1), ("traceCompletedNormally", 2), ("traceIncomplete", 3), ("traceExceededIELengthLimitations", 4), ("traceExceededMessageLengthLimitations", 5), ("traceLackResource", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTraceRecordStatus.setStatus('current')
if mibBuilder.loadTexts: atmTraceRecordStatus.setDescription('The returned trace status for this connection or party.')
atmTraceRecordCause = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 5, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTraceRecordCause.setReference("ATM Forum's UNI3.0/3.1 Specification. ")
if mibBuilder.loadTexts: atmTraceRecordCause.setStatus('current')
if mibBuilder.loadTexts: atmTraceRecordCause.setDescription('This object identifies the reason for the call failure. When the call succeeds, the distinguished value zero is returned. When a PNNI Crankback information element is included in the last call clearing message, this object contains the crankback cause. In all other cases, the values are the same as the cause code values defined for the Cause information element.')
atmTraceRecordDiags = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 5, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTraceRecordDiags.setReference("ATM Forum's UNI3.0/3.1 Specification. ")
if mibBuilder.loadTexts: atmTraceRecordDiags.setStatus('current')
if mibBuilder.loadTexts: atmTraceRecordDiags.setDescription("This object contains the contents of the diagnostics fields from the Cause information element. When the value of atmTraceRecordCause is 49, 'Quality of Service unavailable', the diagnostics are taken from the PNNI Crankback information element instead of the Cause information element.")
atmTraceRecordTraceSourcePortId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 5, 1, 1, 5), PnniPortId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTraceRecordTraceSourcePortId.setStatus('current')
if mibBuilder.loadTexts: atmTraceRecordTraceSourcePortId.setDescription('The PNNI logical port ID identifying the trace source interface. The distinguished value zero indicates that no trace source port ID was returned in the Trace transit list.')
atmTraceRecordTraceSourceDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 5, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTraceRecordTraceSourceDlci.setStatus('current')
if mibBuilder.loadTexts: atmTraceRecordTraceSourceDlci.setDescription('The DLCI used on the trace source interface. The distinguished value zero indicates that no DLCI was included in the Trace transit list for the trace source interface.')
atmTraceRecordTraceDestVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 5, 1, 1, 7), AtmVpIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTraceRecordTraceDestVpi.setStatus('current')
if mibBuilder.loadTexts: atmTraceRecordTraceDestVpi.setDescription('The VPI used on the preceding side of the trace destination interface. The value zero is returned if no VPI was included in the Trace transit list for the trace destination interface.')
atmTraceRecordTraceDestVci = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 5, 1, 1, 8), AtmVcIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTraceRecordTraceDestVci.setStatus('current')
if mibBuilder.loadTexts: atmTraceRecordTraceDestVci.setDescription('The VCI used on the trace destination interface. The distinguished value zero indicates that no VCI was included in the Trace transit list for the trace destination interface.')
atmTraceRecordTraceDestCallRef = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 5, 1, 1, 9), CallReference()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTraceRecordTraceDestCallRef.setStatus('current')
if mibBuilder.loadTexts: atmTraceRecordTraceDestCallRef.setDescription('The call reference used on the trace destination interface.')
atmTraceRecordTraceDestEndPtRef = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 5, 1, 1, 10), AtmEndPointReference()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTraceRecordTraceDestEndPtRef.setStatus('current')
if mibBuilder.loadTexts: atmTraceRecordTraceDestEndPtRef.setDescription('The endpoint reference used on the trace destination interface.')
atmTraceRecordTraceDestDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 5, 1, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTraceRecordTraceDestDlci.setStatus('current')
if mibBuilder.loadTexts: atmTraceRecordTraceDestDlci.setDescription('The DLCI used on the trace destination interface. The distinguished value zero indicates that no DLCI was included in the Trace transit list for the trace destination interface.')
atmTraceRecordTimeStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 5, 1, 1, 12), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTraceRecordTimeStamp.setStatus('current')
if mibBuilder.loadTexts: atmTraceRecordTimeStamp.setDescription('The time at which this record entry was created.')
atmTraceRecordTraceDestReceiveLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 5, 1, 1, 13), MplsLabel()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTraceRecordTraceDestReceiveLabel.setStatus('current')
if mibBuilder.loadTexts: atmTraceRecordTraceDestReceiveLabel.setDescription('The label for the interworking LSP used for packets transmitted in the direction of the tracing message (either SETUP, ADD PARTY, or TRACE CONNECTION) on the trace destination interface. The value zero is returned if no labels were included in the Trace transit list for the trace destination interface.')
atmTraceRecordTraceDestTransmitLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 5, 1, 1, 14), MplsLabel()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTraceRecordTraceDestTransmitLabel.setStatus('current')
if mibBuilder.loadTexts: atmTraceRecordTraceDestTransmitLabel.setDescription('The label for the interworking LSP used for packets transmitted in the opposite direction to that of the tracing message (either SETUP, ADD PARTY, or TRACE CONNECTION) on the trace destination interface. The value zero is returned if no labels were included in the Trace transit list for the trace destination interface.')
atmTraceInfoTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 5, 2), )
if mibBuilder.loadTexts: atmTraceInfoTable.setStatus('current')
if mibBuilder.loadTexts: atmTraceInfoTable.setDescription('The table in which the detailed trace information (i.e., logical nodes, logical ports, VPI/VCIs, and Call/Endpoint References) of traced connections or parties are recorded.')
atmTraceInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 5, 2, 1), ).setIndexNames((0, "ATM-TRACE-MIB", "atmTraceRecordIndex"), (0, "ATM-TRACE-MIB", "atmTraceInfoSequenceIndex"))
if mibBuilder.loadTexts: atmTraceInfoEntry.setStatus('current')
if mibBuilder.loadTexts: atmTraceInfoEntry.setDescription('Trace information for one hop of an existing or new connection or party. This lists the nodes and ports traversed by the connection or party. VPI/VCIs and Call/Endpoint References may also be included in this entry. Each entry contains trace information added by one node. If there are gaps in the Trace transit list due to the use of the Pass along request flag and the presence of nodes that do not support trace, the gaps will be between successive entries in this table. Since the entries in this table are linked to the entries of the atmTraceRecordTable, the entries are added and removed from the table as and when the corresponding entries in the atmTraceRecordTable are added and removed.')
atmTraceInfoSequenceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 5, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 200)))
if mibBuilder.loadTexts: atmTraceInfoSequenceIndex.setStatus('current')
if mibBuilder.loadTexts: atmTraceInfoSequenceIndex.setDescription('An index into the list of logical nodes / logical ports traversed by the connection or party. The logical nodes and logical ports are given in order, as specified by this index.')
atmTraceInfoNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 5, 2, 1, 2), PnniNodeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTraceInfoNodeId.setStatus('current')
if mibBuilder.loadTexts: atmTraceInfoNodeId.setDescription('The node ID of a logical node traversed by the connection or party.')
atmTraceInfoOutgoingPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 5, 2, 1, 3), PnniPortId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTraceInfoOutgoingPortId.setStatus('current')
if mibBuilder.loadTexts: atmTraceInfoOutgoingPortId.setDescription('The port ID of the logical node identified in atmTraceInfoNodeId that identifies the logical port used to progress this connection or party towards the called party.')
atmTraceInfoIncomingVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 5, 2, 1, 4), AtmVpIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTraceInfoIncomingVpi.setStatus('current')
if mibBuilder.loadTexts: atmTraceInfoIncomingVpi.setDescription('The VPI used on the succeeding side of the incoming interface of the node identified by atmTraceInfoNodeId. The value zero is returned if no VPI was included in the Trace transit list. If there are no gaps in the Trace transit list, this is the VPI used on the other side of the interface identified by the atmTraceInfoNodeId and atmTraceInfoPortId under the previous atmTraceInfoSequenceIndex.')
atmTraceInfoIncomingVci = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 5, 2, 1, 5), AtmVcIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTraceInfoIncomingVci.setStatus('current')
if mibBuilder.loadTexts: atmTraceInfoIncomingVci.setDescription('The VCI used on the incoming interface of the node identified by atmTraceInfoNodeId. The distinguished value zero indicates that no VCI was included in the Trace transit list. If there are no gaps in the Trace transit list, this is the VCI used on the interface identified by the atmTraceInfoNodeId and atmTraceInfoPortId under the previous atmTraceInfoSequenceIndex.')
atmTraceInfoIncomingCallRef = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 5, 2, 1, 6), CallReference()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTraceInfoIncomingCallRef.setStatus('current')
if mibBuilder.loadTexts: atmTraceInfoIncomingCallRef.setDescription('The Call Reference used on the incoming interface of the node identified by atmTraceInfoNodeId. If there are no gaps in the Trace transit list, this is the call reference used on the interface identified by the atmTraceInfoNodeId and atmTraceInfoPortId under the previous atmTraceInfoSequenceIndex.')
atmTraceInfoIncomingEndPtRef = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 5, 2, 1, 7), AtmEndPointReference()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTraceInfoIncomingEndPtRef.setStatus('current')
if mibBuilder.loadTexts: atmTraceInfoIncomingEndPtRef.setDescription('The Endpoint Reference used on the incoming interface of the node identified by atmTraceInfoNodeId. If there are no gaps in the Trace transit list, this is the endpoint reference used on the interface identified by the atmTraceInfoNodeId and atmTraceInfoPortId under the previous atmTraceInfoSequenceIndex.')
atmTraceInfoRefusalIndicator = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 5, 2, 1, 8), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTraceInfoRefusalIndicator.setStatus('current')
if mibBuilder.loadTexts: atmTraceInfoRefusalIndicator.setDescription('Indicates whether the node identified by the atmTraceInfoNodeId refused to participate in this trace.')
atmTraceInfoCrankBackRcvdAtDest = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 5, 2, 1, 9), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTraceInfoCrankBackRcvdAtDest.setStatus('current')
if mibBuilder.loadTexts: atmTraceInfoCrankBackRcvdAtDest.setDescription('Indicates whether a crankback was received at the node identified by the atmTraceInfoNodeId, when that node is the trace destination node and the trace destination interface is not a PNNI interface.')
atmTraceInfoCrankBackGap = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 5, 2, 1, 10), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTraceInfoCrankBackGap.setStatus('current')
if mibBuilder.loadTexts: atmTraceInfoCrankBackGap.setDescription('Indicates that the trace was propagated beyond the node identified by the atmTraceInfoNodeId, but was cranked back, and no trace information was returned by the node initiating crankback.')
atmTraceInfoCrankBackIndicator = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 5, 2, 1, 11), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTraceInfoCrankBackIndicator.setStatus('current')
if mibBuilder.loadTexts: atmTraceInfoCrankBackIndicator.setDescription('Indicates whether crankback information (octet group 16 of the Trace transit list information element) is present after the node identified by the atmTraceInfoNodeId, but before the next node identified in the Trace transit list information element.')
atmTraceInfoCrankBackBlockedTransitType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 5, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("blockedIncomingLink", 1), ("blockedNode", 2), ("blockedOutgoingLink", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTraceInfoCrankBackBlockedTransitType.setStatus('current')
if mibBuilder.loadTexts: atmTraceInfoCrankBackBlockedTransitType.setDescription("This object identifies the type of blockage in case of a blocked call at the node identified by the atmTraceInfoNodeId. This object does not apply if the value of atmTraceInfoCrankBackIndicator is 'false'.")
atmTraceInfoCrankBackBlockedTransitInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 5, 2, 1, 13), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTraceInfoCrankBackBlockedTransitInfo.setReference('PNNI Addendum for Path and Connection Trace Version 1.0, Section 3.1')
if mibBuilder.loadTexts: atmTraceInfoCrankBackBlockedTransitInfo.setStatus('current')
if mibBuilder.loadTexts: atmTraceInfoCrankBackBlockedTransitInfo.setDescription("This object does not apply if the value of atmTraceInfoCrankBackIndicator is 'false'. When the value of atmTraceInfoCrankBackIndicator is 'true', this object includes the contents of the Blocked Transit Trace Information field from the Trace transit list Information element.")
atmTraceInfoCrankBackCause = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 5, 2, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTraceInfoCrankBackCause.setStatus('current')
if mibBuilder.loadTexts: atmTraceInfoCrankBackCause.setDescription("This object returns the PNNI crankback cause. This object does not apply if atmTraceInfoCrankBackIndicator is set to 'false'.")
atmTraceInfoReceiveLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 5, 2, 1, 15), MplsLabel()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTraceInfoReceiveLabel.setStatus('current')
if mibBuilder.loadTexts: atmTraceInfoReceiveLabel.setDescription('The label for the interworking LSP used for packets transmitted in the direction of the tracing message (either SETUP, ADD PARTY, or TRACE CONNECTION). If there are no gaps in the Trace transit list, this is from the atmTraceInfoNodeId under the previous atmTraceInfoSequenceIndex towards the atmTraceInfoNodeId under the current atmTraceInfoSequenceIndex.')
atmTraceInfoTransmitLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 5, 2, 1, 16), MplsLabel()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTraceInfoTransmitLabel.setStatus('current')
if mibBuilder.loadTexts: atmTraceInfoTransmitLabel.setDescription('The label for the interworking LSP used for packets transmitted in the opposite direction to that of the the tracing message (either SETUP, ADD PARTY, or TRACE CONNECTION). If there are no gaps in the Trace transit list, this is from the atmTraceInfoNodeId under the current atmTraceInfoSequenceIndex towards the atmTraceInfoNodeId under the previous atmTraceInfoSequenceIndex.')
atmTraceInfoNeNscTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 5, 3), )
if mibBuilder.loadTexts: atmTraceInfoNeNscTable.setStatus('current')
if mibBuilder.loadTexts: atmTraceInfoNeNscTable.setDescription('The table in which records the Ne-NSCs which tag the network entity over which the connection was established on the interfaces of the node.')
atmTraceInfoNeNscEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 5, 3, 1), ).setIndexNames((0, "ATM-TRACE-MIB", "atmTraceRecordIndex"), (0, "ATM-TRACE-MIB", "atmTraceInfoSequenceIndex"), (0, "ATM-TRACE-MIB", "atmTraceInfoNeNscInterface"), (0, "ATM-TRACE-MIB", "atmTraceInfoNeNscIndex"))
if mibBuilder.loadTexts: atmTraceInfoNeNscEntry.setStatus('current')
if mibBuilder.loadTexts: atmTraceInfoNeNscEntry.setDescription('One of the Ne-NSCs which tag the network entity over which the connection was established on the interface of the node.')
atmTraceInfoNeNscInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 5, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("incoming", 1), ("outgoing", 2))))
if mibBuilder.loadTexts: atmTraceInfoNeNscInterface.setStatus('current')
if mibBuilder.loadTexts: atmTraceInfoNeNscInterface.setDescription('An index into the list of NSCs, used to identify the NSCs tagging resources on the incoming or outgoing interface')
atmTraceInfoNeNscIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 5, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 40)))
if mibBuilder.loadTexts: atmTraceInfoNeNscIndex.setStatus('current')
if mibBuilder.loadTexts: atmTraceInfoNeNscIndex.setDescription('An index into the list of Ne-NSCs which tag the network entity over which the connection was established on the interface of the node. The order of the Ne-NSCs is not important')
atmTraceInfoNeNsc = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 5, 3, 1, 3), NetworkEntityNetworkServiceCategory()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTraceInfoNeNsc.setStatus('current')
if mibBuilder.loadTexts: atmTraceInfoNeNsc.setDescription('One of the Ne-NSCs which tag the network entity over which the connection was established on the incoming interface of the node. ')
atmTraceInfoRpNscTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 5, 4), )
if mibBuilder.loadTexts: atmTraceInfoRpNscTable.setStatus('current')
if mibBuilder.loadTexts: atmTraceInfoRpNscTable.setDescription('The table in which records the Rp-NSCs which tag the resource in which the connection was established on the interfaces of the node.')
atmTraceInfoRpNscEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 5, 4, 1), ).setIndexNames((0, "ATM-TRACE-MIB", "atmTraceRecordIndex"), (0, "ATM-TRACE-MIB", "atmTraceInfoSequenceIndex"), (0, "ATM-TRACE-MIB", "atmTraceInfoRpNscInterface"), (0, "ATM-TRACE-MIB", "atmTraceInfoRpNscSequenceIndex"))
if mibBuilder.loadTexts: atmTraceInfoRpNscEntry.setStatus('current')
if mibBuilder.loadTexts: atmTraceInfoRpNscEntry.setDescription('One of the Rp-NSCs which tag the resource in which the connection was established on the interfaces of the node.')
atmTraceInfoRpNscInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 5, 4, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("incoming", 1), ("outgoing", 2))))
if mibBuilder.loadTexts: atmTraceInfoRpNscInterface.setStatus('current')
if mibBuilder.loadTexts: atmTraceInfoRpNscInterface.setDescription('An index into the list of NSCs, used to identify the NSCs tagging resources on the incoming or outgoing interface')
atmTraceInfoRpNscSequenceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 5, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 40)))
if mibBuilder.loadTexts: atmTraceInfoRpNscSequenceIndex.setStatus('current')
if mibBuilder.loadTexts: atmTraceInfoRpNscSequenceIndex.setDescription('An index into the list of Rp-NSCs which tag the resource in which the connection was established on the interface of the node. The order of the Rp-NSCs is not important')
atmTraceInfoRpNsc = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 5, 4, 1, 3), ResourcePartitionNetworkServiceCategory()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTraceInfoRpNsc.setStatus('current')
if mibBuilder.loadTexts: atmTraceInfoRpNsc.setDescription('One of the Rp-NSCs which tag the resource in which the connection was established on the interface of the node. ')
atmTraceIfGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 6))
atmTraceIfTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 6, 1), )
if mibBuilder.loadTexts: atmTraceIfTable.setStatus('current')
if mibBuilder.loadTexts: atmTraceIfTable.setDescription('This table is used to specify trace-related properties of a PNNI interface (e.g. whether a PNNI interface allows tracing over that interface).')
atmTraceIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 6, 1, 1), )
pnniIfEntry.registerAugmentions(("ATM-TRACE-MIB", "atmTraceIfEntry"))
atmTraceIfEntry.setIndexNames(*pnniIfEntry.getIndexNames())
if mibBuilder.loadTexts: atmTraceIfEntry.setStatus('current')
if mibBuilder.loadTexts: atmTraceIfEntry.setDescription('An entry representing the trace-related properties of a PNNI interface.')
atmTraceIfTraceBoundary = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 1, 6, 1, 1, 1), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmTraceIfTraceBoundary.setStatus('current')
if mibBuilder.loadTexts: atmTraceIfTraceBoundary.setDescription('When this is a PNNI interface, indicates whether path and connection trace will be terminated or refused for outgoing or incoming, respectively, connections or parties on this interface. This object has no effect when this is not a PNNI interface.')
atmTraceMIBTrapsPrefix = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 2))
atmTraceMIBTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 2, 0))
atmTraceConnCompletion = NotificationType((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 2, 0, 1)).setObjects(("ATM-TRACE-MIB", "atmTraceConnRecordIndex"))
if mibBuilder.loadTexts: atmTraceConnCompletion.setStatus('current')
if mibBuilder.loadTexts: atmTraceConnCompletion.setDescription('An atmTraceConnCompletion trap is sent when enabled and either a TRACE CONNECTION ACKNOWLEDGE message is received at the trace source node, or after atmTraceConnFailTimeout has passed without any response (i.e., the connection trace fails).')
atmTracePathTestCompletion = NotificationType((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 2, 0, 2)).setObjects(("ATM-TRACE-MIB", "atmTracePathTestRecordIndex"))
if mibBuilder.loadTexts: atmTracePathTestCompletion.setStatus('current')
if mibBuilder.loadTexts: atmTracePathTestCompletion.setDescription('An atmTracePathTestCompletion trap is sent when enabled and the test connection or test party becomes active on the trace source interface, or is cleared across the trace source interface.')
atmTracePathFilterTrap = NotificationType((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 2, 0, 3)).setObjects(("ATM-TRACE-MIB", "atmTraceFilterRecordConnKind"))
if mibBuilder.loadTexts: atmTracePathFilterTrap.setStatus('current')
if mibBuilder.loadTexts: atmTracePathFilterTrap.setDescription("An atmTracePathFilter trap is sent when the trap is enabled and a record is added to the atmTraceRecordTable and the atmTraceFilterRecordTable corresponding to this filter. The atmTraceFilterTrapEnable object must be reset to 'true' before another atmTracePathFilter trap can be generated by the agent for this filter entry.")
atmTraceMIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 3))
atmTraceMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 3, 1))
atmTraceMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 3, 2))
atmTraceMIBCompliance2 = ModuleCompliance((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 3, 1, 2)).setObjects(("ATM-TRACE-MIB", "atmTraceMIBMandatoryGroup"), ("ATM-TRACE-MIB", "atmTraceConnAndPathFilterMandatoryGroup"), ("ATM-TRACE-MIB", "atmTracePathMandatoryGroup"), ("ATM-TRACE-MIB", "atmTraceConnMandatoryGroup"), ("ATM-TRACE-MIB", "atmTracePathTestMandatoryGroup"), ("ATM-TRACE-MIB", "atmTracePathFilterMandatoryGroup"), ("ATM-TRACE-MIB", "atmTraceConnAndPathFilterPolicyMandatoryGroup"), ("ATM-TRACE-MIB", "atmTraceConnPolicyMandatoryGroup"), ("ATM-TRACE-MIB", "atmTracePathTestPolicyMandatoryGroup"), ("ATM-TRACE-MIB", "atmTracePathFilterPolicyMandatoryGroup"), ("ATM-TRACE-MIB", "atmTraceConnAndPathFilterMplsMandatoryGroup"), ("ATM-TRACE-MIB", "atmTraceConnMplsMandatoryGroup"), ("ATM-TRACE-MIB", "atmTracePathTestMplsMandatoryGroup"), ("ATM-TRACE-MIB", "atmTracePathFilterMplsMandatoryGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmTraceMIBCompliance2 = atmTraceMIBCompliance2.setStatus('current')
if mibBuilder.loadTexts: atmTraceMIBCompliance2.setDescription('The compliance statement for entities which implement the PNNI Addendum for Path and Connection Trace Version 1.1. Groups of objects required to support certain functionality are identified by the suffix MandatoryGroup. Groups of optional objects are identified by the suffix OptionalGroup.')
atmTraceMIBMandatoryGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 3, 2, 1)).setObjects(("ATM-TRACE-MIB", "atmTraceMaxConcurrentRequests"), ("ATM-TRACE-MIB", "atmTraceAvailableRequests"), ("ATM-TRACE-MIB", "atmTraceTransitListMaximumSize"), ("ATM-TRACE-MIB", "atmTraceRecordStatus"), ("ATM-TRACE-MIB", "atmTraceRecordTraceSourcePortId"), ("ATM-TRACE-MIB", "atmTraceRecordTimeStamp"), ("ATM-TRACE-MIB", "atmTraceInfoNodeId"), ("ATM-TRACE-MIB", "atmTraceInfoOutgoingPortId"), ("ATM-TRACE-MIB", "atmTraceInfoRefusalIndicator"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmTraceMIBMandatoryGroup = atmTraceMIBMandatoryGroup.setStatus('current')
if mibBuilder.loadTexts: atmTraceMIBMandatoryGroup.setDescription('A collection of objects required when path or connection trace is supported.')
atmTraceMIBOptionalGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 3, 2, 2)).setObjects(("ATM-TRACE-MIB", "atmTraceRecordTraceSourceDlci"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmTraceMIBOptionalGroup = atmTraceMIBOptionalGroup.setStatus('current')
if mibBuilder.loadTexts: atmTraceMIBOptionalGroup.setDescription('A collection of optional objects used for path and connection trace.')
atmTraceConnAndPathFilterMandatoryGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 3, 2, 3)).setObjects(("ATM-TRACE-MIB", "atmTraceRecordTraceDestVpi"), ("ATM-TRACE-MIB", "atmTraceRecordTraceDestVci"), ("ATM-TRACE-MIB", "atmTraceRecordTraceDestCallRef"), ("ATM-TRACE-MIB", "atmTraceRecordTraceDestEndPtRef"), ("ATM-TRACE-MIB", "atmTraceRecordTraceDestDlci"), ("ATM-TRACE-MIB", "atmTraceInfoIncomingVpi"), ("ATM-TRACE-MIB", "atmTraceInfoIncomingVci"), ("ATM-TRACE-MIB", "atmTraceInfoIncomingCallRef"), ("ATM-TRACE-MIB", "atmTraceInfoIncomingEndPtRef"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmTraceConnAndPathFilterMandatoryGroup = atmTraceConnAndPathFilterMandatoryGroup.setStatus('current')
if mibBuilder.loadTexts: atmTraceConnAndPathFilterMandatoryGroup.setDescription('A collection of objects required when supporting connection trace or path trace using filtering of new connection and party establishment messages.')
atmTracePathMandatoryGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 3, 2, 4)).setObjects(("ATM-TRACE-MIB", "atmTraceRecordCause"), ("ATM-TRACE-MIB", "atmTraceRecordDiags"), ("ATM-TRACE-MIB", "atmTraceInfoCrankBackRcvdAtDest"), ("ATM-TRACE-MIB", "atmTraceInfoCrankBackGap"), ("ATM-TRACE-MIB", "atmTraceInfoCrankBackIndicator"), ("ATM-TRACE-MIB", "atmTraceInfoCrankBackBlockedTransitType"), ("ATM-TRACE-MIB", "atmTraceInfoCrankBackBlockedTransitInfo"), ("ATM-TRACE-MIB", "atmTraceInfoCrankBackCause"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmTracePathMandatoryGroup = atmTracePathMandatoryGroup.setStatus('current')
if mibBuilder.loadTexts: atmTracePathMandatoryGroup.setDescription('A collection of objects required when supporting path trace.')
atmTraceConnMandatoryGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 3, 2, 5)).setObjects(("ATM-TRACE-MIB", "atmTraceConnOwner"), ("ATM-TRACE-MIB", "atmTraceConnTraceSourceIf"), ("ATM-TRACE-MIB", "atmTraceConnOrigConnType"), ("ATM-TRACE-MIB", "atmTraceConnOrigVpi"), ("ATM-TRACE-MIB", "atmTraceConnOrigVci"), ("ATM-TRACE-MIB", "atmTraceConnEndPtRef"), ("ATM-TRACE-MIB", "atmTraceConnOrigDirection"), ("ATM-TRACE-MIB", "atmTraceConnTraceConnId"), ("ATM-TRACE-MIB", "atmTraceConnTraceCallRef"), ("ATM-TRACE-MIB", "atmTraceConnPassAlongRequest"), ("ATM-TRACE-MIB", "atmTraceConnFailTimeout"), ("ATM-TRACE-MIB", "atmTraceConnAgeTimeout"), ("ATM-TRACE-MIB", "atmTraceConnRestart"), ("ATM-TRACE-MIB", "atmTraceConnRecordIndex"), ("ATM-TRACE-MIB", "atmTraceConnRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmTraceConnMandatoryGroup = atmTraceConnMandatoryGroup.setStatus('current')
if mibBuilder.loadTexts: atmTraceConnMandatoryGroup.setDescription('A collection of objects required when connection trace is supported.')
atmTraceConnOptionalGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 3, 2, 6)).setObjects(("ATM-TRACE-MIB", "atmTraceConnCallRef"), ("ATM-TRACE-MIB", "atmTraceConnOrigDlci"), ("ATM-TRACE-MIB", "atmTraceConnTrapOnCompletion"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmTraceConnOptionalGroup = atmTraceConnOptionalGroup.setStatus('current')
if mibBuilder.loadTexts: atmTraceConnOptionalGroup.setDescription('A collection of optional objects used for connection trace.')
atmTracePathTestMandatoryGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 3, 2, 7)).setObjects(("ATM-TRACE-MIB", "atmTracePathTestOwner"), ("ATM-TRACE-MIB", "atmTracePathTestConnType"), ("ATM-TRACE-MIB", "atmTracePathTestConnCastType"), ("ATM-TRACE-MIB", "atmTracePathTestTraceSourceIf"), ("ATM-TRACE-MIB", "atmTracePathTestP2MpNewConn"), ("ATM-TRACE-MIB", "atmTracePathTestOrigVpi"), ("ATM-TRACE-MIB", "atmTracePathTestOrigVci"), ("ATM-TRACE-MIB", "atmTracePathTestCalledParty"), ("ATM-TRACE-MIB", "atmTracePathTestTxTrafDescrIndex"), ("ATM-TRACE-MIB", "atmTracePathTestRxTrafDescrIndex"), ("ATM-TRACE-MIB", "atmTracePathTestClearCallAtTDest"), ("ATM-TRACE-MIB", "atmTracePathTestTraceCrankback"), ("ATM-TRACE-MIB", "atmTracePathTestPassAlongRequest"), ("ATM-TRACE-MIB", "atmTracePathTestAgeTimeout"), ("ATM-TRACE-MIB", "atmTracePathTestRestart"), ("ATM-TRACE-MIB", "atmTracePathTestRecordIndex"), ("ATM-TRACE-MIB", "atmTracePathTestRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmTracePathTestMandatoryGroup = atmTracePathTestMandatoryGroup.setStatus('current')
if mibBuilder.loadTexts: atmTracePathTestMandatoryGroup.setDescription('A collection of objects required when path trace using test connections and test parties is supported.')
atmTracePathTestOptionalGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 3, 2, 8)).setObjects(("ATM-TRACE-MIB", "atmTracePathTestCallingParty"), ("ATM-TRACE-MIB", "atmTracePathTestTraceConnId"), ("ATM-TRACE-MIB", "atmTracePathTestTraceCallRef"), ("ATM-TRACE-MIB", "atmTracePathTestTrapOnCompletion"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmTracePathTestOptionalGroup = atmTracePathTestOptionalGroup.setStatus('current')
if mibBuilder.loadTexts: atmTracePathTestOptionalGroup.setDescription('A collection of optional objects used for path trace using test connections and test parties.')
atmTracePathFilterMandatoryGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 3, 2, 9)).setObjects(("ATM-TRACE-MIB", "atmTraceFilterControl"), ("ATM-TRACE-MIB", "atmTraceFilterOwner"), ("ATM-TRACE-MIB", "atmTraceFilterConnKind"), ("ATM-TRACE-MIB", "atmTraceFilterInIf"), ("ATM-TRACE-MIB", "atmTraceFilterCalledPartyPrefix"), ("ATM-TRACE-MIB", "atmTraceFilterCalledPartyLength"), ("ATM-TRACE-MIB", "atmTraceFilterClearCallAtTDest"), ("ATM-TRACE-MIB", "atmTraceFilterTraceCrankback"), ("ATM-TRACE-MIB", "atmTraceFilterTraceConnId"), ("ATM-TRACE-MIB", "atmTraceFilterTraceCallRef"), ("ATM-TRACE-MIB", "atmTraceFilterPassAlongRequest"), ("ATM-TRACE-MIB", "atmTraceFilterMaxRecords"), ("ATM-TRACE-MIB", "atmTraceFilterStopTimeout"), ("ATM-TRACE-MIB", "atmTraceFilterAgeTimeout"), ("ATM-TRACE-MIB", "atmTraceFilterPurge"), ("ATM-TRACE-MIB", "atmTraceFilterNumMatches"), ("ATM-TRACE-MIB", "atmTraceFilterRowStatus"), ("ATM-TRACE-MIB", "atmTraceFilterRecordConnKind"), ("ATM-TRACE-MIB", "atmTraceFilterRecordConnCastType"), ("ATM-TRACE-MIB", "atmTraceFilterRecordServiceCategory"), ("ATM-TRACE-MIB", "atmTraceFilterRecordInIf"), ("ATM-TRACE-MIB", "atmTraceFilterRecordOutIf"), ("ATM-TRACE-MIB", "atmTraceFilterRecordCallingParty"), ("ATM-TRACE-MIB", "atmTraceFilterRecordCalledParty"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmTracePathFilterMandatoryGroup = atmTracePathFilterMandatoryGroup.setStatus('current')
if mibBuilder.loadTexts: atmTracePathFilterMandatoryGroup.setDescription('A collection of objects required when path trace is supported using filtering of new connection and party establishment messages.')
atmTracePathFilterOptionalGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 3, 2, 10)).setObjects(("ATM-TRACE-MIB", "atmTraceFilterConnCastType"), ("ATM-TRACE-MIB", "atmTraceFilterServiceCategory"), ("ATM-TRACE-MIB", "atmTraceFilterOutIf"), ("ATM-TRACE-MIB", "atmTraceFilterCallingPartyPrefix"), ("ATM-TRACE-MIB", "atmTraceFilterCallingPartyLength"), ("ATM-TRACE-MIB", "atmTraceFilterRecordCountDown"), ("ATM-TRACE-MIB", "atmTraceFilterTrapEnable"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmTracePathFilterOptionalGroup = atmTracePathFilterOptionalGroup.setStatus('current')
if mibBuilder.loadTexts: atmTracePathFilterOptionalGroup.setDescription('A collection of optional objects used for path trace using filtering of new connection and party establishment messages.')
atmTraceIfOptionalGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 3, 2, 11)).setObjects(("ATM-TRACE-MIB", "atmTraceIfTraceBoundary"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmTraceIfOptionalGroup = atmTraceIfOptionalGroup.setStatus('current')
if mibBuilder.loadTexts: atmTraceIfOptionalGroup.setDescription('A collection of optional objects used to configure PNNI interfaces to refuse incoming and terminate outgoing path and connection traces.')
atmTraceNotificationOptionalGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 3, 2, 12)).setObjects(("ATM-TRACE-MIB", "atmTraceConnCompletion"), ("ATM-TRACE-MIB", "atmTracePathTestCompletion"), ("ATM-TRACE-MIB", "atmTracePathFilterTrap"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmTraceNotificationOptionalGroup = atmTraceNotificationOptionalGroup.setStatus('current')
if mibBuilder.loadTexts: atmTraceNotificationOptionalGroup.setDescription('A collection of optional notifications used for path and connection trace.')
atmTraceConnAndPathFilterPolicyMandatoryGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 3, 2, 13)).setObjects(("ATM-TRACE-MIB", "atmTraceInfoNeNsc"), ("ATM-TRACE-MIB", "atmTraceInfoRpNsc"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmTraceConnAndPathFilterPolicyMandatoryGroup = atmTraceConnAndPathFilterPolicyMandatoryGroup.setStatus('current')
if mibBuilder.loadTexts: atmTraceConnAndPathFilterPolicyMandatoryGroup.setDescription('A collection of objects required when supporting connection trace or path trace using filtering of new connection and party establishment messages and policy tracing.')
atmTraceConnPolicyMandatoryGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 3, 2, 14)).setObjects(("ATM-TRACE-MIB", "atmTraceConnTraceNeNsc"), ("ATM-TRACE-MIB", "atmTraceConnTraceRpNsc"), ("ATM-TRACE-MIB", "atmTraceConnTraceIncoming"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmTraceConnPolicyMandatoryGroup = atmTraceConnPolicyMandatoryGroup.setStatus('current')
if mibBuilder.loadTexts: atmTraceConnPolicyMandatoryGroup.setDescription('A collection of objects required when connection trace and policy tracing is supported.')
atmTracePathTestPolicyMandatoryGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 3, 2, 15)).setObjects(("ATM-TRACE-MIB", "atmTracePathTestTraceNeNsc"), ("ATM-TRACE-MIB", "atmTracePathTestTraceRpNsc"), ("ATM-TRACE-MIB", "atmTracePathTestTraceIncoming"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmTracePathTestPolicyMandatoryGroup = atmTracePathTestPolicyMandatoryGroup.setStatus('current')
if mibBuilder.loadTexts: atmTracePathTestPolicyMandatoryGroup.setDescription('A collection of objects required when path trace using test connections and test parties and policy tracing are supported.')
atmTracePathFilterPolicyMandatoryGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 3, 2, 16)).setObjects(("ATM-TRACE-MIB", "atmTraceFilterPolicy"), ("ATM-TRACE-MIB", "atmTraceFilterTraceNeNsc"), ("ATM-TRACE-MIB", "atmTraceFilterTraceRpNsc"), ("ATM-TRACE-MIB", "atmTraceFilterTraceIncoming"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmTracePathFilterPolicyMandatoryGroup = atmTracePathFilterPolicyMandatoryGroup.setStatus('current')
if mibBuilder.loadTexts: atmTracePathFilterPolicyMandatoryGroup.setDescription('A collection of objects required when path trace using filtering of new connection and party establishment messages and policy tracing is supported.')
atmTraceConnAndPathFilterMplsMandatoryGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 3, 2, 17)).setObjects(("ATM-TRACE-MIB", "atmTraceRecordTraceDestReceiveLabel"), ("ATM-TRACE-MIB", "atmTraceRecordTraceDestTransmitLabel"), ("ATM-TRACE-MIB", "atmTraceInfoReceiveLabel"), ("ATM-TRACE-MIB", "atmTraceInfoTransmitLabel"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmTraceConnAndPathFilterMplsMandatoryGroup = atmTraceConnAndPathFilterMplsMandatoryGroup.setStatus('current')
if mibBuilder.loadTexts: atmTraceConnAndPathFilterMplsMandatoryGroup.setDescription('A collection of objects required when supporting connection trace or path trace using filtering of new connection and party establishment messages and interworking LSP label tracing.')
atmTraceConnMplsMandatoryGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 3, 2, 18)).setObjects(("ATM-TRACE-MIB", "atmTraceConnTraceLabels"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmTraceConnMplsMandatoryGroup = atmTraceConnMplsMandatoryGroup.setStatus('current')
if mibBuilder.loadTexts: atmTraceConnMplsMandatoryGroup.setDescription('A collection of objects required when connection trace and interworking LSP label tracing is supported.')
atmTracePathTestMplsMandatoryGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 3, 2, 19)).setObjects(("ATM-TRACE-MIB", "atmTracePathTestTraceLabels"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmTracePathTestMplsMandatoryGroup = atmTracePathTestMplsMandatoryGroup.setStatus('current')
if mibBuilder.loadTexts: atmTracePathTestMplsMandatoryGroup.setDescription('A collection of objects required when path trace using test connections and test parties and interworking LSP label tracing are supported.')
atmTracePathFilterMplsMandatoryGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 3, 2, 20)).setObjects(("ATM-TRACE-MIB", "atmTraceFilterTraceLabels"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmTracePathFilterMplsMandatoryGroup = atmTracePathFilterMplsMandatoryGroup.setStatus('current')
if mibBuilder.loadTexts: atmTracePathFilterMplsMandatoryGroup.setDescription('A collection of objects required when path trace using filtering of new connection and party establishment messages and interworking LSP label tracing is supported.')
atmTraceMIBCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 353, 5, 9, 2, 1, 3, 1, 1)).setObjects(("ATM-TRACE-MIB", "atmTraceMIBMandatoryGroup"), ("ATM-TRACE-MIB", "atmTraceConnAndPathFilterMandatoryGroup"), ("ATM-TRACE-MIB", "atmTracePathMandatoryGroup"), ("ATM-TRACE-MIB", "atmTraceConnMandatoryGroup"), ("ATM-TRACE-MIB", "atmTracePathTestMandatoryGroup"), ("ATM-TRACE-MIB", "atmTracePathFilterMandatoryGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmTraceMIBCompliance = atmTraceMIBCompliance.setStatus('deprecated')
if mibBuilder.loadTexts: atmTraceMIBCompliance.setDescription('The compliance statement for entities which implement the PNNI Addendum for Path and Connection Trace Version 1.0. Groups of objects required to support certain functionality are identified by the suffix MandatoryGroup. Groups of optional objects are identified by the suffix OptionalGroup.')
mibBuilder.exportSymbols("ATM-TRACE-MIB", atmTraceFilterTraceConnId=atmTraceFilterTraceConnId, atmTraceRecordDiags=atmTraceRecordDiags, atmTraceConnTraceConnId=atmTraceConnTraceConnId, atmTraceRecordEntry=atmTraceRecordEntry, atmTraceInfoNeNscInterface=atmTraceInfoNeNscInterface, atmTraceRecordTable=atmTraceRecordTable, atmTracePathMandatoryGroup=atmTracePathMandatoryGroup, atmTraceRecordTraceSourceDlci=atmTraceRecordTraceSourceDlci, atmTracePathFilterTrap=atmTracePathFilterTrap, atmTraceRecordTraceDestCallRef=atmTraceRecordTraceDestCallRef, atmTraceInfoTable=atmTraceInfoTable, atmTraceFilterControl=atmTraceFilterControl, atmTraceConnOrigDirection=atmTraceConnOrigDirection, atmTracePathFilterOptionalGroup=atmTracePathFilterOptionalGroup, AtmTraceRecordIndex=AtmTraceRecordIndex, atmTraceMIBTrapsPrefix=atmTraceMIBTrapsPrefix, atmTraceConnAndPathFilterPolicyMandatoryGroup=atmTraceConnAndPathFilterPolicyMandatoryGroup, atmfSignalling=atmfSignalling, atmTracePathTestTable=atmTracePathTestTable, atmTracePathTestTraceLabels=atmTracePathTestTraceLabels, atmTraceIfTable=atmTraceIfTable, atmTraceFilterRecordOutIf=atmTraceFilterRecordOutIf, atmTracePathTestIndex=atmTracePathTestIndex, atmTracePathTestConnCastType=atmTracePathTestConnCastType, atmTraceConnTraceCallRef=atmTraceConnTraceCallRef, atmTracePathTestMplsMandatoryGroup=atmTracePathTestMplsMandatoryGroup, atmTraceConnRestart=atmTraceConnRestart, atmTraceConnOwner=atmTraceConnOwner, atmTraceFilterPolicy=atmTraceFilterPolicy, atmTraceFilterPurge=atmTraceFilterPurge, atmTraceConnEntry=atmTraceConnEntry, atmTraceFilterNumMatches=atmTraceFilterNumMatches, atmTracePathTestTraceNeNsc=atmTracePathTestTraceNeNsc, atmTraceMIBOptionalGroup=atmTraceMIBOptionalGroup, atmTraceInfoRpNscSequenceIndex=atmTraceInfoRpNscSequenceIndex, atmTraceFilterOutIf=atmTraceFilterOutIf, atmTraceConnCallRef=atmTraceConnCallRef, atmTraceInfoRpNsc=atmTraceInfoRpNsc, atmTraceFilterRecordInIf=atmTraceFilterRecordInIf, atmTracePathTestOrigVpi=atmTracePathTestOrigVpi, atmTraceConnMplsMandatoryGroup=atmTraceConnMplsMandatoryGroup, atmTraceFilterRecordCalledParty=atmTraceFilterRecordCalledParty, atmTraceRecordIndex=atmTraceRecordIndex, atmTraceInfoTransmitLabel=atmTraceInfoTransmitLabel, atmTraceConnTraceIncoming=atmTraceConnTraceIncoming, atmTraceFilterRecordTable=atmTraceFilterRecordTable, atmTraceInfoRefusalIndicator=atmTraceInfoRefusalIndicator, atmTraceInfoNeNscTable=atmTraceInfoNeNscTable, atmTracePathTestConnType=atmTracePathTestConnType, atmTraceInfoCrankBackRcvdAtDest=atmTraceInfoCrankBackRcvdAtDest, atmTraceConnGroup=atmTraceConnGroup, atmTracePathTestTraceCallRef=atmTracePathTestTraceCallRef, atmTraceInfoEntry=atmTraceInfoEntry, atmTraceFilterGroup=atmTraceFilterGroup, AtmEndPointReference=AtmEndPointReference, atmTracePathTestPolicyMandatoryGroup=atmTracePathTestPolicyMandatoryGroup, atmTracePathFilterMandatoryGroup=atmTracePathFilterMandatoryGroup, atmTraceFilterCalledPartyLength=atmTraceFilterCalledPartyLength, atmTraceConnCompletion=atmTraceConnCompletion, atmTracePathTestRxTrafDescrIndex=atmTracePathTestRxTrafDescrIndex, atmTraceMIBMandatoryGroup=atmTraceMIBMandatoryGroup, atmTraceConnTable=atmTraceConnTable, atmTraceAvailableRequests=atmTraceAvailableRequests, atmTraceInfoNeNsc=atmTraceInfoNeNsc, atmTracePathTestGroup=atmTracePathTestGroup, atmTraceFilterTraceIncoming=atmTraceFilterTraceIncoming, atmTracePathTestTxTrafDescrIndex=atmTracePathTestTxTrafDescrIndex, atmTraceConnPassAlongRequest=atmTraceConnPassAlongRequest, atmTracePathTestTraceRpNsc=atmTracePathTestTraceRpNsc, atmTraceFilterCallingPartyLength=atmTraceFilterCallingPartyLength, atmTraceRecordTimeStamp=atmTraceRecordTimeStamp, atmTraceFilterTraceRpNsc=atmTraceFilterTraceRpNsc, atmTraceInfoRpNscInterface=atmTraceInfoRpNscInterface, atmTraceRecordTraceDestTransmitLabel=atmTraceRecordTraceDestTransmitLabel, atmTraceIfTraceBoundary=atmTraceIfTraceBoundary, atmTraceConnOptionalGroup=atmTraceConnOptionalGroup, atmTraceConnMandatoryGroup=atmTraceConnMandatoryGroup, atmTraceConnTraceLabels=atmTraceConnTraceLabels, atmTraceRecordGroup=atmTraceRecordGroup, atmTraceFilterPassAlongRequest=atmTraceFilterPassAlongRequest, atmTraceRecordTraceDestVci=atmTraceRecordTraceDestVci, atmTraceConnTrapOnCompletion=atmTraceConnTrapOnCompletion, atmTracePathTestTraceConnId=atmTracePathTestTraceConnId, atmTraceFilterOwner=atmTraceFilterOwner, atmTraceConnEndPtRef=atmTraceConnEndPtRef, atmTracePathTestClearCallAtTDest=atmTracePathTestClearCallAtTDest, atmTracePathTestPolicyConstraint=atmTracePathTestPolicyConstraint, atmTracePathTestMandatoryGroup=atmTracePathTestMandatoryGroup, atmTraceIfOptionalGroup=atmTraceIfOptionalGroup, atmTracePathTestTraceIncoming=atmTracePathTestTraceIncoming, atmTraceInfoNeNscEntry=atmTraceInfoNeNscEntry, atmTraceFilterTraceNeNsc=atmTraceFilterTraceNeNsc, atmTraceInfoCrankBackCause=atmTraceInfoCrankBackCause, atmTraceFilterConnCastType=atmTraceFilterConnCastType, atmTraceFilterInIf=atmTraceFilterInIf, atmTracePathTestEntry=atmTracePathTestEntry, atmTraceConnTraceNeNsc=atmTraceConnTraceNeNsc, CallReference=CallReference, atmTraceRecordTraceSourcePortId=atmTraceRecordTraceSourcePortId, atmTraceMIBCompliance=atmTraceMIBCompliance, atmTraceFilterClearCallAtTDest=atmTraceFilterClearCallAtTDest, atmTraceInfoNodeId=atmTraceInfoNodeId, atmTraceRecordTraceDestReceiveLabel=atmTraceRecordTraceDestReceiveLabel, atmTraceMIBConformance=atmTraceMIBConformance, atmTraceInfoRpNscEntry=atmTraceInfoRpNscEntry, atmTraceConnAgeTimeout=atmTraceConnAgeTimeout, atmTraceInfoCrankBackGap=atmTraceInfoCrankBackGap, atmTraceInfoReceiveLabel=atmTraceInfoReceiveLabel, atmTracePathTestAgeTimeout=atmTracePathTestAgeTimeout, atmTraceFilterRecordServiceCategory=atmTraceFilterRecordServiceCategory, atmTraceMaxConcurrentRequests=atmTraceMaxConcurrentRequests, atmTraceRecordStatus=atmTraceRecordStatus, atmTraceInfoCrankBackIndicator=atmTraceInfoCrankBackIndicator, atmTracePathTestTrapOnCompletion=atmTracePathTestTrapOnCompletion, atmTraceFilterIndex=atmTraceFilterIndex, atmTraceRecordTraceDestEndPtRef=atmTraceRecordTraceDestEndPtRef, atmTraceConnIndex=atmTraceConnIndex, atmTraceMIBCompliances=atmTraceMIBCompliances, atmTraceFilterStopTimeout=atmTraceFilterStopTimeout, atmTraceMIB=atmTraceMIB, atmTraceConnOrigConnType=atmTraceConnOrigConnType, atmTraceInfoIncomingVci=atmTraceInfoIncomingVci, atmForum=atmForum, atmTraceFilterRecordCountDown=atmTraceFilterRecordCountDown, atmTraceMIBCompliance2=atmTraceMIBCompliance2, atmTraceFilterTrapEnable=atmTraceFilterTrapEnable, atmTraceFilterRecordConnKind=atmTraceFilterRecordConnKind, atmTraceConnTraceRpNsc=atmTraceConnTraceRpNsc, atmTraceFilterRecordConnCastType=atmTraceFilterRecordConnCastType, atmTraceInfoSequenceIndex=atmTraceInfoSequenceIndex, atmTraceInfoCrankBackBlockedTransitType=atmTraceInfoCrankBackBlockedTransitType, atmTraceConnAndPathFilterMplsMandatoryGroup=atmTraceConnAndPathFilterMplsMandatoryGroup, atmTracePathTestCalledParty=atmTracePathTestCalledParty, atmTraceMIBTraps=atmTraceMIBTraps, atmTraceConnPolicyMandatoryGroup=atmTraceConnPolicyMandatoryGroup, atmTraceInfoIncomingVpi=atmTraceInfoIncomingVpi, atmTraceFilterCalledPartyPrefix=atmTraceFilterCalledPartyPrefix, atmTracePathTestCompletion=atmTracePathTestCompletion, atmTraceInfoIncomingEndPtRef=atmTraceInfoIncomingEndPtRef, PYSNMP_MODULE_ID=atmTraceMIB, atmTraceFilterConnKind=atmTraceFilterConnKind, atmTraceFilterTraceCallRef=atmTraceFilterTraceCallRef, atmTraceConnRowStatus=atmTraceConnRowStatus, atmTraceConnOrigVpi=atmTraceConnOrigVpi, atmTracePathTestRestart=atmTracePathTestRestart, atmTraceFilterTraceLabels=atmTraceFilterTraceLabels, atmTraceFilterRecordCallingParty=atmTraceFilterRecordCallingParty, atmTracePathTestRowStatus=atmTracePathTestRowStatus, atmTraceIfGroup=atmTraceIfGroup, atmTraceBaseGroup=atmTraceBaseGroup, atmTraceInfoIncomingCallRef=atmTraceInfoIncomingCallRef, AtmTraceOwnerString=AtmTraceOwnerString, atmTraceConnOrigVci=atmTraceConnOrigVci, atmTraceFilterRecordEntry=atmTraceFilterRecordEntry, atmTraceNotificationOptionalGroup=atmTraceNotificationOptionalGroup, atmTraceRecordTraceDestDlci=atmTraceRecordTraceDestDlci, atmTraceIfEntry=atmTraceIfEntry, atmTraceFilterTable=atmTraceFilterTable, atmTraceInfoCrankBackBlockedTransitInfo=atmTraceInfoCrankBackBlockedTransitInfo, atmTraceConnAndPathFilterMandatoryGroup=atmTraceConnAndPathFilterMandatoryGroup, atmTracePathTestOptionalGroup=atmTracePathTestOptionalGroup, atmTracePathFilterPolicyMandatoryGroup=atmTracePathFilterPolicyMandatoryGroup, atmTracePathTestP2MpNewConn=atmTracePathTestP2MpNewConn, atmTraceFilterEntry=atmTraceFilterEntry, atmTraceInfoOutgoingPortId=atmTraceInfoOutgoingPortId, atmTracePathTestTraceSourceIf=atmTracePathTestTraceSourceIf, atmTraceMIBObjects=atmTraceMIBObjects, atmTracePathTestOrigVci=atmTracePathTestOrigVci, atmTraceConnOrigDlci=atmTraceConnOrigDlci, atmTraceConnFailTimeout=atmTraceConnFailTimeout, atmTraceFilterRecordIndex=atmTraceFilterRecordIndex, atmTraceFilterTraceCrankback=atmTraceFilterTraceCrankback, atmTraceFilterServiceCategory=atmTraceFilterServiceCategory, atmTraceInfoNeNscIndex=atmTraceInfoNeNscIndex, atmTraceConnTraceSourceIf=atmTraceConnTraceSourceIf, atmTracePathTestCallingParty=atmTracePathTestCallingParty, atmfTrace=atmfTrace, atmTracePathTestOwner=atmTracePathTestOwner, atmTracePathTestPassAlongRequest=atmTracePathTestPassAlongRequest, atmTraceMIBGroups=atmTraceMIBGroups, atmTraceFilterRowStatus=atmTraceFilterRowStatus, atmTracePathTestTraceCrankback=atmTracePathTestTraceCrankback, atmTraceInfoRpNscTable=atmTraceInfoRpNscTable, atmTracePathTestRecordIndex=atmTracePathTestRecordIndex, atmForumNetworkManagement=atmForumNetworkManagement, atmTraceRecordTraceDestVpi=atmTraceRecordTraceDestVpi, atmTraceFilterAgeTimeout=atmTraceFilterAgeTimeout, atmTraceFilterCallingPartyPrefix=atmTraceFilterCallingPartyPrefix, atmTraceFilterMaxRecords=atmTraceFilterMaxRecords, atmTracePathFilterMplsMandatoryGroup=atmTracePathFilterMplsMandatoryGroup, atmTraceConnRecordIndex=atmTraceConnRecordIndex, atmTraceRecordCause=atmTraceRecordCause, atmTraceTransitListMaximumSize=atmTraceTransitListMaximumSize)

#
# PySNMP MIB module Wellfleet-FDDI-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/Wellfleet-FDDI-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:40:08 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueSizeConstraint, ConstraintsIntersection, ConstraintsUnion, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsIntersection", "ConstraintsUnion", "ValueRangeConstraint")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
iso, Gauge32, ObjectIdentity, Counter64, Unsigned32, Counter32, Integer32, Bits, MibIdentifier, IpAddress, TimeTicks, ModuleIdentity, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn = mibBuilder.importSymbols("SNMPv2-SMI", "iso", "Gauge32", "ObjectIdentity", "Counter64", "Unsigned32", "Counter32", "Integer32", "Bits", "MibIdentifier", "IpAddress", "TimeTicks", "ModuleIdentity", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
wfFddiGroup, wfLine = mibBuilder.importSymbols("Wellfleet-COMMON-MIB", "wfFddiGroup", "wfLine")
wfFddiSmtGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 1))
wfFddiMacGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 2))
wfFddiPathGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 3))
wfFddiPortGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 4))
wfFddiXGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 5))
wfFddiTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 4), )
if mibBuilder.loadTexts: wfFddiTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiTable.setDescription('FDDI line record')
wfFddiEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1), ).setIndexNames((0, "Wellfleet-FDDI-MIB", "wfFDDISlot"), (0, "Wellfleet-FDDI-MIB", "wfFDDINode"))
if mibBuilder.loadTexts: wfFddiEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiEntry.setDescription('An entry in the FDDI table')
wfFDDIDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("create", 1), ("delete", 2))).clone('create')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFDDIDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDIDelete.setDescription('Create/delete parameter, default = create.')
wfFDDIEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFDDIEnable.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDIEnable.setDescription('Enable/disable parameter, default = enable.')
wfFDDIState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("init", 3), ("notpresent", 4))).clone('notpresent')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFDDIState.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDIState.setDescription('Line driver state variable, not present, init, down, up.')
wfFDDISlot = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 14))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFDDISlot.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDISlot.setDescription('Instance ID slot - filled in by driver.')
wfFDDINode = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 44))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFDDINode.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDINode.setDescription("Instance ID node - filled in by driver. For the ASN this attribute is an encoded value and is equal to 'module'*10 + 'node'. Where 'module' is defined in attribute 50 and 'node' is defined in attribute 51 of this table. For non-ASN platforms this attribute indicates the physical node number on the slot")
wfFDDICct = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1023))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFDDICct.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDICct.setDescription('Cct number for this line instance.')
wfFDDIBofl = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFDDIBofl.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDIBofl.setDescription('The Breath-Of-Life (BOFL) function, when enabled, will disable the LLC interface when the FDDI becomes non-operational (i.e., link unavailable) and the following conditions are true: 1. The wfFddiMacMaUnitDataEnable attribute is enabled. 2. The BOFL timer expired (specified by wfFDDIBoflTmo). If this attribute is disabled, the LLC interface will be terminated immediately after the link becomes unavailable. ')
wfFDDIBoflTmo = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3600)).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFDDIBoflTmo.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDIBoflTmo.setDescription('Specifies the time value (in seconds) of the BOFL timer. The BOFL timer will be set to the value of this attribute when the following conditions are true: 1. The wfFDDIBofl attribute is enabled. 2. The link becomes unavailable. Upon expiration of the BOFL timer, the LLC interface will be disabled. Note also that the BOFL timer will be disabled if the link becomes operational (available) before the timer expires..')
wfFDDIMtu = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4495))).clone(namedValues=NamedValues(("default", 4495))).clone('default')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFDDIMtu.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDIMtu.setDescription('The MTU is the maximum allowed frame length on the wire, excluding frame delimiters (i.e. preamble, ending delimiter). The MTU of an FDDI frame includes: FC (1 octet) + DA (6 octets) + SA (6 octets) + INFO (<= 4478 octets) + FCS (4 octets) = 4495 octets')
wfFDDIMadr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 10), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFDDIMadr.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDIMadr.setDescription('PROM-based MAC address, fixed - line driver fills in.')
wfFDDIOctetsRxOk = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFDDIOctetsRxOk.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDIOctetsRxOk.setDescription('Number of bytes received without error. This byte count only includes LLC frames (i.e. no MAC and SMT frames).')
wfFDDIFramesRxOk = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFDDIFramesRxOk.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDIFramesRxOk.setDescription('Number of frames received without error. This frame count only includes LLC frames (i.e. no MAC and SMT frames).')
wfFDDIOctetsTxOk = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFDDIOctetsTxOk.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDIOctetsTxOk.setDescription('Number of bytes transmitted without error. This byte count only includes LLC and SMT frames (i.e. no MAC frames).')
wfFDDIFramesTxOk = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFDDIFramesTxOk.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDIFramesTxOk.setDescription('Number of frames transmitted without error. This frame count only includes LLC and SMT frames (i.e. no MAC frames ).')
wfFDDICrcErrRx = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFDDICrcErrRx.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDICrcErrRx.setDescription('Number of frames received with CRC errors.')
wfFDDIOverrunRx = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFDDIOverrunRx.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDIOverrunRx.setDescription('Number of frames received with internal overrun errors.')
wfFDDIParityErrRx = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFDDIParityErrRx.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDIParityErrRx.setDescription('Number of frames received with parity errors.')
wfFDDIMacErrRx = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFDDIMacErrRx.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDIMacErrRx.setDescription('Number of frames received with MAC errors.')
wfFDDIRingErrRx = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFDDIRingErrRx.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDIRingErrRx.setDescription('Number of receive ring error events.')
wfFDDISmtRingErrRx = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFDDISmtRingErrRx.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDISmtRingErrRx.setDescription('Number of SMT receive ring error events.')
wfFDDIRingOverrunRx = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFDDIRingOverrunRx.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDIRingOverrunRx.setDescription('Number of LLC receive ring overrun events.')
wfFDDISmtRingOverrunRx = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFDDISmtRingOverrunRx.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDISmtRingOverrunRx.setDescription('Number of SMT receive ring overrun events.')
wfFDDIAbortTx = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFDDIAbortTx.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDIAbortTx.setDescription('Number of transmit frames with internal abort errors.')
wfFDDIUnderrunTx = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFDDIUnderrunTx.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDIUnderrunTx.setDescription('Number of transmit frames aborted with underrun errors.')
wfFDDIParityErrTx = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFDDIParityErrTx.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDIParityErrTx.setDescription('Number of transmit frames aborted with parity errors.')
wfFDDIRingErrTx = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFDDIRingErrTx.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDIRingErrTx.setDescription('Number of LLC/SMT transmit ring error events.')
wfFDDIPortOpErr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFDDIPortOpErr.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDIPortOpErr.setDescription('Number of port operation error events.')
wfFDDIInternOpErr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFDDIInternOpErr.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDIInternOpErr.setDescription('Number of internal operation error events.')
wfFDDIHostErr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFDDIHostErr.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDIHostErr.setDescription('Number of host error events.')
wfFDDISmtConnectionPolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(65381))).clone(namedValues=NamedValues(("default", 65381))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFDDISmtConnectionPolicy.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDISmtConnectionPolicy.setDescription("A value that indicates the connection policies enforced at the station. A station sets the corresponding policy for each of the connection types that it rejects. The letter designations, X and Y, in the 'rejectX-Y' names have the following significance: X represents the PC-Type of the local PORT and Y represents a PC-Neighbor in the evaluation of Connection-Policy (PC-Type, PC- Neighbor) that is done to determine the setting of T-Val(3) in the PC-Signaling sequence. The value is a sum. This value initially takes the value zero, then for each of the connection policies currently enforced on the node, 2 raised to a power is added to the sum. The powers are according to the following table: Policy Power rejectA-A 0 rejectA-B 1 rejectA-S 2 rejectA-M 3 rejectB-A 4 rejectB-B 5 rejectB-S 6 rejectB-M 7 rejectS-A 8 rejectS-B 9 rejectS-S 10 rejectS-M 11 rejectM-A 12 rejectM-B 13 rejectM-S 14 rejectM-M 15")
wfFDDISmtTNotify = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 31), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 30)).clone(22)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFDDISmtTNotify.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDISmtTNotify.setDescription('The timer used in the Neighbor Notification protocol, reported in seconds and ranging from 2 to 30 seconds.')
wfFDDIMacTReq = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2062500))).clone(namedValues=NamedValues(("default", 2062500))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFDDIMacTReq.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDIMacTReq.setDescription("Specifies the maximum time value of 'wfFddiPathMaxTReq' that shall be used by any MAC that is configured in this path. The operational value of 'wfFddiPathMaxTReq' is managed by setting this attribute. This attribute has the time value range of: wfFddiPathTvxLowerBound < wfFddiMacTReq <= wfFddiPathTMaxLowerBound. Time specified in octet units. The default value of this attribute is 165 msec. The name of this attribute in the IETF MIB is FddiMibPATHMaxTReq. To convert 165 milliseconds to octet units of 80 nanaseconds: T_Req Nanaoseconds = ((165 * 1000 * 1000) / 80) = 2062500 To convert 2062500 octet units of 80 nanoseconds to milliseconds: T_Req Milliseconds = ((2062500 / 12.5) / 1000) = 165")
wfFDDIMacTMax = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 33), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFDDIMacTMax.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDIMacTMax.setDescription('The requested maximum TTRT to be supported by a MAC represented in unsigned integer specifying time in octet units (80 nanoseconds).')
wfFDDIMacTvxValue = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 34), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFDDIMacTvxValue.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDIMacTvxValue.setDescription('The requested value of TvxValue represented in unsigned integer specifying time in octet units (80 nanoseconds).')
wfFDDIMacTMin = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(50000))).clone(namedValues=NamedValues(("default", 50000))).clone('default')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFDDIMacTMin.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDIMacTMin.setDescription('The requested minimum TTRT to be requested by a MAC represented in unsigned integer specifying time in octet units (80 nanoseconds).')
wfFDDIHardwareFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 36), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFDDIHardwareFilter.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDIHardwareFilter.setDescription('Hardware filter (CAM) parameter.')
wfFDDISmtEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 37), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFDDISmtEnable.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDISmtEnable.setDescription('Enable Station Management periodic timer and NIF protocol.')
wfFDDITxQueueLength = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 38), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFDDITxQueueLength.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDITxQueueLength.setDescription('Current Transmit Queue Length')
wfFDDIRxQueueLength = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 39), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFDDIRxQueueLength.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDIRxQueueLength.setDescription('Current Receive Queue Length')
wfFDDITxClipFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 40), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFDDITxClipFrames.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDITxClipFrames.setDescription("Number of frames clipped in driver's transmit routine due to transmit congestion.")
wfFDDIRxReplenMisses = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 41), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFDDIRxReplenMisses.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDIRxReplenMisses.setDescription('Number of packet buffer misses while attempting to replenish driver receive ring.')
wfFDDICfgTxQueueLength = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 42), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFDDICfgTxQueueLength.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDICfgTxQueueLength.setDescription('Configured Transmit Queue Length. Values other than zero over-ride the router selected values. A value of zero has a special meaning. Zero causes router based default values to be used. Values larger than the compiled ring size are truncated to the compiled ring size.')
wfFDDICfgRxQueueLength = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 43), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFDDICfgRxQueueLength.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDICfgRxQueueLength.setDescription('Configured Receive Queue Length. Values other than zero over-ride the router selected values. A value of zero has a special meaning. Zero cuases router based default values to be used. Values larger than the compiled ring size are truncated to the compiled ring size.')
wfFDDILineNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 44), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFDDILineNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDILineNumber.setDescription('Logical line number associated with this driver entity.')
wfFDDIForcePeerTree = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 45), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFDDIForcePeerTree.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDIForcePeerTree.setDescription("This attribute allows all FDDI Peer/Tree connections to reach the 'Thru' state. This is done to give the user some flexibility and allow them to Daisy Chain their Phy connections, mixing Tree & Peer connections. This type of daisy chaining DOES NOT conform to the SMT standard and is NOT recommended as it may result in a less than optimum token path. Normally when we have a Peer/Tree connection mix, we will wrap the connection, favoring PHY B.")
wfFDDIInvalidFrameStatusRx = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 46), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFDDIInvalidFrameStatusRx.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDIInvalidFrameStatusRx.setDescription('A count of the number of badly formed frames received off of the FDDI ring. These are frames which do not contain a valid Frame Status field of at least 3 control indicator symbols (i.e. E, A, C, flags).')
wfFDDIRxOversizedFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 47), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFDDIRxOversizedFrames.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDIRxOversizedFrames.setDescription('Number of LLC frames received whose length exceeded the MTU.')
wfFDDIRxSmtOversizedFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 48), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFDDIRxSmtOversizedFrames.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDIRxSmtOversizedFrames.setDescription('Number of SMT frames received whose length exceeded the MTU.')
wfFDDIRxUndersizedFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 49), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFDDIRxUndersizedFrames.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDIRxUndersizedFrames.setDescription('Number of LLC frames received whose length was less than 20 bytes including the FC byte and a 4 byte CRC.')
wfFDDIRxSmtUndersizedFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 50), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFDDIRxSmtUndersizedFrames.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDIRxSmtUndersizedFrames.setDescription('Number of SMT frames received whose length was less than 37 bytes including the FC byte and a 4 byte CRC.')
wfFDDIModule = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 51), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("one", 1), ("two", 2), ("three", 3), ("four", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFDDIModule.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDIModule.setDescription('Module number for ASN platform, filled in by driver. For non-ASN platforms this attribute will not be used.')
wfFDDIActualNode = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 52), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("one", 1), ("two", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFDDIActualNode.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDIActualNode.setDescription('Actual Node number for ASN platform, filled in by driver. For non-ASN platforms, this attribute will not be used.')
wfFDDILastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 53), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFDDILastChange.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDILastChange.setDescription("The value of SysUpTime at the time the interface entered it's current operational state (UP state). SysUpTime is defined as the time (in hundredths of a second) since the network management portion of the system was last re-initialized. Usually the time since boot.")
wfFDDIOutQLen = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 54), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFDDIOutQLen.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDIOutQLen.setDescription('The instantaneous current length of the output packet queue (in packets).')
wfFDDIRxSmtOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 55), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFDDIRxSmtOctets.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDIRxSmtOctets.setDescription('Number of bytes received without error. This byte count only includes SMT frames (i.e. no MAC and LLC frames).')
wfFDDIRxSmtFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 56), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFDDIRxSmtFrames.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDIRxSmtFrames.setDescription('Number of frames received without error. This frame count only includes SMT frames (i.e. no MAC and LLC frames).')
wfFDDIIntProcessings = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 57), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFDDIIntProcessings.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDIIntProcessings.setDescription('Counts the number of times the interrupt service routine has been called ')
wfFDDITxProcessings = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 58), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFDDITxProcessings.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDITxProcessings.setDescription('Counts the number of times the transmit routine fsi_xmt_oper_act(), has been called ')
wfFDDIRxProcessings = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 59), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFDDIRxProcessings.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDIRxProcessings.setDescription('Counts the number of times RINT processing takes place in the interrupt service routine. ')
wfFDDITxRNRProcessings = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 60), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFDDITxRNRProcessings.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDITxRNRProcessings.setDescription('Counts the number of times the transmit complete routine fsi_xmt_cmpl(), has been called ')
wfFDDISmtRxProcessings = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 61), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFDDISmtRxProcessings.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDISmtRxProcessings.setDescription('Counts the number of time RINT was processing was performed on the SMT receive ring.')
wfFDDIPhyALogPtr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 62), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFDDIPhyALogPtr.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDIPhyALogPtr.setDescription('Address of the Debug Phy Event Buffer for Phy A. This attribute is strictly for diagnostic purposes. The size of the buffer is 1028 bytes.')
wfFDDIPhyBLogPtr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 63), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFDDIPhyBLogPtr.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDIPhyBLogPtr.setDescription('Address of the Debug Phy Event Buffer for Phy B. This attribute is strictly for diagnostic purposes. The size of the buffer is 1028 bytes.')
wfFDDIPromiscuous = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 64), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFDDIPromiscuous.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDIPromiscuous.setDescription('For now this attribute is used only in BNX code !!! The promiscuous parameter allows address filtering based on the destination MAC addresses. When enabled, all frames are received, disabled indicates only frames destined for this local address and any functional group address are received.')
wfFDDILLCFrameControl = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 65), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("async", 1), ("sync", 2))).clone('async')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFDDILLCFrameControl.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDILLCFrameControl.setDescription('Frame control used for LLC frames, using synchronous frames for reserved priority traffic when specified.')
wfFDDITurboBofl = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 66), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFDDITurboBofl.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDITurboBofl.setDescription('DEBUG parameter - Turbo bofl enabled or disabled, by adjusting BoflNum and BoflLen bofl packets can be made to fill the links available bandwith. This function is not a faster parallel of the wfFDDIBofl feature it does not opperate on a disabled LLC interface')
wfFDDIBoflNum = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 67), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFDDIBoflNum.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDIBoflNum.setDescription('DEBUG parameter - Number of breath of life packets per breath of life')
wfFDDIBoflLen = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 68), Integer32().subtype(subtypeSpec=ValueRangeConstraint(22, 4450)).clone(200)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFDDIBoflLen.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDIBoflLen.setDescription('DEBUG parameter - breath of life packet length')
wfFddiSmtTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 1, 2), )
if mibBuilder.loadTexts: wfFddiSmtTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiSmtTable.setDescription('A list of SMT entries.')
wfFddiSmtEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 1, 2, 1), ).setIndexNames((0, "Wellfleet-FDDI-MIB", "wfFddiSmtSlot"), (0, "Wellfleet-FDDI-MIB", "wfFddiSmtNode"))
if mibBuilder.loadTexts: wfFddiSmtEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiSmtEntry.setDescription('A SMT entry containing information common to a given SMT.')
wfFddiSmtSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 1, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiSmtSlot.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiSmtSlot.setDescription('Slot number associated with an SMT entity.')
wfFddiSmtNode = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 1, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiSmtNode.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiSmtNode.setDescription('Node/connector number associated with an SMT entity.')
wfFddiSmtCct = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 1, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiSmtCct.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiSmtCct.setDescription('Circuit number associated with an SMT entity.')
wfFddiSmtStationId = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 1, 2, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiSmtStationId.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiSmtStationId.setDescription('Unique identifier of an FDDI station.')
wfFddiSmtOpVersionId = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 1, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiSmtOpVersionId.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiSmtOpVersionId.setDescription('The version that this station is using for its operation.')
wfFddiSmtMacCt = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 1, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiSmtMacCt.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiSmtMacCt.setDescription('The number of MACs in a station.')
wfFddiSmtNonMasterCt = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 1, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiSmtNonMasterCt.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiSmtNonMasterCt.setDescription('The number of non master ports (A, B, or S PORTs) in a station.')
wfFddiSmtEcmState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 1, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("out", 1), ("in", 2), ("trace", 3), ("leave", 4), ("pathtest", 5), ("insert", 6), ("check", 7), ("deinsert", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiSmtEcmState.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiSmtEcmState.setDescription('Indicates the current state of the ECM state machine.')
wfFddiSmtCfState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 1, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("isolated", 1), ("wraps", 2), ("wrapa", 3), ("wrapb", 4), ("wrapab", 5), ("thru", 6), ("locala", 7), ("localb", 8), ("localab", 9), ("locals", 10), ("cwrapa", 11), ("cwrapb", 12), ("cwraps", 13)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiSmtCfState.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiSmtCfState.setDescription('The attachment configuration for a station.')
wfFddiSmtBypassPresent = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 1, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiSmtBypassPresent.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiSmtBypassPresent.setDescription('A flag indicating if the station has an optical bypass on its A/B port pair.')
wfFddiSmtRemoteDisconnectFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 1, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiSmtRemoteDisconnectFlag.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiSmtRemoteDisconnectFlag.setDescription("A flag indicating that the station was remotely disconnected from the network as a result of receiving an 'wfFddiSmtStationAction' disconnect in a Parameter Management Frame. A station requires a Connect Action to rejoin & clear the flag.")
wfFddiSmtStationStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 1, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("concatenated", 1), ("seperated", 2), ("thru", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiSmtStationStatus.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiSmtStationStatus.setDescription('This variable indicates the current state of the primary and secondary paths within this station.')
wfFddiSmtPeerWrapFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 1, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiSmtPeerWrapFlag.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiSmtPeerWrapFlag.setDescription("This variable assumes the value of the 'PeerWrapFlag' in CFM.")
wfFddiSmtExtTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 1, 3), )
if mibBuilder.loadTexts: wfFddiSmtExtTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiSmtExtTable.setDescription('A list of SMT extension entries.')
wfFddiSmtExtEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 1, 3, 1), ).setIndexNames((0, "Wellfleet-FDDI-MIB", "wfFddiSmtExtSlot"), (0, "Wellfleet-FDDI-MIB", "wfFddiSmtExtNode"))
if mibBuilder.loadTexts: wfFddiSmtExtEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiSmtExtEntry.setDescription('A SMT entry containing information common to a given SMT.')
wfFddiSmtDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFddiSmtDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiSmtDelete.setDescription('Create/delete parameter, default = create.')
wfFddiSmtExtSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 1, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiSmtExtSlot.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiSmtExtSlot.setDescription('Slot number associated with an SMT entity.')
wfFddiSmtExtNode = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 1, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiSmtExtNode.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiSmtExtNode.setDescription('Node/connector number associated with an SMT entity.')
wfFddiSmtExtCct = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 1, 3, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiSmtExtCct.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiSmtExtCct.setDescription('Circuit number associated with an SMT entity.')
wfFddiSmtHiVersionId = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 1, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2))).clone(namedValues=NamedValues(("id", 2))).clone('id')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiSmtHiVersionId.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiSmtHiVersionId.setDescription('The highest version of SMT that this station supports.')
wfFddiSmtLoVersionId = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 1, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2))).clone(namedValues=NamedValues(("id", 2))).clone('id')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiSmtLoVersionId.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiSmtLoVersionId.setDescription('The lowest version of SMT that this station supports.')
wfFddiSmtManufacturerData = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 1, 3, 1, 7), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiSmtManufacturerData.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiSmtManufacturerData.setDescription('Contains 32 Octets of manufacturer data. The first component, manufacturing OUI, is the 3 octet Organizationally Unique Identifier (OUI) assigned by IEEE. The second component, ManufacturerData, is the manufacturers data (29 octets).')
wfFddiSmtUserData = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 1, 3, 1, 8), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFddiSmtUserData.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiSmtUserData.setDescription('Contains 32 Octets of user defined information in ascii format.')
wfFddiSmtMibVersionId = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 1, 3, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("id", 1))).clone('id')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiSmtMibVersionId.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiSmtMibVersionId.setDescription('The version of the FDDI MIB of this station.')
wfFddiSmtMasterCts = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 1, 3, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiSmtMasterCts.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiSmtMasterCts.setDescription('The number of M ports in a node.')
wfFddiSmtAvailablePaths = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 1, 3, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4))).clone(namedValues=NamedValues(("p", 1), ("s", 2), ("l", 4))).clone('p')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiSmtAvailablePaths.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiSmtAvailablePaths.setDescription('A bit string that indicates the path types that are available in the station. The value initially takes the value 0, then for each type of path that this node has available, 2 raised to a power is added to the sum. The powers are according to the following table: Path Power ---- ----- Primary 0 Secondary 1 Local 2 For example, a station having Primary and Local paths available would have a value of 5 (2**0 + 2**2).')
wfFddiSmtConfigCapabilities = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 1, 3, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("avail", 1), ("ab", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiSmtConfigCapabilities.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiSmtConfigCapabilities.setDescription("A bit string which indicates the configuration capabilities of a node. The 'Hold Available' bit indicates the support of the optional Hold function, which is controlled by 'wfFddiSmtConfigPolicy'. The 'CF-Wrap-AB' bit indicates that the station has the capability of performing a wrab_ab. The value is a sum. This value initially takes the value 0, then for each of the configuration policies currently enforced on the node, 2 raised to a power is added to the sum. The powers are according to the following table: Policy Power ------ ----- HoldAvailable 0 CF_Wrap-AB 1")
wfFddiSmtConfigPolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 1, 3, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiSmtConfigPolicy.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiSmtConfigPolicy.setDescription("A bit string representing the configuration policies currently desired in a node. 'Hold' is one of the terms used for the 'Hold' flag.")
wfFddiSmtStatRptPolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 1, 3, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFddiSmtStatRptPolicy.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiSmtStatRptPolicy.setDescription('If ENABLED, indicates that the node will generate Status Report Frames (SRF) for its implemented events.')
wfFddiSmtTraceMaxExpiration = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 1, 3, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(6001, 256000)).clone(7000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFddiSmtTraceMaxExpiration.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiSmtTraceMaxExpiration.setDescription('Maximum propogation time for a Trace on an FDDI topology. The value is stored in milliseconds.')
wfFddiSmtTimeStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 1, 3, 1, 16), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiSmtTimeStamp.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiSmtTimeStamp.setDescription('Holds the time of creation of the last Status Report Frame (SRF).')
wfFddiSmtTransitionTimeStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 1, 3, 1, 17), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiSmtTransitionTimeStamp.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiSmtTransitionTimeStamp.setDescription('Holds the time of occurrence of the last condition or event.')
wfFddiSmtDatProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 1, 3, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFddiSmtDatProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiSmtDatProtocol.setDescription('SMT will implement an optional ANSI duplicate address test involving periodic transmission of NSA NIF frames addressed to itself if enabled by this attribute.')
wfFddiSmtActionTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 1, 4), )
if mibBuilder.loadTexts: wfFddiSmtActionTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiSmtActionTable.setDescription('A list of SMT action entries.')
wfFddiSmtActionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 1, 4, 1), ).setIndexNames((0, "Wellfleet-FDDI-MIB", "wfFddiSmtActionSlot"), (0, "Wellfleet-FDDI-MIB", "wfFddiSmtActionNode"))
if mibBuilder.loadTexts: wfFddiSmtActionEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiSmtActionEntry.setDescription('An SMT entry containing actions common to a given SMT.')
wfFddiSmtActionDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 1, 4, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFddiSmtActionDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiSmtActionDelete.setDescription('Create/delete parameter, default = create.')
wfFddiSmtActionSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 1, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiSmtActionSlot.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiSmtActionSlot.setDescription('Slot number associated with an SMT action entity.')
wfFddiSmtActionNode = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 1, 4, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiSmtActionNode.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiSmtActionNode.setDescription('Node/connector number associated with an SMT action entity.')
wfFddiSmtActionCct = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 1, 4, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiSmtActionCct.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiSmtActionCct.setDescription('Circuit number associated with an SMT action entity.')
wfFddiSmtStationAction = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 1, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("other", 1), ("connect", 2), ("disconnect", 3), ("pathtest", 4), ("selftest", 5), ("disablea", 6), ("disableb", 7), ("disablem", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFddiSmtStationAction.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiSmtStationAction.setDescription("This object when read, always returns a value of other(1). The behavior of setting this variable to each of the acceptable values is as follows: Other: Results in a BadValue error Connect: Generates a connect signal to ECM to begin a connection sequence. The 'wfFddiSmtRemoteDisconnectFlag' is cleared on the setting of this variable to 1. Disconnect: Generates a disconnect signal to ECM and sets the 'wfFddiSmtRemoteDisconnectFlag' to TRUE. Path_Test: Initiates a station path test. The 'PathTest' variable is set to 'Testing'. The results of this action are not specified in the standard. Self_test: Initiates a station self test. The results of this action are not specified in the standard. Disable_A: Disable_A causes a PC_Disable on the A port if the A port mode is peer. Disable_B: Disable_B causes a PC_Disable on the B port if the B port mode is peer. Disable_M: Disable_M causes a PC_Disable on all M ports. Attempts to set this object to all other values results in a BadValue error. Agents may elect to return a BadValue error on attempts to set this variable to PathTest or SelfTest.")
wfFddiMacTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 2, 2), )
if mibBuilder.loadTexts: wfFddiMacTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiMacTable.setDescription('A list of MAC entries.')
wfFddiMacEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 2, 2, 1), ).setIndexNames((0, "Wellfleet-FDDI-MIB", "wfFddiMacSlot"), (0, "Wellfleet-FDDI-MIB", "wfFddiMacNode"))
if mibBuilder.loadTexts: wfFddiMacEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiMacEntry.setDescription('A MAC entry containing information common to a given MAC.')
wfFddiMacSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 2, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiMacSlot.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiMacSlot.setDescription('Slot number associated with a MAC entity.')
wfFddiMacNode = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 2, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiMacNode.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiMacNode.setDescription('Node/connector number associated with a MAC entity.')
wfFddiMacCct = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 2, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiMacCct.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiMacCct.setDescription('Circuit number associated with a MAC entity.')
wfFddiMacUpstreamNbr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 2, 2, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiMacUpstreamNbr.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiMacUpstreamNbr.setDescription("The MAC's upstream neighbor's long individual MAC address. It may be determined by the Neighbor Information Frame protocol. The value shall be reported as '00 00 00 00 00 00' if it is unknown. SMT uses the MSB form for representation of 48-bit addresses.")
wfFddiMacDownstreamNbr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 2, 2, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiMacDownstreamNbr.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiMacDownstreamNbr.setDescription("The MAC's downstream neighbor's long individual MAC address. It may be determined by the Neighbor Information Frame protocol. The value shall be reported as '00 00 00 00 00 00' if it is unknown. SMT uses the MSB form for representation of 48-bit addresses.")
wfFddiMacSmtAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 2, 2, 1, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiMacSmtAddress.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiMacSmtAddress.setDescription('The 48 bit individual address of the MAC used for SMT frames. SMT uses the MSB form for representation of 48-bit addresses.')
wfFddiMacTNeg = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 2, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiMacTNeg.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiMacTNeg.setDescription('The negotiated TTRT during the claim process represented as an unsigned integer specifying time in nanoseconds.')
wfFddiMacRmtState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 2, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("isolated", 1), ("nonop", 2), ("ringop", 3), ("detect", 4), ("nonopdup", 5), ("ringopdup", 6), ("directed", 7), ("trace", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiMacRmtState.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiMacRmtState.setDescription('Indicates the current state of the Ring Management state machine.')
wfFddiMacOldUpstreamNbr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 2, 2, 1, 9), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiMacOldUpstreamNbr.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiMacOldUpstreamNbr.setDescription("The previous value of the MAC's upstream neighbor's long individual MAC address. It has an initial value of the SMT-Unknown-MAC Address and is only modified as specified by the Neighbor Information Frame protocol. SMT uses the MSB form for representation of 48-bit addresses.")
wfFddiMacOldDownstreamNbr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 2, 2, 1, 10), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiMacOldDownstreamNbr.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiMacOldDownstreamNbr.setDescription("The previous value of the MAC's downstream neighbor's long individual MAC address. It has an initial value of the SMT-Unknown-MAC Address and is only modified as specified by the Neighbor Information Frame protocol. SMT uses the MSB form for representation of 48-bit addresses.")
wfFddiMacTokenCts = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 2, 2, 1, 11), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiMacTokenCts.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiMacTokenCts.setDescription('A count that should as closely as possible match the number of times the station has received a token (total of non-restricted and restricted) on this MAC. This count is valuable for determination of network load.')
wfFddiMacErrorCts = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 2, 2, 1, 12), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiMacErrorCts.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiMacErrorCts.setDescription('A count of the number of frames that were detected in error by this MAC that had not been detected in error by another MAC.')
wfFddiMacLostCts = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 2, 2, 1, 13), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiMacLostCts.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiMacLostCts.setDescription('A count of the number of instances that this MAC detected a format error during frame reception such that the frame was stripped.')
wfFddiMacDaFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 2, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiMacDaFlag.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiMacDaFlag.setDescription('Duplicate Address Flag. An RMT flag used to indicate that the MAC under control has the same address as another MAC on the FDDI.')
wfFddiMacUnaDaFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 2, 2, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiMacUnaDaFlag.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiMacUnaDaFlag.setDescription('A flag, UNDA_Flag, set when the upstream neighbor reports a duplicate address condition. Cleared once the condition clears.')
wfFddiMacFrameErrorFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 2, 2, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiMacFrameErrorFlag.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiMacFrameErrorFlag.setDescription('Indicates the MAC Frame Error Condition is present when set. Cleared when the condition clears and on station initialization.')
wfFddiMacMaUnitDataAvailable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 2, 2, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiMacMaUnitDataAvailable.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiMacMaUnitDataAvailable.setDescription('A flag indicating that the MAC is available for the transmission and reception of Protocol Data Units (PDUs). The MAC and LLC interface will be established when the wfFddiMacMaUnitDataEnable attribute is enabled.')
wfFddiMacDownstreamPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 2, 2, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("typea", 1), ("typeb", 2), ("types", 3), ("typem", 4), ("typenone", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiMacDownstreamPortType.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiMacDownstreamPortType.setDescription('Indicates the PC-Type of the first port that is downstream of this MAC (the exit port).')
wfFddiMacExtTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 2, 3), )
if mibBuilder.loadTexts: wfFddiMacExtTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiMacExtTable.setDescription('A list of MAC extension entries.')
wfFddiMacExtEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 2, 3, 1), ).setIndexNames((0, "Wellfleet-FDDI-MIB", "wfFddiMacExtSlot"), (0, "Wellfleet-FDDI-MIB", "wfFddiMacExtNode"))
if mibBuilder.loadTexts: wfFddiMacExtEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiMacExtEntry.setDescription('A MAC entry containing information common to a given MAC.')
wfFddiMacDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFddiMacDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiMacDelete.setDescription('Create/delete parameter, default = create.')
wfFddiMacExtSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 2, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiMacExtSlot.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiMacExtSlot.setDescription('Slot number associated with a MAC entity.')
wfFddiMacExtNode = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 2, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiMacExtNode.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiMacExtNode.setDescription('Node/connector number associated with a MAC entity.')
wfFddiMacExtCct = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 2, 3, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiMacExtCct.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiMacExtCct.setDescription('Circuit number associated with a MAC entity.')
wfFddiMacFrameStatusFunctions = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 2, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4))).clone(namedValues=NamedValues(("repeat", 1), ("set", 2), ("clear", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiMacFrameStatusFunctions.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiMacFrameStatusFunctions.setDescription("Indicates the MAC's optional Frame Status processing functions. The value is a sum. This value initially takes the value 0, then for each function present, 2 raised to a power is added to the sum. The powers are according to the following table: function power -------- ----- fs-repeating 0 fs-setting 1 fs-clearing 2")
wfFddiMacBridgeFunctions = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 2, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4))).clone(namedValues=NamedValues(("transparent", 1), ("srcroute", 2), ("srt", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiMacBridgeFunctions.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiMacBridgeFunctions.setDescription("Indicates the MAC's optional bridging functions. The value is a sum. This value initially takes the value zero, then for each function present, 2 raised to a power is added to the sum. The powers are according to the following table: Function Power -------- ---- tb 0 -- Transparent bridging active sr 1 -- Src routing active srt 2 -- Src routing transparent active")
wfFddiMacTMaxCapability = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 2, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1336934400))).clone(namedValues=NamedValues(("default", 1336934400))).clone('default')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiMacTMaxCapability.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiMacTMaxCapability.setDescription("Indicates the maximum time value (in nanoseconds) of 'wfFddiMacTMax' that this MAC can support.")
wfFddiMacTvxCapability = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 2, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5222400))).clone(namedValues=NamedValues(("default", 5222400))).clone('default')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiMacTvxCapability.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiMacTvxCapability.setDescription("Indicates the maximum time value (in nanoseconds) of 'wfFddiMacTvxValue' that this MAC can support.")
wfFddiMacAvailablePaths = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 2, 3, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4))).clone(namedValues=NamedValues(("p", 1), ("s", 2), ("l", 4))).clone('p')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiMacAvailablePaths.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiMacAvailablePaths.setDescription('Indicates the paths available for this MAC. The value is a sum. This value initially takes the value 0, then for each type of PATH that this MAC has available, 2 raised to a power is added to the sum. The powers are according to the following table: Path Power ---- ----- Primary 0 Secondary 1 Local 2')
wfFddiMacCurrentPath = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 2, 3, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("isolated", 1), ("local", 2), ("secondary", 3), ("primary", 4), ("concatenated", 5), ("thru", 6))).clone('isolated')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiMacCurrentPath.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiMacCurrentPath.setDescription('Indicates the Path into which this MAC is currently inserted.')
wfFddiMacDupAddrTest = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 2, 3, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("pass", 2), ("fail", 3))).clone('none')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiMacDupAddrTest.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiMacDupAddrTest.setDescription('The Duplicate Address test flag.')
wfFddiMacRequestedPaths = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 2, 3, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 8, 16, 32, 64, 128))).clone(namedValues=NamedValues(("local", 1), ("salt", 2), ("palt", 4), ("calt", 8), ("spref", 16), ("ppref", 32), ("cpref", 64), ("thru", 128))).clone('palt')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiMacRequestedPaths.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiMacRequestedPaths.setDescription('Contains a list of Permitted Paths which specifies the Path(s) into which the MAC may be inserted. The value is a sum which represents the individual paths that are desired. This value initially takes the value zero, then for each type of PATH that this node is, 2 raised to a power is added to the sum. The powers are according to the following table: Path Power ---- ----- local 0 secondary-alternate 1 primary-alternate 2 concatenated-alternate 3 secondary-preferred 4 primary-preferred 5 concatenated-preferred 6 thru 7')
wfFddiMacCopiedCts = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 2, 3, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiMacCopiedCts.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiMacCopiedCts.setDescription("A count that should as closely as possible match the number of frames addressed to (A bit set) and successfully copied into the station's receive buffers (C bit set) by this MAC.")
wfFddiMacFrameErrorThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 2, 3, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFddiMacFrameErrorThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiMacFrameErrorThreshold.setDescription('Specifies the Mac Frame Error Threshold for determining when a MAC Frame Error Condition report will be generated (via an SRF Frame). If Mac Frame Error Ratio is greater than Mac Frame Error Threshold then the Mac Frame Error Condition exists. This Mac Frame Error Ratio is calculated periodically based on the attributes wfFddiMacErrorCts and wfFddiMacLostCts. A low value of Mac Frame Error Threshold will generate more frequent Mac Frame Error conditions if the wfFddiMacErrorCts and wfFddiMacLostCts counters are periodically increased. Therefore the user should set the Mac Frame Error Threshold (1..65535) in accordance with the volatility of the ring.')
wfFddiMacFrameErrorRatio = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 2, 3, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiMacFrameErrorRatio.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiMacFrameErrorRatio.setDescription('This variable is the value of the ratio: ((delta wfFddiMacLostCts + delta wfFddiMacErrorCts) / (delta wfFddiMacFrameCts + delta wfFddiMacLostCts)) 2**16)')
wfFddiMacHardwarePresent = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 2, 3, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notpresent", 1), ("present", 2))).clone('present')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiMacHardwarePresent.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiMacHardwarePresent.setDescription('This variable indicates the presence of underlying hardware support for this MAC object.')
wfFddiMacMaUnitDataEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 2, 3, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFddiMacMaUnitDataEnable.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiMacMaUnitDataEnable.setDescription('A configurable attribute that specifies whether the MAC will be available for the transmission and reception of Protocol Data Units (PDUs). If enabled, the interface to the MAC entity will be available for the exchange of PDUs between the MAC and the local LLC entity when the ring becomes operational (i.e., LLC interface is established). Setting this attribute has no effect on the transfer and reception of MAC or SMT frames.')
wfFddiMacTvxExpiredCts = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 2, 3, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiMacTvxExpiredCts.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiMacTvxExpiredCts.setDescription('A count that should as closely as possible match the number of times that TVX has expired.')
wfFddiMacLateCts = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 2, 3, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiMacLateCts.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiMacLateCts.setDescription('A count that should as closely as possible match the number of TRT expirations since this MAC was reset or a token was received.')
wfFddiMacRingOpCts = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 2, 3, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiMacRingOpCts.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiMacRingOpCts.setDescription("The count of the number of times the ring has entered the 'Ring Operational' state from the `Ring Not Operational' state. This count is updated when a SM_MA_STATUS Indication of a change in the Ring_Operational state occurs. Because of implementatio considerations, this count may be less than the actual RingOp_Ct. It is not a requirement that this count be exact.")
wfFddiMacDuplicateTokenCts = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 2, 3, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiMacDuplicateTokenCts.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiMacDuplicateTokenCts.setDescription('The count of the number of times a Duplicate Token has been detected.')
wfFddiPathTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 3, 2), )
if mibBuilder.loadTexts: wfFddiPathTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiPathTable.setDescription('A list of PATH entries.')
wfFddiPathEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 3, 2, 1), ).setIndexNames((0, "Wellfleet-FDDI-MIB", "wfFddiPathSlot"), (0, "Wellfleet-FDDI-MIB", "wfFddiPathNode"))
if mibBuilder.loadTexts: wfFddiPathEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiPathEntry.setDescription('A PATH entry containing information common to a given PATH.')
wfFddiPathSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 3, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiPathSlot.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiPathSlot.setDescription('Slot number associated with a PATH entity.')
wfFddiPathNode = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 3, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiPathNode.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiPathNode.setDescription('Node/connector number associated with a PATH entity.')
wfFddiPathCct = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 3, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiPathCct.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiPathCct.setDescription('Circuit number associated with a PATH entity.')
wfFddiPathConfiguration = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 3, 2, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiPathConfiguration.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiPathConfiguration.setDescription("A circular list of resources on the path where each entry in the list consists of a resource type identifier (MAC or PORT), an index, and its CurrentPath. If the path is available to a resource in the node (as indicated by 'wfFddiPortAvailablePaths' or 'wfFddiMacAvailablePaths') then that resource shall be included in the list. If the path is not available to a resource or the underlying hardware is not present, then that resource shall not be included in the list. Resources currently inserted in the Path shall appear in the list once in token order. Resources not currently inserted in the Path shall appear once in any position supported by the implementation.")
wfFddiPathExtTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 3, 3), )
if mibBuilder.loadTexts: wfFddiPathExtTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiPathExtTable.setDescription('A list of PATH extension entries.')
wfFddiPathExtEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 3, 3, 1), ).setIndexNames((0, "Wellfleet-FDDI-MIB", "wfFddiPathExtSlot"), (0, "Wellfleet-FDDI-MIB", "wfFddiPathExtNode"))
if mibBuilder.loadTexts: wfFddiPathExtEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiPathExtEntry.setDescription('A PATH entry containing information common to a given PATH.')
wfFddiPathDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 3, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFddiPathDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiPathDelete.setDescription('Create/delete parameter, default = create.')
wfFddiPathExtSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 3, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiPathExtSlot.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiPathExtSlot.setDescription('Slot number associated with a Path entity.')
wfFddiPathExtNode = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 3, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiPathExtNode.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiPathExtNode.setDescription('Node/connector number associated with a Path entity.')
wfFddiPathExtCct = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 3, 3, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiPathExtCct.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiPathExtCct.setDescription('Circuit number associated with a Path entity.')
wfFddiPathTvxLowerBound = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 3, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2500000))).clone(namedValues=NamedValues(("default", 2500000))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFddiPathTvxLowerBound.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiPathTvxLowerBound.setDescription("Specifies the minimum time value of 'wfFddiMacTvxValue' that shall be used by any MAC that is configured in this path. The operational value of 'wfFddiMacTvxValue' is managed by setting this variable. This variable has the time value range of: 0 < wfFddiPathTvxLowerBound < wfFddiPathMaxTReq Changes to this attribute shall either satisfy the time value relationship: wfFddiPathTvxLowerBound <= wfFddiMacTvxCapability of each of the MACS currently on the path, or be considered out of range. Time specified in nanoseconds. The initial value of wfFddiPathTvxLowerBound shall be 2.500 msec.")
wfFddiPathTMaxLowerBound = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 3, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(165000000))).clone(namedValues=NamedValues(("default", 165000000))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFddiPathTMaxLowerBound.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiPathTMaxLowerBound.setDescription("Specifies the minimum time value of 'wfFddiMACTMax' that shall be used by any MAC that is configured in this path. The operational value of 'wfFddiMacTMax' is managed by setting this attribute. This attribute has the time value range of: wfFddiPathMaxTReq <= wfFddiPathTMaxLowerBound and an absolute time value range of 10msec <= wfFddiPathTMaxLowerBound. Changes to this aattribute shall either satisfy the time value relationship: wfFddiPathTMaxLowerBound < wfFddiMacTMaxCapability of each of the MACs currently on the path, or be considered out of range. Time specified in nanoseconds. The initial value of wfFddiPathTMaxLowerBound shall be 165 msec.")
wfFddiPathMaxTReq = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 3, 3, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiPathMaxTReq.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiPathMaxTReq.setDescription('This variable is the T_Req_value passed to the MAC. Without having detected a duplicate, the time value of this variable shall assume the maximum supported time value which is less than or equal to the time value of wfFDDIMacTReq. When a MAC has an address detected as a duplicate, it may use a time value for this variable greater than the time value of wfFddiPathTMaxLowerBound. A station shall cause claim when the new T_Req may cause the value of T_Neg to change in the claim process (i.e., time value new T_Req < T_Neg, or old T_Req = T_Neg). This value is encoded in nanoseconds. The name of this attribute in the IETF MIB is FddiMibMACTReq.')
wfFddiPortTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 4, 2), )
if mibBuilder.loadTexts: wfFddiPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiPortTable.setDescription('A list of PORT entries.')
wfFddiPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 4, 2, 1), ).setIndexNames((0, "Wellfleet-FDDI-MIB", "wfFddiPortSlot"), (0, "Wellfleet-FDDI-MIB", "wfFddiPortNode"), (0, "Wellfleet-FDDI-MIB", "wfFddiPortIndex"))
if mibBuilder.loadTexts: wfFddiPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiPortEntry.setDescription('A PORT entry containing information common to a given PORT.')
wfFddiPortSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 4, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiPortSlot.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiPortSlot.setDescription('Slot number associated with a PORT entity.')
wfFddiPortNode = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 4, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiPortNode.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiPortNode.setDescription('Node/connector number associated with a PORT entity.')
wfFddiPortCct = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 4, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiPortCct.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiPortCct.setDescription('Circuit number associated with a PORT entity.')
wfFddiPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 4, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiPortIndex.setDescription('A unique value for each PORT associated with each slot/connector pair.')
wfFddiPortPcType = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 4, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("a", 1), ("b", 2), ("s", 3), ("m", 4), ("none", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiPortPcType.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiPortPcType.setDescription('The physical connector type of the local PORT.')
wfFddiPortPcNeighbor = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 4, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("a", 1), ("b", 2), ("s", 3), ("m", 4), ("unknown", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiPortPcNeighbor.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiPortPcNeighbor.setDescription('The physical connector type of the remote PORT.')
wfFddiPortPcmState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 4, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("off", 1), ("break", 2), ("trace", 3), ("connect", 4), ("next", 5), ("signal", 6), ("join", 7), ("verify", 8), ("active", 9), ("maint", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiPortPcmState.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiPortPcmState.setDescription('State of Physical State Machine.')
wfFddiPortRequestedPaths = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 4, 2, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiPortRequestedPaths.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiPortRequestedPaths.setDescription("This variable is a list of permitted paths where each list element defines the Port's permitted paths. The first octet corresponds to 'none', the second octet to 'tree' and the third octet to 'peer'.")
wfFddiPortBsFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 4, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiPortBsFlag.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiPortBsFlag.setDescription('Break State Flag - A PCM flag used to indicate that the PCM state Machine is not leaving the Break State in an expected time interval & a problem is suspected.')
wfFddiPortLerFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 4, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiPortLerFlag.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiPortLerFlag.setDescription("The condition becomes active when the value of 'wfFddiPortLerEstimate' is <= 'wfFddiPortLerAlarm'. This will be reported with Status Report Frames (SRF).")
wfFddiPortConnectState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 4, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("disabled", 1), ("connecting", 2), ("standby", 3), ("active", 4), ("unknown", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiPortConnectState.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiPortConnectState.setDescription('A variable from PCM to other management entities indicating the state of the connection.')
wfFddiPortMacIndicated = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 4, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("ff", 1), ("ft", 2), ("tf", 3), ("tt", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiPortMacIndicated.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiPortMacIndicated.setDescription('The indications (T_Val(9), R_Val(9)) in PC-Signalling, of the intent to place a MAC in the output token path to a PORT.')
wfFddiPortExtTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 4, 3), )
if mibBuilder.loadTexts: wfFddiPortExtTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiPortExtTable.setDescription('A list of PORT extension entries.')
wfFddiPortExtEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 4, 3, 1), ).setIndexNames((0, "Wellfleet-FDDI-MIB", "wfFddiPortExtSlot"), (0, "Wellfleet-FDDI-MIB", "wfFddiPortExtNode"), (0, "Wellfleet-FDDI-MIB", "wfFddiPortExtIndex"))
if mibBuilder.loadTexts: wfFddiPortExtEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiPortExtEntry.setDescription('A PORT entry containing information common to a given PORT.')
wfFddiPortDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 4, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFddiPortDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiPortDelete.setDescription('Create/delete parameter, default = create.')
wfFddiPortExtSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 4, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiPortExtSlot.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiPortExtSlot.setDescription('Slot number associated with a Port entity.')
wfFddiPortExtNode = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 4, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiPortExtNode.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiPortExtNode.setDescription('Node/connector number associated with a Port entity.')
wfFddiPortExtCct = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 4, 3, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiPortExtCct.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiPortExtCct.setDescription('Circuit number associated with a Port entity.')
wfFddiPortExtIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 4, 3, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiPortExtIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiPortExtIndex.setDescription('A unique value for each PORT associated with each slot/connector pair.')
wfFddiPortConnectionPolicies = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 4, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("maclct", 1), ("macloop", 2))).clone('maclct')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiPortConnectionPolicies.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiPortConnectionPolicies.setDescription("A value representing the PORT's connection policies desired in the node. The value of 'pc-mac-lct' (i.e. PCM MAC LinkConfidence Test) is a term used in the PC_MAC_LCT Flag. The value of 'pc-mac-loop' is a term used in the PC_MAC_LOOP flag. The value is a sum. This value initially takes the value zero, then for each PORT policy, 2 raised to a power is added to the sum. The powers are according to the following table: Policy Power ------ ----- pc-mac-lct 0 pc-mac-loop 1")
wfFddiPortCurrentPath = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 4, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("isolated", 1), ("local", 2), ("secondary", 3), ("primary", 4), ("concatenated", 5), ("thru", 6))).clone('isolated')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiPortCurrentPath.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiPortCurrentPath.setDescription('Indicates the Path(s) into which this PORT is currently inserted.')
wfFddiPortMacPlacement = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 4, 3, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiPortMacPlacement.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiPortMacPlacement.setDescription('Indicates the MAC, if any, whose transmit path exits the station via this PORT. The value shall be zero if there is no MAC associated with the PORT.')
wfFddiPortAvailablePaths = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 4, 3, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4))).clone(namedValues=NamedValues(("p", 1), ("s", 2), ("l", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiPortAvailablePaths.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiPortAvailablePaths.setDescription('Indicates the Paths which are available to this Port. In the absence of faults, the A & B ports will always have both the Primary & Secondary paths available. The value is a sum. This value initially takes the value 0, then for each type of PATH that this port has available, 2 raised to a power is added to the sum. The powers are according to the following table: Path Power ---- ----- Primary 0 Secondary 1 Local 2')
wfFddiPortPmdClass = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 4, 3, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("multimode", 1), ("mode1", 2), ("mode2", 3), ("sonet", 4), ("fiber", 5), ("twistedpair", 6), ("unknown", 7), ("unspecified", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiPortPmdClass.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiPortPmdClass.setDescription('Indicates the Path(s) into which this PORT is currently inserted.')
wfFddiPortConnectionCapabilities = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 4, 3, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("maclct", 1), ("macloop", 2))).clone('maclct')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiPortConnectionCapabilities.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiPortConnectionCapabilities.setDescription("A value that indicates the connection capabilities of the port. The 'pc-mac-lct' bit indicates that the station has the capability of setting the PC_MAC_LCT Flag. The 'pc-mac-loop' bit indicates that the station has the capability of setting the PC_MAC_LOOP Flag. The value is a sum. This value initially takes the value zero, then for each PORT policy, 2 raised to a power is added to the sum. The powers are according to the following table: Capability Power ---------- ----- pc-mac-lct 0 pc-mac-loop 1")
wfFddiPortEbErrorCts = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 4, 3, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiPortEbErrorCts.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiPortEbErrorCts.setDescription('The count of the number of elasticity buffer errors for a particular PHY. The elasticity buffer is used to account for clock tolerances between stations')
wfFddiPortLctFailCts = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 4, 3, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiPortLctFailCts.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiPortLctFailCts.setDescription('The count of the consecutive times the link confidence test (LCT) has failed during Connection Management.')
wfFddiPortLerEstimate = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 4, 3, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(4, 15)).clone(15)).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiPortLerEstimate.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiPortLerEstimate.setDescription('A long term average of the link error rate. It ranges from 10**-4 to 10**-15 and is reported as the absolute value of the base 10 logarithm.')
wfFddiPortLemRejectCts = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 4, 3, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiPortLemRejectCts.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiPortLemRejectCts.setDescription('A link error monitoring count of the times that a link has been rejected.')
wfFddiPortLemCts = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 4, 3, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiPortLemCts.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiPortLemCts.setDescription('The aggregate link error moniitor error count, set to 0 only on station initialization.')
wfFddiPortLerCutOff = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 4, 3, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(4, 15)).clone(7)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFddiPortLerCutOff.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiPortLerCutOff.setDescription('The link err rate estimate at which a link connection will be broken. It ranges from 10**-4 to 10**-15 and is reported as the absolute value of the base 10 logarithm.')
wfFddiPortLerAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 4, 3, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(4, 15)).clone(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFddiPortLerAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiPortLerAlarm.setDescription('The link err rate estimate at which a link connection will generate an alarm. It ranges from 10**-4 to 10**-15 and is reported as the absolute value of the base 10 logarithm of the estimate.')
wfFddiPortPcWithhold = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 4, 3, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("mtom", 2), ("otherincompatible", 3), ("pathnotavailable", 4))).clone('none')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiPortPcWithhold.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiPortPcWithhold.setDescription('A variable from PCM to other management entities containing the reason for withholding a connection.')
wfFddiPortHardwarePresent = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 4, 3, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notpresent", 1), ("present", 2))).clone('present')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiPortHardwarePresent.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiPortHardwarePresent.setDescription('This variable indicates the presence of underlying hardware support for this port object.')
wfFddiPortActionTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 4, 4), )
if mibBuilder.loadTexts: wfFddiPortActionTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiPortActionTable.setDescription('A list of Port Action entries.')
wfFddiPortActionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 4, 4, 1), ).setIndexNames((0, "Wellfleet-FDDI-MIB", "wfFddiPortActionSlot"), (0, "Wellfleet-FDDI-MIB", "wfFddiPortActionNode"), (0, "Wellfleet-FDDI-MIB", "wfFddiPortActionIndex"))
if mibBuilder.loadTexts: wfFddiPortActionEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiPortActionEntry.setDescription('A PORT entry containing actions common to a given PORT.')
wfFddiPortActionDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 4, 4, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFddiPortActionDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiPortActionDelete.setDescription('Create/delete parameter, default = create.')
wfFddiPortActionSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 4, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiPortActionSlot.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiPortActionSlot.setDescription('Slot number associated with a PORT action entity.')
wfFddiPortActionNode = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 4, 4, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiPortActionNode.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiPortActionNode.setDescription('Node/connector number associated with a PORT action entity.')
wfFddiPortActionCct = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 4, 4, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiPortActionCct.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiPortActionCct.setDescription('Circuit number associated with a PORT action entity.')
wfFddiPortActionIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 4, 4, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiPortActionIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiPortActionIndex.setDescription('A unique value for each PORT associated with each slot/connector pair.')
wfFddiPortAction = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 4, 4, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("maint", 2), ("enable", 3), ("disable", 4), ("start", 5), ("stop", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFddiPortAction.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiPortAction.setDescription("Causes a control signal to be generated with a control_action of 'Signal' and the 'variable' parameter set with the appropriate value (i.e. PC_Maint, PC_Enable, PC_Disable, PC_Start, or PC_Stop). These signals are used to initiate a state change within Connection Management")
wfFddiXLineCfgTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 5, 1), )
if mibBuilder.loadTexts: wfFddiXLineCfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiXLineCfgTable.setDescription('FDDI switch configuration line record')
wfFddiXLineCfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 5, 1, 1), ).setIndexNames((0, "Wellfleet-FDDI-MIB", "wfFddiXLineCfgSlot"), (0, "Wellfleet-FDDI-MIB", "wfFddiXLineCfgNode"))
if mibBuilder.loadTexts: wfFddiXLineCfgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiXLineCfgEntry.setDescription('An FDDI entry containing configuration parameters about an FDDI interface.')
wfFddiXLineCfgDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 5, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("create", 1), ("delete", 2))).clone('create')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFddiXLineCfgDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiXLineCfgDelete.setDescription('FDDI interface table create/delete object. The default setting is create.')
wfFddiXLineCfgEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFddiXLineCfgEnable.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiXLineCfgEnable.setDescription('FDDI interface enable/disable object. The default setting is enable.')
wfFddiXLineCfgLossOfServiceTmo = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 5, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFddiXLineCfgLossOfServiceTmo.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiXLineCfgLossOfServiceTmo.setDescription('This timer (in seconds) provides debounce functionality for an FDDI interface. When the FDDI ring becomes non-operational, the LLC interface will be disabled if the following conditions hold TRUE: 1. fddimibMACMAUnitdataEnable (contained in fddimibMACTable of rfc1512.mib) is enabled 2. This FDDI interface has been unavailable for wfFddiXLineCfgLossOfServiceTmo seconds. If the FDDI interface becomes enabled before wfFddiXLineCfgLossOfServiceTmo expires, then the timer is cancelled and nothing occurs. This debounce timer may be disabled by setting it to 0. In this case, when the FDDI interface becomes non-operational, the LLC interface will be notified right away.')
wfFddiXLineCfgSmtEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 5, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFddiXLineCfgSmtEnable.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiXLineCfgSmtEnable.setDescription('Enable Station Management periodic timers and NIF protocol.')
wfFddiXLineCfgSmtDatProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 5, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFddiXLineCfgSmtDatProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiXLineCfgSmtDatProtocol.setDescription('SMT will implement an optional ANSI duplicate address test involving periodic transmission of NSA NIF frames addressed to itself if enabled by this attribute.')
wfFddiXLineCfgLineNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 5, 1, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFddiXLineCfgLineNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiXLineCfgLineNumber.setDescription('Logical line number associated with this driver entity.')
wfFddiXLineCfgForcePeerTree = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 5, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFddiXLineCfgForcePeerTree.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiXLineCfgForcePeerTree.setDescription("This attribute allows all FDDI Peer/Tree connections to reach the 'Thru' state. This is done to give the user some flexibility and allow them to Daisy Chain their Phy connections, mixing Tree & Peer connections. This type of daisy chaining DOES NOT conform to the SMT standard and is NOT recommended as it may result in a less than optimum token path. Normally when we have a Peer/Tree connection mix, we will wrap the connection, favoring PHY B.")
wfFddiXLineCfgSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 5, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 14))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiXLineCfgSlot.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiXLineCfgSlot.setDescription('Chassis slot number of FDDI interface.')
wfFddiXLineCfgModule = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 5, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("one", 1), ("two", 2), ("three", 3), ("four", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiXLineCfgModule.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiXLineCfgModule.setDescription('Module number for Fiddlestix platform, filled in by driver.')
wfFddiXLineCfgActualNode = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 5, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("one", 1), ("two", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiXLineCfgActualNode.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiXLineCfgActualNode.setDescription('Actual Node number for this FDDI interface, filled in by the driver.')
wfFddiXLineCfgNode = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 5, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 44))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiXLineCfgNode.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiXLineCfgNode.setDescription("Instance ID node - filled in by driver. This attribute is an encoded value and is equal to 'module'*100 + 'node'. Where 'module' is defined in object 4 and 'node' is defined in object 5 of this table.")
wfFddiXLineCfgSmtIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 5, 1, 1, 12), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFddiXLineCfgSmtIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiXLineCfgSmtIndex.setDescription("Used for indexing into rfc1512 MIBS, this value is gotten from multiplying the 'slot*1000' and then adding the 'wfFddiXLineCfgNode' attribute described above. Its purpose is to uniquely identify each SMT which exists.")
wfFddiXLineCfgIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 5, 1, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiXLineCfgIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiXLineCfgIfIndex.setDescription('An index value that uniquely identifies an interface to a FDDI-like medium. The interface identified by a particular value of this index is the same interface as identified by the same value of ifIndex.')
wfFddiXLineTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 5, 2), )
if mibBuilder.loadTexts: wfFddiXLineTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiXLineTable.setDescription('FDDI switch statistic line record')
wfFddiXLineEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 5, 2, 1), ).setIndexNames((0, "Wellfleet-FDDI-MIB", "wfFddiXLineIfIndex"))
if mibBuilder.loadTexts: wfFddiXLineEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiXLineEntry.setDescription('An FDDI entry containing information about an FDDI interface.')
wfFddiXLineSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 5, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 14))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiXLineSlot.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiXLineSlot.setDescription('Chassis slot number of FDDI interface.')
wfFddiXLineModule = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 5, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("one", 1), ("two", 2), ("three", 3), ("four", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiXLineModule.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiXLineModule.setDescription('Module number for Fiddlestix platform, filled in by driver.')
wfFddiXLineActualNode = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 5, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("one", 1), ("two", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiXLineActualNode.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiXLineActualNode.setDescription('Actual Node number for this FDDI interface, filled in by the driver.')
wfFddiXLineNode = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 5, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 44))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiXLineNode.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiXLineNode.setDescription("Instance ID node - filled in by driver. This attribute is an encoded value and is equal to 'module'*10 + 'node'. Where 'module' is defined in object 4 and 'node' is defined in object 5 of this table.")
wfFddiXLineSmtIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 5, 2, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFddiXLineSmtIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiXLineSmtIndex.setDescription('Logical line number associated with this FDDI interface.')
wfFddiXLineIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 5, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiXLineIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiXLineIfIndex.setDescription('An index value that uniquely identifies an interface to a FDDI-like medium. The interface identified by a particular value of this index is the same interface as identified by the same value of ifIndex.')
wfFddiXLineTxErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 5, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiXLineTxErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiXLineTxErrors.setDescription('An aggregate of the total number of transmit errors on this FDDI interface.')
wfFddiXLineTxAborts = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 5, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiXLineTxAborts.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiXLineTxAborts.setDescription('Number of transmitted frames terminated (i.e. aborted) abnormally by the MAC.')
wfFddiXLineTxOverruns = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 5, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiXLineTxOverruns.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiXLineTxOverruns.setDescription('Number of tranmitter overruns experienced by this interface. May indicate a HW problem with regards to the DMAC feeding the MAC.')
wfFddiXLineTxUnderruns = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 5, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiXLineTxUnderruns.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiXLineTxUnderruns.setDescription('Number of tranmitter underruns experienced by this interface. May indicate a SW problem with regards to replenishing the DMACs XMT descriptor.')
wfFddiXLineRxErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 5, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiXLineRxErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiXLineRxErrors.setDescription('An aggregate of the total number of receive errors on this FDDI interface.')
wfFddiXLineRxCrcErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 5, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiXLineRxCrcErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiXLineRxCrcErrors.setDescription('Number of LLC frames received with CRC errors.')
wfFddiXLineRxSmtCrcErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 5, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiXLineRxSmtCrcErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiXLineRxSmtCrcErrors.setDescription('Number of SMT frames received with CRC errors.')
wfFddiXLineRxInvalidFrameStatusErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 5, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiXLineRxInvalidFrameStatusErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiXLineRxInvalidFrameStatusErrors.setDescription('A count of the number of badly formed LLC frames received off of the FDDI ring. These are frames which do not contain a valid Frame Status field of at least 3 control indicator symbols (i.e. E, A, C, flags).')
wfFddiXLineRxSmtInvalidFrameStatusErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 5, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiXLineRxSmtInvalidFrameStatusErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiXLineRxSmtInvalidFrameStatusErrors.setDescription('A count of the number of badly formed SMT frames received off of the FDDI ring. These are frames which do not contain a valid Frame Status field of at least 3 control indicator symbols (i.e. E, A, C, flags).')
wfFddiXLineRxMacErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 5, 2, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiXLineRxMacErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiXLineRxMacErrors.setDescription('Number of LLC frames received with MAC errors.')
wfFddiXLineRxSmtMacErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 5, 2, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiXLineRxSmtMacErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiXLineRxSmtMacErrors.setDescription('Number of SMT frames received with MAC errors.')
wfFddiXLineRxFormatErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 5, 2, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiXLineRxFormatErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiXLineRxFormatErrors.setDescription('Number of LLC frames received with Format errors.')
wfFddiXLineRxSmtFormatErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 5, 2, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiXLineRxSmtFormatErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiXLineRxSmtFormatErrors.setDescription('Number of SMT frames received with Format errors.')
wfFddiXLineRxFragmentErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 5, 2, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiXLineRxFragmentErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiXLineRxFragmentErrors.setDescription('Number of LLC frame fragments received.')
wfFddiXLineRxSmtFragmentErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 5, 2, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiXLineRxSmtFragmentErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiXLineRxSmtFragmentErrors.setDescription('Number of SMT frame fragments received.')
wfFddiXLineRxInvalidLengthErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 5, 2, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiXLineRxInvalidLengthErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiXLineRxInvalidLengthErrors.setDescription('Number of LLC frames received with an ending T symbol which are either too short or contain an odd number of symbols.')
wfFddiXLineRxSmtInvalidLengthErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 5, 2, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiXLineRxSmtInvalidLengthErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiXLineRxSmtInvalidLengthErrors.setDescription('Number of SMT frames received with an ending T symbol which are either too short or contain an odd number of symbols.')
wfFddiXLineRxAbortErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 5, 2, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiXLineRxAbortErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiXLineRxAbortErrors.setDescription('Number of LLC frames aborted during reception.')
wfFddiXLineRxSmtAbortErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 5, 2, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiXLineRxSmtAbortErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiXLineRxSmtAbortErrors.setDescription('Number of LLC frames aborted during reception.')
wfFddiXLineRxEDataUnknownErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 5, 2, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiXLineRxEDataUnknownErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiXLineRxEDataUnknownErrors.setDescription("Number of LLC frames received with the Error indication set, that we couldn't decode as were unable to get the END_DATA value from the frame.")
wfFddiXLineRxSmtEDataUnknownErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 5, 2, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiXLineRxSmtEDataUnknownErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiXLineRxSmtEDataUnknownErrors.setDescription("Number of SMT frames received with the Error indication set, that we couldn't decode as were unable to get the END_DATA value from the frame.")
wfFddiXLineRxLastEDataFStatusErrorVal = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 5, 2, 1, 28), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiXLineRxLastEDataFStatusErrorVal.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiXLineRxLastEDataFStatusErrorVal.setDescription('The value of END_DATA and FRAME_STATUS from the last LLC frame received containing an error.')
wfFddiXLineRxSmtLastEDataFStatusErrorVal = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 5, 2, 1, 29), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiXLineRxSmtLastEDataFStatusErrorVal.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiXLineRxSmtLastEDataFStatusErrorVal.setDescription('The value of END_DATA and FRAME_STATUS from the last SMT frame received containing an error.')
wfFddiXLineRxOverruns = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 5, 2, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiXLineRxOverruns.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiXLineRxOverruns.setDescription('Number of receiver overruns experienced by this interface. May indicate a SW problem with regards to replenishing the DMACs RCV descriptors.')
wfFddiXLineRxUnderruns = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 5, 2, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiXLineRxUnderruns.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiXLineRxUnderruns.setDescription('Number of receiver underruns experienced by this interface. May indicate a HW problem with regards to the DMAC feeding the MAC.')
wfFddiXLineRxOversizedFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 5, 2, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiXLineRxOversizedFrames.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiXLineRxOversizedFrames.setDescription('Number of LLC frames received whose length exceeded the MTU. (Note: The MTU is defined in rfc1573 in the ifMtu object.)')
wfFddiXLineRxSmtOversizedFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 5, 2, 1, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiXLineRxSmtOversizedFrames.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiXLineRxSmtOversizedFrames.setDescription('Number of SMT frames received whose length exceeded the MTU. (Note: The MTU is defined in rfc1573 in the ifMtu object.)')
wfFddiXLineRxUndersizedFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 5, 2, 1, 34), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiXLineRxUndersizedFrames.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiXLineRxUndersizedFrames.setDescription('Number of LLC frames received whose length was less than 20 bytes, including the FC byte and a 4 byte CRC.')
wfFddiXLineRxSmtUndersizedFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 5, 2, 1, 35), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiXLineRxSmtUndersizedFrames.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiXLineRxSmtUndersizedFrames.setDescription('Number of SMT frames received whose length was less than 37 bytes, including the FC byte and a 4 byte CRC.')
wfFddiXLineRxSmtSecondaryNsaFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 5, 2, 1, 36), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiXLineRxSmtSecondaryNsaFrames.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiXLineRxSmtSecondaryNsaFrames.setDescription('Number of Secondary NSA frames received by this interface and dropped.')
wfFddiXLineUnexpectedFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 5, 2, 1, 37), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiXLineUnexpectedFrames.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiXLineUnexpectedFrames.setDescription('Number of non-LLC and non SMT frames received by this interface. Does NOT include MAC frames or Void frames.')
wfFddiXLineRxSmtOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 5, 2, 1, 38), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiXLineRxSmtOctets.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiXLineRxSmtOctets.setDescription('Number of bytes received without error. This byte count only includes SMT frames (i.e. no MAC and LLC frames).')
wfFddiXLineRxSmtFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 5, 2, 1, 39), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiXLineRxSmtFrames.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiXLineRxSmtFrames.setDescription('Number of frames received without error. This frame count only includes SMT frames (i.e. no MAC and LLC frames).')
wfFddiXLineTxSmtOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 5, 2, 1, 40), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiXLineTxSmtOctets.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiXLineTxSmtOctets.setDescription('Number of bytes transmitted. This byte count only includes SMT frames (i.e. no MAC and LLC frames). Also note that this value is an approximation in that its assumed frames queued for transmit ALWAYS make it onto the ring.')
wfFddiXLineTxSmtFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 5, 2, 1, 41), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiXLineTxSmtFrames.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiXLineTxSmtFrames.setDescription('Number of frames transmitted. This frame count only includes SMT frames (i.e. no MAC and LLC frames). Also note that this value is an approximation in that its assumed frames queued for transmit ALWAYS make it onto the ring.')
wfFddiXLinePhyALogPtr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 5, 2, 1, 42), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiXLinePhyALogPtr.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiXLinePhyALogPtr.setDescription('Address of the Debug Phy Event Buffer for Phy A. This attribute is strictly for diagnostic purposes. The size of the buffer is 1028 bytes.')
wfFddiXLinePhyBLogPtr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 5, 2, 1, 43), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiXLinePhyBLogPtr.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiXLinePhyBLogPtr.setDescription('Address of the Debug Phy Event Buffer for Phy B. This attribute is strictly for diagnostic purposes. The size of the buffer is 1028 bytes.')
wfFddiXSmtTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 5, 3), )
if mibBuilder.loadTexts: wfFddiXSmtTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiXSmtTable.setDescription('A list of SMT entries.')
wfFddiXSmtEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 5, 3, 1), ).setIndexNames((0, "Wellfleet-FDDI-MIB", "wfFddiXSmtIndex"))
if mibBuilder.loadTexts: wfFddiXSmtEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiXSmtEntry.setDescription('An FDDI entry containing information about an FDDI interface.')
wfFddiXSmtIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 5, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiXSmtIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiXSmtIndex.setDescription("A unique value for each SMT. The value for each SMT must remain constant at least from one re- initialization of the entity's network management system to the next re-initialization.")
wfFddiXSmtManufacturerData = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 5, 3, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiXSmtManufacturerData.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiXSmtManufacturerData.setDescription('Contains 32 Octets of manufacturer data. The first component, manufacturing OUI, is the 3 octet Organizationally Unique Identifier (OUI) assigned by IEEE. The second component, ManufacturerData, is the manufacturers data (29 octets).')
wfFddiXMacTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 5, 4), )
if mibBuilder.loadTexts: wfFddiXMacTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiXMacTable.setDescription('A list of MAC entries.')
wfFddiXMacEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 5, 4, 1), ).setIndexNames((0, "Wellfleet-FDDI-MIB", "wfFddiXMacSmtIndex"), (0, "Wellfleet-FDDI-MIB", "wfFddiXMacIndex"))
if mibBuilder.loadTexts: wfFddiXMacEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiXMacEntry.setDescription('An FDDI entry containing information about an FDDI interface.')
wfFddiXMacSmtIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 5, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiXMacSmtIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiXMacSmtIndex.setDescription('The value of the SMT index associated with this MAC.')
wfFddiXMacIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 5, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiXMacIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiXMacIndex.setDescription('Index variable for uniquely identifying the MAC object instances, which is the same as the corresponding resource index in SMT.')
wfFddiXMacBridgeFunctions = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 5, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4))).clone(namedValues=NamedValues(("transparent", 1), ("srcroute", 2), ("srt", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiXMacBridgeFunctions.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiXMacBridgeFunctions.setDescription("Indicates the MAC's optional bridging functions. The value is a sum. This value initially takes the value zero, then for each function present, 2 raised to a power is added to the sum. The powers are according to the following table: Function Power -------- ---- tb 0 -- Transparent bridging active sr 1 -- Src routing active srt 2 -- Src routing transparent active")
wfFddiXMacDuplicateTokenCts = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 5, 4, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiXMacDuplicateTokenCts.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiXMacDuplicateTokenCts.setDescription('The count of the number of times a Duplicate Token has been detected.')
wfFddiXPortTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 5, 5), )
if mibBuilder.loadTexts: wfFddiXPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiXPortTable.setDescription('A list of PORT Entries.')
wfFddiXPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 5, 5, 1), ).setIndexNames((0, "Wellfleet-FDDI-MIB", "wfFddiXPortSmtIndex"), (0, "Wellfleet-FDDI-MIB", "wfFddiXPortIndex"))
if mibBuilder.loadTexts: wfFddiXPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiXPortEntry.setDescription('An FDDI entry containing information about an FDDI interface.')
wfFddiXPortSmtIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 5, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiXPortSmtIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiXPortSmtIndex.setDescription('The value of the SMT index associated with this PORT.')
wfFddiXPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 5, 5, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiXPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiXPortIndex.setDescription("A unique value for each PORT within a given SMT, which is the same as the corresponding resource index in SMT. The value for each PORT must remain constant at least from one re-initialization of the entity's network management system to the next re-initialization.")
wfFddiXPortEbErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 5, 5, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiXPortEbErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiXPortEbErrors.setDescription('The count of the number of elasticity buffer errors for a particular PHY. The elasticity buffer is used to account for clock tolerances between stations.')
mibBuilder.exportSymbols("Wellfleet-FDDI-MIB", wfFDDIRxSmtOctets=wfFDDIRxSmtOctets, wfFddiXLineTxUnderruns=wfFddiXLineTxUnderruns, wfFddiPortBsFlag=wfFddiPortBsFlag, wfFddiMacRingOpCts=wfFddiMacRingOpCts, wfFddiPortActionEntry=wfFddiPortActionEntry, wfFDDIPromiscuous=wfFDDIPromiscuous, wfFddiMacEntry=wfFddiMacEntry, wfFddiXPortIndex=wfFddiXPortIndex, wfFddiSmtDelete=wfFddiSmtDelete, wfFddiPortPmdClass=wfFddiPortPmdClass, wfFddiXLineTxErrors=wfFddiXLineTxErrors, wfFddiXLineSlot=wfFddiXLineSlot, wfFddiXLineRxSmtInvalidLengthErrors=wfFddiXLineRxSmtInvalidLengthErrors, wfFddiXGroup=wfFddiXGroup, wfFDDIMtu=wfFDDIMtu, wfFddiMacMaUnitDataEnable=wfFddiMacMaUnitDataEnable, wfFDDIPhyALogPtr=wfFDDIPhyALogPtr, wfFddiMacUpstreamNbr=wfFddiMacUpstreamNbr, wfFddiPathDelete=wfFddiPathDelete, wfFddiMacDuplicateTokenCts=wfFddiMacDuplicateTokenCts, wfFddiMacBridgeFunctions=wfFddiMacBridgeFunctions, wfFddiXLineRxMacErrors=wfFddiXLineRxMacErrors, wfFddiPathSlot=wfFddiPathSlot, wfFddiSmtActionSlot=wfFddiSmtActionSlot, wfFddiPortMacPlacement=wfFddiPortMacPlacement, wfFDDIModule=wfFDDIModule, wfFddiPortLemRejectCts=wfFddiPortLemRejectCts, wfFddiXMacEntry=wfFddiXMacEntry, wfFddiSmtStationStatus=wfFddiSmtStationStatus, wfFddiSmtDatProtocol=wfFddiSmtDatProtocol, wfFddiPortConnectState=wfFddiPortConnectState, wfFddiMacTable=wfFddiMacTable, wfFDDITxQueueLength=wfFDDITxQueueLength, wfFddiMacTvxCapability=wfFddiMacTvxCapability, wfFDDIParityErrRx=wfFDDIParityErrRx, wfFddiXLineCfgIfIndex=wfFddiXLineCfgIfIndex, wfFddiXLineRxErrors=wfFddiXLineRxErrors, wfFddiSmtCct=wfFddiSmtCct, wfFddiXLineActualNode=wfFddiXLineActualNode, wfFddiXLineRxAbortErrors=wfFddiXLineRxAbortErrors, wfFddiXLineRxSmtEDataUnknownErrors=wfFddiXLineRxSmtEDataUnknownErrors, wfFddiXLineRxLastEDataFStatusErrorVal=wfFddiXLineRxLastEDataFStatusErrorVal, wfFddiSmtEntry=wfFddiSmtEntry, wfFddiSmtConfigCapabilities=wfFddiSmtConfigCapabilities, wfFddiPortMacIndicated=wfFddiPortMacIndicated, wfFddiPortAvailablePaths=wfFddiPortAvailablePaths, wfFddiMacExtNode=wfFddiMacExtNode, wfFddiXLineCfgEnable=wfFddiXLineCfgEnable, wfFddiXLineRxCrcErrors=wfFddiXLineRxCrcErrors, wfFddiSmtStationId=wfFddiSmtStationId, wfFddiMacOldDownstreamNbr=wfFddiMacOldDownstreamNbr, wfFddiSmtExtNode=wfFddiSmtExtNode, wfFDDITxRNRProcessings=wfFDDITxRNRProcessings, wfFddiPortSlot=wfFddiPortSlot, wfFddiXLineCfgDelete=wfFddiXLineCfgDelete, wfFddiPathNode=wfFddiPathNode, wfFDDIEnable=wfFDDIEnable, wfFddiMacTMaxCapability=wfFddiMacTMaxCapability, wfFddiPathTMaxLowerBound=wfFddiPathTMaxLowerBound, wfFddiSmtActionTable=wfFddiSmtActionTable, wfFddiSmtTable=wfFddiSmtTable, wfFddiXLineCfgEntry=wfFddiXLineCfgEntry, wfFddiXLineModule=wfFddiXLineModule, wfFddiPathExtTable=wfFddiPathExtTable, wfFddiXLineRxSmtUndersizedFrames=wfFddiXLineRxSmtUndersizedFrames, wfFddiXMacBridgeFunctions=wfFddiXMacBridgeFunctions, wfFDDIMacTMin=wfFDDIMacTMin, wfFddiSmtOpVersionId=wfFddiSmtOpVersionId, wfFddiSmtActionNode=wfFddiSmtActionNode, wfFddiMacLostCts=wfFddiMacLostCts, wfFddiXLineCfgActualNode=wfFddiXLineCfgActualNode, wfFDDISmtRingOverrunRx=wfFDDISmtRingOverrunRx, wfFddiSmtExtEntry=wfFddiSmtExtEntry, wfFddiPortPcmState=wfFddiPortPcmState, wfFddiTable=wfFddiTable, wfFddiXLineRxSmtFormatErrors=wfFddiXLineRxSmtFormatErrors, wfFddiXLineTxSmtFrames=wfFddiXLineTxSmtFrames, wfFddiPortEntry=wfFddiPortEntry, wfFddiMacExtCct=wfFddiMacExtCct, wfFDDIBofl=wfFDDIBofl, wfFddiPortActionIndex=wfFddiPortActionIndex, wfFddiPortTable=wfFddiPortTable, wfFddiMacSlot=wfFddiMacSlot, wfFddiMacExtTable=wfFddiMacExtTable, wfFddiMacFrameErrorRatio=wfFddiMacFrameErrorRatio, wfFddiXPortEbErrors=wfFddiXPortEbErrors, wfFddiSmtBypassPresent=wfFddiSmtBypassPresent, wfFddiPathExtCct=wfFddiPathExtCct, wfFddiSmtRemoteDisconnectFlag=wfFddiSmtRemoteDisconnectFlag, wfFddiXLineRxEDataUnknownErrors=wfFddiXLineRxEDataUnknownErrors, wfFddiXMacTable=wfFddiXMacTable, wfFddiMacTvxExpiredCts=wfFddiMacTvxExpiredCts, wfFddiSmtMibVersionId=wfFddiSmtMibVersionId, wfFDDICct=wfFDDICct, wfFDDICrcErrRx=wfFDDICrcErrRx, wfFddiSmtActionEntry=wfFddiSmtActionEntry, wfFddiSmtLoVersionId=wfFddiSmtLoVersionId, wfFddiMacRmtState=wfFddiMacRmtState, wfFddiSmtManufacturerData=wfFddiSmtManufacturerData, wfFddiXLineCfgNode=wfFddiXLineCfgNode, wfFddiMacHardwarePresent=wfFddiMacHardwarePresent, wfFDDIPortOpErr=wfFDDIPortOpErr, wfFddiMacTokenCts=wfFddiMacTokenCts, wfFDDISmtRingErrRx=wfFDDISmtRingErrRx, wfFDDIAbortTx=wfFDDIAbortTx, wfFDDIBoflLen=wfFDDIBoflLen, wfFddiPortCurrentPath=wfFddiPortCurrentPath, wfFddiPortLerFlag=wfFddiPortLerFlag, wfFDDITxProcessings=wfFDDITxProcessings, wfFddiMacGroup=wfFddiMacGroup, wfFddiPathEntry=wfFddiPathEntry, wfFddiPortActionNode=wfFddiPortActionNode, wfFddiXLineRxSmtInvalidFrameStatusErrors=wfFddiXLineRxSmtInvalidFrameStatusErrors, wfFddiPortConnectionPolicies=wfFddiPortConnectionPolicies, wfFddiXLineRxSmtAbortErrors=wfFddiXLineRxSmtAbortErrors, wfFddiXLineRxOverruns=wfFddiXLineRxOverruns, wfFddiXLineCfgSmtDatProtocol=wfFddiXLineCfgSmtDatProtocol, wfFddiPortLctFailCts=wfFddiPortLctFailCts, wfFddiXLineCfgLineNumber=wfFddiXLineCfgLineNumber, wfFDDILastChange=wfFDDILastChange, wfFDDIMacTMax=wfFDDIMacTMax, wfFddiSmtActionDelete=wfFddiSmtActionDelete, wfFddiPortActionDelete=wfFddiPortActionDelete, wfFDDIForcePeerTree=wfFDDIForcePeerTree, wfFddiXLineRxSmtFrames=wfFddiXLineRxSmtFrames, wfFddiPathTvxLowerBound=wfFddiPathTvxLowerBound, wfFddiPortAction=wfFddiPortAction, wfFddiMacCurrentPath=wfFddiMacCurrentPath, wfFddiXLinePhyALogPtr=wfFddiXLinePhyALogPtr, wfFddiXLineRxSmtOversizedFrames=wfFddiXLineRxSmtOversizedFrames, wfFDDIIntProcessings=wfFDDIIntProcessings, wfFDDIRxSmtFrames=wfFDDIRxSmtFrames, wfFddiXLineRxSmtSecondaryNsaFrames=wfFddiXLineRxSmtSecondaryNsaFrames, wfFddiMacAvailablePaths=wfFddiMacAvailablePaths, wfFddiPortActionTable=wfFddiPortActionTable, wfFddiXLineTxSmtOctets=wfFddiXLineTxSmtOctets, wfFddiPortConnectionCapabilities=wfFddiPortConnectionCapabilities, wfFddiXSmtIndex=wfFddiXSmtIndex, wfFddiMacMaUnitDataAvailable=wfFddiMacMaUnitDataAvailable, wfFDDISmtConnectionPolicy=wfFDDISmtConnectionPolicy, wfFddiSmtExtSlot=wfFddiSmtExtSlot, wfFddiSmtAvailablePaths=wfFddiSmtAvailablePaths, wfFDDIActualNode=wfFDDIActualNode, wfFddiMacOldUpstreamNbr=wfFddiMacOldUpstreamNbr, wfFddiPortIndex=wfFddiPortIndex, wfFddiSmtEcmState=wfFddiSmtEcmState, wfFddiXLineTxAborts=wfFddiXLineTxAborts, wfFDDIDelete=wfFDDIDelete, wfFDDIInvalidFrameStatusRx=wfFDDIInvalidFrameStatusRx, wfFddiSmtMacCt=wfFddiSmtMacCt, wfFddiXLineCfgTable=wfFddiXLineCfgTable, wfFddiXLineCfgForcePeerTree=wfFddiXLineCfgForcePeerTree, wfFddiXLineRxSmtMacErrors=wfFddiXLineRxSmtMacErrors, wfFddiPortPcType=wfFddiPortPcType, wfFddiPortPcWithhold=wfFddiPortPcWithhold, wfFddiXLineSmtIndex=wfFddiXLineSmtIndex, wfFDDIRingOverrunRx=wfFDDIRingOverrunRx, wfFDDIRxSmtUndersizedFrames=wfFDDIRxSmtUndersizedFrames, wfFDDISmtRxProcessings=wfFDDISmtRxProcessings, wfFddiSmtUserData=wfFddiSmtUserData, wfFddiSmtActionCct=wfFddiSmtActionCct, wfFddiSmtStatRptPolicy=wfFddiSmtStatRptPolicy, wfFDDIRingErrRx=wfFDDIRingErrRx, wfFddiEntry=wfFddiEntry, wfFddiSmtCfState=wfFddiSmtCfState, wfFddiXLineCfgLossOfServiceTmo=wfFddiXLineCfgLossOfServiceTmo, wfFddiXPortEntry=wfFddiXPortEntry, wfFDDIFramesRxOk=wfFDDIFramesRxOk, wfFddiMacExtSlot=wfFddiMacExtSlot, wfFddiXLineRxUndersizedFrames=wfFddiXLineRxUndersizedFrames, wfFddiSmtPeerWrapFlag=wfFddiSmtPeerWrapFlag, wfFDDIBoflTmo=wfFDDIBoflTmo, wfFDDIMadr=wfFDDIMadr, wfFDDILineNumber=wfFDDILineNumber, wfFddiXSmtEntry=wfFddiXSmtEntry, wfFddiMacDaFlag=wfFddiMacDaFlag, wfFddiPortGroup=wfFddiPortGroup, wfFddiXLinePhyBLogPtr=wfFddiXLinePhyBLogPtr, wfFddiSmtTimeStamp=wfFddiSmtTimeStamp, wfFDDISmtTNotify=wfFDDISmtTNotify, wfFddiPortExtIndex=wfFddiPortExtIndex, wfFddiPortNode=wfFddiPortNode, wfFddiPathGroup=wfFddiPathGroup, wfFddiSmtTraceMaxExpiration=wfFddiSmtTraceMaxExpiration, wfFddiXMacSmtIndex=wfFddiXMacSmtIndex, wfFDDIBoflNum=wfFDDIBoflNum, wfFddiMacCopiedCts=wfFddiMacCopiedCts, wfFDDIFramesTxOk=wfFDDIFramesTxOk, wfFddiMacFrameStatusFunctions=wfFddiMacFrameStatusFunctions, wfFddiSmtMasterCts=wfFddiSmtMasterCts, wfFDDICfgRxQueueLength=wfFDDICfgRxQueueLength, wfFddiMacRequestedPaths=wfFddiMacRequestedPaths, wfFddiMacExtEntry=wfFddiMacExtEntry, wfFddiMacFrameErrorThreshold=wfFddiMacFrameErrorThreshold, wfFddiXLineRxSmtFragmentErrors=wfFddiXLineRxSmtFragmentErrors, wfFDDILLCFrameControl=wfFDDILLCFrameControl, wfFddiXLineRxSmtLastEDataFStatusErrorVal=wfFddiXLineRxSmtLastEDataFStatusErrorVal, wfFddiMacSmtAddress=wfFddiMacSmtAddress, wfFddiPortLemCts=wfFddiPortLemCts, wfFddiPathExtEntry=wfFddiPathExtEntry, wfFddiPathMaxTReq=wfFddiPathMaxTReq, wfFddiXLineRxInvalidFrameStatusErrors=wfFddiXLineRxInvalidFrameStatusErrors, wfFDDISlot=wfFDDISlot, wfFDDIParityErrTx=wfFDDIParityErrTx, wfFDDIOctetsTxOk=wfFDDIOctetsTxOk, wfFddiPortLerAlarm=wfFddiPortLerAlarm, wfFDDICfgTxQueueLength=wfFDDICfgTxQueueLength, wfFddiXLineRxSmtCrcErrors=wfFddiXLineRxSmtCrcErrors, wfFddiPortLerEstimate=wfFddiPortLerEstimate, wfFddiXLineRxFormatErrors=wfFddiXLineRxFormatErrors, wfFDDIOverrunRx=wfFDDIOverrunRx, wfFddiSmtGroup=wfFddiSmtGroup, wfFddiXLineTable=wfFddiXLineTable, wfFddiSmtHiVersionId=wfFddiSmtHiVersionId, wfFddiXLineRxOversizedFrames=wfFddiXLineRxOversizedFrames, wfFDDITxClipFrames=wfFDDITxClipFrames, wfFddiPortActionSlot=wfFddiPortActionSlot, wfFDDIHardwareFilter=wfFDDIHardwareFilter, wfFddiXLineRxUnderruns=wfFddiXLineRxUnderruns, wfFddiXPortSmtIndex=wfFddiXPortSmtIndex, wfFDDINode=wfFDDINode, wfFddiSmtExtCct=wfFddiSmtExtCct, wfFDDIMacTvxValue=wfFDDIMacTvxValue, wfFddiPortActionCct=wfFddiPortActionCct, wfFDDIMacErrRx=wfFDDIMacErrRx, wfFddiSmtNode=wfFddiSmtNode, wfFddiPathTable=wfFddiPathTable, wfFddiSmtNonMasterCt=wfFddiSmtNonMasterCt, wfFddiPathConfiguration=wfFddiPathConfiguration, wfFddiXLineRxSmtOctets=wfFddiXLineRxSmtOctets, wfFddiSmtExtTable=wfFddiSmtExtTable, wfFddiXLineRxInvalidLengthErrors=wfFddiXLineRxInvalidLengthErrors, wfFDDIRxProcessings=wfFDDIRxProcessings, wfFddiXLineCfgSmtIndex=wfFddiXLineCfgSmtIndex, wfFddiXLineNode=wfFddiXLineNode, wfFddiPathExtNode=wfFddiPathExtNode, wfFddiMacNode=wfFddiMacNode, wfFddiXLineRxFragmentErrors=wfFddiXLineRxFragmentErrors, wfFddiPortExtCct=wfFddiPortExtCct, wfFddiPortExtEntry=wfFddiPortExtEntry, wfFDDIMacTReq=wfFDDIMacTReq, wfFDDIUnderrunTx=wfFDDIUnderrunTx, wfFDDIOutQLen=wfFDDIOutQLen, wfFddiXMacIndex=wfFddiXMacIndex, wfFDDIHostErr=wfFDDIHostErr, wfFddiMacDupAddrTest=wfFddiMacDupAddrTest, wfFddiMacLateCts=wfFddiMacLateCts, wfFddiPortRequestedPaths=wfFddiPortRequestedPaths, wfFDDIState=wfFDDIState, wfFddiMacCct=wfFddiMacCct, wfFddiPortExtTable=wfFddiPortExtTable, wfFddiPortDelete=wfFddiPortDelete, wfFddiSmtConfigPolicy=wfFddiSmtConfigPolicy, wfFddiXSmtTable=wfFddiXSmtTable)
mibBuilder.exportSymbols("Wellfleet-FDDI-MIB", wfFddiXPortTable=wfFddiXPortTable, wfFddiMacDownstreamNbr=wfFddiMacDownstreamNbr, wfFDDIRingErrTx=wfFDDIRingErrTx, wfFddiMacTNeg=wfFddiMacTNeg, wfFddiMacErrorCts=wfFddiMacErrorCts, wfFddiSmtSlot=wfFddiSmtSlot, wfFddiPortPcNeighbor=wfFddiPortPcNeighbor, wfFddiPortHardwarePresent=wfFddiPortHardwarePresent, wfFddiXSmtManufacturerData=wfFddiXSmtManufacturerData, wfFddiPortExtSlot=wfFddiPortExtSlot, wfFDDIPhyBLogPtr=wfFDDIPhyBLogPtr, wfFDDIOctetsRxOk=wfFDDIOctetsRxOk, wfFDDISmtEnable=wfFDDISmtEnable, wfFDDIRxReplenMisses=wfFDDIRxReplenMisses, wfFDDIRxUndersizedFrames=wfFDDIRxUndersizedFrames, wfFddiXLineCfgSmtEnable=wfFddiXLineCfgSmtEnable, wfFddiPathExtSlot=wfFddiPathExtSlot, wfFDDIRxOversizedFrames=wfFDDIRxOversizedFrames, wfFDDIRxQueueLength=wfFDDIRxQueueLength, wfFddiPortCct=wfFddiPortCct, wfFDDITurboBofl=wfFDDITurboBofl, wfFddiPortExtNode=wfFddiPortExtNode, wfFddiXLineCfgSlot=wfFddiXLineCfgSlot, wfFddiPortLerCutOff=wfFddiPortLerCutOff, wfFddiPortEbErrorCts=wfFddiPortEbErrorCts, wfFddiXLineTxOverruns=wfFddiXLineTxOverruns, wfFddiPathCct=wfFddiPathCct, wfFDDIRxSmtOversizedFrames=wfFDDIRxSmtOversizedFrames, wfFDDIInternOpErr=wfFDDIInternOpErr, wfFddiSmtStationAction=wfFddiSmtStationAction, wfFddiXMacDuplicateTokenCts=wfFddiXMacDuplicateTokenCts, wfFddiXLineCfgModule=wfFddiXLineCfgModule, wfFddiMacDownstreamPortType=wfFddiMacDownstreamPortType, wfFddiMacFrameErrorFlag=wfFddiMacFrameErrorFlag, wfFddiXLineUnexpectedFrames=wfFddiXLineUnexpectedFrames, wfFddiMacDelete=wfFddiMacDelete, wfFddiXLineIfIndex=wfFddiXLineIfIndex, wfFddiMacUnaDaFlag=wfFddiMacUnaDaFlag, wfFddiSmtTransitionTimeStamp=wfFddiSmtTransitionTimeStamp, wfFddiXLineEntry=wfFddiXLineEntry)

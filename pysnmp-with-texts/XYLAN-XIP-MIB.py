#
# PySNMP MIB module XYLAN-XIP-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/XYLAN-XIP-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:45:34 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, SingleValueConstraint, ConstraintsIntersection, ValueRangeConstraint, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "SingleValueConstraint", "ConstraintsIntersection", "ValueRangeConstraint", "ValueSizeConstraint")
MacAddress, = mibBuilder.importSymbols("BRIDGE-MIB", "MacAddress")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Unsigned32, iso, Integer32, Counter32, Counter64, MibIdentifier, Gauge32, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, NotificationType, IpAddress, ObjectIdentity, ModuleIdentity, Bits = mibBuilder.importSymbols("SNMPv2-SMI", "Unsigned32", "iso", "Integer32", "Counter32", "Counter64", "MibIdentifier", "Gauge32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks", "NotificationType", "IpAddress", "ObjectIdentity", "ModuleIdentity", "Bits")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
xylanXIPArch, = mibBuilder.importSymbols("XYLAN-BASE-MIB", "xylanXIPArch")
xylanXIPGMAPconfig = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 20, 1))
xylanXIPXMAPconfig = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 20, 2))
xylanXIPGMAPstate = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 20, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("inactive", 0), ("active", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylanXIPGMAPstate.setStatus('mandatory')
if mibBuilder.loadTexts: xylanXIPGMAPstate.setDescription('Current state of the GMAP functionality.')
xylanXIPGMAPgaptime = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 20, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylanXIPGMAPgaptime.setStatus('mandatory')
if mibBuilder.loadTexts: xylanXIPGMAPgaptime.setDescription('The time in milliseconds for gaps between successive GMAP protocol packets.')
xylanXIPGMAPupdatetime = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 20, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylanXIPGMAPupdatetime.setStatus('mandatory')
if mibBuilder.loadTexts: xylanXIPGMAPupdatetime.setDescription('The time in seconds between GMAP update packet generation.')
xylanXIPGMAPholdtime = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 20, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylanXIPGMAPholdtime.setStatus('mandatory')
if mibBuilder.loadTexts: xylanXIPGMAPholdtime.setDescription('The time in minutes that the switch will remember information received in GMAP update packets.')
xylanXIPGMAPLastTrapReason = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 20, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("no-trap-sent", 0), ("authenticated-group", 1), ("conflicting-binding-rule", 2), ("same-proto-different-groups-conflict", 3), ("same-group-different-protocols-conflict", 4), ("non-mobile-group", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylanXIPGMAPLastTrapReason.setStatus('mandatory')
if mibBuilder.loadTexts: xylanXIPGMAPLastTrapReason.setDescription('Reason for last GMAP update to not be applied. Valid reasons are: 0 - No trap has been sent 1 - Target group is an authenticated group 2 - Update would conflict with a binding rule 3 - Update would create two different group entries for the same protocol 4 - Update would create two different protocol entries for the same group 5 - Target group is not mobile')
xylanXIPGMAPLastTrapPort = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 20, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylanXIPGMAPLastTrapPort.setStatus('mandatory')
if mibBuilder.loadTexts: xylanXIPGMAPLastTrapPort.setDescription('The virtual port number of the last port on which the GMAP change was not applied because of a conflict.')
xylanXIPGMAPLastTrapMac = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 20, 1, 7), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylanXIPGMAPLastTrapMac.setStatus('mandatory')
if mibBuilder.loadTexts: xylanXIPGMAPLastTrapMac.setDescription('The last MAC address for which a GMAP change was not applied because of a conflict.')
xylanXIPGMAPLastTrapProtocol = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 20, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylanXIPGMAPLastTrapProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: xylanXIPGMAPLastTrapProtocol.setDescription('The protocol identifier of the last GMAP change that was not applied because of a conflict.')
xylanXIPGMAPLastTrapGroup = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 20, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylanXIPGMAPLastTrapGroup.setStatus('mandatory')
if mibBuilder.loadTexts: xylanXIPGMAPLastTrapGroup.setDescription('The group identifier of the last GMAP change that was not applied because of a conflict.')
xylanXIPGMAPTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 20, 1, 10), )
if mibBuilder.loadTexts: xylanXIPGMAPTable.setStatus('mandatory')
if mibBuilder.loadTexts: xylanXIPGMAPTable.setDescription('GMAP MAC address list.')
xylanXIPGMAPTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 20, 1, 10, 1), ).setIndexNames((0, "XYLAN-XIP-MIB", "xylanXIPGMAPMacAddr"), (0, "XYLAN-XIP-MIB", "xylanXIPGMAPProtocol"))
if mibBuilder.loadTexts: xylanXIPGMAPTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: xylanXIPGMAPTableEntry.setDescription('GMAP MAC address list.')
xylanXIPGMAPMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 20, 1, 10, 1, 1), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylanXIPGMAPMacAddr.setStatus('mandatory')
if mibBuilder.loadTexts: xylanXIPGMAPMacAddr.setDescription('The MAC address of a GMAP entry.')
xylanXIPGMAPProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 20, 1, 10, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylanXIPGMAPProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: xylanXIPGMAPProtocol.setDescription('The protocol identifier for a GMAP entry.')
xylanXIPGMAPGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 20, 1, 10, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylanXIPGMAPGroup.setStatus('mandatory')
if mibBuilder.loadTexts: xylanXIPGMAPGroup.setDescription('The group identifier for a GMAP entry.')
xylanXIPGMAPSrcSwitch = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 20, 1, 10, 1, 4), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylanXIPGMAPSrcSwitch.setStatus('mandatory')
if mibBuilder.loadTexts: xylanXIPGMAPSrcSwitch.setDescription('The MAC address of the switch that provided the information for a GMAP entry.')
xylanXIPGMAPFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 20, 1, 10, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylanXIPGMAPFlags.setStatus('mandatory')
if mibBuilder.loadTexts: xylanXIPGMAPFlags.setDescription('The flags for a GMAP entry. The least significant byte holds the router flags. The next byte contains the flags from auto-tracker. The most significant 2 bytes are not currently used.')
xylanXIPGMAPTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 20, 1, 10, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylanXIPGMAPTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: xylanXIPGMAPTimeout.setDescription('Seconds remaining before this entry will age out.')
xylanXIPXMAPstate = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 20, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("inactive", 0), ("active", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylanXIPXMAPstate.setStatus('mandatory')
if mibBuilder.loadTexts: xylanXIPXMAPstate.setDescription('Current state of the XMAP agent.')
xylanXIPXMAPdisctime = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 20, 2, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylanXIPXMAPdisctime.setStatus('mandatory')
if mibBuilder.loadTexts: xylanXIPXMAPdisctime.setDescription('The time in seconds for interval betweeen hello packets in the initial discovery phase of the XMAP protocol.')
xylanXIPXMAPcommontime = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 20, 2, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylanXIPXMAPcommontime.setStatus('mandatory')
if mibBuilder.loadTexts: xylanXIPXMAPcommontime.setDescription('The time in seconds for the interval between hello packets at other than the discovery phase.')
xylanXIPXMAPLastTrapReason = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 20, 2, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("no-trap-sent", 0), ("add", 1), ("change", 2), ("remove", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylanXIPXMAPLastTrapReason.setStatus('mandatory')
if mibBuilder.loadTexts: xylanXIPXMAPLastTrapReason.setDescription('Reason for last change of port status. Valid reasons are: 0 - no trap has been sent 1 - port added 2 - change of information on existing port 3 - port deleted')
xylanXIPXMAPLastTrapPort = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 20, 2, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylanXIPXMAPLastTrapPort.setStatus('mandatory')
if mibBuilder.loadTexts: xylanXIPXMAPLastTrapPort.setDescription('The virtual port number of the port that most recently changed.')
xylanXIPXMAPports = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 20, 2, 6), )
if mibBuilder.loadTexts: xylanXIPXMAPports.setStatus('mandatory')
if mibBuilder.loadTexts: xylanXIPXMAPports.setDescription('XMAP adjacent switch, remote port, and group information.')
xylanXIPXMAPPortentry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 20, 2, 6, 1), ).setIndexNames((0, "XYLAN-XIP-MIB", "xylanXIPXMAPAdjPort"), (0, "XYLAN-XIP-MIB", "xylanXIPXMAPRemMac"), (0, "XYLAN-XIP-MIB", "xylanXIPXMAPRemPort"))
if mibBuilder.loadTexts: xylanXIPXMAPPortentry.setStatus('mandatory')
if mibBuilder.loadTexts: xylanXIPXMAPPortentry.setDescription('XMAP adjacent switch, remote port, and group information.')
xylanXIPXMAPAdjPort = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 20, 2, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylanXIPXMAPAdjPort.setStatus('mandatory')
if mibBuilder.loadTexts: xylanXIPXMAPAdjPort.setDescription('The local virtual port number which has an adjacent switch connected.')
xylanXIPXMAPRemMac = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 20, 2, 6, 1, 2), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylanXIPXMAPRemMac.setStatus('mandatory')
if mibBuilder.loadTexts: xylanXIPXMAPRemMac.setDescription('The MAC Address of the MPM in the adjacent switch.')
xylanXIPXMAPRemPort = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 20, 2, 6, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylanXIPXMAPRemPort.setStatus('mandatory')
if mibBuilder.loadTexts: xylanXIPXMAPRemPort.setDescription('The remote virtual port number in the adjacent switch.')
xylanXIPXMAPRemGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 20, 2, 6, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylanXIPXMAPRemGroup.setStatus('mandatory')
if mibBuilder.loadTexts: xylanXIPXMAPRemGroup.setDescription('The remote group for the virtual port in the adjacent switch.')
xylanXIPXMAPhosts = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 20, 2, 7), )
if mibBuilder.loadTexts: xylanXIPXMAPhosts.setStatus('mandatory')
if mibBuilder.loadTexts: xylanXIPXMAPhosts.setDescription('XMAP adjacent switch IP address information.')
xylanXIPXMAPHostentry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 20, 2, 7, 1), ).setIndexNames((0, "XYLAN-XIP-MIB", "xylanXIPXMAPHostMac"), (0, "XYLAN-XIP-MIB", "xylanXIPXMAPIpAddr"))
if mibBuilder.loadTexts: xylanXIPXMAPHostentry.setStatus('mandatory')
if mibBuilder.loadTexts: xylanXIPXMAPHostentry.setDescription('XMAP adjacent switch IP address information.')
xylanXIPXMAPHostMac = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 20, 2, 7, 1, 1), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylanXIPXMAPHostMac.setStatus('mandatory')
if mibBuilder.loadTexts: xylanXIPXMAPHostMac.setDescription('The MAC Address of the MPM in the adjacent switch.')
xylanXIPXMAPIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 20, 2, 7, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylanXIPXMAPIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: xylanXIPXMAPIpAddr.setDescription('An IP address of the adjacent switch.')
mibBuilder.exportSymbols("XYLAN-XIP-MIB", xylanXIPGMAPholdtime=xylanXIPGMAPholdtime, xylanXIPXMAPLastTrapPort=xylanXIPXMAPLastTrapPort, xylanXIPXMAPdisctime=xylanXIPXMAPdisctime, xylanXIPXMAPHostentry=xylanXIPXMAPHostentry, xylanXIPGMAPSrcSwitch=xylanXIPGMAPSrcSwitch, xylanXIPXMAPconfig=xylanXIPXMAPconfig, xylanXIPGMAPProtocol=xylanXIPGMAPProtocol, xylanXIPXMAPAdjPort=xylanXIPXMAPAdjPort, xylanXIPXMAPhosts=xylanXIPXMAPhosts, xylanXIPXMAPcommontime=xylanXIPXMAPcommontime, xylanXIPGMAPstate=xylanXIPGMAPstate, xylanXIPGMAPTableEntry=xylanXIPGMAPTableEntry, xylanXIPXMAPstate=xylanXIPXMAPstate, xylanXIPGMAPLastTrapPort=xylanXIPGMAPLastTrapPort, xylanXIPXMAPRemGroup=xylanXIPXMAPRemGroup, xylanXIPXMAPHostMac=xylanXIPXMAPHostMac, xylanXIPXMAPports=xylanXIPXMAPports, xylanXIPGMAPupdatetime=xylanXIPGMAPupdatetime, xylanXIPXMAPRemMac=xylanXIPXMAPRemMac, xylanXIPXMAPRemPort=xylanXIPXMAPRemPort, xylanXIPGMAPLastTrapMac=xylanXIPGMAPLastTrapMac, xylanXIPGMAPGroup=xylanXIPGMAPGroup, xylanXIPGMAPconfig=xylanXIPGMAPconfig, xylanXIPGMAPLastTrapReason=xylanXIPGMAPLastTrapReason, xylanXIPXMAPPortentry=xylanXIPXMAPPortentry, xylanXIPGMAPTable=xylanXIPGMAPTable, xylanXIPGMAPFlags=xylanXIPGMAPFlags, xylanXIPGMAPLastTrapProtocol=xylanXIPGMAPLastTrapProtocol, xylanXIPGMAPMacAddr=xylanXIPGMAPMacAddr, xylanXIPGMAPTimeout=xylanXIPGMAPTimeout, xylanXIPXMAPLastTrapReason=xylanXIPXMAPLastTrapReason, xylanXIPGMAPLastTrapGroup=xylanXIPGMAPLastTrapGroup, xylanXIPXMAPIpAddr=xylanXIPXMAPIpAddr, xylanXIPGMAPgaptime=xylanXIPGMAPgaptime)

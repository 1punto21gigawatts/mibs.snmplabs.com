#
# PySNMP MIB module BFD-STD-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/BFD-STD-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:37:46 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ValueSizeConstraint, ConstraintsIntersection, ValueRangeConstraint, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ValueSizeConstraint", "ConstraintsIntersection", "ValueRangeConstraint", "SingleValueConstraint")
BfdSessIndexTC, BfdMultiplierTC, BfdIntervalTC, BfdCtrlSourcePortNumberTC, BfdCtrlDestPortNumberTC = mibBuilder.importSymbols("BFD-TC-STD-MIB", "BfdSessIndexTC", "BfdMultiplierTC", "BfdIntervalTC", "BfdCtrlSourcePortNumberTC", "BfdCtrlDestPortNumberTC")
IndexIntegerNextFree, = mibBuilder.importSymbols("DIFFSERV-DSCP-TC", "IndexIntegerNextFree")
IANAbfdSessAuthenticationTypeTC, IANAbfdSessAuthenticationKeyTC, IANAbfdSessTypeTC, IANAbfdDiagTC, IANAbfdSessStateTC, IANAbfdSessOperModeTC = mibBuilder.importSymbols("IANA-BFD-TC-STD-MIB", "IANAbfdSessAuthenticationTypeTC", "IANAbfdSessAuthenticationKeyTC", "IANAbfdSessTypeTC", "IANAbfdDiagTC", "IANAbfdSessStateTC", "IANAbfdSessOperModeTC")
InterfaceIndexOrZero, = mibBuilder.importSymbols("IF-MIB", "InterfaceIndexOrZero")
InetAddress, InetPortNumber, InetAddressType = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddress", "InetPortNumber", "InetAddressType")
NotificationGroup, ObjectGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ObjectGroup", "ModuleCompliance")
MibIdentifier, Bits, NotificationType, TimeTicks, ModuleIdentity, Gauge32, Unsigned32, Counter64, IpAddress, ObjectIdentity, Counter32, iso, MibScalar, MibTable, MibTableRow, MibTableColumn, Integer32, mib_2 = mibBuilder.importSymbols("SNMPv2-SMI", "MibIdentifier", "Bits", "NotificationType", "TimeTicks", "ModuleIdentity", "Gauge32", "Unsigned32", "Counter64", "IpAddress", "ObjectIdentity", "Counter32", "iso", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Integer32", "mib-2")
TimeStamp, TextualConvention, RowStatus, TruthValue, StorageType, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TimeStamp", "TextualConvention", "RowStatus", "TruthValue", "StorageType", "DisplayString")
bfdMIB = ModuleIdentity((1, 3, 6, 1, 2, 1, 222))
bfdMIB.setRevisions(('2014-08-12 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: bfdMIB.setRevisionsDescriptions(('Initial version. Published as RFC 7331.',))
if mibBuilder.loadTexts: bfdMIB.setLastUpdated('201408120000Z')
if mibBuilder.loadTexts: bfdMIB.setOrganization('IETF Bidirectional Forwarding Detection Working Group')
if mibBuilder.loadTexts: bfdMIB.setContactInfo('Thomas D. Nadeau Brocade Email: tnadeau@lucidvision.com Zafar Ali Cisco Systems, Inc. Email: zali@cisco.com Nobo Akiya Cisco Systems, Inc. Email: nobo@cisco.com Comments about this document should be emailed directly to the BFD Working Group mailing list at rtg-bfd@ietf.org')
if mibBuilder.loadTexts: bfdMIB.setDescription("Bidirectional Forwarding Management Information Base. Copyright (c) 2014 IETF Trust and the persons identified as authors of the code. All rights reserved. Redistribution and use in source and binary forms, with or without modification, is permitted pursuant to, and subject to the license terms contained in, the Simplified BSD License set forth in Section 4.c of the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info).")
bfdNotifications = MibIdentifier((1, 3, 6, 1, 2, 1, 222, 0))
bfdObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 222, 1))
bfdConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 222, 2))
bfdScalarObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 222, 1, 1))
bfdAdminStatus = MibScalar((1, 3, 6, 1, 2, 1, 222, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("adminDown", 3), ("down", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bfdAdminStatus.setStatus('current')
if mibBuilder.loadTexts: bfdAdminStatus.setDescription('The desired global administrative status of the BFD system in this device.')
bfdOperStatus = MibScalar((1, 3, 6, 1, 2, 1, 222, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("adminDown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bfdOperStatus.setStatus('current')
if mibBuilder.loadTexts: bfdOperStatus.setDescription('Indicates the actual operational status of the BFD system in this device. When this value is down(2), all entries in the bfdSessTable MUST have their bfdSessOperStatus as down(2) as well. When this value is adminDown(3), all entries in the bfdSessTable MUST have their bfdSessOperStatus as adminDown(3) as well.')
bfdNotificationsEnable = MibScalar((1, 3, 6, 1, 2, 1, 222, 1, 1, 3), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bfdNotificationsEnable.setReference('See also RFC3413 for explanation that notifications are under the ultimate control of the MIB modules in this document.')
if mibBuilder.loadTexts: bfdNotificationsEnable.setStatus('current')
if mibBuilder.loadTexts: bfdNotificationsEnable.setDescription('If this object is set to true(1), then it enables the emission of bfdSessUp and bfdSessDown notifications; otherwise these notifications are not emitted.')
bfdSessIndexNext = MibScalar((1, 3, 6, 1, 2, 1, 222, 1, 1, 4), IndexIntegerNextFree().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bfdSessIndexNext.setStatus('current')
if mibBuilder.loadTexts: bfdSessIndexNext.setDescription('This object contains an unused value for bfdSessIndex that can be used when creating entries in the table. A zero indicates that no entries are available, but MUST NOT be used as a valid index. ')
bfdSessTable = MibTable((1, 3, 6, 1, 2, 1, 222, 1, 2), )
if mibBuilder.loadTexts: bfdSessTable.setReference('Katz, D. and D. Ward, Bidirectional Forwarding Detection (BFD), RFC 5880, June 2012.')
if mibBuilder.loadTexts: bfdSessTable.setStatus('current')
if mibBuilder.loadTexts: bfdSessTable.setDescription('The BFD Session Table describes the BFD sessions.')
bfdSessEntry = MibTableRow((1, 3, 6, 1, 2, 1, 222, 1, 2, 1), ).setIndexNames((0, "BFD-STD-MIB", "bfdSessIndex"))
if mibBuilder.loadTexts: bfdSessEntry.setStatus('current')
if mibBuilder.loadTexts: bfdSessEntry.setDescription('The BFD Session Entry describes BFD session.')
bfdSessIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 2, 1, 1), BfdSessIndexTC())
if mibBuilder.loadTexts: bfdSessIndex.setStatus('current')
if mibBuilder.loadTexts: bfdSessIndex.setDescription('This object contains an index used to represent a unique BFD session on this device. Managers should obtain new values for row creation in this table by reading bfdSessIndexNext.')
bfdSessVersionNumber = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 2, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 7)).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bfdSessVersionNumber.setReference('Katz, D. and D. Ward, Bidirectional Forwarding Detection (BFD), RFC 5880, June 2012.')
if mibBuilder.loadTexts: bfdSessVersionNumber.setStatus('current')
if mibBuilder.loadTexts: bfdSessVersionNumber.setDescription('The version number of the BFD protocol that this session is running in. Write access is available for this object to provide ability to set desired version for this BFD session.')
bfdSessType = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 2, 1, 3), IANAbfdSessTypeTC()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bfdSessType.setStatus('current')
if mibBuilder.loadTexts: bfdSessType.setDescription('This object specifies the type of this BFD session.')
bfdSessDiscriminator = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 2, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bfdSessDiscriminator.setStatus('current')
if mibBuilder.loadTexts: bfdSessDiscriminator.setDescription('This object specifies the local discriminator for this BFD session, used to uniquely identify it.')
bfdSessRemoteDiscr = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 2, 1, 5), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 4294967295), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bfdSessRemoteDiscr.setReference('Section 6.8.6, from Katz, D. and D. Ward, Bidirectional Forwarding Detection (BFD), RFC 5880, June 2012.')
if mibBuilder.loadTexts: bfdSessRemoteDiscr.setStatus('current')
if mibBuilder.loadTexts: bfdSessRemoteDiscr.setDescription('This object specifies the session discriminator chosen by the remote system for this BFD session. The value may be zero(0) if the remote discriminator is not yet known or if the session is in the down or adminDown(1) state.')
bfdSessDestinationUdpPort = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 2, 1, 6), BfdCtrlDestPortNumberTC()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bfdSessDestinationUdpPort.setStatus('current')
if mibBuilder.loadTexts: bfdSessDestinationUdpPort.setDescription("This object specifies the destination UDP port number used for this BFD session's control packets. The value may be zero(0) if the session is in adminDown(1) state.")
bfdSessSourceUdpPort = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 2, 1, 7), BfdCtrlSourcePortNumberTC()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bfdSessSourceUdpPort.setStatus('current')
if mibBuilder.loadTexts: bfdSessSourceUdpPort.setDescription("This object specifies the source UDP port number used for this BFD session's control packets. The value may be zero(0) if the session is in adminDown(1) state. Upon creation of a new BFD session via this MIB, the value of zero(0) specified would permit the implementation to choose its own source port number.")
bfdSessEchoSourceUdpPort = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 2, 1, 8), InetPortNumber()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bfdSessEchoSourceUdpPort.setStatus('current')
if mibBuilder.loadTexts: bfdSessEchoSourceUdpPort.setDescription("This object specifies the source UDP port number used for this BFD session's echo packets. The value may be zero(0) if the session is not running in the echo mode, or the session is in adminDown(1) state. Upon creation of a new BFD session via this MIB, the value of zero(0) would permit the implementation to choose its own source port number.")
bfdSessAdminStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("adminDown", 3), ("down", 4)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bfdSessAdminStatus.setStatus('current')
if mibBuilder.loadTexts: bfdSessAdminStatus.setDescription('Denotes the desired operational status of the BFD Session. A transition to enabled(1) will start the BFD state machine for the session. The state machine will have an initial state of down(2). A transition to disabled(2) will stop the BFD state machine for the session. The state machine may first transition to adminDown(1) prior to stopping. A transition to adminDown(3) will cause the BFD state machine to transition to adminDown(1), and will cause the session to remain in this state. A transition to down(4) will cause the BFD state machine to transition to down(2), and will cause the session to remain in this state. Care should be used in providing write access to this object without adequate authentication.')
bfdSessOperStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("adminDown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bfdSessOperStatus.setStatus('current')
if mibBuilder.loadTexts: bfdSessOperStatus.setDescription('Denotes the actual operational status of the BFD Session. If the value of bfdOperStatus is down(2), this value MUST eventually be down(2) as well. If the value of bfdOperStatus is adminDown(3), this value MUST eventually be adminDown(3) as well.')
bfdSessState = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 2, 1, 11), IANAbfdSessStateTC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bfdSessState.setStatus('current')
if mibBuilder.loadTexts: bfdSessState.setDescription('Configured BFD session state.')
bfdSessRemoteHeardFlag = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 2, 1, 12), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bfdSessRemoteHeardFlag.setReference('Katz, D. and D. Ward, Bidirectional Forwarding Detection (BFD), RFC 5880, June 2012.')
if mibBuilder.loadTexts: bfdSessRemoteHeardFlag.setStatus('current')
if mibBuilder.loadTexts: bfdSessRemoteHeardFlag.setDescription('This object specifies status of BFD packet reception from the remote system. Specifically, it is set to true(1) if the local system is actively receiving BFD packets from the remote system, and is set to false(2) if the local system has not received BFD packets recently (within the detection time) or if the local system is attempting to tear down the BFD session.')
bfdSessDiag = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 2, 1, 13), IANAbfdDiagTC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bfdSessDiag.setStatus('current')
if mibBuilder.loadTexts: bfdSessDiag.setDescription("A diagnostic code specifying the local system's reason for the last transition of the session from up(4) to some other state.")
bfdSessOperMode = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 2, 1, 14), IANAbfdSessOperModeTC()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bfdSessOperMode.setStatus('current')
if mibBuilder.loadTexts: bfdSessOperMode.setDescription('This object specifies the operational mode of this BFD session.')
bfdSessDemandModeDesiredFlag = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 2, 1, 15), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bfdSessDemandModeDesiredFlag.setStatus('current')
if mibBuilder.loadTexts: bfdSessDemandModeDesiredFlag.setDescription("This object indicates that the local system's desire to use Demand mode. Specifically, it is set to true(1) if the local system wishes to use Demand mode or false(2) if not")
bfdSessControlPlaneIndepFlag = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 2, 1, 16), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bfdSessControlPlaneIndepFlag.setStatus('current')
if mibBuilder.loadTexts: bfdSessControlPlaneIndepFlag.setDescription("This object indicates that the local system's ability to continue to function through a disruption of the control plane. Specifically, it is set to true(1) if the local system BFD implementation is independent of the control plane. Otherwise, the value is set to false(2)")
bfdSessMultipointFlag = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 2, 1, 17), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bfdSessMultipointFlag.setStatus('current')
if mibBuilder.loadTexts: bfdSessMultipointFlag.setDescription('This object indicates the Multipoint (M) bit for this session. It is set to true(1) if Multipoint (M) bit is set to 1. Otherwise, the value is set to false(2)')
bfdSessInterface = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 2, 1, 18), InterfaceIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bfdSessInterface.setStatus('current')
if mibBuilder.loadTexts: bfdSessInterface.setDescription('This object contains an interface index used to indicate the interface which this BFD session is running on. This value can be zero if there is no interface associated with this BFD session.')
bfdSessSrcAddrType = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 2, 1, 19), InetAddressType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bfdSessSrcAddrType.setStatus('current')
if mibBuilder.loadTexts: bfdSessSrcAddrType.setDescription('This object specifies IP address type of the source IP address of this BFD session. The value of unknown(0) is allowed only when the session is singleHop(1) and the source IP address of this BFD session is derived from the outgoing interface, or when the BFD session is not associated with a specific interface. If any other unsupported values are attempted in a set operation, the agent MUST return an inconsistentValue error.')
bfdSessSrcAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 2, 1, 20), InetAddress().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bfdSessSrcAddr.setStatus('current')
if mibBuilder.loadTexts: bfdSessSrcAddr.setDescription('This object specifies the source IP address of this BFD session. The format of this object is controlled by the bfdSessSrcAddrType object.')
bfdSessDstAddrType = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 2, 1, 21), InetAddressType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bfdSessDstAddrType.setStatus('current')
if mibBuilder.loadTexts: bfdSessDstAddrType.setDescription('This object specifies IP address type of the neighboring IP address which is being monitored with this BFD session. The value of unknown(0) is allowed only when the session is singleHop(1) and the outgoing interface is of type point-to-point, or when the BFD session is not associated with a specific interface. If any other unsupported values are attempted in a set operation, the agent MUST return an inconsistentValue error.')
bfdSessDstAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 2, 1, 22), InetAddress().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bfdSessDstAddr.setStatus('current')
if mibBuilder.loadTexts: bfdSessDstAddr.setDescription('This object specifies the neighboring IP address which is being monitored with this BFD session. The format of this object is controlled by the bfdSessDstAddrType object.')
bfdSessGTSM = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 2, 1, 23), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bfdSessGTSM.setReference('RFC5082, The Generalized TTL Security Mechanism (GTSM). RFC5881, Section 5')
if mibBuilder.loadTexts: bfdSessGTSM.setStatus('current')
if mibBuilder.loadTexts: bfdSessGTSM.setDescription('Setting the value of this object to false(2) will disable GTSM protection of the BFD session. GTSM MUST be enabled on a singleHop(1) session if no authentication is in use.')
bfdSessGTSMTTL = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 2, 1, 24), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(255)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bfdSessGTSMTTL.setReference('RFC5082, The Generalized TTL Security Mechanism (GTSM). RFC5881, Section 5')
if mibBuilder.loadTexts: bfdSessGTSMTTL.setStatus('current')
if mibBuilder.loadTexts: bfdSessGTSMTTL.setDescription('This object is valid only when bfdSessGTSM protection is enabled on the system. This object indicates the minimum allowed TTL for received BFD control packets. For a singleHop(1) session, if GTSM protection is enabled, this object SHOULD be set to maximum TTL value allowed for single hop. By default, GTSM is enabled and TTL value is 255. For a multihop session, updating of maximum TTL value allowed is likely required.')
bfdSessDesiredMinTxInterval = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 2, 1, 25), BfdIntervalTC()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bfdSessDesiredMinTxInterval.setReference('Section 4.1 from Katz, D. and D. Ward, Bidirectional Forwarding Detection (BFD), RFC 5880, June 2012.')
if mibBuilder.loadTexts: bfdSessDesiredMinTxInterval.setStatus('current')
if mibBuilder.loadTexts: bfdSessDesiredMinTxInterval.setDescription('This object specifies the minimum interval, in microseconds, that the local system would like to use when transmitting BFD Control packets. The value of zero(0) is reserved in this case, and should not be used.')
bfdSessReqMinRxInterval = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 2, 1, 26), BfdIntervalTC()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bfdSessReqMinRxInterval.setReference('Section 4.1 from Katz, D. and D. Ward, Bidirectional Forwarding Detection (BFD), RFC 5880, June 2012.')
if mibBuilder.loadTexts: bfdSessReqMinRxInterval.setStatus('current')
if mibBuilder.loadTexts: bfdSessReqMinRxInterval.setDescription('This object specifies the minimum interval, in microseconds, between received BFD Control packets the local system is capable of supporting. The value of zero(0) can be specified when the transmitting system does not want the remote system to send any periodic BFD control packets.')
bfdSessReqMinEchoRxInterval = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 2, 1, 27), BfdIntervalTC()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bfdSessReqMinEchoRxInterval.setStatus('current')
if mibBuilder.loadTexts: bfdSessReqMinEchoRxInterval.setDescription('This object specifies the minimum interval, in microseconds, between received BFD Echo packets that this system is capable of supporting. Value must be zero(0) if this is a multihop BFD session.')
bfdSessDetectMult = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 2, 1, 28), BfdMultiplierTC()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bfdSessDetectMult.setStatus('current')
if mibBuilder.loadTexts: bfdSessDetectMult.setDescription('This object specifies the Detect time multiplier.')
bfdSessNegotiatedInterval = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 2, 1, 29), BfdIntervalTC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bfdSessNegotiatedInterval.setStatus('current')
if mibBuilder.loadTexts: bfdSessNegotiatedInterval.setDescription('This object specifies the negotiated interval, in microseconds, that the local system is transmitting BFD Control packets.')
bfdSessNegotiatedEchoInterval = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 2, 1, 30), BfdIntervalTC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bfdSessNegotiatedEchoInterval.setStatus('current')
if mibBuilder.loadTexts: bfdSessNegotiatedEchoInterval.setDescription('This object specifies the negotiated interval, in microseconds, that the local system is transmitting BFD echo packets. Value is expected to be zero if the sessions is not running in echo mode.')
bfdSessNegotiatedDetectMult = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 2, 1, 31), BfdMultiplierTC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bfdSessNegotiatedDetectMult.setStatus('current')
if mibBuilder.loadTexts: bfdSessNegotiatedDetectMult.setDescription('This object specifies the Detect time multiplier.')
bfdSessAuthPresFlag = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 2, 1, 32), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bfdSessAuthPresFlag.setReference('Sections 4.2 - 4.4 from Katz, D. and D. Ward, Bidirectional Forwarding Detection (BFD), RFC 5880, June 2012.')
if mibBuilder.loadTexts: bfdSessAuthPresFlag.setStatus('current')
if mibBuilder.loadTexts: bfdSessAuthPresFlag.setDescription("This object indicates that the local system's desire to use Authentication. Specifically, it is set to true(1) if the local system wishes the session to be authenticated or false(2) if not.")
bfdSessAuthenticationType = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 2, 1, 33), IANAbfdSessAuthenticationTypeTC().clone('noAuthentication')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bfdSessAuthenticationType.setReference('Sections 4.2 - 4.4 from Katz, D. and D. Ward, Bidirectional Forwarding Detection (BFD), RFC 5880, June 2012.')
if mibBuilder.loadTexts: bfdSessAuthenticationType.setStatus('current')
if mibBuilder.loadTexts: bfdSessAuthenticationType.setDescription('The Authentication Type used for this BFD session. This field is valid only when the Authentication Present bit is set. Max-access to this object as well as other authentication related objects are set to read-create in order to support management of a single key ID at a time, key rotation is not handled. Key update in practice must be done by atomic update using a set containing all affected objects in the same varBindList or otherwise risk the session dropping.')
bfdSessAuthenticationKeyID = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 2, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(-1, -1), ValueRangeConstraint(0, 255), )).clone(-1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bfdSessAuthenticationKeyID.setReference('Sections 4.2 - 4.4 from Katz, D. and D. Ward, Bidirectional Forwarding Detection (BFD), RFC 5880, June 2012.')
if mibBuilder.loadTexts: bfdSessAuthenticationKeyID.setStatus('current')
if mibBuilder.loadTexts: bfdSessAuthenticationKeyID.setDescription('The authentication key ID in use for this session. This object permits multiple keys to be active simultaneously. The value -1 indicates that no Authentication Key ID will be present in the optional BFD Authentication Section.')
bfdSessAuthenticationKey = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 2, 1, 35), IANAbfdSessAuthenticationKeyTC()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bfdSessAuthenticationKey.setReference('Sections 4.2 - 4.4 from Katz, D. and D. Ward, Bidirectional Forwarding Detection (BFD), RFC 5880, June 2012.')
if mibBuilder.loadTexts: bfdSessAuthenticationKey.setStatus('current')
if mibBuilder.loadTexts: bfdSessAuthenticationKey.setDescription('The authentication key. When the bfdSessAuthenticationType is simplePassword(1), the value of this object is the password present in the BFD packets. When the bfdSessAuthenticationType is one of the keyed authentication types, this value is used in the computation of the key present in the BFD authentication packet.')
bfdSessStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 2, 1, 36), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bfdSessStorageType.setStatus('current')
if mibBuilder.loadTexts: bfdSessStorageType.setDescription("This variable indicates the storage type for this object. Conceptual rows having the value 'permanent' need not allow write-access to any columnar objects in the row.")
bfdSessRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 2, 1, 37), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bfdSessRowStatus.setStatus('current')
if mibBuilder.loadTexts: bfdSessRowStatus.setDescription('This variable is used to create, modify, and/or delete a row in this table. When a row in this table has a row in the active(1) state, no objects in this row can be modified except the bfdSessRowStatus and bfdSessStorageType.')
bfdSessPerfTable = MibTable((1, 3, 6, 1, 2, 1, 222, 1, 3), )
if mibBuilder.loadTexts: bfdSessPerfTable.setStatus('current')
if mibBuilder.loadTexts: bfdSessPerfTable.setDescription('This table specifies BFD Session performance counters.')
bfdSessPerfEntry = MibTableRow((1, 3, 6, 1, 2, 1, 222, 1, 3, 1), )
bfdSessEntry.registerAugmentions(("BFD-STD-MIB", "bfdSessPerfEntry"))
bfdSessPerfEntry.setIndexNames(*bfdSessEntry.getIndexNames())
if mibBuilder.loadTexts: bfdSessPerfEntry.setStatus('current')
if mibBuilder.loadTexts: bfdSessPerfEntry.setDescription('An entry in this table is created by a BFD-enabled node for every BFD Session. bfdSessPerfDiscTime is used to indicate potential discontinuity for all counter objects in this table.')
bfdSessPerfCtrlPktIn = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 3, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bfdSessPerfCtrlPktIn.setStatus('current')
if mibBuilder.loadTexts: bfdSessPerfCtrlPktIn.setDescription('The total number of BFD control messages received for this BFD session. It MUST be equal to the least significant 32 bits of bfdSessPerfCtrlPktInHC if supported, and MUST do so with the rules spelled out in RFC 2863.')
bfdSessPerfCtrlPktOut = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 3, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bfdSessPerfCtrlPktOut.setStatus('current')
if mibBuilder.loadTexts: bfdSessPerfCtrlPktOut.setDescription('The total number of BFD control messages sent for this BFD session. It MUST be equal to the least significant 32 bits of bfdSessPerfCtrlPktOutHC if supported, and MUST do so with the rules spelled out in RFC 2863.')
bfdSessPerfCtrlPktDrop = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 3, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bfdSessPerfCtrlPktDrop.setStatus('current')
if mibBuilder.loadTexts: bfdSessPerfCtrlPktDrop.setDescription('The total number of BFD control messages received for this session yet dropped for being invalid. It MUST be equal to the least significant 32 bits of bfdSessPerfCtrlPktDropHC if supported, and MUST do so with the rules spelled out in RFC 2863.')
bfdSessPerfCtrlPktDropLastTime = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 3, 1, 4), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bfdSessPerfCtrlPktDropLastTime.setStatus('current')
if mibBuilder.loadTexts: bfdSessPerfCtrlPktDropLastTime.setDescription('The value of sysUpTime on the most recent occasion at which received BFD control message for this session was dropped. If no such up event exists, this object contains a zero value.')
bfdSessPerfEchoPktIn = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 3, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bfdSessPerfEchoPktIn.setStatus('current')
if mibBuilder.loadTexts: bfdSessPerfEchoPktIn.setDescription('The total number of BFD echo messages received for this BFD session. It MUST be equal to the least significant 32 bits of bfdSessPerfEchoPktInHC if supported, and MUST do so with the rules spelled out in RFC 2863.')
bfdSessPerfEchoPktOut = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 3, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bfdSessPerfEchoPktOut.setStatus('current')
if mibBuilder.loadTexts: bfdSessPerfEchoPktOut.setDescription('The total number of BFD echo messages sent for this BFD session. It MUST be equal to the least significant 32 bits of bfdSessPerfEchoPktOutHC if supported, and MUST do so with the rules spelled out in RFC 2863.')
bfdSessPerfEchoPktDrop = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 3, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bfdSessPerfEchoPktDrop.setStatus('current')
if mibBuilder.loadTexts: bfdSessPerfEchoPktDrop.setDescription('The total number of BFD echo messages received for this session yet dropped for being invalid. It MUST be equal to the least significant 32 bits of bfdSessPerfEchoPktDropHC if supported, and MUST do so with the rules spelled out in RFC 2863.')
bfdSessPerfEchoPktDropLastTime = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 3, 1, 8), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bfdSessPerfEchoPktDropLastTime.setStatus('current')
if mibBuilder.loadTexts: bfdSessPerfEchoPktDropLastTime.setDescription('The value of sysUpTime on the most recent occasion at which received BFD echo message for this session was dropped. If no such up event has been issued, this object contains a zero value.')
bfdSessUpTime = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 3, 1, 9), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bfdSessUpTime.setStatus('current')
if mibBuilder.loadTexts: bfdSessUpTime.setDescription('The value of sysUpTime on the most recent occasion at which the session came up. If no such event has been issued, this object contains a zero value.')
bfdSessPerfLastSessDownTime = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 3, 1, 10), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bfdSessPerfLastSessDownTime.setStatus('current')
if mibBuilder.loadTexts: bfdSessPerfLastSessDownTime.setDescription('The value of sysUpTime on the most recent occasion at which the last time communication was lost with the neighbor. If no down event has been issued this object contains a zero value.')
bfdSessPerfLastCommLostDiag = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 3, 1, 11), IANAbfdDiagTC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bfdSessPerfLastCommLostDiag.setStatus('current')
if mibBuilder.loadTexts: bfdSessPerfLastCommLostDiag.setDescription('The BFD diag code for the last time communication was lost with the neighbor. If such an event has not been issued this object contains a zero value.')
bfdSessPerfSessUpCount = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 3, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bfdSessPerfSessUpCount.setStatus('current')
if mibBuilder.loadTexts: bfdSessPerfSessUpCount.setDescription('The number of times this session has gone into the Up state since the system last rebooted.')
bfdSessPerfDiscTime = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 3, 1, 13), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bfdSessPerfDiscTime.setStatus('current')
if mibBuilder.loadTexts: bfdSessPerfDiscTime.setDescription('The value of sysUpTime on the most recent occasion at which any one or more of the session counters suffered a discontinuity. The relevant counters are the specific instances associated with this BFD session of any Counter32 object contained in the BfdSessPerfTable. If no such discontinuities have occurred since the last re-initialization of the local management subsystem, then this object contains a zero value.')
bfdSessPerfCtrlPktInHC = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 3, 1, 14), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bfdSessPerfCtrlPktInHC.setStatus('current')
if mibBuilder.loadTexts: bfdSessPerfCtrlPktInHC.setDescription('This value represents the total number of BFD control messages received for this BFD session. The least significant 32 bits MUST equal to bfdSessPerfCtrlPktIn, and MUST do so with the rules spelled out in RFC 2863.')
bfdSessPerfCtrlPktOutHC = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 3, 1, 15), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bfdSessPerfCtrlPktOutHC.setStatus('current')
if mibBuilder.loadTexts: bfdSessPerfCtrlPktOutHC.setDescription('This value represents the total number of BFD control messages transmitted for this BFD session. The least significant 32 bits MUST equal to bfdSessPerfCtrlPktOut, and MUST do so with the rules spelled out in RFC 2863.')
bfdSessPerfCtrlPktDropHC = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 3, 1, 16), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bfdSessPerfCtrlPktDropHC.setStatus('current')
if mibBuilder.loadTexts: bfdSessPerfCtrlPktDropHC.setDescription('This value represents the total number of BFD control messages received for this BFD session yet dropped for being invalid. The least significant 32 bits MUST equal to bfdSessPerfCtrlPktDrop, and MUST do so with the rules spelled out in RFC 2863.')
bfdSessPerfEchoPktInHC = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 3, 1, 17), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bfdSessPerfEchoPktInHC.setStatus('current')
if mibBuilder.loadTexts: bfdSessPerfEchoPktInHC.setDescription('This value represents the total number of BFD echo messages received for this BFD session. The least significant 32 bits MUST equal to bfdSessPerfEchoPktIn, and MUST do so with the rules spelled out in RFC 2863.')
bfdSessPerfEchoPktOutHC = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 3, 1, 18), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bfdSessPerfEchoPktOutHC.setStatus('current')
if mibBuilder.loadTexts: bfdSessPerfEchoPktOutHC.setDescription('This value represents the total number of BFD echo messages transmitted for this BFD session. The least significant 32 bits MUST equal to bfdSessPerfEchoPktOut, and MUST do so with the rules spelled out in RFC 2863.')
bfdSessPerfEchoPktDropHC = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 3, 1, 19), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bfdSessPerfEchoPktDropHC.setStatus('current')
if mibBuilder.loadTexts: bfdSessPerfEchoPktDropHC.setDescription('This value represents the total number of BFD echo messages received for this BFD session yet dropped for being invalid. The least significant 32 bits MUST equal to bfdSessPerfEchoPktDrop, and MUST do so with the rules spelled out in RFC 2863.')
bfdSessDiscMapTable = MibTable((1, 3, 6, 1, 2, 1, 222, 1, 4), )
if mibBuilder.loadTexts: bfdSessDiscMapTable.setStatus('current')
if mibBuilder.loadTexts: bfdSessDiscMapTable.setDescription("The BFD Session Discriminator Mapping Table maps a local discriminator value to associated BFD session's bfdSessIndex found in the bfdSessionTable.")
bfdSessDiscMapEntry = MibTableRow((1, 3, 6, 1, 2, 1, 222, 1, 4, 1), ).setIndexNames((0, "BFD-STD-MIB", "bfdSessDiscriminator"))
if mibBuilder.loadTexts: bfdSessDiscMapEntry.setStatus('current')
if mibBuilder.loadTexts: bfdSessDiscMapEntry.setDescription('The BFD Session Discriminator Mapping Entry specifies a mapping between a local discriminator and a BFD session.')
bfdSessDiscMapIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 4, 1, 1), BfdSessIndexTC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bfdSessDiscMapIndex.setStatus('current')
if mibBuilder.loadTexts: bfdSessDiscMapIndex.setDescription('This object specifies a mapping between a local discriminator and a BFD Session in the BfdSessTable.')
bfdSessIpMapTable = MibTable((1, 3, 6, 1, 2, 1, 222, 1, 5), )
if mibBuilder.loadTexts: bfdSessIpMapTable.setStatus('current')
if mibBuilder.loadTexts: bfdSessIpMapTable.setDescription('The BFD Session IP Mapping Table maps given bfdSessInterface, bfdSessSrcAddrType, bfdSessSrcAddr, bfdSessDstAddrType and bfdSessDstAddr to an associated BFD session found in the bfdSessionTable.')
bfdSessIpMapEntry = MibTableRow((1, 3, 6, 1, 2, 1, 222, 1, 5, 1), ).setIndexNames((0, "BFD-STD-MIB", "bfdSessInterface"), (0, "BFD-STD-MIB", "bfdSessSrcAddrType"), (0, "BFD-STD-MIB", "bfdSessSrcAddr"), (0, "BFD-STD-MIB", "bfdSessDstAddrType"), (0, "BFD-STD-MIB", "bfdSessDstAddr"))
if mibBuilder.loadTexts: bfdSessIpMapEntry.setStatus('current')
if mibBuilder.loadTexts: bfdSessIpMapEntry.setDescription('The BFD Session IP Map Entry contains a mapping from the IP information for a session, to the session in the bfdSessionTable.')
bfdSessIpMapIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 5, 1, 1), BfdSessIndexTC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bfdSessIpMapIndex.setStatus('current')
if mibBuilder.loadTexts: bfdSessIpMapIndex.setDescription('This object specifies the BfdSessIndexTC referred to by the indexes of this row. In essence, a mapping is provided between these indexes and the BfdSessTable.')
bfdSessUp = NotificationType((1, 3, 6, 1, 2, 1, 222, 0, 1)).setObjects(("BFD-STD-MIB", "bfdSessDiag"), ("BFD-STD-MIB", "bfdSessDiag"))
if mibBuilder.loadTexts: bfdSessUp.setStatus('current')
if mibBuilder.loadTexts: bfdSessUp.setDescription('This notification is generated when the bfdSessState object for one or more contiguous entries in bfdSessTable are about to enter the up(4) state from some other state. The included values of bfdSessDiag MUST both be set equal to this new state (i.e: up(4)). The two instances of bfdSessDiag in this notification indicate the range of indexes that are affected. Note that all the indexes of the two ends of the range can be derived from the instance identifiers of these two objects. For the cases where a contiguous range of sessions have transitioned into the up(4) state at roughly the same time, the device SHOULD issue a single notification for each range of contiguous indexes in an effort to minimize the emission of a large number of notifications. If a notification has to be issued for just a single bfdSessEntry, then the instance identifier (and values) of the two bfdSessDiag objects MUST be the identical.')
bfdSessDown = NotificationType((1, 3, 6, 1, 2, 1, 222, 0, 2)).setObjects(("BFD-STD-MIB", "bfdSessDiag"), ("BFD-STD-MIB", "bfdSessDiag"))
if mibBuilder.loadTexts: bfdSessDown.setStatus('current')
if mibBuilder.loadTexts: bfdSessDown.setDescription('This notification is generated when the bfdSessState object for one or more contiguous entries in bfdSessTable are about to enter the down(2) or adminDown(1) states from some other state. The included values of bfdSessDiag MUST both be set equal to this new state (i.e: down(2) or adminDown(1)). The two instances of bfdSessDiag in this notification indicate the range of indexes that are affected. Note that all the indexes of the two ends of the range can be derived from the instance identifiers of these two objects. For cases where a contiguous range of sessions have transitioned into the down(2) or adminDown(1) states at roughly the same time, the device SHOULD issue a single notification for each range of contiguous indexes in an effort to minimize the emission of a large number of notifications. If a notification has to be issued for just a single bfdSessEntry, then the instance identifier (and values) of the two bfdSessDiag objects MUST be the identical.')
bfdGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 222, 2, 1))
bfdCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 222, 2, 2))
bfdModuleFullCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 222, 2, 2, 1)).setObjects(("BFD-STD-MIB", "bfdSessionGroup"), ("BFD-STD-MIB", "bfdSessionReadOnlyGroup"), ("BFD-STD-MIB", "bfdSessionPerfGroup"), ("BFD-STD-MIB", "bfdNotificationGroup"), ("BFD-STD-MIB", "bfdSessionPerfHCGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    bfdModuleFullCompliance = bfdModuleFullCompliance.setStatus('current')
if mibBuilder.loadTexts: bfdModuleFullCompliance.setDescription('Compliance statement for agents that provide full support for the BFD-MIB module. Such devices can then be monitored and also be configured using this MIB module.')
bfdModuleReadOnlyCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 222, 2, 2, 2)).setObjects(("BFD-STD-MIB", "bfdSessionGroup"), ("BFD-STD-MIB", "bfdSessionReadOnlyGroup"), ("BFD-STD-MIB", "bfdSessionPerfGroup"), ("BFD-STD-MIB", "bfdNotificationGroup"), ("BFD-STD-MIB", "bfdSessionPerfHCGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    bfdModuleReadOnlyCompliance = bfdModuleReadOnlyCompliance.setStatus('current')
if mibBuilder.loadTexts: bfdModuleReadOnlyCompliance.setDescription('Compliance requirement for implementations that only provide read-only support for BFD-MIB. Such devices can then be monitored but cannot be configured using this MIB module.')
bfdSessionGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 222, 2, 1, 1)).setObjects(("BFD-STD-MIB", "bfdAdminStatus"), ("BFD-STD-MIB", "bfdOperStatus"), ("BFD-STD-MIB", "bfdNotificationsEnable"), ("BFD-STD-MIB", "bfdSessVersionNumber"), ("BFD-STD-MIB", "bfdSessType"), ("BFD-STD-MIB", "bfdSessIndexNext"), ("BFD-STD-MIB", "bfdSessDiscriminator"), ("BFD-STD-MIB", "bfdSessDestinationUdpPort"), ("BFD-STD-MIB", "bfdSessSourceUdpPort"), ("BFD-STD-MIB", "bfdSessEchoSourceUdpPort"), ("BFD-STD-MIB", "bfdSessAdminStatus"), ("BFD-STD-MIB", "bfdSessOperStatus"), ("BFD-STD-MIB", "bfdSessOperMode"), ("BFD-STD-MIB", "bfdSessDemandModeDesiredFlag"), ("BFD-STD-MIB", "bfdSessControlPlaneIndepFlag"), ("BFD-STD-MIB", "bfdSessMultipointFlag"), ("BFD-STD-MIB", "bfdSessInterface"), ("BFD-STD-MIB", "bfdSessSrcAddrType"), ("BFD-STD-MIB", "bfdSessSrcAddr"), ("BFD-STD-MIB", "bfdSessDstAddrType"), ("BFD-STD-MIB", "bfdSessDstAddr"), ("BFD-STD-MIB", "bfdSessGTSM"), ("BFD-STD-MIB", "bfdSessGTSMTTL"), ("BFD-STD-MIB", "bfdSessDesiredMinTxInterval"), ("BFD-STD-MIB", "bfdSessReqMinRxInterval"), ("BFD-STD-MIB", "bfdSessReqMinEchoRxInterval"), ("BFD-STD-MIB", "bfdSessDetectMult"), ("BFD-STD-MIB", "bfdSessAuthPresFlag"), ("BFD-STD-MIB", "bfdSessAuthenticationType"), ("BFD-STD-MIB", "bfdSessAuthenticationKeyID"), ("BFD-STD-MIB", "bfdSessAuthenticationKey"), ("BFD-STD-MIB", "bfdSessStorageType"), ("BFD-STD-MIB", "bfdSessRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    bfdSessionGroup = bfdSessionGroup.setStatus('current')
if mibBuilder.loadTexts: bfdSessionGroup.setDescription('Collection of objects needed for BFD sessions.')
bfdSessionReadOnlyGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 222, 2, 1, 2)).setObjects(("BFD-STD-MIB", "bfdSessRemoteDiscr"), ("BFD-STD-MIB", "bfdSessState"), ("BFD-STD-MIB", "bfdSessRemoteHeardFlag"), ("BFD-STD-MIB", "bfdSessDiag"), ("BFD-STD-MIB", "bfdSessNegotiatedInterval"), ("BFD-STD-MIB", "bfdSessNegotiatedEchoInterval"), ("BFD-STD-MIB", "bfdSessNegotiatedDetectMult"), ("BFD-STD-MIB", "bfdSessDiscMapIndex"), ("BFD-STD-MIB", "bfdSessIpMapIndex"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    bfdSessionReadOnlyGroup = bfdSessionReadOnlyGroup.setStatus('current')
if mibBuilder.loadTexts: bfdSessionReadOnlyGroup.setDescription('Collection of read-only objects needed for BFD sessions.')
bfdSessionPerfGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 222, 2, 1, 3)).setObjects(("BFD-STD-MIB", "bfdSessPerfCtrlPktIn"), ("BFD-STD-MIB", "bfdSessPerfCtrlPktOut"), ("BFD-STD-MIB", "bfdSessPerfCtrlPktDrop"), ("BFD-STD-MIB", "bfdSessPerfCtrlPktDropLastTime"), ("BFD-STD-MIB", "bfdSessPerfEchoPktIn"), ("BFD-STD-MIB", "bfdSessPerfEchoPktOut"), ("BFD-STD-MIB", "bfdSessPerfEchoPktDrop"), ("BFD-STD-MIB", "bfdSessPerfEchoPktDropLastTime"), ("BFD-STD-MIB", "bfdSessUpTime"), ("BFD-STD-MIB", "bfdSessPerfLastSessDownTime"), ("BFD-STD-MIB", "bfdSessPerfLastCommLostDiag"), ("BFD-STD-MIB", "bfdSessPerfSessUpCount"), ("BFD-STD-MIB", "bfdSessPerfDiscTime"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    bfdSessionPerfGroup = bfdSessionPerfGroup.setStatus('current')
if mibBuilder.loadTexts: bfdSessionPerfGroup.setDescription('Collection of objects needed to monitor the performance of BFD sessions.')
bfdSessionPerfHCGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 222, 2, 1, 4)).setObjects(("BFD-STD-MIB", "bfdSessPerfCtrlPktInHC"), ("BFD-STD-MIB", "bfdSessPerfCtrlPktOutHC"), ("BFD-STD-MIB", "bfdSessPerfCtrlPktDropHC"), ("BFD-STD-MIB", "bfdSessPerfEchoPktInHC"), ("BFD-STD-MIB", "bfdSessPerfEchoPktOutHC"), ("BFD-STD-MIB", "bfdSessPerfEchoPktDropHC"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    bfdSessionPerfHCGroup = bfdSessionPerfHCGroup.setStatus('current')
if mibBuilder.loadTexts: bfdSessionPerfHCGroup.setDescription('Collection of objects needed to monitor the performance of BFD sessions for which the values of bfdSessPerfPktIn, bfdSessPerfPktOut wrap around too quickly.')
bfdNotificationGroup = NotificationGroup((1, 3, 6, 1, 2, 1, 222, 2, 1, 5)).setObjects(("BFD-STD-MIB", "bfdSessUp"), ("BFD-STD-MIB", "bfdSessDown"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    bfdNotificationGroup = bfdNotificationGroup.setStatus('current')
if mibBuilder.loadTexts: bfdNotificationGroup.setDescription('Set of notifications implemented in this module.')
mibBuilder.exportSymbols("BFD-STD-MIB", bfdSessDstAddr=bfdSessDstAddr, bfdSessVersionNumber=bfdSessVersionNumber, bfdSessUp=bfdSessUp, bfdSessDiscMapIndex=bfdSessDiscMapIndex, bfdSessPerfLastSessDownTime=bfdSessPerfLastSessDownTime, bfdGroups=bfdGroups, PYSNMP_MODULE_ID=bfdMIB, bfdSessSourceUdpPort=bfdSessSourceUdpPort, bfdScalarObjects=bfdScalarObjects, bfdCompliances=bfdCompliances, bfdSessSrcAddr=bfdSessSrcAddr, bfdSessPerfCtrlPktDropHC=bfdSessPerfCtrlPktDropHC, bfdSessPerfCtrlPktIn=bfdSessPerfCtrlPktIn, bfdSessEchoSourceUdpPort=bfdSessEchoSourceUdpPort, bfdSessRemoteHeardFlag=bfdSessRemoteHeardFlag, bfdSessionGroup=bfdSessionGroup, bfdSessOperStatus=bfdSessOperStatus, bfdSessDestinationUdpPort=bfdSessDestinationUdpPort, bfdSessDetectMult=bfdSessDetectMult, bfdSessStorageType=bfdSessStorageType, bfdSessReqMinEchoRxInterval=bfdSessReqMinEchoRxInterval, bfdSessDiscriminator=bfdSessDiscriminator, bfdSessControlPlaneIndepFlag=bfdSessControlPlaneIndepFlag, bfdSessMultipointFlag=bfdSessMultipointFlag, bfdSessPerfEchoPktOutHC=bfdSessPerfEchoPktOutHC, bfdSessOperMode=bfdSessOperMode, bfdSessNegotiatedInterval=bfdSessNegotiatedInterval, bfdSessPerfEntry=bfdSessPerfEntry, bfdSessPerfSessUpCount=bfdSessPerfSessUpCount, bfdSessPerfCtrlPktOutHC=bfdSessPerfCtrlPktOutHC, bfdNotificationsEnable=bfdNotificationsEnable, bfdSessSrcAddrType=bfdSessSrcAddrType, bfdSessUpTime=bfdSessUpTime, bfdSessPerfEchoPktDropHC=bfdSessPerfEchoPktDropHC, bfdSessState=bfdSessState, bfdSessIpMapTable=bfdSessIpMapTable, bfdSessAuthenticationKeyID=bfdSessAuthenticationKeyID, bfdNotificationGroup=bfdNotificationGroup, bfdSessInterface=bfdSessInterface, bfdSessGTSMTTL=bfdSessGTSMTTL, bfdSessPerfLastCommLostDiag=bfdSessPerfLastCommLostDiag, bfdSessPerfEchoPktIn=bfdSessPerfEchoPktIn, bfdSessIndexNext=bfdSessIndexNext, bfdNotifications=bfdNotifications, bfdSessDstAddrType=bfdSessDstAddrType, bfdSessDiscMapEntry=bfdSessDiscMapEntry, bfdSessIpMapIndex=bfdSessIpMapIndex, bfdSessAuthPresFlag=bfdSessAuthPresFlag, bfdSessNegotiatedEchoInterval=bfdSessNegotiatedEchoInterval, bfdSessPerfCtrlPktOut=bfdSessPerfCtrlPktOut, bfdSessAuthenticationType=bfdSessAuthenticationType, bfdSessDiag=bfdSessDiag, bfdSessGTSM=bfdSessGTSM, bfdSessTable=bfdSessTable, bfdSessPerfCtrlPktDrop=bfdSessPerfCtrlPktDrop, bfdSessionPerfHCGroup=bfdSessionPerfHCGroup, bfdSessPerfTable=bfdSessPerfTable, bfdObjects=bfdObjects, bfdModuleFullCompliance=bfdModuleFullCompliance, bfdSessDesiredMinTxInterval=bfdSessDesiredMinTxInterval, bfdSessAuthenticationKey=bfdSessAuthenticationKey, bfdSessPerfCtrlPktInHC=bfdSessPerfCtrlPktInHC, bfdSessReqMinRxInterval=bfdSessReqMinRxInterval, bfdSessIpMapEntry=bfdSessIpMapEntry, bfdModuleReadOnlyCompliance=bfdModuleReadOnlyCompliance, bfdSessIndex=bfdSessIndex, bfdSessType=bfdSessType, bfdSessionPerfGroup=bfdSessionPerfGroup, bfdSessRemoteDiscr=bfdSessRemoteDiscr, bfdSessEntry=bfdSessEntry, bfdSessPerfDiscTime=bfdSessPerfDiscTime, bfdSessPerfEchoPktInHC=bfdSessPerfEchoPktInHC, bfdConformance=bfdConformance, bfdSessPerfCtrlPktDropLastTime=bfdSessPerfCtrlPktDropLastTime, bfdSessRowStatus=bfdSessRowStatus, bfdSessAdminStatus=bfdSessAdminStatus, bfdSessPerfEchoPktOut=bfdSessPerfEchoPktOut, bfdSessDown=bfdSessDown, bfdSessPerfEchoPktDropLastTime=bfdSessPerfEchoPktDropLastTime, bfdSessionReadOnlyGroup=bfdSessionReadOnlyGroup, bfdOperStatus=bfdOperStatus, bfdSessDiscMapTable=bfdSessDiscMapTable, bfdMIB=bfdMIB, bfdAdminStatus=bfdAdminStatus, bfdSessPerfEchoPktDrop=bfdSessPerfEchoPktDrop, bfdSessDemandModeDesiredFlag=bfdSessDemandModeDesiredFlag, bfdSessNegotiatedDetectMult=bfdSessNegotiatedDetectMult)

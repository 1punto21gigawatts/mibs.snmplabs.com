#
# PySNMP MIB module CISCO-RF-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCO-RF-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:05:35 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ConstraintsIntersection, SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ConstraintsIntersection", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint")
ciscoMgmt, = mibBuilder.importSymbols("CISCO-SMI", "ciscoMgmt")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
ObjectGroup, ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "ModuleCompliance", "NotificationGroup")
sysUpTime, = mibBuilder.importSymbols("SNMPv2-MIB", "sysUpTime")
Integer32, Unsigned32, NotificationType, TimeTicks, Gauge32, IpAddress, MibIdentifier, iso, ObjectIdentity, Counter64, ModuleIdentity, Bits, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter32 = mibBuilder.importSymbols("SNMPv2-SMI", "Integer32", "Unsigned32", "NotificationType", "TimeTicks", "Gauge32", "IpAddress", "MibIdentifier", "iso", "ObjectIdentity", "Counter64", "ModuleIdentity", "Bits", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter32")
DateAndTime, TruthValue, TimeInterval, TextualConvention, TimeStamp, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "DateAndTime", "TruthValue", "TimeInterval", "TextualConvention", "TimeStamp", "DisplayString")
ciscoRFMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 9, 9, 176))
ciscoRFMIB.setRevisions(('2008-03-18 00:00', '2005-09-01 00:00', '2004-04-01 00:00', '2004-02-04 00:00', '2003-10-02 00:00', '2002-01-07 00:00', '2001-07-20 00:00', '2001-06-26 00:00', '2001-04-03 09:45',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ciscoRFMIB.setRevisionsDescriptions(('Added a new state standbyWarm. This state will be used in RPR plus mode.', 'Added a new textual convention : RFClientStatus. Added the cRFStatusRFClientTable which contains information about all the clients registered with the Redundancy Facility (RF).', 'Added the new states, systemReset, loadVersionSwitchover and runVersionSwitchover. The unset state has been removed and the init state will represent the absense of the ISSU process. Updated the object cRFStatusIssuState to cRFStatusIssuStateRev1 as the ISSU states have been revised. Added new object, cRFStatusIssuFromVersion and cRFStatusIssuToVersion which represent the from and the to versions of IOS that are involved in the upgrade process. The object ciscoRFIssuStateObjGroup was changed to ciscoRFIssuStateObjGroupRev1 to accomodate these new objects.', 'Added ciscoRFIssuStateNotifGroup and ciscoRFIssuStateObjGroup that represent the notification group and the object group that represents the ISSU state of the system.', 'Changed the description for ciscoRFProgressionNotif', 'Added the following object in cRFStatus: cRFStatusRFModeCapsTable Added the following object in cRFCfg: cRFCfgRedundancyOperMode Updated description of following object in cRFCfg: cRFCfgRedundancyMode', 'Added new sub-group cRFHistory Added new table cRFHistorySwitchOverTable which maintains the history of switchovers. Also added objects: cRFStatusFailoverTime cRFStatusPeerStandByEntryTime cRFHistoryTableMaxLength cRFHistoryColdStarts cRFHistoryStandByAvailTime Added textual convention: RFUnitIdentifier.', "Changed terminology: 'split-mode' is now 'maintenance-mode' Added textual convention: RFMode Deprecated object: cRFCfgSplitMode Added objects: cRFCfgMaintenanceMode cRFCfgRedundancyMode cRFCfgRedundancyModeDescr Added enumeration values: noAction(0) to RFAction activeExtraload(15) to RFState activeHandback(16) to RFState Added new transition state to ciscoRFProgressionNotif: activeExtraload Update compliance and conformance statements", 'The initial revision of this MIB.',))
if mibBuilder.loadTexts: ciscoRFMIB.setLastUpdated('200803180000Z')
if mibBuilder.loadTexts: ciscoRFMIB.setOrganization('Cisco Systems, Inc.')
if mibBuilder.loadTexts: ciscoRFMIB.setContactInfo('Cisco Systems Customer Service Postal: 170 West Tasman Drive San Jose, CA 95134 USA Tel: +1 800 553-NETS E-mail: cs-rf-mib@cisco.com')
if mibBuilder.loadTexts: ciscoRFMIB.setDescription('This MIB provides configuration control and status for the Redundancy Framework (RF) subsystem. RF provides a mechanism for logical redundancy of software functionality and is designed to support 1:1 redundancy on processor cards. RF is not intended to solve all redundancy schemes. Nor is RF designed to support redundant hardware, such as power supplies. Redundancy is concerned with the duplication of data elements and software functions to provide an alternative in case of failure. It is a key component to meeting 99.999% availability requirements for Class 5 carrier solutions. In the scope of this MIB definition, peer software elements are redundant and redundant software elements are peers.')
class RFState(TextualConvention, Integer32):
    description = "The current state of the RF subsystem. notKnown - state is unknown disabled - RF is not operational on this unit initialization - establish necessary system services negotiation - peer unit discovery and negotiation standbyCold - client notification on standby unit *standbyColdConfig - standby configuration is updated from active configuration *standbyColdFileSys - standby file system (FS) is updated from the active FS *standbyColdBulk - clients sync data from active to standby standbyHot - incremental client data sync continues. This unit is ready to take over activity. activeFast - call maintenance efforts during a SWACT activeDrain - client clean-up phase activePreconfig - unit is active but has not read its configuration activePostconfig - unit is active and is post-processing its configuration active - unit is active and processing calls activeExtraload - unit is active and processing calls for all feature boards in the system activeHandback - unit is active, processing calls and is in the process of handing some resources to the other unit in the system standbyWarm - unit is ready when using RPR+ mode * Sub-state of 'standbyCold'"
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17))
    namedValues = NamedValues(("notKnown", 1), ("disabled", 2), ("initialization", 3), ("negotiation", 4), ("standbyCold", 5), ("standbyColdConfig", 6), ("standbyColdFileSys", 7), ("standbyColdBulk", 8), ("standbyHot", 9), ("activeFast", 10), ("activeDrain", 11), ("activePreconfig", 12), ("activePostconfig", 13), ("active", 14), ("activeExtraload", 15), ("activeHandback", 16), ("standbyWarm", 17))

class RFMode(TextualConvention, Integer32):
    description = "The characterization of the redundancy subsystem. nonRedundant - the system is not redundant. staticLoadShareNonRedundant - the system is *not* redundant but is load sharing. The load sharing is *not* based on operational load (i.e. number of calls, etc). dynamicLoadShareNonRedundant - the system is *not* redundant but is load sharing. Load sharing is based on operational load. staticLoadShareRedundant - the system is redundant and is load sharing. The load sharing is *not* based on operational load. dynamicLoadShareRedundant - the system is redundant and is load sharing. Load sharing is based on operational load. coldStandbyRedundant - the system is redundant but the redundant peer unit is not fully initialized and is not able to retain established calls. warmStandbyRedundant - the system is redundant and the redundant peer unit is immediately able to handle new calls. The redundant unit is unable to retain established calls. hotStandbyRedundant - the system is redundant and the redundant peer unit is able to 'instantaneously' retain established calls and immediately able to handle new calls."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))
    namedValues = NamedValues(("nonRedundant", 1), ("staticLoadShareNonRedundant", 2), ("dynamicLoadShareNonRedundant", 3), ("staticLoadShareRedundant", 4), ("dynamicLoadShareRedundant", 5), ("coldStandbyRedundant", 6), ("warmStandbyRedundant", 7), ("hotStandbyRedundant", 8))

class RFAction(TextualConvention, Integer32):
    description = "Administrative commands to invoke in the RF subsystem. noAction - no action (do nothing) reloadPeer - reset the redundant peer unit reloadShelf - reset the entire shelf switchActivity - safely SWACT to peer unit and go standby forceSwitchActivity - switch activity; ignoring pre-conditions, system warnings and safety checks. When the value is set to 'noAction' no operation is performed. When read, the value 'noAction' is always returned."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))
    namedValues = NamedValues(("noAction", 0), ("reloadPeer", 1), ("reloadShelf", 2), ("switchActivity", 3), ("forceSwitchActivity", 4))

class RFSwactReasonType(TextualConvention, Integer32):
    description = "Reason codes for the switch of activity from an active redundant unit to its standby peer unit. unsupported - the 'reason code' is an unsupported feature none - no SWACT has occurred notKnown - reason is unknown userInitiated - a safe, manual SWACT was initiated by user userForced - a manual SWACT was forced by user; ignoring pre-conditions, warnings and safety checks activeUnitFailed - active unit failure caused an auto SWACT activeUnitRemoved - active unit removal caused an auto SWACT"
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))
    namedValues = NamedValues(("unsupported", 1), ("none", 2), ("notKnown", 3), ("userInitiated", 4), ("userForced", 5), ("activeUnitFailed", 6), ("activeUnitRemoved", 7))

class RFUnitIdentifier(TextualConvention, Integer32):
    description = 'A unique identifier for Active/Standby unit.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 2147483647)

class RFIssuState(TextualConvention, Integer32):
    description = 'ISSU state represents the current system state. unset - unset state; if the system is booted from tftp or from ROMMON such that the image is not the first in BOOT init - init state; the first ISSU state that the system will move to after the unset state, when the ISSU process has just been kicked off. The first CLI that is executed to make this happen is the loadversion CLI. loadVersion - Once the loadversion CLI has been executed, the state of the system is changed to reflect this, and this state is called the loadVersion state. The boot variable on the Standby is updated to point to the new image that the Standby needs to load and then it is reset. runVersion - runVersion state; When the system is in the loadversion state, the Active is running the old image and the Standby is running the new image. When the runversion CLI is executed, a switchover occurs, and the Standby running the new image takes over as the Active. The state of the system at this stage is updated to runversion. commitVersion - in the runversion state, the Active is running the new image, and the Standby is running the old image. When the user is satisfied with the functioning of the system, they execute the commitversion CLI, which will prepend the boot variable on the Standby with the new image, and then the Standby is reset. After this, the Standby comes up with the new image, and the state of the system is updated to reflect the commitVersion state.'
    status = 'deprecated'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))
    namedValues = NamedValues(("unset", 0), ("init", 1), ("loadVersion", 2), ("runVersion", 3), ("commitVersion", 4))

class RFIssuStateRev1(TextualConvention, Integer32):
    description = 'ISSU state represents the current system state. init - This state represents the initial state of the system. The ISSU process is not running at this stage. The only CLI for ISSU process that can be executed in this state is the loadversion CLI. systemReset - If a system reset occurs, or the abortversion CLI is executed, the state of the system is pushed to this state. loadVersion - When the Standby signs in after the loadversion CLI is executed, the state of the system is changed to loadVersion. loadVersionSwitchover - If a switchover occurs in the loadVersion state, by the user, or because the Active crashes, the new state of the system will be loadVersionSwitchover. It is analogous to the runVersion state, except that the runversion CLI was not executed. runVersion - When the Standby signs in after executing the runversion CLI, the state of the system is changed to runVersion. runVersionSwitchover - if a switchover occurs while the system is in the runVersion state, the new state will be called runVersionSwitchover. It is analogous to the loadVersion state. commitVersion - When the Standby signs in after the commitversion CLI is executed, the state of the system is changed to commitVersion.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 3, 4, 6, 7, 9))
    namedValues = NamedValues(("init", 0), ("systemReset", 1), ("loadVersion", 3), ("loadVersionSwitchover", 4), ("runVersion", 6), ("runVersionSwitchover", 7), ("commitVersion", 9))

class RFClientStatus(TextualConvention, Integer32):
    description = 'The status of a RF client before, during and after switchover. noStatus - No status information is available for this client. clientNotRedundant - Client is active. But there is no redundancy to this client. This could be because there is no standby or the client cannot claim that the standby client can take over without losing data or traffic during a switchover. clientRedundancyInProgress - The client is trying to sync all data to standby and achieve redundancy. clientRedundant - The client is redundant and ready for switchover. The client can safely claim that there is no data or traffic loss if there is a switchover.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("noStatus", 1), ("clientNotRedundant", 2), ("clientRedundancyInProgress", 3), ("clientRedundant", 4))

ciscoRFMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 176, 1))
cRFStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 176, 1, 1))
cRFCfg = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 176, 1, 2))
cRFHistory = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 176, 1, 3))
cRFClient = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 176, 1, 4))
cRFStatusUnitId = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 176, 1, 1, 1), RFUnitIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cRFStatusUnitId.setStatus('current')
if mibBuilder.loadTexts: cRFStatusUnitId.setDescription('A unique identifier for this redundant unit. This identifier is implementation-specific but the method for selecting the id must remain consistent throughout the redundant system. Some example identifiers include: slot id, physical or logical entity id, or a unique id assigned internally by the RF subsystem.')
cRFStatusUnitState = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 176, 1, 1, 2), RFState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cRFStatusUnitState.setStatus('current')
if mibBuilder.loadTexts: cRFStatusUnitState.setDescription('The current state of RF on this unit.')
cRFStatusPeerUnitId = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 176, 1, 1, 3), RFUnitIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cRFStatusPeerUnitId.setStatus('current')
if mibBuilder.loadTexts: cRFStatusPeerUnitId.setDescription('A unique identifier for the redundant peer unit. This identifier is implementation-specific but the method for selecting the id must remain consistent throughout the redundant system. Some example identifiers include: slot id, physical or logical entity id, or a unique id assigned internally by the RF subsystem.')
cRFStatusPeerUnitState = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 176, 1, 1, 4), RFState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cRFStatusPeerUnitState.setStatus('current')
if mibBuilder.loadTexts: cRFStatusPeerUnitState.setDescription('The current state of RF on the peer unit.')
cRFStatusPrimaryMode = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 176, 1, 1, 5), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cRFStatusPrimaryMode.setStatus('current')
if mibBuilder.loadTexts: cRFStatusPrimaryMode.setDescription("Indicates whether this is the primary redundant unit or not. If this unit is the primary unit, this object is true. If this unit is the secondary unit, this object is false. Note that the terms 'primary/secondary' are not synonymous with the terms 'active/standby'. At any given time, the primary unit may be the active unit, or the primary unit may be the standby unit. Likewise, the secondary unit, at any given time, may be the active unit, or the secondary unit may be the standby unit. The primary unit is given a higher priority or precedence over the secondary unit. In a race condition (usually at initialization time) or any situation where the redundant units are unable to successfully negotiate activity between themselves, the primary unit will always become the active unit and the secondary unit will fall back to standby. Only one redundant unit can be the primary unit at any given time. The algorithm for determining the primary unit is system dependent, such as 'the redundant unit with the lower numeric unit id is always the primary unit.'")
cRFStatusDuplexMode = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 176, 1, 1, 6), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cRFStatusDuplexMode.setStatus('current')
if mibBuilder.loadTexts: cRFStatusDuplexMode.setDescription('Indicates whether the redundant peer unit has been detected or not. If the redundant peer unit is detected, this object is true. If the redundant peer unit is not detected, this object is false.')
cRFStatusManualSwactInhibit = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 176, 1, 1, 7), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cRFStatusManualSwactInhibit.setStatus('current')
if mibBuilder.loadTexts: cRFStatusManualSwactInhibit.setDescription('Indicates whether a manual switch of activity is permitted. If a manual switch of activity is allowed, this object is false. If a manual switch of activity is not allowed, this object is true. Note that the value of this object is the inverse of the status of manual SWACTs. This object does not indicate whether a switch of activity is or has occurred. This object only indicates if the user-controllable capability is enabled or not. A switch of activity is the event in which the standby redundant unit becomes active and the previously active unit becomes standby.')
cRFStatusLastSwactReasonCode = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 176, 1, 1, 8), RFSwactReasonType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cRFStatusLastSwactReasonCode.setStatus('current')
if mibBuilder.loadTexts: cRFStatusLastSwactReasonCode.setDescription('The reason for the last switch of activity.')
cRFStatusFailoverTime = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 176, 1, 1, 9), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cRFStatusFailoverTime.setStatus('current')
if mibBuilder.loadTexts: cRFStatusFailoverTime.setDescription('The value of sysUpTime when the primary redundant unit took over as active. The value of this object will be 0 till the first switchover.')
cRFStatusPeerStandByEntryTime = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 176, 1, 1, 10), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cRFStatusPeerStandByEntryTime.setStatus('current')
if mibBuilder.loadTexts: cRFStatusPeerStandByEntryTime.setDescription('The value of sysUpTime when the peer redundant unit entered the standbyHot state. The value will be 0 on system initialization.')
cRFStatusRFModeCapsTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 176, 1, 1, 11), )
if mibBuilder.loadTexts: cRFStatusRFModeCapsTable.setStatus('current')
if mibBuilder.loadTexts: cRFStatusRFModeCapsTable.setDescription('This table containing a list of redundancy modes that can be supported on the device.')
cRFStatusRFModeCapsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 176, 1, 1, 11, 1), ).setIndexNames((0, "CISCO-RF-MIB", "cRFStatusRFModeCapsMode"))
if mibBuilder.loadTexts: cRFStatusRFModeCapsEntry.setStatus('current')
if mibBuilder.loadTexts: cRFStatusRFModeCapsEntry.setDescription('An entry containing the device implementation specific terminology associated with the redundancy mode that can be supported on the device.')
cRFStatusRFModeCapsMode = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 176, 1, 1, 11, 1, 1), RFMode())
if mibBuilder.loadTexts: cRFStatusRFModeCapsMode.setStatus('current')
if mibBuilder.loadTexts: cRFStatusRFModeCapsMode.setDescription('The redundancy mode that can be supported on the device.')
cRFStatusRFModeCapsModeDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 176, 1, 1, 11, 1, 2), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cRFStatusRFModeCapsModeDescr.setStatus('current')
if mibBuilder.loadTexts: cRFStatusRFModeCapsModeDescr.setDescription('The description of the device implementation specific terminology associated with its supported redundancy mode.')
cRFStatusIssuState = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 176, 1, 1, 12), RFIssuState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cRFStatusIssuState.setStatus('deprecated')
if mibBuilder.loadTexts: cRFStatusIssuState.setDescription('The current ISSU state of the system.')
cRFStatusIssuStateRev1 = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 176, 1, 1, 13), RFIssuStateRev1()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cRFStatusIssuStateRev1.setStatus('current')
if mibBuilder.loadTexts: cRFStatusIssuStateRev1.setDescription('The current ISSU state of the system.')
cRFStatusIssuFromVersion = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 176, 1, 1, 14), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cRFStatusIssuFromVersion.setStatus('current')
if mibBuilder.loadTexts: cRFStatusIssuFromVersion.setDescription('The IOS version from with the user is upgrading')
cRFStatusIssuToVersion = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 176, 1, 1, 15), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cRFStatusIssuToVersion.setStatus('current')
if mibBuilder.loadTexts: cRFStatusIssuToVersion.setDescription('The IOS version to with the user is upgrading')
cRFStatusRFClientTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 176, 1, 4, 1), )
if mibBuilder.loadTexts: cRFStatusRFClientTable.setStatus('current')
if mibBuilder.loadTexts: cRFStatusRFClientTable.setDescription('This table contains a list of RF clients that are registered on the device. RF clients are applications that have registered with the Redundancy Facility (RF) to receive RF events and notifications. The purpose of RF clients is to synchronize any relevant data with the standby unit.')
cRFStatusRFClientEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 176, 1, 4, 1, 1), ).setIndexNames((0, "CISCO-RF-MIB", "cRFStatusRFClientID"))
if mibBuilder.loadTexts: cRFStatusRFClientEntry.setStatus('current')
if mibBuilder.loadTexts: cRFStatusRFClientEntry.setDescription('An entry containing information on various clients registered with the Redundancy Facility (RF). Entries in this table are always created by the system. An entry is created in this table when a redundancy aware application registers with the Redundancy Facility. The entry is destroyed when that application deregisters from the Redundancy Facility.')
cRFStatusRFClientID = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 176, 1, 4, 1, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: cRFStatusRFClientID.setStatus('current')
if mibBuilder.loadTexts: cRFStatusRFClientID.setDescription('A unique identifier for the client which registered with the Redundancy Facility.')
cRFStatusRFClientDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 176, 1, 4, 1, 1, 2), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cRFStatusRFClientDescr.setStatus('current')
if mibBuilder.loadTexts: cRFStatusRFClientDescr.setDescription('The description of the client which has registered with the Redundancy Facility.')
cRFStatusRFClientSeq = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 176, 1, 4, 1, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cRFStatusRFClientSeq.setStatus('current')
if mibBuilder.loadTexts: cRFStatusRFClientSeq.setDescription('The sequence number of the client. The system assigns the sequence numbers based on the order of registration of the Redundancy Facility clients. This is used for deciding order of RF events sent to clients.')
cRFStatusRFClientRedTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 176, 1, 4, 1, 1, 4), Unsigned32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: cRFStatusRFClientRedTime.setStatus('current')
if mibBuilder.loadTexts: cRFStatusRFClientRedTime.setDescription("Time taken for this client to become Redundant. This value is meaningful when the value of cRFStatusRFClientStatus is not 'noStatus'.")
cRFStatusRFClientStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 176, 1, 4, 1, 1, 5), RFClientStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cRFStatusRFClientStatus.setStatus('current')
if mibBuilder.loadTexts: cRFStatusRFClientStatus.setDescription('This object provides the status of the Redundancy Facility client.')
cRFCfgSplitMode = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 176, 1, 2, 1), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cRFCfgSplitMode.setStatus('deprecated')
if mibBuilder.loadTexts: cRFCfgSplitMode.setDescription('Indicates whether redundant units may communicate synchronization messages with each other. If communication is not permitted, this object is set to true. If communication is permitted, this object is set to false. In split mode (true), the active unit will not communicate with the standby unit. The standby unit progression will not occur. When split mode is disabled (false), the standby unit is reset to recover. Split mode (true) is useful for maintenance operations.')
cRFCfgKeepaliveThresh = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 176, 1, 2, 2), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cRFCfgKeepaliveThresh.setStatus('current')
if mibBuilder.loadTexts: cRFCfgKeepaliveThresh.setDescription('On platforms that support keep-alives, the keep-alive threshold value designates the number of lost keep-alives tolerated before a failure condition is declared. If this occurs, a SWACT notification is sent. On platforms that do not support keep-alives, this object has no purpose or effect.')
cRFCfgKeepaliveThreshMin = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 176, 1, 2, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cRFCfgKeepaliveThreshMin.setStatus('current')
if mibBuilder.loadTexts: cRFCfgKeepaliveThreshMin.setDescription('The minimum acceptable value for the cRFCfgKeepaliveThresh object.')
cRFCfgKeepaliveThreshMax = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 176, 1, 2, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cRFCfgKeepaliveThreshMax.setStatus('current')
if mibBuilder.loadTexts: cRFCfgKeepaliveThreshMax.setDescription('The maximum acceptable value for the cRFCfgKeepaliveThresh object.')
cRFCfgKeepaliveTimer = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 176, 1, 2, 5), Unsigned32()).setUnits('milliseconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cRFCfgKeepaliveTimer.setStatus('current')
if mibBuilder.loadTexts: cRFCfgKeepaliveTimer.setDescription('On platforms that support keep-alives, the keep-alive timer value is used to guard against lost keep-alives. The RF subsystem expects to receive a keep-alive within this period. If a keep-alive is not received within this time period, a SWACT notification is sent. On platforms that do not support keep-alives, this object has no purpose or effect.')
cRFCfgKeepaliveTimerMin = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 176, 1, 2, 6), Unsigned32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: cRFCfgKeepaliveTimerMin.setStatus('current')
if mibBuilder.loadTexts: cRFCfgKeepaliveTimerMin.setDescription('The minimum acceptable value for the cRFCfgKeepaliveTimer object.')
cRFCfgKeepaliveTimerMax = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 176, 1, 2, 7), Unsigned32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: cRFCfgKeepaliveTimerMax.setStatus('current')
if mibBuilder.loadTexts: cRFCfgKeepaliveTimerMax.setDescription('The maximum acceptable value for the cRFCfgKeepaliveTimer object.')
cRFCfgNotifTimer = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 176, 1, 2, 8), Unsigned32()).setUnits('milliseconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cRFCfgNotifTimer.setStatus('current')
if mibBuilder.loadTexts: cRFCfgNotifTimer.setDescription("Note that the term 'notification' here refers to an RF notification and not an SNMP notification. As the standby unit progresses to the 'standbyHot' state, asynchronous messages are sent from the active unit to the standby unit which must then be acknowledged by the standby unit. If the active unit receives the acknowledgement during the time period specified by this object, progression proceeds as normal. If the timer expires and an acknowledgement was not received by the active unit, a switch of activity occurs.")
cRFCfgNotifTimerMin = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 176, 1, 2, 9), Unsigned32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: cRFCfgNotifTimerMin.setStatus('current')
if mibBuilder.loadTexts: cRFCfgNotifTimerMin.setDescription('The minimum acceptable value for the cRFCfgNotifTimer object.')
cRFCfgNotifTimerMax = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 176, 1, 2, 10), Unsigned32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: cRFCfgNotifTimerMax.setStatus('current')
if mibBuilder.loadTexts: cRFCfgNotifTimerMax.setDescription('The maximum acceptable value for the cRFCfgNotifTimer object.')
cRFCfgAdminAction = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 176, 1, 2, 11), RFAction()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cRFCfgAdminAction.setStatus('current')
if mibBuilder.loadTexts: cRFCfgAdminAction.setDescription('This variable is set to invoke RF subsystem action commands. The commands are useful for maintenance and software upgrade activities.')
cRFCfgNotifsEnabled = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 176, 1, 2, 12), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cRFCfgNotifsEnabled.setStatus('current')
if mibBuilder.loadTexts: cRFCfgNotifsEnabled.setDescription('Allows enabling/disabling of RF subsystem notifications.')
cRFCfgMaintenanceMode = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 176, 1, 2, 13), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cRFCfgMaintenanceMode.setStatus('current')
if mibBuilder.loadTexts: cRFCfgMaintenanceMode.setDescription("Indicates whether redundant units may communicate synchronization messages with each other. If communication is not permitted, this object is set to 'true'. If communication is permitted, this object is set to 'false'. If the value of this object is 'true', the redundant system is considered to be in a maintenance mode of operation. If the value of this object is 'false', the redundant system is considered to be in a normal (non-maintenance) mode of operation. In maintenance mode (true), the active unit will not communicate with the standby unit. The standby unit progression will not occur. When maintenance mode is disabled (false), the standby unit is reset to recover. Maintenance mode (true) is useful for maintenance-type operations.")
cRFCfgRedundancyMode = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 176, 1, 2, 14), RFMode()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cRFCfgRedundancyMode.setStatus('current')
if mibBuilder.loadTexts: cRFCfgRedundancyMode.setDescription('Indicates the redundancy mode configured on the device.')
cRFCfgRedundancyModeDescr = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 176, 1, 2, 15), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cRFCfgRedundancyModeDescr.setStatus('current')
if mibBuilder.loadTexts: cRFCfgRedundancyModeDescr.setDescription('Further clarifies or describes the redundancy mode indicated by cRFCfgRedundancyMode. Implementation-specific terminology associated with the current redundancy mode may be presented here.')
cRFCfgRedundancyOperMode = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 176, 1, 2, 16), RFMode()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cRFCfgRedundancyOperMode.setStatus('current')
if mibBuilder.loadTexts: cRFCfgRedundancyOperMode.setDescription('Indicate the operational redundancy mode of the device.')
cRFHistoryTableMaxLength = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 176, 1, 3, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 50)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cRFHistoryTableMaxLength.setStatus('current')
if mibBuilder.loadTexts: cRFHistoryTableMaxLength.setDescription('Maximum number of entries permissible in the history table. A value of 0 will result in no history being maintained.')
cRFHistorySwitchOverTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 176, 1, 3, 2), )
if mibBuilder.loadTexts: cRFHistorySwitchOverTable.setStatus('current')
if mibBuilder.loadTexts: cRFHistorySwitchOverTable.setDescription('A table that tracks the history of all switchovers that have occurred since system initialization. The maximum number of entries permissible in this table is defined by cRFHistoryTableMaxLength. When the number of entries in the table reaches the maximum limit, the next entry would replace the oldest existing entry in the table.')
cRFHistorySwitchOverEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 176, 1, 3, 2, 1), ).setIndexNames((0, "CISCO-RF-MIB", "cRFHistorySwitchOverIndex"))
if mibBuilder.loadTexts: cRFHistorySwitchOverEntry.setStatus('current')
if mibBuilder.loadTexts: cRFHistorySwitchOverEntry.setDescription('The entries in this table contain the switchover information. Each entry in the table is indexed by cRFHistorySwitchOverIndex. The index wraps around to 1 after reaching the maximum value.')
cRFHistorySwitchOverIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 176, 1, 3, 2, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: cRFHistorySwitchOverIndex.setStatus('current')
if mibBuilder.loadTexts: cRFHistorySwitchOverIndex.setDescription('A monotonically increasing integer for the purpose of indexing history table. After reaching maximum value, it wraps around to 1.')
cRFHistoryPrevActiveUnitId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 176, 1, 3, 2, 1, 2), RFUnitIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cRFHistoryPrevActiveUnitId.setStatus('current')
if mibBuilder.loadTexts: cRFHistoryPrevActiveUnitId.setDescription('Indicates the primary redundant unit that went down.')
cRFHistoryCurrActiveUnitId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 176, 1, 3, 2, 1, 3), RFUnitIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cRFHistoryCurrActiveUnitId.setStatus('current')
if mibBuilder.loadTexts: cRFHistoryCurrActiveUnitId.setDescription('Indicates the secondary redundant unit that took over as active.')
cRFHistorySwitchOverReason = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 176, 1, 3, 2, 1, 4), RFSwactReasonType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cRFHistorySwitchOverReason.setStatus('current')
if mibBuilder.loadTexts: cRFHistorySwitchOverReason.setDescription('Indicates the reason for the switchover.')
cRFHistorySwactTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 176, 1, 3, 2, 1, 5), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cRFHistorySwactTime.setStatus('current')
if mibBuilder.loadTexts: cRFHistorySwactTime.setDescription('Indicates the Date & Time when switchover occurred.')
cRFHistoryColdStarts = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 176, 1, 3, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cRFHistoryColdStarts.setStatus('current')
if mibBuilder.loadTexts: cRFHistoryColdStarts.setDescription('Indicates the number of system cold starts. This includes the number of system cold starts due to switchover failure and the number of manual restarts.')
cRFHistoryStandByAvailTime = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 176, 1, 3, 4), TimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cRFHistoryStandByAvailTime.setStatus('current')
if mibBuilder.loadTexts: cRFHistoryStandByAvailTime.setDescription('Indicates the cumulative time that a standby redundant unit has been available since last system initialization.')
ciscoRFMIBNotificationsPrefix = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 176, 2))
ciscoRFMIBNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 176, 2, 0))
ciscoRFSwactNotif = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 176, 2, 0, 1)).setObjects(("CISCO-RF-MIB", "cRFStatusUnitId"), ("SNMPv2-MIB", "sysUpTime"), ("CISCO-RF-MIB", "cRFStatusLastSwactReasonCode"))
if mibBuilder.loadTexts: ciscoRFSwactNotif.setStatus('current')
if mibBuilder.loadTexts: ciscoRFSwactNotif.setDescription('A SWACT notification is sent by the newly active redundant unit whenever a switch of activity occurs. In the case where a SWACT event may be indistinguishable from a reset event, a network management station should use this notification to differentiate the activity. sysUpTime is the same sysUpTime defined in the RFC-1213 MIB.')
ciscoRFProgressionNotif = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 176, 2, 0, 2)).setObjects(("CISCO-RF-MIB", "cRFStatusUnitId"), ("CISCO-RF-MIB", "cRFStatusUnitState"), ("CISCO-RF-MIB", "cRFStatusPeerUnitId"), ("CISCO-RF-MIB", "cRFStatusPeerUnitState"))
if mibBuilder.loadTexts: ciscoRFProgressionNotif.setStatus('current')
if mibBuilder.loadTexts: ciscoRFProgressionNotif.setDescription('A progression notification is sent by the active redundant unit whenever its RF state changes or the RF state of the peer unit changes. To avoid a flurry of notifications for all state transitions, notifications will only be sent for transitions to the following RF states: disabled (for the peer state) standbyCold standbyHot active activeExtraload')
ciscoRFIssuStateNotif = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 176, 2, 0, 3)).setObjects(("CISCO-RF-MIB", "cRFStatusUnitId"), ("CISCO-RF-MIB", "cRFStatusUnitState"), ("CISCO-RF-MIB", "cRFStatusIssuState"))
if mibBuilder.loadTexts: ciscoRFIssuStateNotif.setStatus('deprecated')
if mibBuilder.loadTexts: ciscoRFIssuStateNotif.setDescription('An ISSU notification to indicate the new state of the system.')
ciscoRFIssuStateNotifRev1 = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 176, 2, 0, 4)).setObjects(("CISCO-RF-MIB", "cRFStatusIssuStateRev1"), ("CISCO-RF-MIB", "cRFStatusIssuFromVersion"), ("CISCO-RF-MIB", "cRFStatusIssuToVersion"), ("CISCO-RF-MIB", "cRFStatusLastSwactReasonCode"))
if mibBuilder.loadTexts: ciscoRFIssuStateNotifRev1.setStatus('current')
if mibBuilder.loadTexts: ciscoRFIssuStateNotifRev1.setDescription('An ISSU notification to indicate the new state of the system.')
ciscoRFMIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 176, 3))
ciscoRFMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 176, 3, 1))
ciscoRFMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 176, 3, 2))
ciscoRFMIBCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 176, 3, 1, 1)).setObjects(("CISCO-RF-MIB", "ciscoRFStatusGroup"), ("CISCO-RF-MIB", "ciscoRFConfigGroup"), ("CISCO-RF-MIB", "ciscoRFNotifGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoRFMIBCompliance = ciscoRFMIBCompliance.setStatus('deprecated')
if mibBuilder.loadTexts: ciscoRFMIBCompliance.setDescription('The compliance statement for entities which implement the Cisco RF MIB.')
ciscoRFMIBComplianceRev1 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 176, 3, 1, 2)).setObjects(("CISCO-RF-MIB", "ciscoRFStatusGroup"), ("CISCO-RF-MIB", "ciscoRFConfigGroupRev1"), ("CISCO-RF-MIB", "ciscoRFNotifGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoRFMIBComplianceRev1 = ciscoRFMIBComplianceRev1.setStatus('deprecated')
if mibBuilder.loadTexts: ciscoRFMIBComplianceRev1.setDescription('The compliance statement for entities which implement the Cisco RF MIB')
ciscoRFMIBComplianceRev2 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 176, 3, 1, 3)).setObjects(("CISCO-RF-MIB", "ciscoRFStatusGroupRev1"), ("CISCO-RF-MIB", "ciscoRFConfigGroupRev1"), ("CISCO-RF-MIB", "ciscoRFNotifGroup"), ("CISCO-RF-MIB", "ciscoRFHistoryGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoRFMIBComplianceRev2 = ciscoRFMIBComplianceRev2.setStatus('deprecated')
if mibBuilder.loadTexts: ciscoRFMIBComplianceRev2.setDescription('The compliance statement for entities which implement the Cisco RF MIB.')
ciscoRFMIBComplianceRev3 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 176, 3, 1, 4)).setObjects(("CISCO-RF-MIB", "ciscoRFStatusGroupRev1"), ("CISCO-RF-MIB", "ciscoRFConfigGroupRev1"), ("CISCO-RF-MIB", "ciscoRFNotifGroup"), ("CISCO-RF-MIB", "ciscoRFHistoryGroup"), ("CISCO-RF-MIB", "ciscoRFConfigRFOperModeGroup"), ("CISCO-RF-MIB", "ciscoRFStatusRFModeCapsGroup"), ("CISCO-RF-MIB", "ciscoRFIssuStateNotifGroup"), ("CISCO-RF-MIB", "ciscoRFIssuStateObjGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoRFMIBComplianceRev3 = ciscoRFMIBComplianceRev3.setStatus('deprecated')
if mibBuilder.loadTexts: ciscoRFMIBComplianceRev3.setDescription('The compliance statement for entities which implement the Cisco RF MIB.')
ciscoRFMIBComplianceRev4 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 176, 3, 1, 5)).setObjects(("CISCO-RF-MIB", "ciscoRFStatusGroupRev1"), ("CISCO-RF-MIB", "ciscoRFConfigGroupRev1"), ("CISCO-RF-MIB", "ciscoRFNotifGroup"), ("CISCO-RF-MIB", "ciscoRFHistoryGroup"), ("CISCO-RF-MIB", "ciscoRFConfigRFOperModeGroup"), ("CISCO-RF-MIB", "ciscoRFStatusRFModeCapsGroup"), ("CISCO-RF-MIB", "ciscoRFIssuStateNotifGroupRev1"), ("CISCO-RF-MIB", "ciscoRFIssuStateObjGroupRev1"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoRFMIBComplianceRev4 = ciscoRFMIBComplianceRev4.setStatus('deprecated')
if mibBuilder.loadTexts: ciscoRFMIBComplianceRev4.setDescription('The compliance statement for entities which implement the Cisco RF MIB.')
ciscoRFMIBComplianceRev5 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 176, 3, 1, 6)).setObjects(("CISCO-RF-MIB", "ciscoRFStatusGroupRev1"), ("CISCO-RF-MIB", "ciscoRFConfigGroupRev1"), ("CISCO-RF-MIB", "ciscoRFNotifGroup"), ("CISCO-RF-MIB", "ciscoRFHistoryGroup"), ("CISCO-RF-MIB", "ciscoRFConfigRFOperModeGroup"), ("CISCO-RF-MIB", "ciscoRFStatusRFModeCapsGroup"), ("CISCO-RF-MIB", "ciscoRFIssuStateNotifGroupRev1"), ("CISCO-RF-MIB", "ciscoRFIssuStateObjGroupRev1"), ("CISCO-RF-MIB", "ciscoRFStatusClientGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoRFMIBComplianceRev5 = ciscoRFMIBComplianceRev5.setStatus('current')
if mibBuilder.loadTexts: ciscoRFMIBComplianceRev5.setDescription('The compliance statement for entities which implement the Cisco RF MIB.')
ciscoRFStatusGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 176, 3, 2, 1)).setObjects(("CISCO-RF-MIB", "cRFStatusUnitId"), ("CISCO-RF-MIB", "cRFStatusUnitState"), ("CISCO-RF-MIB", "cRFStatusPeerUnitId"), ("CISCO-RF-MIB", "cRFStatusPeerUnitState"), ("CISCO-RF-MIB", "cRFStatusPrimaryMode"), ("CISCO-RF-MIB", "cRFStatusDuplexMode"), ("CISCO-RF-MIB", "cRFStatusManualSwactInhibit"), ("CISCO-RF-MIB", "cRFStatusLastSwactReasonCode"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoRFStatusGroup = ciscoRFStatusGroup.setStatus('deprecated')
if mibBuilder.loadTexts: ciscoRFStatusGroup.setDescription('The collection of global RF status objects.')
ciscoRFConfigGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 176, 3, 2, 2)).setObjects(("CISCO-RF-MIB", "cRFCfgSplitMode"), ("CISCO-RF-MIB", "cRFCfgKeepaliveThresh"), ("CISCO-RF-MIB", "cRFCfgKeepaliveThreshMin"), ("CISCO-RF-MIB", "cRFCfgKeepaliveThreshMax"), ("CISCO-RF-MIB", "cRFCfgKeepaliveTimer"), ("CISCO-RF-MIB", "cRFCfgKeepaliveTimerMin"), ("CISCO-RF-MIB", "cRFCfgKeepaliveTimerMax"), ("CISCO-RF-MIB", "cRFCfgNotifTimer"), ("CISCO-RF-MIB", "cRFCfgNotifTimerMin"), ("CISCO-RF-MIB", "cRFCfgNotifTimerMax"), ("CISCO-RF-MIB", "cRFCfgAdminAction"), ("CISCO-RF-MIB", "cRFCfgNotifsEnabled"), ("CISCO-RF-MIB", "cRFCfgRedundancyMode"), ("CISCO-RF-MIB", "cRFCfgRedundancyModeDescr"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoRFConfigGroup = ciscoRFConfigGroup.setStatus('deprecated')
if mibBuilder.loadTexts: ciscoRFConfigGroup.setDescription('The collection of RF configuration objects.')
ciscoRFNotifGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 9, 9, 176, 3, 2, 3)).setObjects(("CISCO-RF-MIB", "ciscoRFSwactNotif"), ("CISCO-RF-MIB", "ciscoRFProgressionNotif"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoRFNotifGroup = ciscoRFNotifGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoRFNotifGroup.setDescription('The collection of notifications used to indicate RF state information.')
ciscoRFConfigGroupRev1 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 176, 3, 2, 4)).setObjects(("CISCO-RF-MIB", "cRFCfgKeepaliveThresh"), ("CISCO-RF-MIB", "cRFCfgKeepaliveThreshMin"), ("CISCO-RF-MIB", "cRFCfgKeepaliveThreshMax"), ("CISCO-RF-MIB", "cRFCfgKeepaliveTimer"), ("CISCO-RF-MIB", "cRFCfgKeepaliveTimerMin"), ("CISCO-RF-MIB", "cRFCfgKeepaliveTimerMax"), ("CISCO-RF-MIB", "cRFCfgNotifTimer"), ("CISCO-RF-MIB", "cRFCfgNotifTimerMin"), ("CISCO-RF-MIB", "cRFCfgNotifTimerMax"), ("CISCO-RF-MIB", "cRFCfgAdminAction"), ("CISCO-RF-MIB", "cRFCfgNotifsEnabled"), ("CISCO-RF-MIB", "cRFCfgMaintenanceMode"), ("CISCO-RF-MIB", "cRFCfgRedundancyMode"), ("CISCO-RF-MIB", "cRFCfgRedundancyModeDescr"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoRFConfigGroupRev1 = ciscoRFConfigGroupRev1.setStatus('current')
if mibBuilder.loadTexts: ciscoRFConfigGroupRev1.setDescription('The collection of RF configuration objects.')
ciscoRFStatusGroupRev1 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 176, 3, 2, 5)).setObjects(("CISCO-RF-MIB", "cRFStatusUnitId"), ("CISCO-RF-MIB", "cRFStatusUnitState"), ("CISCO-RF-MIB", "cRFStatusPeerUnitId"), ("CISCO-RF-MIB", "cRFStatusPeerUnitState"), ("CISCO-RF-MIB", "cRFStatusPrimaryMode"), ("CISCO-RF-MIB", "cRFStatusDuplexMode"), ("CISCO-RF-MIB", "cRFStatusManualSwactInhibit"), ("CISCO-RF-MIB", "cRFStatusLastSwactReasonCode"), ("CISCO-RF-MIB", "cRFStatusFailoverTime"), ("CISCO-RF-MIB", "cRFStatusPeerStandByEntryTime"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoRFStatusGroupRev1 = ciscoRFStatusGroupRev1.setStatus('current')
if mibBuilder.loadTexts: ciscoRFStatusGroupRev1.setDescription('The collection of global RF Status objects.')
ciscoRFHistoryGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 176, 3, 2, 6)).setObjects(("CISCO-RF-MIB", "cRFHistoryPrevActiveUnitId"), ("CISCO-RF-MIB", "cRFHistoryCurrActiveUnitId"), ("CISCO-RF-MIB", "cRFHistorySwitchOverReason"), ("CISCO-RF-MIB", "cRFHistorySwactTime"), ("CISCO-RF-MIB", "cRFHistoryColdStarts"), ("CISCO-RF-MIB", "cRFHistoryStandByAvailTime"), ("CISCO-RF-MIB", "cRFHistoryTableMaxLength"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoRFHistoryGroup = ciscoRFHistoryGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoRFHistoryGroup.setDescription('The collection of RF History objects.')
ciscoRFConfigRFOperModeGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 176, 3, 2, 7)).setObjects(("CISCO-RF-MIB", "cRFCfgRedundancyOperMode"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoRFConfigRFOperModeGroup = ciscoRFConfigRFOperModeGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoRFConfigRFOperModeGroup.setDescription('An optional group with a collection of objects providing the information of the operational redundancy mode on the device.')
ciscoRFStatusRFModeCapsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 176, 3, 2, 8)).setObjects(("CISCO-RF-MIB", "cRFStatusRFModeCapsModeDescr"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoRFStatusRFModeCapsGroup = ciscoRFStatusRFModeCapsGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoRFStatusRFModeCapsGroup.setDescription('An optional group with a collection of objects providing the information of redundancy mode capability on the device.')
ciscoRFIssuStateNotifGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 9, 9, 176, 3, 2, 9)).setObjects(("CISCO-RF-MIB", "ciscoRFIssuStateNotif"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoRFIssuStateNotifGroup = ciscoRFIssuStateNotifGroup.setStatus('deprecated')
if mibBuilder.loadTexts: ciscoRFIssuStateNotifGroup.setDescription('The collection of notifications used to indicate ISSU state of the system.')
ciscoRFIssuStateNotifGroupRev1 = NotificationGroup((1, 3, 6, 1, 4, 1, 9, 9, 176, 3, 2, 10)).setObjects(("CISCO-RF-MIB", "ciscoRFIssuStateNotifRev1"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoRFIssuStateNotifGroupRev1 = ciscoRFIssuStateNotifGroupRev1.setStatus('current')
if mibBuilder.loadTexts: ciscoRFIssuStateNotifGroupRev1.setDescription('The collection of notifications used to indicate ISSU state of the system.')
ciscoRFIssuStateObjGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 176, 3, 2, 11)).setObjects(("CISCO-RF-MIB", "cRFStatusIssuState"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoRFIssuStateObjGroup = ciscoRFIssuStateObjGroup.setStatus('deprecated')
if mibBuilder.loadTexts: ciscoRFIssuStateObjGroup.setDescription('An optional group with a collection of objects providing the information on the current ISSU state of the system.')
ciscoRFIssuStateObjGroupRev1 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 176, 3, 2, 12)).setObjects(("CISCO-RF-MIB", "cRFStatusIssuStateRev1"), ("CISCO-RF-MIB", "cRFStatusIssuFromVersion"), ("CISCO-RF-MIB", "cRFStatusIssuToVersion"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoRFIssuStateObjGroupRev1 = ciscoRFIssuStateObjGroupRev1.setStatus('current')
if mibBuilder.loadTexts: ciscoRFIssuStateObjGroupRev1.setDescription('An optional group with a collection of objects providing the information on the current ISSU state of the system.')
ciscoRFStatusClientGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 176, 3, 2, 13)).setObjects(("CISCO-RF-MIB", "cRFStatusRFClientDescr"), ("CISCO-RF-MIB", "cRFStatusRFClientSeq"), ("CISCO-RF-MIB", "cRFStatusRFClientRedTime"), ("CISCO-RF-MIB", "cRFStatusRFClientStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoRFStatusClientGroup = ciscoRFStatusClientGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoRFStatusClientGroup.setDescription('A group of objects providing information regarding the various clients registered with the RF.')
mibBuilder.exportSymbols("CISCO-RF-MIB", RFAction=RFAction, ciscoRFConfigGroup=ciscoRFConfigGroup, cRFCfgRedundancyMode=cRFCfgRedundancyMode, cRFStatusRFClientEntry=cRFStatusRFClientEntry, ciscoRFConfigGroupRev1=ciscoRFConfigGroupRev1, cRFStatusIssuStateRev1=cRFStatusIssuStateRev1, cRFStatusRFClientID=cRFStatusRFClientID, cRFHistorySwitchOverEntry=cRFHistorySwitchOverEntry, cRFCfgKeepaliveTimerMin=cRFCfgKeepaliveTimerMin, RFClientStatus=RFClientStatus, ciscoRFMIBComplianceRev5=ciscoRFMIBComplianceRev5, ciscoRFMIBComplianceRev3=ciscoRFMIBComplianceRev3, ciscoRFProgressionNotif=ciscoRFProgressionNotif, cRFStatusRFModeCapsEntry=cRFStatusRFModeCapsEntry, ciscoRFStatusRFModeCapsGroup=ciscoRFStatusRFModeCapsGroup, cRFStatusFailoverTime=cRFStatusFailoverTime, cRFStatusRFClientDescr=cRFStatusRFClientDescr, RFUnitIdentifier=RFUnitIdentifier, cRFCfgKeepaliveThreshMin=cRFCfgKeepaliveThreshMin, ciscoRFMIBComplianceRev1=ciscoRFMIBComplianceRev1, cRFStatusRFModeCapsTable=cRFStatusRFModeCapsTable, ciscoRFMIBGroups=ciscoRFMIBGroups, cRFCfgMaintenanceMode=cRFCfgMaintenanceMode, RFIssuStateRev1=RFIssuStateRev1, cRFStatusPeerStandByEntryTime=cRFStatusPeerStandByEntryTime, cRFStatusLastSwactReasonCode=cRFStatusLastSwactReasonCode, cRFCfgNotifTimer=cRFCfgNotifTimer, ciscoRFConfigRFOperModeGroup=ciscoRFConfigRFOperModeGroup, cRFHistory=cRFHistory, RFSwactReasonType=RFSwactReasonType, ciscoRFMIBCompliances=ciscoRFMIBCompliances, cRFStatusUnitId=cRFStatusUnitId, cRFStatusRFModeCapsModeDescr=cRFStatusRFModeCapsModeDescr, cRFHistorySwitchOverIndex=cRFHistorySwitchOverIndex, cRFStatusIssuToVersion=cRFStatusIssuToVersion, cRFCfgKeepaliveTimerMax=cRFCfgKeepaliveTimerMax, ciscoRFMIBConformance=ciscoRFMIBConformance, RFMode=RFMode, cRFHistoryCurrActiveUnitId=cRFHistoryCurrActiveUnitId, cRFStatusPrimaryMode=cRFStatusPrimaryMode, cRFStatusRFModeCapsMode=cRFStatusRFModeCapsMode, cRFHistoryColdStarts=cRFHistoryColdStarts, cRFCfgRedundancyModeDescr=cRFCfgRedundancyModeDescr, cRFCfgNotifsEnabled=cRFCfgNotifsEnabled, cRFCfgSplitMode=cRFCfgSplitMode, cRFHistoryPrevActiveUnitId=cRFHistoryPrevActiveUnitId, ciscoRFMIBComplianceRev4=ciscoRFMIBComplianceRev4, cRFStatusRFClientRedTime=cRFStatusRFClientRedTime, cRFCfgKeepaliveThresh=cRFCfgKeepaliveThresh, cRFHistorySwitchOverTable=cRFHistorySwitchOverTable, ciscoRFNotifGroup=ciscoRFNotifGroup, ciscoRFSwactNotif=ciscoRFSwactNotif, ciscoRFMIBNotificationsPrefix=ciscoRFMIBNotificationsPrefix, cRFCfgAdminAction=cRFCfgAdminAction, ciscoRFMIB=ciscoRFMIB, RFState=RFState, ciscoRFIssuStateNotifRev1=ciscoRFIssuStateNotifRev1, ciscoRFIssuStateNotifGroup=ciscoRFIssuStateNotifGroup, ciscoRFStatusGroup=ciscoRFStatusGroup, cRFCfg=cRFCfg, cRFCfgNotifTimerMax=cRFCfgNotifTimerMax, cRFCfgNotifTimerMin=cRFCfgNotifTimerMin, cRFClient=cRFClient, ciscoRFStatusClientGroup=ciscoRFStatusClientGroup, cRFStatusPeerUnitState=cRFStatusPeerUnitState, cRFHistoryStandByAvailTime=cRFHistoryStandByAvailTime, cRFStatusIssuFromVersion=cRFStatusIssuFromVersion, cRFCfgRedundancyOperMode=cRFCfgRedundancyOperMode, cRFStatusRFClientTable=cRFStatusRFClientTable, cRFCfgKeepaliveThreshMax=cRFCfgKeepaliveThreshMax, ciscoRFIssuStateObjGroupRev1=ciscoRFIssuStateObjGroupRev1, ciscoRFStatusGroupRev1=ciscoRFStatusGroupRev1, cRFStatus=cRFStatus, cRFStatusUnitState=cRFStatusUnitState, ciscoRFMIBNotifications=ciscoRFMIBNotifications, cRFStatusManualSwactInhibit=cRFStatusManualSwactInhibit, cRFCfgKeepaliveTimer=cRFCfgKeepaliveTimer, cRFStatusRFClientStatus=cRFStatusRFClientStatus, ciscoRFMIBObjects=ciscoRFMIBObjects, ciscoRFMIBCompliance=ciscoRFMIBCompliance, cRFStatusIssuState=cRFStatusIssuState, ciscoRFMIBComplianceRev2=ciscoRFMIBComplianceRev2, cRFHistorySwitchOverReason=cRFHistorySwitchOverReason, ciscoRFIssuStateObjGroup=ciscoRFIssuStateObjGroup, RFIssuState=RFIssuState, PYSNMP_MODULE_ID=ciscoRFMIB, cRFStatusDuplexMode=cRFStatusDuplexMode, ciscoRFIssuStateNotif=ciscoRFIssuStateNotif, cRFHistorySwactTime=cRFHistorySwactTime, ciscoRFIssuStateNotifGroupRev1=ciscoRFIssuStateNotifGroupRev1, cRFStatusPeerUnitId=cRFStatusPeerUnitId, cRFHistoryTableMaxLength=cRFHistoryTableMaxLength, ciscoRFHistoryGroup=ciscoRFHistoryGroup, cRFStatusRFClientSeq=cRFStatusRFClientSeq)

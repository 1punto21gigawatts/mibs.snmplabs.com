#
# PySNMP MIB module Nortel-MsCarrier-MscPassport-DprsMcsEpMIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/Nortel-MsCarrier-MscPassport-DprsMcsEpMIB
# Produced by pysmi-0.3.4 at Wed May  1 14:29:52 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ValueRangeConstraint, SingleValueConstraint, ConstraintsIntersection, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsIntersection", "ValueSizeConstraint")
mscMcsMgrIndex, mscMcsMgr = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-McsMgrMIB", "mscMcsMgrIndex", "mscMcsMgr")
Counter32, DisplayString, Integer32, RowPointer, RowStatus, StorageType, Unsigned32, Gauge32 = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-StandardTextualConventionsMIB", "Counter32", "DisplayString", "Integer32", "RowPointer", "RowStatus", "StorageType", "Unsigned32", "Gauge32")
PassportCounter64, NonReplicated, Link, HexString, Unsigned64, FixedPoint2, AsciiString, EnterpriseDateAndTime = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-TextualConventionsMIB", "PassportCounter64", "NonReplicated", "Link", "HexString", "Unsigned64", "FixedPoint2", "AsciiString", "EnterpriseDateAndTime")
mscPassportMIBs, = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-UsefulDefinitionsMIB", "mscPassportMIBs")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
NotificationType, Bits, ObjectIdentity, ModuleIdentity, IpAddress, iso, Counter32, TimeTicks, Integer32, MibIdentifier, Counter64, MibScalar, MibTable, MibTableRow, MibTableColumn, Unsigned32, Gauge32 = mibBuilder.importSymbols("SNMPv2-SMI", "NotificationType", "Bits", "ObjectIdentity", "ModuleIdentity", "IpAddress", "iso", "Counter32", "TimeTicks", "Integer32", "MibIdentifier", "Counter64", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Unsigned32", "Gauge32")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
dprsMcsEpMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 125))
mscMcsMgrDprsMcsEpG = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2))
mscMcsMgrDprsMcsEpGRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 1), )
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGRowStatusTable.setDescription('This entry controls the addition and deletion of mscMcsMgrDprsMcsEpG components.')
mscMcsMgrDprsMcsEpGRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-McsMgrMIB", "mscMcsMgrIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGIndex"))
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGRowStatusEntry.setDescription('A single entry in the table represents a single mscMcsMgrDprsMcsEpG component.')
mscMcsMgrDprsMcsEpGRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscMcsMgrDprsMcsEpG components. These components can be added and deleted.')
mscMcsMgrDprsMcsEpGComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscMcsMgrDprsMcsEpGStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGStorageType.setDescription('This variable represents the storage type value for the mscMcsMgrDprsMcsEpG tables.')
mscMcsMgrDprsMcsEpGIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8191)))
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGIndex.setDescription('This variable represents the index for the mscMcsMgrDprsMcsEpG tables.')
mscMcsMgrDprsMcsEpGOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 10), )
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGOperTable.setDescription('This group contains the operational attributes of the DprsMcsEpG component.')
mscMcsMgrDprsMcsEpGOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-McsMgrMIB", "mscMcsMgrIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGIndex"))
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGOperEntry.setDescription('An entry in the mscMcsMgrDprsMcsEpGOperTable.')
mscMcsMgrDprsMcsEpGRemoteAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 10, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 44))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGRemoteAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGRemoteAddress.setDescription('This attribute indicates the NSAP address of the McsMgr at the destination module to which all EndPoints of this group are connected.')
mscMcsMgrDprsMcsEpGAssociatedEpGroupName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 10, 1, 2), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGAssociatedEpGroupName.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGAssociatedEpGroupName.setDescription('For a provisioned DprsMcsEpG, this attribute indicates the name of the DprsMcsEpG that contains the dynamic Eps to the same destination. For a dynamic DprsMcsEpG, this attribute indicates the name of the DprsMcsEpG that contains the provisioned Eps to the same destination. A null component name indicates that there is no DprsMcsEpG associated with this group.')
mscMcsMgrDprsMcsEpGAddr = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 2))
mscMcsMgrDprsMcsEpGAddrRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 2, 1), )
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGAddrRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGAddrRowStatusTable.setDescription('This entry controls the addition and deletion of mscMcsMgrDprsMcsEpGAddr components.')
mscMcsMgrDprsMcsEpGAddrRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-McsMgrMIB", "mscMcsMgrIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGAddrIndex"))
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGAddrRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGAddrRowStatusEntry.setDescription('A single entry in the table represents a single mscMcsMgrDprsMcsEpGAddr component.')
mscMcsMgrDprsMcsEpGAddrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGAddrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGAddrRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscMcsMgrDprsMcsEpGAddr components. These components cannot be added nor deleted.')
mscMcsMgrDprsMcsEpGAddrComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGAddrComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGAddrComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscMcsMgrDprsMcsEpGAddrStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGAddrStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGAddrStorageType.setDescription('This variable represents the storage type value for the mscMcsMgrDprsMcsEpGAddr tables.')
mscMcsMgrDprsMcsEpGAddrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGAddrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGAddrIndex.setDescription('This variable represents the index for the mscMcsMgrDprsMcsEpGAddr tables.')
mscMcsMgrDprsMcsEpGAddrProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 2, 10), )
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGAddrProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGAddrProvTable.setDescription('This group contains the provisionable attributes of the Address component.')
mscMcsMgrDprsMcsEpGAddrProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-McsMgrMIB", "mscMcsMgrIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGAddrIndex"))
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGAddrProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGAddrProvEntry.setDescription('An entry in the mscMcsMgrDprsMcsEpGAddrProvTable.')
mscMcsMgrDprsMcsEpGAddrRemoteAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 2, 10, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(1, 44))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGAddrRemoteAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGAddrRemoteAddress.setDescription('This attribute specifies the NSAP address of the McsMgr at the destination module. This address is used by the EndPoints provisioned under this DprsMcsEpG to establish a DPRS MCS Switched Path.')
mscMcsMgrDprsMcsEpGAddrCommentText = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 2, 10, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 60)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGAddrCommentText.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGAddrCommentText.setDescription('This attribute specifies additional textual information to be added by the network operator. Typical use of this attribute is to specify the destination module name.')
mscMcsMgrDprsMcsEpGEp = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3))
mscMcsMgrDprsMcsEpGEpRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 1), )
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpRowStatusTable.setDescription('This entry controls the addition and deletion of mscMcsMgrDprsMcsEpGEp components.')
mscMcsMgrDprsMcsEpGEpRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-McsMgrMIB", "mscMcsMgrIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGEpIndex"))
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpRowStatusEntry.setDescription('A single entry in the table represents a single mscMcsMgrDprsMcsEpGEp component.')
mscMcsMgrDprsMcsEpGEpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscMcsMgrDprsMcsEpGEp components. These components can be added and deleted.')
mscMcsMgrDprsMcsEpGEpComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscMcsMgrDprsMcsEpGEpStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpStorageType.setDescription('This variable represents the storage type value for the mscMcsMgrDprsMcsEpGEp tables.')
mscMcsMgrDprsMcsEpGEpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 256)))
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpIndex.setDescription('This variable represents the index for the mscMcsMgrDprsMcsEpGEp tables.')
mscMcsMgrDprsMcsEpGEpStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 10), )
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpStateTable.setDescription('This group contains the three OSI State attributes and the six OSI Status attributes. The descriptions generically indicate what each attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241- 7001-150, Passport Operations and Maintenance Guide.')
mscMcsMgrDprsMcsEpGEpStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-McsMgrMIB", "mscMcsMgrIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGEpIndex"))
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpStateEntry.setDescription('An entry in the mscMcsMgrDprsMcsEpGEpStateTable.')
mscMcsMgrDprsMcsEpGEpAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscMcsMgrDprsMcsEpGEpOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscMcsMgrDprsMcsEpGEpUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscMcsMgrDprsMcsEpGEpAvailabilityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 10, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpAvailabilityStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpAvailabilityStatus.setDescription('If supported by the component, this attribute indicates the OSI Availability status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value inTest indicates that the resource is undergoing a test procedure. If adminState is locked or shuttingDown, the normal users are precluded from using the resource and controlStatus is reservedForTest. Tests that do not exclude additional users can be present in any operational or administrative state but the reservedForTest condition should not be present. The value failed indicates that the component has an internal fault that prevents it from operating. The operationalState is disabled. The value dependency indicates that the component cannot operate because some other resource on which it depends is unavailable. The operationalState is disabled. The value powerOff indicates the resource requires power to be applied and it is not powered on. The operationalState is disabled. The value offLine indicates the resource requires a routine operation (either manual, automatic, or both) to be performed to place it on-line and make it available for use. The operationalState is disabled. The value offDuty indicates the resource is inactive in accordance with a predetermined time schedule. In the absence of other disabling conditions, the operationalState is enabled or disabled. The value degraded indicates the service provided by the component is degraded in some way, such as in speed or operating capacity. However, the resource remains available for service. The operationalState is enabled. The value notInstalled indicates the resource is not present. The operationalState is disabled. The value logFull is not used. Description of bits: inTest(0) failed(1) powerOff(2) offLine(3) offDuty(4) dependency(5) degraded(6) notInstalled(7) logFull(8)')
mscMcsMgrDprsMcsEpGEpProceduralStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 10, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpProceduralStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpProceduralStatus.setDescription("If supported by the component, this attribute indicates the OSI Procedural status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value initializationRequired indicates (for a resource which doesn't initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState is disabled. The value notInitialized indicates (for a resource which does initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState may be enabled or disabled. The value initializing indicates that initialization has been initiated but is not yet complete. The operationalState may be enabled or disabled. The value reporting indicates the resource has completed some processing operation and is notifying the results. The operationalState is enabled. The value terminating indicates the component is in a termination phase. If the resource doesn't reinitialize autonomously, operationalState is disabled; otherwise it is enabled or disabled. Description of bits: initializationRequired(0) notInitialized(1) initializing(2) reporting(3) terminating(4)")
mscMcsMgrDprsMcsEpGEpControlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 10, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpControlStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpControlStatus.setDescription('If supported by the component, this attribute indicates the OSI Control status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value subjectToTest indicates the resource is available but tests may be conducted simultaneously at unpredictable times, which may cause it to exhibit unusual characteristics. The value partOfServicesLocked indicates that part of the service is restricted from users of a resource. The adminState is unlocked. The value reservedForTest indicates that the component is administratively unavailable because it is undergoing a test procedure. The adminState is locked. The value suspended indicates that the service has been administratively suspended. Description of bits: subjectToTest(0) partOfServicesLocked(1) reservedForTest(2) suspended(3)')
mscMcsMgrDprsMcsEpGEpAlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 10, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpAlarmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpAlarmStatus.setDescription('If supported by the component, this attribute indicates the OSI Alarm status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value underRepair indicates the component is currently being repaired. The operationalState is enabled or disabled. The value critical indicates one or more critical alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value major indicates one or more major alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value minor indicates one or more minor alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value alarmOutstanding generically indicates that an alarm of some severity is outstanding against the component. Description of bits: underRepair(0) critical(1) major(2) minor(3) alarmOutstanding(4)')
mscMcsMgrDprsMcsEpGEpStandbyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 10, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 15))).clone(namedValues=NamedValues(("hotStandby", 0), ("coldStandby", 1), ("providingService", 2), ("notSet", 15))).clone('notSet')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpStandbyStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpStandbyStatus.setDescription('If supported by the component, this attribute indicates the OSI Standby status of the component. The value notSet indicates that either the attribute is not supported or that none of the status conditions described below are present. Note that this is a non-standard value, used because the original specification indicated this attribute was set-valued and thus, did not provide a value to indicate that none of the other three are applicable. The value hotStandby indicates that the resource is not providing service but will be immediately able to take over the role of the resource to be backed up, without initialization activity, and containing the same information as the resource to be backed up. The value coldStandby indicates the resource is a backup for another resource but will not be immediately able to take over the role of the backed up resource and will require some initialization activity. The value providingService indicates that this component, as a backup resource, is currently backing up another resource.')
mscMcsMgrDprsMcsEpGEpUnknownStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 10, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1))).clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpUnknownStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpUnknownStatus.setDescription('This attribute indicates the OSI Unknown status of the component. The value false indicates that all of the other OSI State and Status attribute values can be considered accurate. The value true indicates that the actual state of the component is not known for sure.')
mscMcsMgrDprsMcsEpGEpOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 11), )
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpOperTable.setDescription('This group contains the operational attributes of the EndPoint component.')
mscMcsMgrDprsMcsEpGEpOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-McsMgrMIB", "mscMcsMgrIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGEpIndex"))
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpOperEntry.setDescription('An entry in the mscMcsMgrDprsMcsEpGEpOperTable.')
mscMcsMgrDprsMcsEpGEpLastTransportConnectionClearCause = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLastTransportConnectionClearCause.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLastTransportConnectionClearCause.setDescription('This attribute indicates the most recent clear cause for the transport connection. This indicates the causes provided by the network. A value of zero indicates that the transport connection has never been cleared. A value of 1000 indicates that the network has not provided a clear cause for the transport connection clearing. Section 5.4.5.15 of the ATMF UNI 3.1 specification lists the clear causes provided by the network.')
mscMcsMgrDprsMcsEpGEpType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 11, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("originating", 0), ("terminating", 1))).clone('originating')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpType.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpType.setDescription('This attribute indicates the type of the end point. If the value is originating, this Ep is provisioned and is responsible for initiating the SPVC call to set up the PORS or ATM connection. If the value is terminating, this Ep is created dynamically by the McsMgr at the destination node when it receives a call setup request.')
mscMcsMgrDprsMcsEpGEpSupportedTransferPriorities = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 11, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpSupportedTransferPriorities.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpSupportedTransferPriorities.setDescription('This attribute indicates the Frame Relay transfer priorities supported by the transport connection. Description of bits: n0(0) n1(1) n2(2) n3(3) n4(4) n5(5) n6(6) n7(7) n8(8) n9(9) n10(10) n11(11) n12(12) n13(13) n14(14) n15(15)')
mscMcsMgrDprsMcsEpGEpConnectionTransferPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 11, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpConnectionTransferPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpConnectionTransferPriority.setDescription('This attribute indicates the transfer priority used to establish the transport connection.')
mscMcsMgrDprsMcsEpGEpServiceCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 11, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("ubr", 0), ("cbr", 1), ("rtVbr", 2), ("nrtVbr", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpServiceCategory.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpServiceCategory.setDescription('This attribute indicates the ATM service category of the transport connection.')
mscMcsMgrDprsMcsEpGEpBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 11, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 155000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpBandwidth.setStatus('obsolete')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpBandwidth.setDescription('This attribute indicates the bandwidth at which the transport connection agrees to transfer information. This attribute has been replaced by the forwardBandwidth and backwardBandwidth attributes.')
mscMcsMgrDprsMcsEpGEpRemoteComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 11, 1, 9), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 46))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpRemoteComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpRemoteComponentName.setDescription("This attribute indicates the component name of the remote Ep, learned from the remote end. For example: 'EM/NODEY2D0 McsMgr DprsMcsEpG/1 Ep/1'. The value is a null string if the transport connection is down.")
mscMcsMgrDprsMcsEpGEpRemoteRoutingId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 11, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 126))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpRemoteRoutingId.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpRemoteRoutingId.setDescription('This attribute indicates the routing identifier (RID) associated with the Passport node on which the remote Ep resides. The remote RID is learned from the remote Ep. The value is valid when the transport connection is up and zero otherwise.')
mscMcsMgrDprsMcsEpGEpRemoteModuleId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 11, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1909))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpRemoteModuleId.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpRemoteModuleId.setDescription('This attribute indicates the module identifier (MID) associated with the Passport node on which the remote Ep resides. The remote MID is learned from the remote Ep. The value is valid when the transport connection is up and zero otherwise.')
mscMcsMgrDprsMcsEpGEpLastTrConnDiagCode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 11, 1, 12), HexString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLastTrConnDiagCode.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLastTrConnDiagCode.setDescription('This attribute indicates the diagnostic code of the most recently cleared transport connection. This indicates the diagnostic code (associated with the lastTransportConnectionClearCause) provided by the network. A string containing only a 0 or 00 (zero) indicates that the network has not provided a diagnostic code for the most recently cleared transport connection. Section 5.4.5.15 of the ATMF UNI 3.1 specification lists the diagnostic codes that can be provided by the network.')
mscMcsMgrDprsMcsEpGEpForwardBandwith = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 11, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 155000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpForwardBandwith.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpForwardBandwith.setDescription('This attribute indicates the bandwidth at which the transport connection agrees to transfer information in the forward (from the originating to the dynamic End Point) direction.')
mscMcsMgrDprsMcsEpGEpReverseBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 11, 1, 14), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 155000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpReverseBandwidth.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpReverseBandwidth.setDescription('This attribute indicates the bandwidth at which the transport connection agrees to transfer information in the reverse (from the dynamic to the to the originating End Point) direction.')
mscMcsMgrDprsMcsEpGEpStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 12), )
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpStatsTable.setDescription('This group contains statistics of traffic received on the DPRS MCS Switched Path.')
mscMcsMgrDprsMcsEpGEpStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-McsMgrMIB", "mscMcsMgrIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGEpIndex"))
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpStatsEntry.setDescription('An entry in the mscMcsMgrDprsMcsEpGEpStatsTable.')
mscMcsMgrDprsMcsEpGEpSetupAttempts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 12, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpSetupAttempts.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpSetupAttempts.setDescription('This attribute counts the number of attempts made to set up the transport connection. The counter wraps around to zero when the maximum value is exceeded.')
mscMcsMgrDprsMcsEpGEpPktDiscErroredFromMcs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 12, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpPktDiscErroredFromMcs.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpPktDiscErroredFromMcs.setDescription('This attribute counts errored packets received on the DPRS MCS Switched Path; these packets are discarded. The counter wraps around to zero when the maximum value is exceeded.')
mscMcsMgrDprsMcsEpGEpPktFromMcsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 402), )
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpPktFromMcsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpPktFromMcsTable.setDescription('This attribute counts the packets received on the DPRS MCS Switched Path for each discard priority. This attribute is a vector with four entries. Each vector entry is a counter indexed by one of four discard priorities, namely, discard priority 0 (dp0), discard priority 1 (dp1), discard priority 2 (dp2), or discard priority 3 (dp3). Each entry (counter) wraps around to zero when the maximum value is exceeded.')
mscMcsMgrDprsMcsEpGEpPktFromMcsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 402, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-McsMgrMIB", "mscMcsMgrIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGEpIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGEpPktFromMcsIndex"))
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpPktFromMcsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpPktFromMcsEntry.setDescription('An entry in the mscMcsMgrDprsMcsEpGEpPktFromMcsTable.')
mscMcsMgrDprsMcsEpGEpPktFromMcsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 402, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("discardPriority0", 0), ("discardPriority1", 1), ("discardPriority2", 2), ("discardPriority3", 3))))
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpPktFromMcsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpPktFromMcsIndex.setDescription('This variable represents the mscMcsMgrDprsMcsEpGEpPktFromMcsTable specific index for the mscMcsMgrDprsMcsEpGEpPktFromMcsTable.')
mscMcsMgrDprsMcsEpGEpPktFromMcsValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 402, 1, 2), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpPktFromMcsValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpPktFromMcsValue.setDescription('This variable represents an individual value for the mscMcsMgrDprsMcsEpGEpPktFromMcsTable.')
mscMcsMgrDprsMcsEpGEpOctetsFromMcsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 403), )
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpOctetsFromMcsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpOctetsFromMcsTable.setDescription('This attribute counts the octets received on the DPRS MCS Switched Path for each discard priority. This attribute is a vector with four entries. Each vector entry is a counter indexed by one of four discard priorities, namely, discard priority 0 (dp0), discard priority 1 (dp1), discard priority 2 (dp2), or discard priority 3 (dp3). Each entry (counter) wraps around to zero when the maximum value is exceeded.')
mscMcsMgrDprsMcsEpGEpOctetsFromMcsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 403, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-McsMgrMIB", "mscMcsMgrIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGEpIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGEpOctetsFromMcsIndex"))
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpOctetsFromMcsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpOctetsFromMcsEntry.setDescription('An entry in the mscMcsMgrDprsMcsEpGEpOctetsFromMcsTable.')
mscMcsMgrDprsMcsEpGEpOctetsFromMcsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 403, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("discardPriority0", 0), ("discardPriority1", 1), ("discardPriority2", 2), ("discardPriority3", 3))))
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpOctetsFromMcsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpOctetsFromMcsIndex.setDescription('This variable represents the mscMcsMgrDprsMcsEpGEpOctetsFromMcsTable specific index for the mscMcsMgrDprsMcsEpGEpOctetsFromMcsTable.')
mscMcsMgrDprsMcsEpGEpOctetsFromMcsValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 403, 1, 2), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpOctetsFromMcsValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpOctetsFromMcsValue.setDescription('This variable represents an individual value for the mscMcsMgrDprsMcsEpGEpOctetsFromMcsTable.')
mscMcsMgrDprsMcsEpGEpPktDiscCongestedFromMcsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 404), )
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpPktDiscCongestedFromMcsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpPktDiscCongestedFromMcsTable.setDescription('This attribute counts packets received on the DPRS MCS Switched Path for each discard priority that have been discarded at the transport card due to congestion at the access card. This attribute is a vector with four entries. Each vector entry is a counter indexed by one of four discard priorities, namely, discard priority 0 (dp0), discard priority 1 (dp1), discard priority 2 (dp2), or discard priority 3 (dp3). Each entry (counter) wraps around to zero when the maximum value is exceeded.')
mscMcsMgrDprsMcsEpGEpPktDiscCongestedFromMcsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 404, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-McsMgrMIB", "mscMcsMgrIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGEpIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGEpPktDiscCongestedFromMcsIndex"))
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpPktDiscCongestedFromMcsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpPktDiscCongestedFromMcsEntry.setDescription('An entry in the mscMcsMgrDprsMcsEpGEpPktDiscCongestedFromMcsTable.')
mscMcsMgrDprsMcsEpGEpPktDiscCongestedFromMcsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 404, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("discardPriority0", 0), ("discardPriority1", 1), ("discardPriority2", 2), ("discardPriority3", 3))))
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpPktDiscCongestedFromMcsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpPktDiscCongestedFromMcsIndex.setDescription('This variable represents the mscMcsMgrDprsMcsEpGEpPktDiscCongestedFromMcsTable specific index for the mscMcsMgrDprsMcsEpGEpPktDiscCongestedFromMcsTable.')
mscMcsMgrDprsMcsEpGEpPktDiscCongestedFromMcsValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 404, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpPktDiscCongestedFromMcsValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpPktDiscCongestedFromMcsValue.setDescription('This variable represents an individual value for the mscMcsMgrDprsMcsEpGEpPktDiscCongestedFromMcsTable.')
mscMcsMgrDprsMcsEpGEpEpD = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 2))
mscMcsMgrDprsMcsEpGEpEpDRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 2, 1), )
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpEpDRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpEpDRowStatusTable.setDescription('This entry controls the addition and deletion of mscMcsMgrDprsMcsEpGEpEpD components.')
mscMcsMgrDprsMcsEpGEpEpDRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-McsMgrMIB", "mscMcsMgrIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGEpIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGEpEpDIndex"))
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpEpDRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpEpDRowStatusEntry.setDescription('A single entry in the table represents a single mscMcsMgrDprsMcsEpGEpEpD component.')
mscMcsMgrDprsMcsEpGEpEpDRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpEpDRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpEpDRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscMcsMgrDprsMcsEpGEpEpD components. These components cannot be added nor deleted.')
mscMcsMgrDprsMcsEpGEpEpDComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpEpDComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpEpDComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscMcsMgrDprsMcsEpGEpEpDStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpEpDStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpEpDStorageType.setDescription('This variable represents the storage type value for the mscMcsMgrDprsMcsEpGEpEpD tables.')
mscMcsMgrDprsMcsEpGEpEpDIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpEpDIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpEpDIndex.setDescription('This variable represents the index for the mscMcsMgrDprsMcsEpGEpEpD tables.')
mscMcsMgrDprsMcsEpGEpEpDProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 2, 10), )
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpEpDProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpEpDProvTable.setDescription('This group contains the parameters used to establish the transport connection for this Ep.')
mscMcsMgrDprsMcsEpGEpEpDProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-McsMgrMIB", "mscMcsMgrIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGEpIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGEpEpDIndex"))
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpEpDProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpEpDProvEntry.setDescription('An entry in the mscMcsMgrDprsMcsEpGEpEpDProvTable.')
mscMcsMgrDprsMcsEpGEpEpDBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 2, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(56000, 155000000)).clone(512000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpEpDBandwidth.setStatus('obsolete')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpEpDBandwidth.setDescription('This attribute specifies the bandwidth at which the transport connection agrees to transfer information. A conservative value would be the sum of the committed information rates (CIRs) of all individual Frame Relay DLCIs multiplexed on the transport connection. For ATM connections, the value is converted to an equivalent Peak Cell Rate (PCR01) for all cells with Cell Loss Priority (CLP), CLP = 0 and CLP = 1. Note that the conversion to an equivalent cell rate for ATM connections may result in some wasted bandwidth depending on the average frame size to cell ratio. This attribute is obosolete and on a migration the value that is provisioned for this attribute is copied to both the forwardBandwidth and reverseBandwidth attributes creating a switched path with symmetrical bandwidth.')
mscMcsMgrDprsMcsEpGEpEpDConnectionTransferPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 2, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpEpDConnectionTransferPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpEpDConnectionTransferPriority.setDescription('This attribute specifies the transfer priority used to establish the transport connection. It references the ModuleData Frs AtmNet Tpm to determine the ATM service category to be used by the transport connection. This attribute is used by the Ep solely for the purpose of determining the service category that should be used to establish the transport connection.')
mscMcsMgrDprsMcsEpGEpEpDTransportConnectionPreference = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 2, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3))).clone(namedValues=NamedValues(("atmOnly", 1), ("porsOnly", 3))).clone('porsOnly')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpEpDTransportConnectionPreference.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpEpDTransportConnectionPreference.setDescription("This attribute specifies the preference of routing system to be used to set up the transport connection. If a value of atmOnly is specified, attempts to set up the transport connection will be made using only the ATM routing system's network facilities. If a value of porsOnly is specified, attempts to set up the transport connection will be made using only PORS network facilities.")
mscMcsMgrDprsMcsEpGEpEpDProfile = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 2, 10, 1, 4), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpEpDProfile.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpEpDProfile.setDescription('This attribute specifies the PORS profile to be used for the transport connection when it is set up using PORS. This attribute is ignored if the transportConnectionPreference is atmOnly.')
mscMcsMgrDprsMcsEpGEpEpDPorsManualPath = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 2, 10, 1, 5), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpEpDPorsManualPath.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpEpDPorsManualPath.setDescription('This attribute specifies the PORS manual path to be used for the transport connection when it is set up using PORS. The manual path that this attribute is linked to specifies the sequence of Trunks that will be used when PORS chooses and instantiates the route. This attribute is ignored if the transportConnectionPreference is atmOnly.')
mscMcsMgrDprsMcsEpGEpEpDSupportedTransferPriorities = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 2, 10, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2).clone(hexValue="8000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpEpDSupportedTransferPriorities.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpEpDSupportedTransferPriorities.setDescription('This attribute specifies the Frame Relay transfer priorities that are supported through the transport connection. It is used to determine which EndPoint within a DprsMcsEndPointGroup is to multiplex a particular Frame Relay DLCI. A particular transfer priority can be specified on at most one EndPoint within a DprsMcsEndPointGroup. Description of bits: n0(0) n1(1) n2(2) n3(3) n4(4) n5(5) n6(6) n7(7) n8(8) n9(9) n10(10) n11(11) n12(12) n13(13) n14(14) n15(15)')
mscMcsMgrDprsMcsEpGEpEpDForwardBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 2, 10, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(56000, 155000000)).clone(512000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpEpDForwardBandwidth.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpEpDForwardBandwidth.setDescription('This attribute specifies the bandwidth this End Point will request when setting up a transfer connection which the transport in the forward (from the originating to the terminating End Point) direction. A conservative value would be the sum of the committed information rates (CIRs) of all individual Frame Relay DLCIs multiplexed on the transport connection. For ATM connections, the value is converted to an equivalent Peak Cell Rate (PCR01) for all cells with Cell Loss Priority (CLP), CLP = 0 and CLP = 1. Note that the conversion to an equivalent cell rate for ATM connections may result in some wasted bandwidth depending on the average frame size to cell ratio.')
mscMcsMgrDprsMcsEpGEpEpDReverseBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 2, 10, 1, 8), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(56000, 155000000), ValueRangeConstraint(155000002, 155000002), )).clone(155000002)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpEpDReverseBandwidth.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpEpDReverseBandwidth.setDescription('This attribute specifies the bandwidth this End Point will request when setting up a transfer connection which the transport in the reverse (from the terminating to the originating End Point) direction. A conservative value would be the sum of the committed information rates (CIRs) of all individual Frame Relay DLCIs multiplexed on the transport connection. For ATM connections, the value is converted to an equivalent Peak Cell Rate (PCR01) for all cells with Cell Loss Priority (CLP), CLP = 0 and CLP = 1. Note that the conversion to an equivalent cell rate for ATM connections may result in some wasted bandwidth depending on the average frame size to cell ratio. VALUES ( 155000002 = sameAsForward )')
mscMcsMgrDprsMcsEpGEpAtmCon = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 3))
mscMcsMgrDprsMcsEpGEpAtmConRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 3, 1), )
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpAtmConRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpAtmConRowStatusTable.setDescription('This entry controls the addition and deletion of mscMcsMgrDprsMcsEpGEpAtmCon components.')
mscMcsMgrDprsMcsEpGEpAtmConRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 3, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-McsMgrMIB", "mscMcsMgrIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGEpIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGEpAtmConIndex"))
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpAtmConRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpAtmConRowStatusEntry.setDescription('A single entry in the table represents a single mscMcsMgrDprsMcsEpGEpAtmCon component.')
mscMcsMgrDprsMcsEpGEpAtmConRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 3, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpAtmConRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpAtmConRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscMcsMgrDprsMcsEpGEpAtmCon components. These components cannot be added nor deleted.')
mscMcsMgrDprsMcsEpGEpAtmConComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpAtmConComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpAtmConComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscMcsMgrDprsMcsEpGEpAtmConStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpAtmConStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpAtmConStorageType.setDescription('This variable represents the storage type value for the mscMcsMgrDprsMcsEpGEpAtmCon tables.')
mscMcsMgrDprsMcsEpGEpAtmConIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpAtmConIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpAtmConIndex.setDescription('This variable represents the index for the mscMcsMgrDprsMcsEpGEpAtmCon tables.')
mscMcsMgrDprsMcsEpGEpAtmConOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 3, 10), )
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpAtmConOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpAtmConOperTable.setDescription('This attribute group contains the operational attributes for the NapAtmConnection component.')
mscMcsMgrDprsMcsEpGEpAtmConOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 3, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-McsMgrMIB", "mscMcsMgrIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGEpIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGEpAtmConIndex"))
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpAtmConOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpAtmConOperEntry.setDescription('An entry in the mscMcsMgrDprsMcsEpGEpAtmConOperTable.')
mscMcsMgrDprsMcsEpGEpAtmConNextHop = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 3, 10, 1, 1), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpAtmConNextHop.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpAtmConNextHop.setDescription('This attribute shows the component name of the AtmIf Vcc Ep or AtmCon component to which this switched connection is established.')
mscMcsMgrDprsMcsEpGEpLCo = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 4))
mscMcsMgrDprsMcsEpGEpLCoRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 4, 1), )
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoRowStatusTable.setDescription('This entry controls the addition and deletion of mscMcsMgrDprsMcsEpGEpLCo components.')
mscMcsMgrDprsMcsEpGEpLCoRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 4, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-McsMgrMIB", "mscMcsMgrIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGEpIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGEpLCoIndex"))
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoRowStatusEntry.setDescription('A single entry in the table represents a single mscMcsMgrDprsMcsEpGEpLCo component.')
mscMcsMgrDprsMcsEpGEpLCoRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 4, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscMcsMgrDprsMcsEpGEpLCo components. These components cannot be added nor deleted.')
mscMcsMgrDprsMcsEpGEpLCoComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscMcsMgrDprsMcsEpGEpLCoStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoStorageType.setDescription('This variable represents the storage type value for the mscMcsMgrDprsMcsEpGEpLCo tables.')
mscMcsMgrDprsMcsEpGEpLCoIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 4, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoIndex.setDescription('This variable represents the index for the mscMcsMgrDprsMcsEpGEpLCo tables.')
mscMcsMgrDprsMcsEpGEpLCoPathDataTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 4, 10), )
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoPathDataTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoPathDataTable.setDescription('This group contains all operational attributes for the path oriented LCo.')
mscMcsMgrDprsMcsEpGEpLCoPathDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 4, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-McsMgrMIB", "mscMcsMgrIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGEpIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGEpLCoIndex"))
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoPathDataEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoPathDataEntry.setDescription('An entry in the mscMcsMgrDprsMcsEpGEpLCoPathDataTable.')
mscMcsMgrDprsMcsEpGEpLCoState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 4, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("pathDown", 0), ("selectingRoute", 1), ("connecting", 2), ("pathUp", 3), ("pathDownRetrying", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoState.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoState.setDescription('This attribute reflects the current state of the connection. The pathDown state indicates a connection that has no remote end provisioned or the application has not yet signalled for a path. The selectingRoute state occurs when a request has been sent to route selector and it has not yet responded. The connectingState occurs while a path is being established. The pathUp state is the normal operational state of a path. The pathDownRetrying state indicates a path that attempted route selection but received no route and is now waiting to retry route selection again.')
mscMcsMgrDprsMcsEpGEpLCoOverrideRemoteName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 4, 10, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoOverrideRemoteName.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoOverrideRemoteName.setDescription("If set and the current PLC remoteName is blank this remoteName will override the blank PLC remoteName. Usually you would set this attribute and then lock/unlock the service component which will result in this new overrideRemoteName being used as if it had been provisioned into the PLC remoteName. The advantage of this attribute is that the connection's remoteName can be changed immediately without having to 'activate prov' but the disadvantage is that the overrideRemoteName is not permanent and if the card or switch is reset the override will be lost.")
mscMcsMgrDprsMcsEpGEpLCoEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 4, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("calling", 0), ("called", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoEnd.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoEnd.setDescription('This attribute identifies whether this is the calling or called end of the path.')
mscMcsMgrDprsMcsEpGEpLCoCostMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 4, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoCostMetric.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoCostMetric.setDescription("This attribute gives the route's total cost metric. It is calculated as the sum of the cost metric of all trunks in the path at the time the connection was established. The cost metric of a trunk is defined by the trunkCost attribute of the Trunk component. The costMetric for an LCo that is originated and terminated on the same module is 0.")
mscMcsMgrDprsMcsEpGEpLCoDelayMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 4, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 100000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoDelayMetric.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoDelayMetric.setDescription('This attribute gives the total delay of the route as the one way delay for a 512 byte packet. It is calculated as the sum of the delays of all trunks in the path stored in topology at the time the connection was established. The delay for an LCo that is originated and terminated on the same module is 0.')
mscMcsMgrDprsMcsEpGEpLCoRoundTripDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 4, 10, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 200000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoRoundTripDelay.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoRoundTripDelay.setDescription('This attribute contains the time taken for a packet (cell) of 44 bytes to be transmitted to the remote LCo and return to this LCo. The number reported is given in milliseconds to the nearest millisecond. A value of one millisecond is reported if the time is less than 1 millisecond even though the delay may be less than 1 Millisecond when the LCo is originated and terminated on the same module.')
mscMcsMgrDprsMcsEpGEpLCoSetupPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 4, 10, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoSetupPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoSetupPriority.setDescription('This attribute gives the priority at which the current path is established. Zero is the highest priority and four is the lowest. The holdingPriority, a complementary attribute of this component, indicates the priority a path maintains once it is established.')
mscMcsMgrDprsMcsEpGEpLCoHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 4, 10, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoHoldingPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoHoldingPriority.setDescription('This attribute gives the priority at which a path holds its current path once the path is established. Zero is the highest priority and four is the lowest. The setupPriority, a complementary attribute, indicates the priority of a path at establishment time.')
mscMcsMgrDprsMcsEpGEpLCoRequiredTxBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 4, 10, 1, 9), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoRequiredTxBandwidth.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoRequiredTxBandwidth.setDescription('This attribute gives the actual bandwidth (in bits per second) reserved by this path on each of the trunks of its route. This attribute represents the bandwidth for traffic outgoing to the remote end point. The originating end of the connection determines this value.')
mscMcsMgrDprsMcsEpGEpLCoRequiredRxBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 4, 10, 1, 10), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoRequiredRxBandwidth.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoRequiredRxBandwidth.setDescription('This attribute gives the actual bandwidth (in bits per second) reserved by this path on each of trunks of its route. This attribute represents the bandwidth for traffic incoming from the remote end point. The originating end of the connection determines this value')
mscMcsMgrDprsMcsEpGEpLCoRequiredTrafficType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 4, 10, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("voice", 0), ("data", 1), ("video", 2), ("trafficType1", 3), ("trafficType2", 4), ("trafficType3", 5), ("trafficType4", 6), ("trafficType5", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoRequiredTrafficType.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoRequiredTrafficType.setDescription('This operational attribute indicates the type of traffic transmitted over the path. There are eight possible traffic types, and the path can transmit only one of them. The originating end of the connection determines the type. These are arbitrary designations for traffic type. The voice, data and video traffic types are defined, and five other arbitrary traffic types can be defined by the network administration. This attribute is used in the route selection process to restrict the route to trunks that support this traffic type. The supportedTrafficType trunk attribute lists all the types of traffic allowed on the trunk. For example, if requiredTrafficType is specified as trafficType1 then only trunks that include trafficType1 in supportedTrafficType, will be candidates for this connection.')
mscMcsMgrDprsMcsEpGEpLCoPermittedTrunkTypes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 4, 10, 1, 12), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoPermittedTrunkTypes.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoPermittedTrunkTypes.setDescription("This operational attribute lists up to eight types of trunk that can be used on the route. The originating end of the connection determines the types. The terrestrial and satellite trunk types have been defined, leaving six remaining arbitrary types that can be defined by the network administration. The trunk's type is indicated in the trunkType attribute of the Trunk component. When selecting a route, PORS only chooses trunks whose trunkType are in the permittedTrunkTypes for the path. Description of bits: terrestrial(0) satellite(1) trunkType1(2) trunkType2(3) trunkType3(4) trunkType4(5) trunkType5(6) trunkType6(7)")
mscMcsMgrDprsMcsEpGEpLCoRequiredSecurity = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 4, 10, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoRequiredSecurity.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoRequiredSecurity.setDescription("This attribute indicates the required minimum level of security of the trunks on the route. Zero represents the most secure and seven represents the least secure. The trunk's security is indicated by the trunkSecurity attribute of the Trunk component, and has values identical in range and meaning to the requiredSecurity attribute. PORS ensures that any route selected does not contain a trunk whose trunkSecurity attribute is numerically greater than the requiredSecurity.")
mscMcsMgrDprsMcsEpGEpLCoRequiredCustomerParameter = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 4, 10, 1, 14), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoRequiredCustomerParameter.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoRequiredCustomerParameter.setDescription('This attribute indicates the allowed customer defined parameter of the trunks on the route.The originating end of the connection determines the customer defined parameter. Its value, a number from zero to seven, is chosen by a network administration to have a meaning specific to their network, thus allowing them to customize the use of their trunks. A complementary trunk attribute, customerParameter, also has a value from zero to seven. The route selection process does not consider trunks whose customerParameter is greater than the requiredCustomerParameter of the path.')
mscMcsMgrDprsMcsEpGEpLCoEmissionPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 4, 10, 1, 15), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoEmissionPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoEmissionPriority.setDescription('This attribute indicates the urgency with which packets on the path are emitted by the trunks on the route. The originating end of the connection selects the emissionPriority. EmissionPriority of zero indicates the highest emission priority, while two indicates the lowest emission priority. Packets with a higher emissionPriority (or numerically less) are serviced and sent out before the packets of lower emissionPriority (or numerically higher).')
mscMcsMgrDprsMcsEpGEpLCoDiscardPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 4, 10, 1, 16), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoDiscardPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoDiscardPriority.setDescription('This attribute indicates the importance of the packets on the path.The originating end of the connection sets discardPriority. One is used for paths carrying the most important traffic, and three is used for paths carrying the least important traffic. Packets with lower discardPriority(numerically lower) are discarded after packets with a higher discardPriority(numerically higher).')
mscMcsMgrDprsMcsEpGEpLCoPathType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 4, 10, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("normal", 0), ("manual", 1), ("forced", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoPathType.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoPathType.setDescription('This attribute indicates whether the path for this PLC was determined automatically or by static provisioning. Normal pathTypes are selected automatically by Route Selector.The other pathTypes are both manual pathTypes where the operator must specify, through provisioning, a static route termed the manualPath. A manual pathType connection is nearly identical to a normal path type connection with the exception that the route is pre-provisioned. For a manual pathType, bandwidth reservations are respected along the path exactly as in a normal path. The last type, the forced pathType, is also a manual path but regardless of the bandwidth available the route is granted provided the trunks are operational and there are sufficient Logical Channels (LChs). The forced pathType could result in over committing the reserved bandwidth allowed on a trunk. A better way to achieve the effects of a forced pathType is to use a manual pathType with setupPriority = 0 and holdingPriority = 0. In this manner the path will reserve correct bandwidth and it will bump other paths if required while not being bumped itself.')
mscMcsMgrDprsMcsEpGEpLCoRetryCount = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 4, 10, 1, 18), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoRetryCount.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoRetryCount.setDescription('This attribute is the count of the number of times the path chosen during route selection could not be instantiated. This count should be three or below if the network is performing adequately. A high value indicates that the route selection is often performed using an out-of-date view of available network bandwidth and/or topology. This attribute will only increase at the calling end of the connection. This attribute is reset each time a path reconnects and stops counting when it reaches its maximum value.')
mscMcsMgrDprsMcsEpGEpLCoPathFailureCount = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 4, 10, 1, 19), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoPathFailureCount.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoPathFailureCount.setDescription('This attribute is the count of the number of times the path has successfully connected. It is set to zero the first time the path is up. If a path fails anytime after connecting this count will be incremented when the path is up again. Failed route requests do not count in this statistic. See retryCount above. This attribute stops counting at its maximum value.')
mscMcsMgrDprsMcsEpGEpLCoReasonForNoRoute = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 4, 10, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14))).clone(namedValues=NamedValues(("none", 0), ("destinationNameTooLong", 1), ("destinationNotSpecified", 2), ("unknownDestinationName", 3), ("incorrectDestination", 4), ("incorrectDestinationEndPoint", 5), ("unknownSource", 6), ("unknownDestination", 7), ("sameNode", 8), ("routeCostTooMuch", 9), ("routesDelayTooLong", 10), ("attributesNotMet", 11), ("anError", 12), ("attributeProfileProblem", 13), ("manualPathIndexProblem", 14))).clone('none')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoReasonForNoRoute.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoReasonForNoRoute.setDescription("This attribute is the route selection's reasonForNoRoute and provides a brief reason for which a route was not selected. The reasons are essentially self-explanatory. Perhaps two reasons for no route require some explanation. The reason unknownRemoteNodeName is issued when the remote node name is not in the topological database. The reason plcAttributesNotMet is issued when there is no network connectivity at a level specified by the PLC attributes. This reason is also issued when there is no physical connectivity between two end nodes.")
mscMcsMgrDprsMcsEpGEpLCoLastTearDownReason = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 4, 10, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23))).clone(namedValues=NamedValues(("none", 0), ("normalShutDown", 1), ("insufficientTxLcOrBandwidth", 2), ("insufficientRxLcOrBandwidth", 3), ("trunkFailure", 4), ("trunkCardFailure", 5), ("operatorForced", 6), ("lostLcnClash", 7), ("networkCongestion", 8), ("trunkNotFound", 9), ("farEndNotFound", 10), ("wrongModuleReached", 11), ("farEndBusy", 12), ("callLoopedBack", 13), ("unknownReason", 14), ("farEndNotReady", 15), ("remoteNameMismatch", 16), ("serviceTypeMismatch", 17), ("reconnectFromFarEnd", 18), ("bumped", 19), ("accessCardFailure", 20), ("optimized", 21), ("overrideRemoteName", 22), ("trunkOrFarEndDidNotSupportMode", 23))).clone('none')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoLastTearDownReason.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoLastTearDownReason.setDescription("This attribute reflects the last tear down reason for a connection (LCo). In many cases this displays the reason for a momentary service interruption. This attribute applies to the last path failure only. If a path is no longer up, this may give an indication to the reason that the path has failed. In many cases an alarm will also be generated with more specific information. The following is a brief description of the reasons: none - This path has no information for the teardown this is typical of a path provisioned with no remoteName that has not been up. normalShutDown - This path has gone down due to normal call termination. insufficientTxLcOrBandwidth - At present there is either no available bandwidth or logical channel numbers available on one or more of the trunks for this path in the transmit direction. insufficientRxLcOrBandwidth - At present there is either no available bandwidth or logical channel numbers available on one or more of the trunks for this path in the receive direction. trunkFailure- A trunk on the path has failed or has gone down due to a provisioning change of a critical attribute. trunkCardFailure- A trunk FP card has failed along the path. accessCardFailure- The FP on which the peer access service was running has failed. operatorForced- The path has terminated due to the operator locking a trunk along the path. lostLcnClash- The path has terminated because the PA's at both ends of an intermediate trunk have allocated the same LC to different calls. When this happens both calls must go down and then try to come up again a fraction of a second later (effectively ensuring that they will now be assigned different LC's). It is normal to get the odd clash especially when the PA's usedLC is approaching the PA's maxLC. networkCongestion - The path has failed due to control information being lost and not recoverable. trunkNotFound - Occurs on a manual path usually. Check for trunks not up or names provisioned incorrectly. farEndNotFound - The far end is not provisioned or is not up. Check remote Name. wrongModuleReached - This may occur on a manual path. Check provisioning for correct trunk and service names. For a normal path, the network Topology may be changing check remoteName. farEndBusy - The far end has been reached but it is busy. Check remoteName and remote end provisioning. callLoopedBack - This LCo is provisioned to call itself. Re- provision since this is invalid. unknownReason - The failure was not resolved. farEndNotReady - The remote end was reached but the connection was refused due to the remote end not being enabled. remoteNameMismatch - The remote end has alarmed and rejected this setup due to remoteName provisioning. serviceTypeMismatch - The remote Service Type does not match this service type. Check provisioning. reconnectFromFarEnd - The remote end re-established this connection. Check the remote end lastTearDownReason to determine the real reason. bumped - Another call bumped this path from a trunk to get bandwidth (or an LC) which it required to come up. This other path had a higher setupPriority than this path's holdingPriority hence it was allowed to steal the bandwidth (or LC) from this path. optimized - This call has been rerouted due to the optimization feature. The call is still active this just indicates why the path changed. trunkOrFarEndDidNotSupportMode - This call was unable to complete because a mode required by the service was not supported by one of the trunks the route went through or by the far end service it connected to. Currently the only mode that this applies to is the map/mux mode on TRUNK PA ATM component. Map mode was required by the application (CES/FrAtm etc.) but was not available on the TRUNK PA ATM component through which the call was routed or the far end CES/FrAtm component did not specify the same mode.")
mscMcsMgrDprsMcsEpGEpLCoPathFailureAction = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 4, 10, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disconnectConnection", 0), ("reRoutePath", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoPathFailureAction.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoPathFailureAction.setDescription('This attribute displays whether the application is set to tolerate momentary interruption of a path while a new path is selected. If disconnectConnection is displayed, the application is informed as soon as possible about a failure by disconnection. If the attribute displays reRoutePath, the path may attempt an immediate reroute, provided the failure is a recoverable failure. If rerouting fails the application is informed of the failure. With this option set to reRoutePath the LCo may wait up to 30 seconds before informing the service of complete disconnection in order to allow both ends to attempt to reconnect. Note that if PLC components are different at both ends only the calling end is allowed to reconnect. All pathTypes respect this attribute. Also on a manualPath with both ends provisioned with independent paths (at least with respect to the failure) this option will have the desired effect that the path is rerouted without complete disconnection at both ends')
mscMcsMgrDprsMcsEpGEpLCoBumpPreference = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 4, 10, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("bumpWhenNecessary", 0), ("bumpToObtainBestRoute", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoBumpPreference.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoBumpPreference.setDescription("This attribute specifies when bumping will occur during route selection process. Bumping may occur when necessary or always. It will be necessary for a connection to bump if there is not enough resources for the connection to be established and these resources are occupied by a connection whose setupPriority is lower (numerically higher) than the connection's setupPriority. A connection may also always bump in order to obtain the best route.")
mscMcsMgrDprsMcsEpGEpLCoOptimization = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 4, 10, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoOptimization.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoOptimization.setDescription('This attribute is used to specify whether this connection should attempt to optimize its path when requested by the routing PORS component. Every path is as optimal as it can be when it is established, but as network traffic patterns and configurations change this path may no longer be as optimal as it could be. The PORS connection manager on a module requests circuits to optimize at the optimization interval.')
mscMcsMgrDprsMcsEpGEpLCoPathUpDateTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 4, 10, 1, 25), EnterpriseDateAndTime().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(19, 19), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoPathUpDateTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoPathUpDateTime.setDescription('This is the time stamp when the current path was established or reestablished.')
mscMcsMgrDprsMcsEpGEpLCoStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 4, 11), )
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoStatsTable.setDescription('This group contains the operational statistics attributes for the path oriented LCo.')
mscMcsMgrDprsMcsEpGEpLCoStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 4, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-McsMgrMIB", "mscMcsMgrIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGEpIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGEpLCoIndex"))
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoStatsEntry.setDescription('An entry in the mscMcsMgrDprsMcsEpGEpLCoStatsTable.')
mscMcsMgrDprsMcsEpGEpLCoPktsToNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 4, 11, 1, 1), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoPktsToNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoPktsToNetwork.setDescription('This attribute counts the number of packets transmitted to the network over this Logical Connection.')
mscMcsMgrDprsMcsEpGEpLCoBytesToNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 4, 11, 1, 2), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoBytesToNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoBytesToNetwork.setDescription('This attribute counts the number of bytes sent to the network over this Logical Connection.')
mscMcsMgrDprsMcsEpGEpLCoPktsFromNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 4, 11, 1, 3), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoPktsFromNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoPktsFromNetwork.setDescription('This attribute counts the number of packets received from the remote LCo via the network.')
mscMcsMgrDprsMcsEpGEpLCoBytesFromNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 4, 11, 1, 4), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoBytesFromNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoBytesFromNetwork.setDescription('This attribute counts the number of bytes received from the remote LCo via the network.')
mscMcsMgrDprsMcsEpGEpLCoPathTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 4, 264), )
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoPathTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoPathTable.setDescription('This attribute contains the trunk component names over which the path has been instantiated and the remote end point name terminating the path.')
mscMcsMgrDprsMcsEpGEpLCoPathEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 4, 264, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-McsMgrMIB", "mscMcsMgrIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGEpIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGEpLCoIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGEpLCoPathValue"))
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoPathEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoPathEntry.setDescription('An entry in the mscMcsMgrDprsMcsEpGEpLCoPathTable.')
mscMcsMgrDprsMcsEpGEpLCoPathValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 4, 264, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoPathValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpLCoPathValue.setDescription('This variable represents both the value and the index for the mscMcsMgrDprsMcsEpGEpLCoPathTable.')
mscMcsMgrDprsMcsEpGEpCac = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 5))
mscMcsMgrDprsMcsEpGEpCacRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 5, 1), )
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacRowStatusTable.setDescription('This entry controls the addition and deletion of mscMcsMgrDprsMcsEpGEpCac components.')
mscMcsMgrDprsMcsEpGEpCacRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 5, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-McsMgrMIB", "mscMcsMgrIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGEpIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGEpCacIndex"))
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacRowStatusEntry.setDescription('A single entry in the table represents a single mscMcsMgrDprsMcsEpGEpCac component.')
mscMcsMgrDprsMcsEpGEpCacRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 5, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscMcsMgrDprsMcsEpGEpCac components. These components can be added and deleted.')
mscMcsMgrDprsMcsEpGEpCacComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 5, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscMcsMgrDprsMcsEpGEpCacStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 5, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacStorageType.setDescription('This variable represents the storage type value for the mscMcsMgrDprsMcsEpGEpCac tables.')
mscMcsMgrDprsMcsEpGEpCacIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 5, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacIndex.setDescription('This variable represents the index for the mscMcsMgrDprsMcsEpGEpCac tables.')
mscMcsMgrDprsMcsEpGEpCacOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 5, 10), )
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacOperTable.setDescription('This group contains the operational attributes of the CallAdmissionControl component.')
mscMcsMgrDprsMcsEpGEpCacOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 5, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-McsMgrMIB", "mscMcsMgrIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGEpIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGEpCacIndex"))
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacOperEntry.setDescription('An entry in the mscMcsMgrDprsMcsEpGEpCacOperTable.')
mscMcsMgrDprsMcsEpGEpCacEffectiveBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 5, 10, 1, 1), Unsigned64().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacEffectiveBandwidth.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacEffectiveBandwidth.setDescription("This attribute indicates the total bandwidth which is used as the bandwidth pool for tracking call admission requests. On the originating End Point the effectiveBandwidth is equal to the forwardBandwidth attribute specified in this End Point's Epd component multiplied by the forwardOversubFactor specified in the Cacd subcomponent. On the terminating End Point the effectiveBandwidth is equal to the reverseBandwidth attribute specified in this End Point's Epd component multiplied by this End Point's reverseOversubFactor specified in the Cacd subcomponent. This value indicates CIR bandwidth when the cacType attribute of the Cacd subcomponent is specified as cir. This value indicates EIR bandwidth when the cacType attribute of the Cacd subcomponent is specified as eir.")
mscMcsMgrDprsMcsEpGEpCacEffectiveBandwidthAvailable = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 5, 10, 1, 2), Unsigned64().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacEffectiveBandwidthAvailable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacEffectiveBandwidthAvailable.setDescription('This attribute indicates the effective bandwidth that is still available in the bandwidth pool for use by Frame Relay service connections requesting bandwidth. This value is the amount of effectiveBandwith less the amount reserved by Frame Relay service connections that have been admitted. To display the specific Frame Relay service connections which have successfully completed call admission and to see the amount of bandwidth they have reserved, the network operator can use the following command: Display McsMgr DprsMcsEpG/n Ep/n Connection/* This value indicates CIR bandwidth when the cacType attribute of the Cac subcomponent is specified as cir. This value indicates EIR bandwidth when the cacType attribute of the Cac subcomponent is specified as eir.')
mscMcsMgrDprsMcsEpGEpCacNumberOfCallsActive = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 5, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 512))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacNumberOfCallsActive.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacNumberOfCallsActive.setDescription('This attribute indicates the total number of Frame Relay service connections which have successfully completed call admission and are currently in service. To display the specific Frame Relay service connections which have successfully completed call admission and to see the amount of bandwidth they have reserved the network operator can use the following command: Display McsMgr DprsMcsEpG/n Ep/n Connection/*')
mscMcsMgrDprsMcsEpGEpCacCacPolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 5, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("enforced", 0), ("monitored", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacCacPolicy.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacCacPolicy.setDescription('This attribute indicates the CAC policy in use at this end of the switched path. For the originating End Point this is the value specified by the forwardCacPolicy attribute of the Cacd subcomponent. For the terminating End Point this is the value specified by the reverseCacPolicy attribute of the Cacd subcomponent of the originating End Point at the other end of the switched path. To determine the component name of the originating End Point, the following command can be used: Display McsMgr DprsMcsEpG/n Ep/n remoteComponentName')
mscMcsMgrDprsMcsEpGEpCacCacType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 5, 10, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("eir", 0), ("cir", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacCacType.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacCacType.setDescription('This attribute indicates the CAC type in use at this end of the switched path. For the originating End Point this is the value specified by the forwardCacType attribute of the Cacd subcomponent. For the terminating End Point this is the value specified by the reverseCacType attribute of the Cacd subcomponent of the originating End Point at the other end of the switched path.To determine the component name of the originating End Point, the following command can be used: Display McsMgr DprsMcsEpG/n Ep/n remoteComponentName')
mscMcsMgrDprsMcsEpGEpCacMaximumSvcBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 5, 10, 1, 6), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 155000000), ValueRangeConstraint(155000001, 155000001), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacMaximumSvcBandwidth.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacMaximumSvcBandwidth.setDescription('This attribute indicates the largest amount of SVC bandwidth which can be reserved for a single Frame Relay service connection using the switched path. For the originating End Point this is the value specified by the forwardMaximumSvcBw attribute of the Cacd subcomponent. For the terminating End Point this is the value specified by the reverseMaximumSvcBw attribute of the Cacd subcomponent by the originating End Point at the other end of the switched path. This value indicates CIR bandwidth when the cacType attribute of the Cac subcomponent is cir. This value indicates EIR bandwidth when the cacType attribute of the Cac subcomponent is eir. The value of noMaximum for this attribute indicates that this attribute has either been provisioned not to have a maximum value or that the cacPolicy is monitored. VALUES ( 155000001 = noMaximum )')
mscMcsMgrDprsMcsEpGEpCacMaximumPvcBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 5, 10, 1, 7), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 155000000), ValueRangeConstraint(155000001, 155000001), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacMaximumPvcBandwidth.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacMaximumPvcBandwidth.setDescription('This attribute indicates the largest amount of PVC bandwidth allowed to be reserved for a single Frame Relay service connection using the switched path. For the originating End Point this is the value specified by the forwardMaximumSvcBw attribute of the Cacd subcomponent. For the terminating End Point this is the value specified by the reverseMaximumSvcBw attribute of the Cacd subcomponent by the originating End Point at the other end of the switched path. This value indicates CIR bandwidth when the cacType attribute of the Cac subcomponent is cir. This value indicates EIR bandwidth when the cacType attribute of the Cac subcomponent is eir. The value of noMaximum for this attribute indicates that this attribute has either been provisioned not to have a maximum value or that the cacPolicy is monitored. VALUES ( 155000001 = noMaximum )')
mscMcsMgrDprsMcsEpGEpCacNumberOfCacFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 5, 10, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacNumberOfCacFailures.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacNumberOfCacFailures.setDescription('This attribute counts the total number of Frame Relay service connections which have failed to successfully complete call admission on the given switched path. This number does not increase if the cacPolicy attribute of the McsMgr DprsMcsEpG/n EndPoint/m Cac component is set to monitored. This value wraps back to 0 when its maximum value is exceeded.')
mscMcsMgrDprsMcsEpGEpCacLastFailedFrDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 5, 10, 1, 9), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacLastFailedFrDlci.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacLastFailedFrDlci.setDescription('This attribute indicates the component name of the last Frame Relay service connection which did not successfully complete call admission. This value is empty if no call admission failure has occurred.')
mscMcsMgrDprsMcsEpGEpCacLastFailedReason = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 5, 10, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("none", 0), ("noBandwidthAvailable", 1), ("maxSvcExceeded", 2), ("maxPvcExceeded", 3), ("epCacUnavailable", 4), ("maxConsExceeded", 5))).clone('none')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacLastFailedReason.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacLastFailedReason.setDescription("This attribute indicates the reason for the failure of the last Frame Relay service connection's attempt at call admission. none indicates that there has been no call admission failure. noBandwidthAvailable indicates that there was insufficient effectiveBandwidthAvailable to admit the Frame Relay service connection. maxSvcExceeded indicates that an SVC was attempting to reserve more bandwidth than that specified by maximumSvcBandwidth attribute. maxPvcExceeded indicates that an SVC was attempting to reserve more bandwidth than that specified by maximumPvcBandwidth attribute. endPointCacUnavailable indicates that the End Point was not in a state in which it could process the call admission request. The Frame Relay service should attempt call admission again after a suitable backoff period. maxConsExceeded indicates that 512 call admission connections have already been accepted on this End Point.")
mscMcsMgrDprsMcsEpGEpCacOverSubscriptionFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 5, 10, 1, 11), FixedPoint2().subtype(subtypeSpec=ValueRangeConstraint(0, 10000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacOverSubscriptionFactor.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacOverSubscriptionFactor.setDescription('This attribute indicates the oversubscription factor that is applied to the forward and reverse bandwidth attributes of the parent component to determine the effectiveBandwidth. On the originating side of the switched path this value is equal to the forwardOsFactor specified in the Cacd subcomponent. On the terminating side of the switched path this value is equal to the reverseOsFactor attribute of the Cacd subcomponent at the originating end of the switched path.')
mscMcsMgrDprsMcsEpGEpCacAlarmThresholdTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 5, 802), )
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacAlarmThresholdTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacAlarmThresholdTable.setDescription('This attribute indicates the alarm threshold values that are used at this end of the switched path. On the originating end of the switch path these values are those specified by the forwardAlarmThresholds attribute of the Cacd subcomponent. On the terminating end of the switched path these values are those specified by the reverseAlarmThresholds attribute of the Cacd subcomponent on the originating end of the switched path')
mscMcsMgrDprsMcsEpGEpCacAlarmThresholdEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 5, 802, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-McsMgrMIB", "mscMcsMgrIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGEpIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGEpCacIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGEpCacAlarmThresholdIndex"))
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacAlarmThresholdEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacAlarmThresholdEntry.setDescription('An entry in the mscMcsMgrDprsMcsEpGEpCacAlarmThresholdTable.')
mscMcsMgrDprsMcsEpGEpCacAlarmThresholdIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 5, 802, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("minor", 0), ("major", 1), ("critical", 2))))
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacAlarmThresholdIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacAlarmThresholdIndex.setDescription('This variable represents the mscMcsMgrDprsMcsEpGEpCacAlarmThresholdTable specific index for the mscMcsMgrDprsMcsEpGEpCacAlarmThresholdTable.')
mscMcsMgrDprsMcsEpGEpCacAlarmThresholdValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 5, 802, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacAlarmThresholdValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacAlarmThresholdValue.setDescription('This variable represents an individual value for the mscMcsMgrDprsMcsEpGEpCacAlarmThresholdTable.')
mscMcsMgrDprsMcsEpGEpCacCacd = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 5, 2))
mscMcsMgrDprsMcsEpGEpCacCacdRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 5, 2, 1), )
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacCacdRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacCacdRowStatusTable.setDescription('This entry controls the addition and deletion of mscMcsMgrDprsMcsEpGEpCacCacd components.')
mscMcsMgrDprsMcsEpGEpCacCacdRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 5, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-McsMgrMIB", "mscMcsMgrIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGEpIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGEpCacIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGEpCacCacdIndex"))
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacCacdRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacCacdRowStatusEntry.setDescription('A single entry in the table represents a single mscMcsMgrDprsMcsEpGEpCacCacd component.')
mscMcsMgrDprsMcsEpGEpCacCacdRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 5, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacCacdRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacCacdRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscMcsMgrDprsMcsEpGEpCacCacd components. These components cannot be added nor deleted.')
mscMcsMgrDprsMcsEpGEpCacCacdComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 5, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacCacdComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacCacdComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscMcsMgrDprsMcsEpGEpCacCacdStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 5, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacCacdStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacCacdStorageType.setDescription('This variable represents the storage type value for the mscMcsMgrDprsMcsEpGEpCacCacd tables.')
mscMcsMgrDprsMcsEpGEpCacCacdIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 5, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacCacdIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacCacdIndex.setDescription('This variable represents the index for the mscMcsMgrDprsMcsEpGEpCacCacd tables.')
mscMcsMgrDprsMcsEpGEpCacCacdFrwdTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 5, 2, 10), )
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacCacdFrwdTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacCacdFrwdTable.setDescription('This group contains the parameters that are used to specify the call admission control characteristics for the given End Point in the forward direction.')
mscMcsMgrDprsMcsEpGEpCacCacdFrwdEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 5, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-McsMgrMIB", "mscMcsMgrIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGEpIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGEpCacIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGEpCacCacdIndex"))
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacCacdFrwdEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacCacdFrwdEntry.setDescription('An entry in the mscMcsMgrDprsMcsEpGEpCacCacdFrwdTable.')
mscMcsMgrDprsMcsEpGEpCacCacdForwardCacPolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 5, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("enforced", 0), ("monitored", 1))).clone('monitored')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacCacdForwardCacPolicy.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacCacdForwardCacPolicy.setDescription('This attribute specifies the call admission policy which is to be used in the forward direction. When this attribute is set to enforced, a Frame Relay service connection fails call admission if there is insufficient effectiveBandwidth available in the forward direction, the forwardMaximumSvcBw is exceeded, or the forwardMaximumPvcBw is exceeded. Call admission failure causes the Frame Relay service connection to clear. When this attribute is set to monitored no Frame Relay service call will ever fail call admission.')
mscMcsMgrDprsMcsEpGEpCacCacdForwardCacType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 5, 2, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("eir", 0), ("cir", 1))).clone('cir')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacCacdForwardCacType.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacCacdForwardCacType.setDescription('This attributes specifies whether the effectiveBandwidth in the forward direction is treated as eir or cir bandwidth.')
mscMcsMgrDprsMcsEpGEpCacCacdForwardOversubFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 5, 2, 10, 1, 3), FixedPoint2().subtype(subtypeSpec=ValueRangeConstraint(0, 10000)).clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacCacdForwardOversubFactor.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacCacdForwardOversubFactor.setDescription("This attribute specifies the level of oversubscription to be used when calculating the parent component's effectiveBandwidth in the forward direction. The forwardBandwidth attribute of the McsMgr DprsMcsEpG/m Ep/n Epd subcomponent is multiplied by this attribute to determine the effectiveBandwidth attribute.")
mscMcsMgrDprsMcsEpGEpCacCacdForwardMaximumSvcBw = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 5, 2, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 155000000), ValueRangeConstraint(155000001, 155000001), )).clone(155000001)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacCacdForwardMaximumSvcBw.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacCacdForwardMaximumSvcBw.setDescription('This attribute specifies the maximum bandwidth that can be reserved by a Frame Relay SVC. The forwardCacType parameter specifies if this value is to be treated as an EIR or CIR value. If this attribute is set to noMaximum or the forwardCacPolicy is set to monitored this check is not made. VALUES ( 155000001 = noMaximum )')
mscMcsMgrDprsMcsEpGEpCacCacdForwardMaximumPvcBw = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 5, 2, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 155000000), ValueRangeConstraint(155000001, 155000001), )).clone(155000001)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacCacdForwardMaximumPvcBw.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacCacdForwardMaximumPvcBw.setDescription('This attribute specifies the maximum bandwidth that can be reserved by a Frame Relay PVC. The forwardCacType parameter specifies if this value is to be treated as an EIR or CIR value. If this attribute is set to noMaximum or the forwardCacPolicy is set to monitored this check is not made. VALUES ( 155000001 = noMaximum )')
mscMcsMgrDprsMcsEpGEpCacCacdRvrsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 5, 2, 11), )
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacCacdRvrsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacCacdRvrsTable.setDescription('This group contains the parameters that are used to specify the call admission control characteristics for the given End Point in the reverse direction.')
mscMcsMgrDprsMcsEpGEpCacCacdRvrsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 5, 2, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-McsMgrMIB", "mscMcsMgrIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGEpIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGEpCacIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGEpCacCacdIndex"))
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacCacdRvrsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacCacdRvrsEntry.setDescription('An entry in the mscMcsMgrDprsMcsEpGEpCacCacdRvrsTable.')
mscMcsMgrDprsMcsEpGEpCacCacdReverseCacPolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 5, 2, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("enforced", 0), ("monitored", 1), ("sameAsForward", 2))).clone('sameAsForward')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacCacdReverseCacPolicy.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacCacdReverseCacPolicy.setDescription('This attribute is used to specify the CAC policy to be used in the reverse direction. When this attribute is set to enforced a Frame Relay service connection will fail call admission if there insufficient effectiveBandwidth in the reverse direction, the reverseMaximumSvcBw is exceeded or the reverseMaximumPvcBw is exceeded. Call admission failure causes the Frame Relay service connection clear. When this attribute is set to monitored no Frame Relay service call is ever rejected. When this attribute is set to sameAsForward the reverseCacPolicy is the same as that specified by the forwardCacPolicy attribute.')
mscMcsMgrDprsMcsEpGEpCacCacdReverseCacType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 5, 2, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("eir", 0), ("cir", 1), ("sameAsForward", 2))).clone('sameAsForward')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacCacdReverseCacType.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacCacdReverseCacType.setDescription('This attributes specifies if the effectiveBandwidth in the reverse direction is treated as eir or cir bandwidth. When this attribute is set to sameAsForward the reverseCacType is the same as that specified by the forwardCacType attribute.')
mscMcsMgrDprsMcsEpGEpCacCacdReverseCacOverSub = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 5, 2, 11, 1, 3), FixedPoint2().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 10000), ValueRangeConstraint(10100, 10100), )).clone(10100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacCacdReverseCacOverSub.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacCacdReverseCacOverSub.setDescription("This attribute specifies the level of over subscription to be used when calculating the parent component's effectiveBandwidth in the reverse direction. The reverseBandwidth attribute of the McsMgr DprsMcsEpG/m Ep/ n Epd subcomponent is multiplied by this attribute to determine the effectiveBandwidth in the reverse direction. When this attribute is set to sameAsForward the reverseCacOverSub is the same as that specified by the forwardCacOverSub attribute. VALUES ( 10100 = sameAsForward )")
mscMcsMgrDprsMcsEpGEpCacCacdReverseMaxSvcBw = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 5, 2, 11, 1, 4), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 155000000), ValueRangeConstraint(155000001, 155000001), ValueRangeConstraint(155000002, 155000002), )).clone(155000002)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacCacdReverseMaxSvcBw.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacCacdReverseMaxSvcBw.setDescription('This attribute specifies the maximum bandwidth that can be reserved by a Frame Relay SVC. The reverseCacType parameter specifies if this value is to be treated as an EIR or CIR value. If the reverseCacPolicy is set to monitored or the value of this attribute is set to noMaximum this check is not made. When this attribute is set to sameAsForward the reverseMaxSvcBw is the same as that specified by the forwardMaxSvcBw attribute. VALUES ( 155000001 = noMaximum 155000002 = sameAsForward )')
mscMcsMgrDprsMcsEpGEpCacCacdReverseMaxPvcBw = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 5, 2, 11, 1, 5), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 155000000), ValueRangeConstraint(155000001, 155000001), ValueRangeConstraint(155000002, 155000002), )).clone(155000002)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacCacdReverseMaxPvcBw.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacCacdReverseMaxPvcBw.setDescription('This attribute specifies the maximum bandwidth that can be reserved by a Frame Relay PVC. The reverseCacType parameter specifies if this value is to be treated as an EIR or CIR value. If the reverseCacPolicy is set to monitored or the value of this attribute is set to noMaximum this check is not made. When this attribute is set to sameAsForward the reverseMaxPvcBw is the same as that specified by the forwardMaxPvcBw attribute. VALUES ( 155000001 = noMaximum 155000002 = sameAsForward )')
mscMcsMgrDprsMcsEpGEpCacCacdFAlarmThreshTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 5, 2, 800), )
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacCacdFAlarmThreshTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacCacdFAlarmThreshTable.setDescription('This attribute specifies the bandwidth reservation level at which the minor, major, and critical alarms are raised at in the forward direction. By default all alarms are set to 0 disables alarm generation. Each of these threshold alarms is cleared when the reservation level falls 10% below the respective threshold level.')
mscMcsMgrDprsMcsEpGEpCacCacdFAlarmThreshEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 5, 2, 800, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-McsMgrMIB", "mscMcsMgrIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGEpIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGEpCacIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGEpCacCacdIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGEpCacCacdFAlarmThreshIndex"))
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacCacdFAlarmThreshEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacCacdFAlarmThreshEntry.setDescription('An entry in the mscMcsMgrDprsMcsEpGEpCacCacdFAlarmThreshTable.')
mscMcsMgrDprsMcsEpGEpCacCacdFAlarmThreshIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 5, 2, 800, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("minor", 0), ("major", 1), ("critical", 2))))
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacCacdFAlarmThreshIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacCacdFAlarmThreshIndex.setDescription('This variable represents the mscMcsMgrDprsMcsEpGEpCacCacdFAlarmThreshTable specific index for the mscMcsMgrDprsMcsEpGEpCacCacdFAlarmThreshTable.')
mscMcsMgrDprsMcsEpGEpCacCacdFAlarmThreshValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 5, 2, 800, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacCacdFAlarmThreshValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacCacdFAlarmThreshValue.setDescription('This variable represents an individual value for the mscMcsMgrDprsMcsEpGEpCacCacdFAlarmThreshTable.')
mscMcsMgrDprsMcsEpGEpCacCacdRAlarmThreshTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 5, 2, 801), )
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacCacdRAlarmThreshTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacCacdRAlarmThreshTable.setDescription('This attribute specifies the reservation level at which the minor, major, and critical alarms are raised in the reverse direction. By default all alarms are set to 0 which is the off setting. Each of these threshold alarms are cleared when the reservation level falls 10% below each respective threshold level.')
mscMcsMgrDprsMcsEpGEpCacCacdRAlarmThreshEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 5, 2, 801, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-McsMgrMIB", "mscMcsMgrIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGEpIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGEpCacIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGEpCacCacdIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGEpCacCacdRAlarmThreshIndex"))
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacCacdRAlarmThreshEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacCacdRAlarmThreshEntry.setDescription('An entry in the mscMcsMgrDprsMcsEpGEpCacCacdRAlarmThreshTable.')
mscMcsMgrDprsMcsEpGEpCacCacdRAlarmThreshIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 5, 2, 801, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("minor", 0), ("major", 1), ("critical", 2))))
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacCacdRAlarmThreshIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacCacdRAlarmThreshIndex.setDescription('This variable represents the mscMcsMgrDprsMcsEpGEpCacCacdRAlarmThreshTable specific index for the mscMcsMgrDprsMcsEpGEpCacCacdRAlarmThreshTable.')
mscMcsMgrDprsMcsEpGEpCacCacdRAlarmThreshValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 5, 2, 801, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacCacdRAlarmThreshValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpCacCacdRAlarmThreshValue.setDescription('This variable represents an individual value for the mscMcsMgrDprsMcsEpGEpCacCacdRAlarmThreshTable.')
mscMcsMgrDprsMcsEpGEpCon = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 6))
mscMcsMgrDprsMcsEpGEpConRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 6, 1), )
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpConRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpConRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of mscMcsMgrDprsMcsEpGEpCon components.')
mscMcsMgrDprsMcsEpGEpConRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 6, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-McsMgrMIB", "mscMcsMgrIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGEpIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGEpConIndex"))
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpConRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpConRowStatusEntry.setDescription('A single entry in the table represents a single mscMcsMgrDprsMcsEpGEpCon component.')
mscMcsMgrDprsMcsEpGEpConRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 6, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpConRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpConRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscMcsMgrDprsMcsEpGEpCon components. These components cannot be added nor deleted.')
mscMcsMgrDprsMcsEpGEpConComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 6, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpConComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpConComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscMcsMgrDprsMcsEpGEpConStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 6, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpConStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpConStorageType.setDescription('This variable represents the storage type value for the mscMcsMgrDprsMcsEpGEpCon tables.')
mscMcsMgrDprsMcsEpGEpConIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 6, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 512)))
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpConIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpConIndex.setDescription('This variable represents the index for the mscMcsMgrDprsMcsEpGEpCon tables.')
mscMcsMgrDprsMcsEpGEpConOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 6, 10), )
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpConOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpConOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains the operational attributes of the Connection component.')
mscMcsMgrDprsMcsEpGEpConOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 6, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-McsMgrMIB", "mscMcsMgrIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGEpIndex"), (0, "Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", "mscMcsMgrDprsMcsEpGEpConIndex"))
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpConOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpConOperEntry.setDescription('An entry in the mscMcsMgrDprsMcsEpGEpConOperTable.')
mscMcsMgrDprsMcsEpGEpConFrameRelayDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 6, 10, 1, 1), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpConFrameRelayDlci.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpConFrameRelayDlci.setDescription('This attribute indicates the DLCI of a Frame Relay service connection that has successfully completed call admission and has reserved bandwidth on this switched path.')
mscMcsMgrDprsMcsEpGEpConReservedBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 122, 2, 3, 6, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 155000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpConReservedBandwidth.setStatus('mandatory')
if mibBuilder.loadTexts: mscMcsMgrDprsMcsEpGEpConReservedBandwidth.setDescription('This attribute indicates the amount of bandwidth reserved by the given Frame Relay service connection. To determine if this is EIR or CIR bandwidth see the cacType attribute for this EndPoint.')
dprsMcsEpGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 125, 1))
dprsMcsEpGroupCA = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 125, 1, 1))
dprsMcsEpGroupCA02 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 125, 1, 1, 3))
dprsMcsEpGroupCA02A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 125, 1, 1, 3, 2))
dprsMcsEpCapabilities = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 125, 3))
dprsMcsEpCapabilitiesCA = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 125, 3, 1))
dprsMcsEpCapabilitiesCA02 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 125, 3, 1, 3))
dprsMcsEpCapabilitiesCA02A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 125, 3, 1, 3, 2))
mibBuilder.exportSymbols("Nortel-MsCarrier-MscPassport-DprsMcsEpMIB", mscMcsMgrDprsMcsEpGEpCacRowStatus=mscMcsMgrDprsMcsEpGEpCacRowStatus, mscMcsMgrDprsMcsEpGEpAtmConComponentName=mscMcsMgrDprsMcsEpGEpAtmConComponentName, mscMcsMgrDprsMcsEpGEpEpDBandwidth=mscMcsMgrDprsMcsEpGEpEpDBandwidth, mscMcsMgrDprsMcsEpGEpLCoPathDataTable=mscMcsMgrDprsMcsEpGEpLCoPathDataTable, mscMcsMgrDprsMcsEpGEpCacEffectiveBandwidth=mscMcsMgrDprsMcsEpGEpCacEffectiveBandwidth, mscMcsMgrDprsMcsEpGEpOctetsFromMcsValue=mscMcsMgrDprsMcsEpGEpOctetsFromMcsValue, mscMcsMgrDprsMcsEpGEpCacStorageType=mscMcsMgrDprsMcsEpGEpCacStorageType, mscMcsMgrDprsMcsEpGEpLCoRequiredRxBandwidth=mscMcsMgrDprsMcsEpGEpLCoRequiredRxBandwidth, dprsMcsEpGroupCA02=dprsMcsEpGroupCA02, mscMcsMgrDprsMcsEpGIndex=mscMcsMgrDprsMcsEpGIndex, mscMcsMgrDprsMcsEpGEpCacAlarmThresholdTable=mscMcsMgrDprsMcsEpGEpCacAlarmThresholdTable, mscMcsMgrDprsMcsEpGAddrRemoteAddress=mscMcsMgrDprsMcsEpGAddrRemoteAddress, mscMcsMgrDprsMcsEpGEpEpDTransportConnectionPreference=mscMcsMgrDprsMcsEpGEpEpDTransportConnectionPreference, dprsMcsEpMIB=dprsMcsEpMIB, mscMcsMgrDprsMcsEpGEpProceduralStatus=mscMcsMgrDprsMcsEpGEpProceduralStatus, mscMcsMgrDprsMcsEpGEpCacCacdRvrsTable=mscMcsMgrDprsMcsEpGEpCacCacdRvrsTable, mscMcsMgrDprsMcsEpGEpAtmConRowStatus=mscMcsMgrDprsMcsEpGEpAtmConRowStatus, mscMcsMgrDprsMcsEpGEpCacOperTable=mscMcsMgrDprsMcsEpGEpCacOperTable, mscMcsMgrDprsMcsEpGAddrRowStatusTable=mscMcsMgrDprsMcsEpGAddrRowStatusTable, mscMcsMgrDprsMcsEpGEpLCoIndex=mscMcsMgrDprsMcsEpGEpLCoIndex, mscMcsMgrDprsMcsEpGEpLCoPathValue=mscMcsMgrDprsMcsEpGEpLCoPathValue, mscMcsMgrDprsMcsEpGEpCacLastFailedReason=mscMcsMgrDprsMcsEpGEpCacLastFailedReason, mscMcsMgrDprsMcsEpGEpCacCacdIndex=mscMcsMgrDprsMcsEpGEpCacCacdIndex, mscMcsMgrDprsMcsEpGEpRemoteModuleId=mscMcsMgrDprsMcsEpGEpRemoteModuleId, mscMcsMgrDprsMcsEpGEpStateEntry=mscMcsMgrDprsMcsEpGEpStateEntry, mscMcsMgrDprsMcsEpGEpOperTable=mscMcsMgrDprsMcsEpGEpOperTable, mscMcsMgrDprsMcsEpGEpCacCacdReverseCacPolicy=mscMcsMgrDprsMcsEpGEpCacCacdReverseCacPolicy, mscMcsMgrDprsMcsEpGEpLCo=mscMcsMgrDprsMcsEpGEpLCo, mscMcsMgrDprsMcsEpGEpCacNumberOfCacFailures=mscMcsMgrDprsMcsEpGEpCacNumberOfCacFailures, mscMcsMgrDprsMcsEpGEpConRowStatus=mscMcsMgrDprsMcsEpGEpConRowStatus, mscMcsMgrDprsMcsEpGEpLCoRowStatusEntry=mscMcsMgrDprsMcsEpGEpLCoRowStatusEntry, mscMcsMgrDprsMcsEpGEpCacCacdForwardCacPolicy=mscMcsMgrDprsMcsEpGEpCacCacdForwardCacPolicy, mscMcsMgrDprsMcsEpGEpCacComponentName=mscMcsMgrDprsMcsEpGEpCacComponentName, mscMcsMgrDprsMcsEpGEpLastTransportConnectionClearCause=mscMcsMgrDprsMcsEpGEpLastTransportConnectionClearCause, mscMcsMgrDprsMcsEpGEpAtmConOperTable=mscMcsMgrDprsMcsEpGEpAtmConOperTable, mscMcsMgrDprsMcsEpGEpOperEntry=mscMcsMgrDprsMcsEpGEpOperEntry, mscMcsMgrDprsMcsEpGAssociatedEpGroupName=mscMcsMgrDprsMcsEpGAssociatedEpGroupName, mscMcsMgrDprsMcsEpGEpRowStatusEntry=mscMcsMgrDprsMcsEpGEpRowStatusEntry, mscMcsMgrDprsMcsEpGEpEpDIndex=mscMcsMgrDprsMcsEpGEpEpDIndex, mscMcsMgrDprsMcsEpGEpCacCacdRowStatusEntry=mscMcsMgrDprsMcsEpGEpCacCacdRowStatusEntry, mscMcsMgrDprsMcsEpGEpCacCacPolicy=mscMcsMgrDprsMcsEpGEpCacCacPolicy, mscMcsMgrDprsMcsEpGRemoteAddress=mscMcsMgrDprsMcsEpGRemoteAddress, mscMcsMgrDprsMcsEpGEpConFrameRelayDlci=mscMcsMgrDprsMcsEpGEpConFrameRelayDlci, mscMcsMgrDprsMcsEpGOperEntry=mscMcsMgrDprsMcsEpGOperEntry, mscMcsMgrDprsMcsEpGEpCacCacd=mscMcsMgrDprsMcsEpGEpCacCacd, mscMcsMgrDprsMcsEpGEpAtmConIndex=mscMcsMgrDprsMcsEpGEpAtmConIndex, mscMcsMgrDprsMcsEpGEpOperationalState=mscMcsMgrDprsMcsEpGEpOperationalState, mscMcsMgrDprsMcsEpGEpCacCacdRAlarmThreshEntry=mscMcsMgrDprsMcsEpGEpCacCacdRAlarmThreshEntry, mscMcsMgrDprsMcsEpGEpEpDRowStatusTable=mscMcsMgrDprsMcsEpGEpEpDRowStatusTable, mscMcsMgrDprsMcsEpGEpCacMaximumSvcBandwidth=mscMcsMgrDprsMcsEpGEpCacMaximumSvcBandwidth, mscMcsMgrDprsMcsEpGRowStatusTable=mscMcsMgrDprsMcsEpGRowStatusTable, mscMcsMgrDprsMcsEpGEpEpDProvTable=mscMcsMgrDprsMcsEpGEpEpDProvTable, mscMcsMgrDprsMcsEpGEpLCoStatsTable=mscMcsMgrDprsMcsEpGEpLCoStatsTable, mscMcsMgrDprsMcsEpGEpCacLastFailedFrDlci=mscMcsMgrDprsMcsEpGEpCacLastFailedFrDlci, mscMcsMgrDprsMcsEpGEpLCoPathDataEntry=mscMcsMgrDprsMcsEpGEpLCoPathDataEntry, dprsMcsEpGroupCA02A=dprsMcsEpGroupCA02A, mscMcsMgrDprsMcsEpGRowStatus=mscMcsMgrDprsMcsEpGRowStatus, mscMcsMgrDprsMcsEpGEpServiceCategory=mscMcsMgrDprsMcsEpGEpServiceCategory, mscMcsMgrDprsMcsEpGEpLCoPktsFromNetwork=mscMcsMgrDprsMcsEpGEpLCoPktsFromNetwork, mscMcsMgrDprsMcsEpGEpAtmConRowStatusTable=mscMcsMgrDprsMcsEpGEpAtmConRowStatusTable, mscMcsMgrDprsMcsEpGEpCacCacdRvrsEntry=mscMcsMgrDprsMcsEpGEpCacCacdRvrsEntry, mscMcsMgrDprsMcsEpGEpConnectionTransferPriority=mscMcsMgrDprsMcsEpGEpConnectionTransferPriority, mscMcsMgrDprsMcsEpGEpConRowStatusEntry=mscMcsMgrDprsMcsEpGEpConRowStatusEntry, mscMcsMgrDprsMcsEpGEpEpDConnectionTransferPriority=mscMcsMgrDprsMcsEpGEpEpDConnectionTransferPriority, dprsMcsEpCapabilitiesCA02A=dprsMcsEpCapabilitiesCA02A, mscMcsMgrDprsMcsEpGEpLCoRoundTripDelay=mscMcsMgrDprsMcsEpGEpLCoRoundTripDelay, mscMcsMgrDprsMcsEpGOperTable=mscMcsMgrDprsMcsEpGOperTable, mscMcsMgrDprsMcsEpGEpPktFromMcsIndex=mscMcsMgrDprsMcsEpGEpPktFromMcsIndex, mscMcsMgrDprsMcsEpGEpPktFromMcsEntry=mscMcsMgrDprsMcsEpGEpPktFromMcsEntry, mscMcsMgrDprsMcsEpGEpCacCacdForwardOversubFactor=mscMcsMgrDprsMcsEpGEpCacCacdForwardOversubFactor, mscMcsMgrDprsMcsEpGEpLCoReasonForNoRoute=mscMcsMgrDprsMcsEpGEpLCoReasonForNoRoute, mscMcsMgrDprsMcsEpGEpCac=mscMcsMgrDprsMcsEpGEpCac, mscMcsMgrDprsMcsEpGEpLCoPathFailureCount=mscMcsMgrDprsMcsEpGEpLCoPathFailureCount, mscMcsMgrDprsMcsEpGEpCacCacdFAlarmThreshTable=mscMcsMgrDprsMcsEpGEpCacCacdFAlarmThreshTable, mscMcsMgrDprsMcsEpGEpCacCacdForwardMaximumPvcBw=mscMcsMgrDprsMcsEpGEpCacCacdForwardMaximumPvcBw, mscMcsMgrDprsMcsEpGEpLCoBytesFromNetwork=mscMcsMgrDprsMcsEpGEpLCoBytesFromNetwork, mscMcsMgrDprsMcsEpGEpCacCacdReverseMaxPvcBw=mscMcsMgrDprsMcsEpGEpCacCacdReverseMaxPvcBw, mscMcsMgrDprsMcsEpGEpRemoteRoutingId=mscMcsMgrDprsMcsEpGEpRemoteRoutingId, mscMcsMgrDprsMcsEpGEpRowStatusTable=mscMcsMgrDprsMcsEpGEpRowStatusTable, mscMcsMgrDprsMcsEpGEpLCoOptimization=mscMcsMgrDprsMcsEpGEpLCoOptimization, mscMcsMgrDprsMcsEpGEpCacCacdRAlarmThreshTable=mscMcsMgrDprsMcsEpGEpCacCacdRAlarmThreshTable, mscMcsMgrDprsMcsEpGEpLCoPathTable=mscMcsMgrDprsMcsEpGEpLCoPathTable, mscMcsMgrDprsMcsEpGEpCacOperEntry=mscMcsMgrDprsMcsEpGEpCacOperEntry, mscMcsMgrDprsMcsEpGEpCacCacdFAlarmThreshIndex=mscMcsMgrDprsMcsEpGEpCacCacdFAlarmThreshIndex, mscMcsMgrDprsMcsEpGEpLCoSetupPriority=mscMcsMgrDprsMcsEpGEpLCoSetupPriority, mscMcsMgrDprsMcsEpGEpAtmConNextHop=mscMcsMgrDprsMcsEpGEpAtmConNextHop, mscMcsMgrDprsMcsEpGEpOctetsFromMcsIndex=mscMcsMgrDprsMcsEpGEpOctetsFromMcsIndex, mscMcsMgrDprsMcsEpGEpCacCacdFAlarmThreshEntry=mscMcsMgrDprsMcsEpGEpCacCacdFAlarmThreshEntry, mscMcsMgrDprsMcsEpGEpCacRowStatusEntry=mscMcsMgrDprsMcsEpGEpCacRowStatusEntry, mscMcsMgrDprsMcsEpGEpPktDiscCongestedFromMcsValue=mscMcsMgrDprsMcsEpGEpPktDiscCongestedFromMcsValue, mscMcsMgrDprsMcsEpGEpOctetsFromMcsEntry=mscMcsMgrDprsMcsEpGEpOctetsFromMcsEntry, mscMcsMgrDprsMcsEpGEpEpDProfile=mscMcsMgrDprsMcsEpGEpEpDProfile, dprsMcsEpCapabilities=dprsMcsEpCapabilities, mscMcsMgrDprsMcsEpGEpEpDComponentName=mscMcsMgrDprsMcsEpGEpEpDComponentName, mscMcsMgrDprsMcsEpGEpLCoRequiredTxBandwidth=mscMcsMgrDprsMcsEpGEpLCoRequiredTxBandwidth, mscMcsMgrDprsMcsEpGEpPktFromMcsTable=mscMcsMgrDprsMcsEpGEpPktFromMcsTable, mscMcsMgrDprsMcsEpGEpPktDiscCongestedFromMcsEntry=mscMcsMgrDprsMcsEpGEpPktDiscCongestedFromMcsEntry, mscMcsMgrDprsMcsEpGEpPktDiscCongestedFromMcsIndex=mscMcsMgrDprsMcsEpGEpPktDiscCongestedFromMcsIndex, mscMcsMgrDprsMcsEpGEpEpDForwardBandwidth=mscMcsMgrDprsMcsEpGEpEpDForwardBandwidth, mscMcsMgrDprsMcsEpGEpLCoCostMetric=mscMcsMgrDprsMcsEpGEpLCoCostMetric, mscMcsMgrDprsMcsEpGEpCacCacdReverseCacOverSub=mscMcsMgrDprsMcsEpGEpCacCacdReverseCacOverSub, mscMcsMgrDprsMcsEpGEpLCoComponentName=mscMcsMgrDprsMcsEpGEpLCoComponentName, mscMcsMgrDprsMcsEpGEpLCoStatsEntry=mscMcsMgrDprsMcsEpGEpLCoStatsEntry, mscMcsMgrDprsMcsEpGEpLCoRequiredTrafficType=mscMcsMgrDprsMcsEpGEpLCoRequiredTrafficType, mscMcsMgrDprsMcsEpGEpCacIndex=mscMcsMgrDprsMcsEpGEpCacIndex, mscMcsMgrDprsMcsEpGAddr=mscMcsMgrDprsMcsEpGAddr, mscMcsMgrDprsMcsEpGAddrStorageType=mscMcsMgrDprsMcsEpGAddrStorageType, mscMcsMgrDprsMcsEpGEpSupportedTransferPriorities=mscMcsMgrDprsMcsEpGEpSupportedTransferPriorities, mscMcsMgrDprsMcsEpGEpCacCacdRowStatusTable=mscMcsMgrDprsMcsEpGEpCacCacdRowStatusTable, mscMcsMgrDprsMcsEpGEpLastTrConnDiagCode=mscMcsMgrDprsMcsEpGEpLastTrConnDiagCode, mscMcsMgrDprsMcsEpGEpCacCacdReverseMaxSvcBw=mscMcsMgrDprsMcsEpGEpCacCacdReverseMaxSvcBw, mscMcsMgrDprsMcsEpGEpCacCacdRAlarmThreshValue=mscMcsMgrDprsMcsEpGEpCacCacdRAlarmThreshValue, mscMcsMgrDprsMcsEpGEpStatsTable=mscMcsMgrDprsMcsEpGEpStatsTable, mscMcsMgrDprsMcsEpGEpPktDiscCongestedFromMcsTable=mscMcsMgrDprsMcsEpGEpPktDiscCongestedFromMcsTable, mscMcsMgrDprsMcsEpGEpUsageState=mscMcsMgrDprsMcsEpGEpUsageState, mscMcsMgrDprsMcsEpGEpCacAlarmThresholdEntry=mscMcsMgrDprsMcsEpGEpCacAlarmThresholdEntry, mscMcsMgrDprsMcsEpGEpControlStatus=mscMcsMgrDprsMcsEpGEpControlStatus, mscMcsMgrDprsMcsEpGEpCacCacdRowStatus=mscMcsMgrDprsMcsEpGEpCacCacdRowStatus, mscMcsMgrDprsMcsEpGEpUnknownStatus=mscMcsMgrDprsMcsEpGEpUnknownStatus, mscMcsMgrDprsMcsEpGEpLCoState=mscMcsMgrDprsMcsEpGEpLCoState, mscMcsMgrDprsMcsEpGEpCacRowStatusTable=mscMcsMgrDprsMcsEpGEpCacRowStatusTable, mscMcsMgrDprsMcsEpGEpCacMaximumPvcBandwidth=mscMcsMgrDprsMcsEpGEpCacMaximumPvcBandwidth, mscMcsMgrDprsMcsEpGEpEpD=mscMcsMgrDprsMcsEpGEpEpD, mscMcsMgrDprsMcsEpGEpType=mscMcsMgrDprsMcsEpGEpType, mscMcsMgrDprsMcsEpGEpCacOverSubscriptionFactor=mscMcsMgrDprsMcsEpGEpCacOverSubscriptionFactor, mscMcsMgrDprsMcsEpGEpAtmCon=mscMcsMgrDprsMcsEpGEpAtmCon, mscMcsMgrDprsMcsEpGEpCacCacdFrwdEntry=mscMcsMgrDprsMcsEpGEpCacCacdFrwdEntry, mscMcsMgrDprsMcsEpGAddrRowStatus=mscMcsMgrDprsMcsEpGAddrRowStatus, mscMcsMgrDprsMcsEpGEpLCoRowStatus=mscMcsMgrDprsMcsEpGEpLCoRowStatus, mscMcsMgrDprsMcsEpGEpRemoteComponentName=mscMcsMgrDprsMcsEpGEpRemoteComponentName, mscMcsMgrDprsMcsEpGEpRowStatus=mscMcsMgrDprsMcsEpGEpRowStatus, mscMcsMgrDprsMcsEpGEpLCoPathUpDateTime=mscMcsMgrDprsMcsEpGEpLCoPathUpDateTime, mscMcsMgrDprsMcsEpGEpEpDReverseBandwidth=mscMcsMgrDprsMcsEpGEpEpDReverseBandwidth, mscMcsMgrDprsMcsEpGEpReverseBandwidth=mscMcsMgrDprsMcsEpGEpReverseBandwidth, mscMcsMgrDprsMcsEpGEpLCoStorageType=mscMcsMgrDprsMcsEpGEpLCoStorageType, mscMcsMgrDprsMcsEpGEpLCoEnd=mscMcsMgrDprsMcsEpGEpLCoEnd, mscMcsMgrDprsMcsEpGEpCacCacdFAlarmThreshValue=mscMcsMgrDprsMcsEpGEpCacCacdFAlarmThreshValue, mscMcsMgrDprsMcsEpGEpConOperTable=mscMcsMgrDprsMcsEpGEpConOperTable, mscMcsMgrDprsMcsEpGEpCacEffectiveBandwidthAvailable=mscMcsMgrDprsMcsEpGEpCacEffectiveBandwidthAvailable, mscMcsMgrDprsMcsEpGAddrProvEntry=mscMcsMgrDprsMcsEpGAddrProvEntry, mscMcsMgrDprsMcsEpGEpConIndex=mscMcsMgrDprsMcsEpGEpConIndex, mscMcsMgrDprsMcsEpGEpEpDPorsManualPath=mscMcsMgrDprsMcsEpGEpEpDPorsManualPath, mscMcsMgrDprsMcsEpGEpStorageType=mscMcsMgrDprsMcsEpGEpStorageType, mscMcsMgrDprsMcsEpGEpOctetsFromMcsTable=mscMcsMgrDprsMcsEpGEpOctetsFromMcsTable, mscMcsMgrDprsMcsEpGAddrComponentName=mscMcsMgrDprsMcsEpGAddrComponentName, mscMcsMgrDprsMcsEpGEpAlarmStatus=mscMcsMgrDprsMcsEpGEpAlarmStatus, mscMcsMgrDprsMcsEpGEpConStorageType=mscMcsMgrDprsMcsEpGEpConStorageType, mscMcsMgrDprsMcsEpGEpLCoBumpPreference=mscMcsMgrDprsMcsEpGEpLCoBumpPreference, dprsMcsEpGroupCA=dprsMcsEpGroupCA, mscMcsMgrDprsMcsEpGEpComponentName=mscMcsMgrDprsMcsEpGEpComponentName, mscMcsMgrDprsMcsEpGEpCacCacdReverseCacType=mscMcsMgrDprsMcsEpGEpCacCacdReverseCacType, mscMcsMgrDprsMcsEpGEpCacAlarmThresholdValue=mscMcsMgrDprsMcsEpGEpCacAlarmThresholdValue, mscMcsMgrDprsMcsEpGEpAtmConStorageType=mscMcsMgrDprsMcsEpGEpAtmConStorageType, mscMcsMgrDprsMcsEpGComponentName=mscMcsMgrDprsMcsEpGComponentName, mscMcsMgrDprsMcsEpGEpEpDSupportedTransferPriorities=mscMcsMgrDprsMcsEpGEpEpDSupportedTransferPriorities, mscMcsMgrDprsMcsEpGEpLCoBytesToNetwork=mscMcsMgrDprsMcsEpGEpLCoBytesToNetwork, mscMcsMgrDprsMcsEpGEpIndex=mscMcsMgrDprsMcsEpGEpIndex, mscMcsMgrDprsMcsEpGEpPktFromMcsValue=mscMcsMgrDprsMcsEpGEpPktFromMcsValue, mscMcsMgrDprsMcsEpGEpCacCacdForwardCacType=mscMcsMgrDprsMcsEpGEpCacCacdForwardCacType, mscMcsMgrDprsMcsEpGAddrCommentText=mscMcsMgrDprsMcsEpGAddrCommentText, mscMcsMgrDprsMcsEpGEpStatsEntry=mscMcsMgrDprsMcsEpGEpStatsEntry, mscMcsMgrDprsMcsEpGEpCacCacdFrwdTable=mscMcsMgrDprsMcsEpGEpCacCacdFrwdTable, mscMcsMgrDprsMcsEpGEp=mscMcsMgrDprsMcsEpGEp, mscMcsMgrDprsMcsEpGEpEpDRowStatus=mscMcsMgrDprsMcsEpGEpEpDRowStatus, mscMcsMgrDprsMcsEpGRowStatusEntry=mscMcsMgrDprsMcsEpGRowStatusEntry, mscMcsMgrDprsMcsEpGEpConComponentName=mscMcsMgrDprsMcsEpGEpConComponentName, mscMcsMgrDprsMcsEpGEpLCoRequiredSecurity=mscMcsMgrDprsMcsEpGEpLCoRequiredSecurity, mscMcsMgrDprsMcsEpGEpLCoHoldingPriority=mscMcsMgrDprsMcsEpGEpLCoHoldingPriority, dprsMcsEpGroup=dprsMcsEpGroup, mscMcsMgrDprsMcsEpGEpLCoPathEntry=mscMcsMgrDprsMcsEpGEpLCoPathEntry, mscMcsMgrDprsMcsEpGEpCacCacType=mscMcsMgrDprsMcsEpGEpCacCacType, mscMcsMgrDprsMcsEpGAddrIndex=mscMcsMgrDprsMcsEpGAddrIndex, mscMcsMgrDprsMcsEpGEpAdminState=mscMcsMgrDprsMcsEpGEpAdminState, mscMcsMgrDprsMcsEpGEpEpDProvEntry=mscMcsMgrDprsMcsEpGEpEpDProvEntry, mscMcsMgrDprsMcsEpGEpCacCacdRAlarmThreshIndex=mscMcsMgrDprsMcsEpGEpCacCacdRAlarmThreshIndex, mscMcsMgrDprsMcsEpGEpConOperEntry=mscMcsMgrDprsMcsEpGEpConOperEntry, mscMcsMgrDprsMcsEpGEpStateTable=mscMcsMgrDprsMcsEpGEpStateTable, mscMcsMgrDprsMcsEpGEpForwardBandwith=mscMcsMgrDprsMcsEpGEpForwardBandwith, mscMcsMgrDprsMcsEpGEpStandbyStatus=mscMcsMgrDprsMcsEpGEpStandbyStatus, mscMcsMgrDprsMcsEpGEpSetupAttempts=mscMcsMgrDprsMcsEpGEpSetupAttempts, mscMcsMgrDprsMcsEpGEpAtmConRowStatusEntry=mscMcsMgrDprsMcsEpGEpAtmConRowStatusEntry, mscMcsMgrDprsMcsEpGEpLCoRowStatusTable=mscMcsMgrDprsMcsEpGEpLCoRowStatusTable, mscMcsMgrDprsMcsEpGEpLCoPathType=mscMcsMgrDprsMcsEpGEpLCoPathType, mscMcsMgrDprsMcsEpGEpLCoPktsToNetwork=mscMcsMgrDprsMcsEpGEpLCoPktsToNetwork, mscMcsMgrDprsMcsEpGEpAvailabilityStatus=mscMcsMgrDprsMcsEpGEpAvailabilityStatus, mscMcsMgrDprsMcsEpGEpLCoDiscardPriority=mscMcsMgrDprsMcsEpGEpLCoDiscardPriority, mscMcsMgrDprsMcsEpGEpCacCacdForwardMaximumSvcBw=mscMcsMgrDprsMcsEpGEpCacCacdForwardMaximumSvcBw, mscMcsMgrDprsMcsEpGEpLCoLastTearDownReason=mscMcsMgrDprsMcsEpGEpLCoLastTearDownReason, mscMcsMgrDprsMcsEpGEpConReservedBandwidth=mscMcsMgrDprsMcsEpGEpConReservedBandwidth, mscMcsMgrDprsMcsEpGEpLCoPathFailureAction=mscMcsMgrDprsMcsEpGEpLCoPathFailureAction, mscMcsMgrDprsMcsEpGEpLCoRetryCount=mscMcsMgrDprsMcsEpGEpLCoRetryCount, mscMcsMgrDprsMcsEpGEpEpDRowStatusEntry=mscMcsMgrDprsMcsEpGEpEpDRowStatusEntry, mscMcsMgrDprsMcsEpGEpEpDStorageType=mscMcsMgrDprsMcsEpGEpEpDStorageType, dprsMcsEpCapabilitiesCA02=dprsMcsEpCapabilitiesCA02, mscMcsMgrDprsMcsEpGStorageType=mscMcsMgrDprsMcsEpGStorageType, dprsMcsEpCapabilitiesCA=dprsMcsEpCapabilitiesCA, mscMcsMgrDprsMcsEpGEpCacAlarmThresholdIndex=mscMcsMgrDprsMcsEpGEpCacAlarmThresholdIndex, mscMcsMgrDprsMcsEpGEpLCoRequiredCustomerParameter=mscMcsMgrDprsMcsEpGEpLCoRequiredCustomerParameter, mscMcsMgrDprsMcsEpGEpBandwidth=mscMcsMgrDprsMcsEpGEpBandwidth, mscMcsMgrDprsMcsEpGEpCacNumberOfCallsActive=mscMcsMgrDprsMcsEpGEpCacNumberOfCallsActive, mscMcsMgrDprsMcsEpGEpLCoDelayMetric=mscMcsMgrDprsMcsEpGEpLCoDelayMetric, mscMcsMgrDprsMcsEpGEpLCoOverrideRemoteName=mscMcsMgrDprsMcsEpGEpLCoOverrideRemoteName, mscMcsMgrDprsMcsEpGEpConRowStatusTable=mscMcsMgrDprsMcsEpGEpConRowStatusTable, mscMcsMgrDprsMcsEpGAddrRowStatusEntry=mscMcsMgrDprsMcsEpGAddrRowStatusEntry, mscMcsMgrDprsMcsEpGEpLCoEmissionPriority=mscMcsMgrDprsMcsEpGEpLCoEmissionPriority, mscMcsMgrDprsMcsEpGEpAtmConOperEntry=mscMcsMgrDprsMcsEpGEpAtmConOperEntry, mscMcsMgrDprsMcsEpG=mscMcsMgrDprsMcsEpG, mscMcsMgrDprsMcsEpGEpPktDiscErroredFromMcs=mscMcsMgrDprsMcsEpGEpPktDiscErroredFromMcs, mscMcsMgrDprsMcsEpGEpCacCacdStorageType=mscMcsMgrDprsMcsEpGEpCacCacdStorageType, mscMcsMgrDprsMcsEpGEpCacCacdComponentName=mscMcsMgrDprsMcsEpGEpCacCacdComponentName, mscMcsMgrDprsMcsEpGAddrProvTable=mscMcsMgrDprsMcsEpGAddrProvTable, mscMcsMgrDprsMcsEpGEpCon=mscMcsMgrDprsMcsEpGEpCon, mscMcsMgrDprsMcsEpGEpLCoPermittedTrunkTypes=mscMcsMgrDprsMcsEpGEpLCoPermittedTrunkTypes)

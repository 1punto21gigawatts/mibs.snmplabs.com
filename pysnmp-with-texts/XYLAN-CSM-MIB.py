#
# PySNMP MIB module XYLAN-CSM-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/XYLAN-CSM-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:44:56 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, SingleValueConstraint, ValueSizeConstraint, ConstraintsUnion, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsUnion", "ConstraintsIntersection")
ifIndex, = mibBuilder.importSymbols("IF-MIB", "ifIndex")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
MibScalar, MibTable, MibTableRow, MibTableColumn, Counter32, Integer32, Unsigned32, Counter64, ObjectIdentity, IpAddress, NotificationType, MibIdentifier, Gauge32, iso, Bits, ModuleIdentity, TimeTicks = mibBuilder.importSymbols("SNMPv2-SMI", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter32", "Integer32", "Unsigned32", "Counter64", "ObjectIdentity", "IpAddress", "NotificationType", "MibIdentifier", "Gauge32", "iso", "Bits", "ModuleIdentity", "TimeTicks")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
xylanCsmArch, = mibBuilder.importSymbols("XYLAN-BASE-MIB", "xylanCsmArch")
xylanCsmMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 9, 1))
atmxVplGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 1))
atmxInterfaceConfGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 2))
atmxVclGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 3))
xylnatmInterfaceConfGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 4))
atmxVpCrossConnectGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 5))
xylnatmInterfaceStatGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 6))
atmxVcCrossConnectGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 7))
atmxTrafficDescrGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 8))
xylnatmVplGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 9))
xylnatmVclGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 10))
xylnatmVplStatGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 11))
xylnatmVclStatGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 12))
xylnatmVcCrossConnectGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 13))
xylnatmVpCrossConnectGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 14))
xylnatmVclModGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 15))
xylnatmVplModGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 16))
xylnatmClockingxCtrlGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 17))
xylnatmTrafficShaperConfGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 18))
xylnatmTrafficShaperMemGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 19))
class AtmxTrafficDescrParamIndex(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 2147483647)

atmxInterfaceConfTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 2, 1), )
if mibBuilder.loadTexts: atmxInterfaceConfTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmxInterfaceConfTable.setDescription('This table contains ATM local interface configuration parameters, one entry per ATM interface port.')
atmxInterfaceConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 2, 1, 1), ).setIndexNames((0, "XYLAN-CSM-MIB", "atmxInterfaceSlotIndex"), (0, "XYLAN-CSM-MIB", "atmxInterfacePortIndex"))
if mibBuilder.loadTexts: atmxInterfaceConfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmxInterfaceConfEntry.setDescription('This list contains ATM interface configuration parameters and state variables.')
atmxInterfaceSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 9))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxInterfaceSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmxInterfaceSlotIndex.setDescription('The slot number of the chassis')
atmxInterfacePortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxInterfacePortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmxInterfacePortIndex.setDescription('The slot number for the CSM board')
atmxInterfaceMaxVpcs = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxInterfaceMaxVpcs.setStatus('mandatory')
if mibBuilder.loadTexts: atmxInterfaceMaxVpcs.setDescription('The maximum number of VPCs (PVCs and SVCs) supported at this ATM interface. At the ATM UNI, the maximum number of VPCs (PVCs and SVCs) ranges from 0 to 256 only.')
atmxInterfaceMaxVccs = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxInterfaceMaxVccs.setStatus('mandatory')
if mibBuilder.loadTexts: atmxInterfaceMaxVccs.setDescription('The maximum number of VCCs (PVCs and SVCs) supported at this ATM interface.')
atmxInterfaceConfVpcs = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxInterfaceConfVpcs.setStatus('mandatory')
if mibBuilder.loadTexts: atmxInterfaceConfVpcs.setDescription('The number of VPCs (PVCs and SVCs) configured for use at this ATM interface. At the ATM UNI, the configured number of VPCs (PVCs and SVCs) can range from 0 to 256 only.')
atmxInterfaceConfVccs = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxInterfaceConfVccs.setStatus('mandatory')
if mibBuilder.loadTexts: atmxInterfaceConfVccs.setDescription('The number of VCCs (PVCs and SVCs) configured for use at the ATM interface.')
atmxInterfaceMaxActiveVpiBits = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 12))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxInterfaceMaxActiveVpiBits.setStatus('mandatory')
if mibBuilder.loadTexts: atmxInterfaceMaxActiveVpiBits.setDescription('The maximum number of active VPI bits configured for use at the ATM interface. At the ATM UNI, the maximum number of active VPI bits configured for use ranges from 0 to 8 only.')
atmxInterfaceMaxActiveVciBits = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxInterfaceMaxActiveVciBits.setStatus('mandatory')
if mibBuilder.loadTexts: atmxInterfaceMaxActiveVciBits.setDescription('The maximum number of active VCI bits configured for use at this ATM interface.')
atmxInterfaceIlmiVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 2, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxInterfaceIlmiVpi.setStatus('mandatory')
if mibBuilder.loadTexts: atmxInterfaceIlmiVpi.setDescription('The VPI value of the VCC supporting the ILMI at this ATM interface. If the values of atmInterfaceIlmiVpi and atmInterfaceIlmiVci are both equal to zero then the ILMI is not supported at this ATM interface.')
atmxInterfaceIlmiVci = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(16)).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxInterfaceIlmiVci.setStatus('mandatory')
if mibBuilder.loadTexts: atmxInterfaceIlmiVci.setDescription('The VCI value of the VCC supporting the ILMI at this ATM interface. If the values of atmInterfaceIlmiVpi and atmInterfaceIlmiVci are both equal to zero then the ILMI is not supported at this ATM interface.')
atmxInterfaceAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 2, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("private", 1), ("nsapE164", 2), ("nativeE164", 3), ("other", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxInterfaceAddressType.setStatus('mandatory')
if mibBuilder.loadTexts: atmxInterfaceAddressType.setDescription('The type of primary ATM address configured for use at this ATM interface.')
atmxTrafficDescrParamTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 8, 1), )
if mibBuilder.loadTexts: atmxTrafficDescrParamTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmxTrafficDescrParamTable.setDescription('This table contains information on ATM traffic descriptor type and the associated parameters.')
atmxTrafficDescrParamEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 8, 1, 1), ).setIndexNames((0, "XYLAN-CSM-MIB", "atmxTrafficDescrParamIndex"))
if mibBuilder.loadTexts: atmxTrafficDescrParamEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmxTrafficDescrParamEntry.setDescription('This list contains ATM traffic descriptor type and the associated parameters.')
atmxTrafficDescrParamIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 8, 1, 1, 1), AtmxTrafficDescrParamIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxTrafficDescrParamIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmxTrafficDescrParamIndex.setDescription("This object is used by the virtual link table (i.e., VPL or VCL table) to identify the row of this table. For NMS to create a specific entry, the index is limited from 1-16000. Instances greater than 16000 are created internally by the switch for use by SVC's etc")
atmxTrafficDescrType = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 8, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("atmxNoTrafficDescriptor", 1), ("atmxNoClpNoScr", 2), ("atmxClpNoTaggingNoScr", 3), ("atmxClpTaggingNoScr", 4), ("atmxNoClpScr", 5), ("atmxClpNoTaggingScr", 6), ("atmxClpTaggingScr", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxTrafficDescrType.setStatus('mandatory')
if mibBuilder.loadTexts: atmxTrafficDescrType.setDescription('The value of this object identifies the type of ATM traffic descriptor. The type may indicate no traffic descriptor or traffic descriptor with one or more parameters. These parameters are specified as a parameter vector, in the corresponding instances of the objects: atmxTrafficDescrParam1 atmxTrafficDescrParam2 atmxTrafficDescrParam3 atmxTrafficDescrParam4 atmxTrafficDescrParam5.')
atmxTrafficDescrParam1 = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 8, 1, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxTrafficDescrParam1.setStatus('mandatory')
if mibBuilder.loadTexts: atmxTrafficDescrParam1.setDescription('The first parameter of the ATM traffic descriptor used according to the value of atmxTrafficDescrType.')
atmxTrafficDescrParam2 = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 8, 1, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxTrafficDescrParam2.setStatus('mandatory')
if mibBuilder.loadTexts: atmxTrafficDescrParam2.setDescription('The second parameter of the ATM traffic descriptor used according to the value of atmxTrafficDescrType.')
atmxTrafficDescrParam3 = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 8, 1, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxTrafficDescrParam3.setStatus('mandatory')
if mibBuilder.loadTexts: atmxTrafficDescrParam3.setDescription('The third parameter of the ATM traffic descriptor used according to the value of atmxTrafficDescrType.')
atmxTrafficDescrParam4 = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 8, 1, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxTrafficDescrParam4.setStatus('mandatory')
if mibBuilder.loadTexts: atmxTrafficDescrParam4.setDescription('The fourth parameter of the ATM traffic descriptor used according to the value of atmxTrafficDescrType.')
atmxTrafficDescrParam5 = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 8, 1, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxTrafficDescrParam5.setStatus('mandatory')
if mibBuilder.loadTexts: atmxTrafficDescrParam5.setDescription('The fifth parameter of the ATM traffic descriptor used according to the value of atmxTrafficDescrType.')
atmxTrafficQoSClass = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 8, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxTrafficQoSClass.setStatus('mandatory')
if mibBuilder.loadTexts: atmxTrafficQoSClass.setDescription("The value of this object identifies the QoS Class. Four Service classes have been specified in the ATM Forum UNI Specification: Service Class A: Constant bit rate video and Circuit emulation Service Class B: Variable bit rate video/audio Service Class C: Connection-oriented data Service Class D: Connectionless data Four QoS classes numbered 1, 2, 3, and 4 have been specified with the aim to support service classes A, B, C, and D respectively. An unspecified QoS Class numbered `0' is used for best effort traffic.")
atmxTrafficDescrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 8, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("create", 1), ("modify", 2), ("delete", 3), ("active", 4), ("notActive", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxTrafficDescrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmxTrafficDescrRowStatus.setDescription('This object is used to create a new row or modify or delete an existing row in this table. An entry cannot be deleted or modified if any VC/VP is using the row')
atmxVplTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 1, 1), )
if mibBuilder.loadTexts: atmxVplTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVplTable.setDescription('The Virtual Path Link (VPL) table. A bi-directional VPL is modeled as one entry in this table.')
atmxVplEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 1, 1, 1), ).setIndexNames((0, "XYLAN-CSM-MIB", "atmxVplSlotIndex"), (0, "XYLAN-CSM-MIB", "atmxVplPortIndex"), (0, "XYLAN-CSM-MIB", "atmxVplVpi"))
if mibBuilder.loadTexts: atmxVplEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVplEntry.setDescription("An entry in the VPL table. This entry is used to model a bi-directional VPL. To create a VPL at an ATM interface, either of the following procedures are used: Negotiated VPL establishment (1) The management application creates a VPL entry in the atmxVplTable by setting atmxVplRowStatus to createAndWait(5). This may fail for the following reasons: - The selected VPI value is unavailable, - The selected VPI value is in use. Otherwise, the agent creates a row and reserves the VPI value on that port. (2) The manager selects an existing row(s) in the atmxTrafficDescrParamTable, thereby, selecting a set of self-consistent ATM traffic parameters and the QoS Class for receive and transmit directions of the VPL. (2a) If no suitable row(s) in the atmxTrafficDescrParamTable exists, the manager must create a new row(s) in that table. (2b) The manager characterizes the VPL's traffic parameters through setting the atmxVplReceiveTrafficDescrIndex and the atmxVplTransmitTrafficDescrIndex values in the VPL table, which point to the rows containing desired ATM traffic parameter values in the atmxTrafficDescrParamTable. The agent will check the availability of resources and may refuse the request. (3) The manager activates the VPL by setting the the atmxVplRowStatus to active(1). If this set is successful, the agent has reserved the resources to satisfy the requested traffic parameter values and the QoS Class for that VPL. (4) If the VPL terminates a VPC in the ATM host or switch, the manager turns on the atmxVplAdminStatus to up(1) to turn the VPL traffic flow on. Otherwise, the atmxVpCrossConnectTable must be used to cross-connect the VPL to another VPL(s) in an ATM switch or network. One-Shot VPL Establishment A VPL may also be established in one step by a set-request with all necessary VPL parameter values and atmxVplRowStatus set to createAndGo(4). In contrast to the negotiated VPL establishment which allows for detailed error checking (i.e., set errors are explicitly linked to particular resource acquisition failures), the one-shot VPL establishment performs the setup on one operation but does not have the advantage of step-wise error checking. VPL Retirement A VPL is released by setting atmxVplRowStatus to destroy(6), and the agent may release all associated resources.")
atmxVplSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 9))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVplSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVplSlotIndex.setDescription('The slot number of the chassis')
atmxVplPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVplPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVplPortIndex.setDescription('The port number of the csm board')
atmxVplVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVplVpi.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVplVpi.setDescription('The VPI value of the VPL. Note that the VPI=0 is not used for a VPL not associated with a VCL. The maximum VPI value cannot exceed the value allowable by the atmInterfaceMaxVpiBits.')
atmxVplAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2))).clone('down')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxVplAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVplAdminStatus.setDescription('This object is implemented only for a VPL which terminates a VPC (i.e., one which is NOT cross-connected to other VPLs). Its value specifies the desired administrative state of the VPL. The up and down states indicate that the traffic flow is enabled and disabled respectively for this VPL.')
atmxVplOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unknown", 1), ("end2endup", 2), ("end2endDown", 3), ("localUpEndToEndUnknown", 4), ("localDown", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVplOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVplOperStatus.setDescription('This object indicates the current operational status of the VPL. The up and down states indicate that the VPL is currently operational, or not operational, respectively. The unknown state indicates that the status of this VPL cannot be determined.')
atmxVplLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 1, 1, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVplLastChange.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVplLastChange.setDescription("The value of MIB II's sysUpTime object at the time this VPL entered its current operational state. If the current state was entered prior to the last re-initialization of the agent, then this object contains a zero value.")
atmxVplReceiveTrafficDescrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 1, 1, 1, 7), AtmxTrafficDescrParamIndex()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxVplReceiveTrafficDescrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVplReceiveTrafficDescrIndex.setDescription('The value of this object identifies the row in the atmxTrafficDescrParamTable which applies to the receive direction of the VPL.')
atmxVplTransmitTrafficDescrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 1, 1, 1, 8), AtmxTrafficDescrParamIndex()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxVplTransmitTrafficDescrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVplTransmitTrafficDescrIndex.setDescription('The value of this object identifies the row in the atmxTrafficDescrParamTable which applies to the transmit direction of the VPL.')
atmxVplCrossConnectIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVplCrossConnectIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVplCrossConnectIdentifier.setDescription('This object is implemented only for a VPL which is cross-connected to other VPLs that belong to the same VPC. All such associated VPLs have the same value of this object, and all their cross-connections are identified by entries in the atmxVpCrossConnectTable for which atmxVpCrossConnectIndex has the same value. The value of this object is initialized by the agent after the associated entries in the atmxVpCrossConnectTable have been created.')
atmxVplRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("create", 1), ("modify", 2), ("delete", 3), ("active", 4), ("notActive", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxVplRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVplRowStatus.setDescription("This object is used to create, delete or modify a row in this table. To create a new VCL, this object is initially set to 'createAndWait' or 'createAndGo'. This object must not be set to 'active' unless the following columnar objects exist in this row: atmxVplReceiveTrafficDescrIndex and atmxVplTransmitTrafficDescrIndex. Xylan implemnts createAndWait and createAndGo as just Create..")
atmxVplBidirect = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2))).clone('on')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxVplBidirect.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVplBidirect.setDescription(' Indicates whether the same traffic parameters are used for both the transmit and receive sides of a virtual connection.')
atmxVclTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 3, 1), )
if mibBuilder.loadTexts: atmxVclTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVclTable.setDescription('The Virtual Channel Link (VCL) table. A bi-directional VCL is modeled as one entry in this table.')
atmxVclEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 3, 1, 1), ).setIndexNames((0, "XYLAN-CSM-MIB", "atmxVclSlotIndex"), (0, "XYLAN-CSM-MIB", "atmxVclPortIndex"), (0, "XYLAN-CSM-MIB", "atmxVclVpi"), (0, "XYLAN-CSM-MIB", "atmxVclVci"))
if mibBuilder.loadTexts: atmxVclEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVclEntry.setDescription("An entry in the VCL table. This entry is used to model a bi-directional VCL. To create a VCL at an ATM interface, either of the following procedures are used: Negotiated VCL establishment (1) The management application creates a VCL entry in the atmxVclTable by setting atmxVclRowStatus to createAndWait(5). This may fail for the following reasons: - The selected VPI/VCI values are unavailable, - The selected VPI/VCI values are in use. Otherwise, the agent creates a row and reserves the VPI/VCI values on that port. (2) The manager selects an existing row(s) in the atmxTrafficDescrParamTable, thereby, selecting a set of self-consistent ATM traffic parameters and the QoS Class for receive and transmit directions of the VCL. (2a) If no suitable row(s) in the atmxTrafficDescrParamTable exists, the manager must create a new row(s) in that table. (2b) The manager characterizes the VCL's traffic parameters through setting the atmxVclReceiveTrafficDescrIndex and the atmxVclTransmitTrafficDescrIndex values in the VCL table, which point to the rows containing desired ATM traffic parameter values in the atmxTrafficDescrParamTable. The agent will check the availability of resources and may refuse the request. (3) The manager activates the VCL by setting the the atmxVclRowStatus to active(1). If this set is successful, the agent has reserved the resources to satisfy the requested traffic parameter values and the QoS Class for that VCL. (4) If the VCL terminates a VCC in the ATM host or switch, the manager turns on the atmxVclAdminStatus to up(1) to turn the VCL traffic flow on. Otherwise, the atmxVcCrossConnectTable must be used to cross-connect the VCL to another VCL(s) in an ATM switch or network. One-Shot VCL Establishment A VCL may also be established in one step by a set-request with all necessary VCL parameter values and atmxVclRowStatus set to createAndGo(4). In contrast to the negotiated VCL establishment which allows for detailed error checking (i.e., set errors are explicitly linked to particular resource acquisition failures), the one-shot VCL establishment performs the setup on one operation but does not have the advantage of step-wise error checking. VCL Retirement A VCL is released by setting atmxVclRowStatus to destroy(6), and the agent may release all associated resources.")
atmxVclSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 9))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVclSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVclSlotIndex.setDescription('The slot number')
atmxVclPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVclPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVclPortIndex.setDescription('The port number of the csm board')
atmxVclVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVclVpi.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVclVpi.setDescription('The VPI value of the VCL. The maximum VPI value cannot exceed the value allowable by the atmInterfaceMaxVpiBits.')
atmxVclVci = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVclVci.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVclVci.setDescription('The VCI value of the VCL. The maximum VCI value cannot exceed the value allowable by the atmInterfaceMaxVciBits.')
atmxVclAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxVclAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVclAdminStatus.setDescription('This object is implemented only for a VCL which terminates a VCC (i.e., one which is NOT cross-connected to other VCLs). Its value specifies the desired administrative state of the VCL. The up and down states indicate that the traffic flow is enabled and disabled respectively for this VCL.')
atmxVclOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unknown", 1), ("end2endup", 2), ("end2endDown", 3), ("localUpEndToEndUnknown", 4), ("localDown", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVclOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVclOperStatus.setDescription('This object indicates the current operational status of the VCL. The up and down states indicate that the VCL is currently operational, or not operational, respectively. The unknown state indicates that the status of this VCL cannot be determined.')
atmxVclLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 3, 1, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVclLastChange.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVclLastChange.setDescription("The value of MIB II's sysUpTime object at the time this VCL entered its current operational state. If the current state was entered prior to the last re-initialization of the agent, then this object contains a zero value.")
atmxVclReceiveTrafficDescrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 3, 1, 1, 8), AtmxTrafficDescrParamIndex()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxVclReceiveTrafficDescrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVclReceiveTrafficDescrIndex.setDescription('The value of this object identifies the row in the ATM Traffic Descriptor Table which applies to the receive direction of this VCL.')
atmxVclTransmitTrafficDescrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 3, 1, 1, 9), AtmxTrafficDescrParamIndex()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxVclTransmitTrafficDescrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVclTransmitTrafficDescrIndex.setDescription('The value of this object identifies the row of the ATM Traffic Descriptor Table which applies to the transmit direction of this VCL.')
atmxVccAalType = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("aal1", 1), ("aal34", 2), ("aal5", 3), ("other", 4), ("unknown", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxVccAalType.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccAalType.setDescription('An instance of this object only exists when the local VCL end-point is also the VCC end-point, and AAL is in use. The type of AAL used on this VCC. The AAL type includes AAL1, AAL3/4, and AAL5. The other(4) may be user-defined AAL type. The unknown type indicates that the AAL type cannot be determined.')
atmxVccAal5CpcsTransmitSduSize = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 3, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(9188)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxVccAal5CpcsTransmitSduSize.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccAal5CpcsTransmitSduSize.setDescription('An instance of this object only exists when the local VCL end-point is also the VCC end-point, and AAL5 is in use. The maximum AAL5 CPCS SDU size in octets that is supported on the transmit direction of this VCC.')
atmxVccAal5CpcsReceiveSduSize = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 3, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(9188)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxVccAal5CpcsReceiveSduSize.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccAal5CpcsReceiveSduSize.setDescription('An instance of this object only exists when the local VCL end-point is also the VCC end-point, and AAL5 is in use. The maximum AAL5 CPCS SDU size in octets that is supported on the receive direction of this VCC.')
atmxVccAal5EncapsType = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 3, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("vcMultiplexRoutedProtocol", 1), ("vcMultiplexBridgedProtocol8023", 2), ("vcMultiplexBridgedProtocol8025", 3), ("vcMultiplexBridgedProtocol8026", 4), ("vcMultiplexLANemulation8023", 5), ("vcMultiplexLANemulation8025", 6), ("llcEncapsulation", 7), ("multiprotocolFrameRelaySscs", 8), ("other", 9), ("unknown", 10))).clone('llcEncapsulation')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxVccAal5EncapsType.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccAal5EncapsType.setDescription('An instance of this object only exists when the local VCL end-point is also the VCC end-point, and AAL5 is in use. The type of data encapsulation used over the AAL5 SSCS layer. The definitions reference RFC 1483 Multiprotocol Encapsulation over ATM AAL5 and to the ATM Forum LAN Emulation specification.')
atmxVclCrossConnectIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 3, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVclCrossConnectIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVclCrossConnectIdentifier.setDescription('This object is implemented only for a VCL which is cross-connected to other VCLs that belong to the same VCC. All such associated VCLs have the same value of this object, and all their cross-connections are identified by entries in the atmxVcCrossConnectTable for which atmxVcCrossConnectIndex has the same value. The value of this object is initialized by the agent after the associated entries in the atmxVcCrossConnectTable have been created.')
atmxVclRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 3, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("create", 1), ("modify", 2), ("delete", 3), ("active", 4), ("notActive", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxVclRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVclRowStatus.setDescription("This object is used to create, delete or modify a row in this table. To create a new VCL, this object is initially set to 'createAndWait' or 'createAndGo'. This object must not be set to 'active' unless the following columnar objects exist in this row: atmxVclReceiveTrafficDescrIndex, atmxVclTransmitTrafficDescrIndex. Xylan implements createAndWait along with create&Go as create. Create is basically a superset. In addition, if the local VCL end-point is also the VCC end-point: atmVccAalType. In addition, for AAL5 connections only: atmVccAal5CpcsTransmitSduSize, atmVccAal5CpcsReceiveSduSize, and atmVccAal5EncapsType.")
atmxVclBidirect = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 3, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2))).clone('on')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxVclBidirect.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVclBidirect.setDescription(' Indicates whether the same traffic parameters are used for both the transmit and receive sides of a virtual connection. ')
atmxVpCrossConnectTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 5, 1), )
if mibBuilder.loadTexts: atmxVpCrossConnectTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVpCrossConnectTable.setDescription('The ATM VP Cross Connect table. A bi- directional VP cross-connect which cross-connects two VPLs is modeled as one entry in this table.')
atmxVpCrossConnectEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 5, 1, 1), ).setIndexNames((0, "XYLAN-CSM-MIB", "atmxVpCrossConnectLowSlotIndex"), (0, "XYLAN-CSM-MIB", "atmxVpCrossConnectLowPortIndex"), (0, "XYLAN-CSM-MIB", "atmxVpCrossConnectLowVpi"), (0, "XYLAN-CSM-MIB", "atmxVpCrossConnectHighSlotIndex"), (0, "XYLAN-CSM-MIB", "atmxVpCrossConnectHighPortIndex"), (0, "XYLAN-CSM-MIB", "atmxVpCrossConnectHighVpi"))
if mibBuilder.loadTexts: atmxVpCrossConnectEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVpCrossConnectEntry.setDescription('An entry in the ATM VP Cross Connect table. This entry is used to model a bi-directional ATM VP cross-connect which cross-connects two VPLs. Step-wise Procedures to set up a VP Cross-connect Once the entries in the atmxVplTable are created, the following procedures are used to cross-connect the VPLs together. (1) The manager obtains a unique atmxVpCrossConnectIndex by reading the atmxVpCrossConnectIndexNext object. (2) Next, the manager creates a set of one or more rows in the ATM VP Cross Connect Table, one for each cross-connection between two VPLs. Each row is indexed by the ATM interface port numbers and VPI values of the two ends of that cross-connection. This set of rows specifies the topology of the VPC cross-connect and is identified by a single value of atmxVpCrossConnectIndex. Negotiated VP Cross-Connect Establishment (2a) The manager creates a row in this table by setting atmxVpCrossConnectRowStatus to createAndWait(5). The agent checks the requested topology and the mutual sanity of the ATM traffic parameters and QoS Classes, i.e., the row creation fails if: - the requested topology is not supported by the agent, - the traffic/QoS parameter values associated with the requested row are incompatible with those of already existing rows for this VP cross-connect. [For example, for setting up a point-to-point VP cross-connect, the ATM traffic parameters in the receive direction of a VPL at the low end of the cross-connect must equal to the traffic parameters in the transmit direction of the other VPL at the high end of the cross-connect, otherwise, the row creation fails.] The agent also checks for internal errors in building the cross-connect. The atmxVpCrossConnectIndex values in the corresponding atmxVplTable rows are filled in by the agent at this point. (2b) The manager promotes the row in the atmxVpCrossConnectTable by setting atmxVpCrossConnectRowStatus to active(1). If this set is successful, the agent has reserved the resources specified by the ATM traffic parameter and QoS Class values for each direction of the VP cross-connect in an ATM switch or network. (3) The manager sets the atmxVpCrossConnectAdminStatus to up(1) in all rows of this VP cross-connect to turn the traffic flow on. One-Shot VP Cross-Connect Establishment A VP cross-connect may also be established in one step by a set-request with all necessary parameter values and atmxVpCrossConnectRowStatus set to createAndGo(4). In contrast to the negotiated VP cross-connect establishment which allows for detailed error checking (i.e., set errors are explicitly linked to particular resource acquisition failures), the one-shot VP cross-connect establishment performs the setup on one operation but does not have the advantage of step-wise error checking. VP Cross-Connect Retirement A VP cross-connect identified by a particular value of atmxVpCrossConnectIndex is released by: (1) Setting atmxVpCrossConnectRowStatus of all rows identified by this value of atmxVpCrossConnectIndex to destroy(6). The agent may release all associated resources, and the atmxVpCrossConnectIndex values in the corresponding atmxVplTable row are removed. Note that a situation when only a subset of the associated rows are deleted corresponds to a VP topology change. (2) After deletion of the appropriate atmxVpCrossConnectEntries, the manager may set atmxVplRowStatus to destroy(6) the associated VPLs. The agent releases the resources and removes the associated rows in the atmxVplTable. VP Cross-connect Reconfiguration At the discretion of the agent, a VP cross-connect may be reconfigured by adding and/or deleting leafs to/from the VP topology as per the VP cross-connect establishment/retirement procedures. Reconfiguration of traffic/QoS parameter values requires release of the VP cross-connect before those parameter values may by changed for individual VPLs.')
atmxVpCrossConnectIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 5, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVpCrossConnectIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVpCrossConnectIndex.setDescription('A unique value to identify this VP Cross Connect')
atmxVpCrossConnectLowSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 9))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVpCrossConnectLowSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVpCrossConnectLowSlotIndex.setDescription('The low slot number')
atmxVpCrossConnectLowPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 5, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVpCrossConnectLowPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVpCrossConnectLowPortIndex.setDescription('The low physical port number')
atmxVpCrossConnectLowVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 5, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVpCrossConnectLowVpi.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVpCrossConnectLowVpi.setDescription('The value of this object is equal to the VPI value at the ATM interface associated with the VP cross-connect that is identified by atmxVpCrossConnectLow (Slot/Port)Index. The VPI value cannot exceed the number supported by the atmInterfaceMaxVpiBits at the low ATM interface port.')
atmxVpCrossConnectHighSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 5, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVpCrossConnectHighSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVpCrossConnectHighSlotIndex.setDescription('The value of the high slot number')
atmxVpCrossConnectHighPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 5, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVpCrossConnectHighPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVpCrossConnectHighPortIndex.setDescription('The high physical port number')
atmxVpCrossConnectHighVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 5, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVpCrossConnectHighVpi.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVpCrossConnectHighVpi.setDescription('The value of this object is equal to the VPI value at the ATM interface associated with the VP cross-connect that is identified by atmxVpCrossConnectHigh(Slot/Port)Index. The VPI value cannot exceed the number supported by the atmInterfaceMaxVpiBits at the high ATM interface port.')
atmxVpCrossConnectAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 5, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxVpCrossConnectAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVpCrossConnectAdminStatus.setDescription('The value of this object identifies the desired administrative status of this bi-directional VP cross-connect. The up and down states indicate that the traffic flow is enabled and disabled respectively on this VP cross-connect.')
atmxVpCrossConnectL2HOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 5, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unknown", 1), ("end2endup", 2), ("end2endDown", 3), ("localUpEndToEndUnknown", 4), ("localDown", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVpCrossConnectL2HOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVpCrossConnectL2HOperStatus.setDescription('The value of this object identifies the current operational status of the VP cross-connect in one direction; (i.e., from the low to high direction). The up and down states indicate that this ATM VP cross-connect from low to high direction is operational or not operational respectively. The unknown state indicates that the state of it cannot be determined.')
atmxVpCrossConnectH2LOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 5, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unknown", 1), ("end2endup", 2), ("end2endDown", 3), ("localUpEndToEndUnknown", 4), ("localDown", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVpCrossConnectH2LOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVpCrossConnectH2LOperStatus.setDescription('The value of this object identifies the current operational status of the VP cross-connect in one direction; (i.e., from the high to low direction). The up and down states indicate that this ATM VP cross-connect from high to low direction is operational or not operational respectively. The unknown state indicates that the state of it cannot be determined.')
atmxVpCrossConnectL2HLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 5, 1, 1, 11), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVpCrossConnectL2HLastChange.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVpCrossConnectL2HLastChange.setDescription("The value of MIB II's sysUpTime object at the time this VP cross-connect entered its current operational state in the low to high direction. If the current state was entered prior to the last re-initialization of the agent, then this object contains a zero value.")
atmxVpCrossConnectH2LLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 5, 1, 1, 12), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVpCrossConnectH2LLastChange.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVpCrossConnectH2LLastChange.setDescription("The value of MIB II's sysUpTime object at the time this VP cross-connect entered its current operational state in the high to low direction. If the current state was entered prior to the last re-initialization of the agent, then this object contains a zero value.")
atmxVpCrossConnectRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 5, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("create", 1), ("modify", 2), ("delete", 3), ("active", 4), ("notActive", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxVpCrossConnectRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVpCrossConnectRowStatus.setDescription("The status of this entry in the atmxVpCrossConnectTable. This object is used to create a cross-connect for cross-connecting VPLs which are created using the atmxVplTable or to change or delete an existing cross-connect. This object must be initially set to `createAndWait' or 'createAndGo'. This object cannot be set to `active' unless the following columnar object exists in this row: atmxVpCrossConnectAdminStatus. To turn on a VP cross-connect, the atmxVpCrossConnectAdminStatus is set to `up'. Xylan implements createAndWait along with create&Go as create. Create is basically a superset.")
atmxSvcVpCrossConnectTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 5, 2), )
if mibBuilder.loadTexts: atmxSvcVpCrossConnectTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmxSvcVpCrossConnectTable.setDescription('The ATM SVC VP Cross Connect table. A bi- directional VP cross-connect which cross-connects two SVC VPLs is modeled as one entry in this table.')
atmxSvcVpCrossConnectEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 5, 2, 1), ).setIndexNames((0, "XYLAN-CSM-MIB", "atmxSvcVpCrossConnectLowSlotIndex"), (0, "XYLAN-CSM-MIB", "atmxSvcVpCrossConnectLowPortIndex"), (0, "XYLAN-CSM-MIB", "atmxSvcVpCrossConnectLowVpi"), (0, "XYLAN-CSM-MIB", "atmxSvcVpCrossConnectHighSlotIndex"), (0, "XYLAN-CSM-MIB", "atmxSvcVpCrossConnectHighPortIndex"), (0, "XYLAN-CSM-MIB", "atmxSvcVpCrossConnectHighVpi"))
if mibBuilder.loadTexts: atmxSvcVpCrossConnectEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmxSvcVpCrossConnectEntry.setDescription('An entry in the ATM SVC VP Cross Connect table. This entry is used to model a bi-directional ATM SVC VP cross-connect which cross-connects two VPLs.')
atmxSvcVpCrossConnectLowSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 5, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 9)))
if mibBuilder.loadTexts: atmxSvcVpCrossConnectLowSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmxSvcVpCrossConnectLowSlotIndex.setDescription('The low slot of the SVC VP cross-connect.')
atmxSvcVpCrossConnectLowPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 5, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 25)))
if mibBuilder.loadTexts: atmxSvcVpCrossConnectLowPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmxSvcVpCrossConnectLowPortIndex.setDescription('The incoming slot for this SVC')
atmxSvcVpCrossConnectLowVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 5, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095)))
if mibBuilder.loadTexts: atmxSvcVpCrossConnectLowVpi.setStatus('mandatory')
if mibBuilder.loadTexts: atmxSvcVpCrossConnectLowVpi.setDescription('The value of this object is equal to the VPI value at the ATM interface associated with the SVC VP cross-connect that is identified by atmSvcVpCrossConnectLow(Slot/Port)Index. The VPI value cannot exceed the number supported by the atmInterfaceMaxVpiBits at the low ATM interface port.')
atmxSvcVpCrossConnectHighSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 5, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 9)))
if mibBuilder.loadTexts: atmxSvcVpCrossConnectHighSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmxSvcVpCrossConnectHighSlotIndex.setDescription('The outgoing slot for this SVC')
atmxSvcVpCrossConnectHighPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 5, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 25)))
if mibBuilder.loadTexts: atmxSvcVpCrossConnectHighPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmxSvcVpCrossConnectHighPortIndex.setDescription('The outgoing port for this SVC')
atmxSvcVpCrossConnectHighVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 5, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095)))
if mibBuilder.loadTexts: atmxSvcVpCrossConnectHighVpi.setStatus('mandatory')
if mibBuilder.loadTexts: atmxSvcVpCrossConnectHighVpi.setDescription('The value of this object is equal to the VPI value at the ATM interface associated with the SVC VP cross-connect that is identified by atmSvcVpCrossConnectHigh(Slot/Port)Index. The VPI value cannot exceed the number supported by the atmInterfaceMaxVpiBits at the high ATM interface port.')
atmxSvcVpCrossConnectCreationTime = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 5, 2, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxSvcVpCrossConnectCreationTime.setStatus('mandatory')
if mibBuilder.loadTexts: atmxSvcVpCrossConnectCreationTime.setDescription("The value of MIB II's sysUpTime object at the time this bi-directional SVC VP cross-connect was created. If the current state was entered prior to the last re-initialization of the agent, then this object contains a zero value.")
atmxSvcVpCrossConnectLowTDIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 5, 2, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxSvcVpCrossConnectLowTDIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmxSvcVpCrossConnectLowTDIndex.setDescription('The low end connections Traffic Descriptor Index')
atmxSvcVpCrossConnectHighTDIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 5, 2, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxSvcVpCrossConnectHighTDIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmxSvcVpCrossConnectHighTDIndex.setDescription('The high connections traffic descriptor index')
atmxSvcVpCrossConnectRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 5, 2, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxSvcVpCrossConnectRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmxSvcVpCrossConnectRowStatus.setDescription('This object can be used to delete rows in the atmSvcVpCrossConnectTable. But unless we require it for specific reasons we will not allow creation/deletion')
atmxVcCrossConnectTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 7, 1), )
if mibBuilder.loadTexts: atmxVcCrossConnectTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVcCrossConnectTable.setDescription('The ATM VC Cross Connect table. A bi- directional VC cross-connect which cross-connects two end points (i.e., VCLs) is modeled as one entry in this table.')
atmxVcCrossConnectEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 7, 1, 1), ).setIndexNames((0, "XYLAN-CSM-MIB", "atmxVcCrossConnectLowSlotIndex"), (0, "XYLAN-CSM-MIB", "atmxVcCrossConnectLowPortIndex"), (0, "XYLAN-CSM-MIB", "atmxVcCrossConnectLowVpi"), (0, "XYLAN-CSM-MIB", "atmxVcCrossConnectLowVci"), (0, "XYLAN-CSM-MIB", "atmxVcCrossConnectHighSlotIndex"), (0, "XYLAN-CSM-MIB", "atmxVcCrossConnectHighPortIndex"), (0, "XYLAN-CSM-MIB", "atmxVcCrossConnectHighVpi"), (0, "XYLAN-CSM-MIB", "atmxVcCrossConnectHighVci"))
if mibBuilder.loadTexts: atmxVcCrossConnectEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVcCrossConnectEntry.setDescription('An entry in the ATM VC Cross Connect table. This entry is used to model a bi-directional ATM VC cross-connect cross-connecting two end points. Step-wise Procedures to set up a VC Cross-connect Once the entries in the atmxVclTable are created, the following procedures are used to cross-connect the VCLs together to form a VCC segment. (1) The manager obtains a unique atmxVcCrossConnectIndex by reading the atmxVcCrossConnectIndexNext object. (2) Next, the manager creates a set of one or more rows in the ATM VC Cross Connect Table, one for each cross-connection between two VCLs. Each row is indexed by the ATM interface port numbers and VPI/VCI values of the two ends of that cross-connection. This set of rows specifies the topology of the VCC cross-connect and is identified by a single value of atmxVcCrossConnectIndex. Negotiated VC Cross-Connect Establishment (2a) The manager creates a row in this table by setting atmxVcCrossConnectRowStatus to createAndWait(5). The agent checks the requested topology and the mutual sanity of the ATM traffic parameters and QoS Classes, i.e., the row creation fails if: - the requested topology is not supported by the agent, - the traffic/QoS parameter values associated with the requested row are incompatible with those of already existing rows for this VC cross-connect. [For example, for setting up a point-to-point VC cross-connect, the ATM traffic parameters in the receive direction of a VCL at the low end of the cross-connect must equal to the traffic parameters in the transmit direction of the other VCL at the high end of the cross-connect, otherwise, the row creation fails.] The agent also checks for internal errors in building the cross-connect. The atmxVcCrossConnectIndex values in the corresponding atmxVclTable rows are filled in by the agent at this point. (2b) The manager promotes the row in the atmxVcCrossConnectTable by setting atmxVcCrossConnectRowStatus to active(1). If this set is successful, the agent has reserved the resources specified by the ATM traffic parameter and QoS Class values for each direction of the VC cross-connect in an ATM switch or network. (3) The manager sets the atmxVcCrossConnectAdminStatus to up(1) in all rows of this VC cross-connect to turn the traffic flow on. One-Shot VC Cross-Connect Establishment A VC cross-connect may also be established in one step by a set-request with all necessary parameter values and atmxVcCrossConnectRowStatus set to createAndGo(4). In contrast to the negotiated VC cross-connect establishment which allows for detailed error checking i.e., set errors are explicitly linked to particular resource acquisition failures), the one-shot VC cross-connect establishment performs the setup on one operation but does not have the advantage of step-wise error checking. VC Cross-Connect Retirement A VC cross-connect identified by a particular value of atmxVcCrossConnectIndex is released by: (1) Setting atmxVcCrossConnectRowStatus of all rows identified by this value of atmxVcCrossConnectIndex to destroy(6). The agent may release all associated resources, and the atmxVcCrossConnectIndex values in the corresponding atmxVclTable row are removed. Note that a situation when only a subset of the associated rows are deleted corresponds to a VC topology change. (2) After deletion of the appropriate atmxVcCrossConnectEntries, the manager may set atmxVclRowStatus to destroy(6) the associated VCLs. The agent releases the resources and removes the associated rows in the atmxVclTable. VC Cross-Connect Reconfiguration At the discretion of the agent, a VC cross-connect may be reconfigured by adding and/or deleting leafs to/from the VC topology as per the VC cross-connect establishment/retirement procedures. Reconfiguration of traffic/QoS parameter values requires release of the VC cross-connect before those parameter values may by changed for individual VCLs.')
atmxVcCrossConnectIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 7, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVcCrossConnectIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVcCrossConnectIndex.setDescription('A unique value to identify this VC Cross Connect')
atmxVcCrossConnectLowSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 7, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 9))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVcCrossConnectLowSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVcCrossConnectLowSlotIndex.setDescription('The low port number')
atmxVcCrossConnectLowPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 7, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVcCrossConnectLowPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVcCrossConnectLowPortIndex.setDescription('The value of this object is equal to the ATM interface port in this slot for this VC cross-connect. The term low implies that this ATM interface has the numerically lower PortIndex value than the other ATM interface identified in the same atmxVcCrossConnectEntry.')
atmxVcCrossConnectLowVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 7, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVcCrossConnectLowVpi.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVcCrossConnectLowVpi.setDescription('The value of this object is equal to the VPI value at the ATM interface associated with the VC cross-connect that is identified by atmxVcCrossConnectLow(Slot/Port)Index. The VPI value cannot exceed the number supported by the atmInterfaceMaxVpiBits at the low ATM interface port.')
atmxVcCrossConnectLowVci = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 7, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVcCrossConnectLowVci.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVcCrossConnectLowVci.setDescription('The value of this object is equal to the VCI value at the ATM interface associated with this VC cross-connect that is identified by atmxVcCrossConnectLow(Slot/Port)index. The VCI value cannot exceed the number supported by the atmInterfaceMaxVciBits at the low ATM interface port.')
atmxVcCrossConnectHighSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 7, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 9))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVcCrossConnectHighSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVcCrossConnectHighSlotIndex.setDescription('The high port number')
atmxVcCrossConnectHighPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 7, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVcCrossConnectHighPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVcCrossConnectHighPortIndex.setDescription('The value of this object is equal to the ATM interface port in this slot for this VC cross-connect. The term high implies that this VC cross-connect that this ATM interface has the numerically higher slot/port value than the other ATM interface identified in the same atmxVcCrossConnectEntry.')
atmxVcCrossConnectHighVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 7, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVcCrossConnectHighVpi.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVcCrossConnectHighVpi.setDescription('The value of this object is equal to the VPI value at the ATM interface associated with the VC cross-connect that is identified by atmxVcCrossConnectHigh(slot/port)index. The VPI value cannot exceed the number supported by the atmInterfaceMaxVpiBits at the high ATM interface port.')
atmxVcCrossConnectHighVci = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 7, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVcCrossConnectHighVci.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVcCrossConnectHighVci.setDescription('The value of this object is equal to the VCI value at the ATM interface associated with the VC cross-connect that is identified by atmxVcCrossConnectHigh(Slot/port)Index. The VCI value cannot exceed the number supported by the atmInterfaceMaxVciBits at the high ATM interface port.')
atmxVcCrossConnectAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 7, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxVcCrossConnectAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVcCrossConnectAdminStatus.setDescription('The value of this object identifies the desired administrative status of this bi-directional VC cross-connect. The up and down states indicate that the traffic flow is enabled or disabled respectively on this VC cross-connect.')
atmxVcCrossConnectL2HOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 7, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unknown", 1), ("end2endup", 2), ("end2endDown", 3), ("localUpEndToEndUnknown", 4), ("localDown", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVcCrossConnectL2HOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVcCrossConnectL2HOperStatus.setDescription('The value of this object identifies the current operational status of the VC cross-connect in one direction; (i.e., from the low to high direction). The up and down states indicate that this ATM VC cross-connect from low to high direction is operational or not operational respectively. The unknown state indicates that the state of it cannot be determined.')
atmxVcCrossConnectH2LOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 7, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unknown", 1), ("end2endup", 2), ("end2endDown", 3), ("localUpEndToEndUnknown", 4), ("localDown", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVcCrossConnectH2LOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVcCrossConnectH2LOperStatus.setDescription('The value of this object identifies the current operational status of the VC cross-connect in one direction; (i.e., from the high to low direction). The up and down states indicate that this ATM VC cross-connect from high to low direction is operational or not operational respectively. The unknown state indicates that the state of it cannot be determined.')
atmxVcCrossConnectL2HLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 7, 1, 1, 13), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVcCrossConnectL2HLastChange.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVcCrossConnectL2HLastChange.setDescription("The value of MIB II's sysUpTime object at the time this VC cross-connect entered its current operational state in low to high direction. If the current state was entered prior to the last re-initialization of the agent, then this object contains a zero value.")
atmxVcCrossConnectH2LLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 7, 1, 1, 14), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVcCrossConnectH2LLastChange.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVcCrossConnectH2LLastChange.setDescription("The value of MIB II's sysUpTime object at the time this VC cross-connect entered its current operational state in high to low direction. If the current state was entered prior to the last re-initialization of the agent, then this object contains a zero value.")
atmxVcCrossConnectRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 7, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("create", 1), ("modify", 2), ("delete", 3), ("active", 4), ("notActive", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxVcCrossConnectRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVcCrossConnectRowStatus.setDescription("The status of this entry in the atmxVcCrossConnectTable. This object is used to create a new cross-connect for cross-connecting VCLs which are created using the atmxVclTable or to change or delete existing cross-connect. This object must be initially set to `createAndWait' or 'createAndGo'. This object cannot be set to `active' unless the following columnar object exists in this row: atmxVcCrossConnectAdminStatus. To turn on a VC cross-connect, the atmxVcCrossConnectAdminStatus is set to `up'. Xylan implements createAndWait along with create&Go as create. Create is basically a superset.")
atmxSvcVcCrossConnectTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 7, 2), )
if mibBuilder.loadTexts: atmxSvcVcCrossConnectTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmxSvcVcCrossConnectTable.setDescription('The ATM SVC VC Cross Connect table. A bi- directional SVC VC cross-connect which cross-connects two end points (i.e., VCLs) is modeled as one entry in this table.')
atmxSvcVcCrossConnectEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 7, 2, 1), ).setIndexNames((0, "XYLAN-CSM-MIB", "atmxSvcVcCrossConnectLowSlotIndex"), (0, "XYLAN-CSM-MIB", "atmxSvcVcCrossConnectLowPortIndex"), (0, "XYLAN-CSM-MIB", "atmxSvcVcCrossConnectLowVpi"), (0, "XYLAN-CSM-MIB", "atmxSvcVcCrossConnectLowVci"), (0, "XYLAN-CSM-MIB", "atmxSvcVcCrossConnectHighSlotIndex"), (0, "XYLAN-CSM-MIB", "atmxSvcVcCrossConnectHighPortIndex"), (0, "XYLAN-CSM-MIB", "atmxSvcVcCrossConnectHighVpi"), (0, "XYLAN-CSM-MIB", "atmxSvcVcCrossConnectHighVci"))
if mibBuilder.loadTexts: atmxSvcVcCrossConnectEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmxSvcVcCrossConnectEntry.setDescription('An entry in the ATM SVC VC Cross Connect table. This entry is used to model a bi-directional ATM SVC VC cross-connect cross-connecting two end points.')
atmxSvcVcCrossConnectLowSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 7, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 9)))
if mibBuilder.loadTexts: atmxSvcVcCrossConnectLowSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmxSvcVcCrossConnectLowSlotIndex.setDescription('The incoming slot for this SVC.')
atmxSvcVcCrossConnectLowPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 7, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 25)))
if mibBuilder.loadTexts: atmxSvcVcCrossConnectLowPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmxSvcVcCrossConnectLowPortIndex.setDescription('The incoming port for this SVC.')
atmxSvcVcCrossConnectLowVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 7, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095)))
if mibBuilder.loadTexts: atmxSvcVcCrossConnectLowVpi.setStatus('mandatory')
if mibBuilder.loadTexts: atmxSvcVcCrossConnectLowVpi.setDescription('The value of this object is equal to the VPI value at the ATM interface associated with the SVC VC cross-connect that is identified by atmSvcVcCrossConnectLow(Slot/Port)Index. The VPI value cannot exceed the number supported by the atmInterfaceMaxVpiBits at the low ATM interface port.')
atmxSvcVcCrossConnectLowVci = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 7, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: atmxSvcVcCrossConnectLowVci.setStatus('mandatory')
if mibBuilder.loadTexts: atmxSvcVcCrossConnectLowVci.setDescription('The value of this object is equal to the VCI value at the ATM interface associated with this SVC VC cross-connect that is identified by atmSvcVcCrossConnectLow(Slot/Port)Index. The VCI value cannot exceed the number supported by the atmInterfaceMaxVciBits at the low ATM interface port.')
atmxSvcVcCrossConnectHighSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 7, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 9)))
if mibBuilder.loadTexts: atmxSvcVcCrossConnectHighSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmxSvcVcCrossConnectHighSlotIndex.setDescription('The outgoing slot for this SVC')
atmxSvcVcCrossConnectHighPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 7, 2, 1, 6), Integer32())
if mibBuilder.loadTexts: atmxSvcVcCrossConnectHighPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmxSvcVcCrossConnectHighPortIndex.setDescription('The outgoing port for this SVC')
atmxSvcVcCrossConnectHighVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 7, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095)))
if mibBuilder.loadTexts: atmxSvcVcCrossConnectHighVpi.setStatus('mandatory')
if mibBuilder.loadTexts: atmxSvcVcCrossConnectHighVpi.setDescription('The value of this object is equal to the VPI value at the ATM interface associated with the SVC VC cross-connect that is identified by atmSvcVcCrossConnectHigh(Slot/Port)Index. The VPI value cannot exceed the number supported by the atmInterfaceMaxVpiBits at the high ATM interface port.')
atmxSvcVcCrossConnectHighVci = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 7, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: atmxSvcVcCrossConnectHighVci.setStatus('mandatory')
if mibBuilder.loadTexts: atmxSvcVcCrossConnectHighVci.setDescription('The value of this object is equal to the VCI value at the ATM interface associated with the SVC VC cross-connect that is identified by atmSvcVcCrossConnectHigh(Slot/Port)Index. The VCI value cannot exceed the number supported by the atmInterfaceMaxVciBits at the high ATM interface port.')
atmxSvcVcCrossConnectCreationTime = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 7, 2, 1, 9), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxSvcVcCrossConnectCreationTime.setStatus('mandatory')
if mibBuilder.loadTexts: atmxSvcVcCrossConnectCreationTime.setDescription("The value of MIB II's sysUpTime object at the time this bi-directional SVC VC cross-connect was created. If the current state was entered prior to the last re-initialization of the agent, then this object contains a zero value.")
atmxSvcVcCrossConnectLowTDIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 7, 2, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxSvcVcCrossConnectLowTDIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmxSvcVcCrossConnectLowTDIndex.setDescription('The low end connections Traffic Descriptor Index')
atmxSvcVcCrossConnectHighTDIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 7, 2, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxSvcVcCrossConnectHighTDIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmxSvcVcCrossConnectHighTDIndex.setDescription('The high connections traffic descriptor index')
atmxSvcVcCrossConnectRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 7, 2, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxSvcVcCrossConnectRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmxSvcVcCrossConnectRowStatus.setDescription('This object is used to indicate the status of the SVC in the atmSvcVcCrossConnectTable.')
xylnatmInterfaceConfTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 4, 1), )
if mibBuilder.loadTexts: xylnatmInterfaceConfTable.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmInterfaceConfTable.setDescription('This table contains the private ATM local interface configuration parameters, one entry per ATM interface port.')
xylnatmInterfaceConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 4, 1, 1), ).setIndexNames((0, "XYLAN-CSM-MIB", "xylnatmInterfaceSlotIndex"), (0, "XYLAN-CSM-MIB", "xylnatmInterfacePortIndex"))
if mibBuilder.loadTexts: xylnatmInterfaceConfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmInterfaceConfEntry.setDescription('This list contains xyln specific ATM interface configuration parameters and state variables.')
xylnatmInterfaceSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 9))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmInterfaceSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmInterfaceSlotIndex.setDescription('The slot number of the chassis')
xylnatmInterfacePortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 25))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmInterfacePortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmInterfacePortIndex.setDescription('The port number of the chassis')
xylnatmInterfaceDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 4, 1, 1, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmInterfaceDescription.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmInterfaceDescription.setDescription('The name in ascii characters describing the interface')
xylnatmInterfaceTransType = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 20))).clone(namedValues=NamedValues(("unknown", 1), ("sonetSts3", 2), ("ds3", 3), ("fourb5b", 4), ("eightb10b", 5), ("e3", 6), ("sonetSts12", 7), ("ds1", 8), ("e1", 9), ("internal", 20)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmInterfaceTransType.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmInterfaceTransType.setDescription('The transmission type at this interface. The type is either an unknown type or sonet/ds3/ds12/4b-5b/8b_10b encoding method.')
xylnatmInterfaceType = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 4, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("public", 1), ("private", 2), ("pnni10", 3), ("nni-iisp-network", 4), ("nni-iisp-user", 5), ("other", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmInterfaceType.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmInterfaceType.setDescription('The signaling type at this interface.')
xylnatmInterfaceMediaType = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 4, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("unknown", 1), ("coax", 2), ("singlemode", 3), ("multimode", 4), ("stp", 5), ("utp", 6), ("internal", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmInterfaceMediaType.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmInterfaceMediaType.setDescription('The physical media type from this physical port')
xylnatmInterfaceAtmAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 4, 1, 1, 7), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmInterfaceAtmAddress.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmInterfaceAtmAddress.setDescription('The AtmAddress @ this interface. The AtmAddress should be a 20 octet hex number.')
xylnatmInterfacePortMode = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 4, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("passthru", 2), ("normal", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmInterfacePortMode.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmInterfacePortMode.setDescription('This object describes whether this interface is switched off or allowing traffic to pass thru or is in normal mode.')
xylnatmInterfaceOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 4, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmInterfaceOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmInterfaceOperStatus.setDescription('The Oper status @ this interface is reflected by the status of the object.')
xylnatmInterfaceQsaalStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 4, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmInterfaceQsaalStatus.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmInterfaceQsaalStatus.setDescription('The QSAAL status @ this interface is reflected by the status of the object.')
xylnatmInterfaceIlmiStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 4, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmInterfaceIlmiStatus.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmInterfaceIlmiStatus.setDescription('The Ilmi Status @ this interface.')
xylnatmInterfaceTpRedirect = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 4, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmInterfaceTpRedirect.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmInterfaceTpRedirect.setDescription('This object indicates whether Cut-Over is enabled or disabled @ this interface')
xylnatmInterfaceCutOverSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 4, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 9))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmInterfaceCutOverSlot.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmInterfaceCutOverSlot.setDescription('The Cut-Over slot number of the chassis')
xylnatmInterfaceCutOverPort = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 4, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 25))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmInterfaceCutOverPort.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmInterfaceCutOverPort.setDescription('The Cut Over Port number of the chassis')
xylnatmInterfaceClearPortStats = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 4, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmInterfaceClearPortStats.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmInterfaceClearPortStats.setDescription('True clears the stats for this port')
xylnatmInterfaceClearChanStats = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 4, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmInterfaceClearChanStats.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmInterfaceClearChanStats.setDescription('True clears the chan stats')
xylnatmInterfaceClearSlotStats = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 4, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmInterfaceClearSlotStats.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmInterfaceClearSlotStats.setDescription('True clears all the port stats in this slot.')
xylnatmInterfaceTransmissionType = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 4, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("sonet3c", 1), ("sdh", 2), ("sonet12c", 3), ("notApplicable", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmInterfaceTransmissionType.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmInterfaceTransmissionType.setDescription('The type of physical media for transmission on the port Sonet or SDH. SDH is primarily used in Europe and Sonet in the US. The S bit in the payload pointer is 00 for Sonet and 01 for SDH')
xylnatmInterfaceIlmiState = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 4, 1, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmInterfaceIlmiState.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmInterfaceIlmiState.setDescription('The state of Ilmi for the instanced port. Setting this object to disable, would prevent any ILMI queries being sent out on this port. ')
xylnatmInterfaceTimingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 4, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("local", 1), ("loop", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmInterfaceTimingMode.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmInterfaceTimingMode.setDescription('This object selects the method used by the port to generate the clock used for transmit data. local(1) selects local clock source. loop(2) selects the derived clock from the receive data.')
xylnatmInterfaceLocalSrc = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 4, 1, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("oscillator", 1), ("busLine8K", 2), ("busLine19M", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmInterfaceLocalSrc.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmInterfaceLocalSrc.setDescription("This object selects which local clock source used to drive the transmit data for the port. This option is not available when the port's timing mode is loop. oscillator(1) selects the on board oscillator. busLine8K(2) selects the 8 KHz clocking bus line. All CSM-interface types except for OC3 and OC12 can use an 8 KHz clock from the bus to generate their local timing. busLine19M(3) selects the 19.44 MHz clocking bus line. All CSM OC3, OC12 and CSM-AB-CE-T1 and CSM-AB-CE-E1 interface types can use a 19.44 Mhz clock from the bus to generate their local timing. In the case of the CSM-AB-CE the adapter board does a divide operation on the 19.44 Mhz clock to get an 8 Khz clock to use. Currently, only the CSM-AB-CE T1 and E1 adapter boards have the ability to support either busLine8K and busLine19M options.")
xylnatmInterfaceUniVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 4, 1, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("uni30", 1), ("uni31", 2), ("uniIisp", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmInterfaceUniVersion.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmInterfaceUniVersion.setDescription('UNI Version used in the chassis')
xylnatmILMIConfTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 4, 3), )
if mibBuilder.loadTexts: xylnatmILMIConfTable.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmILMIConfTable.setDescription(' This table contains CSM ILMI configuration parameters, one entry per CSM physical interface, or per virtual UNI/NNI instance')
xylnatmILMIConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 4, 3, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: xylnatmILMIConfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmILMIConfEntry.setDescription('This list contains CSM ILMI configuration and state variables')
xylnatmILMIConfSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 4, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmILMIConfSlot.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmILMIConfSlot.setDescription(' The slot number this entry represents')
xylnatmILMIConfPort = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 4, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmILMIConfPort.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmILMIConfPort.setDescription(' The port number this entry represents')
xylnatmILMIConfInstance = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 4, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmILMIConfInstance.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmILMIConfInstance.setDescription(' The Virtual UNI/NNI instance this entry represents')
xylnatmILMIConfILMIEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 4, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmILMIConfILMIEnable.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmILMIConfILMIEnable.setDescription(' Indicate whether ILMI is enabled on this port, or on this Virtual UNI/NNI instance')
xylnatmILMIConfILMIPollEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 4, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmILMIConfILMIPollEnable.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmILMIConfILMIPollEnable.setDescription(' Indicate whether ILMI polling is enabled on this port, or on this Virtual UNI/NNI instance')
xylnatmILMIConfAutoCfgEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 4, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmILMIConfAutoCfgEnable.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmILMIConfAutoCfgEnable.setDescription(' Indicate whether CSM auto cfg is enabled on this port, or on this Virtual UNI/NNI instance')
xylnatmILMIConfAutoCfgStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 4, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("cfgDone", 1), ("idle", 2), ("inProgress", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmILMIConfAutoCfgStatus.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmILMIConfAutoCfgStatus.setDescription(' The status of auto configuration procedure on this port, or this Virtual UNI/NNI instance')
xylnatmILMIConfAutoCfgTrigg = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 4, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("phyLogic", 2), ("phy", 3), ("logic", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmILMIConfAutoCfgTrigg.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmILMIConfAutoCfgTrigg.setDescription(' Indicate how auto configuration procedure is triggerred on this port or virtual UNI/NNI instance, phy indicates auto configuration is only triggered when the port detects physical layer connection is from down to up, logic indicates auto configuration procedure is triggerred when CSM port receives trap from peer port, while phy_logic indicate auto configuration procedure is triggerred by both phy and logic, which are situations described by above narrative ')
xylnatmILMIConfAutoCfgDfltIf = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 4, 3, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("privateUNI", 1), ("pnni", 2), ("iispNetwork", 3), ("iispUser", 4), ("publicUNI", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmILMIConfAutoCfgDfltIf.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmILMIConfAutoCfgDfltIf.setDescription(" The default interface type this port or virtual UNI/NNI instance will take when auto configuration procedure fails to detect its peer port's interface type")
xylnatmILMIConfAutoCfgDfltSigVer = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 4, 3, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("uni30", 1), ("uni31", 2), ("uni40", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmILMIConfAutoCfgDfltSigVer.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmILMIConfAutoCfgDfltSigVer.setDescription(" The default signaling version this port or virtual UNI/NNI instance will take when auto configuration procedure fails to detect its peer port's signaling version")
xylnatmILMIConfAutoCfgCurIf = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 4, 3, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("privateUNI", 1), ("pnni", 2), ("iispNetwork", 3), ("iispUser", 4), ("publicUNI", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmILMIConfAutoCfgCurIf.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmILMIConfAutoCfgCurIf.setDescription(' Current operational interface type for this CSM port or virtual UNI/NNI instance')
xylnatmILMIConfAutoCfgCurSigVer = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 4, 3, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("uni30", 1), ("uni31", 2), ("uni40", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmILMIConfAutoCfgCurSigVer.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmILMIConfAutoCfgCurSigVer.setDescription(' Current operational signaling version for this CSM port or virtual UNI/NNI instance')
xylnatmILMIConfAutoCfgCurILMIVer = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 4, 3, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("unsupported", 1), ("ilmi40", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmILMIConfAutoCfgCurILMIVer.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmILMIConfAutoCfgCurILMIVer.setDescription(' Current ILMI version running on this CSM port or virtual UNI/NNI instance')
xylnatmILMIConfPeerUniType = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 4, 3, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("public", 1), ("private", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmILMIConfPeerUniType.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmILMIConfPeerUniType.setDescription(' The UNI type this port gathered from its peer port through ILMI')
xylnatmILMIConfPeerUniVer = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 4, 3, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("uni30", 1), ("uni31", 2), ("uni40", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmILMIConfPeerUniVer.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmILMIConfPeerUniVer.setDescription(' The signaling version this port gathered from its peer port through ILMI')
xylnatmILMIConfPeerDevType = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 4, 3, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("user", 1), ("node", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmILMIConfPeerDevType.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmILMIConfPeerDevType.setDescription(' The device type this port gathered from its peer port through ILMI')
xylnatmILMIConfPeerNNISigVer = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 4, 3, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unsupported", 1), ("iisp", 2), ("pnni10", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmILMIConfPeerNNISigVer.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmILMIConfPeerNNISigVer.setDescription(' The NNI signaling version this port gathered from its peer port through ILMI')
xylnatmILMIConfPeerILMIVer = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 4, 3, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("unsupported", 1), ("ilmi40", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmILMIConfPeerILMIVer.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmILMIConfPeerILMIVer.setDescription(' The ILMI version this port gathered from its peer port through ILMI')
xylnatmInterfaceStatTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 6, 1), )
if mibBuilder.loadTexts: xylnatmInterfaceStatTable.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmInterfaceStatTable.setDescription('This table contains the statistical information about the interface')
xylnatmInterfaceStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 6, 1, 1), ).setIndexNames((0, "XYLAN-CSM-MIB", "xylnatmInterfaceStatSlotIndex"), (0, "XYLAN-CSM-MIB", "xylnatmInterfaceStatPortIndex"))
if mibBuilder.loadTexts: xylnatmInterfaceStatEntry.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmInterfaceStatEntry.setDescription(' This list contains xylan specific ATM interface configuration parameters and state variables')
xylnatmInterfaceStatSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 6, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmInterfaceStatSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmInterfaceStatSlotIndex.setDescription('The slot number in the switch')
xylnatmInterfaceStatPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 6, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmInterfaceStatPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmInterfaceStatPortIndex.setDescription('The port number in this slot')
xylnatmInterfaceStatRxCells = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 6, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmInterfaceStatRxCells.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmInterfaceStatRxCells.setDescription('The total number of Received Cells at this interface (OC3, OC12, ATM25...)')
xylnatmInterfaceStatRxClp0Cells = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 6, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmInterfaceStatRxClp0Cells.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmInterfaceStatRxClp0Cells.setDescription('The total number of received cells at this interface with Cell loss priority of zero')
xylnatmInterfaceStatRxClp1Cells = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 6, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmInterfaceStatRxClp1Cells.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmInterfaceStatRxClp1Cells.setDescription('The total number of received cells at this interface with Cell loss Priority of zero or one')
xylnatmInterfaceStatTxCells = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 6, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmInterfaceStatTxCells.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmInterfaceStatTxCells.setDescription('The total number of transmitted cells at this interface')
xylnatmInterfaceStatMarkEfciCells = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 6, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmInterfaceStatMarkEfciCells.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmInterfaceStatMarkEfciCells.setDescription('The number of cells that are marked with efci (explicit forward congestion notification) in the payload type identifier field of the atm cell. This EFCI notification is used in conjunction with backward RM cells so that the destination can notify the source that there is congestion on the path to the destination')
xylnatmInterfaceStatMarkGcraCells = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 6, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmInterfaceStatMarkGcraCells.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmInterfaceStatMarkGcraCells.setDescription('The number of cells marked by policing that violated their traffic contract for clp0+1 cells')
xylnatmInterfaceStatTotalDiscardCells = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 6, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmInterfaceStatTotalDiscardCells.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmInterfaceStatTotalDiscardCells.setDescription("The total number of cells discarded at this interface due to congestion, policing and unknown vpi/vci's")
xylnatmInterfaceStatDxCongClp0Cells = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 6, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmInterfaceStatDxCongClp0Cells.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmInterfaceStatDxCongClp0Cells.setDescription('The number of Clp0 cells discarded due to congestion')
xylnatmInterfaceStatDxCongClp1Cells = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 6, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmInterfaceStatDxCongClp1Cells.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmInterfaceStatDxCongClp1Cells.setDescription('The number of Clp1 cells discarded due to congestion')
xylnatmInterfaceStatDxGcraClp0Cells = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 6, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmInterfaceStatDxGcraClp0Cells.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmInterfaceStatDxGcraClp0Cells.setDescription('The total number of Clp0 cells discarded due to policing on Clp0+1 cells')
xylnatmInterfaceStatDxGcraClp1Cells = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 6, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmInterfaceStatDxGcraClp1Cells.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmInterfaceStatDxGcraClp1Cells.setDescription('The total number of cell loss priority one cells discarded due to policing on Clp0+1 cells')
xylnatmInterfaceStatDxGcrabClp0Cells = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 6, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmInterfaceStatDxGcrabClp0Cells.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmInterfaceStatDxGcrabClp0Cells.setDescription('The total number of Clp0 cells discarded due to policing on cell loss priority zero cells')
xylnatmInterfaceStatDxGcrabClp1Cells = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 6, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmInterfaceStatDxGcrabClp1Cells.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmInterfaceStatDxGcrabClp1Cells.setDescription('The total number of cell loss prioity one cells discarded due to policing on Clp0+1 cells')
xylnatmInterfaceStatUnknownVpVcCells = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 6, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmInterfaceStatUnknownVpVcCells.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmInterfaceStatUnknownVpVcCells.setDescription('The total number of cells received on this interface which has a vpi/vci combination that doesnt correspond to any channels vpi/vci for this physical interface')
xylnatmInterfaceStatUnknownVpiCells = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 6, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmInterfaceStatUnknownVpiCells.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmInterfaceStatUnknownVpiCells.setDescription('The total number of unknown Vpi cells recieved at this interface that dont correspond to any channels vpi')
xylnatmInterfaceStatUnknownVciCells = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 6, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmInterfaceStatUnknownVciCells.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmInterfaceStatUnknownVciCells.setDescription('The total number of unknown Vci cells recieved at this interface that dont correspond to any channels vci')
xylnatmInterfaceStatUniType = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 6, 1, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("public", 1), ("private", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmInterfaceStatUniType.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmInterfaceStatUniType.setDescription('Type of UNI used on this interface...Public or Private')
xylnatmInterfaceStatUniVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 6, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("uni30", 1), ("uni31", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmInterfaceStatUniVersion.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmInterfaceStatUniVersion.setDescription('UNI Version used in the chassis')
xylnatmInterfaceStatRemainingRxBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 6, 1, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmInterfaceStatRemainingRxBandwidth.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmInterfaceStatRemainingRxBandwidth.setDescription('The remaining bandwidth available on this port thru which connections can be created and cells can be received.')
xylnatmInterfaceStatRemainingTxBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 6, 1, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmInterfaceStatRemainingTxBandwidth.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmInterfaceStatRemainingTxBandwidth.setDescription('The remaining bandwidth available on this port thru which connections can be created for cells to be transmitted')
xylnatmVclTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 10, 1), )
if mibBuilder.loadTexts: xylnatmVclTable.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVclTable.setDescription('This table contains xylan implementation specific objects')
xylnatmVclEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 10, 1, 1), ).setIndexNames((0, "XYLAN-CSM-MIB", "xylnatmVclSlotIndex"), (0, "XYLAN-CSM-MIB", "xylnatmVclPortIndex"), (0, "XYLAN-CSM-MIB", "xylnatmVclVpi"), (0, "XYLAN-CSM-MIB", "xylnatmVclVci"))
if mibBuilder.loadTexts: xylnatmVclEntry.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVclEntry.setDescription('List of xylan specific objects')
xylnatmVclSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 10, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVclSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVclSlotIndex.setDescription('Slot Instance')
xylnatmVclPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 10, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVclPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVclPortIndex.setDescription('Port Instance')
xylnatmVclVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 10, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVclVpi.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVclVpi.setDescription('Vpi instance')
xylnatmVclVci = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 10, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVclVci.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVclVci.setDescription('Vcl instance')
xylnatmVclConnectionDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 10, 1, 1, 5), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmVclConnectionDescr.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVclConnectionDescr.setDescription('An ascii value for the connection')
xylnatmVclChanType = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 10, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("vcNni", 3), ("vcUni", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmVclChanType.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVclChanType.setDescription('The type of Virtual path')
xylnatmVclTransportPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 10, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 5, 6, 7, 8))).clone(namedValues=NamedValues(("qosCbrPrs", 2), ("qosCbr", 3), ("qosVbrRt", 5), ("qosVbrNrt", 6), ("qosAbr", 7), ("qosUbr", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmVclTransportPriority.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVclTransportPriority.setDescription('The transport priority...')
xylnatmVclUserPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 10, 1, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmVclUserPriority.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVclUserPriority.setDescription(' The user priority 0-15, with 0 being the highest')
xylnatmVclStatsMode = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 10, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("cntGcraDxCell", 1), ("mrkGcraDxCell", 2), ("cntGcraPsCell", 3), ("mrkGcraPsCell", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmVclStatsMode.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVclStatsMode.setDescription('This allows the user one of the 4 choices. When the user selects cntGcraDxCell = count clp0 & 1 and discard cell mrkGcraDxCell = count clp0 & 1, mark efci &clp, discard cell cntGcraPsCell = count clp0 &1 and pass the cell mrkGcraPsCell = count clp0 &1, mark efci and clp, pass cell')
xylnatmVclPrTrackPortBase = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 10, 1, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVclPrTrackPortBase.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVclPrTrackPortBase.setDescription('The dest internal pport')
xylnatmVclPrTrackPort1 = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 10, 1, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVclPrTrackPort1.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVclPrTrackPort1.setDescription('Used under multicast conditions and will be supported in future releases for load balancing')
xylnatmVclPrTrackPort2 = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 10, 1, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVclPrTrackPort2.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVclPrTrackPort2.setDescription('Used under multicast conditions and will be supported in future releases for load balancing')
xylnatmVclPrTrackPort3 = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 10, 1, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVclPrTrackPort3.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVclPrTrackPort3.setDescription('Used under multicast conditions and will be supported in future releases for load balancing')
xylnatmVclAltTrackPortBase = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 10, 1, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVclAltTrackPortBase.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVclAltTrackPortBase.setDescription('Alternate port under failure conditions and will be supported in future release')
xylnatmVclAltTrackPort1 = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 10, 1, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVclAltTrackPort1.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVclAltTrackPort1.setDescription('Alternate port under failure conditions and will be supported in future release')
xylnatmVclAltTrackPort2 = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 10, 1, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVclAltTrackPort2.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVclAltTrackPort2.setDescription('Alternate port under failure conditions and will be supported in future release')
xylnatmVclAltTrackPort3 = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 10, 1, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVclAltTrackPort3.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVclAltTrackPort3.setDescription('Alternate port under failure conditions and will be supported in future release')
xylnatmVclLgclChanRedirect = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 10, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notAllowed", 1), ("allowed", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmVclLgclChanRedirect.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVclLgclChanRedirect.setDescription('Permits the user to allow or not allow logical channel redirects')
xylnatmVclAAL5Discard = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 10, 1, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("earlyPktDiscard", 1), ("disable", 2), ("partialPktDiscard", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmVclAAL5Discard.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVclAAL5Discard.setDescription("This field configures an action that IOP should take against cells when traffic congestion occurs. earlyPktDiscard(1) is treated as 'enable' for IOP version 1 since it doesn't support early packet discard feature. Early packet discard is an IOP 2 feature. In this mode, IOP either passes or discards all the cells of a packet. It passes all cells of a packet during congestion if the first cell of the packet has been passed. Cells are marked when GCRA contract is violated. This option does not apply to VBR_RT and CBR and CBR_PRS. disable(2) is selected to disable early packet discard and partial discard feature. Cells are discarded when needed during congestion. Cells are marked when GCRA contract is violated. partialPktDiscard(3) is an IOP 2 feature. IOP starts discarding cells--all of the remaining cells except for the last cell of the packet-when congestion occurs. When congestion ends, the first cell of a new packet is passed. Cells are marked when GCRA contract is violated. This option does not apply to VBR_RT and CBR and CBR_PRS. The default value for IOP 1 is 'disable'. The default value is 'earlyPktDiscard' for IOP 2 if the transport type of the circuit is UBR, ABR, and VBR_NRT. 'disable' is the default for VBR_RT and CBR and CBR_PRS.")
xylnatmVclF4F5SegEndpt = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 10, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmVclF4F5SegEndpt.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVclF4F5SegEndpt.setDescription('Future release')
xylnatmVclF4F5CopySeg = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 10, 1, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmVclF4F5CopySeg.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVclF4F5CopySeg.setDescription('Future release')
xylnatmVclF4F5End2EndEndpt = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 10, 1, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmVclF4F5End2EndEndpt.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVclF4F5End2EndEndpt.setDescription('Future release')
xylnatmVclF4F5CopyEnd2End = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 10, 1, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmVclF4F5CopyEnd2End.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVclF4F5CopyEnd2End.setDescription('Future release')
xylnatmVclOamEndpt = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 10, 1, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmVclOamEndpt.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVclOamEndpt.setDescription('Future release')
xylnatmVclOamCopy = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 10, 1, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmVclOamCopy.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVclOamCopy.setDescription('Future release')
xylnatmVclRmFwdEndpt = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 10, 1, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmVclRmFwdEndpt.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVclRmFwdEndpt.setDescription('Future release')
xylnatmVclRmFwdCopy = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 10, 1, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmVclRmFwdCopy.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVclRmFwdCopy.setDescription('Future release')
xylnatmVclRmFwdGcraAdv = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 10, 1, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmVclRmFwdGcraAdv.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVclRmFwdGcraAdv.setDescription('Future release')
xylnatmVclRmBkwdEndpt = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 10, 1, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmVclRmBkwdEndpt.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVclRmBkwdEndpt.setDescription('Future release')
xylnatmVclRmBkwdCopy = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 10, 1, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmVclRmBkwdCopy.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVclRmBkwdCopy.setDescription('Future release')
xylnatmVclRmBkwdGcraAdv = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 10, 1, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmVclRmBkwdGcraAdv.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVclRmBkwdGcraAdv.setDescription('Future release')
xylnatmVclRmDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 10, 1, 1, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmVclRmDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVclRmDiscard.setDescription('Future release')
xylnatmVclGcraAPoliceMode = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 10, 1, 1, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("gcraEmDxAll", 1), ("gcraEmMarkClp0DxClp1", 2), ("gcraEmMarkAllDxAll", 3), ("gcraEmMarkClp0DxAll", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVclGcraAPoliceMode.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVclGcraAPoliceMode.setDescription('Enforcement mode of GcraA as following gcraEmDxAll = Discard all cells on congestion gcraEmMarkClp0DxClp1 = On congestion discard Clp1 cells gcraEmMarkAllDxAll = On congestion mark all gcraEmMarkClp0DxAll = on congestion mark clp0 and discard all')
xylnatmVclGcraBPoliceMode = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 10, 1, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("gcraEmDxAll", 1), ("gcraEmMarkClp0DxClp1", 2), ("gcraEmMarkAllDxAll", 3), ("gcraEmMarkClp0DxAll", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVclGcraBPoliceMode.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVclGcraBPoliceMode.setDescription('Enforcement mode of GcraB as following gcraEmDxAll = Discard all cells on congestion gcraEmMarkClp0DxClp1 = On congestion discard Clp1 cells gcraEmMarkAllDxAll = On congestion mark all gcraEmMarkClp0DxAll = on congestion mark clp0 and discard all')
xylnatmVclMcGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 10, 1, 1, 35), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVclMcGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVclMcGroupId.setDescription('Internal use of multicast group id')
xylnatmVclMcIngressEgress = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 10, 1, 1, 36), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ingress", 1), ("egress", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVclMcIngressEgress.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVclMcIngressEgress.setDescription('Always ingress in this release')
xylnatmVclStatTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 12, 1), )
if mibBuilder.loadTexts: xylnatmVclStatTable.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVclStatTable.setDescription('This table contains the xylan specific statistical object')
xylnatmVclStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 12, 1, 1), ).setIndexNames((0, "XYLAN-CSM-MIB", "xylnatmVclStatSlotIndex"), (0, "XYLAN-CSM-MIB", "xylnatmVclStatPortIndex"), (0, "XYLAN-CSM-MIB", "xylnatmVclStatVpi"), (0, "XYLAN-CSM-MIB", "xylnatmVclStatVci"))
if mibBuilder.loadTexts: xylnatmVclStatEntry.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVclStatEntry.setDescription('Contains the stats objects')
xylnatmVclStatSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 12, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVclStatSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVclStatSlotIndex.setDescription('The slot number of the chassis')
xylnatmVclStatPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 12, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 25))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVclStatPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVclStatPortIndex.setDescription('The port number of this slot')
xylnatmVclStatVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 12, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVclStatVpi.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVclStatVpi.setDescription('The Vpi number for this connection')
xylnatmVclStatVci = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 12, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVclStatVci.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVclStatVci.setDescription('The Vci number for the connection')
xylnatmVclStatRxCells = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 12, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVclStatRxCells.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVclStatRxCells.setDescription(' The total number of cells received on this connection identified by the slot/port/vpi/vci')
xylnatmVclStatTxCells = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 12, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVclStatTxCells.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVclStatTxCells.setDescription('The total number of cells transmitted on this connection identified by the slot/port/vpi/vci')
xylnatmVclStatRxClp0Cells = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 12, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVclStatRxClp0Cells.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVclStatRxClp0Cells.setDescription('The total number of received cells with Clp0 received on this connection identified by slot/port/vpi/vci')
xylnatmVclStatRxClp1Cells = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 12, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVclStatRxClp1Cells.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVclStatRxClp1Cells.setDescription('The total number of received cells with Clp1 received on this connection identified by slot/port/vpi/vci')
xylnatmVclStatDxCongClp0Cells = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 12, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVclStatDxCongClp0Cells.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVclStatDxCongClp0Cells.setDescription('The total number of cell loss priority zero cells discarded on this connection at this interface identified by the slot/port due to congestion')
xylnatmVclStatDxCongClp1Cells = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 12, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVclStatDxCongClp1Cells.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVclStatDxCongClp1Cells.setDescription('The total number of cell loss priority one cells discarded on this connection at this interface identified by the slot/port due to congestion')
xylnatmVclStatDxGcraClp0Cells = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 12, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVclStatDxGcraClp0Cells.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVclStatDxGcraClp0Cells.setDescription('The number of Clp0 cells discarded on this connection due to policing on Clp0+1 cells')
xylnatmVclStatDxGcraClp1Cells = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 12, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVclStatDxGcraClp1Cells.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVclStatDxGcraClp1Cells.setDescription('The total number of Clp1 cells discarded due to policing on Clp0+1 cells')
xylnatmVclStatDxGcraBClp0Cells = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 12, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVclStatDxGcraBClp0Cells.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVclStatDxGcraBClp0Cells.setDescription('The total number of Clp0 cells discarded due to policing on Clp0+1 cells')
xylnatmVclStatDxGcraBClp1Cells = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 12, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVclStatDxGcraBClp1Cells.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVclStatDxGcraBClp1Cells.setDescription('The total number of Clp1 cells discarded due to policing on Clp0+1 cells')
xylnatmVplTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 9, 1), )
if mibBuilder.loadTexts: xylnatmVplTable.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVplTable.setDescription('This table contains xylan implementation specific objects')
xylnatmVplEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 9, 1, 1), ).setIndexNames((0, "XYLAN-CSM-MIB", "xylnatmVplSlotIndex"), (0, "XYLAN-CSM-MIB", "xylnatmVplPortIndex"), (0, "XYLAN-CSM-MIB", "xylnatmVplVpi"))
if mibBuilder.loadTexts: xylnatmVplEntry.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVplEntry.setDescription('List of xylan specific objects')
xylnatmVplSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 9, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVplSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVplSlotIndex.setDescription('Slot Instance')
xylnatmVplPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 9, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVplPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVplPortIndex.setDescription('Port Instance')
xylnatmVplVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 9, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVplVpi.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVplVpi.setDescription('Vpi instance')
xylnatmVplConnectionDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 9, 1, 1, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmVplConnectionDescr.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVplConnectionDescr.setDescription('An ascii value for the connection')
xylnatmVplChanType = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 9, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 5, 6))).clone(namedValues=NamedValues(("unknown", 1), ("vpNNI", 5), ("vpUni", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmVplChanType.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVplChanType.setDescription('The type of Virtual path')
xylnatmVplTransportPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 9, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 5, 6, 7, 8))).clone(namedValues=NamedValues(("qosCbrPrs", 2), ("qosCbr", 3), ("qosVbrRt", 5), ("qosVbrNrt", 6), ("qosAbr", 7), ("qosUbr", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmVplTransportPriority.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVplTransportPriority.setDescription('The transport priority...')
xylnatmVplUserPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 9, 1, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmVplUserPriority.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVplUserPriority.setDescription('The user priority 0-15 with 0 being the highest')
xylnatmVplStatsMode = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 9, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("cntGcraDxCell", 1), ("mrkGcraDxCell", 2), ("cntGcraPsCell", 3), ("mrkGcraPsCell", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmVplStatsMode.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVplStatsMode.setDescription('This allows the user one of the 4 choices. When the user selects cntGcraDxCell = count clp0 & 1 and discard cell mrkGcraDxCell = count clp0 & 1, mark efci &clp, discard cell cntGcraPsCell = count clp0 &1 and pass the cell mrkGcraPsCell = count clp0 &1, mark efci and clp, pass cell')
xylnatmVplPrTrackPortBase = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 9, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVplPrTrackPortBase.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVplPrTrackPortBase.setDescription('The destination internal pport')
xylnatmVplPrTrackPort1 = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 9, 1, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVplPrTrackPort1.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVplPrTrackPort1.setDescription('Used under multicast conditions and will be supported in future releases for load balancing')
xylnatmVplPrTrackPort2 = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 9, 1, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVplPrTrackPort2.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVplPrTrackPort2.setDescription('Used under multicast conditions and will be supported in future releases for load balancing')
xylnatmVplPrTrackPort3 = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 9, 1, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVplPrTrackPort3.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVplPrTrackPort3.setDescription('Used under multicast conditions and will be supported in future releases for load balancing')
xylnatmVplAltTrackPortBase = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 9, 1, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVplAltTrackPortBase.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVplAltTrackPortBase.setDescription('Alternate port under failure conditions and will be supported in future release')
xylnatmVplAltTrackPort1 = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 9, 1, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVplAltTrackPort1.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVplAltTrackPort1.setDescription('Alternate port under failure conditions and will be supported in future release')
xylnatmVplAltTrackPort2 = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 9, 1, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVplAltTrackPort2.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVplAltTrackPort2.setDescription('Alternate port under failure conditions and will be supported in future release')
xylnatmVplAltTrackPort3 = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 9, 1, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVplAltTrackPort3.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVplAltTrackPort3.setDescription('Alternate port under failure conditions and will be supported in future release')
xylnatmVplLgclChanRedirect = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 9, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notAllowed", 1), ("allowed", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmVplLgclChanRedirect.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVplLgclChanRedirect.setDescription('Permits the user to allow or not allow logical channel redirects')
xylnatmVplAAL5Discard = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 9, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("earlyPktDiscard", 1), ("disable", 2), ("partialPktDiscard", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmVplAAL5Discard.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVplAAL5Discard.setDescription("This field configures an action that IOP should take against cells when traffic congestion occurs. earlyPktDiscard(1) is treated as 'enable' for IOP version 1 since it doesn't support early packet discard feature. Early packet discard is an IOP 2 feature. In this mode, IOP either passes or discards all the cells of a packet. It passes all cells of a packet during congestion if the first cell of the packet has been passed. Cells are marked when GCRA contract is violated. This option does not apply to VBR_RT and CBR and CBR_PRS. disable(2) is selected to disable early packet discard and partial discard feature. Cells are discarded when needed during congestion. Cells are marked when GCRA contract is violated. partialPktDiscard(3) is an IOP 2 feature. IOP starts discarding cells--all of the remaining cells except for the last cell of the packet-when congestion occurs. When congestion ends, the first cell of a new packet is passed. Cells are marked when GCRA contract is violated. This option does not apply to VBR_RT and CBR and CBR_PRS. The default value for IOP 1 is 'disable'. The default value is 'earlyPktDiscard' for IOP 2 if the transport type of the circuit is UBR, ABR, and VBR_NRT. 'disable' is the default VBR_RT and CBR.")
xylnatmVplF4F5SegEndpt = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 9, 1, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmVplF4F5SegEndpt.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVplF4F5SegEndpt.setDescription('Future release')
xylnatmVplF4F5CopySeg = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 9, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmVplF4F5CopySeg.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVplF4F5CopySeg.setDescription('Future release')
xylnatmVplF4F5End2EndEndpt = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 9, 1, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmVplF4F5End2EndEndpt.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVplF4F5End2EndEndpt.setDescription('Future release')
xylnatmVplF4F5CopyEnd2End = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 9, 1, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmVplF4F5CopyEnd2End.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVplF4F5CopyEnd2End.setDescription('Future release')
xylnatmVplOamEndpt = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 9, 1, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmVplOamEndpt.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVplOamEndpt.setDescription('Future release')
xylnatmVplOamCopy = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 9, 1, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmVplOamCopy.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVplOamCopy.setDescription('Future release')
xylnatmVplRmFwdEndpt = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 9, 1, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmVplRmFwdEndpt.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVplRmFwdEndpt.setDescription('Future release')
xylnatmVplRmFwdCopy = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 9, 1, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmVplRmFwdCopy.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVplRmFwdCopy.setDescription('Future release')
xylnatmVplRmFwdGcraAdv = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 9, 1, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmVplRmFwdGcraAdv.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVplRmFwdGcraAdv.setDescription('Future release')
xylnatmVplRmBkwdEndpt = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 9, 1, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmVplRmBkwdEndpt.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVplRmBkwdEndpt.setDescription('Future release')
xylnatmVplRmBkwdCopy = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 9, 1, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmVplRmBkwdCopy.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVplRmBkwdCopy.setDescription('Future release')
xylnatmVplRmBkwdGcraAdv = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 9, 1, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmVplRmBkwdGcraAdv.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVplRmBkwdGcraAdv.setDescription('Future release')
xylnatmVplRmDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 9, 1, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmVplRmDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVplRmDiscard.setDescription('Future release')
xylnatmVplGcraAPoliceMode = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 9, 1, 1, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("gcraEmDxAll", 1), ("gcraEmMarkClp0DxClp1", 2), ("gcraEmMarkAllDxAll", 3), ("gcraEmMarkClp0DxAll", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVplGcraAPoliceMode.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVplGcraAPoliceMode.setDescription('Enforcement mode of GcraA as following gcraEmDxAll = Discard all cells on congestion gcraEmMarkClp0DxClp1 = On congestion discard Clp1 cells gcraEmMarkAllDxAll = On congestion mark all gcraEmMarkClp0DxAll = on congestion mark clp0 and discard all')
xylnatmVplGcraBPoliceMode = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 9, 1, 1, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("gcraEmDxAll", 1), ("gcraEmMarkClp0DxClp1", 2), ("gcraEmMarkAllDxAll", 3), ("gcraEmMarkClp0DxAll", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVplGcraBPoliceMode.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVplGcraBPoliceMode.setDescription('Enforcement mode of GcraB as following gcraEmDxAll = Discard all cells on congestion gcraEmMarkClp0DxClp1 = On congestion discard Clp1 cells gcraEmMarkAllDxAll = On congestion mark all gcraEmMarkClp0DxAll = on congestion mark clp0 and discard all')
xylnatmVplMcGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 9, 1, 1, 34), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVplMcGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVplMcGroupId.setDescription('Internal use of multicast group id')
xylnatmVplMcIngressEgress = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 9, 1, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ingress", 1), ("egress", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVplMcIngressEgress.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVplMcIngressEgress.setDescription('Always ingress in this release')
xylnatmVplStatTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 11, 1), )
if mibBuilder.loadTexts: xylnatmVplStatTable.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVplStatTable.setDescription('This table contains the xylan specific statistical object')
xylnatmVplStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 11, 1, 1), ).setIndexNames((0, "XYLAN-CSM-MIB", "xylnatmVplStatSlotIndex"), (0, "XYLAN-CSM-MIB", "xylnatmVplStatPortIndex"), (0, "XYLAN-CSM-MIB", "xylnatmVplStatVpi"))
if mibBuilder.loadTexts: xylnatmVplStatEntry.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVplStatEntry.setDescription('Contains the stats objects')
xylnatmVplStatSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 11, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVplStatSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVplStatSlotIndex.setDescription('The slot number of the chassis')
xylnatmVplStatPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 11, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 25))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVplStatPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVplStatPortIndex.setDescription('The port number on this slot')
xylnatmVplStatVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 11, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVplStatVpi.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVplStatVpi.setDescription('The Vpi number for this connection')
xylnatmVplStatRxCells = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 11, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVplStatRxCells.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVplStatRxCells.setDescription(' The total number of cells received on this connection identified by the slot/port/vpi')
xylnatmVplStatTxCells = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 11, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVplStatTxCells.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVplStatTxCells.setDescription('The total number of cells transmitted on this connection identified by the slot/port/vpi')
xylnatmVplStatRxClp0Cells = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 11, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVplStatRxClp0Cells.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVplStatRxClp0Cells.setDescription('The total number of received cells with Clp0 received on this connection identified by slot/port/vpi')
xylnatmVplStatRxClp1Cells = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 11, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVplStatRxClp1Cells.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVplStatRxClp1Cells.setDescription('The total number of received cells with Clp1 received on this connection identified by slot/port/vpi')
xylnatmVplStatDxCongClp0Cells = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 11, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVplStatDxCongClp0Cells.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVplStatDxCongClp0Cells.setDescription('The total number of cell loss priority zero cells discarded on this connection at this interface identified by the slot/port due to congestion')
xylnatmVplStatDxCongClp1Cells = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 11, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVplStatDxCongClp1Cells.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVplStatDxCongClp1Cells.setDescription('The total number of cell loss priority one cells discarded on this connection at this interface identified by the slot/port due to congestion')
xylnatmVplStatDxGcraClp0Cells = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 11, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVplStatDxGcraClp0Cells.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVplStatDxGcraClp0Cells.setDescription('The number of Clp0 cells discarded on this connection due to policing on Clp0+1 cells')
xylnatmVplStatDxGcraClp1Cells = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 11, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVplStatDxGcraClp1Cells.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVplStatDxGcraClp1Cells.setDescription('The total number of Clp1 cells discarded due to policing on Clp0+1 cells')
xylnatmVplStatDxGcraBClp0Cells = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 11, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVplStatDxGcraBClp0Cells.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVplStatDxGcraBClp0Cells.setDescription('The number of Clp0 cells discarded on this connection due to policing on Clp0+1 cells')
xylnatmVplStatDxGcraBClp1Cells = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 11, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVplStatDxGcraBClp1Cells.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVplStatDxGcraBClp1Cells.setDescription('The total number of Clp1 cells discarded due to policing on Clp0+1 cells')
xylnatmVpCrossConnectTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 14, 1), )
if mibBuilder.loadTexts: xylnatmVpCrossConnectTable.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVpCrossConnectTable.setDescription("The Xyln specific ATM VP Cross Connect table. A bi- directional VP cross-connect which cross-connects two end points (i.e., VPLs) is modeled as one entry in this table. This table along with the xylan VcCrossConnect Table contains all the objects which would enable xylan NMS to create a cross connection without creating VCL's and then cross connecting them. The reason why we prefer this approach is to prevent creation of VCL's which in our architecture is actually a cross connect with all the cells coming in on that vc going to the fabric and then getting switched back on the same vc that it came in. We have also duplicated all the objects in the Vcl table so that they can be set in a single set request.")
xylnatmVpCrossConnectEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 14, 1, 1), ).setIndexNames((0, "XYLAN-CSM-MIB", "xylnatmVpCrossConnectLowSlotIndex"), (0, "XYLAN-CSM-MIB", "xylnatmVpCrossConnectLowPortIndex"), (0, "XYLAN-CSM-MIB", "xylnatmVpCrossConnectLowVpi"), (0, "XYLAN-CSM-MIB", "xylnatmVpCrossConnectHighSlotIndex"), (0, "XYLAN-CSM-MIB", "xylnatmVpCrossConnectHighPortIndex"), (0, "XYLAN-CSM-MIB", "xylnatmVpCrossConnectHighVpi"))
if mibBuilder.loadTexts: xylnatmVpCrossConnectEntry.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVpCrossConnectEntry.setDescription('An entry in the ATM VP Cross Connect table. This entry is used to model a bi-directional ATM VP cross-connect cross-connecting two end points.')
xylnatmVpCrossConnectLowSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 14, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 9))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVpCrossConnectLowSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVpCrossConnectLowSlotIndex.setDescription('The low slot number')
xylnatmVpCrossConnectLowPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 14, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVpCrossConnectLowPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVpCrossConnectLowPortIndex.setDescription('The low physical port number')
xylnatmVpCrossConnectLowVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 14, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVpCrossConnectLowVpi.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVpCrossConnectLowVpi.setDescription('The value of this object is equal to the VPI value at the ATM interface associated with the VP cross-connect that is identified by atmVpCrossConnectLow(Slot/Port)Index. The VPI value cannot exceed the number supported by the atmInterfaceMaxVpiBits at the low ATM interface port.')
xylnatmVpCrossConnectHighSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 14, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 9))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVpCrossConnectHighSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVpCrossConnectHighSlotIndex.setDescription('The value of the high slot number')
xylnatmVpCrossConnectHighPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 14, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVpCrossConnectHighPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVpCrossConnectHighPortIndex.setDescription('The high physical port number')
xylnatmVpCrossConnectHighVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 14, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVpCrossConnectHighVpi.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVpCrossConnectHighVpi.setDescription('The value of this object is equal to the VPI value at the ATM interface associated with the VP cross-connect that is identified by atmVpCrossConnectHigh(Slot/Port)Index. The VPI value cannot exceed the number supported by the atmInterfaceMaxVpiBits at the high ATM interface port.')
xylnatmVpCrossConnectConnectionId = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 14, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("multicastParent", 1), ("multicastChild", 2), ("nonMulticastParent", 3), ("unknown", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVpCrossConnectConnectionId.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVpCrossConnectConnectionId.setDescription('The status of this object indicates whether the said Vc Cross Connection is the parent or a child. If the connection status is unknown, then the value of this object is unknown. Only deletion of the parent is possible when all the child connections have been disconnected. To delete all all parent and child connections, use the VCL table to delete the low VCL.')
xylnatmVpCrossConnectLowRxTrafficDescrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 14, 1, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmVpCrossConnectLowRxTrafficDescrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVpCrossConnectLowRxTrafficDescrIndex.setDescription('The receive traffic descriptor index. The reason why we duplicate this index is to allow the user to change the traffic descriptor without deleting the connection AND without any changes to the RFC1695.mib. RFC1695 describes the traffic descriptor indices only the vcl/vpl tables. Hence if the user wishes to change the TD after creating the cross-connection, then the user has to delete the cross connection to ensire that the receive direction of the low end of the cross connect is equal to the transmit direction of the other VCL at the high end of the cross connect. 10/18/96. Since we dont want to create Vcl without cross connecting them, NMS will now call this table which would allow the creation/deletion and modification of Cross Connect Entries. ')
xylnatmVpCrossConnectLowTxTrafficDescrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 14, 1, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmVpCrossConnectLowTxTrafficDescrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVpCrossConnectLowTxTrafficDescrIndex.setDescription('The transmit traffic descriptor index. The reason why we duplicate this index is to allow the user to change the traffic descriptor without deleting the connection AND without any changes to the RFC1695.mib. RFC1695 describes the traffic descriptor indices only the vcl/vpl tables. Hence if the user wishes to change the TD after creating the cross-connection, then the user has to delete the cross connection to ensire that the receive direction of the low end of the cross connect is equal to the transmit direction of the other VCL at the high end of the cross connect. 10/18/96. Since we dont want to create Vcl without cross connecting them, NMS will now call this table which would allow the creation/deletion and modification of Cross Connect Entries. ')
xylnatmVpCrossConnectMCastEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 14, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmVpCrossConnectMCastEnable.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVpCrossConnectMCastEnable.setDescription('Whether Mcast should be enabled/disabled for this connection')
xylnatmVpCrossConnectL2HLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 14, 1, 1, 11), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVpCrossConnectL2HLastChange.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVpCrossConnectL2HLastChange.setDescription("The value of MIB II's sysUpTime object at the time this VC cross-connect entered its current operational state in low to high direction. If the current state was entered prior to the last re-initialization of the agent, then this object contains a zero value.")
xylnatmVpCrossConnectH2LLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 14, 1, 1, 12), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVpCrossConnectH2LLastChange.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVpCrossConnectH2LLastChange.setDescription("The value of MIB II's sysUpTime object at the time this VC cross-connect entered its current operational state in high to low direction. If the current state was entered prior to the last re-initialization of the agent, then this object contains a zero value.")
xylnatmVpCrossConnectL2HOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 14, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unknown", 1), ("end2endup", 2), ("end2endDown", 3), ("localUpEndToEndUnknown", 4), ("localDown", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVpCrossConnectL2HOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVpCrossConnectL2HOperStatus.setDescription('The value of this object identifies the current operational status of the VC cross-connect in one direction; (i.e., from the low to high direction). The up and down states indicate that this ATM VC cross-connect from low to high direction is operational or not operational respectively. The unknown state indicates that the state of it cannot be determined.')
xylnatmVpCrossConnectH2LOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 14, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unknown", 1), ("end2endup", 2), ("end2endDown", 3), ("localUpEndToEndUnknown", 4), ("localDown", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVpCrossConnectH2LOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVpCrossConnectH2LOperStatus.setDescription('The value of this object identifies the current operational status of the VC cross-connect in one direction; (i.e., from the high to low direction). The up and down states indicate that this ATM VC cross-connect from high to low direction is operational or not operational respectively. The unknown state indicates that the state of it cannot be determined.')
xylnatmVpCrossConnectVcType = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 14, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("pvc", 1), ("svc", 2), ("softPvc", 3), ("control", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVpCrossConnectVcType.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVpCrossConnectVcType.setDescription('The type of VC...Permanent/Switched/Soft/control')
xylnatmVpCrossConnectPvcIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 14, 1, 1, 16), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmVpCrossConnectPvcIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVpCrossConnectPvcIdentifier.setDescription("This is required by NMS to id PVC's across networks")
xylnatmVpCrossConnectRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 14, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("create", 1), ("modify", 2), ("delete", 3), ("active", 4), ("notActive", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmVpCrossConnectRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVpCrossConnectRowStatus.setDescription("This object is used to create, delete or modify a row in this table. To create a new CrossConnect, this object is initially set to 'createAndWait' or 'createAndGo'. This object must not be set to 'active' unless the following columnar objects exist in this row: xylnatmVcCrossConnectLowRxTrafficDescrIndex, xylnatmVcCrossConnectLowTxTrafficDescrIndex. Xylan implements createAndWait along with create&Go as create. Create is basically a superset. In addition, if the local VCL end-point is also the VCC end-point")
xylnatmVcCrossConnectTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 13, 1), )
if mibBuilder.loadTexts: xylnatmVcCrossConnectTable.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVcCrossConnectTable.setDescription('The ATM VC Cross Connect table. A bi- directional VC cross-connect which cross-connects two end points (i.e., VCLs) is modeled as one entry in this table.')
xylnatmVcCrossConnectEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 13, 1, 1), ).setIndexNames((0, "XYLAN-CSM-MIB", "xylnatmVcCrossConnectLowSlotIndex"), (0, "XYLAN-CSM-MIB", "xylnatmVcCrossConnectLowPortIndex"), (0, "XYLAN-CSM-MIB", "xylnatmVcCrossConnectLowVpi"), (0, "XYLAN-CSM-MIB", "xylnatmVcCrossConnectLowVci"), (0, "XYLAN-CSM-MIB", "xylnatmVcCrossConnectHighSlotIndex"), (0, "XYLAN-CSM-MIB", "xylnatmVcCrossConnectHighPortIndex"), (0, "XYLAN-CSM-MIB", "xylnatmVcCrossConnectHighVpi"), (0, "XYLAN-CSM-MIB", "xylnatmVcCrossConnectHighVci"))
if mibBuilder.loadTexts: xylnatmVcCrossConnectEntry.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVcCrossConnectEntry.setDescription('An entry in the ATM VC Cross Connect table. This entry is used to model a bi-directional ATM VC cross-connect cross-connecting two end points.')
xylnatmVcCrossConnectLowSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 13, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVcCrossConnectLowSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVcCrossConnectLowSlotIndex.setDescription('The incoming slot number')
xylnatmVcCrossConnectLowPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 13, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVcCrossConnectLowPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVcCrossConnectLowPortIndex.setDescription('The value of this object is equal to the ATM interface port in this slot for this VC cross-connect. The term low implies that this ATM interface has the numerically lower slot/port value than the other ATM interface identified in the same atmVcCrossConnectEntry.')
xylnatmVcCrossConnectLowVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 13, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVcCrossConnectLowVpi.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVcCrossConnectLowVpi.setDescription('The value of this object is equal to the VPI value at the ATM interface associated with the VC cross-connect that is identified by atmVcCrossConnectLow(Slot/Port)Index. The VPI value cannot exceed the number supported by the atmInterfaceMaxVpiBits at the low ATM interface port.')
xylnatmVcCrossConnectLowVci = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 13, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVcCrossConnectLowVci.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVcCrossConnectLowVci.setDescription('The value of this object is equal to the VCI value at the ATM interface associated with this VC cross-connect that is identified by atmVcCrossConnectLow(Slot/Port)Index. The VCI value cannot exceed the number supported by the atmInterfaceMaxVciBits at the low ATM interface port.')
xylnatmVcCrossConnectHighSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 13, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 9))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVcCrossConnectHighSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVcCrossConnectHighSlotIndex.setDescription('The high port number')
xylnatmVcCrossConnectHighPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 13, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVcCrossConnectHighPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVcCrossConnectHighPortIndex.setDescription('The value of this object is equal to the ATM interface port in this slot for this VC cross-connect. The term high implies that this VC cross-connect that this ATM interface has the numerically higher slot/port value than the other ATM interface identified in the same atmVcCrossConnectEntry.')
xylnatmVcCrossConnectHighVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 13, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVcCrossConnectHighVpi.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVcCrossConnectHighVpi.setDescription('The value of this object is equal to the VPI value at the ATM interface associated with the VC cross-connect that is identified by atmVcCrossConnectHigh(Slot/Port)Index. The VPI value cannot exceed the number supported by the atmInterfaceMaxVpiBits at the high ATM interface port.')
xylnatmVcCrossConnectHighVci = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 13, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVcCrossConnectHighVci.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVcCrossConnectHighVci.setDescription('The value of this object is equal to the VCI value at the ATM interface associated with the VC cross-connect that is identified by atmVcCrossConnectHigh(Slot/Port)Index. The VCI value cannot exceed the number supported by the atmInterfaceMaxVciBits at the high ATM interface port.')
xylnatmVcCrossConnectConnectionId = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 13, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("multicastParent", 1), ("multicastChild", 2), ("nonMulticastParent", 3), ("unknown", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVcCrossConnectConnectionId.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVcCrossConnectConnectionId.setDescription('The status of this object indicates whether the said Vc Cross Connection is the parent or a child. If the connection status is unknown, then the value of this object is unknown. Only deletion of the parent is possible when all the child connections have been disconnected. To delete all all parent and child connections, use the VCL table to delete the low VCL.')
xylnatmVcCrossConnectLowRxTrafficDescrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 13, 1, 1, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmVcCrossConnectLowRxTrafficDescrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVcCrossConnectLowRxTrafficDescrIndex.setDescription('The receive traffic descriptor index. The reason why we duplicate this index is to allow the user to change the traffic descriptor without deleting the connection AND without any changes to the RFC1695.mib. RFC1695 describes the traffic descriptor indices only the vcl/vpl tables. Hence if the user wishes to change the TD after creating the cross-connection, then the user has to delete the cross connection to ensire that the receive direction of the low end of the cross connect is equal to the transmit direction of the other VCL at the high end of the cross connect. 10/18/96. Since we dont want to create Vcl without cross connecting them, NMS will now call this table which would allow the creation/deletion and modification of Cross Connect Entries. ')
xylnatmVcCrossConnectLowTxTrafficDescrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 13, 1, 1, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmVcCrossConnectLowTxTrafficDescrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVcCrossConnectLowTxTrafficDescrIndex.setDescription('The transmit traffic descriptor index. The reason why we duplicate this index is to allow the user to change the traffic descriptor without deleting the connection AND without any changes to the RFC1695.mib. RFC1695 describes the traffic descriptor indices only the vcl/vpl tables. Hence if the user wishes to change the TD after creating the cross-connection, then the user has to delete the cross connection to ensire that the receive direction of the low end of the cross connect is equal to the transmit direction of the other VCL at the high end of the cross connect. 10/18/96. Since we dont want to create Vcl without cross connecting them, NMS will now call this table which would allow the creation/deletion and modification of Cross Connect Entries. ')
xylnatmVcCrossConnectMCastEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 13, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmVcCrossConnectMCastEnable.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVcCrossConnectMCastEnable.setDescription('Enable/disable multicast as per the ui')
xylnatmVcCrossConnectL2HLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 13, 1, 1, 13), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVcCrossConnectL2HLastChange.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVcCrossConnectL2HLastChange.setDescription("The value of MIB II's sysUpTime object at the time this VC cross-connect entered its current operational state in low to high direction. If the current state was entered prior to the last re-initialization of the agent, then this object contains a zero value.")
xylnatmVcCrossConnectH2LLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 13, 1, 1, 14), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVcCrossConnectH2LLastChange.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVcCrossConnectH2LLastChange.setDescription("The value of MIB II's sysUpTime object at the time this VC cross-connect entered its current operational state in high to low direction. If the current state was entered prior to the last re-initialization of the agent, then this object contains a zero value.")
xylnatmVcCrossConnectL2HOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 13, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unknown", 1), ("end2endup", 2), ("end2endDown", 3), ("localUpEndToEndUnknown", 4), ("localDown", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVcCrossConnectL2HOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVcCrossConnectL2HOperStatus.setDescription('The value of this object identifies the current operational status of the VC cross-connect in one direction; (i.e., from the low to high direction). The up and down states indicate that this ATM VC cross-connect from low to high direction is operational or not operational respectively. The unknown state indicates that the state of it cannot be determined.')
xylnatmVcCrossConnectH2LOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 13, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unknown", 1), ("end2endup", 2), ("end2endDown", 3), ("localUpEndToEndUnknown", 4), ("localDown", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVcCrossConnectH2LOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVcCrossConnectH2LOperStatus.setDescription('The value of this object identifies the current operational status of the VC cross-connect in one direction; (i.e., from the high to low direction). The up and down states indicate that this ATM VC cross-connect from high to low direction is operational or not operational respectively. The unknown state indicates that the state of it cannot be determined.')
xylnatmVcCrossConnectVcType = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 13, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("pvc", 1), ("svc", 2), ("softPvc", 3), ("control", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVcCrossConnectVcType.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVcCrossConnectVcType.setDescription('The type of VC...Permanent/Switched/ Soft/control')
xylnatmVcCrossConnectPvcIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 13, 1, 1, 18), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmVcCrossConnectPvcIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVcCrossConnectPvcIdentifier.setDescription("This is required by NMS to identify PVC's across networks")
xylnatmVcCrossConnectRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 13, 1, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("create", 1), ("modify", 2), ("delete", 3), ("active", 4), ("notActive", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmVcCrossConnectRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVcCrossConnectRowStatus.setDescription("This object is used to create, delete or modify a row in this table. To create a new CrossConnect, this object is initially set to 'createAndWait' or 'createAndGo'. This object must not be set to 'active' unless the following columnar objects exist in this row: xylnatmVcCrossConnectLowRxTrafficDescrIndex, xylnatmVcCrossConnectLowTxTrafficDescrIndex. Xylan implements createAndWait along with create&Go as create. Create is basically a superset. In addition, if the local VCL end-point is also the VCC end-point")
xylnatmVplModTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 16, 1), )
if mibBuilder.loadTexts: xylnatmVplModTable.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVplModTable.setDescription('This table contains xylan implementation specific objects')
xylnatmVplModEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 16, 1, 1), ).setIndexNames((0, "XYLAN-CSM-MIB", "xylnatmVplModSlotIndex"), (0, "XYLAN-CSM-MIB", "xylnatmVplModPortIndex"), (0, "XYLAN-CSM-MIB", "xylnatmVplModVplVpi"))
if mibBuilder.loadTexts: xylnatmVplModEntry.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVplModEntry.setDescription('List of xylan specific objects')
xylnatmVplModSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 16, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVplModSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVplModSlotIndex.setDescription('Slot Instance')
xylnatmVplModPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 16, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVplModPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVplModPortIndex.setDescription('Port Instance')
xylnatmVplModVplVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 16, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVplModVplVpi.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVplModVplVpi.setDescription('Vpi instance')
xylnatmVplModDestSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 16, 1, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmVplModDestSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVplModDestSlotIndex.setDescription('Slot Instance')
xylnatmVplModDestPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 16, 1, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmVplModDestPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVplModDestPortIndex.setDescription('Port Instance')
xylnatmVplModDestVplVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 16, 1, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmVplModDestVplVpi.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVplModDestVplVpi.setDescription('Vpi instance')
xylnatmVplModDestStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 16, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("create", 1), ("modify", 2), ("delete", 3), ("active", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmVplModDestStatus.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVplModDestStatus.setDescription('To be in sync with the ui we allow modification')
xylnatmVclModTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 15, 1), )
if mibBuilder.loadTexts: xylnatmVclModTable.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVclModTable.setDescription('This table contains xylan implementation specific objects')
xylnatmVclModEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 15, 1, 1), ).setIndexNames((0, "XYLAN-CSM-MIB", "xylnatmVclModSlotIndex"), (0, "XYLAN-CSM-MIB", "xylnatmVclModPortIndex"), (0, "XYLAN-CSM-MIB", "xylnatmVclModVclVpi"), (0, "XYLAN-CSM-MIB", "xylnatmVclModVclVci"))
if mibBuilder.loadTexts: xylnatmVclModEntry.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVclModEntry.setDescription('List of xylan specific objects')
xylnatmVclModSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 15, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVclModSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVclModSlotIndex.setDescription('Slot Instance')
xylnatmVclModPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 15, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVclModPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVclModPortIndex.setDescription('Port Instance')
xylnatmVclModVclVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 15, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVclModVclVpi.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVclModVclVpi.setDescription('Vpi instance')
xylnatmVclModVclVci = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 15, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmVclModVclVci.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVclModVclVci.setDescription('Vci instance')
xylnatmVclModDestSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 15, 1, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmVclModDestSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVclModDestSlotIndex.setDescription('Slot Instance')
xylnatmVclModDestPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 15, 1, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmVclModDestPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVclModDestPortIndex.setDescription('Port Instance')
xylnatmVclModDestVclVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 15, 1, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmVclModDestVclVpi.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVclModDestVclVpi.setDescription('Vpi instance')
xylnatmVclModDestVclVci = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 15, 1, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmVclModDestVclVci.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVclModDestVclVci.setDescription('Vci instance')
xylnatmVclModDestStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 15, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("create", 1), ("modify", 2), ("delete", 3), ("active", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmVclModDestStatus.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmVclModDestStatus.setDescription('To be in sync with the ui we allow modification')
xylnatmClockingxCtrlTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 17, 1), )
if mibBuilder.loadTexts: xylnatmClockingxCtrlTable.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmClockingxCtrlTable.setDescription('A table of Clocking configuration and control information.')
xylnatmClockingxCtrlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 17, 1, 1), ).setIndexNames((0, "XYLAN-CSM-MIB", "xylnatmClockingxCtrlBusLine"), (0, "XYLAN-CSM-MIB", "xylnatmClockingxCtrlSrcLevel"))
if mibBuilder.loadTexts: xylnatmClockingxCtrlEntry.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmClockingxCtrlEntry.setDescription('An entry in the Clocking Configuration/control table, containing information about Cell Switching Module (CSM) clocking.')
xylnatmClockingxCtrlBusLine = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 17, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eightKhz", 1), ("nineteenMhz", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmClockingxCtrlBusLine.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmClockingxCtrlBusLine.setDescription('The Bus Signal function used for clocking CSM modules. This is used as a unique ID to identify a clocking line on the bus.')
xylnatmClockingxCtrlSrcLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 17, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("primary", 1), ("secondary", 2), ("tertiary", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmClockingxCtrlSrcLevel.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmClockingxCtrlSrcLevel.setDescription('This object identifies which source entry type for this row in the table. Primary is the preffered source, if the primary source clock is not available, then the secondary source (if configured) will be used to drive the bus line. If the primary and secondary are both configured but not available, then the tertiary (if configured) source will be used. If no clock sources are available for this bus line, then all port configured to use the bus line for their local (transmit) clocking, then those ports will switch to their local on-board oscillator.')
xylnatmClockingxSrcOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 17, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("inactive", 1), ("active", 2), ("standby", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmClockingxSrcOperState.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmClockingxSrcOperState.setDescription('This object identifies the state of the clock source. inactive(1) indicates the source is not available for use. active(2) indicates the source is currently being used to drive the bus. standby(3) indicates the source is currently availble for use, but another source is currently being used.')
xylnatmClockingxSrcType = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 17, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notConfigured", 1), ("receiveDataDerived", 2), ("onboardOscillator", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmClockingxSrcType.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmClockingxSrcType.setDescription("This object controls the type of clock used as the source for the bus line. If 'notConfigured', then this source isn't configured. If 'receiveDataDerived' then the source of the clock comes from the specified port's receive data (e.g. calculated using a Phase Lock loop off the receive data line). If 'onboardOscillator' then the source of the clock comes from the on-board oscillator associated with this port. Currently (as of release 3.2) this is only valid with 19.44 Mhz clocking, and not valid for 8 Khz clocking.")
xylnatmClockingxCtrlSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 17, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 9))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmClockingxCtrlSlot.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmClockingxCtrlSlot.setDescription('This object is used to configure the slot of the port used to drive the bus. This object will return 0 if not configured. For setting this object only a non-zero value is allowed and it must be a valid CSM slot.')
xylnatmClockingxCtrlPort = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 17, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmClockingxCtrlPort.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmClockingxCtrlPort.setDescription('This object is used to configure the port number used to drive the bus. This object will return 0 if not configured. For setting this object only a non-zero value is allowed and it must be a valid CSM port that can drive the bus at the proper 8 Khz or 19.44 Mhz speed.')
xylnatmClockingxGlobalCST = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 17, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmClockingxGlobalCST.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmClockingxGlobalCST.setDescription("This object is used to specify the time period (in seconds) that the primary clock source should be up before the switching software resumes its role in driving the bus line. If the clock source goes down within this time period, the secondary source continues to drive the bus line. This prevents the software from doing the switching too often when the clock source isn't stable.")
xylnatmTrafficShaperConfTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 18, 1), )
if mibBuilder.loadTexts: xylnatmTrafficShaperConfTable.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmTrafficShaperConfTable.setDescription("A table of Traffic Shapers' configuration information. Currently, traffic shaping function is available on module types CSM-AB-OC3 and CSM-AB-DS3/E3 only.")
xylnatmTrafficShaperConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 18, 1, 1), ).setIndexNames((0, "XYLAN-CSM-MIB", "xylnatmTrafficShaperConfSlotIndex"), (0, "XYLAN-CSM-MIB", "xylnatmTrafficShaperConfPortIndex"), (0, "XYLAN-CSM-MIB", "xylnatmTrafficShaperConfTsNumIndex"))
if mibBuilder.loadTexts: xylnatmTrafficShaperConfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmTrafficShaperConfEntry.setDescription('An entry in the Traffic Shaper Configuration table containing parameters of the traffic shapers of cell switching module.')
xylnatmTrafficShaperConfSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 18, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 9))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmTrafficShaperConfSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmTrafficShaperConfSlotIndex.setDescription('The slot on which the traffic shaping module resides.')
xylnatmTrafficShaperConfPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 18, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmTrafficShaperConfPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmTrafficShaperConfPortIndex.setDescription('The port on which traffic shaping circuitry resides. A CSM-AB module can have either one or two traffic shaping ports. If the module has one traffic shaping port, then the traffic shaping circuitry is always installed on the first port of the module.')
xylnatmTrafficShaperConfTsNumIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 18, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmTrafficShaperConfTsNumIndex.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmTrafficShaperConfTsNumIndex.setDescription('This object identifies the traffic shaper number on the port. On each port, there are eight traffic shapers whose bandwidth are allocated based on configurabled parameters Cell Delay Variation (CDV), Peak Cell Rate (PCR), Sustainable Cell Rate (SCR) and Maximum Brust Size (MBS).')
xylnatmTrafficShaperConfCDV = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 18, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(7, 1000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmTrafficShaperConfCDV.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmTrafficShaperConfCDV.setDescription('This object is used to specify the Cell Delay Variation of the outgoing cell stream of a shaper. CDV is one of the parameters configured to alter the characteristics of the cell streams to acquire a desired QOS objective. It is the variation in the delay time, induced by buffering cell scheduling, experienced by a cell at network entry and exit points. CDV must be between 7 and 1000 uSec.')
xylnatmTrafficShaperConfPCR = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 18, 1, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmTrafficShaperConfPCR.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmTrafficShaperConfPCR.setDescription('This object is used to configure the Peak Cell Rate of a shaper. PCR is one of the parameters set to alter the characteristics of the cell streams to acquire a desired QOS objective. It is the maximum instantaneous cell rate at which the cell streams are transmited. PCR must be greater than 0 and not exceeds the maximum bandwidth of the physical interface. The bandwidth of the physical interface is devided up to 8 shapers, by default, shaper 8 has the highest bandwidth. PCR value must not exceed the remaining bandwidth of the interface.')
xylnatmTrafficShaperConfSCR = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 18, 1, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmTrafficShaperConfSCR.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmTrafficShaperConfSCR.setDescription('This object is used to configure the Sustainable Cell Rate of a shaper. SCR is the average conforming cell rate an ATM connection measured over a time interval. This measurement allows the network to allocate sufficient resources that are less than those based on PCR and still ensure the achievement of the desired QOS. SCR could be unspecified, value set to 0. If specified, SCR value must be less than the PCR value.')
xylnatmTrafficShaperConfMBS = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 18, 1, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmTrafficShaperConfMBS.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmTrafficShaperConfMBS.setDescription('This object is used to configure the Maximum Brust Size of the outgoing cell streams of a shaper. MBS is one of the parameters set to alter the characteristics of the cell streams to acquire a desired QOS objective. It is the maximum number of back to back cells that can be sent at the peak cell rate. MBS could be unspecified, value set to 0.')
xylnatmTrafficShaperMemTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 19, 1), )
if mibBuilder.loadTexts: xylnatmTrafficShaperMemTable.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmTrafficShaperMemTable.setDescription("A table of Traffic Shapers' VPI/VCI Membership information. Currently, traffic shaping function is available on module types CSM-AB-OC3 and CSM-AB-DS3/E3 only. To have the outgoing cell streams of a connection shaped to a desired characteristic of a shaper, its VPI/VCI needs to be registered to one of the traffic shapers (1..7) of the port. Shaper number eight is designated as the default shaper where cell streams of non-specified VPI/VCI's are routed to. Therefore, VPI/VCI is not registrable to shaper eight.")
xylnatmTrafficShaperMemEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 19, 1, 1), ).setIndexNames((0, "XYLAN-CSM-MIB", "xylnatmTrafficShaperMemSlotIndex"), (0, "XYLAN-CSM-MIB", "xylnatmTrafficShaperMemPortIndex"), (0, "XYLAN-CSM-MIB", "xylnatmTrafficShaperMemTsNumIndex"), (0, "XYLAN-CSM-MIB", "xylnatmTrafficShaperMemVpiNumIndex"), (0, "XYLAN-CSM-MIB", "xylnatmTrafficShaperMemVciNumIndex"))
if mibBuilder.loadTexts: xylnatmTrafficShaperMemEntry.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmTrafficShaperMemEntry.setDescription('An entry in the Traffic Shaper Membership table containing a VPI/VCI number mapping to a traffic shaper number.')
xylnatmTrafficShaperMemSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 19, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 9))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmTrafficShaperMemSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmTrafficShaperMemSlotIndex.setDescription('The slot on which the traffic shaping module resides.')
xylnatmTrafficShaperMemPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 19, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmTrafficShaperMemPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmTrafficShaperMemPortIndex.setDescription('The port on which traffic shaping circuitry resides. A CSM-AB module can have either one or two traffic shaping ports. If the module has one traffic shaping port, then the traffic shaping circuitry is always installed on the first port of the module.')
xylnatmTrafficShaperMemTsNumIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 19, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmTrafficShaperMemTsNumIndex.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmTrafficShaperMemTsNumIndex.setDescription('This object identifies the traffic shaper number on the port. Each port provides mapping of up to 512 VPI/VCI to the eight shapers. Non-specified VPI/VCI is logically mapped to the default shaper (shaper 8). Therefore, VPI/VCI is not registrable to shaper 8.')
xylnatmTrafficShaperMemVpiNumIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 19, 1, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmTrafficShaperMemVpiNumIndex.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmTrafficShaperMemVpiNumIndex.setDescription('This object is used to register a VPI to a traffic shaper. The outgoing cell streams with this VPI is shaped by the traffic shaper it registers to. The valid range is 1-[2^(max_vpi_bits of slot/port) -1].')
xylnatmTrafficShaperMemVciNumIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 19, 1, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmTrafficShaperMemVciNumIndex.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmTrafficShaperMemVciNumIndex.setDescription('This object is used to register a VCI to a traffic shaper. The outgoing cell streams with this VCI is shaped by the traffic shaper it registers to. The valid range is 1-[2^(9-max_vpi_bits of slot port) -1].')
xylnatmTrafficShaperMemVpiOper = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 1, 19, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("add", 2), ("rem", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmTrafficShaperMemVpiOper.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmTrafficShaperMemVpiOper.setDescription('This object is used to register or de-register a VPI/VCI to or out of a traffic shaper. none(1) when VPI/VCI is not registered/ de-register to/from the shaper. No operation. add(2) registers the VPI/VCI to the shaper. Its outgoing cell stream is shaped based on the characteristics of the shaper. rem(3) de-registers the VPI/VCI out of the shaper. When a VPI/VCI is not register to one of the seven shapers (1..7), its outgoing traffic is logically routed to the default shaper (shaper 8) and shaped based on traffic characteristics of shaper 8.')
mibBuilder.exportSymbols("XYLAN-CSM-MIB", xylnatmTrafficShaperMemTable=xylnatmTrafficShaperMemTable, xylnatmClockingxCtrlBusLine=xylnatmClockingxCtrlBusLine, xylnatmVplChanType=xylnatmVplChanType, xylnatmVplF4F5CopyEnd2End=xylnatmVplF4F5CopyEnd2End, atmxInterfaceMaxActiveVpiBits=atmxInterfaceMaxActiveVpiBits, xylnatmILMIConfAutoCfgStatus=xylnatmILMIConfAutoCfgStatus, xylnatmInterfaceTpRedirect=xylnatmInterfaceTpRedirect, xylnatmVplModDestVplVpi=xylnatmVplModDestVplVpi, xylnatmInterfaceStatDxGcrabClp1Cells=xylnatmInterfaceStatDxGcrabClp1Cells, xylnatmVplMcGroupId=xylnatmVplMcGroupId, atmxVclSlotIndex=atmxVclSlotIndex, atmxSvcVcCrossConnectEntry=atmxSvcVcCrossConnectEntry, xylnatmVcCrossConnectHighSlotIndex=xylnatmVcCrossConnectHighSlotIndex, xylnatmInterfaceUniVersion=xylnatmInterfaceUniVersion, atmxVcCrossConnectHighVci=atmxVcCrossConnectHighVci, xylnatmTrafficShaperMemVpiOper=xylnatmTrafficShaperMemVpiOper, xylnatmVclRmBkwdGcraAdv=xylnatmVclRmBkwdGcraAdv, xylnatmVplF4F5CopySeg=xylnatmVplF4F5CopySeg, xylnatmVcCrossConnectHighVci=xylnatmVcCrossConnectHighVci, xylnatmVcCrossConnectHighPortIndex=xylnatmVcCrossConnectHighPortIndex, xylnatmVpCrossConnectH2LOperStatus=xylnatmVpCrossConnectH2LOperStatus, atmxVclCrossConnectIdentifier=atmxVclCrossConnectIdentifier, xylnatmVcCrossConnectH2LLastChange=xylnatmVcCrossConnectH2LLastChange, xylnatmVclModEntry=xylnatmVclModEntry, atmxVclLastChange=atmxVclLastChange, xylnatmVpCrossConnectLowRxTrafficDescrIndex=xylnatmVpCrossConnectLowRxTrafficDescrIndex, atmxTrafficDescrParam4=atmxTrafficDescrParam4, atmxVcCrossConnectRowStatus=atmxVcCrossConnectRowStatus, atmxSvcVcCrossConnectHighVci=atmxSvcVcCrossConnectHighVci, atmxSvcVcCrossConnectHighVpi=atmxSvcVcCrossConnectHighVpi, atmxSvcVpCrossConnectCreationTime=atmxSvcVpCrossConnectCreationTime, xylnatmVpCrossConnectHighSlotIndex=xylnatmVpCrossConnectHighSlotIndex, xylnatmVplModTable=xylnatmVplModTable, xylnatmVclAltTrackPort2=xylnatmVclAltTrackPort2, xylnatmVplPrTrackPort1=xylnatmVplPrTrackPort1, atmxInterfaceMaxVpcs=atmxInterfaceMaxVpcs, xylnatmInterfaceStatEntry=xylnatmInterfaceStatEntry, xylnatmVplTransportPriority=xylnatmVplTransportPriority, xylnatmClockingxCtrlSlot=xylnatmClockingxCtrlSlot, xylnatmVplMcIngressEgress=xylnatmVplMcIngressEgress, atmxSvcVpCrossConnectRowStatus=atmxSvcVpCrossConnectRowStatus, atmxTrafficDescrType=atmxTrafficDescrType, xylnatmVclStatDxGcraBClp0Cells=xylnatmVclStatDxGcraBClp0Cells, xylnatmILMIConfILMIPollEnable=xylnatmILMIConfILMIPollEnable, xylnatmVplVpi=xylnatmVplVpi, xylnatmVclStatRxClp0Cells=xylnatmVclStatRxClp0Cells, xylnatmVclStatRxCells=xylnatmVclStatRxCells, xylnatmVpCrossConnectPvcIdentifier=xylnatmVpCrossConnectPvcIdentifier, xylnatmInterfaceIlmiStatus=xylnatmInterfaceIlmiStatus, xylnatmVplStatDxGcraBClp0Cells=xylnatmVplStatDxGcraBClp0Cells, xylnatmInterfaceDescription=xylnatmInterfaceDescription, xylnatmVplStatRxClp1Cells=xylnatmVplStatRxClp1Cells, xylnatmVplRmBkwdEndpt=xylnatmVplRmBkwdEndpt, xylnatmInterfaceStatTotalDiscardCells=xylnatmInterfaceStatTotalDiscardCells, xylnatmVcCrossConnectH2LOperStatus=xylnatmVcCrossConnectH2LOperStatus, xylnatmVplGroup=xylnatmVplGroup, xylnatmVcCrossConnectGroup=xylnatmVcCrossConnectGroup, xylnatmILMIConfAutoCfgTrigg=xylnatmILMIConfAutoCfgTrigg, xylnatmVclVpi=xylnatmVclVpi, xylnatmTrafficShaperMemGroup=xylnatmTrafficShaperMemGroup, atmxTrafficDescrParamEntry=atmxTrafficDescrParamEntry, atmxSvcVcCrossConnectLowSlotIndex=atmxSvcVcCrossConnectLowSlotIndex, atmxSvcVcCrossConnectTable=atmxSvcVcCrossConnectTable, xylnatmInterfaceConfTable=xylnatmInterfaceConfTable, xylnatmVplUserPriority=xylnatmVplUserPriority, xylnatmVplModDestStatus=xylnatmVplModDestStatus, xylnatmVpCrossConnectConnectionId=xylnatmVpCrossConnectConnectionId, xylnatmVclModGroup=xylnatmVclModGroup, xylnatmVclConnectionDescr=xylnatmVclConnectionDescr, xylnatmInterfaceIlmiState=xylnatmInterfaceIlmiState, xylnatmInterfaceStatMarkEfciCells=xylnatmInterfaceStatMarkEfciCells, xylnatmVclMcGroupId=xylnatmVclMcGroupId, atmxVpCrossConnectL2HOperStatus=atmxVpCrossConnectL2HOperStatus, xylnatmInterfaceStatTable=xylnatmInterfaceStatTable, xylnatmVplPortIndex=xylnatmVplPortIndex, atmxInterfacePortIndex=atmxInterfacePortIndex, xylnatmInterfaceStatDxGcraClp1Cells=xylnatmInterfaceStatDxGcraClp1Cells, xylnatmVclStatVpi=xylnatmVclStatVpi, atmxInterfaceIlmiVpi=atmxInterfaceIlmiVpi, atmxTrafficDescrGroup=atmxTrafficDescrGroup, atmxVplLastChange=atmxVplLastChange, atmxVpCrossConnectHighSlotIndex=atmxVpCrossConnectHighSlotIndex, atmxVplGroup=atmxVplGroup, xylnatmInterfacePortIndex=xylnatmInterfacePortIndex, xylnatmInterfaceStatRxClp0Cells=xylnatmInterfaceStatRxClp0Cells, xylnatmVcCrossConnectL2HOperStatus=xylnatmVcCrossConnectL2HOperStatus, xylnatmTrafficShaperMemTsNumIndex=xylnatmTrafficShaperMemTsNumIndex, atmxVplTable=atmxVplTable, atmxVpCrossConnectLowPortIndex=atmxVpCrossConnectLowPortIndex, xylnatmILMIConfPeerUniType=xylnatmILMIConfPeerUniType, xylnatmILMIConfAutoCfgEnable=xylnatmILMIConfAutoCfgEnable, xylnatmVplTable=xylnatmVplTable, atmxSvcVcCrossConnectHighSlotIndex=atmxSvcVcCrossConnectHighSlotIndex, xylnatmVclF4F5SegEndpt=xylnatmVclF4F5SegEndpt, atmxVclPortIndex=atmxVclPortIndex, xylnatmVcCrossConnectLowRxTrafficDescrIndex=xylnatmVcCrossConnectLowRxTrafficDescrIndex, xylnatmVcCrossConnectVcType=xylnatmVcCrossConnectVcType, xylnatmInterfaceStatUnknownVciCells=xylnatmInterfaceStatUnknownVciCells, xylnatmVclAltTrackPortBase=xylnatmVclAltTrackPortBase, atmxSvcVpCrossConnectHighPortIndex=atmxSvcVpCrossConnectHighPortIndex, xylnatmTrafficShaperConfSCR=xylnatmTrafficShaperConfSCR, xylnatmTrafficShaperConfTable=xylnatmTrafficShaperConfTable, xylnatmInterfaceStatGroup=xylnatmInterfaceStatGroup, xylanCsmMIB=xylanCsmMIB, xylnatmILMIConfPeerILMIVer=xylnatmILMIConfPeerILMIVer, xylnatmVplStatRxClp0Cells=xylnatmVplStatRxClp0Cells, xylnatmVclRmBkwdEndpt=xylnatmVclRmBkwdEndpt, xylnatmInterfaceStatDxCongClp0Cells=xylnatmInterfaceStatDxCongClp0Cells, xylnatmTrafficShaperConfGroup=xylnatmTrafficShaperConfGroup, xylnatmVclModDestStatus=xylnatmVclModDestStatus, atmxVcCrossConnectH2LOperStatus=atmxVcCrossConnectH2LOperStatus, atmxVcCrossConnectL2HLastChange=atmxVcCrossConnectL2HLastChange, xylnatmVclStatsMode=xylnatmVclStatsMode, xylnatmInterfaceStatDxCongClp1Cells=xylnatmInterfaceStatDxCongClp1Cells, xylnatmVcCrossConnectLowVpi=xylnatmVcCrossConnectLowVpi, atmxSvcVcCrossConnectHighTDIndex=atmxSvcVcCrossConnectHighTDIndex, xylnatmVclModPortIndex=xylnatmVclModPortIndex, xylnatmVpCrossConnectGroup=xylnatmVpCrossConnectGroup, xylnatmVclAltTrackPort3=xylnatmVclAltTrackPort3, xylnatmInterfaceLocalSrc=xylnatmInterfaceLocalSrc, atmxVcCrossConnectLowVci=atmxVcCrossConnectLowVci, xylnatmVclStatVci=xylnatmVclStatVci, xylnatmInterfaceClearPortStats=xylnatmInterfaceClearPortStats, atmxVpCrossConnectIndex=atmxVpCrossConnectIndex, xylnatmTrafficShaperConfCDV=xylnatmTrafficShaperConfCDV, atmxVcCrossConnectGroup=atmxVcCrossConnectGroup, atmxVplBidirect=atmxVplBidirect, atmxSvcVpCrossConnectLowSlotIndex=atmxSvcVpCrossConnectLowSlotIndex, xylnatmClockingxGlobalCST=xylnatmClockingxGlobalCST, xylnatmVclStatPortIndex=xylnatmVclStatPortIndex, xylnatmVplStatDxCongClp0Cells=xylnatmVplStatDxCongClp0Cells, xylnatmVclPortIndex=xylnatmVclPortIndex, atmxVclReceiveTrafficDescrIndex=atmxVclReceiveTrafficDescrIndex, xylnatmVclTable=xylnatmVclTable, xylnatmVclOamEndpt=xylnatmVclOamEndpt, xylnatmVclStatRxClp1Cells=xylnatmVclStatRxClp1Cells, xylnatmVpCrossConnectHighPortIndex=xylnatmVpCrossConnectHighPortIndex, xylnatmVpCrossConnectLowSlotIndex=xylnatmVpCrossConnectLowSlotIndex, xylnatmVclStatDxGcraClp0Cells=xylnatmVclStatDxGcraClp0Cells, xylnatmTrafficShaperConfTsNumIndex=xylnatmTrafficShaperConfTsNumIndex, atmxSvcVcCrossConnectLowTDIndex=atmxSvcVcCrossConnectLowTDIndex, atmxVclTable=atmxVclTable, xylnatmInterfaceCutOverPort=xylnatmInterfaceCutOverPort, atmxVccAal5EncapsType=atmxVccAal5EncapsType, xylnatmVplAltTrackPort2=xylnatmVplAltTrackPort2, xylnatmVcCrossConnectHighVpi=xylnatmVcCrossConnectHighVpi, xylnatmInterfaceOperStatus=xylnatmInterfaceOperStatus, xylnatmVplStatGroup=xylnatmVplStatGroup, atmxVpCrossConnectLowSlotIndex=atmxVpCrossConnectLowSlotIndex, xylnatmVplOamEndpt=xylnatmVplOamEndpt, xylnatmVplF4F5End2EndEndpt=xylnatmVplF4F5End2EndEndpt, xylnatmInterfaceMediaType=xylnatmInterfaceMediaType, xylnatmInterfaceStatRemainingTxBandwidth=xylnatmInterfaceStatRemainingTxBandwidth, xylnatmVplStatPortIndex=xylnatmVplStatPortIndex, xylnatmVplStatSlotIndex=xylnatmVplStatSlotIndex, atmxVpCrossConnectHighPortIndex=atmxVpCrossConnectHighPortIndex, atmxVplVpi=atmxVplVpi, xylnatmVplOamCopy=xylnatmVplOamCopy, xylnatmVclModSlotIndex=xylnatmVclModSlotIndex, xylnatmInterfaceStatMarkGcraCells=xylnatmInterfaceStatMarkGcraCells, xylnatmVplEntry=xylnatmVplEntry, atmxTrafficDescrParam5=atmxTrafficDescrParam5, xylnatmVclGcraAPoliceMode=xylnatmVclGcraAPoliceMode, atmxInterfaceIlmiVci=atmxInterfaceIlmiVci, atmxSvcVpCrossConnectTable=atmxSvcVpCrossConnectTable, xylnatmILMIConfSlot=xylnatmILMIConfSlot, xylnatmVplStatTable=xylnatmVplStatTable, xylnatmTrafficShaperConfSlotIndex=xylnatmTrafficShaperConfSlotIndex, xylnatmClockingxSrcType=xylnatmClockingxSrcType, xylnatmVcCrossConnectEntry=xylnatmVcCrossConnectEntry, xylnatmVclAAL5Discard=xylnatmVclAAL5Discard, xylnatmVplStatDxGcraClp1Cells=xylnatmVplStatDxGcraClp1Cells, xylnatmVplStatEntry=xylnatmVplStatEntry, xylnatmInterfaceStatUnknownVpiCells=xylnatmInterfaceStatUnknownVpiCells, atmxVpCrossConnectLowVpi=atmxVpCrossConnectLowVpi, xylnatmVplAltTrackPort3=xylnatmVplAltTrackPort3, xylnatmTrafficShaperConfEntry=xylnatmTrafficShaperConfEntry, atmxVpCrossConnectTable=atmxVpCrossConnectTable, xylnatmVpCrossConnectEntry=xylnatmVpCrossConnectEntry, xylnatmVplAltTrackPort1=xylnatmVplAltTrackPort1, xylnatmILMIConfPeerUniVer=xylnatmILMIConfPeerUniVer, xylnatmVclRmFwdCopy=xylnatmVclRmFwdCopy, xylnatmVclGcraBPoliceMode=xylnatmVclGcraBPoliceMode, xylnatmVplPrTrackPort3=xylnatmVplPrTrackPort3, xylnatmVcCrossConnectLowTxTrafficDescrIndex=xylnatmVcCrossConnectLowTxTrafficDescrIndex, xylnatmVplPrTrackPort2=xylnatmVplPrTrackPort2, xylnatmILMIConfILMIEnable=xylnatmILMIConfILMIEnable, atmxVplAdminStatus=atmxVplAdminStatus, atmxVccAalType=atmxVccAalType, xylnatmVclGroup=xylnatmVclGroup, atmxInterfaceConfGroup=atmxInterfaceConfGroup, xylnatmILMIConfPort=xylnatmILMIConfPort, atmxVpCrossConnectHighVpi=atmxVpCrossConnectHighVpi, xylnatmVclStatSlotIndex=xylnatmVclStatSlotIndex, xylnatmTrafficShaperMemPortIndex=xylnatmTrafficShaperMemPortIndex, xylnatmInterfaceAtmAddress=xylnatmInterfaceAtmAddress, xylnatmVplStatDxGcraBClp1Cells=xylnatmVplStatDxGcraBClp1Cells, xylnatmILMIConfAutoCfgCurSigVer=xylnatmILMIConfAutoCfgCurSigVer, atmxSvcVcCrossConnectLowPortIndex=atmxSvcVcCrossConnectLowPortIndex, atmxTrafficDescrParamIndex=atmxTrafficDescrParamIndex, atmxSvcVcCrossConnectLowVpi=atmxSvcVcCrossConnectLowVpi, atmxSvcVpCrossConnectEntry=atmxSvcVpCrossConnectEntry, xylnatmVclStatTable=xylnatmVclStatTable, xylnatmInterfaceStatDxGcraClp0Cells=xylnatmInterfaceStatDxGcraClp0Cells, xylnatmVplModEntry=xylnatmVplModEntry, atmxVclAdminStatus=atmxVclAdminStatus, xylnatmVplConnectionDescr=xylnatmVplConnectionDescr, xylnatmVclLgclChanRedirect=xylnatmVclLgclChanRedirect, xylnatmVplAltTrackPortBase=xylnatmVplAltTrackPortBase, atmxVpCrossConnectGroup=atmxVpCrossConnectGroup, xylnatmILMIConfEntry=xylnatmILMIConfEntry, xylnatmInterfaceStatUnknownVpVcCells=xylnatmInterfaceStatUnknownVpVcCells, xylnatmVpCrossConnectRowStatus=xylnatmVpCrossConnectRowStatus, atmxVcCrossConnectLowVpi=atmxVcCrossConnectLowVpi, atmxVcCrossConnectHighPortIndex=atmxVcCrossConnectHighPortIndex, xylnatmInterfaceType=xylnatmInterfaceType, xylnatmILMIConfPeerNNISigVer=xylnatmILMIConfPeerNNISigVer, xylnatmILMIConfPeerDevType=xylnatmILMIConfPeerDevType, atmxInterfaceConfTable=atmxInterfaceConfTable, xylnatmVclStatGroup=xylnatmVclStatGroup, xylnatmVplRmBkwdCopy=xylnatmVplRmBkwdCopy, atmxSvcVcCrossConnectHighPortIndex=atmxSvcVcCrossConnectHighPortIndex, xylnatmInterfaceSlotIndex=xylnatmInterfaceSlotIndex, xylnatmVplModPortIndex=xylnatmVplModPortIndex, xylnatmVcCrossConnectConnectionId=xylnatmVcCrossConnectConnectionId, xylnatmVclStatEntry=xylnatmVclStatEntry, xylnatmVcCrossConnectL2HLastChange=xylnatmVcCrossConnectL2HLastChange, xylnatmVclUserPriority=xylnatmVclUserPriority, xylnatmILMIConfInstance=xylnatmILMIConfInstance, atmxVplRowStatus=atmxVplRowStatus, xylnatmVplRmFwdGcraAdv=xylnatmVplRmFwdGcraAdv, atmxVcCrossConnectL2HOperStatus=atmxVcCrossConnectL2HOperStatus, xylnatmTrafficShaperMemVciNumIndex=xylnatmTrafficShaperMemVciNumIndex, atmxVplPortIndex=atmxVplPortIndex, xylnatmVclRmDiscard=xylnatmVclRmDiscard, xylnatmVplRmFwdEndpt=xylnatmVplRmFwdEndpt, atmxVcCrossConnectEntry=atmxVcCrossConnectEntry, xylnatmVplStatDxCongClp1Cells=xylnatmVplStatDxCongClp1Cells, xylnatmInterfaceStatRxClp1Cells=xylnatmInterfaceStatRxClp1Cells, xylnatmTrafficShaperConfMBS=xylnatmTrafficShaperConfMBS, xylnatmVclPrTrackPortBase=xylnatmVclPrTrackPortBase, xylnatmVclModTable=xylnatmVclModTable, atmxVclOperStatus=atmxVclOperStatus, xylnatmClockingxCtrlEntry=xylnatmClockingxCtrlEntry, atmxVpCrossConnectH2LOperStatus=atmxVpCrossConnectH2LOperStatus, xylnatmInterfaceStatPortIndex=xylnatmInterfaceStatPortIndex, xylnatmVplModDestSlotIndex=xylnatmVplModDestSlotIndex, xylnatmVclModDestPortIndex=xylnatmVclModDestPortIndex, atmxVplCrossConnectIdentifier=atmxVplCrossConnectIdentifier, xylnatmVplRmBkwdGcraAdv=xylnatmVplRmBkwdGcraAdv, atmxInterfaceConfVccs=atmxInterfaceConfVccs, xylnatmVclEntry=xylnatmVclEntry, xylnatmVcCrossConnectPvcIdentifier=xylnatmVcCrossConnectPvcIdentifier, xylnatmInterfaceStatUniVersion=xylnatmInterfaceStatUniVersion)
mibBuilder.exportSymbols("XYLAN-CSM-MIB", atmxInterfaceConfVpcs=atmxInterfaceConfVpcs, xylnatmClockingxSrcOperState=xylnatmClockingxSrcOperState, xylnatmInterfaceTransmissionType=xylnatmInterfaceTransmissionType, atmxVclGroup=atmxVclGroup, xylnatmVpCrossConnectLowTxTrafficDescrIndex=xylnatmVpCrossConnectLowTxTrafficDescrIndex, atmxVpCrossConnectEntry=atmxVpCrossConnectEntry, atmxInterfaceAddressType=atmxInterfaceAddressType, xylnatmVclRmBkwdCopy=xylnatmVclRmBkwdCopy, xylnatmTrafficShaperConfPortIndex=xylnatmTrafficShaperConfPortIndex, xylnatmVcCrossConnectTable=xylnatmVcCrossConnectTable, xylnatmClockingxCtrlSrcLevel=xylnatmClockingxCtrlSrcLevel, atmxVccAal5CpcsReceiveSduSize=atmxVccAal5CpcsReceiveSduSize, xylnatmInterfaceStatRemainingRxBandwidth=xylnatmInterfaceStatRemainingRxBandwidth, xylnatmVclChanType=xylnatmVclChanType, xylnatmTrafficShaperMemSlotIndex=xylnatmTrafficShaperMemSlotIndex, xylnatmVclPrTrackPort1=xylnatmVclPrTrackPort1, xylnatmVclStatDxCongClp1Cells=xylnatmVclStatDxCongClp1Cells, atmxSvcVpCrossConnectHighVpi=atmxSvcVpCrossConnectHighVpi, atmxVplOperStatus=atmxVplOperStatus, xylnatmVplModGroup=xylnatmVplModGroup, atmxVclVci=atmxVclVci, atmxVclVpi=atmxVclVpi, xylnatmInterfaceStatRxCells=xylnatmInterfaceStatRxCells, xylnatmVpCrossConnectLowPortIndex=xylnatmVpCrossConnectLowPortIndex, xylnatmTrafficShaperConfPCR=xylnatmTrafficShaperConfPCR, atmxTrafficDescrParam1=atmxTrafficDescrParam1, atmxVcCrossConnectAdminStatus=atmxVcCrossConnectAdminStatus, xylnatmInterfaceConfGroup=xylnatmInterfaceConfGroup, atmxVcCrossConnectLowPortIndex=atmxVcCrossConnectLowPortIndex, xylnatmInterfaceClearSlotStats=xylnatmInterfaceClearSlotStats, xylnatmVpCrossConnectTable=xylnatmVpCrossConnectTable, xylnatmVclVci=xylnatmVclVci, atmxVpCrossConnectH2LLastChange=atmxVpCrossConnectH2LLastChange, xylnatmInterfaceClearChanStats=xylnatmInterfaceClearChanStats, xylnatmInterfaceStatDxGcrabClp0Cells=xylnatmInterfaceStatDxGcrabClp0Cells, xylnatmVpCrossConnectL2HLastChange=xylnatmVpCrossConnectL2HLastChange, atmxVclRowStatus=atmxVclRowStatus, atmxSvcVcCrossConnectRowStatus=atmxSvcVcCrossConnectRowStatus, xylnatmInterfaceStatUniType=xylnatmInterfaceStatUniType, atmxTrafficDescrParamTable=atmxTrafficDescrParamTable, xylnatmVpCrossConnectVcType=xylnatmVpCrossConnectVcType, xylnatmVplAAL5Discard=xylnatmVplAAL5Discard, xylnatmVclModDestSlotIndex=xylnatmVclModDestSlotIndex, xylnatmILMIConfAutoCfgDfltSigVer=xylnatmILMIConfAutoCfgDfltSigVer, atmxVcCrossConnectTable=atmxVcCrossConnectTable, atmxInterfaceSlotIndex=atmxInterfaceSlotIndex, atmxVpCrossConnectAdminStatus=atmxVpCrossConnectAdminStatus, atmxSvcVcCrossConnectLowVci=atmxSvcVcCrossConnectLowVci, xylnatmVcCrossConnectMCastEnable=xylnatmVcCrossConnectMCastEnable, xylnatmVclOamCopy=xylnatmVclOamCopy, xylnatmVpCrossConnectHighVpi=xylnatmVpCrossConnectHighVpi, xylnatmVpCrossConnectLowVpi=xylnatmVpCrossConnectLowVpi, xylnatmTrafficShaperMemEntry=xylnatmTrafficShaperMemEntry, xylnatmInterfaceStatSlotIndex=xylnatmInterfaceStatSlotIndex, xylnatmVclRmFwdEndpt=xylnatmVclRmFwdEndpt, atmxInterfaceConfEntry=atmxInterfaceConfEntry, xylnatmILMIConfAutoCfgDfltIf=xylnatmILMIConfAutoCfgDfltIf, xylnatmVclF4F5CopyEnd2End=xylnatmVclF4F5CopyEnd2End, atmxSvcVpCrossConnectHighSlotIndex=atmxSvcVpCrossConnectHighSlotIndex, xylnatmVclModDestVclVci=xylnatmVclModDestVclVci, atmxTrafficDescrRowStatus=atmxTrafficDescrRowStatus, xylnatmVplModDestPortIndex=xylnatmVplModDestPortIndex, xylnatmVpCrossConnectMCastEnable=xylnatmVpCrossConnectMCastEnable, xylnatmInterfacePortMode=xylnatmInterfacePortMode, atmxVcCrossConnectLowSlotIndex=atmxVcCrossConnectLowSlotIndex, xylnatmVclStatDxCongClp0Cells=xylnatmVclStatDxCongClp0Cells, xylnatmTrafficShaperMemVpiNumIndex=xylnatmTrafficShaperMemVpiNumIndex, atmxVpCrossConnectRowStatus=atmxVpCrossConnectRowStatus, xylnatmVclStatDxGcraClp1Cells=xylnatmVclStatDxGcraClp1Cells, atmxVclBidirect=atmxVclBidirect, atmxVplSlotIndex=atmxVplSlotIndex, xylnatmVcCrossConnectLowSlotIndex=xylnatmVcCrossConnectLowSlotIndex, xylnatmInterfaceQsaalStatus=xylnatmInterfaceQsaalStatus, xylnatmVclRmFwdGcraAdv=xylnatmVclRmFwdGcraAdv, atmxVccAal5CpcsTransmitSduSize=atmxVccAal5CpcsTransmitSduSize, xylnatmVclSlotIndex=xylnatmVclSlotIndex, atmxSvcVpCrossConnectLowVpi=atmxSvcVpCrossConnectLowVpi, xylnatmVplRmFwdCopy=xylnatmVplRmFwdCopy, atmxSvcVpCrossConnectLowTDIndex=atmxSvcVpCrossConnectLowTDIndex, xylnatmVplRmDiscard=xylnatmVplRmDiscard, xylnatmILMIConfTable=xylnatmILMIConfTable, xylnatmILMIConfAutoCfgCurILMIVer=xylnatmILMIConfAutoCfgCurILMIVer, xylnatmVclPrTrackPort2=xylnatmVclPrTrackPort2, xylnatmVplLgclChanRedirect=xylnatmVplLgclChanRedirect, xylnatmVplF4F5SegEndpt=xylnatmVplF4F5SegEndpt, atmxVclEntry=atmxVclEntry, xylnatmVplPrTrackPortBase=xylnatmVplPrTrackPortBase, xylnatmVpCrossConnectH2LLastChange=xylnatmVpCrossConnectH2LLastChange, xylnatmVplSlotIndex=xylnatmVplSlotIndex, atmxInterfaceMaxActiveVciBits=atmxInterfaceMaxActiveVciBits, xylnatmVpCrossConnectL2HOperStatus=xylnatmVpCrossConnectL2HOperStatus, xylnatmVclMcIngressEgress=xylnatmVclMcIngressEgress, xylnatmInterfaceCutOverSlot=xylnatmInterfaceCutOverSlot, xylnatmClockingxCtrlPort=xylnatmClockingxCtrlPort, xylnatmVplGcraAPoliceMode=xylnatmVplGcraAPoliceMode, xylnatmInterfaceTransType=xylnatmInterfaceTransType, xylnatmVplStatDxGcraClp0Cells=xylnatmVplStatDxGcraClp0Cells, atmxInterfaceMaxVccs=atmxInterfaceMaxVccs, xylnatmVplModVplVpi=xylnatmVplModVplVpi, xylnatmVcCrossConnectLowVci=xylnatmVcCrossConnectLowVci, xylnatmVplStatTxCells=xylnatmVplStatTxCells, atmxVplReceiveTrafficDescrIndex=atmxVplReceiveTrafficDescrIndex, atmxVplTransmitTrafficDescrIndex=atmxVplTransmitTrafficDescrIndex, xylnatmVcCrossConnectRowStatus=xylnatmVcCrossConnectRowStatus, xylnatmVclModVclVci=xylnatmVclModVclVci, xylnatmVclPrTrackPort3=xylnatmVclPrTrackPort3, xylnatmClockingxCtrlTable=xylnatmClockingxCtrlTable, atmxVclTransmitTrafficDescrIndex=atmxVclTransmitTrafficDescrIndex, xylnatmClockingxCtrlGroup=xylnatmClockingxCtrlGroup, xylnatmInterfaceConfEntry=xylnatmInterfaceConfEntry, atmxVpCrossConnectL2HLastChange=atmxVpCrossConnectL2HLastChange, atmxTrafficQoSClass=atmxTrafficQoSClass, atmxTrafficDescrParam2=atmxTrafficDescrParam2, AtmxTrafficDescrParamIndex=AtmxTrafficDescrParamIndex, xylnatmVplStatVpi=xylnatmVplStatVpi, atmxSvcVpCrossConnectLowPortIndex=atmxSvcVpCrossConnectLowPortIndex, atmxVcCrossConnectHighVpi=atmxVcCrossConnectHighVpi, atmxVcCrossConnectH2LLastChange=atmxVcCrossConnectH2LLastChange, atmxVplEntry=atmxVplEntry, atmxVcCrossConnectIndex=atmxVcCrossConnectIndex, atmxSvcVpCrossConnectHighTDIndex=atmxSvcVpCrossConnectHighTDIndex, xylnatmVclStatTxCells=xylnatmVclStatTxCells, atmxVcCrossConnectHighSlotIndex=atmxVcCrossConnectHighSlotIndex, xylnatmVclF4F5End2EndEndpt=xylnatmVclF4F5End2EndEndpt, xylnatmVclAltTrackPort1=xylnatmVclAltTrackPort1, xylnatmVclF4F5CopySeg=xylnatmVclF4F5CopySeg, xylnatmVplModSlotIndex=xylnatmVplModSlotIndex, xylnatmInterfaceStatTxCells=xylnatmInterfaceStatTxCells, xylnatmVclTransportPriority=xylnatmVclTransportPriority, xylnatmVclStatDxGcraBClp1Cells=xylnatmVclStatDxGcraBClp1Cells, xylnatmVcCrossConnectLowPortIndex=xylnatmVcCrossConnectLowPortIndex, atmxSvcVcCrossConnectCreationTime=atmxSvcVcCrossConnectCreationTime, xylnatmInterfaceTimingMode=xylnatmInterfaceTimingMode, xylnatmILMIConfAutoCfgCurIf=xylnatmILMIConfAutoCfgCurIf, xylnatmVplStatRxCells=xylnatmVplStatRxCells, xylnatmVclModDestVclVpi=xylnatmVclModDestVclVpi, xylnatmVplStatsMode=xylnatmVplStatsMode, xylnatmVplGcraBPoliceMode=xylnatmVplGcraBPoliceMode, xylnatmVclModVclVpi=xylnatmVclModVclVpi, atmxTrafficDescrParam3=atmxTrafficDescrParam3)

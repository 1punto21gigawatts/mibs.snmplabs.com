#
# PySNMP MIB module EATON-PXG-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/EATON-PXG-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:59:09 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, SingleValueConstraint, ConstraintsUnion, ValueSizeConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsUnion", "ValueSizeConstraint", "ConstraintsIntersection")
powerChain, = mibBuilder.importSymbols("EATON-OIDS", "powerChain")
entPhysicalName, = mibBuilder.importSymbols("ENTITY-MIB", "entPhysicalName")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
ObjectGroup, NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "NotificationGroup", "ModuleCompliance")
Unsigned32, NotificationType, Integer32, iso, IpAddress, MibScalar, MibTable, MibTableRow, MibTableColumn, ObjectIdentity, ModuleIdentity, Counter64, TimeTicks, Gauge32, Bits, MibIdentifier, Counter32 = mibBuilder.importSymbols("SNMPv2-SMI", "Unsigned32", "NotificationType", "Integer32", "iso", "IpAddress", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ObjectIdentity", "ModuleIdentity", "Counter64", "TimeTicks", "Gauge32", "Bits", "MibIdentifier", "Counter32")
TimeStamp, DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "TimeStamp", "DisplayString", "TextualConvention")
pxgMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 534, 8, 1))
pxgMIB.setRevisions(('2008-01-30 00:00', '2007-07-05 00:00', '2007-04-10 00:00', '2007-01-03 00:00', '2006-10-13 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: pxgMIB.setRevisionsDescriptions(('Added powerChainAlarmUpdated and notes.', 'Used accessible-for-notify where appropriate for trap-only vars.', 'Renamed from TOOLKIT-MIB to better EATON-PXG-MIB. Added powerChainAlarmClosed trap and closed alarmLevel.', 'Added activeAlarmsTable and corresponding Notifications.', 'Initial Version of pxgMIB. Provides Notifications and supporting objects.',))
if mibBuilder.loadTexts: pxgMIB.setLastUpdated('200801300000Z')
if mibBuilder.loadTexts: pxgMIB.setOrganization('Eaton Corporation')
if mibBuilder.loadTexts: pxgMIB.setContactInfo('Eaton Power Quality Technical Support (PQTS) group www.eaton.com/powerxpert Technical Resource Center phone numbers United States: 1.800.843.9433 or 919.870.3028 Canada: 1.800.461.9166 ext. 260 All other countries: Call your local service representative.')
if mibBuilder.loadTexts: pxgMIB.setDescription("The MIB module for objects and notifications supported by Eaton's Toolkit-enabled Power Xpert Gateways. Copyright (C) Eaton Corporation (2006-2007).")
pxgMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 534, 8, 1, 1))
eventInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 534, 8, 1, 1, 1))
alarms = MibIdentifier((1, 3, 6, 1, 4, 1, 534, 8, 1, 1, 2))
eventID = MibScalar((1, 3, 6, 1, 4, 1, 534, 8, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: eventID.setStatus('current')
if mibBuilder.loadTexts: eventID.setDescription('A unique identifier for the event.')
eventSequenceIndex = MibScalar((1, 3, 6, 1, 4, 1, 534, 8, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: eventSequenceIndex.setStatus('current')
if mibBuilder.loadTexts: eventSequenceIndex.setDescription('A unique identifier for a sequence of events using the same EventId.')
eventDescription = MibScalar((1, 3, 6, 1, 4, 1, 534, 8, 1, 1, 1, 3), SnmpAdminString()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: eventDescription.setStatus('current')
if mibBuilder.loadTexts: eventDescription.setDescription('A human-readable text description of the Event or Alarm.')
eventValue = MibScalar((1, 3, 6, 1, 4, 1, 534, 8, 1, 1, 1, 4), SnmpAdminString()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: eventValue.setStatus('current')
if mibBuilder.loadTexts: eventValue.setDescription("A human-readable text representation of the source and value of the node that caused the Event or Alarm. This text should be of the form 'SourcePath = Value' where SourcePath is the address of the node within the BACnetWS+ node tree, as accessed with web service calls.")
numAlarmsPresent = MibScalar((1, 3, 6, 1, 4, 1, 534, 8, 1, 1, 2, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: numAlarmsPresent.setStatus('current')
if mibBuilder.loadTexts: numAlarmsPresent.setDescription('The present number of active alarm conditions.')
activeAlarmsTable = MibTable((1, 3, 6, 1, 4, 1, 534, 8, 1, 1, 2, 2), )
if mibBuilder.loadTexts: activeAlarmsTable.setStatus('current')
if mibBuilder.loadTexts: activeAlarmsTable.setDescription('A list of alarm table entries. The table contains zero, one, or many rows at any moment, depending upon the number of alarm conditions in effect. The table is initially empty at agent startup. The agent creates a row in the table each time an alarm condition is detected and deletes that row when that alarm is no longer active. The numbering of the table entries, using alarmID, is sparse. The number of rows in the table at any given time is reflected by the value of numAlarmsPresent.')
activeAlarmsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 534, 8, 1, 1, 2, 2, 1), ).setIndexNames((0, "EATON-PXG-MIB", "alarmID"))
if mibBuilder.loadTexts: activeAlarmsEntry.setStatus('current')
if mibBuilder.loadTexts: activeAlarmsEntry.setDescription('An entry containing information applicable to a particular alarm.')
alarmID = MibTableColumn((1, 3, 6, 1, 4, 1, 534, 8, 1, 1, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: alarmID.setStatus('current')
if mibBuilder.loadTexts: alarmID.setDescription('A unique identifier for the alarm. This var is not-accessible when browsing the table.')
alarmSequenceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 534, 8, 1, 1, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: alarmSequenceIndex.setStatus('current')
if mibBuilder.loadTexts: alarmSequenceIndex.setDescription('A unique identifier for a sequence of alarms using the same alarmID.')
alarmDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 534, 8, 1, 1, 2, 2, 1, 3), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alarmDescription.setStatus('current')
if mibBuilder.loadTexts: alarmDescription.setDescription('A human-readable text description of the Event or Alarm.')
alarmValue = MibTableColumn((1, 3, 6, 1, 4, 1, 534, 8, 1, 1, 2, 2, 1, 4), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alarmValue.setStatus('current')
if mibBuilder.loadTexts: alarmValue.setDescription("A human-readable text representation of the source and value of the node that caused the Event or Alarm. This text should be of the form 'SourcePath = Value' where SourcePath is the address of the node within the BACnetWS+ node tree, as accessed with web service calls.")
alarmLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 534, 8, 1, 1, 2, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("critical", 1), ("cautionary", 2), ("acknowledged", 3), ("active", 4), ("cleared", 5), ("closed", 6), ("unknown", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: alarmLevel.setStatus('current')
if mibBuilder.loadTexts: alarmLevel.setDescription('Enumerated value that tells the present level (status) of an activeAlarmsEntry. critical (1) - The alarm is at a critical level. cautionary (2) - The alarm is at a cautionary level (a less severe level than critical). acknowledged (3) - The user has acknowledged, but not yet closed, the cautionary or critical alarm. active (4) - Not used; would be a status for an event. cleared (5) - A transient internal level, not normally seen. closed (6) - A transient internal level, not normally seen because the activeAlarmsEntry is removed when closed. unknown (7) - Alarm status is not known. Not normally seen.')
alarmTime = MibTableColumn((1, 3, 6, 1, 4, 1, 534, 8, 1, 1, 2, 2, 1, 6), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alarmTime.setStatus('current')
if mibBuilder.loadTexts: alarmTime.setDescription('The value of sysUpTime when the alarm condition was detected. If the alarm condition was detected at the time of agent startup and presumably existed before agent startup, the value of alarmTime shall equal 0.')
pxgNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 534, 8, 1, 0))
powerChainCriticalAlarmEvent = NotificationType((1, 3, 6, 1, 4, 1, 534, 8, 1, 0, 1)).setObjects(("EATON-PXG-MIB", "eventID"), ("EATON-PXG-MIB", "eventSequenceIndex"), ("EATON-PXG-MIB", "eventDescription"), ("EATON-PXG-MIB", "eventValue"), ("ENTITY-MIB", "entPhysicalName"))
if mibBuilder.loadTexts: powerChainCriticalAlarmEvent.setStatus('current')
if mibBuilder.loadTexts: powerChainCriticalAlarmEvent.setDescription('A Critical Alarm has occurred in a Power Chain Device. Alarm and source information are contained in the OBJECTS.')
powerChainCautionaryAlarmEvent = NotificationType((1, 3, 6, 1, 4, 1, 534, 8, 1, 0, 2)).setObjects(("EATON-PXG-MIB", "eventID"), ("EATON-PXG-MIB", "eventSequenceIndex"), ("EATON-PXG-MIB", "eventDescription"), ("EATON-PXG-MIB", "eventValue"), ("ENTITY-MIB", "entPhysicalName"))
if mibBuilder.loadTexts: powerChainCautionaryAlarmEvent.setStatus('current')
if mibBuilder.loadTexts: powerChainCautionaryAlarmEvent.setDescription('A Cautionary Alarm has occurred in a Power Chain Device. Alarm and source information are contained in the OBJECTS.')
powerChainAlarmEventAcknowledged = NotificationType((1, 3, 6, 1, 4, 1, 534, 8, 1, 0, 3)).setObjects(("EATON-PXG-MIB", "eventID"), ("EATON-PXG-MIB", "eventSequenceIndex"), ("EATON-PXG-MIB", "eventDescription"), ("EATON-PXG-MIB", "eventValue"), ("ENTITY-MIB", "entPhysicalName"))
if mibBuilder.loadTexts: powerChainAlarmEventAcknowledged.setStatus('current')
if mibBuilder.loadTexts: powerChainAlarmEventAcknowledged.setDescription("A user has Acknowledged a Critical or Cautionary Alarm. This does NOT clear or 'close' a latched Alarm. Alarm and source information are contained in the OBJECTS.")
powerChainEventCleared = NotificationType((1, 3, 6, 1, 4, 1, 534, 8, 1, 0, 4)).setObjects(("EATON-PXG-MIB", "eventID"), ("EATON-PXG-MIB", "eventSequenceIndex"), ("EATON-PXG-MIB", "eventDescription"), ("EATON-PXG-MIB", "eventValue"), ("ENTITY-MIB", "entPhysicalName"))
if mibBuilder.loadTexts: powerChainEventCleared.setStatus('current')
if mibBuilder.loadTexts: powerChainEventCleared.setDescription('The condition that raised the Alarm or Event no longer exists; the three types of Events have different outcomes: 1) A latching Alarm is still considered active and will need to be Closed by a user Close Acknowledgement. 2) A non-latching Alarm is closed and its Alarm sequence completed. 3) An Event is closed and its Event sequence completed. Alarm and source information are contained in the OBJECTS.')
powerChainEvent = NotificationType((1, 3, 6, 1, 4, 1, 534, 8, 1, 0, 5)).setObjects(("EATON-PXG-MIB", "eventID"), ("EATON-PXG-MIB", "eventSequenceIndex"), ("EATON-PXG-MIB", "eventDescription"), ("EATON-PXG-MIB", "eventValue"), ("ENTITY-MIB", "entPhysicalName"))
if mibBuilder.loadTexts: powerChainEvent.setStatus('current')
if mibBuilder.loadTexts: powerChainEvent.setDescription('A non-alarming Event has occurred in a Power Chain Device. Event and source information are contained in the OBJECTS.')
powerChainAlarmEventClosed = NotificationType((1, 3, 6, 1, 4, 1, 534, 8, 1, 0, 6)).setObjects(("EATON-PXG-MIB", "eventID"), ("EATON-PXG-MIB", "eventSequenceIndex"), ("EATON-PXG-MIB", "eventDescription"), ("EATON-PXG-MIB", "eventValue"), ("ENTITY-MIB", "entPhysicalName"))
if mibBuilder.loadTexts: powerChainAlarmEventClosed.setStatus('current')
if mibBuilder.loadTexts: powerChainAlarmEventClosed.setDescription("A user has Closed a Critical or Cautionary Alarm. This Close Acknowledgement has 'closed' a latched Alarm and completed its sequence. Alarm and source information are contained in the OBJECTS.")
powerChainCriticalAlarm = NotificationType((1, 3, 6, 1, 4, 1, 534, 8, 1, 0, 7)).setObjects(("EATON-PXG-MIB", "alarmID"), ("EATON-PXG-MIB", "alarmSequenceIndex"), ("EATON-PXG-MIB", "alarmDescription"), ("EATON-PXG-MIB", "alarmValue"), ("ENTITY-MIB", "entPhysicalName"))
if mibBuilder.loadTexts: powerChainCriticalAlarm.setStatus('current')
if mibBuilder.loadTexts: powerChainCriticalAlarm.setDescription('A Critical Alarm has occurred in a Power Chain Device. Alarm and source information are contained in the OBJECTS.')
powerChainCautionaryAlarm = NotificationType((1, 3, 6, 1, 4, 1, 534, 8, 1, 0, 8)).setObjects(("EATON-PXG-MIB", "alarmID"), ("EATON-PXG-MIB", "alarmSequenceIndex"), ("EATON-PXG-MIB", "alarmDescription"), ("EATON-PXG-MIB", "alarmValue"), ("ENTITY-MIB", "entPhysicalName"))
if mibBuilder.loadTexts: powerChainCautionaryAlarm.setStatus('current')
if mibBuilder.loadTexts: powerChainCautionaryAlarm.setDescription('A Cautionary Alarm has occurred in a Power Chain Device. Alarm and source information are contained in the OBJECTS.')
powerChainAlarmAcknowledged = NotificationType((1, 3, 6, 1, 4, 1, 534, 8, 1, 0, 9)).setObjects(("EATON-PXG-MIB", "alarmID"), ("EATON-PXG-MIB", "alarmSequenceIndex"), ("EATON-PXG-MIB", "alarmDescription"), ("EATON-PXG-MIB", "alarmValue"), ("ENTITY-MIB", "entPhysicalName"))
if mibBuilder.loadTexts: powerChainAlarmAcknowledged.setStatus('current')
if mibBuilder.loadTexts: powerChainAlarmAcknowledged.setDescription("A user has Acknowledged a Critical or Cautionary Alarm. This does NOT clear or 'close' a latched Alarm. Alarm and source information are contained in the OBJECTS.")
powerChainAlarmCleared = NotificationType((1, 3, 6, 1, 4, 1, 534, 8, 1, 0, 10)).setObjects(("EATON-PXG-MIB", "alarmID"), ("EATON-PXG-MIB", "alarmSequenceIndex"), ("EATON-PXG-MIB", "alarmDescription"), ("EATON-PXG-MIB", "alarmValue"), ("ENTITY-MIB", "entPhysicalName"))
if mibBuilder.loadTexts: powerChainAlarmCleared.setStatus('current')
if mibBuilder.loadTexts: powerChainAlarmCleared.setDescription('The condition that raised the Alarm or Event no longer exists; the three types of Events have different outcomes: 1) A latching Alarm is still considered active and will need to be Closed by a user Close Acknowledgement. 2) A non-latching Alarm is closed and its Alarm sequence completed. 3) An Event is closed and its Event sequence completed. Alarm and source information are contained in the OBJECTS.')
powerChainAlarmClosed = NotificationType((1, 3, 6, 1, 4, 1, 534, 8, 1, 0, 11)).setObjects(("EATON-PXG-MIB", "alarmID"), ("EATON-PXG-MIB", "alarmSequenceIndex"), ("EATON-PXG-MIB", "alarmDescription"), ("EATON-PXG-MIB", "alarmValue"), ("ENTITY-MIB", "entPhysicalName"))
if mibBuilder.loadTexts: powerChainAlarmClosed.setStatus('current')
if mibBuilder.loadTexts: powerChainAlarmClosed.setDescription("A user has Closed a Critical or Cautionary Alarm. This Close Acknowledgement has 'closed' a latched Alarm and completed its sequence. Alarm and source information are contained in the OBJECTS.")
powerChainAlarmUpdated = NotificationType((1, 3, 6, 1, 4, 1, 534, 8, 1, 0, 12)).setObjects(("EATON-PXG-MIB", "alarmID"), ("EATON-PXG-MIB", "alarmSequenceIndex"), ("EATON-PXG-MIB", "alarmDescription"), ("EATON-PXG-MIB", "alarmValue"), ("EATON-PXG-MIB", "alarmLevel"), ("ENTITY-MIB", "entPhysicalName"))
if mibBuilder.loadTexts: powerChainAlarmUpdated.setStatus('current')
if mibBuilder.loadTexts: powerChainAlarmUpdated.setDescription('An update to the alarm entry at alarmID has occurred; however, the alarmLevel has not changed due to this update. This is normally seen with latching alarms when condition that caused the alarm is removed or recurs before the alarm has been closed. Alarm and source information are contained in the OBJECTS.')
pxgConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 534, 8, 1, 2))
tkEventGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 534, 8, 1, 2, 1)).setObjects(("EATON-PXG-MIB", "eventID"), ("EATON-PXG-MIB", "eventSequenceIndex"), ("EATON-PXG-MIB", "eventDescription"), ("EATON-PXG-MIB", "eventValue"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tkEventGroup = tkEventGroup.setStatus('current')
if mibBuilder.loadTexts: tkEventGroup.setDescription('The eventInfo objects that are only accessible to notifications.')
tkAlarmTableGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 534, 8, 1, 2, 2)).setObjects(("EATON-PXG-MIB", "alarmID"), ("EATON-PXG-MIB", "alarmSequenceIndex"), ("EATON-PXG-MIB", "alarmDescription"), ("EATON-PXG-MIB", "alarmValue"), ("EATON-PXG-MIB", "alarmLevel"), ("EATON-PXG-MIB", "alarmTime"), ("EATON-PXG-MIB", "numAlarmsPresent"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tkAlarmTableGroup = tkAlarmTableGroup.setStatus('current')
if mibBuilder.loadTexts: tkAlarmTableGroup.setDescription('The activeAlarms objects that are accessible to MIB browsers and notifications, except that alarmID is only accessible to notifications.')
tkEventNotifyGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 534, 8, 1, 2, 3)).setObjects(("EATON-PXG-MIB", "powerChainCriticalAlarmEvent"), ("EATON-PXG-MIB", "powerChainCautionaryAlarmEvent"), ("EATON-PXG-MIB", "powerChainAlarmEventAcknowledged"), ("EATON-PXG-MIB", "powerChainEventCleared"), ("EATON-PXG-MIB", "powerChainEvent"), ("EATON-PXG-MIB", "powerChainAlarmEventClosed"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tkEventNotifyGroup = tkEventNotifyGroup.setStatus('current')
if mibBuilder.loadTexts: tkEventNotifyGroup.setDescription('The Alarm and Event notifications which use the eventInfo objects.')
tkAlarmNotifyGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 534, 8, 1, 2, 4)).setObjects(("EATON-PXG-MIB", "powerChainCriticalAlarm"), ("EATON-PXG-MIB", "powerChainCautionaryAlarm"), ("EATON-PXG-MIB", "powerChainAlarmAcknowledged"), ("EATON-PXG-MIB", "powerChainAlarmCleared"), ("EATON-PXG-MIB", "powerChainAlarmClosed"), ("EATON-PXG-MIB", "powerChainAlarmUpdated"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tkAlarmNotifyGroup = tkAlarmNotifyGroup.setStatus('current')
if mibBuilder.loadTexts: tkAlarmNotifyGroup.setDescription('The Alarm notifications which use the activeAlarmTable objects.')
tkSimpleCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 534, 8, 1, 2, 5)).setObjects(("EATON-PXG-MIB", "tkEventGroup"), ("EATON-PXG-MIB", "tkEventNotifyGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tkSimpleCompliance = tkSimpleCompliance.setStatus('current')
if mibBuilder.loadTexts: tkSimpleCompliance.setDescription('The compliance statement for Power Xpert Gateway implementations that do not implement the activeAlarmsTable.')
tkAlarmsTableCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 534, 8, 1, 2, 6)).setObjects(("EATON-PXG-MIB", "tkEventGroup"), ("EATON-PXG-MIB", "tkAlarmTableGroup"), ("EATON-PXG-MIB", "tkEventNotifyGroup"), ("EATON-PXG-MIB", "tkAlarmNotifyGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tkAlarmsTableCompliance = tkAlarmsTableCompliance.setStatus('current')
if mibBuilder.loadTexts: tkAlarmsTableCompliance.setDescription('The compliance statement for Power Xpert Gateway implementations that do implement the activeAlarmsTable. The eventInfo objects are still used for Event-only notices.')
mibBuilder.exportSymbols("EATON-PXG-MIB", powerChainAlarmEventAcknowledged=powerChainAlarmEventAcknowledged, activeAlarmsTable=activeAlarmsTable, powerChainAlarmAcknowledged=powerChainAlarmAcknowledged, powerChainAlarmEventClosed=powerChainAlarmEventClosed, alarmSequenceIndex=alarmSequenceIndex, powerChainEventCleared=powerChainEventCleared, pxgMIB=pxgMIB, powerChainCriticalAlarm=powerChainCriticalAlarm, alarmValue=alarmValue, powerChainCautionaryAlarmEvent=powerChainCautionaryAlarmEvent, numAlarmsPresent=numAlarmsPresent, tkAlarmsTableCompliance=tkAlarmsTableCompliance, eventInfo=eventInfo, pxgNotifications=pxgNotifications, eventDescription=eventDescription, alarms=alarms, powerChainAlarmCleared=powerChainAlarmCleared, powerChainAlarmUpdated=powerChainAlarmUpdated, tkEventNotifyGroup=tkEventNotifyGroup, powerChainCriticalAlarmEvent=powerChainCriticalAlarmEvent, alarmLevel=alarmLevel, tkAlarmTableGroup=tkAlarmTableGroup, powerChainEvent=powerChainEvent, activeAlarmsEntry=activeAlarmsEntry, alarmDescription=alarmDescription, powerChainCautionaryAlarm=powerChainCautionaryAlarm, tkSimpleCompliance=tkSimpleCompliance, pxgMIBObjects=pxgMIBObjects, tkAlarmNotifyGroup=tkAlarmNotifyGroup, powerChainAlarmClosed=powerChainAlarmClosed, eventID=eventID, PYSNMP_MODULE_ID=pxgMIB, pxgConformance=pxgConformance, tkEventGroup=tkEventGroup, alarmID=alarmID, alarmTime=alarmTime, eventValue=eventValue, eventSequenceIndex=eventSequenceIndex)

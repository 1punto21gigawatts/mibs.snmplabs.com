#
# PySNMP MIB module BIANCA-BOX-PABX-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/BIANCA-BOX-PABX-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:37:58 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsUnion, ConstraintsIntersection, ValueRangeConstraint, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsUnion", "ConstraintsIntersection", "ValueRangeConstraint", "ValueSizeConstraint")
BitValue, = mibBuilder.importSymbols("BIANCA-BRICK-PPP-MIB", "BitValue")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Gauge32, MibIdentifier, iso, ObjectIdentity, Unsigned32, ModuleIdentity, Integer32, NotificationType, Bits, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter64, IpAddress, TimeTicks, Counter32 = mibBuilder.importSymbols("SNMPv2-SMI", "Gauge32", "MibIdentifier", "iso", "ObjectIdentity", "Unsigned32", "ModuleIdentity", "Integer32", "NotificationType", "Bits", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter64", "IpAddress", "TimeTicks", "Counter32")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
org = MibIdentifier((1, 3))
dod = MibIdentifier((1, 3, 6))
internet = MibIdentifier((1, 3, 6, 1))
private = MibIdentifier((1, 3, 6, 1, 4))
enterprises = MibIdentifier((1, 3, 6, 1, 4, 1))
bintec = MibIdentifier((1, 3, 6, 1, 4, 1, 272))
bibo = MibIdentifier((1, 3, 6, 1, 4, 1, 272, 4))
pabx = MibIdentifier((1, 3, 6, 1, 4, 1, 272, 4, 20))
class Date(Integer32):
    pass

class HexValue(Integer32):
    pass

pabxUserTable = MibTable((1, 3, 6, 1, 4, 1, 272, 4, 20, 1), )
if mibBuilder.loadTexts: pabxUserTable.setStatus('mandatory')
if mibBuilder.loadTexts: pabxUserTable.setDescription('The pabxUserTable contains information about the pabx users. CAPI and TAPI users must authenticate to the system by means of user name and password, before active or passive connections may be established. The default configuration defines a user named <default> with all permissions. This user will also be used by old CAPI applications which are not able to select a user. Please note, that the password for the user <default> must be empty in this case. Entries in this table can be deleted by setting the object pabxUserTapiMon to the value <delete>.')
pabxUserEntry = MibTableRow((1, 3, 6, 1, 4, 1, 272, 4, 20, 1, 1), ).setIndexNames((0, "BIANCA-BOX-PABX-MIB", "pabxUserName"))
if mibBuilder.loadTexts: pabxUserEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pabxUserEntry.setDescription('')
pabxUserName = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxUserName.setStatus('mandatory')
if mibBuilder.loadTexts: pabxUserName.setDescription('The name of the user.')
pabxUserPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxUserPassword.setStatus('mandatory')
if mibBuilder.loadTexts: pabxUserPassword.setDescription('The password for the user.')
pabxUserTapiMon = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("delete", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxUserTapiMon.setStatus('mandatory')
if mibBuilder.loadTexts: pabxUserTapiMon.setDescription('Allow or deny monitoring of call activity with TAPI or delete entry.')
pabxUserTapiCtrl = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxUserTapiCtrl.setStatus('mandatory')
if mibBuilder.loadTexts: pabxUserTapiCtrl.setDescription('Allow or deny controlling of calls for the terminal belonging to the user with TAPI.')
pabxUserTapiMedia = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxUserTapiMedia.setStatus('mandatory')
if mibBuilder.loadTexts: pabxUserTapiMedia.setDescription('Allow or deny the usage of TAPI media streams.')
pabxUserCapi = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxUserCapi.setStatus('mandatory')
if mibBuilder.loadTexts: pabxUserCapi.setDescription('Allow or deny the usage of CAPI.')
pabxUserId = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxUserId.setStatus('mandatory')
if mibBuilder.loadTexts: pabxUserId.setDescription("The user id uniquely identifies a user and is now used as reference to that user in other tables instead of her name. The id 0 has the meaning 'no special user'.")
pabxUserPIN = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 1, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(4, 9))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxUserPIN.setStatus('mandatory')
if mibBuilder.loadTexts: pabxUserPIN.setDescription("The PIN is the personal identification number that is needed for authorisation during telephone based configurations. It consists solely of digits and must be between 4 and 9 characters long. Default Value is '0000'.")
pabxUserPrimGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxUserPrimGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: pabxUserPrimGroupId.setDescription('PrimGroupId is the primary group identification number for that user. It serves only for configuration purposes so that all newly created extensions for a terminal that user is primary user of, will automatically become member in that group. The default value is 0.')
pabxTrunkTable = MibTable((1, 3, 6, 1, 4, 1, 272, 4, 20, 2), )
if mibBuilder.loadTexts: pabxTrunkTable.setStatus('mandatory')
if mibBuilder.loadTexts: pabxTrunkTable.setDescription('This table contains an entry for each trunk-line (or central office line) connecting the system to an outside network. Entries are deleted from this table by setting the object pabxTrunkProtocol to the value <delete>.')
pabxTrunkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 272, 4, 20, 2, 1), ).setIndexNames((0, "BIANCA-BOX-PABX-MIB", "pabxTrunkNumber"))
if mibBuilder.loadTexts: pabxTrunkEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pabxTrunkEntry.setDescription('')
pabxTrunkNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxTrunkNumber.setStatus('mandatory')
if mibBuilder.loadTexts: pabxTrunkNumber.setDescription('The object pabxTrunkNumber ranges from 0..31 and specifies a unique identification for the trunk line.')
pabxTrunkDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 2, 1, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxTrunkDescr.setStatus('mandatory')
if mibBuilder.loadTexts: pabxTrunkDescr.setDescription('Description text for the trunk-line. This object is for information only and not otherwise being used by the system.')
pabxTrunkSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxTrunkSlot.setStatus('mandatory')
if mibBuilder.loadTexts: pabxTrunkSlot.setDescription('This object specifies the number of the physical slot the trunk-line is leading to.')
pabxTrunkUnit = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 9))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxTrunkUnit.setStatus('mandatory')
if mibBuilder.loadTexts: pabxTrunkUnit.setDescription('This object specifies the physical unit in the slot specified by pabxTrunkSlot. When there is only one unit in the slot, the unitnumber has to be set to 0.')
pabxTrunkProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("delete", 1), ("dss1", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxTrunkProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: pabxTrunkProtocol.setDescription('This object specifies the protocol to be used on the trunk-line. Currently only dss1 is available.')
pabxTrunkConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("point-to-multipoint", 1), ("point-to-point", 2), ("unknown", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxTrunkConfig.setStatus('mandatory')
if mibBuilder.loadTexts: pabxTrunkConfig.setDescription('This object specifies, whether the trunk line is running in point-to-point or point-to-multipoint configuration.')
pabxTrunkTeiProc = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("automatic", 1), ("fixed", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxTrunkTeiProc.setStatus('mandatory')
if mibBuilder.loadTexts: pabxTrunkTeiProc.setDescription('This object specifies the TEI procedure to be used with the trunk-line. The procedure may be either <automatic> or <fixed>. In the latter case, the TEI value has to be specified in the object pabxTrunkTeiValue')
pabxTrunkTeiValue = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 63))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxTrunkTeiValue.setStatus('mandatory')
if mibBuilder.loadTexts: pabxTrunkTeiValue.setDescription('This object specifies the TEI value to be used for fixed TEI configurations and is ignored in automatic TEI configurations.')
pabxTrunkCountryCode = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 2, 1, 9), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxTrunkCountryCode.setStatus('mandatory')
if mibBuilder.loadTexts: pabxTrunkCountryCode.setDescription('This object specifies the country code of the trunk-line. This information has to be specified in point-to-point configurations, because the country code has to be skipped in the destination address of incoming calls in order to isolate the local extension part.')
pabxTrunkAreaCode = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 2, 1, 10), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxTrunkAreaCode.setStatus('mandatory')
if mibBuilder.loadTexts: pabxTrunkAreaCode.setDescription('This object specifies the area code of the trunk-line. This information has to be specified in point-to-point configurations, because the area code has to be skipped in the destination address of incoming calls in order to isolate the local extension part.')
pabxTrunkSubscriberNo = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 2, 1, 11), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxTrunkSubscriberNo.setStatus('mandatory')
if mibBuilder.loadTexts: pabxTrunkSubscriberNo.setDescription('This object specifies the subscriber number of the trunk-line. This information has to be specified in point-to-point configurations, because the subscriber number has to be skipped in the destination address of incoming calls in order to isolate the local extension part.')
pabxTrunkExtension = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 2, 1, 12), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxTrunkExtension.setStatus('mandatory')
if mibBuilder.loadTexts: pabxTrunkExtension.setDescription('This object specifies the extension number of the trunk-line. This information has to be specified in point-to-point configurations, because the extension number has to be skipped in the destination address of incoming calls in order to isolate the local extension part. Please note, that this object shall be empty, when connected to a normal central office line.')
pabxTrunkType = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("external", 1), ("internal", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxTrunkType.setStatus('mandatory')
if mibBuilder.loadTexts: pabxTrunkType.setDescription("The trunk type identifies the purpose of an ISDN interface. Normal external trunks are identified with type 'external'. When cascading trunks one side must behave as network side and, hence, a trunk entry must be created for it, despite of operating in NT (actually NT or LTS) mode. This is achieved by creating a trunk of type 'internal'. Internal trunks are always point to point type interfaces. Type 'external' is assumed by default.")
pabxTrunkL2Mode = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("auto", 1), ("te", 2), ("nt", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxTrunkL2Mode.setStatus('mandatory')
if mibBuilder.loadTexts: pabxTrunkL2Mode.setDescription("The TrunkL2Mode specifies the mode layer 2 is to operate in. To be able to use leased lines as well as back to back connections to link two machines, layer 2 mode must be configurable independently from layer 1 mode. If mode is set to auto(1), layer 2 mode is derived from physical configuration of interface (NT/TE). Settings te(2) and nt(3) force the respective configuration. By default mode is set to 'auto'.")
pabxTrunkPrefixTable = MibTable((1, 3, 6, 1, 4, 1, 272, 4, 20, 3), )
if mibBuilder.loadTexts: pabxTrunkPrefixTable.setStatus('mandatory')
if mibBuilder.loadTexts: pabxTrunkPrefixTable.setDescription('This table specifies escape codes, that may be used to access the available trunk-lines. Initially, the prefix <0> will be defined to use any trunk line in the system. Please note, that this table is only used, when The global object pabxLocalPrefix is set to an empty string. Entries in this table are deleted by setting the object pabxTrunkPrefixStatus to the value <delete>')
pabxTrunkPrefixEntry = MibTableRow((1, 3, 6, 1, 4, 1, 272, 4, 20, 3, 1), ).setIndexNames((0, "BIANCA-BOX-PABX-MIB", "pabxTrunkPrefixPrefix"))
if mibBuilder.loadTexts: pabxTrunkPrefixEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pabxTrunkPrefixEntry.setDescription('')
pabxTrunkPrefixPrefix = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 3, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxTrunkPrefixPrefix.setStatus('mandatory')
if mibBuilder.loadTexts: pabxTrunkPrefixPrefix.setDescription("This object specifies a prefix used to access (a subset of) the available trunk-lines. It's value is a string consisting of the dialable digits 0..9, * and #.")
pabxTrunkPrefixTrunkMask = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 3, 1, 2), BitValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxTrunkPrefixTrunkMask.setStatus('mandatory')
if mibBuilder.loadTexts: pabxTrunkPrefixTrunkMask.setDescription('This object is a bit mask consisting of bit 0 to bit 31. Each bit corresponds to the trunk-line index with the same number (Bit 0 <-> Number 0 ...). The whole mask specifies the set of trunk lines to be used with the trunk-prefix.')
pabxTrunkPrefixStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2), ("delete", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxTrunkPrefixStatus.setStatus('mandatory')
if mibBuilder.loadTexts: pabxTrunkPrefixStatus.setDescription('This object specifies the status of the trunk-prefix. When set to valid, the trunk prefix will be used normally, when set to invalid, the prefix will not be used and when set to delete, the table-entry will be deleted.')
pabxTrunkPrefixStripOnOutgoing = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxTrunkPrefixStripOnOutgoing.setStatus('mandatory')
if mibBuilder.loadTexts: pabxTrunkPrefixStripOnOutgoing.setDescription('This object specifies handling of trunk-prefix on outgoing calls: When set to enable (by default) the trunk prefix will be stripped on outgoing calls, what must be set for external trunks (otherwise a wrong called party number would be passed on). When set to disable, the prefix will remain in the called party number, allowing a distributed PABX via internal trunks.')
pabxTrunkPrefixPrependOnIncoming = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxTrunkPrefixPrependOnIncoming.setStatus('mandatory')
if mibBuilder.loadTexts: pabxTrunkPrefixPrependOnIncoming.setDescription('This object specifies handling of trunk-prefix on incoming calls: When set to enable (by default) the trunk prefix will be appended to the calling party number on incoming calls, what must be set for external trunks (otherwise a wrong calling party number would be provided, hence leading to the calling party number being unusable for a call back). When set to disable, no prefix will be prepended to the calling party number, nedded for a distributed PABX via internal trunks.')
pabxExtensionTable = MibTable((1, 3, 6, 1, 4, 1, 272, 4, 20, 4), )
if mibBuilder.loadTexts: pabxExtensionTable.setStatus('mandatory')
if mibBuilder.loadTexts: pabxExtensionTable.setDescription('This table defines the local numbers (extensions), that shall be used within PABX and assigns an identifier to it. Besides the extension is assigned to a terminal and user via apropriate identifiers and to either a physical or a logical destination. The items pabxExtSlot and pabxExtUnit moved to the terminal table as every extension must be associated with a terminal and, moreover, a terminal is always as a whole physically attached to a slot and unit. Also pabxExtUser is no longer valid, because the associated user is now refered to via the pabxExtUserId, avoiding some possible configuration faults. Rows are deleted from the table by setting the object pabxExtDestination to the value <delete>.')
pabxExtensionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 272, 4, 20, 4, 1), ).setIndexNames((0, "BIANCA-BOX-PABX-MIB", "pabxExtExtension"))
if mibBuilder.loadTexts: pabxExtensionEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pabxExtensionEntry.setDescription('')
pabxExtExtension = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 4, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxExtExtension.setStatus('mandatory')
if mibBuilder.loadTexts: pabxExtExtension.setDescription('This object contains the extension, which is a dialable string consisting of the digits 0..9, * and #.')
pabxExtType = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("voice", 1), ("data", 2), ("voice-and-data", 3), ("delete", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxExtType.setStatus('mandatory')
if mibBuilder.loadTexts: pabxExtType.setDescription('Specifies the call types, for which the entry shall be valid.')
pabxExtIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 4, 1, 6), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxExtIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: pabxExtIpAddr.setDescription('Specifies the ip-address, to which the call shall be routed if pabxExtDestination is set to internet-telephony.')
pabxExtEAZ = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 4, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxExtEAZ.setStatus('mandatory')
if mibBuilder.loadTexts: pabxExtEAZ.setDescription('The EAZ is to be used by 1TR6-based applications such as CAPI 1.1. and is only valid if the object pabxExtDestination is set to application.')
pabxExtLayer1Prot = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 4, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 11, 12, 13, 15, 16, 17, 18, 19, 20, 21, 26, 27, 28, 29, 30, 31, 32, 33))).clone(namedValues=NamedValues(("auto", 1), ("sync-64k", 11), ("sync-56k", 12), ("modem", 13), ("v110-1200", 15), ("v110-2400", 16), ("v110-4800", 17), ("v110-9600", 18), ("v110-14400", 19), ("v110-19200", 20), ("v110-38400", 21), ("modem-profile-1", 26), ("modem-profile-2", 27), ("modem-profile-3", 28), ("modem-profile-4", 29), ("modem-profile-5", 30), ("modem-profile-6", 31), ("modem-profile-7", 32), ("modem-profile-8", 33)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxExtLayer1Prot.setStatus('mandatory')
if mibBuilder.loadTexts: pabxExtLayer1Prot.setDescription('The layer1 protocol to be used for multiprotocol-routing (incoming calls only).')
pabxExtIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 4, 1, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxExtIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pabxExtIfIndex.setDescription('The interface index of the MPR interface to be used for the call. This object is valid for routing only.')
pabxExtId = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 4, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxExtId.setStatus('mandatory')
if mibBuilder.loadTexts: pabxExtId.setDescription('The id uniquely identifies an extension may be within the range from 0 to 2147483647. This id is used to refer to that extension from other tables. Id 0 has the special meaning, that the PABX shall choose a valid one.')
pabxExtUserId = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 4, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxExtUserId.setStatus('mandatory')
if mibBuilder.loadTexts: pabxExtUserId.setDescription('This identificator refers to the user the extension is associated with. Its default value is 0 meaning no particular user.')
pabxExtTermId = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 4, 1, 13), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxExtTermId.setStatus('mandatory')
if mibBuilder.loadTexts: pabxExtTermId.setDescription('This identificator refers to the terminal the extension is associated with. Its value must be a valid identificator, i.e. there must be a terminal with the given id. The special number -1 is used for specifying that the extension is a group extension.')
pabxExtDefaultExtFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 4, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxExtDefaultExtFlag.setStatus('mandatory')
if mibBuilder.loadTexts: pabxExtDefaultExtFlag.setDescription('This value specifies whether the extension should be used as a default extension (for outgoing calls) for the associated terminal. The flag to be set currently only makes sense for physical analog terminals. The case that this flag is yes(1) for more than one extension per terminal is considered a configuration error. Which extension will be used in that case depends on the order in which extensions are configured (automatically at system start-up) and, hence, is undefined.')
pabxExtPresentationNr = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 4, 1, 15), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxExtPresentationNr.setStatus('mandatory')
if mibBuilder.loadTexts: pabxExtPresentationNr.setDescription('This field allows for specifying an extension that will be presented to externally called partners instead of the actual calling number. Hence it allows to use a group extension so that the called partner does only see the extension she should use for call back if necessary, rather than the extension within the group. Default value is the empty string meaning that no mapping shall take place.')
pabxExtOutsideCallSeq = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 4, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("type1", 1), ("type2", 2), ("type3", 3), ("type4", 4), ("type5", 5), ("type6", 6), ("systeltype7", 7), ("systeltype8", 8), ("systeltype9", 9), ("systeltype10", 10)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxExtOutsideCallSeq.setStatus('mandatory')
if mibBuilder.loadTexts: pabxExtOutsideCallSeq.setDescription('Set the ringing sequence for incoming calls from outside')
pabxExtInsideCallSeq = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 4, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("type1", 1), ("type2", 2), ("type3", 3), ("type4", 4), ("type5", 5), ("type6", 6), ("systeltype7", 7), ("systeltype8", 8), ("systeltype9", 9), ("systeltype10", 10)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxExtInsideCallSeq.setStatus('mandatory')
if mibBuilder.loadTexts: pabxExtInsideCallSeq.setDescription('Set the ringing sequence for incoming calls inside the PABX.')
pabxExtPresentationFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 4, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("off", 1), ("internal", 2), ("external", 3), ("on", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxExtPresentationFlag.setStatus('mandatory')
if mibBuilder.loadTexts: pabxExtPresentationFlag.setDescription("Specify when the presentation number should take effect. By default its value is 'off' defining the actual extension is to be used. If presentation number shall be used only on internal calls ExtPresentation must be set to 'internal'. Analogous to the last, value 'external' is for use on external calls. The last value 'on' specifies that the presentation number is to be used in any case.")
pabxExtProfileId = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 4, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxExtProfileId.setStatus('mandatory')
if mibBuilder.loadTexts: pabxExtProfileId.setDescription('ProfileId holds an id specifying an applying profile entry in pabx profile table. If set to 0 no profile applies as 0 is not a valid id for profiles. In that case terminal profile applies, or if also 0, system default settings apply for the extension.')
pabxExtCtrlByCapiApp = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 4, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxExtCtrlByCapiApp.setStatus('mandatory')
if mibBuilder.loadTexts: pabxExtCtrlByCapiApp.setDescription('CtrlByCapiAppl indicates whether a capi application controls this extension. If set to on a special CAPI application registered for handling incoming calls, causing PABX to only signal that incoming call towards CAPI application, hence avoiding a spurious short alerting of Phone until call is answered by application. A CAPI application can request this feature by a LISTEN request with special contents. The default value is off.')
pabxExtCtrlByCapiAppNo = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 4, 1, 21), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pabxExtCtrlByCapiAppNo.setStatus('mandatory')
if mibBuilder.loadTexts: pabxExtCtrlByCapiAppNo.setDescription('CtrlByCapiAppl indicates capi application number that controls extension in case pabxExtCtrlByCapiApp is set to on.')
pabxExtFeatureTable = MibTable((1, 3, 6, 1, 4, 1, 272, 4, 20, 5), )
if mibBuilder.loadTexts: pabxExtFeatureTable.setStatus('mandatory')
if mibBuilder.loadTexts: pabxExtFeatureTable.setDescription('This table stores all extension related feature settings that would have overloaded the extension table. The extension for which the settings apply is identified by its id. Currently found features are only the different call forwarding modes. For every mode (unconditional, busy and no reply) a separate telephone number can be stored. The active call forwarding mode is stored in an extra mode field. The pabxExtUsrConfigTable is replaced by that one. To delete a row set pabxExtFeatureCFMode to value delete. CAUTION: deleting a row will result in also deleting the related extension table entry!')
pabxExtFeatureEntry = MibTableRow((1, 3, 6, 1, 4, 1, 272, 4, 20, 5, 1), ).setIndexNames((0, "BIANCA-BOX-PABX-MIB", "pabxExtFeatureExtId"))
if mibBuilder.loadTexts: pabxExtFeatureEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pabxExtFeatureEntry.setDescription('')
pabxExtFeatureExtId = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pabxExtFeatureExtId.setStatus('mandatory')
if mibBuilder.loadTexts: pabxExtFeatureExtId.setDescription('This parameter identifies the extension for which all feature settings stored here apply. It must be a valid one, i.e. one that is also found in the pabxExtensionTable.')
pabxExtFeatureCFUncond = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 5, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxExtFeatureCFUncond.setStatus('mandatory')
if mibBuilder.loadTexts: pabxExtFeatureCFUncond.setDescription('This field contains the phone number to be used for unconditional call forwarding.')
pabxExtFeatureCFBusy = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 5, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxExtFeatureCFBusy.setStatus('mandatory')
if mibBuilder.loadTexts: pabxExtFeatureCFBusy.setDescription('This field contains the phone number to be used for call forwarding in case of busy subscriber.')
pabxExtFeatureCFNoReply = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 5, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxExtFeatureCFNoReply.setStatus('mandatory')
if mibBuilder.loadTexts: pabxExtFeatureCFNoReply.setDescription('This field contains the phone number to be used for call forwarding in case user does not respond.')
pabxExtFeatureCFNoReplyTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 5, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 120))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxExtFeatureCFNoReplyTimer.setStatus('mandatory')
if mibBuilder.loadTexts: pabxExtFeatureCFNoReplyTimer.setDescription('This field defines the time in seconds a call must be in state alerting until call forwarding will be activated. Reasonable values are 3 up to maybe 30, nevertheless all values between 1 and 120 are allowed.')
pabxExtFeatureCFMode = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 5, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("none", 2), ("busy", 3), ("noreply", 4), ("busy-noreply", 5), ("uncond", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxExtFeatureCFMode.setStatus('mandatory')
if mibBuilder.loadTexts: pabxExtFeatureCFMode.setDescription("In this field the active call forwarding mode for the extension is stored. It can have the values none, busy, noreply and uncond for the different modes. Besides it makes sense to allow both noreply and busy to be active at a time, so there's the additional value busy-noreply. Apart from that, if mode is set to delete the entry will be deleted.")
pabxExtFeatureEMailAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 5, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxExtFeatureEMailAddr.setStatus('mandatory')
if mibBuilder.loadTexts: pabxExtFeatureEMailAddr.setDescription('This field contains the E-Mail address for the extension')
pabxExtFeatureSystelMSNSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 5, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxExtFeatureSystelMSNSlot.setStatus('mandatory')
if mibBuilder.loadTexts: pabxExtFeatureSystelMSNSlot.setDescription('SystelMSNSlot is only valid for extensions associated with system terminals. It identifies the MSN configuration slot within the system phone (1 through 10) where it is to be stored when configuring system phone from brick. Value 0 has the special meaning that the configuration slot is undefined; the configuration position is chosen randomly then. Default value is 0.')
pabxExtFeatureSystelVolume = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 5, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxExtFeatureSystelVolume.setStatus('mandatory')
if mibBuilder.loadTexts: pabxExtFeatureSystelVolume.setDescription('SystelVolume specifies ringing volume setting within system phone for externally (to brick) initiated incoming calls. Default value is 4.')
pabxExtFeatureSystelText = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 5, 1, 10), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxExtFeatureSystelText.setStatus('mandatory')
if mibBuilder.loadTexts: pabxExtFeatureSystelText.setDescription('SystelText contains info text shown in system phone display on incoming and outgoing calls indicating the used/directed-to MSN.')
pabxGroupTable = MibTable((1, 3, 6, 1, 4, 1, 272, 4, 20, 8), )
if mibBuilder.loadTexts: pabxGroupTable.setStatus('mandatory')
if mibBuilder.loadTexts: pabxGroupTable.setDescription('The group table contains all defined groups. It contains the group id and the associated name and one more field that is currently only needed for deleting groups. To delete a row set pabxGroupCalladdInhibit to value delete.')
pabxGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 272, 4, 20, 8, 1), ).setIndexNames((0, "BIANCA-BOX-PABX-MIB", "pabxGroupId"))
if mibBuilder.loadTexts: pabxGroupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pabxGroupEntry.setDescription('')
pabxGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 8, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: pabxGroupId.setDescription("The group id is a non-negative identificator that is unique. The maximum value for it is 2147483647. Id 0 treated specially meaning 'auto group id' when creating new groups.")
pabxGroupName = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 8, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxGroupName.setStatus('mandatory')
if mibBuilder.loadTexts: pabxGroupName.setDescription('The group name is just a human readable description for the group and serves for ease of configuration.')
pabxGroupCalladdInhibit = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 8, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("delete", 1), ("enable", 2), ("disable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxGroupCalladdInhibit.setStatus('mandatory')
if mibBuilder.loadTexts: pabxGroupCalladdInhibit.setDescription('As of the necessity to be able of removing groups, another integer variable had to be added. Therefore only the value delete has consequences. The other values are for future use and normal entries so far may have either value.')
pabxTerminalTable = MibTable((1, 3, 6, 1, 4, 1, 272, 4, 20, 9), )
if mibBuilder.loadTexts: pabxTerminalTable.setStatus('mandatory')
if mibBuilder.loadTexts: pabxTerminalTable.setDescription('The terminal table contains all terminals with specification of their corresponding hardware interface, hence invalidating the respective entries in the extension table. Besides a primary user may be given that will be assumed for newly created extensions for that terminal. Deleting a row is done by setting pabxTermDestination to value delete.')
pabxTerminalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 272, 4, 20, 9, 1), ).setIndexNames((0, "BIANCA-BOX-PABX-MIB", "pabxTermId"))
if mibBuilder.loadTexts: pabxTerminalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pabxTerminalEntry.setDescription('')
pabxTermId = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 9, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxTermId.setStatus('mandatory')
if mibBuilder.loadTexts: pabxTermId.setDescription("The id uniquely identifies a terminal and can have the values 0 up to 2147483647, where number 0 has the special meaning 'auto id' when creating new terminals.")
pabxTermName = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 9, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxTermName.setStatus('mandatory')
if mibBuilder.loadTexts: pabxTermName.setDescription('This optional field contains just a (preferably unique) descriptive name for the terminal.')
pabxTermSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 9, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxTermSlot.setStatus('mandatory')
if mibBuilder.loadTexts: pabxTermSlot.setDescription('Designates the slot of the physical interface the terminal is attached to.')
pabxTermUnit = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 9, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxTermUnit.setStatus('mandatory')
if mibBuilder.loadTexts: pabxTermUnit.setDescription('Designates the unit of the physical interface the terminal is attached to.')
pabxTermDestination = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 9, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("delete", 1), ("physical", 2), ("application", 3), ("internet-telephony", 4), ("multiprotocol-routing", 5), ("isdn-login", 6), ("msg-box", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxTermDestination.setStatus('mandatory')
if mibBuilder.loadTexts: pabxTermDestination.setDescription('This object specifies the type of the destination. When set to physical, the destination is the physical device selected by pabxExtSlot and pabxExtUnit. When set to application, the extension may be used by CAPI or TAPI software applications. When set to internet-telephony, the destination is the computer on the network with the ip-address pabxExtIpAddr. When this object ist set to multiprotocol-routing, the destination is the builtin multiprotocol-router. In this case the object pabxExtLayer1Prot may be used to specify the layer1 protocol and pabxExtIfIndex may be used to assign the extension to a specific multiprotocol-interface. Finally isdn-login may be used to assign the extension to the isdn-login facility of the system.')
pabxTermPrimUserId = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 9, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxTermPrimUserId.setStatus('mandatory')
if mibBuilder.loadTexts: pabxTermPrimUserId.setDescription('The primary user id allows for automatically setting the user for newly created extensions for that terminal. The default value is 0 meaning no particular user.')
pabxTermType = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 9, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("phone", 1), ("modem", 2), ("fax", 3), ("headset", 4), ("answeringmachine", 5), ("system-phone", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxTermType.setStatus('mandatory')
if mibBuilder.loadTexts: pabxTermType.setDescription('The terminal type identifies which kind of terminal it is. By default type is set to phone; other possibilities are modem, fax and headset. When set to modem or fax the normal dial tone is provided instead of a pulsed one normally (without automatic dialout on trunks).')
pabxTermProfileId = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 9, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxTermProfileId.setStatus('mandatory')
if mibBuilder.loadTexts: pabxTermProfileId.setDescription('ProfileId holds an id specifying an applying profile entry in pabx profile table. If set to 0 no profile applies as 0 is not a valid id for profiles. In that case system default settings apply for the terminal (-> pabxSTATICTable).')
pabxTermSystelSerialNo = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 9, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxTermSystelSerialNo.setStatus('mandatory')
if mibBuilder.loadTexts: pabxTermSystelSerialNo.setDescription("This field is only for terminals of type system-phone and specifies its serial number. For terminals set to terminal type 'system phone' the next system terminal found will automatically be associated with a terminal in case serial number is left blank. Default value is the empty string.")
pabxExtToGroupTable = MibTable((1, 3, 6, 1, 4, 1, 272, 4, 20, 10), )
if mibBuilder.loadTexts: pabxExtToGroupTable.setStatus('mandatory')
if mibBuilder.loadTexts: pabxExtToGroupTable.setDescription('The exttogroup table contains all associations of extensions to groups. To allow for extensions being in arbitrary groups as well as groups containing any number of extensions it is necessary to implement an extra table holding that informations and is done right here. Currently the table has only 3 columns (beside the index) where two of them hold an id either, one an extension id the other a group id, and the last column currently serves solely for the purpose of deleting rows. Deleting a row is done by setting pabxTerminalLock to value delete.')
pabxExtToGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 272, 4, 20, 10, 1), ).setIndexNames((0, "BIANCA-BOX-PABX-MIB", "pabxExtToGroupExtId"))
if mibBuilder.loadTexts: pabxExtToGroupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pabxExtToGroupEntry.setDescription('')
pabxExtToGroupExtId = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 10, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxExtToGroupExtId.setStatus('mandatory')
if mibBuilder.loadTexts: pabxExtToGroupExtId.setDescription('This field identifies the extension that should become member in a group.')
pabxExtToGroupGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 10, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxExtToGroupGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: pabxExtToGroupGroupId.setDescription('This field identifies the group the extension will become member of')
pabxExtToGroupCallPickupActive = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("delete", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxExtToGroupCallPickupActive.setStatus('mandatory')
if mibBuilder.loadTexts: pabxExtToGroupCallPickupActive.setDescription('Currently the only purpose of that field is to supply the user with a possibility to delete such association entries.')
pabxTrunkMsnTable = MibTable((1, 3, 6, 1, 4, 1, 272, 4, 20, 11), )
if mibBuilder.loadTexts: pabxTrunkMsnTable.setStatus('mandatory')
if mibBuilder.loadTexts: pabxTrunkMsnTable.setDescription("The pabxTrunkMsnTable contains all MSNs that were detected during auto-configuration process on point-to-multipoint trunk lines. The table is handled solely by pabxautocf, hence there's no chance for alteration or deletion of rows.")
pabxTrunkMsnEntry = MibTableRow((1, 3, 6, 1, 4, 1, 272, 4, 20, 11, 1), ).setIndexNames((0, "BIANCA-BOX-PABX-MIB", "pabxTrunkMsnSlot"))
if mibBuilder.loadTexts: pabxTrunkMsnEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pabxTrunkMsnEntry.setDescription('')
pabxTrunkMsnSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 11, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pabxTrunkMsnSlot.setStatus('mandatory')
if mibBuilder.loadTexts: pabxTrunkMsnSlot.setDescription('Specifies slot of interface for which an MSN is found.')
pabxTrunkMsnUnit = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 11, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pabxTrunkMsnUnit.setStatus('mandatory')
if mibBuilder.loadTexts: pabxTrunkMsnUnit.setDescription('Specifies unit of interface for which an MSN is found.')
pabxTrunkMsnNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 11, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pabxTrunkMsnNumber.setStatus('mandatory')
if mibBuilder.loadTexts: pabxTrunkMsnNumber.setDescription('Holds the found MSN.')
pabxTrunkMsnNumberType = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 20, 11, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("unknown", 1), ("private", 2), ("public-international", 3), ("public-national", 4), ("public-subscriber", 5), ("public-other", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pabxTrunkMsnNumberType.setStatus('mandatory')
if mibBuilder.loadTexts: pabxTrunkMsnNumberType.setDescription('Tells the type of number stored in pabxTrunkMsnNumber field.')
pabxProfileTable = MibTable((1, 3, 6, 1, 4, 1, 272, 4, 20, 12), )
if mibBuilder.loadTexts: pabxProfileTable.setStatus('mandatory')
if mibBuilder.loadTexts: pabxProfileTable.setDescription('The pabxProfileTable.')
pabxProfileEntry = MibTableRow((1, 3, 6, 1, 4, 1, 272, 4, 20, 12, 1), ).setIndexNames((0, "BIANCA-BOX-PABX-MIB", "pabxProfileId"))
if mibBuilder.loadTexts: pabxProfileEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pabxProfileEntry.setDescription('')
pabxProfileId = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 12, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxProfileId.setStatus('mandatory')
if mibBuilder.loadTexts: pabxProfileId.setDescription("Identifies a profile entry for association to extension, terminal or user. Must be within range 0-2147483647 where value '0' has special meaning 'automatic id' when creating a new entry. Hence, value '0' cannot be used and may only show up in MIB table for ignored entries.")
pabxProfileName = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 12, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxProfileName.setStatus('mandatory')
if mibBuilder.loadTexts: pabxProfileName.setDescription('Descriptive - preferably unique - name for profile.')
pabxProfileAutoDialOutNo = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 12, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxProfileAutoDialOutNo.setStatus('mandatory')
if mibBuilder.loadTexts: pabxProfileAutoDialOutNo.setDescription("Number string to be dialled automatically when just starting a call. Allows for automatical dialout via trunk. Default is the empty string '' meaning the system default shall be used (see pabxSTATICTable). If not empty it takes precedence over system default.")
pabxProfileDialPerm = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 12, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("internal", 1), ("local", 2), ("national", 3), ("national-special", 4), ("full", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxProfileDialPerm.setStatus('mandatory')
if mibBuilder.loadTexts: pabxProfileDialPerm.setDescription("Define dial permissions of extension. When set to 'internal' dialling out over (external) trunks is prevented. Value 'local' allows dialling external numbers without an area prefix. With setting 'national' any national number but special numbers (like mobile numbers) may be dialled. The only restriction applying to value 'national_special' is dialling of internaltional numbers. The default setting 'full' grants access to any number.")
pabxProfileAvailability = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 12, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 15))).clone(namedValues=NamedValues(("internal", 1), ("external", 2), ("full", 3), ("delete", 15)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxProfileAvailability.setStatus('mandatory')
if mibBuilder.loadTexts: pabxProfileAvailability.setDescription('Define availability of an extension/terminal. By default extensions are fully available (full), i.e. internal and external bound calls can reach the extension depending on the trunk constellation. Setting availability to internal restricts the extension to be called only by internal callers.')
pabxExtNoPermTable = MibTable((1, 3, 6, 1, 4, 1, 272, 4, 20, 13), )
if mibBuilder.loadTexts: pabxExtNoPermTable.setStatus('mandatory')
if mibBuilder.loadTexts: pabxExtNoPermTable.setDescription('The pabxExtNoPermTable.')
pabxExtNoPermEntry = MibTableRow((1, 3, 6, 1, 4, 1, 272, 4, 20, 13, 1), ).setIndexNames((0, "BIANCA-BOX-PABX-MIB", "pabxExtNoPermNumber"))
if mibBuilder.loadTexts: pabxExtNoPermEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pabxExtNoPermEntry.setDescription('')
pabxExtNoPermNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 13, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxExtNoPermNumber.setStatus('mandatory')
if mibBuilder.loadTexts: pabxExtNoPermNumber.setDescription('')
pabxExtNoPermPermission = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 13, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 255))).clone(namedValues=NamedValues(("internal", 1), ("local", 2), ("national", 3), ("national-special", 4), ("full", 5), ("deny", 6), ("provider", 7), ("delete", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxExtNoPermPermission.setStatus('mandatory')
if mibBuilder.loadTexts: pabxExtNoPermPermission.setDescription('')
pabxExtNoPermStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 13, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ok", 1), ("format-error", 2), ("exists-error", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pabxExtNoPermStatus.setStatus('mandatory')
if mibBuilder.loadTexts: pabxExtNoPermStatus.setDescription('')
pabxExtNoPermDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 13, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 39))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxExtNoPermDescription.setStatus('mandatory')
if mibBuilder.loadTexts: pabxExtNoPermDescription.setDescription('')
systelTerminalTable = MibTable((1, 3, 6, 1, 4, 1, 272, 4, 20, 14), )
if mibBuilder.loadTexts: systelTerminalTable.setStatus('mandatory')
if mibBuilder.loadTexts: systelTerminalTable.setDescription('The systelTerminalTable stores all information about system phones attached to the brick. This covers serial number, software version, release date and other information provided by system phone. Deleting a row is done by setting systelTermAutoMove to value delete.')
systelTerminalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 272, 4, 20, 14, 1), ).setIndexNames((0, "BIANCA-BOX-PABX-MIB", "systelTermSerialNo"))
if mibBuilder.loadTexts: systelTerminalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: systelTerminalEntry.setDescription('')
systelTermSerialNo = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 14, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systelTermSerialNo.setStatus('mandatory')
if mibBuilder.loadTexts: systelTermSerialNo.setDescription('This field is only for terminals of type system-phone and specifies its serial number.')
systelTermAutoMove = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 14, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2), ("delete", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systelTermAutoMove.setStatus('mandatory')
if mibBuilder.loadTexts: systelTermAutoMove.setDescription('This field specifies whether a terminal shall be automatically reconfigured in case terminal logs in on another port than the one defined in current configuration. By default automatic reconfiguration is disabled.')
systelTermSWVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 14, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: systelTermSWVersion.setStatus('mandatory')
if mibBuilder.loadTexts: systelTermSWVersion.setDescription('SystelSWVersion shows the version of the attached system phone and is only valid for terminals of type system-phone.')
systelTermRelDate = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 14, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: systelTermRelDate.setStatus('mandatory')
if mibBuilder.loadTexts: systelTermRelDate.setDescription("SystelRelDate shows the system phone software's release date and is only valid for terminals of type system-phone.")
systelTermCountry = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 14, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: systelTermCountry.setStatus('mandatory')
if mibBuilder.loadTexts: systelTermCountry.setDescription('SystelCountry shows the active country profile in the attached system phone and is only valid for terminals of type system-phone.')
systelTermOEMString = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 14, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: systelTermOEMString.setStatus('mandatory')
if mibBuilder.loadTexts: systelTermOEMString.setDescription('SystelOEMString shows OEM string found in system phone and is only valid for terminals of type system-phone.')
systelTermDBVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 14, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: systelTermDBVersion.setStatus('mandatory')
if mibBuilder.loadTexts: systelTermDBVersion.setDescription('SystelDBVersion shows data base version found in system phone and is only valid for terminals of type system-phone.')
systelTermSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 14, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: systelTermSlot.setStatus('mandatory')
if mibBuilder.loadTexts: systelTermSlot.setDescription('The field systelTermSlot serves as a hint to which port the system phone is attached to and is only needed for automatical configuration purposes.')
systelTermUnit = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 14, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: systelTermUnit.setStatus('mandatory')
if mibBuilder.loadTexts: systelTermUnit.setDescription('The field systelTermUnit serves as a hint to which port the system phone is attached to and is only needed for automatical configuration purposes.')
systelTermTei = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 14, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: systelTermTei.setStatus('mandatory')
if mibBuilder.loadTexts: systelTermTei.setDescription('The field systelTermTei only shows the TEI of an active system terminal.')
systelTermAutoConf = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 14, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on-registration", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systelTermAutoConf.setStatus('mandatory')
if mibBuilder.loadTexts: systelTermAutoConf.setDescription('AutoConf controls whether the brick tries setting system phone configuration automatically. Value off means no automatic setting is performed, value on-registration causes the brick to invoke automatic configuration upon system phone registration. Default value is off.')
systelTermTriggerConf = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 14, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 255))).clone(namedValues=NamedValues(("done", 1), ("check", 2), ("set", 3), ("get", 4), ("get-and-create", 5), ("error", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systelTermTriggerConf.setStatus('mandatory')
if mibBuilder.loadTexts: systelTermTriggerConf.setDescription('TriggerConf allows for initiation of configuration process by setting variable to start anytime when system phone is registered with brick. Beyond termination status of last configuration process is reflected: either done upon success or error upon failure. Default value is done.')
systelTermLastConfAction = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 14, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unknown", 1), ("check", 2), ("set", 3), ("get", 4), ("get-and-create", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: systelTermLastConfAction.setStatus('mandatory')
if mibBuilder.loadTexts: systelTermLastConfAction.setDescription('LastConfAction remembers the most recently performed action initiated via TriggerConf helping users interpreting return value of either done or error there. Default value is unknown.')
pabxSpeedDialTable = MibTable((1, 3, 6, 1, 4, 1, 272, 4, 20, 15), )
if mibBuilder.loadTexts: pabxSpeedDialTable.setStatus('mandatory')
if mibBuilder.loadTexts: pabxSpeedDialTable.setDescription('The pabxSpeedDialTable contains shortcuts for dialling arbitrary numbers. and is in fact part of the dial plan like extensions and trunk prefixes. Deleting a row is done by setting pabxSpeedDialCtrl to value delete.')
pabxSpeedDialEntry = MibTableRow((1, 3, 6, 1, 4, 1, 272, 4, 20, 15, 1), ).setIndexNames((0, "BIANCA-BOX-PABX-MIB", "pabxSpeedDialShortcut"))
if mibBuilder.loadTexts: pabxSpeedDialEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pabxSpeedDialEntry.setDescription('')
pabxSpeedDialShortcut = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 15, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxSpeedDialShortcut.setStatus('mandatory')
if mibBuilder.loadTexts: pabxSpeedDialShortcut.setDescription('This field contains the shortcut number for an arbitrary number by which it is replaced.')
pabxSpeedDialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 15, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxSpeedDialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: pabxSpeedDialNumber.setDescription('This field contains actual number that replaces shortcut.')
pabxSpeedDialCtrl = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 20, 15, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("delete", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxSpeedDialCtrl.setStatus('mandatory')
if mibBuilder.loadTexts: pabxSpeedDialCtrl.setDescription('This field specifies whether a speed dial entry is active at all. Besides entries in speed dial table can be deleted by setting this field to delete. Default value is on')
pabxLocalPrefix = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 20, 20), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxLocalPrefix.setStatus('mandatory')
if mibBuilder.loadTexts: pabxLocalPrefix.setDescription('When this object is not empty, internal numbers are dialed by using the contents of this object as a prefix. External numbers are dialled as usual, without using a prefix. When this object is empty, internal numbers are dialled without a prefix, while external numbers need a prefix specified in the pabxTrunkPrefixTable.')
pabxTrunkMask = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 20, 21), BitValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxTrunkMask.setStatus('mandatory')
if mibBuilder.loadTexts: pabxTrunkMask.setDescription('This object is a bitmask specifying the set of trunk-lines to be used for external calls, when pabxLocalPrefix is not empty and external numbers are dialled without trunk-prefix.')
pabxPriorityVoice = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 20, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxPriorityVoice.setStatus('mandatory')
if mibBuilder.loadTexts: pabxPriorityVoice.setDescription('Enable of Disable Priority Voice Feature')
pabxMusicOnHold = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 20, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("internal", 1), ("external", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxMusicOnHold.setStatus('mandatory')
if mibBuilder.loadTexts: pabxMusicOnHold.setDescription('Select the source while call in hold state')
pabxDoorIntercomCallExtension = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 20, 24), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxDoorIntercomCallExtension.setStatus('mandatory')
if mibBuilder.loadTexts: pabxDoorIntercomCallExtension.setDescription('Specify extension to be called by door intercom.')
pabxDoorIntercomExternalOpen = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 20, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("allow", 1), ("deny", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxDoorIntercomExternalOpen.setStatus('mandatory')
if mibBuilder.loadTexts: pabxDoorIntercomExternalOpen.setDescription("Specifies whether opening the door (i.e. calling a door intercom extension) is possible via a trunk call ('allow') or not ('deny'). The default is 'denied'.")
pabxTapiAdmPassword = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 20, 26), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxTapiAdmPassword.setStatus('mandatory')
if mibBuilder.loadTexts: pabxTapiAdmPassword.setDescription("Password for TAPI super-user named 'TAPIadmin'. Default is 'bintec'.")
pabxDefaultAutoDialOutNo = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 20, 27), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxDefaultAutoDialOutNo.setStatus('mandatory')
if mibBuilder.loadTexts: pabxDefaultAutoDialOutNo.setDescription("String to be used by default if auto dialout is selected for a user/terminal/extension that has no profile associated with. Default value at system initialisation (no boot configuration) is '0'. If it's set to an empty string autodialout is disabled by system default.")
pabxDefaultAvailability = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 20, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("internal", 1), ("external", 2), ("full", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxDefaultAvailability.setStatus('mandatory')
if mibBuilder.loadTexts: pabxDefaultAvailability.setDescription('Define default availability of extension w/o associated profile. By default extensions are fully available (full), i.e. internal and external bound calls can reach the extension depending on the trunk constellation. Setting availability to internal restricts referred to extensions to be available only by internal callers.')
pabxDefaultDialPerm = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 20, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("internal", 1), ("local", 2), ("national", 3), ("national-special", 4), ("full", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxDefaultDialPerm.setStatus('mandatory')
if mibBuilder.loadTexts: pabxDefaultDialPerm.setDescription("Define dial permissions of extensions w/o associated profile. When set to 'internal' dialling out over (external) trunks is prevented. Value 'local' allows dialling external numbers without an area prefix. With setting 'national' any national number but special numbers (like mobile numbers) may be dialled. The only restriction applying to value 'national_special' is dialling of internaltional numbers. The default setting 'full' grants access to any number.")
pabxExternalCallDialPerm = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 20, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("internal", 1), ("local", 2), ("national", 3), ("national-special", 4), ("full", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxExternalCallDialPerm.setStatus('mandatory')
if mibBuilder.loadTexts: pabxExternalCallDialPerm.setDescription("Define dial permissions for external calls. When set to 'internal' dialling out over (external) trunks is prevented. Value 'local' allows dialling external numbers without an area prefix. With setting 'national' any national number but special numbers (like mobile numbers) may be dialled. The only restriction applying to value 'national_special' is dialling of internaltional numbers. The default setting is 'internal'.")
pabxCapiAdmPassword = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 20, 31), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxCapiAdmPassword.setStatus('mandatory')
if mibBuilder.loadTexts: pabxCapiAdmPassword.setDescription("Password for CAPI super-user named 'CAPIadmin'. Default is an empty password meaning CAPIadmin registration is blocked.")
pabxCountry = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 20, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("germany", 1), ("uk", 2), ("france", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pabxCountry.setStatus('mandatory')
if mibBuilder.loadTexts: pabxCountry.setDescription('Specifies country where machine resides for country specific settings.')
mibBuilder.exportSymbols("BIANCA-BOX-PABX-MIB", pabxExtPresentationNr=pabxExtPresentationNr, pabxUserTapiMedia=pabxUserTapiMedia, pabxTrunkMsnNumberType=pabxTrunkMsnNumberType, pabxTrunkTable=pabxTrunkTable, pabxUserName=pabxUserName, systelTermSerialNo=systelTermSerialNo, pabxExtFeatureCFUncond=pabxExtFeatureCFUncond, systelTermTei=systelTermTei, pabxExtensionEntry=pabxExtensionEntry, pabxExtNoPermTable=pabxExtNoPermTable, pabxExtId=pabxExtId, pabxTermType=pabxTermType, pabxDefaultDialPerm=pabxDefaultDialPerm, pabxTrunkType=pabxTrunkType, systelTermAutoConf=systelTermAutoConf, pabxUserCapi=pabxUserCapi, pabxLocalPrefix=pabxLocalPrefix, pabxExtProfileId=pabxExtProfileId, pabxTrunkPrefixPrependOnIncoming=pabxTrunkPrefixPrependOnIncoming, pabxTrunkMsnEntry=pabxTrunkMsnEntry, dod=dod, pabxExtIfIndex=pabxExtIfIndex, pabxExtFeatureEntry=pabxExtFeatureEntry, pabxProfileEntry=pabxProfileEntry, pabxTrunkSubscriberNo=pabxTrunkSubscriberNo, pabxTrunkConfig=pabxTrunkConfig, HexValue=HexValue, pabxExtFeatureCFMode=pabxExtFeatureCFMode, pabxExtToGroupTable=pabxExtToGroupTable, pabxTrunkExtension=pabxTrunkExtension, systelTermSlot=systelTermSlot, pabxExtFeatureSystelText=pabxExtFeatureSystelText, pabxTrunkMsnTable=pabxTrunkMsnTable, pabxTrunkPrefixTable=pabxTrunkPrefixTable, pabx=pabx, private=private, pabxTrunkPrefixStripOnOutgoing=pabxTrunkPrefixStripOnOutgoing, systelTerminalTable=systelTerminalTable, pabxUserPIN=pabxUserPIN, pabxTrunkMsnNumber=pabxTrunkMsnNumber, systelTermOEMString=systelTermOEMString, pabxTrunkNumber=pabxTrunkNumber, pabxTermSystelSerialNo=pabxTermSystelSerialNo, pabxTrunkEntry=pabxTrunkEntry, pabxExtensionTable=pabxExtensionTable, pabxExtEAZ=pabxExtEAZ, pabxExtIpAddr=pabxExtIpAddr, internet=internet, pabxTerminalEntry=pabxTerminalEntry, pabxTrunkCountryCode=pabxTrunkCountryCode, pabxTrunkTeiValue=pabxTrunkTeiValue, systelTermDBVersion=systelTermDBVersion, pabxExtLayer1Prot=pabxExtLayer1Prot, pabxExtTermId=pabxExtTermId, pabxGroupId=pabxGroupId, systelTermRelDate=systelTermRelDate, pabxUserId=pabxUserId, pabxExtCtrlByCapiAppNo=pabxExtCtrlByCapiAppNo, pabxUserTapiMon=pabxUserTapiMon, pabxExtToGroupExtId=pabxExtToGroupExtId, pabxDefaultAutoDialOutNo=pabxDefaultAutoDialOutNo, pabxGroupTable=pabxGroupTable, systelTermSWVersion=systelTermSWVersion, pabxProfileTable=pabxProfileTable, pabxTapiAdmPassword=pabxTapiAdmPassword, systelTermCountry=systelTermCountry, pabxDoorIntercomExternalOpen=pabxDoorIntercomExternalOpen, pabxExtToGroupCallPickupActive=pabxExtToGroupCallPickupActive, pabxExtFeatureTable=pabxExtFeatureTable, enterprises=enterprises, pabxExtFeatureSystelVolume=pabxExtFeatureSystelVolume, pabxExtUserId=pabxExtUserId, pabxSpeedDialCtrl=pabxSpeedDialCtrl, pabxDefaultAvailability=pabxDefaultAvailability, pabxTrunkDescr=pabxTrunkDescr, pabxTrunkPrefixPrefix=pabxTrunkPrefixPrefix, pabxExtFeatureCFNoReplyTimer=pabxExtFeatureCFNoReplyTimer, pabxProfileId=pabxProfileId, pabxExtCtrlByCapiApp=pabxExtCtrlByCapiApp, systelTerminalEntry=systelTerminalEntry, pabxTrunkMsnSlot=pabxTrunkMsnSlot, pabxExtToGroupGroupId=pabxExtToGroupGroupId, pabxExtInsideCallSeq=pabxExtInsideCallSeq, pabxExtNoPermDescription=pabxExtNoPermDescription, pabxExtDefaultExtFlag=pabxExtDefaultExtFlag, bibo=bibo, pabxTermProfileId=pabxTermProfileId, pabxExtOutsideCallSeq=pabxExtOutsideCallSeq, pabxProfileDialPerm=pabxProfileDialPerm, pabxMusicOnHold=pabxMusicOnHold, pabxCountry=pabxCountry, pabxTrunkUnit=pabxTrunkUnit, Date=Date, pabxTermUnit=pabxTermUnit, pabxTermName=pabxTermName, pabxSpeedDialTable=pabxSpeedDialTable, pabxExtNoPermPermission=pabxExtNoPermPermission, pabxExtPresentationFlag=pabxExtPresentationFlag, pabxTrunkProtocol=pabxTrunkProtocol, pabxTermPrimUserId=pabxTermPrimUserId, pabxGroupCalladdInhibit=pabxGroupCalladdInhibit, pabxExternalCallDialPerm=pabxExternalCallDialPerm, pabxGroupEntry=pabxGroupEntry, pabxUserEntry=pabxUserEntry, pabxTermId=pabxTermId, systelTermTriggerConf=systelTermTriggerConf, pabxTrunkPrefixStatus=pabxTrunkPrefixStatus, pabxProfileAvailability=pabxProfileAvailability, pabxExtFeatureExtId=pabxExtFeatureExtId, pabxTrunkPrefixTrunkMask=pabxTrunkPrefixTrunkMask, pabxExtFeatureEMailAddr=pabxExtFeatureEMailAddr, pabxTrunkTeiProc=pabxTrunkTeiProc, pabxProfileName=pabxProfileName, pabxExtNoPermStatus=pabxExtNoPermStatus, pabxExtNoPermNumber=pabxExtNoPermNumber, pabxTrunkL2Mode=pabxTrunkL2Mode, pabxTrunkMsnUnit=pabxTrunkMsnUnit, pabxExtFeatureCFBusy=pabxExtFeatureCFBusy, pabxExtNoPermEntry=pabxExtNoPermEntry, pabxExtToGroupEntry=pabxExtToGroupEntry, pabxSpeedDialShortcut=pabxSpeedDialShortcut, pabxProfileAutoDialOutNo=pabxProfileAutoDialOutNo, pabxExtFeatureSystelMSNSlot=pabxExtFeatureSystelMSNSlot, pabxExtFeatureCFNoReply=pabxExtFeatureCFNoReply, pabxTerminalTable=pabxTerminalTable, pabxUserTapiCtrl=pabxUserTapiCtrl, systelTermLastConfAction=systelTermLastConfAction, pabxTermSlot=pabxTermSlot, pabxTrunkSlot=pabxTrunkSlot, pabxUserTable=pabxUserTable, pabxSpeedDialEntry=pabxSpeedDialEntry, pabxCapiAdmPassword=pabxCapiAdmPassword, pabxPriorityVoice=pabxPriorityVoice, pabxUserPassword=pabxUserPassword, pabxDoorIntercomCallExtension=pabxDoorIntercomCallExtension, pabxSpeedDialNumber=pabxSpeedDialNumber, pabxUserPrimGroupId=pabxUserPrimGroupId, pabxTrunkPrefixEntry=pabxTrunkPrefixEntry, pabxTermDestination=pabxTermDestination, pabxGroupName=pabxGroupName, systelTermAutoMove=systelTermAutoMove, pabxTrunkAreaCode=pabxTrunkAreaCode, systelTermUnit=systelTermUnit, pabxExtType=pabxExtType, org=org, pabxExtExtension=pabxExtExtension, pabxTrunkMask=pabxTrunkMask, bintec=bintec)

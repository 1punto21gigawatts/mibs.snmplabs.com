#
# PySNMP MIB module CTRON-IF-REMAP-2-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CTRON-IF-REMAP-2-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:30:08 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ConstraintsIntersection, ValueRangeConstraint, SingleValueConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ConstraintsIntersection", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsUnion")
ctIFRemap2, = mibBuilder.importSymbols("CTRON-MIB-NAMES", "ctIFRemap2")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
IpAddress, MibScalar, MibTable, MibTableRow, MibTableColumn, Integer32, TimeTicks, Bits, iso, NotificationType, Counter32, ObjectIdentity, Unsigned32, ModuleIdentity, Gauge32, Counter64, MibIdentifier = mibBuilder.importSymbols("SNMPv2-SMI", "IpAddress", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Integer32", "TimeTicks", "Bits", "iso", "NotificationType", "Counter32", "ObjectIdentity", "Unsigned32", "ModuleIdentity", "Gauge32", "Counter64", "MibIdentifier")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
ctIFRemap2Config = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 1, 14, 1))
ctIFRemap2Table = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 1, 14, 1, 1), )
if mibBuilder.loadTexts: ctIFRemap2Table.setStatus('mandatory')
if mibBuilder.loadTexts: ctIFRemap2Table.setDescription('This table provides the ability to remap all frames from one port onto another port. A port is defined by ctIFRemap2PortIndex from the ctIFRemap2PortTable below. Only ports listed in the ctIFRemap2PortTable are available for remapping. A given source port may only be mapped to only one destination port. Once a port is reserved as part of a ctIFRemap2Table entry, it may not be used in any other ctIFRemap2Table entries (ie. If remapping port 1 to port 3, then neither port 1 or port 3 may be used as a ctIFRemap2SourcePort or ctIFRemap2DestPort in another ctIFRemap2Table entry). Each row that exists in this table defines such a relationship. By disabling a row in this table the remapping relationship no longer exists. Each entry will be referenced by slot. In the case of a stand-alone device the slot will always be 1. If a given relationship cannot be created the set will fail with a BAD-VALUE error.')
ctIFRemap2Entry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 1, 14, 1, 1, 1), ).setIndexNames((0, "CTRON-IF-REMAP-2-MIB", "ctIFRemap2SourceSlot"), (0, "CTRON-IF-REMAP-2-MIB", "ctIFRemap2SourcePort"), (0, "CTRON-IF-REMAP-2-MIB", "ctIFRemap2DestSlot"), (0, "CTRON-IF-REMAP-2-MIB", "ctIFRemap2DestPort"))
if mibBuilder.loadTexts: ctIFRemap2Entry.setStatus('mandatory')
if mibBuilder.loadTexts: ctIFRemap2Entry.setDescription('Describes a particular ifremap entry.')
ctIFRemap2SourceSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 1, 14, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctIFRemap2SourceSlot.setStatus('mandatory')
if mibBuilder.loadTexts: ctIFRemap2SourceSlot.setDescription('The slot combined with the ctIFRemap2SourcePort which will have all packets redirected to the destination port as defined by ctIFRemap2DestSlot and ctIFRemap2DestPort.')
ctIFRemap2SourcePort = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 1, 14, 1, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctIFRemap2SourcePort.setStatus('mandatory')
if mibBuilder.loadTexts: ctIFRemap2SourcePort.setDescription('The port combined with the ctIFRemap2SourceSlot which will have all packets redirected to the destination port as defined by ctIFRemap2DestSlot and ctIFRemap2DestPort.')
ctIFRemap2DestSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 1, 14, 1, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctIFRemap2DestSlot.setStatus('mandatory')
if mibBuilder.loadTexts: ctIFRemap2DestSlot.setDescription('The slot combined with the ctIFRemap2DestPort which will see all packets redirected from ctIFRemap2SourceSlot and ctIFRemap2SourcePort.')
ctIFRemap2DestPort = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 1, 14, 1, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctIFRemap2DestPort.setStatus('mandatory')
if mibBuilder.loadTexts: ctIFRemap2DestPort.setDescription('The port combined with the ctIFRemap2DestSlot which will see all packets redirected from ctIFRemap2SourceSlot and ctIFRemap2SourcePort.')
ctIFRemap2Status = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 1, 14, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctIFRemap2Status.setStatus('mandatory')
if mibBuilder.loadTexts: ctIFRemap2Status.setDescription('Defines the status of the ifremap entry. Setting ctIFRemap2Status to a value of enable(1) has the effect of creating an entry in the table when it does not already exist. Setting ctIFRemap2Status to a value of disable(2) disables the entry and deletes the row from the table. Therefore this table only contains entries that are active.')
ctIFRemap2PhysicalErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 1, 14, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("unsupported", 3))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctIFRemap2PhysicalErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ctIFRemap2PhysicalErrors.setDescription('Enable or disable remapping of physical errors. This object controls whether or not frames with physical errors should be remapped out the destination port for this entry. By default, this will be enabled when an entry is created. NOTE: This action is always superseded by the value of ctIFRemap2PhysErrsCapable for either the source or destination port specified in this remap entry. If a port is not physically capable of transmitting or receiving error frames, then this object will return unsupported(3) and the value cannot be changed.')
ctIFRemap2EgressType = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 1, 14, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("normal", 1), ("alwaysTagged", 2), ("alwaysUntagged", 3))).clone('normal')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctIFRemap2EgressType.setStatus('mandatory')
if mibBuilder.loadTexts: ctIFRemap2EgressType.setDescription('Defines how each packet will be tagged when sent out the ctIFRemap2DestPort. Setting ctIFRemap2EgressType to normal(1) will set packets to be sent out as they are seen by ctIFRemap2SourcePort. Setting ctIFRemap2EgressType to alwaysTagged(2) will set packets to always be sent out ctIFRemap2DestSlot and ctIFRemap2DestPort with a tag. Setting ctIFRemap2EgressType to alwaysUntagged(3) will set packets to always be sent out ctIFRemap2DestSlot and ctIFRemap2DestPort without a tag. If the module is not configured to support packet tagging (i.e. 802.1d bridge mode) then setting this object to alwaysTagged(2) or alwaysUntagged(3) will return a BAD-VALUE error.')
ctIFRemap2PortTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 1, 14, 1, 2), )
if mibBuilder.loadTexts: ctIFRemap2PortTable.setStatus('mandatory')
if mibBuilder.loadTexts: ctIFRemap2PortTable.setDescription('This table holds all valid ports that are remappable or able to accept a remapped packet.')
ctIFRemap2PortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 1, 14, 1, 2, 1), ).setIndexNames((0, "CTRON-IF-REMAP-2-MIB", "ctIFRemap2PortSlot"), (0, "CTRON-IF-REMAP-2-MIB", "ctIFRemap2PortIndex"))
if mibBuilder.loadTexts: ctIFRemap2PortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ctIFRemap2PortEntry.setDescription('Describes a particular supported remappable port.')
ctIFRemap2PortSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 1, 14, 1, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctIFRemap2PortSlot.setStatus('mandatory')
if mibBuilder.loadTexts: ctIFRemap2PortSlot.setDescription('Defines the slot in which the remap capable module resides. In the case of a stand-alone device the slot will always be 1.')
ctIFRemap2PortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 1, 14, 1, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctIFRemap2PortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ctIFRemap2PortIndex.setDescription('Defines an port that is remappable or is able to accept a remapped packet. Ideally indices will start with 1 and will be numbered continuously through the number of available remap ports. However, this need not necessarily be the case. Indices may be sparse and begin with any number if desired for a particular implementation.')
ctIFRemap2PortReference = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 1, 14, 1, 2, 1, 3), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctIFRemap2PortReference.setStatus('mandatory')
if mibBuilder.loadTexts: ctIFRemap2PortReference.setDescription('This object returns an OID referencing an object which uniquely corresponds to this remap port. The only criteria is that this OID is a leaf, and that it exists and is accessible. For example, if remap functionality is running on an 802.1d compliant bridge, remap port #1 could reference dot1dBasePort.1. Alternatively you could reference a mib2 interface like ifIndex.1 or a Cabletron Secure Fast port. Mixing these types (some refer to bridge ports, others refer to SFS ports) is not advised, but not prohibited')
ctIFRemap2PhysErrsCapable = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 1, 14, 1, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("supported", 1), ("unsupported", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctIFRemap2PhysErrsCapable.setStatus('mandatory')
if mibBuilder.loadTexts: ctIFRemap2PhysErrsCapable.setDescription('Indicate whether the port is incapable of remapping physical errors. If the capability is supported, this object will return supported(1). If the capability is unsupported, this object will return unsupported(2).')
ctIFRemap2SlotTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 1, 14, 1, 3), )
if mibBuilder.loadTexts: ctIFRemap2SlotTable.setStatus('mandatory')
if mibBuilder.loadTexts: ctIFRemap2SlotTable.setDescription('This table contains all information pertaining to the abilities or limitations of a particular remap capable module.')
ctIFRemap2SlotEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 1, 14, 1, 3, 1), ).setIndexNames((0, "CTRON-IF-REMAP-2-MIB", "ctIFRemap2SlotIndex"))
if mibBuilder.loadTexts: ctIFRemap2SlotEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ctIFRemap2SlotEntry.setDescription('Describes a particular entry in the ctIFRemap2SlotTable. Each entry is indexed by the physical slot in which the module resides.')
ctIFRemap2SlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 1, 14, 1, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctIFRemap2SlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ctIFRemap2SlotIndex.setDescription('Defines the slot in which the remap capable module resides. In the case of a stand-alone device the slot will always be 1.')
ctIFRemap2SlotMaxRemaps = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 1, 14, 1, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctIFRemap2SlotMaxRemaps.setStatus('mandatory')
if mibBuilder.loadTexts: ctIFRemap2SlotMaxRemaps.setDescription('The maximum number of entries allowed to be sourced from the module in this slot in the ctIFRemap2Table.')
ctIFRemap2SlotMaxRemoteDests = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 1, 14, 1, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctIFRemap2SlotMaxRemoteDests.setStatus('mandatory')
if mibBuilder.loadTexts: ctIFRemap2SlotMaxRemoteDests.setDescription('The maximum number of remote destination ports per remote module. For example, a value of 3 means that I can have no more than 3 remap destination ports between this module, and any other given module in the same chassis simultaneously. I can have multiple source ports remapped to each of the three remote destination ports. I can also remap to up to three remote destination ports on each of the other modules in the chassis simultaneously.')
ctIFRemap2VlanTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 1, 14, 1, 4), )
if mibBuilder.loadTexts: ctIFRemap2VlanTable.setReference('ctvlan-ext-mib .4.4.1.1')
if mibBuilder.loadTexts: ctIFRemap2VlanTable.setStatus('mandatory')
if mibBuilder.loadTexts: ctIFRemap2VlanTable.setDescription('This table provides the ability to remap all frames from any port on a particular vlan to a specific destination port. Each row that exists in this table defines such a relationship. By disabling a row in this table the remapping relationship no longer exists. Multiple vlans may be mapped to a given destination port (ie. vlan 11 and vlan 35 may both remap to port 10). A port is defined by ctIFRemap2PortIndex in the ctIFRemap2PortTable, above. Only ports listed in the ctIFRemap2PortTable are available for remapping. A vlan is defined by ctVlanVID in the ctVlanConfigTable. Only vlans listed in the ctVlanConfigTable are available for remapping. Each entry will be referenced by slot. In the case of a stand-alone device the slot will always be 1. If a given relationship cannot be created the set will fail with a BAD-VALUE error.')
ctIFRemap2VlanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 1, 14, 1, 4, 1), ).setIndexNames((0, "CTRON-IF-REMAP-2-MIB", "ctIFRemap2VlanSourceSlot"), (0, "CTRON-IF-REMAP-2-MIB", "ctIFRemap2VlanSourceVlan"), (0, "CTRON-IF-REMAP-2-MIB", "ctIFRemap2VlanDestSlot"), (0, "CTRON-IF-REMAP-2-MIB", "ctIFRemap2VlanDestPort"))
if mibBuilder.loadTexts: ctIFRemap2VlanEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ctIFRemap2VlanEntry.setDescription('Describes a particular ifremap Vlan entry.')
ctIFRemap2VlanSourceSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 1, 14, 1, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctIFRemap2VlanSourceSlot.setStatus('mandatory')
if mibBuilder.loadTexts: ctIFRemap2VlanSourceSlot.setDescription('The slot combined with the ctIFRemap2VlanSourceVlan which will have all packets redirected to the destination port as defined by ctIFRemap2VlanDestSlot and ctIFRemap2VlanDestPort.')
ctIFRemap2VlanSourceVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 1, 14, 1, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctIFRemap2VlanSourceVlan.setStatus('mandatory')
if mibBuilder.loadTexts: ctIFRemap2VlanSourceVlan.setDescription('The vlan combined with the ctIFRemap2VlanSourceSlot which will have all packets redirected to the destination port as defined by ctIFRemap2VlanDestSlot and ctIFRemap2VlanDestPort.')
ctIFRemap2VlanDestSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 1, 14, 1, 4, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctIFRemap2VlanDestSlot.setStatus('mandatory')
if mibBuilder.loadTexts: ctIFRemap2VlanDestSlot.setDescription('The slot combined with the ctIFRemap2VlanDestPort which will see all packets redirected from ctIFRemap2VlanSourceSlot and ctIFRemap2VlanSourceVlan.')
ctIFRemap2VlanDestPort = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 1, 14, 1, 4, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctIFRemap2VlanDestPort.setStatus('mandatory')
if mibBuilder.loadTexts: ctIFRemap2VlanDestPort.setDescription('The port combined with the ctIFRemap2VlanDestSlot which will see all packets redirected from ctIFRemap2VlanSourceSlot and ctIFRemap2VlanSourceVlan.')
ctIFRemap2VlanStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 1, 14, 1, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctIFRemap2VlanStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ctIFRemap2VlanStatus.setDescription('Defines the status of the ifremap vlan entry. Setting ctIFRemap2VlanStatus to a value of enable(1) has the effect of creating an entry in the table when it does not already exist. Setting ctIFRemap2VlanStatus to a value of disable(2) disables the entry and deletes the row from the table. Therefore this table only contains entries that are active. If ctIFRemap2VlanSourceVlan is already being used by another ctIfRemap2Vlan entry or ctifRemap2 Entry then a set to ctIFRemap2VlanStatus of value enable(1) will return with a BAD-VALUE error.')
ctIFRemap2VlanEgressType = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 1, 14, 1, 4, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("received", 1), ("alwaysTagged", 2), ("alwaysUntagged", 3))).clone('received')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctIFRemap2VlanEgressType.setStatus('mandatory')
if mibBuilder.loadTexts: ctIFRemap2VlanEgressType.setDescription("Defines how each packet will be tagged when sent out the ctIFRemap2VlanDestPort. Setting ctIFRemap2VlanEgressType to received(1) will set packets to be sent out ctIFRemap2VlanDestSlot and ctIFRemap2VlanDestPort exactly as they are received by ctIFRemap2VlanSourceVlan. Setting ctIFRemap2VlanEgressType to alwaysTagged(2) will set packets to be sent out ctIFRemap2VlanDestSlot and ctIFRemap2VlanDestPort with the vlan tag associated with ctIFRemap2VlanSourceVlan. If this port does not have a vlan tag associated with it then all packets will be remapped without a tag. Setting ctIFRemap2VlanEgressType to alwaysUntagged(3) will set packets to be sent out ctIFRemap2VlanDestSlot and ctIFRemap2VlanDestPort without any tag reguardless of ctIFRemap2VlanSourceVlan's tagging status.")
mibBuilder.exportSymbols("CTRON-IF-REMAP-2-MIB", ctIFRemap2DestPort=ctIFRemap2DestPort, ctIFRemap2VlanTable=ctIFRemap2VlanTable, ctIFRemap2VlanEntry=ctIFRemap2VlanEntry, ctIFRemap2SourcePort=ctIFRemap2SourcePort, ctIFRemap2PortSlot=ctIFRemap2PortSlot, ctIFRemap2SlotTable=ctIFRemap2SlotTable, ctIFRemap2SlotEntry=ctIFRemap2SlotEntry, ctIFRemap2VlanStatus=ctIFRemap2VlanStatus, ctIFRemap2SlotIndex=ctIFRemap2SlotIndex, ctIFRemap2DestSlot=ctIFRemap2DestSlot, ctIFRemap2Status=ctIFRemap2Status, ctIFRemap2PhysErrsCapable=ctIFRemap2PhysErrsCapable, ctIFRemap2SlotMaxRemoteDests=ctIFRemap2SlotMaxRemoteDests, ctIFRemap2VlanEgressType=ctIFRemap2VlanEgressType, ctIFRemap2PortReference=ctIFRemap2PortReference, ctIFRemap2PortTable=ctIFRemap2PortTable, ctIFRemap2VlanSourceVlan=ctIFRemap2VlanSourceVlan, ctIFRemap2SlotMaxRemaps=ctIFRemap2SlotMaxRemaps, ctIFRemap2EgressType=ctIFRemap2EgressType, ctIFRemap2PortEntry=ctIFRemap2PortEntry, ctIFRemap2PortIndex=ctIFRemap2PortIndex, ctIFRemap2PhysicalErrors=ctIFRemap2PhysicalErrors, ctIFRemap2VlanSourceSlot=ctIFRemap2VlanSourceSlot, ctIFRemap2SourceSlot=ctIFRemap2SourceSlot, ctIFRemap2Table=ctIFRemap2Table, ctIFRemap2Config=ctIFRemap2Config, ctIFRemap2VlanDestPort=ctIFRemap2VlanDestPort, ctIFRemap2Entry=ctIFRemap2Entry, ctIFRemap2VlanDestSlot=ctIFRemap2VlanDestSlot)

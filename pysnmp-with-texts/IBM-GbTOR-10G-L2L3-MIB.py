#
# PySNMP MIB module IBM-GbTOR-10G-L2L3-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/IBM-GbTOR-10G-L2L3-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:51:00 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ConstraintsIntersection, ValueSizeConstraint, SingleValueConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ConstraintsIntersection", "ValueSizeConstraint", "SingleValueConstraint", "ConstraintsUnion")
dot1dBasePort, dot1dTpPort, BridgeId, dot1dTp, dot1dBridge, dot1dBasePortEntry = mibBuilder.importSymbols("BRIDGE-MIB", "dot1dBasePort", "dot1dTpPort", "BridgeId", "dot1dTp", "dot1dBridge", "dot1dBasePortEntry")
ifIndex, InterfaceIndexOrZero, InterfaceIndex = mibBuilder.importSymbols("IF-MIB", "ifIndex", "InterfaceIndexOrZero", "InterfaceIndex")
InetAddressIPv6, InetAddress, InetAddressType = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddressIPv6", "InetAddress", "InetAddressType")
EnabledStatus, = mibBuilder.importSymbols("P-BRIDGE-MIB", "EnabledStatus")
PortList, = mibBuilder.importSymbols("Q-BRIDGE-MIB", "PortList")
SnmpEngineID, SnmpMessageProcessingModel, SnmpSecurityLevel, SnmpSecurityModel, SnmpAdminString = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpEngineID", "SnmpMessageProcessingModel", "SnmpSecurityLevel", "SnmpSecurityModel", "SnmpAdminString")
usmNoPrivProtocol, usmNoAuthProtocol = mibBuilder.importSymbols("SNMP-USER-BASED-SM-MIB", "usmNoPrivProtocol", "usmNoAuthProtocol")
ModuleCompliance, ObjectGroup, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "ObjectGroup", "NotificationGroup")
sysLocation, sysContact, sysName = mibBuilder.importSymbols("SNMPv2-MIB", "sysLocation", "sysContact", "sysName")
IpAddress, NotificationType, iso, Unsigned32, Counter64, ObjectIdentity, Integer32, Gauge32, enterprises, MibIdentifier, Bits, MibScalar, MibTable, MibTableRow, MibTableColumn, mib_2, TimeTicks, Counter32, ModuleIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "IpAddress", "NotificationType", "iso", "Unsigned32", "Counter64", "ObjectIdentity", "Integer32", "Gauge32", "enterprises", "MibIdentifier", "Bits", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "mib-2", "TimeTicks", "Counter32", "ModuleIdentity")
RowStatus, RowPointer, TimeInterval, TAddress, TimeStamp, TruthValue, TextualConvention, TDomain, AutonomousType, StorageType, PhysAddress, DisplayString, MacAddress = mibBuilder.importSymbols("SNMPv2-TC", "RowStatus", "RowPointer", "TimeInterval", "TAddress", "TimeStamp", "TruthValue", "TextualConvention", "TDomain", "AutonomousType", "StorageType", "PhysAddress", "DisplayString", "MacAddress")
ibmGbTORG8124MIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 26543, 3))
if mibBuilder.loadTexts: ibmGbTORG8124MIB.setLastUpdated('201308142148Z')
if mibBuilder.loadTexts: ibmGbTORG8124MIB.setOrganization('IBM/System Networking')
if mibBuilder.loadTexts: ibmGbTORG8124MIB.setContactInfo(' IBM/System Networking 4400 North First Street San Jose, CA 95134 408-956-3239 ')
if mibBuilder.loadTexts: ibmGbTORG8124MIB.setDescription(' MIB for IBM Networking Operating System RackSwitch G8124 All Rights reserved DEVICE VERSION: 7.7.5.0 ')
class PortNumber(TextualConvention, Unsigned32):
    description = 'Represents a port number of a switch.'
    status = 'current'

class VlanId(TextualConvention, Integer32):
    description = 'A 12-bit VLAN ID used in the VLAN Tag header.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 4094)

class Timeout(TextualConvention, Integer32):
    description = ' Time out value in 4 byte'
    status = 'current'
    displayHint = 'd4'

blade = MibIdentifier((1, 3, 6, 1, 4, 1, 26543))
registration = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 1))
private_mibs = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2)).setLabel("private-mibs")
ibm_switch_mgmt = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7)).setLabel("ibm-switch-mgmt")
g8124_mgmt = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4)).setLabel("g8124-mgmt")
ibm_switch = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 1, 7)).setLabel("ibm-switch")
g8124 = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 1, 7, 4))
agent = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1))
agentConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1))
agentStats = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2))
agentInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3))
agentOper = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 4))
agSystem = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1))
agPortConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 2))
agRadiusConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 3))
agNTP = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 4))
agSyslog = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5))
agTransfer = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 7))
agApply = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 8))
agTacacsConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 11))
agMgmtNetConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 12))
agBoot = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 13))
agAccess = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 19))
agLdapConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 21))
agSSHConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 22))
agsFlowConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 24))
pktStats = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 1))
mpCpuStats = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 2))
portStats = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3))
agClearStats = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 7))
ntpStats = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 9))
aclStats = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 11))
memoryStats = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 12))
snmpStats = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 20))
mpTcbStats = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 21))
mpUdpStats = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 22))
hardware = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 1))
portInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 2))
agDiff = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 4))
agCfgDump = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 5))
geaportInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 9))
sfpInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 11))
accessInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 13))
agNTPOper = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 4, 2))
hwPartNumber = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPartNumber.setStatus('current')
if mibBuilder.loadTexts: hwPartNumber.setDescription('The hardware part number of the Switch.')
hwRevision = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwRevision.setStatus('current')
if mibBuilder.loadTexts: hwRevision.setDescription('The hardware revision. If the revision is not available, a zero length string should be returned.')
hwFanStatus = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwFanStatus.setStatus('current')
if mibBuilder.loadTexts: hwFanStatus.setDescription('The fan status on the system.')
hwFanSpeed = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 1, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwFanSpeed.setStatus('current')
if mibBuilder.loadTexts: hwFanSpeed.setDescription('The fan speed on the system.')
hwTempSensors = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 1, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwTempSensors.setStatus('current')
if mibBuilder.loadTexts: hwTempSensors.setDescription('The temperature sensors on the system.')
hwGlobalHealthStatus = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ok", 1), ("noncritical", 2), ("critical", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwGlobalHealthStatus.setStatus('current')
if mibBuilder.loadTexts: hwGlobalHealthStatus.setDescription(' This variable summarizes the statuses of several key elements of the device. OK: - All temperature sensors are below the warning threshold (eg. < 85 C); - All fans are running at >= 100 RPMs; - Both power supplies are on; - No panic dump exists in flash. Non-critical: - One or more temperature sensors is in the warning range (eg. >= 85 and < 100 C); - A panic dump exists in flash. Critical: - One or more temperature sensors is in the failure range (eg. >= 100 C); - One or more fans are running < 100 RPM; - One power supply is off. ')
hwMainBoardRevision = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwMainBoardRevision.setStatus('current')
if mibBuilder.loadTexts: hwMainBoardRevision.setDescription('The main board revision. If the revision is not available, a zero length string should be returned.')
agPortOperTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 4, 1), )
if mibBuilder.loadTexts: agPortOperTable.setStatus('current')
if mibBuilder.loadTexts: agPortOperTable.setDescription('The table of port operations.')
agPortOperTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 4, 1, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "portOperIdx"))
if mibBuilder.loadTexts: agPortOperTableEntry.setStatus('current')
if mibBuilder.loadTexts: agPortOperTableEntry.setDescription('A row in the port operations table.')
portOperIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 4, 1, 1, 1), PortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portOperIdx.setStatus('current')
if mibBuilder.loadTexts: portOperIdx.setDescription('The port index.')
portOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portOperState.setStatus('current')
if mibBuilder.loadTexts: portOperState.setDescription('Enable/Disable port.')
portOperRmon = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portOperRmon.setStatus('current')
if mibBuilder.loadTexts: portOperRmon.setDescription('Enable/Disable RMON for port.')
portOperLearning = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portOperLearning.setStatus('current')
if mibBuilder.loadTexts: portOperLearning.setDescription('Enable/Disable L2 (FDB) Learning for this port.')
ntpOperSendReq = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 4, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntpOperSendReq.setStatus('current')
if mibBuilder.loadTexts: ntpOperSendReq.setDescription('Allows the user to send requests to the NTP server.')
portInfoTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 2, 1), )
if mibBuilder.loadTexts: portInfoTable.setStatus('current')
if mibBuilder.loadTexts: portInfoTable.setDescription('The table of port information.')
portInfoTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 2, 1, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "portInfoIndx"))
if mibBuilder.loadTexts: portInfoTableEntry.setStatus('current')
if mibBuilder.loadTexts: portInfoTableEntry.setDescription('A row in the port information table.')
portInfoIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 2, 1, 1, 1), PortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portInfoIndx.setStatus('current')
if mibBuilder.loadTexts: portInfoIndx.setDescription('The port index.')
portInfoSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("mbs10", 2), ("mbs100", 3), ("mbs1000", 4), ("any", 5), ("mbs10000", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portInfoSpeed.setStatus('current')
if mibBuilder.loadTexts: portInfoSpeed.setDescription('The current operational speed of the port.')
portInfoMode = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("full-duplex", 2), ("half-duplex", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portInfoMode.setStatus('current')
if mibBuilder.loadTexts: portInfoMode.setDescription('The current operational mode of the port.')
portInfoFlowCtrl = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5))).clone(namedValues=NamedValues(("transmit", 2), ("receive", 3), ("both", 4), ("none", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portInfoFlowCtrl.setStatus('current')
if mibBuilder.loadTexts: portInfoFlowCtrl.setDescription('The current operational flow control of the port.')
portInfoLink = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("disabled", 3), ("inoperative", 4), ("errdisabled", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portInfoLink.setStatus('current')
if mibBuilder.loadTexts: portInfoLink.setDescription('The current operational link status of the port.')
portInfoPhyIfDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 2, 1, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portInfoPhyIfDescr.setStatus('current')
if mibBuilder.loadTexts: portInfoPhyIfDescr.setDescription('A textual string containing information about the interface. This string should include the name of the manufacturer, the product name and the version of the hardware interface.')
portInfoPhyIfType = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32))).clone(namedValues=NamedValues(("other", 1), ("regular1822", 2), ("hdh1822", 3), ("ddn-x25", 4), ("rfc877-x25", 5), ("ethernet-csmacd", 6), ("iso88023-csmacd", 7), ("iso88024-tokenBus", 8), ("iso88025-tokenRing", 9), ("iso88026-man", 10), ("starLan", 11), ("proteon-10Mbit", 12), ("proteon-80Mbit", 13), ("hyperchannel", 14), ("fddi", 15), ("lapb", 16), ("sdlc", 17), ("ds1", 18), ("e1", 19), ("basicISDN", 20), ("primaryISDN", 21), ("propPointToPointSerial", 22), ("ppp", 23), ("softwareLoopback", 24), ("eon", 25), ("ethernet-3Mbit", 26), ("nsip", 27), ("slip", 28), ("ultra", 29), ("ds3", 30), ("sip", 31), ("frame-relay", 32)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portInfoPhyIfType.setStatus('current')
if mibBuilder.loadTexts: portInfoPhyIfType.setDescription("The type of interface, distinguished according to the physical/link protocol(s) immediately `below' the network layer in the protocol stack.")
portInfoPhyIfMtu = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 2, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portInfoPhyIfMtu.setStatus('current')
if mibBuilder.loadTexts: portInfoPhyIfMtu.setDescription('The size of the largest datagram which can be sent/received on the interface, specified in octets. For interfaces that are used for transmitting network datagrams, this is the size of the largest network datagram that can be sent on the interface.')
portInfoPhyIfPhysAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 2, 1, 1, 9), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portInfoPhyIfPhysAddress.setStatus('current')
if mibBuilder.loadTexts: portInfoPhyIfPhysAddress.setDescription("The interface's address at the protocol layer immediately `below' the network layer in the protocol stack. For interfaces which do not have such an address (e.g., a serial line), this object should contain an octet string of zero length.")
portInfoPhyIfOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portInfoPhyIfOperStatus.setStatus('current')
if mibBuilder.loadTexts: portInfoPhyIfOperStatus.setDescription('The current operational state of the interface. The testing(3) state indicates that no operational packets can be passed.')
portInfoPhyIfLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 2, 1, 1, 11), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portInfoPhyIfLastChange.setStatus('current')
if mibBuilder.loadTexts: portInfoPhyIfLastChange.setDescription('The value of sysUpTime at the time the interface entered its current operational state. If the current state was entered prior to the last re- initialization of the local network management subsystem, then this object contains a zero value.')
portInfoLearning = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 2, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portInfoLearning.setStatus('current')
if mibBuilder.loadTexts: portInfoLearning.setDescription('The port L2 (FDB) Learning state.')
portInfoBpduGuard = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 2, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portInfoBpduGuard.setStatus('current')
if mibBuilder.loadTexts: portInfoBpduGuard.setDescription('The operational status of BPDU Guard on the port.')
portInfoPvid = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 2, 1, 1, 21), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portInfoPvid.setStatus('current')
if mibBuilder.loadTexts: portInfoPvid.setDescription('This is the operational port vlan-id of the port. Typically, the value of this object is the same as the value of the agPortCurCfgPVID object. But if, for example, 802.1x is enabled on the port and the port is assigned a vlan-id via 802.1x, this port will be moved to the assigned vlan even when the port is configured with a different PVID.')
portInfoVlanTag = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 2, 1, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("untagged", 0), ("tagged", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portInfoVlanTag.setStatus('current')
if mibBuilder.loadTexts: portInfoVlanTag.setDescription('This is the operational VLAN tag state of the port. Typically, the value of this object is the same as the value of the agPortCurCfgVlanTag objec. But if, for example, 802.1x is enabled on the port and if the port is assigned a vlan via 802.1x, the port will be operationally untagged even when the port is configured to be tagged.')
portInfoErrDisableRecovery = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 2, 1, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portInfoErrDisableRecovery.setStatus('current')
if mibBuilder.loadTexts: portInfoErrDisableRecovery.setDescription("This object indicates whether the system will automatically re-enable an error-disabled port after the time interval indicated by agCurCfgErrDisableTimeout has elapsed. A port is in error-disabled state when it has been operationally disabled by the system due to an error condition. The value of this object is 'enable' if the values of both the global agCurCfgErrDisableRecovery object and the port's agPortCurCfgErrDisableRecovery object are 'enable'.")
portInfoErrDisableTimeLeft = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 2, 1, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 86400))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portInfoErrDisableTimeLeft.setStatus('current')
if mibBuilder.loadTexts: portInfoErrDisableTimeLeft.setDescription("If the portInfoErrDisableRecovery object has a value of 'enable' and the portInfoLink object has a value of 'errdisabled', the value of this object indicates the remaining time, in seconds, before the system automatically re-enables this port.")
portInfoExtGuard = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 2, 1, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 0))).clone(namedValues=NamedValues(("loop", 1), ("root", 2), ("global-loop", 3), ("no-guard", 0)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portInfoExtGuard.setStatus('current')
if mibBuilder.loadTexts: portInfoExtGuard.setDescription('The operational status of STP Loop/Root Guard on the port.')
portInfoLFDState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 2, 1, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portInfoLFDState.setStatus('current')
if mibBuilder.loadTexts: portInfoLFDState.setDescription("This object indicates whether the port is error-disabled due to excessive link flaps. The value of this object is 'yes' if the port is error-disabled due to excessive link flaps, otherwise the value is 'no'.")
agApplyConfiguration = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("apply", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agApplyConfiguration.setStatus('current')
if mibBuilder.loadTexts: agApplyConfiguration.setDescription('This is an action object to apply the changes made to configuration of the switch. By setting the value to apply(2), all the changes made since the last apply are written to the new configuration block. other(1) is returned when this object ie read. ')
agSavePending = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("saveNeeded", 1), ("noSaveNeeded", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agSavePending.setStatus('current')
if mibBuilder.loadTexts: agSavePending.setDescription('This object, when read, gives the user information whether an save action is needed and that the configuration has been applied but not saved to the flash.')
agSaveConfiguration = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ok", 1), ("saveActive", 2), ("notSaveActive", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agSaveConfiguration.setStatus('current')
if mibBuilder.loadTexts: agSaveConfiguration.setDescription('This is an action object to write current configuration to nonvolatile storage. When issued with the saveActive, the active configuration in flash is saved to backup in flash and then the new configuration is saved to the active configuration in flash. When issued with notSaveActive, the active configuration is NOT saved to the flash and the active configuration is overwritten with the new configuration. ok(1) is returned always when read.')
agRevert = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("revert", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agRevert.setStatus('current')
if mibBuilder.loadTexts: agRevert.setDescription('This is an action object to revert the unapplied changes made to the switch. By setting the value to revert(2), all the unapplied changes will be reverted. This action will copy the current_config to the new configuration block. other(1) is returned when this object is read. ')
agRevertApply = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("revertApply", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agRevertApply.setStatus('current')
if mibBuilder.loadTexts: agRevertApply.setDescription('This is an action object to revert the unsaved changes made to the switch. By setting the value to revertApply(2), all the unsaved as well as unapplied changes will be reverted. other(1) is returned when this object is read. ')
agReset = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agReset.setStatus('current')
if mibBuilder.loadTexts: agReset.setDescription('This is an action object to reboot the agent. other(1) is returned always when read.')
agConfigForNxtReset = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("active", 2), ("backup", 3), ("default", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agConfigForNxtReset.setStatus('current')
if mibBuilder.loadTexts: agConfigForNxtReset.setDescription('The configuration information to be loaded from at next reset. The following values are writable: active(2)...active configuration block backup(3)...backup configuration block default(4)..default configuration block')
agImageForNxtReset = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("image1", 2), ("image2", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agImageForNxtReset.setStatus('current')
if mibBuilder.loadTexts: agImageForNxtReset.setDescription('The software image to be booted from at next reset. The following values are writable: image1(2)...image 1 image2(3)...image 2')
agSoftwareVersion = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agSoftwareVersion.setStatus('current')
if mibBuilder.loadTexts: agSoftwareVersion.setDescription("The version of the software image that is currently running on the system in the form of 'major.minor.maintenance.bugfix'. A zero length string is returned if version is not available.")
agBootVer = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agBootVer.setStatus('current')
if mibBuilder.loadTexts: agBootVer.setDescription("The version of the boot code in the form of 'major.minor.bugfix'. A zero length string is returned if version is not available.")
agImage1Ver = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agImage1Ver.setStatus('current')
if mibBuilder.loadTexts: agImage1Ver.setDescription("The version of the software image stored in image 1 storage in the form of 'major.minor.bugfix'. A zero length string is returned if version is not available or there is no valid software image.")
agImage2Ver = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agImage2Ver.setStatus('current')
if mibBuilder.loadTexts: agImage2Ver.setDescription("The version of the software image stored in image 2 storage in the form of 'major.minor.bugfix'. A zero length string is returned if version is not available or there is no valid software image.")
agRtcDate = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agRtcDate.setStatus('current')
if mibBuilder.loadTexts: agRtcDate.setDescription("The date on the real time clock in the form of 'mm/dd/yy'. A zero length string is returned if date is not available.")
agRtcTime = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 15), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agRtcTime.setStatus('current')
if mibBuilder.loadTexts: agRtcTime.setDescription("The time on the real time clock in the form of 'hh:mm:ss'. A zero length string is returned if time is not available.")
agLastSetErrorReason = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 16), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agLastSetErrorReason.setStatus('current')
if mibBuilder.loadTexts: agLastSetErrorReason.setDescription('The error reason of the last SET failure.')
agCurCfgHttpServerPort = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgHttpServerPort.setStatus('current')
if mibBuilder.loadTexts: agCurCfgHttpServerPort.setDescription('The TCP port number that the HTTP server is listening to in the current configuration block.')
agNewCfgHttpServerPort = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgHttpServerPort.setStatus('current')
if mibBuilder.loadTexts: agNewCfgHttpServerPort.setDescription('The TCP port number that the HTTP server is listening to in the new configuration block.')
agCurCfgLoginBanner = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 19), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgLoginBanner.setStatus('current')
if mibBuilder.loadTexts: agCurCfgLoginBanner.setDescription('The user defined login banner.')
agNewCfgLoginBanner = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 20), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgLoginBanner.setStatus('current')
if mibBuilder.loadTexts: agNewCfgLoginBanner.setDescription('The user defined login banner.')
agCurCfgLoginNotice = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 78), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgLoginNotice.setStatus('current')
if mibBuilder.loadTexts: agCurCfgLoginNotice.setDescription('The user defined login notice.')
agNewCfgLoginNotice = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 79), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgLoginNotice.setStatus('current')
if mibBuilder.loadTexts: agNewCfgLoginNotice.setDescription('The user defined login notice.')
agCurCfgConsole = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgConsole.setStatus('current')
if mibBuilder.loadTexts: agCurCfgConsole.setDescription('Enable or disable console output of syslog messages.')
agNewCfgConsole = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgConsole.setStatus('current')
if mibBuilder.loadTexts: agNewCfgConsole.setDescription('Enable or disable console output of syslog messages.')
agCurCfgBootp = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("enabled", 2), ("disabled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgBootp.setStatus('current')
if mibBuilder.loadTexts: agCurCfgBootp.setDescription('Enable or disable the use of BootP, as currently configured in the current configuration block.')
agNewCfgBootp = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("enabled", 2), ("disabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgBootp.setStatus('current')
if mibBuilder.loadTexts: agNewCfgBootp.setDescription('Enable or disable the use of BootP, in the new configuration block.')
agSlotNumber = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 31), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agSlotNumber.setStatus('current')
if mibBuilder.loadTexts: agSlotNumber.setDescription('Identifies the slot in which this switch is installed. If the agent implementing this MIB is not a blade in a chassis this value has no meaning.')
agCurCfgSnmpTimeout = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 32), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 30))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgSnmpTimeout.setStatus('current')
if mibBuilder.loadTexts: agCurCfgSnmpTimeout.setDescription("Once SNMP operations like agApplyConfig, agDiffState and agDumpState, which use the state machine are done the resources used by these operations need to be freed by setting the state back to 'idle' so others can issue the commands via SNMP. agSnmpTimeout indicates the number of minutes before the resources are freed and the state set back to 'idle' if this operation is not performed by the user.")
agNewCfgSnmpTimeout = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 33), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgSnmpTimeout.setStatus('current')
if mibBuilder.loadTexts: agNewCfgSnmpTimeout.setDescription("Once SNMP operations like agApplyConfig, agDiffState and agDumpState, which use the state machine are done the resources used by these operations need to be freed by setting the state back to 'idle' so others can issue the commands via SNMP. agSnmpTimeout indicates the number of minutes before the resources are freed and the state set back to 'idle' if this operation is not performed by the user.")
agCurCfgTelnetServerPort = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 34), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgTelnetServerPort.setStatus('current')
if mibBuilder.loadTexts: agCurCfgTelnetServerPort.setDescription('The TCP port number that the telnet server listens for telnet sessions.')
agNewCfgTelnetServerPort = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 35), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgTelnetServerPort.setStatus('current')
if mibBuilder.loadTexts: agNewCfgTelnetServerPort.setDescription('The TCP port number that the telnet server listens for telnet sessions.')
agClearFlashDump = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 36), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("clear", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agClearFlashDump.setStatus('current')
if mibBuilder.loadTexts: agClearFlashDump.setDescription('This is an action object to clear the FLASH dump. ok(1) is returned when this object is read. ')
agCurCfgTrapSrcIf = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 39), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgTrapSrcIf.setStatus('current')
if mibBuilder.loadTexts: agCurCfgTrapSrcIf.setDescription('The SNMP trap source interface number.')
agNewCfgTrapSrcIf = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 40), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgTrapSrcIf.setStatus('current')
if mibBuilder.loadTexts: agNewCfgTrapSrcIf.setDescription('The SNMP trap source interface number.')
agCurCfgHttpsServerPort = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 49), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgHttpsServerPort.setStatus('current')
if mibBuilder.loadTexts: agCurCfgHttpsServerPort.setDescription('The TCP port number that the HTTPS server is listening to in the current configuration block.')
agNewCfgHttpsServerPort = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 50), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgHttpsServerPort.setStatus('current')
if mibBuilder.loadTexts: agNewCfgHttpsServerPort.setDescription('The TCP port number that the HTTPS server is listening to in the new configuration block.')
agCurCfgTftpServerPort = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 51), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgTftpServerPort.setStatus('current')
if mibBuilder.loadTexts: agCurCfgTftpServerPort.setDescription('The TCP port number that the TFTP server is listening to in the current configuration block.')
agNewCfgTftpServerPort = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 52), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgTftpServerPort.setStatus('current')
if mibBuilder.loadTexts: agNewCfgTftpServerPort.setDescription('The TCP port number that the TFTP server is listening to in the new configuration block.')
agRackId = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 53), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agRackId.setStatus('current')
if mibBuilder.loadTexts: agRackId.setDescription('The rack unique identifier.')
agChassis = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 54), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agChassis.setStatus('current')
if mibBuilder.loadTexts: agChassis.setDescription('Chassis serial number.')
agCurDaylightSavings = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 55), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254), SingleValueConstraint(255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 421, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 348, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420))).clone(namedValues=NamedValues(("none", 0), ("africa-Algeria", 1), ("africa-Angola", 2), ("africa-Benin", 3), ("africa-Botswana", 4), ("africa-Burkina-Faso", 5), ("africa-Burundi", 6), ("africa-Cameroon", 7), ("africa-Central-African-Rep", 8), ("africa-Chad", 9), ("africa-Congo-WestDemRepCongo", 10), ("africa-Congo-EastDemRepCongo", 11), ("africa-Congo-Rep", 12), ("africa-Cote-dIvoire", 13), ("africa-Djibouti", 14), ("africa-Egypt", 15), ("africa-Equatorial-Guinea", 16), ("africa-Eritrea", 17), ("africa-Ethiopia", 18), ("africa-Gabon", 19), ("africa-Gambia", 20), ("africa-Ghana", 21), ("africa-Guinea", 22), ("africa-Guinea-Bissau", 23), ("africa-Kenya", 24), ("africa-Lesotho", 25), ("africa-Liberia", 26), ("africa-Libya", 27), ("africa-Malawi", 28), ("africa-Mali-SouthWestMali", 29), ("africa-Mali-NorthEastMali", 30), ("africa-Mauritania", 31), ("africa-Morocco", 32), ("africa-Mozambique", 33), ("africa-Namibia", 34), ("africa-Niger", 35), ("africa-Nigeria", 36), ("africa-Rwanda", 37), ("africa-SaoTome-And-Principe", 38), ("africa-Senegal", 39), ("africa-SierraLeone", 40), ("africa-Somalia", 41), ("africa-SouthAfrica", 42), ("africa-Spain-Mainland", 43), ("africa-Spain-CeutaMelilla", 44), ("africa-Spain-CanaryIslands", 45), ("africa-Sudan", 46), ("africa-Swaziland", 47), ("africa-Tanzania", 48), ("africa-Togo", 49), ("africa-Tunisia", 50), ("africa-Uganda", 51), ("africa-Western-Sahara", 52), ("africa-Zambia", 53), ("africa-Zimbabwe", 54), ("americas-Anguilla", 55), ("americas-Antigua-Barbuda", 56), ("americas-Argentina-EArgentina", 57), ("americas-Argentina-MostLocations", 58), ("americas-Argentina-Jujuy", 59), ("americas-Argentina-Catamarca", 60), ("americas-Argentina-Mendoza", 61), ("americas-Aruba", 62), ("americas-Bahamas", 63), ("americas-Barbados", 64), ("americas-Belize", 65), ("americas-Bolivia", 66), ("americas-Brazil-AtlanticIslands", 67), ("americas-Brazil-AmapaEPara", 68), ("americas-Brazil-NEBrazil", 69), ("americas-Brazil-Pernambuco", 70), ("americas-Brazil-Tocantins", 71), ("americas-Brazil-AlagoasSergipe", 72), ("americas-Brazil-SSEBrazil", 73), ("americas-Brazil-MatoGrossoDoSul", 74), ("americas-Brazil-WParaRondonia", 75), ("americas-Brazil-Roraima", 76), ("americas-Brazil-EAmazonas", 77), ("americas-Brazil-WAmazonas", 78), ("americas-Brazil-Acre", 79), ("americas-Canada-NewfoundlandIsland", 80), ("americas-Canada-AtlanTime-NovaScotia", 81), ("americas-Canada-AtlanTime-ELabrador", 82), ("americas-Canada-EastTime-OntarioMostlocation", 83), ("americas-Canada-EastTime-ThunderBay", 84), ("americas-Canada-EastStdTime-PangnirtungNunavut", 85), ("americas-Canada-EastStdTime-EastNunavut", 86), ("americas-Canada-EastStdTime-CenNunavut", 87), ("americas-Canada-CenTime-ManitobaWestOntario", 88), ("americas-Canada-CenTime-RainyRiver", 89), ("americas-Canada-CenTime-WestNunavut", 90), ("americas-Canada-CenStdTime-SaskatchewanMostlocation", 91), ("americas-Canada-CenStdTime-SaskatchewanMidwest", 92), ("americas-Canada-MountTime-AlbertaEastBritishColumbia", 93), ("americas-Canada-MountTime-CentralNorthwestTerritories", 94), ("americas-Canada-MountTime-WestNorthwestTerritories", 95), ("americas-Canada-MountStdTime-DawsonCrkStJohnBritColumbia", 96), ("americas-Canada-PacificTime-WestBritishColumbia", 97), ("americas-Canada-PacificTime-SouthYukon", 98), ("americas-Canada-PacificTime-NorthYukon", 99), ("americas-CaymanIslands", 100), ("americas-Chile-MostLocation", 101), ("americas-Chile-EasterIsland", 102), ("americas-Colombia", 103), ("americas-CostaRica", 104), ("americas-Cuba", 105), ("americas-Dominica", 106), ("americas-DominicanRepublic", 107), ("americas-Ecuador", 108), ("americas-ElSalvado", 109), ("americas-FrenchGuiana", 110), ("americas-Greenland-MostLocation", 111), ("americas-Greenland-EastCoastNorthScoresbysund", 112), ("americas-Greenland-ScoresbysundIttoqqortoormiit", 113), ("americas-Greenland-ThulePituffik", 114), ("americas-Grenada", 115), ("americas-Guadeloupe", 116), ("americas-Guatemala", 117), ("americas-Guyana", 118), ("americas-Haiti", 119), ("americas-Honduras", 120), ("americas-Jamaica", 121), ("americas-Martinique", 122), ("americas-Mexico-CentTime-Mostlocations", 123), ("americas-Mexico-CentTime-QuintanaRoo", 124), ("americas-Mexico-CentTime-CampecheYucatan", 125), ("americas-Mexico-CentTime-CoahuilaDurNuevoLeonTam", 126), ("americas-Mexico-MountTime-SBajaNayaritSinaloa", 127), ("americas-Mexico-MountTime-Chihuahua", 128), ("americas-Mexico-MountStdTime-Sonora", 129), ("americas-Mexico-PacificTime", 130), ("americas-Montserrat", 131), ("americas-NetherlandsAntilles", 132), ("americas-Nicaragua", 133), ("americas-Panama", 134), ("americas-Paraguay", 135), ("americas-Peru", 136), ("americas-PuertoRico", 137), ("americas-StKittsAndNevis", 138), ("americas-StLucia", 139), ("americas-StPierreAndMiquelon", 140), ("americas-StVincent", 141), ("americas-Suriname", 142), ("americas-TrinidadAndTobago", 143), ("americas-TurksAndCaicosIs", 144), ("americas-USA-EastTime", 145), ("americas-USA-EastTime-MichiganMostLocation", 146), ("americas-USA-EastTime-KentuckyLouisvilleArea", 147), ("americas-USA-EastTime-KentuckyWayneCounty", 148), ("americas-USA-EastStdTime-IndianaMostLocations", 149), ("americas-USA-EastStdTime-IndianaCrawfordCounty", 150), ("americas-USA-EastStdTime-IndianaStarkeCounty", 151), ("americas-USA-EastStdTime-IndianaSwitzerlandCounty", 152), ("americas-USA-CentTime", 153), ("americas-USA-CentTime-MichiganWisconsinborder", 154), ("americas-USA-CentTime-NorthDakotaOliverCounty", 155), ("americas-USA-MountTime", 156), ("americas-USA-MountTime-SouthIdahoAndEastOregon", 157), ("americas-USA-MountTime-Navajo", 158), ("americas-USA-MountStdTime-Arizona", 159), ("americas-USA-PacificTime", 160), ("americas-USA-AlaskaTime", 161), ("americas-USA-AlaskaTime-AlaskaPanhandle", 162), ("americas-USA-AlaskaTime-AlaskaPanhandleNeck", 163), ("americas-USA-AlaskaTime-WestAlaska", 164), ("americas-USA-AleutianIslands", 165), ("americas-USA-Hawaii", 166), ("americas-Uruguay", 167), ("americas-Venezuela", 168), ("americas-VirginIslands-UK", 169), ("americas-VirginIslands-US", 170), ("antarctica-McMurdoStationRossIsland", 171), ("antarctica-Amundsen-ScottStationSouthPole", 172), ("antarctica-PalmerStationAnversIsland", 173), ("antarctica-MawsonStationHolmeBay", 174), ("antarctica-DavisStationVestfoldHills", 175), ("antarctica-CaseyStationBaileyPeninsula", 176), ("antarctica-VostokStationSMagneticPole", 177), ("antarctica-Dumont-dUrvilleBaseTerreAdelie", 178), ("antarctica-SyowaStationEOngulI", 179), ("arcticOcean-Svalbard", 180), ("arcticOcean-JanMayen", 181), ("asia-Afghanistan", 182), ("asia-Armenia", 183), ("asia-Azerbaijan", 184), ("asia-Bahrain", 185), ("asia-Bangladesh", 186), ("asia-Bhutan", 187), ("asia-Brunei", 188), ("asia-Cambodia", 189), ("asia-China-EastChinaBeijingGuangdongShanghai", 190), ("asia-China-Heilongjiang", 191), ("asia-China-CentralChinaGansuGuizhouSichuanYunnan", 192), ("asia-China-TibetmostofXinjiangUyghur", 193), ("asia-China-SouthwestXinjiangUyghur", 194), ("asia-Cyprus", 195), ("asia-EastTimor", 196), ("asia-Georgia", 197), ("asia-HongKong", 198), ("asia-India", 199), ("asia-Indonesia-JavaAndSumatra", 200), ("asia-Indonesia-WestCentralBorneo", 201), ("asia-Indonesia-ESBorneoCelebesBaliNusaTengaWTimor", 202), ("asia-Indonesia-IrianJayaAndMoluccas", 203), ("asia-Iran", 204), ("asia-Iraq", 205), ("asia-Israel", 206), ("asia-Japan", 207), ("asia-Jordan", 208), ("asia-Kazakhstan-MostLocations", 209), ("asia-Kazakhstan-QyzylordaKyzylorda", 210), ("asia-Kazakhstan-Aqtobe", 211), ("asia-Kazakhstan-AtyrauMangghystau", 212), ("asia-Kazakhstan-WestKazakhstan", 213), ("asia-Korea-North", 214), ("asia-Korea-South", 215), ("asia-Kuwait", 216), ("asia-Kyrgyzstan", 217), ("asia-Laos", 218), ("asia-Lebanon", 219), ("asia-Macau", 220), ("asia-Malaysia-PeninsularMalaysia", 221), ("asia-Malaysia-SabahSarawak", 222), ("asia-Mongolia-MostLocations", 223), ("asia-Mongolia-BayanOlgiyGoviAltaiHovdUvsZavkhan", 224), ("asia-Mongolia-DornodSukhbaatar", 225), ("asia-Myanmar", 226), ("asia-Nepal", 227), ("asia-Oman", 228), ("asia-Pakistan", 229), ("asia-Palestine", 230), ("asia-Philippines", 231), ("asia-Qatar", 232), ("asia-Russia-Moscow-01Kaliningrad", 233), ("asia-Russia-Moscow00WestRussia", 234), ("asia-Russia-Moscow01CaspianSea", 235), ("asia-Russia-Moscow02Urals", 236), ("asia-Russia-Moscow03WestSiberia", 237), ("asia-Russia-Moscow03Novosibirsk", 238), ("asia-Russia-Moscow04YeniseiRiver", 239), ("asia-Russia-Moscow05LakeBaikal", 240), ("asia-Russia-Moscow06LenaRiver", 241), ("asia-Russia-Moscow07AmurRiver", 242), ("asia-Russia-Moscow07SakhalinIsland", 243), ("asia-Russia-Moscow08Magadan", 244), ("asia-Russia-Moscow09Kamchatka", 245), ("asia-Russia-Moscow10BeringSea", 246), ("asia-SaudiArabia", 247), ("asia-Singapore", 248), ("asia-SriLanka", 249), ("asia-Syria", 250), ("asia-Taiwan", 251), ("asia-Tajikistan", 252), ("asia-Thailand", 253), ("asia-Turkmenistan", 254)) + NamedValues(("asia-UnitedArabEmirates", 255), ("asia-Uzbekistan-WestUzbekistan", 256), ("asia-Uzbekistan-EastUzbekistan", 257), ("asia-Vietnam", 258), ("asia-Yemen", 259), ("atlanticOcean-Bermuda", 260), ("atlanticOcean-CapeVerde", 261), ("atlanticOcean-FaeroeIslands", 262), ("atlanticOcean-FalklandIslands", 263), ("atlanticOcean-Iceland", 264), ("atlanticOcean-Portugal-Mainland", 265), ("atlanticOcean-Portugal-MadeiraIslands", 266), ("atlanticOcean-Portugal-Azores", 267), ("atlanticOcean-SouthGeorgia-SouthSandwichIslands", 268), ("atlanticOcean-Spain-Mainland", 269), ("atlanticOcean-Spain-CeutaMelilla", 270), ("atlanticOcean-Spain-CanaryIslands", 271), ("atlanticOcean-StHelena", 272), ("atlanticOcean-Svalbard-JanMayen", 273), ("australia-LordHoweIsland", 274), ("australia-Tasmania", 275), ("australia-Victoria", 276), ("australia-NewSouthWales-MostLocations", 277), ("australia-NewSouthWales-Yancowinna", 278), ("australia-Queensland-MostLocations", 279), ("australia-Queensland-HolidayIslands", 280), ("australia-SouthAustralia", 281), ("australia-NorthernTerritory", 282), ("australia-WesternAustralia", 283), ("europe-Albania", 284), ("europe-Andorra", 285), ("europe-Austria", 286), ("europe-Belarus", 287), ("europe-Belgium", 288), ("europe-BosniaHerzegovina", 289), ("europe-Britain-UKGreatBritain", 290), ("europe-Britain-UKNorthernIreland", 291), ("europe-Bulgaria", 292), ("europe-Croatia", 293), ("europe-CzechRepublic", 294), ("europe-Denmark", 295), ("europe-Estonia", 296), ("europe-Finland", 297), ("europe-France", 298), ("europe-Germany", 299), ("europe-Gibraltar", 300), ("europe-Greece", 301), ("europe-Hungary", 302), ("europe-Ireland", 303), ("europe-Italy", 304), ("europe-Latvia", 305), ("europe-Liechtenstein", 306), ("europe-Lithuania", 307), ("europe-Luxembourg", 308), ("europe-Macedonia", 309), ("europe-Malta", 310), ("europe-Moldova", 311), ("europe-Monaco", 312), ("europe-Montenegro", 421), ("europe-Netherlands", 313), ("europe-Norway", 314), ("europe-Poland", 315), ("europe-Portugal-Mainland", 316), ("europe-Portugal-MadeiraIslands", 317), ("europe-Portugal-Azores", 318), ("europe-Romania", 319), ("europe-Russia-Moscow-01Kaliningrad", 320), ("europe-Russia-Moscow00WestRussia", 321), ("europe-Russia-Moscow01CaspianSea", 322), ("europe-Russia-Moscow02Urals", 323), ("europe-Russia-Moscow03WestSiberia", 324), ("europe-Russia-Moscow03Novosibirsk", 325), ("europe-Russia-Moscow04YeniseiRiver", 326), ("europe-Russia-Moscow05LakeBaikal", 327), ("europe-Russia-Moscow06LenaRiver", 328), ("europe-Russia-Moscow07AmurRiver", 329), ("europe-Russia-Moscow07SakhalinIsland", 330), ("europe-Russia-Moscow08Magadan", 331), ("europe-Russia-Moscow09Kamchatka", 332), ("europe-Russia-Moscow10BeringSea", 333), ("europe-SanMarino", 334), ("europe-Serbia", 348), ("europe-Slovakia", 335), ("europe-Slovenia", 336), ("europe-Spain-Mainland", 337), ("europe-Spain-CeutaAndMelilla", 338), ("europe-Spain-CanaryIslands", 339), ("europe-Sweden", 340), ("europe-Switzerland", 341), ("europe-Turkey", 342), ("europe-Ukraine-MostLocations", 343), ("europe-Ukraine-Ruthenia", 344), ("europe-Ukraine-Zaporozhye-ELugansk", 345), ("europe-Ukraine-CentralCrimea", 346), ("europe-VaticanCity", 347), ("indianOcean-BritishIndianOceanTerritory", 349), ("indianOcean-ChristmasIsland", 350), ("indianOcean-CocosOrKeelingIslands", 351), ("indianOcean-Comoros", 352), ("indianOcean-FrenchSouthernAndAntarcticLands", 353), ("indianOcean-Madagascar", 354), ("indianOcean-Maldives", 355), ("indianOcean-Mauritius", 356), ("indianOcean-Mayotte", 357), ("indianOcean-Reunion", 358), ("indianOcean-Seychelles", 359), ("pacificOcean-Chile-MostLocations", 360), ("pacificOcean-Chile-EasterIslandSalayGomez", 361), ("pacificOcean-CookIslands", 362), ("pacificOcean-Ecuador", 363), ("pacificOcean-Fiji", 364), ("pacificOcean-FrenchPolynesia-SocietyIslands", 365), ("pacificOcean-FrenchPolynesia-MarquesasIslands", 366), ("pacificOcean-FrenchPolynesia-GambierIslands", 367), ("pacificOcean-Guam", 368), ("pacificOcean-Kiribati-GilbertIslands", 369), ("pacificOcean-Kiribati-PhoenixIslands", 370), ("pacificOcean-Kiribati-LineIslands", 371), ("pacificOcean-MarshallIslands-MostLocations", 372), ("pacificOcean-MarshallIslands-Kwajalein", 373), ("pacificOcean-Micronesia-Yap", 374), ("pacificOcean-Micronesia-TrukOrChuuk", 375), ("pacificOcean-Micronesia-PonapeOrPohnpei", 376), ("pacificOcean-Micronesia-Kosrae", 377), ("pacificOcean-Nauru", 378), ("pacificOcean-NewCaledonia", 379), ("pacificOcean-NewZealand-MostLocations", 380), ("pacificOcean-NewZealand-ChathamIslands", 381), ("pacificOcean-Niue", 382), ("pacificOcean-NorfolkIsland", 383), ("pacificOcean-NorthernMarianaIslands", 384), ("pacificOcean-Palau", 385), ("pacificOcean-PapuaNewGuinea", 386), ("pacificOcean-Pitcairn", 387), ("pacificOcean-SamoaAmerican", 388), ("pacificOcean-SamoaWestern", 389), ("pacificOcean-SolomonIslands", 390), ("pacificOcean-Tokelau", 391), ("pacificOcean-Tonga", 392), ("pacificOcean-Tuvalu", 393), ("pacificOceanUSA-EastTime", 394), ("pacificOceanUSA-EastTime-MichiganMostLocations", 395), ("pacificOceanUSA-EastTime-KentuckyLouisvilleArea", 396), ("pacificOceanUSA-EastTime-KentuckyWayneCounty", 397), ("pacificOceanUSA-EastStdTime-IndianaMostLocations", 398), ("pacificOceanUSA-EastStdTime-IndianaCrawfordCounty", 399), ("pacificOceanUSA-EastStdTime-IndianaStarkeCounty", 400), ("pacificOceanUSA-EastStdTime-IndianaSwitzerlandCounty", 401), ("pacificOceanUSA-CentTime", 402), ("pacificOceanUSA-CentTime-MichiganWisconsinborder", 403), ("pacificOceanUSA-CentTime-NorthDakotaOliverCounty", 404), ("pacificOceanUSA-MountTime", 405), ("pacificOceanUSA-MountTime-SouthIdahoAndEastOregon", 406), ("pacificOceanUSA-MountTime-Navajo", 407), ("pacificOceanUSA-MountStdTime-Arizona", 408), ("pacificOceanUSA-PacificTime", 409), ("pacificOceanUSA-AlaskaTime", 410), ("pacificOceanUSA-AlaskaTime-AlaskaPanhandle", 411), ("pacificOceanUSA-AlaskaTime-AlaskaPanhandleNeck", 412), ("pacificOceanUSA-AlaskaTime-WestAlaska", 413), ("pacificOceanUSA-AleutianIslands", 414), ("pacificOceanUSA-Hawaii", 415), ("pacificOcean-USMinorOutlyingIslands-JohnstonAtoll", 416), ("pacificOcean-USMinorOutlyingIslands-MidwayIslands", 417), ("pacificOcean-USMinorOutlyingIslands-WakeIsland", 418), ("pacificOcean-Vanuatu", 419), ("pacificOcean-WallisAndFutuna", 420)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurDaylightSavings.setStatus('current')
if mibBuilder.loadTexts: agCurDaylightSavings.setDescription('The daylight savings location. Note: Locations are alphabetically ordered and the corresponding code is not reflected in CLI.')
agNewDaylightSavings = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 56), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254), SingleValueConstraint(255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 421, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 348, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420))).clone(namedValues=NamedValues(("none", 0), ("africa-Algeria", 1), ("africa-Angola", 2), ("africa-Benin", 3), ("africa-Botswana", 4), ("africa-Burkina-Faso", 5), ("africa-Burundi", 6), ("africa-Cameroon", 7), ("africa-Central-African-Rep", 8), ("africa-Chad", 9), ("africa-Congo-WestDemRepCongo", 10), ("africa-Congo-EastDemRepCongo", 11), ("africa-Congo-Rep", 12), ("africa-Cote-dIvoire", 13), ("africa-Djibouti", 14), ("africa-Egypt", 15), ("africa-Equatorial-Guinea", 16), ("africa-Eritrea", 17), ("africa-Ethiopia", 18), ("africa-Gabon", 19), ("africa-Gambia", 20), ("africa-Ghana", 21), ("africa-Guinea", 22), ("africa-Guinea-Bissau", 23), ("africa-Kenya", 24), ("africa-Lesotho", 25), ("africa-Liberia", 26), ("africa-Libya", 27), ("africa-Malawi", 28), ("africa-Mali-SouthWestMali", 29), ("africa-Mali-NorthEastMali", 30), ("africa-Mauritania", 31), ("africa-Morocco", 32), ("africa-Mozambique", 33), ("africa-Namibia", 34), ("africa-Niger", 35), ("africa-Nigeria", 36), ("africa-Rwanda", 37), ("africa-SaoTome-And-Principe", 38), ("africa-Senegal", 39), ("africa-SierraLeone", 40), ("africa-Somalia", 41), ("africa-SouthAfrica", 42), ("africa-Spain-Mainland", 43), ("africa-Spain-CeutaMelilla", 44), ("africa-Spain-CanaryIslands", 45), ("africa-Sudan", 46), ("africa-Swaziland", 47), ("africa-Tanzania", 48), ("africa-Togo", 49), ("africa-Tunisia", 50), ("africa-Uganda", 51), ("africa-Western-Sahara", 52), ("africa-Zambia", 53), ("africa-Zimbabwe", 54), ("americas-Anguilla", 55), ("americas-Antigua-Barbuda", 56), ("americas-Argentina-EArgentina", 57), ("americas-Argentina-MostLocations", 58), ("americas-Argentina-Jujuy", 59), ("americas-Argentina-Catamarca", 60), ("americas-Argentina-Mendoza", 61), ("americas-Aruba", 62), ("americas-Bahamas", 63), ("americas-Barbados", 64), ("americas-Belize", 65), ("americas-Bolivia", 66), ("americas-Brazil-AtlanticIslands", 67), ("americas-Brazil-AmapaEPara", 68), ("americas-Brazil-NEBrazil", 69), ("americas-Brazil-Pernambuco", 70), ("americas-Brazil-Tocantins", 71), ("americas-Brazil-AlagoasSergipe", 72), ("americas-Brazil-SSEBrazil", 73), ("americas-Brazil-MatoGrossoDoSul", 74), ("americas-Brazil-WParaRondonia", 75), ("americas-Brazil-Roraima", 76), ("americas-Brazil-EAmazonas", 77), ("americas-Brazil-WAmazonas", 78), ("americas-Brazil-Acre", 79), ("americas-Canada-NewfoundlandIsland", 80), ("americas-Canada-AtlanTime-NovaScotia", 81), ("americas-Canada-AtlanTime-ELabrador", 82), ("americas-Canada-EastTime-OntarioMostlocation", 83), ("americas-Canada-EastTime-ThunderBay", 84), ("americas-Canada-EastStdTime-PangnirtungNunavut", 85), ("americas-Canada-EastStdTime-EastNunavut", 86), ("americas-Canada-EastStdTime-CenNunavut", 87), ("americas-Canada-CenTime-ManitobaWestOntario", 88), ("americas-Canada-CenTime-RainyRiver", 89), ("americas-Canada-CenTime-WestNunavut", 90), ("americas-Canada-CenStdTime-SaskatchewanMostlocation", 91), ("americas-Canada-CenStdTime-SaskatchewanMidwest", 92), ("americas-Canada-MountTime-AlbertaEastBritishColumbia", 93), ("americas-Canada-MountTime-CentralNorthwestTerritories", 94), ("americas-Canada-MountTime-WestNorthwestTerritories", 95), ("americas-Canada-MountStdTime-DawsonCrkStJohnBritColumbia", 96), ("americas-Canada-PacificTime-WestBritishColumbia", 97), ("americas-Canada-PacificTime-SouthYukon", 98), ("americas-Canada-PacificTime-NorthYukon", 99), ("americas-CaymanIslands", 100), ("americas-Chile-MostLocation", 101), ("americas-Chile-EasterIsland", 102), ("americas-Colombia", 103), ("americas-CostaRica", 104), ("americas-Cuba", 105), ("americas-Dominica", 106), ("americas-DominicanRepublic", 107), ("americas-Ecuador", 108), ("americas-ElSalvado", 109), ("americas-FrenchGuiana", 110), ("americas-Greenland-MostLocation", 111), ("americas-Greenland-EastCoastNorthScoresbysund", 112), ("americas-Greenland-ScoresbysundIttoqqortoormiit", 113), ("americas-Greenland-ThulePituffik", 114), ("americas-Grenada", 115), ("americas-Guadeloupe", 116), ("americas-Guatemala", 117), ("americas-Guyana", 118), ("americas-Haiti", 119), ("americas-Honduras", 120), ("americas-Jamaica", 121), ("americas-Martinique", 122), ("americas-Mexico-CentTime-Mostlocations", 123), ("americas-Mexico-CentTime-QuintanaRoo", 124), ("americas-Mexico-CentTime-CampecheYucatan", 125), ("americas-Mexico-CentTime-CoahuilaDurNuevoLeonTam", 126), ("americas-Mexico-MountTime-SBajaNayaritSinaloa", 127), ("americas-Mexico-MountTime-Chihuahua", 128), ("americas-Mexico-MountStdTime-Sonora", 129), ("americas-Mexico-PacificTime", 130), ("americas-Montserrat", 131), ("americas-NetherlandsAntilles", 132), ("americas-Nicaragua", 133), ("americas-Panama", 134), ("americas-Paraguay", 135), ("americas-Peru", 136), ("americas-PuertoRico", 137), ("americas-StKittsAndNevis", 138), ("americas-StLucia", 139), ("americas-StPierreAndMiquelon", 140), ("americas-StVincent", 141), ("americas-Suriname", 142), ("americas-TrinidadAndTobago", 143), ("americas-TurksAndCaicosIs", 144), ("americas-USA-EastTime", 145), ("americas-USA-EastTime-MichiganMostLocation", 146), ("americas-USA-EastTime-KentuckyLouisvilleArea", 147), ("americas-USA-EastTime-KentuckyWayneCounty", 148), ("americas-USA-EastStdTime-IndianaMostLocations", 149), ("americas-USA-EastStdTime-IndianaCrawfordCounty", 150), ("americas-USA-EastStdTime-IndianaStarkeCounty", 151), ("americas-USA-EastStdTime-IndianaSwitzerlandCounty", 152), ("americas-USA-CentTime", 153), ("americas-USA-CentTime-MichiganWisconsinborder", 154), ("americas-USA-CentTime-NorthDakotaOliverCounty", 155), ("americas-USA-MountTime", 156), ("americas-USA-MountTime-SouthIdahoAndEastOregon", 157), ("americas-USA-MountTime-Navajo", 158), ("americas-USA-MountStdTime-Arizona", 159), ("americas-USA-PacificTime", 160), ("americas-USA-AlaskaTime", 161), ("americas-USA-AlaskaTime-AlaskaPanhandle", 162), ("americas-USA-AlaskaTime-AlaskaPanhandleNeck", 163), ("americas-USA-AlaskaTime-WestAlaska", 164), ("americas-USA-AleutianIslands", 165), ("americas-USA-Hawaii", 166), ("americas-Uruguay", 167), ("americas-Venezuela", 168), ("americas-VirginIslands-UK", 169), ("americas-VirginIslands-US", 170), ("antarctica-McMurdoStationRossIsland", 171), ("antarctica-Amundsen-ScottStationSouthPole", 172), ("antarctica-PalmerStationAnversIsland", 173), ("antarctica-MawsonStationHolmeBay", 174), ("antarctica-DavisStationVestfoldHills", 175), ("antarctica-CaseyStationBaileyPeninsula", 176), ("antarctica-VostokStationSMagneticPole", 177), ("antarctica-Dumont-dUrvilleBaseTerreAdelie", 178), ("antarctica-SyowaStationEOngulI", 179), ("arcticOcean-Svalbard", 180), ("arcticOcean-JanMayen", 181), ("asia-Afghanistan", 182), ("asia-Armenia", 183), ("asia-Azerbaijan", 184), ("asia-Bahrain", 185), ("asia-Bangladesh", 186), ("asia-Bhutan", 187), ("asia-Brunei", 188), ("asia-Cambodia", 189), ("asia-China-EastChinaBeijingGuangdongShanghai", 190), ("asia-China-Heilongjiang", 191), ("asia-China-CentralChinaGansuGuizhouSichuanYunnan", 192), ("asia-China-TibetmostofXinjiangUyghur", 193), ("asia-China-SouthwestXinjiangUyghur", 194), ("asia-Cyprus", 195), ("asia-EastTimor", 196), ("asia-Georgia", 197), ("asia-HongKong", 198), ("asia-India", 199), ("asia-Indonesia-JavaAndSumatra", 200), ("asia-Indonesia-WestCentralBorneo", 201), ("asia-Indonesia-ESBorneoCelebesBaliNusaTengaWTimor", 202), ("asia-Indonesia-IrianJayaAndMoluccas", 203), ("asia-Iran", 204), ("asia-Iraq", 205), ("asia-Israel", 206), ("asia-Japan", 207), ("asia-Jordan", 208), ("asia-Kazakhstan-MostLocations", 209), ("asia-Kazakhstan-QyzylordaKyzylorda", 210), ("asia-Kazakhstan-Aqtobe", 211), ("asia-Kazakhstan-AtyrauMangghystau", 212), ("asia-Kazakhstan-WestKazakhstan", 213), ("asia-Korea-North", 214), ("asia-Korea-South", 215), ("asia-Kuwait", 216), ("asia-Kyrgyzstan", 217), ("asia-Laos", 218), ("asia-Lebanon", 219), ("asia-Macau", 220), ("asia-Malaysia-PeninsularMalaysia", 221), ("asia-Malaysia-SabahSarawak", 222), ("asia-Mongolia-MostLocations", 223), ("asia-Mongolia-BayanOlgiyGoviAltaiHovdUvsZavkhan", 224), ("asia-Mongolia-DornodSukhbaatar", 225), ("asia-Myanmar", 226), ("asia-Nepal", 227), ("asia-Oman", 228), ("asia-Pakistan", 229), ("asia-Palestine", 230), ("asia-Philippines", 231), ("asia-Qatar", 232), ("asia-Russia-Moscow-01Kaliningrad", 233), ("asia-Russia-Moscow00WestRussia", 234), ("asia-Russia-Moscow01CaspianSea", 235), ("asia-Russia-Moscow02Urals", 236), ("asia-Russia-Moscow03WestSiberia", 237), ("asia-Russia-Moscow03Novosibirsk", 238), ("asia-Russia-Moscow04YeniseiRiver", 239), ("asia-Russia-Moscow05LakeBaikal", 240), ("asia-Russia-Moscow06LenaRiver", 241), ("asia-Russia-Moscow07AmurRiver", 242), ("asia-Russia-Moscow07SakhalinIsland", 243), ("asia-Russia-Moscow08Magadan", 244), ("asia-Russia-Moscow09Kamchatka", 245), ("asia-Russia-Moscow10BeringSea", 246), ("asia-SaudiArabia", 247), ("asia-Singapore", 248), ("asia-SriLanka", 249), ("asia-Syria", 250), ("asia-Taiwan", 251), ("asia-Tajikistan", 252), ("asia-Thailand", 253), ("asia-Turkmenistan", 254)) + NamedValues(("asia-UnitedArabEmirates", 255), ("asia-Uzbekistan-WestUzbekistan", 256), ("asia-Uzbekistan-EastUzbekistan", 257), ("asia-Vietnam", 258), ("asia-Yemen", 259), ("atlanticOcean-Bermuda", 260), ("atlanticOcean-CapeVerde", 261), ("atlanticOcean-FaeroeIslands", 262), ("atlanticOcean-FalklandIslands", 263), ("atlanticOcean-Iceland", 264), ("atlanticOcean-Portugal-Mainland", 265), ("atlanticOcean-Portugal-MadeiraIslands", 266), ("atlanticOcean-Portugal-Azores", 267), ("atlanticOcean-SouthGeorgia-SouthSandwichIslands", 268), ("atlanticOcean-Spain-Mainland", 269), ("atlanticOcean-Spain-CeutaMelilla", 270), ("atlanticOcean-Spain-CanaryIslands", 271), ("atlanticOcean-StHelena", 272), ("atlanticOcean-Svalbard-JanMayen", 273), ("australia-LordHoweIsland", 274), ("australia-Tasmania", 275), ("australia-Victoria", 276), ("australia-NewSouthWales-MostLocations", 277), ("australia-NewSouthWales-Yancowinna", 278), ("australia-Queensland-MostLocations", 279), ("australia-Queensland-HolidayIslands", 280), ("australia-SouthAustralia", 281), ("australia-NorthernTerritory", 282), ("australia-WesternAustralia", 283), ("europe-Albania", 284), ("europe-Andorra", 285), ("europe-Austria", 286), ("europe-Belarus", 287), ("europe-Belgium", 288), ("europe-BosniaHerzegovina", 289), ("europe-Britain-UKGreatBritain", 290), ("europe-Britain-UKNorthernIreland", 291), ("europe-Bulgaria", 292), ("europe-Croatia", 293), ("europe-CzechRepublic", 294), ("europe-Denmark", 295), ("europe-Estonia", 296), ("europe-Finland", 297), ("europe-France", 298), ("europe-Germany", 299), ("europe-Gibraltar", 300), ("europe-Greece", 301), ("europe-Hungary", 302), ("europe-Ireland", 303), ("europe-Italy", 304), ("europe-Latvia", 305), ("europe-Liechtenstein", 306), ("europe-Lithuania", 307), ("europe-Luxembourg", 308), ("europe-Macedonia", 309), ("europe-Malta", 310), ("europe-Moldova", 311), ("europe-Monaco", 312), ("europe-Montenegro", 421), ("europe-Netherlands", 313), ("europe-Norway", 314), ("europe-Poland", 315), ("europe-Portugal-Mainland", 316), ("europe-Portugal-MadeiraIslands", 317), ("europe-Portugal-Azores", 318), ("europe-Romania", 319), ("europe-Russia-Moscow-01Kaliningrad", 320), ("europe-Russia-Moscow00WestRussia", 321), ("europe-Russia-Moscow01CaspianSea", 322), ("europe-Russia-Moscow02Urals", 323), ("europe-Russia-Moscow03WestSiberia", 324), ("europe-Russia-Moscow03Novosibirsk", 325), ("europe-Russia-Moscow04YeniseiRiver", 326), ("europe-Russia-Moscow05LakeBaikal", 327), ("europe-Russia-Moscow06LenaRiver", 328), ("europe-Russia-Moscow07AmurRiver", 329), ("europe-Russia-Moscow07SakhalinIsland", 330), ("europe-Russia-Moscow08Magadan", 331), ("europe-Russia-Moscow09Kamchatka", 332), ("europe-Russia-Moscow10BeringSea", 333), ("europe-SanMarino", 334), ("europe-Serbia", 348), ("europe-Slovakia", 335), ("europe-Slovenia", 336), ("europe-Spain-Mainland", 337), ("europe-Spain-CeutaAndMelilla", 338), ("europe-Spain-CanaryIslands", 339), ("europe-Sweden", 340), ("europe-Switzerland", 341), ("europe-Turkey", 342), ("europe-Ukraine-MostLocations", 343), ("europe-Ukraine-Ruthenia", 344), ("europe-Ukraine-Zaporozhye-ELugansk", 345), ("europe-Ukraine-CentralCrimea", 346), ("europe-VaticanCity", 347), ("indianOcean-BritishIndianOceanTerritory", 349), ("indianOcean-ChristmasIsland", 350), ("indianOcean-CocosOrKeelingIslands", 351), ("indianOcean-Comoros", 352), ("indianOcean-FrenchSouthernAndAntarcticLands", 353), ("indianOcean-Madagascar", 354), ("indianOcean-Maldives", 355), ("indianOcean-Mauritius", 356), ("indianOcean-Mayotte", 357), ("indianOcean-Reunion", 358), ("indianOcean-Seychelles", 359), ("pacificOcean-Chile-MostLocations", 360), ("pacificOcean-Chile-EasterIslandSalayGomez", 361), ("pacificOcean-CookIslands", 362), ("pacificOcean-Ecuador", 363), ("pacificOcean-Fiji", 364), ("pacificOcean-FrenchPolynesia-SocietyIslands", 365), ("pacificOcean-FrenchPolynesia-MarquesasIslands", 366), ("pacificOcean-FrenchPolynesia-GambierIslands", 367), ("pacificOcean-Guam", 368), ("pacificOcean-Kiribati-GilbertIslands", 369), ("pacificOcean-Kiribati-PhoenixIslands", 370), ("pacificOcean-Kiribati-LineIslands", 371), ("pacificOcean-MarshallIslands-MostLocations", 372), ("pacificOcean-MarshallIslands-Kwajalein", 373), ("pacificOcean-Micronesia-Yap", 374), ("pacificOcean-Micronesia-TrukOrChuuk", 375), ("pacificOcean-Micronesia-PonapeOrPohnpei", 376), ("pacificOcean-Micronesia-Kosrae", 377), ("pacificOcean-Nauru", 378), ("pacificOcean-NewCaledonia", 379), ("pacificOcean-NewZealand-MostLocations", 380), ("pacificOcean-NewZealand-ChathamIslands", 381), ("pacificOcean-Niue", 382), ("pacificOcean-NorfolkIsland", 383), ("pacificOcean-NorthernMarianaIslands", 384), ("pacificOcean-Palau", 385), ("pacificOcean-PapuaNewGuinea", 386), ("pacificOcean-Pitcairn", 387), ("pacificOcean-SamoaAmerican", 388), ("pacificOcean-SamoaWestern", 389), ("pacificOcean-SolomonIslands", 390), ("pacificOcean-Tokelau", 391), ("pacificOcean-Tonga", 392), ("pacificOcean-Tuvalu", 393), ("pacificOceanUSA-EastTime", 394), ("pacificOceanUSA-EastTime-MichiganMostLocations", 395), ("pacificOceanUSA-EastTime-KentuckyLouisvilleArea", 396), ("pacificOceanUSA-EastTime-KentuckyWayneCounty", 397), ("pacificOceanUSA-EastStdTime-IndianaMostLocations", 398), ("pacificOceanUSA-EastStdTime-IndianaCrawfordCounty", 399), ("pacificOceanUSA-EastStdTime-IndianaStarkeCounty", 400), ("pacificOceanUSA-EastStdTime-IndianaSwitzerlandCounty", 401), ("pacificOceanUSA-CentTime", 402), ("pacificOceanUSA-CentTime-MichiganWisconsinborder", 403), ("pacificOceanUSA-CentTime-NorthDakotaOliverCounty", 404), ("pacificOceanUSA-MountTime", 405), ("pacificOceanUSA-MountTime-SouthIdahoAndEastOregon", 406), ("pacificOceanUSA-MountTime-Navajo", 407), ("pacificOceanUSA-MountStdTime-Arizona", 408), ("pacificOceanUSA-PacificTime", 409), ("pacificOceanUSA-AlaskaTime", 410), ("pacificOceanUSA-AlaskaTime-AlaskaPanhandle", 411), ("pacificOceanUSA-AlaskaTime-AlaskaPanhandleNeck", 412), ("pacificOceanUSA-AlaskaTime-WestAlaska", 413), ("pacificOceanUSA-AleutianIslands", 414), ("pacificOceanUSA-Hawaii", 415), ("pacificOcean-USMinorOutlyingIslands-JohnstonAtoll", 416), ("pacificOcean-USMinorOutlyingIslands-MidwayIslands", 417), ("pacificOcean-USMinorOutlyingIslands-WakeIsland", 418), ("pacificOcean-Vanuatu", 419), ("pacificOceanWallisAndFutuna", 420)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewDaylightSavings.setStatus('current')
if mibBuilder.loadTexts: agNewDaylightSavings.setDescription('The daylight savings location.')
agCurCfgIdleCLITimeout = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 57), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgIdleCLITimeout.setStatus('current')
if mibBuilder.loadTexts: agCurCfgIdleCLITimeout.setDescription('Set idle CLI sessions timeout.')
agNewCfgIdleCLITimeout = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 58), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgIdleCLITimeout.setStatus('current')
if mibBuilder.loadTexts: agNewCfgIdleCLITimeout.setDescription('Set idle CLI sessions timeout.')
agCurCfgHttpsServerAccess = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 62), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 0))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 0)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgHttpsServerAccess.setStatus('current')
if mibBuilder.loadTexts: agCurCfgHttpsServerAccess.setDescription('Current HTTPS server access state.')
agNewCfgHttpsServerAccess = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 63), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 0))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgHttpsServerAccess.setStatus('current')
if mibBuilder.loadTexts: agNewCfgHttpsServerAccess.setDescription('Enable/disable HTTPS server access.')
agCurBootNxtCliMode = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 64), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ibmnos-cli", 1), ("iscli", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurBootNxtCliMode.setStatus('current')
if mibBuilder.loadTexts: agCurBootNxtCliMode.setDescription('Current boot mode.')
agNewBootNxtCliMode = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 65), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ibmnos-cli", 1), ("iscli", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewBootNxtCliMode.setStatus('current')
if mibBuilder.loadTexts: agNewBootNxtCliMode.setDescription('Next cli boot mode.')
agCurBootNxtCliModePrompt = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 76), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurBootNxtCliModePrompt.setStatus('current')
if mibBuilder.loadTexts: agCurBootNxtCliModePrompt.setDescription('Current status of selectable CLI mode prompt.')
agNewBootNxtCliModePrompt = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 77), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewBootNxtCliModePrompt.setStatus('current')
if mibBuilder.loadTexts: agNewBootNxtCliModePrompt.setDescription('Next status of selectable CLI mode prompt.')
agCurHttpAcces = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 66), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurHttpAcces.setStatus('current')
if mibBuilder.loadTexts: agCurHttpAcces.setDescription('Current HTTP server access state.')
agNewHttpAcces = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 67), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewHttpAcces.setStatus('current')
if mibBuilder.loadTexts: agNewHttpAcces.setDescription('New HTTP server access state.')
agCurCfgReminders = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 70), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgReminders.setStatus('current')
if mibBuilder.loadTexts: agCurCfgReminders.setDescription('Current status of reminders feature.')
agNewCfgReminders = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 71), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgReminders.setStatus('current')
if mibBuilder.loadTexts: agNewCfgReminders.setDescription('Enable or disable reminders feature.')
agCurCfgHprompt = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 72), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgHprompt.setStatus('current')
if mibBuilder.loadTexts: agCurCfgHprompt.setDescription('Current status of hprompt.')
agNewCfgHprompt = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 73), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgHprompt.setStatus('current')
if mibBuilder.loadTexts: agNewCfgHprompt.setDescription('New status of hprompt.')
agCurCfgUserBBI = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 74), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgUserBBI.setStatus('current')
if mibBuilder.loadTexts: agCurCfgUserBBI.setDescription('Current status of user configuration from BBI.')
agNewCfgUserBBI = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 75), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgUserBBI.setStatus('current')
if mibBuilder.loadTexts: agNewCfgUserBBI.setDescription('New status of user configuration from BBI.')
agCurCfgSysCustomDstState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 98), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgSysCustomDstState.setStatus('current')
if mibBuilder.loadTexts: agCurCfgSysCustomDstState.setDescription('The current status of Custom DST')
agNewCfgSysCustomDstState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 99), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgSysCustomDstState.setStatus('current')
if mibBuilder.loadTexts: agNewCfgSysCustomDstState.setDescription('Enable/disable Custom DST')
agCurCfgSysCustomDstStart = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 100), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgSysCustomDstStart.setStatus('current')
if mibBuilder.loadTexts: agCurCfgSysCustomDstStart.setDescription(' The current Custom DST start rule')
agNewCfgSysCustomDstStart = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 101), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgSysCustomDstStart.setStatus('current')
if mibBuilder.loadTexts: agNewCfgSysCustomDstStart.setDescription('Set Custom DST start rule')
agCurCfgSysCustomDstEnd = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 102), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgSysCustomDstEnd.setStatus('current')
if mibBuilder.loadTexts: agCurCfgSysCustomDstEnd.setDescription('The current Custom DST end rule')
agNewCfgSysCustomDstEnd = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 103), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgSysCustomDstEnd.setStatus('current')
if mibBuilder.loadTexts: agNewCfgSysCustomDstEnd.setDescription('Set Custom DST end rule')
agHavePanicDump = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 104), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("havePanic", 1), ("noHavePanic", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agHavePanicDump.setStatus('current')
if mibBuilder.loadTexts: agHavePanicDump.setDescription('The presence of a panic dump in the flash memory.')
agCurCfgResetControl = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 111), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgResetControl.setStatus('current')
if mibBuilder.loadTexts: agCurCfgResetControl.setDescription('Current reset control state.')
agNewCfgResetControl = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 112), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgResetControl.setStatus('current')
if mibBuilder.loadTexts: agNewCfgResetControl.setDescription('Enable/disable reset control after panic.')
agCurCfgSysDlight = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 113), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgSysDlight.setStatus('current')
if mibBuilder.loadTexts: agCurCfgSysDlight.setDescription('Current daylight savings time status.')
agNewCfgSysDlight = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 114), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgSysDlight.setStatus('current')
if mibBuilder.loadTexts: agNewCfgSysDlight.setDescription('Enable/disable daylight savings time.')
agCurCfgErrDisableRecovery = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 115), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgErrDisableRecovery.setStatus('current')
if mibBuilder.loadTexts: agCurCfgErrDisableRecovery.setDescription("This object indicates whether the system will automatically re-enable an error-disabled port after the time interval indicated by agCurCfgErrDisableTimeout has elapsed. A port is in error-disabled state when it has been operationally disabled due to abnormal conditions detected on the port. An error-disabled port will only be automatically re-enabled by the system if and only if this object and the port's agPortCurCfgErrDisableRecovery object both have a value of 'enable(1)'.")
agNewCfgErrDisableRecovery = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 116), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgErrDisableRecovery.setStatus('current')
if mibBuilder.loadTexts: agNewCfgErrDisableRecovery.setDescription('This object specifies whether the system should automatically re-enable an error-disabled port. Use this object to change the global setting of the error-disable recovery action.')
agCurCfgErrDisableTimeout = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 117), Integer32().subtype(subtypeSpec=ValueRangeConstraint(30, 86400)).clone(300)).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgErrDisableTimeout.setStatus('current')
if mibBuilder.loadTexts: agCurCfgErrDisableTimeout.setDescription('This object indicates the time, in seconds, that the system will wait before it automatically re-enables any port that is in error-disabled state.')
agNewCfgErrDisableTimeout = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 118), Integer32().subtype(subtypeSpec=ValueRangeConstraint(30, 86400)).clone(300)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgErrDisableTimeout.setStatus('current')
if mibBuilder.loadTexts: agNewCfgErrDisableTimeout.setDescription('This object specifies the time, in seconds, that the system should wait before it automatically re-enables a port that is in error-disabled state. Use this object to change the global error-disable timeout value.')
agCurCfgTelnetAccess = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 119), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 0))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 0)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgTelnetAccess.setStatus('current')
if mibBuilder.loadTexts: agCurCfgTelnetAccess.setDescription('Current telnet access state.')
agNewCfgTelnetAccess = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 120), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 0))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgTelnetAccess.setStatus('current')
if mibBuilder.loadTexts: agNewCfgTelnetAccess.setDescription('Enable/disable telnet access.')
agCurCfgDcbx = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 121), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 0))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 0)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgDcbx.setStatus('current')
if mibBuilder.loadTexts: agCurCfgDcbx.setDescription('Current DCBX state.')
agNewCfgDcbx = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 122), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 0))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgDcbx.setStatus('current')
if mibBuilder.loadTexts: agNewCfgDcbx.setDescription('Enable/disable DCBX feature.')
agCurCfgDhcpMgta = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 123), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgDhcpMgta.setStatus('current')
if mibBuilder.loadTexts: agCurCfgDhcpMgta.setDescription('Enable or disable the use of DHCP mgta, as configured in the current configuration block.')
agNewCfgDhcpMgta = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 124), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgDhcpMgta.setStatus('current')
if mibBuilder.loadTexts: agNewCfgDhcpMgta.setDescription('Enable or disable the use of DHCP mgta, in the new configuration block.')
agCurCfgDhcpMgtb = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 125), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgDhcpMgtb.setStatus('current')
if mibBuilder.loadTexts: agCurCfgDhcpMgtb.setDescription('Enable or disable the use of DHCP mgtb, as configured in the current configuration block.')
agNewCfgDhcpMgtb = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 126), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgDhcpMgtb.setStatus('current')
if mibBuilder.loadTexts: agNewCfgDhcpMgtb.setDescription('Enable or disable the use of DHCP mgtb, in the new configuration block.')
serverPortsCurCfgPorts = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 127), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: serverPortsCurCfgPorts.setStatus('current')
if mibBuilder.loadTexts: serverPortsCurCfgPorts.setDescription('The current configured server port list. The ports are presented in bitmap format. in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ port 8 || || || ||___ port 7 || |____ port 6 || . . . ||_________ port 1 |__________ reserved where x : 1 - The represented port belongs to the server ports list 0 - The represented port does not belong to the server ports list')
serverPortsNewCfgPorts = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 128), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: serverPortsNewCfgPorts.setStatus('current')
if mibBuilder.loadTexts: serverPortsNewCfgPorts.setDescription('New configuration server port list. The ports are presented in bitmap format. in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ port 8 || || || ||___ port 7 || |____ port 6 || . . . ||_________ port 1 |__________ reserved where x : 1 - The represented port belongs to the server ports list 0 - The represented port does not belong to the server ports list')
serverPortsNewCfgAddPort = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 129), PortNumber()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: serverPortsNewCfgAddPort.setStatus('current')
if mibBuilder.loadTexts: serverPortsNewCfgAddPort.setDescription("The port to be added to the server ports list. A '0' value is returned when read.")
serverPortsNewCfgRemovePort = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 130), PortNumber()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: serverPortsNewCfgRemovePort.setStatus('current')
if mibBuilder.loadTexts: serverPortsNewCfgRemovePort.setDescription("The port to be removed from the server ports list. A '0' value is returned when read.")
agCurBootProfile = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 131), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 6))).clone(namedValues=NamedValues(("default", 0), ("routing", 1), ("aggregate", 2), ("hft", 3), ("ipv6", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurBootProfile.setStatus('current')
if mibBuilder.loadTexts: agCurBootProfile.setDescription('Profile that will be used by the switch after reset')
agNewBootProfile = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 132), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 6))).clone(namedValues=NamedValues(("default", 0), ("routing", 1), ("aggregate", 2), ("hft", 3), ("ipv6", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewBootProfile.setStatus('current')
if mibBuilder.loadTexts: agNewBootProfile.setDescription('Configure the profile that will be used by the switch after reset')
agNetboot = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 133), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNetboot.setStatus('current')
if mibBuilder.loadTexts: agNetboot.setDescription('Ena/dis loading of config over n/w during bootup')
agNetbootTftpAddr = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 134), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNetbootTftpAddr.setStatus('current')
if mibBuilder.loadTexts: agNetbootTftpAddr.setDescription('Tftp server address from where config file needs to be downloaded')
agNetbootCfgFile = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 135), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNetbootCfgFile.setStatus('current')
if mibBuilder.loadTexts: agNetbootCfgFile.setDescription('Config file location on tftp server')
agCurRFC4741NetconfAccess = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 142), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurRFC4741NetconfAccess.setStatus('current')
if mibBuilder.loadTexts: agCurRFC4741NetconfAccess.setDescription('Current NETCONF server access state.')
agNewRFC4741NetconfAccess = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 143), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewRFC4741NetconfAccess.setStatus('current')
if mibBuilder.loadTexts: agNewRFC4741NetconfAccess.setDescription('Enable/disable NETCONF server access state.')
agCurRFC4741NetconfSessionTimeout = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 144), Integer32().subtype(subtypeSpec=ValueRangeConstraint(60, 3600))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurRFC4741NetconfSessionTimeout.setStatus('current')
if mibBuilder.loadTexts: agCurRFC4741NetconfSessionTimeout.setDescription('Once NETCONF session setup, NETCONF server will allocate resource for this session. agCurRFC4741NetconfSessionTimeout indicates the number of seconds before the resources are freed if there is no operation on this session')
agNewRFC4741NetconfSessionTimeout = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 145), Integer32().subtype(subtypeSpec=ValueRangeConstraint(60, 3600))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewRFC4741NetconfSessionTimeout.setStatus('current')
if mibBuilder.loadTexts: agNewRFC4741NetconfSessionTimeout.setDescription('Once NETCONF session setup, NETCONF server will allocate resource for this session. agNewRFC4741NetconfSessionTimeout specifies the number of seconds before the resources are freed if there is no operation on this session')
agCurRFC4741NetconfSshAccess = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 146), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurRFC4741NetconfSshAccess.setStatus('current')
if mibBuilder.loadTexts: agCurRFC4741NetconfSshAccess.setDescription('Current NETCONF server over SSH access state.')
agNewRFC4741NetconfSshAccess = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 147), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewRFC4741NetconfSshAccess.setStatus('current')
if mibBuilder.loadTexts: agNewRFC4741NetconfSshAccess.setDescription('Enable/disable NETCONF server over SSH access state.')
agCurRFC4741NetconfSshPort = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 148), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurRFC4741NetconfSshPort.setStatus('current')
if mibBuilder.loadTexts: agCurRFC4741NetconfSshPort.setDescription('The TCP port number that the NETCONF server over SSH is listening to in the current configuration block.')
agNewRFC4741NetconfSshPort = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 149), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewRFC4741NetconfSshPort.setStatus('current')
if mibBuilder.loadTexts: agNewRFC4741NetconfSshPort.setDescription('The TCP port number that the NETCONF server over SSH is listening to in the new configuration block.')
agCurCfgCpuRateLimitArp = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 150), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgCpuRateLimitArp.setStatus('current')
if mibBuilder.loadTexts: agCurCfgCpuRateLimitArp.setDescription('Current CPU rate limit for ARP requests and responses.')
agNewCfgCpuRateLimitArp = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 151), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgCpuRateLimitArp.setStatus('current')
if mibBuilder.loadTexts: agNewCfgCpuRateLimitArp.setDescription('New CPU rate limit for ARP requests and responses.')
agCurCfgCpuRateLimitBpdu = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 152), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgCpuRateLimitBpdu.setStatus('current')
if mibBuilder.loadTexts: agCurCfgCpuRateLimitBpdu.setDescription('Current CPU rate limit for BPDUs (STP, LACP).')
agNewCfgCpuRateLimitBpdu = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 153), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgCpuRateLimitBpdu.setStatus('current')
if mibBuilder.loadTexts: agNewCfgCpuRateLimitBpdu.setDescription('New CPU rate limit for BPDUs (STP, LACP).')
agCurCfgCpuRateLimitCntl = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 154), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgCpuRateLimitCntl.setStatus('current')
if mibBuilder.loadTexts: agCurCfgCpuRateLimitCntl.setDescription('Current CPU rate limit for control packets (IGMP, DHCP).')
agNewCfgCpuRateLimitCntl = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 155), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgCpuRateLimitCntl.setStatus('current')
if mibBuilder.loadTexts: agNewCfgCpuRateLimitCntl.setDescription('New CPU rate limit for control packets (IGMP, DHCP).')
agCurCfgCpuRateLimitOther = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 156), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgCpuRateLimitOther.setStatus('current')
if mibBuilder.loadTexts: agCurCfgCpuRateLimitOther.setDescription('Current CPU rate limit for other packets (Data, ICMP).')
agNewCfgCpuRateLimitOther = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 157), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgCpuRateLimitOther.setStatus('current')
if mibBuilder.loadTexts: agNewCfgCpuRateLimitOther.setDescription('New CPU rate limit for other packets (Data, ICMP).')
agCurCfgLFDStatus = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 158), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgLFDStatus.setStatus('current')
if mibBuilder.loadTexts: agCurCfgLFDStatus.setDescription("This object indicates whether the system will put any port in an error-disabled state due to excessive link flaps. A port will be put in an error-disabled state due to excessive link flaps if this object and the port's agPortCurCfgLFDStatus object both have a value of 'enable'. A port has an excessive number of link flaps if the number of link flaps detected during a time period in seconds indicated by agCurCfgLFDTime exceeds the maximum number of allowed flaps indicated by agCurCfgLFDFlaps.")
agNewCfgLFDStatus = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 159), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgLFDStatus.setStatus('current')
if mibBuilder.loadTexts: agNewCfgLFDStatus.setDescription('This object indicates whether the system should put any port in an error-disabled state due to excessive link flaps. Use this object to change the global setting of the Link Flap Dampening error-disable action.')
agCurCfgLFDFlaps = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 160), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100)).clone(5)).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgLFDFlaps.setStatus('current')
if mibBuilder.loadTexts: agCurCfgLFDFlaps.setDescription('This object indicates the maximum number of flaps allowed in a time period set by agCurCfgLFDTime.')
agNewCfgLFDFlaps = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 161), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgLFDFlaps.setStatus('current')
if mibBuilder.loadTexts: agNewCfgLFDFlaps.setDescription('This object specifies the maximum number of flaps that should be allowed in a time period. Use this object to change the global maximum number of flaps allowed in a time period.')
agCurCfgLFDTime = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 162), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 500)).clone(30)).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgLFDTime.setStatus('current')
if mibBuilder.loadTexts: agCurCfgLFDTime.setDescription('This object indicates the length of time period in seconds during which link flaps are counted.')
agNewCfgLFDTime = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 163), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 500)).clone(30)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgLFDTime.setStatus('current')
if mibBuilder.loadTexts: agNewCfgLFDTime.setDescription('This object specifies the length of time period in seconds that should be used to count link flaps.')
agCurCfgTrapSrcLoopIf = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 164), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgTrapSrcLoopIf.setStatus('current')
if mibBuilder.loadTexts: agCurCfgTrapSrcLoopIf.setDescription('The index of the loopback interface that should be used for the source IP of the SNMP trap; 0 means that no loopback interface is used as the source of the SNMP trap.')
agNewCfgTrapSrcLoopIf = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 165), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgTrapSrcLoopIf.setStatus('current')
if mibBuilder.loadTexts: agNewCfgTrapSrcLoopIf.setDescription('The index of the loopback interface that should be used for the source IP of the SNMP trap; 0 means that no loopback interface is used as the source of the SNMP trap.')
agCfgMtm = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 166), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("mtmValue1", 1), ("mtmValue2", 2), ("mtmValue3", 3), ("mtmValue4", 4), ("mtmValue5", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agCfgMtm.setStatus('current')
if mibBuilder.loadTexts: agCfgMtm.setDescription('This object specifies the new value for MTM. The available MTM values are: 1455-24E (1) 7309-BF7 (2) 7309-BR6 (3) 7309-HC7 (4) 7309-HC6 (5)')
agCurCfgDefipData = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 167), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgDefipData.setStatus('current')
if mibBuilder.loadTexts: agCurCfgDefipData.setDescription('Enable or disable the use of default IP address on data interface, as configured in the current configuration block.')
agNewCfgDefipData = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 168), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgDefipData.setStatus('current')
if mibBuilder.loadTexts: agNewCfgDefipData.setDescription('Enable or disable the use of default IP address on data interface, in the new configuration block.')
agCurCfgDefipMgta = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 169), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgDefipMgta.setStatus('current')
if mibBuilder.loadTexts: agCurCfgDefipMgta.setDescription('Enable or disable the use of default IP address on mgta interface, as configured in the current configuration block.')
agNewCfgDefipMgta = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 170), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgDefipMgta.setStatus('current')
if mibBuilder.loadTexts: agNewCfgDefipMgta.setDescription('Enable or disable the use of default IP address on mgta interface, in the new configuration block.')
agCurCfgDefipMgtb = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 171), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgDefipMgtb.setStatus('current')
if mibBuilder.loadTexts: agCurCfgDefipMgtb.setDescription('Enable or disable the use of default IP address on mgtb interface, as configured in the current configuration block.')
agNewCfgDefipMgtb = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 1, 172), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgDefipMgtb.setStatus('current')
if mibBuilder.loadTexts: agNewCfgDefipMgtb.setDescription('Enable or disable the use of default IP address on mgtb interface, in the new configuration block.')
agCurCfgSyslogHost = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgSyslogHost.setStatus('current')
if mibBuilder.loadTexts: agCurCfgSyslogHost.setDescription('The syslog host IP address in the current configuration block.')
agNewCfgSyslogHost = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgSyslogHost.setStatus('current')
if mibBuilder.loadTexts: agNewCfgSyslogHost.setDescription('The syslog host IP address in the new configuration block.')
agCurCfgSyslog2Host = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgSyslog2Host.setStatus('current')
if mibBuilder.loadTexts: agCurCfgSyslog2Host.setDescription('The second syslog host IP address in the current configuration block.')
agNewCfgSyslog2Host = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgSyslog2Host.setStatus('current')
if mibBuilder.loadTexts: agNewCfgSyslog2Host.setDescription('The second syslog host IP address in the new configuration block.')
agCurCfgSyslogFac = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("local0", 1), ("local1", 2), ("local2", 3), ("local3", 4), ("local4", 5), ("local5", 6), ("local6", 7), ("local7", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgSyslogFac.setStatus('current')
if mibBuilder.loadTexts: agCurCfgSyslogFac.setDescription('The facility level of syslog host in the current configuration block.')
agNewCfgSyslogFac = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("local0", 1), ("local1", 2), ("local2", 3), ("local3", 4), ("local4", 5), ("local5", 6), ("local6", 7), ("local7", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgSyslogFac.setStatus('current')
if mibBuilder.loadTexts: agNewCfgSyslogFac.setDescription('The facility level of syslog host in the new configuration block.')
agCurCfgSyslog2Fac = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("local0", 1), ("local1", 2), ("local2", 3), ("local3", 4), ("local4", 5), ("local5", 6), ("local6", 7), ("local7", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgSyslog2Fac.setStatus('current')
if mibBuilder.loadTexts: agCurCfgSyslog2Fac.setDescription('The facility level of second syslog host in the current configuration block.')
agNewCfgSyslog2Fac = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("local0", 1), ("local1", 2), ("local2", 3), ("local3", 4), ("local4", 5), ("local5", 6), ("local6", 7), ("local7", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgSyslog2Fac.setStatus('current')
if mibBuilder.loadTexts: agNewCfgSyslog2Fac.setDescription('The facility level of second syslog host in the new configuration block.')
agCurCfgSyslogSev = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("emerg0", 1), ("alert1", 2), ("crit2", 3), ("err3", 4), ("warning4", 5), ("notice5", 6), ("info6", 7), ("debug7", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgSyslogSev.setStatus('current')
if mibBuilder.loadTexts: agCurCfgSyslogSev.setDescription('The severity of syslog host in the current configuration block.')
agNewCfgSyslogSev = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("emerg0", 1), ("alert1", 2), ("crit2", 3), ("err3", 4), ("warning4", 5), ("notice5", 6), ("info6", 7), ("debug7", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgSyslogSev.setStatus('current')
if mibBuilder.loadTexts: agNewCfgSyslogSev.setDescription('The severity of syslog host in the new configuration block.')
agCurCfgSyslog2Sev = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("emerg0", 1), ("alert1", 2), ("crit2", 3), ("err3", 4), ("warning4", 5), ("notice5", 6), ("info6", 7), ("debug7", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgSyslog2Sev.setStatus('current')
if mibBuilder.loadTexts: agCurCfgSyslog2Sev.setDescription('The severity of syslog2 host in the current configuration block.')
agNewCfgSyslog2Sev = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("emerg0", 1), ("alert1", 2), ("crit2", 3), ("err3", 4), ("warning4", 5), ("notice5", 6), ("info6", 7), ("debug7", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgSyslog2Sev.setStatus('current')
if mibBuilder.loadTexts: agNewCfgSyslog2Sev.setDescription('The severity of syslogs host in the new configuration block.')
agCurCfgSyslogConsoleSev = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("emerg0", 1), ("alert1", 2), ("crit2", 3), ("err3", 4), ("warning4", 5), ("notice5", 6), ("info6", 7), ("debug7", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgSyslogConsoleSev.setStatus('current')
if mibBuilder.loadTexts: agCurCfgSyslogConsoleSev.setDescription('The severity of syslogs console in the current configuration block.')
agNewCfgSyslogConsoleSev = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("emerg0", 1), ("alert1", 2), ("crit2", 3), ("err3", 4), ("warning4", 5), ("notice5", 6), ("info6", 7), ("debug7", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgSyslogConsoleSev.setStatus('current')
if mibBuilder.loadTexts: agNewCfgSyslogConsoleSev.setDescription('The severity of syslogs console in the new configuration block.')
agCurCfgSyslogFlashSev = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("emerg0", 1), ("alert1", 2), ("crit2", 3), ("err3", 4), ("warning4", 5), ("notice5", 6), ("info6", 7), ("debug7", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgSyslogFlashSev.setStatus('current')
if mibBuilder.loadTexts: agCurCfgSyslogFlashSev.setDescription('The severity of syslogs flash in the current configuration block.')
agNewCfgSyslogFlashSev = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("emerg0", 1), ("alert1", 2), ("crit2", 3), ("err3", 4), ("warning4", 5), ("notice5", 6), ("info6", 7), ("debug7", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgSyslogFlashSev.setStatus('current')
if mibBuilder.loadTexts: agNewCfgSyslogFlashSev.setDescription('The severity of syslogs flash in the new configuration block.')
agClrSyslogMsgs = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agClrSyslogMsgs.setStatus('current')
if mibBuilder.loadTexts: agClrSyslogMsgs.setDescription('Clears all current Syslog messages.')
agSyslogMsgTableMaxSize = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agSyslogMsgTableMaxSize.setStatus('current')
if mibBuilder.loadTexts: agSyslogMsgTableMaxSize.setDescription('The maximum number of rows in the syslog message table.')
agCurCfgSyslogHostPort = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("data", 1), ("mgta", 2), ("mgtb", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgSyslogHostPort.setStatus('current')
if mibBuilder.loadTexts: agCurCfgSyslogHostPort.setDescription('Choose the port that the primary Syslog server is connected to.')
agNewCfgSyslogHostPort = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("data", 1), ("mgta", 2), ("mgtb", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgSyslogHostPort.setStatus('current')
if mibBuilder.loadTexts: agNewCfgSyslogHostPort.setDescription('Choose the port that the primary Syslog server is connected to.')
agCurCfgSyslog2HostPort = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("data", 1), ("mgta", 2), ("mgtb", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgSyslog2HostPort.setStatus('current')
if mibBuilder.loadTexts: agCurCfgSyslog2HostPort.setDescription('Choose the port that the secondary Syslog server is connected to.')
agNewCfgSyslog2HostPort = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("data", 1), ("mgta", 2), ("mgtb", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgSyslog2HostPort.setStatus('current')
if mibBuilder.loadTexts: agNewCfgSyslog2HostPort.setDescription('Choose the port that the secondary Syslog server is connected to.')
agCurCfgSyslogSrcLoopIf = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 21), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgSyslogSrcLoopIf.setStatus('current')
if mibBuilder.loadTexts: agCurCfgSyslogSrcLoopIf.setDescription('The index of the loopback interface that should be used for the source IP of the syslog message; 0 means that no loopback interface is used as the source of the syslog message.')
agNewCfgSyslogSrcLoopIf = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 22), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgSyslogSrcLoopIf.setStatus('current')
if mibBuilder.loadTexts: agNewCfgSyslogSrcLoopIf.setDescription('The index of the loopback interface that should be used for the source IP of the syslog message; 0 means that no loopback interface is used as the source of the syslog message.')
agSyslogMsgTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 11), )
if mibBuilder.loadTexts: agSyslogMsgTable.setStatus('current')
if mibBuilder.loadTexts: agSyslogMsgTable.setDescription('The table of syslog messages.')
agSyslogMsgTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 11, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "agSyslogMsgIndex"))
if mibBuilder.loadTexts: agSyslogMsgTableEntry.setStatus('current')
if mibBuilder.loadTexts: agSyslogMsgTableEntry.setDescription('A syslog message stored on the switch.')
agSyslogMsgIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 11, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agSyslogMsgIndex.setStatus('current')
if mibBuilder.loadTexts: agSyslogMsgIndex.setDescription('The syslog message table index.')
agSyslogMessage = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 11, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agSyslogMessage.setStatus('current')
if mibBuilder.loadTexts: agSyslogMessage.setDescription('The syslog message.')
agLog = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 12))
agNewCfgSyslogTrapConsole = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 12, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgSyslogTrapConsole.setStatus('current')
if mibBuilder.loadTexts: agNewCfgSyslogTrapConsole.setDescription('Enable or disable console syslog and SNMP trap in the new configuration block.')
agCurCfgSyslogTrapConsole = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 12, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgSyslogTrapConsole.setStatus('current')
if mibBuilder.loadTexts: agCurCfgSyslogTrapConsole.setDescription('Enable or disable console syslog and SNMP trap, as configured in the current configuration block.')
agNewCfgSyslogTrapSystem = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 12, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgSyslogTrapSystem.setStatus('current')
if mibBuilder.loadTexts: agNewCfgSyslogTrapSystem.setDescription('Enable or disable system level syslog and SNMP trap in the new configuration block.')
agCurCfgSyslogTrapSystem = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 12, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgSyslogTrapSystem.setStatus('current')
if mibBuilder.loadTexts: agCurCfgSyslogTrapSystem.setDescription('Enable or disable system level syslog and SNMP trap, as configured in the current configuration block.')
agNewCfgSyslogTrapMgmt = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 12, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgSyslogTrapMgmt.setStatus('current')
if mibBuilder.loadTexts: agNewCfgSyslogTrapMgmt.setDescription('Enable or disable management(flash, config, login) syslog and SNMP trap in the new configuration block.')
agCurCfgSyslogTrapMgmt = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 12, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgSyslogTrapMgmt.setStatus('current')
if mibBuilder.loadTexts: agCurCfgSyslogTrapMgmt.setDescription('Enable or disable management(flash, config, login) syslog and SNMP trap, as configured in the current configuration block.')
agNewCfgSyslogTrapCli = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 12, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgSyslogTrapCli.setStatus('current')
if mibBuilder.loadTexts: agNewCfgSyslogTrapCli.setDescription('Enable or disable CLI generated error syslog and SNMP trap in the new configuration block.')
agCurCfgSyslogTrapCli = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 12, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgSyslogTrapCli.setStatus('current')
if mibBuilder.loadTexts: agCurCfgSyslogTrapCli.setDescription('Enable or disable CLI generated error syslog and SNMP trap, as configured in the current configuration block.')
agNewCfgSyslogTrapStg = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 12, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgSyslogTrapStg.setStatus('current')
if mibBuilder.loadTexts: agNewCfgSyslogTrapStg.setDescription('Enable or disable spanning tree syslog and SNMP trap in the new configuration block.')
agCurCfgSyslogTrapStg = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 12, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgSyslogTrapStg.setStatus('current')
if mibBuilder.loadTexts: agCurCfgSyslogTrapStg.setDescription('Enable or disable spanning tree syslog and SNMP trap, as configured in the current configuration block.')
agNewCfgSyslogTrapVlan = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 12, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgSyslogTrapVlan.setStatus('current')
if mibBuilder.loadTexts: agNewCfgSyslogTrapVlan.setDescription('Enable or disable VLAN syslog and SNMP trap in the new configuration block.')
agCurCfgSyslogTrapVlan = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 12, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgSyslogTrapVlan.setStatus('current')
if mibBuilder.loadTexts: agCurCfgSyslogTrapVlan.setDescription('Enable or disable VLAN syslog and SNMP trap, as configured in the current configuration block.')
agNewCfgSyslogTrapSsh = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 12, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgSyslogTrapSsh.setStatus('current')
if mibBuilder.loadTexts: agNewCfgSyslogTrapSsh.setDescription('Enable or disable SSH, RADIUS syslog and SNMP trap in the new configuration block.')
agCurCfgSyslogTrapSsh = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 12, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgSyslogTrapSsh.setStatus('current')
if mibBuilder.loadTexts: agCurCfgSyslogTrapSsh.setDescription('Enable or disable SSH, RADIUS syslog and SNMP trap, as configured in the current configuration block.')
agNewCfgSyslogTrapVrrp = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 12, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgSyslogTrapVrrp.setStatus('current')
if mibBuilder.loadTexts: agNewCfgSyslogTrapVrrp.setDescription('Enable or disable VRRP syslog and SNMP trap in the new configuration block.')
agCurCfgSyslogTrapVrrp = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 12, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgSyslogTrapVrrp.setStatus('current')
if mibBuilder.loadTexts: agCurCfgSyslogTrapVrrp.setDescription('Enable or disable VRRP syslog and SNMP trap, as configured in the current configuration block.')
agNewCfgSyslogTrapBgp = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 12, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgSyslogTrapBgp.setStatus('current')
if mibBuilder.loadTexts: agNewCfgSyslogTrapBgp.setDescription('Enable or disable BGP syslog and SNMP trap in the new configuration block.')
agCurCfgSyslogTrapBgp = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 12, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgSyslogTrapBgp.setStatus('current')
if mibBuilder.loadTexts: agCurCfgSyslogTrapBgp.setDescription('Enable or disable BGP syslog and SNMP trap, as configured in the current configuration block.')
agNewCfgSyslogTrapNtp = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 12, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgSyslogTrapNtp.setStatus('current')
if mibBuilder.loadTexts: agNewCfgSyslogTrapNtp.setDescription('Enable or disable NTP syslog and SNMP trap in the new configuration block.')
agCurCfgSyslogTrapNtp = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 12, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgSyslogTrapNtp.setStatus('current')
if mibBuilder.loadTexts: agCurCfgSyslogTrapNtp.setDescription('Enable or disable NTP syslog and SNMP trap, as configured in the current configuration block.')
agNewCfgSyslogTrapIp = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 12, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgSyslogTrapIp.setStatus('current')
if mibBuilder.loadTexts: agNewCfgSyslogTrapIp.setDescription('Enable or disable IP related syslog and SNMP trap in the new configuration block.')
agCurCfgSyslogTrapIp = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 12, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgSyslogTrapIp.setStatus('current')
if mibBuilder.loadTexts: agCurCfgSyslogTrapIp.setDescription('Enable or disable IP related syslog and SNMP trap, as configured in the current configuration block.')
agNewCfgSyslogTrapWeb = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 12, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgSyslogTrapWeb.setStatus('current')
if mibBuilder.loadTexts: agNewCfgSyslogTrapWeb.setDescription('Enable or disable WEBUI related syslog and SNMP trap in the new configuration block.')
agCurCfgSyslogTrapWeb = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 12, 36), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgSyslogTrapWeb.setStatus('current')
if mibBuilder.loadTexts: agCurCfgSyslogTrapWeb.setDescription('Enable or disable WEBUI related syslog and SNMP trap, as configured in the current configuration block.')
agNewCfgSyslogTrapOspf = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 12, 41), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgSyslogTrapOspf.setStatus('current')
if mibBuilder.loadTexts: agNewCfgSyslogTrapOspf.setDescription('Enable or disable OSPF related syslog and SNMP trap in the new configuration block.')
agCurCfgSyslogTrapOspf = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 12, 42), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgSyslogTrapOspf.setStatus('current')
if mibBuilder.loadTexts: agCurCfgSyslogTrapOspf.setDescription('Enable or disable OSPF related syslog and SNMP trap, as configured in the current configuration block.')
agNewCfgSyslogTrapRmon = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 12, 45), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgSyslogTrapRmon.setStatus('current')
if mibBuilder.loadTexts: agNewCfgSyslogTrapRmon.setDescription('Enable or disable RMON related syslog and SNMP trap in the new configuration block.')
agCurCfgSyslogTrapRmon = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 12, 46), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgSyslogTrapRmon.setStatus('current')
if mibBuilder.loadTexts: agCurCfgSyslogTrapRmon.setDescription('Enable or disable RMON related syslog and SNMP trap, as configured in the current configuration block.')
agNewCfgSyslogTrapCfg = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 12, 53), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgSyslogTrapCfg.setStatus('current')
if mibBuilder.loadTexts: agNewCfgSyslogTrapCfg.setDescription('Enable or disable CFG related syslog and SNMP trap in the new configuration block.')
agCurCfgSyslogTrapCfg = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 12, 54), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgSyslogTrapCfg.setStatus('current')
if mibBuilder.loadTexts: agCurCfgSyslogTrapCfg.setDescription('Enable or disable CFG related syslog and SNMP trap, as configured in the current configuration block.')
agNewCfgSyslogTrapServer = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 12, 55), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgSyslogTrapServer.setStatus('current')
if mibBuilder.loadTexts: agNewCfgSyslogTrapServer.setDescription('Enable or disable Server related syslog and SNMP trap in the new configuration block.')
agCurCfgSyslogTrapServer = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 12, 56), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgSyslogTrapServer.setStatus('current')
if mibBuilder.loadTexts: agCurCfgSyslogTrapServer.setDescription('Enable or disable Server related syslog and SNMP trap, as configured in the current configuration block.')
agNewCfgSyslogTrapDifftrak = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 12, 57), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgSyslogTrapDifftrak.setStatus('current')
if mibBuilder.loadTexts: agNewCfgSyslogTrapDifftrak.setDescription('Enable or disable Difftrak related syslog and SNMP trap in the new configuration block.')
agCurCfgSyslogTrapDifftrak = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 12, 58), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgSyslogTrapDifftrak.setStatus('current')
if mibBuilder.loadTexts: agCurCfgSyslogTrapDifftrak.setDescription('Enable or disable Difftrak related syslog and SNMP trap, as configured in the current configuration block.')
agNewCfgSyslogTrapHotlinks = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 12, 61), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgSyslogTrapHotlinks.setStatus('current')
if mibBuilder.loadTexts: agNewCfgSyslogTrapHotlinks.setDescription('Enable or disable Hot Links related syslog and SNMP trap in the new configuration block.')
agCurCfgSyslogTrapHotlinks = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 12, 62), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgSyslogTrapHotlinks.setStatus('current')
if mibBuilder.loadTexts: agCurCfgSyslogTrapHotlinks.setDescription('Enable or disable Hot Links related syslog and SNMP trap, as configured in the current configuration block.')
agNewCfgSyslogTrapLldp = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 12, 63), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgSyslogTrapLldp.setStatus('current')
if mibBuilder.loadTexts: agNewCfgSyslogTrapLldp.setDescription('Enable or disable LLDP related syslog and SNMP trap in the new configuration block.')
agCurCfgSyslogTrapLldp = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 12, 64), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgSyslogTrapLldp.setStatus('current')
if mibBuilder.loadTexts: agCurCfgSyslogTrapLldp.setDescription('Enable or disable LLDP related syslog and SNMP trap, as configured in the current configuration block.')
agNewCfgSyslogTrapAll = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 12, 65), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgSyslogTrapAll.setStatus('current')
if mibBuilder.loadTexts: agNewCfgSyslogTrapAll.setDescription('Enable or disable all syslog and SNMP traps in the new configuration block.')
agCurCfgSyslogTrapAll = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 12, 66), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgSyslogTrapAll.setStatus('current')
if mibBuilder.loadTexts: agCurCfgSyslogTrapAll.setDescription('Enable or disable all syslog and SNMP traps, as configured in the current configuration block.')
agNewCfgSyslogTrapIpv6 = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 12, 67), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgSyslogTrapIpv6.setStatus('current')
if mibBuilder.loadTexts: agNewCfgSyslogTrapIpv6.setDescription('Enable or disable IPv6 related syslog and SNMP trap in the new configuration block.')
agCurCfgSyslogTrapIpv6 = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 12, 68), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgSyslogTrapIpv6.setStatus('current')
if mibBuilder.loadTexts: agCurCfgSyslogTrapIpv6.setDescription('Enable or disable IPv6 related syslog and SNMP trap, as configured in the current configuration block.')
agNewCfgSyslogTrapFailover = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 12, 73), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgSyslogTrapFailover.setStatus('current')
if mibBuilder.loadTexts: agNewCfgSyslogTrapFailover.setDescription('Enable or disable failover related syslog and SNMP trap in the new configuration block.')
agCurCfgSyslogTrapFailover = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 12, 74), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgSyslogTrapFailover.setStatus('current')
if mibBuilder.loadTexts: agCurCfgSyslogTrapFailover.setDescription('Enable or disable failover related syslog and SNMP trap, as configured in the current configuration block.')
agNewCfgSyslogTrapLacp = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 12, 77), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgSyslogTrapLacp.setStatus('current')
if mibBuilder.loadTexts: agNewCfgSyslogTrapLacp.setDescription('Enable or disable LACP syslog and SNMP trap in the new configuration block.')
agCurCfgSyslogTrapLacp = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 12, 78), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgSyslogTrapLacp.setStatus('current')
if mibBuilder.loadTexts: agCurCfgSyslogTrapLacp.setDescription('Enable or disable LACP syslog and SNMP trap, as configured in the current configuration block.')
agNewCfgSyslogTrapLink = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 12, 79), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgSyslogTrapLink.setStatus('current')
if mibBuilder.loadTexts: agNewCfgSyslogTrapLink.setDescription('Enable or disable all syslog and SNMP traps, in link up/down.')
agCurCfgSyslogTrapLink = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 12, 80), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgSyslogTrapLink.setStatus('current')
if mibBuilder.loadTexts: agCurCfgSyslogTrapLink.setDescription('Enable or disable all syslog and SNMP traps, as currently configured in link up/down.')
agNewCfgSyslogTrapOspfv3 = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 12, 81), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgSyslogTrapOspfv3.setStatus('current')
if mibBuilder.loadTexts: agNewCfgSyslogTrapOspfv3.setDescription('Enable or disable OSPFv3 related syslog and SNMP trap in the new configuration block.')
agCurCfgSyslogTrapOspfv3 = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 12, 82), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgSyslogTrapOspfv3.setStatus('current')
if mibBuilder.loadTexts: agCurCfgSyslogTrapOspfv3.setDescription('Enable or disable OSPFv3 related syslog and SNMP trap, as configured in the current configuration block.')
agNewCfgSyslogTrapDcbx = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 12, 85), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgSyslogTrapDcbx.setStatus('current')
if mibBuilder.loadTexts: agNewCfgSyslogTrapDcbx.setDescription('Enable or disable all DCBX-related syslog and SNMP traps.')
agCurCfgSyslogTrapDcbx = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 12, 86), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgSyslogTrapDcbx.setStatus('current')
if mibBuilder.loadTexts: agCurCfgSyslogTrapDcbx.setDescription('Enable or disable all DCBX-related syslog and SNMP traps.')
agNewCfgSyslogTrapFcoe = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 12, 87), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgSyslogTrapFcoe.setStatus('current')
if mibBuilder.loadTexts: agNewCfgSyslogTrapFcoe.setDescription('Enable or disable all FCOE-related syslog and SNMP traps.')
agCurCfgSyslogTrapFcoe = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 12, 88), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgSyslogTrapFcoe.setStatus('current')
if mibBuilder.loadTexts: agCurCfgSyslogTrapFcoe.setDescription('Enable or disable all FCOE-related syslog and SNMP traps.')
agNewCfgSyslogTrapVm = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 12, 89), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgSyslogTrapVm.setStatus('current')
if mibBuilder.loadTexts: agNewCfgSyslogTrapVm.setDescription('Enable or disable all VM-related syslog and SNMP traps.')
agCurCfgSyslogTrapVm = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 12, 90), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgSyslogTrapVm.setStatus('current')
if mibBuilder.loadTexts: agCurCfgSyslogTrapVm.setDescription('Enable or disable all VM-related syslog and SNMP traps.')
agNewCfgSyslogTrapVnic = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 12, 91), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgSyslogTrapVnic.setStatus('current')
if mibBuilder.loadTexts: agNewCfgSyslogTrapVnic.setDescription('Enable or disable all VNIC-related syslog and SNMP traps.')
agCurCfgSyslogTrapVnic = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 12, 92), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgSyslogTrapVnic.setStatus('current')
if mibBuilder.loadTexts: agCurCfgSyslogTrapVnic.setDescription('Enable or disable all VNIC-related syslog and SNMP traps.')
agNewCfgSyslogTrapCfgchg = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 12, 93), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgSyslogTrapCfgchg.setStatus('current')
if mibBuilder.loadTexts: agNewCfgSyslogTrapCfgchg.setDescription('Enable or disable configuration change related syslog and SNMP trap in the new configuration block.')
agCurCfgSyslogTrapCfgchg = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 12, 94), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgSyslogTrapCfgchg.setStatus('current')
if mibBuilder.loadTexts: agCurCfgSyslogTrapCfgchg.setDescription('Enable or disable configuration change related syslog and SNMP trap, as configured in the current configuration block.')
agNewCfgSyslogTrapVlag = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 12, 95), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgSyslogTrapVlag.setStatus('current')
if mibBuilder.loadTexts: agNewCfgSyslogTrapVlag.setDescription('Enable or disable Vlag related syslog and SNMP trap.')
agCurCfgSyslogTrapVlag = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 12, 96), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgSyslogTrapVlag.setStatus('current')
if mibBuilder.loadTexts: agCurCfgSyslogTrapVlag.setDescription('Enable or disable Vlag related syslog and SNMP trap.')
agNewCfgSyslogTrapIgmpGroup = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 12, 99), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgSyslogTrapIgmpGroup.setStatus('current')
if mibBuilder.loadTexts: agNewCfgSyslogTrapIgmpGroup.setDescription('Enable or disable all IGMP GROUP-related syslog and SNMP traps.')
agCurCfgSyslogTrapIgmpGroup = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 12, 100), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgSyslogTrapIgmpGroup.setStatus('current')
if mibBuilder.loadTexts: agCurCfgSyslogTrapIgmpGroup.setDescription('Enable or disable all IGMP GROUP-related syslog and SNMP traps.')
agNewCfgSyslogTrapIgmpMrouter = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 12, 101), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgSyslogTrapIgmpMrouter.setStatus('current')
if mibBuilder.loadTexts: agNewCfgSyslogTrapIgmpMrouter.setDescription('Enable or disable all IGMP MROUTER-related syslog and SNMP traps.')
agCurCfgSyslogTrapIgmpMrouter = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 12, 102), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgSyslogTrapIgmpMrouter.setStatus('current')
if mibBuilder.loadTexts: agCurCfgSyslogTrapIgmpMrouter.setDescription('Enable or disable all IGMP MROUTER-related syslog and SNMP traps.')
agNewCfgSyslogTrapIgmpQuerier = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 12, 103), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgSyslogTrapIgmpQuerier.setStatus('current')
if mibBuilder.loadTexts: agNewCfgSyslogTrapIgmpQuerier.setDescription('Enable or disable all IGMP QUERIER-related syslog and SNMP traps.')
agCurCfgSyslogTrapIgmpQuerier = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 12, 104), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgSyslogTrapIgmpQuerier.setStatus('current')
if mibBuilder.loadTexts: agCurCfgSyslogTrapIgmpQuerier.setDescription('Enable or disable all IGMP QUERIER-related syslog and SNMP traps.')
agNewCfgSyslogTrapMld = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 12, 105), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgSyslogTrapMld.setStatus('current')
if mibBuilder.loadTexts: agNewCfgSyslogTrapMld.setDescription('Enable or disable all MLD-related syslog and SNMP traps.')
agCurCfgSyslogTrapMld = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 5, 12, 106), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgSyslogTrapMld.setStatus('current')
if mibBuilder.loadTexts: agCurCfgSyslogTrapMld.setDescription('Enable or disable all MLD-related syslog and SNMP traps.')
agTransferServer = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 7, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agTransferServer.setStatus('current')
if mibBuilder.loadTexts: agTransferServer.setDescription('The FTP/TFTP server IP address or domain name.')
agTransferImage = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 7, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("image1", 2), ("image2", 3), ("boot", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agTransferImage.setStatus('current')
if mibBuilder.loadTexts: agTransferImage.setDescription('Whether the image file should be loaded in image1 or image2 in flash.')
agTransferImageFileName = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 7, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agTransferImageFileName.setStatus('current')
if mibBuilder.loadTexts: agTransferImageFileName.setDescription('The image file name to be downloaded.')
agTransferCfgFileName = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 7, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agTransferCfgFileName.setStatus('current')
if mibBuilder.loadTexts: agTransferCfgFileName.setDescription('The configuration file name.')
agTransferDumpFileName = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 7, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agTransferDumpFileName.setStatus('current')
if mibBuilder.loadTexts: agTransferDumpFileName.setDescription('The core dump file name.')
agTransferAction = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 7, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 7, 8, 14, 15, 16))).clone(namedValues=NamedValues(("other", 1), ("img-get", 2), ("cfg-get", 3), ("cfg-put", 4), ("dump-put", 5), ("img-put", 7), ("tsdump-put", 8), ("ca-get", 14), ("hostcert-get", 15), ("hostkey-get", 16)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agTransferAction.setStatus('current')
if mibBuilder.loadTexts: agTransferAction.setDescription('This is an action object to perform various FTP/TFTP Get or Put functions. The FTP/TFTP sever is specified in agTransferServer object. img-get(2) - Download switch image from a specified image file(agTransferImageFileName) on the FTP/TFTP server to the destinated storage(agTransferImage). The duration of the action will depend on the image downloading and writting time on the network element. Sugguest 150 seconds timeout setting in MIB Browser to get the correct response for this action. cfg-get(3) - Download switch configuration from a specified file(agTransferCfgFileName) on the FTP/TFTP server. cfg-put(4) - Upload switch configuration to a specified file(agTransferCfgFileName) on the FTP/TFTP server. dump-put(5) - Download switch core dump to a specified file(agTransferDumpFileName) on the FTP/TFTP server. bkpdump-put(6)- Download switch backup core dump to a specified file(agTransferDumpFileName) on the FTP/TFTP server. img-put(7) - Upload specified switch image to a specified image file(agTransferImageFileName) on the FTP/TFTP server. tsdump-put(8) - Download switch tech support dump to a specified file(agTransferTSDumpFileName) on the FTP/TFTP server. bogon-get(9) - Download bogon config file from a specified bogon file(uses agTransferImageFileName) on the FTP/TFTP server. ca-get(14) - Download CA root certificate from a specified file(agTransferCaFileName) on the TFTP server. This command did not support FTP. hostcert-get(15) - Download host certificate from a specified file(agTransferHostCertFileName) on the TFTP server. This command did not support FTP. hostkey-get(16) - Download host private key from a specified file(agTransferHostKeyFileName) on the TFTP server. This command did not support FTP. other(1) is returned always when read.')
agTransferLastActionStatus = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 7, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agTransferLastActionStatus.setStatus('current')
if mibBuilder.loadTexts: agTransferLastActionStatus.setDescription('The recorded status of the previous FTP/TFTP activity.')
agTransferPort = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 7, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("data", 1), ("mgta", 2), ("mgtb", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agTransferPort.setStatus('current')
if mibBuilder.loadTexts: agTransferPort.setDescription('Specify whether the FTP/TFTP operation should be performed over the data port or the management port.')
agTransferUserName = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 7, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agTransferUserName.setStatus('current')
if mibBuilder.loadTexts: agTransferUserName.setDescription('The username for the FTP server or blank for TFTP server.')
agTransferPassword = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 7, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agTransferPassword.setStatus('current')
if mibBuilder.loadTexts: agTransferPassword.setDescription('The password for the FTP server. For security reason, an empty string will be returned when the OID is read.')
agTransferTSDumpFileName = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 7, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agTransferTSDumpFileName.setStatus('current')
if mibBuilder.loadTexts: agTransferTSDumpFileName.setDescription('The TS dump file name.')
agTransferLastConfigurationActionStatus = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 7, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("successfully", 1), ("failed", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agTransferLastConfigurationActionStatus.setStatus('current')
if mibBuilder.loadTexts: agTransferLastConfigurationActionStatus.setDescription("The status of the last configuration action using the file ftp/tftp'd from server.")
agTransferCaFileName = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 7, 15), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agTransferCaFileName.setStatus('current')
if mibBuilder.loadTexts: agTransferCaFileName.setDescription('The CA certificate file name.')
agTransferHostCertFileName = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 7, 16), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agTransferHostCertFileName.setStatus('current')
if mibBuilder.loadTexts: agTransferHostCertFileName.setDescription('The Host certificate file name.')
agTransferHostKeyFileName = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 7, 17), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agTransferHostKeyFileName.setStatus('current')
if mibBuilder.loadTexts: agTransferHostKeyFileName.setDescription('The Host private key file name.')
agPortTableMaxEnt = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 2, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agPortTableMaxEnt.setStatus('current')
if mibBuilder.loadTexts: agPortTableMaxEnt.setDescription('The maximum number of rows in the port configuration host table.')
agPortCurCfgTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 2, 2), )
if mibBuilder.loadTexts: agPortCurCfgTable.setStatus('current')
if mibBuilder.loadTexts: agPortCurCfgTable.setDescription('The table of port configuration in the current configuration block.')
agPortCurCfgTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 2, 2, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "agPortCurCfgIndx"))
if mibBuilder.loadTexts: agPortCurCfgTableEntry.setStatus('current')
if mibBuilder.loadTexts: agPortCurCfgTableEntry.setDescription('A row in the port table in the current configuration block.')
agPortCurCfgIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 2, 2, 1, 1), PortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agPortCurCfgIndx.setStatus('current')
if mibBuilder.loadTexts: agPortCurCfgIndx.setDescription('The index of the row in port configurations table.')
agPortCurCfgState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("enabled", 2), ("disabled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agPortCurCfgState.setStatus('current')
if mibBuilder.loadTexts: agPortCurCfgState.setDescription('This is the state of the port.')
agPortCurCfgVlanTag = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("tagged", 2), ("untagged", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agPortCurCfgVlanTag.setStatus('current')
if mibBuilder.loadTexts: agPortCurCfgVlanTag.setDescription('This is VLAN tag state of the port')
agPortCurCfgRmon = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 2, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("on", 2), ("off", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agPortCurCfgRmon.setStatus('current')
if mibBuilder.loadTexts: agPortCurCfgRmon.setDescription('This object is used to turn RMON on or off on the port.')
agPortCurCfgPVID = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 2, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agPortCurCfgPVID.setStatus('current')
if mibBuilder.loadTexts: agPortCurCfgPVID.setDescription('The default VLAN ID for the port. ')
agPortCurCfgGigEthFctl = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 2, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5))).clone(namedValues=NamedValues(("transmit", 2), ("receive", 3), ("both", 4), ("none", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agPortCurCfgGigEthFctl.setStatus('current')
if mibBuilder.loadTexts: agPortCurCfgGigEthFctl.setDescription('This object is used to select port flow control for gigabit Ethernet connection.')
agPortCurCfgPortName = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 2, 2, 1, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agPortCurCfgPortName.setStatus('current')
if mibBuilder.loadTexts: agPortCurCfgPortName.setDescription('The switch port name.')
agPortCurCfgLinkTrap = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 2, 2, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agPortCurCfgLinkTrap.setStatus('current')
if mibBuilder.loadTexts: agPortCurCfgLinkTrap.setDescription("Indicates whether linkUp/linkDown traps should be generated for this interface. By default, this object should have the value enabled(1) for interfaces which do not operate on 'top' of any other interface (as defined in the ifStackTable), and disabled(2) otherwise.")
agPortCurCfgDscpRemarking = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 2, 2, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agPortCurCfgDscpRemarking.setStatus('current')
if mibBuilder.loadTexts: agPortCurCfgDscpRemarking.setDescription('Enable or disable Dscp remarking for the switch port.')
agPortCurCfgPortAlias = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 2, 2, 1, 24), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agPortCurCfgPortAlias.setStatus('current')
if mibBuilder.loadTexts: agPortCurCfgPortAlias.setDescription('The switch port alias.')
agPortCurCfgTagPVID = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 2, 2, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("tagged", 2), ("untagged", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agPortCurCfgTagPVID.setStatus('current')
if mibBuilder.loadTexts: agPortCurCfgTagPVID.setDescription('This is PVID tag state of the port')
agPortCurCfgLearning = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 2, 2, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agPortCurCfgLearning.setStatus('current')
if mibBuilder.loadTexts: agPortCurCfgLearning.setDescription('Enable or disable L2 (FDB) Learning for the switch port.')
agPortCurCfgFloodBlocking = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 2, 2, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agPortCurCfgFloodBlocking.setStatus('current')
if mibBuilder.loadTexts: agPortCurCfgFloodBlocking.setDescription('Enable or disable flood blocking for the switch port.')
agPortCurCfgType = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 2, 2, 1, 29), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agPortCurCfgType.setStatus('current')
if mibBuilder.loadTexts: agPortCurCfgType.setDescription('The switch port type.')
agPortCurCfgLinkType = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 2, 2, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("auto", 1), ("p2p", 2), ("shared", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agPortCurCfgLinkType.setStatus('current')
if mibBuilder.loadTexts: agPortCurCfgLinkType.setDescription('The type of port connection. (for PVRST only)')
agPortCurCfgEdge = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 2, 2, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agPortCurCfgEdge.setStatus('current')
if mibBuilder.loadTexts: agPortCurCfgEdge.setDescription('The state of port edge.')
agPortCurCfgErrDisableRecovery = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 2, 2, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readonly")
if mibBuilder.loadTexts: agPortCurCfgErrDisableRecovery.setStatus('current')
if mibBuilder.loadTexts: agPortCurCfgErrDisableRecovery.setDescription("This object indicates whether the system will automatically re-enable this port if it becomes error-disabled. This port will be re-enabled after the time interval specified by the agCurCfgErrDisableTimeout object has elapsed. A port is in error-disabled state when it is operationally disabled due to abnormal conditions detected on the port. If this port is error-disabled, it will only be re-enabled by the system if the agCurCfgErrDisableRecovery object and this object both have a value of 'enable(1)'.")
agPortCurCfgUdld = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 2, 2, 1, 37), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agPortCurCfgUdld.setStatus('current')
if mibBuilder.loadTexts: agPortCurCfgUdld.setDescription('Enable or disable UDLD for the switch port.')
agPortCurCfgUdldMode = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 2, 2, 1, 38), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normal", 1), ("aggressive", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agPortCurCfgUdldMode.setStatus('current')
if mibBuilder.loadTexts: agPortCurCfgUdldMode.setDescription('Enable or disable UDLD mode for the switch port.')
agPortCurCfgOam = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 2, 2, 1, 39), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agPortCurCfgOam.setStatus('current')
if mibBuilder.loadTexts: agPortCurCfgOam.setDescription('Enable or disable OAM Discovery process for the switch port.')
agPortCurCfgOamMode = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 2, 2, 1, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("passive", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agPortCurCfgOamMode.setStatus('current')
if mibBuilder.loadTexts: agPortCurCfgOamMode.setDescription('Enable or disable OAM mode for the switch port.')
agPortCurCfgBpduGuard = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 2, 2, 1, 41), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agPortCurCfgBpduGuard.setStatus('current')
if mibBuilder.loadTexts: agPortCurCfgBpduGuard.setDescription('Enable or disable BPDU guard for the switch port.')
agPortCurCfgMulticastThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 2, 2, 1, 42), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agPortCurCfgMulticastThreshold.setStatus('current')
if mibBuilder.loadTexts: agPortCurCfgMulticastThreshold.setDescription("Current status of the port's Multicast Threshold.")
agPortCurCfgMulticastThresholdRate = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 2, 2, 1, 43), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agPortCurCfgMulticastThresholdRate.setStatus('current')
if mibBuilder.loadTexts: agPortCurCfgMulticastThresholdRate.setDescription("Current port's Multicast Threshold Rate.")
agPortCurCfgBroadcastThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 2, 2, 1, 44), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agPortCurCfgBroadcastThreshold.setStatus('current')
if mibBuilder.loadTexts: agPortCurCfgBroadcastThreshold.setDescription("Current status of the port's Broadcast Threshold.")
agPortCurCfgBroadcastThresholdRate = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 2, 2, 1, 45), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agPortCurCfgBroadcastThresholdRate.setStatus('current')
if mibBuilder.loadTexts: agPortCurCfgBroadcastThresholdRate.setDescription("Current port's Broadcast Threshold Rate.")
agPortCurCfgDLFThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 2, 2, 1, 46), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agPortCurCfgDLFThreshold.setStatus('current')
if mibBuilder.loadTexts: agPortCurCfgDLFThreshold.setDescription("Current status of the port's Destination Lookup Fail Threshold.")
agPortCurCfgDLFThresholdRate = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 2, 2, 1, 47), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agPortCurCfgDLFThresholdRate.setStatus('current')
if mibBuilder.loadTexts: agPortCurCfgDLFThresholdRate.setDescription("Current port's Destination Lookup Fail Threshold Rate.")
agPortCurCfgMacAddrNotif = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 2, 2, 1, 48), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("enabled", 2), ("disabled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agPortCurCfgMacAddrNotif.setStatus('current')
if mibBuilder.loadTexts: agPortCurCfgMacAddrNotif.setDescription('This is the state of the MAC address notification syslog messages on the port.')
agPortCurCfgStpExtGuard = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 2, 2, 1, 52), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 0))).clone(namedValues=NamedValues(("loop", 1), ("root", 2), ("none", 3), ("default", 0)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agPortCurCfgStpExtGuard.setStatus('current')
if mibBuilder.loadTexts: agPortCurCfgStpExtGuard.setDescription('Current state for spanning tree guard type')
agPortCurCfgLFDStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 2, 2, 1, 53), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readonly")
if mibBuilder.loadTexts: agPortCurCfgLFDStatus.setStatus('current')
if mibBuilder.loadTexts: agPortCurCfgLFDStatus.setDescription("This object indicates whether the system will put this port in an error-disabled state due to excessive link flaps. A port will be put in an error-disabled state due to excessive link flaps if this object and the global agCurCfgLFDStatus object both have a value of 'enable'. A port has an excessive number of link flaps if the number of link flaps detected during a time period in seconds indicated by agCurCfgLFDTime exceeds the maximum number of allowed flaps indicated by agCurCfgLFDFlaps.")
agPortNewCfgTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 2, 3), )
if mibBuilder.loadTexts: agPortNewCfgTable.setStatus('current')
if mibBuilder.loadTexts: agPortNewCfgTable.setDescription('The table of port configuration in the new configuration block.')
agPortNewCfgTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 2, 3, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "agPortNewCfgIndx"))
if mibBuilder.loadTexts: agPortNewCfgTableEntry.setStatus('current')
if mibBuilder.loadTexts: agPortNewCfgTableEntry.setDescription('A row in the port configuration table in the new configuration block.')
agPortNewCfgIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 2, 3, 1, 1), PortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agPortNewCfgIndx.setStatus('current')
if mibBuilder.loadTexts: agPortNewCfgIndx.setDescription('The index of the row in port configurations table.')
agPortNewCfgState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 2, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("enabled", 2), ("disabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agPortNewCfgState.setStatus('current')
if mibBuilder.loadTexts: agPortNewCfgState.setDescription('This is the state of the port.')
agPortNewCfgVlanTag = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 2, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("tagged", 2), ("untagged", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agPortNewCfgVlanTag.setStatus('current')
if mibBuilder.loadTexts: agPortNewCfgVlanTag.setDescription('This is VLAN tag state of the port')
agPortNewCfgRmon = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 2, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("on", 2), ("off", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agPortNewCfgRmon.setStatus('current')
if mibBuilder.loadTexts: agPortNewCfgRmon.setDescription('This object is used to turn RMON on or off on the port.')
agPortNewCfgPVID = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 2, 3, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agPortNewCfgPVID.setStatus('current')
if mibBuilder.loadTexts: agPortNewCfgPVID.setDescription('The default VLAN ID for the port. ')
agPortNewCfgGigEthFctl = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 2, 3, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5))).clone(namedValues=NamedValues(("transmit", 2), ("receive", 3), ("both", 4), ("none", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agPortNewCfgGigEthFctl.setStatus('current')
if mibBuilder.loadTexts: agPortNewCfgGigEthFctl.setDescription('This object is used to select port flow control for gigabit Ethernet connection.')
agPortNewCfgPortName = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 2, 3, 1, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agPortNewCfgPortName.setStatus('current')
if mibBuilder.loadTexts: agPortNewCfgPortName.setDescription('The switch port name.')
agPortNewCfgLinkTrap = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 2, 3, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agPortNewCfgLinkTrap.setStatus('current')
if mibBuilder.loadTexts: agPortNewCfgLinkTrap.setDescription("Indicates whether linkUp/linkDown traps should be generated for this interface. By default, this object should have the value enabled(1) for interfaces which do not operate on 'top' of any other interface (as defined in the ifStackTable), and disabled(2) otherwise.")
agPortNewCfgDscpRemarking = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 2, 3, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agPortNewCfgDscpRemarking.setStatus('current')
if mibBuilder.loadTexts: agPortNewCfgDscpRemarking.setDescription('Enable or disable Dscp remarking for the switch port.')
agPortNewCfgTagPVID = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 2, 3, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("tagged", 2), ("untagged", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agPortNewCfgTagPVID.setStatus('current')
if mibBuilder.loadTexts: agPortNewCfgTagPVID.setDescription('This is PVID tag state of the port')
agPortNewCfgLearning = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 2, 3, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agPortNewCfgLearning.setStatus('current')
if mibBuilder.loadTexts: agPortNewCfgLearning.setDescription('Enable or disable L2 (FDB) Learning for the switch port.')
agPortNewCfgFloodBlocking = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 2, 3, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agPortNewCfgFloodBlocking.setStatus('current')
if mibBuilder.loadTexts: agPortNewCfgFloodBlocking.setDescription('Enable or disable flood blocking for the switch port.')
agPortNewCfgType = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 2, 3, 1, 29), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agPortNewCfgType.setStatus('current')
if mibBuilder.loadTexts: agPortNewCfgType.setDescription('The switch port type.')
agPortNewCfgLinkType = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 2, 3, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("auto", 1), ("p2p", 2), ("shared", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: agPortNewCfgLinkType.setStatus('current')
if mibBuilder.loadTexts: agPortNewCfgLinkType.setDescription('The type of port connection. (for PVRST only)')
agPortNewCfgEdge = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 2, 3, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: agPortNewCfgEdge.setStatus('current')
if mibBuilder.loadTexts: agPortNewCfgEdge.setDescription('The state of port edge.')
agPortNewCfgErrDisableRecovery = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 2, 3, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agPortNewCfgErrDisableRecovery.setStatus('current')
if mibBuilder.loadTexts: agPortNewCfgErrDisableRecovery.setDescription('This object specifies whether the system should automatically re-enable this port when it becomes error-disabled. Use this object to change the port-level setting of the error-disable recovery action.')
agPortNewCfgUdld = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 2, 3, 1, 37), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agPortNewCfgUdld.setStatus('current')
if mibBuilder.loadTexts: agPortNewCfgUdld.setDescription('Enable or disable UDLD for the switch port.')
agPortNewCfgUdldMode = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 2, 3, 1, 38), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normal", 1), ("aggressive", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agPortNewCfgUdldMode.setStatus('current')
if mibBuilder.loadTexts: agPortNewCfgUdldMode.setDescription('Enable or disable UDLD mode for the switch port.')
agPortNewCfgOam = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 2, 3, 1, 39), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agPortNewCfgOam.setStatus('current')
if mibBuilder.loadTexts: agPortNewCfgOam.setDescription('Enable or disable OAM Discovery process for the switch port.')
agPortNewCfgOamMode = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 2, 3, 1, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("passive", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agPortNewCfgOamMode.setStatus('current')
if mibBuilder.loadTexts: agPortNewCfgOamMode.setDescription('Enable or disable OAM mode for the switch port.')
agPortNewCfgBpduGuard = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 2, 3, 1, 41), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agPortNewCfgBpduGuard.setStatus('current')
if mibBuilder.loadTexts: agPortNewCfgBpduGuard.setDescription('Enable or disable BPDU guard for the switch port.')
agPortNewCfgMulticastThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 2, 3, 1, 42), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agPortNewCfgMulticastThreshold.setStatus('current')
if mibBuilder.loadTexts: agPortNewCfgMulticastThreshold.setDescription("New status of the port's Multicast Threshold.")
agPortNewCfgMulticastThresholdRate = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 2, 3, 1, 43), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agPortNewCfgMulticastThresholdRate.setStatus('current')
if mibBuilder.loadTexts: agPortNewCfgMulticastThresholdRate.setDescription("New port's Multicast Threshold Rate.")
agPortNewCfgBroadcastThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 2, 3, 1, 44), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agPortNewCfgBroadcastThreshold.setStatus('current')
if mibBuilder.loadTexts: agPortNewCfgBroadcastThreshold.setDescription("New status of the port's Broadcast Threshold.")
agPortNewCfgBroadcastThresholdRate = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 2, 3, 1, 45), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agPortNewCfgBroadcastThresholdRate.setStatus('current')
if mibBuilder.loadTexts: agPortNewCfgBroadcastThresholdRate.setDescription("New port's Broadcast Threshold Rate.")
agPortNewCfgDLFThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 2, 3, 1, 46), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agPortNewCfgDLFThreshold.setStatus('current')
if mibBuilder.loadTexts: agPortNewCfgDLFThreshold.setDescription("New status of the port's Destination Lookup Fail Threshold.")
agPortNewCfgDLFThresholdRate = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 2, 3, 1, 47), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agPortNewCfgDLFThresholdRate.setStatus('current')
if mibBuilder.loadTexts: agPortNewCfgDLFThresholdRate.setDescription("New port's Destination Lookup Fail Threshold Rate.")
agPortNewCfgMacAddrNotif = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 2, 3, 1, 48), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("enabled", 2), ("disabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agPortNewCfgMacAddrNotif.setStatus('current')
if mibBuilder.loadTexts: agPortNewCfgMacAddrNotif.setDescription('Enables or Disables the MAC address notification syslog messages on the port.')
agPortNewCfgStpExtGuard = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 2, 3, 1, 52), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 0))).clone(namedValues=NamedValues(("loop", 1), ("root", 2), ("none", 3), ("default", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agPortNewCfgStpExtGuard.setStatus('current')
if mibBuilder.loadTexts: agPortNewCfgStpExtGuard.setDescription('Set spanning tree guard type')
agPortNewCfgLFDStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 2, 3, 1, 53), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agPortNewCfgLFDStatus.setStatus('current')
if mibBuilder.loadTexts: agPortNewCfgLFDStatus.setDescription('This object indicates whether the system should put this port in an error-disabled state due to excessive link flaps. Use this object to change the port setting of the Link Flap Dampening error-disable action.')
sshCurCfgScpAdm = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 22, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sshCurCfgScpAdm.setStatus('current')
if mibBuilder.loadTexts: sshCurCfgScpAdm.setDescription('SCP-only admin password.')
sshNewCfgScpAdm = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 22, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sshNewCfgScpAdm.setStatus('current')
if mibBuilder.loadTexts: sshNewCfgScpAdm.setDescription('Set SCP-only admin password.')
sshNewCfgHKeyGen = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 22, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("generate", 1), ("other", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sshNewCfgHKeyGen.setStatus('current')
if mibBuilder.loadTexts: sshNewCfgHKeyGen.setDescription('This is an action object to generate the RSA host key. other(2) is returned always when read. The following values are writable: generate(1).. Generate the RSA host key.')
sshCurCfgSSHPort = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 22, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sshCurCfgSSHPort.setStatus('current')
if mibBuilder.loadTexts: sshCurCfgSSHPort.setDescription('SSH server port number.')
sshNewCfgSSHPort = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 22, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sshNewCfgSSHPort.setStatus('current')
if mibBuilder.loadTexts: sshNewCfgSSHPort.setDescription('Set SSH server port number.')
sshCurCfgScpApplySave = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 22, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sshCurCfgScpApplySave.setStatus('current')
if mibBuilder.loadTexts: sshCurCfgScpApplySave.setDescription('SCP apply and save.')
sshNewCfgScpApplySave = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 22, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sshNewCfgScpApplySave.setStatus('current')
if mibBuilder.loadTexts: sshNewCfgScpApplySave.setDescription('Enable/Disable the SCP apply and save.')
sshCurCfgStatus = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 22, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sshCurCfgStatus.setStatus('current')
if mibBuilder.loadTexts: sshCurCfgStatus.setDescription('SSH server status.')
sshNewCfgStatus = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 22, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sshNewCfgStatus.setStatus('current')
if mibBuilder.loadTexts: sshNewCfgStatus.setDescription('Turn SSH server ON/OFF.')
radCurCfgPrimaryServer = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 3, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radCurCfgPrimaryServer.setStatus('current')
if mibBuilder.loadTexts: radCurCfgPrimaryServer.setDescription('The IP address of the Primary RADIUS server.')
radNewCfgPrimaryServer = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 3, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radNewCfgPrimaryServer.setStatus('current')
if mibBuilder.loadTexts: radNewCfgPrimaryServer.setDescription('The IP address of the Primary RADIUS server.')
radCurCfgSecondaryServer = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 3, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radCurCfgSecondaryServer.setStatus('current')
if mibBuilder.loadTexts: radCurCfgSecondaryServer.setDescription('The IP address of the Secondary RADIUS server.')
radNewCfgSecondaryServer = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 3, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radNewCfgSecondaryServer.setStatus('current')
if mibBuilder.loadTexts: radNewCfgSecondaryServer.setDescription('The IP address of the Secondary RADIUS server.')
radCurCfgPort = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 3, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1500, 3000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: radCurCfgPort.setStatus('current')
if mibBuilder.loadTexts: radCurCfgPort.setDescription('Specify the RADIUS port number.')
radNewCfgPort = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 3, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1500, 3000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radNewCfgPort.setStatus('current')
if mibBuilder.loadTexts: radNewCfgPort.setDescription('Specify the RADIUS port number.')
radCurCfgTimeout = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 3, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: radCurCfgTimeout.setStatus('current')
if mibBuilder.loadTexts: radCurCfgTimeout.setDescription('The maximum number of seconds before resending authentication to RADIUS server.')
radNewCfgTimeout = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 3, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radNewCfgTimeout.setStatus('current')
if mibBuilder.loadTexts: radNewCfgTimeout.setDescription('The maximum number of seconds before resending authentication to RADIUS server.')
radCurCfgRetries = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 3, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: radCurCfgRetries.setStatus('current')
if mibBuilder.loadTexts: radCurCfgRetries.setDescription('Number of retries to the RADIUS server.')
radNewCfgRetries = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 3, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radNewCfgRetries.setStatus('current')
if mibBuilder.loadTexts: radNewCfgRetries.setDescription('Number of retries to the RADIUS server.')
radCurCfgState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 3, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 0))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 0)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: radCurCfgState.setStatus('current')
if mibBuilder.loadTexts: radCurCfgState.setDescription('Enable or disable RADIUS authentication.')
radNewCfgState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 3, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 0))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radNewCfgState.setStatus('current')
if mibBuilder.loadTexts: radNewCfgState.setDescription('Enable or disable RADIUS authentication.')
radCurCfgAuthenString = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 3, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: radCurCfgAuthenString.setStatus('current')
if mibBuilder.loadTexts: radCurCfgAuthenString.setDescription('The RADIUS authentication string.')
radNewCfgAuthenString = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 3, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radNewCfgAuthenString.setStatus('current')
if mibBuilder.loadTexts: radNewCfgAuthenString.setDescription('The RADIUS authentication string.')
radCurCfgBackdoor = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 3, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: radCurCfgBackdoor.setStatus('current')
if mibBuilder.loadTexts: radCurCfgBackdoor.setDescription('Enable or disable RADIUS backdoor for telnet/ssh/http/https.')
radNewCfgBackdoor = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 3, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radNewCfgBackdoor.setStatus('current')
if mibBuilder.loadTexts: radNewCfgBackdoor.setDescription('Enable or disable RADIUS backdoor for telnet/ssh/http/https.')
radCurCfgAuthenSecondString = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 3, 17), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: radCurCfgAuthenSecondString.setStatus('current')
if mibBuilder.loadTexts: radCurCfgAuthenSecondString.setDescription('The second RADIUS authentication string.')
radNewCfgAuthenSecondString = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 3, 18), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radNewCfgAuthenSecondString.setStatus('current')
if mibBuilder.loadTexts: radNewCfgAuthenSecondString.setDescription('The second RADIUS authentication string.')
radCurCfgSecBd = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 3, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: radCurCfgSecBd.setStatus('current')
if mibBuilder.loadTexts: radCurCfgSecBd.setDescription('Enable or disable RADIUS secure backdoor for telnet.')
radNewCfgSecBd = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 3, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radNewCfgSecBd.setStatus('current')
if mibBuilder.loadTexts: radNewCfgSecBd.setDescription('Enable or disable RADIUS secure backdoor for telnet.')
radCurCfgPorttoUse = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 3, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("data", 1), ("mgta", 2), ("mgtb", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: radCurCfgPorttoUse.setStatus('current')
if mibBuilder.loadTexts: radCurCfgPorttoUse.setDescription('Specify whether the Radius should be performed over the data port or the management port.')
radNewCfgPorttoUse = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 3, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("data", 1), ("mgta", 2), ("mgtb", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radNewCfgPorttoUse.setStatus('current')
if mibBuilder.loadTexts: radNewCfgPorttoUse.setDescription('Specify whether the Radius should be performed over the data port or the management port.')
radCurCfgSecPorttoUse = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 3, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("data", 1), ("mgta", 2), ("mgtb", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: radCurCfgSecPorttoUse.setStatus('current')
if mibBuilder.loadTexts: radCurCfgSecPorttoUse.setDescription('Specify whether the Radius should be performed over the data port or the management port.')
radNewCfgSecPorttoUse = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 3, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("data", 1), ("mgta", 2), ("mgtb", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radNewCfgSecPorttoUse.setStatus('current')
if mibBuilder.loadTexts: radNewCfgSecPorttoUse.setDescription('Specify whether the Radius should be performed over the data port or the management port.')
radCurCfgSrcLoopIf = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 3, 25), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radCurCfgSrcLoopIf.setStatus('current')
if mibBuilder.loadTexts: radCurCfgSrcLoopIf.setDescription('The index of the loopback interface that should be used for the source IP of the Radius message; 0 means that no loopback interface is used as the source of the Radius message.')
radNewCfgSrcLoopIf = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 3, 26), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radNewCfgSrcLoopIf.setStatus('current')
if mibBuilder.loadTexts: radNewCfgSrcLoopIf.setDescription('The index of the loopback interface that should be used for the source IP of the Radius message; 0 means that no loopback interface is used as the source of the Radius message.')
agCurCfgNTPServer = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 4, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 46))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgNTPServer.setStatus('current')
if mibBuilder.loadTexts: agCurCfgNTPServer.setDescription('The NTP Server Address.')
agNewCfgNTPServer = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 4, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 46))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgNTPServer.setStatus('current')
if mibBuilder.loadTexts: agNewCfgNTPServer.setDescription('The NTP Server Address.')
agCurCfgNTPResyncInterval = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 4, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 44640))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgNTPResyncInterval.setStatus('current')
if mibBuilder.loadTexts: agCurCfgNTPResyncInterval.setDescription('The NTP Server resync interval in minutes.')
agNewCfgNTPResyncInterval = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 4, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 44640))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgNTPResyncInterval.setStatus('current')
if mibBuilder.loadTexts: agNewCfgNTPResyncInterval.setDescription('The NTP Server resync interval in minutes.')
agCurCfgNTPService = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 4, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgNTPService.setStatus('current')
if mibBuilder.loadTexts: agCurCfgNTPService.setDescription('Enable/disable NTP Service.')
agNewCfgNTPService = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 4, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgNTPService.setStatus('current')
if mibBuilder.loadTexts: agNewCfgNTPService.setDescription('Enable/disable NTP Service.')
agCurCfgNTPSecServer = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 4, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 46))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgNTPSecServer.setStatus('current')
if mibBuilder.loadTexts: agCurCfgNTPSecServer.setDescription('The Secondary NTP Server Address.')
agNewCfgNTPSecServer = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 4, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 46))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgNTPSecServer.setStatus('current')
if mibBuilder.loadTexts: agNewCfgNTPSecServer.setDescription('The Secondary NTP Server Address.')
agCurCfgNTPServerPort = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 4, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("data", 1), ("mgta", 2), ("mgtb", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgNTPServerPort.setStatus('current')
if mibBuilder.loadTexts: agCurCfgNTPServerPort.setDescription('Choose the port that the primary server is connected to.')
agNewCfgNTPServerPort = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 4, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("data", 1), ("mgta", 2), ("mgtb", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgNTPServerPort.setStatus('current')
if mibBuilder.loadTexts: agNewCfgNTPServerPort.setDescription('Choose the port that the primary server is connected to.')
agCurCfgNTPSecServerPort = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 4, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("data", 1), ("mgta", 2), ("mgtb", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgNTPSecServerPort.setStatus('current')
if mibBuilder.loadTexts: agCurCfgNTPSecServerPort.setDescription('Choose the port that the secondary server is connected to.')
agNewCfgNTPSecServerPort = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 4, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("data", 1), ("mgta", 2), ("mgtb", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgNTPSecServerPort.setStatus('current')
if mibBuilder.loadTexts: agNewCfgNTPSecServerPort.setDescription('Choose the port that the secondary server is connected to.')
agCurCfgNTPSrcLoopIf = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 4, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgNTPSrcLoopIf.setStatus('current')
if mibBuilder.loadTexts: agCurCfgNTPSrcLoopIf.setDescription('The index of the loopback interface that should be used for the source IP of the NTP packet; 0 means that no loopback interface is used as the source of the NTP packet.')
agNewCfgNTPSrcLoopIf = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 4, 18), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agNewCfgNTPSrcLoopIf.setStatus('current')
if mibBuilder.loadTexts: agNewCfgNTPSrcLoopIf.setDescription('The index of the loopback interface that should be used for the source IP of the NTP packet; 0 means that no loopback interface is used as the source of the NTP packet.')
agApplyPending = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 8, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("applyNeeded", 2), ("noApplyNeeded", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agApplyPending.setStatus('current')
if mibBuilder.loadTexts: agApplyPending.setDescription('This object, when read, gives the user information whether an apply action is needed and that the configuration has been chaged by the user actions. The user then can apply the changes by setting proper value to the object agApplyConfiguration described above.')
agApplyConfig = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 8, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("apply", 1), ("idle", 2), ("inprogress", 3), ("complete", 4), ("failed", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agApplyConfig.setStatus('current')
if mibBuilder.loadTexts: agApplyConfig.setDescription("When this object is read the current state is returned. idle(1) indicates that there is no apply in progess. complete(4) indicates that the last apply operation is completed. Setting the value to apply(1), will write all the changes made since the last apply to the current configuration block. If the apply is successful this variable will return the state 'complete' else it will return 'failed'. In case of failure, to read the reason for failure use the agApplyTable. Once the operation is completed or the agApplyTable is read in case of failure, the apply buffer needs to be freed and the agApplyState should be set back to 'idle' state so others can issue the apply command via SNMP.")
agApplyTableSize = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 8, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agApplyTableSize.setStatus('current')
if mibBuilder.loadTexts: agApplyTableSize.setDescription('The number of strings in the apply table.')
agApplyTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 8, 5), )
if mibBuilder.loadTexts: agApplyTable.setStatus('current')
if mibBuilder.loadTexts: agApplyTable.setDescription('The table of failure reasons for an apply of current configuration block changes.')
agApplyTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 8, 5, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "agApplyIndex"))
if mibBuilder.loadTexts: agApplyTableEntry.setStatus('current')
if mibBuilder.loadTexts: agApplyTableEntry.setDescription('A row in the table of failure reasons for an apply (information about a particular reason of failure).')
agApplyIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 8, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agApplyIndex.setStatus('current')
if mibBuilder.loadTexts: agApplyIndex.setDescription('The table index.')
agApplyString = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 8, 5, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agApplyString.setStatus('current')
if mibBuilder.loadTexts: agApplyString.setDescription('A string in the apply table.')
tacCurCfgPrimaryServer = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 11, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tacCurCfgPrimaryServer.setStatus('current')
if mibBuilder.loadTexts: tacCurCfgPrimaryServer.setDescription('The IP address of the Primary TACACS+ server.')
tacNewCfgPrimaryServer = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 11, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tacNewCfgPrimaryServer.setStatus('current')
if mibBuilder.loadTexts: tacNewCfgPrimaryServer.setDescription('The IP address of the Primary TACACS+ server.')
tacCurCfgSecondaryServer = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 11, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tacCurCfgSecondaryServer.setStatus('current')
if mibBuilder.loadTexts: tacCurCfgSecondaryServer.setDescription('The IP address of the Secondary TACACS+ server.')
tacNewCfgSecondaryServer = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 11, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tacNewCfgSecondaryServer.setStatus('current')
if mibBuilder.loadTexts: tacNewCfgSecondaryServer.setDescription('The IP address of the Secondary TACACS+ server.')
tacCurCfgPort = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 11, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tacCurCfgPort.setStatus('current')
if mibBuilder.loadTexts: tacCurCfgPort.setDescription('Specify the TACACS+ port number.')
tacNewCfgPort = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 11, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tacNewCfgPort.setStatus('current')
if mibBuilder.loadTexts: tacNewCfgPort.setDescription('Specify the TACACS+ port number.')
tacCurCfgTimeout = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 11, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(4, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tacCurCfgTimeout.setStatus('current')
if mibBuilder.loadTexts: tacCurCfgTimeout.setDescription('The maximum number of seconds before resending authentication to TACACS+ server.')
tacNewCfgTimeout = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 11, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(4, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tacNewCfgTimeout.setStatus('current')
if mibBuilder.loadTexts: tacNewCfgTimeout.setDescription('The maximum number of seconds before resending authentication to TACACS+ server.')
tacCurCfgRetries = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 11, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tacCurCfgRetries.setStatus('current')
if mibBuilder.loadTexts: tacCurCfgRetries.setDescription('Number of retries to the TACACS+ server.')
tacNewCfgRetries = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 11, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tacNewCfgRetries.setStatus('current')
if mibBuilder.loadTexts: tacNewCfgRetries.setDescription('Number of retries to the TACACS+ server.')
tacCurCfgState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 11, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 0))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 0)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tacCurCfgState.setStatus('current')
if mibBuilder.loadTexts: tacCurCfgState.setDescription('Enable or disable TACACS+ authentication.')
tacNewCfgState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 11, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 0))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tacNewCfgState.setStatus('current')
if mibBuilder.loadTexts: tacNewCfgState.setDescription('Enable or disable TACACS+ authentication.')
tacCurCfgAuthenString = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 11, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tacCurCfgAuthenString.setStatus('current')
if mibBuilder.loadTexts: tacCurCfgAuthenString.setDescription('The TACACS+ authentication string.')
tacNewCfgAuthenString = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 11, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tacNewCfgAuthenString.setStatus('current')
if mibBuilder.loadTexts: tacNewCfgAuthenString.setDescription('The TACACS+ authentication string.')
tacCurCfgBackdoor = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 11, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tacCurCfgBackdoor.setStatus('current')
if mibBuilder.loadTexts: tacCurCfgBackdoor.setDescription('Enable or disable TACACS+ backdoor for telnet/ssh/http/https.')
tacNewCfgBackdoor = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 11, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tacNewCfgBackdoor.setStatus('current')
if mibBuilder.loadTexts: tacNewCfgBackdoor.setDescription('Enable or disable TACACS+ backdoor for telnet/ssh/http/https.')
tacCurCfgAuthenSecondString = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 11, 17), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tacCurCfgAuthenSecondString.setStatus('current')
if mibBuilder.loadTexts: tacCurCfgAuthenSecondString.setDescription('The second TACACS+ authentication string.')
tacNewCfgAuthenSecondString = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 11, 18), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tacNewCfgAuthenSecondString.setStatus('current')
if mibBuilder.loadTexts: tacNewCfgAuthenSecondString.setDescription('The second TACACS+ authentication string.')
tacCurCfgCmdAuthor = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 11, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tacCurCfgCmdAuthor.setStatus('current')
if mibBuilder.loadTexts: tacCurCfgCmdAuthor.setDescription('Enable or disable TACACS+ command authorization.')
tacNewCfgCmdAuthor = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 11, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tacNewCfgCmdAuthor.setStatus('current')
if mibBuilder.loadTexts: tacNewCfgCmdAuthor.setDescription('Enable or disable TACACS+ command authorization.')
tacCurCfgCmdLogging = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 11, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tacCurCfgCmdLogging.setStatus('current')
if mibBuilder.loadTexts: tacCurCfgCmdLogging.setDescription('Enable or disable TACACS+ command logging.')
tacNewCfgCmdLogging = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 11, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tacNewCfgCmdLogging.setStatus('current')
if mibBuilder.loadTexts: tacNewCfgCmdLogging.setDescription('Enable or disable TACACS+ command logging.')
tacCurCfgSecBd = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 11, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tacCurCfgSecBd.setStatus('current')
if mibBuilder.loadTexts: tacCurCfgSecBd.setDescription('Enable or disable TACACS+ secure backdoor for telnet.')
tacNewCfgSecBd = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 11, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tacNewCfgSecBd.setStatus('current')
if mibBuilder.loadTexts: tacNewCfgSecBd.setDescription('Enable or disable TACACS+ secure backdoor for telnet.')
tacCurCfgCmap = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 11, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tacCurCfgCmap.setStatus('current')
if mibBuilder.loadTexts: tacCurCfgCmap.setDescription('Enable/Disable Tacacs+ new privilege level mapping, as configured in the current configuration block.')
tacNewCfgCmap = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 11, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tacNewCfgCmap.setStatus('current')
if mibBuilder.loadTexts: tacNewCfgCmap.setDescription('Enable/Disable Tacacs+ new privilege level mapping.')
tacCurCfgEnaPassChange = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 11, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tacCurCfgEnaPassChange.setStatus('current')
if mibBuilder.loadTexts: tacCurCfgEnaPassChange.setDescription(' Enable/Disable Tacacs+ password change.')
tacNewCfgEnaPassChange = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 11, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tacNewCfgEnaPassChange.setStatus('current')
if mibBuilder.loadTexts: tacNewCfgEnaPassChange.setDescription(' Enable/Disable Tacacs+ password change.')
tacChangePassForUser = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 11, 31), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tacChangePassForUser.setStatus('current')
if mibBuilder.loadTexts: tacChangePassForUser.setDescription('The username for changing server password.')
tacChangePassCurPass = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 11, 32), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tacChangePassCurPass.setStatus('current')
if mibBuilder.loadTexts: tacChangePassCurPass.setDescription('The current password for tacacs server.')
tacChangePassNewPass = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 11, 33), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tacChangePassNewPass.setStatus('current')
if mibBuilder.loadTexts: tacChangePassNewPass.setDescription('The new password for tacacs server.')
tacChangePassForServer = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 11, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("primary", 1), ("secondary", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tacChangePassForServer.setStatus('current')
if mibBuilder.loadTexts: tacChangePassForServer.setDescription('Change password for <1/2> Tacacs+ server.')
tacCurCfgPorttoUse = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 11, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("data", 1), ("mgta", 2), ("mgtb", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tacCurCfgPorttoUse.setStatus('current')
if mibBuilder.loadTexts: tacCurCfgPorttoUse.setDescription('Specify whether the Tacacs should be performed over the data port or the management port.')
tacNewCfgPorttoUse = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 11, 36), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("data", 1), ("mgta", 2), ("mgtb", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tacNewCfgPorttoUse.setStatus('current')
if mibBuilder.loadTexts: tacNewCfgPorttoUse.setDescription('Specify whether the Tacacs should be performed over the data port or the management port.')
tacCurCfgSecPorttoUse = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 11, 37), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("data", 1), ("mgta", 2), ("mgtb", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tacCurCfgSecPorttoUse.setStatus('current')
if mibBuilder.loadTexts: tacCurCfgSecPorttoUse.setDescription('Specify whether the Tacacs should be performed over the data port or the management port.')
tacNewCfgSecPorttoUse = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 11, 38), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("data", 1), ("mgta", 2), ("mgtb", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tacNewCfgSecPorttoUse.setStatus('current')
if mibBuilder.loadTexts: tacNewCfgSecPorttoUse.setDescription('Specify whether the Tacacs should be performed over the data port or the management port.')
agTacacsUserMapCurCfgTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 11, 39), )
if mibBuilder.loadTexts: agTacacsUserMapCurCfgTable.setStatus('current')
if mibBuilder.loadTexts: agTacacsUserMapCurCfgTable.setDescription('The table of tacacs+ user map current configuration.')
agTacacsUserMapCurCfgTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 11, 39, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "agTacacsUserMapCurCfgUId"))
if mibBuilder.loadTexts: agTacacsUserMapCurCfgTableEntry.setStatus('current')
if mibBuilder.loadTexts: agTacacsUserMapCurCfgTableEntry.setDescription('A row in the tacacs+ user mapping table.')
agTacacsUserMapCurCfgUId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 11, 39, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agTacacsUserMapCurCfgUId.setStatus('current')
if mibBuilder.loadTexts: agTacacsUserMapCurCfgUId.setDescription('The current config remote privilege identifier. The identifier value corresponds to the remote privilege.')
agTacacsUserMapCurCfgMapping = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 11, 39, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("none", 0), ("user", 1), ("oper", 2), ("admin", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agTacacsUserMapCurCfgMapping.setStatus('current')
if mibBuilder.loadTexts: agTacacsUserMapCurCfgMapping.setDescription('Current Tacacs+ user privilege mappings. The correspondence between the local privilege and the remote privilege is: - The remote privilege is the privilege identifier value - The local privilege is the mapped value(user, oper, admin) Example: For the remote privilege 15, we have the index 16: agTacacsUserMapCurCfgUId.16 = 15.')
agTacacsUserMapNewCfgTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 11, 40), )
if mibBuilder.loadTexts: agTacacsUserMapNewCfgTable.setStatus('current')
if mibBuilder.loadTexts: agTacacsUserMapNewCfgTable.setDescription('The table of tacacs+ user map new configuration.')
tacNewCfgDirectedRequest = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 11, 41), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disabled", 1), ("restricted", 2), ("no-truncate", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tacNewCfgDirectedRequest.setStatus('current')
if mibBuilder.loadTexts: tacNewCfgDirectedRequest.setDescription('Enable/Disable tacacs directed request.')
tacCurCfgDirectedRequest = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 11, 42), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disabled", 1), ("restricted", 2), ("no-truncate", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tacCurCfgDirectedRequest.setStatus('current')
if mibBuilder.loadTexts: tacCurCfgDirectedRequest.setDescription('The current tacacs directed request state.')
agTacacsUserMapNewCfgTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 11, 40, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "agTacacsUserMapNewCfgUId"))
if mibBuilder.loadTexts: agTacacsUserMapNewCfgTableEntry.setStatus('current')
if mibBuilder.loadTexts: agTacacsUserMapNewCfgTableEntry.setDescription('A row in the tacacs+ user mapping table.')
agTacacsUserMapNewCfgUId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 11, 40, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agTacacsUserMapNewCfgUId.setStatus('current')
if mibBuilder.loadTexts: agTacacsUserMapNewCfgUId.setDescription('The new config remote privilege identifier. The identifier value corresponds to the remote privilege.')
agTacacsUserMapNewCfgMapping = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 11, 40, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("none", 0), ("user", 1), ("oper", 2), ("admin", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: agTacacsUserMapNewCfgMapping.setStatus('current')
if mibBuilder.loadTexts: agTacacsUserMapNewCfgMapping.setDescription('Set new Tacacs+ user privilege mappings. The correspondence between the local privilege and the remote privilege is: - The remote privilege is the privilege identifier value - The local privilege is the mapped value(user, oper, admin) Example: For the remote privilege 15, we have the index 16: agTacacsUserMapNewCfgUId.16 = 15.')
tacCurCfgAttempts = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 11, 43), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tacCurCfgAttempts.setStatus('current')
if mibBuilder.loadTexts: tacCurCfgAttempts.setDescription('Number of login attempts to the TACACS+ server.')
tacNewCfgAttempts = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 11, 44), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tacNewCfgAttempts.setStatus('current')
if mibBuilder.loadTexts: tacNewCfgAttempts.setDescription('Number of login attempts to the TACACS+ server.')
tacCurBypassEnable = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 11, 45), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1))).clone('enable')).setMaxAccess("readonly")
if mibBuilder.loadTexts: tacCurBypassEnable.setStatus('current')
if mibBuilder.loadTexts: tacCurBypassEnable.setDescription('Status of the enable bypass.If the status of this object is enabled, user authenticated via TACACS+ with admin previllage is granted enable previllage access.If disabled, admin users will be provided with enable previllage access based on enable password configured.')
tacNewBypassEnable = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 11, 46), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tacNewBypassEnable.setStatus('current')
if mibBuilder.loadTexts: tacNewBypassEnable.setDescription('Status of the enable bypass.If the status of this object is enabled, user authenticated via TACACS+ with admin previllage is granted enable previllage access.If disabled, admin users will be provided with enable previllage access based on enable password configured.')
tacCurCfgEnableAccounting = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 11, 47), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 0))).clone(namedValues=NamedValues(("enable", 1), ("disable", 0)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tacCurCfgEnableAccounting.setStatus('current')
if mibBuilder.loadTexts: tacCurCfgEnableAccounting.setDescription(' Current TACACS+ accounting state.')
tacNewCfgEnableAccounting = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 11, 48), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 0))).clone(namedValues=NamedValues(("enable", 1), ("disable", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tacNewCfgEnableAccounting.setStatus('current')
if mibBuilder.loadTexts: tacNewCfgEnableAccounting.setDescription(' Enable/Disable TACACS+ accounting.')
tacCurCfgSrcLoopIf = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 11, 49), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tacCurCfgSrcLoopIf.setStatus('current')
if mibBuilder.loadTexts: tacCurCfgSrcLoopIf.setDescription('The index of the loopback interface that should be used for the source IP of the Tacacs+ message; 0 means that no loopback interface is used as the source of the Tacacs+ message.')
tacNewCfgSrcLoopIf = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 11, 50), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tacNewCfgSrcLoopIf.setStatus('current')
if mibBuilder.loadTexts: tacNewCfgSrcLoopIf.setDescription('The index of the loopback interface that should be used for the source IP of the Tacacs+ message; 0 means that no loopback interface is used as the source of the Tacacs+ message.')
agMgmtNetTableMaxSize = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 12, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agMgmtNetTableMaxSize.setStatus('current')
if mibBuilder.loadTexts: agMgmtNetTableMaxSize.setDescription('The maximum number of entries in the Management Network Table.')
agCurCfgMgmtNetTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 12, 2), )
if mibBuilder.loadTexts: agCurCfgMgmtNetTable.setStatus('current')
if mibBuilder.loadTexts: agCurCfgMgmtNetTable.setDescription('The table for Management Network definitions in the current configuration block.')
agCurCfgMgmtNetEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 12, 2, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "agCurCfgMgmtNetIndex"))
if mibBuilder.loadTexts: agCurCfgMgmtNetEntry.setStatus('current')
if mibBuilder.loadTexts: agCurCfgMgmtNetEntry.setDescription('A row in the management network definition table.')
agCurCfgMgmtNetIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 12, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgMgmtNetIndex.setStatus('current')
if mibBuilder.loadTexts: agCurCfgMgmtNetIndex.setDescription('The index of the Management Network Definition table.')
agCurCfgMgmtNetSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 12, 2, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgMgmtNetSubnet.setStatus('current')
if mibBuilder.loadTexts: agCurCfgMgmtNetSubnet.setDescription('The Management Network Address in the current configuration block.')
agCurCfgMgmtNetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 12, 2, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCurCfgMgmtNetMask.setStatus('current')
if mibBuilder.loadTexts: agCurCfgMgmtNetMask.setDescription('The Management Network Mask/Prefix Length in the current configuration block.')
agNewCfgMgmtNetTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 12, 3), )
if mibBuilder.loadTexts: agNewCfgMgmtNetTable.setStatus('current')
if mibBuilder.loadTexts: agNewCfgMgmtNetTable.setDescription('The table for Management Network definitions in the new configuration block.')
agNewCfgMgmtNetEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 12, 3, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "agNewCfgMgmtNetIndex"))
if mibBuilder.loadTexts: agNewCfgMgmtNetEntry.setStatus('current')
if mibBuilder.loadTexts: agNewCfgMgmtNetEntry.setDescription('A row in the management network definition table.')
agNewCfgMgmtNetIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 12, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agNewCfgMgmtNetIndex.setStatus('current')
if mibBuilder.loadTexts: agNewCfgMgmtNetIndex.setDescription('The index of the Management Network Definition table.')
agNewCfgMgmtNetSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 12, 3, 1, 2), DisplayString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: agNewCfgMgmtNetSubnet.setStatus('current')
if mibBuilder.loadTexts: agNewCfgMgmtNetSubnet.setDescription('The Management Network Address in the new configuration block.')
agNewCfgMgmtNetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 12, 3, 1, 3), DisplayString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: agNewCfgMgmtNetMask.setStatus('current')
if mibBuilder.loadTexts: agNewCfgMgmtNetMask.setDescription('The Management Network Mask/Prefix length in the new configuration block.')
agNewCfgMgmtNetDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 12, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("delete", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: agNewCfgMgmtNetDelete.setStatus('current')
if mibBuilder.loadTexts: agNewCfgMgmtNetDelete.setDescription('By setting the value to delete(2), the entire row is deleted.')
agMgmtNetClear = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 12, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("clear", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agMgmtNetClear.setStatus('current')
if mibBuilder.loadTexts: agMgmtNetClear.setDescription('By setting the value to delete(2), the entire table is cleared.')
agCfgBootResetParameters = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 13, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agCfgBootResetParameters.setStatus('current')
if mibBuilder.loadTexts: agCfgBootResetParameters.setDescription("String formatated as 'weekday hour minute' where - weekday is none(0),sunday(1),monday(2), tuesday(3),wednesday(4),thursday(5),friday(6), saturday(7) - hour is the hour in 24-hour format for reboot - minutes are the minutes [00] for reboot")
agCfgBootReset = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 13, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("none", 1), ("cancel", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agCfgBootReset.setStatus('current')
if mibBuilder.loadTexts: agCfgBootReset.setDescription('Cancel pending switch reset.')
agCfgBootNxtResetTime = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 13, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCfgBootNxtResetTime.setStatus('current')
if mibBuilder.loadTexts: agCfgBootNxtResetTime.setDescription('Display the next scheduled reboot time.')
agCfgBootPendingReset = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 13, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("idle", 1), ("pending", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCfgBootPendingReset.setStatus('current')
if mibBuilder.loadTexts: agCfgBootPendingReset.setDescription('Shows if there is any pending reboot scheduled. You should cancel any pending reboot scheduled before setting another.')
agAccessUserMaxUserID = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 19, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agAccessUserMaxUserID.setStatus('current')
if mibBuilder.loadTexts: agAccessUserMaxUserID.setDescription('The maximum number of User IDs.')
agAccessCurStrongPassword = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 19, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 0))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 0)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agAccessCurStrongPassword.setStatus('current')
if mibBuilder.loadTexts: agAccessCurStrongPassword.setDescription('Status of strong password.')
agAccessNewStrongPassword = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 19, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 0))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agAccessNewStrongPassword.setStatus('current')
if mibBuilder.loadTexts: agAccessNewStrongPassword.setDescription('Setting this value to enabled(1) enables strong password support, while disabled(0) disables it.')
agAccessCurStrongPassValidity = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 19, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 365))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agAccessCurStrongPassValidity.setStatus('current')
if mibBuilder.loadTexts: agAccessCurStrongPassValidity.setDescription('Password validity in days.')
agAccessNewStrongPassValidity = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 19, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 365))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agAccessNewStrongPassValidity.setStatus('current')
if mibBuilder.loadTexts: agAccessNewStrongPassValidity.setDescription('Get or set password validity in days.')
agAccessCurStrongPassWarning = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 19, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 365))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agAccessCurStrongPassWarning.setStatus('current')
if mibBuilder.loadTexts: agAccessCurStrongPassWarning.setDescription('Warning days before password expires.')
agAccessNewStrongPassWarning = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 19, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 365))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agAccessNewStrongPassWarning.setStatus('current')
if mibBuilder.loadTexts: agAccessNewStrongPassWarning.setDescription('Get or set warning days before password expires.')
agAccessCurStrongPassFailLog = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 19, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agAccessCurStrongPassFailLog.setStatus('current')
if mibBuilder.loadTexts: agAccessCurStrongPassFailLog.setDescription('Number of failed logins that trigger security notifications.')
agAccessNewStrongPassFailLog = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 19, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agAccessNewStrongPassFailLog.setStatus('current')
if mibBuilder.loadTexts: agAccessNewStrongPassFailLog.setDescription('Get or set number of failed logins that trigger security notifications.')
agAccessCurDefaultAdmin = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 19, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 0))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 0)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agAccessCurDefaultAdmin.setStatus('current')
if mibBuilder.loadTexts: agAccessCurDefaultAdmin.setDescription('Get default admin account state. (1) indicates enabled and (0) indicates disabled (0). Default it is enabled.')
agAccessNewDefaultAdmin = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 19, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 0))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agAccessNewDefaultAdmin.setStatus('current')
if mibBuilder.loadTexts: agAccessNewDefaultAdmin.setDescription('Setting this value to enabled (1) will enable the default admin account while disabled (0) will disable the default admin account. Default it is enabled.')
agAccessCurStrongPassLockout = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 19, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 0))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 0)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agAccessCurStrongPassLockout.setStatus('current')
if mibBuilder.loadTexts: agAccessCurStrongPassLockout.setDescription('Status of Lockout')
agAccessNewStrongPassLockout = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 19, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 0))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agAccessNewStrongPassLockout.setStatus('current')
if mibBuilder.loadTexts: agAccessNewStrongPassLockout.setDescription('Setting this value to enabled (1) enables account locking after trying for failed login attempts. While disabled (0) disables account locking.')
agAccessCurStrongPassAttemptsMaxFail = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 19, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agAccessCurStrongPassAttemptsMaxFail.setStatus('current')
if mibBuilder.loadTexts: agAccessCurStrongPassAttemptsMaxFail.setDescription('The max number of failed logins before disabling account. Default value is 6')
agAccessNewStrongPassAttemptsMaxFail = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 19, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agAccessNewStrongPassAttemptsMaxFail.setStatus('current')
if mibBuilder.loadTexts: agAccessNewStrongPassAttemptsMaxFail.setDescription('Sets Max number of failed logins before disabling account. Default value is 6')
agAccessUserCurCfgTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 19, 2), )
if mibBuilder.loadTexts: agAccessUserCurCfgTable.setStatus('current')
if mibBuilder.loadTexts: agAccessUserCurCfgTable.setDescription('The table of Access user configuration.')
agAccessUserCurCfgTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 19, 2, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "agAccessUserCurCfgUId"))
if mibBuilder.loadTexts: agAccessUserCurCfgTableEntry.setStatus('current')
if mibBuilder.loadTexts: agAccessUserCurCfgTableEntry.setDescription('A row in the Access user configuration table.')
agAccessUserCurCfgUId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 19, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agAccessUserCurCfgUId.setStatus('current')
if mibBuilder.loadTexts: agAccessUserCurCfgUId.setDescription('The User identifier.')
agAccessUserCurCos = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 19, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 3, 6))).clone(namedValues=NamedValues(("user", 0), ("oper", 3), ("admin", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agAccessUserCurCos.setStatus('current')
if mibBuilder.loadTexts: agAccessUserCurCos.setDescription('The user class of service.')
agAccessUserCurCfgName = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 19, 2, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agAccessUserCurCfgName.setStatus('current')
if mibBuilder.loadTexts: agAccessUserCurCfgName.setDescription('The user name. Please note, the max length is 8 in stacking mode.')
agAccessUserCurCfgPswd = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 19, 2, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agAccessUserCurCfgPswd.setStatus('current')
if mibBuilder.loadTexts: agAccessUserCurCfgPswd.setDescription('The character string representing the user password.')
agAccessUserCurCfgState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 19, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("enabled", 2), ("disabled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agAccessUserCurCfgState.setStatus('current')
if mibBuilder.loadTexts: agAccessUserCurCfgState.setDescription('User validation (enabled or disabled) in current configuration block.')
agAccessUserNewCfgTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 19, 3), )
if mibBuilder.loadTexts: agAccessUserNewCfgTable.setStatus('current')
if mibBuilder.loadTexts: agAccessUserNewCfgTable.setDescription('The table of Access user configuration.')
agAccessUserNewCfgTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 19, 3, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "agAccessUserNewCfgUId"))
if mibBuilder.loadTexts: agAccessUserNewCfgTableEntry.setStatus('current')
if mibBuilder.loadTexts: agAccessUserNewCfgTableEntry.setDescription('A row in the Access user configuration table.')
agAccessUserNewCfgUId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 19, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agAccessUserNewCfgUId.setStatus('current')
if mibBuilder.loadTexts: agAccessUserNewCfgUId.setDescription('The User identifier.')
agAccessUserNewCos = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 19, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 3, 6))).clone(namedValues=NamedValues(("user", 0), ("oper", 3), ("admin", 6)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: agAccessUserNewCos.setStatus('current')
if mibBuilder.loadTexts: agAccessUserNewCos.setDescription('The user class of service.')
agAccessUserNewCfgName = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 19, 3, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: agAccessUserNewCfgName.setStatus('current')
if mibBuilder.loadTexts: agAccessUserNewCfgName.setDescription('The user name. Please note, the max length is 8 in stacking mode.')
agAccessUserNewCfgPswd = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 19, 3, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: agAccessUserNewCfgPswd.setStatus('current')
if mibBuilder.loadTexts: agAccessUserNewCfgPswd.setDescription('The character string representing the user password.')
agAccessUserNewCfgState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 19, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("enabled", 2), ("disabled", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: agAccessUserNewCfgState.setStatus('current')
if mibBuilder.loadTexts: agAccessUserNewCfgState.setDescription('User validation (enabled or disabled) in new configuration block.')
agAccessUserNewCfgDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 19, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("delete", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: agAccessUserNewCfgDelete.setStatus('current')
if mibBuilder.loadTexts: agAccessUserNewCfgDelete.setDescription('This is an action object to create or delete a User. other(1) is returned always when read. The following values are writable: delete(2)...to delete a User')
ldapCurCfgPrimaryIpAddr = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 21, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ldapCurCfgPrimaryIpAddr.setStatus('current')
if mibBuilder.loadTexts: ldapCurCfgPrimaryIpAddr.setDescription('The IP address of the Primary LDAP server.')
ldapNewCfgPrimaryIpAddr = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 21, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ldapNewCfgPrimaryIpAddr.setStatus('current')
if mibBuilder.loadTexts: ldapNewCfgPrimaryIpAddr.setDescription('The IP address of the Primary LDAP server.')
ldapCurCfgSecondaryIpAddr = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 21, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ldapCurCfgSecondaryIpAddr.setStatus('current')
if mibBuilder.loadTexts: ldapCurCfgSecondaryIpAddr.setDescription('The IP address of the Secondary LDAP server.')
ldapNewCfgSecondaryIpAddr = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 21, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ldapNewCfgSecondaryIpAddr.setStatus('current')
if mibBuilder.loadTexts: ldapNewCfgSecondaryIpAddr.setDescription('The IP address of the Secondary LDAP server.')
ldapCurCfgPort = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 21, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ldapCurCfgPort.setStatus('current')
if mibBuilder.loadTexts: ldapCurCfgPort.setDescription('Specify the LDAP port number.')
ldapNewCfgPort = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 21, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ldapNewCfgPort.setStatus('current')
if mibBuilder.loadTexts: ldapNewCfgPort.setDescription('Specify the LDAP port number.')
ldapCurCfgRetries = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 21, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ldapCurCfgRetries.setStatus('current')
if mibBuilder.loadTexts: ldapCurCfgRetries.setDescription('Number of retries to the LDAP server.')
ldapNewCfgRetries = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 21, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ldapNewCfgRetries.setStatus('current')
if mibBuilder.loadTexts: ldapNewCfgRetries.setDescription('Number of retries to the LDAP server.')
ldapCurCfgTimeout = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 21, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(4, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ldapCurCfgTimeout.setStatus('current')
if mibBuilder.loadTexts: ldapCurCfgTimeout.setDescription('The maximum number of seconds before resending authentication to LDAP server.')
ldapNewCfgTimeout = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 21, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(4, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ldapNewCfgTimeout.setStatus('current')
if mibBuilder.loadTexts: ldapNewCfgTimeout.setDescription('The maximum number of seconds before resending authentication to LDAP server.')
ldapCurCfgDomain = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 21, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ldapCurCfgDomain.setStatus('current')
if mibBuilder.loadTexts: ldapCurCfgDomain.setDescription('The LDAP domain name.')
ldapNewCfgDomain = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 21, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 127))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ldapNewCfgDomain.setStatus('current')
if mibBuilder.loadTexts: ldapNewCfgDomain.setDescription('The LDAP domain name.')
ldapCurCfgBackdoor = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 21, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 0))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 0)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ldapCurCfgBackdoor.setStatus('current')
if mibBuilder.loadTexts: ldapCurCfgBackdoor.setDescription('Enable or disable LDAP backdoor for telnet/ssh/http/https.')
ldapNewCfgBackdoor = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 21, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 0))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ldapNewCfgBackdoor.setStatus('current')
if mibBuilder.loadTexts: ldapNewCfgBackdoor.setDescription('Enable or disable LDAP backdoor for telnet/ssh/http/https.')
ldapCurCfgState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 21, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 0))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 0)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ldapCurCfgState.setStatus('current')
if mibBuilder.loadTexts: ldapCurCfgState.setDescription('Enable or disable LDAP authentication.')
ldapNewCfgState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 21, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 0))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ldapNewCfgState.setStatus('current')
if mibBuilder.loadTexts: ldapNewCfgState.setDescription('Enable or disable LDAP authentication.')
ldapCurCfgPorttoUse = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 21, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("data", 1), ("mgta", 2), ("mgtb", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ldapCurCfgPorttoUse.setStatus('current')
if mibBuilder.loadTexts: ldapCurCfgPorttoUse.setDescription('Specify whether the LDAP should be performed over the data port or the management port.')
ldapNewCfgPorttoUse = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 21, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("data", 1), ("mgta", 2), ("mgtb", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ldapNewCfgPorttoUse.setStatus('current')
if mibBuilder.loadTexts: ldapNewCfgPorttoUse.setDescription('Specify whether the LDAP should be performed over the data port or the management port.')
ldapCurCfgSecPorttoUse = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 21, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("data", 1), ("mgta", 2), ("mgtb", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ldapCurCfgSecPorttoUse.setStatus('current')
if mibBuilder.loadTexts: ldapCurCfgSecPorttoUse.setDescription('Specify whether the LDAP should be performed over the data port or the management port.')
ldapNewCfgSecPorttoUse = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 21, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("data", 1), ("mgta", 2), ("mgtb", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ldapNewCfgSecPorttoUse.setStatus('current')
if mibBuilder.loadTexts: ldapNewCfgSecPorttoUse.setDescription('Specify whether the LDAP should be performed over the data port or the management port.')
sflowCurCfgServerAddress = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 24, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sflowCurCfgServerAddress.setStatus('current')
if mibBuilder.loadTexts: sflowCurCfgServerAddress.setDescription('The IP address of the sFlow server.')
sflowNewCfgServerAddress = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 24, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 46))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sflowNewCfgServerAddress.setStatus('current')
if mibBuilder.loadTexts: sflowNewCfgServerAddress.setDescription('The IP address of the sFlow server.')
sflowCurCfgServerPort = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 24, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sflowCurCfgServerPort.setStatus('current')
if mibBuilder.loadTexts: sflowCurCfgServerPort.setDescription('Specify the sFlow server port number.')
sflowNewCfgServerPort = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 24, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sflowNewCfgServerPort.setStatus('current')
if mibBuilder.loadTexts: sflowNewCfgServerPort.setDescription('Specify the sFlow server port number.')
sflowCurCfgState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 24, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 0))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 0)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sflowCurCfgState.setStatus('current')
if mibBuilder.loadTexts: sflowCurCfgState.setDescription('Enable or disable sFlow.')
sflowNewCfgState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 24, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 0))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sflowNewCfgState.setStatus('current')
if mibBuilder.loadTexts: sflowNewCfgState.setDescription('Enable or disable sFlow')
sflowCurPortCfgTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 24, 7), )
if mibBuilder.loadTexts: sflowCurPortCfgTable.setStatus('current')
if mibBuilder.loadTexts: sflowCurPortCfgTable.setDescription('The table of sFlow port configuration.')
sflowCurPortCfgTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 24, 7, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "sflowCurPortCfgTableId"))
if mibBuilder.loadTexts: sflowCurPortCfgTableEntry.setStatus('current')
if mibBuilder.loadTexts: sflowCurPortCfgTableEntry.setDescription('A row in the sFlow port configuration table.')
sflowCurPortCfgTableId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 24, 7, 1, 1), PortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sflowCurPortCfgTableId.setStatus('current')
if mibBuilder.loadTexts: sflowCurPortCfgTableId.setDescription('sFlow port number.')
sflowCurPortSampling = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 24, 7, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(256, 65536))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sflowCurPortSampling.setStatus('current')
if mibBuilder.loadTexts: sflowCurPortSampling.setDescription('The current sFlow port sampling rate.')
sflowCurPortPolling = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 24, 7, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 60))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sflowCurPortPolling.setStatus('current')
if mibBuilder.loadTexts: sflowCurPortPolling.setDescription('The current sFlow port polling interval.')
sflowNewPortCfgTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 24, 8), )
if mibBuilder.loadTexts: sflowNewPortCfgTable.setStatus('current')
if mibBuilder.loadTexts: sflowNewPortCfgTable.setDescription('The table of sFlow port configuration.')
sflowNewPortCfgTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 24, 8, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "sflowNewPortCfgTableId"))
if mibBuilder.loadTexts: sflowNewPortCfgTableEntry.setStatus('current')
if mibBuilder.loadTexts: sflowNewPortCfgTableEntry.setDescription('A row in the sFlow port configuration table.')
sflowNewPortCfgTableId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 24, 8, 1, 1), PortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sflowNewPortCfgTableId.setStatus('current')
if mibBuilder.loadTexts: sflowNewPortCfgTableId.setDescription(' sFlow port number.')
sflowNewPortSampling = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 24, 8, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16777215))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sflowNewPortSampling.setStatus('current')
if mibBuilder.loadTexts: sflowNewPortSampling.setDescription('The new sFlow port sampling rate. Valid range: 1-16777215| 0 for disable')
sflowNewPortPolling = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 24, 8, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sflowNewPortPolling.setStatus('current')
if mibBuilder.loadTexts: sflowNewPortPolling.setDescription('The new sFlow port polling interval. Valid range: 5-60| 0 for disable')
sflowCurCfgMgmtPort = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 24, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("data", 1), ("mgta", 2), ("mgtb", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sflowCurCfgMgmtPort.setStatus('current')
if mibBuilder.loadTexts: sflowCurCfgMgmtPort.setDescription('The port that the sFlow server is connected to')
sflowNewCfgMgmtPort = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 1, 24, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("data", 1), ("mgta", 2), ("mgtb", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sflowNewCfgMgmtPort.setStatus('current')
if mibBuilder.loadTexts: sflowNewCfgMgmtPort.setDescription('Chose the port that the sFlow server will connect to')
pktStatsAllocs = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktStatsAllocs.setStatus('current')
if mibBuilder.loadTexts: pktStatsAllocs.setDescription('Total number of packet allocations from the packet buffer pool by the TCP/IP protocol stack.')
pktStatsFrees = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktStatsFrees.setStatus('current')
if mibBuilder.loadTexts: pktStatsFrees.setDescription('Total number of times the packet buffers are freed(released) to the packet buffer pool by the TCP/IP protocol stack.')
pktStatsAllocFails = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktStatsAllocFails.setStatus('current')
if mibBuilder.loadTexts: pktStatsAllocFails.setDescription('Total number of packet allocation failures from the packet buffer pool by the TCP/IP protocol stack.')
pktStatsMediums = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktStatsMediums.setStatus('current')
if mibBuilder.loadTexts: pktStatsMediums.setDescription('Total number of packet allocations with size greater than 128 bytes and less than or equal to 1536 bytes from the packet buffer pool by the TCP/IP protocol stack.')
pktStatsJumbos = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktStatsJumbos.setStatus('current')
if mibBuilder.loadTexts: pktStatsJumbos.setDescription('Total number of packet allocations with size larger than 1536 bytes from the packet buffer pool by the TCP/IP protocol stack.')
pktStatsSmalls = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktStatsSmalls.setStatus('current')
if mibBuilder.loadTexts: pktStatsSmalls.setDescription('Total number of packet allocations with size less than or eqaul to 128 bytes from the packet buffer pool by the TCP/IP protocol stack.')
pktStatsMediumsHiWatermark = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktStatsMediumsHiWatermark.setStatus('current')
if mibBuilder.loadTexts: pktStatsMediumsHiWatermark.setDescription('The highest number of packet allocations with size greater than 128 bytes and less than or equal to 1536 bytes from the packet buffer pool by the TCP/IP protocol stack.')
pktStatsJumbosHiWatermark = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktStatsJumbosHiWatermark.setStatus('current')
if mibBuilder.loadTexts: pktStatsJumbosHiWatermark.setDescription('The highest number of packet allocations with size larger than 1536 bytes from the packet buffer pool by the TCP/IP protocol stack.')
pktStatsSmallsHiWatermark = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktStatsSmallsHiWatermark.setStatus('current')
if mibBuilder.loadTexts: pktStatsSmallsHiWatermark.setDescription('The highest number of packet allocations with size less than or equal to 128 bytes from the packet buffer pool by the TCP/IP protocol stack.')
mpCpuStatsUtil1Second = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 2, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpCpuStatsUtil1Second.setStatus('current')
if mibBuilder.loadTexts: mpCpuStatsUtil1Second.setDescription('The utilization of MP CPU over 1 second. It shows the percentage.')
mpCpuStatsUtil4Seconds = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 2, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpCpuStatsUtil4Seconds.setStatus('current')
if mibBuilder.loadTexts: mpCpuStatsUtil4Seconds.setDescription('The utilization of MP CPU over 4 seconds. It shows the percentage.')
mpCpuStatsUtil64Seconds = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 2, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mpCpuStatsUtil64Seconds.setStatus('current')
if mibBuilder.loadTexts: mpCpuStatsUtil64Seconds.setDescription('The utilization of MP CPU over 64 seconds. It shows the percentage.')
cpuUtilProcessStatsTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 2, 5), )
if mibBuilder.loadTexts: cpuUtilProcessStatsTable.setStatus('current')
if mibBuilder.loadTexts: cpuUtilProcessStatsTable.setDescription('The table of CPU utilization per process statistics.')
cpuUtilProcessStatsTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 2, 5, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "processId"))
if mibBuilder.loadTexts: cpuUtilProcessStatsTableEntry.setStatus('current')
if mibBuilder.loadTexts: cpuUtilProcessStatsTableEntry.setDescription('A row in the CPU utilization stats per process table.')
processId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 2, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: processId.setStatus('current')
if mibBuilder.loadTexts: processId.setDescription('The process ID.')
processName = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 2, 5, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: processName.setStatus('current')
if mibBuilder.loadTexts: processName.setDescription('Process Name.')
cpuProcessUtil1Sec = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 2, 5, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpuProcessUtil1Sec.setStatus('current')
if mibBuilder.loadTexts: cpuProcessUtil1Sec.setDescription('The utilization of MP CPU over 1 second. It shows the percentage.')
cpuProcessUtil5Sec = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 2, 5, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpuProcessUtil5Sec.setStatus('current')
if mibBuilder.loadTexts: cpuProcessUtil5Sec.setDescription('The utilization of MP CPU over 5 seconds. It shows the percentage.')
cpuProcessUtil1Min = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 2, 5, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpuProcessUtil1Min.setStatus('current')
if mibBuilder.loadTexts: cpuProcessUtil1Min.setDescription('The utilization of MP CPU over 1 min. It shows the percentage.')
cpuProcessUtil5Min = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 2, 5, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpuProcessUtil5Min.setStatus('current')
if mibBuilder.loadTexts: cpuProcessUtil5Min.setDescription('The utilization of MP CPU over 5 min. It shows the percentage.')
processStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 2, 5, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: processStatus.setStatus('current')
if mibBuilder.loadTexts: processStatus.setDescription('Process Status')
portStatsTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 1), )
if mibBuilder.loadTexts: portStatsTable.setStatus('current')
if mibBuilder.loadTexts: portStatsTable.setDescription('The table of port statistics.')
portStatsTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 1, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "portStatsIndx"))
if mibBuilder.loadTexts: portStatsTableEntry.setStatus('current')
if mibBuilder.loadTexts: portStatsTableEntry.setDescription('A row in the port stats table.')
tcpControlBlocksTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 21, 1), )
if mibBuilder.loadTexts: tcpControlBlocksTable.setStatus('current')
if mibBuilder.loadTexts: tcpControlBlocksTable.setDescription('All TCP allocated control blocks ')
tcpControlBlocksTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 21, 1, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "tcpControlBlocksIndx"))
if mibBuilder.loadTexts: tcpControlBlocksTableEntry.setStatus('current')
if mibBuilder.loadTexts: tcpControlBlocksTableEntry.setDescription('A row in the TCP control blocks table. ')
tcpControlBlocksIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 21, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpControlBlocksIndx.setStatus('current')
if mibBuilder.loadTexts: tcpControlBlocksIndx.setDescription('The TCP blocks index.')
destAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 21, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: destAddr.setStatus('current')
if mibBuilder.loadTexts: destAddr.setDescription('The TCP block destination address.')
remotePort = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 21, 1, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: remotePort.setStatus('current')
if mibBuilder.loadTexts: remotePort.setDescription('Tcp informations concerning the remote port')
sourceAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 21, 1, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sourceAddr.setStatus('current')
if mibBuilder.loadTexts: sourceAddr.setDescription('IP address of the source of the Tcp block')
localPort = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 21, 1, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: localPort.setStatus('current')
if mibBuilder.loadTexts: localPort.setDescription('Tcp informations concerning the local port')
portType = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 21, 1, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portType.setStatus('current')
if mibBuilder.loadTexts: portType.setDescription('The type of the local port')
portState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 21, 1, 1, 8), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portState.setStatus('current')
if mibBuilder.loadTexts: portState.setDescription(' The state of the local port')
state = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 21, 1, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: state.setStatus('current')
if mibBuilder.loadTexts: state.setDescription('The state of the Tcp')
tcpMGMTControlBlocksTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 21, 2), )
if mibBuilder.loadTexts: tcpMGMTControlBlocksTable.setStatus('current')
if mibBuilder.loadTexts: tcpMGMTControlBlocksTable.setDescription('All TCP allocated control blocks on MGMT port')
tcpMGMTTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 21, 2, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "tcpMGMTIndx"))
if mibBuilder.loadTexts: tcpMGMTTableEntry.setStatus('current')
if mibBuilder.loadTexts: tcpMGMTTableEntry.setDescription(' A row in the TCP on MGMT port table. ')
tcpMGMTIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 21, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpMGMTIndx.setStatus('current')
if mibBuilder.loadTexts: tcpMGMTIndx.setDescription(' Index in the tcpMGMTControlBlocksTable table.')
recvQ = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 21, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: recvQ.setStatus('current')
if mibBuilder.loadTexts: recvQ.setDescription('The size of the received TCP queue.')
sentQ = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 21, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sentQ.setStatus('current')
if mibBuilder.loadTexts: sentQ.setDescription('The size of the sent TCP blocks queue.')
localAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 21, 2, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: localAddress.setStatus('current')
if mibBuilder.loadTexts: localAddress.setDescription('The local address for the TCP.')
foreignAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 21, 2, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: foreignAddress.setStatus('current')
if mibBuilder.loadTexts: foreignAddress.setDescription('The remote address for the TCP.')
stateMgmt = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 21, 2, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stateMgmt.setStatus('current')
if mibBuilder.loadTexts: stateMgmt.setDescription("The port's state.")
udpControlBlocksTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 22, 1), )
if mibBuilder.loadTexts: udpControlBlocksTable.setStatus('current')
if mibBuilder.loadTexts: udpControlBlocksTable.setDescription('All UDP control blocks in use')
udpControlBlocksTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 22, 1, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "udpMpLocalPort"))
if mibBuilder.loadTexts: udpControlBlocksTableEntry.setStatus('current')
if mibBuilder.loadTexts: udpControlBlocksTableEntry.setDescription('A row in the UDP control blocks table. ')
udpMpLocalPort = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 22, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: udpMpLocalPort.setStatus('current')
if mibBuilder.loadTexts: udpMpLocalPort.setDescription('The current UDP local port.')
udpMpState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 22, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: udpMpState.setStatus('current')
if mibBuilder.loadTexts: udpMpState.setDescription(" The port's state. ")
udpMGMTControlBlocksTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 22, 2), )
if mibBuilder.loadTexts: udpMGMTControlBlocksTable.setStatus('current')
if mibBuilder.loadTexts: udpMGMTControlBlocksTable.setDescription('All UDP control blocks allocated on MGMT port')
udpMGMTTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 22, 2, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "udpMGMTIndx"))
if mibBuilder.loadTexts: udpMGMTTableEntry.setStatus('current')
if mibBuilder.loadTexts: udpMGMTTableEntry.setDescription(' A row in the UDP on MGMT port table. ')
udpMGMTIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 22, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: udpMGMTIndx.setStatus('current')
if mibBuilder.loadTexts: udpMGMTIndx.setDescription(' Index in the udpMGMTControlBlocksTable table.')
recvQUdp = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 22, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: recvQUdp.setStatus('current')
if mibBuilder.loadTexts: recvQUdp.setDescription('The size of the received UDP queue.')
sentQUdp = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 22, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sentQUdp.setStatus('current')
if mibBuilder.loadTexts: sentQUdp.setDescription('The size of the sent UDP blocks queue.')
localAddressUdp = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 22, 2, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: localAddressUdp.setStatus('current')
if mibBuilder.loadTexts: localAddressUdp.setDescription('The local address for the UDP.')
foreignAddressUdp = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 22, 2, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: foreignAddressUdp.setStatus('current')
if mibBuilder.loadTexts: foreignAddressUdp.setDescription('The remote address for the UDP.')
stateMgmtUdp = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 22, 2, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stateMgmtUdp.setStatus('current')
if mibBuilder.loadTexts: stateMgmtUdp.setDescription("The port's state.")
portStatsIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 1, 1, 1), PortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portStatsIndx.setStatus('current')
if mibBuilder.loadTexts: portStatsIndx.setDescription('The port index.')
portStatsPhyIfInOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portStatsPhyIfInOctets.setStatus('current')
if mibBuilder.loadTexts: portStatsPhyIfInOctets.setDescription('The total number of octets received on the interface, including framing characters.')
portStatsPhyIfInUcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portStatsPhyIfInUcastPkts.setStatus('current')
if mibBuilder.loadTexts: portStatsPhyIfInUcastPkts.setDescription('The number of subnetwork-unicast packets delivered to a higher-layer protocol.')
portStatsPhyIfInNUcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portStatsPhyIfInNUcastPkts.setStatus('current')
if mibBuilder.loadTexts: portStatsPhyIfInNUcastPkts.setDescription('The number of non-unicast (i.e., subnetwork- broadcast or subnetwork-multicast) packets delivered to a higher-layer protocol.')
portStatsPhyIfInDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portStatsPhyIfInDiscards.setStatus('current')
if mibBuilder.loadTexts: portStatsPhyIfInDiscards.setDescription('The number of inbound packets which were chosen to be discarded even though no errors had been detected to prevent their being deliverable to a higher-layer protocol. One possible reason for discarding such a packet could be to free up buffer space.')
portStatsPhyIfInErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portStatsPhyIfInErrors.setStatus('current')
if mibBuilder.loadTexts: portStatsPhyIfInErrors.setDescription('The number of inbound packets that contained errors preventing them from being deliverable to a higher-layer protocol.')
portStatsPhyIfInUnknownProtos = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portStatsPhyIfInUnknownProtos.setStatus('current')
if mibBuilder.loadTexts: portStatsPhyIfInUnknownProtos.setDescription('The number of packets received via the interface which were discarded because of an unknown or unsupported protocol.')
portStatsPhyIfOutOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portStatsPhyIfOutOctets.setStatus('current')
if mibBuilder.loadTexts: portStatsPhyIfOutOctets.setDescription('The total number of octets transmitted out of the interface, including framing characters.')
portStatsPhyIfOutUcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portStatsPhyIfOutUcastPkts.setStatus('current')
if mibBuilder.loadTexts: portStatsPhyIfOutUcastPkts.setDescription('The total number of packets that higher-level protocols requested be transmitted to a subnetwork-unicast address, including those that were discarded or not sent.')
portStatsPhyIfOutNUcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portStatsPhyIfOutNUcastPkts.setStatus('current')
if mibBuilder.loadTexts: portStatsPhyIfOutNUcastPkts.setDescription('The total number of packets that higher-level protocols requested be transmitted to a non- unicast (i.e., a subnetwork-broadcast or subnetwork-multicast) address, including those that were discarded or not sent.')
portStatsPhyIfOutDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portStatsPhyIfOutDiscards.setStatus('current')
if mibBuilder.loadTexts: portStatsPhyIfOutDiscards.setDescription('The number of outbound packets which were chosen to be discarded even though no errors had been detected to prevent their being transmitted. One possible reason for discarding such a packet could be to free up buffer space.')
portStatsPhyIfOutErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portStatsPhyIfOutErrors.setStatus('current')
if mibBuilder.loadTexts: portStatsPhyIfOutErrors.setDescription('The number of outbound packets that could not be transmitted because of errors.')
portStatsPhyIfOutQLen = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 1, 1, 13), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portStatsPhyIfOutQLen.setStatus('current')
if mibBuilder.loadTexts: portStatsPhyIfOutQLen.setDescription('The length of the output packet queue (in packets).')
portStatsPhyIfInBroadcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portStatsPhyIfInBroadcastPkts.setStatus('current')
if mibBuilder.loadTexts: portStatsPhyIfInBroadcastPkts.setDescription('The number of packets, delivered by this sub-layer to a higher (sub-)layer, which were addressed to a broadcast address at this sub-layer.')
portStatsPhyIfOutBroadcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portStatsPhyIfOutBroadcastPkts.setStatus('current')
if mibBuilder.loadTexts: portStatsPhyIfOutBroadcastPkts.setDescription('The total number of packets that higher-level protocols requested be transmitted, and which were addressed to a broadcast address at this sub-layer, including those that were discarded or not sent.')
portStatsPhyIfInMulticastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portStatsPhyIfInMulticastPkts.setStatus('current')
if mibBuilder.loadTexts: portStatsPhyIfInMulticastPkts.setDescription('The number of packets, delivered by this sub-layer to a higher (sub-)layer, which were addressed to a multicast address at this sub-layer.')
portStatsPhyIfOutMulticastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portStatsPhyIfOutMulticastPkts.setStatus('current')
if mibBuilder.loadTexts: portStatsPhyIfOutMulticastPkts.setDescription('The total number of packets that higher-level protocols requested be transmitted, and which were addressed to a multicast address at this sub-layer, including those that were discarded or not sent.')
portStatsClear = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("clear", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portStatsClear.setStatus('current')
if mibBuilder.loadTexts: portStatsClear.setDescription('Setting this value to clear(2) clears the stats for this port.')
portStatsLinkStateChange = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portStatsLinkStateChange.setStatus('current')
if mibBuilder.loadTexts: portStatsLinkStateChange.setDescription('Number of link state changes.')
portStatsPhyIfInFctlPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 1, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portStatsPhyIfInFctlPkts.setStatus('current')
if mibBuilder.loadTexts: portStatsPhyIfInFctlPkts.setDescription('The number of inbound flow control packets.')
portStatsPhyIfOutFctlPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 1, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portStatsPhyIfOutFctlPkts.setStatus('current')
if mibBuilder.loadTexts: portStatsPhyIfOutFctlPkts.setDescription('The number of outbound flow control packets.')
portStatsPhyIfInFctlPktsRate = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 1, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portStatsPhyIfInFctlPktsRate.setStatus('current')
if mibBuilder.loadTexts: portStatsPhyIfInFctlPktsRate.setDescription('The number of inbound flow control packets per second.')
portStatsPhyIfOutFctlPktsRate = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 1, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portStatsPhyIfOutFctlPktsRate.setStatus('current')
if mibBuilder.loadTexts: portStatsPhyIfOutFctlPktsRate.setDescription('The number of outbound flow control packets per second.')
portStatsDot1PortInFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 1, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portStatsDot1PortInFrames.setStatus('current')
if mibBuilder.loadTexts: portStatsDot1PortInFrames.setDescription('The number of IN frames per port.')
portStatsDot1PortOutFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 1, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portStatsDot1PortOutFrames.setStatus('current')
if mibBuilder.loadTexts: portStatsDot1PortOutFrames.setDescription('The number of OUT frames per port.')
portStatsDot1PortInDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 1, 1, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portStatsDot1PortInDiscards.setStatus('current')
if mibBuilder.loadTexts: portStatsDot1PortInDiscards.setDescription('The number of IN packets discarded per port.')
portStatsDot1TpLearnedEntryDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 1, 1, 34), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portStatsDot1TpLearnedEntryDiscards.setStatus('current')
if mibBuilder.loadTexts: portStatsDot1TpLearnedEntryDiscards.setDescription('The number of Dot1Tp learned entries discarded.')
portStatsDot1StpPortForwardTransitions = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 1, 1, 35), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portStatsDot1StpPortForwardTransitions.setStatus('current')
if mibBuilder.loadTexts: portStatsDot1StpPortForwardTransitions.setDescription('The number of transitions ....')
portMgmtStatsTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 3), )
if mibBuilder.loadTexts: portMgmtStatsTable.setStatus('current')
if mibBuilder.loadTexts: portMgmtStatsTable.setDescription('The table of port statistics.')
portMgmtStatsTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 3, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "portMgmtStatsIndx"))
if mibBuilder.loadTexts: portMgmtStatsTableEntry.setStatus('current')
if mibBuilder.loadTexts: portMgmtStatsTableEntry.setDescription('A row in the management port stats table.')
portMgmtStatsIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portMgmtStatsIndx.setStatus('current')
if mibBuilder.loadTexts: portMgmtStatsIndx.setDescription('The management port index.')
portMgmtStatsRxBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 3, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portMgmtStatsRxBytes.setStatus('current')
if mibBuilder.loadTexts: portMgmtStatsRxBytes.setDescription('The total number of bytes received.')
portMgmtStatsTxBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 3, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portMgmtStatsTxBytes.setStatus('current')
if mibBuilder.loadTexts: portMgmtStatsTxBytes.setDescription('The total number of bytes transmitted.')
portMgmtStatsRxpackets = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 3, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portMgmtStatsRxpackets.setStatus('current')
if mibBuilder.loadTexts: portMgmtStatsRxpackets.setDescription('Total number of packet allocations from the packet buffer pool by the TCP/IP protocol stack.')
portMgmtStatsTxpackets = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 3, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portMgmtStatsTxpackets.setStatus('current')
if mibBuilder.loadTexts: portMgmtStatsTxpackets.setDescription('Total number of packet allocations from the packet buffer pool by the TCP/IP protocol stack.')
portMgmtStatsRxErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 3, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portMgmtStatsRxErrors.setStatus('current')
if mibBuilder.loadTexts: portMgmtStatsRxErrors.setDescription('The number of inbound packets that contained errors preventing them from being deliverable to a higher-layer protocol.')
portMgmtStatsTxErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 3, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portMgmtStatsTxErrors.setStatus('current')
if mibBuilder.loadTexts: portMgmtStatsTxErrors.setDescription('The number of outbound packets that contained errors preventing them from being deliverable to a higher-layer protocol.')
portMgmtStatsRxDropped = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 3, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portMgmtStatsRxDropped.setStatus('current')
if mibBuilder.loadTexts: portMgmtStatsRxDropped.setDescription('The number of inbound packets that were dropped.')
portMgmtStatsTxDropped = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 3, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portMgmtStatsTxDropped.setStatus('current')
if mibBuilder.loadTexts: portMgmtStatsTxDropped.setDescription('The number of outbound packets that were dropped.')
portMgmtStatsRxOverruns = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 3, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portMgmtStatsRxOverruns.setStatus('current')
if mibBuilder.loadTexts: portMgmtStatsRxOverruns.setDescription('The number of data overruns over this link.')
portMgmtStatsTxOverruns = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 3, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portMgmtStatsTxOverruns.setStatus('current')
if mibBuilder.loadTexts: portMgmtStatsTxOverruns.setDescription('The number of data overruns over this link.')
portMgmtStatsRxFrame = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 3, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portMgmtStatsRxFrame.setStatus('current')
if mibBuilder.loadTexts: portMgmtStatsRxFrame.setDescription('The number of frames received on this link.')
portMgmtStatsTxCarrier = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 3, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portMgmtStatsTxCarrier.setStatus('current')
if mibBuilder.loadTexts: portMgmtStatsTxCarrier.setDescription('The number of times that the carrier sense condition was lost or never asserted when attempting to transmit a frame on a this interface.')
portMgmtStatsRxMulticast = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 3, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portMgmtStatsRxMulticast.setStatus('current')
if mibBuilder.loadTexts: portMgmtStatsRxMulticast.setDescription('The total number of multicast packets received.')
portMgmtStatsTxCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 3, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portMgmtStatsTxCollisions.setStatus('current')
if mibBuilder.loadTexts: portMgmtStatsTxCollisions.setDescription('The number of collisions on this outbound segment.')
allportsStatsTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 4), )
if mibBuilder.loadTexts: allportsStatsTable.setStatus('current')
if mibBuilder.loadTexts: allportsStatsTable.setDescription('The table of all ports statistics.')
allportsStatsTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 4, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "allportsStatsIndx"))
if mibBuilder.loadTexts: allportsStatsTableEntry.setStatus('current')
if mibBuilder.loadTexts: allportsStatsTableEntry.setDescription('A row in the table of all ports statistics.')
allportsStatsIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 4, 1, 1), PortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: allportsStatsIndx.setStatus('current')
if mibBuilder.loadTexts: allportsStatsIndx.setDescription('The port number.')
allportsStatsDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 4, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: allportsStatsDescr.setStatus('current')
if mibBuilder.loadTexts: allportsStatsDescr.setDescription('The port description.')
allportsStatsSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("mbs10", 2), ("mbs100", 3), ("mbs1000", 4), ("any", 5), ("mbs10000", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: allportsStatsSpeed.setStatus('current')
if mibBuilder.loadTexts: allportsStatsSpeed.setDescription('The current operational speed of the port.')
allportsStatsPhysAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 4, 1, 4), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: allportsStatsPhysAddress.setStatus('current')
if mibBuilder.loadTexts: allportsStatsPhysAddress.setDescription('The port MAC Address.')
allportsStatsAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: allportsStatsAdminStatus.setStatus('current')
if mibBuilder.loadTexts: allportsStatsAdminStatus.setDescription('The port Admin state.')
allportsStatsOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 4, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: allportsStatsOperStatus.setStatus('current')
if mibBuilder.loadTexts: allportsStatsOperStatus.setDescription('The port Operational Status.')
allportsStatsInOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 4, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: allportsStatsInOctets.setStatus('current')
if mibBuilder.loadTexts: allportsStatsInOctets.setDescription('Octets In for port.')
allportsStatsOutOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 4, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: allportsStatsOutOctets.setStatus('current')
if mibBuilder.loadTexts: allportsStatsOutOctets.setDescription('Octets Out for port.')
allportsStatsInPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 4, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: allportsStatsInPkts.setStatus('current')
if mibBuilder.loadTexts: allportsStatsInPkts.setDescription('Packets In for port.')
allportsStatsOutPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 4, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: allportsStatsOutPkts.setStatus('current')
if mibBuilder.loadTexts: allportsStatsOutPkts.setDescription('Packets Out for port.')
allportsStatsInUcast = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 4, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: allportsStatsInUcast.setStatus('current')
if mibBuilder.loadTexts: allportsStatsInUcast.setDescription('Unicast Packets In for port.')
allportsStatsOutUcast = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 4, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: allportsStatsOutUcast.setStatus('current')
if mibBuilder.loadTexts: allportsStatsOutUcast.setDescription('Unicast Packets Out for port.')
allportsStatsInBcast = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 4, 1, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: allportsStatsInBcast.setStatus('current')
if mibBuilder.loadTexts: allportsStatsInBcast.setDescription('Broadcasts Packets In for port.')
allportsStatsOutBcast = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 4, 1, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: allportsStatsOutBcast.setStatus('current')
if mibBuilder.loadTexts: allportsStatsOutBcast.setDescription('Broadcasts Packets Out for port.')
allportsStatsInMcast = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 4, 1, 15), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: allportsStatsInMcast.setStatus('current')
if mibBuilder.loadTexts: allportsStatsInMcast.setDescription('Multicast Packets In for port.')
allportsStatsOutMcast = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 4, 1, 16), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: allportsStatsOutMcast.setStatus('current')
if mibBuilder.loadTexts: allportsStatsOutMcast.setDescription('Multicast Packets Out for port.')
allportsStatsInDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 4, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: allportsStatsInDiscards.setStatus('current')
if mibBuilder.loadTexts: allportsStatsInDiscards.setDescription('Discarded Packets for port.')
allportsStatsOutDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 4, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: allportsStatsOutDiscards.setStatus('current')
if mibBuilder.loadTexts: allportsStatsOutDiscards.setDescription('Outbound Packets for port.')
allportsStatsInErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 4, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: allportsStatsInErrors.setStatus('current')
if mibBuilder.loadTexts: allportsStatsInErrors.setDescription('Error Packets for port.')
allportsStatsOutErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 4, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: allportsStatsOutErrors.setStatus('current')
if mibBuilder.loadTexts: allportsStatsOutErrors.setDescription('Not sent packets due to error.')
allportsStatsInUnknownProtos = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 4, 1, 21), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: allportsStatsInUnknownProtos.setStatus('current')
if mibBuilder.loadTexts: allportsStatsInUnknownProtos.setDescription('Unknown protocol packets.')
allportsStatsOutQLen = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 4, 1, 22), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: allportsStatsOutQLen.setStatus('current')
if mibBuilder.loadTexts: allportsStatsOutQLen.setDescription('Outbound Packet Queue Length.')
allportsStatsLinkStateChange = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 4, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: allportsStatsLinkStateChange.setStatus('current')
if mibBuilder.loadTexts: allportsStatsLinkStateChange.setDescription('Number of link state changes.')
allportsStatsInOctetsRate = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 4, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: allportsStatsInOctetsRate.setStatus('current')
if mibBuilder.loadTexts: allportsStatsInOctetsRate.setDescription('Octets In rate for port.')
allportsStatsOutOctetsRate = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 4, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: allportsStatsOutOctetsRate.setStatus('current')
if mibBuilder.loadTexts: allportsStatsOutOctetsRate.setDescription('Octets Out rate for port.')
allportsStatsInUcastRate = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 4, 1, 32), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: allportsStatsInUcastRate.setStatus('current')
if mibBuilder.loadTexts: allportsStatsInUcastRate.setDescription('Unicast Packets In rate for port.')
allportsStatsOutUcastRate = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 4, 1, 33), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: allportsStatsOutUcastRate.setStatus('current')
if mibBuilder.loadTexts: allportsStatsOutUcastRate.setDescription('Unicast Packets Out rate for port.')
allportsStatsInBcastRate = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 4, 1, 34), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: allportsStatsInBcastRate.setStatus('current')
if mibBuilder.loadTexts: allportsStatsInBcastRate.setDescription('Broadcasts Packets In rate for port.')
allportsStatsOutBcastRate = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 4, 1, 35), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: allportsStatsOutBcastRate.setStatus('current')
if mibBuilder.loadTexts: allportsStatsOutBcastRate.setDescription('Broadcasts Packets Out rate for port.')
allportsStatsInMcastRate = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 4, 1, 36), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: allportsStatsInMcastRate.setStatus('current')
if mibBuilder.loadTexts: allportsStatsInMcastRate.setDescription('Multicast Packets In rate for port.')
allportsStatsOutMcastRate = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 4, 1, 37), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: allportsStatsOutMcastRate.setStatus('current')
if mibBuilder.loadTexts: allportsStatsOutMcastRate.setDescription('Multicast Packets Out rate for port.')
allportsStatsInDiscardsRate = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 4, 1, 38), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: allportsStatsInDiscardsRate.setStatus('current')
if mibBuilder.loadTexts: allportsStatsInDiscardsRate.setDescription('Discarded In Packets rate for port.')
allportsStatsOutDiscardsRate = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 4, 1, 39), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: allportsStatsOutDiscardsRate.setStatus('current')
if mibBuilder.loadTexts: allportsStatsOutDiscardsRate.setDescription('Discarded Out Packets rate for port.')
allportsStatsInErrorsRate = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 4, 1, 40), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: allportsStatsInErrorsRate.setStatus('current')
if mibBuilder.loadTexts: allportsStatsInErrorsRate.setDescription('Erroneus inbound packets rate for port.')
allportsStatsOutErrorsRate = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 4, 1, 41), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: allportsStatsOutErrorsRate.setStatus('current')
if mibBuilder.loadTexts: allportsStatsOutErrorsRate.setDescription('Not sent packets due to error rate.')
clearPortsStats = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("clear", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: clearPortsStats.setStatus('current')
if mibBuilder.loadTexts: clearPortsStats.setDescription('Setting this to clear(2) results in clearing the statistics for all ports.')
dot1RateStatsTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 7), )
if mibBuilder.loadTexts: dot1RateStatsTable.setStatus('current')
if mibBuilder.loadTexts: dot1RateStatsTable.setDescription('The table of bridging statistics per second.')
dot1RateStatsTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 7, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "dot1RateStatsIndx"))
if mibBuilder.loadTexts: dot1RateStatsTableEntry.setStatus('current')
if mibBuilder.loadTexts: dot1RateStatsTableEntry.setDescription('Bridging statistics per second.')
dot1RateStatsIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 7, 1, 1), PortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1RateStatsIndx.setStatus('current')
if mibBuilder.loadTexts: dot1RateStatsIndx.setDescription('The port index.')
dot1RatePortInFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 7, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1RatePortInFrames.setStatus('current')
if mibBuilder.loadTexts: dot1RatePortInFrames.setDescription('The number of frames that have been received per second by this port from its segment.')
dot1RatePortOutFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 7, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1RatePortOutFrames.setStatus('current')
if mibBuilder.loadTexts: dot1RatePortOutFrames.setDescription('The number of frames that have been transmitted per second by this port to its segment.')
dot1RatePortInDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 7, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1RatePortInDiscards.setStatus('current')
if mibBuilder.loadTexts: dot1RatePortInDiscards.setDescription('Count of valid frames received which were discarded per second.')
dot1RateTpLearnedEntryDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 7, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1RateTpLearnedEntryDiscards.setStatus('current')
if mibBuilder.loadTexts: dot1RateTpLearnedEntryDiscards.setDescription('The number per second of Forwarding Database entries, which have been or would have been learnt, but have been discarded due to a lack of space to store them.')
dot1RateStpPortForwardTransitions = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 7, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1RateStpPortForwardTransitions.setStatus('current')
if mibBuilder.loadTexts: dot1RateStpPortForwardTransitions.setDescription('The number of times this port has transitioned per second from the Learning state to the Forwarding state.')
dot3RateStatsTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 8), )
if mibBuilder.loadTexts: dot3RateStatsTable.setStatus('current')
if mibBuilder.loadTexts: dot3RateStatsTable.setDescription('The table of Ethernet statistics per second.')
dot3RateStatsTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 8, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "dot3RateStatsIndx"))
if mibBuilder.loadTexts: dot3RateStatsTableEntry.setStatus('current')
if mibBuilder.loadTexts: dot3RateStatsTableEntry.setDescription('Ethernet statistics per second.')
dot3RateStatsIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 8, 1, 1), PortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot3RateStatsIndx.setStatus('current')
if mibBuilder.loadTexts: dot3RateStatsIndx.setDescription('The port index.')
dot3RateStatsAlignmentErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 8, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot3RateStatsAlignmentErrors.setStatus('current')
if mibBuilder.loadTexts: dot3RateStatsAlignmentErrors.setDescription('A count of frames received per second on a particular interface that are not an integral number of octets in length and do not pass the FCS check.')
dot3RateStatsFCSErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 8, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot3RateStatsFCSErrors.setStatus('current')
if mibBuilder.loadTexts: dot3RateStatsFCSErrors.setDescription('A count of frames received per second on a particular interface that are an integral number of octets in length but do not pass the FCS check.')
dot3RateStatsSingleCollisionFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 8, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot3RateStatsSingleCollisionFrames.setStatus('current')
if mibBuilder.loadTexts: dot3RateStatsSingleCollisionFrames.setDescription('A count of successfully transmitted frames per second on a particular interface for which transmission is inhibited by exactly one collision.')
dot3RateStatsMultipleCollisionFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 8, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot3RateStatsMultipleCollisionFrames.setStatus('current')
if mibBuilder.loadTexts: dot3RateStatsMultipleCollisionFrames.setDescription('A count of successfully transmitted frames per second on a particular interface for which transmission is inhibited by more than one collision.')
dot3RateStatsLateCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 8, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot3RateStatsLateCollisions.setStatus('current')
if mibBuilder.loadTexts: dot3RateStatsLateCollisions.setDescription('The number of times per second that a collision is detected on a particular interface later than 512 bit-times into the transmission of a packet.')
dot3RateStatsExcessiveCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 8, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot3RateStatsExcessiveCollisions.setStatus('current')
if mibBuilder.loadTexts: dot3RateStatsExcessiveCollisions.setDescription('A count per second of frames for which transmission on a particular interface fails due to excessive collisions.')
dot3RateStatsInternalMacTransmitErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 8, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot3RateStatsInternalMacTransmitErrors.setStatus('current')
if mibBuilder.loadTexts: dot3RateStatsInternalMacTransmitErrors.setDescription('A count per second of frames for which transmission on a particular interface fails due to an internal MAC sublayer transmit error.')
dot3RateStatsFrameTooLongs = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 8, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot3RateStatsFrameTooLongs.setStatus('current')
if mibBuilder.loadTexts: dot3RateStatsFrameTooLongs.setDescription('A count per second of frames received on a particular interface that exceed the maximum permitted frame size.')
dot3RateStatsInternalMacReceiveErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 3, 8, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot3RateStatsInternalMacReceiveErrors.setStatus('current')
if mibBuilder.loadTexts: dot3RateStatsInternalMacReceiveErrors.setDescription('A count per second of frames for which reception on a particular interface fails due to an internal MAC sublayer receive error.')
ntpPrimaryServerReqSent = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 9, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntpPrimaryServerReqSent.setStatus('current')
if mibBuilder.loadTexts: ntpPrimaryServerReqSent.setDescription('The total number of NTP requests sent to Primary NTP Server.')
ntpPrimaryServerRespRcvd = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 9, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntpPrimaryServerRespRcvd.setStatus('current')
if mibBuilder.loadTexts: ntpPrimaryServerRespRcvd.setDescription('The total number of NTP responces received from Primary NTP Server.')
ntpPrimaryServerUpdates = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 9, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntpPrimaryServerUpdates.setStatus('current')
if mibBuilder.loadTexts: ntpPrimaryServerUpdates.setDescription('The total number of NTP Updates by Primary NTP Server.')
ntpSecondaryServerReqSent = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 9, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntpSecondaryServerReqSent.setStatus('current')
if mibBuilder.loadTexts: ntpSecondaryServerReqSent.setDescription('The total number of NTP requests sent to Secondary NTP Server.')
ntpSecondaryServerRespRcvd = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 9, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntpSecondaryServerRespRcvd.setStatus('current')
if mibBuilder.loadTexts: ntpSecondaryServerRespRcvd.setDescription('The total number of NTP responces received from Secondary NTP Server.')
ntpSecondaryServerUpdates = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 9, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntpSecondaryServerUpdates.setStatus('current')
if mibBuilder.loadTexts: ntpSecondaryServerUpdates.setDescription('The total number of NTP Updates by Secondary NTP Server.')
ntpLastUpdateServer = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 9, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("none", 0), ("primary", 1), ("secondary", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntpLastUpdateServer.setStatus('current')
if mibBuilder.loadTexts: ntpLastUpdateServer.setDescription('The type of ntp server updated last time.')
ntpLastUpdateTime = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 9, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntpLastUpdateTime.setStatus('current')
if mibBuilder.loadTexts: ntpLastUpdateTime.setDescription('The last time updated by ntp server.')
ntpClearStats = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 9, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("clear", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntpClearStats.setStatus('current')
if mibBuilder.loadTexts: ntpClearStats.setDescription('Setting this value to clear(2) clears the stats for ntp.')
ntpSystemCurrentTime = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 9, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntpSystemCurrentTime.setStatus('current')
if mibBuilder.loadTexts: ntpSystemCurrentTime.setDescription('The current system time.')
aclStatsTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 11, 1), )
if mibBuilder.loadTexts: aclStatsTable.setStatus('current')
if mibBuilder.loadTexts: aclStatsTable.setDescription('The table of ACL statistics.')
aclStatsTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 11, 1, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "aclStatsIndex"))
if mibBuilder.loadTexts: aclStatsTableEntry.setStatus('current')
if mibBuilder.loadTexts: aclStatsTableEntry.setDescription('Statistics about a particular ACL configuration entry.')
aclStatsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 11, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aclStatsIndex.setStatus('current')
if mibBuilder.loadTexts: aclStatsIndex.setDescription('The acl index.')
aclStatsHits = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 11, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aclStatsHits.setStatus('current')
if mibBuilder.loadTexts: aclStatsHits.setDescription('Total number of hits for this ACL entry')
aclClearStats = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 11, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("clear", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclClearStats.setStatus('current')
if mibBuilder.loadTexts: aclClearStats.setDescription('Setting this value to clear(2) clears the stats for the ACL.')
vmapStatsTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 11, 2), )
if mibBuilder.loadTexts: vmapStatsTable.setStatus('current')
if mibBuilder.loadTexts: vmapStatsTable.setDescription('The table of VMAP statistics.')
vmapStatsTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 11, 2, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "vmapStatsIndex"))
if mibBuilder.loadTexts: vmapStatsTableEntry.setStatus('current')
if mibBuilder.loadTexts: vmapStatsTableEntry.setDescription('Statistics about a particular VMAP configuration entry.')
vmapStatsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 11, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmapStatsIndex.setStatus('current')
if mibBuilder.loadTexts: vmapStatsIndex.setDescription('The vmap index.')
vmapStatsHits = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 11, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmapStatsHits.setStatus('current')
if mibBuilder.loadTexts: vmapStatsHits.setDescription('Total number of hits for this VMAP entry')
vmapClearStats = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 11, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("clear", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmapClearStats.setStatus('current')
if mibBuilder.loadTexts: vmapClearStats.setDescription('Setting this value to clear(2) clears the stats for the VMAP.')
acl6StatsTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 11, 3), )
if mibBuilder.loadTexts: acl6StatsTable.setStatus('current')
if mibBuilder.loadTexts: acl6StatsTable.setDescription('The table of IPv6 ACL statistics.')
acl6StatsTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 11, 3, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "aclStatsIndex"))
if mibBuilder.loadTexts: acl6StatsTableEntry.setStatus('current')
if mibBuilder.loadTexts: acl6StatsTableEntry.setDescription('Statistics about a particular IPv6 ACL configuration entry.')
acl6StatsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 11, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: acl6StatsIndex.setStatus('current')
if mibBuilder.loadTexts: acl6StatsIndex.setDescription('The ipv6 acl index.')
acl6StatsHits = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 11, 3, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: acl6StatsHits.setStatus('current')
if mibBuilder.loadTexts: acl6StatsHits.setDescription('Total number of hits for this IPv6 ACL entry')
acl6ClearStats = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 11, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("clear", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: acl6ClearStats.setStatus('current')
if mibBuilder.loadTexts: acl6ClearStats.setDescription('Setting this value to clear(2) clears the stats for the IPv6 ACL.')
snmpClearStats = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 7, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("clear", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpClearStats.setStatus('current')
if mibBuilder.loadTexts: snmpClearStats.setDescription('Setting this to clear(2) results in clearing the SNMP statistics.')
agDiffState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 4, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("diff", 1), ("flashdiff", 2), ("idle", 3), ("inprogress", 4), ("complete", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agDiffState.setStatus('current')
if mibBuilder.loadTexts: agDiffState.setDescription("When this object is read the current state is returned. idle(3) indicates that there is no diff in progess. complete(5) indicates that the last diff operation is completed. Setting the value to diff(1), will start a new diff operation Diff compares the new configuration with the current configuration and shows the pending configuration changes. Setting the value to flashdiff(1), will start a new diff operation. flashdiff compares new configuration with the flash configuration. To read the configuration changes use the agDiffTable once the state of this variable returns complete. Once the agDiffTable is read the state should be set back to 'idle' which frees the diff buffer and others can issue a diff command via SNMP.")
agDiffTableSize = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 4, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agDiffTableSize.setStatus('current')
if mibBuilder.loadTexts: agDiffTableSize.setDescription('The number of strings in the diff table.')
agDiffTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 4, 4), )
if mibBuilder.loadTexts: agDiffTable.setStatus('current')
if mibBuilder.loadTexts: agDiffTable.setDescription('The table of diff strings.')
agDiffTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 4, 4, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "agDiffIndex"))
if mibBuilder.loadTexts: agDiffTableEntry.setStatus('current')
if mibBuilder.loadTexts: agDiffTableEntry.setDescription('An entry in the diff table.')
agDiffIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 4, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agDiffIndex.setStatus('current')
if mibBuilder.loadTexts: agDiffIndex.setDescription('The table index.')
agDiffString = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 4, 4, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agDiffString.setStatus('current')
if mibBuilder.loadTexts: agDiffString.setDescription('A string in the diff table.')
agCfgDumpState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 5, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("dump", 1), ("idle", 2), ("inprogress", 3), ("complete", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agCfgDumpState.setStatus('current')
if mibBuilder.loadTexts: agCfgDumpState.setDescription("When this object is read the current state is returned. idle(2) indicates that there is no dump in progess. complete(4) indicates that the last dump operation is completed. Setting the value to dump(1), will start a new dump operation Dump will show the current configuration. To read the configuration dump use the agCfgDumpTable once the state of this variable returns complete. Once the agCfgDumpTable is read the state should be set back to 'idle' which frees the dump buffer and others can issue a dump command via SNMP.")
agCfgDumpTableSize = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 5, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCfgDumpTableSize.setStatus('current')
if mibBuilder.loadTexts: agCfgDumpTableSize.setDescription('The number of strings in the dump table.')
agCfgDumpTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 5, 4), )
if mibBuilder.loadTexts: agCfgDumpTable.setStatus('current')
if mibBuilder.loadTexts: agCfgDumpTable.setDescription('The table of dump strings.')
agCfgDumpTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 5, 4, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "agCfgDumpIndex"))
if mibBuilder.loadTexts: agCfgDumpTableEntry.setStatus('current')
if mibBuilder.loadTexts: agCfgDumpTableEntry.setDescription('An entry in the dump table.')
agCfgDumpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 5, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCfgDumpIndex.setStatus('current')
if mibBuilder.loadTexts: agCfgDumpIndex.setDescription('The table index.')
agCfgDumpString = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 5, 4, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agCfgDumpString.setStatus('current')
if mibBuilder.loadTexts: agCfgDumpString.setDescription('A string in the dump table.')
totalMemoryStats = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 12, 1), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: totalMemoryStats.setStatus('current')
if mibBuilder.loadTexts: totalMemoryStats.setDescription('The total memory in bytes.')
memoryFreeStats = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 12, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: memoryFreeStats.setStatus('current')
if mibBuilder.loadTexts: memoryFreeStats.setDescription('The free memory in bytes.')
memorySharedStats = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 12, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: memorySharedStats.setStatus('current')
if mibBuilder.loadTexts: memorySharedStats.setDescription('The shared memory in bytes.')
memoryBufferStats = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 12, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: memoryBufferStats.setStatus('current')
if mibBuilder.loadTexts: memoryBufferStats.setDescription('The buffer memory in bytes.')
swapTotalStats = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 12, 5), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swapTotalStats.setStatus('current')
if mibBuilder.loadTexts: swapTotalStats.setDescription('The total swap memory in bytes.')
swapFreeStats = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 12, 6), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swapFreeStats.setStatus('current')
if mibBuilder.loadTexts: swapFreeStats.setDescription('The free swap memory in bytes.')
highTotalStats = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 12, 7), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: highTotalStats.setStatus('current')
if mibBuilder.loadTexts: highTotalStats.setDescription('The total high memory in bytes.')
highFreeStats = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 12, 8), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: highFreeStats.setStatus('current')
if mibBuilder.loadTexts: highFreeStats.setDescription('The free high memory in bytes.')
geaportInfoTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 9, 1), )
if mibBuilder.loadTexts: geaportInfoTable.setStatus('current')
if mibBuilder.loadTexts: geaportInfoTable.setDescription('The table of gea port mapping.')
geaportInfoTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 9, 1, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "geaportInfoLogicalIndex"))
if mibBuilder.loadTexts: geaportInfoTableEntry.setStatus('current')
if mibBuilder.loadTexts: geaportInfoTableEntry.setDescription('An entry in the geaport table mapping.')
geaportInfoLogicalIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 9, 1, 1, 1), PortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: geaportInfoLogicalIndex.setStatus('current')
if mibBuilder.loadTexts: geaportInfoLogicalIndex.setDescription('The logical port index.')
geaportInfoAlias = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 9, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: geaportInfoAlias.setStatus('current')
if mibBuilder.loadTexts: geaportInfoAlias.setDescription('The GEA Port Alias.')
geaportInfoPort = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 9, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: geaportInfoPort.setStatus('current')
if mibBuilder.loadTexts: geaportInfoPort.setDescription('The GEA Port (0-based).')
geaportInfoUnit = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 9, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: geaportInfoUnit.setStatus('current')
if mibBuilder.loadTexts: geaportInfoUnit.setDescription('The GEA Unit.')
sfpInfoTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 11, 1), )
if mibBuilder.loadTexts: sfpInfoTable.setStatus('current')
if mibBuilder.loadTexts: sfpInfoTable.setDescription('The table of external port SFP information.')
sfpInfoTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 11, 1, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "sfpInfoIndx"))
if mibBuilder.loadTexts: sfpInfoTableEntry.setStatus('current')
if mibBuilder.loadTexts: sfpInfoTableEntry.setDescription('A row in the external port SFP information table.')
sfpInfoIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 11, 1, 1, 1), PortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpInfoIndx.setStatus('current')
if mibBuilder.loadTexts: sfpInfoIndx.setDescription('The external port SFX index.')
sfpInfoPort = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 11, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 6))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpInfoPort.setStatus('current')
if mibBuilder.loadTexts: sfpInfoPort.setDescription('External Port SFP/XFP alias.')
sfpInfoDevice = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 11, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 6))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpInfoDevice.setStatus('current')
if mibBuilder.loadTexts: sfpInfoDevice.setDescription('External Port SFP/XFP Device.')
sfpInfoTXEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 11, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 5))).clone(namedValues=NamedValues(("notInstalled", 1), ("enabled", 2), ("disabled", 3), ("notAvailable", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpInfoTXEnable.setStatus('current')
if mibBuilder.loadTexts: sfpInfoTXEnable.setDescription('External Port SFP/XFP TX-Enable.')
sfpInfoRXSignal = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 11, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notInstalled", 1), ("down", 2), ("link", 3), ("notAvailable", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpInfoRXSignal.setStatus('current')
if mibBuilder.loadTexts: sfpInfoRXSignal.setDescription('External Port SFP/XFP RX-Signal.')
sfpInfoTXFault = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 11, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notInstalled", 1), ("fault", 2), ("none", 3), ("notAvailable", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpInfoTXFault.setStatus('current')
if mibBuilder.loadTexts: sfpInfoTXFault.setDescription('External Port SFP/XFP TX-Fault.')
sfpInfoApproved = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 11, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 5))).clone(namedValues=NamedValues(("notInstalled", 1), ("notApproved", 2), ("sfpApproved", 3), ("sfpAccepted", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpInfoApproved.setStatus('current')
if mibBuilder.loadTexts: sfpInfoApproved.setDescription('External Port SFP/XFP Approval.')
sfpInfoVendor = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 11, 1, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpInfoVendor.setStatus('current')
if mibBuilder.loadTexts: sfpInfoVendor.setDescription('External Port SFP/XFP device vendor.')
sfpInfoSerial = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 11, 1, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpInfoSerial.setStatus('current')
if mibBuilder.loadTexts: sfpInfoSerial.setDescription('External Port SFP/XFP device serial.')
accessInfoClearAllUserFailAttempts = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 13, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("clear", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: accessInfoClearAllUserFailAttempts.setStatus('current')
if mibBuilder.loadTexts: accessInfoClearAllUserFailAttempts.setDescription('Action Object. When set to clear(2),clears all the unsuccessful attempts of users. Otherwise nothing is done. ok(1) is returned always when read.')
accessInfoClearAllUserLocks = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 13, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("clear", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: accessInfoClearAllUserLocks.setStatus('current')
if mibBuilder.loadTexts: accessInfoClearAllUserLocks.setDescription('Action Object. When set to clear(2), Unlock all locked users. Otherwise nothing is done. ok(1) is returned always when read.')
accessUserInfoTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 13, 3), )
if mibBuilder.loadTexts: accessUserInfoTable.setStatus('current')
if mibBuilder.loadTexts: accessUserInfoTable.setDescription('The table of user information.')
accessUserInfoTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 13, 3, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "accessUserInfoIndex"))
if mibBuilder.loadTexts: accessUserInfoTableEntry.setStatus('current')
if mibBuilder.loadTexts: accessUserInfoTableEntry.setDescription('An entry in the user information table.')
accessUserInfoIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 13, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: accessUserInfoIndex.setStatus('current')
if mibBuilder.loadTexts: accessUserInfoIndex.setDescription('The table index. The index value corresponds to the same value of agAccessUserCurCfgUId for the user.')
accessUserInfoLockState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 13, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("unlocked", 1), ("locked", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: accessUserInfoLockState.setStatus('current')
if mibBuilder.loadTexts: accessUserInfoLockState.setDescription('Lock State of a specific user, unlocked(1) or locked(2). When the state is locked the user is not allowed to login until the account is unlocked by the administrator.')
accessUserInfoClearFailAttempts = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 13, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("clear", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: accessUserInfoClearFailAttempts.setStatus('current')
if mibBuilder.loadTexts: accessUserInfoClearFailAttempts.setDescription('Action Object. When set to clear(2), clears the unsuccessful attempts of a particular user. Otherwise nothing is done. ok(1) is returned always when read.')
accessUserInfoClearLock = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 13, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("clear", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: accessUserInfoClearLock.setStatus('current')
if mibBuilder.loadTexts: accessUserInfoClearLock.setDescription('Action Object. When set to clear(2), unlock a particular user. Otherwise nothing is done. ok(1) is returned always when read.')
layer2 = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2))
layer2Configs = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1))
layer2Stats = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2))
layer2Info = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3))
layer2Oper = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 4))
vlan = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 1))
trunkgroup = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 2))
stgCfg = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 3))
mirroring = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 4))
lacp = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 5))
thash = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 6))
mstCfg = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 7))
l2GeneralCfg = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 8))
failoverCfg = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 10))
failoverCurCfgOnState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 10, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: failoverCurCfgOnState.setStatus('current')
if mibBuilder.loadTexts: failoverCurCfgOnState.setDescription('Failover ON/OFF setting.')
failoverNewCfgOnState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 10, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: failoverNewCfgOnState.setStatus('current')
if mibBuilder.loadTexts: failoverNewCfgOnState.setDescription('Failover ON/OFF settings.')
failoverMaxTriggerEntries = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 10, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: failoverMaxTriggerEntries.setStatus('current')
if mibBuilder.loadTexts: failoverMaxTriggerEntries.setDescription('The maximum number of entries in the Failover Trigger Table.')
failoverCurCfgTriggerTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 10, 6), )
if mibBuilder.loadTexts: failoverCurCfgTriggerTable.setStatus('current')
if mibBuilder.loadTexts: failoverCurCfgTriggerTable.setDescription('The Failover Trigger Table.')
failoverCurCfgTriggerTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 10, 6, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "failoverCurCfgTriggerId"))
if mibBuilder.loadTexts: failoverCurCfgTriggerTableEntry.setStatus('current')
if mibBuilder.loadTexts: failoverCurCfgTriggerTableEntry.setDescription('A row in the Failover Trigger Table.')
failoverCurCfgTriggerId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 10, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: failoverCurCfgTriggerId.setStatus('current')
if mibBuilder.loadTexts: failoverCurCfgTriggerId.setDescription('The Trigger identifier.')
failoverCurCfgTriggerState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 10, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: failoverCurCfgTriggerState.setStatus('current')
if mibBuilder.loadTexts: failoverCurCfgTriggerState.setDescription('Enable or disable Trigger state')
failoverCurCfgTriggerLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 10, 6, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: failoverCurCfgTriggerLimit.setStatus('current')
if mibBuilder.loadTexts: failoverCurCfgTriggerLimit.setDescription('Limit # of operational links')
failoverCurCfgTriggerMmonPort = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 10, 6, 1, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: failoverCurCfgTriggerMmonPort.setStatus('current')
if mibBuilder.loadTexts: failoverCurCfgTriggerMmonPort.setDescription('The Manual Monitor port list. The ports are presented in bitmap format: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ port 8 || || || ||___ port 7 || |____ port 6 || . . . ||_________ port 1 |__________ reserved where x : 1 - The represented port belongs to the Manual Monitor 0 - The represented port does not belong to the Manual Monitor')
failoverCurCfgTriggerMmonTrunk = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 10, 6, 1, 7), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: failoverCurCfgTriggerMmonTrunk.setStatus('current')
if mibBuilder.loadTexts: failoverCurCfgTriggerMmonTrunk.setDescription('The Manual Monitor trunk list. The trunks are presented in bitmap format: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ trunk 8 || || || ||___ trunk 7 || |____ trunk 6 || . . . ||_________ trunk 1 |__________ reserved where x : 1 - The represented trunk belongs to the Manual Monitor 0 - The represented trunk does not belong to the Manual Monitor')
failoverCurCfgTriggerMmonKey = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 10, 6, 1, 8), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: failoverCurCfgTriggerMmonKey.setStatus('current')
if mibBuilder.loadTexts: failoverCurCfgTriggerMmonKey.setDescription('The LACP admin key. This is an array of 16-bit read-only values.')
failoverCurCfgTriggerMconPort = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 10, 6, 1, 9), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: failoverCurCfgTriggerMconPort.setStatus('current')
if mibBuilder.loadTexts: failoverCurCfgTriggerMconPort.setDescription('The Manual Control port list. The ports are presented in bitmap format: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ port 8 || || || ||___ port 7 || |____ port 6 || . . . ||_________ port 1 |__________ reserved where x : 1 - The represented port belongs to the Manual Control 0 - The represented port does not belong to the Manual Control')
failoverCurCfgTriggerMconTrunk = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 10, 6, 1, 11), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: failoverCurCfgTriggerMconTrunk.setStatus('current')
if mibBuilder.loadTexts: failoverCurCfgTriggerMconTrunk.setDescription('The Manual Control trunk list. The trunks are presented in bitmap format: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ trunk 8 || || || ||___ trunk 7 || |____ trunk 6 || . . . ||_________ trunk 1 |__________ reserved where x : 1 - The represented trunk belongs to the Manual Control 0 - The represented trunk does not belong to the Manual Control')
failoverCurCfgTriggerMconKey = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 10, 6, 1, 12), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: failoverCurCfgTriggerMconKey.setStatus('current')
if mibBuilder.loadTexts: failoverCurCfgTriggerMconKey.setDescription('The LACP admin key. This is an array of 16-bit read-only values.')
failoverNewCfgTriggerTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 10, 7), )
if mibBuilder.loadTexts: failoverNewCfgTriggerTable.setStatus('current')
if mibBuilder.loadTexts: failoverNewCfgTriggerTable.setDescription('The Failover Trigger Table.')
failoverNewCfgTriggerTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 10, 7, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "failoverNewCfgTriggerId"))
if mibBuilder.loadTexts: failoverNewCfgTriggerTableEntry.setStatus('current')
if mibBuilder.loadTexts: failoverNewCfgTriggerTableEntry.setDescription('A row in the Failover Trigger Table.')
failoverNewCfgTriggerId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 10, 7, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: failoverNewCfgTriggerId.setStatus('current')
if mibBuilder.loadTexts: failoverNewCfgTriggerId.setDescription('The Trigger identifier.')
failoverNewCfgTriggerState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 10, 7, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: failoverNewCfgTriggerState.setStatus('current')
if mibBuilder.loadTexts: failoverNewCfgTriggerState.setDescription('Enable or disable Trigger state')
failoverNewCfgTriggerLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 10, 7, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1024))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: failoverNewCfgTriggerLimit.setStatus('current')
if mibBuilder.loadTexts: failoverNewCfgTriggerLimit.setDescription('Limit # of operational links')
failoverNewCfgTriggerMmonPort = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 10, 7, 1, 10), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: failoverNewCfgTriggerMmonPort.setStatus('current')
if mibBuilder.loadTexts: failoverNewCfgTriggerMmonPort.setDescription('The Manual Monitor port list. The ports are presented in bitmap format: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ port 8 || || || ||___ port 7 || |____ port 6 || . . . ||_________ port 1 |__________ reserved where x : 1 - The represented port belongs to the Manual Monitor 0 - The represented port does not belong to the Manual Monitor')
failoverNewCfgTriggerMmonPortAdd = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 10, 7, 1, 11), PortNumber()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: failoverNewCfgTriggerMmonPortAdd.setStatus('current')
if mibBuilder.loadTexts: failoverNewCfgTriggerMmonPortAdd.setDescription('Add port to Manual Monitor. When read, 0 is returned.')
failoverNewCfgTriggerMmonPortRem = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 10, 7, 1, 12), PortNumber()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: failoverNewCfgTriggerMmonPortRem.setStatus('current')
if mibBuilder.loadTexts: failoverNewCfgTriggerMmonPortRem.setDescription('Remove port from Manual Monitor. When read, 0 is returned.')
failoverNewCfgTriggerMmonTrunk = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 10, 7, 1, 13), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: failoverNewCfgTriggerMmonTrunk.setStatus('current')
if mibBuilder.loadTexts: failoverNewCfgTriggerMmonTrunk.setDescription('The Manual Monitor trunk list. The trunks are presented in bitmap format: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ trunk 8 || || || ||___ trunk 7 || |____ trunk 6 || . . . ||_________ trunk 1 |__________ reserved where x : 1 - The represented trunk belongs to the Manual Monitor 0 - The represented trunk does not belong to the Manual Monitor')
failoverNewCfgTriggerMmonTrunkAdd = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 10, 7, 1, 14), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: failoverNewCfgTriggerMmonTrunkAdd.setStatus('current')
if mibBuilder.loadTexts: failoverNewCfgTriggerMmonTrunkAdd.setDescription('Add trunk to Manual Monitor. When read, 0 is returned.')
failoverNewCfgTriggerMmonTrunkRem = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 10, 7, 1, 15), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: failoverNewCfgTriggerMmonTrunkRem.setStatus('current')
if mibBuilder.loadTexts: failoverNewCfgTriggerMmonTrunkRem.setDescription('Remove trunk from Manual Monitor. When read, 0 is returned.')
failoverNewCfgTriggerMmonKey = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 10, 7, 1, 16), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: failoverNewCfgTriggerMmonKey.setStatus('current')
if mibBuilder.loadTexts: failoverNewCfgTriggerMmonKey.setDescription('The LACP admin key. This is an array of 16-bit read-only values.')
failoverNewCfgTriggerMmonKeyAdd = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 10, 7, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: failoverNewCfgTriggerMmonKeyAdd.setStatus('current')
if mibBuilder.loadTexts: failoverNewCfgTriggerMmonKeyAdd.setDescription('Add LACP admin key to Manual Monitor. When read, 0 is returned.')
failoverNewCfgTriggerMmonKeyRem = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 10, 7, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: failoverNewCfgTriggerMmonKeyRem.setStatus('current')
if mibBuilder.loadTexts: failoverNewCfgTriggerMmonKeyRem.setDescription('Remove LACP admin key from Manual Monitor. When read, 0 is returned.')
failoverNewCfgTriggerMconPort = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 10, 7, 1, 19), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: failoverNewCfgTriggerMconPort.setStatus('current')
if mibBuilder.loadTexts: failoverNewCfgTriggerMconPort.setDescription('The Manual Control port list. The ports are presented in bitmap format: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ port 8 || || || ||___ port 7 || |____ port 6 || . . . ||_________ port 1 |__________ reserved where x : 1 - The represented port belongs to the Manual Control 0 - The represented port does not belong to the Manual Control')
failoverNewCfgTriggerMconPortAdd = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 10, 7, 1, 20), PortNumber()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: failoverNewCfgTriggerMconPortAdd.setStatus('current')
if mibBuilder.loadTexts: failoverNewCfgTriggerMconPortAdd.setDescription('Add port to Manual Control. When read, 0 is returned.')
failoverNewCfgTriggerMconPortRem = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 10, 7, 1, 21), PortNumber()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: failoverNewCfgTriggerMconPortRem.setStatus('current')
if mibBuilder.loadTexts: failoverNewCfgTriggerMconPortRem.setDescription('Remove port from Manual Control. When read, 0 is returned.')
failoverNewCfgTriggerMconTrunk = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 10, 7, 1, 25), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: failoverNewCfgTriggerMconTrunk.setStatus('current')
if mibBuilder.loadTexts: failoverNewCfgTriggerMconTrunk.setDescription('The Manual Control trunk list. The trunks are presented in bitmap format: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ trunk 8 || || || ||___ trunk 7 || |____ trunk 6 || . . . ||_________ trunk 1 |__________ reserved where x : 1 - The represented trunk belongs to the Manual Control 0 - The represented trunk does not belong to the Manual Control')
failoverNewCfgTriggerMconTrunkAdd = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 10, 7, 1, 26), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: failoverNewCfgTriggerMconTrunkAdd.setStatus('current')
if mibBuilder.loadTexts: failoverNewCfgTriggerMconTrunkAdd.setDescription('Add trunk to Manual Control. When read, 0 is returned.')
failoverNewCfgTriggerMconTrunkRem = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 10, 7, 1, 27), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: failoverNewCfgTriggerMconTrunkRem.setStatus('current')
if mibBuilder.loadTexts: failoverNewCfgTriggerMconTrunkRem.setDescription('Remove trunk from Manual Control. When read, 0 is returned.')
failoverNewCfgTriggerMconKey = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 10, 7, 1, 28), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: failoverNewCfgTriggerMconKey.setStatus('current')
if mibBuilder.loadTexts: failoverNewCfgTriggerMconKey.setDescription('The LACP admin key. This is an array of 16-bit read-only values.')
failoverNewCfgTriggerMconKeyAdd = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 10, 7, 1, 29), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: failoverNewCfgTriggerMconKeyAdd.setStatus('current')
if mibBuilder.loadTexts: failoverNewCfgTriggerMconKeyAdd.setDescription('Add LACP admin key to Manual Control. When read, 0 is returned.')
failoverNewCfgTriggerMconKeyRem = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 10, 7, 1, 30), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: failoverNewCfgTriggerMconKeyRem.setStatus('current')
if mibBuilder.loadTexts: failoverNewCfgTriggerMconKeyRem.setDescription('Remove LACP admin key from Manual Control. When read, 0 is returned.')
failoverNewCfgTriggerDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 10, 7, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("delete", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: failoverNewCfgTriggerDelete.setStatus('current')
if mibBuilder.loadTexts: failoverNewCfgTriggerDelete.setDescription('Setting the value to delete(2) will delete the entire row. When read, other(1) is returned.')
fdb = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 13))
hotlinksCfg = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 14))
hotlinksCurCfgOnState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 14, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hotlinksCurCfgOnState.setStatus('current')
if mibBuilder.loadTexts: hotlinksCurCfgOnState.setDescription('Hot Links ON/OFF setting.')
hotlinksNewCfgOnState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 14, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hotlinksNewCfgOnState.setStatus('current')
if mibBuilder.loadTexts: hotlinksNewCfgOnState.setDescription('Hot Links ON/OFF settings.')
hotlinksCurCfgFdbUpdateState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 14, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hotlinksCurCfgFdbUpdateState.setStatus('current')
if mibBuilder.loadTexts: hotlinksCurCfgFdbUpdateState.setDescription('Enable/disable Hot Links FDB Update setting.')
hotlinksNewCfgFdbUpdateState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 14, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hotlinksNewCfgFdbUpdateState.setStatus('current')
if mibBuilder.loadTexts: hotlinksNewCfgFdbUpdateState.setDescription('Enable/disable Hot Links FDB Update setting.')
hotlinksMaxTriggerEntries = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 14, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hotlinksMaxTriggerEntries.setStatus('current')
if mibBuilder.loadTexts: hotlinksMaxTriggerEntries.setDescription('The maximum number of entries in the Hot Links Trigger Table.')
hotlinksCurCfgTriggerTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 14, 6), )
if mibBuilder.loadTexts: hotlinksCurCfgTriggerTable.setStatus('current')
if mibBuilder.loadTexts: hotlinksCurCfgTriggerTable.setDescription('The Hot Links Trigger Table.')
hotlinksCurCfgTriggerTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 14, 6, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "hotlinksCurCfgTriggerId"))
if mibBuilder.loadTexts: hotlinksCurCfgTriggerTableEntry.setStatus('current')
if mibBuilder.loadTexts: hotlinksCurCfgTriggerTableEntry.setDescription('A row in the Hot Links Trigger Table.')
hotlinksCurCfgTriggerId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 14, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hotlinksCurCfgTriggerId.setStatus('current')
if mibBuilder.loadTexts: hotlinksCurCfgTriggerId.setDescription('The Trigger identifier.')
hotlinksCurCfgTriggerName = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 14, 6, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hotlinksCurCfgTriggerName.setStatus('current')
if mibBuilder.loadTexts: hotlinksCurCfgTriggerName.setDescription('A textual string containing the trigger name.')
hotlinksCurCfgTriggerState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 14, 6, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hotlinksCurCfgTriggerState.setStatus('current')
if mibBuilder.loadTexts: hotlinksCurCfgTriggerState.setDescription('Enable/disable Trigger state.')
hotlinksCurCfgTriggerPreemptState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 14, 6, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hotlinksCurCfgTriggerPreemptState.setStatus('current')
if mibBuilder.loadTexts: hotlinksCurCfgTriggerPreemptState.setDescription('Enable/disable Preemption state.')
hotlinksCurCfgTriggerFdelay = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 14, 6, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hotlinksCurCfgTriggerFdelay.setStatus('current')
if mibBuilder.loadTexts: hotlinksCurCfgTriggerFdelay.setDescription('Forward Delay setting (in secs).')
hotlinksCurCfgTriggerMasterPort = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 14, 6, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hotlinksCurCfgTriggerMasterPort.setStatus('current')
if mibBuilder.loadTexts: hotlinksCurCfgTriggerMasterPort.setDescription('The master interface port number.')
hotlinksCurCfgTriggerMasterTrunk = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 14, 6, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hotlinksCurCfgTriggerMasterTrunk.setStatus('current')
if mibBuilder.loadTexts: hotlinksCurCfgTriggerMasterTrunk.setDescription('The master interface trunk number.')
hotlinksCurCfgTriggerBackupPort = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 14, 6, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hotlinksCurCfgTriggerBackupPort.setStatus('current')
if mibBuilder.loadTexts: hotlinksCurCfgTriggerBackupPort.setDescription('The backup interface port number.')
hotlinksCurCfgTriggerBackupTrunk = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 14, 6, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hotlinksCurCfgTriggerBackupTrunk.setStatus('current')
if mibBuilder.loadTexts: hotlinksCurCfgTriggerBackupTrunk.setDescription('The backup interface trunk number.')
hotlinksCurCfgTriggerDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 14, 6, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("delete", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hotlinksCurCfgTriggerDelete.setStatus('current')
if mibBuilder.loadTexts: hotlinksCurCfgTriggerDelete.setDescription('Delete a Hot Links trigger configuration.')
hotlinksCurCfgTriggerMasterAdminkey = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 14, 6, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hotlinksCurCfgTriggerMasterAdminkey.setStatus('current')
if mibBuilder.loadTexts: hotlinksCurCfgTriggerMasterAdminkey.setDescription('The master interface admin key number.')
hotlinksCurCfgTriggerBackupAdminkey = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 14, 6, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hotlinksCurCfgTriggerBackupAdminkey.setStatus('current')
if mibBuilder.loadTexts: hotlinksCurCfgTriggerBackupAdminkey.setDescription('The backup interface admin key number.')
hotlinksNewCfgTriggerTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 14, 7), )
if mibBuilder.loadTexts: hotlinksNewCfgTriggerTable.setStatus('current')
if mibBuilder.loadTexts: hotlinksNewCfgTriggerTable.setDescription('The Hot Links Trigger Table.')
hotlinksNewCfgTriggerTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 14, 7, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "hotlinksNewCfgTriggerId"))
if mibBuilder.loadTexts: hotlinksNewCfgTriggerTableEntry.setStatus('current')
if mibBuilder.loadTexts: hotlinksNewCfgTriggerTableEntry.setDescription('A row in the Hot Links Trigger Table.')
hotlinksNewCfgTriggerId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 14, 7, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hotlinksNewCfgTriggerId.setStatus('current')
if mibBuilder.loadTexts: hotlinksNewCfgTriggerId.setDescription('The Trigger identifier.')
hotlinksNewCfgTriggerName = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 14, 7, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 33))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hotlinksNewCfgTriggerName.setStatus('current')
if mibBuilder.loadTexts: hotlinksNewCfgTriggerName.setDescription('A textual string containing the trigger name.')
hotlinksNewCfgTriggerState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 14, 7, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hotlinksNewCfgTriggerState.setStatus('current')
if mibBuilder.loadTexts: hotlinksNewCfgTriggerState.setDescription('Enable/disable Trigger state.')
hotlinksNewCfgTriggerPreemptState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 14, 7, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hotlinksNewCfgTriggerPreemptState.setStatus('current')
if mibBuilder.loadTexts: hotlinksNewCfgTriggerPreemptState.setDescription('Enable/disable Preemption state.')
hotlinksNewCfgTriggerFdelay = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 14, 7, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hotlinksNewCfgTriggerFdelay.setStatus('current')
if mibBuilder.loadTexts: hotlinksNewCfgTriggerFdelay.setDescription('Forward Delay setting (in secs).')
hotlinksNewCfgTriggerMasterPort = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 14, 7, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hotlinksNewCfgTriggerMasterPort.setStatus('current')
if mibBuilder.loadTexts: hotlinksNewCfgTriggerMasterPort.setDescription('The master interface port number.')
hotlinksNewCfgTriggerMasterTrunk = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 14, 7, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hotlinksNewCfgTriggerMasterTrunk.setStatus('current')
if mibBuilder.loadTexts: hotlinksNewCfgTriggerMasterTrunk.setDescription('The master interface trunk number.')
hotlinksNewCfgTriggerBackupPort = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 14, 7, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hotlinksNewCfgTriggerBackupPort.setStatus('current')
if mibBuilder.loadTexts: hotlinksNewCfgTriggerBackupPort.setDescription('The backup interface port number.')
hotlinksNewCfgTriggerBackupTrunk = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 14, 7, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hotlinksNewCfgTriggerBackupTrunk.setStatus('current')
if mibBuilder.loadTexts: hotlinksNewCfgTriggerBackupTrunk.setDescription('The backup interface trunk number.')
hotlinksNewCfgTriggerDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 14, 7, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("delete", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hotlinksNewCfgTriggerDelete.setStatus('current')
if mibBuilder.loadTexts: hotlinksNewCfgTriggerDelete.setDescription('Delete a Hot Links trigger configuration.')
hotlinksNewCfgTriggerMasterAdminkey = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 14, 7, 1, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hotlinksNewCfgTriggerMasterAdminkey.setStatus('current')
if mibBuilder.loadTexts: hotlinksNewCfgTriggerMasterAdminkey.setDescription('The master interface admin key number.')
hotlinksNewCfgTriggerBackupAdminkey = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 14, 7, 1, 12), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hotlinksNewCfgTriggerBackupAdminkey.setStatus('current')
if mibBuilder.loadTexts: hotlinksNewCfgTriggerBackupAdminkey.setDescription('The backup interface admin key number.')
hotlinksCurCfgBpduState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 14, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hotlinksCurCfgBpduState.setStatus('current')
if mibBuilder.loadTexts: hotlinksCurCfgBpduState.setDescription('Enable/disable Hot Links BPDU flood setting.')
hotlinksNewCfgBpduState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 14, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hotlinksNewCfgBpduState.setStatus('current')
if mibBuilder.loadTexts: hotlinksNewCfgBpduState.setDescription('Enable/disable Hot Links BPDU flood setting.')
hotlinksCurCfgFdbUpdateRate = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 14, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hotlinksCurCfgFdbUpdateRate.setStatus('current')
if mibBuilder.loadTexts: hotlinksCurCfgFdbUpdateRate.setDescription('Hot Links FDB update rate (packets per second).')
hotlinksNewCfgFdbUpdateRate = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 14, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hotlinksNewCfgFdbUpdateRate.setStatus('current')
if mibBuilder.loadTexts: hotlinksNewCfgFdbUpdateRate.setDescription('Hot Links FDB update rate (packets per second).')
lldpCfg = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 15))
vlagCfg = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 18))
vlagIslCfg = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 18, 1))
ecpCfg = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 19))
thashL2 = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 6, 1))
mirrPortMirr = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 4, 1))
mstGeneralCfg = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 7, 1))
mstCistCfg = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 7, 2))
fdbGeneralCfg = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 13, 1))
fdbCurCfgAgingTime = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 13, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fdbCurCfgAgingTime.setStatus('current')
if mibBuilder.loadTexts: fdbCurCfgAgingTime.setDescription('Fdb current aging time')
fdbNewCfgAgingTime = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 13, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fdbNewCfgAgingTime.setStatus('current')
if mibBuilder.loadTexts: fdbNewCfgAgingTime.setDescription('Fdb new aging time.')
fdbStats = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 1))
stpStats = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 2))
lacpStats = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 4))
hotlinksStats = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 6))
hotlinksStatsTriggerTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 6, 1), )
if mibBuilder.loadTexts: hotlinksStatsTriggerTable.setStatus('current')
if mibBuilder.loadTexts: hotlinksStatsTriggerTable.setDescription('The Hot Links Trigger Table Stats.')
hotlinksStatsTriggerTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 6, 1, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "hotlinksStatsTriggerId"))
if mibBuilder.loadTexts: hotlinksStatsTriggerTableEntry.setStatus('current')
if mibBuilder.loadTexts: hotlinksStatsTriggerTableEntry.setDescription('A row in the Hot Links Trigger Table Stats.')
hotlinksStatsTriggerId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 6, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hotlinksStatsTriggerId.setStatus('current')
if mibBuilder.loadTexts: hotlinksStatsTriggerId.setDescription('The Trigger identifier.')
hotlinksStatsTriggerName = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 6, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hotlinksStatsTriggerName.setStatus('current')
if mibBuilder.loadTexts: hotlinksStatsTriggerName.setDescription('A textual string containing the trigger name.')
hotlinksStatsTriggerMasterActive = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 6, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hotlinksStatsTriggerMasterActive.setStatus('current')
if mibBuilder.loadTexts: hotlinksStatsTriggerMasterActive.setDescription('The number of times the master interface was set to active.')
hotlinksStatsTriggerBackupActive = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 6, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hotlinksStatsTriggerBackupActive.setStatus('current')
if mibBuilder.loadTexts: hotlinksStatsTriggerBackupActive.setDescription('The number of times the backup interface was set to active.')
hotlinksStatsTriggerFdbUpdate = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 6, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hotlinksStatsTriggerFdbUpdate.setStatus('current')
if mibBuilder.loadTexts: hotlinksStatsTriggerFdbUpdate.setDescription('The number of times an FDB update was performed.')
hotlinksStatsTriggerFdbFailed = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 6, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hotlinksStatsTriggerFdbFailed.setStatus('current')
if mibBuilder.loadTexts: hotlinksStatsTriggerFdbFailed.setDescription('The number of times an FDB update failed.')
lldpStats = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 7))
oamStats = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 8))
vlagStats = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 11))
vlagStatsSystem = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 11, 1))
vlagStatsIsl = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 11, 2))
vlagStatsHealth = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 11, 3))
vlagStatsLacp = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 11, 4))
vlagStatsPdu = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 11, 5))
vlagStatsIgmp = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 11, 6))
fdbInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 1))
stpInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 2))
lacpInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3))
cistInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 4))
genInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 7))
vlanInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 5))
trunkGroupInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 9))
hotlinksInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 10))
hotlinksInfoOnState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 10, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hotlinksInfoOnState.setStatus('current')
if mibBuilder.loadTexts: hotlinksInfoOnState.setDescription('Hot Links ON/OFF setting info.')
hotlinksInfoFdbUpdateState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 10, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hotlinksInfoFdbUpdateState.setStatus('current')
if mibBuilder.loadTexts: hotlinksInfoFdbUpdateState.setDescription('Enable/disable Hot Links FDB Update setting info.')
hotlinksInfoTriggerTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 10, 3), )
if mibBuilder.loadTexts: hotlinksInfoTriggerTable.setStatus('current')
if mibBuilder.loadTexts: hotlinksInfoTriggerTable.setDescription('The Hot Links Trigger Table Info.')
hotlinksInfoBpduState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 10, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hotlinksInfoBpduState.setStatus('current')
if mibBuilder.loadTexts: hotlinksInfoBpduState.setDescription('Enable/disable Hot Links BPDU flood setting info.')
hotlinksInfoFdbUpdateRate = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 10, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hotlinksInfoFdbUpdateRate.setStatus('current')
if mibBuilder.loadTexts: hotlinksInfoFdbUpdateRate.setDescription('Hot Links FDB update rate (packets per second).')
hotlinksInfoTriggerTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 10, 3, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "hotlinksInfoTriggerId"))
if mibBuilder.loadTexts: hotlinksInfoTriggerTableEntry.setStatus('current')
if mibBuilder.loadTexts: hotlinksInfoTriggerTableEntry.setDescription('A row in the Hot Links Trigger Table Info.')
hotlinksInfoTriggerId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 10, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hotlinksInfoTriggerId.setStatus('current')
if mibBuilder.loadTexts: hotlinksInfoTriggerId.setDescription('The Trigger identifier.')
hotlinksInfoTriggerName = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 10, 3, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hotlinksInfoTriggerName.setStatus('current')
if mibBuilder.loadTexts: hotlinksInfoTriggerName.setDescription('A textual string containing the trigger name.')
hotlinksInfoTriggerState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 10, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hotlinksInfoTriggerState.setStatus('current')
if mibBuilder.loadTexts: hotlinksInfoTriggerState.setDescription('Enable/disable Trigger state info.')
hotlinksInfoTriggerPreemptState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 10, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hotlinksInfoTriggerPreemptState.setStatus('current')
if mibBuilder.loadTexts: hotlinksInfoTriggerPreemptState.setDescription('Enable/disable Preemption state info.')
hotlinksInfoTriggerFdelay = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 10, 3, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hotlinksInfoTriggerFdelay.setStatus('current')
if mibBuilder.loadTexts: hotlinksInfoTriggerFdelay.setDescription('Forward Delay setting info (in secs).')
hotlinksInfoTriggerActive = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 10, 3, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hotlinksInfoTriggerActive.setStatus('current')
if mibBuilder.loadTexts: hotlinksInfoTriggerActive.setDescription('A textual string containing the active interface info.')
lldpInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 11))
cistGeneralInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 4, 1))
oamInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 12))
udldInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 13))
failoverInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 14))
failoverInfoState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 14, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: failoverInfoState.setStatus('current')
if mibBuilder.loadTexts: failoverInfoState.setDescription('Current state of failover')
failoverInfoTriggerTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 14, 3), )
if mibBuilder.loadTexts: failoverInfoTriggerTable.setStatus('current')
if mibBuilder.loadTexts: failoverInfoTriggerTable.setDescription('This table holds the information for individual triggers')
failoverInfoTriggerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 14, 3, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "failoverInfoTriggerId"))
if mibBuilder.loadTexts: failoverInfoTriggerEntry.setStatus('current')
if mibBuilder.loadTexts: failoverInfoTriggerEntry.setDescription('A row in the failover trigger table.')
failoverInfoTriggerId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 14, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: failoverInfoTriggerId.setStatus('current')
if mibBuilder.loadTexts: failoverInfoTriggerId.setDescription('The trigger identifier.')
failoverInfoTriggerState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 14, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: failoverInfoTriggerState.setStatus('current')
if mibBuilder.loadTexts: failoverInfoTriggerState.setDescription('The trigger state.')
failoverInfoTriggerLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 14, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: failoverInfoTriggerLimit.setStatus('current')
if mibBuilder.loadTexts: failoverInfoTriggerLimit.setDescription('Limit number of operational links')
failoverInfoTriggerMonitorState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 14, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: failoverInfoTriggerMonitorState.setStatus('current')
if mibBuilder.loadTexts: failoverInfoTriggerMonitorState.setDescription('The runtime monitor state')
failoverInfoTriggerMonitorPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 14, 3, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: failoverInfoTriggerMonitorPorts.setStatus('current')
if mibBuilder.loadTexts: failoverInfoTriggerMonitorPorts.setDescription('The list of ports that are monitored. The ports are represented in bitmap format in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ port 8 || || || ||___ port 7 || |____ port 6 || . . . ||_________ port 1 |__________ reserved where x : 1 - The represented port belongs to Monitor list 0 - The represented port does not belong to Monitor list')
failoverInfoTriggerControlState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 14, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("auto-controlled", 1), ("auto-disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: failoverInfoTriggerControlState.setStatus('current')
if mibBuilder.loadTexts: failoverInfoTriggerControlState.setDescription('The runtime control state')
failoverInfoTriggerControlPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 14, 3, 1, 7), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: failoverInfoTriggerControlPorts.setStatus('current')
if mibBuilder.loadTexts: failoverInfoTriggerControlPorts.setDescription('The list of ports that are controlled. The ports are represented in bitmap format in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ port 8 || || || ||___ port 7 || |____ port 6 || . . . ||_________ port 1 |__________ reserved where x : 1 - The represented port belongs to Control list 0 - The represented port does not belong to Control list')
failoverInfoMonPortStateTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 14, 4), )
if mibBuilder.loadTexts: failoverInfoMonPortStateTable.setStatus('current')
if mibBuilder.loadTexts: failoverInfoMonPortStateTable.setDescription('This table holds the information for individual triggers')
failoverInfoTriggerMonPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 14, 4, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "failoverInfoTriggerMonId"), (0, "IBM-GbTOR-10G-L2L3-MIB", "failoverInfoTriggerMonPortId"))
if mibBuilder.loadTexts: failoverInfoTriggerMonPortEntry.setStatus('current')
if mibBuilder.loadTexts: failoverInfoTriggerMonPortEntry.setDescription('A row in the failover trigger table.')
failoverInfoTriggerMonId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 14, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: failoverInfoTriggerMonId.setStatus('current')
if mibBuilder.loadTexts: failoverInfoTriggerMonId.setDescription('The trigger identifier.')
failoverInfoTriggerMonPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 14, 4, 1, 2), PortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: failoverInfoTriggerMonPortId.setStatus('current')
if mibBuilder.loadTexts: failoverInfoTriggerMonPortId.setDescription('The Port identifier.')
failoverInfoTriggerMonPortStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 14, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("failed", 0), ("operational", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: failoverInfoTriggerMonPortStatus.setStatus('current')
if mibBuilder.loadTexts: failoverInfoTriggerMonPortStatus.setDescription('The Port Status.')
failoverInfoCtlPortStateTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 14, 5), )
if mibBuilder.loadTexts: failoverInfoCtlPortStateTable.setStatus('current')
if mibBuilder.loadTexts: failoverInfoCtlPortStateTable.setDescription('This table holds the information for individual triggers')
failoverInfoTriggerCtlPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 14, 5, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "failoverInfoTriggerCtlId"), (0, "IBM-GbTOR-10G-L2L3-MIB", "failoverInfoTriggerCtlPortId"))
if mibBuilder.loadTexts: failoverInfoTriggerCtlPortEntry.setStatus('current')
if mibBuilder.loadTexts: failoverInfoTriggerCtlPortEntry.setDescription('A row in the failover trigger table.')
failoverInfoTriggerCtlId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 14, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: failoverInfoTriggerCtlId.setStatus('current')
if mibBuilder.loadTexts: failoverInfoTriggerCtlId.setDescription('The trigger identifier.')
failoverInfoTriggerCtlPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 14, 5, 1, 2), PortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: failoverInfoTriggerCtlPortId.setStatus('current')
if mibBuilder.loadTexts: failoverInfoTriggerCtlPortId.setDescription('The Port identifier.')
failoverInfoTriggerCtlPortStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 14, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("failed", 0), ("operational", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: failoverInfoTriggerCtlPortStatus.setStatus('current')
if mibBuilder.loadTexts: failoverInfoTriggerCtlPortStatus.setDescription('The Port Status.')
vlagInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 16))
vlagInfoSystem = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 16, 1))
vlagInfoGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 16, 2))
vlagInfoIslGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 16, 2, 2))
ecpInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 17))
vlanMaxEnt = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlanMaxEnt.setStatus('current')
if mibBuilder.loadTexts: vlanMaxEnt.setDescription('The maximum number of rows in the VLAN configuration table.')
vlanMaxVlanID = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlanMaxVlanID.setStatus('current')
if mibBuilder.loadTexts: vlanMaxVlanID.setDescription('The maximum allowed VLAN ID.')
vlanCurCfgTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 1, 2), )
if mibBuilder.loadTexts: vlanCurCfgTable.setStatus('current')
if mibBuilder.loadTexts: vlanCurCfgTable.setDescription('The table of VLAN configuration.')
vlanCurCfgTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 1, 2, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "vlanCurCfgVlanId"))
if mibBuilder.loadTexts: vlanCurCfgTableEntry.setStatus('current')
if mibBuilder.loadTexts: vlanCurCfgTableEntry.setDescription('A row in the VLAN configuration table.')
vlanCurCfgVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 1, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlanCurCfgVlanId.setStatus('current')
if mibBuilder.loadTexts: vlanCurCfgVlanId.setDescription('The VLAN identifier.')
vlanCurCfgPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 1, 2, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlanCurCfgPorts.setStatus('current')
if mibBuilder.loadTexts: vlanCurCfgPorts.setDescription('The port list in the VLAN. The ports are presented in bitmap format. in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ port 8 || || || ||___ port 7 || |____ port 6 || . . . ||_________ port 1 |__________ reserved where x : 1 - The represented port belongs to the VLAN 0 - The represented port does not belong to the VLAN')
vlanCurCfgState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 1, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("enabled", 2), ("disabled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlanCurCfgState.setStatus('current')
if mibBuilder.loadTexts: vlanCurCfgState.setDescription('Enable or disable a VLAN')
vlanCurCfgStg = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 1, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlanCurCfgStg.setStatus('current')
if mibBuilder.loadTexts: vlanCurCfgStg.setDescription('The Spanning Tree Group for the VLAN.')
vlanCurCfgVlanName = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 1, 2, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlanCurCfgVlanName.setStatus('current')
if mibBuilder.loadTexts: vlanCurCfgVlanName.setDescription('The VLAN name.')
vlanCurCfgPrVlanType = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 1, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("none", 0), ("primary", 1), ("isolated", 2), ("community", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlanCurCfgPrVlanType.setStatus('current')
if mibBuilder.loadTexts: vlanCurCfgPrVlanType.setDescription('The type of the Private VLAN.')
vlanCurCfgPrVlanMapPriId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 1, 2, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlanCurCfgPrVlanMapPriId.setStatus('current')
if mibBuilder.loadTexts: vlanCurCfgPrVlanMapPriId.setDescription('The primary vlan id')
vlanCurCfgPrVlanState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 1, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 0))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 0)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlanCurCfgPrVlanState.setStatus('current')
if mibBuilder.loadTexts: vlanCurCfgPrVlanState.setDescription('Enable or disable a Private VLAN.')
vlanNewCfgTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 1, 3), )
if mibBuilder.loadTexts: vlanNewCfgTable.setStatus('current')
if mibBuilder.loadTexts: vlanNewCfgTable.setDescription('The table of VLAN configuration.')
vlanNewCfgTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 1, 3, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "vlanNewCfgVlanId"))
if mibBuilder.loadTexts: vlanNewCfgTableEntry.setStatus('current')
if mibBuilder.loadTexts: vlanNewCfgTableEntry.setDescription('A row in the VLAN configuration table.')
vlanNewCfgVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 1, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlanNewCfgVlanId.setStatus('current')
if mibBuilder.loadTexts: vlanNewCfgVlanId.setDescription('The VLAN identifier.')
vlanNewCfgVlanName = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 1, 3, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vlanNewCfgVlanName.setStatus('current')
if mibBuilder.loadTexts: vlanNewCfgVlanName.setDescription('The VLAN name.')
vlanNewCfgPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 1, 3, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlanNewCfgPorts.setStatus('current')
if mibBuilder.loadTexts: vlanNewCfgPorts.setDescription('The port list in the VLAN. The ports are presented in bitmap format. in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ port 8 || || || ||___ port 7 || |____ port 6 || . . . ||_________ port 1 |__________ reserved where x : 1 - The represented port belongs to the VLAN 0 - The represented port does not belong to the VLAN')
vlanNewCfgState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 1, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("enabled", 2), ("disabled", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vlanNewCfgState.setStatus('current')
if mibBuilder.loadTexts: vlanNewCfgState.setDescription('Enable or disable a VLAN')
vlanNewCfgAddPort = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 1, 3, 1, 5), PortNumber()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vlanNewCfgAddPort.setStatus('current')
if mibBuilder.loadTexts: vlanNewCfgAddPort.setDescription("The port to be added to the specified VLAN. A '0' value is returned when read.")
vlanNewCfgRemovePort = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 1, 3, 1, 6), PortNumber()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vlanNewCfgRemovePort.setStatus('current')
if mibBuilder.loadTexts: vlanNewCfgRemovePort.setDescription("The port to be removed from the specified VLAN. A '0' value is returned when read.")
vlanNewCfgDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 1, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("delete", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vlanNewCfgDelete.setStatus('current')
if mibBuilder.loadTexts: vlanNewCfgDelete.setDescription('This is an action object to create or delete a VLAN. other(1) is returned always when read. The following values are writable: delete(2)...to delete a VLAN')
vlanNewCfgStg = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 1, 3, 1, 9), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vlanNewCfgStg.setStatus('current')
if mibBuilder.loadTexts: vlanNewCfgStg.setDescription('The Spanning Tree Group for the VLAN.')
vlanNewCfgPrVlanType = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 1, 3, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("none", 0), ("primary", 1), ("isolated", 2), ("community", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlanNewCfgPrVlanType.setStatus('current')
if mibBuilder.loadTexts: vlanNewCfgPrVlanType.setDescription('The type of the Private VLAN.')
vlanNewCfgPrVlanMapPriId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 1, 3, 1, 14), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlanNewCfgPrVlanMapPriId.setStatus('current')
if mibBuilder.loadTexts: vlanNewCfgPrVlanMapPriId.setDescription('The primary vlan id. To delete set 0.')
vlanNewCfgPrVlanState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 1, 3, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 0))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlanNewCfgPrVlanState.setStatus('current')
if mibBuilder.loadTexts: vlanNewCfgPrVlanState.setDescription('Enable or disable a Private VLAN.')
lacpCurSystemPriority = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 5, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpCurSystemPriority.setStatus('current')
if mibBuilder.loadTexts: lacpCurSystemPriority.setDescription("A 2-octet read-write value indicating the priority value associated with the Actor's System ID.")
lacpNewSystemPriority = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 5, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lacpNewSystemPriority.setStatus('current')
if mibBuilder.loadTexts: lacpNewSystemPriority.setDescription("A 2-octet read-write value indicating the priority value associated with the Actor's System ID.")
lacpCurSystemTimeoutTime = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 5, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 90))).clone(namedValues=NamedValues(("short", 3), ("long", 90)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpCurSystemTimeoutTime.setStatus('current')
if mibBuilder.loadTexts: lacpCurSystemTimeoutTime.setDescription('If a port does not receive LACPDUs for Timeout time LACP information pertaining to the port is invalidated. Its every 3 sec (short) and every 90 sec (long 3).')
lacpNewSystemTimeoutTime = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 5, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 90))).clone(namedValues=NamedValues(("short", 3), ("long", 90)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lacpNewSystemTimeoutTime.setStatus('current')
if mibBuilder.loadTexts: lacpNewSystemTimeoutTime.setDescription('If a port does not receive LACPDUs for Timeout time LACP information pertaining to the port is invalidated. Its every 3 sec (short) and every 90 sec (long 3).')
lacpCurPortCfgTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 5, 7), )
if mibBuilder.loadTexts: lacpCurPortCfgTable.setStatus('current')
if mibBuilder.loadTexts: lacpCurPortCfgTable.setDescription('The table of LACP port configuration.')
lacpCurPortCfgTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 5, 7, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "lacpCurPortCfgTableId"))
if mibBuilder.loadTexts: lacpCurPortCfgTableEntry.setStatus('current')
if mibBuilder.loadTexts: lacpCurPortCfgTableEntry.setDescription('A row in the LACP port configuration table.')
lacpCurPortCfgTableId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 5, 7, 1, 1), PortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpCurPortCfgTableId.setStatus('current')
if mibBuilder.loadTexts: lacpCurPortCfgTableId.setDescription(' LACP port number.')
lacpCurPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 5, 7, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("active", 2), ("passive", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpCurPortState.setStatus('current')
if mibBuilder.loadTexts: lacpCurPortState.setDescription('LACP port state can be one of three states off (Not participating in LACP) Active (Initiates LACPDU updates) Passive (Does not initiate LACPDU updates but responds to peer.')
lacpCurPortActorPortPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 5, 7, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpCurPortActorPortPriority.setStatus('current')
if mibBuilder.loadTexts: lacpCurPortActorPortPriority.setDescription('The priority value assigned to this Aggregation Port. This 16-bit value is read-only.')
lacpCurPortActorAdminKey = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 5, 7, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpCurPortActorAdminKey.setStatus('current')
if mibBuilder.loadTexts: lacpCurPortActorAdminKey.setDescription('The current administrative value of the Key for the Aggregation Port. This is a 16-bit read-only value. The meaning of particular Key values is of local significance.')
lacpCurPortActorMinLinks = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 5, 7, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpCurPortActorMinLinks.setStatus('current')
if mibBuilder.loadTexts: lacpCurPortActorMinLinks.setDescription('The current minimum links for the Aggregation Port. This is a 16-bit read-only value. The meaning of particular Key values is of local significance.')
lacpNewPortCfgTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 5, 8), )
if mibBuilder.loadTexts: lacpNewPortCfgTable.setStatus('current')
if mibBuilder.loadTexts: lacpNewPortCfgTable.setDescription('The table of LACP port configuration.')
lacpNewPortCfgTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 5, 8, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "lacpNewPortCfgTableId"))
if mibBuilder.loadTexts: lacpNewPortCfgTableEntry.setStatus('current')
if mibBuilder.loadTexts: lacpNewPortCfgTableEntry.setDescription('A row in the LACP port configuration table.')
lacpNewPortCfgTableId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 5, 8, 1, 1), PortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpNewPortCfgTableId.setStatus('current')
if mibBuilder.loadTexts: lacpNewPortCfgTableId.setDescription(' LACP port number.')
lacpNewPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 5, 8, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("active", 2), ("passive", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lacpNewPortState.setStatus('current')
if mibBuilder.loadTexts: lacpNewPortState.setDescription('LACP port state can be one of three states off (Not participating in LACP) Active (Initiates LACPDU updates) Passive (Does not initiate LACPDU updates but responds to peer.')
lacpNewPortActorPortPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 5, 8, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lacpNewPortActorPortPriority.setStatus('current')
if mibBuilder.loadTexts: lacpNewPortActorPortPriority.setDescription('The priority value assigned to this Aggregation Port. This 16-bit value is read-write.')
lacpNewPortActorAdminKey = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 5, 8, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lacpNewPortActorAdminKey.setStatus('current')
if mibBuilder.loadTexts: lacpNewPortActorAdminKey.setDescription('The current administrative value of the Key for the Aggregation Port. This is a 16-bit read-write value. The meaning of particular Key values is of local significance.')
lacpNewPortActorMinLinks = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 5, 8, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 12))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lacpNewPortActorMinLinks.setStatus('current')
if mibBuilder.loadTexts: lacpNewPortActorMinLinks.setDescription('The current minimum links for the Aggregation Port. This is a 16-bit read-write value. The meaning of particular Key values is of local significance.')
lacpNewPortSetToDefault = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 5, 8, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("none", 1), ("setDefault", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lacpNewPortSetToDefault.setStatus('current')
if mibBuilder.loadTexts: lacpNewPortSetToDefault.setDescription('When read, always returns none(1). When setting setDefault(2) value, the LACP port settings are set to the default values.')
lacpDeleteTrunk = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 5, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lacpDeleteTrunk.setStatus('current')
if mibBuilder.loadTexts: lacpDeleteTrunk.setDescription('Delete a trunk with specified admin key')
lacpNewSystemSetToDefault = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 5, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("none", 1), ("setDefault", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lacpNewSystemSetToDefault.setStatus('current')
if mibBuilder.loadTexts: lacpNewSystemSetToDefault.setDescription('When read, always returns none(1). When setting setDefault(2) value, the LACP system settings are set to the default values.')
trunkGroupTableMaxSize = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 2, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkGroupTableMaxSize.setStatus('current')
if mibBuilder.loadTexts: trunkGroupTableMaxSize.setDescription('The maximum number of entries in trunk group table.')
trunkGroupCurCfgTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 2, 2), )
if mibBuilder.loadTexts: trunkGroupCurCfgTable.setStatus('current')
if mibBuilder.loadTexts: trunkGroupCurCfgTable.setDescription('The table of trunk group configuration.')
trunkGroupCurCfgTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 2, 2, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "trunkGroupCurCfgIndex"))
if mibBuilder.loadTexts: trunkGroupCurCfgTableEntry.setStatus('current')
if mibBuilder.loadTexts: trunkGroupCurCfgTableEntry.setDescription('A row in the trunk group configuration table.')
trunkGroupCurCfgIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 2, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkGroupCurCfgIndex.setStatus('current')
if mibBuilder.loadTexts: trunkGroupCurCfgIndex.setDescription('The identifier of the trunk group.')
trunkGroupCurCfgPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 2, 2, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkGroupCurCfgPorts.setStatus('current')
if mibBuilder.loadTexts: trunkGroupCurCfgPorts.setDescription('The port list in the trunk group. The ports are presented in bitmap format. in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ port 8 || || || ||___ port 7 || |____ port 6 || . . . ||_________ port 1 |__________ reserved where x : 1 - The represented port belongs to the trunk group 0 - The represented port does not belong to the trunk group')
trunkGroupCurCfgState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkGroupCurCfgState.setStatus('current')
if mibBuilder.loadTexts: trunkGroupCurCfgState.setDescription('Enable or disable a trunk group.')
trunkGroupNewCfgTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 2, 3), )
if mibBuilder.loadTexts: trunkGroupNewCfgTable.setStatus('current')
if mibBuilder.loadTexts: trunkGroupNewCfgTable.setDescription('The table of trunk group configuration.')
trunkGroupNewCfgTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 2, 3, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "trunkGroupNewCfgIndex"))
if mibBuilder.loadTexts: trunkGroupNewCfgTableEntry.setStatus('current')
if mibBuilder.loadTexts: trunkGroupNewCfgTableEntry.setDescription('A row in the trunk group configuration table.')
trunkGroupNewCfgIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 2, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkGroupNewCfgIndex.setStatus('current')
if mibBuilder.loadTexts: trunkGroupNewCfgIndex.setDescription('The identifier of the trunk group.')
trunkGroupNewCfgPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 2, 3, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkGroupNewCfgPorts.setStatus('current')
if mibBuilder.loadTexts: trunkGroupNewCfgPorts.setDescription('The port list in the trunk group. The ports are presented in bitmap format. in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ port 8 || || || ||___ port 7 || |____ port 6 || . . . ||_________ port 1 |__________ reserved where x : 1 - The represented port belongs to the trunk group 0 - The represented port does not belong to the trunk group')
trunkGroupNewCfgAddPort = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 2, 3, 1, 3), PortNumber()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: trunkGroupNewCfgAddPort.setStatus('current')
if mibBuilder.loadTexts: trunkGroupNewCfgAddPort.setDescription('The port to be added in the trunk group. When read, 0 is returned.')
trunkGroupNewCfgRemovePort = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 2, 3, 1, 4), PortNumber()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: trunkGroupNewCfgRemovePort.setStatus('current')
if mibBuilder.loadTexts: trunkGroupNewCfgRemovePort.setDescription('The port to be deleted from the trunk group. when read, 0 is returned.')
trunkGroupNewCfgState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 2, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: trunkGroupNewCfgState.setStatus('current')
if mibBuilder.loadTexts: trunkGroupNewCfgState.setDescription('Enable or disable a trunk group.')
trunkGroupNewCfgDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 2, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("delete", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: trunkGroupNewCfgDelete.setStatus('current')
if mibBuilder.loadTexts: trunkGroupNewCfgDelete.setDescription('Setting the value to delete(2) will delete the entire row. When read, other(1) is returned.')
trunkLacpGroupTableMaxSize = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 2, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkLacpGroupTableMaxSize.setStatus('current')
if mibBuilder.loadTexts: trunkLacpGroupTableMaxSize.setDescription('The maximum number of entries in LACP trunk group table.')
trunkLacpGroupCurCfgTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 2, 5), )
if mibBuilder.loadTexts: trunkLacpGroupCurCfgTable.setStatus('current')
if mibBuilder.loadTexts: trunkLacpGroupCurCfgTable.setDescription('The table of LACP trunk group configuration.')
trunkLacpGroupCurCfgTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 2, 5, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "trunkLacpGroupCurCfgIndex"))
if mibBuilder.loadTexts: trunkLacpGroupCurCfgTableEntry.setStatus('current')
if mibBuilder.loadTexts: trunkLacpGroupCurCfgTableEntry.setDescription('A row in the LACP trunk group configuration table.')
trunkLacpGroupCurCfgIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 2, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkLacpGroupCurCfgIndex.setStatus('current')
if mibBuilder.loadTexts: trunkLacpGroupCurCfgIndex.setDescription('The identifier of the LACP trunk group.')
trunkLacpGroupCurCfgAdminKey = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 2, 5, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkLacpGroupCurCfgAdminKey.setStatus('current')
if mibBuilder.loadTexts: trunkLacpGroupCurCfgAdminKey.setDescription('The administrative key of the LACP trunk group. Ports whose LACP key is same will be member ports of the trunk.')
trunkLacpGroupNewCfgTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 2, 6), )
if mibBuilder.loadTexts: trunkLacpGroupNewCfgTable.setStatus('current')
if mibBuilder.loadTexts: trunkLacpGroupNewCfgTable.setDescription('The table of LACP trunk group configuration.')
trunkLacpGroupNewCfgTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 2, 6, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "trunkLacpGroupNewCfgIndex"))
if mibBuilder.loadTexts: trunkLacpGroupNewCfgTableEntry.setStatus('current')
if mibBuilder.loadTexts: trunkLacpGroupNewCfgTableEntry.setDescription('A row in the LACP trunk group configuration table.')
trunkLacpGroupNewCfgIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 2, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkLacpGroupNewCfgIndex.setStatus('current')
if mibBuilder.loadTexts: trunkLacpGroupNewCfgIndex.setDescription('The identifier of the LACP trunk group.')
trunkLacpGroupNewCfgAdminKey = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 2, 6, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trunkLacpGroupNewCfgAdminKey.setStatus('current')
if mibBuilder.loadTexts: trunkLacpGroupNewCfgAdminKey.setDescription('The administrative key of the LACP trunk group. Ports whose LACP key is same will be member ports of the trunk. Value 0 means LACP trunk group deletion.')
l2ThashCurCfgSmacState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 6, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: l2ThashCurCfgSmacState.setStatus('current')
if mibBuilder.loadTexts: l2ThashCurCfgSmacState.setDescription('Enable or disable smac hash.')
l2ThashNewCfgSmacState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: l2ThashNewCfgSmacState.setStatus('current')
if mibBuilder.loadTexts: l2ThashNewCfgSmacState.setDescription('Enable or disable smac hash.')
l2ThashCurCfgDmacState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 6, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: l2ThashCurCfgDmacState.setStatus('current')
if mibBuilder.loadTexts: l2ThashCurCfgDmacState.setDescription('Enable or disable dmac hash.')
l2ThashNewCfgDmacState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 6, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: l2ThashNewCfgDmacState.setStatus('current')
if mibBuilder.loadTexts: l2ThashNewCfgDmacState.setDescription('Enable or disable dmac hash.')
l2ThashCurCfgSipState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 6, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: l2ThashCurCfgSipState.setStatus('current')
if mibBuilder.loadTexts: l2ThashCurCfgSipState.setDescription('Enable or disable sip hash.')
l2ThashNewCfgSipState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 6, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: l2ThashNewCfgSipState.setStatus('current')
if mibBuilder.loadTexts: l2ThashNewCfgSipState.setDescription('Enable or disable sip hash.')
l2ThashCurCfgDipState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 6, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: l2ThashCurCfgDipState.setStatus('current')
if mibBuilder.loadTexts: l2ThashCurCfgDipState.setDescription('Enable or disable dip hash.')
l2ThashNewCfgDipState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 6, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: l2ThashNewCfgDipState.setStatus('current')
if mibBuilder.loadTexts: l2ThashNewCfgDipState.setDescription('Enable or disable dip hash.')
stgCurCfgTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 3, 1), )
if mibBuilder.loadTexts: stgCurCfgTable.setStatus('current')
if mibBuilder.loadTexts: stgCurCfgTable.setDescription('The table of Spanning Tree Group configuration.')
stgCurCfgTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 3, 1, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "stgCurCfgIndex"))
if mibBuilder.loadTexts: stgCurCfgTableEntry.setStatus('current')
if mibBuilder.loadTexts: stgCurCfgTableEntry.setDescription('Information about a particular Spanning Tree Group configuration.')
stgCurCfgIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stgCurCfgIndex.setStatus('current')
if mibBuilder.loadTexts: stgCurCfgIndex.setDescription('The identifier of a particular Spanning Tree Group. This is also index to the entLogicalTable of Entity MIB.')
stgCurCfgState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stgCurCfgState.setStatus('current')
if mibBuilder.loadTexts: stgCurCfgState.setDescription('Turn on of off Spanning Tree operation of a particular Spanning Tree Group.')
stgCurCfgPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stgCurCfgPriority.setStatus('current')
if mibBuilder.loadTexts: stgCurCfgPriority.setDescription('The value of the write-able portion of the Bridge ID, i.e., the first two octets of the (8 octet long) Bridge ID.')
stgCurCfgBrgHelloTime = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stgCurCfgBrgHelloTime.setStatus('current')
if mibBuilder.loadTexts: stgCurCfgBrgHelloTime.setDescription('The value in seconds that all bridges use for HelloTime when this bridge is acting as the root.')
stgCurCfgBrgForwardDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(4, 30))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stgCurCfgBrgForwardDelay.setStatus('current')
if mibBuilder.loadTexts: stgCurCfgBrgForwardDelay.setDescription('The value in seconds that all bridges use for ForwardDelay when this bridge is acting as the root.')
stgCurCfgBrgMaxAge = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 3, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(6, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stgCurCfgBrgMaxAge.setStatus('current')
if mibBuilder.loadTexts: stgCurCfgBrgMaxAge.setDescription('The value in seconds that all bridges use for MaxAge when this bridge is acting as the root.')
stgCurCfgVlanBmap = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 3, 1, 1, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 512))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stgCurCfgVlanBmap.setStatus('current')
if mibBuilder.loadTexts: stgCurCfgVlanBmap.setDescription('The vlans applied to the spanning tree group. The vlans are presented in bitmap format. This string displays vlan number from 1 to 4096. in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ vlan 9 || || || ||___ vlan 8 || |____ vlan 7 || . . . ||_________ vlan 2 |__________ vlan 1 (as index to stgCurCfgTable) where x : 1 - The represented vlan applied to the spanning tree. 0 - The represented vlan not applied to the spanning tree')
stgNewCfgTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 3, 2), )
if mibBuilder.loadTexts: stgNewCfgTable.setStatus('current')
if mibBuilder.loadTexts: stgNewCfgTable.setDescription('The table of Spanning Tree Groups configuration in the new_config.')
stgNewCfgTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 3, 2, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "stgNewCfgIndex"))
if mibBuilder.loadTexts: stgNewCfgTableEntry.setStatus('current')
if mibBuilder.loadTexts: stgNewCfgTableEntry.setDescription('Information about a particular Spanning Tree Group configuration.')
stgNewCfgIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 3, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stgNewCfgIndex.setStatus('current')
if mibBuilder.loadTexts: stgNewCfgIndex.setDescription('The identifier of a particular Spanning Tree Group. This is also index to the entLogicalTable of Entity MIB.')
stgNewCfgState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 3, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: stgNewCfgState.setStatus('current')
if mibBuilder.loadTexts: stgNewCfgState.setDescription('Turn on of off Spanning Tree operation of a particular Spanning Tree Group.')
stgNewCfgDefaultCfg = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 3, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("default-config", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: stgNewCfgDefaultCfg.setStatus('current')
if mibBuilder.loadTexts: stgNewCfgDefaultCfg.setDescription('Setting the value to default-config(1) will set the default configuration as recommended by IEEE 802.1D for a particular Spanning Tree Group. default-config (1) is always returned When read, but it does not mean anything.')
stgNewCfgAddVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 3, 2, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: stgNewCfgAddVlan.setStatus('current')
if mibBuilder.loadTexts: stgNewCfgAddVlan.setDescription("The vlan to be added to the specified Spanning Tree Group. A '0' value is returned when read.")
stgNewCfgRemoveVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 3, 2, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: stgNewCfgRemoveVlan.setStatus('current')
if mibBuilder.loadTexts: stgNewCfgRemoveVlan.setDescription("The vlan to be removed from the specified Spanning Tree Group. A '0' value is returned when read.")
stgNewCfgPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 3, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: stgNewCfgPriority.setStatus('current')
if mibBuilder.loadTexts: stgNewCfgPriority.setDescription('The value of the write-able portion of the Bridge ID, i.e., the first two octets of the (8 octet long) Bridge ID.')
stgNewCfgBrgHelloTime = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 3, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: stgNewCfgBrgHelloTime.setStatus('current')
if mibBuilder.loadTexts: stgNewCfgBrgHelloTime.setDescription('The value in seconds that all bridges use for HelloTime when this bridge is acting as the root.')
stgNewCfgBrgForwardDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 3, 2, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(4, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: stgNewCfgBrgForwardDelay.setStatus('current')
if mibBuilder.loadTexts: stgNewCfgBrgForwardDelay.setDescription('The value in seconds that all bridges use for ForwardDelay when this bridge is acting as the root.')
stgNewCfgBrgMaxAge = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 3, 2, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(6, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: stgNewCfgBrgMaxAge.setStatus('current')
if mibBuilder.loadTexts: stgNewCfgBrgMaxAge.setDescription('The value in seconds that all bridges use for MaxAge when this bridge is acting as the root.')
stgNewCfgVlanBmap = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 3, 2, 1, 13), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 512))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stgNewCfgVlanBmap.setStatus('current')
if mibBuilder.loadTexts: stgNewCfgVlanBmap.setDescription('The vlans applied to the spanning tree group. The vlans are presented in bitmap format. This string displays vlan number from 1 to 4096. in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ vlan 9 || || || ||___ vlan 8 || |____ vlan 7 || . . . ||_________ vlan 2 |__________ vlan 1 (as index to stgCurCfgTable) where x : 1 - The represented vlan applied to the spanning tree. 0 - The represented vlan not applied to the spanning tree')
stgNewCfgRemoveAllVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 3, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("default-config", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: stgNewCfgRemoveAllVlan.setStatus('current')
if mibBuilder.loadTexts: stgNewCfgRemoveAllVlan.setDescription("The all vlans to be removed from the specified Spanning Tree Group. A '0' value is returned when read.")
stgCurCfgPortTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 3, 3), )
if mibBuilder.loadTexts: stgCurCfgPortTable.setStatus('current')
if mibBuilder.loadTexts: stgCurCfgPortTable.setDescription('The table of Spanning Tree Group port configuration in the current_config.')
stgCurCfgPortTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 3, 3, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "stgCurCfgStgIndex"), (0, "IBM-GbTOR-10G-L2L3-MIB", "stgCurCfgPortIndex"))
if mibBuilder.loadTexts: stgCurCfgPortTableEntry.setStatus('current')
if mibBuilder.loadTexts: stgCurCfgPortTableEntry.setDescription('Information about port configuration of a particular Spanning Tree Group.')
stgCurCfgStgIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 3, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stgCurCfgStgIndex.setStatus('current')
if mibBuilder.loadTexts: stgCurCfgStgIndex.setDescription('The identifier of a particular Spanning Tree Group. This is also index to the entLogicalTable of Entity MIB.')
stgCurCfgPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 3, 3, 1, 2), PortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stgCurCfgPortIndex.setStatus('current')
if mibBuilder.loadTexts: stgCurCfgPortIndex.setDescription('The port identifier of a particular Spanning Tree Group.')
stgCurCfgPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 3, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stgCurCfgPortState.setStatus('current')
if mibBuilder.loadTexts: stgCurCfgPortState.setDescription('Turn on of off Spanning Tree operation of a particular port of a Spanning Tree Group.')
stgCurCfgPortPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 3, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 240))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stgCurCfgPortPriority.setStatus('current')
if mibBuilder.loadTexts: stgCurCfgPortPriority.setDescription('The value of the priority field which is contained in the first (in network byte order) octet of the (2 octet long) Port ID.')
stgCurCfgPortPathCost = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 3, 3, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stgCurCfgPortPathCost.setStatus('current')
if mibBuilder.loadTexts: stgCurCfgPortPathCost.setDescription('The contribution of this port to the path cost of paths towards the spanning tree root which include this port ( range is (0..200000000) ).')
stgNewCfgPortTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 3, 4), )
if mibBuilder.loadTexts: stgNewCfgPortTable.setStatus('current')
if mibBuilder.loadTexts: stgNewCfgPortTable.setDescription('The table of Spanning Tree Group port configuration in the new_config.')
stgNewCfgPortTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 3, 4, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "stgNewCfgStgIndex"), (0, "IBM-GbTOR-10G-L2L3-MIB", "stgNewCfgPortIndex"))
if mibBuilder.loadTexts: stgNewCfgPortTableEntry.setStatus('current')
if mibBuilder.loadTexts: stgNewCfgPortTableEntry.setDescription('Information about port configuration of a particular Spanning Tree Group.')
stgNewCfgStgIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 3, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stgNewCfgStgIndex.setStatus('current')
if mibBuilder.loadTexts: stgNewCfgStgIndex.setDescription('The identifier of a particular Spanning Tree Group. This is also index to the entLogicalTable of Entity MIB.')
stgNewCfgPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 3, 4, 1, 2), PortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stgNewCfgPortIndex.setStatus('current')
if mibBuilder.loadTexts: stgNewCfgPortIndex.setDescription('The port identifier of a particular Spanning Tree Group.')
stgNewCfgPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 3, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: stgNewCfgPortState.setStatus('current')
if mibBuilder.loadTexts: stgNewCfgPortState.setDescription('Turn on of off Spanning Tree operation of a particular port of a Spanning Tree Group.')
stgNewCfgPortPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 3, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 240))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: stgNewCfgPortPriority.setStatus('current')
if mibBuilder.loadTexts: stgNewCfgPortPriority.setDescription('The value of the priority field which is contained in the first (in network byte order) octet of the (2 octet long) Port ID.')
stgNewCfgPortPathCost = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 3, 4, 1, 5), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: stgNewCfgPortPathCost.setStatus('current')
if mibBuilder.loadTexts: stgNewCfgPortPathCost.setDescription('The contribution of this port to the path cost of paths towards the spanning tree root which include this port ( range is (0..200000000) ).')
pmCurCfgPortMirrState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 4, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pmCurCfgPortMirrState.setStatus('current')
if mibBuilder.loadTexts: pmCurCfgPortMirrState.setDescription('The state of port-based port mirroring.')
pmNewCfgPortMirrState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pmNewCfgPortMirrState.setStatus('current')
if mibBuilder.loadTexts: pmNewCfgPortMirrState.setDescription('The state of port-based port mirroring.')
pmCurCfgPortMonitorTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 4, 1, 3), )
if mibBuilder.loadTexts: pmCurCfgPortMonitorTable.setStatus('current')
if mibBuilder.loadTexts: pmCurCfgPortMonitorTable.setDescription('The table of monitoring ports.')
pmCurCfgPortMonitorEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 4, 1, 3, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "pmCurCfgPmirrMoniPortIndex"), (0, "IBM-GbTOR-10G-L2L3-MIB", "pmCurCfgPmirrMirrPortIndex"))
if mibBuilder.loadTexts: pmCurCfgPortMonitorEntry.setStatus('current')
if mibBuilder.loadTexts: pmCurCfgPortMonitorEntry.setDescription('A row in the monitoring port table.')
pmCurCfgPmirrMoniPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 4, 1, 3, 1, 1), PortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pmCurCfgPmirrMoniPortIndex.setStatus('current')
if mibBuilder.loadTexts: pmCurCfgPmirrMoniPortIndex.setDescription('The monitoring port number.')
pmCurCfgPmirrMirrPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 4, 1, 3, 1, 2), PortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pmCurCfgPmirrMirrPortIndex.setStatus('current')
if mibBuilder.loadTexts: pmCurCfgPmirrMirrPortIndex.setDescription('The mirrored port number')
pmCurCfgPmirrDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 4, 1, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("in", 1), ("out", 2), ("both", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pmCurCfgPmirrDirection.setStatus('current')
if mibBuilder.loadTexts: pmCurCfgPmirrDirection.setDescription('The type of traffic to be monitored with respect to the mirrored port.')
pmNewCfgPortMonitorTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 4, 1, 4), )
if mibBuilder.loadTexts: pmNewCfgPortMonitorTable.setStatus('current')
if mibBuilder.loadTexts: pmNewCfgPortMonitorTable.setDescription('The table of monitoring ports.')
pmNewCfgPortMonitorEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 4, 1, 4, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "pmNewCfgPmirrMoniPortIndex"), (0, "IBM-GbTOR-10G-L2L3-MIB", "pmNewCfgPmirrMirrPortIndex"))
if mibBuilder.loadTexts: pmNewCfgPortMonitorEntry.setStatus('current')
if mibBuilder.loadTexts: pmNewCfgPortMonitorEntry.setDescription('A row in the monitoring port table.')
pmNewCfgPmirrMoniPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 4, 1, 4, 1, 1), PortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pmNewCfgPmirrMoniPortIndex.setStatus('current')
if mibBuilder.loadTexts: pmNewCfgPmirrMoniPortIndex.setDescription('The monitoring port number.')
pmNewCfgPmirrMirrPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 4, 1, 4, 1, 2), PortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pmNewCfgPmirrMirrPortIndex.setStatus('current')
if mibBuilder.loadTexts: pmNewCfgPmirrMirrPortIndex.setDescription('The mirrored port number')
pmNewCfgPmirrDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 4, 1, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("in", 1), ("out", 2), ("both", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pmNewCfgPmirrDirection.setStatus('current')
if mibBuilder.loadTexts: pmNewCfgPmirrDirection.setDescription('The type of traffic to be monitored with respect to the mirrored port.')
pmNewCfgPmirrDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 4, 1, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("delete", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pmNewCfgPmirrDelete.setStatus('current')
if mibBuilder.loadTexts: pmNewCfgPmirrDelete.setDescription('Setting the value to delete(2) will delete the entire row. When read, other(1) is returned.')
pmNewCfgPmonDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 4, 1, 4, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("delete", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pmNewCfgPmonDelete.setStatus('current')
if mibBuilder.loadTexts: pmNewCfgPmonDelete.setDescription('Setting the value to delete(2) will delete the monitor port. When read, other(1) is returned.')
mstCurCfgRegionName = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 7, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mstCurCfgRegionName.setStatus('current')
if mibBuilder.loadTexts: mstCurCfgRegionName.setDescription("The Name for the Region's configuration.")
mstNewCfgRegionName = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 7, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mstNewCfgRegionName.setStatus('current')
if mibBuilder.loadTexts: mstNewCfgRegionName.setDescription("The Name for the Region's configuration.")
mstCurCfgRegionRevision = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 7, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mstCurCfgRegionRevision.setStatus('current')
if mibBuilder.loadTexts: mstCurCfgRegionRevision.setDescription('Revision of the MST Region.')
mstNewCfgRegionRevision = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 7, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mstNewCfgRegionRevision.setStatus('current')
if mibBuilder.loadTexts: mstNewCfgRegionRevision.setDescription('Revision of the MST Region.')
mstCurCfgMaxHopCount = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 7, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(4, 60))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mstCurCfgMaxHopCount.setStatus('current')
if mibBuilder.loadTexts: mstCurCfgMaxHopCount.setDescription('Indicates the maximum hop count value.')
mstNewCfgMaxHopCount = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 7, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(4, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mstNewCfgMaxHopCount.setStatus('current')
if mibBuilder.loadTexts: mstNewCfgMaxHopCount.setDescription('Indicates the maximum hop count value.')
mstCurCfgStpMode = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 7, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("mstp", 1), ("rstp", 2), ("pvrst", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mstCurCfgStpMode.setStatus('current')
if mibBuilder.loadTexts: mstCurCfgStpMode.setDescription('The version of Spanning Tree Protocal the bridge is currently running.')
mstNewCfgStpMode = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 7, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("mstp", 1), ("rstp", 2), ("pvrst", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mstNewCfgStpMode.setStatus('current')
if mibBuilder.loadTexts: mstNewCfgStpMode.setDescription('The version of Spanning Tree Protocal the bridge is currently running.')
mstCistDefaultCfg = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 7, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("default", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mstCistDefaultCfg.setStatus('current')
if mibBuilder.loadTexts: mstCistDefaultCfg.setDescription('Setting the value to default(1) will set the Multiple Spanning Tree and member parameters to default. default(1) is always returned when read, but it does not mean anything.')
mstCistBridgeCfg = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 7, 2, 2))
mstCistCurCfgBridgePriority = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 7, 2, 2, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mstCistCurCfgBridgePriority.setStatus('current')
if mibBuilder.loadTexts: mstCistCurCfgBridgePriority.setDescription('The value of the writable portion of the Brigde Identifier comprising of the first two octets.')
mstCistNewCfgBridgePriority = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 7, 2, 2, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mstCistNewCfgBridgePriority.setStatus('current')
if mibBuilder.loadTexts: mstCistNewCfgBridgePriority.setDescription('The value of the writable portion of the Brigde Identifier comprising of the first two octets.')
mstCistCurCfgBridgeMaxAge = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 7, 2, 2, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(6, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mstCistCurCfgBridgeMaxAge.setStatus('current')
if mibBuilder.loadTexts: mstCistCurCfgBridgeMaxAge.setDescription('The value in seconds that all bridges use for MaxAge when this bridge is acting as the root.')
mstCistNewCfgBridgeMaxAge = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 7, 2, 2, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(6, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mstCistNewCfgBridgeMaxAge.setStatus('current')
if mibBuilder.loadTexts: mstCistNewCfgBridgeMaxAge.setDescription('The value in seconds that all bridges use for MaxAge when this bridge is acting as the root.')
mstCistCurCfgBridgeForwardDelay = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 7, 2, 2, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(4, 30))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mstCistCurCfgBridgeForwardDelay.setStatus('current')
if mibBuilder.loadTexts: mstCistCurCfgBridgeForwardDelay.setDescription('The value in seconds that all bridges use for ForwardDelay when this bridge is acting as the root.')
mstCistNewCfgBridgeForwardDelay = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 7, 2, 2, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(4, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mstCistNewCfgBridgeForwardDelay.setStatus('current')
if mibBuilder.loadTexts: mstCistNewCfgBridgeForwardDelay.setDescription('The value in seconds that all bridges use for ForwardDelay when this bridge is acting as the root.')
mstCistCurCfgVlanBmap = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 7, 2, 2, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 512))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mstCistCurCfgVlanBmap.setStatus('current')
if mibBuilder.loadTexts: mstCistCurCfgVlanBmap.setDescription('The vlans applied to the CIST group. The vlans are presented in bitmap format. This string displays vlan number from 1 to 4094. in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ vlan 9 || || || ||___ vlan 8 || |____ vlan 7 || . . . ||_________ vlan 2 |__________ vlan 1 where x : 1 - The represented vlan applied to the CIST group. 0 - The represented vlan not applied to the group')
mstCistNewCfgVlanBmap = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 7, 2, 2, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 512))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mstCistNewCfgVlanBmap.setStatus('current')
if mibBuilder.loadTexts: mstCistNewCfgVlanBmap.setDescription('The vlans applied to the CIST group. The vlans are presented in bitmap format. This string displays vlan number from 1 to 4094. in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ vlan 9 || || || ||___ vlan 8 || |____ vlan 7 || . . . ||_________ vlan 2 |__________ vlan 1 where x : 1 - The represented vlan applied to the CIST group. 0 - The represented vlan not applied to the group')
mstCistNewCfgAddVlan = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 7, 2, 2, 11), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mstCistNewCfgAddVlan.setStatus('current')
if mibBuilder.loadTexts: mstCistNewCfgAddVlan.setDescription("The vlan to be added to the CIST Group. A '0' value is returned when read.")
mstCistCurCfgPortTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 7, 2, 3), )
if mibBuilder.loadTexts: mstCistCurCfgPortTable.setStatus('current')
if mibBuilder.loadTexts: mstCistCurCfgPortTable.setDescription('The table of CIST Port configuration.')
mstCistCurCfgPortTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 7, 2, 3, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "mstCistCurCfgPortIndex"))
if mibBuilder.loadTexts: mstCistCurCfgPortTableEntry.setStatus('current')
if mibBuilder.loadTexts: mstCistCurCfgPortTableEntry.setDescription('Information about a particular CIST Port configuration.')
mstCistCurCfgPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 7, 2, 3, 1, 1), PortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mstCistCurCfgPortIndex.setStatus('current')
if mibBuilder.loadTexts: mstCistCurCfgPortIndex.setDescription('The port number of the port for which this entry contains spanning tree configuration.')
mstCistCurCfgPortPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 7, 2, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 240))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mstCistCurCfgPortPriority.setStatus('current')
if mibBuilder.loadTexts: mstCistCurCfgPortPriority.setDescription('The four most significant bits of the Port Identifier of the Spanning Tree instance can be modified by setting this value.')
mstCistCurCfgPortPathCost = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 7, 2, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 200000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mstCistCurCfgPortPathCost.setStatus('current')
if mibBuilder.loadTexts: mstCistCurCfgPortPathCost.setDescription('The contribution of this port to the path cost of paths towards the CIST Root which include this port.')
mstCistCurCfgPortLinkType = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 7, 2, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("auto", 1), ("p2p", 2), ("shared", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mstCistCurCfgPortLinkType.setStatus('current')
if mibBuilder.loadTexts: mstCistCurCfgPortLinkType.setDescription('The administrative point-to-point status of the LAN segment attached to this port. A value of p2p (2) indicates that this port should always be treated as if it is connected to a point-to-point link. A value of shared(3) indicates that this port should be treated as having a shared media connection. A value of auto(1) indicates that this port is considered to have a point-to-point link if it is an Aggregator and all of its members are aggregatable, or if the MAC entity is configured for full duplex operation, either through auto-negotiation or by management means. (for MSTP only)')
mstCistCurCfgPortEdge = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 7, 2, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mstCistCurCfgPortEdge.setStatus('current')
if mibBuilder.loadTexts: mstCistCurCfgPortEdge.setDescription('The value of the Edge Port parameter. (for MSTP only)')
mstCistCurCfgPortStpState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 7, 2, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mstCistCurCfgPortStpState.setStatus('current')
if mibBuilder.loadTexts: mstCistCurCfgPortStpState.setDescription("Turn port's Spanning Tree on/off.")
mstCistCurCfgPortHelloTime = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 7, 2, 3, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mstCistCurCfgPortHelloTime.setStatus('current')
if mibBuilder.loadTexts: mstCistCurCfgPortHelloTime.setDescription('The amount of time between the transmission of Configuration Port PDUs in seconds.')
mstCistCurCfgPortPvstProtection = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 7, 2, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mstCistCurCfgPortPvstProtection.setStatus('current')
if mibBuilder.loadTexts: mstCistCurCfgPortPvstProtection.setDescription('The value of the PVST Protection parameter.')
mstCistNewCfgPortTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 7, 2, 4), )
if mibBuilder.loadTexts: mstCistNewCfgPortTable.setStatus('current')
if mibBuilder.loadTexts: mstCistNewCfgPortTable.setDescription('The table of CIST Port configuration.')
mstCistNewCfgPortTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 7, 2, 4, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "mstCistNewCfgPortIndex"))
if mibBuilder.loadTexts: mstCistNewCfgPortTableEntry.setStatus('current')
if mibBuilder.loadTexts: mstCistNewCfgPortTableEntry.setDescription('Information about a particular CIST Port configuration.')
mstCistNewCfgPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 7, 2, 4, 1, 1), PortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mstCistNewCfgPortIndex.setStatus('current')
if mibBuilder.loadTexts: mstCistNewCfgPortIndex.setDescription('The port number of the port for which this entry contains spanning tree configuration.')
mstCistNewCfgPortPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 7, 2, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 240))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mstCistNewCfgPortPriority.setStatus('current')
if mibBuilder.loadTexts: mstCistNewCfgPortPriority.setDescription('The four most significant bits of the Port Identifier of the Spanning Tree instance can be modified by setting this value.')
mstCistNewCfgPortPathCost = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 7, 2, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 200000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mstCistNewCfgPortPathCost.setStatus('current')
if mibBuilder.loadTexts: mstCistNewCfgPortPathCost.setDescription('The contribution of this port to the path cost of paths towards the CIST Root which include this port.')
mstCistNewCfgPortStpState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 7, 2, 4, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mstCistNewCfgPortStpState.setStatus('current')
if mibBuilder.loadTexts: mstCistNewCfgPortStpState.setDescription("Turn port's Spanning Tree on/off.")
mstCistNewCfgPortHelloTime = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 7, 2, 4, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mstCistNewCfgPortHelloTime.setStatus('current')
if mibBuilder.loadTexts: mstCistNewCfgPortHelloTime.setDescription('The amount of time between the transmission of Configuration Port PDUs in seconds.')
mstCistNewCfgPortPvstProtection = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 7, 2, 4, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mstCistNewCfgPortPvstProtection.setStatus('current')
if mibBuilder.loadTexts: mstCistNewCfgPortPvstProtection.setDescription('The value of the PVST Protection parameter.')
pvstCompatibilityCurCfgState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 8, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pvstCompatibilityCurCfgState.setStatus('current')
if mibBuilder.loadTexts: pvstCompatibilityCurCfgState.setDescription('Enable or disable PVST+ compatibility')
pvstCompatibilityNewCfgState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 8, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvstCompatibilityNewCfgState.setStatus('current')
if mibBuilder.loadTexts: pvstCompatibilityNewCfgState.setDescription('Enable or disable PVST+ compatibility')
nostpCurCfgState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 8, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nostpCurCfgState.setStatus('current')
if mibBuilder.loadTexts: nostpCurCfgState.setDescription('STP Mode Disable global state.')
nostpNewCfgState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 8, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nostpNewCfgState.setStatus('current')
if mibBuilder.loadTexts: nostpNewCfgState.setDescription('Enable or disable STP Mode Disable.')
stpLoopGuardCurCfgState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 8, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stpLoopGuardCurCfgState.setStatus('current')
if mibBuilder.loadTexts: stpLoopGuardCurCfgState.setDescription('STP loop guard global state.')
stpLoopGuardNewCfgState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 8, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: stpLoopGuardNewCfgState.setStatus('current')
if mibBuilder.loadTexts: stpLoopGuardNewCfgState.setDescription('Enable or disable STP loop guard.')
vlanAutoStgCurCfgState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 8, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlanAutoStgCurCfgState.setStatus('current')
if mibBuilder.loadTexts: vlanAutoStgCurCfgState.setDescription('VLAN automatic STG assignment global state.')
vlanAutoStgNewCfgState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 8, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlanAutoStgNewCfgState.setStatus('current')
if mibBuilder.loadTexts: vlanAutoStgNewCfgState.setDescription('Enable or disable VLAN automatic STG assignment.')
lldpPortTableMaxEnt = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 15, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpPortTableMaxEnt.setStatus('current')
if mibBuilder.loadTexts: lldpPortTableMaxEnt.setDescription('The maximum number of rows in the port configuration host table.')
lldpCurCfgPortTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 15, 2), )
if mibBuilder.loadTexts: lldpCurCfgPortTable.setStatus('current')
if mibBuilder.loadTexts: lldpCurCfgPortTable.setDescription('The table of LLDP port configuration in the current_configuration block.')
lldpCurCfgPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 15, 2, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "lldpCurCfgPortIndx"))
if mibBuilder.loadTexts: lldpCurCfgPortEntry.setStatus('current')
if mibBuilder.loadTexts: lldpCurCfgPortEntry.setDescription('A row in the LLDP port configuration table in the current_configuration block.')
lldpCurCfgPortIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 15, 2, 1, 1), PortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpCurCfgPortIndx.setStatus('current')
if mibBuilder.loadTexts: lldpCurCfgPortIndx.setDescription('The index of the row in LLDP port configurations table.')
lldpCurCfgPortAdmStat = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 15, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("enabledTxOnly", 1), ("enabledRxOnly", 2), ("enabledRxTx", 3), ("disabled", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpCurCfgPortAdmStat.setStatus('current')
if mibBuilder.loadTexts: lldpCurCfgPortAdmStat.setDescription('This is the admin status of the LLDP port.')
lldpCurCfgPortSnmpTrap = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 15, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpCurCfgPortSnmpTrap.setStatus('current')
if mibBuilder.loadTexts: lldpCurCfgPortSnmpTrap.setDescription('This is the SNMP trap notification state of the LLDP port.')
lldpCurCfgPortportdesctlv = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 15, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpCurCfgPortportdesctlv.setStatus('current')
if mibBuilder.loadTexts: lldpCurCfgPortportdesctlv.setDescription('This is the Port Description TLV state of the LLDP port.')
lldpCurCfgPortsysnametlv = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 15, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpCurCfgPortsysnametlv.setStatus('current')
if mibBuilder.loadTexts: lldpCurCfgPortsysnametlv.setDescription('This is the System Name TLV state of the LLDP port.')
lldpCurCfgPortsysdescrtlv = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 15, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpCurCfgPortsysdescrtlv.setStatus('current')
if mibBuilder.loadTexts: lldpCurCfgPortsysdescrtlv.setDescription('This is the System Description TLV state of the LLDP port.')
lldpCurCfgPortsyscaptlv = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 15, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpCurCfgPortsyscaptlv.setStatus('current')
if mibBuilder.loadTexts: lldpCurCfgPortsyscaptlv.setDescription('This is the System Capabilities TLV state of the LLDP port.')
lldpCurCfgPortmgmtaddrtlv = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 15, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpCurCfgPortmgmtaddrtlv.setStatus('current')
if mibBuilder.loadTexts: lldpCurCfgPortmgmtaddrtlv.setDescription('This is the Management Address TLV state of the LLDP port.')
lldpCurCfgPortportvidtlv = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 15, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpCurCfgPortportvidtlv.setStatus('current')
if mibBuilder.loadTexts: lldpCurCfgPortportvidtlv.setDescription('This is the Port VLAN ID TLV state of the LLDP port.')
lldpCurCfgPortportprottlv = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 15, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpCurCfgPortportprottlv.setStatus('current')
if mibBuilder.loadTexts: lldpCurCfgPortportprottlv.setDescription('This is the Port and Protocol VLAN ID TLV state of the LLDP port.')
lldpCurCfgPortvlannametlv = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 15, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpCurCfgPortvlannametlv.setStatus('current')
if mibBuilder.loadTexts: lldpCurCfgPortvlannametlv.setDescription('This is the VLAN Name TLV state of the LLDP port.')
lldpCurCfgPortprotidtlv = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 15, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpCurCfgPortprotidtlv.setStatus('current')
if mibBuilder.loadTexts: lldpCurCfgPortprotidtlv.setDescription('This is the Protocol Identity TLV state of the LLDP port.')
lldpCurCfgPortmacphytlv = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 15, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpCurCfgPortmacphytlv.setStatus('current')
if mibBuilder.loadTexts: lldpCurCfgPortmacphytlv.setDescription('This is the MAC/PHY Configuration/Status TLV state of the LLDP port.')
lldpCurCfgPortpowermditlv = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 15, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpCurCfgPortpowermditlv.setStatus('current')
if mibBuilder.loadTexts: lldpCurCfgPortpowermditlv.setDescription('This is the Power Via MDI TLV state of the LLDP port.')
lldpCurCfgPortlinkaggrtlv = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 15, 2, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpCurCfgPortlinkaggrtlv.setStatus('current')
if mibBuilder.loadTexts: lldpCurCfgPortlinkaggrtlv.setDescription('This is the Link Aggregation TLV state of the LLDP port.')
lldpCurCfgPortframesztlv = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 15, 2, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpCurCfgPortframesztlv.setStatus('current')
if mibBuilder.loadTexts: lldpCurCfgPortframesztlv.setDescription('This is the Maximum Frame Size TLV state of the LLDP port.')
lldpCurCfgPortdcbxtlv = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 15, 2, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpCurCfgPortdcbxtlv.setStatus('current')
if mibBuilder.loadTexts: lldpCurCfgPortdcbxtlv.setDescription('This is the DCBX TLV state of the LLDP port.')
lldpNewCfgPortTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 15, 3), )
if mibBuilder.loadTexts: lldpNewCfgPortTable.setStatus('current')
if mibBuilder.loadTexts: lldpNewCfgPortTable.setDescription('The table of LLDP port configuration in the new_configuration block.')
lldpNewCfgPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 15, 3, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "lldpNewCfgPortIndx"))
if mibBuilder.loadTexts: lldpNewCfgPortEntry.setStatus('current')
if mibBuilder.loadTexts: lldpNewCfgPortEntry.setDescription('A row in the LLDP port configuration table in the new_configuration block.')
lldpNewCfgPortIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 15, 3, 1, 1), PortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpNewCfgPortIndx.setStatus('current')
if mibBuilder.loadTexts: lldpNewCfgPortIndx.setDescription('The index of the row in LLDP port configurations table.')
lldpNewCfgPortAdmStat = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 15, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("enabledTxOnly", 1), ("enabledRxOnly", 2), ("enabledRxTx", 3), ("disabled", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lldpNewCfgPortAdmStat.setStatus('current')
if mibBuilder.loadTexts: lldpNewCfgPortAdmStat.setDescription('This is the admin status of the LLDP port.')
lldpNewCfgPortSnmpTrap = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 15, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lldpNewCfgPortSnmpTrap.setStatus('current')
if mibBuilder.loadTexts: lldpNewCfgPortSnmpTrap.setDescription('This is the SNMP trap notification state of the LLDP port')
lldpNewCfgPortportdesctlv = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 15, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lldpNewCfgPortportdesctlv.setStatus('current')
if mibBuilder.loadTexts: lldpNewCfgPortportdesctlv.setDescription('This is the Port Description TLV state of the LLDP port.')
lldpNewCfgPortsysnametlv = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 15, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lldpNewCfgPortsysnametlv.setStatus('current')
if mibBuilder.loadTexts: lldpNewCfgPortsysnametlv.setDescription('This is the System Name TLV state of the LLDP port.')
lldpNewCfgPortsysdescrtlv = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 15, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lldpNewCfgPortsysdescrtlv.setStatus('current')
if mibBuilder.loadTexts: lldpNewCfgPortsysdescrtlv.setDescription('This is the System Description TLV state of the LLDP port.')
lldpNewCfgPortsyscaptlv = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 15, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lldpNewCfgPortsyscaptlv.setStatus('current')
if mibBuilder.loadTexts: lldpNewCfgPortsyscaptlv.setDescription('This is the System Capabilities TLV state of the LLDP port.')
lldpNewCfgPortmgmtaddrtlv = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 15, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lldpNewCfgPortmgmtaddrtlv.setStatus('current')
if mibBuilder.loadTexts: lldpNewCfgPortmgmtaddrtlv.setDescription('This is the Management Address TLV state of the LLDP port.')
lldpNewCfgPortportvidtlv = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 15, 3, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lldpNewCfgPortportvidtlv.setStatus('current')
if mibBuilder.loadTexts: lldpNewCfgPortportvidtlv.setDescription('This is the Port VLAN ID TLV state of the LLDP port.')
lldpNewCfgPortportprottlv = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 15, 3, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lldpNewCfgPortportprottlv.setStatus('current')
if mibBuilder.loadTexts: lldpNewCfgPortportprottlv.setDescription('This is the Port and Protocol VLAN ID TLV state of the LLDP port.')
lldpNewCfgPortvlannametlv = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 15, 3, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lldpNewCfgPortvlannametlv.setStatus('current')
if mibBuilder.loadTexts: lldpNewCfgPortvlannametlv.setDescription('This is the VLAN Name TLV state of the LLDP port.')
lldpNewCfgPortprotidtlv = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 15, 3, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lldpNewCfgPortprotidtlv.setStatus('current')
if mibBuilder.loadTexts: lldpNewCfgPortprotidtlv.setDescription('This is the Protocol Identity TLV state of the LLDP port.')
lldpNewCfgPortmacphytlv = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 15, 3, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lldpNewCfgPortmacphytlv.setStatus('current')
if mibBuilder.loadTexts: lldpNewCfgPortmacphytlv.setDescription('This is the MAC/PHY Configuration/Status TLV state of the LLDP port.')
lldpNewCfgPortpowermditlv = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 15, 3, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lldpNewCfgPortpowermditlv.setStatus('current')
if mibBuilder.loadTexts: lldpNewCfgPortpowermditlv.setDescription('This is the Power Via MDI TLV state of the LLDP port.')
lldpNewCfgPortlinkaggrtlv = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 15, 3, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lldpNewCfgPortlinkaggrtlv.setStatus('current')
if mibBuilder.loadTexts: lldpNewCfgPortlinkaggrtlv.setDescription('This is the Link Aggregation TLV state of the LLDP port.')
lldpNewCfgPortframesztlv = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 15, 3, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lldpNewCfgPortframesztlv.setStatus('current')
if mibBuilder.loadTexts: lldpNewCfgPortframesztlv.setDescription('This is the Maximum Frame Size TLV state of the LLDP port.')
lldpNewCfgPortalltlv = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 15, 3, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("other", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lldpNewCfgPortalltlv.setStatus('current')
if mibBuilder.loadTexts: lldpNewCfgPortalltlv.setDescription("Set the corresponding state for all the LLDP port's TLVs. other(3) is returned when the object is read.")
lldpNewCfgPortdcbxtlv = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 15, 3, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lldpNewCfgPortdcbxtlv.setStatus('current')
if mibBuilder.loadTexts: lldpNewCfgPortdcbxtlv.setDescription('This is the DCBX TLV state of the LLDP port.')
lldpGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 15, 4))
lldpCurCfgState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 15, 4, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpCurCfgState.setStatus('current')
if mibBuilder.loadTexts: lldpCurCfgState.setDescription('LLDP global state.')
lldpNewCfgState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 15, 4, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lldpNewCfgState.setStatus('current')
if mibBuilder.loadTexts: lldpNewCfgState.setDescription('Globally turn LLDP on or off.')
lldpCurCfgMsgTxInt = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 15, 4, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 32768))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpCurCfgMsgTxInt.setStatus('current')
if mibBuilder.loadTexts: lldpCurCfgMsgTxInt.setDescription('LLDP message transmission interval for LLDPDU.')
lldpNewCfgMsgTxInt = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 15, 4, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 32768))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lldpNewCfgMsgTxInt.setStatus('current')
if mibBuilder.loadTexts: lldpNewCfgMsgTxInt.setDescription('LLDP message transmission interval for LLDPDU.')
lldpCurCfgMsgTxHld = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 15, 4, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpCurCfgMsgTxHld.setStatus('current')
if mibBuilder.loadTexts: lldpCurCfgMsgTxHld.setDescription('LLDP message transmission holdtime-multiplier.')
lldpNewCfgMsgTxHld = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 15, 4, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lldpNewCfgMsgTxHld.setStatus('current')
if mibBuilder.loadTexts: lldpNewCfgMsgTxHld.setDescription('LLDP message transmission holdtime-multiplier.')
lldpCurCfgNotifInt = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 15, 4, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpCurCfgNotifInt.setStatus('current')
if mibBuilder.loadTexts: lldpCurCfgNotifInt.setDescription('LLDP minimum SNMP trap notification interval.')
lldpNewCfgNotifInt = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 15, 4, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lldpNewCfgNotifInt.setStatus('current')
if mibBuilder.loadTexts: lldpNewCfgNotifInt.setDescription('LLDP minimum SNMP trap notification interval.')
lldpCurCfgTxDelay = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 15, 4, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8192))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpCurCfgTxDelay.setStatus('current')
if mibBuilder.loadTexts: lldpCurCfgTxDelay.setDescription('LLDP delay interval between advertisements.')
lldpNewCfgTxDelay = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 15, 4, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8192))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lldpNewCfgTxDelay.setStatus('current')
if mibBuilder.loadTexts: lldpNewCfgTxDelay.setDescription('LLDP delay interval between advertisements.')
lldpCurCfgReinitDelay = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 15, 4, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpCurCfgReinitDelay.setStatus('current')
if mibBuilder.loadTexts: lldpCurCfgReinitDelay.setDescription('LLDP reinit delay interval.')
lldpNewCfgReinitDelay = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 15, 4, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lldpNewCfgReinitDelay.setStatus('current')
if mibBuilder.loadTexts: lldpNewCfgReinitDelay.setDescription('LLDP reinit delay interval.')
lldpStatsTableMaxEnt = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 7, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpStatsTableMaxEnt.setStatus('current')
if mibBuilder.loadTexts: lldpStatsTableMaxEnt.setDescription('The maximum number of rows in the statistics host table.')
lldpStatsTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 7, 2), )
if mibBuilder.loadTexts: lldpStatsTable.setStatus('current')
if mibBuilder.loadTexts: lldpStatsTable.setDescription('The table of LLDP statistics.')
lldpStatsClearAll = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 7, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("clear", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lldpStatsClearAll.setStatus('current')
if mibBuilder.loadTexts: lldpStatsClearAll.setDescription('Setting this to clear(2) results in clearing the LLDP statistics for all the ports.')
lldpStatsTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 7, 2, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "lldpStatsIndex"))
if mibBuilder.loadTexts: lldpStatsTableEntry.setStatus('current')
if mibBuilder.loadTexts: lldpStatsTableEntry.setDescription('LLDP statistics info.')
lldpStatsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 7, 2, 1, 1), PortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpStatsIndex.setStatus('current')
if mibBuilder.loadTexts: lldpStatsIndex.setDescription('The index of the row in LLDP port statistics.')
lldpStatsFramesOutTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 7, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpStatsFramesOutTotal.setStatus('current')
if mibBuilder.loadTexts: lldpStatsFramesOutTotal.setDescription('The total number of LLDP frames transmitted in this port.')
lldpStatsFramesInTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 7, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpStatsFramesInTotal.setStatus('current')
if mibBuilder.loadTexts: lldpStatsFramesInTotal.setDescription('The total number of LLDP frames received in this port.')
lldpStatsFramesInErrorsTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 7, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpStatsFramesInErrorsTotal.setStatus('current')
if mibBuilder.loadTexts: lldpStatsFramesInErrorsTotal.setDescription('The total number of erroneous LLDP frames received in this port.')
lldpStatsFramesDiscardedTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 7, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpStatsFramesDiscardedTotal.setStatus('current')
if mibBuilder.loadTexts: lldpStatsFramesDiscardedTotal.setDescription('The total number of received LLDP frames discarded in this port.')
lldpStatsTLVsUnrecognizedTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 7, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpStatsTLVsUnrecognizedTotal.setStatus('current')
if mibBuilder.loadTexts: lldpStatsTLVsUnrecognizedTotal.setDescription('The total number of unrecognized TLVs in this port.')
lldpStatsAgeoutsTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 7, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpStatsAgeoutsTotal.setStatus('current')
if mibBuilder.loadTexts: lldpStatsAgeoutsTotal.setDescription("The total number of neighbor's information deleted in this port.")
lldpStatsClear = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 7, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("clear", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lldpStatsClear.setStatus('current')
if mibBuilder.loadTexts: lldpStatsClear.setDescription('Setting this to clear(2) results in clearing the LLDP statistics.')
lldpInfoPortTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 11, 1), )
if mibBuilder.loadTexts: lldpInfoPortTable.setStatus('current')
if mibBuilder.loadTexts: lldpInfoPortTable.setDescription('The table of LLDP Port Info.')
lldpInfoPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 11, 1, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "lldpInfoPortIndex"))
if mibBuilder.loadTexts: lldpInfoPortEntry.setStatus('current')
if mibBuilder.loadTexts: lldpInfoPortEntry.setDescription('LLDP Port Info.')
lldpInfoPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 11, 1, 1, 1), PortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpInfoPortIndex.setStatus('current')
if mibBuilder.loadTexts: lldpInfoPortIndex.setDescription('The index of the row in LLDP info port table.')
lldpInfoPortAlias = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 11, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpInfoPortAlias.setStatus('current')
if mibBuilder.loadTexts: lldpInfoPortAlias.setDescription('The port alias of the port in LLDP info port table.')
lldpInfoPortMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 11, 1, 1, 3), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpInfoPortMacAddress.setStatus('current')
if mibBuilder.loadTexts: lldpInfoPortMacAddress.setDescription('The mac address of the port in LLDP info port table.')
lldpInfoPortMtu = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 11, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpInfoPortMtu.setStatus('current')
if mibBuilder.loadTexts: lldpInfoPortMtu.setDescription('The MTU size of the port in LLDP info port table.')
lldpInfoPortEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 11, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpInfoPortEnabled.setStatus('current')
if mibBuilder.loadTexts: lldpInfoPortEnabled.setDescription('The PortEnabled field of the port in LLDP info port table.')
lldpInfoPortAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 11, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("enabledTxOnly", 1), ("enabledRxOnly", 2), ("enabledRxTx", 3), ("disabled", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpInfoPortAdminStatus.setStatus('current')
if mibBuilder.loadTexts: lldpInfoPortAdminStatus.setDescription('The Admin Status of the port in LLDP info port table.')
lldpInfoPortRxChanges = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 11, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpInfoPortRxChanges.setStatus('current')
if mibBuilder.loadTexts: lldpInfoPortRxChanges.setDescription('The rxChanges field of the port in LLDP info port table.')
lldpInfoPortportdesctlv = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 11, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpInfoPortportdesctlv.setStatus('current')
if mibBuilder.loadTexts: lldpInfoPortportdesctlv.setDescription('This is the Port Description TLV state of the LLDP port.')
lldpInfoPortsysnametlv = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 11, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpInfoPortsysnametlv.setStatus('current')
if mibBuilder.loadTexts: lldpInfoPortsysnametlv.setDescription('This is the System Name TLV state of the LLDP port.')
lldpInfoPortsysdescrtlv = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 11, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpInfoPortsysdescrtlv.setStatus('current')
if mibBuilder.loadTexts: lldpInfoPortsysdescrtlv.setDescription('This is the System Description TLV state of the LLDP port.')
lldpInfoPortsyscaptlv = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 11, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpInfoPortsyscaptlv.setStatus('current')
if mibBuilder.loadTexts: lldpInfoPortsyscaptlv.setDescription('This is the System Capabilities TLV state of the LLDP port.')
lldpInfoPortmgmtaddrtlv = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 11, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpInfoPortmgmtaddrtlv.setStatus('current')
if mibBuilder.loadTexts: lldpInfoPortmgmtaddrtlv.setDescription('This is the Management Address TLV state of the LLDP port.')
lldpInfoPortportvidtlv = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 11, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpInfoPortportvidtlv.setStatus('current')
if mibBuilder.loadTexts: lldpInfoPortportvidtlv.setDescription('This is the Port VLAN ID TLV state of the LLDP port.')
lldpInfoPortportprottlv = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 11, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpInfoPortportprottlv.setStatus('current')
if mibBuilder.loadTexts: lldpInfoPortportprottlv.setDescription('This is the Port and Protocol VLAN ID TLV state of the LLDP port.')
lldpInfoPortvlannametlv = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 11, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpInfoPortvlannametlv.setStatus('current')
if mibBuilder.loadTexts: lldpInfoPortvlannametlv.setDescription('This is the VLAN Name TLV state of the LLDP port.')
lldpInfoPortprotidtlv = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 11, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpInfoPortprotidtlv.setStatus('current')
if mibBuilder.loadTexts: lldpInfoPortprotidtlv.setDescription('This is the Protocol Identity TLV state of the LLDP port.')
lldpInfoPortmacphytlv = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 11, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpInfoPortmacphytlv.setStatus('current')
if mibBuilder.loadTexts: lldpInfoPortmacphytlv.setDescription('This is the MAC/PHY Configuration/Status TLV state of the LLDP port.')
lldpInfoPortpowermditlv = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 11, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpInfoPortpowermditlv.setStatus('current')
if mibBuilder.loadTexts: lldpInfoPortpowermditlv.setDescription('This is the Power Via MDI TLV state of the LLDP port.')
lldpInfoPortlinkaggrtlv = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 11, 1, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpInfoPortlinkaggrtlv.setStatus('current')
if mibBuilder.loadTexts: lldpInfoPortlinkaggrtlv.setDescription('This is the Link Aggregation TLV state of the LLDP port.')
lldpInfoPortframesztlv = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 11, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpInfoPortframesztlv.setStatus('current')
if mibBuilder.loadTexts: lldpInfoPortframesztlv.setDescription('This is the Maximum Frame Size TLV state of the LLDP port.')
lldpInfoPortdcbxtlv = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 11, 1, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpInfoPortdcbxtlv.setStatus('current')
if mibBuilder.loadTexts: lldpInfoPortdcbxtlv.setDescription('This is the DCBX TLV state of the LLDP port.')
lldpInfoTxTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 11, 2), )
if mibBuilder.loadTexts: lldpInfoTxTable.setStatus('current')
if mibBuilder.loadTexts: lldpInfoTxTable.setDescription('The table of LLDP Transmit State Machine Info.')
lldpInfoTxEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 11, 2, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "lldpInfoTxIndex"))
if mibBuilder.loadTexts: lldpInfoTxEntry.setStatus('current')
if mibBuilder.loadTexts: lldpInfoTxEntry.setDescription('LLDP Transmit State Machine Info.')
lldpInfoTxIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 11, 2, 1, 1), PortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpInfoTxIndex.setStatus('current')
if mibBuilder.loadTexts: lldpInfoTxIndex.setDescription('The index of the row in LLDP Transmit State Machine info table.')
lldpInfoTxState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 11, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("txLldpInitialize", 1), ("txIdle", 2), ("txShutdownFrame", 3), ("txInfoFrame", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpInfoTxState.setStatus('current')
if mibBuilder.loadTexts: lldpInfoTxState.setDescription('The transmit state of the port in LLDP Transmit State Machine.')
lldpInfoTxLocalChanged = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 11, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpInfoTxLocalChanged.setStatus('current')
if mibBuilder.loadTexts: lldpInfoTxLocalChanged.setDescription('The somethingChangedLocal field of the port in LLDP Transmit State Machine.')
lldpInfoTxTTL = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 11, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpInfoTxTTL.setStatus('current')
if mibBuilder.loadTexts: lldpInfoTxTTL.setDescription('The txTTL timer of the port in LLDP Transmit State Machine.')
lldpInfoTxTxTTR = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 11, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpInfoTxTxTTR.setStatus('current')
if mibBuilder.loadTexts: lldpInfoTxTxTTR.setDescription('The txTTR timer of the port in LLDP Transmit State Machine.')
lldpInfoTxDelayWhile = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 11, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpInfoTxDelayWhile.setStatus('current')
if mibBuilder.loadTexts: lldpInfoTxDelayWhile.setDescription('The txDelayWhile timer of the port in LLDP Transmit State Machine.')
lldpInfoTxShutdownWhile = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 11, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpInfoTxShutdownWhile.setStatus('current')
if mibBuilder.loadTexts: lldpInfoTxShutdownWhile.setDescription('The txShutdownWhile timer of the port in LLDP Transmit State Machine.')
lldpInfoTxReinitDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 11, 2, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpInfoTxReinitDelay.setStatus('current')
if mibBuilder.loadTexts: lldpInfoTxReinitDelay.setDescription('The reinitDelay timer of the port in LLDP Transmit State Machine.')
lldpInfoTxHoldMultiplier = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 11, 2, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpInfoTxHoldMultiplier.setStatus('current')
if mibBuilder.loadTexts: lldpInfoTxHoldMultiplier.setDescription('The msgTxHold timer of the port in LLDP Transmit State Machine.')
lldpInfoTxTransmitInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 11, 2, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpInfoTxTransmitInterval.setStatus('current')
if mibBuilder.loadTexts: lldpInfoTxTransmitInterval.setDescription('The msgTxInterval timer of the port in LLDP Transmit State Machine.')
lldpInfoTxTransmitDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 11, 2, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpInfoTxTransmitDelay.setStatus('current')
if mibBuilder.loadTexts: lldpInfoTxTransmitDelay.setDescription('The txDelay timer of the port in LLDP Transmit State Machine.')
lldpInfoRxTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 11, 3), )
if mibBuilder.loadTexts: lldpInfoRxTable.setStatus('current')
if mibBuilder.loadTexts: lldpInfoRxTable.setDescription('The table of LLDP Receive State Machine Info.')
lldpInfoRxEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 11, 3, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "lldpInfoRxIndex"))
if mibBuilder.loadTexts: lldpInfoRxEntry.setStatus('current')
if mibBuilder.loadTexts: lldpInfoRxEntry.setDescription('LLDP Receive State Machine Info.')
lldpInfoRxIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 11, 3, 1, 1), PortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpInfoRxIndex.setStatus('current')
if mibBuilder.loadTexts: lldpInfoRxIndex.setDescription('The index of the row in LLDP Receive State Machine info table.')
lldpInfoRxState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 11, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("lldpWaitPortOperational", 1), ("deleteAgedInfo", 2), ("rxLldpInitialize", 3), ("rxWaitForFrame", 4), ("rxFrame", 5), ("deleteInfo", 6), ("updateInfo", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpInfoRxState.setStatus('current')
if mibBuilder.loadTexts: lldpInfoRxState.setDescription('The receive state of the port in LLDP Receive State Machine.')
lldpInfoRxBadFrame = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 11, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpInfoRxBadFrame.setStatus('current')
if mibBuilder.loadTexts: lldpInfoRxBadFrame.setDescription('The badFrame field of the port in LLDP Receive State Machine.')
lldpInfoRxRcvFrame = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 11, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpInfoRxRcvFrame.setStatus('current')
if mibBuilder.loadTexts: lldpInfoRxRcvFrame.setDescription('The rcvFrame field of the port in LLDP Receive State Machine.')
lldpInfoRxRxInfoAge = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 11, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpInfoRxRxInfoAge.setStatus('current')
if mibBuilder.loadTexts: lldpInfoRxRxInfoAge.setDescription('The rxInfoAge field of the port in LLDP Receive State Machine.')
lldpInfoRxRemoteChanged = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 11, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpInfoRxRemoteChanged.setStatus('current')
if mibBuilder.loadTexts: lldpInfoRxRemoteChanged.setDescription('The somethingChangedRemote field of the port in LLDP Receive State Machine.')
lldpInfoRxTooManyNeighbors = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 11, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpInfoRxTooManyNeighbors.setStatus('current')
if mibBuilder.loadTexts: lldpInfoRxTooManyNeighbors.setDescription('The tooManyNeighbors field of the port in LLDP Receive State Machine.')
lldpInfoRxSNMPNotify = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 11, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpInfoRxSNMPNotify.setStatus('current')
if mibBuilder.loadTexts: lldpInfoRxSNMPNotify.setDescription('The tooManyNeighbors field of the port in LLDP Receive State Machine.')
lldpInfoRxRxTTL = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 11, 3, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpInfoRxRxTTL.setStatus('current')
if mibBuilder.loadTexts: lldpInfoRxRxTTL.setDescription('The rxTTL timer of the port in LLDP Receive State Machine.')
lldpInfoRxTooManyNeighborTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 11, 3, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpInfoRxTooManyNeighborTimer.setStatus('current')
if mibBuilder.loadTexts: lldpInfoRxTooManyNeighborTimer.setDescription('The tooManyNeighborsTimer timer of the port in LLDP Receive State Machine.')
lldpInfoRemoteDevicesTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 11, 4), )
if mibBuilder.loadTexts: lldpInfoRemoteDevicesTable.setStatus('current')
if mibBuilder.loadTexts: lldpInfoRemoteDevicesTable.setDescription('The table of LLDP remote devices Info.')
lldpInfoRemoteDevicesEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 11, 4, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "lldpInfoRemoteDevicesIndex"))
if mibBuilder.loadTexts: lldpInfoRemoteDevicesEntry.setStatus('current')
if mibBuilder.loadTexts: lldpInfoRemoteDevicesEntry.setDescription('LLDP remote devices Info.')
lldpInfoRemoteDevicesIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 11, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpInfoRemoteDevicesIndex.setStatus('current')
if mibBuilder.loadTexts: lldpInfoRemoteDevicesIndex.setDescription('The index of the row in LLDP remote devices info table.')
lldpInfoRemoteDevicesRemoteTTL = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 11, 4, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpInfoRemoteDevicesRemoteTTL.setStatus('current')
if mibBuilder.loadTexts: lldpInfoRemoteDevicesRemoteTTL.setDescription('The remote TTL of the LLDP remote devices entry.')
lldpInfoRemoteDevicesRxChanges = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 11, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpInfoRemoteDevicesRxChanges.setStatus('current')
if mibBuilder.loadTexts: lldpInfoRemoteDevicesRxChanges.setDescription('The rxChanges field of the LLDP remote devices entry.')
lldpInfoRemoteDevicesLocalPort = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 11, 4, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpInfoRemoteDevicesLocalPort.setStatus('current')
if mibBuilder.loadTexts: lldpInfoRemoteDevicesLocalPort.setDescription('The local port alias of the LLDP remote devices entry.')
lldpInfoRemoteDevicesChassisSubtype = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 11, 4, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("chassisComponent", 1), ("interfaceAlias", 2), ("portComponent", 3), ("macAddress", 4), ("networkAddress", 5), ("interfaceName", 6), ("locallyAssigned", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpInfoRemoteDevicesChassisSubtype.setStatus('current')
if mibBuilder.loadTexts: lldpInfoRemoteDevicesChassisSubtype.setDescription('The chassis ID subtype of the LLDP remote devices entry.')
lldpInfoRemoteDevicesChassisId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 11, 4, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpInfoRemoteDevicesChassisId.setStatus('current')
if mibBuilder.loadTexts: lldpInfoRemoteDevicesChassisId.setDescription('The chassis ID of the LLDP remote devices entry.')
lldpInfoRemoteDevicesPortSubtype = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 11, 4, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("interfaceAlias", 1), ("portComponent", 2), ("macAddress", 3), ("networkAddress", 4), ("interfaceName", 5), ("agentCircuitId", 6), ("locallyAssigned", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpInfoRemoteDevicesPortSubtype.setStatus('current')
if mibBuilder.loadTexts: lldpInfoRemoteDevicesPortSubtype.setDescription('The port ID subtype of the LLDP remote devices entry.')
lldpInfoRemoteDevicesPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 11, 4, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpInfoRemoteDevicesPortId.setStatus('current')
if mibBuilder.loadTexts: lldpInfoRemoteDevicesPortId.setDescription('The port ID of the LLDP remote devices entry.')
lldpInfoRemoteDevicesSystemName = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 11, 4, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpInfoRemoteDevicesSystemName.setStatus('current')
if mibBuilder.loadTexts: lldpInfoRemoteDevicesSystemName.setDescription('The system name of the LLDP remote devices entry.')
lldpInfoRemoteDevicesSystemDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 11, 4, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpInfoRemoteDevicesSystemDescription.setStatus('current')
if mibBuilder.loadTexts: lldpInfoRemoteDevicesSystemDescription.setDescription('The system description of the LLDP remote devices entry.')
lldpInfoRemoteDevicesPortDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 11, 4, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpInfoRemoteDevicesPortDescription.setStatus('current')
if mibBuilder.loadTexts: lldpInfoRemoteDevicesPortDescription.setDescription('The port description of the LLDP remote devices entry.')
lldpInfoRemoteDevicesSystemCapSupported = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 11, 4, 1, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpInfoRemoteDevicesSystemCapSupported.setStatus('current')
if mibBuilder.loadTexts: lldpInfoRemoteDevicesSystemCapSupported.setDescription('The supported system capabilities of the LLDP remote devices entry.')
lldpInfoRemoteDevicesSystemCapEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 11, 4, 1, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpInfoRemoteDevicesSystemCapEnabled.setStatus('current')
if mibBuilder.loadTexts: lldpInfoRemoteDevicesSystemCapEnabled.setDescription('The enabled system capabilities of the LLDP remote devices entry.')
lldpInfoRemoteDevicesManAddrTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 11, 5), )
if mibBuilder.loadTexts: lldpInfoRemoteDevicesManAddrTable.setStatus('current')
if mibBuilder.loadTexts: lldpInfoRemoteDevicesManAddrTable.setDescription('The table of LLDP remote devices management address Info.')
lldpInfoRemoteDevicesManAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 11, 5, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "lldpInfoRemoteDevicesIndex"), (0, "IBM-GbTOR-10G-L2L3-MIB", "lldpInfoRemoteDevicesManAddrSubtype"), (0, "IBM-GbTOR-10G-L2L3-MIB", "lldpInfoRemoteDevicesManAddr"))
if mibBuilder.loadTexts: lldpInfoRemoteDevicesManAddrEntry.setStatus('current')
if mibBuilder.loadTexts: lldpInfoRemoteDevicesManAddrEntry.setDescription('LLDP remote devices management address Info.')
lldpInfoRemoteDevicesManAddrSubtype = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 11, 5, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 65535))).clone(namedValues=NamedValues(("other", 0), ("ipV4", 1), ("ipV6", 2), ("nsap", 3), ("hdlc", 4), ("bbn1822", 5), ("all802", 6), ("e163", 7), ("e164", 8), ("f69", 9), ("x121", 10), ("ipx", 11), ("appletalk", 12), ("decnetIV", 13), ("banyanVines", 14), ("e164withNsap", 15), ("dns", 16), ("distinguishedname", 17), ("asnumber", 18), ("xtpoveripv4", 19), ("xtpoveripv6", 20), ("xtpnativemodextp", 21), ("reserved", 65535)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpInfoRemoteDevicesManAddrSubtype.setStatus('current')
if mibBuilder.loadTexts: lldpInfoRemoteDevicesManAddrSubtype.setDescription('The management address subtype of the LLDP remote devices entry.')
lldpInfoRemoteDevicesManAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 11, 5, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpInfoRemoteDevicesManAddr.setStatus('current')
if mibBuilder.loadTexts: lldpInfoRemoteDevicesManAddr.setDescription('The management address of the LLDP remote devices entry.')
lldpInfoRemoteDevicesManAddrIfSubtype = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 11, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("ifIndex", 2), ("systemPortNumber", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpInfoRemoteDevicesManAddrIfSubtype.setStatus('current')
if mibBuilder.loadTexts: lldpInfoRemoteDevicesManAddrIfSubtype.setDescription('The interface numbering subtype of the LLDP remote devices management address entry.')
lldpInfoRemoteDevicesManAddrIfId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 11, 5, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpInfoRemoteDevicesManAddrIfId.setStatus('current')
if mibBuilder.loadTexts: lldpInfoRemoteDevicesManAddrIfId.setDescription('The interface number of the LLDP remote devices management address entry.')
lldpInfoRemoteDevicesManAddrOID = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 11, 5, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpInfoRemoteDevicesManAddrOID.setStatus('current')
if mibBuilder.loadTexts: lldpInfoRemoteDevicesManAddrOID.setDescription('The object identifier of the LLDP remote devices management address entry.')
lldpClearMsap = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 11, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ok", 0), ("clearMsap", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lldpClearMsap.setStatus('current')
if mibBuilder.loadTexts: lldpClearMsap.setDescription('Clear LLDP remote devices information when setting clearMsap(1). When read, ok(0) is always returned.')
udldInfoPortTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 13, 1), )
if mibBuilder.loadTexts: udldInfoPortTable.setStatus('current')
if mibBuilder.loadTexts: udldInfoPortTable.setDescription('The table of UDLD port info.')
udldInfoPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 13, 1, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "udldInfoPortIndex"))
if mibBuilder.loadTexts: udldInfoPortEntry.setStatus('current')
if mibBuilder.loadTexts: udldInfoPortEntry.setDescription('A row inside UDLD port info table.')
udldInfoPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 13, 1, 1, 1), PortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: udldInfoPortIndex.setStatus('current')
if mibBuilder.loadTexts: udldInfoPortIndex.setDescription('The index of the row in UDLD port configuration table.')
udldInfoPortConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 13, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: udldInfoPortConfig.setStatus('current')
if mibBuilder.loadTexts: udldInfoPortConfig.setDescription('The Config field of the port in UDLD port info table. Shows the administative state of the current port.')
udldInfoPortMode = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 13, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("aggresive", 1), ("normal", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: udldInfoPortMode.setStatus('current')
if mibBuilder.loadTexts: udldInfoPortMode.setDescription('The Mode field of the port in UDLD info port table. Shows the udld administrative mode for the current port.')
udldInfoPortLink = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 13, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: udldInfoPortLink.setStatus('current')
if mibBuilder.loadTexts: udldInfoPortLink.setDescription('The Link field of the port in UDLD info port table. Shows the state of the link associated with the port.')
udldInfoPortOperationalStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 13, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("init", 1), ("inactive", 2), ("linkup", 3), ("advertisement", 4), ("detection", 5), ("extDetection", 6), ("shutdown", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: udldInfoPortOperationalStatus.setStatus('current')
if mibBuilder.loadTexts: udldInfoPortOperationalStatus.setDescription('The OperationalStatus field of the port in UDLD info port table. Contains the udld operational state for the current port.')
udldInfoPortBidirectionalStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 13, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unknown", 1), ("unidirectional", 2), ("bidirectional", 3), ("loop", 4), ("neighborMismatch", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: udldInfoPortBidirectionalStatus.setStatus('current')
if mibBuilder.loadTexts: udldInfoPortBidirectionalStatus.setDescription('The BidirectionalStatus field of the port in UDLD info port table. Contains the udld bidirectional state for the current port.')
udldInfoPortInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 13, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: udldInfoPortInterval.setStatus('current')
if mibBuilder.loadTexts: udldInfoPortInterval.setDescription('The Interval field of the port in UDLD info port table. The duration, measured in seconds, of the interval during which UDLD probes are sent, after the linkup or detection phases. Its time unit is 1 second.')
udldInfoPortTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 13, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: udldInfoPortTimeout.setStatus('current')
if mibBuilder.loadTexts: udldInfoPortTimeout.setDescription('The Timeout field of the port in UDLD info port table. Length of the detection phase, measured in seconds.')
udldInfoPortNeighborCount = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 13, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: udldInfoPortNeighborCount.setStatus('current')
if mibBuilder.loadTexts: udldInfoPortNeighborCount.setDescription('The Neighbor field of the port in UDLD info port table. Contains the number of udld neighbors for the current port.')
udldInfoNeighborTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 13, 2), )
if mibBuilder.loadTexts: udldInfoNeighborTable.setStatus('current')
if mibBuilder.loadTexts: udldInfoNeighborTable.setDescription('The table of UDLD port neighbor info.')
udldInfoNeighborEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 13, 2, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "udldInfoNeighborLocalPortIndex"), (0, "IBM-GbTOR-10G-L2L3-MIB", "udldInfoNeighborIndex"))
if mibBuilder.loadTexts: udldInfoNeighborEntry.setStatus('current')
if mibBuilder.loadTexts: udldInfoNeighborEntry.setDescription('A row inside UDLD port info table.')
udldInfoNeighborLocalPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 13, 2, 1, 1), PortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: udldInfoNeighborLocalPortIndex.setStatus('current')
if mibBuilder.loadTexts: udldInfoNeighborLocalPortIndex.setDescription('The index of the port for which neighbor information will be returned.')
udldInfoNeighborIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 13, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: udldInfoNeighborIndex.setStatus('current')
if mibBuilder.loadTexts: udldInfoNeighborIndex.setDescription('The index of the target neighbor among the port neighbors.')
udldInfoNeighborExpiration = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 13, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: udldInfoNeighborExpiration.setStatus('current')
if mibBuilder.loadTexts: udldInfoNeighborExpiration.setDescription('Hold time for the given neighbor.')
udldInfoNeighborDeviceName = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 13, 2, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: udldInfoNeighborDeviceName.setStatus('current')
if mibBuilder.loadTexts: udldInfoNeighborDeviceName.setDescription('Device name reported by neigbor.')
udldInfoNeighborDeviceID = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 13, 2, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: udldInfoNeighborDeviceID.setStatus('current')
if mibBuilder.loadTexts: udldInfoNeighborDeviceID.setDescription('Device ID reported by neigbor.')
udldInfoNeighborPortID = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 13, 2, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: udldInfoNeighborPortID.setStatus('current')
if mibBuilder.loadTexts: udldInfoNeighborPortID.setDescription('Port ID reported by neigbor.')
fdbCurCfgStaticTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 13, 2), )
if mibBuilder.loadTexts: fdbCurCfgStaticTable.setStatus('current')
if mibBuilder.loadTexts: fdbCurCfgStaticTable.setDescription('The table of FDB static entries.')
fdbCurCfgStaticEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 13, 2, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "fdbCurCfgEntryIndex"))
if mibBuilder.loadTexts: fdbCurCfgStaticEntry.setStatus('current')
if mibBuilder.loadTexts: fdbCurCfgStaticEntry.setDescription('A row in the fdb table.')
fdbCurCfgEntryIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 13, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fdbCurCfgEntryIndex.setStatus('current')
if mibBuilder.loadTexts: fdbCurCfgEntryIndex.setDescription('The fdb entry index')
fdbCurCfgVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 13, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fdbCurCfgVlan.setStatus('current')
if mibBuilder.loadTexts: fdbCurCfgVlan.setDescription('Add vlan for fdb entry index')
fdbCurCfgPort = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 13, 2, 1, 3), PortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fdbCurCfgPort.setStatus('current')
if mibBuilder.loadTexts: fdbCurCfgPort.setDescription('The MAC address port number.')
fdbCurCfgMac = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 13, 2, 1, 4), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fdbCurCfgMac.setStatus('current')
if mibBuilder.loadTexts: fdbCurCfgMac.setDescription('Add a fdb entry.')
fdbCurCfgTrunk = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 13, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fdbCurCfgTrunk.setStatus('current')
if mibBuilder.loadTexts: fdbCurCfgTrunk.setDescription('The MAC address trunk number.')
fdbCurCfgAdminkey = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 13, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fdbCurCfgAdminkey.setStatus('current')
if mibBuilder.loadTexts: fdbCurCfgAdminkey.setDescription('The MAC address LACP trunk adminkey.')
fdbNewCfgStaticTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 13, 3), )
if mibBuilder.loadTexts: fdbNewCfgStaticTable.setStatus('current')
if mibBuilder.loadTexts: fdbNewCfgStaticTable.setDescription('The table of FDB static entries.')
fdbNewCfgStaticEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 13, 3, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "fdbNewCfgEntryIndex"))
if mibBuilder.loadTexts: fdbNewCfgStaticEntry.setStatus('current')
if mibBuilder.loadTexts: fdbNewCfgStaticEntry.setDescription('A row in the fdb table.')
fdbNewCfgEntryIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 13, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fdbNewCfgEntryIndex.setStatus('current')
if mibBuilder.loadTexts: fdbNewCfgEntryIndex.setDescription('The fdb entry index')
fdbNewCfgAddVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 13, 3, 1, 2), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: fdbNewCfgAddVlan.setStatus('current')
if mibBuilder.loadTexts: fdbNewCfgAddVlan.setDescription('Add vlan for fdb entry index')
fdbNewCfgAddPort = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 13, 3, 1, 3), PortNumber()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: fdbNewCfgAddPort.setStatus('current')
if mibBuilder.loadTexts: fdbNewCfgAddPort.setDescription('The MAC address port number.')
fdbNewCfgAddMac = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 13, 3, 1, 4), PhysAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: fdbNewCfgAddMac.setStatus('current')
if mibBuilder.loadTexts: fdbNewCfgAddMac.setDescription('Add a fdb entry, ex:0x00 0x01 0x02 0x03 0x04 0x05')
fdbNewCfgDelStaticEntry = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 13, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("delete", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: fdbNewCfgDelStaticEntry.setStatus('current')
if mibBuilder.loadTexts: fdbNewCfgDelStaticEntry.setDescription('When set to the value of 2 (delete), the entire row is deleted. When read, other(1) is returned. Setting the value to anything other than 2(delete) has no effect on the state of the row.')
fdbNewCfgAddTrunk = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 13, 3, 1, 6), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: fdbNewCfgAddTrunk.setStatus('current')
if mibBuilder.loadTexts: fdbNewCfgAddTrunk.setDescription('The MAC address trunk number.')
fdbNewCfgAddAdminkey = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 13, 3, 1, 7), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: fdbNewCfgAddAdminkey.setStatus('current')
if mibBuilder.loadTexts: fdbNewCfgAddAdminkey.setDescription('The MAC address LACP trunk adminkey.')
mcastFdbCurCfgTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 13, 8), )
if mibBuilder.loadTexts: mcastFdbCurCfgTable.setStatus('current')
if mibBuilder.loadTexts: mcastFdbCurCfgTable.setDescription('The table of multicast FDB static entries.')
mcastFdbCurCfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 13, 8, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "mcastFdbCurCfgEntryIndex"))
if mibBuilder.loadTexts: mcastFdbCurCfgEntry.setStatus('current')
if mibBuilder.loadTexts: mcastFdbCurCfgEntry.setDescription('A row in the multicast fdb table.')
mcastFdbCurCfgEntryIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 13, 8, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcastFdbCurCfgEntryIndex.setStatus('current')
if mibBuilder.loadTexts: mcastFdbCurCfgEntryIndex.setDescription('The multicast fdb entry index')
mcastFdbCurCfgVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 13, 8, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcastFdbCurCfgVlan.setStatus('current')
if mibBuilder.loadTexts: mcastFdbCurCfgVlan.setDescription('Add vlan for multicast fdb entry index')
mcastFdbCurCfgPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 13, 8, 1, 3), PortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcastFdbCurCfgPorts.setStatus('current')
if mibBuilder.loadTexts: mcastFdbCurCfgPorts.setDescription('The multicast MAC address port list. The ports are presented in bitmap format. in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ port 8 || || || ||___ port 7 || |____ port 6 || . . . ||_________ port 1 |__________ reserved where x : 1 - The represented port belongs to the multicast MAC address. 0 - The represented port does not belong to the multicast MAC address.')
mcastFdbCurCfgMac = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 13, 8, 1, 4), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcastFdbCurCfgMac.setStatus('current')
if mibBuilder.loadTexts: mcastFdbCurCfgMac.setDescription('Add a multicast fdb entry.')
mcastFdbNewCfgTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 13, 9), )
if mibBuilder.loadTexts: mcastFdbNewCfgTable.setStatus('current')
if mibBuilder.loadTexts: mcastFdbNewCfgTable.setDescription('The table of multicast FDB static entries.')
mcastFdbNewCfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 13, 9, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "mcastFdbNewCfgEntryIndex"))
if mibBuilder.loadTexts: mcastFdbNewCfgEntry.setStatus('current')
if mibBuilder.loadTexts: mcastFdbNewCfgEntry.setDescription('A row in the multicast fdb table.')
mcastFdbNewCfgEntryIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 13, 9, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcastFdbNewCfgEntryIndex.setStatus('current')
if mibBuilder.loadTexts: mcastFdbNewCfgEntryIndex.setDescription('The multicast fdb entry index')
mcastFdbNewCfgAddVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 13, 9, 1, 2), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mcastFdbNewCfgAddVlan.setStatus('current')
if mibBuilder.loadTexts: mcastFdbNewCfgAddVlan.setDescription('Add vlan for multicast fdb entry index')
mcastFdbNewCfgPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 13, 9, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcastFdbNewCfgPorts.setStatus('current')
if mibBuilder.loadTexts: mcastFdbNewCfgPorts.setDescription('The multicast MAC address port list. The ports are presented in bitmap format. in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ port 8 || || || ||___ port 7 || |____ port 6 || . . . ||_________ port 1 |__________ reserved where x : 1 - The represented port belongs to the multicast MAC address. 0 - The represented port does not belong to the multicast MAC address.')
mcastFdbNewCfgAddPort = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 13, 9, 1, 4), PortNumber()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mcastFdbNewCfgAddPort.setStatus('current')
if mibBuilder.loadTexts: mcastFdbNewCfgAddPort.setDescription("The multicast MAC address port number to be added. A '0' value is returned when read.")
mcastFdbNewCfgRemPort = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 13, 9, 1, 5), PortNumber()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mcastFdbNewCfgRemPort.setStatus('current')
if mibBuilder.loadTexts: mcastFdbNewCfgRemPort.setDescription("The multicast MAC address port number to be removed. A '0' value is returned when read.")
mcastFdbNewCfgAddMac = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 13, 9, 1, 6), MacAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mcastFdbNewCfgAddMac.setStatus('current')
if mibBuilder.loadTexts: mcastFdbNewCfgAddMac.setDescription('Add a multicast fdb entry, ex:0x00 0x01 0x02 0x03 0x04 0x05')
mcastFdbNewCfgDelStaticEntry = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 13, 9, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("delete", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mcastFdbNewCfgDelStaticEntry.setStatus('current')
if mibBuilder.loadTexts: mcastFdbNewCfgDelStaticEntry.setDescription('When set to the value of 2 (delete), the entire row is deleted. When read, other(1) is returned. Setting the value to anything other than 2(delete) has no effect on the state of the row.')
oamInfoPortTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 12, 1), )
if mibBuilder.loadTexts: oamInfoPortTable.setStatus('current')
if mibBuilder.loadTexts: oamInfoPortTable.setDescription('The table of OAM port information.')
oamInfoPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 12, 1, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "oamInfoPortIndex"))
if mibBuilder.loadTexts: oamInfoPortEntry.setStatus('current')
if mibBuilder.loadTexts: oamInfoPortEntry.setDescription('Information about OAM Port')
oamInfoPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 12, 1, 1, 1), PortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: oamInfoPortIndex.setStatus('current')
if mibBuilder.loadTexts: oamInfoPortIndex.setDescription('The OAM Port number for which the table is related.')
oamInfoPortLocalState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 12, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("enabled", 0), ("disabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: oamInfoPortLocalState.setStatus('current')
if mibBuilder.loadTexts: oamInfoPortLocalState.setDescription(' OAM local port state')
oamInfoPortLocalMode = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 12, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("active", 0), ("passive", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: oamInfoPortLocalMode.setStatus('current')
if mibBuilder.loadTexts: oamInfoPortLocalMode.setDescription(' OAM local port mode')
oamInfoPortLocalLinkStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 12, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ok", 0), ("fail", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: oamInfoPortLocalLinkStatus.setStatus('current')
if mibBuilder.loadTexts: oamInfoPortLocalLinkStatus.setDescription(' OAM local port link status')
oamInfoPortLocalStable = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 12, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("true", 0), ("false", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: oamInfoPortLocalStable.setStatus('current')
if mibBuilder.loadTexts: oamInfoPortLocalStable.setDescription(' OAM local port stable')
oamInfoPortLocalSatisfied = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 12, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("true", 0), ("false", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: oamInfoPortLocalSatisfied.setStatus('current')
if mibBuilder.loadTexts: oamInfoPortLocalSatisfied.setDescription(' OAM local port satisfied')
oamInfoPortLocalEvaluating = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 12, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("true", 0), ("false", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: oamInfoPortLocalEvaluating.setStatus('current')
if mibBuilder.loadTexts: oamInfoPortLocalEvaluating.setDescription(' OAM local port evaluating')
oamInfoPortRemoteMode = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 12, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("active", 0), ("passive", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: oamInfoPortRemoteMode.setStatus('current')
if mibBuilder.loadTexts: oamInfoPortRemoteMode.setDescription(' OAM remote port mode')
oamInfoPortRemoteMAC = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 12, 1, 1, 9), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: oamInfoPortRemoteMAC.setStatus('current')
if mibBuilder.loadTexts: oamInfoPortRemoteMAC.setDescription(' OAM remote port MAC address')
oamInfoPortRemoteStable = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 12, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("true", 0), ("false", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: oamInfoPortRemoteStable.setStatus('current')
if mibBuilder.loadTexts: oamInfoPortRemoteStable.setDescription(' OAM remote port stable')
oamInfoPortRemoteStateValid = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 12, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("true", 0), ("false", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: oamInfoPortRemoteStateValid.setStatus('current')
if mibBuilder.loadTexts: oamInfoPortRemoteStateValid.setDescription(' OAM remote port state valid')
oamInfoPortRemoteEvaluating = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 12, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("true", 0), ("false", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: oamInfoPortRemoteEvaluating.setStatus('current')
if mibBuilder.loadTexts: oamInfoPortRemoteEvaluating.setDescription(' OAM remote port evaluating')
oamStatsPortTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 8, 1), )
if mibBuilder.loadTexts: oamStatsPortTable.setStatus('current')
if mibBuilder.loadTexts: oamStatsPortTable.setDescription('The table of OAM port statistics.')
oamStatsPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 8, 1, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "oamStatsPortIndex"))
if mibBuilder.loadTexts: oamStatsPortEntry.setStatus('current')
if mibBuilder.loadTexts: oamStatsPortEntry.setDescription('Statistics about OAM Port')
oamStatsPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 8, 1, 1, 1), PortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: oamStatsPortIndex.setStatus('current')
if mibBuilder.loadTexts: oamStatsPortIndex.setDescription('The OAM Port number for which the table is related.')
oamStatsPortInfoTx = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 8, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: oamStatsPortInfoTx.setStatus('current')
if mibBuilder.loadTexts: oamStatsPortInfoTx.setDescription('The number of transmitted OAM information packets')
oamStatsPortInfoRx = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 8, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: oamStatsPortInfoRx.setStatus('current')
if mibBuilder.loadTexts: oamStatsPortInfoRx.setDescription('The number of received OAM information packets')
oamStatsPortUnsupTx = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 8, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: oamStatsPortUnsupTx.setStatus('current')
if mibBuilder.loadTexts: oamStatsPortUnsupTx.setDescription('The number of transmitted OAM unsupported packets')
oamStatsPortUnsupRx = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 8, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: oamStatsPortUnsupRx.setStatus('current')
if mibBuilder.loadTexts: oamStatsPortUnsupRx.setDescription('The number of received OAM unsupported packets')
oamStatsPortLocalLinkFaults = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 8, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: oamStatsPortLocalLinkFaults.setStatus('current')
if mibBuilder.loadTexts: oamStatsPortLocalLinkFaults.setDescription('The number of local OAM link fault packets')
oamStatsPortLocalCriticalEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 8, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: oamStatsPortLocalCriticalEvents.setStatus('current')
if mibBuilder.loadTexts: oamStatsPortLocalCriticalEvents.setDescription('The number of local OAM critical event packets')
oamStatsPortLocalDyingGasps = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 8, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: oamStatsPortLocalDyingGasps.setStatus('current')
if mibBuilder.loadTexts: oamStatsPortLocalDyingGasps.setDescription('The number of local OAM dying gasp packets')
oamStatsPortRemoteLinkFaults = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 8, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: oamStatsPortRemoteLinkFaults.setStatus('current')
if mibBuilder.loadTexts: oamStatsPortRemoteLinkFaults.setDescription('The number of remote OAM link fault packets')
oamStatsPortRemoteCriticalEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 8, 1, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: oamStatsPortRemoteCriticalEvents.setStatus('current')
if mibBuilder.loadTexts: oamStatsPortRemoteCriticalEvents.setDescription('The number of remote OAM critical event packets')
oamStatsPortRemoteDyingGasps = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 8, 1, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: oamStatsPortRemoteDyingGasps.setStatus('current')
if mibBuilder.loadTexts: oamStatsPortRemoteDyingGasps.setDescription('The number of remote OAM dying gasp packets')
trunkGroupInfoTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 9, 1), )
if mibBuilder.loadTexts: trunkGroupInfoTable.setStatus('current')
if mibBuilder.loadTexts: trunkGroupInfoTable.setDescription('The table of trunk group information.')
trunkGroupInfoTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 9, 1, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "trunkGroupInfoIndex"))
if mibBuilder.loadTexts: trunkGroupInfoTableEntry.setStatus('current')
if mibBuilder.loadTexts: trunkGroupInfoTableEntry.setDescription('A row in trunk group information table.')
trunkGroupInfoIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 9, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkGroupInfoIndex.setStatus('current')
if mibBuilder.loadTexts: trunkGroupInfoIndex.setDescription('The identifier of the trunk group.')
trunkGroupInfoState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 9, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkGroupInfoState.setStatus('current')
if mibBuilder.loadTexts: trunkGroupInfoState.setDescription('Trunk group state.')
trunkGroupInfoPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 9, 1, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkGroupInfoPorts.setStatus('current')
if mibBuilder.loadTexts: trunkGroupInfoPorts.setDescription('The port list in the trunk group. The ports are presented in bitmap format. in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ port 8 || || || ||___ port 7 || |____ port 6 || . . . ||_________ port 1 |__________ reserved where x : 1 - The represented port belongs to the trunk group 0 - The represented port does not belong to the trunk group')
trunkGroupInfoProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 9, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("static", 1), ("lacp", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkGroupInfoProtocol.setStatus('current')
if mibBuilder.loadTexts: trunkGroupInfoProtocol.setDescription('Trunk group protocol Static - static trunk group Lacp - dynamic trunk group')
trunkGroupInfoPortTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 9, 2), )
if mibBuilder.loadTexts: trunkGroupInfoPortTable.setStatus('current')
if mibBuilder.loadTexts: trunkGroupInfoPortTable.setDescription('The table of Trunk Group Info.')
trunkGroupInfoPortTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 9, 2, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "trunkGroupInfoPortTrunkId"), (0, "IBM-GbTOR-10G-L2L3-MIB", "trunkGroupInfoPortPortId"))
if mibBuilder.loadTexts: trunkGroupInfoPortTableEntry.setStatus('current')
if mibBuilder.loadTexts: trunkGroupInfoPortTableEntry.setDescription('A row in the Trunk Info table.')
trunkGroupInfoPortTrunkId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 9, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkGroupInfoPortTrunkId.setStatus('current')
if mibBuilder.loadTexts: trunkGroupInfoPortTrunkId.setDescription('The Trunk identifier.')
trunkGroupInfoPortPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 9, 2, 1, 2), PortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkGroupInfoPortPortId.setStatus('current')
if mibBuilder.loadTexts: trunkGroupInfoPortPortId.setDescription('The Port identifier.')
trunkGroupInfoPortStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 9, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("down", 0), ("blocking", 1), ("forwarding", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkGroupInfoPortStatus.setStatus('current')
if mibBuilder.loadTexts: trunkGroupInfoPortStatus.setDescription('The Port Status.')
lacpStatsTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 4, 1), )
if mibBuilder.loadTexts: lacpStatsTable.setStatus('current')
if mibBuilder.loadTexts: lacpStatsTable.setDescription('The table of LACP Stats.')
lacpStatsTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 4, 1, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "lacpStatsIndex"))
if mibBuilder.loadTexts: lacpStatsTableEntry.setStatus('current')
if mibBuilder.loadTexts: lacpStatsTableEntry.setDescription('Lacp status info.')
lacpStatsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 4, 1, 1, 1), PortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpStatsIndex.setStatus('current')
if mibBuilder.loadTexts: lacpStatsIndex.setDescription('Index')
lacpdusRx = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 4, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpdusRx.setStatus('current')
if mibBuilder.loadTexts: lacpdusRx.setDescription('Valid LACPDUs received')
markerpdusRx = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 4, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: markerpdusRx.setStatus('current')
if mibBuilder.loadTexts: markerpdusRx.setDescription('Valid Marker PDUs received')
markerresponsepdusRx = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 4, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: markerresponsepdusRx.setStatus('current')
if mibBuilder.loadTexts: markerresponsepdusRx.setDescription('Valid Marker Rsp PDUs received')
unknownRx = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 4, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: unknownRx.setStatus('current')
if mibBuilder.loadTexts: unknownRx.setDescription('Unknown version/TLV type')
illegalRx = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 4, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: illegalRx.setStatus('current')
if mibBuilder.loadTexts: illegalRx.setDescription('Illegal subtype received')
lacpdusTx = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 4, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpdusTx.setStatus('current')
if mibBuilder.loadTexts: lacpdusTx.setDescription('LACPDUs transmitted')
markerpdusTx = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 4, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: markerpdusTx.setStatus('current')
if mibBuilder.loadTexts: markerpdusTx.setDescription('Market PDUs transmitted')
markerresponsepdusTx = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 4, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: markerresponsepdusTx.setStatus('current')
if mibBuilder.loadTexts: markerresponsepdusTx.setDescription('Marker Rsp PDUs transmitted ')
lacpClearStats = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 4, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("clear", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lacpClearStats.setStatus('current')
if mibBuilder.loadTexts: lacpClearStats.setDescription('Setting this to clear(2) results in clearing the LACP statistics.')
fdbStatsCurrent = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fdbStatsCurrent.setStatus('current')
if mibBuilder.loadTexts: fdbStatsCurrent.setDescription('Current number of entries in the Forwarding Database.')
fdbStatsHiwat = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fdbStatsHiwat.setStatus('current')
if mibBuilder.loadTexts: fdbStatsHiwat.setDescription('Highest number of entries recorded at any given time in the Forwarding Database.')
fdbStatsClear = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("clear", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fdbStatsClear.setStatus('current')
if mibBuilder.loadTexts: fdbStatsClear.setDescription('Clear FDB statistics')
stgStatsPortTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 2, 1), )
if mibBuilder.loadTexts: stgStatsPortTable.setStatus('current')
if mibBuilder.loadTexts: stgStatsPortTable.setDescription('The table of Spanning Tree Group port statistics.')
stgStatsPortTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 2, 1, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "stgStatsStpIndex"), (0, "IBM-GbTOR-10G-L2L3-MIB", "stgStatsPortIndex"))
if mibBuilder.loadTexts: stgStatsPortTableEntry.setStatus('current')
if mibBuilder.loadTexts: stgStatsPortTableEntry.setDescription('Statistics about port of a particular Spanning Tree Group.')
stgStatsStpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stgStatsStpIndex.setStatus('current')
if mibBuilder.loadTexts: stgStatsStpIndex.setDescription('The identifier of a particular Spanning Tree Group.')
stgStatsPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 2, 1, 1, 2), PortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stgStatsPortIndex.setStatus('current')
if mibBuilder.loadTexts: stgStatsPortIndex.setDescription('The port identifier of a particular Spanning Tree Group.')
stgStatsPortRcvCfgBpdus = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 2, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stgStatsPortRcvCfgBpdus.setStatus('current')
if mibBuilder.loadTexts: stgStatsPortRcvCfgBpdus.setDescription("Number of Configuration BPDU's received on this port.")
stgStatsPortRcvTcnBpdus = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 2, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stgStatsPortRcvTcnBpdus.setStatus('current')
if mibBuilder.loadTexts: stgStatsPortRcvTcnBpdus.setDescription("Number of TCN BPDU's received on this port.")
stgStatsPortXmtCfgBpdus = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 2, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stgStatsPortXmtCfgBpdus.setStatus('current')
if mibBuilder.loadTexts: stgStatsPortXmtCfgBpdus.setDescription("Number of Configuration BPDU's trasmitted from the port.")
stgStatsPortXmtTcnBpdus = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 2, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stgStatsPortXmtTcnBpdus.setStatus('current')
if mibBuilder.loadTexts: stgStatsPortXmtTcnBpdus.setDescription("Number of TCN BPDU's trasmitted from the port.")
fdbClear = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("clear", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fdbClear.setStatus('current')
if mibBuilder.loadTexts: fdbClear.setDescription('Setting this value to clear(2) clears the entire master FDB.')
fdbTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 1, 2), )
if mibBuilder.loadTexts: fdbTable.setStatus('current')
if mibBuilder.loadTexts: fdbTable.setDescription('The table of FDB entries.')
fdbEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 1, 2, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "fdbMacAddr"))
if mibBuilder.loadTexts: fdbEntry.setStatus('current')
if mibBuilder.loadTexts: fdbEntry.setDescription('A row in the FDB table')
fdbMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 1, 2, 1, 1), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fdbMacAddr.setStatus('current')
if mibBuilder.loadTexts: fdbMacAddr.setDescription('The MAC address for the FDB entry.')
fdbVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 1, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fdbVlan.setStatus('current')
if mibBuilder.loadTexts: fdbVlan.setDescription('The VLAN ID for the FDB entry.')
fdbSrcPort = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 1, 2, 1, 3), PortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fdbSrcPort.setStatus('current')
if mibBuilder.loadTexts: fdbSrcPort.setDescription("Either the value '0', or the port number of the port on which a frame having a source address equal to the value of the corresponding instance has been seen. A value of '0' indicates that the port number has not been learned but that the bridge does have some forwarding/filtering information about this address.")
fdbState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 1, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("forward", 2), ("trunk", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fdbState.setStatus('current')
if mibBuilder.loadTexts: fdbState.setDescription('The state of the FDB entry. The meanings of the values are : unknown(1) : the MAC address has not yet been learned by the switch but has only been seen as a destination address forward(3) : the MAC address has been learned by the switch flood(4) : the MAC address is a multicast destination address trunk(6) : frames with this MAC address are forwarded to trunk group vir(7) : frames with this MAC address are forwarded for L3 processing')
fdbSrcTrunk = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 1, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fdbSrcTrunk.setStatus('current')
if mibBuilder.loadTexts: fdbSrcTrunk.setDescription("Either the value '0', or the trunk number of the trunk on which a frame having a source address equal to the value of the corresponding instance has been seen. A value of '0' indicates that the source address is not associated with a trunk.")
fdbStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 1, 2, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fdbStatus.setStatus('current')
if mibBuilder.loadTexts: fdbStatus.setDescription("'1' if it is permanent '0' if it is not permanent")
mcastFdbTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 1, 3), )
if mibBuilder.loadTexts: mcastFdbTable.setStatus('current')
if mibBuilder.loadTexts: mcastFdbTable.setDescription('The table of static multicast FDB entries.')
mcastFdbEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 1, 3, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "mcastFdbEntryIndex"))
if mibBuilder.loadTexts: mcastFdbEntry.setStatus('current')
if mibBuilder.loadTexts: mcastFdbEntry.setDescription('A row in the static multicast FDB table')
mcastFdbEntryIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 1, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcastFdbEntryIndex.setStatus('current')
if mibBuilder.loadTexts: mcastFdbEntryIndex.setDescription('The static multicast fdb entry index')
mcastFdbMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 1, 3, 1, 2), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcastFdbMacAddr.setStatus('current')
if mibBuilder.loadTexts: mcastFdbMacAddr.setDescription('The static multicast MAC address for the FDB entry.')
mcastFdbVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 1, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcastFdbVlan.setStatus('current')
if mibBuilder.loadTexts: mcastFdbVlan.setDescription('The VLAN ID for the FDB entry.')
mcastFdbSrcPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 1, 3, 1, 4), PortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcastFdbSrcPorts.setStatus('current')
if mibBuilder.loadTexts: mcastFdbSrcPorts.setDescription('The multicast MAC address port list. The ports are presented in bitmap format. in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ port 8 || || || ||___ port 7 || |____ port 6 || . . . ||_________ port 1 |__________ reserved where x : 1 - The represented port belongs to the multicast MAC address. 0 - The represented port does not belong to the multicast MAC address.')
stpInfoTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 2, 1), )
if mibBuilder.loadTexts: stpInfoTable.setStatus('current')
if mibBuilder.loadTexts: stpInfoTable.setDescription('The table of Spanning Tree Group information.')
stpInfoTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 2, 1, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "stpInfoIndex"))
if mibBuilder.loadTexts: stpInfoTableEntry.setStatus('current')
if mibBuilder.loadTexts: stpInfoTableEntry.setDescription('Information about a particular Spanning Tree Group.')
stpInfoIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stpInfoIndex.setStatus('current')
if mibBuilder.loadTexts: stpInfoIndex.setDescription('The identifier of a particular Spanning Tree Group. This is also index to the entLogicalTable of Entity MIB.')
stpInfoTimeSinceTopChange = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 2, 1, 1, 2), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stpInfoTimeSinceTopChange.setStatus('current')
if mibBuilder.loadTexts: stpInfoTimeSinceTopChange.setDescription('The time (in hundredths of a second) since the last time a topology change was detected by the bridge entity.')
stpInfoTopChanges = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 2, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stpInfoTopChanges.setStatus('current')
if mibBuilder.loadTexts: stpInfoTopChanges.setDescription('The total number of topology changes detected by this bridge since the management entity was last reset or initialized.')
stpInfoDesignatedRoot = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 2, 1, 1, 4), BridgeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stpInfoDesignatedRoot.setStatus('current')
if mibBuilder.loadTexts: stpInfoDesignatedRoot.setDescription('The bridge identifier of the root of the spanning tree as determined by the Spanning Tree Protocol as executed by this node. This value is used as the Root Identifier parameter in all Configuration Bridge PDUs originated by this node.')
stpInfoRootCost = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 2, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stpInfoRootCost.setStatus('current')
if mibBuilder.loadTexts: stpInfoRootCost.setDescription('The cost of the path to the root as seen from this bridge.')
stpInfoRootPort = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 2, 1, 1, 6), PortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stpInfoRootPort.setStatus('current')
if mibBuilder.loadTexts: stpInfoRootPort.setDescription('The port number of the port which offers the lowest cost path from this bridge to the root bridge.')
stpInfoMaxAge = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 2, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stpInfoMaxAge.setStatus('current')
if mibBuilder.loadTexts: stpInfoMaxAge.setDescription('The maximum age of Spanning Tree Protocol information learned from the network on any port before it is discarded, in units of hundredths of a second. This is the actual value that this bridge is currently using.')
stpInfoHelloTime = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 2, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stpInfoHelloTime.setStatus('current')
if mibBuilder.loadTexts: stpInfoHelloTime.setDescription('The amount of time between the transmission of Configuration bridge PDUs by this node on any port when it is the root of the spanning tree or trying to become so, in units of hundredths of a second. This is the actual value that this bridge is currently using.')
stpInfoForwardDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 2, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stpInfoForwardDelay.setStatus('current')
if mibBuilder.loadTexts: stpInfoForwardDelay.setDescription('This time value, measured in units of hundredths of a second, controls how fast a port changes its spanning state when moving towards the Forwarding state. The value determines how long the port stays in each of the Listening and Learning states, which precede the Forwarding state. This value is also used, when a topology change has been detected and is underway, to age all dynamic entries in the Forwarding Database.')
stpInfoHoldTime = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 2, 1, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stpInfoHoldTime.setStatus('current')
if mibBuilder.loadTexts: stpInfoHoldTime.setDescription('This time value determines the interval length during which no more than two Configuration bridge PDUs shall be transmitted by this node, in units of hundredths of a second.')
stpInfoPortTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 2, 2), )
if mibBuilder.loadTexts: stpInfoPortTable.setStatus('current')
if mibBuilder.loadTexts: stpInfoPortTable.setDescription('The table of Spanning Tree Group port information.')
stpInfoPortTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 2, 2, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "stpInfoPortStpIndex"), (0, "IBM-GbTOR-10G-L2L3-MIB", "stpInfoPortIndex"))
if mibBuilder.loadTexts: stpInfoPortTableEntry.setStatus('current')
if mibBuilder.loadTexts: stpInfoPortTableEntry.setDescription('Information about port configuration for a particular Spanning Tree Group.')
stpInfoPortStpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 2, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stpInfoPortStpIndex.setStatus('current')
if mibBuilder.loadTexts: stpInfoPortStpIndex.setDescription('The identifier of a particular Spanning Tree Group.')
stpInfoPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 2, 2, 1, 2), PortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stpInfoPortIndex.setStatus('current')
if mibBuilder.loadTexts: stpInfoPortIndex.setDescription('The port identifier of a particular Spanning Tree Group.')
stpInfoPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 7, 6))).clone(namedValues=NamedValues(("disabled", 1), ("blocking", 2), ("listening", 3), ("learning", 4), ("forwarding", 5), ("discarding", 7), ("broken", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stpInfoPortState.setStatus('current')
if mibBuilder.loadTexts: stpInfoPortState.setDescription("The port's current state as defined by application of the Spanning Tree Protocol. This state controls what action a port takes on reception of a frame. If the bridge has detected a port that is malfunctioning it will place that port into the broken(6) state. For ports which are disabled, this object will have a value of disabled(1).")
stpInfoPortDesignatedRoot = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 2, 2, 1, 4), BridgeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stpInfoPortDesignatedRoot.setStatus('current')
if mibBuilder.loadTexts: stpInfoPortDesignatedRoot.setDescription('The unique Bridge Identifier of the Bridge recorded as the Root in the Configuration BPDUs transmitted by the Designated Bridge for the segment to which the port is attached.')
stpInfoPortDesignatedCost = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 2, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stpInfoPortDesignatedCost.setStatus('current')
if mibBuilder.loadTexts: stpInfoPortDesignatedCost.setDescription('The path cost of the Designated Port of the segment connected to this port. This value is compared to the Root Path Cost field in received bridge PDUs.')
stpInfoPortDesignatedBridge = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 2, 2, 1, 6), BridgeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stpInfoPortDesignatedBridge.setStatus('current')
if mibBuilder.loadTexts: stpInfoPortDesignatedBridge.setDescription("The Bridge Identifier of the bridge which this port considers to be the Designated Bridge for this port's segment.")
stpInfoPortDesignatedPort = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 2, 2, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: stpInfoPortDesignatedPort.setStatus('current')
if mibBuilder.loadTexts: stpInfoPortDesignatedPort.setDescription("The Port Identifier of the port on the Designated Bridge for this port's segment.")
stpInfoPortForwardTransitions = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 2, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stpInfoPortForwardTransitions.setStatus('current')
if mibBuilder.loadTexts: stpInfoPortForwardTransitions.setDescription('The number of times this port has transitioned from the Learning state to the Forwarding state.')
stpInfoPortPathCost = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 2, 2, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stpInfoPortPathCost.setStatus('current')
if mibBuilder.loadTexts: stpInfoPortPathCost.setDescription('The path cost of the port.')
stpInfoPortRole = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 2, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("disabled", 1), ("alternate", 2), ("backup", 3), ("root", 4), ("designated", 5), ("master", 6), ("unknown", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stpInfoPortRole.setStatus('current')
if mibBuilder.loadTexts: stpInfoPortRole.setDescription('The port role. Returns unknown(7) when MSTP/RSTP is not enabled, otherwise returns appropriate port role.')
stpInfoPortLinkType = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 2, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("p2p", 1), ("shared", 2), ("unknown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stpInfoPortLinkType.setStatus('current')
if mibBuilder.loadTexts: stpInfoPortLinkType.setDescription('The point-to-point status of the LAN segment attached to this port. A value of p2p (1) indicates that this port is being treated as if it is connected to a point-to-point link. A value of shared(2) indicates that this port is being treated as having a shared media connection.')
stpInfoPortEdge = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 2, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stpInfoPortEdge.setStatus('current')
if mibBuilder.loadTexts: stpInfoPortEdge.setDescription('The port is an edge port or not. Returns disabled(2) when the port is not an edge port and returns enabled(1) when it is an edge port.')
stpInfoPortExtGuard = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 2, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 0))).clone(namedValues=NamedValues(("loop-inc", 1), ("root-inc", 2), ("normal", 0)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stpInfoPortExtGuard.setStatus('current')
if mibBuilder.loadTexts: stpInfoPortExtGuard.setDescription('Current STP guard state. Not include BPDU Guard.')
stpInfoPortPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 2, 2, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stpInfoPortPriority.setStatus('current')
if mibBuilder.loadTexts: stpInfoPortPriority.setDescription('The four most significant bits of the Port Identifier of the Spanning Tree instance can be modified by setting this value.')
lacpInfoAggrTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3, 1), )
if mibBuilder.loadTexts: lacpInfoAggrTable.setStatus('current')
if mibBuilder.loadTexts: lacpInfoAggrTable.setDescription('The table of LACP aggregator information.')
lacpInfoAggrTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3, 1, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "lacpInfoAggrIndex"))
if mibBuilder.loadTexts: lacpInfoAggrTableEntry.setStatus('current')
if mibBuilder.loadTexts: lacpInfoAggrTableEntry.setDescription('Information about a LACP aggregator.')
lacpInfoAggrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3, 1, 1, 1), PortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpInfoAggrIndex.setStatus('current')
if mibBuilder.loadTexts: lacpInfoAggrIndex.setDescription('The aggregator identifier.')
lacpInfoAggrId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpInfoAggrId.setStatus('current')
if mibBuilder.loadTexts: lacpInfoAggrId.setDescription('LACP aggregator ID')
lacpInfoAggrMac = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3, 1, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpInfoAggrMac.setStatus('current')
if mibBuilder.loadTexts: lacpInfoAggrMac.setDescription('LACP aggregator MAC address')
lacpInfoAggrActSysPrio = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpInfoAggrActSysPrio.setStatus('current')
if mibBuilder.loadTexts: lacpInfoAggrActSysPrio.setDescription('LACP aggregator actor system priority')
lacpInfoAggrActSysId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3, 1, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpInfoAggrActSysId.setStatus('current')
if mibBuilder.loadTexts: lacpInfoAggrActSysId.setDescription('LACP aggregator actor system ID')
lacpInfoAggrIndivState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpInfoAggrIndivState.setStatus('current')
if mibBuilder.loadTexts: lacpInfoAggrIndivState.setDescription('LACP aggregator individual state')
lacpInfoAggrActAdminKey = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpInfoAggrActAdminKey.setStatus('current')
if mibBuilder.loadTexts: lacpInfoAggrActAdminKey.setDescription('LACP aggregator actor admin key')
lacpInfoAggrActOperKey = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpInfoAggrActOperKey.setStatus('current')
if mibBuilder.loadTexts: lacpInfoAggrActOperKey.setDescription('LACP aggregator actor oper key')
lacpInfoAggrPartSysPrio = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpInfoAggrPartSysPrio.setStatus('current')
if mibBuilder.loadTexts: lacpInfoAggrPartSysPrio.setDescription('LACP aggregator partner system priority')
lacpInfoAggrPartSysId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3, 1, 1, 10), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpInfoAggrPartSysId.setStatus('current')
if mibBuilder.loadTexts: lacpInfoAggrPartSysId.setDescription('LACP aggregator partner system ID')
lacpInfoAggrPartOperKey = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3, 1, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpInfoAggrPartOperKey.setStatus('current')
if mibBuilder.loadTexts: lacpInfoAggrPartOperKey.setDescription('LACP aggregator partner oper key')
lacpInfoAggrReadyState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpInfoAggrReadyState.setStatus('current')
if mibBuilder.loadTexts: lacpInfoAggrReadyState.setDescription('LACP aggregator ready state')
lacpInfoAggrNumPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3, 1, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpInfoAggrNumPorts.setStatus('current')
if mibBuilder.loadTexts: lacpInfoAggrNumPorts.setDescription('Number of ports in aggregator')
lacpInfoPort = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3, 2))
lacpInfoPortGeneralTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3, 2, 1), )
if mibBuilder.loadTexts: lacpInfoPortGeneralTable.setStatus('current')
if mibBuilder.loadTexts: lacpInfoPortGeneralTable.setDescription('The table of LACP port general information.')
lacpInfoPortGeneralTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3, 2, 1, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "lacpInfoPortGeneralIndex"))
if mibBuilder.loadTexts: lacpInfoPortGeneralTableEntry.setStatus('current')
if mibBuilder.loadTexts: lacpInfoPortGeneralTableEntry.setDescription('General information about a LACP port.')
lacpInfoPortGeneralIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3, 2, 1, 1, 1), PortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpInfoPortGeneralIndex.setStatus('current')
if mibBuilder.loadTexts: lacpInfoPortGeneralIndex.setDescription('The port identifier.')
lacpInfoPortLacpEna = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpInfoPortLacpEna.setStatus('current')
if mibBuilder.loadTexts: lacpInfoPortLacpEna.setDescription('LACP enabled on port')
lacpInfoPortAdminEna = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpInfoPortAdminEna.setStatus('current')
if mibBuilder.loadTexts: lacpInfoPortAdminEna.setDescription('LACP port admin enabled')
lacpInfoPortActSysId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3, 2, 1, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpInfoPortActSysId.setStatus('current')
if mibBuilder.loadTexts: lacpInfoPortActSysId.setDescription('LACP port actor system ID')
lacpInfoPortActSysPrio = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3, 2, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpInfoPortActSysPrio.setStatus('current')
if mibBuilder.loadTexts: lacpInfoPortActSysPrio.setDescription('LACP port actor system priority')
lacpInfoPortActAdminKey = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3, 2, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpInfoPortActAdminKey.setStatus('current')
if mibBuilder.loadTexts: lacpInfoPortActAdminKey.setDescription('LACP port actor admin key')
lacpInfoPortActOperKey = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3, 2, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpInfoPortActOperKey.setStatus('current')
if mibBuilder.loadTexts: lacpInfoPortActOperKey.setDescription('LACP port actor oper key')
lacpInfoPortActPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3, 2, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpInfoPortActPortNum.setStatus('current')
if mibBuilder.loadTexts: lacpInfoPortActPortNum.setDescription('LACP port number')
lacpInfoPortActPortPrio = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3, 2, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpInfoPortActPortPrio.setStatus('current')
if mibBuilder.loadTexts: lacpInfoPortActPortPrio.setDescription('LACP port priority')
lacpInfoPortIndivState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpInfoPortIndivState.setStatus('current')
if mibBuilder.loadTexts: lacpInfoPortIndivState.setDescription('LACP port individual state')
lacpInfoSelAggrId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3, 2, 1, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpInfoSelAggrId.setStatus('current')
if mibBuilder.loadTexts: lacpInfoSelAggrId.setDescription('LACP port selected aggregator ID')
lacpInfoAttAggrId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3, 2, 1, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpInfoAttAggrId.setStatus('current')
if mibBuilder.loadTexts: lacpInfoAttAggrId.setDescription('LACP port attached aggregator ID')
lacpInfoPortReadyN = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3, 2, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpInfoPortReadyN.setStatus('current')
if mibBuilder.loadTexts: lacpInfoPortReadyN.setDescription('True value for Ready_N flag indicates that the wait while timer has expired and it is waiting to attach to an aggregator. There is one Ready_N value for each port.')
lacpInfoPortNtt = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3, 2, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpInfoPortNtt.setStatus('current')
if mibBuilder.loadTexts: lacpInfoPortNtt.setDescription('Need to transmit flag. True indicates that there is new protocol information that should be transmitted on the link.')
lacpInfoPortSelected = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3, 2, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("selected", 1), ("unselected", 2), ("standby", 3), ("suspended", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpInfoPortSelected.setStatus('current')
if mibBuilder.loadTexts: lacpInfoPortSelected.setDescription('Selected flag value indicates that the selection logic has selected an appropriate Aggregator. A value of unselected indicates that no aggregator is currently selected. A value of standby indicates that although the selection logic has selected an appropriate Aggregator, aggregation restrictions currently prevent the port from being enabled as part of the aggregation, and so the port is being held in standby condition. A value of suspended indicates that the port in a LACP port-channel cannot be aggregated due to, for example, incompatible LACP system/port attributes of the remote endpoints. ')
lacpInfoPortMoved = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3, 2, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpInfoPortMoved.setStatus('current')
if mibBuilder.loadTexts: lacpInfoPortMoved.setDescription('Port Moved flag is set to true if the receive machine for a port is in the port_disabled state, and the combination of partner oper system and partner oper port number in use by the port has been used by received in an incoming LACPDU on a different port.')
lacpInfoCollDetState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3, 2, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpInfoCollDetState.setStatus('current')
if mibBuilder.loadTexts: lacpInfoCollDetState.setDescription('LACP port collision and detection state')
lacpInfoPortRxState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3, 2, 1, 1, 18), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpInfoPortRxState.setStatus('current')
if mibBuilder.loadTexts: lacpInfoPortRxState.setDescription('LACP port RX machine state')
lacpInfoPortMuxState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3, 2, 1, 1, 19), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpInfoPortMuxState.setStatus('current')
if mibBuilder.loadTexts: lacpInfoPortMuxState.setDescription('LACP port Mux machine state')
lacpInfoPortPerState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3, 2, 1, 1, 20), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpInfoPortPerState.setStatus('current')
if mibBuilder.loadTexts: lacpInfoPortPerState.setDescription('LACP port periodic machine state')
lacpInfoPortPerTraTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3, 2, 1, 1, 21), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpInfoPortPerTraTimer.setStatus('current')
if mibBuilder.loadTexts: lacpInfoPortPerTraTimer.setDescription('Periodic Transmit Timer')
lacpInfoPortCurWhileTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3, 2, 1, 1, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpInfoPortCurWhileTimer.setStatus('current')
if mibBuilder.loadTexts: lacpInfoPortCurWhileTimer.setDescription('Current While Timer')
lacpInfoPortOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3, 2, 1, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disabled", 1), ("up", 2), ("down", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpInfoPortOperState.setStatus('current')
if mibBuilder.loadTexts: lacpInfoPortOperState.setDescription('The current operational state of LACP on the port.')
lacpInfoPortAdminTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3, 2, 2), )
if mibBuilder.loadTexts: lacpInfoPortAdminTable.setStatus('current')
if mibBuilder.loadTexts: lacpInfoPortAdminTable.setDescription('The table of LACP port admin information.')
lacpInfoPortAdminTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3, 2, 2, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "lacpInfoPortAdminIndex"))
if mibBuilder.loadTexts: lacpInfoPortAdminTableEntry.setStatus('current')
if mibBuilder.loadTexts: lacpInfoPortAdminTableEntry.setDescription('Admin information about a LACP port.')
lacpInfoPortAdminIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3, 2, 2, 1, 1), PortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpInfoPortAdminIndex.setStatus('current')
if mibBuilder.loadTexts: lacpInfoPortAdminIndex.setDescription('The port identifier.')
lacpInfoPortActAdPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3, 2, 2, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpInfoPortActAdPortState.setStatus('current')
if mibBuilder.loadTexts: lacpInfoPortActAdPortState.setDescription('The state of Actor Administrator Port. This is a octet mask with the following bits: Activity, Synchronization, Defaulted, Timeout, Collecting, Expired, Aggregation and Distributing. If all of them are 0 then the state is showed as 0x0, else it is displayed a blank state which mean is not a NULL state')
lacpInfoPortActAdActiv = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3, 2, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("passive", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpInfoPortActAdActiv.setStatus('current')
if mibBuilder.loadTexts: lacpInfoPortActAdActiv.setDescription('The state of Actor Administrator Port Activity')
lacpInfoPortActAdSync = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3, 2, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpInfoPortActAdSync.setStatus('current')
if mibBuilder.loadTexts: lacpInfoPortActAdSync.setDescription('The state of Actor Administrator Port Synchronization')
lacpInfoPortActAdDef = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3, 2, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpInfoPortActAdDef.setStatus('current')
if mibBuilder.loadTexts: lacpInfoPortActAdDef.setDescription('The state of Actor Administrator Port Defaulted')
lacpInfoPortActAdTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3, 2, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("short", 1), ("long", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpInfoPortActAdTimeout.setStatus('current')
if mibBuilder.loadTexts: lacpInfoPortActAdTimeout.setDescription('The state of Actor Administrator Port Timeout')
lacpInfoPortActAdColl = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3, 2, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpInfoPortActAdColl.setStatus('current')
if mibBuilder.loadTexts: lacpInfoPortActAdColl.setDescription('The state of Actor Administrator Port Collecting')
lacpInfoPortActAdExp = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3, 2, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpInfoPortActAdExp.setStatus('current')
if mibBuilder.loadTexts: lacpInfoPortActAdExp.setDescription('The state of Actor Administrator Port Expired')
lacpInfoPortActAdAggr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3, 2, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpInfoPortActAdAggr.setStatus('current')
if mibBuilder.loadTexts: lacpInfoPortActAdAggr.setDescription('The state of Actor Administrator Port Aggregation')
lacpInfoPortActAdDist = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3, 2, 2, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpInfoPortActAdDist.setStatus('current')
if mibBuilder.loadTexts: lacpInfoPortActAdDist.setDescription('The state of Actor Administrator Port Distributing')
lacpInfoPortOperTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3, 2, 3), )
if mibBuilder.loadTexts: lacpInfoPortOperTable.setStatus('current')
if mibBuilder.loadTexts: lacpInfoPortOperTable.setDescription('The table of LACP port oper information.')
lacpInfoPortOperTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3, 2, 3, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "lacpInfoPortOperIndex"))
if mibBuilder.loadTexts: lacpInfoPortOperTableEntry.setStatus('current')
if mibBuilder.loadTexts: lacpInfoPortOperTableEntry.setDescription('Oper information about a LACP port.')
lacpInfoPortOperIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3, 2, 3, 1, 1), PortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpInfoPortOperIndex.setStatus('current')
if mibBuilder.loadTexts: lacpInfoPortOperIndex.setDescription('The port identifier.')
lacpInfoPortPartOpSysPrio = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3, 2, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpInfoPortPartOpSysPrio.setStatus('current')
if mibBuilder.loadTexts: lacpInfoPortPartOpSysPrio.setDescription('The value of Partner Operator Port System Priority')
lacpInfoPortPartOpSysId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3, 2, 3, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpInfoPortPartOpSysId.setStatus('current')
if mibBuilder.loadTexts: lacpInfoPortPartOpSysId.setDescription('The value of Partner Operator Port System ID')
lacpInfoPortPartOpKey = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3, 2, 3, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpInfoPortPartOpKey.setStatus('current')
if mibBuilder.loadTexts: lacpInfoPortPartOpKey.setDescription('The value of Partner Operator Port Key')
lacpInfoPortPartOpPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3, 2, 3, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpInfoPortPartOpPortNum.setStatus('current')
if mibBuilder.loadTexts: lacpInfoPortPartOpPortNum.setDescription('The Partner Operator Port Number')
lacpInfoPortPartOpPortPrio = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3, 2, 3, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpInfoPortPartOpPortPrio.setStatus('current')
if mibBuilder.loadTexts: lacpInfoPortPartOpPortPrio.setDescription('The value of Partner Operator Port Priority')
lacpInfoPortActOpPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3, 2, 3, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpInfoPortActOpPortState.setStatus('current')
if mibBuilder.loadTexts: lacpInfoPortActOpPortState.setDescription('The state of Actor Operator Port. This is a octet mask with the following bits: Activity, Synchronization, Defaulted, Timeout, Collecting, Expired, Aggregation and Distributing. If all of them are 0 then the state is showed as 0x0, else it is displayed a blank state which mean is not a NULL state')
lacpInfoPortActOpActiv = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3, 2, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("passive", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpInfoPortActOpActiv.setStatus('current')
if mibBuilder.loadTexts: lacpInfoPortActOpActiv.setDescription('The state of Actor Operator Port Activity')
lacpInfoPortActOpSync = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3, 2, 3, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpInfoPortActOpSync.setStatus('current')
if mibBuilder.loadTexts: lacpInfoPortActOpSync.setDescription('The state of Actor Operator Port Synchronization')
lacpInfoPortActOpDef = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3, 2, 3, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpInfoPortActOpDef.setStatus('current')
if mibBuilder.loadTexts: lacpInfoPortActOpDef.setDescription('The state of Actor Operator Port Defaulted')
lacpInfoPortActOpTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3, 2, 3, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("short", 1), ("long", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpInfoPortActOpTimeout.setStatus('current')
if mibBuilder.loadTexts: lacpInfoPortActOpTimeout.setDescription('The state of Actor Operator Port Timeout')
lacpInfoPortActOpColl = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3, 2, 3, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpInfoPortActOpColl.setStatus('current')
if mibBuilder.loadTexts: lacpInfoPortActOpColl.setDescription('The state of Actor Operator Port Collecting')
lacpInfoPortActOpExp = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3, 2, 3, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpInfoPortActOpExp.setStatus('current')
if mibBuilder.loadTexts: lacpInfoPortActOpExp.setDescription('The state of Actor Operator Port Expired')
lacpInfoPortActOpAggr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3, 2, 3, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpInfoPortActOpAggr.setStatus('current')
if mibBuilder.loadTexts: lacpInfoPortActOpAggr.setDescription('The state of Actor Operator Port Aggregation')
lacpInfoPortActOpDist = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3, 2, 3, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpInfoPortActOpDist.setStatus('current')
if mibBuilder.loadTexts: lacpInfoPortActOpDist.setDescription('The state of Actor Operator Port Distributing')
lacpInfoPortPartOpPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3, 2, 3, 1, 16), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpInfoPortPartOpPortState.setStatus('current')
if mibBuilder.loadTexts: lacpInfoPortPartOpPortState.setDescription('The state of Partner Operator Port. This is a octet mask with the following bits: Activity, Synchronization, Defaulted, Timeout, Collecting, Expired, Aggregation and Distributing. If all of them are 0 then the state is showed as 0x0, else it is displayed a blank state which mean is not a NULL state')
lacpInfoPortPartOpActiv = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3, 2, 3, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("passive", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpInfoPortPartOpActiv.setStatus('current')
if mibBuilder.loadTexts: lacpInfoPortPartOpActiv.setDescription('The state of Partner Operator Port Activity')
lacpInfoPortPartOpSync = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3, 2, 3, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpInfoPortPartOpSync.setStatus('current')
if mibBuilder.loadTexts: lacpInfoPortPartOpSync.setDescription('The state of Partner Operator Port Synchronization')
lacpInfoPortPartOpDef = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3, 2, 3, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpInfoPortPartOpDef.setStatus('current')
if mibBuilder.loadTexts: lacpInfoPortPartOpDef.setDescription('The state of Partner Operator Port Defaulted')
lacpInfoPortPartOpTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3, 2, 3, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("short", 1), ("long", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpInfoPortPartOpTimeout.setStatus('current')
if mibBuilder.loadTexts: lacpInfoPortPartOpTimeout.setDescription('The state of Partner Operator Port Timeout')
lacpInfoPortPartOpColl = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3, 2, 3, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpInfoPortPartOpColl.setStatus('current')
if mibBuilder.loadTexts: lacpInfoPortPartOpColl.setDescription('The state of Partner Operator Port Collecting')
lacpInfoPortPartOpExp = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3, 2, 3, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpInfoPortPartOpExp.setStatus('current')
if mibBuilder.loadTexts: lacpInfoPortPartOpExp.setDescription('The state of Partner Operator Port Expired')
lacpInfoPortPartOpAggr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3, 2, 3, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpInfoPortPartOpAggr.setStatus('current')
if mibBuilder.loadTexts: lacpInfoPortPartOpAggr.setDescription('The state of Partner Operator Port Aggregation')
lacpInfoPortPartOpDist = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 3, 2, 3, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lacpInfoPortPartOpDist.setStatus('current')
if mibBuilder.loadTexts: lacpInfoPortPartOpDist.setDescription('The state of Partner Operator Port Distributing')
cistRoot = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 4, 1, 1), BridgeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cistRoot.setStatus('current')
if mibBuilder.loadTexts: cistRoot.setDescription('The bridge identifier of the Root of the common spanning tree as determined by the Spanning Tree Protocol as executed by this node. This value is used as the CIST Root Identifier parameter in all Configuration Bridge PDUs originated by this node.')
cistRootPathCost = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cistRootPathCost.setStatus('current')
if mibBuilder.loadTexts: cistRootPathCost.setDescription('The cost of the path to the CIST Root as seen from this bridge.')
cistRootPort = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 4, 1, 3), PortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cistRootPort.setStatus('current')
if mibBuilder.loadTexts: cistRootPort.setDescription('The Port Number of the Port which offers the lowest path cost from this bridge to the CIST Root Bridge.')
cistBridgeHelloTime = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 4, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cistBridgeHelloTime.setStatus('current')
if mibBuilder.loadTexts: cistBridgeHelloTime.setDescription('The amount of time between the transmission of Configuration bridge PDUs in seconds.')
cistBridgeMaxAge = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 4, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cistBridgeMaxAge.setStatus('current')
if mibBuilder.loadTexts: cistBridgeMaxAge.setDescription('The value in seconds that all bridges use for MaxAge when this bridge is acting as the root.')
cistBridgeForwardDelay = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 4, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cistBridgeForwardDelay.setStatus('current')
if mibBuilder.loadTexts: cistBridgeForwardDelay.setDescription('The value in seconds that all bridges use for ForwardDelay when this bridge is acting as the root.')
cistRegionalRoot = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 4, 1, 7), BridgeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cistRegionalRoot.setStatus('current')
if mibBuilder.loadTexts: cistRegionalRoot.setDescription('The bridge identifier of the Root of the Multiple spanning tree region as determined by the Spanning Tree Protocol as executed by this node. This value is used as the CIST Regional Root Identifier parameter in all Configuration Bridge PDUs originated by this node.')
cistRegionalPathCost = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 4, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cistRegionalPathCost.setStatus('current')
if mibBuilder.loadTexts: cistRegionalPathCost.setDescription('The Cost of the path to the CIST Regional Root as seen from this bridge.')
mstpDigest = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 4, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mstpDigest.setStatus('current')
if mibBuilder.loadTexts: mstpDigest.setDescription('The digest of the mstp.')
cistInfoPortTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 4, 2), )
if mibBuilder.loadTexts: cistInfoPortTable.setStatus('current')
if mibBuilder.loadTexts: cistInfoPortTable.setDescription('The table of CIST Port information.')
cistInfoPortTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 4, 2, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "cistInfoPortIndex"))
if mibBuilder.loadTexts: cistInfoPortTableEntry.setStatus('current')
if mibBuilder.loadTexts: cistInfoPortTableEntry.setDescription('Information about a particular CIST Port.')
cistInfoPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 4, 2, 1, 1), PortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cistInfoPortIndex.setStatus('current')
if mibBuilder.loadTexts: cistInfoPortIndex.setDescription('The port number of the port for which this entry contains spanning tree configuration.')
cistInfoPortPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 4, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cistInfoPortPriority.setStatus('current')
if mibBuilder.loadTexts: cistInfoPortPriority.setDescription('The four most significant bits of the Port Identifier of the Spanning Tree instance can be modified by setting this value.')
cistInfoPortPathCost = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 4, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cistInfoPortPathCost.setStatus('current')
if mibBuilder.loadTexts: cistInfoPortPathCost.setDescription('The contribution of this port to the path cost of paths towards the CIST Root which include this port.')
cistInfoPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 4, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 5))).clone(namedValues=NamedValues(("disabled", 1), ("discarding", 2), ("learning", 4), ("forwarding", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cistInfoPortState.setStatus('current')
if mibBuilder.loadTexts: cistInfoPortState.setDescription('Current state of the Port as defined by the Common spanning tree protocol.')
cistInfoPortRole = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 4, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("disabled", 1), ("alternate", 2), ("backup", 3), ("root", 4), ("designated", 5), ("master", 6), ("unknown", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cistInfoPortRole.setStatus('current')
if mibBuilder.loadTexts: cistInfoPortRole.setDescription('Selected Port Role of the port for this spanning tree instance.')
cistInfoPortDesignatedBridge = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 4, 2, 1, 6), BridgeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cistInfoPortDesignatedBridge.setStatus('current')
if mibBuilder.loadTexts: cistInfoPortDesignatedBridge.setDescription("The unique Bridge Identifier of the bridge which this port considers to be the Designated Bridge for the port's segment.")
cistInfoPortDesignatedPort = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 4, 2, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: cistInfoPortDesignatedPort.setStatus('current')
if mibBuilder.loadTexts: cistInfoPortDesignatedPort.setDescription("The Port identifier of the port on the Designated Bridge for this port's segment.")
cistInfoPortLinkType = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 4, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("p2p", 1), ("shared", 2), ("unknown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cistInfoPortLinkType.setStatus('current')
if mibBuilder.loadTexts: cistInfoPortLinkType.setDescription('The point-to-point status of the LAN segment attached to this port. A value of p2p (2) indicates that this port is being treated as if it is connected to a point-to-point link. A value of shared(3) indicates that this port is being treated as having a shared media connection.')
cistInfoPortHelloTime = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 4, 2, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cistInfoPortHelloTime.setStatus('current')
if mibBuilder.loadTexts: cistInfoPortHelloTime.setDescription('CIST port Hello Time')
cistInfoPortEdge = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 4, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cistInfoPortEdge.setStatus('current')
if mibBuilder.loadTexts: cistInfoPortEdge.setDescription('The port is an edge port or not. Returns disabled(2) when the port is not an edge port and returns enabled(1) when it is an edge port.')
vlanInfoTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 5, 1), )
if mibBuilder.loadTexts: vlanInfoTable.setStatus('current')
if mibBuilder.loadTexts: vlanInfoTable.setDescription('The table of VLAN information.')
vlanInfoTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 5, 1, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "vlanInfoId"))
if mibBuilder.loadTexts: vlanInfoTableEntry.setStatus('current')
if mibBuilder.loadTexts: vlanInfoTableEntry.setDescription('Information about a particular VLAN.')
vlanInfoId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 5, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4090))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlanInfoId.setStatus('current')
if mibBuilder.loadTexts: vlanInfoId.setDescription('The VLAN identifier.')
vlanInfoName = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 5, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlanInfoName.setStatus('current')
if mibBuilder.loadTexts: vlanInfoName.setDescription('The VLAN name.')
vlanInfoStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 5, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("enabled", 2), ("disabled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlanInfoStatus.setStatus('current')
if mibBuilder.loadTexts: vlanInfoStatus.setDescription('Enable or disable, VLAN state information')
vlanInfoPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 5, 1, 1, 7), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlanInfoPorts.setStatus('current')
if mibBuilder.loadTexts: vlanInfoPorts.setDescription('The port list information in the VLAN. The ports are presented in bitmap format. in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ port 8 || || || ||___ port 7 || |____ port 6 || . . . ||_________ port 1 |__________ reserved where x : 1 - The represented port belongs to the VLAN 0 - The represented port does not belong to the VLAN')
vlagCurIslCfgPortChannel = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 18, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlagCurIslCfgPortChannel.setStatus('current')
if mibBuilder.loadTexts: vlagCurIslCfgPortChannel.setDescription('Current vLAG ISL portchannel')
vlagNewIslCfgPortChannel = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 18, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlagNewIslCfgPortChannel.setStatus('current')
if mibBuilder.loadTexts: vlagNewIslCfgPortChannel.setDescription('This object is used to change the vLAG ISL portchannel.')
vlagCurIslCfgAdminKey = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 18, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlagCurIslCfgAdminKey.setStatus('current')
if mibBuilder.loadTexts: vlagCurIslCfgAdminKey.setDescription('Current vLAG ISL admin key.')
vlagNewIslCfgAdminKey = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 18, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlagNewIslCfgAdminKey.setStatus('current')
if mibBuilder.loadTexts: vlagNewIslCfgAdminKey.setDescription('This object is used to change the vLAG ISL admin key.')
vlagCurCfgSwitchPriority = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 18, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlagCurCfgSwitchPriority.setStatus('current')
if mibBuilder.loadTexts: vlagCurCfgSwitchPriority.setDescription('Current vLAG switch priority')
vlagNewCfgSwitchPriority = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 18, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlagNewCfgSwitchPriority.setStatus('current')
if mibBuilder.loadTexts: vlagNewCfgSwitchPriority.setDescription('This object is used to change the vLAG priority of this switch.')
vlagCurCfgTrunkTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 18, 6), )
if mibBuilder.loadTexts: vlagCurCfgTrunkTable.setStatus('current')
if mibBuilder.loadTexts: vlagCurCfgTrunkTable.setDescription('A table of objects of the vLAG groups configured in this switch.')
vlagCurCfgTrunkTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 18, 6, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "vlagCurCfgTrunkIndex"))
if mibBuilder.loadTexts: vlagCurCfgTrunkTableEntry.setStatus('current')
if mibBuilder.loadTexts: vlagCurCfgTrunkTableEntry.setDescription('The configuration objects for an vLAG group.')
vlagCurCfgTrunkIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 18, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlagCurCfgTrunkIndex.setStatus('current')
if mibBuilder.loadTexts: vlagCurCfgTrunkIndex.setDescription('The identifier of the trunk group.')
vlagCurCfgTrunkState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 18, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlagCurCfgTrunkState.setStatus('current')
if mibBuilder.loadTexts: vlagCurCfgTrunkState.setDescription('The current administrative state of the vLAG group.')
vlagNewCfgTrunkTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 18, 7), )
if mibBuilder.loadTexts: vlagNewCfgTrunkTable.setStatus('current')
if mibBuilder.loadTexts: vlagNewCfgTrunkTable.setDescription('A table of objects of the vLAG groups configured in this switch.')
vlagNewCfgTrunkTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 18, 7, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "vlagNewCfgTrunkIndex"))
if mibBuilder.loadTexts: vlagNewCfgTrunkTableEntry.setStatus('current')
if mibBuilder.loadTexts: vlagNewCfgTrunkTableEntry.setDescription('The configuration objects for an vLAG group.')
vlagNewCfgTrunkIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 18, 7, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlagNewCfgTrunkIndex.setStatus('current')
if mibBuilder.loadTexts: vlagNewCfgTrunkIndex.setDescription('The identifier of the trunk group.')
vlagNewCfgTrunkState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 18, 7, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlagNewCfgTrunkState.setStatus('current')
if mibBuilder.loadTexts: vlagNewCfgTrunkState.setDescription('The current administrative state of the vLAG group.')
vlagCurCfgLacpTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 18, 8), )
if mibBuilder.loadTexts: vlagCurCfgLacpTable.setStatus('current')
if mibBuilder.loadTexts: vlagCurCfgLacpTable.setDescription('A table of objects of the vLAG groups configured in this switch.')
vlagCurCfgLacpTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 18, 8, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "vlagCurCfgLacpKey"))
if mibBuilder.loadTexts: vlagCurCfgLacpTableEntry.setStatus('current')
if mibBuilder.loadTexts: vlagCurCfgLacpTableEntry.setDescription('The configuration objects for an vLAG group.')
vlagCurCfgLacpKey = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 18, 8, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlagCurCfgLacpKey.setStatus('current')
if mibBuilder.loadTexts: vlagCurCfgLacpKey.setDescription('The identifier of the trunk group.')
vlagCurCfgLacpState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 18, 8, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlagCurCfgLacpState.setStatus('current')
if mibBuilder.loadTexts: vlagCurCfgLacpState.setDescription('The current administrative state of the vLAG group.')
vlagNewCfgLacpTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 18, 9), )
if mibBuilder.loadTexts: vlagNewCfgLacpTable.setStatus('current')
if mibBuilder.loadTexts: vlagNewCfgLacpTable.setDescription('A table of objects of the vLAG groups configured in this switch.')
vlagNewCfgLacpTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 18, 9, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "vlagNewCfgLacpKey"))
if mibBuilder.loadTexts: vlagNewCfgLacpTableEntry.setStatus('current')
if mibBuilder.loadTexts: vlagNewCfgLacpTableEntry.setDescription('The configuration objects for an vLAG group.')
vlagNewCfgLacpKey = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 18, 9, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlagNewCfgLacpKey.setStatus('current')
if mibBuilder.loadTexts: vlagNewCfgLacpKey.setDescription('The identifier of the trunk group.')
vlagNewCfgLacpState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 18, 9, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlagNewCfgLacpState.setStatus('current')
if mibBuilder.loadTexts: vlagNewCfgLacpState.setDescription('The current administrative state of the vLAG group.')
vlagCurCfgHlthchkPeerIp = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 18, 10), IpAddress().clone(hexValue="00000000")).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlagCurCfgHlthchkPeerIp.setStatus('current')
if mibBuilder.loadTexts: vlagCurCfgHlthchkPeerIp.setDescription('The current Health check Peer ip address.')
vlagNewCfgHlthchkPeerIp = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 18, 11), IpAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlagNewCfgHlthchkPeerIp.setStatus('current')
if mibBuilder.loadTexts: vlagNewCfgHlthchkPeerIp.setDescription('The New Health check Peer ip address.')
vlagCurCfgTierId = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 18, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 512))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlagCurCfgTierId.setStatus('current')
if mibBuilder.loadTexts: vlagCurCfgTierId.setDescription('Current vLAG Tier ID')
vlagNewCfgTierId = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 18, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 512))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlagNewCfgTierId.setStatus('current')
if mibBuilder.loadTexts: vlagNewCfgTierId.setDescription('This object is used to change the vLAG Tier ID of this switch. vLAG consist of 2 vLAG peer switches connected by ISL link, the system formed by the switches is referred to as a vLAG tier. This object is used to specify the vLAG tier. And the tier id is used to generate vLAG system MAC.')
vlagCurCfgStartupDelayInterval = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 18, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3600)).clone(120)).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlagCurCfgStartupDelayInterval.setStatus('current')
if mibBuilder.loadTexts: vlagCurCfgStartupDelayInterval.setDescription('Current vLAG Startup delay interval')
vlagNewCfgStartupDelayInterval = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 18, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3600)).clone(120)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlagNewCfgStartupDelayInterval.setStatus('current')
if mibBuilder.loadTexts: vlagNewCfgStartupDelayInterval.setDescription('This object is used to change the vLAG startup Delay Timer interval. The Timer is used to prevent traffic lost for the vLAG ports may be up before the ISL is up. The Timer is st- arted when the ISL is up and the role has been elected. And when the timer expires, all vLAG ports will be up. Before and during the timer running, all vLAG ports should be err- disabled.')
vlagCurCfgGlobalEnable = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 18, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlagCurCfgGlobalEnable.setStatus('current')
if mibBuilder.loadTexts: vlagCurCfgGlobalEnable.setDescription('Current vLAG global status on switch.')
vlagNewCfgGlobalEnable = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 18, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlagNewCfgGlobalEnable.setStatus('current')
if mibBuilder.loadTexts: vlagNewCfgGlobalEnable.setDescription('Set true to enable vLAG globally or Set false to disable vLAG globally on switch.')
vlagCurCfgHlthchkConnectRetryInterval = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 18, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 300)).clone(30)).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlagCurCfgHlthchkConnectRetryInterval.setStatus('current')
if mibBuilder.loadTexts: vlagCurCfgHlthchkConnectRetryInterval.setDescription('In case of healtcheck TCP connection can not be established, interval at which the retry attempt will be made to connect to the peer.')
vlagNewCfgHlthchkConnectRetryInterval = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 18, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 300)).clone(30)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlagNewCfgHlthchkConnectRetryInterval.setStatus('current')
if mibBuilder.loadTexts: vlagNewCfgHlthchkConnectRetryInterval.setDescription('In case of healtcheck TCP connection can not be established, interval at which the retry attempt will be made to connect to the peer.')
vlagCurCfgHlthchkKeepaliveAttempts = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 18, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 24)).clone(3)).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlagCurCfgHlthchkKeepaliveAttempts.setStatus('current')
if mibBuilder.loadTexts: vlagCurCfgHlthchkKeepaliveAttempts.setDescription('Number of keepalive attempts made before declaring peer is down. Within this time, atleast one of the keepalive message should have been received from the peer.')
vlagNewCfgHlthchkKeepaliveAttempts = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 18, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 24)).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlagNewCfgHlthchkKeepaliveAttempts.setStatus('current')
if mibBuilder.loadTexts: vlagNewCfgHlthchkKeepaliveAttempts.setDescription('Number of keepalive attempts made before declaring peer is down.Within this time, atleast one of the keepalive message should have been received from the peer.')
vlagCurCfgHlthchkKeepaliveInterval = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 18, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 300)).clone(5)).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlagCurCfgHlthchkKeepaliveInterval.setStatus('current')
if mibBuilder.loadTexts: vlagCurCfgHlthchkKeepaliveInterval.setDescription('Interval between keepalives sent over healthcheck TCP session to keep the session alive.')
vlagNewCfgHlthchkKeepaliveInterval = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 18, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 300)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlagNewCfgHlthchkKeepaliveInterval.setStatus('current')
if mibBuilder.loadTexts: vlagNewCfgHlthchkKeepaliveInterval.setDescription('Interval between keepalives sent over healthcheck TCP session to keep the session alive.')
vlagCurCfgAutoRecoveryInterval = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 18, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(240, 3600)).clone(300)).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlagCurCfgAutoRecoveryInterval.setStatus('current')
if mibBuilder.loadTexts: vlagCurCfgAutoRecoveryInterval.setDescription('Current vLAG Auto Recovery interval')
vlagNewCfgAutoRecoveryInterval = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 18, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(240, 3600)).clone(300)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlagNewCfgAutoRecoveryInterval.setStatus('current')
if mibBuilder.loadTexts: vlagNewCfgAutoRecoveryInterval.setDescription('This object is used to change the vLAG Auto Recovery Timer interval. The Timer is used to prevent all vlag ports stay in ErrDisabled state when booting two vLAG switches but one can not be up.')
vlagInfoState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 16, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlagInfoState.setStatus('current')
if mibBuilder.loadTexts: vlagInfoState.setDescription('The current running state of vLAG.')
vlagInfoAdminRole = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 16, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("unelected", 0), ("primary", 1), ("secondary", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlagInfoAdminRole.setStatus('current')
if mibBuilder.loadTexts: vlagInfoAdminRole.setDescription('The current running role of the switch. Role can be Primary(1), secondary(2) and unelected(3). Primary role indicates that the this switch controls the centralized operation in a vLAG domain. Secondary role indicates that this switch can take up the primary role when primary is not available. Unelected indicates that switches are not detected by one another')
vlagInfoISLId = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 16, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlagInfoISLId.setStatus('current')
if mibBuilder.loadTexts: vlagInfoISLId.setDescription('vLAG ISL trunk id.')
vlagInfoLocalMac = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 16, 1, 4), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlagInfoLocalMac.setStatus('current')
if mibBuilder.loadTexts: vlagInfoLocalMac.setDescription('Local vLAG MAC address.')
vlagInfoLocalPriority = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 16, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlagInfoLocalPriority.setStatus('current')
if mibBuilder.loadTexts: vlagInfoLocalPriority.setDescription('Local vLAG Priority.')
vlagInfoRemoteMac = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 16, 1, 6), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlagInfoRemoteMac.setStatus('current')
if mibBuilder.loadTexts: vlagInfoRemoteMac.setDescription('Local vLAG MAC address.')
vlagInfoRemotePriority = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 16, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlagInfoRemotePriority.setStatus('current')
if mibBuilder.loadTexts: vlagInfoRemotePriority.setDescription('Local vLAG Priority.')
vlagInfoHlthchkStatus = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 16, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlagInfoHlthchkStatus.setStatus('current')
if mibBuilder.loadTexts: vlagInfoHlthchkStatus.setDescription('The current health check running status.')
vlagInfoStartupDelayInterval = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 16, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlagInfoStartupDelayInterval.setStatus('current')
if mibBuilder.loadTexts: vlagInfoStartupDelayInterval.setDescription('Startup Delay Timer Interval. The value may be different from vlagCurCfgStartupDelayInterval for the configuration of the interval after the timer is started can only take effect next startup.')
vlagInfoStartupDelayStatus = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 16, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unstarted", 1), ("running", 2), ("finished", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlagInfoStartupDelayStatus.setStatus('current')
if mibBuilder.loadTexts: vlagInfoStartupDelayStatus.setDescription('Startup Delay Timer Status.')
vlagInfoSystemMac = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 16, 1, 11), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlagInfoSystemMac.setStatus('current')
if mibBuilder.loadTexts: vlagInfoSystemMac.setDescription('System vLAG MAC address')
vlagInfoOperaRole = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 16, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("unelected", 0), ("primary", 1), ("secondary", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlagInfoOperaRole.setStatus('current')
if mibBuilder.loadTexts: vlagInfoOperaRole.setDescription('vLAG switch operational role.')
vlagInfoAutoRecoveryInterval = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 16, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlagInfoAutoRecoveryInterval.setStatus('current')
if mibBuilder.loadTexts: vlagInfoAutoRecoveryInterval.setDescription('Auto Recovery Timer Interval. The value may be different from vlagCurCfgAutoRecoveryInterval for the configuration of the interval after the timer is started can only take effect next startup.')
vlagInfoAutoRecoveryStatus = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 16, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unstarted", 1), ("running", 2), ("finished", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlagInfoAutoRecoveryStatus.setStatus('current')
if mibBuilder.loadTexts: vlagInfoAutoRecoveryStatus.setDescription('Auto Recovery Timer Status.')
vlagInfoInstanceTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 16, 2, 1), )
if mibBuilder.loadTexts: vlagInfoInstanceTable.setStatus('current')
if mibBuilder.loadTexts: vlagInfoInstanceTable.setDescription('A table of objects of the running vLAG instances.')
vlagInfoInstanceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 16, 2, 1, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "vlagInstanceId"))
if mibBuilder.loadTexts: vlagInfoInstanceEntry.setStatus('current')
if mibBuilder.loadTexts: vlagInfoInstanceEntry.setDescription('The configuration objects for an vLAG group.')
vlagInstanceId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 16, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlagInstanceId.setStatus('current')
if mibBuilder.loadTexts: vlagInstanceId.setDescription('The identifier of this instance.')
vlagInstanceTrunkId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 16, 2, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlagInstanceTrunkId.setStatus('current')
if mibBuilder.loadTexts: vlagInstanceTrunkId.setDescription('The trunk id of this vLAG instance.')
vlagInstanceAdminKey = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 16, 2, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlagInstanceAdminKey.setStatus('current')
if mibBuilder.loadTexts: vlagInstanceAdminKey.setDescription('AdminKey of this vLAG instance. Applicable only incase of dynamic trunks.')
vlagInstanceState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 16, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("down", 1), ("localUp", 2), ("remoteUp", 3), ("formed", 4))).clone('down')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlagInstanceState.setStatus('current')
if mibBuilder.loadTexts: vlagInstanceState.setDescription('The current running state of the vLAG instance.')
vlagInfoIslId = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 16, 2, 2, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlagInfoIslId.setStatus('current')
if mibBuilder.loadTexts: vlagInfoIslId.setDescription('vLAG ISL Id')
vlagInfoIslProtocol = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 16, 2, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("static", 1), ("lacp", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlagInfoIslProtocol.setStatus('current')
if mibBuilder.loadTexts: vlagInfoIslProtocol.setDescription('vLAG ISL trunk group state Static - static trunk group Lacp - dynamic trunk group')
vlagInfoIslPortchannel = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 16, 2, 2, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlagInfoIslPortchannel.setStatus('current')
if mibBuilder.loadTexts: vlagInfoIslPortchannel.setDescription('vLAG ISL portchannel number')
vlagInfoIslAdminkey = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 16, 2, 2, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlagInfoIslAdminkey.setStatus('current')
if mibBuilder.loadTexts: vlagInfoIslAdminkey.setDescription('vLAG ISL lacp admin key')
vlagInfoIslPorts = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 16, 2, 2, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlagInfoIslPorts.setStatus('current')
if mibBuilder.loadTexts: vlagInfoIslPorts.setDescription('Local vLAG MAC address.')
vlagInfoIslPortState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 16, 2, 2, 7), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlagInfoIslPortState.setStatus('current')
if mibBuilder.loadTexts: vlagInfoIslPortState.setDescription('Local vLAG MAC address.')
vlagStatsClear = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clear", 1), ("other", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlagStatsClear.setStatus('current')
if mibBuilder.loadTexts: vlagStatsClear.setDescription("Setting this object to 'clear' will reset all statistics objects of VLAG. A get action of this object will always return 'other'. Setting this object to 'other' is not allowed.")
vlagStatsIslInOctets = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 11, 2, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlagStatsIslInOctets.setStatus('current')
if mibBuilder.loadTexts: vlagStatsIslInOctets.setDescription('The total number of vlag ISL octets received.')
vlagStatsIslInPackets = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 11, 2, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlagStatsIslInPackets.setStatus('current')
if mibBuilder.loadTexts: vlagStatsIslInPackets.setDescription('The total number of vlag ISL packets received.')
vlagStatsIslOutOctets = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 11, 2, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlagStatsIslOutOctets.setStatus('current')
if mibBuilder.loadTexts: vlagStatsIslOutOctets.setDescription('The total number of vlag ISL octets sent.')
vlagStatsIslOutPackets = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 11, 2, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlagStatsIslOutPackets.setStatus('current')
if mibBuilder.loadTexts: vlagStatsIslOutPackets.setDescription('The total number of vlag ISL packets sent.')
vlagStatsPduSentRoleElection = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 11, 5, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlagStatsPduSentRoleElection.setStatus('current')
if mibBuilder.loadTexts: vlagStatsPduSentRoleElection.setDescription('The total number of vlag PDUs sent for role elections')
vlagStatsPduSentSystemInfo = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 11, 5, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlagStatsPduSentSystemInfo.setStatus('current')
if mibBuilder.loadTexts: vlagStatsPduSentSystemInfo.setDescription('The total number of vlag PDUs sent for system info')
vlagStatsPduSentFdbDynamicAdd = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 11, 5, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlagStatsPduSentFdbDynamicAdd.setStatus('current')
if mibBuilder.loadTexts: vlagStatsPduSentFdbDynamicAdd.setDescription('The total number of vlag PDUs sent for addition of FDB dynamic entry')
vlagStatsPduSentFdbDynamicDel = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 11, 5, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlagStatsPduSentFdbDynamicDel.setStatus('current')
if mibBuilder.loadTexts: vlagStatsPduSentFdbDynamicDel.setDescription('The total number of vlag PDUs sent for deletion of FDB dynamic entry')
vlagStatsPduSentFdbInactiveAdd = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 11, 5, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlagStatsPduSentFdbInactiveAdd.setStatus('current')
if mibBuilder.loadTexts: vlagStatsPduSentFdbInactiveAdd.setDescription('The total number of vlag PDUs sent for addition of FDB inactive entry')
vlagStatsPduSentFdbInactiveDel = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 11, 5, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlagStatsPduSentFdbInactiveDel.setStatus('current')
if mibBuilder.loadTexts: vlagStatsPduSentFdbInactiveDel.setDescription('The total number of vlag PDUs sent for deletion of FDB inactive entry')
vlagStatsPduSentHlthCheck = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 11, 5, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlagStatsPduSentHlthCheck.setStatus('current')
if mibBuilder.loadTexts: vlagStatsPduSentHlthCheck.setDescription('The total number of vlag PDUs sent for Health check')
vlagStatsPduSentOther = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 11, 5, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlagStatsPduSentOther.setStatus('current')
if mibBuilder.loadTexts: vlagStatsPduSentOther.setDescription('The total number of vlag PDUs sent for others')
vlagStatsPduSentUnknown = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 11, 5, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlagStatsPduSentUnknown.setStatus('current')
if mibBuilder.loadTexts: vlagStatsPduSentUnknown.setDescription('The total number of vlag PDUs sent for unknowns')
vlagStatsPduRcvRoleElection = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 11, 5, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlagStatsPduRcvRoleElection.setStatus('current')
if mibBuilder.loadTexts: vlagStatsPduRcvRoleElection.setDescription('The total number of vlag PDUs received for role elections')
vlagStatsPduRcvSystemInfo = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 11, 5, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlagStatsPduRcvSystemInfo.setStatus('current')
if mibBuilder.loadTexts: vlagStatsPduRcvSystemInfo.setDescription('The total number of vlag PDUs received for system info')
vlagStatsPduRcvFdbDynamicAdd = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 11, 5, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlagStatsPduRcvFdbDynamicAdd.setStatus('current')
if mibBuilder.loadTexts: vlagStatsPduRcvFdbDynamicAdd.setDescription('The total number of vlag PDUs received for addition of FDB dynamic entry')
vlagStatsPduRcvFdbDynamicDel = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 11, 5, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlagStatsPduRcvFdbDynamicDel.setStatus('current')
if mibBuilder.loadTexts: vlagStatsPduRcvFdbDynamicDel.setDescription('The total number of vlag PDUs received for deletion of FDB dynamic entry')
vlagStatsPduRcvFdbInactiveAdd = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 11, 5, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlagStatsPduRcvFdbInactiveAdd.setStatus('current')
if mibBuilder.loadTexts: vlagStatsPduRcvFdbInactiveAdd.setDescription('The total number of vlag PDUs received for addition of FDB inactive entry')
vlagStatsPduRcvFdbInactiveDel = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 11, 5, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlagStatsPduRcvFdbInactiveDel.setStatus('current')
if mibBuilder.loadTexts: vlagStatsPduRcvFdbInactiveDel.setDescription('The total number of vlag PDUs received for deletion of FDB inactive entry')
vlagStatsPduRcvHlthCheck = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 11, 5, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlagStatsPduRcvHlthCheck.setStatus('current')
if mibBuilder.loadTexts: vlagStatsPduRcvHlthCheck.setDescription('The total number of vlag PDUs received for Health check')
vlagStatsPduRcvOther = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 11, 5, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlagStatsPduRcvOther.setStatus('current')
if mibBuilder.loadTexts: vlagStatsPduRcvOther.setDescription('The total number of vlag PDUs received for others')
vlagStatsPduRcvUnknown = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 11, 5, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlagStatsPduRcvUnknown.setStatus('current')
if mibBuilder.loadTexts: vlagStatsPduRcvUnknown.setDescription('The total number of vlag PDUs received for unknowns')
vlagStatsPduSentPeerInstanceEnable = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 11, 5, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlagStatsPduSentPeerInstanceEnable.setStatus('current')
if mibBuilder.loadTexts: vlagStatsPduSentPeerInstanceEnable.setDescription('The total number of vlag PDUs sent for peer instance enable')
vlagStatsPduSentPeerInstanceDisable = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 11, 5, 34), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlagStatsPduSentPeerInstanceDisable.setStatus('current')
if mibBuilder.loadTexts: vlagStatsPduSentPeerInstanceDisable.setDescription('The total number of vlag PDUs sent for peer instance disable')
vlagStatsPduSentISLHello = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 11, 5, 35), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlagStatsPduSentISLHello.setStatus('current')
if mibBuilder.loadTexts: vlagStatsPduSentISLHello.setDescription('The total number of vlag PDUs sent for ISL hello')
vlagStatsPduRcvISLHello = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 11, 5, 36), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlagStatsPduRcvISLHello.setStatus('current')
if mibBuilder.loadTexts: vlagStatsPduRcvISLHello.setDescription('The total number of vlag PDUs received for ISL hello')
vlagStatsPduRcvPeerInstanceEnable = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 11, 5, 37), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlagStatsPduRcvPeerInstanceEnable.setStatus('current')
if mibBuilder.loadTexts: vlagStatsPduRcvPeerInstanceEnable.setDescription('The total number of vlag PDUs received for peer instance enable')
vlagStatsPduRcvPeerInstanceDisable = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 11, 5, 38), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlagStatsPduRcvPeerInstanceDisable.setStatus('current')
if mibBuilder.loadTexts: vlagStatsPduRcvPeerInstanceDisable.setDescription('The total number of vlag PDUs received for peer instance disable')
vlagStatsIgmpReportsForwarded = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 11, 6, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlagStatsIgmpReportsForwarded.setStatus('current')
if mibBuilder.loadTexts: vlagStatsIgmpReportsForwarded.setDescription('The total number of IGMP reports forwarded to the peer')
vlagStatsIgmpLeavesForwarded = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 2, 11, 6, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlagStatsIgmpLeavesForwarded.setStatus('current')
if mibBuilder.loadTexts: vlagStatsIgmpLeavesForwarded.setDescription('The total number of IGMP leaves forwarded to the peer')
ecpCurCfgRetrans = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 19, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ecpCurCfgRetrans.setStatus('current')
if mibBuilder.loadTexts: ecpCurCfgRetrans.setDescription('The ECP retransmission interval in millisecond')
ecpNewCfgRetrans = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 1, 19, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(100, 9000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ecpNewCfgRetrans.setStatus('current')
if mibBuilder.loadTexts: ecpNewCfgRetrans.setDescription('The ECP retransmission interval in millisecond')
ecpChnlInfoTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 17, 1), )
if mibBuilder.loadTexts: ecpChnlInfoTable.setStatus('current')
if mibBuilder.loadTexts: ecpChnlInfoTable.setDescription('The table of ECP channel Info.')
ecpChnlInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 17, 1, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ecpChnlInfoEntryIndex"))
if mibBuilder.loadTexts: ecpChnlInfoEntry.setStatus('current')
if mibBuilder.loadTexts: ecpChnlInfoEntry.setDescription('Information about ECP channel.')
ecpChnlInfoEntryIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 17, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ecpChnlInfoEntryIndex.setStatus('current')
if mibBuilder.loadTexts: ecpChnlInfoEntryIndex.setDescription('The index of the ecp chnl info table.')
ecpChnlPort = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 17, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ecpChnlPort.setStatus('current')
if mibBuilder.loadTexts: ecpChnlPort.setDescription('The ecp chanl port info.')
ecpChnlStag = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 17, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ecpChnlStag.setStatus('current')
if mibBuilder.loadTexts: ecpChnlStag.setDescription('The ecp chanl stag info.')
ecpChnlSndlen = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 17, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ecpChnlSndlen.setStatus('current')
if mibBuilder.loadTexts: ecpChnlSndlen.setDescription('The ecp chanl send length info.')
ecpChnlSndnxt = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 17, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ecpChnlSndnxt.setStatus('current')
if mibBuilder.loadTexts: ecpChnlSndnxt.setDescription('The ecp chanl send next info.')
ecpChnlRcvlast = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 17, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ecpChnlRcvlast.setStatus('current')
if mibBuilder.loadTexts: ecpChnlRcvlast.setDescription('The ecp chanl recv last sequence info.')
ecpChnlStateMachine = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 17, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ecpChnlStateMachine.setStatus('current')
if mibBuilder.loadTexts: ecpChnlStateMachine.setDescription('The ecp chanl state machineinfo.')
ecpChnlRxCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 17, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ecpChnlRxCnt.setStatus('current')
if mibBuilder.loadTexts: ecpChnlRxCnt.setDescription('The ecp chanl Rx count info.')
ecpChnlTxCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 17, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ecpChnlTxCnt.setStatus('current')
if mibBuilder.loadTexts: ecpChnlTxCnt.setDescription('The ecp chanl Tx count info.')
ecpChnlRxDrop = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 17, 1, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ecpChnlRxDrop.setStatus('current')
if mibBuilder.loadTexts: ecpChnlRxDrop.setDescription('The ecp chanl RxDrop info.')
ecpChnlTxDrop = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 17, 1, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ecpChnlTxDrop.setStatus('current')
if mibBuilder.loadTexts: ecpChnlTxDrop.setDescription('The ecp chanl TxDrop info.')
ecpChnlState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 17, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 0))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 0)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ecpChnlState.setStatus('current')
if mibBuilder.loadTexts: ecpChnlState.setDescription('The ecp chanl state info.')
ecpChnlAckErr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 2, 3, 17, 1, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ecpChnlAckErr.setStatus('current')
if mibBuilder.loadTexts: ecpChnlAckErr.setDescription('The ecp chanl ACK error info.')
layer3 = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3))
layer3Configs = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1))
layer3Stats = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2))
layer3Info = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3))
layer3Oper = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 4))
ipInterfaceCfg = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 1))
ipInterfaceLoopbackCfg = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 24))
ipGatewayCfg = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 2))
ipStaticRouteCfg = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 3))
ipForwardCfg = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 4))
vrrpCfg = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6))
arpCfg = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 7))
ipBootpCfg = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 8))
dnsCfg = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 9))
ipNwfCfg = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 10))
ipRmapCfg = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 11))
bgpCfg = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12))
ospfCfg = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13))
ipGeneralCfg = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 14))
ipStaticArpCfg = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 15))
rip2Cfg = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 18))
igmpCfg = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19))
ipStaticNbrCfg = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 21))
ipGatewayIpv6Cfg = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 22))
ipStaticRoute6Cfg = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 23))
ospf3Cfg = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26))
pptCfg = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 27))
ipv6pmtuCfg = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 28))
mldCfg = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 30))
ndprefixCfg = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 31))
dhcpsnpCfg = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 33))
ipsecCfg = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32))
arpStats = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 2))
routeStats = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 3))
dnsStats = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 4))
vrrpStats = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 5))
ospfStats = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6))
clearStats = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 7))
igmpStats = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 9))
ipv6Stats = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 10))
rip2Stats = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 13))
ipStats = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 16))
icmpStats = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 17))
tcpStats = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 18))
udpStats = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 19))
bootpStats = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 20))
ospf3Stats = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22))
mldStats = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 23))
ipsecStats = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 24))
dhcpsnpStats = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 25))
ipRoutingInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 1))
ipEcmpRoutingInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 19))
ipEcmpHash = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 20))
ipv6PmtuInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 21))
arpInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 2))
vrrpInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 3))
ospfinfo = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4))
gatewayInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 5))
igmpInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 6))
nbrInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 12))
gatewayIPv6Info = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 13))
ipRoute6Info = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 14))
ipInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 8))
ipIntfInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 9))
ipIntfLoopbackInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 16))
rip2Info = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 10))
bgpInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 11))
dhcpInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 15))
ospf3Info = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18))
mldInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 22))
ipsecInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 23))
dhcpsnpInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 24))
dhcpSnoopingCurCfgOnState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 33, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpSnoopingCurCfgOnState.setStatus('current')
if mibBuilder.loadTexts: dhcpSnoopingCurCfgOnState.setDescription('DHCP Snooping ON/OFF settings.')
dhcpSnoopingNewCfgOnState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 33, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpSnoopingNewCfgOnState.setStatus('current')
if mibBuilder.loadTexts: dhcpSnoopingNewCfgOnState.setDescription('DHCP Snooping ON/OFF setting.')
dhcpSnoopingCurCfgOption82OnState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 33, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpSnoopingCurCfgOption82OnState.setStatus('current')
if mibBuilder.loadTexts: dhcpSnoopingCurCfgOption82OnState.setDescription('on/off state of DHCP Snooping option82.')
dhcpSnoopingNewCfgOption82OnState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 33, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpSnoopingNewCfgOption82OnState.setStatus('current')
if mibBuilder.loadTexts: dhcpSnoopingNewCfgOption82OnState.setDescription('Enable/Disable DHCP Snooping option82')
dhcpSnoopingCurCfgPortTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 33, 5), )
if mibBuilder.loadTexts: dhcpSnoopingCurCfgPortTable.setStatus('current')
if mibBuilder.loadTexts: dhcpSnoopingCurCfgPortTable.setDescription('DHCP Snooping Port Configuration Table.')
dhcpSnoopingCurCfgPortTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 33, 5, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "dhcpSnoopingCurCfgPortId"))
if mibBuilder.loadTexts: dhcpSnoopingCurCfgPortTableEntry.setStatus('current')
if mibBuilder.loadTexts: dhcpSnoopingCurCfgPortTableEntry.setDescription('A row in DHCP Snooping Port Configuration Table')
dhcpSnoopingCurCfgPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 33, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpSnoopingCurCfgPortId.setStatus('current')
if mibBuilder.loadTexts: dhcpSnoopingCurCfgPortId.setDescription('Port ID of this DHCP Snooping port configration.')
dhcpSnoopingCurCfgPortTrusted = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 33, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("trusted", 1), ("untrusted", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpSnoopingCurCfgPortTrusted.setStatus('current')
if mibBuilder.loadTexts: dhcpSnoopingCurCfgPortTrusted.setDescription('Set port as trusted or untrusted port.')
dhcpSnoopingCurCfgPortRateLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 33, 5, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpSnoopingCurCfgPortRateLimit.setStatus('current')
if mibBuilder.loadTexts: dhcpSnoopingCurCfgPortRateLimit.setDescription('Set port DHCP packet rate limit(pps). Its ranges is 0 ~ 2048, set 0 to disable rate limit.')
dhcpSnoopingNewCfgPortTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 33, 6), )
if mibBuilder.loadTexts: dhcpSnoopingNewCfgPortTable.setStatus('current')
if mibBuilder.loadTexts: dhcpSnoopingNewCfgPortTable.setDescription('DHCP Snooping Port Configuration Table.')
dhcpSnoopingNewCfgPortTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 33, 6, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "dhcpSnoopingNewCfgportId"))
if mibBuilder.loadTexts: dhcpSnoopingNewCfgPortTableEntry.setStatus('current')
if mibBuilder.loadTexts: dhcpSnoopingNewCfgPortTableEntry.setDescription('A row in the DHCP Snooping Port Configuration Table')
dhcpSnoopingNewCfgportId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 33, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpSnoopingNewCfgportId.setStatus('current')
if mibBuilder.loadTexts: dhcpSnoopingNewCfgportId.setDescription('Port ID of this DHCP Snooping port configration.')
dhcpSnoopingNewCfgportTrusted = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 33, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("trusted", 1), ("untrusted", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpSnoopingNewCfgportTrusted.setStatus('current')
if mibBuilder.loadTexts: dhcpSnoopingNewCfgportTrusted.setDescription('Set port as trusted or untrusted port.')
dhcpSnoopingNewCfgportRateLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 33, 6, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpSnoopingNewCfgportRateLimit.setStatus('current')
if mibBuilder.loadTexts: dhcpSnoopingNewCfgportRateLimit.setDescription('Set port DHCP packet rate limit(pps). Set 0 to disable rate limit.')
dhcpSnoopingCurCfgVlanTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 33, 7), )
if mibBuilder.loadTexts: dhcpSnoopingCurCfgVlanTable.setStatus('current')
if mibBuilder.loadTexts: dhcpSnoopingCurCfgVlanTable.setDescription('DHCP Snooping VLAN Table.')
dhcpSnoopingCurCfgVlanTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 33, 7, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "dhcpSnoopingCurCfgVlanId"))
if mibBuilder.loadTexts: dhcpSnoopingCurCfgVlanTableEntry.setStatus('current')
if mibBuilder.loadTexts: dhcpSnoopingCurCfgVlanTableEntry.setDescription('A row in the DHCP Snooping VLAN Table')
dhcpSnoopingCurCfgVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 33, 7, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4094))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpSnoopingCurCfgVlanId.setStatus('current')
if mibBuilder.loadTexts: dhcpSnoopingCurCfgVlanId.setDescription('VLAN ID of this DHCP Snooping VLAN configration.')
dhcpSnoopingCurCfgVlanOnState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 33, 7, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpSnoopingCurCfgVlanOnState.setStatus('current')
if mibBuilder.loadTexts: dhcpSnoopingCurCfgVlanOnState.setDescription('on/off state of DHCP Snooping on this VLAN.')
dhcpSnoopingNewCfgVlanTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 33, 8), )
if mibBuilder.loadTexts: dhcpSnoopingNewCfgVlanTable.setStatus('current')
if mibBuilder.loadTexts: dhcpSnoopingNewCfgVlanTable.setDescription('DHCP Snooping VLAN Table.')
dhcpSnoopingNewCfgVlanTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 33, 8, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "dhcpSnoopingNewCfgVlanId"))
if mibBuilder.loadTexts: dhcpSnoopingNewCfgVlanTableEntry.setStatus('current')
if mibBuilder.loadTexts: dhcpSnoopingNewCfgVlanTableEntry.setDescription('A row in the DHCP Snooping VLAN Table')
dhcpSnoopingNewCfgVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 33, 8, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4094))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpSnoopingNewCfgVlanId.setStatus('current')
if mibBuilder.loadTexts: dhcpSnoopingNewCfgVlanId.setDescription('VLAN ID of this DHCP Snooping VLAN configration.')
dhcpSnoopingNewCfgVlanOnState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 33, 8, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpSnoopingNewCfgVlanOnState.setStatus('current')
if mibBuilder.loadTexts: dhcpSnoopingNewCfgVlanOnState.setDescription('Enable/Disable DHCP Snooping on this VLAN.')
dhcpSnoopingBindingInfoTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 24, 1), )
if mibBuilder.loadTexts: dhcpSnoopingBindingInfoTable.setStatus('current')
if mibBuilder.loadTexts: dhcpSnoopingBindingInfoTable.setDescription('DHCP Snooping binding Table.')
dhcpSnoopingBindingInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 24, 1, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "dhcpSnoopingBindingInfoIndex"))
if mibBuilder.loadTexts: dhcpSnoopingBindingInfoEntry.setStatus('current')
if mibBuilder.loadTexts: dhcpSnoopingBindingInfoEntry.setDescription('A row in the DHCP Snooping binding Table')
dhcpSnoopingBindingInfoIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 24, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpSnoopingBindingInfoIndex.setStatus('current')
if mibBuilder.loadTexts: dhcpSnoopingBindingInfoIndex.setDescription('Index of this DHCP Snooping binding entry.')
dhcpSnoopingBindingInfoMac = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 24, 1, 1, 2), OctetString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dhcpSnoopingBindingInfoMac.setStatus('current')
if mibBuilder.loadTexts: dhcpSnoopingBindingInfoMac.setDescription('Mac Address of this DHCP Snooping binding entry.')
dhcpSnoopingBindingInfoIp = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 24, 1, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpSnoopingBindingInfoIp.setStatus('current')
if mibBuilder.loadTexts: dhcpSnoopingBindingInfoIp.setDescription('Ip Address of this DHCP Snooping binding entry.')
dhcpSnoopingBindingInfoVLAN = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 24, 1, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpSnoopingBindingInfoVLAN.setStatus('current')
if mibBuilder.loadTexts: dhcpSnoopingBindingInfoVLAN.setDescription('VLAN ID of this DHCP Snooping binding entry.')
dhcpSnoopingBindingInfoPort = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 24, 1, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpSnoopingBindingInfoPort.setStatus('current')
if mibBuilder.loadTexts: dhcpSnoopingBindingInfoPort.setDescription('Port Number of this DHCP Snooping binding entry.')
dhcpSnoopingBindingInfoExpiry = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 24, 1, 1, 6), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpSnoopingBindingInfoExpiry.setStatus('current')
if mibBuilder.loadTexts: dhcpSnoopingBindingInfoExpiry.setDescription('The lease time of this DHCP Snooping binding entry. Set 0 to remove this entry')
dhcpSnoopingBindingInfoType = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 24, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("static", 1), ("dynamic", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpSnoopingBindingInfoType.setStatus('current')
if mibBuilder.loadTexts: dhcpSnoopingBindingInfoType.setDescription('Show How this DHCP Snooping binding entry come from.')
dhcpSnoopingStatInPacketRequest = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 25, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpSnoopingStatInPacketRequest.setStatus('current')
if mibBuilder.loadTexts: dhcpSnoopingStatInPacketRequest.setDescription('Counter of DHCP REQUEST messages received.')
dhcpSnoopingStatInPacketReply = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 25, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpSnoopingStatInPacketReply.setStatus('current')
if mibBuilder.loadTexts: dhcpSnoopingStatInPacketReply.setDescription('Counter of DHCP REPLY messages received.')
dhcpSnoopingStatDroppedPacketInvalid = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 25, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpSnoopingStatDroppedPacketInvalid.setStatus('current')
if mibBuilder.loadTexts: dhcpSnoopingStatDroppedPacketInvalid.setDescription('Counter of dropped DHCP messages due to invalid packet.')
dhcpSnoopingStatDroppedPacketRateLimit = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 25, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpSnoopingStatDroppedPacketRateLimit.setStatus('current')
if mibBuilder.loadTexts: dhcpSnoopingStatDroppedPacketRateLimit.setDescription('Counter of dropped DHCP messages due to Rate Limit in software.')
dhcpSnoopingStatDroppedPacketOther = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 25, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpSnoopingStatDroppedPacketOther.setStatus('current')
if mibBuilder.loadTexts: dhcpSnoopingStatDroppedPacketOther.setDescription('Counter of dropped DHCP messages due to other reason.')
vrrpOper = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 4, 1))
dhcpInfoMacAddr = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 15, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpInfoMacAddr.setStatus('current')
if mibBuilder.loadTexts: dhcpInfoMacAddr.setDescription('The MAC address of the interface.')
dhcpInfoAddr = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 15, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpInfoAddr.setStatus('current')
if mibBuilder.loadTexts: dhcpInfoAddr.setDescription('The IP address of the interface.')
dhcpInfoSubnetMask = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 15, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpInfoSubnetMask.setStatus('current')
if mibBuilder.loadTexts: dhcpInfoSubnetMask.setDescription('The subnet mask of the interface.')
dhcpInfoDefaultGateway = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 15, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpInfoDefaultGateway.setStatus('current')
if mibBuilder.loadTexts: dhcpInfoDefaultGateway.setDescription('The IP address of default gateway for the interface.')
dhcpInfoServer = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 15, 5), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpInfoServer.setStatus('current')
if mibBuilder.loadTexts: dhcpInfoServer.setDescription('The IP address of the DHCP server that leased the ip of the interface.')
dhcpInfoLeaseObtained = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 15, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpInfoLeaseObtained.setStatus('current')
if mibBuilder.loadTexts: dhcpInfoLeaseObtained.setDescription('The time and date when the lease was obtained .')
dhcpInfoLeaseExpires = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 15, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpInfoLeaseExpires.setStatus('current')
if mibBuilder.loadTexts: dhcpInfoLeaseExpires.setDescription('The time and date when the lease was obtained .')
ipInterfaceTableMax = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipInterfaceTableMax.setStatus('current')
if mibBuilder.loadTexts: ipInterfaceTableMax.setDescription('The maximum number of rows in the IP interface table.')
ipCurCfgIntfTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 1, 2), )
if mibBuilder.loadTexts: ipCurCfgIntfTable.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgIntfTable.setDescription('The table of IP interface configuration.')
ipCurCfgIntfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 1, 2, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ipCurCfgIntfIndex"))
if mibBuilder.loadTexts: ipCurCfgIntfEntry.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgIntfEntry.setDescription('A row in the Ip interface table')
ipCurCfgIntfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 1, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgIntfIndex.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgIntfIndex.setDescription('The interface number for which the IP information is related.')
ipCurCfgIntfAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 1, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgIntfAddr.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgIntfAddr.setDescription('This field configures the new IP/IPv6 addr of the interface. Address should be IPv4 dotted-quads or IPv6 16-byte hexadecimal colon notation. Valid IPv6 address should be in any of the following forms xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx or xxxx::xxxx:xxxx:xxxx:xxxx')
ipCurCfgIntfMask = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 1, 2, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgIntfMask.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgIntfMask.setDescription('The subnet mask as IPv4 dotted-quads OR the IPv6 prefix length (integer in range 0..128) associated with this IP address .')
ipCurCfgIntfBroadcast = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 1, 2, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgIntfBroadcast.setStatus('obsolete')
if mibBuilder.loadTexts: ipCurCfgIntfBroadcast.setDescription('The broadcast address of the interface.')
ipCurCfgIntfVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 1, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgIntfVlan.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgIntfVlan.setDescription('The VLAN associated with the interface.')
ipCurCfgIntfState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 1, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("enabled", 2), ("disabled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgIntfState.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgIntfState.setDescription('The state of the interface.')
ipCurCfgIntfBootpRelay = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 1, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgIntfBootpRelay.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgIntfBootpRelay.setDescription('Enable/disable BOOTP relay.')
ipCurCfgIntfRouteAdv = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 1, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgIntfRouteAdv.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgIntfRouteAdv.setDescription('Enable/disable route advertisement of the interface.')
ipCurCfgIntfManagedCfg = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 1, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgIntfManagedCfg.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgIntfManagedCfg.setDescription('Enable/disable Managed config flag of the interface, which allows the host to use DHCP for address configuration.')
ipCurCfgIntfOtherCfg = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 1, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgIntfOtherCfg.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgIntfOtherCfg.setDescription('Enable/disable Other config flag of the interface, which allows the host to use DHCP for other stateful configuration.')
ipCurCfgIntfAdvLifetime = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 1, 2, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 9000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgIntfAdvLifetime.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgIntfAdvLifetime.setDescription('Set Router Advertisement lifetime of the interface.')
ipCurCfgIntfDadAttempts = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 1, 2, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgIntfDadAttempts.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgIntfDadAttempts.setDescription('Set the number of duplicate address detection (dad) attempts of the interface.')
ipCurCfgIntfReachTime = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 1, 2, 1, 17), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 3600000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgIntfReachTime.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgIntfReachTime.setDescription('Set the advertised reachability time of the interface in ms.')
ipCurCfgIntfAdvInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 1, 2, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(4, 1800))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgIntfAdvInterval.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgIntfAdvInterval.setDescription('Set the IPv6 Router Advertisement interval of the interface.')
ipCurCfgIntfAdvIntervalMin = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 1, 2, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(3, 1350))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgIntfAdvIntervalMin.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgIntfAdvIntervalMin.setDescription('Set the IPv6 Router Advertisement Minimum interval limit of the interface.')
ipCurCfgIntfRetransmitTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 1, 2, 1, 20), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgIntfRetransmitTimer.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgIntfRetransmitTimer.setDescription('Set the IPv6 Router Advertisement Retransmit Timer in ms.')
ipCurCfgIntfHopLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 1, 2, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgIntfHopLimit.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgIntfHopLimit.setDescription('Set the IPv6 Router Advertisement Current Hop Limit')
ipCurCfgIntfAdvMtu = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 1, 2, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgIntfAdvMtu.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgIntfAdvMtu.setDescription('Enable/disable Advertise MTU option.')
ipCurCfgIntfIp6Host = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 1, 2, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgIntfIp6Host.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgIntfIp6Host.setDescription('Enable/disable IPv6 host mode on the interface.')
ipCurCfgSecIntfAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 1, 2, 1, 25), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgSecIntfAddr.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgSecIntfAddr.setDescription('This field configures the new IP/IPv6 addr of the interface. Address should be in IPv6 4-byte haxadecimal colon notation. Valid IPv6 address should be in any of the following forms xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx or xxxx::xxxx:xxxx:xxxx:xxxx')
ipCurCfgSecIntfPrefix = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 1, 2, 1, 26), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgSecIntfPrefix.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgSecIntfPrefix.setDescription('The IPv6 prefix length (integer in range 0..128) associated with this IP address .')
ipCurCfgIntfAnycast = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 1, 2, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("anycast", 1), ("none", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgIntfAnycast.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgIntfAnycast.setDescription('This field has the value of anycast(1) if IPv6 interface address is anycast and none(2) if not.')
ipCurCfgSecIntfAnycast = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 1, 2, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("anycast", 1), ("none", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgSecIntfAnycast.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgSecIntfAnycast.setDescription('This field has the value of anycast(1) if secondary IPv6 interface address is anycast and none(2) if not.')
ipCurCfgIntfIp6Dstun = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 1, 2, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgIntfIp6Dstun.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgIntfIp6Dstun.setDescription('Enable/disable sending of ICMP Unreachable messages.')
ipNewCfgIntfTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 1, 3), )
if mibBuilder.loadTexts: ipNewCfgIntfTable.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgIntfTable.setDescription('The table of interface in the new configuration block.')
ipNewCfgIntfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 1, 3, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ipNewCfgIntfIndex"))
if mibBuilder.loadTexts: ipNewCfgIntfEntry.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgIntfEntry.setDescription('A row in the Ip interface table')
ipNewCfgIntfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 1, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipNewCfgIntfIndex.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgIntfIndex.setDescription('The interface number for which the IP information is related.')
ipNewCfgIntfAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 1, 3, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgIntfAddr.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgIntfAddr.setDescription('This field configures the new IP/IPv6 addr of the interface. Address should be IPv4 dotted-quads or IPv6 16-byte hexadecimal colon notation. Valid IPv6 address should be in any of the following forms xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx or xxxx::xxxx:xxxx:xxxx:xxxx')
ipNewCfgIntfMask = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 1, 3, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgIntfMask.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgIntfMask.setDescription('The subnet mask as IPv4 dotted-quads OR the IPv6 prefix length (integer in range 0..128) associated with this IP address .')
ipNewCfgIntfVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 1, 3, 1, 5), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgIntfVlan.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgIntfVlan.setDescription('The VLAN associated with the interface.')
ipNewCfgIntfState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 1, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("enabled", 2), ("disabled", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgIntfState.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgIntfState.setDescription('The state of the interface.')
ipNewCfgIntfDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 1, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("delete", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgIntfDelete.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgIntfDelete.setDescription('When set to the value of 2 (delete), the entire row is deleted. When read, other(1) is returned. Setting the value to anything other than 2(delete) has no effect on the state of the row.')
ipNewCfgIntfBootpRelay = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 1, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgIntfBootpRelay.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgIntfBootpRelay.setDescription('Enable/disable BOOTP relay.')
ipNewCfgIntfRouteAdv = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 1, 3, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgIntfRouteAdv.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgIntfRouteAdv.setDescription('Enable/disable route advertisement of the interface.')
ipNewCfgIntfManagedCfg = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 1, 3, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgIntfManagedCfg.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgIntfManagedCfg.setDescription('Enable/disable Managed config flag of the interface, which allows the host to use DHCP for address configuration.')
ipNewCfgIntfOtherCfg = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 1, 3, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgIntfOtherCfg.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgIntfOtherCfg.setDescription('Enable/disable Other config flag of the interface, which allows the host to use DHCP for other stateful configuration.')
ipNewCfgIntfAdvLifetime = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 1, 3, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 9000))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgIntfAdvLifetime.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgIntfAdvLifetime.setDescription('Set Router Advertisement lifetime of the interface.')
ipNewCfgIntfDadAttempts = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 1, 3, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgIntfDadAttempts.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgIntfDadAttempts.setDescription('Set the number of duplicate address detection (dad) attempts of the interface.')
ipNewCfgIntfReachTime = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 1, 3, 1, 18), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 3600000))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgIntfReachTime.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgIntfReachTime.setDescription('Set the advertised reachability time of the interface in ms.')
ipNewCfgIntfAdvInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 1, 3, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(4, 1800))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgIntfAdvInterval.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgIntfAdvInterval.setDescription('Set the IPv6 Router Advertisement interval of the interface.')
ipNewCfgIntfAdvIntervalMin = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 1, 3, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(3, 1350))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgIntfAdvIntervalMin.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgIntfAdvIntervalMin.setDescription('Set the IPv6 Router Advertisement Minimum interval limit of the interface.')
ipNewCfgIntfRetransmitTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 1, 3, 1, 21), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgIntfRetransmitTimer.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgIntfRetransmitTimer.setDescription('Set the IPv6 Router Advertisement Retransmit Timer in ms.')
ipNewCfgIntfHopLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 1, 3, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgIntfHopLimit.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgIntfHopLimit.setDescription('Set the IPv6 Router Advertisement Current Hop Limit')
ipNewCfgIntfAdvMtu = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 1, 3, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgIntfAdvMtu.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgIntfAdvMtu.setDescription('Enable/disable Advertise MTU option.')
ipNewCfgIntfIp6Host = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 1, 3, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgIntfIp6Host.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgIntfIp6Host.setDescription('Enable/disable IPv6 host mode on the interface.')
ipNewCfgSecIntfAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 1, 3, 1, 26), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipNewCfgSecIntfAddr.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgSecIntfAddr.setDescription('This field configures the new IPv6 addr of the interface. Address should be in IPv6 4-byte haxadecimal colon notation. Valid IPv6 address should be in any of the following forms xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx or xxxx::xxxx:xxxx:xxxx:xxxx')
ipNewCfgSecIntfPrefix = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 1, 3, 1, 27), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipNewCfgSecIntfPrefix.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgSecIntfPrefix.setDescription('The IPv6 prefix length (integer in range 0..128) associated with this IP address .')
ipNewCfgIntfAnycast = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 1, 3, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("anycast", 1), ("none", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipNewCfgIntfAnycast.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgIntfAnycast.setDescription('This field has the value of anycast(1) if IPv6 interface address is anycast and none(2) if not.')
ipNewCfgSecIntfAnycast = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 1, 3, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("anycast", 1), ("none", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipNewCfgSecIntfAnycast.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgSecIntfAnycast.setDescription('This field has the value of anycast(1) if secondary IPv6 interface address is anycast and none(2) if not.')
ipNewCfgIntfIp6Dstun = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 1, 3, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgIntfIp6Dstun.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgIntfIp6Dstun.setDescription('Enable/disable sending of ICMP Unreachable messages.')
ipInterfaceLoopbackTableMax = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 24, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipInterfaceLoopbackTableMax.setStatus('current')
if mibBuilder.loadTexts: ipInterfaceLoopbackTableMax.setDescription('The maximum number of rows in the IP Loopback interface table.')
ipCurCfgIntfLoopbackTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 24, 2), )
if mibBuilder.loadTexts: ipCurCfgIntfLoopbackTable.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgIntfLoopbackTable.setDescription('The table of IP Loopback interface configuration.')
ipCurCfgIntfLoopbackEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 24, 2, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ipCurCfgIntfLoopbackIndex"))
if mibBuilder.loadTexts: ipCurCfgIntfLoopbackEntry.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgIntfLoopbackEntry.setDescription('A row in the Ip Loopback interface table')
ipCurCfgIntfLoopbackIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 24, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgIntfLoopbackIndex.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgIntfLoopbackIndex.setDescription('The Loopback interface number for which the IP information is related.')
ipCurCfgIntfLoopbackAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 24, 2, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgIntfLoopbackAddr.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgIntfLoopbackAddr.setDescription('The IP address of the interface.')
ipCurCfgIntfLoopbackMask = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 24, 2, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgIntfLoopbackMask.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgIntfLoopbackMask.setDescription('The subnet mask of the interface.')
ipCurCfgIntfLoopbackBroadcast = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 24, 2, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgIntfLoopbackBroadcast.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgIntfLoopbackBroadcast.setDescription('The broadcast address of the interface.')
ipCurCfgIntfLoopbackState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 24, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("enabled", 2), ("disabled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgIntfLoopbackState.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgIntfLoopbackState.setDescription('The state of the interface.')
ipNewCfgIntfLoopbackTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 24, 3), )
if mibBuilder.loadTexts: ipNewCfgIntfLoopbackTable.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgIntfLoopbackTable.setDescription('The table of loopback interface in the new configuration block.')
ipNewCfgIntfLoopbackEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 24, 3, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ipNewCfgIntfLoopbackIndex"))
if mibBuilder.loadTexts: ipNewCfgIntfLoopbackEntry.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgIntfLoopbackEntry.setDescription('A row in the Ip Loopback interface table')
ipNewCfgIntfLoopbackIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 24, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipNewCfgIntfLoopbackIndex.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgIntfLoopbackIndex.setDescription('The Loopback interface number for which the IP information is related.')
ipNewCfgIntfLoopbackAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 24, 3, 1, 2), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgIntfLoopbackAddr.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgIntfLoopbackAddr.setDescription('The IP address of the interface.')
ipNewCfgIntfLoopbackMask = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 24, 3, 1, 3), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgIntfLoopbackMask.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgIntfLoopbackMask.setDescription('The subnet mask of the interface.')
ipNewCfgIntfLoopbackState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 24, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("enabled", 2), ("disabled", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgIntfLoopbackState.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgIntfLoopbackState.setDescription('The state of the interface.')
ipNewCfgIntfLoopbackDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 24, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("delete", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgIntfLoopbackDelete.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgIntfLoopbackDelete.setDescription('When set to the value of 2 (delete), the entire row is deleted. When read, other(1) is returned. Setting the value to anything other than 2(delete) has no effect on the state of the row.')
ipGatewayTableMax = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 2, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipGatewayTableMax.setStatus('current')
if mibBuilder.loadTexts: ipGatewayTableMax.setDescription('The maximum number of rows in the IP gateway table.')
ipCurCfgGwTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 2, 4), )
if mibBuilder.loadTexts: ipCurCfgGwTable.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgGwTable.setDescription('The table of gateways in the current configuration block.')
ipCurCfgGwEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 2, 4, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ipCurCfgGwIndex"))
if mibBuilder.loadTexts: ipCurCfgGwEntry.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgGwEntry.setDescription('A row in the Ip gateway table')
ipCurCfgGwIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 2, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgGwIndex.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgGwIndex.setDescription('The gateway number for which the information is related.')
ipCurCfgGwAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 2, 4, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgGwAddr.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgGwAddr.setDescription('The IP address of the default gateway.')
ipCurCfgGwInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 2, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgGwInterval.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgGwInterval.setDescription('The interval between ping attempts.')
ipCurCfgGwRetry = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 2, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 120))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgGwRetry.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgGwRetry.setDescription('The number of failed attempts to declare the default gateway DOWN.')
ipCurCfgGwState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 2, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("enabled", 2), ("disabled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgGwState.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgGwState.setDescription('The state of the default gateway.')
ipCurCfgGwArp = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 2, 4, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("enabled", 2), ("disabled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgGwArp.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgGwArp.setDescription('The state of ARP only health checks.')
ipNewCfgGwTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 2, 5), )
if mibBuilder.loadTexts: ipNewCfgGwTable.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgGwTable.setDescription('The table of gateway in the new configuration block.')
ipNewCfgGwEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 2, 5, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ipNewCfgGwIndex"))
if mibBuilder.loadTexts: ipNewCfgGwEntry.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgGwEntry.setDescription('A row in the Ip default gateway table')
ipNewCfgGwIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 2, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipNewCfgGwIndex.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgGwIndex.setDescription('The gateway number for which the information is related.')
ipNewCfgGwAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 2, 5, 1, 2), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgGwAddr.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgGwAddr.setDescription('The IP address of the default gateway.')
ipNewCfgGwInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 2, 5, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgGwInterval.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgGwInterval.setDescription('The interval in seconds between ping attempts.')
ipNewCfgGwRetry = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 2, 5, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 120))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgGwRetry.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgGwRetry.setDescription('The number of failed attempts to declare the default gateway DOWN.')
ipNewCfgGwState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 2, 5, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("enabled", 2), ("disabled", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgGwState.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgGwState.setDescription('The state of the default gateway.')
ipNewCfgGwDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 2, 5, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("delete", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgGwDelete.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgGwDelete.setDescription('When set to the value of 2 (delete), the entire row is deleted. When read, other is returned. Setting the value to anything other than 2(delete) has no effect on the state of the row.')
ipNewCfgGwArp = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 2, 5, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("enabled", 2), ("disabled", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgGwArp.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgGwArp.setDescription('The state of the ARP only health checks.')
ipStaticRouteTableMaxSize = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 3, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipStaticRouteTableMaxSize.setStatus('current')
if mibBuilder.loadTexts: ipStaticRouteTableMaxSize.setDescription('The maximum number of rows in the Static Route table.')
ipCurCfgStaticRouteTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 3, 2), )
if mibBuilder.loadTexts: ipCurCfgStaticRouteTable.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgStaticRouteTable.setDescription('The table of static routes in the current configuration block.')
ipCurCfgStaticRouteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 3, 2, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ipCurCfgStaticRouteIndx"))
if mibBuilder.loadTexts: ipCurCfgStaticRouteEntry.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgStaticRouteEntry.setDescription('A row in the static IP route table')
ipCurCfgStaticRouteIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 3, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgStaticRouteIndx.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgStaticRouteIndx.setDescription('The index of the static routing table.')
ipCurCfgStaticRouteDestIp = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 3, 2, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgStaticRouteDestIp.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgStaticRouteDestIp.setDescription('The destination IP address of this route.')
ipCurCfgStaticRouteMask = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 3, 2, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgStaticRouteMask.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgStaticRouteMask.setDescription('The current subnet mask of this route.')
ipCurCfgStaticRouteGateway = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 3, 2, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgStaticRouteGateway.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgStaticRouteGateway.setDescription('The current gateway of this route.')
ipCurCfgStaticRouteInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 3, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgStaticRouteInterface.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgStaticRouteInterface.setDescription('The IP interface of this route. The IP address of the specified interface shall be use as source IP when performs routing.')
ipNewCfgStaticRouteTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 3, 3), )
if mibBuilder.loadTexts: ipNewCfgStaticRouteTable.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgStaticRouteTable.setDescription('The table of static routes in the new configuration block.')
ipStaticRouteClearAllByDestIp = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 3, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipStaticRouteClearAllByDestIp.setStatus('current')
if mibBuilder.loadTexts: ipStaticRouteClearAllByDestIp.setDescription('Clears all static routes with the specified destination IP address.')
ipStaticRouteClearAllByGatewayIp = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 3, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipStaticRouteClearAllByGatewayIp.setStatus('current')
if mibBuilder.loadTexts: ipStaticRouteClearAllByGatewayIp.setDescription('Clears all static routes with the specified gateway IP address.')
ipStaticRouteClearAllByInterface = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 3, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipStaticRouteClearAllByInterface.setStatus('current')
if mibBuilder.loadTexts: ipStaticRouteClearAllByInterface.setDescription('Clears all routes on the specified inteface number.')
ipStaticRouteClearAll = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 3, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("clear", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipStaticRouteClearAll.setStatus('current')
if mibBuilder.loadTexts: ipStaticRouteClearAll.setDescription('When set to clear(2),clears all static routes. Otherwhise nothing is done.')
ipStaticRouteCurPingInterval = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 3, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipStaticRouteCurPingInterval.setStatus('current')
if mibBuilder.loadTexts: ipStaticRouteCurPingInterval.setDescription('The time between ping retries.')
ipStaticRouteNewPingInterval = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 3, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipStaticRouteNewPingInterval.setStatus('current')
if mibBuilder.loadTexts: ipStaticRouteNewPingInterval.setDescription('The time between ping retries.')
ipStaticRouteCurPingRetries = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 3, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipStaticRouteCurPingRetries.setStatus('current')
if mibBuilder.loadTexts: ipStaticRouteCurPingRetries.setDescription('The number of ping retries.')
ipStaticRouteNewPingRetries = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 3, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipStaticRouteNewPingRetries.setStatus('current')
if mibBuilder.loadTexts: ipStaticRouteNewPingRetries.setDescription('The number of ping retries.')
ipStaticRouteCurEcmpHash = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 3, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipStaticRouteCurEcmpHash.setStatus('current')
if mibBuilder.loadTexts: ipStaticRouteCurEcmpHash.setDescription('Ecmp Hash mechanism.It is a BIT mask which represents the combination of different parameters which can be used for ECMP hashing ECMP_HASH_SIP ------ 0x00000001 - Include Source IP for ECMP hash ECMP_HASH_DIP ------ 0x00000002 - Include destination IP for ECMP hash ECMP_HASH_PROT ------ 0x00000004 - Include layer3 protocol for ECMP hash ECMP_HASH_TCP ------ 0x00000008 - Enable L4 source/destination port hash if protocl is TCP ECMP_HASH_UDP ------ 0x00000010 - Enable L4 source/destination port hash if protocl is UDP ECMP_HASH_L4SRC------ 0x00000020 - Include L4 source port for ECMP hash ECMP_HASH_L4DST------ 0x00000040 - Include L4 destination port for ECMP hash ')
ipStaticRouteNewEcmpHash = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 3, 13), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipStaticRouteNewEcmpHash.setStatus('current')
if mibBuilder.loadTexts: ipStaticRouteNewEcmpHash.setDescription('Ecmp Hash mechanism.It is a BIT mask which represents the combination of different parameters which can be used for ECMP hashing ECMP_HASH_SIP ------ 0x00000001 - Include Source IP for ECMP hash ECMP_HASH_DIP ------ 0x00000002 - Include destination IP for ECMP hash ECMP_HASH_PROT ------ 0x00000004 - Include layer3 protocol for ECMP hash ECMP_HASH_TCP ------ 0x00000008 - Enable L4 source/destination port hash if protocl is TCP ECMP_HASH_UDP ------ 0x00000010 - Enable L4 source/destination port hash if protocl is UDP ECMP_HASH_L4SRC------ 0x00000020 - Include L4 source port for ECMP hash ECMP_HASH_L4DST------ 0x00000040 - Include L4 destination port for ECMP hash ')
ipStaticRouteCurHealthcheck = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 3, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipStaticRouteCurHealthcheck.setStatus('current')
if mibBuilder.loadTexts: ipStaticRouteCurHealthcheck.setDescription('Gateway healthcheck functionality')
ipStaticRouteNewHealthcheck = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 3, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipStaticRouteNewHealthcheck.setStatus('current')
if mibBuilder.loadTexts: ipStaticRouteNewHealthcheck.setDescription('Gateway healthcheck functionality')
ipNewCfgStaticRouteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 3, 3, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ipNewCfgStaticRouteIndx"))
if mibBuilder.loadTexts: ipNewCfgStaticRouteEntry.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgStaticRouteEntry.setDescription('A row in the static IP route table')
ipNewCfgStaticRouteIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 3, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipNewCfgStaticRouteIndx.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgStaticRouteIndx.setDescription('The index of the static routing table.')
ipNewCfgStaticRouteDestIp = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 3, 3, 1, 2), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgStaticRouteDestIp.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgStaticRouteDestIp.setDescription('The destination IP address of this route.')
ipNewCfgStaticRouteMask = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 3, 3, 1, 3), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgStaticRouteMask.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgStaticRouteMask.setDescription('The subnet mask of this route.')
ipNewCfgStaticRouteGateway = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 3, 3, 1, 4), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgStaticRouteGateway.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgStaticRouteGateway.setDescription('The IP address of the gateway for this route.')
ipNewCfgStaticRouteAction = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 3, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("delete", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgStaticRouteAction.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgStaticRouteAction.setDescription('When set to the value of 2 (delete), the entire row is deleted. When read, other is returned. Setting the value to anything other than 2(delete) has no effect on the state of the row.')
ipNewCfgStaticRouteInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 3, 3, 1, 6), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgStaticRouteInterface.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgStaticRouteInterface.setDescription('The IP interface of this route. The IP address of the specified interface shall be use as source IP when performs routing.')
ripCurCfgIntfTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 18, 1), )
if mibBuilder.loadTexts: ripCurCfgIntfTable.setStatus('current')
if mibBuilder.loadTexts: ripCurCfgIntfTable.setDescription('The table of RIP on IP interface in the current configuration block.')
ripCurCfgIntfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 18, 1, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ripCurCfgIntfIndex"))
if mibBuilder.loadTexts: ripCurCfgIntfEntry.setStatus('current')
if mibBuilder.loadTexts: ripCurCfgIntfEntry.setDescription('Information about RIP on IP interface.')
ripCurCfgIntfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 18, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripCurCfgIntfIndex.setStatus('current')
if mibBuilder.loadTexts: ripCurCfgIntfIndex.setDescription('The interface number for which the RIP information is related.')
ripCurCfgIntfVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 18, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ripVersion1", 1), ("ripVersion2", 2), ("ripVersionBoth", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripCurCfgIntfVersion.setStatus('current')
if mibBuilder.loadTexts: ripCurCfgIntfVersion.setDescription('RIP version.')
ripCurCfgIntfState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 18, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripCurCfgIntfState.setStatus('current')
if mibBuilder.loadTexts: ripCurCfgIntfState.setDescription('Enable or disable RIP protocol.')
ripCurCfgIntfListen = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 18, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripCurCfgIntfListen.setStatus('current')
if mibBuilder.loadTexts: ripCurCfgIntfListen.setDescription('Enable or disable listening to route updates.')
ripCurCfgIntfTrigUpdate = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 18, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripCurCfgIntfTrigUpdate.setStatus('current')
if mibBuilder.loadTexts: ripCurCfgIntfTrigUpdate.setDescription('Enable or disable triggered updates.')
ripCurCfgIntfMcastUpdate = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 18, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripCurCfgIntfMcastUpdate.setStatus('current')
if mibBuilder.loadTexts: ripCurCfgIntfMcastUpdate.setDescription('Enable or disable multicast updates.')
ripCurCfgIntfPoisonReverse = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 18, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripCurCfgIntfPoisonReverse.setStatus('current')
if mibBuilder.loadTexts: ripCurCfgIntfPoisonReverse.setDescription('RIP poison reverse.')
ripCurCfgIntfSupply = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 18, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripCurCfgIntfSupply.setStatus('current')
if mibBuilder.loadTexts: ripCurCfgIntfSupply.setDescription('Enable or disable supplying route updates.')
ripCurCfgIntfMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 18, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripCurCfgIntfMetric.setStatus('current')
if mibBuilder.loadTexts: ripCurCfgIntfMetric.setDescription('RIP route metric for this interface.')
ripCurCfgIntfAuth = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 18, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("none", 1), ("password", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripCurCfgIntfAuth.setStatus('current')
if mibBuilder.loadTexts: ripCurCfgIntfAuth.setDescription('The type of Authentication used on this interface.')
ripCurCfgIntfKey = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 18, 1, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripCurCfgIntfKey.setStatus('current')
if mibBuilder.loadTexts: ripCurCfgIntfKey.setDescription('RIP update authentication password.')
ripCurCfgIntfDefault = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 18, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("both", 1), ("listen", 2), ("supply", 3), ("none", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripCurCfgIntfDefault.setStatus('current')
if mibBuilder.loadTexts: ripCurCfgIntfDefault.setDescription('Specifies what RIP does with default routes.')
ripCurCfgIntfSplitHorizon = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 18, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("enabled", 2), ("disabled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripCurCfgIntfSplitHorizon.setStatus('current')
if mibBuilder.loadTexts: ripCurCfgIntfSplitHorizon.setDescription('RIP split horizon.')
ripNewCfgIntfTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 18, 2), )
if mibBuilder.loadTexts: ripNewCfgIntfTable.setStatus('current')
if mibBuilder.loadTexts: ripNewCfgIntfTable.setDescription('The table of RIP on IP interface in the new configuration block.')
ripNewCfgIntfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 18, 2, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ripNewCfgIntfIndex"))
if mibBuilder.loadTexts: ripNewCfgIntfEntry.setStatus('current')
if mibBuilder.loadTexts: ripNewCfgIntfEntry.setDescription('Information about RIP on IP interface.')
ripNewCfgIntfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 18, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripNewCfgIntfIndex.setStatus('current')
if mibBuilder.loadTexts: ripNewCfgIntfIndex.setDescription('The interface number for which the RIP information is related.')
ripNewCfgIntfVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 18, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ripVersion1", 1), ("ripVersion2", 2), ("ripVersionBoth", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ripNewCfgIntfVersion.setStatus('current')
if mibBuilder.loadTexts: ripNewCfgIntfVersion.setDescription('RIP version.')
ripNewCfgIntfSupply = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 18, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ripNewCfgIntfSupply.setStatus('current')
if mibBuilder.loadTexts: ripNewCfgIntfSupply.setDescription('Enable or disable supplying route updates.')
ripNewCfgIntfListen = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 18, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ripNewCfgIntfListen.setStatus('current')
if mibBuilder.loadTexts: ripNewCfgIntfListen.setDescription('Enable or disable listening to route updates.')
ripNewCfgIntfTrigUpdate = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 18, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ripNewCfgIntfTrigUpdate.setStatus('current')
if mibBuilder.loadTexts: ripNewCfgIntfTrigUpdate.setDescription('Enable or disable triggered updates.')
ripNewCfgIntfMcastUpdate = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 18, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ripNewCfgIntfMcastUpdate.setStatus('current')
if mibBuilder.loadTexts: ripNewCfgIntfMcastUpdate.setDescription('Enable or disable multicast updates.')
ripNewCfgIntfPoisonReverse = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 18, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ripNewCfgIntfPoisonReverse.setStatus('current')
if mibBuilder.loadTexts: ripNewCfgIntfPoisonReverse.setDescription('RIP poison reverse.')
ripNewCfgIntfState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 18, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ripNewCfgIntfState.setStatus('current')
if mibBuilder.loadTexts: ripNewCfgIntfState.setDescription('Enable or disable RIP protocol.')
ripNewCfgIntfMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 18, 2, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ripNewCfgIntfMetric.setStatus('current')
if mibBuilder.loadTexts: ripNewCfgIntfMetric.setDescription('RIP route metric for this interface.')
ripNewCfgIntfAuth = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 18, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("none", 1), ("password", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ripNewCfgIntfAuth.setStatus('current')
if mibBuilder.loadTexts: ripNewCfgIntfAuth.setDescription('The type of Authentication used on this interface.')
ripNewCfgIntfKey = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 18, 2, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ripNewCfgIntfKey.setStatus('current')
if mibBuilder.loadTexts: ripNewCfgIntfKey.setDescription('RIP update authentication password.')
ripNewCfgIntfDefault = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 18, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("both", 1), ("listen", 2), ("supply", 3), ("none", 4)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ripNewCfgIntfDefault.setStatus('current')
if mibBuilder.loadTexts: ripNewCfgIntfDefault.setDescription('Specifies what RIP does with default routes. The default routes action could be set to listen/supply/both/none.')
ripNewCfgIntfSplitHorizon = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 18, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("enabled", 2), ("disabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ripNewCfgIntfSplitHorizon.setStatus('current')
if mibBuilder.loadTexts: ripNewCfgIntfSplitHorizon.setDescription('RIP split horizon.')
ripGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 18, 3))
rip2CurCfgState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 18, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rip2CurCfgState.setStatus('current')
if mibBuilder.loadTexts: rip2CurCfgState.setDescription('RIP global state.')
rip2NewCfgState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 18, 3, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rip2NewCfgState.setStatus('current')
if mibBuilder.loadTexts: rip2NewCfgState.setDescription('Globally turn RIP on or off.')
rip2CurCfgUpdatePeriod = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 18, 3, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 120))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rip2CurCfgUpdatePeriod.setStatus('current')
if mibBuilder.loadTexts: rip2CurCfgUpdatePeriod.setDescription('Update Period in seconds.')
rip2NewCfgUpdatePeriod = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 18, 3, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 120))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rip2NewCfgUpdatePeriod.setStatus('current')
if mibBuilder.loadTexts: rip2NewCfgUpdatePeriod.setDescription('Update Period in seconds.')
ripRouteRedistribution = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 18, 4))
ripRedistributeStatic = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 18, 4, 1))
ripCurCfgStaticMetric = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 18, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripCurCfgStaticMetric.setStatus('current')
if mibBuilder.loadTexts: ripCurCfgStaticMetric.setDescription('The metric to be assigned to static routes. A value of 0 indicates none.')
ripNewCfgStaticMetric = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 18, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ripNewCfgStaticMetric.setStatus('current')
if mibBuilder.loadTexts: ripNewCfgStaticMetric.setDescription('The metric to be assigned to static routes. A value of 0 indicates none.')
ripCurCfgStaticOutRmapList = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 18, 4, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripCurCfgStaticOutRmapList.setStatus('current')
if mibBuilder.loadTexts: ripCurCfgStaticOutRmapList.setDescription('The route maps present in the out route map list. The route maps are presented in a bitmap format. in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ Rmap 9 || || || ||___ Rmap 8 || |____ Rmap 7 || . . . ||_________ Rmap 2 |__________ Rmap 1 where x : 1 - The represented route map is selected 0 - The represented route map is not selected')
ripNewCfgStaticOutRmapList = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 18, 4, 1, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripNewCfgStaticOutRmapList.setStatus('current')
if mibBuilder.loadTexts: ripNewCfgStaticOutRmapList.setDescription('The route maps present in the out route map list. The route maps are presented in a bitmap format. in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ Rmap 9 || || || ||___ Rmap 8 || |____ Rmap 7 || . . . ||_________ Rmap 2 |__________ Rmap 1 where x : 1 - The represented route map is selected 0 - The represented route map is not selected')
ripNewCfgStaticAddOutRmap = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 18, 4, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ripNewCfgStaticAddOutRmap.setStatus('current')
if mibBuilder.loadTexts: ripNewCfgStaticAddOutRmap.setDescription('The route map to be add into out-rmap list. When read, 0 is returned.')
ripNewCfgStaticRemoveOutRmap = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 18, 4, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ripNewCfgStaticRemoveOutRmap.setStatus('current')
if mibBuilder.loadTexts: ripNewCfgStaticRemoveOutRmap.setDescription('The route map to be removed from out-rmap list. When read, 0 is returned.')
ripRedistributeEbgp = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 18, 4, 2))
ripCurCfgEbgpMetric = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 18, 4, 2, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripCurCfgEbgpMetric.setStatus('current')
if mibBuilder.loadTexts: ripCurCfgEbgpMetric.setDescription('The export metric to be assigned to External BGP routes. A value of 0 indicates none.')
ripNewCfgEbgpMetric = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 18, 4, 2, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ripNewCfgEbgpMetric.setStatus('current')
if mibBuilder.loadTexts: ripNewCfgEbgpMetric.setDescription('The export metric to be assigned to External BGP routes. A value of 0 indicates none.')
ripCurCfgEbgpOutRmapList = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 18, 4, 2, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripCurCfgEbgpOutRmapList.setStatus('current')
if mibBuilder.loadTexts: ripCurCfgEbgpOutRmapList.setDescription('The route maps present in the out route map list. The route maps are presented in a bitmap format. in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ Rmap 9 || || || ||___ Rmap 8 || |____ Rmap 7 || . . . ||_________ Rmap 2 |__________ Rmap 1 where x : 1 - The represented route map is selected 0 - The represented route map is not selected')
ripNewCfgEbgpOutRmapList = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 18, 4, 2, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripNewCfgEbgpOutRmapList.setStatus('current')
if mibBuilder.loadTexts: ripNewCfgEbgpOutRmapList.setDescription('The route maps present in the out route map list. The route maps are presented in a bitmap format. in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ Rmap 9 || || || ||___ Rmap 8 || |____ Rmap 7 || . . . ||_________ Rmap 2 |__________ Rmap 1 where x : 1 - The represented route map is selected 0 - The represented route map is not selected')
ripNewCfgEbgpAddOutRmap = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 18, 4, 2, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ripNewCfgEbgpAddOutRmap.setStatus('current')
if mibBuilder.loadTexts: ripNewCfgEbgpAddOutRmap.setDescription('The route map to be add into out-rmap list. When read, 0 is returned.')
ripNewCfgEbgpRemoveOutRmap = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 18, 4, 2, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ripNewCfgEbgpRemoveOutRmap.setStatus('current')
if mibBuilder.loadTexts: ripNewCfgEbgpRemoveOutRmap.setDescription('The route map to be removed from out-rmap list. When read, 0 is returned.')
ripRedistributeIbgp = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 18, 4, 3))
ripCurCfgIbgpMetric = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 18, 4, 3, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripCurCfgIbgpMetric.setStatus('current')
if mibBuilder.loadTexts: ripCurCfgIbgpMetric.setDescription('The export metric for Internal BGP routes. A value of 0 indicates none.')
ripNewCfgIbgpMetric = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 18, 4, 3, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ripNewCfgIbgpMetric.setStatus('current')
if mibBuilder.loadTexts: ripNewCfgIbgpMetric.setDescription('The export metric for Internal BGP routes. A value of 0 indicates none.')
ripCurCfgIbgpOutRmapList = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 18, 4, 3, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripCurCfgIbgpOutRmapList.setStatus('current')
if mibBuilder.loadTexts: ripCurCfgIbgpOutRmapList.setDescription('The route maps present in the out route map list. The route maps are presented in a bitmap format. in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ Rmap 9 || || || ||___ Rmap 8 || |____ Rmap 7 || . . . ||_________ Rmap 2 |__________ Rmap 1 where x : 1 - The represented route map is selected 0 - The represented route map is not selected')
ripNewCfgIbgpOutRmapList = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 18, 4, 3, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripNewCfgIbgpOutRmapList.setStatus('current')
if mibBuilder.loadTexts: ripNewCfgIbgpOutRmapList.setDescription('The route maps present in the out route map list. The route maps are presented in a bitmap format. in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ Rmap 9 || || || ||___ Rmap 8 || |____ Rmap 7 || . . . ||_________ Rmap 2 |__________ Rmap 1 where x : 1 - The represented route map is selected 0 - The represented route map is not selected')
ripNewCfgIbgpAddOutRmap = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 18, 4, 3, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ripNewCfgIbgpAddOutRmap.setStatus('current')
if mibBuilder.loadTexts: ripNewCfgIbgpAddOutRmap.setDescription('The route map to be add into out-rmap list. When read, 0 is returned.')
ripNewCfgIbgpRemoveOutRmap = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 18, 4, 3, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ripNewCfgIbgpRemoveOutRmap.setStatus('current')
if mibBuilder.loadTexts: ripNewCfgIbgpRemoveOutRmap.setDescription('The route map to be removed from out-rmap list. When read, 0 is returned.')
ripRedistributeFixed = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 18, 4, 4))
ripCurCfgFixedMetric = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 18, 4, 4, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripCurCfgFixedMetric.setStatus('current')
if mibBuilder.loadTexts: ripCurCfgFixedMetric.setDescription('The export metric for fixed routes. A value of 0 indicates none')
ripNewCfgFixedMetric = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 18, 4, 4, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ripNewCfgFixedMetric.setStatus('current')
if mibBuilder.loadTexts: ripNewCfgFixedMetric.setDescription('The export metric for fixed routes. A value of 0 indicates none')
ripCurCfgFixedOutRmapList = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 18, 4, 4, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripCurCfgFixedOutRmapList.setStatus('current')
if mibBuilder.loadTexts: ripCurCfgFixedOutRmapList.setDescription('The route maps present in the out route map list. The route maps are presented in a bitmap format. in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ Rmap 9 || || || ||___ Rmap 8 || |____ Rmap 7 || . . . ||_________ Rmap 2 |__________ Rmap 1 where x : 1 - The represented route map is selected 0 - The represented route map is not selected')
ripNewCfgFixedOutRmapList = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 18, 4, 4, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripNewCfgFixedOutRmapList.setStatus('current')
if mibBuilder.loadTexts: ripNewCfgFixedOutRmapList.setDescription('The route maps present in the out route map list. The route maps are presented in a bitmap format. in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ Rmap 9 || || || ||___ Rmap 8 || |____ Rmap 7 || . . . ||_________ Rmap 2 |__________ Rmap 1 where x : 1 - The represented route map is selected 0 - The represented route map is not selected')
ripNewCfgFixedAddOutRmap = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 18, 4, 4, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ripNewCfgFixedAddOutRmap.setStatus('current')
if mibBuilder.loadTexts: ripNewCfgFixedAddOutRmap.setDescription('The route map to be add into out-rmap list. When read, 0 is returned.')
ripNewCfgFixedRemoveOutRmap = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 18, 4, 4, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ripNewCfgFixedRemoveOutRmap.setStatus('current')
if mibBuilder.loadTexts: ripNewCfgFixedRemoveOutRmap.setDescription('The route map to be removed from out-rmap list. When read, 0 is returned.')
ripRedistributeOspf = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 18, 4, 5))
ripCurCfgOspfMetric = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 18, 4, 5, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripCurCfgOspfMetric.setStatus('current')
if mibBuilder.loadTexts: ripCurCfgOspfMetric.setDescription('The export metric for RIP routes. A value of 0 indicates none')
ripNewCfgOspfMetric = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 18, 4, 5, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ripNewCfgOspfMetric.setStatus('current')
if mibBuilder.loadTexts: ripNewCfgOspfMetric.setDescription('The export metric for RIP routes. A value of 0 indicates none')
ripCurCfgOspfOutRmapList = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 18, 4, 5, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripCurCfgOspfOutRmapList.setStatus('current')
if mibBuilder.loadTexts: ripCurCfgOspfOutRmapList.setDescription('The route maps present in the out route map list. The route maps are presented in a bitmap format. in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ Rmap 9 || || || ||___ Rmap 8 || |____ Rmap 7 || . . . ||_________ Rmap 2 |__________ Rmap 1 where x : 1 - The represented route map is selected 0 - The represented route map is not selected')
ripNewCfgOspfOutRmapList = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 18, 4, 5, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripNewCfgOspfOutRmapList.setStatus('current')
if mibBuilder.loadTexts: ripNewCfgOspfOutRmapList.setDescription('The route maps present in the out route map list. The route maps are presented in a bitmap format. in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ Rmap 9 || || || ||___ Rmap 8 || |____ Rmap 7 || . . . ||_________ Rmap 2 |__________ Rmap 1 where x : 1 - The represented route map is selected 0 - The represented route map is not selected')
ripNewCfgOspfAddOutRmap = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 18, 4, 5, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ripNewCfgOspfAddOutRmap.setStatus('current')
if mibBuilder.loadTexts: ripNewCfgOspfAddOutRmap.setDescription('The route map to be add into out-rmap list. When read, 0 is returned.')
ripNewCfgOspfRemoveOutRmap = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 18, 4, 5, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ripNewCfgOspfRemoveOutRmap.setStatus('current')
if mibBuilder.loadTexts: ripNewCfgOspfRemoveOutRmap.setDescription('The route map to be removed from out-rmap list. When read, 0 is returned.')
ripRedistributeEospf = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 18, 4, 6))
ripCurCfgEospfMetric = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 18, 4, 6, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripCurCfgEospfMetric.setStatus('current')
if mibBuilder.loadTexts: ripCurCfgEospfMetric.setDescription('The export metric for RIP routes. A value of 0 indicates none')
ripNewCfgEospfMetric = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 18, 4, 6, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ripNewCfgEospfMetric.setStatus('current')
if mibBuilder.loadTexts: ripNewCfgEospfMetric.setDescription('The export metric for RIP routes. A value of 0 indicates none')
ripCurCfgEospfOutRmapList = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 18, 4, 6, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripCurCfgEospfOutRmapList.setStatus('current')
if mibBuilder.loadTexts: ripCurCfgEospfOutRmapList.setDescription('The route maps present in the out route map list. The route maps are presented in a bitmap format. in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ Rmap 9 || || || ||___ Rmap 8 || |____ Rmap 7 || . . . ||_________ Rmap 2 |__________ Rmap 1 where x : 1 - The represented route map is selected 0 - The represented route map is not selected')
ripNewCfgEospfOutRmapList = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 18, 4, 6, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripNewCfgEospfOutRmapList.setStatus('current')
if mibBuilder.loadTexts: ripNewCfgEospfOutRmapList.setDescription('The route maps present in the out route map list. The route maps are presented in a bitmap format. in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ Rmap 9 || || || ||___ Rmap 8 || |____ Rmap 7 || . . . ||_________ Rmap 2 |__________ Rmap 1 where x : 1 - The represented route map is selected 0 - The represented route map is not selected')
ripNewCfgEospfAddOutRmap = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 18, 4, 6, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ripNewCfgEospfAddOutRmap.setStatus('current')
if mibBuilder.loadTexts: ripNewCfgEospfAddOutRmap.setDescription('The route map to be add into out-rmap list. When read, 0 is returned.')
ripNewCfgEospfRemoveOutRmap = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 18, 4, 6, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ripNewCfgEospfRemoveOutRmap.setStatus('current')
if mibBuilder.loadTexts: ripNewCfgEospfRemoveOutRmap.setDescription('The route map to be removed from out-rmap list. When read, 0 is returned.')
ipFwdGeneralCfg = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 4, 1))
ipFwdCurCfgState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 4, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("on", 2), ("off", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipFwdCurCfgState.setStatus('current')
if mibBuilder.loadTexts: ipFwdCurCfgState.setDescription('IP forwarding global state.')
ipFwdNewCfgState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("on", 2), ("off", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipFwdNewCfgState.setStatus('current')
if mibBuilder.loadTexts: ipFwdNewCfgState.setDescription('IP forwarding global state.')
ipFwdCurCfgDirectedBcast = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("enabled", 2), ("disabled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipFwdCurCfgDirectedBcast.setStatus('current')
if mibBuilder.loadTexts: ipFwdCurCfgDirectedBcast.setDescription('Enable or disable forwarding directed broadcasts.')
ipFwdNewCfgDirectedBcast = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("enabled", 2), ("disabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipFwdNewCfgDirectedBcast.setStatus('current')
if mibBuilder.loadTexts: ipFwdNewCfgDirectedBcast.setDescription('Enable or disable forwarding directed broadcasts.')
ipFwdCurCfgICMP6Redirect = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 4, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("enabled", 2), ("disabled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipFwdCurCfgICMP6Redirect.setStatus('current')
if mibBuilder.loadTexts: ipFwdCurCfgICMP6Redirect.setDescription('Enable or disable ICMPv6 redirects.')
ipFwdNewCfgICMP6Redirect = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 4, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("enabled", 2), ("disabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipFwdNewCfgICMP6Redirect.setStatus('current')
if mibBuilder.loadTexts: ipFwdNewCfgICMP6Redirect.setDescription('Enable or disable ICMPv6 redirects.')
arpCurCfgReARPPeriod = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 7, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 120))).setMaxAccess("readonly")
if mibBuilder.loadTexts: arpCurCfgReARPPeriod.setStatus('current')
if mibBuilder.loadTexts: arpCurCfgReARPPeriod.setDescription('Re-ARP Period in seconds.')
arpNewCfgReARPPeriod = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 7, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 120))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: arpNewCfgReARPPeriod.setStatus('current')
if mibBuilder.loadTexts: arpNewCfgReARPPeriod.setDescription('Re-ARP Period in seconds.')
ipCurCfgBootpAddr = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 8, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgBootpAddr.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgBootpAddr.setDescription('The IP address of BOOTP server.')
ipNewCfgBootpAddr = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 8, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipNewCfgBootpAddr.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgBootpAddr.setDescription('The IP address of BOOTP server.')
ipCurCfgBootpAddr2 = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 8, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgBootpAddr2.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgBootpAddr2.setDescription('The IP address of second BOOTP server.')
ipNewCfgBootpAddr2 = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 8, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipNewCfgBootpAddr2.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgBootpAddr2.setDescription('The IP address of second BOOTP server.')
ipCurCfgBootpState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 8, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("enabled", 2), ("disabled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgBootpState.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgBootpState.setDescription('The state of BOOTP relay.')
ipNewCfgBootpState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 8, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("enabled", 2), ("disabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipNewCfgBootpState.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgBootpState.setDescription('The state of BOOTP relay.')
ipCurCfgBootpGlobalServerTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 8, 20), )
if mibBuilder.loadTexts: ipCurCfgBootpGlobalServerTable.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgBootpGlobalServerTable.setDescription('The table of global BOOTP server addresses')
ipCurCfgBootpGlobalServerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 8, 20, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ipCurCfgBootpGlobalServerIndex"))
if mibBuilder.loadTexts: ipCurCfgBootpGlobalServerEntry.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgBootpGlobalServerEntry.setDescription('A row in the ipCurCfgBootpGlobalServerAddrTable')
ipCurCfgBootpGlobalServerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 8, 20, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgBootpGlobalServerIndex.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgBootpGlobalServerIndex.setDescription('The index of ipCurCfgBootpGlobalServerTable')
ipCurCfgBootpGlobalServerAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 8, 20, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgBootpGlobalServerAddress.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgBootpGlobalServerAddress.setDescription('The current global server IP.')
ipNewCfgBootpGlobalServerTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 8, 21), )
if mibBuilder.loadTexts: ipNewCfgBootpGlobalServerTable.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgBootpGlobalServerTable.setDescription('The table of global BOOTP server addresses')
ipNewCfgBootpGlobalServerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 8, 21, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ipNewCfgBootpGlobalServerIndex"))
if mibBuilder.loadTexts: ipNewCfgBootpGlobalServerEntry.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgBootpGlobalServerEntry.setDescription('A row in the ipNewCfgBootpGlobalServerAddrTable')
ipNewCfgBootpGlobalServerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 8, 21, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipNewCfgBootpGlobalServerIndex.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgBootpGlobalServerIndex.setDescription('The index of ipCurCfgBootpGlobalServerTable')
ipNewCfgBootpGlobalServerAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 8, 21, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipNewCfgBootpGlobalServerAddress.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgBootpGlobalServerAddress.setDescription('The current global server IP.')
ipCurCfgBootpBcastDomainTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 8, 22), )
if mibBuilder.loadTexts: ipCurCfgBootpBcastDomainTable.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgBootpBcastDomainTable.setDescription('The table of broadcast domain settings')
ipCurCfgBootpBcastDomainEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 8, 22, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ipCurCfgBootpBcastDomainIndex"))
if mibBuilder.loadTexts: ipCurCfgBootpBcastDomainEntry.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgBootpBcastDomainEntry.setDescription('A row in the broadcast domain table')
ipCurCfgBootpBcastDomainIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 8, 22, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgBootpBcastDomainIndex.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgBootpBcastDomainIndex.setDescription('The index of the broadcast domain entry')
ipCurCfgBootpBcastDomainVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 8, 22, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgBootpBcastDomainVlan.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgBootpBcastDomainVlan.setDescription('The VLAN of the broadcast domain entry')
ipCurCfgBootpBcastDomainEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 8, 22, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("enabled", 2), ("disabled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgBootpBcastDomainEnable.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgBootpBcastDomainEnable.setDescription('The state of the broadcast domain entry')
ipNewCfgBootpBcastDomainTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 8, 23), )
if mibBuilder.loadTexts: ipNewCfgBootpBcastDomainTable.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgBootpBcastDomainTable.setDescription('The table of broadcast domain settings')
ipNewCfgBootpBcastDomainEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 8, 23, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ipNewCfgBootpBcastDomainIndex"))
if mibBuilder.loadTexts: ipNewCfgBootpBcastDomainEntry.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgBootpBcastDomainEntry.setDescription('A row in the broadcast domain table')
ipNewCfgBootpBcastDomainIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 8, 23, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipNewCfgBootpBcastDomainIndex.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgBootpBcastDomainIndex.setDescription('The index of the broadcast domain entry')
ipNewCfgBootpBcastDomainVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 8, 23, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipNewCfgBootpBcastDomainVlan.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgBootpBcastDomainVlan.setDescription('The VLAN of the broadcast domain entry')
ipNewCfgBootpBcastDomainEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 8, 23, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("enabled", 2), ("disabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipNewCfgBootpBcastDomainEnable.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgBootpBcastDomainEnable.setDescription('The state of the broadcast domain entry')
ipNewCfgBootpBcastDomainAction = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 8, 23, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("delete", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgBootpBcastDomainAction.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgBootpBcastDomainAction.setDescription('When set to the value of 2 (delete), the broadcast domain is deleted. When read, other is returned. Setting the value to anything other than 2(delete) has no effect on the state of broadcast domain.')
ipCurCfgBootpBcastDomainServerTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 8, 24), )
if mibBuilder.loadTexts: ipCurCfgBootpBcastDomainServerTable.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgBootpBcastDomainServerTable.setDescription('The table of broadcast domain servers')
ipCurCfgBootpBcastDomainServerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 8, 24, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ipCurCfgBootpBcastDomainBDIndex"), (0, "IBM-GbTOR-10G-L2L3-MIB", "ipCurCfgBootpBcastDomainServIndex"))
if mibBuilder.loadTexts: ipCurCfgBootpBcastDomainServerEntry.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgBootpBcastDomainServerEntry.setDescription('A row in the broadcast domain server table')
ipCurCfgBootpBcastDomainBDIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 8, 24, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgBootpBcastDomainBDIndex.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgBootpBcastDomainBDIndex.setDescription('The index of the broadcast domain entry in the server table')
ipCurCfgBootpBcastDomainServIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 8, 24, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgBootpBcastDomainServIndex.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgBootpBcastDomainServIndex.setDescription('The index of the server in the server table')
ipCurCfgBootpBcastDomainServerIP = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 8, 24, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgBootpBcastDomainServerIP.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgBootpBcastDomainServerIP.setDescription('The current broadcast domain server IP.')
ipNewCfgBootpBcastDomainServerTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 8, 25), )
if mibBuilder.loadTexts: ipNewCfgBootpBcastDomainServerTable.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgBootpBcastDomainServerTable.setDescription('The table of broadcast domain servers')
ipNewCfgBootpBcastDomainServerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 8, 25, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ipNewCfgBootpBcastDomainBDIndex"), (0, "IBM-GbTOR-10G-L2L3-MIB", "ipNewCfgBootpBcastDomainServIndex"))
if mibBuilder.loadTexts: ipNewCfgBootpBcastDomainServerEntry.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgBootpBcastDomainServerEntry.setDescription('A row in the broadcast domain server table')
ipNewCfgBootpBcastDomainBDIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 8, 25, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipNewCfgBootpBcastDomainBDIndex.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgBootpBcastDomainBDIndex.setDescription('The index of the broadcast domain entry in the server table')
ipNewCfgBootpBcastDomainServIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 8, 25, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipNewCfgBootpBcastDomainServIndex.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgBootpBcastDomainServIndex.setDescription('The index of the server in the server table')
ipNewCfgBootpBcastDomainServerIP = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 8, 25, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipNewCfgBootpBcastDomainServerIP.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgBootpBcastDomainServerIP.setDescription('The current broadcast domain server IP.')
ipCurCfgBootpOpt82State = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 8, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("enabled", 2), ("disabled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgBootpOpt82State.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgBootpOpt82State.setDescription('The state of Bootp relay option 82')
ipNewCfgBootpOpt82State = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 8, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("enabled", 2), ("disabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipNewCfgBootpOpt82State.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgBootpOpt82State.setDescription('Set the stare of Bootp relay option 82')
ipCurCfgBootpOpt82Policy = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 8, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("replace", 0), ("drop", 1), ("keep", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgBootpOpt82Policy.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgBootpOpt82Policy.setDescription('The policy of Bootp relay option 82')
ipNewCfgBootpOpt82Policy = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 8, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("replace", 0), ("drop", 1), ("keep", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipNewCfgBootpOpt82Policy.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgBootpOpt82Policy.setDescription('Set the policy of Bootp relay option 82')
vrrpGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 1))
vrrpCurCfgGenState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgGenState.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgGenState.setDescription('Enable or disable VRRP operation globally.')
vrrpNewCfgGenState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrrpNewCfgGenState.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgGenState.setDescription('Enable or disable VRRP operation globally.')
vrrpCurCfgGenTckVirtRtrInc = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 254))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgGenTckVirtRtrInc.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgGenTckVirtRtrInc.setDescription('The increment of VRRP virtual router priority. The priority is adjusted by tracking the state of other virtual routers.')
vrrpNewCfgGenTckVirtRtrInc = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 254))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrrpNewCfgGenTckVirtRtrInc.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgGenTckVirtRtrInc.setDescription('The increment of VRRP virtual router priority. The priority is adjusted by tracking the state of other virtual routers.')
vrrpCurCfgGenTckIpIntfInc = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 254))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgGenTckIpIntfInc.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgGenTckIpIntfInc.setDescription('The increment of VRRP virtual router priority. The priority is adjusted by tracking the state of other router interfaces.')
vrrpNewCfgGenTckIpIntfInc = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 254))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrrpNewCfgGenTckIpIntfInc.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgGenTckIpIntfInc.setDescription('The increment of VRRP virtual router priority. The priority is adjusted by tracking the state of other router interfaces.')
vrrpCurCfgGenTckVlanPortInc = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 254))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgGenTckVlanPortInc.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgGenTckVlanPortInc.setDescription('The increment of VRRP virtual router priority. The priority is adjusted by tracking the port state of ports that belongs to the same virtual LAN as the virtual router.')
vrrpNewCfgGenTckVlanPortInc = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 254))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrrpNewCfgGenTckVlanPortInc.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgGenTckVlanPortInc.setDescription('The increment of VRRP virtual router priority. The priority is adjusted by tracking the port state of ports that belongs to the same virtual LAN as the virtual router.')
vrrpCurCfgGenHoldoff = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgGenHoldoff.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgGenHoldoff.setDescription('The time for VRRP virtual router to hold before it begins to change state to backup or master state.')
vrrpNewCfgGenHoldoff = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrrpNewCfgGenHoldoff.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgGenHoldoff.setDescription('The time for VRRP virtual router to hold before it begins to change state to backup or master state.')
vrrpVirtRtrTableMaxSize = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpVirtRtrTableMaxSize.setStatus('current')
if mibBuilder.loadTexts: vrrpVirtRtrTableMaxSize.setDescription('The maximum number of entries in VRRP virtual router table.')
vrrpCurCfgVirtRtrTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 3), )
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrTable.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrTable.setDescription('The table of VRRP virtual routers in the current configuration block.')
vrrpCurCfgVirtRtrTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 3, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "vrrpCurCfgVirtRtrIndx"))
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrTableEntry.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrTableEntry.setDescription('Information about a VRRP virtual router.')
vrrpCurCfgVirtRtrIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrIndx.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrIndx.setDescription('The VRRP virtual router table index.')
vrrpCurCfgVirtRtrID = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrID.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrID.setDescription('The VRRP virtual router identifier.')
vrrpCurCfgVirtRtrAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 3, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrAddr.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrAddr.setDescription('The VRRP virtual router IP address.')
vrrpCurCfgVirtRtrIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 3, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrIfIndex.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrIfIndex.setDescription('The IfIndex that the VRRP virtual router is representing.')
vrrpCurCfgVirtRtrInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 3, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrInterval.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrInterval.setDescription('The time interval between VRRP advertisements in seconds. When FAST_ADVERTISEMENT is enabled, this object indicates advertisement interval in centi-seconds')
vrrpCurCfgVirtRtrPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 3, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 254))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrPriority.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrPriority.setDescription('The priority value to be used by the specified VRRP virtual routers.')
vrrpCurCfgVirtRtrPreempt = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrPreempt.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrPreempt.setDescription('This is for controlling whether a higher priority Backup VRRP virtual router preempts a low priority Master. enabled(1) - allow preemption disabled(2) - prohibit preemption')
vrrpCurCfgVirtRtrTckVirtRtr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 3, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrTckVirtRtr.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrTckVirtRtr.setDescription('Enable or disable tracking other virtual routers for priority adjustment. The priority increment is defined in vrrpCurCfgGenTckVirtRtrInc.')
vrrpCurCfgVirtRtrTckIpIntf = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 3, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrTckIpIntf.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrTckIpIntf.setDescription('Enable or disable tracking other router interfaces for priority adjustment. The priority increment is defined in vrrpCurCfgGenTckIpIntfInc.')
vrrpCurCfgVirtRtrTckVlanPort = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 3, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrTckVlanPort.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrTckVlanPort.setDescription('Enable or disable tracking port state of VLAN ports for priority adjustment. The priority increment is defined in vrrpCurCfgGenTckVlanPortInc.')
vrrpCurCfgVirtRtrState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 3, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrState.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrState.setDescription('Enable or disable the VRRP virtual router.')
vrrpCurCfgVirtRtrFastAdvertisement = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 3, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrFastAdvertisement.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrFastAdvertisement.setDescription('This object provides the status of FAST_ADVERTISEMENT. When FAST_ADVERTISEMENT is enabled, - New message type FAST_ADVERTISEMENT(2) will be used in the VRRP advertisements - Can interop only with another FAST_ADVERTISEMENT enabled router - VRRP advertisement interval will be sent in units of centi-seconds - Timers will be running with centi-second granularity')
vrrpCurCfgVirtRtrPreDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 3, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrPreDelay.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrPreDelay.setDescription('The pre-emptive delay interval in seconds.')
vrrpNewCfgVirtRtrTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 4), )
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrTable.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrTable.setDescription('The table of VRRP virtual routers in the current configuration block.')
vrrpNewCfgVirtRtrTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 4, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "vrrpNewCfgVirtRtrIndx"))
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrTableEntry.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrTableEntry.setDescription('Information about a VRRP virtual router.')
vrrpNewCfgVirtRtrIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrIndx.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrIndx.setDescription('The VRRP virtual router table index.')
vrrpNewCfgVirtRtrID = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrID.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrID.setDescription('The VRRP virtual router identifier.')
vrrpNewCfgVirtRtrAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 4, 1, 3), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrAddr.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrAddr.setDescription('The VRRP virtual router IP address.')
vrrpNewCfgVirtRtrIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 4, 1, 4), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrIfIndex.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrIfIndex.setDescription('The IfIndex that the VRRP virtual router is representing.')
vrrpNewCfgVirtRtrInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 4, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrInterval.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrInterval.setDescription('The time interval between VRRP advertisements in seconds. When FAST_ADVERTISEMENT is enabled, this object indicates advertisement interval in centi-seconds')
vrrpNewCfgVirtRtrPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 4, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 254))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrPriority.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrPriority.setDescription('The priority value to be used by the specified VRRP virtual router.')
vrrpNewCfgVirtRtrPreempt = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 4, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrPreempt.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrPreempt.setDescription('This is for controlling whether a higher priority Backup VRRP virtual router preempts a low priority Master. enabled(1) - allow preemption disabled(2) - prohibit preemption')
vrrpNewCfgVirtRtrDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 4, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("delete", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrDelete.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrDelete.setDescription('When set to the value of 2 (delete), the entire row is deleted. When read, other(1) is returned. Setting the value to anything other than delete(2) has no effect on the state of the row.')
vrrpNewCfgVirtRtrTckVirtRtr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 4, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrTckVirtRtr.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrTckVirtRtr.setDescription('Enable or disable tracking other virtual routers for priority adjustment. the priority increment is defined in vrrpNewCfgGenTckVirtRtrInc.')
vrrpNewCfgVirtRtrTckIpIntf = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 4, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrTckIpIntf.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrTckIpIntf.setDescription('Enable or disable tracking other router interfaces for priority adjustment. the priority increment is defined in vrrpNewCfgGenTckIpIntfInc.')
vrrpNewCfgVirtRtrTckVlanPort = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 4, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrTckVlanPort.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrTckVlanPort.setDescription('Enable or disable tracking port state of VLAN ports for priority adjustment. the priority increment is defined in vrrpNewCfgGenTckVlanPortInc.')
vrrpNewCfgVirtRtrState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 4, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrState.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrState.setDescription('Enable or disable the VRRP virtual router.')
vrrpNewCfgVirtRtrFastAdvertisement = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 4, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrFastAdvertisement.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrFastAdvertisement.setDescription('This object can be enabled if sub-second advertisement interval is required. When FAST_ADVERTISEMENT is enabled, - New message type FAST_ADVERTISEMENT(2) will be used in the VRRP advertisements - Can interop only with another FAST_ADVERTISEMENT enabled router - VRRP advertisement interval will be sent in units of centi-seconds - Timers will be running with centi-second granularity')
vrrpNewCfgVirtRtrPreDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 4, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrPreDelay.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrPreDelay.setDescription('The pre-emptive delay interval in seconds.')
vrrpIfTableMaxSize = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpIfTableMaxSize.setStatus('current')
if mibBuilder.loadTexts: vrrpIfTableMaxSize.setDescription('The maximum number of entries in VRRP interface table.')
vrrpCurCfgIfTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 6), )
if mibBuilder.loadTexts: vrrpCurCfgIfTable.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgIfTable.setDescription('The table of VRRP interface in the current configuration block.')
vrrpCurCfgIfTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 6, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "vrrpCurCfgIfIndx"))
if mibBuilder.loadTexts: vrrpCurCfgIfTableEntry.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgIfTableEntry.setDescription('Information about a VRRP interface.')
vrrpCurCfgIfIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgIfIndx.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgIfIndx.setDescription('The VRRP interface index. This is eqivalent to IfIndex.')
vrrpCurCfgIfAuthType = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("none", 1), ("simple-text-password", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgIfAuthType.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgIfAuthType.setDescription('Type of authentication being used. none(1) - no authentication simple-text-password(2) - use password specified in vrrpCurCfgIfPasswd for authentication.')
vrrpCurCfgIfPasswd = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 6, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgIfPasswd.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgIfPasswd.setDescription('The password for authentication.')
vrrpNewCfgIfTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 7), )
if mibBuilder.loadTexts: vrrpNewCfgIfTable.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgIfTable.setDescription('The table of VRRP interface in the current configuration block.')
vrrpNewCfgIfTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 7, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "vrrpNewCfgIfIndx"))
if mibBuilder.loadTexts: vrrpNewCfgIfTableEntry.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgIfTableEntry.setDescription('Information about a VRRP interface.')
vrrpNewCfgIfIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 7, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpNewCfgIfIndx.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgIfIndx.setDescription('The VRRP interface index. This is eqivalent to IfIndex.')
vrrpNewCfgIfAuthType = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 7, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("none", 1), ("simple-text-password", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpNewCfgIfAuthType.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgIfAuthType.setDescription('Type of authentication being used. none(1) - no authentication simple-text-password(2) - use password specified in vrrpNewCfgIfPasswd for authentication.')
vrrpNewCfgIfPasswd = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 7, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpNewCfgIfPasswd.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgIfPasswd.setDescription('The password for authentication.')
vrrpNewCfgIfDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 7, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("delete", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpNewCfgIfDelete.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgIfDelete.setDescription('When set to the value of 2 (delete), the entire row is deleted. When read, other(1) is returned. Setting the value to anything other than delete(2) has no effect on the state of the row.')
vrrpVirtRtrGrpTableMaxSize = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpVirtRtrGrpTableMaxSize.setStatus('current')
if mibBuilder.loadTexts: vrrpVirtRtrGrpTableMaxSize.setDescription('The maximum number of entries in VRRP Group table.')
vrrpCurCfgVirtRtrGrpTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 9), )
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrGrpTable.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrGrpTable.setDescription('The table of VRRP virtual router group in the current configuration block.')
vrrpCurCfgVirtRtrGrpTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 9, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "vrrpCurCfgVirtRtrGrpIndx"))
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrGrpTableEntry.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrGrpTableEntry.setDescription('Information about a VRRP failover virtual router.')
vrrpCurCfgVirtRtrGrpIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 9, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrGrpIndx.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrGrpIndx.setDescription('The VRRP virtual router table index.')
vrrpCurCfgVirtRtrGrpID = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 9, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrGrpID.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrGrpID.setDescription('The VRRP virtual router identifier.')
vrrpCurCfgVirtRtrGrpIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 9, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrGrpIfIndex.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrGrpIfIndex.setDescription('The IfIndex that the VRRP virtual router is representing.')
vrrpCurCfgVirtRtrGrpInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 9, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrGrpInterval.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrGrpInterval.setDescription('The time interval between VRRP advertisements in seconds.')
vrrpCurCfgVirtRtrGrpPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 9, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 254))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrGrpPriority.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrGrpPriority.setDescription('The priority value to be used by the specified VRRP virtual routers.')
vrrpCurCfgVirtRtrGrpPreempt = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 9, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrGrpPreempt.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrGrpPreempt.setDescription('This is for controlling whether a higher priority Backup VRRP virtual router preempts a low priority Master. enabled(1) - allow preemption disabled(2) - prohibit preemption')
vrrpCurCfgVirtRtrGrpState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 9, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrGrpState.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrGrpState.setDescription('Enable or disable the VRRP virtual router.')
vrrpCurCfgVirtRtrGrpTckIpIntf = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 9, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrGrpTckIpIntf.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrGrpTckIpIntf.setDescription('Enable or disable tracking other router interfaces for priority adjustment. the priority increment is defined in vrrpCurCfgGenTckIpIntfInc.')
vrrpCurCfgVirtRtrGrpTckVlanPort = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 9, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrGrpTckVlanPort.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrGrpTckVlanPort.setDescription('Enable or disable tracking port state of VLAN ports for priority adjustment. the priority increment is defined in vrrpCurCfgGenTckVlanPortInc.')
vrrpCurCfgVirtRtrGrpFastAdvertisement = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 9, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrGrpFastAdvertisement.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrGrpFastAdvertisement.setDescription('This object provides the status of FAST_ADVERTISEMENT. When FAST_ADVERTISEMENT is enabled, - New message type FAST_ADVERTISEMENT(2) will be used in the VRRP advertisements - Can interop only with another FAST_ADVERTISEMENT enabled router - VRRP advertisement interval will be sent in units of centi-seconds - Timers will be running with centi-second granularity')
vrrpCurCfgVirtRtrGrpPredelay = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 9, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrGrpPredelay.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrGrpPredelay.setDescription('The pre-emptive delay interval in seconds for specified VRRP virtual routers.')
vrrpNewCfgVirtRtrGrpTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 10), )
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrGrpTable.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrGrpTable.setDescription('The table of VRRP virtual router group in the new configuration block.')
vrrpNewCfgVirtRtrGrpTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 10, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "vrrpNewCfgVirtRtrGrpIndx"))
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrGrpTableEntry.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrGrpTableEntry.setDescription('Information about a VRRP failover virtual router.')
vrrpNewCfgVirtRtrGrpIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 10, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrGrpIndx.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrGrpIndx.setDescription('The VRRP virtual router table index.')
vrrpNewCfgVirtRtrGrpID = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 10, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrGrpID.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrGrpID.setDescription('The VRRP virtual router identifier.')
vrrpNewCfgVirtRtrGrpIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 10, 1, 3), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrGrpIfIndex.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrGrpIfIndex.setDescription('The IfIndex that the VRRP virtual router is representing.')
vrrpNewCfgVirtRtrGrpInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 10, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrGrpInterval.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrGrpInterval.setDescription('The time interval between VRRP advertisements in seconds.')
vrrpNewCfgVirtRtrGrpPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 10, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 254))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrGrpPriority.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrGrpPriority.setDescription('The priority value to be used by the specified VRRP virtual router.')
vrrpNewCfgVirtRtrGrpPreempt = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrGrpPreempt.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrGrpPreempt.setDescription('This is for controlling whether a higher priority Backup VRRP virtual router preempts a low priority Master. enabled(1) - allow preemption disabled(2) - prohibit preemption')
vrrpNewCfgVirtRtrGrpState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 10, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrGrpState.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrGrpState.setDescription('Enable or disable the VRRP virtual router.')
vrrpNewCfgVirtRtrGrpDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 10, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("delete", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrGrpDelete.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrGrpDelete.setDescription('When set to the value of 2 (delete), the entire row is deleted. When read, other(1) is returned. Setting the value to anything other than delete(2) has no effect on the state of the row.')
vrrpNewCfgVirtRtrGrpTckIpIntf = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 10, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrGrpTckIpIntf.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrGrpTckIpIntf.setDescription('Enable or disable tracking other router interfaces for priority adjustment. the priority increment is defined in vrrpNewCfgGenTckIpIntfInc.')
vrrpNewCfgVirtRtrGrpTckVlanPort = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 10, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrGrpTckVlanPort.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrGrpTckVlanPort.setDescription('Enable or disable tracking port state of VLAN ports for priority adjustment. the priority increment is defined in vrrpNewCfgGenTckVlanPortInc.')
vrrpNewCfgVirtRtrGrpFastAdvertisement = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 10, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrGrpFastAdvertisement.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrGrpFastAdvertisement.setDescription('This object can be enabled if sub-second advertisement interval is required. When FAST_ADVERTISEMENT is enabled, - New message type FAST_ADVERTISEMENT(2) will be used in the VRRP advertisements - Can interop only with another FAST_ADVERTISEMENT enabled router - VRRP advertisement interval will be sent in units of centi-seconds - Timers will be running with centi-second granularity')
vrrpNewCfgVirtRtrGrpPredelay = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 6, 10, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrGrpPredelay.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrGrpPredelay.setDescription('The pre-emptive delay interval in seconds.')
dnsCurCfgPrimaryIpAddr = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 9, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dnsCurCfgPrimaryIpAddr.setStatus('current')
if mibBuilder.loadTexts: dnsCurCfgPrimaryIpAddr.setDescription('The DNS primary IP address in the current configuration block.')
dnsNewCfgPrimaryIpAddr = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 9, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dnsNewCfgPrimaryIpAddr.setStatus('current')
if mibBuilder.loadTexts: dnsNewCfgPrimaryIpAddr.setDescription('The DNS primary IP address in the new configuration block.')
dnsCurCfgSecondaryIpAddr = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 9, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dnsCurCfgSecondaryIpAddr.setStatus('current')
if mibBuilder.loadTexts: dnsCurCfgSecondaryIpAddr.setDescription('The DNS primary IP address in the current configuration block.')
dnsNewCfgSecondaryIpAddr = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 9, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dnsNewCfgSecondaryIpAddr.setStatus('current')
if mibBuilder.loadTexts: dnsNewCfgSecondaryIpAddr.setDescription('The DNS primary IP address in the new configuration block.')
dnsCurCfgDomainName = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 9, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 191))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dnsCurCfgDomainName.setStatus('current')
if mibBuilder.loadTexts: dnsCurCfgDomainName.setDescription('The DNS doamin name in the current configuration block.')
dnsNewCfgDomainName = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 9, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 191))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dnsNewCfgDomainName.setStatus('current')
if mibBuilder.loadTexts: dnsNewCfgDomainName.setDescription('The DNS doamin name in the new configuration block.')
dnsNewCfgFirstRequestAddr = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 9, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ipv4", 1), ("ipv6", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dnsNewCfgFirstRequestAddr.setStatus('current')
if mibBuilder.loadTexts: dnsNewCfgFirstRequestAddr.setDescription('Type of the first request to dns')
dnsCurCfgFirstRequestAddr = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 9, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ipv4", 1), ("ipv6", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dnsCurCfgFirstRequestAddr.setStatus('current')
if mibBuilder.loadTexts: dnsCurCfgFirstRequestAddr.setDescription('Type of the first request to dns')
dnsCurCfgPriServerPort = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 9, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("data", 1), ("mgtb", 2), ("mgta", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dnsCurCfgPriServerPort.setStatus('current')
if mibBuilder.loadTexts: dnsCurCfgPriServerPort.setDescription('Choose the port that the primary server is connected to.')
dnsNewCfgPriServerPort = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 9, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("data", 1), ("mgtb", 2), ("mgta", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dnsNewCfgPriServerPort.setStatus('current')
if mibBuilder.loadTexts: dnsNewCfgPriServerPort.setDescription('Choose the port that the primary server is connected to.')
dnsCurCfgSecServerPort = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 9, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("data", 1), ("mgtb", 2), ("mgta", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dnsCurCfgSecServerPort.setStatus('current')
if mibBuilder.loadTexts: dnsCurCfgSecServerPort.setDescription('Choose the port that the secondary server is connected to.')
dnsNewCfgSecServerPort = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 9, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("data", 1), ("mgtb", 2), ("mgta", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dnsNewCfgSecServerPort.setStatus('current')
if mibBuilder.loadTexts: dnsNewCfgSecServerPort.setDescription('Choose the port that the secondary server is connected to.')
ipNwfTableMax = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 10, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipNwfTableMax.setStatus('current')
if mibBuilder.loadTexts: ipNwfTableMax.setDescription('The maximum number of rows in the IP network filter table.')
ipCurCfgNwfTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 10, 2), )
if mibBuilder.loadTexts: ipCurCfgNwfTable.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgNwfTable.setDescription('The table of IP network filter in the current configuration block.')
ipCurCfgNwfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 10, 2, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ipCurCfgNwfIndex"))
if mibBuilder.loadTexts: ipCurCfgNwfEntry.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgNwfEntry.setDescription('Information about an IP network filter.')
ipCurCfgNwfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 10, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgNwfIndex.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgNwfIndex.setDescription('The netowrk filter number for which the NWF is related.')
ipCurCfgNwfAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 10, 2, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgNwfAddr.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgNwfAddr.setDescription('The IP address of the network filter.')
ipCurCfgNwfMask = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 10, 2, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgNwfMask.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgNwfMask.setDescription('The IP network filter mask.')
ipCurCfgNwfState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 10, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgNwfState.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgNwfState.setDescription('Enable or disable the network filter.')
ipNewCfgNwfTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 10, 3), )
if mibBuilder.loadTexts: ipNewCfgNwfTable.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgNwfTable.setDescription('The table of IP network filter in the current configuration block.')
ipNewCfgNwfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 10, 3, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ipNewCfgNwfIndex"))
if mibBuilder.loadTexts: ipNewCfgNwfEntry.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgNwfEntry.setDescription('Information about an IP network filter.')
ipNewCfgNwfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 10, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipNewCfgNwfIndex.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgNwfIndex.setDescription('The netowrk filter number for which the NWF is related.')
ipNewCfgNwfAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 10, 3, 1, 2), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgNwfAddr.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgNwfAddr.setDescription('The IP address of the network filter.')
ipNewCfgNwfMask = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 10, 3, 1, 3), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgNwfMask.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgNwfMask.setDescription('The IP network filter mask.')
ipNewCfgNwfState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 10, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgNwfState.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgNwfState.setDescription('Enable or disable the network filter.')
ipNewCfgNwfDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 10, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("delete", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgNwfDelete.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgNwfDelete.setDescription('When set to the value of 2 (delete), the entire row is deleted. When read, other(1) is returned. Setting the value to anything other than 2(delete) has no effect on the state of the row.')
ipRmapTableMax = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 11, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipRmapTableMax.setStatus('current')
if mibBuilder.loadTexts: ipRmapTableMax.setDescription('The maximum number of rows in the IP route map table.')
ipCurCfgRmapTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 11, 2), )
if mibBuilder.loadTexts: ipCurCfgRmapTable.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgRmapTable.setDescription('The table of IP route map in the current configuration block.')
ipCurCfgRmapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 11, 2, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ipCurCfgRmapIndex"))
if mibBuilder.loadTexts: ipCurCfgRmapEntry.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgRmapEntry.setDescription('Information about an IP route map.')
ipCurCfgRmapIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 11, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgRmapIndex.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgRmapIndex.setDescription('The route map number for which the RMAP is related.')
ipCurCfgRmapLp = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 11, 2, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgRmapLp.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgRmapLp.setDescription('The local-preference of the route map. 4294967295 means none')
ipCurCfgRmapMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 11, 2, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgRmapMetric.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgRmapMetric.setDescription('The metric of the route map. 4294967295 means none. Range is [1-16777214] if OSPF metric-type is used.')
ipCurCfgRmapPrec = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 11, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgRmapPrec.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgRmapPrec.setDescription('The precedence of the route map.')
ipCurCfgRmapWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 11, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgRmapWeight.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgRmapWeight.setDescription('The weight of the route map. 65535 means none')
ipCurCfgRmapState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 11, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgRmapState.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgRmapState.setDescription('Enable or disable the route map.')
ipCurCfgRmapAp = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 11, 2, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgRmapAp.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgRmapAp.setDescription('The as-path prepend of the matched route. Up to 3 AS number can be displayed for the string. The usuage is:<AS number> [<AS number>][ <AS number>]')
ipCurCfgRmapMetricType = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 11, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("type1", 2), ("type2", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgRmapMetricType.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgRmapMetricType.setDescription('The OSPF metric-type of the matched route.')
ipCurCfgRmapNexthop = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 11, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgRmapNexthop.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgRmapNexthop.setDescription('Peer address as nexthop of the matched route(only for BGP).')
ipNewCfgRmapTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 11, 3), )
if mibBuilder.loadTexts: ipNewCfgRmapTable.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgRmapTable.setDescription('The table of IP route map in the new configuration block.')
ipNewCfgRmapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 11, 3, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ipNewCfgRmapIndex"))
if mibBuilder.loadTexts: ipNewCfgRmapEntry.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgRmapEntry.setDescription('Information about an IP route map.')
ipNewCfgRmapIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 11, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipNewCfgRmapIndex.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgRmapIndex.setDescription('The route map number for which the RMAP is related.')
ipNewCfgRmapLp = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 11, 3, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgRmapLp.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgRmapLp.setDescription('The local-preference of the route map. 4294967295 means none')
ipNewCfgRmapMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 11, 3, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgRmapMetric.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgRmapMetric.setDescription('The metric of the route map. 4294967295 means none. Range is [1-16777214] if OSPF metric-type is used.')
ipNewCfgRmapPrec = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 11, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgRmapPrec.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgRmapPrec.setDescription('The precedence of the route map.')
ipNewCfgRmapWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 11, 3, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgRmapWeight.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgRmapWeight.setDescription('The weight of the route map. 65535 means none')
ipNewCfgRmapState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 11, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgRmapState.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgRmapState.setDescription('Enable or disable the route map.')
ipNewCfgRmapAp = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 11, 3, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 17))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgRmapAp.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgRmapAp.setDescription('The as-path prepend of the matched route. Up to 3 AS number can be displayed for the string. The usuage is:<AS number> [<AS number>][ <AS number>]')
ipNewCfgRmapMetricType = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 11, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("type1", 2), ("type2", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgRmapMetricType.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgRmapMetricType.setDescription('The OSPF metric-type of the matched route.')
ipNewCfgRmapDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 11, 3, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("delete", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgRmapDelete.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgRmapDelete.setDescription('When set to the value of 2 (delete), the entire row is deleted. When read, other(1) is returned. Setting the value to anything other than 2(delete) has no effect on the state of the row.')
ipNewCfgRmapNexthop = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 11, 3, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgRmapNexthop.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgRmapNexthop.setDescription('Peer address as nexthop of the matched route(only for BGP).')
ipAlistTableMax = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 11, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipAlistTableMax.setStatus('current')
if mibBuilder.loadTexts: ipAlistTableMax.setDescription('The maximum number of rows in the IP route map table.')
ipCurCfgAlistTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 11, 5), )
if mibBuilder.loadTexts: ipCurCfgAlistTable.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgAlistTable.setDescription('The table of IP route map access list in the current configuration block.')
ipCurCfgAlistEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 11, 5, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ipCurCfgAlistRmapIndex"), (0, "IBM-GbTOR-10G-L2L3-MIB", "ipCurCfgAlistIndex"))
if mibBuilder.loadTexts: ipCurCfgAlistEntry.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgAlistEntry.setDescription('Information about an IP route map.')
ipCurCfgAlistRmapIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 11, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgAlistRmapIndex.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgAlistRmapIndex.setDescription('The route map number for which the RMAP is related.')
ipCurCfgAlistIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 11, 5, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgAlistIndex.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgAlistIndex.setDescription('The access list number for which the access list is related.')
ipCurCfgAlistNwf = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 11, 5, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgAlistNwf.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgAlistNwf.setDescription('The network filter number of the route map access list. 0 means none')
ipCurCfgAlistMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 11, 5, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgAlistMetric.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgAlistMetric.setDescription('The metric of the route map access list. 4294967295 means none')
ipCurCfgAlistAction = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 11, 5, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("permit", 1), ("deny", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgAlistAction.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgAlistAction.setDescription('Action of the route map access list.')
ipCurCfgAlistState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 11, 5, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgAlistState.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgAlistState.setDescription('Enable or disable the route map access list.')
ipNewCfgAlistTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 11, 6), )
if mibBuilder.loadTexts: ipNewCfgAlistTable.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgAlistTable.setDescription('The table of IP route map access list in the current configuration block.')
ipNewCfgAlistEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 11, 6, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ipNewCfgAlistRmapIndex"), (0, "IBM-GbTOR-10G-L2L3-MIB", "ipNewCfgAlistIndex"))
if mibBuilder.loadTexts: ipNewCfgAlistEntry.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgAlistEntry.setDescription('Information about an IP route map.')
ipNewCfgAlistRmapIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 11, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipNewCfgAlistRmapIndex.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgAlistRmapIndex.setDescription('The route map number for which the RMAP is related.')
ipNewCfgAlistIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 11, 6, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipNewCfgAlistIndex.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgAlistIndex.setDescription('The access list number for which the access list is related.')
ipNewCfgAlistNwf = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 11, 6, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 256))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgAlistNwf.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgAlistNwf.setDescription('The network filter number of the route map access list. 0 means none')
ipNewCfgAlistMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 11, 6, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgAlistMetric.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgAlistMetric.setDescription('The metric of the route map access list. 4294967295 means none')
ipNewCfgAlistAction = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 11, 6, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("permit", 1), ("deny", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgAlistAction.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgAlistAction.setDescription('Action of the route map access list.')
ipNewCfgAlistState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 11, 6, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgAlistState.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgAlistState.setDescription('Enable or disable the route map access list.')
ipNewCfgAlistDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 11, 6, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("delete", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgAlistDelete.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgAlistDelete.setDescription('When set to the value of 2 (delete), the entire row is deleted. When read, other(1) is returned. Setting the value to anything other than 2(delete) has no effect on the state of the row.')
ipAspathTableMax = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 11, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipAspathTableMax.setStatus('current')
if mibBuilder.loadTexts: ipAspathTableMax.setDescription('The maximum number of rows in the IP route map table.')
ipCurCfgAspathTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 11, 8), )
if mibBuilder.loadTexts: ipCurCfgAspathTable.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgAspathTable.setDescription('The table of IP route map access path configuration.')
ipCurCfgAspathEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 11, 8, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ipCurCfgAspathRmapIndex"), (0, "IBM-GbTOR-10G-L2L3-MIB", "ipCurCfgAlistIndex"))
if mibBuilder.loadTexts: ipCurCfgAspathEntry.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgAspathEntry.setDescription('Information about an IP route map.')
ipCurCfgAspathRmapIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 11, 8, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgAspathRmapIndex.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgAspathRmapIndex.setDescription('The route map number for which the RMAP is related.')
ipCurCfgAspathIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 11, 8, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgAspathIndex.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgAspathIndex.setDescription('The access path number for which the access list is related.')
ipCurCfgAspathAS = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 11, 8, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgAspathAS.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgAspathAS.setDescription('The AS number of the route map access path. 0 means none')
ipCurCfgAspathAction = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 11, 8, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("permit", 1), ("deny", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgAspathAction.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgAspathAction.setDescription('Action of the route map access path.')
ipCurCfgAspathState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 11, 8, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgAspathState.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgAspathState.setDescription('Enable or disable the route map access path.')
ipNewCfgAspathTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 11, 9), )
if mibBuilder.loadTexts: ipNewCfgAspathTable.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgAspathTable.setDescription('The table of IP route map access path configuration')
ipNewCfgAspathEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 11, 9, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ipNewCfgAspathRmapIndex"), (0, "IBM-GbTOR-10G-L2L3-MIB", "ipNewCfgAspathIndex"))
if mibBuilder.loadTexts: ipNewCfgAspathEntry.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgAspathEntry.setDescription('Information about an IP route map.')
ipNewCfgAspathRmapIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 11, 9, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipNewCfgAspathRmapIndex.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgAspathRmapIndex.setDescription('The route map number for which the RMAP is related.')
ipNewCfgAspathIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 11, 9, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipNewCfgAspathIndex.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgAspathIndex.setDescription('The access path number for which the access list is related.')
ipNewCfgAspathAS = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 11, 9, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgAspathAS.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgAspathAS.setDescription('The AS number of the route map access path. 0 means none')
ipNewCfgAspathAction = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 11, 9, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("permit", 1), ("deny", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgAspathAction.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgAspathAction.setDescription('Action of the route map access path.')
ipNewCfgAspathState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 11, 9, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgAspathState.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgAspathState.setDescription('Enable or disable the route map access path.')
ipNewCfgAspathDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 11, 9, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("delete", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgAspathDelete.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgAspathDelete.setDescription('When set to the value of 2 (delete), the entire row is deleted. When read, other(1) is returned. Setting the value to anything other than 2(delete) has no effect on the state of the row.')
bgpGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 1))
bgpCurCfgState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgState.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgState.setDescription('BGP global state.')
bgpNewCfgState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bgpNewCfgState.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgState.setDescription('Globally turn BGP on or off.')
bgpCurCfgLocalPref = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967294))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgLocalPref.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgLocalPref.setDescription('Local preference value.')
bgpNewCfgLocalPref = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967294))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bgpNewCfgLocalPref.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgLocalPref.setDescription('Local Preference value.')
bgpCurCfgASNumber = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgASNumber.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgASNumber.setDescription('The autonomous system (AS) number.')
bgpNewCfgASNumber = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bgpNewCfgASNumber.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgASNumber.setDescription('The autonomous system (AS) number.')
bgpCurCfgEbgpMaxPaths = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967294))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgEbgpMaxPaths.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgEbgpMaxPaths.setDescription('Maximum eBGP Paths.')
bgpNewCfgEbgpMaxPaths = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967294))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bgpNewCfgEbgpMaxPaths.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgEbgpMaxPaths.setDescription('Maximum eBGP Paths.')
bgpCurCfgIbgpMaxPaths = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967294))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgIbgpMaxPaths.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgIbgpMaxPaths.setDescription('Maximum iBGP Paths.')
bgpNewCfgIbgpMaxPaths = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967294))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bgpNewCfgIbgpMaxPaths.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgIbgpMaxPaths.setDescription('Maximum iBGP Paths.')
bgpCurCfgAsn4Comp = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgAsn4Comp.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgAsn4Comp.setDescription('ASN4 to ASN2 compatibility.')
bgpNewCfgAsn4Comp = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bgpNewCfgAsn4Comp.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgAsn4Comp.setDescription('ASN4 to ASN2 compatibility.')
bgpCurCfgDscp = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgDscp.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgDscp.setDescription('BGP dscp marking value.')
bgpNewCfgDscp = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 63))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bgpNewCfgDscp.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgDscp.setDescription('BGP dscp marking value.')
bgpNewCfgClusterId = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 1, 15), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bgpNewCfgClusterId.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgClusterId.setDescription('Cluster ID.')
bgpCurCfgClusterId = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 1, 16), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgClusterId.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgClusterId.setDescription('Cluster ID.')
bgpNewCfgClientToClientReflection = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bgpNewCfgClientToClientReflection.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgClientToClientReflection.setDescription('Enable/disable client to client route reflection')
bgpCurCfgClientToClientReflection = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgClientToClientReflection.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgClientToClientReflection.setDescription('Enable/disable client to client route reflection')
bgpPeerTableMax = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpPeerTableMax.setStatus('current')
if mibBuilder.loadTexts: bgpPeerTableMax.setDescription('The maximum number of rows in the BGP peer table.')
bgpCurCfgPeerTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 3), )
if mibBuilder.loadTexts: bgpCurCfgPeerTable.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgPeerTable.setDescription('The table of BGP peer in the current configuration block.')
bgpCurCfgPeerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 3, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "bgpCurCfgPeerIndex"))
if mibBuilder.loadTexts: bgpCurCfgPeerEntry.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgPeerEntry.setDescription('Information about a BGP peer.')
bgpCurCfgPeerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgPeerIndex.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgPeerIndex.setDescription('The BGP peer number for which the BGP peer table is related.')
bgpCurCfgPeerRemoteAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 3, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgPeerRemoteAddr.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgPeerRemoteAddr.setDescription('The remote IP address of the BGP peer.')
bgpCurCfgPeerRemoteAs = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgPeerRemoteAs.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgPeerRemoteAs.setDescription('The remote AS number of the BGP peer. 0 means none')
bgpCurCfgPeerTtl = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgPeerTtl.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgPeerTtl.setDescription('The time-to-live value of the BGP peer IP datagram. 0 means none.')
bgpCurCfgPeerState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgPeerState.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgPeerState.setDescription('Enable or disable the peer.')
bgpCurCfgPeerMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 3, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967294))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgPeerMetric.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgPeerMetric.setDescription("The metric value of the BGP peer. A value of '0' means none")
bgpCurCfgPeerDefaultAction = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 3, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("import", 2), ("originate", 3), ("redistribute", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgPeerDefaultAction.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgPeerDefaultAction.setDescription('The value of default route action.')
bgpCurCfgPeerOspfState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 3, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgPeerOspfState.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgPeerOspfState.setDescription('Enable or disable advertising OSPF routes.')
bgpCurCfgPeerFixedState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 3, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgPeerFixedState.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgPeerFixedState.setDescription('Enable or disable advertising fixed routes.')
bgpCurCfgPeerStaticState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 3, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgPeerStaticState.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgPeerStaticState.setDescription('Enable or disable advertising static routes.')
bgpCurCfgPeerInRmapList = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 3, 1, 16), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgPeerInRmapList.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgPeerInRmapList.setDescription('The route maps present in the in route map list. The route maps are presented in a bitmap format. in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ Rmap 9 || || || ||___ Rmap 8 || |____ Rmap 7 || . . . ||_________ Rmap 2 |__________ Rmap 1 where x : 1 - The represented route map is selected 0 - The represented route map is not selected')
bgpCurCfgPeerOutRmapList = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 3, 1, 17), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgPeerOutRmapList.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgPeerOutRmapList.setDescription('The route maps present in the out route map list. The route maps are presented in a bitmap format. in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ Rmap 9 || || || ||___ Rmap 8 || |____ Rmap 7 || . . . ||_________ Rmap 2 |__________ Rmap 1 where x : 1 - The represented route map is selected 0 - The represented route map is not selected')
bgpCurCfgPeerHold = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 3, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgPeerHold.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgPeerHold.setDescription('The hold time')
bgpCurCfgPeerAlive = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 3, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 21845))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgPeerAlive.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgPeerAlive.setDescription('The keep alive time')
bgpCurCfgPeerAdvert = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 3, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgPeerAdvert.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgPeerAdvert.setDescription('The min time between advertisements')
bgpCurCfgPeerRetry = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 3, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgPeerRetry.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgPeerRetry.setDescription('The connect retry interval')
bgpCurCfgPeerOrig = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 3, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgPeerOrig.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgPeerOrig.setDescription('The min time between route originations')
bgpCurCfgPeerRipState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 3, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgPeerRipState.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgPeerRipState.setDescription('Enable/disable advertising RIP routes')
bgpCurCfgPeerPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 3, 1, 24), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgPeerPassword.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgPeerPassword.setDescription('Peer BGP password')
bgpCurCfgPeerPassive = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 3, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgPeerPassive.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgPeerPassive.setDescription('Enable/disable BGP passive peer')
bgpCurCfgPeerUpdateSrcIf = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 3, 1, 30), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgPeerUpdateSrcIf.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgPeerUpdateSrcIf.setDescription('BGP peer update source interface index')
bgpCurCfgPeerUpdateSrcLoopIf = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 3, 1, 31), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgPeerUpdateSrcLoopIf.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgPeerUpdateSrcLoopIf.setDescription('BGP peer update source loopback interface index')
bgpCurCfgPeerTtlSecHops = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 3, 1, 32), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 254))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgPeerTtlSecHops.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgPeerTtlSecHops.setDescription('The BGP ttl security hops. 0 means none.')
bgpCurCfgPeerNexthopSelf = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 3, 1, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgPeerNexthopSelf.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgPeerNexthopSelf.setDescription('Enable/Disable using this router as next-hop in BGP updates.')
bgpCurCfgPeerClient = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 3, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgPeerClient.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgPeerClient.setDescription('Enable/disable BGP client peer')
bgpNewCfgPeerTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 4), )
if mibBuilder.loadTexts: bgpNewCfgPeerTable.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgPeerTable.setDescription('The table of BGP peer in the new configuration block.')
bgpNewCfgPeerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 4, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "bgpNewCfgPeerIndex"))
if mibBuilder.loadTexts: bgpNewCfgPeerEntry.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgPeerEntry.setDescription('Information about a BGP peer.')
bgpNewCfgPeerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpNewCfgPeerIndex.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgPeerIndex.setDescription('The BGP peer number for which the BGP peer table is related.')
bgpNewCfgPeerRemoteAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 4, 1, 2), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bgpNewCfgPeerRemoteAddr.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgPeerRemoteAddr.setDescription('The remote IP address of the BGP peer.')
bgpNewCfgPeerRemoteAs = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bgpNewCfgPeerRemoteAs.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgPeerRemoteAs.setDescription('The remote AS number of the BGP peer. 0 means none')
bgpNewCfgPeerTtl = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bgpNewCfgPeerTtl.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgPeerTtl.setDescription('The time-to-live value of the BGP peer IP datagram. 0 means none.')
bgpNewCfgPeerState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bgpNewCfgPeerState.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgPeerState.setDescription('Enable or disable the peer.')
bgpNewCfgPeerDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 4, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("delete", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bgpNewCfgPeerDelete.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgPeerDelete.setDescription('When set to the value of 2 (delete), the entire row is deleted. When read, other(1) is returned. Setting the value to anything other than 2(delete) has no effect on the state of the row.')
bgpNewCfgPeerMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 4, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967294))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bgpNewCfgPeerMetric.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgPeerMetric.setDescription("The metric value of the BGP peer. A value of '0' means none")
bgpNewCfgPeerDefaultAction = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 4, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("import", 2), ("originate", 3), ("redistribute", 4)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bgpNewCfgPeerDefaultAction.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgPeerDefaultAction.setDescription('The value of default route action.')
bgpNewCfgPeerOspfState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 4, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bgpNewCfgPeerOspfState.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgPeerOspfState.setDescription('Enable or disable advertising OSPF routes.')
bgpNewCfgPeerFixedState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 4, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bgpNewCfgPeerFixedState.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgPeerFixedState.setDescription('Enable or disable advertising fixed routes.')
bgpNewCfgPeerStaticState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 4, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bgpNewCfgPeerStaticState.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgPeerStaticState.setDescription('Enable or disable advertising static routes.')
bgpNewCfgPeerInRmapList = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 4, 1, 16), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpNewCfgPeerInRmapList.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgPeerInRmapList.setDescription('The route maps present in the in route map list. The route maps are presented in a bitmap format. in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ Rmap 9 || || || ||___ Rmap 8 || |____ Rmap 7 || . . . ||_________ Rmap 2 |__________ Rmap 1 where x : 1 - The represented route map is selected 0 - The represented route map is not selected')
bgpNewCfgPeerOutRmapList = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 4, 1, 17), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpNewCfgPeerOutRmapList.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgPeerOutRmapList.setDescription('The route maps present in the out route map list. The route maps are presented in a bitmap format. in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ Rmap 9 || || || ||___ Rmap 8 || |____ Rmap 7 || . . . ||_________ Rmap 2 |__________ Rmap 1 where x : 1 - The represented route map is selected 0 - The represented route map is not selected')
bgpNewCfgPeerAddInRmap = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 4, 1, 18), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bgpNewCfgPeerAddInRmap.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgPeerAddInRmap.setDescription('The route map to be add into in-rmap list. When read, 0 is returned.')
bgpNewCfgPeerAddOutRmap = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 4, 1, 19), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bgpNewCfgPeerAddOutRmap.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgPeerAddOutRmap.setDescription('The route map to be add into out-rmap list. When read, 0 is returned.')
bgpNewCfgPeerRemoveInRmap = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 4, 1, 20), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bgpNewCfgPeerRemoveInRmap.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgPeerRemoveInRmap.setDescription('The route map to be removed from out-rmap list. When read, 0 is returned.')
bgpNewCfgPeerRemoveOutRmap = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 4, 1, 21), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bgpNewCfgPeerRemoveOutRmap.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgPeerRemoveOutRmap.setDescription('The route map to be removed from out-rmap list. When read, 0 is returned.')
bgpNewCfgPeerHold = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 4, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bgpNewCfgPeerHold.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgPeerHold.setDescription('The hold time')
bgpNewCfgPeerAlive = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 4, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 21845))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bgpNewCfgPeerAlive.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgPeerAlive.setDescription('The keep alive time')
bgpNewCfgPeerAdvert = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 4, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bgpNewCfgPeerAdvert.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgPeerAdvert.setDescription('The min time between advertisements')
bgpNewCfgPeerRetry = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 4, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bgpNewCfgPeerRetry.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgPeerRetry.setDescription('The connect retry interval')
bgpNewCfgPeerOrig = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 4, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bgpNewCfgPeerOrig.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgPeerOrig.setDescription('The min time between route originations')
bgpNewCfgPeerRipState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 4, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bgpNewCfgPeerRipState.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgPeerRipState.setDescription('Enable/disable advertising RIP routes')
bgpNewCfgPeerPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 4, 1, 28), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bgpNewCfgPeerPassword.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgPeerPassword.setDescription('Peer BGP password')
bgpNewCfgPeerPassive = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 4, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bgpNewCfgPeerPassive.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgPeerPassive.setDescription('Enable/disable BGP passive peer')
bgpNewCfgPeerUpdateSrcIf = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 4, 1, 30), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bgpNewCfgPeerUpdateSrcIf.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgPeerUpdateSrcIf.setDescription('BGP peer update source interface index')
bgpNewCfgPeerUpdateSrcLoopIf = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 4, 1, 31), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bgpNewCfgPeerUpdateSrcLoopIf.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgPeerUpdateSrcLoopIf.setDescription('BGP peer update source loopback interface index')
bgpNewCfgPeerTtlSecHops = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 4, 1, 32), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 254))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bgpNewCfgPeerTtlSecHops.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgPeerTtlSecHops.setDescription('The BGP ttl security hops. 0 means none.')
bgpNewCfgPeerNexthopSelf = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 4, 1, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bgpNewCfgPeerNexthopSelf.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgPeerNexthopSelf.setDescription('Enable/Disable using this router as next-hop in BGP updates.')
bgpNewCfgPeerClient = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 4, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bgpNewCfgPeerClient.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgPeerClient.setDescription('Enable/disable BGP client peer')
bgpAggrTableMax = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpAggrTableMax.setStatus('current')
if mibBuilder.loadTexts: bgpAggrTableMax.setDescription('The maximum number of rows in the BGP aggregation table.')
bgpCurCfgAggrTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 6), )
if mibBuilder.loadTexts: bgpCurCfgAggrTable.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgAggrTable.setDescription('The table of BGP aggregation configuration.')
bgpCurCfgAggrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 6, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "bgpCurCfgAggrIndex"))
if mibBuilder.loadTexts: bgpCurCfgAggrEntry.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgAggrEntry.setDescription('Information about a BGP aggregation.')
bgpCurCfgAggrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgAggrIndex.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgAggrIndex.setDescription('The aggregation number for which the BGP aggregation is related.')
bgpCurCfgAggrAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 6, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgAggrAddr.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgAggrAddr.setDescription('The IP address of the BGP aggregation.')
bgpCurCfgAggrMask = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 6, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgAggrMask.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgAggrMask.setDescription('The subnet mask of the BGP aggregation.')
bgpCurCfgAggrState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 6, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgAggrState.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgAggrState.setDescription('Enable or disable the BGP aggregation.')
bgpNewCfgAggrTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 7), )
if mibBuilder.loadTexts: bgpNewCfgAggrTable.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgAggrTable.setDescription('The table of BGP aggregation configuration.')
bgpNewCfgAggrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 7, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "bgpNewCfgAggrIndex"))
if mibBuilder.loadTexts: bgpNewCfgAggrEntry.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgAggrEntry.setDescription('Information about an BGP aggregation.')
bgpNewCfgAggrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 7, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpNewCfgAggrIndex.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgAggrIndex.setDescription('The aggregation number for which the BGP aggregation is related.')
bgpNewCfgAggrAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 7, 1, 2), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bgpNewCfgAggrAddr.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgAggrAddr.setDescription('The IP address of the BGP aggregation.')
bgpNewCfgAggrMask = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 7, 1, 3), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bgpNewCfgAggrMask.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgAggrMask.setDescription('The subnet mask of the BGP aggregation.')
bgpNewCfgAggrState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 7, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bgpNewCfgAggrState.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgAggrState.setDescription('Enable or disable the BGP aggregation.')
bgpNewCfgAggrDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 7, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("delete", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bgpNewCfgAggrDelete.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgAggrDelete.setDescription('When set to the value of 2 (delete), the entire row is deleted. When read, other(1) is returned. Setting the value to anything other than 2(delete) has no effect on the state of the row.')
bgpGroupTableMax = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpGroupTableMax.setStatus('current')
if mibBuilder.loadTexts: bgpGroupTableMax.setDescription('The maximum number of groups in the BGP groups table.')
bgpCurCfgGroupTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 9), )
if mibBuilder.loadTexts: bgpCurCfgGroupTable.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgGroupTable.setDescription('The table of BGP group in the current configuration block.')
bgpCurCfgGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 9, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "bgpCurCfgGroupIndex"))
if mibBuilder.loadTexts: bgpCurCfgGroupEntry.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgGroupEntry.setDescription('Information about a BGP group.')
bgpCurCfgGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 9, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgGroupIndex.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgGroupIndex.setDescription('The BGP group number for which the BGP group table is related.')
bgpCurCfgGroupName = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 9, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgGroupName.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgGroupName.setDescription('The group name.')
bgpCurCfgGroupRemoteAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 9, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgGroupRemoteAddr.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgGroupRemoteAddr.setDescription('The IP address of the BGP group.')
bgpCurCfgGroupRemoteMask = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 9, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgGroupRemoteMask.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgGroupRemoteMask.setDescription('The subnet mask of the BGP group.')
bgpCurCfgGroupLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 9, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 96))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgGroupLimit.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgGroupLimit.setDescription(' The maximum number of BGP dynamic peers.')
bgpCurCfgGroupUpdateSrcIf = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 9, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgGroupUpdateSrcIf.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgGroupUpdateSrcIf.setDescription('BGP group update source interface index')
bgpCurCfgGroupUpdateSrcLoopIf = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 9, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgGroupUpdateSrcLoopIf.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgGroupUpdateSrcLoopIf.setDescription('BGP group update source loopback interface index')
bgpCurCfgGroupHold = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 9, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgGroupHold.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgGroupHold.setDescription('The hold time')
bgpCurCfgGroupAlive = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 9, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 21845))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgGroupAlive.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgGroupAlive.setDescription('The keep alive time')
bgpCurCfgGroupAdvert = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 9, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgGroupAdvert.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgGroupAdvert.setDescription('The min time between advertisements')
bgpCurCfgGroupOrig = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 9, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgGroupOrig.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgGroupOrig.setDescription('The min time between route originations')
bgpCurCfgGroupMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 9, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967294))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgGroupMetric.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgGroupMetric.setDescription("The metric value of the BGP group. A value of '0' means none")
bgpCurCfgGroupTtl = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 9, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgGroupTtl.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgGroupTtl.setDescription('The time-to-live value of the BGP peer IP datagram. 0 means none.')
bgpCurCfgGroupDefaultAction = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 9, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("import", 2), ("originate", 3), ("redistribute", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgGroupDefaultAction.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgGroupDefaultAction.setDescription('The value of default route action.')
bgpCurCfgGroupOspfState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 9, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgGroupOspfState.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgGroupOspfState.setDescription('Enable or disable advertising OSPF routes.')
bgpCurCfgGroupRipState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 9, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgGroupRipState.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgGroupRipState.setDescription('Enable/disable advertising RIP routes')
bgpCurCfgGroupFixedState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 9, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgGroupFixedState.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgGroupFixedState.setDescription('Enable or disable advertising fixed routes.')
bgpCurCfgGroupStaticState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 9, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgGroupStaticState.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgGroupStaticState.setDescription('Enable or disable advertising static routes.')
bgpCurCfgGroupInRmapList = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 9, 1, 19), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgGroupInRmapList.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgGroupInRmapList.setDescription('The route maps present in the in route map list. The route maps are presented in a bitmap format. in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ Rmap 9 || || || ||___ Rmap 8 || |____ Rmap 7 || . . . ||_________ Rmap 2 |__________ Rmap 1 where x : 1 - The represented route map is selected 0 - The represented route map is not selected')
bgpCurCfgGroupOutRmapList = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 9, 1, 20), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgGroupOutRmapList.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgGroupOutRmapList.setDescription('The route maps present in the out route map list. The route maps are presented in a bitmap format. in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ Rmap 9 || || || ||___ Rmap 8 || |____ Rmap 7 || . . . ||_________ Rmap 2 |__________ Rmap 1 where x : 1 - The represented route map is selected 0 - The represented route map is not selected')
bgpCurCfgGroupPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 9, 1, 21), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgGroupPassword.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgGroupPassword.setDescription('Peer BGP password')
bgpCurCfgGroupState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 9, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgGroupState.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgGroupState.setDescription('Enable or disable the group.')
bgpCurCfgGroupTtlSecHops = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 9, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 254))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgGroupTtlSecHops.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgGroupTtlSecHops.setDescription('The BGP ttl security hops. 0 means none.')
bgpCurCfgGroupNexthopSelf = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 9, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgGroupNexthopSelf.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgGroupNexthopSelf.setDescription('Enable/Disable using this router as next-hop in BGP updates.')
bgpCurCfgGroupClient = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 9, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgGroupClient.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgGroupClient.setDescription('Enable/Disable Route Reflector for this client.')
bgpNewCfgGroupTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 10), )
if mibBuilder.loadTexts: bgpNewCfgGroupTable.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgGroupTable.setDescription('The table of BGP group in the new configuration block.')
bgpNewCfgGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 10, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "bgpNewCfgGroupIndex"))
if mibBuilder.loadTexts: bgpNewCfgGroupEntry.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgGroupEntry.setDescription('Information about a BGP group.')
bgpNewCfgGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 10, 1, 1), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bgpNewCfgGroupIndex.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgGroupIndex.setDescription('The BGP group number for which the BGP group table is related.')
bgpNewCfgGroupName = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 10, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bgpNewCfgGroupName.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgGroupName.setDescription('The group name.')
bgpNewCfgGroupRemoteAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 10, 1, 3), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bgpNewCfgGroupRemoteAddr.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgGroupRemoteAddr.setDescription('The IP address of the BGP group.')
bgpNewCfgGroupRemoteMask = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 10, 1, 4), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bgpNewCfgGroupRemoteMask.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgGroupRemoteMask.setDescription('The subnet mask of the BGP group.')
bgpNewCfgGroupLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 10, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 96))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bgpNewCfgGroupLimit.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgGroupLimit.setDescription(' The maximum number of BGP dynamic peers.')
bgpNewCfgGroupUpdateSrcIf = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 10, 1, 6), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bgpNewCfgGroupUpdateSrcIf.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgGroupUpdateSrcIf.setDescription('BGP group update source interface index')
bgpNewCfgGroupUpdateSrcLoopIf = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 10, 1, 7), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bgpNewCfgGroupUpdateSrcLoopIf.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgGroupUpdateSrcLoopIf.setDescription('BGP group update source loopback interface index')
bgpNewCfgGroupHold = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 10, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bgpNewCfgGroupHold.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgGroupHold.setDescription('The hold time')
bgpNewCfgGroupAlive = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 10, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 21845))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bgpNewCfgGroupAlive.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgGroupAlive.setDescription('The keep alive time')
bgpNewCfgGroupAdvert = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 10, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bgpNewCfgGroupAdvert.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgGroupAdvert.setDescription('The min time between advertisements')
bgpNewCfgGroupOrig = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 10, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bgpNewCfgGroupOrig.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgGroupOrig.setDescription('The min time between route originations')
bgpNewCfgGroupMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 10, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967294))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bgpNewCfgGroupMetric.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgGroupMetric.setDescription("The metric value of the BGP group. A value of '0' means none")
bgpNewCfgGroupTtl = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 10, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bgpNewCfgGroupTtl.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgGroupTtl.setDescription('The time-to-live value of the BGP peer IP datagram. 0 means none.')
bgpNewCfgGroupDefaultAction = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 10, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("import", 2), ("originate", 3), ("redistribute", 4)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bgpNewCfgGroupDefaultAction.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgGroupDefaultAction.setDescription('The value of default route action.')
bgpNewCfgGroupOspfState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 10, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bgpNewCfgGroupOspfState.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgGroupOspfState.setDescription('Enable or disable advertising OSPF routes.')
bgpNewCfgGroupRipState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 10, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bgpNewCfgGroupRipState.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgGroupRipState.setDescription('Enable/disable advertising RIP routes')
bgpNewCfgGroupFixedState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 10, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bgpNewCfgGroupFixedState.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgGroupFixedState.setDescription('Enable or disable advertising fixed routes.')
bgpNewCfgGroupStaticState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 10, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bgpNewCfgGroupStaticState.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgGroupStaticState.setDescription('Enable or disable advertising static routes.')
bgpNewCfgGroupInRmapList = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 10, 1, 19), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpNewCfgGroupInRmapList.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgGroupInRmapList.setDescription('The route maps present in the in route map list. The route maps are presented in a bitmap format. in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ Rmap 9 || || || ||___ Rmap 8 || |____ Rmap 7 || . . . ||_________ Rmap 2 |__________ Rmap 1 where x : 1 - The represented route map is selected 0 - The represented route map is not selected')
bgpNewCfgGroupOutRmapList = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 10, 1, 20), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpNewCfgGroupOutRmapList.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgGroupOutRmapList.setDescription('The route maps present in the out route map list. The route maps are presented in a bitmap format. in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ Rmap 9 || || || ||___ Rmap 8 || |____ Rmap 7 || . . . ||_________ Rmap 2 |__________ Rmap 1 where x : 1 - The represented route map is selected 0 - The represented route map is not selected')
bgpNewCfgGroupAddInRmap = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 10, 1, 21), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bgpNewCfgGroupAddInRmap.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgGroupAddInRmap.setDescription('The route map to be add into in-rmap list. When read, 0 is returned.')
bgpNewCfgGroupAddOutRmap = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 10, 1, 22), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bgpNewCfgGroupAddOutRmap.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgGroupAddOutRmap.setDescription('The route map to be add into out-rmap list. When read, 0 is returned.')
bgpNewCfgGroupRemoveInRmap = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 10, 1, 23), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bgpNewCfgGroupRemoveInRmap.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgGroupRemoveInRmap.setDescription('The route map to be removed from out-rmap list. When read, 0 is returned.')
bgpNewCfgGroupRemoveOutRmap = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 10, 1, 24), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bgpNewCfgGroupRemoveOutRmap.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgGroupRemoveOutRmap.setDescription('The route map to be removed from out-rmap list. When read, 0 is returned.')
bgpNewCfgGroupPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 10, 1, 25), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bgpNewCfgGroupPassword.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgGroupPassword.setDescription('Peer BGP password')
bgpNewCfgGroupDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 10, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("delete", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bgpNewCfgGroupDelete.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgGroupDelete.setDescription('When set to the value of 2 (delete), the entire row is deleted. When read, other(1) is returned. Setting the value to anything other than 2(delete) has no effect on the state of the row.')
bgpNewCfgGroupState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 10, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bgpNewCfgGroupState.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgGroupState.setDescription('Enable or disable the group.')
bgpNewCfgGroupTtlSecHops = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 10, 1, 28), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 254))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bgpNewCfgGroupTtlSecHops.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgGroupTtlSecHops.setDescription('The BGP ttl security hops. 0 means none.')
bgpNewCfgGroupNexthopSelf = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 10, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bgpNewCfgGroupNexthopSelf.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgGroupNexthopSelf.setDescription('Enable/Disable using this router as next-hop in BGP updates.')
bgpNewCfgGroupClient = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 10, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bgpNewCfgGroupClient.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgGroupClient.setDescription('Enable/Disable Route Reflector for this client.')
bgpCurCfgGroupRASTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 11), )
if mibBuilder.loadTexts: bgpCurCfgGroupRASTable.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgGroupRASTable.setDescription('The table of BGP group RASs in the current configuration block.')
bgpCurCfgGroupRASEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 11, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "bgpCurCfgGroupIndex"), (0, "IBM-GbTOR-10G-L2L3-MIB", "bgpCurCfgGroupRASIndex"))
if mibBuilder.loadTexts: bgpCurCfgGroupRASEntry.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgGroupRASEntry.setDescription('Information about a BGP group RAS.')
bgpCurCfgGroupRASIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 11, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgGroupRASIndex.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgGroupRASIndex.setDescription('The BGP remote-as number for which the BGP RAS table is related.')
bgpCurCfgGroupRAS = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 11, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgGroupRAS.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgGroupRAS.setDescription('The remote AS number of the BGP group bgpCurCfgGroupIndex. 0 means none')
bgpNewCfgGroupRASTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 12), )
if mibBuilder.loadTexts: bgpNewCfgGroupRASTable.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgGroupRASTable.setDescription('The table of BGP group RASs in the new configuration block.')
bgpNewCfgGroupRASEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 12, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "bgpNewCfgGroupIndex"), (0, "IBM-GbTOR-10G-L2L3-MIB", "bgpNewCfgGroupRASIndex"))
if mibBuilder.loadTexts: bgpNewCfgGroupRASEntry.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgGroupRASEntry.setDescription('Information about a BGP group RAS.')
bgpNewCfgGroupRASIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 12, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpNewCfgGroupRASIndex.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgGroupRASIndex.setDescription('The BGP group RAS number for which the BGP group RASs table is related.')
bgpNewCfgGroupRAS = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 12, 12, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bgpNewCfgGroupRAS.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgGroupRAS.setDescription('The remote AS number of the BGP group bgpNewCfgGroupIndex. 0 means none')
bgpInfoGroupTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 11, 4), )
if mibBuilder.loadTexts: bgpInfoGroupTable.setStatus('current')
if mibBuilder.loadTexts: bgpInfoGroupTable.setDescription('The table of BGP group in the current configuration block.')
bgpInfoGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 11, 4, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "bgpInfoGroupIndex"))
if mibBuilder.loadTexts: bgpInfoGroupEntry.setStatus('current')
if mibBuilder.loadTexts: bgpInfoGroupEntry.setDescription('Information about a BGP group.')
bgpInfoGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 11, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpInfoGroupIndex.setStatus('current')
if mibBuilder.loadTexts: bgpInfoGroupIndex.setDescription('The BGP group number for which the BGP group table is related.')
bgpInfoGroupName = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 11, 4, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpInfoGroupName.setStatus('current')
if mibBuilder.loadTexts: bgpInfoGroupName.setDescription('The BGP group nname for which the BGP group table is related.')
bgpInfoGroupRemoteAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 11, 4, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpInfoGroupRemoteAddr.setStatus('current')
if mibBuilder.loadTexts: bgpInfoGroupRemoteAddr.setDescription('The remote IP address of the BGP group.')
bgpInfoGroupRemoteMask = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 11, 4, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpInfoGroupRemoteMask.setStatus('current')
if mibBuilder.loadTexts: bgpInfoGroupRemoteMask.setDescription('The remote mask of the BGP group.')
bgpInfoGroupLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 11, 4, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpInfoGroupLimit.setStatus('current')
if mibBuilder.loadTexts: bgpInfoGroupLimit.setDescription('The maximum number of BGP dynamic peers.')
bgpInfoGroupPeersNum = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 11, 4, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpInfoGroupPeersNum.setStatus('current')
if mibBuilder.loadTexts: bgpInfoGroupPeersNum.setDescription('The total number of BGP dynamic peers.')
bgpInfoGroupState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 11, 4, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpInfoGroupState.setStatus('current')
if mibBuilder.loadTexts: bgpInfoGroupState.setDescription('BGP group state.')
bgpInfoGroupRASTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 11, 5), )
if mibBuilder.loadTexts: bgpInfoGroupRASTable.setStatus('current')
if mibBuilder.loadTexts: bgpInfoGroupRASTable.setDescription('The table of BGP group RASs in the current configuration block.')
bgpInfoGroupRASEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 11, 5, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "bgpInfoGroupIndex"), (0, "IBM-GbTOR-10G-L2L3-MIB", "bgpInfoGroupRASIndex"))
if mibBuilder.loadTexts: bgpInfoGroupRASEntry.setStatus('current')
if mibBuilder.loadTexts: bgpInfoGroupRASEntry.setDescription('Information about a BGP group RAS.')
bgpInfoGroupRASIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 11, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpInfoGroupRASIndex.setStatus('current')
if mibBuilder.loadTexts: bgpInfoGroupRASIndex.setDescription('The BGP group RAS number for which the BGP group RAS table is related.')
bgpInfoGroupRAS = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 11, 5, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpInfoGroupRAS.setStatus('current')
if mibBuilder.loadTexts: bgpInfoGroupRAS.setDescription('The remote AS number of the BGP group bgpInfoGroupIndex.')
bgpInfoDynamicPeerTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 11, 6), )
if mibBuilder.loadTexts: bgpInfoDynamicPeerTable.setStatus('current')
if mibBuilder.loadTexts: bgpInfoDynamicPeerTable.setDescription('The table of BGP dynamic peers.')
bgpInfoDynamicPeerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 11, 6, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "bgpInfoDynamicPeerIndex"))
if mibBuilder.loadTexts: bgpInfoDynamicPeerEntry.setStatus('current')
if mibBuilder.loadTexts: bgpInfoDynamicPeerEntry.setDescription('Information about a BGP dynamic peer.')
bgpInfoDynamicPeerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 11, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpInfoDynamicPeerIndex.setStatus('current')
if mibBuilder.loadTexts: bgpInfoDynamicPeerIndex.setDescription('The BGP dynamic peer number for which the BGP peer table is related.')
bgpInfoDynamicPeerRemoteAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 11, 6, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpInfoDynamicPeerRemoteAddr.setStatus('current')
if mibBuilder.loadTexts: bgpInfoDynamicPeerRemoteAddr.setDescription('The remote IP address of the BGP dynamic peer.')
bgpInfoDynamicPeerGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 11, 6, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpInfoDynamicPeerGroup.setStatus('current')
if mibBuilder.loadTexts: bgpInfoDynamicPeerGroup.setDescription('The group of BGP dynamic peer.')
bgpInfoDynamicPeerVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 11, 6, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpInfoDynamicPeerVersion.setStatus('current')
if mibBuilder.loadTexts: bgpInfoDynamicPeerVersion.setDescription('The version negotiated by the BGP dynamic peer.')
bgpInfoDynamicPeerTtl = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 11, 6, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpInfoDynamicPeerTtl.setStatus('current')
if mibBuilder.loadTexts: bgpInfoDynamicPeerTtl.setDescription('The time-to-live value of the BGP dynamic peer IP datagram.')
bgpInfoDynamicPeerRemoteAs = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 11, 6, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpInfoDynamicPeerRemoteAs.setStatus('current')
if mibBuilder.loadTexts: bgpInfoDynamicPeerRemoteAs.setDescription('The remote AS number of the BGP dynamic peer.')
bgpInfoDynamicPeerRouterId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 11, 6, 1, 7), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpInfoDynamicPeerRouterId.setStatus('current')
if mibBuilder.loadTexts: bgpInfoDynamicPeerRouterId.setDescription('The router IP address.')
bgpInfoDynamicTotalReceivedPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 11, 6, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpInfoDynamicTotalReceivedPackets.setStatus('current')
if mibBuilder.loadTexts: bgpInfoDynamicTotalReceivedPackets.setDescription('The total number of received packets.')
bgpInfoDynamicTotalSentPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 11, 6, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpInfoDynamicTotalSentPackets.setStatus('current')
if mibBuilder.loadTexts: bgpInfoDynamicTotalSentPackets.setDescription('The total number of sent packets.')
bgpInfoDynamicReceivedUpdates = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 11, 6, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpInfoDynamicReceivedUpdates.setStatus('current')
if mibBuilder.loadTexts: bgpInfoDynamicReceivedUpdates.setDescription('The number of received updates.')
bgpInfoDynamicSentUpdates = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 11, 6, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpInfoDynamicSentUpdates.setStatus('current')
if mibBuilder.loadTexts: bgpInfoDynamicSentUpdates.setDescription('The number of sent updates.')
bgpInfoDynamicKeepalive = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 11, 6, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpInfoDynamicKeepalive.setStatus('current')
if mibBuilder.loadTexts: bgpInfoDynamicKeepalive.setDescription('The keep alive time.')
bgpInfoDynamicHoldtime = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 11, 6, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpInfoDynamicHoldtime.setStatus('current')
if mibBuilder.loadTexts: bgpInfoDynamicHoldtime.setDescription('The hold time.')
bgpInfoDynamicMinAdvTime = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 11, 6, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpInfoDynamicMinAdvTime.setStatus('current')
if mibBuilder.loadTexts: bgpInfoDynamicMinAdvTime.setDescription('The MinAdvTime.')
ospfGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 1))
ospfCurCfgDefaultRouteMetric = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777214))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgDefaultRouteMetric.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgDefaultRouteMetric.setDescription('Specify the metric to be assigned.')
ospfNewCfgDefaultRouteMetric = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777214))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospfNewCfgDefaultRouteMetric.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgDefaultRouteMetric.setDescription('Specify the metric to be assigned.')
ospfCurCfgDefaultRouteMetricType = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("type1", 2), ("type2", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgDefaultRouteMetricType.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgDefaultRouteMetricType.setDescription('Specify the AS External metric type to be assigned.')
ospfNewCfgDefaultRouteMetricType = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("type1", 2), ("type2", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospfNewCfgDefaultRouteMetricType.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgDefaultRouteMetricType.setDescription('Specify the AS External metric type to be assigned.')
ospfIntfTableMaxSize = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfTableMaxSize.setStatus('current')
if mibBuilder.loadTexts: ospfIntfTableMaxSize.setDescription('The maximum number of rows in the OSPF Interface table.')
ospfAreaTableMaxSize = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaTableMaxSize.setStatus('current')
if mibBuilder.loadTexts: ospfAreaTableMaxSize.setDescription('The maximum number of rows in the OSPF Area table.')
ospfRangeTableMaxSize = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfRangeTableMaxSize.setStatus('current')
if mibBuilder.loadTexts: ospfRangeTableMaxSize.setDescription('The maximum number of rows in the OSPF Range table.')
ospfVirtIntfTableMaxSize = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfVirtIntfTableMaxSize.setStatus('current')
if mibBuilder.loadTexts: ospfVirtIntfTableMaxSize.setDescription('The maximum number of rows in the OSPF Virtual Interface table.')
ospfHostTableMaxSize = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfHostTableMaxSize.setStatus('current')
if mibBuilder.loadTexts: ospfHostTableMaxSize.setDescription('The maximum number of rows in the OSPF Host table.')
ospfCurCfgState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgState.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgState.setDescription('OSPF global state.')
ospfNewCfgState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospfNewCfgState.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgState.setDescription('Globally turn OSPF on or off.')
ospfCurCfgLSDB = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgLSDB.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgLSDB.setDescription('The LSDB limit for external LSA.')
ospfNewCfgLSDB = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 1, 13), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospfNewCfgLSDB.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgLSDB.setDescription('Set the LSDB limit for external LSA.')
ospfCurCfgAreaTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 2), )
if mibBuilder.loadTexts: ospfCurCfgAreaTable.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgAreaTable.setDescription('The table of OSPF area in the current configuration block.')
ospfCurCfgAreaEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 2, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ospfCurCfgAreaIndex"))
if mibBuilder.loadTexts: ospfCurCfgAreaEntry.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgAreaEntry.setDescription('Information about a OSPF area.')
ospfCurCfgAreaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgAreaIndex.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgAreaIndex.setDescription('The OSPF area number for which the OSPF area table is related.')
ospfCurCfgAreaId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 2, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgAreaId.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgAreaId.setDescription('The IP Address of the OSPF area.')
ospfCurCfgAreaSpfInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgAreaSpfInterval.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgAreaSpfInterval.setDescription('The SPF interval for the OSPF area.')
ospfCurCfgAreaAuthType = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("password", 2), ("md5", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgAreaAuthType.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgAreaAuthType.setDescription('Type of authentication being used. none(1) - no authentication password(2) - use password md5(3) - use MD5 authentication.')
ospfCurCfgAreaType = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("transit", 0), ("stub", 1), ("nssa", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgAreaType.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgAreaType.setDescription('Type of Area. transit(0) stub(1) nssa(2)')
ospfCurCfgAreaMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgAreaMetric.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgAreaMetric.setDescription('Metric (1-65535)')
ospfCurCfgAreaStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgAreaStatus.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgAreaStatus.setDescription('Status disabled(0) enabled(1)')
ospfNewCfgAreaTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 3), )
if mibBuilder.loadTexts: ospfNewCfgAreaTable.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgAreaTable.setDescription('The table of OSPF area in the new configuration block.')
ospfNewCfgAreaEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 3, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ospfNewCfgAreaIndex"))
if mibBuilder.loadTexts: ospfNewCfgAreaEntry.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgAreaEntry.setDescription('Information about a OSPF area.')
ospfNewCfgAreaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfNewCfgAreaIndex.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgAreaIndex.setDescription('The OSPF area number for which the OSPF area table is related.')
ospfNewCfgAreaId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 3, 1, 2), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospfNewCfgAreaId.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgAreaId.setDescription('The IP Address of the OSPF area.')
ospfNewCfgAreaSpfInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospfNewCfgAreaSpfInterval.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgAreaSpfInterval.setDescription('The SPF interval for the OSPF area.')
ospfNewCfgAreaAuthType = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("password", 2), ("md5", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospfNewCfgAreaAuthType.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgAreaAuthType.setDescription('Type of authentication being used. none(1) - no authentication password(2) - use password. md5(3) - use MD5 authentication.')
ospfNewCfgAreaType = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("transit", 0), ("stub", 1), ("nssa", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospfNewCfgAreaType.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgAreaType.setDescription('Type of Area. transit(0) stub(1) nssa(2)')
ospfNewCfgAreaMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 3, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospfNewCfgAreaMetric.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgAreaMetric.setDescription('Metric (1-65535)')
ospfNewCfgAreaStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospfNewCfgAreaStatus.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgAreaStatus.setDescription('Status disabled(0) enabled(1)')
ospfNewCfgAreaDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospfNewCfgAreaDelete.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgAreaDelete.setDescription('Delete the area no(0), yes(1)')
ospfCurCfgHostTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 12), )
if mibBuilder.loadTexts: ospfCurCfgHostTable.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgHostTable.setDescription('The table of OSPF Host configuration.')
ospfCurCfgHostEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 12, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ospfCurCfgHostIndex"))
if mibBuilder.loadTexts: ospfCurCfgHostEntry.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgHostEntry.setDescription('Information about a OSPF host.')
ospfCurCfgHostIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 12, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgHostIndex.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgHostIndex.setDescription('The OSPF host number for which the OSPF host table is related.')
ospfCurCfgHostIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 12, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgHostIpAddr.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgHostIpAddr.setDescription('The IP Address of the OSPF host.')
ospfCurCfgHostAreaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 12, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgHostAreaIndex.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgHostAreaIndex.setDescription('The area index.')
ospfCurCfgHostCost = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 12, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgHostCost.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgHostCost.setDescription('The cost of the OSPF host.')
ospfCurCfgHostState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 12, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("enabled", 2), ("disabled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgHostState.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgHostState.setDescription('Enable or disable an OSPF Host')
ospfNewCfgHostTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 13), )
if mibBuilder.loadTexts: ospfNewCfgHostTable.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgHostTable.setDescription('The table of OSPF Host configuration.')
ospfNewCfgHostEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 13, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ospfNewCfgHostIndex"))
if mibBuilder.loadTexts: ospfNewCfgHostEntry.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgHostEntry.setDescription('Information about a OSPF host.')
ospfNewCfgHostIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 13, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfNewCfgHostIndex.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgHostIndex.setDescription('The OSPF host number for which the OSPF host table is related.')
ospfNewCfgHostIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 13, 1, 2), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospfNewCfgHostIpAddr.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgHostIpAddr.setDescription('The IP Address of the OSPF host.')
ospfNewCfgHostAreaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 13, 1, 3), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospfNewCfgHostAreaIndex.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgHostAreaIndex.setDescription('The OSPF area index.')
ospfNewCfgHostCost = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 13, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospfNewCfgHostCost.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgHostCost.setDescription('The cost of the OSPF host.')
ospfNewCfgHostState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 13, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("enabled", 2), ("disabled", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospfNewCfgHostState.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgHostState.setDescription('Enable or disable an OSPF Host')
ospfNewCfgHostDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 13, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospfNewCfgHostDelete.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgHostDelete.setDescription('Delete the OSPF host: no(0), yes(1)')
ospfMdkeyTableMaxSize = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfMdkeyTableMaxSize.setStatus('current')
if mibBuilder.loadTexts: ospfMdkeyTableMaxSize.setDescription('The maximum number of rows in the OSPF Mdkey table.')
ospfCurCfgMdkeyTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 5), )
if mibBuilder.loadTexts: ospfCurCfgMdkeyTable.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgMdkeyTable.setDescription('The table of OSPF MD5 keys in the current configuration block.')
ospfCurCfgMdkeyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 5, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ospfCurCfgMdkeyIndex"))
if mibBuilder.loadTexts: ospfCurCfgMdkeyEntry.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgMdkeyEntry.setDescription('Information about an OSPF MD keys table.')
ospfCurCfgMdkeyIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgMdkeyIndex.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgMdkeyIndex.setDescription('The OSPF MD5 Key number for which the OSPF MdKey table is related.')
ospfCurCfgMdkeyKey = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 5, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgMdkeyKey.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgMdkeyKey.setDescription('The character string representing the MD5 Key.')
ospfNewCfgMdkeyTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 6), )
if mibBuilder.loadTexts: ospfNewCfgMdkeyTable.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgMdkeyTable.setDescription('The table of OSPF MD5 keys in the new configuration block.')
ospfNewCfgMdkeyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 6, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ospfNewCfgMdkeyIndex"))
if mibBuilder.loadTexts: ospfNewCfgMdkeyEntry.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgMdkeyEntry.setDescription('Information about an OSPF MD keys table.')
ospfNewCfgMdkeyIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfNewCfgMdkeyIndex.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgMdkeyIndex.setDescription('The OSPF MD5 Key number for which the OSPF MdKey table is related.')
ospfNewCfgMdkeyKey = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 6, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospfNewCfgMdkeyKey.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgMdkeyKey.setDescription('The character string representing the MD5 Key.')
ospfNewCfgMdkeyDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 6, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("delete", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospfNewCfgMdkeyDelete.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgMdkeyDelete.setDescription('When set to the value of 2 (delete), the entire row is deleted. When read, other(1) is returned. Setting the value to anything other than 2(delete) has no effect on the state of the row.')
ospfCurCfgIntfTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 7), )
if mibBuilder.loadTexts: ospfCurCfgIntfTable.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgIntfTable.setDescription('The table of OSPF Interface in the current configuration block.')
ospfCurCfgIntfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 7, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ospfCurCfgIntfIndex"))
if mibBuilder.loadTexts: ospfCurCfgIntfEntry.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgIntfEntry.setDescription('Information about an OSPF Interface.')
ospfCurCfgIntfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 7, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgIntfIndex.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgIntfIndex.setDescription('The OSPF Interface number for which the OSPF Interface table is related.')
ospfCurCfgIntfArea = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 7, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 5))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgIntfArea.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgIntfArea.setDescription('The index of the area that the interface belongs (0..5)')
ospfCurCfgIntfMdkey = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 7, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgIntfMdkey.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgIntfMdkey.setDescription('The MD5 key for the OSPF interface 0 (none) no MD5 authentication.')
ospfCurCfgIntfCost = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 7, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgIntfCost.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgIntfCost.setDescription('Interface cost')
ospfCurCfgIntfPrio = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 7, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgIntfPrio.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgIntfPrio.setDescription('Interface router priority')
ospfCurCfgIntfHello = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 7, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgIntfHello.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgIntfHello.setDescription('Hello interval')
ospfCurCfgIntfHelloMS = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 7, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("seconds", 0), ("milliseconds", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgIntfHelloMS.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgIntfHelloMS.setDescription('Units of time measurement for Hello interval seconds(0), milliseconds(1)')
ospfCurCfgIntfDead = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 7, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgIntfDead.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgIntfDead.setDescription('Dead interval')
ospfCurCfgIntfDeadMS = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 7, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("seconds", 0), ("milliseconds", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgIntfDeadMS.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgIntfDeadMS.setDescription('Units of time measurement for Dead interval seconds(0), milliseconds(1)')
ospfCurCfgIntfTrans = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 7, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgIntfTrans.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgIntfTrans.setDescription('Transit delay')
ospfCurCfgIntfRetra = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 7, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgIntfRetra.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgIntfRetra.setDescription('Retransmit interval')
ospfCurCfgIntfAuthKey = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 7, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgIntfAuthKey.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgIntfAuthKey.setDescription('Authentication Key')
ospfCurCfgIntfPassive = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 7, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgIntfPassive.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgIntfPassive.setDescription('Passive interface disabled(0), enabled(1)')
ospfCurCfgIntfPtop = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 7, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgIntfPtop.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgIntfPtop.setDescription('Point-to-point interface disabled(0), enabled(1)')
ospfCurCfgIntfStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 7, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgIntfStatus.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgIntfStatus.setDescription('Status of the interface disabled(0), enabled(1)')
ospfNewCfgIntfTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 8), )
if mibBuilder.loadTexts: ospfNewCfgIntfTable.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgIntfTable.setDescription('The table of OSPF interface in the new configuration block.')
ospfNewCfgIntfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 8, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ospfNewCfgIntfIndex"))
if mibBuilder.loadTexts: ospfNewCfgIntfEntry.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgIntfEntry.setDescription('Information about an OSPF interface.')
ospfNewCfgIntfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 8, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfNewCfgIntfIndex.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgIntfIndex.setDescription('The OSPF Interface number for which the OSPF Interface table is related.')
ospfNewCfgIntfArea = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 8, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 5))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospfNewCfgIntfArea.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgIntfArea.setDescription('The index of the area that the interface belongs (0..5)')
ospfNewCfgIntfMdkey = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 8, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospfNewCfgIntfMdkey.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgIntfMdkey.setDescription('The MD5 key for the OSPF interface 0 (none) no MD5 authentication.')
ospfNewCfgIntfCost = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 8, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospfNewCfgIntfCost.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgIntfCost.setDescription('Interface cost(1..65535)')
ospfNewCfgIntfPrio = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 8, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospfNewCfgIntfPrio.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgIntfPrio.setDescription('Interface router priority(0..255)')
ospfNewCfgIntfHello = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 8, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospfNewCfgIntfHello.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgIntfHello.setDescription('Hello interval(1..65535s | 50..65535ms)')
ospfNewCfgIntfHelloMS = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 8, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("seconds", 0), ("milliseconds", 1)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospfNewCfgIntfHelloMS.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgIntfHelloMS.setDescription('Units of time measurement for Hello interval seconds(0), milliseconds(1)')
ospfNewCfgIntfDead = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 8, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospfNewCfgIntfDead.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgIntfDead.setDescription('Dead interval(1..65535s |1000..65535ms)')
ospfNewCfgIntfDeadMS = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 8, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("seconds", 0), ("milliseconds", 1)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospfNewCfgIntfDeadMS.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgIntfDeadMS.setDescription('Units of time measurement for Dead interval seconds(0), milliseconds(1)')
ospfNewCfgIntfTrans = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 8, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospfNewCfgIntfTrans.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgIntfTrans.setDescription('Transit delay(1..3600)')
ospfNewCfgIntfRetra = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 8, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospfNewCfgIntfRetra.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgIntfRetra.setDescription('Retransmit interval(1..3600)')
ospfNewCfgIntfAuthKey = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 8, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospfNewCfgIntfAuthKey.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgIntfAuthKey.setDescription('Authentication Key')
ospfNewCfgIntfPassive = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 8, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospfNewCfgIntfPassive.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgIntfPassive.setDescription('Passive interface disabled(0), enabled(1)')
ospfNewCfgIntfPtop = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 8, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospfNewCfgIntfPtop.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgIntfPtop.setDescription('Point-to-point interface disabled(0), enabled(1)')
ospfNewCfgIntfStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 8, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospfNewCfgIntfStatus.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgIntfStatus.setDescription('Status of the interface disabled(0), enabled(1)')
ospfNewCfgIntfDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 8, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("other", 0), ("delete", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospfNewCfgIntfDelete.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgIntfDelete.setDescription('Delete the interface other(0), delete(1)')
ospfCurCfgLoopIfTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 20), )
if mibBuilder.loadTexts: ospfCurCfgLoopIfTable.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgLoopIfTable.setDescription('The table of OSPF Loopback Interfaces in the current configuration block.')
ospfCurCfgLoopIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 20, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ospfCurCfgLoopIfIndex"))
if mibBuilder.loadTexts: ospfCurCfgLoopIfEntry.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgLoopIfEntry.setDescription('Information about an OSPF Loopback Interface.')
ospfCurCfgLoopIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 20, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgLoopIfIndex.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgLoopIfIndex.setDescription('The OSPF Loopback Interface number for which the OSPF Interface table is related.')
ospfCurCfgLoopIfArea = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 20, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgLoopIfArea.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgLoopIfArea.setDescription('The index of the area that the loopback interface belongs')
ospfCurCfgLoopIfStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 20, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgLoopIfStatus.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgLoopIfStatus.setDescription('Status of the loopback interface disabled(0), enabled(1)')
ospfNewCfgLoopIfTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 21), )
if mibBuilder.loadTexts: ospfNewCfgLoopIfTable.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgLoopIfTable.setDescription('The table of OSPF loopback interface in the new configuration block.')
ospfNewCfgLoopIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 21, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ospfNewCfgLoopIfIndex"))
if mibBuilder.loadTexts: ospfNewCfgLoopIfEntry.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgLoopIfEntry.setDescription('Information about an OSPF loopback interface.')
ospfNewCfgLoopIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 21, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfNewCfgLoopIfIndex.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgLoopIfIndex.setDescription('The OSPF loopback interface number for which the OSPF Loopback Interface table is related.')
ospfNewCfgLoopIfArea = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 21, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 5))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospfNewCfgLoopIfArea.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgLoopIfArea.setDescription('The index of the area that the loopback interface belongs (0..5)')
ospfNewCfgLoopIfStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 21, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospfNewCfgLoopIfStatus.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgLoopIfStatus.setDescription('Status of the loopback interface disabled(0), enabled(1)')
ospfNewCfgLoopIfDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 21, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("other", 0), ("delete", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospfNewCfgLoopIfDelete.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgLoopIfDelete.setDescription('Delete the loopback interface other(0), delete(1)')
ospfCurCfgVirtIntfTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 9), )
if mibBuilder.loadTexts: ospfCurCfgVirtIntfTable.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgVirtIntfTable.setDescription('The table of OSPF Virtual Interface configuration in the current configuration.')
ospfCurCfgVirtIntfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 9, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ospfCurCfgVirtIntfIndex"))
if mibBuilder.loadTexts: ospfCurCfgVirtIntfEntry.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgVirtIntfEntry.setDescription('Information about an OSPF virtual Interface.')
ospfCurCfgVirtIntfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 9, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgVirtIntfIndex.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgVirtIntfIndex.setDescription('The OSPF Virtual Interface number for which the OSPF Virtual Interface table is related.')
ospfCurCfgVirtIntfAreaId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 9, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 5))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgVirtIntfAreaId.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgVirtIntfAreaId.setDescription('The index of the OSPF area to which this virtual interface belongs.')
ospfCurCfgVirtIntfNbr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 9, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgVirtIntfNbr.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgVirtIntfNbr.setDescription('The IP Address of the OSPF neighbor for this virtual interface.')
ospfCurCfgVirtIntfMdkey = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 9, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgVirtIntfMdkey.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgVirtIntfMdkey.setDescription('The MD5 key for the OSPF virtual interface 0 (none) no MD5 authentication.')
ospfCurCfgVirtIntfHello = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 9, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgVirtIntfHello.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgVirtIntfHello.setDescription('Hello interval')
ospfCurCfgVirtIntfHelloMS = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 9, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("seconds", 0), ("milliseconds", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgVirtIntfHelloMS.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgVirtIntfHelloMS.setDescription('Units of time measurement for Hello interval seconds(0), milliseconds(1)')
ospfCurCfgVirtIntfDead = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 9, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgVirtIntfDead.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgVirtIntfDead.setDescription('Dead interval')
ospfCurCfgVirtIntfDeadMS = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 9, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("seconds", 0), ("milliseconds", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgVirtIntfDeadMS.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgVirtIntfDeadMS.setDescription('Units of time measurement for Dead interval seconds(0), milliseconds(1)')
ospfCurCfgVirtIntfTrans = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 9, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgVirtIntfTrans.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgVirtIntfTrans.setDescription('Transit delay')
ospfCurCfgVirtIntfRetra = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 9, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgVirtIntfRetra.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgVirtIntfRetra.setDescription('Retransmit interval')
ospfCurCfgVirtIntfAuthKey = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 9, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgVirtIntfAuthKey.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgVirtIntfAuthKey.setDescription('Authentication Key')
ospfCurCfgVirtIntfStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 9, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgVirtIntfStatus.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgVirtIntfStatus.setDescription('Status disabled(0), enabled(1)')
ospfNewCfgVirtIntfTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 10), )
if mibBuilder.loadTexts: ospfNewCfgVirtIntfTable.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgVirtIntfTable.setDescription('The table of OSPF Virtual interface in the new configuration block.')
ospfNewCfgVirtIntfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 10, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ospfNewCfgVirtIntfIndex"))
if mibBuilder.loadTexts: ospfNewCfgVirtIntfEntry.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgVirtIntfEntry.setDescription('Information about an OSPF virtual interface.')
ospfNewCfgVirtIntfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 10, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfNewCfgVirtIntfIndex.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgVirtIntfIndex.setDescription('The OSPF Virtual Interface number for which the OSPF Virtual Interface table is related.')
ospfNewCfgVirtIntfAreaId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 10, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 5))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospfNewCfgVirtIntfAreaId.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgVirtIntfAreaId.setDescription('The index of the OSPF area to which this virtual interface belongs.')
ospfNewCfgVirtIntfNbr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 10, 1, 3), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospfNewCfgVirtIntfNbr.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgVirtIntfNbr.setDescription('The IP Address of the OSPF neighbor for this virtual interface.')
ospfNewCfgVirtIntfMdkey = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 10, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospfNewCfgVirtIntfMdkey.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgVirtIntfMdkey.setDescription('The MD5 key for the OSPF virtual interface 0 (none) no MD5 authentication.')
ospfNewCfgVirtIntfHello = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 10, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospfNewCfgVirtIntfHello.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgVirtIntfHello.setDescription('Hello interval(1..65535s | 50..65535ms)')
ospfNewCfgVirtIntfHelloMS = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("seconds", 0), ("milliseconds", 1)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospfNewCfgVirtIntfHelloMS.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgVirtIntfHelloMS.setDescription('Units of time measurement fo Hello interval seconds(0), milliseconds(1) ')
ospfNewCfgVirtIntfDead = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 10, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospfNewCfgVirtIntfDead.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgVirtIntfDead.setDescription('Dead interval(1..65535s | 1000..65535ms)')
ospfNewCfgVirtIntfDeadMS = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 10, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("seconds", 0), ("milliseconds", 1)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospfNewCfgVirtIntfDeadMS.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgVirtIntfDeadMS.setDescription('Units of time measurement fo Dead interval seconds(0), milliseconds(1) ')
ospfNewCfgVirtIntfTrans = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 10, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospfNewCfgVirtIntfTrans.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgVirtIntfTrans.setDescription('Transit delay(1..3600)')
ospfNewCfgVirtIntfRetra = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 10, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospfNewCfgVirtIntfRetra.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgVirtIntfRetra.setDescription('Retransmit interval(1..3600)')
ospfNewCfgVirtIntfAuthKey = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 10, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospfNewCfgVirtIntfAuthKey.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgVirtIntfAuthKey.setDescription('Authentication Key SIZE(0..8)')
ospfNewCfgVirtIntfStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 10, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospfNewCfgVirtIntfStatus.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgVirtIntfStatus.setDescription('Status disabled(0), enabled(1) ')
ospfNewCfgVirtIntfDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 10, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("other", 0), ("delete", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospfNewCfgVirtIntfDelete.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgVirtIntfDelete.setDescription('Delete other(0), delete(1)')
ospfCurCfgRangeTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 14), )
if mibBuilder.loadTexts: ospfCurCfgRangeTable.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgRangeTable.setDescription('The table of OSPF summary range in the current configuration.')
ospfCurCfgRangeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 14, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ospfCurCfgRangeIndex"))
if mibBuilder.loadTexts: ospfCurCfgRangeEntry.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgRangeEntry.setDescription('Information about an OSPF summary range.')
ospfCurCfgRangeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 14, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgRangeIndex.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgRangeIndex.setDescription('The range number for which the OSPF summary range table is related.')
ospfCurCfgRangeAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 14, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgRangeAddr.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgRangeAddr.setDescription('The IP Address of the range.')
ospfCurCfgRangeMask = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 14, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgRangeMask.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgRangeMask.setDescription('The mask of the range.')
ospfCurCfgRangeAreaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 14, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgRangeAreaIndex.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgRangeAreaIndex.setDescription('The area index.')
ospfCurCfgRangeHideState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 14, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgRangeHideState.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgRangeHideState.setDescription('The state of the hide range.')
ospfCurCfgRangeState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 14, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgRangeState.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgRangeState.setDescription('The state of the range.')
ospfNewCfgRangeTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 15), )
if mibBuilder.loadTexts: ospfNewCfgRangeTable.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgRangeTable.setDescription('The table of OSPF summary range in the new configuration.')
ospfNewCfgRangeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 15, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ospfNewCfgRangeIndex"))
if mibBuilder.loadTexts: ospfNewCfgRangeEntry.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgRangeEntry.setDescription('Information about an OSPF summary range.')
ospfNewCfgRangeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 15, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfNewCfgRangeIndex.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgRangeIndex.setDescription('The range number for which the OSPF summary range table is related.')
ospfNewCfgRangeAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 15, 1, 2), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospfNewCfgRangeAddr.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgRangeAddr.setDescription('The IP Address of the range.')
ospfNewCfgRangeMask = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 15, 1, 3), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospfNewCfgRangeMask.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgRangeMask.setDescription('The mask of the range.')
ospfNewCfgRangeAreaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 15, 1, 4), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospfNewCfgRangeAreaIndex.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgRangeAreaIndex.setDescription('The area index.')
ospfNewCfgRangeHideState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 15, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospfNewCfgRangeHideState.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgRangeHideState.setDescription('The state of the hide range.')
ospfNewCfgRangeState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 15, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospfNewCfgRangeState.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgRangeState.setDescription('The state of the range.')
ospfNewCfgRangeDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 15, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("delete", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospfNewCfgRangeDelete.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgRangeDelete.setDescription('When set to the value of 2 (delete), the entire row is deleted. When read, other(1) is returned. Setting the value to anything other than 2(delete) has no effect on the state of the row.')
ospfRouteRedistribution = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 4))
ospfRedistributeStatic = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 4, 1))
ospfCurCfgStaticMetric = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777214))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgStaticMetric.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgStaticMetric.setDescription('The metric to be assigned to static routes.')
ospfNewCfgStaticMetric = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777214))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospfNewCfgStaticMetric.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgStaticMetric.setDescription('The metric to be assigned to static routes.')
ospfCurCfgStaticMetricType = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("type1", 2), ("type2", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgStaticMetricType.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgStaticMetricType.setDescription('The AS External metric type for static routes.')
ospfNewCfgStaticMetricType = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("type1", 2), ("type2", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospfNewCfgStaticMetricType.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgStaticMetricType.setDescription('The AS External metric type for static routes.')
ospfCurCfgStaticOutRmapList = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 4, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgStaticOutRmapList.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgStaticOutRmapList.setDescription('The route maps present in the out route map list. The route maps are presented in a bitmap format. in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ Rmap 9 || || || ||___ Rmap 8 || |____ Rmap 7 || . . . ||_________ Rmap 2 |__________ Rmap 1 where x : 1 - The represented route map is selected 0 - The represented route map is not selected')
ospfNewCfgStaticOutRmapList = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 4, 1, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfNewCfgStaticOutRmapList.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgStaticOutRmapList.setDescription('The route maps present in the out route map list. The route maps are presented in a bitmap format. in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ Rmap 9 || || || ||___ Rmap 8 || |____ Rmap 7 || . . . ||_________ Rmap 2 |__________ Rmap 1 where x : 1 - The represented route map is selected 0 - The represented route map is not selected')
ospfNewCfgStaticAddOutRmap = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 4, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospfNewCfgStaticAddOutRmap.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgStaticAddOutRmap.setDescription('The route map to be add into out-rmap list. When read, 0 is returned.')
ospfNewCfgStaticRemoveOutRmap = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 4, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospfNewCfgStaticRemoveOutRmap.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgStaticRemoveOutRmap.setDescription('The route map to be removed from out-rmap list. When read, 0 is returned.')
ospfRedistributeEbgp = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 4, 2))
ospfCurCfgEbgpMetric = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 4, 2, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777214))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgEbgpMetric.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgEbgpMetric.setDescription('The export metric to be assigned to External BGP routes.')
ospfNewCfgEbgpMetric = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 4, 2, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777214))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospfNewCfgEbgpMetric.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgEbgpMetric.setDescription('The export metric to be assigned to External BGP routes.')
ospfCurCfgEbgpMetricType = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 4, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("type1", 2), ("type2", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgEbgpMetricType.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgEbgpMetricType.setDescription('The AS External metric type for External BGP routes.')
ospfNewCfgEbgpMetricType = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 4, 2, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("type1", 2), ("type2", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospfNewCfgEbgpMetricType.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgEbgpMetricType.setDescription('The AS External metric type for External BGP routes.')
ospfCurCfgEbgpOutRmapList = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 4, 2, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgEbgpOutRmapList.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgEbgpOutRmapList.setDescription('The route maps present in the out route map list. The route maps are presented in a bitmap format. in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ Rmap 9 || || || ||___ Rmap 8 || |____ Rmap 7 || . . . ||_________ Rmap 2 |__________ Rmap 1 where x : 1 - The represented route map is selected 0 - The represented route map is not selected')
ospfNewCfgEbgpOutRmapList = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 4, 2, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfNewCfgEbgpOutRmapList.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgEbgpOutRmapList.setDescription('The route maps present in the out route map list. The route maps are presented in a bitmap format. in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ Rmap 9 || || || ||___ Rmap 8 || |____ Rmap 7 || . . . ||_________ Rmap 2 |__________ Rmap 1 where x : 1 - The represented route map is selected 0 - The represented route map is not selected')
ospfNewCfgEbgpAddOutRmap = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 4, 2, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospfNewCfgEbgpAddOutRmap.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgEbgpAddOutRmap.setDescription('The route map to be add into out-rmap list. When read, 0 is returned.')
ospfNewCfgEbgpRemoveOutRmap = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 4, 2, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospfNewCfgEbgpRemoveOutRmap.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgEbgpRemoveOutRmap.setDescription('The route map to be removed from out-rmap list. When read, 0 is returned.')
ospfRedistributeIbgp = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 4, 3))
ospfCurCfgIbgpMetric = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 4, 3, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777214))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgIbgpMetric.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgIbgpMetric.setDescription('The export metric for Internal BGP routes.')
ospfNewCfgIbgpMetric = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 4, 3, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777214))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospfNewCfgIbgpMetric.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgIbgpMetric.setDescription('The export metric for Internal BGP routes.')
ospfCurCfgIbgpMetricType = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 4, 3, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("type1", 2), ("type2", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgIbgpMetricType.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgIbgpMetricType.setDescription('The AS External metric type for Internal BGP routes.')
ospfNewCfgIbgpMetricType = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 4, 3, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("type1", 2), ("type2", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospfNewCfgIbgpMetricType.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgIbgpMetricType.setDescription('The AS External metric type for Internal BGP routes.')
ospfCurCfgIbgpOutRmapList = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 4, 3, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgIbgpOutRmapList.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgIbgpOutRmapList.setDescription('The route maps present in the out route map list. The route maps are presented in a bitmap format. in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ Rmap 9 || || || ||___ Rmap 8 || |____ Rmap 7 || . . . ||_________ Rmap 2 |__________ Rmap 1 where x : 1 - The represented route map is selected 0 - The represented route map is not selected')
ospfNewCfgIbgpOutRmapList = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 4, 3, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfNewCfgIbgpOutRmapList.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgIbgpOutRmapList.setDescription('The route maps present in the out route map list. The route maps are presented in a bitmap format. in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ Rmap 9 || || || ||___ Rmap 8 || |____ Rmap 7 || . . . ||_________ Rmap 2 |__________ Rmap 1 where x : 1 - The represented route map is selected 0 - The represented route map is not selected')
ospfNewCfgIbgpAddOutRmap = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 4, 3, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospfNewCfgIbgpAddOutRmap.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgIbgpAddOutRmap.setDescription('The route map to be add into out-rmap list. When read, 0 is returned.')
ospfNewCfgIbgpRemoveOutRmap = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 4, 3, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospfNewCfgIbgpRemoveOutRmap.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgIbgpRemoveOutRmap.setDescription('The route map to be removed from out-rmap list. When read, 0 is returned.')
ospfRedistributeFixed = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 4, 4))
ospfCurCfgFixedMetric = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 4, 4, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777214))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgFixedMetric.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgFixedMetric.setDescription('The export metric for fixed routes.')
ospfNewCfgFixedMetric = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 4, 4, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777214))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospfNewCfgFixedMetric.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgFixedMetric.setDescription('The export metric for fixed routes.')
ospfCurCfgFixedMetricType = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 4, 4, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("type1", 2), ("type2", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgFixedMetricType.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgFixedMetricType.setDescription('The AS External metric type for fixed routes.')
ospfNewCfgFixedMetricType = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 4, 4, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("type1", 2), ("type2", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospfNewCfgFixedMetricType.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgFixedMetricType.setDescription('The AS External metric type for fixed routes.')
ospfCurCfgFixedOutRmapList = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 4, 4, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgFixedOutRmapList.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgFixedOutRmapList.setDescription('The route maps present in the out route map list. The route maps are presented in a bitmap format. in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ Rmap 9 || || || ||___ Rmap 8 || |____ Rmap 7 || . . . ||_________ Rmap 2 |__________ Rmap 1 where x : 1 - The represented route map is selected 0 - The represented route map is not selected')
ospfNewCfgFixedOutRmapList = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 4, 4, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfNewCfgFixedOutRmapList.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgFixedOutRmapList.setDescription('The route maps present in the out route map list. The route maps are presented in a bitmap format. in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ Rmap 9 || || || ||___ Rmap 8 || |____ Rmap 7 || . . . ||_________ Rmap 2 |__________ Rmap 1 where x : 1 - The represented route map is selected 0 - The represented route map is not selected')
ospfNewCfgFixedAddOutRmap = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 4, 4, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospfNewCfgFixedAddOutRmap.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgFixedAddOutRmap.setDescription('The route map to be add into out-rmap list. When read, 0 is returned.')
ospfNewCfgFixedRemoveOutRmap = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 4, 4, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospfNewCfgFixedRemoveOutRmap.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgFixedRemoveOutRmap.setDescription('The route map to be removed from out-rmap list. When read, 0 is returned.')
ospfRedistributeRip = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 4, 5))
ospfCurCfgRipMetric = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 4, 5, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777214))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgRipMetric.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgRipMetric.setDescription('The export metric for RIP routes. ')
ospfNewCfgRipMetric = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 4, 5, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777214))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospfNewCfgRipMetric.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgRipMetric.setDescription('The export metric for RIP routes. ')
ospfCurCfgRipMetricType = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 4, 5, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("type1", 2), ("type2", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgRipMetricType.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgRipMetricType.setDescription('The AS External metric type for RIP routes.')
ospfNewCfgRipMetricType = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 4, 5, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("type1", 2), ("type2", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospfNewCfgRipMetricType.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgRipMetricType.setDescription('The AS External metric type for RIP routes.')
ospfCurCfgRipOutRmapList = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 4, 5, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgRipOutRmapList.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgRipOutRmapList.setDescription('The route maps present in the out route map list. The route maps are presented in a bitmap format. in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ Rmap 9 || || || ||___ Rmap 8 || |____ Rmap 7 || . . . ||_________ Rmap 2 |__________ Rmap 1 where x : 1 - The represented route map is selected 0 - The represented route map is not selected')
ospfNewCfgRipOutRmapList = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 4, 5, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfNewCfgRipOutRmapList.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgRipOutRmapList.setDescription('The route maps present in the out route map list. The route maps are presented in a bitmap format. in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ Rmap 9 || || || ||___ Rmap 8 || |____ Rmap 7 || . . . ||_________ Rmap 2 |__________ Rmap 1 where x : 1 - The represented route map is selected 0 - The represented route map is not selected')
ospfNewCfgRipAddOutRmap = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 4, 5, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospfNewCfgRipAddOutRmap.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgRipAddOutRmap.setDescription('The route map to be add into out-rmap list. When read, 0 is returned.')
ospfNewCfgRipRemoveOutRmap = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 13, 4, 5, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospfNewCfgRipRemoveOutRmap.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgRipRemoveOutRmap.setDescription('The route map to be removed from out-rmap list. When read, 0 is returned.')
ospf3General = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 1))
ospf3IntfTableMaxSize = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IntfTableMaxSize.setStatus('current')
if mibBuilder.loadTexts: ospf3IntfTableMaxSize.setDescription('The maximum number of rows in the OSPFv3 Interface table.')
ospf3AreaTableMaxSize = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3AreaTableMaxSize.setStatus('current')
if mibBuilder.loadTexts: ospf3AreaTableMaxSize.setDescription('The maximum number of rows in the OSPFv3 Area table.')
ospf3RangeTableMaxSize = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3RangeTableMaxSize.setStatus('current')
if mibBuilder.loadTexts: ospf3RangeTableMaxSize.setDescription('The maximum number of rows in the OSPFv3 Range table.')
ospf3ExtRangeTableMaxSize = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3ExtRangeTableMaxSize.setStatus('current')
if mibBuilder.loadTexts: ospf3ExtRangeTableMaxSize.setDescription('The maximum number of rows in the OSPFv3 Summary Prefix table.')
ospf3RedistTableMaxSize = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3RedistTableMaxSize.setStatus('current')
if mibBuilder.loadTexts: ospf3RedistTableMaxSize.setDescription('The maximum number of rows in the OSPFv3 Redist Config table.')
ospf3VirtIntfTableMaxSize = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3VirtIntfTableMaxSize.setStatus('current')
if mibBuilder.loadTexts: ospf3VirtIntfTableMaxSize.setDescription('The maximum number of rows in the OSPFv3 Virtual Interface table.')
ospf3HostTableMaxSize = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3HostTableMaxSize.setStatus('current')
if mibBuilder.loadTexts: ospf3HostTableMaxSize.setDescription('The maximum number of rows in the OSPFv3 Host table.')
ospf3NbrTableMaxSize = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3NbrTableMaxSize.setStatus('current')
if mibBuilder.loadTexts: ospf3NbrTableMaxSize.setDescription('The maximum number of rows in the OSPFv3 Neighbor table.')
ospf3CurCfgState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgState.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgState.setDescription('OSPFv3 global state.')
ospf3NewCfgState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospf3NewCfgState.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgState.setDescription('Globally turn OSPFv3 on or off.')
ospf3CurCfgRouterId = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 1, 11), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgRouterId.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgRouterId.setDescription('The router ID.')
ospf3NewCfgRouterId = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 1, 12), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospf3NewCfgRouterId.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgRouterId.setDescription('The router ID.')
ospf3CurCfgAbrType = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("standard", 1), ("cisco", 2), ("ibm", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgAbrType.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgAbrType.setDescription('OSPFv3 alternative ABR type.')
ospf3NewCfgAbrType = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("standard", 1), ("cisco", 2), ("ibm", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospf3NewCfgAbrType.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgAbrType.setDescription('Set the OSPFv3 alternative ABR type.')
ospf3CurCfgLSDB = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgLSDB.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgLSDB.setDescription('The LSDB limit for external LSA.')
ospf3NewCfgLSDB = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospf3NewCfgLSDB.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgLSDB.setDescription('Set the LSDB limit for external LSA, -1 for none.')
ospf3CurCfgExitOverflow = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 1, 17), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgExitOverflow.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgExitOverflow.setDescription('The exit overflow interval in seconds.')
ospf3NewCfgExitOverflow = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 1, 18), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospf3NewCfgExitOverflow.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgExitOverflow.setDescription('Set the exit overflow interval in seconds.')
ospf3CurCfgReferenceBw = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 1, 19), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgReferenceBw.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgReferenceBw.setDescription('The reference bandwidth for default interface metric calculation.')
ospf3NewCfgReferenceBw = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 1, 20), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospf3NewCfgReferenceBw.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgReferenceBw.setDescription('The reference bandwidth for default interface metric calculation.')
ospf3CurCfgSpfDelay = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgSpfDelay.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgSpfDelay.setDescription('The delay between topology change and SPF calculation.')
ospf3NewCfgSpfDelay = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospf3NewCfgSpfDelay.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgSpfDelay.setDescription('The delay between topology change and SPF calculation.')
ospf3CurCfgSpfHold = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgSpfHold.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgSpfHold.setDescription('The hold time between two consecutive SPF calculation.')
ospf3NewCfgSpfHold = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospf3NewCfgSpfHold.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgSpfHold.setDescription('The hold time between two consecutive SPF calculation.')
ospf3CurCfgNssaAsbrDfRtTrans = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgNssaAsbrDfRtTrans.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgNssaAsbrDfRtTrans.setDescription('OSPFv3 state of setting P-bit by an NSSA internal ASBR.')
ospf3NewCfgNssaAsbrDfRtTrans = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospf3NewCfgNssaAsbrDfRtTrans.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgNssaAsbrDfRtTrans.setDescription('OSPFv3 state of setting P-bit by an NSSA internal ASBR.')
ospf3CurCfgAreaTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 2), )
if mibBuilder.loadTexts: ospf3CurCfgAreaTable.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgAreaTable.setDescription('The table of OSPFv3 area in the current configuration block.')
ospf3CurCfgAreaEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 2, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ospf3CurCfgAreaIndex"))
if mibBuilder.loadTexts: ospf3CurCfgAreaEntry.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgAreaEntry.setDescription('Information about a OSPFv3 area.')
ospf3CurCfgAreaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgAreaIndex.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgAreaIndex.setDescription('The OSPFv3 area number for which the OSPFv3 area table is related.')
ospf3CurCfgAreaId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 2, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgAreaId.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgAreaId.setDescription('The IP Address of the OSPFv3 area.')
ospf3CurCfgAreaStbInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgAreaStbInterval.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgAreaStbInterval.setDescription('The stability interval for the NSSA area')
ospf3CurCfgAreaType = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("transit", 1), ("stub", 2), ("nssa", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgAreaType.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgAreaType.setDescription('Type of Area. transit(1) stub(2) nssa(3)')
ospf3CurCfgAreaNoSumm = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgAreaNoSumm.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgAreaNoSumm.setDescription('Status disabled(0) enabled(1)')
ospf3CurCfgAreaDefaultMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgAreaDefaultMetric.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgAreaDefaultMetric.setDescription('Metric for stub/NSSA area (1-16777215)')
ospf3CurCfgAreaDefaultMetricType = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgAreaDefaultMetricType.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgAreaDefaultMetricType.setDescription('Metric Type for stub/NSSA area (1-3)')
ospf3CurCfgAreaTranslRole = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("always", 1), ("candidate", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgAreaTranslRole.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgAreaTranslRole.setDescription('Translation role for the NSSA area. always(1) candidate(2)')
ospf3CurCfgAreaStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgAreaStatus.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgAreaStatus.setDescription('Status disabled(0) enabled(1)')
ospf3NewCfgAreaTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 3), )
if mibBuilder.loadTexts: ospf3NewCfgAreaTable.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgAreaTable.setDescription('The table of OSPFv3 Area configuration in the new configuration block.')
ospf3NewCfgAreaEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 3, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ospf3NewCfgAreaIndex"))
if mibBuilder.loadTexts: ospf3NewCfgAreaEntry.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgAreaEntry.setDescription('Information about a OSPFv3 area.')
ospf3NewCfgAreaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3NewCfgAreaIndex.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgAreaIndex.setDescription('The OSPFv3 area number for which the OSPFv3 area table is related.')
ospf3NewCfgAreaId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 3, 1, 2), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospf3NewCfgAreaId.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgAreaId.setDescription('The IP Address of the OSPFv3 area.')
ospf3NewCfgAreaStbInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospf3NewCfgAreaStbInterval.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgAreaStbInterval.setDescription('The Stability interval for the NSSA area.')
ospf3NewCfgAreaType = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("transit", 1), ("stub", 2), ("nssa", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospf3NewCfgAreaType.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgAreaType.setDescription('Type of Area. transit(1) stub(2) nssa(3)')
ospf3NewCfgAreaNoSumm = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospf3NewCfgAreaNoSumm.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgAreaNoSumm.setDescription('Status disabled(0) enabled(1)')
ospf3NewCfgAreaDefaultMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 3, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16777215))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospf3NewCfgAreaDefaultMetric.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgAreaDefaultMetric.setDescription('Metric for stub/NSSA area (1-16777215)')
ospf3NewCfgAreaDefaultMetricType = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 3, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospf3NewCfgAreaDefaultMetricType.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgAreaDefaultMetricType.setDescription('Metric Type for stub/NSSA area (1-3)')
ospf3NewCfgAreaTranslRole = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("always", 1), ("candidate", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospf3NewCfgAreaTranslRole.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgAreaTranslRole.setDescription('Translation role for the NSSA area. always(1) candidate(2)')
ospf3NewCfgAreaStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 3, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospf3NewCfgAreaStatus.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgAreaStatus.setDescription('Status disabled(0) enabled(1)')
ospf3NewCfgAreaDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 3, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospf3NewCfgAreaDelete.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgAreaDelete.setDescription('Delete the area no(0), yes(1)')
ospf3CurCfgHostTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 4), )
if mibBuilder.loadTexts: ospf3CurCfgHostTable.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgHostTable.setDescription('The table of OSPFv3 Host configuration.')
ospf3CurCfgHostEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 4, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ospf3CurCfgHostIndex"))
if mibBuilder.loadTexts: ospf3CurCfgHostEntry.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgHostEntry.setDescription('Information about a OSPFv3 host.')
ospf3CurCfgHostIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgHostIndex.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgHostIndex.setDescription('The OSPFv3 host number for which the OSPFv3 host table is related.')
ospf3CurCfgHostIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 4, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgHostIpAddr.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgHostIpAddr.setDescription('The IPv6 Address of the OSPFv3 host.')
ospf3CurCfgHostAreaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 4, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgHostAreaIndex.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgHostAreaIndex.setDescription('The area index.')
ospf3CurCfgHostCost = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgHostCost.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgHostCost.setDescription('The cost of the OSPFv3 host.')
ospf3CurCfgHostState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("enabled", 2), ("disabled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgHostState.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgHostState.setDescription('Enable or disable an OSPFv3 Host')
ospf3NewCfgHostTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 5), )
if mibBuilder.loadTexts: ospf3NewCfgHostTable.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgHostTable.setDescription('The table of OSPFv3 Host configuration.')
ospf3NewCfgHostEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 5, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ospf3NewCfgHostIndex"))
if mibBuilder.loadTexts: ospf3NewCfgHostEntry.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgHostEntry.setDescription('Information about a OSPFv3 host.')
ospf3NewCfgHostIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3NewCfgHostIndex.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgHostIndex.setDescription('The OSPFv3 host number for which the OSPFv3 host table is related.')
ospf3NewCfgHostIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 5, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospf3NewCfgHostIpAddr.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgHostIpAddr.setDescription('The IP6 Address of the OSPFv3 host. Address should be 4-byte haxadecimal colon notation. Valid IPv6 address should be in any of the following forms xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx or xxxx::xxxx:xxxx:xxxx:xxxx or ::xxxx')
ospf3NewCfgHostAreaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 5, 1, 3), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospf3NewCfgHostAreaIndex.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgHostAreaIndex.setDescription('The OSPFv3 area index.')
ospf3NewCfgHostCost = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 5, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospf3NewCfgHostCost.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgHostCost.setDescription('The cost of the OSPFv3 host.')
ospf3NewCfgHostState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 5, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("enabled", 2), ("disabled", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospf3NewCfgHostState.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgHostState.setDescription('Enable or disable an OSPFv3 Host')
ospf3NewCfgHostDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 5, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospf3NewCfgHostDelete.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgHostDelete.setDescription('Delete the OSPFv3 host: no(0), yes(1)')
ospf3CurCfgNbrTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 6), )
if mibBuilder.loadTexts: ospf3CurCfgNbrTable.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgNbrTable.setDescription('The table of OSPFv3 Neighbor configuration.')
ospf3CurCfgNbrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 6, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ospf3CurCfgNbrIndex"))
if mibBuilder.loadTexts: ospf3CurCfgNbrEntry.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgNbrEntry.setDescription('Information about a OSPFv3 neighbor.')
ospf3CurCfgNbrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgNbrIndex.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgNbrIndex.setDescription('The OSPFv3 neighbor number for which the OSPFv3 neighbor table is related.')
ospf3CurCfgNbrIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 6, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgNbrIpAddr.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgNbrIpAddr.setDescription('The IPv6 Address of the OSPFv3 neighbor.')
ospf3CurCfgNbrIntfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 6, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgNbrIntfIndex.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgNbrIntfIndex.setDescription('The interface index.')
ospf3CurCfgNbrPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 6, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgNbrPriority.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgNbrPriority.setDescription('The priority of the OSPFv3 neighbor.')
ospf3CurCfgNbrState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 6, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("enabled", 2), ("disabled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgNbrState.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgNbrState.setDescription('Enable or disable an OSPFv3 neighbor')
ospf3NewCfgNbrTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 7), )
if mibBuilder.loadTexts: ospf3NewCfgNbrTable.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgNbrTable.setDescription('The table of OSPFv3 Neighbor configuration.')
ospf3NewCfgNbrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 7, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ospf3NewCfgNbrIndex"))
if mibBuilder.loadTexts: ospf3NewCfgNbrEntry.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgNbrEntry.setDescription('Information about a OSPFv3 neighbor.')
ospf3NewCfgNbrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 7, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3NewCfgNbrIndex.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgNbrIndex.setDescription('The OSPFv3 neighbor number for which the OSPFv3 neighbor table is related.')
ospf3NewCfgNbrIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 7, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospf3NewCfgNbrIpAddr.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgNbrIpAddr.setDescription('The IP6 Address of the OSPFv3 neighbor. Address should be 4-byte haxadecimal colon notation. Valid IPv6 address should be in any of the following forms xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx or xxxx::xxxx:xxxx:xxxx:xxxx or ::xxxx')
ospf3NewCfgNbrIntfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 7, 1, 3), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospf3NewCfgNbrIntfIndex.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgNbrIntfIndex.setDescription('The OSPFv3 interface index.')
ospf3NewCfgNbrPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 7, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospf3NewCfgNbrPriority.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgNbrPriority.setDescription('The cost of the OSPFv3 neighbor.')
ospf3NewCfgNbrState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 7, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 0))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 0)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospf3NewCfgNbrState.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgNbrState.setDescription('Enable or disable an OSPFv3 Neighbor')
ospf3NewCfgNbrDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 7, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospf3NewCfgNbrDelete.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgNbrDelete.setDescription('Delete the OSPFv3 neighbor: no(0), yes(1)')
ospf3CurCfgIntfTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 8), )
if mibBuilder.loadTexts: ospf3CurCfgIntfTable.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgIntfTable.setDescription('The table of OSPFv3 Interface in the current configuration block.')
ospf3CurCfgIntfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 8, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ospf3CurCfgIntfIndex"))
if mibBuilder.loadTexts: ospf3CurCfgIntfEntry.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgIntfEntry.setDescription('Information about an OSPFv3 Interface.')
ospf3CurCfgIntfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 8, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgIntfIndex.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgIntfIndex.setDescription('The OSPFv3 Interface number for which the OSPFv3 Interface table is related.')
ospf3CurCfgIntfInstId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 8, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgIntfInstId.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgIntfInstId.setDescription('Interface Instance Id')
ospf3CurCfgIntfArea = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 8, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 5))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgIntfArea.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgIntfArea.setDescription('The index of the area that the interface belongs')
ospf3CurCfgIntfCost = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 8, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgIntfCost.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgIntfCost.setDescription('Interface cost')
ospf3CurCfgIntfPrio = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 8, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgIntfPrio.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgIntfPrio.setDescription('Interface router priority')
ospf3CurCfgIntfHello = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 8, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgIntfHello.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgIntfHello.setDescription('Hello interval')
ospf3CurCfgIntfDead = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 8, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgIntfDead.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgIntfDead.setDescription('Dead interval')
ospf3CurCfgIntfPoll = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 8, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgIntfPoll.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgIntfPoll.setDescription('Poll interval(1..4294967295)')
ospf3CurCfgIntfTrans = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 8, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1800))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgIntfTrans.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgIntfTrans.setDescription('Transmit delay')
ospf3CurCfgIntfRetra = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 8, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1800))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgIntfRetra.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgIntfRetra.setDescription('Retransmit interval')
ospf3CurCfgIntfPassive = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 8, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgIntfPassive.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgIntfPassive.setDescription('Passive interface disabled(0), enabled(1)')
ospf3CurCfgIntfNetworkType = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 8, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("broadcast", 1), ("non-broadcast", 2), ("point-to-point", 3), ("point-to-multipoint", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgIntfNetworkType.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgIntfNetworkType.setDescription('Network Type. broadcast(1), non-broadcast(2), point-to-point(3), point-to-multipoint(4)')
ospf3CurCfgIntfStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 8, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgIntfStatus.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgIntfStatus.setDescription('Status of the interface disabled(0), enabled(1)')
ospf3CurCfgIntfAuthSpi = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 8, 1, 17), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(256, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgIntfAuthSpi.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgIntfAuthSpi.setDescription('Spi Id(256 - 4294967295)')
ospf3CurCfgIntfAuthEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 8, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgIntfAuthEnable.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgIntfAuthEnable.setDescription('Status disabled(0), enabled(1)')
ospf3CurCfgIntfAuthType = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 8, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2, 1))).clone(namedValues=NamedValues(("none", 0), ("md5", 2), ("sha1", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgIntfAuthType.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgIntfAuthType.setDescription('Authentication Type none(0), md5(2), sha1(1)')
ospf3CurCfgIntfAuthKey = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 8, 1, 20), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgIntfAuthKey.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgIntfAuthKey.setDescription('Authentication Key Hex-string MD5 key - 32 chars (128 bits) Hex-string SHA-1 key - 40 chars (160 bits)')
ospf3CurCfgIntfEncrySpi = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 8, 1, 21), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(256, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgIntfEncrySpi.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgIntfEncrySpi.setDescription('Spi Id(256 - 4294967295)')
ospf3CurCfgIntfEncryEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 8, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgIntfEncryEnable.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgIntfEncryEnable.setDescription('Status disabled(0), enabled(1)')
ospf3CurCfgIntfEncryType = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 8, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("null", 0), ("des", 1), ("tripledes", 2), ("aes", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgIntfEncryType.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgIntfEncryType.setDescription('Encryption Type null(0), des(1), 3des(2), aes(3)')
ospf3CurCfgIntfEncryKey = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 8, 1, 24), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 48))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgIntfEncryKey.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgIntfEncryKey.setDescription('Encryption Key Hex-string DES key - 16 chars (64 bits) Hex-string AES key - 32 chars (128 bits) Hex-string 3DES key - 48 chars (192 bits)')
ospf3CurCfgIntfEncryAuthType = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 8, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2, 1))).clone(namedValues=NamedValues(("none", 0), ("md5", 2), ("sha1", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgIntfEncryAuthType.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgIntfEncryAuthType.setDescription('Encryption Authentication Type none(0), md5(2), sha1(1)')
ospf3CurCfgIntfEncryAuthKey = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 8, 1, 26), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgIntfEncryAuthKey.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgIntfEncryAuthKey.setDescription('Encryption Authentication Key Hex-string MD5 key - 32 chars (128 bits) Hex-string SHA-1 key - 40 chars (160 bits)')
ospf3CurCfgIntfLsaSupress = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 8, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgIntfLsaSupress.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgIntfLsaSupress.setDescription('LSA Supression on interface disabled(0), enabled(1)')
ospf3NewCfgIntfTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 9), )
if mibBuilder.loadTexts: ospf3NewCfgIntfTable.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgIntfTable.setDescription('The table of OSPFv3 interface in the new configuration block.')
ospf3NewCfgIntfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 9, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ospf3NewCfgIntfIndex"))
if mibBuilder.loadTexts: ospf3NewCfgIntfEntry.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgIntfEntry.setDescription('Information about an OSPFv3 interface.')
ospf3NewCfgIntfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 9, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3NewCfgIntfIndex.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgIntfIndex.setDescription('The OSPFv3 Interface number for which the OSPFv3 Interface table is related.')
ospf3NewCfgIntfInstId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 9, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospf3NewCfgIntfInstId.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgIntfInstId.setDescription('Interface Instance Id (0..255)')
ospf3NewCfgIntfArea = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 9, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 5))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospf3NewCfgIntfArea.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgIntfArea.setDescription('The index of the area that the interface belongs (0..5)')
ospf3NewCfgIntfCost = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 9, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospf3NewCfgIntfCost.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgIntfCost.setDescription('Interface cost(1..65535) and 0 for none')
ospf3NewCfgIntfPrio = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 9, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospf3NewCfgIntfPrio.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgIntfPrio.setDescription('Interface router priority(0..255)')
ospf3NewCfgIntfHello = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 9, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospf3NewCfgIntfHello.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgIntfHello.setDescription('Hello interval(1..65535)')
ospf3NewCfgIntfDead = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 9, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospf3NewCfgIntfDead.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgIntfDead.setDescription('Dead interval(1..65535)')
ospf3NewCfgIntfPoll = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 9, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospf3NewCfgIntfPoll.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgIntfPoll.setDescription('Poll interval(1..4294967295)')
ospf3NewCfgIntfTrans = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 9, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1800))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospf3NewCfgIntfTrans.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgIntfTrans.setDescription('Transmit delay(1..1800)')
ospf3NewCfgIntfRetra = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 9, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1800))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospf3NewCfgIntfRetra.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgIntfRetra.setDescription('Retransmit interval(1..1800)')
ospf3NewCfgIntfPassive = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 9, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospf3NewCfgIntfPassive.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgIntfPassive.setDescription('Passive interface disabled(0), enabled(1)')
ospf3NewCfgIntfNetworkType = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 9, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("broadcast", 1), ("non-broadcast", 2), ("point-to-point", 3), ("point-to-multipoint", 4)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospf3NewCfgIntfNetworkType.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgIntfNetworkType.setDescription('Network Type. broadcast(1), non-broadcast(2), point-to-point(3), point-to-multipoint(4)')
ospf3NewCfgIntfStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 9, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospf3NewCfgIntfStatus.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgIntfStatus.setDescription('Status of the interface disabled(0), enabled(1)')
ospf3NewCfgIntfDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 9, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("other", 0), ("delete", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospf3NewCfgIntfDelete.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgIntfDelete.setDescription('Delete the interface other(0), delete(1)')
ospf3NewCfgIntfAuthSpi = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 9, 1, 18), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(256, 4294967295))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospf3NewCfgIntfAuthSpi.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgIntfAuthSpi.setDescription('Authentication Spi Id(256 - 4294967295)')
ospf3NewCfgIntfAuthEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 9, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospf3NewCfgIntfAuthEnable.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgIntfAuthEnable.setDescription('Authentication Status disabled(0), enabled(1)')
ospf3NewCfgIntfAuthType = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 9, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2, 1))).clone(namedValues=NamedValues(("none", 0), ("md5", 2), ("sha1", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospf3NewCfgIntfAuthType.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgIntfAuthType.setDescription('Authentication Type none(0), md5(2), sha1(1)')
ospf3NewCfgIntfAuthKey = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 9, 1, 21), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospf3NewCfgIntfAuthKey.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgIntfAuthKey.setDescription('Authentication Type Hex-string MD5 key - 32 chars (128 bits), Hex-string SHA-1 key - 40 chars (160 bits)')
ospf3NewCfgIntfAuthReset = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 9, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("other", 0), ("reset", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospf3NewCfgIntfAuthReset.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgIntfAuthReset.setDescription('Reset AH configuration other(0), reset(1)')
ospf3NewCfgIntfEncrySpi = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 9, 1, 23), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(256, 4294967295))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospf3NewCfgIntfEncrySpi.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgIntfEncrySpi.setDescription('Encryption Spi Id(256 - 4294967295)')
ospf3NewCfgIntfEncryEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 9, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospf3NewCfgIntfEncryEnable.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgIntfEncryEnable.setDescription('Encryption Status disabled(0), enabled(1)')
ospf3NewCfgIntfEncryType = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 9, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("null", 0), ("des", 1), ("tripledes", 2), ("aes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospf3NewCfgIntfEncryType.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgIntfEncryType.setDescription('Encryption Type null(0), des(1), 3des(2), aes(3)')
ospf3NewCfgIntfEncryKey = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 9, 1, 26), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 48))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospf3NewCfgIntfEncryKey.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgIntfEncryKey.setDescription('Encryption Key Hex-string DES key - 16 chars (64 bits) Hex-string AES key - 32 chars (128 bits) Hex-string 3DES key - 48 chars (192 bits)')
ospf3NewCfgIntfEncryAuthType = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 9, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2, 1))).clone(namedValues=NamedValues(("none", 0), ("md5", 2), ("sha1", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospf3NewCfgIntfEncryAuthType.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgIntfEncryAuthType.setDescription('Encryption Authentication Type none(0), md5(2), sha1(1)')
ospf3NewCfgIntfEncryAuthKey = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 9, 1, 28), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospf3NewCfgIntfEncryAuthKey.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgIntfEncryAuthKey.setDescription('Encryption Authentication Key Hex-string MD5 key - 32 chars (128 bits), Hex-string SHA-1 key - 40 chars (160 bits)')
ospf3NewCfgIntfEncryReset = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 9, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("other", 0), ("reset", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospf3NewCfgIntfEncryReset.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgIntfEncryReset.setDescription('Reset Encryption configuration other(0), reset(1)')
ospf3NewCfgIntfLsaSupress = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 9, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospf3NewCfgIntfLsaSupress.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgIntfLsaSupress.setDescription('LSA Supression on interface disabled(0), enabled(1)')
ospf3CurCfgVirtIntfTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 10), )
if mibBuilder.loadTexts: ospf3CurCfgVirtIntfTable.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgVirtIntfTable.setDescription('The table of OSPFv3 Virtual Interface configuration in the current configuration.')
ospf3CurCfgVirtIntfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 10, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ospf3CurCfgVirtIntfIndex"))
if mibBuilder.loadTexts: ospf3CurCfgVirtIntfEntry.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgVirtIntfEntry.setDescription('Information about an OSPFv3v3 virtual Interface.')
ospf3CurCfgVirtIntfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 10, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgVirtIntfIndex.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgVirtIntfIndex.setDescription('The OSPFv3 Virtual Interface number for which the OSPFv3 Virtual Interface table is related.')
ospf3CurCfgVirtIntfAreaId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 10, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 5))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgVirtIntfAreaId.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgVirtIntfAreaId.setDescription('The index of the OSPFv3 area to which this virtual interface belongs.')
ospf3CurCfgVirtIntfNbr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 10, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgVirtIntfNbr.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgVirtIntfNbr.setDescription('The IP Address of the OSPFv3 neighbor for this virtual interface.')
ospf3CurCfgVirtIntfHello = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 10, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgVirtIntfHello.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgVirtIntfHello.setDescription('Hello interval')
ospf3CurCfgVirtIntfDead = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 10, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgVirtIntfDead.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgVirtIntfDead.setDescription('Dead interval')
ospf3CurCfgVirtIntfTrans = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 10, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1800))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgVirtIntfTrans.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgVirtIntfTrans.setDescription('Transmit delay')
ospf3CurCfgVirtIntfRetra = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 10, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1800))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgVirtIntfRetra.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgVirtIntfRetra.setDescription('Retransmit interval')
ospf3CurCfgVirtIntfStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 10, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgVirtIntfStatus.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgVirtIntfStatus.setDescription('Status disabled(0), enabled(1)')
ospf3NewCfgVirtIntfTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 11), )
if mibBuilder.loadTexts: ospf3NewCfgVirtIntfTable.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgVirtIntfTable.setDescription('The table of OSPFv3 Virtual interface in the new configuration block.')
ospf3NewCfgVirtIntfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 11, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ospf3NewCfgVirtIntfIndex"))
if mibBuilder.loadTexts: ospf3NewCfgVirtIntfEntry.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgVirtIntfEntry.setDescription('Information about an OSPFv3 virtual interface.')
ospf3NewCfgVirtIntfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 11, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3NewCfgVirtIntfIndex.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgVirtIntfIndex.setDescription('The OSPFv3 Virtual Interface number for which the OSPFv3 Virtual Interface table is related.')
ospf3NewCfgVirtIntfAreaId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 11, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 5))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospf3NewCfgVirtIntfAreaId.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgVirtIntfAreaId.setDescription('The index of the OSPFv3 area to which this virtual interface belongs.')
ospf3NewCfgVirtIntfNbr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 11, 1, 4), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospf3NewCfgVirtIntfNbr.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgVirtIntfNbr.setDescription('The IP Address of the OSPFv3 neighbor for this virtual interface.')
ospf3NewCfgVirtIntfHello = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 11, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospf3NewCfgVirtIntfHello.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgVirtIntfHello.setDescription('Hello interval(1..65535)')
ospf3NewCfgVirtIntfDead = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 11, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospf3NewCfgVirtIntfDead.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgVirtIntfDead.setDescription('Dead interval(1..65535)')
ospf3NewCfgVirtIntfTrans = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 11, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1800))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospf3NewCfgVirtIntfTrans.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgVirtIntfTrans.setDescription('Transmit delay(1..1800)')
ospf3NewCfgVirtIntfRetra = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 11, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1800))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospf3NewCfgVirtIntfRetra.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgVirtIntfRetra.setDescription('Retransmit interval(1..1800)')
ospf3NewCfgVirtIntfStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 11, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospf3NewCfgVirtIntfStatus.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgVirtIntfStatus.setDescription('Status disabled(0), enabled(1) ')
ospf3NewCfgVirtIntfDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 11, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("other", 0), ("delete", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospf3NewCfgVirtIntfDelete.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgVirtIntfDelete.setDescription('Delete other(0), delete(1)')
ospf3CurCfgRangeTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 12), )
if mibBuilder.loadTexts: ospf3CurCfgRangeTable.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgRangeTable.setDescription('The table of OSPFv3 summary range in the current configuration.')
ospf3CurCfgRangeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 12, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ospf3CurCfgRangeIndex"))
if mibBuilder.loadTexts: ospf3CurCfgRangeEntry.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgRangeEntry.setDescription('Information about an OSPFv3 summary range.')
ospf3CurCfgRangeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 12, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgRangeIndex.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgRangeIndex.setDescription('The range number for which the OSPFv3 summary range table is related.')
ospf3CurCfgRangeAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 12, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgRangeAddr.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgRangeAddr.setDescription('The IPv6 Address of the range.')
ospf3CurCfgRangePrefixLen = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 12, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgRangePrefixLen.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgRangePrefixLen.setDescription('The prefix length of the range.')
ospf3CurCfgRangeAreaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 12, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgRangeAreaIndex.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgRangeAreaIndex.setDescription('The area index.')
ospf3CurCfgRangeHideState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 12, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgRangeHideState.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgRangeHideState.setDescription('The state of the hide range.')
ospf3CurCfgRangeLsaType = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 12, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(8195, 8199))).clone(namedValues=NamedValues(("summary", 8195), ("type7", 8199)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgRangeLsaType.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgRangeLsaType.setDescription('The LSA type for aggregation. summary(8195), type7(8199)')
ospf3CurCfgRangeRouteTag = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 12, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgRangeRouteTag.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgRangeRouteTag.setDescription('The route tag of the range.')
ospf3CurCfgRangeState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 12, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgRangeState.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgRangeState.setDescription('The state of the range.')
ospf3NewCfgRangeTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 13), )
if mibBuilder.loadTexts: ospf3NewCfgRangeTable.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgRangeTable.setDescription('The table of OSPFv3 summary range in the new configuration.')
ospf3NewCfgRangeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 13, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ospf3NewCfgRangeIndex"))
if mibBuilder.loadTexts: ospf3NewCfgRangeEntry.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgRangeEntry.setDescription('Information about an OSPFv3 summary range.')
ospf3NewCfgRangeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 13, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3NewCfgRangeIndex.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgRangeIndex.setDescription('The range number for which the OSPFv3 summary range table is related.')
ospf3NewCfgRangeAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 13, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospf3NewCfgRangeAddr.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgRangeAddr.setDescription('The IPv6 Address of the range. Address should be 4-byte haxadecimal colon notation. Valid IPv6 address should be in any of the following forms xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx or xxxx::xxxx:xxxx:xxxx:xxxx or ::xxxx')
ospf3NewCfgRangePrefixLen = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 13, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 128))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospf3NewCfgRangePrefixLen.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgRangePrefixLen.setDescription('The prefix length of the range.')
ospf3NewCfgRangeAreaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 13, 1, 4), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospf3NewCfgRangeAreaIndex.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgRangeAreaIndex.setDescription('The area index.')
ospf3NewCfgRangeHideState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 13, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospf3NewCfgRangeHideState.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgRangeHideState.setDescription('The state of the hide range.')
ospf3NewCfgRangeLsaType = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 13, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(8195, 8199))).clone(namedValues=NamedValues(("summary", 8195), ("type7", 8199)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospf3NewCfgRangeLsaType.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgRangeLsaType.setDescription('The LSA type for aggregation. summary(8195), type7(8199)')
ospf3NewCfgRangeRouteTag = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 13, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospf3NewCfgRangeRouteTag.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgRangeRouteTag.setDescription('The route tag of the range.')
ospf3NewCfgRangeState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 13, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospf3NewCfgRangeState.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgRangeState.setDescription('The state of the range.')
ospf3NewCfgRangeDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 13, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("delete", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospf3NewCfgRangeDelete.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgRangeDelete.setDescription('When set to the value of 2 (delete), the entire row is deleted. When read, other(1) is returned. Setting the value to anything other than 2(delete) has no effect on the state of the row.')
ospf3CurCfgExtRangeTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 14), )
if mibBuilder.loadTexts: ospf3CurCfgExtRangeTable.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgExtRangeTable.setDescription('The table of OSPFv3 AS-External range in the current configuration.')
ospf3CurCfgExtRangeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 14, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ospf3CurCfgExtRangeIndex"))
if mibBuilder.loadTexts: ospf3CurCfgExtRangeEntry.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgExtRangeEntry.setDescription('Information about an OSPFv3 AS-External range.')
ospf3CurCfgExtRangeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 14, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgExtRangeIndex.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgExtRangeIndex.setDescription('The range number for which the OSPFv3 AS-External range table is related.')
ospf3CurCfgExtRangeAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 14, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgExtRangeAddr.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgExtRangeAddr.setDescription('The IPv6 Address of the AS-External range.')
ospf3CurCfgExtRangePrefixLen = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 14, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgExtRangePrefixLen.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgExtRangePrefixLen.setDescription('The prefix length of the AS-External range.')
ospf3CurCfgExtRangeAreaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 14, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgExtRangeAreaIndex.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgExtRangeAreaIndex.setDescription('The area index.')
ospf3CurCfgExtRangeTranslation = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 14, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgExtRangeTranslation.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgExtRangeTranslation.setDescription('The state of the setting the P-bit in the generated LSA.')
ospf3CurCfgExtRangeAggrEffect = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 14, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("advertise", 1), ("not-advertise", 2), ("allowAll", 3), ("denyAll", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgExtRangeAggrEffect.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgExtRangeAggrEffect.setDescription('The aggregation effect. advertise(1), not-advertise(2), allowAll(3), denyAll(4)')
ospf3CurCfgExtRangeState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 14, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgExtRangeState.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgExtRangeState.setDescription('The state of the AS-External range.')
ospf3NewCfgExtRangeTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 15), )
if mibBuilder.loadTexts: ospf3NewCfgExtRangeTable.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgExtRangeTable.setDescription('The table of OSPFv3 summary AS-External range in the new configuration.')
ospf3NewCfgExtRangeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 15, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ospf3NewCfgExtRangeIndex"))
if mibBuilder.loadTexts: ospf3NewCfgExtRangeEntry.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgExtRangeEntry.setDescription('Information about an OSPFv3 summary AS-External range.')
ospf3NewCfgExtRangeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 15, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3NewCfgExtRangeIndex.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgExtRangeIndex.setDescription('The range number for which the OSPFv3 AS-External range table is related.')
ospf3NewCfgExtRangeAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 15, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospf3NewCfgExtRangeAddr.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgExtRangeAddr.setDescription('The IPv6 Address of the AS-External range. Address should be 4-byte haxadecimal colon notation. Valid IPv6 address should be in any of the following forms xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx or xxxx::xxxx:xxxx:xxxx:xxxx or ::xxxx')
ospf3NewCfgExtRangePrefixLen = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 15, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 128))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospf3NewCfgExtRangePrefixLen.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgExtRangePrefixLen.setDescription('The prefix length of the AS-External range.')
ospf3NewCfgExtRangeAreaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 15, 1, 4), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospf3NewCfgExtRangeAreaIndex.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgExtRangeAreaIndex.setDescription('The area index.')
ospf3NewCfgExtRangeTranslation = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 15, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospf3NewCfgExtRangeTranslation.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgExtRangeTranslation.setDescription('The state of the setting the P-bit in the generated LSA.')
ospf3NewCfgExtRangeAggrEffect = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 15, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("advertise", 1), ("not-advertise", 2), ("allowAll", 3), ("denyAll", 4)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospf3NewCfgExtRangeAggrEffect.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgExtRangeAggrEffect.setDescription('The aggregation effect. advertise(1), not-advertise(2), allowAll(3), denyAll(4)')
ospf3NewCfgExtRangeState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 15, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospf3NewCfgExtRangeState.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgExtRangeState.setDescription('The state of the AS-External range.')
ospf3NewCfgExtRangeDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 15, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("delete", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospf3NewCfgExtRangeDelete.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgExtRangeDelete.setDescription('When set to the value of 2 (delete), the entire row is deleted. When read, other(1) is returned. Setting the value to anything other than 2(delete) has no effect on the state of the row.')
ospf3CurCfgRedistTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 16), )
if mibBuilder.loadTexts: ospf3CurCfgRedistTable.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgRedistTable.setDescription('The table of OSPFv3 redistribution entries in the current configuration.')
ospf3CurCfgRedistEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 16, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ospf3CurCfgRedistIndex"))
if mibBuilder.loadTexts: ospf3CurCfgRedistEntry.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgRedistEntry.setDescription('Information about an OSPFv3 redistribution entry.')
ospf3CurCfgRedistIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 16, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgRedistIndex.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgRedistIndex.setDescription('The redistribution entry number for which the OSPFv3 redistribution entry table is related.')
ospf3CurCfgRedistAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 16, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgRedistAddr.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgRedistAddr.setDescription('The IPv6 Address of the redistribution entry.')
ospf3CurCfgRedistPrefixLen = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 16, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgRedistPrefixLen.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgRedistPrefixLen.setDescription('The prefix length of the redistribution entry.')
ospf3CurCfgRedistMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 16, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgRedistMetric.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgRedistMetric.setDescription('The metric to be applied to the route.')
ospf3CurCfgRedistMetricType = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 16, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4))).clone(namedValues=NamedValues(("asExttype1", 3), ("asExttype2", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgRedistMetricType.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgRedistMetricType.setDescription('The metric type. asExttype1(3), asExttype2(4)')
ospf3CurCfgRedistRouteTag = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 16, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgRedistRouteTag.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgRedistRouteTag.setDescription('The route tag of the redistribution entry.')
ospf3CurCfgRedistRouteTagTypeManual = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 16, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("auto", 0), ("manual", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgRedistRouteTagTypeManual.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgRedistRouteTagTypeManual.setDescription('Indicates if the route tag is set manually. ')
ospf3CurCfgRedistState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 16, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgRedistState.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgRedistState.setDescription('The state of the redistribution entry.')
ospf3NewCfgRedistTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 17), )
if mibBuilder.loadTexts: ospf3NewCfgRedistTable.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgRedistTable.setDescription('The table of OSPFv3 summary redistribution entry in the new configuration.')
ospf3NewCfgRedistEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 17, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ospf3NewCfgRedistIndex"))
if mibBuilder.loadTexts: ospf3NewCfgRedistEntry.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgRedistEntry.setDescription('Information about an OSPFv3 summary redistribution entry.')
ospf3NewCfgRedistIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 17, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3NewCfgRedistIndex.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgRedistIndex.setDescription('The redistribution entry number for which the OSPFv3 redistribution entry table is related.')
ospf3NewCfgRedistAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 17, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospf3NewCfgRedistAddr.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgRedistAddr.setDescription('The IPv6 Address of the redistribution entry. Address should be 4-byte haxadecimal colon notation. Valid IPv6 address should be in any of the following forms xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx or xxxx::xxxx:xxxx:xxxx:xxxx or ::xxxx')
ospf3NewCfgRedistPrefixLen = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 17, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 128))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospf3NewCfgRedistPrefixLen.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgRedistPrefixLen.setDescription('The prefix length of the redistribution entry.')
ospf3NewCfgRedistMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 17, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16777215))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospf3NewCfgRedistMetric.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgRedistMetric.setDescription('The metric to be applied to the route.')
ospf3NewCfgRedistMetricType = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 17, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4))).clone(namedValues=NamedValues(("asExttype1", 3), ("asExttype2", 4)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospf3NewCfgRedistMetricType.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgRedistMetricType.setDescription('The metric type. asExttype1(3), asExttype2(4)')
ospf3NewCfgRedistRouteTag = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 17, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospf3NewCfgRedistRouteTag.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgRedistRouteTag.setDescription('The route tag of the redistribution entry.')
ospf3NewCfgRedistRouteTagTypeManual = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 17, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("auto", 0), ("manual", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospf3NewCfgRedistRouteTagTypeManual.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgRedistRouteTagTypeManual.setDescription('Indicates if the route tag is set manually. ')
ospf3NewCfgRedistState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 17, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospf3NewCfgRedistState.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgRedistState.setDescription('The state of the redistribution entry.')
ospf3NewCfgRedistDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 17, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("delete", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospf3NewCfgRedistDelete.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgRedistDelete.setDescription('When set to the value of 2 (delete), the entire row is deleted. When read, other(1) is returned. Setting the value to anything other than 2(delete) has no effect on the state of the row.')
ospf3RouteRedistribution = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 18))
ospf3RedistributeConnected = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 18, 1))
ospf3CurCfgConnectedMetric = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 18, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777214))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgConnectedMetric.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgConnectedMetric.setDescription('The metric to be assigned to Connected routes.')
ospf3NewCfgConnectedMetric = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 18, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777214))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospf3NewCfgConnectedMetric.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgConnectedMetric.setDescription('The metric to be assigned to Connected routes.')
ospf3CurCfgConnectedMetricType = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 18, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("type1", 2), ("type2", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgConnectedMetricType.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgConnectedMetricType.setDescription('The AS External metric type for Connected routes.')
ospf3NewCfgConnectedMetricType = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 18, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("type1", 2), ("type2", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospf3NewCfgConnectedMetricType.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgConnectedMetricType.setDescription('The AS External metric type for Connected routes.')
ospf3CurCfgConnectedRouteTag = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 18, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgConnectedRouteTag.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgConnectedRouteTag.setDescription('Assigned route tag ')
ospf3NewCfgConnectedRouteTag = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 18, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospf3NewCfgConnectedRouteTag.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgConnectedRouteTag.setDescription('Assigned route tag ')
ospf3CurCfgConnectedRouteTagTypeManual = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 18, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("auto", 0), ("manual", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgConnectedRouteTagTypeManual.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgConnectedRouteTagTypeManual.setDescription('Indicates if the route tag is set manually.')
ospf3NewCfgConnectedRouteTagTypeManual = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 18, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("auto", 0), ("manual", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospf3NewCfgConnectedRouteTagTypeManual.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgConnectedRouteTagTypeManual.setDescription('Indicates if the route tag is set manually.')
ospf3RedistributeStatic = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 18, 2))
ospf3CurCfgStaticMetric = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 18, 2, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777214))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgStaticMetric.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgStaticMetric.setDescription('The metric to be assigned to static routes.')
ospf3NewCfgStaticMetric = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 18, 2, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777214))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospf3NewCfgStaticMetric.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgStaticMetric.setDescription('The metric to be assigned to static routes.')
ospf3CurCfgStaticMetricType = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 18, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("type1", 2), ("type2", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgStaticMetricType.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgStaticMetricType.setDescription('The AS External metric type for static routes.')
ospf3NewCfgStaticMetricType = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 18, 2, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("type1", 2), ("type2", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospf3NewCfgStaticMetricType.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgStaticMetricType.setDescription('The AS External metric type for static routes.')
ospf3CurCfgStaticRouteTag = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 18, 2, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgStaticRouteTag.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgStaticRouteTag.setDescription('Assigned route tag ')
ospf3NewCfgStaticRouteTag = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 18, 2, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospf3NewCfgStaticRouteTag.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgStaticRouteTag.setDescription('Assigned route tag ')
ospf3CurCfgStaticRouteTagTypeManual = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 18, 2, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("auto", 0), ("manual", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CurCfgStaticRouteTagTypeManual.setStatus('current')
if mibBuilder.loadTexts: ospf3CurCfgStaticRouteTagTypeManual.setDescription('Indicates if the route tag is set manually.')
ospf3NewCfgStaticRouteTagTypeManual = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 26, 18, 2, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("auto", 0), ("manual", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospf3NewCfgStaticRouteTagTypeManual.setStatus('current')
if mibBuilder.loadTexts: ospf3NewCfgStaticRouteTagTypeManual.setDescription('Indicates if the route tag is set manually.')
ipv6PmtuCurTimeout = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 28, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6PmtuCurTimeout.setStatus('current')
if mibBuilder.loadTexts: ipv6PmtuCurTimeout.setDescription('IPv6 PMTU Expired Time Value(0|10-100), 0 indicates INFINITY. Other values should be in [10, 100]')
ipv6PmtuNewTimeout = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 28, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipv6PmtuNewTimeout.setStatus('current')
if mibBuilder.loadTexts: ipv6PmtuNewTimeout.setDescription('IPv6 PMTU Expired Time Value(0|10-100), 0 indicates INFINITY. Other values should be in [10, 100]')
ipv6PmtuEntriesClearAll = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 28, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("clear", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipv6PmtuEntriesClearAll.setStatus('current')
if mibBuilder.loadTexts: ipv6PmtuEntriesClearAll.setDescription('When set to clear(2),clears all ipv6 PMTU entries. Otherwhise nothing is done.')
ipCurCfgRouterID = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 14, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgRouterID.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgRouterID.setDescription('The router ID of the switch.')
ipNewCfgRouterID = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 14, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipNewCfgRouterID.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgRouterID.setDescription('The router ID of the switch.')
ipFloodCurCfgFlood = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 14, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 0))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 0)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipFloodCurCfgFlood.setStatus('current')
if mibBuilder.loadTexts: ipFloodCurCfgFlood.setDescription('Enable or disable flooding unregistered IPMCs')
ipFloodNewCfgFlood = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 14, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 0))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipFloodNewCfgFlood.setStatus('current')
if mibBuilder.loadTexts: ipFloodNewCfgFlood.setDescription('Enable or disable flooding unregistered IPMCs')
igmpCurCfgOnOff = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpCurCfgOnOff.setStatus('current')
if mibBuilder.loadTexts: igmpCurCfgOnOff.setDescription('Globally turn IGMP On/Off.')
igmpNewCfgOnOff = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igmpNewCfgOnOff.setStatus('current')
if mibBuilder.loadTexts: igmpNewCfgOnOff.setDescription('Globally turn IGMP On/Off.')
igmpSnoopCfg = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 9))
igmpSnoopCurCfgMrto = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 9, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpSnoopCurCfgMrto.setStatus('current')
if mibBuilder.loadTexts: igmpSnoopCurCfgMrto.setDescription('The value of multicast router timeout in the current config.')
igmpSnoopNewCfgMrto = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 9, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igmpSnoopNewCfgMrto.setStatus('current')
if mibBuilder.loadTexts: igmpSnoopNewCfgMrto.setDescription('The value of multicast router timeout in the new config.')
igmpSnoopCurCfgAggrEnaDis = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 9, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpSnoopCurCfgAggrEnaDis.setStatus('current')
if mibBuilder.loadTexts: igmpSnoopCurCfgAggrEnaDis.setDescription('Enable/Disable of IGMP Report aggregation.')
igmpSnoopNewCfgAggrEnaDis = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 9, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igmpSnoopNewCfgAggrEnaDis.setStatus('current')
if mibBuilder.loadTexts: igmpSnoopNewCfgAggrEnaDis.setDescription('Enable/Disable of IGMP Report aggregation.')
igmpSnoopCurCfgEnaDis = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 9, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpSnoopCurCfgEnaDis.setStatus('current')
if mibBuilder.loadTexts: igmpSnoopCurCfgEnaDis.setDescription('The current status of IGMP Snooping.')
igmpSnoopNewCfgEnaDis = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 9, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igmpSnoopNewCfgEnaDis.setStatus('current')
if mibBuilder.loadTexts: igmpSnoopNewCfgEnaDis.setDescription('Set Enable/Disable of IGMP Snooping.')
igmpSnoopNewCfgVlanAdd = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 9, 13), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igmpSnoopNewCfgVlanAdd.setStatus('current')
if mibBuilder.loadTexts: igmpSnoopNewCfgVlanAdd.setDescription('The VLAN to be added to snooping vlan list. When read, 0 is returned.')
igmpSnoopNewCfgVlanRem = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 9, 14), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igmpSnoopNewCfgVlanRem.setStatus('current')
if mibBuilder.loadTexts: igmpSnoopNewCfgVlanRem.setDescription('The VLAN to be removed from snooping vlan list. When read, 0 is returned.')
igmpSnoopNewCfgVlanClear = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 9, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clear", 1), ("ok", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igmpSnoopNewCfgVlanClear.setStatus('current')
if mibBuilder.loadTexts: igmpSnoopNewCfgVlanClear.setDescription('Removing ALL Snooping Vlans.')
igmpSnoopCurCfgVlanBmap = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 9, 16), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpSnoopCurCfgVlanBmap.setStatus('current')
if mibBuilder.loadTexts: igmpSnoopCurCfgVlanBmap.setDescription('The snooping vlans present in the vlan map list. The snooping vlans are presented in a bitmap format. in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ Vlan 9 || || || ||___ Vlan 8 || |____ Vlan 7 || . . . ||_________ Vlan 2 |__________ Vlan 1 where x : 1 - The represented vlan has snoop enabled 0 - The represented vlan does not have snooping enabled.')
igmpSnoopNewCfgVlanBmap = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 9, 17), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igmpSnoopNewCfgVlanBmap.setStatus('current')
if mibBuilder.loadTexts: igmpSnoopNewCfgVlanBmap.setDescription('The snooping vlans present in the vlan map list. The snooping vlans are presented in a bitmap format. in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ Vlan 9 || || || ||___ Vlan 8 || |____ Vlan 7 || . . . ||_________ Vlan 2 |__________ Vlan 1 where x : 1 - The represented vlan has snoop enabled 0 - The represented vlan does not have snooping enabled.')
igmpSnoopNewCfgVlanFastlvAdd = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 9, 18), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igmpSnoopNewCfgVlanFastlvAdd.setStatus('current')
if mibBuilder.loadTexts: igmpSnoopNewCfgVlanFastlvAdd.setDescription('The VLAN to be added to quick-leave vlan list. When read, 0 is returned.')
igmpSnoopNewCfgVlanFastlvRem = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 9, 19), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igmpSnoopNewCfgVlanFastlvRem.setStatus('current')
if mibBuilder.loadTexts: igmpSnoopNewCfgVlanFastlvRem.setDescription('The VLAN to be removed from quick-leave vlan list. When read, 0 is returned.')
igmpSnoopCurCfgVlanFastlvBmap = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 9, 20), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpSnoopCurCfgVlanFastlvBmap.setStatus('current')
if mibBuilder.loadTexts: igmpSnoopCurCfgVlanFastlvBmap.setDescription('The fast-leave enabled vlans present in the vlan map list. The fast-leave enabled vlans are presented in a bitmap format. in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ Vlan 9 || || || ||___ Vlan 8 || |____ Vlan 7 || . . . ||_________ Vlan 2 |__________ Vlan 1 where x : 1 - The represented vlan has fast-leave enabled 0 - The represented vlan does not have fast-leave enabled.')
igmpSnoopNewCfgVlanFastlvBmap = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 9, 21), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igmpSnoopNewCfgVlanFastlvBmap.setStatus('current')
if mibBuilder.loadTexts: igmpSnoopNewCfgVlanFastlvBmap.setDescription('The fast-leave enabled vlans present in the vlan map list. The fast-leave enabled vlans are presented in a bitmap format. in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ Vlan 9 || || || ||___ Vlan 8 || |____ Vlan 7 || . . . ||_________ Vlan 2 |__________ Vlan 1 where x : 1 - The represented vlan has fast-leave enabled 0 - The represented vlan does not have fast-leave enabled.')
igmpSnoopCurCfgTimeout = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 9, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpSnoopCurCfgTimeout.setStatus('current')
if mibBuilder.loadTexts: igmpSnoopCurCfgTimeout.setDescription('Query Response Interval.')
igmpSnoopNewCfgTimeout = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 9, 23), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igmpSnoopNewCfgTimeout.setStatus('current')
if mibBuilder.loadTexts: igmpSnoopNewCfgTimeout.setDescription('Query Response Interval.')
igmpSnoopCurCfgQInterval = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 9, 24), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpSnoopCurCfgQInterval.setStatus('current')
if mibBuilder.loadTexts: igmpSnoopCurCfgQInterval.setDescription('IGMP Query Interval of current config.')
igmpSnoopNewCfgQInterval = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 9, 25), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igmpSnoopNewCfgQInterval.setStatus('current')
if mibBuilder.loadTexts: igmpSnoopNewCfgQInterval.setDescription('IGMP Query Interval of new config.')
igmpSnoopCurCfgSrcIp = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 9, 26), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpSnoopCurCfgSrcIp.setStatus('current')
if mibBuilder.loadTexts: igmpSnoopCurCfgSrcIp.setDescription('The source ip for GSQ proxy in current config.')
igmpSnoopNewCfgSrcIp = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 9, 27), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igmpSnoopNewCfgSrcIp.setStatus('current')
if mibBuilder.loadTexts: igmpSnoopNewCfgSrcIp.setDescription('The source ip for GSQ proxy in new config.')
igmpSnoopCurCfgFlood = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 9, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpSnoopCurCfgFlood.setStatus('current')
if mibBuilder.loadTexts: igmpSnoopCurCfgFlood.setDescription('Enable/Disable of flood unregistered IPMC')
igmpSnoopNewCfgFlood = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 9, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igmpSnoopNewCfgFlood.setStatus('current')
if mibBuilder.loadTexts: igmpSnoopNewCfgFlood.setDescription('Enable/Disable of flood unregistered IPMC')
igmpSnoopSetToDefault = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 9, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("none", 1), ("setDefault", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igmpSnoopSetToDefault.setStatus('current')
if mibBuilder.loadTexts: igmpSnoopSetToDefault.setDescription('When setting the value setDefault(2), the IGMP Snooping configuration is set to the default values. When reading, none(1) is always returned.')
igmpSnoopCurCfgRtrAlert = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 9, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpSnoopCurCfgRtrAlert.setStatus('current')
if mibBuilder.loadTexts: igmpSnoopCurCfgRtrAlert.setDescription('Enable/disable sending IGMP messages with Router Alert option.')
igmpSnoopNewCfgRtrAlert = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 9, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igmpSnoopNewCfgRtrAlert.setStatus('current')
if mibBuilder.loadTexts: igmpSnoopNewCfgRtrAlert.setDescription('Enable/disable sending IGMP messages with Router Alert option.')
igmpSnoopCurCfgRobustness = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 9, 36), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpSnoopCurCfgRobustness.setStatus('current')
if mibBuilder.loadTexts: igmpSnoopCurCfgRobustness.setDescription('IGMP Robustness variable of current config.')
igmpSnoopNewCfgRobustness = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 9, 37), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igmpSnoopNewCfgRobustness.setStatus('current')
if mibBuilder.loadTexts: igmpSnoopNewCfgRobustness.setDescription('IGMP Robustness variable of new config.')
igmpStaticMrtrCfg = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 10))
igmpFilterCfg = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 11))
igmpV3SnoopCfg = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 14))
igmpV3SnoopCurCfgSources = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 14, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpV3SnoopCurCfgSources.setStatus('current')
if mibBuilder.loadTexts: igmpV3SnoopCurCfgSources.setDescription('Number of sources to snoop in a group record in current config.')
igmpV3SnoopNewCfgSources = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 14, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igmpV3SnoopNewCfgSources.setStatus('current')
if mibBuilder.loadTexts: igmpV3SnoopNewCfgSources.setDescription('Number of sources to snoop in a group record in new config.')
igmpV3SnoopCurCfgEnaDis = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 14, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpV3SnoopCurCfgEnaDis.setStatus('current')
if mibBuilder.loadTexts: igmpV3SnoopCurCfgEnaDis.setDescription('The current status of IGMP V3 Snooping.')
igmpV3SnoopNewCfgEnaDis = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 14, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igmpV3SnoopNewCfgEnaDis.setStatus('current')
if mibBuilder.loadTexts: igmpV3SnoopNewCfgEnaDis.setDescription('Set Enable/Disable of IGMP V3 Snooping.')
igmpV3SnoopCurCfgExcludeEnaDis = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 14, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpV3SnoopCurCfgExcludeEnaDis.setStatus('current')
if mibBuilder.loadTexts: igmpV3SnoopCurCfgExcludeEnaDis.setDescription('The current status of IGMP V3 EXCLUDE filter-mode Snooping.')
igmpV3SnoopNewCfgExcludeEnaDis = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 14, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igmpV3SnoopNewCfgExcludeEnaDis.setStatus('current')
if mibBuilder.loadTexts: igmpV3SnoopNewCfgExcludeEnaDis.setDescription('Set Enable/Disable of IGMP V3 EXCLUDE filter-mode Snooping.')
igmpV3SnoopCurCfgV1V2EnaDis = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 14, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpV3SnoopCurCfgV1V2EnaDis.setStatus('current')
if mibBuilder.loadTexts: igmpV3SnoopCurCfgV1V2EnaDis.setDescription('The current status of IGMP V1/V2 Report Snooping.')
igmpV3SnoopNewCfgV1V2EnaDis = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 14, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igmpV3SnoopNewCfgV1V2EnaDis.setStatus('current')
if mibBuilder.loadTexts: igmpV3SnoopNewCfgV1V2EnaDis.setDescription('Set Enable/Disable of IGMP V1/V2 Report Snooping.')
igmpStaticMrtrCurCfgTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 10, 1), )
if mibBuilder.loadTexts: igmpStaticMrtrCurCfgTable.setStatus('current')
if mibBuilder.loadTexts: igmpStaticMrtrCurCfgTable.setDescription('The IGMP Static Multicast Router table in the current configuration block.')
igmpStaticMrtrCurCfgTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 10, 1, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "igmpStaticMrtrCurCfgIndx"))
if mibBuilder.loadTexts: igmpStaticMrtrCurCfgTableEntry.setStatus('current')
if mibBuilder.loadTexts: igmpStaticMrtrCurCfgTableEntry.setDescription('A row in the Static Multicast Router table.')
igmpStaticMrtrCurCfgIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 10, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpStaticMrtrCurCfgIndx.setStatus('current')
if mibBuilder.loadTexts: igmpStaticMrtrCurCfgIndx.setDescription('The IGMP Multicast Router table port index.')
igmpStaticMrtrCurCfgPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 10, 1, 1, 2), PortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpStaticMrtrCurCfgPortId.setStatus('current')
if mibBuilder.loadTexts: igmpStaticMrtrCurCfgPortId.setDescription('The IGMP Multicast Router port in the current configuration block.')
igmpStaticMrtrCurCfgVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 10, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpStaticMrtrCurCfgVlanId.setStatus('current')
if mibBuilder.loadTexts: igmpStaticMrtrCurCfgVlanId.setDescription('The IGMP Multicast Router port in the current configuration block.')
igmpStaticMrtrCurCfgVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 10, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("version1", 1), ("version2", 2), ("version3", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpStaticMrtrCurCfgVersion.setStatus('current')
if mibBuilder.loadTexts: igmpStaticMrtrCurCfgVersion.setDescription('The IGMP version of the IGMP Static Multicast Router.')
igmpStaticMrtrNewCfgTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 10, 2), )
if mibBuilder.loadTexts: igmpStaticMrtrNewCfgTable.setStatus('current')
if mibBuilder.loadTexts: igmpStaticMrtrNewCfgTable.setDescription('The IGMP Static Multicast Router table in the new configuration block.')
igmpStaticMrtrNewCfgTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 10, 2, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "igmpStaticMrtrNewCfgIndx"))
if mibBuilder.loadTexts: igmpStaticMrtrNewCfgTableEntry.setStatus('current')
if mibBuilder.loadTexts: igmpStaticMrtrNewCfgTableEntry.setDescription('A row in the Static Multicast Router table.')
igmpStaticMrtrNewCfgIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 10, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpStaticMrtrNewCfgIndx.setStatus('current')
if mibBuilder.loadTexts: igmpStaticMrtrNewCfgIndx.setDescription('The IGMP Multicast Router table port index.')
igmpStaticMrtrNewCfgPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 10, 2, 1, 2), PortNumber()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igmpStaticMrtrNewCfgPortId.setStatus('current')
if mibBuilder.loadTexts: igmpStaticMrtrNewCfgPortId.setDescription('The IGMP Multicast Router port in the new configuration block.')
igmpStaticMrtrNewCfgVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 10, 2, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igmpStaticMrtrNewCfgVlanId.setStatus('current')
if mibBuilder.loadTexts: igmpStaticMrtrNewCfgVlanId.setDescription('The IGMP Multicast Router port in the new configuration block.')
igmpStaticMrtrNewCfgVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 10, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("version1", 1), ("version2", 2), ("version3", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igmpStaticMrtrNewCfgVersion.setStatus('current')
if mibBuilder.loadTexts: igmpStaticMrtrNewCfgVersion.setDescription('The IGMP version of the IGMP Static Multicast Router.')
igmpStaticMrtrNewCfgDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 10, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("delete", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igmpStaticMrtrNewCfgDelete.setStatus('current')
if mibBuilder.loadTexts: igmpStaticMrtrNewCfgDelete.setDescription('When set to the value of 2 (delete), the entire row is deleted. When read, other(1) is returned. Setting the value to anything other than 2(delete) has no effect on the state of the row.')
igmpStaticMrtrNewCfgClear = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 10, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("clear", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igmpStaticMrtrNewCfgClear.setStatus('current')
if mibBuilder.loadTexts: igmpStaticMrtrNewCfgClear.setDescription('When set to the value of 2 (clear), the entire table is deleted. When read, other(1) is returned. Setting the value to anything other than 2(clear) has no effect on the table.')
igmpFltCurCfgTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 11, 1), )
if mibBuilder.loadTexts: igmpFltCurCfgTable.setStatus('current')
if mibBuilder.loadTexts: igmpFltCurCfgTable.setDescription('The IGMP filtering table in the current configuration block.')
igmpFltCurCfgTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 11, 1, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "igmpFltCurCfgIndx"))
if mibBuilder.loadTexts: igmpFltCurCfgTableEntry.setStatus('current')
if mibBuilder.loadTexts: igmpFltCurCfgTableEntry.setDescription('A row in the filtering table.')
igmpFltCurCfgIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 11, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpFltCurCfgIndx.setStatus('current')
if mibBuilder.loadTexts: igmpFltCurCfgIndx.setDescription('The IGMP filter table index.')
igmpFltCurCfgMcastIp1 = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 11, 1, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpFltCurCfgMcastIp1.setStatus('current')
if mibBuilder.loadTexts: igmpFltCurCfgMcastIp1.setDescription('Range1 Multicast IP address to be filtered.')
igmpFltCurCfgMcastIp2 = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 11, 1, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpFltCurCfgMcastIp2.setStatus('current')
if mibBuilder.loadTexts: igmpFltCurCfgMcastIp2.setDescription('Range2 Multicast IP address to be filtered.')
igmpFltCurCfgAction = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 11, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("allow", 1), ("deny", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpFltCurCfgAction.setStatus('current')
if mibBuilder.loadTexts: igmpFltCurCfgAction.setDescription('The action for the IGMP filtering rule.')
igmpFltCurCfgState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 11, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpFltCurCfgState.setStatus('current')
if mibBuilder.loadTexts: igmpFltCurCfgState.setDescription('The state of this IGMP filtering rule.')
igmpFltNewCfgTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 11, 2), )
if mibBuilder.loadTexts: igmpFltNewCfgTable.setStatus('current')
if mibBuilder.loadTexts: igmpFltNewCfgTable.setDescription('The IGMP filtering table in the current configuration block.')
igmpFltNewCfgTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 11, 2, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "igmpFltNewCfgIndx"))
if mibBuilder.loadTexts: igmpFltNewCfgTableEntry.setStatus('current')
if mibBuilder.loadTexts: igmpFltNewCfgTableEntry.setDescription('A row in the filtering table.')
igmpFltNewCfgIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 11, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpFltNewCfgIndx.setStatus('current')
if mibBuilder.loadTexts: igmpFltNewCfgIndx.setDescription('The IGMP filter table index.')
igmpFltNewCfgMcastIp1 = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 11, 2, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igmpFltNewCfgMcastIp1.setStatus('current')
if mibBuilder.loadTexts: igmpFltNewCfgMcastIp1.setDescription('Range1 Multicast source IP address to be filtered.')
igmpFltNewCfgMcastIp2 = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 11, 2, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igmpFltNewCfgMcastIp2.setStatus('current')
if mibBuilder.loadTexts: igmpFltNewCfgMcastIp2.setDescription('Range2 Multicast source IP address to be filtered.')
igmpFltNewCfgAction = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 11, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("allow", 1), ("deny", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igmpFltNewCfgAction.setStatus('current')
if mibBuilder.loadTexts: igmpFltNewCfgAction.setDescription('The action for the IGMP filtering rule.')
igmpFltNewCfgState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 11, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igmpFltNewCfgState.setStatus('current')
if mibBuilder.loadTexts: igmpFltNewCfgState.setDescription('The state of this IGMP filtering rule.')
igmpFltNewCfgDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 11, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("delete", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igmpFltNewCfgDelete.setStatus('current')
if mibBuilder.loadTexts: igmpFltNewCfgDelete.setDescription('When set to the value of 2 (delete), the entire row is deleted. When read, other(1) is returned. Setting the value to anything other than 2(delete) has no effect on the state of the row.')
igmpFltCurCfgPortTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 11, 3), )
if mibBuilder.loadTexts: igmpFltCurCfgPortTable.setStatus('current')
if mibBuilder.loadTexts: igmpFltCurCfgPortTable.setDescription('The IGMP filtering port table in the current configuration block.')
igmpFltCurCfgPortTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 11, 3, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "igmpFltCurCfgPortIndx"))
if mibBuilder.loadTexts: igmpFltCurCfgPortTableEntry.setStatus('current')
if mibBuilder.loadTexts: igmpFltCurCfgPortTableEntry.setDescription('A row in the IGMP filtering port table.')
igmpFltCurCfgPortIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 11, 3, 1, 1), PortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpFltCurCfgPortIndx.setStatus('current')
if mibBuilder.loadTexts: igmpFltCurCfgPortIndx.setDescription('The port index.')
igmpFltCurCfgPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 11, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpFltCurCfgPortState.setStatus('current')
if mibBuilder.loadTexts: igmpFltCurCfgPortState.setDescription('Enable or disable IGMP filtering.')
igmpFltCurCfgPortFiltBmap = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 11, 3, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpFltCurCfgPortFiltBmap.setStatus('current')
if mibBuilder.loadTexts: igmpFltCurCfgPortFiltBmap.setDescription('The IGMP filtering rules applied to the port. The filtering rules are presented in bitmap format. in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ filter 9 || || || ||___ filter 8 || |____ filter 7 || . . . ||_________ filter 2 |__________ filter 1 (as index to igmpFltCurCfgTable) where x : 1 - The represented IGMP filter rule applied to the port 0 - The represented IGMP filter rule not applied to the port ')
igmpFltNewCfgPortTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 11, 4), )
if mibBuilder.loadTexts: igmpFltNewCfgPortTable.setStatus('current')
if mibBuilder.loadTexts: igmpFltNewCfgPortTable.setDescription('The IGMP filtering port table in the new configuration block.')
igmpFltNewCfgPortTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 11, 4, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "igmpFltNewCfgPortIndx"))
if mibBuilder.loadTexts: igmpFltNewCfgPortTableEntry.setStatus('current')
if mibBuilder.loadTexts: igmpFltNewCfgPortTableEntry.setDescription('A row in the IGMP filtering port table.')
igmpFltNewCfgPortIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 11, 4, 1, 1), PortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpFltNewCfgPortIndx.setStatus('current')
if mibBuilder.loadTexts: igmpFltNewCfgPortIndx.setDescription('The port index.')
igmpFltNewCfgPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 11, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igmpFltNewCfgPortState.setStatus('current')
if mibBuilder.loadTexts: igmpFltNewCfgPortState.setDescription('Enable or disable IGMP filtering.')
igmpFltNewCfgPortFiltBmap = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 11, 4, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpFltNewCfgPortFiltBmap.setStatus('current')
if mibBuilder.loadTexts: igmpFltNewCfgPortFiltBmap.setDescription('The IGMP filtering rules applied to the port. The filtering rules are presented in bitmap format. in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ filter 9 || || || ||___ filter 8 || |____ filter 7 || . . . ||_________ filter 2 |__________ filter 1 (as index to fltNewCfgTable) where x : 1 - The represented filter rule applied to the port 0 - The represented filter rule not applied to the port ')
igmpFltNewCfgPortAddFiltRule = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 11, 4, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igmpFltNewCfgPortAddFiltRule.setStatus('current')
if mibBuilder.loadTexts: igmpFltNewCfgPortAddFiltRule.setDescription("This is an action object to add filtering rule to a port. The value specified with this object is the index to the fltNewCfgTable for which filtering rule to be added to the port. The range of the valid index is between 1 and igmpFltCurCfgTableMaxSize. When read, the value '0' is returned always.")
igmpFltNewCfgPortRemFiltRule = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 11, 4, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igmpFltNewCfgPortRemFiltRule.setStatus('current')
if mibBuilder.loadTexts: igmpFltNewCfgPortRemFiltRule.setDescription("This is an action object to remove filtering rule from a port. The value specified with this object is the index to the fltNewCfgTable for which filtering rule to be removed from the port. The range of the valid index is between 1 and igmpFltCurCfgTableMaxSize. When read, the value '0' is returned always.")
igmpFltCurCfgEnaDis = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 11, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpFltCurCfgEnaDis.setStatus('current')
if mibBuilder.loadTexts: igmpFltCurCfgEnaDis.setDescription('Enable/Disable of IGMP Filtering.')
igmpFltNewCfgEnaDis = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 11, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igmpFltNewCfgEnaDis.setStatus('current')
if mibBuilder.loadTexts: igmpFltNewCfgEnaDis.setDescription('Enable/Disable of IGMP Filtering.')
igmpCurQurCfgTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 15), )
if mibBuilder.loadTexts: igmpCurQurCfgTable.setStatus('current')
if mibBuilder.loadTexts: igmpCurQurCfgTable.setDescription('The table of IGMP querier configuration.')
igmpCurQurCfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 15, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "igmpCurQurCfgVlanIndex"))
if mibBuilder.loadTexts: igmpCurQurCfgEntry.setStatus('current')
if mibBuilder.loadTexts: igmpCurQurCfgEntry.setDescription('A row in the IGMP querier configuration table')
igmpCurQurCfgVlanIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 15, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4094))).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpCurQurCfgVlanIndex.setStatus('current')
if mibBuilder.loadTexts: igmpCurQurCfgVlanIndex.setDescription('The vlan number for which the IGMP querier information is related.')
igmpCurQuerierState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 15, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("querier", 1), ("nonQuerier", 2), ("checkingMembership", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpCurQuerierState.setStatus('current')
if mibBuilder.loadTexts: igmpCurQuerierState.setDescription('Indicates whether the switch is running as a querier in the VLAN. Based on the querier election, if elected as a querier, it will send query messages. If the switch receives the query message with lower IP/MAC any other querier in the VLAN, It will move to non querier state. If a leave is received then querier moves to checking membership state.')
igmpCurCfgQuerier = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 15, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpCurCfgQuerier.setStatus('current')
if mibBuilder.loadTexts: igmpCurCfgQuerier.setDescription("The snooping switch can be configured to send IGMP queries. querier are not present in the VLAN and it set to 'enabled' the switch will generate general query messages. The query messages will be suppressed if the switch receives the query message from any other querier with lower IP/MAC in the VLAN.")
igmpCurCfgQueryInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 15, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 608))).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpCurCfgQueryInterval.setStatus('current')
if mibBuilder.loadTexts: igmpCurCfgQueryInterval.setDescription('This is the interval (in seconds) for which the switch sends general queries when it is configured as a querier for the VLAN.')
igmpCurCfgQurSrcIp = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 15, 1, 5), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpCurCfgQurSrcIp.setStatus('current')
if mibBuilder.loadTexts: igmpCurCfgQurSrcIp.setDescription('The source ip for GSQ proxy in this vlan. This Src Ip will be used in querier election mechanism. It will be the source address in queries sent bye the switch.')
igmpCurCfgElectionType = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 15, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ipv4", 1), ("macaddr", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpCurCfgElectionType.setStatus('current')
if mibBuilder.loadTexts: igmpCurCfgElectionType.setDescription('The querier selection type specify the criteria to be used to elect querier for this VLAN. When a switch is configured as a querier, this will define the election criteria . e.g. MAC or source IP-address.')
igmpCurCfgQurRobustness = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 15, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpCurCfgQurRobustness.setStatus('current')
if mibBuilder.loadTexts: igmpCurCfgQurRobustness.setDescription('The Robustness Variable allows tuning for the Other Querier Present Interval.')
igmpCurCfgQurStartupCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 15, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpCurCfgQurStartupCnt.setStatus('current')
if mibBuilder.loadTexts: igmpCurCfgQurStartupCnt.setDescription('Represents the number of Queries sent out on startup of querier election, separated by the Startup Query Interval.')
igmpCurCfgQurStartupInt = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 15, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 608))).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpCurCfgQurStartupInt.setStatus('current')
if mibBuilder.loadTexts: igmpCurCfgQurStartupInt.setDescription('This variable represents the interval(in seconds) between General Queries sent by a Querier on startup. By default: 1/4 the Query Interval.')
igmpCurCfgQurMaxRespTime = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 15, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpCurCfgQurMaxRespTime.setStatus('current')
if mibBuilder.loadTexts: igmpCurCfgQurMaxRespTime.setDescription('The maximum query response interval advertised in IGMP queries on this VLAN.')
igmpCurCfgOtherQurAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 15, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpCurCfgOtherQurAddress.setStatus('current')
if mibBuilder.loadTexts: igmpCurCfgOtherQurAddress.setDescription('The IP/MAC Address of the Querier, which has won the Querier election, when bosSnoopVlanCfgQuerier is enabled on this vlan.')
igmpCurCfgOtherQurPresentInt = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 15, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpCurCfgOtherQurPresentInt.setStatus('current')
if mibBuilder.loadTexts: igmpCurCfgOtherQurPresentInt.setDescription('The Other Querier Present Interval is the length of time that must pass before switch decides that there is no longer another multicast router which should be the querier. This value is ((the Robustness Variable) times (the Query Interval)) plus (one half of one Query Response Interval).')
igmpCurCfgVlanOperVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 15, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("igmpV1", 1), ("igmpV2", 2), ("igmpV3", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpCurCfgVlanOperVersion.setStatus('current')
if mibBuilder.loadTexts: igmpCurCfgVlanOperVersion.setDescription("Indicates the operating version of the IGMP snooping switch for a specific VLAN. The default operating mode on a specific VLAN is IGMP version 3 i.e, V3(3). The 'bosIgsVlanCfgOperVersion' should be configured on the basis of the version of the router present in the VLAN.")
igmpCurVlanOperVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 15, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("igmpV1", 1), ("igmpV2", 2), ("igmpV3", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpCurVlanOperVersion.setStatus('current')
if mibBuilder.loadTexts: igmpCurVlanOperVersion.setDescription('Indicates the operating version of the IGMP snooping switch for specific VLAN. The default operating mode on a specific VLAN IGMP version 3 i.e, V3(3).')
igmpCurVlanOlderVerTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 15, 1, 15), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpCurVlanOlderVerTimer.setStatus('current')
if mibBuilder.loadTexts: igmpCurVlanOlderVerTimer.setDescription('Indicates the remaining time of lowest operating version of the vlan. For interoperability with multicast routers/switches/Hosts, running older versions of IGMP, systems maintain a IGMP Version variable for each Vlan. In order to switch gracefully between versions of IGMP, hosts keep both an IGMPv1 Querier Present timer and an IGMPv2 Querier Present timer per Vlan. According to RFC 3376 this value is ((the Robustness Variable) times (the Query Interval)) plus (one Query Response Interval).')
igmpNewQurCfgTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 16), )
if mibBuilder.loadTexts: igmpNewQurCfgTable.setStatus('current')
if mibBuilder.loadTexts: igmpNewQurCfgTable.setDescription('The table of IGMP querier configuration.')
igmpNewQurCfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 16, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "igmpNewQurCfgVlanIndex"))
if mibBuilder.loadTexts: igmpNewQurCfgEntry.setStatus('current')
if mibBuilder.loadTexts: igmpNewQurCfgEntry.setDescription('A row in the IGMP querier configuration table')
igmpNewQurCfgVlanIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 16, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4094))).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpNewQurCfgVlanIndex.setStatus('current')
if mibBuilder.loadTexts: igmpNewQurCfgVlanIndex.setDescription('The vlan number for which the IGMP querier information is related.')
igmpNewQuerierState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 16, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("querier", 1), ("nonQuerier", 2), ("checkingMembership", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpNewQuerierState.setStatus('current')
if mibBuilder.loadTexts: igmpNewQuerierState.setDescription('Indicates whether the switch is running as a querier in the VLAN. Based on the querier election, if elected as a querier, it will send query messages. If the switch receives the query message with lower IP/MAC any other querier in the VLAN, It will move to non querier state. If a leave is received then querier moves to checking membership state.')
igmpNewCfgQuerier = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 16, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igmpNewCfgQuerier.setStatus('current')
if mibBuilder.loadTexts: igmpNewCfgQuerier.setDescription("The snooping switch can be configured to send IGMP queries. querier are not present in the VLAN and it set to 'enabled' the switch will generate general query messages. The query messages will be suppressed if the switch receives the query message from any other querier with lower IP/MAC in the VLAN.")
igmpNewCfgQueryInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 16, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 608))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igmpNewCfgQueryInterval.setStatus('current')
if mibBuilder.loadTexts: igmpNewCfgQueryInterval.setDescription('This is the interval (in seconds) for which the switch sends general queries when it is configured as a querier for the VLAN.')
igmpNewCfgQurSrcIp = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 16, 1, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igmpNewCfgQurSrcIp.setStatus('current')
if mibBuilder.loadTexts: igmpNewCfgQurSrcIp.setDescription('The source ip for GSQ proxy in this vlan. This Src Ip will be used in querier election mechanism. It will be the source address in queries sent bye the switch.')
igmpNewCfgElectionType = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 16, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ipv4", 1), ("macaddr", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igmpNewCfgElectionType.setStatus('current')
if mibBuilder.loadTexts: igmpNewCfgElectionType.setDescription('The querier selection type specify the criteria to be used to elect querier for this VLAN. When a switch is configured as a querier, this will define the election criteria . e.g. MAC or source IP-address.')
igmpNewCfgQurRobustness = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 16, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igmpNewCfgQurRobustness.setStatus('current')
if mibBuilder.loadTexts: igmpNewCfgQurRobustness.setDescription('The Robustness Variable allows tuning for the Other Querier Present Interval.')
igmpNewCfgQurStartupCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 16, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igmpNewCfgQurStartupCnt.setStatus('current')
if mibBuilder.loadTexts: igmpNewCfgQurStartupCnt.setDescription('Represents the number of Queries sent out on startup of querier election, separated by the Startup Query Interval.')
igmpNewCfgQurStartupInt = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 16, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 608))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igmpNewCfgQurStartupInt.setStatus('current')
if mibBuilder.loadTexts: igmpNewCfgQurStartupInt.setDescription('This variable represents the interval(in seconds) between General Queries sent by a Querier on startup. By default: 1/4 the Query Interval.')
igmpNewCfgQurMaxRespTime = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 16, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 256))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igmpNewCfgQurMaxRespTime.setStatus('current')
if mibBuilder.loadTexts: igmpNewCfgQurMaxRespTime.setDescription('The maximum query response interval advertised in IGMP queries on this VLAN.')
igmpNewCfgOtherQurAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 16, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpNewCfgOtherQurAddress.setStatus('current')
if mibBuilder.loadTexts: igmpNewCfgOtherQurAddress.setDescription('The IP/MAC Address of the Querier, which has won the Querier election, when bosSnoopVlanCfgQuerier is enabled on this vlan.')
igmpNewCfgOtherQurPresentInt = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 16, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpNewCfgOtherQurPresentInt.setStatus('current')
if mibBuilder.loadTexts: igmpNewCfgOtherQurPresentInt.setDescription('The Other Querier Present Interval is the length of time that must pass before switch decides that there is no longer another multicast router which should be the querier. This value is ((the Robustness Variable) times (the Query Interval)) plus (one half of one Query Response Interval).')
igmpNewCfgVlanOperVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 16, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("igmpV1", 1), ("igmpV2", 2), ("igmpV3", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igmpNewCfgVlanOperVersion.setStatus('current')
if mibBuilder.loadTexts: igmpNewCfgVlanOperVersion.setDescription("Indicates the operating version of the IGMP snooping switch for a specific VLAN. The default operating mode on a specific VLAN is IGMP version 3 i.e, V3(3). The 'igmpNewCfgVlanOperVersion' should be configured on the basis of the version of the mrouter present in the VLAN.")
igmpNewVlanOperVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 16, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("igmpV1", 1), ("igmpV2", 2), ("igmpV3", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpNewVlanOperVersion.setStatus('current')
if mibBuilder.loadTexts: igmpNewVlanOperVersion.setDescription('Indicates the operating version of the IGMP snooping switch for specific VLAN. The default operating mode on a specific VLAN IGMP version 3 i.e, V3(3).')
igmpNewVlanOlderVerTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 16, 1, 15), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpNewVlanOlderVerTimer.setStatus('current')
if mibBuilder.loadTexts: igmpNewVlanOlderVerTimer.setDescription('Indicates the remaining time of lowest operating version of the vlan. For interoperability with multicast routers/switches/Hosts, running older versions of IGMP, systems maintain a IGMP Version variable for each Vlan. In order to switch gracefully between versions of IGMP, hosts keep both an IGMPv1 Querier Present timer and an IGMPv2 Querier Present timer per Vlan. According to RFC 3376 this value is ((the Robustness Variable) times (the Query Interval)) plus (one Query Response Interval).')
igmpNewCfgQuerierDefault = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 16, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("default", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igmpNewCfgQuerierDefault.setStatus('current')
if mibBuilder.loadTexts: igmpNewCfgQuerierDefault.setDescription('Action to set the default IGMP Querier settings on a Vlan. Returns other(1) when read.')
igmpCurCfgQuerierOnOff = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpCurCfgQuerierOnOff.setStatus('current')
if mibBuilder.loadTexts: igmpCurCfgQuerierOnOff.setDescription('The current status of IGMP Querier.')
igmpNewCfgQuerierOnOff = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 19, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igmpNewCfgQuerierOnOff.setStatus('current')
if mibBuilder.loadTexts: igmpNewCfgQuerierOnOff.setDescription('Globally turn IGMP Querier On/Off.')
ipmcStaticRouteCfg = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 20))
ipmcStaticRouteTableMaxSize = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 20, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipmcStaticRouteTableMaxSize.setStatus('current')
if mibBuilder.loadTexts: ipmcStaticRouteTableMaxSize.setDescription('The maximum number of rows in the IPMC Static Route table.')
ipmcCurCfgStaticRouteTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 20, 2), )
if mibBuilder.loadTexts: ipmcCurCfgStaticRouteTable.setStatus('current')
if mibBuilder.loadTexts: ipmcCurCfgStaticRouteTable.setDescription('The table of static IPMC routes in the current configuration block.')
ipmcCurCfgStaticRouteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 20, 2, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ipmcCurCfgStaticRouteIndx"))
if mibBuilder.loadTexts: ipmcCurCfgStaticRouteEntry.setStatus('current')
if mibBuilder.loadTexts: ipmcCurCfgStaticRouteEntry.setDescription('A row in the static IPMC route table')
ipmcCurCfgStaticRouteIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 20, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipmcCurCfgStaticRouteIndx.setStatus('current')
if mibBuilder.loadTexts: ipmcCurCfgStaticRouteIndx.setDescription('The index of the IPMC static routing table.')
ipmcCurCfgStaticRouteDestIp = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 20, 2, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipmcCurCfgStaticRouteDestIp.setStatus('current')
if mibBuilder.loadTexts: ipmcCurCfgStaticRouteDestIp.setDescription('The destination IPMC address of this IPMC route.')
ipmcCurCfgStaticRouteVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 20, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipmcCurCfgStaticRouteVlanId.setStatus('current')
if mibBuilder.loadTexts: ipmcCurCfgStaticRouteVlanId.setDescription('The vlan id of this route.')
ipmcCurCfgStaticRouteHostBmap = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 20, 2, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipmcCurCfgStaticRouteHostBmap.setStatus('current')
if mibBuilder.loadTexts: ipmcCurCfgStaticRouteHostBmap.setDescription('The Host ports that are added to this IPMC port bitmap. The selected ports are presented in a bitmap format in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ Port 9 || || || ||___ Port 8 || |____ Port 7 || . . . ||_________ Port 2 |__________ Port 1 where x : 1 - The represented Host Port is added 0 - The represented Host Port is not added')
ipmcCurCfgStaticRouteAdminkeys = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 20, 2, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipmcCurCfgStaticRouteAdminkeys.setStatus('current')
if mibBuilder.loadTexts: ipmcCurCfgStaticRouteAdminkeys.setDescription('The LACP port adminkey of this route. Adminkeys on five positions alligned to right, separated by commas.')
ipmcCurCfgStaticRouteTrunks = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 20, 2, 1, 9), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipmcCurCfgStaticRouteTrunks.setStatus('current')
if mibBuilder.loadTexts: ipmcCurCfgStaticRouteTrunks.setDescription('The trunk list for this IPMC route. The trunks are presented in bitmap format. in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ trunk 8 || || || ||___ trunk 7 || |____ trunk 6 || . . . ||_________ trunk 1 |__________ reserved where x : 1 - The represented trunk belongs to IPMC route 0 - The represented trunk does not belong to IPMC route')
ipmcNewCfgStaticRouteTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 20, 3), )
if mibBuilder.loadTexts: ipmcNewCfgStaticRouteTable.setStatus('current')
if mibBuilder.loadTexts: ipmcNewCfgStaticRouteTable.setDescription('The table of IPMC static routes in the new configuration block. When creating a new route, Destination IP and Vlan id must be set first. The actual change in configuration occurs on using PortInfo leaf.')
ipmcNewCfgStaticRouteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 20, 3, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ipmcNewCfgStaticRouteIndx"))
if mibBuilder.loadTexts: ipmcNewCfgStaticRouteEntry.setStatus('current')
if mibBuilder.loadTexts: ipmcNewCfgStaticRouteEntry.setDescription('A row in the static IPMC route table')
ipmcNewCfgStaticRouteIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 20, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipmcNewCfgStaticRouteIndx.setStatus('current')
if mibBuilder.loadTexts: ipmcNewCfgStaticRouteIndx.setDescription('The index of the IPMC static routing table.')
ipmcNewCfgStaticRouteDestIp = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 20, 3, 1, 2), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipmcNewCfgStaticRouteDestIp.setStatus('current')
if mibBuilder.loadTexts: ipmcNewCfgStaticRouteDestIp.setDescription('The destination IPMC address of this route. It must be set along Vlan id before creating new route.')
ipmcNewCfgStaticRouteVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 20, 3, 1, 3), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipmcNewCfgStaticRouteVlanId.setStatus('current')
if mibBuilder.loadTexts: ipmcNewCfgStaticRouteVlanId.setDescription('The vlan id of this route. It must be set along Destination IP before creating new route.')
ipmcNewCfgStaticRouteHostBmap = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 20, 3, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipmcNewCfgStaticRouteHostBmap.setStatus('current')
if mibBuilder.loadTexts: ipmcNewCfgStaticRouteHostBmap.setDescription('The Host ports that are added to this IPMC port bitmap. The selected ports are presented in a bitmap format in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ Port 9 || || || ||___ Port 8 || |____ Port 7 || . . . ||_________ Port 2 |__________ Port 1 where x : 1 - The represented Host Port is added 0 - The represented Host Port is not added')
ipmcNewCfgStaticRouteAddPort = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 20, 3, 1, 7), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipmcNewCfgStaticRouteAddPort.setStatus('current')
if mibBuilder.loadTexts: ipmcNewCfgStaticRouteAddPort.setDescription('The port to be added to this IPMC route. When creating a new route, be sure to set Destination IP and Vlan Id before using this leaf.')
ipmcNewCfgStaticRouteRemPort = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 20, 3, 1, 17), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipmcNewCfgStaticRouteRemPort.setStatus('current')
if mibBuilder.loadTexts: ipmcNewCfgStaticRouteRemPort.setDescription('The port to be removed from this IPMC route. Not allowed to delete ports that are part of trunks.')
ipmcNewCfgStaticRouteTrunks = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 20, 3, 1, 8), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipmcNewCfgStaticRouteTrunks.setStatus('current')
if mibBuilder.loadTexts: ipmcNewCfgStaticRouteTrunks.setDescription('The trunk list for this IPMC route. The trunks are presented in bitmap format. in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ trunk 8 || || || ||___ trunk 7 || |____ trunk 6 || . . . ||_________ trunk 1 |__________ reserved where x : 1 - The represented trunk belongs to ipmc 0 - The represented trunk does not belong to ipmc')
ipmcNewCfgStaticRouteAddTrunk = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 20, 3, 1, 9), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipmcNewCfgStaticRouteAddTrunk.setStatus('current')
if mibBuilder.loadTexts: ipmcNewCfgStaticRouteAddTrunk.setDescription("The trunk group number to be added to this IPMC route. A '0' value is returned when read. When creating a new route, be sure to set Destination IP and Vlan Id before using this leaf.")
ipmcNewCfgStaticRouteRemTrunk = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 20, 3, 1, 10), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipmcNewCfgStaticRouteRemTrunk.setStatus('current')
if mibBuilder.loadTexts: ipmcNewCfgStaticRouteRemTrunk.setDescription("The trunk group number to be added to this IPMC route. A '0' value is returned when read. When creating a new route, be sure to set Destination IP and Vlan Id before using this leaf.")
ipmcNewCfgStaticRouteAdminkeys = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 20, 3, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipmcNewCfgStaticRouteAdminkeys.setStatus('current')
if mibBuilder.loadTexts: ipmcNewCfgStaticRouteAdminkeys.setDescription('The LACP port adminkeys list for to this IPMC route. Adminkeys on five positions alligned to right, separated by commas')
ipmcNewCfgStaticRouteAddAdminkey = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 20, 3, 1, 12), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipmcNewCfgStaticRouteAddAdminkey.setStatus('current')
if mibBuilder.loadTexts: ipmcNewCfgStaticRouteAddAdminkey.setDescription("The LACP port adminkey to be added to this IPMC route. A '0' value is returned when read. When creating a new route, be sure to set Destination IP and Vlan Id before using this leaf.")
ipmcNewCfgStaticRouteRemAdminkey = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 20, 3, 1, 13), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipmcNewCfgStaticRouteRemAdminkey.setStatus('current')
if mibBuilder.loadTexts: ipmcNewCfgStaticRouteRemAdminkey.setDescription("The LACP port adminkey to be removed from this IPMC route. A '0' value is returned when read.")
ipmcNewCfgStaticRouteDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 20, 3, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 0))).clone(namedValues=NamedValues(("delete", 2), ("deletehost", 3), ("no", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipmcNewCfgStaticRouteDelete.setStatus('current')
if mibBuilder.loadTexts: ipmcNewCfgStaticRouteDelete.setDescription('Delete this route.')
ipmcStaticRouteClearAll = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 20, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("clear", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipmcStaticRouteClearAll.setStatus('current')
if mibBuilder.loadTexts: ipmcStaticRouteClearAll.setDescription('When set to clear(2),clears all static IPMC routes. Otherwhise nothing is done.')
ipStaticArpTableMaxSize = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 15, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipStaticArpTableMaxSize.setStatus('current')
if mibBuilder.loadTexts: ipStaticArpTableMaxSize.setDescription('The maximum number of rows in the Static ARP table.')
ipCurCfgStaticArpTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 15, 2), )
if mibBuilder.loadTexts: ipCurCfgStaticArpTable.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgStaticArpTable.setDescription('The table of static ARPs in the current configuration block.')
ipCurCfgStaticArpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 15, 2, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ipCurCfgStaticArpIndx"))
if mibBuilder.loadTexts: ipCurCfgStaticArpEntry.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgStaticArpEntry.setDescription('A row in the static ARP table')
ipCurCfgStaticArpIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 15, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgStaticArpIndx.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgStaticArpIndx.setDescription('The index of the static ARP table.')
ipCurCfgStaticArpIp = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 15, 2, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgStaticArpIp.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgStaticArpIp.setDescription('The IP address for the ARP entry.')
ipCurCfgStaticArpMAC = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 15, 2, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgStaticArpMAC.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgStaticArpMAC.setDescription('The MAC address for the ARP entry.')
ipCurCfgStaticArpVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 15, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgStaticArpVlan.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgStaticArpVlan.setDescription('The VLAN for the ARP entry.')
ipCurCfgStaticArpPort = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 15, 2, 1, 5), PortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgStaticArpPort.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgStaticArpPort.setDescription('The port for the ARP entry.')
ipNewCfgStaticArpTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 15, 3), )
if mibBuilder.loadTexts: ipNewCfgStaticArpTable.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgStaticArpTable.setDescription('The table of static ARPs in the new configuration block.')
ipNewCfgStaticArpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 15, 3, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ipNewCfgStaticArpIndx"))
if mibBuilder.loadTexts: ipNewCfgStaticArpEntry.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgStaticArpEntry.setDescription('A row in the static ARP table')
ipNewCfgStaticArpIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 15, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipNewCfgStaticArpIndx.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgStaticArpIndx.setDescription('The index of the static ARP table.')
ipNewCfgStaticArpIp = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 15, 3, 1, 2), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgStaticArpIp.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgStaticArpIp.setDescription('The IP address for the ARP entry.')
ipNewCfgStaticArpMAC = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 15, 3, 1, 3), DisplayString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgStaticArpMAC.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgStaticArpMAC.setDescription('The MAC address for the ARP entry.')
ipNewCfgStaticArpVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 15, 3, 1, 4), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgStaticArpVlan.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgStaticArpVlan.setDescription('The VLAN for the ARP entry.')
ipNewCfgStaticArpPort = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 15, 3, 1, 5), PortNumber()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgStaticArpPort.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgStaticArpPort.setDescription('The port for the ARP entry.')
ipNewCfgStaticArpAction = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 15, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("delete", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgStaticArpAction.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgStaticArpAction.setDescription('When set to the value of 2 (delete), the entire row is deleted. When read, other is returned. Setting the value to anything other than 2(delete) has no effect on the state of the row.')
ipStaticArpClearAll = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 15, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("clear", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipStaticArpClearAll.setStatus('current')
if mibBuilder.loadTexts: ipStaticArpClearAll.setDescription('When set to clear(2), clears all static ARP entries. Otherwise nothing is done.')
ipStaticNbrTableMaxSize = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 21, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipStaticNbrTableMaxSize.setStatus('current')
if mibBuilder.loadTexts: ipStaticNbrTableMaxSize.setDescription('The maximum number of rows in the Static NBR Cache table.')
ipCurCfgStaticNbrTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 21, 2), )
if mibBuilder.loadTexts: ipCurCfgStaticNbrTable.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgStaticNbrTable.setDescription('The table of static NBR Cache entries in the current configuration block.')
ipCurCfgStaticNbrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 21, 2, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ipCurCfgStaticNbrIndx"))
if mibBuilder.loadTexts: ipCurCfgStaticNbrEntry.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgStaticNbrEntry.setDescription('A row in the static NBR Cache table')
ipCurCfgStaticNbrIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 21, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgStaticNbrIndx.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgStaticNbrIndx.setDescription('The index of the static NBR Cache table.')
ipCurCfgStaticNbrIp = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 21, 2, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgStaticNbrIp.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgStaticNbrIp.setDescription('The IP address for the NBR Cache entry.')
ipCurCfgStaticNbrMAC = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 21, 2, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgStaticNbrMAC.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgStaticNbrMAC.setDescription('The MAC address for the NBR Cache entry.')
ipCurCfgStaticNbrVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 21, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgStaticNbrVlan.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgStaticNbrVlan.setDescription('The VLAN for the NBR Cache entry.')
ipCurCfgStaticNbrPort = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 21, 2, 1, 5), PortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgStaticNbrPort.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgStaticNbrPort.setDescription('The port for the NBR Cache entry.')
ipNewCfgStaticNbrTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 21, 3), )
if mibBuilder.loadTexts: ipNewCfgStaticNbrTable.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgStaticNbrTable.setDescription('The table of static NBR Cache entries in the new configuration block.')
ipNewCfgStaticNbrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 21, 3, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ipNewCfgStaticNbrIndx"))
if mibBuilder.loadTexts: ipNewCfgStaticNbrEntry.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgStaticNbrEntry.setDescription('A row in the static NBR Cache table')
ipNewCfgStaticNbrIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 21, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipNewCfgStaticNbrIndx.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgStaticNbrIndx.setDescription('The index of the static NBR Cache table.')
ipNewCfgStaticNbrIp = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 21, 3, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgStaticNbrIp.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgStaticNbrIp.setDescription('The IP address for the NBR Cache entry.')
ipNewCfgStaticNbrMAC = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 21, 3, 1, 3), DisplayString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgStaticNbrMAC.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgStaticNbrMAC.setDescription('The MAC address for the NBR Cache entry.')
ipNewCfgStaticNbrVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 21, 3, 1, 4), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgStaticNbrVlan.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgStaticNbrVlan.setDescription('The VLAN for the NBR Cache entry.')
ipNewCfgStaticNbrPort = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 21, 3, 1, 5), PortNumber()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgStaticNbrPort.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgStaticNbrPort.setDescription('The port for the NBR Cache entry.')
ipNewCfgStaticNbrAction = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 21, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("delete", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgStaticNbrAction.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgStaticNbrAction.setDescription('When set to the value of 2 (delete), the entire row is deleted. When read, other is returned. Setting the value to anything other than 2(delete) has no effect on the state of the row.')
ipStaticNbrClearAll = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 21, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("clear", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipStaticNbrClearAll.setStatus('current')
if mibBuilder.loadTexts: ipStaticNbrClearAll.setDescription('When set to clear(2),clears all static NBR Cache entries. Otherwhise nothing is done.')
ipStaticRoute6TableMaxSize = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 23, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipStaticRoute6TableMaxSize.setStatus('current')
if mibBuilder.loadTexts: ipStaticRoute6TableMaxSize.setDescription('The maximum number of rows in the Static Route6 table.')
ipCurCfgStaticRoute6Table = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 23, 2), )
if mibBuilder.loadTexts: ipCurCfgStaticRoute6Table.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgStaticRoute6Table.setDescription('The table of static IP6 routes in the current configuration block.')
ipCurCfgStaticRoute6Entry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 23, 2, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ipCurCfgStaticRoute6Indx"))
if mibBuilder.loadTexts: ipCurCfgStaticRoute6Entry.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgStaticRoute6Entry.setDescription('A row in the static IP6 route table')
ipCurCfgStaticRoute6Indx = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 23, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgStaticRoute6Indx.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgStaticRoute6Indx.setDescription('The index of the static IP6 routing table.')
ipCurCfgStaticRoute6DestIp = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 23, 2, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgStaticRoute6DestIp.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgStaticRoute6DestIp.setDescription('The destination IP6 address of this route.')
ipCurCfgStaticRoute6Mask = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 23, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgStaticRoute6Mask.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgStaticRoute6Mask.setDescription('The destination IP6 prefix len of this route.')
ipCurCfgStaticRoute6Gateway = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 23, 2, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgStaticRoute6Gateway.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgStaticRoute6Gateway.setDescription('The IP6 address of the gateway for this route.')
ipCurCfgStaticRoute6Interface = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 23, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgStaticRoute6Interface.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgStaticRoute6Interface.setDescription('The IP6 interface of this route. The IP6 address of the specified interface shall be used as source IP when performs routing.')
ipNewCfgStaticRoute6Table = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 23, 3), )
if mibBuilder.loadTexts: ipNewCfgStaticRoute6Table.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgStaticRoute6Table.setDescription('The table of static IP6 routes in the new configuration block.')
ipStaticRoute6ClearAllByDestIp = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 23, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipStaticRoute6ClearAllByDestIp.setStatus('current')
if mibBuilder.loadTexts: ipStaticRoute6ClearAllByDestIp.setDescription('Clears all static IP6 routes with the specified destination IP6 address.')
ipStaticRoute6ClearAllByGatewayIp = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 23, 5), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipStaticRoute6ClearAllByGatewayIp.setStatus('current')
if mibBuilder.loadTexts: ipStaticRoute6ClearAllByGatewayIp.setDescription('Clears all static IP6 routes with the specified gateway IP address.')
ipStaticRoute6ClearAllByInterface = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 23, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipStaticRoute6ClearAllByInterface.setStatus('current')
if mibBuilder.loadTexts: ipStaticRoute6ClearAllByInterface.setDescription('Clears all IP6 routes on the specified inteface number.')
ipStaticRoute6ClearAll = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 23, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("clear", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipStaticRoute6ClearAll.setStatus('current')
if mibBuilder.loadTexts: ipStaticRoute6ClearAll.setDescription('When set to clear(2), clears all IP6 static routes. Otherwise nothing is done.')
ipNewCfgStaticRoute6Entry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 23, 3, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ipNewCfgStaticRoute6Indx"))
if mibBuilder.loadTexts: ipNewCfgStaticRoute6Entry.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgStaticRoute6Entry.setDescription('A row in the static IP6 route table')
ipNewCfgStaticRoute6Indx = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 23, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipNewCfgStaticRoute6Indx.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgStaticRoute6Indx.setDescription('The index of the static IP6 routing table.')
ipNewCfgStaticRoute6DestIp = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 23, 3, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgStaticRoute6DestIp.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgStaticRoute6DestIp.setDescription('The destination IP6 address of this route. Address should be 16-byte hexadecimal colon notation. Valid IPv6 address should be in any of the following forms xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx or xxxx::xxxx:xxxx:xxxx:xxxx')
ipNewCfgStaticRoute6Mask = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 23, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 128))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgStaticRoute6Mask.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgStaticRoute6Mask.setDescription('The prefix length of this route.')
ipNewCfgStaticRoute6Gateway = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 23, 3, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgStaticRoute6Gateway.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgStaticRoute6Gateway.setDescription('The IP6 address of the gateway for this route. Address should be 16-byte hexadecimal colon notation. Valid IPv6 address should be in any of the following forms xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx or xxxx::xxxx:xxxx:xxxx:xxxx')
ipNewCfgStaticRoute6Action = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 23, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("delete", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgStaticRoute6Action.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgStaticRoute6Action.setDescription("Set the value '2' to delete the entire route entry. Value 1 (other) is returned when read.")
ipNewCfgStaticRoute6Interface = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 23, 3, 1, 6), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgStaticRoute6Interface.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgStaticRoute6Interface.setDescription('The IP6 interface of this route. The IP6 address of the specified interface shall be used as source IP when performs routing.')
ipGatewayIpv6TableMax = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 22, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipGatewayIpv6TableMax.setStatus('current')
if mibBuilder.loadTexts: ipGatewayIpv6TableMax.setDescription('The maximum number of rows in the IPv6 gateway table.')
ipCurCfgGwIpv6Table = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 22, 2), )
if mibBuilder.loadTexts: ipCurCfgGwIpv6Table.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgGwIpv6Table.setDescription('The table of IPv6 gateways in the Current configuration Block.')
ipCurCfgGwIpv6Entry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 22, 2, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ipCurCfgGwIpv6Index"))
if mibBuilder.loadTexts: ipCurCfgGwIpv6Entry.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgGwIpv6Entry.setDescription('A row in the Ipv6 gateway table')
ipCurCfgGwIpv6Index = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 22, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgGwIpv6Index.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgGwIpv6Index.setDescription('The IPv6 gateway number for which the information is related.')
ipCurCfgGwIpv6Addr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 22, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgGwIpv6Addr.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgGwIpv6Addr.setDescription('The IPv6 address of the gateway. Address should be 4-byte hexadecimal colon notation. Valid IPv6 address should be in any of the following forms xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx or xxxx::xxxx:xxxx:xxxx:xxxx or fe80:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx%interface')
ipCurCfgGwIpv6State = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 22, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("enabled", 2), ("disabled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgGwIpv6State.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgGwIpv6State.setDescription('The state of the default IPv6 gateway.')
ipNewCfgGwIpv6Table = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 22, 3), )
if mibBuilder.loadTexts: ipNewCfgGwIpv6Table.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgGwIpv6Table.setDescription('The table of IPv6 gateways in the new configuration block.')
ipNewCfgGwIpv6Entry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 22, 3, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ipNewCfgGwIpv6Index"))
if mibBuilder.loadTexts: ipNewCfgGwIpv6Entry.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgGwIpv6Entry.setDescription('A row in the Ipv6 gateway table')
ipNewCfgGwIpv6Index = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 22, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipNewCfgGwIpv6Index.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgGwIpv6Index.setDescription('The IPv6 gateway number for which the information is related.')
ipNewCfgGwIpv6Addr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 22, 3, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgGwIpv6Addr.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgGwIpv6Addr.setDescription('The IPv6 address of the gateway. Address should be 4-byte hexadecimal colon notation. Valid IPv6 address should be in any of the following forms xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx or xxxx::xxxx:xxxx:xxxx:xxxx')
ipNewCfgGwIpv6State = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 22, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("enabled", 2), ("disabled", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgGwIpv6State.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgGwIpv6State.setDescription('The state of the default IPv6 gateway.')
ipNewCfgGwIpv6Delete = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 22, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("delete", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgGwIpv6Delete.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgGwIpv6Delete.setDescription('When set to the value of 2 (delete), the default gw is deleted. When read, other is returned. Setting the value to anything other than 2(delete) has no effect on the state of the default IPv6 gw.')
pptTableMaxSize = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 27, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pptTableMaxSize.setStatus('current')
if mibBuilder.loadTexts: pptTableMaxSize.setDescription('The maximum number of rows in the Prefix policy table.')
pptCurCfgTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 27, 2), )
if mibBuilder.loadTexts: pptCurCfgTable.setStatus('current')
if mibBuilder.loadTexts: pptCurCfgTable.setDescription('The table of prefix policy table entries in the current configuration block.')
pptCurCfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 27, 2, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "pptCurCfgIndx"))
if mibBuilder.loadTexts: pptCurCfgEntry.setStatus('current')
if mibBuilder.loadTexts: pptCurCfgEntry.setDescription('A row in the prefix policy table')
pptCurCfgIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 27, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pptCurCfgIndx.setStatus('current')
if mibBuilder.loadTexts: pptCurCfgIndx.setDescription('The index of the prefix policy table.')
pptCurCfgPrefix = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 27, 2, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pptCurCfgPrefix.setStatus('current')
if mibBuilder.loadTexts: pptCurCfgPrefix.setDescription('The prefix address for the prefix policy table entry.')
pptCurCfgPrefixLen = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 27, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pptCurCfgPrefixLen.setStatus('current')
if mibBuilder.loadTexts: pptCurCfgPrefixLen.setDescription('The prefix length for the prefix policy table entry.')
pptCurCfgPrecedence = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 27, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pptCurCfgPrecedence.setStatus('current')
if mibBuilder.loadTexts: pptCurCfgPrecedence.setDescription('The precedence for the prefix policy table entry.')
pptCurCfgLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 27, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pptCurCfgLabel.setStatus('current')
if mibBuilder.loadTexts: pptCurCfgLabel.setDescription('The label for the prefix policy table entry.')
pptNewCfgTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 27, 3), )
if mibBuilder.loadTexts: pptNewCfgTable.setStatus('current')
if mibBuilder.loadTexts: pptNewCfgTable.setDescription('The table of prefix policy table entries in the new configuration block.')
pptNewCfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 27, 3, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "pptNewCfgIndx"))
if mibBuilder.loadTexts: pptNewCfgEntry.setStatus('current')
if mibBuilder.loadTexts: pptNewCfgEntry.setDescription('A row in the prefix policy table')
pptNewCfgIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 27, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pptNewCfgIndx.setStatus('current')
if mibBuilder.loadTexts: pptNewCfgIndx.setDescription('The index of the prefix policy table.')
pptNewCfgPrefix = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 27, 3, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pptNewCfgPrefix.setStatus('current')
if mibBuilder.loadTexts: pptNewCfgPrefix.setDescription('The prefix address for the prefix policy table entry.')
pptNewCfgPrefixLen = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 27, 3, 1, 3), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pptNewCfgPrefixLen.setStatus('current')
if mibBuilder.loadTexts: pptNewCfgPrefixLen.setDescription('The prefix length the prefix policy table entry.')
pptNewCfgPrecedence = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 27, 3, 1, 4), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pptNewCfgPrecedence.setStatus('current')
if mibBuilder.loadTexts: pptNewCfgPrecedence.setDescription('The precedence for the prefix policy table entry.')
pptNewCfgLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 27, 3, 1, 5), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pptNewCfgLabel.setStatus('current')
if mibBuilder.loadTexts: pptNewCfgLabel.setDescription('The label for the prefix policy table entry.')
pptNewCfgAction = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 27, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("delete", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pptNewCfgAction.setStatus('current')
if mibBuilder.loadTexts: pptNewCfgAction.setDescription('When set to the value of 2 (delete), the entire row is deleted. When read, other is returned. Setting the value to anything other than 2(delete) has no effect on the state of the row.')
mldCurCfgState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 30, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mldCurCfgState.setStatus('current')
if mibBuilder.loadTexts: mldCurCfgState.setDescription('MLD global state.')
mldNewCfgState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 30, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mldNewCfgState.setStatus('current')
if mibBuilder.loadTexts: mldNewCfgState.setDescription('MLD global state.')
mldCurInterfaceTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 30, 3), )
if mibBuilder.loadTexts: mldCurInterfaceTable.setStatus('current')
if mibBuilder.loadTexts: mldCurInterfaceTable.setDescription('The (conceptual) table listing the interfaces on which MLD is enabled.')
mldCurInterfaceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 30, 3, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "mldCurInterfaceIfIndex"))
if mibBuilder.loadTexts: mldCurInterfaceEntry.setStatus('current')
if mibBuilder.loadTexts: mldCurInterfaceEntry.setDescription('An entry (conceptual row) representing an interface on which MLD is enabled.')
mldCurInterfaceIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 30, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mldCurInterfaceIfIndex.setStatus('current')
if mibBuilder.loadTexts: mldCurInterfaceIfIndex.setDescription('The internetwork-layer interface value of the interface for which MLD is enabled.')
mldCurInterfaceQueryInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 30, 3, 1, 2), Integer32().clone(125)).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: mldCurInterfaceQueryInterval.setStatus('current')
if mibBuilder.loadTexts: mldCurInterfaceQueryInterval.setDescription('The frequency at which MLD Host-Query packets are transmitted on this interface.')
mldCurInterfaceVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 30, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("mldv1", 1), ("mldv2", 2))).clone(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mldCurInterfaceVersion.setStatus('current')
if mibBuilder.loadTexts: mldCurInterfaceVersion.setDescription('The version of MLD which is running on this interface. This object is a place holder to allow for new versions of MLD to be introduced. Version 1 of MLD is defined in RFC 2710.')
mldCurInterfaceQueryMaxResponseIntvl = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 30, 3, 1, 4), Integer32().clone(1000)).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: mldCurInterfaceQueryMaxResponseIntvl.setStatus('current')
if mibBuilder.loadTexts: mldCurInterfaceQueryMaxResponseIntvl.setDescription('The maximum query response time advertised in MLD queries on this interface.')
mldCurInterfaceRobustness = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 30, 3, 1, 5), Integer32().clone(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mldCurInterfaceRobustness.setStatus('current')
if mibBuilder.loadTexts: mldCurInterfaceRobustness.setDescription('The Robustness Variable allows tuning for the expected packet loss on a subnet. If a subnet is expected to be lossy, the Robustness Variable may be increased. MLD is robust to (Robustness Variable-1) packet losses. The discussion of the Robustness Variable is in Section 7.1 of RFC 2710.')
mldCurInterfaceLastListenQueryIntvl = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 30, 3, 1, 6), Integer32().clone(1)).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: mldCurInterfaceLastListenQueryIntvl.setStatus('current')
if mibBuilder.loadTexts: mldCurInterfaceLastListenQueryIntvl.setDescription('The Last Member Query Interval is the Max Response Delay inserted into Group-Specific Queries sent in response to Leave Group messages, and is also the amount of time between Group-Specific Query messages. This value may be tuned to modify the leave latency of the network. A reduced value results in reduced time to detect the loss of the last member of a group.')
mldCurInterfaceDMrtrEna = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 30, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mldCurInterfaceDMrtrEna.setStatus('current')
if mibBuilder.loadTexts: mldCurInterfaceDMrtrEna.setDescription('Dynamic MRouter learning.')
mldCurInterfaceState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 30, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mldCurInterfaceState.setStatus('current')
if mibBuilder.loadTexts: mldCurInterfaceState.setDescription('State of the MLD interface.')
mldNewInterfaceTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 30, 4), )
if mibBuilder.loadTexts: mldNewInterfaceTable.setStatus('current')
if mibBuilder.loadTexts: mldNewInterfaceTable.setDescription('The (conceptual) table listing the interfaces on which MLD is enabled.')
mldNewInterfaceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 30, 4, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "mldNewInterfaceIfIndex"))
if mibBuilder.loadTexts: mldNewInterfaceEntry.setStatus('current')
if mibBuilder.loadTexts: mldNewInterfaceEntry.setDescription('An entry (conceptual row) representing an interface on which MLD is enabled.')
mldNewInterfaceIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 30, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mldNewInterfaceIfIndex.setStatus('current')
if mibBuilder.loadTexts: mldNewInterfaceIfIndex.setDescription('The internetwork-layer interface value of the interface for which MLD is enabled.')
mldNewInterfaceQueryInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 30, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 65535)).clone(125)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: mldNewInterfaceQueryInterval.setStatus('current')
if mibBuilder.loadTexts: mldNewInterfaceQueryInterval.setDescription('The frequency at which MLD Host-Query packets are transmitted on this interface.')
mldNewInterfaceVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 30, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("mldv1", 1), ("mldv2", 2))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mldNewInterfaceVersion.setStatus('current')
if mibBuilder.loadTexts: mldNewInterfaceVersion.setDescription('The version of MLD which is running on this interface. This object is a place holder to allow for new versions of MLD to be introduced. Version 1 of MLD is defined in RFC 2710.')
mldNewInterfaceQueryMaxResponseIntvl = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 30, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1000, 65535)).clone(1000)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: mldNewInterfaceQueryMaxResponseIntvl.setStatus('current')
if mibBuilder.loadTexts: mldNewInterfaceQueryMaxResponseIntvl.setDescription('The maximum query response time advertised in MLD queries on this interface.')
mldNewInterfaceRobustness = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 30, 4, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 10)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mldNewInterfaceRobustness.setStatus('current')
if mibBuilder.loadTexts: mldNewInterfaceRobustness.setDescription('The Robustness Variable allows tuning for the expected packet loss on a subnet. If a subnet is expected to be lossy, the Robustness Variable may be increased. MLD is robust to (Robustness Variable-1) packet losses. The discussion of the Robustness Variable is in Section 7.1 of RFC 2710.')
mldNewInterfaceLastListenQueryIntvl = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 30, 4, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32)).clone(1)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: mldNewInterfaceLastListenQueryIntvl.setStatus('current')
if mibBuilder.loadTexts: mldNewInterfaceLastListenQueryIntvl.setDescription('The Last Member Query Interval is the Max Response Delay inserted into Group-Specific Queries sent in response to Leave Group messages, and is also the amount of time between Group-Specific Query messages. This value may be tuned to modify the leave latency of the network. A reduced value results in reduced time to detect the loss of the last member of a group.')
mldNewInterfaceDMrtrEna = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 30, 4, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mldNewInterfaceDMrtrEna.setStatus('current')
if mibBuilder.loadTexts: mldNewInterfaceDMrtrEna.setDescription('Dynamic MRouter learning.')
mldNewInterfaceState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 30, 4, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mldNewInterfaceState.setStatus('current')
if mibBuilder.loadTexts: mldNewInterfaceState.setDescription('State of the MLD interface.')
mldNewInterfaceDefault = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 30, 4, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("default", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mldNewInterfaceDefault.setStatus('current')
if mibBuilder.loadTexts: mldNewInterfaceDefault.setDescription('Action to set the MLD interface configuration to default. Returns other(1) when read.')
mldDefaultCfgState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 30, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("default", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mldDefaultCfgState.setStatus('current')
if mibBuilder.loadTexts: mldDefaultCfgState.setDescription('Action to set the global MLD configuration to default. Returns other(1) when read.')
ndprefixTableMaxSize = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 31, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndprefixTableMaxSize.setStatus('current')
if mibBuilder.loadTexts: ndprefixTableMaxSize.setDescription('The maximum number of rows in the NDPrefix table.')
ndprefixCurCfgTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 31, 2), )
if mibBuilder.loadTexts: ndprefixCurCfgTable.setStatus('current')
if mibBuilder.loadTexts: ndprefixCurCfgTable.setDescription('The ndprefix table entries in the current configuration block.')
ndprefixCurCfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 31, 2, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ndprefixCurCfgIndx"))
if mibBuilder.loadTexts: ndprefixCurCfgEntry.setStatus('current')
if mibBuilder.loadTexts: ndprefixCurCfgEntry.setDescription('A row in the ndprefix table.')
ndprefixCurCfgIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 31, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndprefixCurCfgIndx.setStatus('current')
if mibBuilder.loadTexts: ndprefixCurCfgIndx.setDescription('The index of the ndprefix table.')
ndprefixCurCfgPrefix = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 31, 2, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndprefixCurCfgPrefix.setStatus('current')
if mibBuilder.loadTexts: ndprefixCurCfgPrefix.setDescription('The prefix address for the prefix table entry.')
ndprefixCurCfgPrefixLen = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 31, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndprefixCurCfgPrefixLen.setStatus('current')
if mibBuilder.loadTexts: ndprefixCurCfgPrefixLen.setDescription('The prefix length for the prefix table entry.')
ndprefixCurCfgInterfaceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 31, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndprefixCurCfgInterfaceIndex.setStatus('current')
if mibBuilder.loadTexts: ndprefixCurCfgInterfaceIndex.setDescription('The interface index for the prefix table entry.')
ndprefixCurCfgProfileIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 31, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndprefixCurCfgProfileIndex.setStatus('current')
if mibBuilder.loadTexts: ndprefixCurCfgProfileIndex.setDescription('The profile index for the prefix table entry Profile 0 is the default profile.')
ndprefixCurCfgValidLifetime = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 31, 2, 1, 6), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndprefixCurCfgValidLifetime.setStatus('current')
if mibBuilder.loadTexts: ndprefixCurCfgValidLifetime.setDescription('The Valid lifetime for the prefix table entry.')
ndprefixCurCfgValidLifetimeFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 31, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndprefixCurCfgValidLifetimeFlag.setStatus('current')
if mibBuilder.loadTexts: ndprefixCurCfgValidLifetimeFlag.setDescription('The Valid lifetime fixed flag for the prefix table entry.')
ndprefixCurCfgPreferredLifetime = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 31, 2, 1, 8), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndprefixCurCfgPreferredLifetime.setStatus('current')
if mibBuilder.loadTexts: ndprefixCurCfgPreferredLifetime.setDescription('The Preferred Lifetime for the prefix table entry.')
ndprefixCurCfgPreferredLifetimeFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 31, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndprefixCurCfgPreferredLifetimeFlag.setStatus('current')
if mibBuilder.loadTexts: ndprefixCurCfgPreferredLifetimeFlag.setDescription('The Preferred Lifetime fixed flag for the prefix table entry.')
ndprefixCurCfgOnlinkFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 31, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndprefixCurCfgOnlinkFlag.setStatus('current')
if mibBuilder.loadTexts: ndprefixCurCfgOnlinkFlag.setDescription('The Onlink flag for the prefix table entry.')
ndprefixCurCfgAutonomousFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 31, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndprefixCurCfgAutonomousFlag.setStatus('current')
if mibBuilder.loadTexts: ndprefixCurCfgAutonomousFlag.setDescription('The Autonomous flag for the prefix table entry.')
ndprefixCurCfgState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 31, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndprefixCurCfgState.setStatus('current')
if mibBuilder.loadTexts: ndprefixCurCfgState.setDescription('The state for the prefix table entry.')
ndprefixNewCfgTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 31, 3), )
if mibBuilder.loadTexts: ndprefixNewCfgTable.setStatus('current')
if mibBuilder.loadTexts: ndprefixNewCfgTable.setDescription('The ndprefix table entries in the new configuration block.')
ndprefixNewCfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 31, 3, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ndprefixNewCfgIndx"))
if mibBuilder.loadTexts: ndprefixNewCfgEntry.setStatus('current')
if mibBuilder.loadTexts: ndprefixNewCfgEntry.setDescription('A row in the prefix table')
ndprefixNewCfgIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 31, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndprefixNewCfgIndx.setStatus('current')
if mibBuilder.loadTexts: ndprefixNewCfgIndx.setDescription('The index of the prefix table.')
ndprefixNewCfgPrefix = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 31, 3, 1, 2), DisplayString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ndprefixNewCfgPrefix.setStatus('current')
if mibBuilder.loadTexts: ndprefixNewCfgPrefix.setDescription('The prefix address for the prefix table entry.')
ndprefixNewCfgPrefixLen = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 31, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 128))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ndprefixNewCfgPrefixLen.setStatus('current')
if mibBuilder.loadTexts: ndprefixNewCfgPrefixLen.setDescription('The prefix length for the prefix table entry.')
ndprefixNewCfgInterfaceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 31, 3, 1, 4), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ndprefixNewCfgInterfaceIndex.setStatus('current')
if mibBuilder.loadTexts: ndprefixNewCfgInterfaceIndex.setDescription('The interface index for the prefix table entry.')
ndprefixNewCfgProfileIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 31, 3, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 127))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ndprefixNewCfgProfileIndex.setStatus('current')
if mibBuilder.loadTexts: ndprefixNewCfgProfileIndex.setDescription('The profile index for the prefix table entry. Profile 0 is the default profile.')
ndprefixNewCfgValidLifetime = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 31, 3, 1, 6), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ndprefixNewCfgValidLifetime.setStatus('current')
if mibBuilder.loadTexts: ndprefixNewCfgValidLifetime.setDescription('The Valid lifetime for the prefix table entry.')
ndprefixNewCfgValidLifetimeFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 31, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ndprefixNewCfgValidLifetimeFlag.setStatus('current')
if mibBuilder.loadTexts: ndprefixNewCfgValidLifetimeFlag.setDescription('The Valid lifetime fixed flag for the prefix table entry.')
ndprefixNewCfgPreferredLifetime = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 31, 3, 1, 8), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ndprefixNewCfgPreferredLifetime.setStatus('current')
if mibBuilder.loadTexts: ndprefixNewCfgPreferredLifetime.setDescription('The Preferred Lifetime for the prefix table entry.')
ndprefixNewCfgPreferredLifetimeFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 31, 3, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ndprefixNewCfgPreferredLifetimeFlag.setStatus('current')
if mibBuilder.loadTexts: ndprefixNewCfgPreferredLifetimeFlag.setDescription('The Preferred Lifetime fixed flag for the prefix table entry.')
ndprefixNewCfgOnlinkFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 31, 3, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ndprefixNewCfgOnlinkFlag.setStatus('current')
if mibBuilder.loadTexts: ndprefixNewCfgOnlinkFlag.setDescription('The Onlink flag for the prefix table entry.')
ndprefixNewCfgAutonomousFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 31, 3, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ndprefixNewCfgAutonomousFlag.setStatus('current')
if mibBuilder.loadTexts: ndprefixNewCfgAutonomousFlag.setDescription('The Autonomous flag for the prefix table entry.')
ndprefixNewCfgState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 31, 3, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ndprefixNewCfgState.setStatus('current')
if mibBuilder.loadTexts: ndprefixNewCfgState.setDescription('The state for the prefix table entry.')
ndprefixNewCfgAction = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 31, 3, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("delete", 2), ("deleteall", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ndprefixNewCfgAction.setStatus('current')
if mibBuilder.loadTexts: ndprefixNewCfgAction.setDescription('When set to the value of 2 (delete), the entire row is deleted. When set to the value of 3 (deleteall), all entries are deleted. When read, other is returned. Setting the value to anything other than 2(delete) or 3(deleteall) has no effect on the state of the row.')
ripStatInPackets = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 13, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripStatInPackets.setStatus('current')
if mibBuilder.loadTexts: ripStatInPackets.setDescription('The total number of RIP packets received.')
ripStatOutPackets = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 13, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripStatOutPackets.setStatus('current')
if mibBuilder.loadTexts: ripStatOutPackets.setDescription('The total number of RIP packets transmitted.')
ripStatInRequestPkts = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 13, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripStatInRequestPkts.setStatus('current')
if mibBuilder.loadTexts: ripStatInRequestPkts.setDescription('The total number of RIP requests received.')
ripStatInResponsePkts = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 13, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripStatInResponsePkts.setStatus('current')
if mibBuilder.loadTexts: ripStatInResponsePkts.setDescription('The total number of RIP response received.')
ripStatOutRequestPkts = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 13, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripStatOutRequestPkts.setStatus('current')
if mibBuilder.loadTexts: ripStatOutRequestPkts.setDescription('The total number of RIP requests transmitted.')
ripStatOutResponsePkts = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 13, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripStatOutResponsePkts.setStatus('current')
if mibBuilder.loadTexts: ripStatOutResponsePkts.setDescription('The total number of RIP responses transmitted.')
ripStatRouteTimeout = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 13, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripStatRouteTimeout.setStatus('current')
if mibBuilder.loadTexts: ripStatRouteTimeout.setDescription('The total number of RIP route timeouts.')
ripStatInBadSizePkts = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 13, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripStatInBadSizePkts.setStatus('current')
if mibBuilder.loadTexts: ripStatInBadSizePkts.setDescription('The total number of bad size RIP packets received.')
ripStatInBadVersion = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 13, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripStatInBadVersion.setStatus('current')
if mibBuilder.loadTexts: ripStatInBadVersion.setDescription('The total number of RIP bad versions received.')
ripStatInBadZeros = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 13, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripStatInBadZeros.setStatus('current')
if mibBuilder.loadTexts: ripStatInBadZeros.setDescription('The total number of RIP bad zeros received.')
ripStatInBadSourcePort = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 13, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripStatInBadSourcePort.setStatus('current')
if mibBuilder.loadTexts: ripStatInBadSourcePort.setDescription('The total number of RIP bad source port received.')
ripStatInBadSourceIP = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 13, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripStatInBadSourceIP.setStatus('current')
if mibBuilder.loadTexts: ripStatInBadSourceIP.setDescription('The total number of RIP bad source IP received.')
ripStatInSelfRcvPkts = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 13, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripStatInSelfRcvPkts.setStatus('current')
if mibBuilder.loadTexts: ripStatInSelfRcvPkts.setDescription('The total number of RIP packets from self received.')
ipStatsInReceives = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 16, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipStatsInReceives.setStatus('current')
if mibBuilder.loadTexts: ipStatsInReceives.setDescription('ip InReceive')
ipStatsInHdrErrors = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 16, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipStatsInHdrErrors.setStatus('current')
if mibBuilder.loadTexts: ipStatsInHdrErrors.setDescription('ip InHdrError')
ipStatsInAddrErrors = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 16, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipStatsInAddrErrors.setStatus('current')
if mibBuilder.loadTexts: ipStatsInAddrErrors.setDescription('ip InAddrErrors')
ipStatsInUnknownProtos = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 16, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipStatsInUnknownProtos.setStatus('current')
if mibBuilder.loadTexts: ipStatsInUnknownProtos.setDescription('ip InUnknownProtos')
ipStatsInDiscards = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 16, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipStatsInDiscards.setStatus('current')
if mibBuilder.loadTexts: ipStatsInDiscards.setDescription('ip InDiscards')
ipStatsInDelivers = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 16, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipStatsInDelivers.setStatus('current')
if mibBuilder.loadTexts: ipStatsInDelivers.setDescription('ip InDelivers')
ipStatsOutRequests = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 16, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipStatsOutRequests.setStatus('current')
if mibBuilder.loadTexts: ipStatsOutRequests.setDescription('ip OutRequests')
ipStatsOutDiscards = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 16, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipStatsOutDiscards.setStatus('current')
if mibBuilder.loadTexts: ipStatsOutDiscards.setDescription('ip OutDiscards')
ipStatsDefaultTTL = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 16, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipStatsDefaultTTL.setStatus('current')
if mibBuilder.loadTexts: ipStatsDefaultTTL.setDescription('ip DefaultTTL')
nsnmpInPkts = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 20, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsnmpInPkts.setStatus('current')
if mibBuilder.loadTexts: nsnmpInPkts.setDescription('snmpInPkts')
nsnmpInBadCommunityNames = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 20, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsnmpInBadCommunityNames.setStatus('current')
if mibBuilder.loadTexts: nsnmpInBadCommunityNames.setDescription('snmpInBadCommunityNames')
nsnmpInASNParseErrs = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 20, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsnmpInASNParseErrs.setStatus('current')
if mibBuilder.loadTexts: nsnmpInASNParseErrs.setDescription('snmpInASNParseErrs')
nsnmpOutPkts = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 20, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsnmpOutPkts.setStatus('current')
if mibBuilder.loadTexts: nsnmpOutPkts.setDescription('snmpOutPkts')
nsnmpInTooBigs = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 20, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsnmpInTooBigs.setStatus('current')
if mibBuilder.loadTexts: nsnmpInTooBigs.setDescription('snmpInTooBigs')
nsnmpInBadValues = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 20, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsnmpInBadValues.setStatus('current')
if mibBuilder.loadTexts: nsnmpInBadValues.setDescription('snmpInBadValues')
nsnmpInGenErrs = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 20, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsnmpInGenErrs.setStatus('current')
if mibBuilder.loadTexts: nsnmpInGenErrs.setDescription('snmpInGenErrs')
nsnmpInTotalSetVars = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 20, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsnmpInTotalSetVars.setStatus('current')
if mibBuilder.loadTexts: nsnmpInTotalSetVars.setDescription('snmpInTotalSetVars')
nsnmpInGetNexts = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 20, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsnmpInGetNexts.setStatus('current')
if mibBuilder.loadTexts: nsnmpInGetNexts.setDescription('snmpInGetNexts')
nsnmpInGetResponses = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 20, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsnmpInGetResponses.setStatus('current')
if mibBuilder.loadTexts: nsnmpInGetResponses.setDescription('snmpInGetResponses')
nsnmpOutTooBigs = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 20, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsnmpOutTooBigs.setStatus('current')
if mibBuilder.loadTexts: nsnmpOutTooBigs.setDescription('snmpOutTooBigs')
nsnmpOutBadValues = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 20, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsnmpOutBadValues.setStatus('current')
if mibBuilder.loadTexts: nsnmpOutBadValues.setDescription('snmpOutBadValues')
nsnmpOutGenErrs = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 20, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsnmpOutGenErrs.setStatus('current')
if mibBuilder.loadTexts: nsnmpOutGenErrs.setDescription('snmpOutGenErrs')
nsnmpOutGetNexts = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 20, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsnmpOutGetNexts.setStatus('current')
if mibBuilder.loadTexts: nsnmpOutGetNexts.setDescription('snmpOutGetNexts')
nsnmpOutGetResponses = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 20, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsnmpOutGetResponses.setStatus('current')
if mibBuilder.loadTexts: nsnmpOutGetResponses.setDescription('snmpOutGetResponses')
nsnmpSilentDrops = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 20, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsnmpSilentDrops.setStatus('current')
if mibBuilder.loadTexts: nsnmpSilentDrops.setDescription('snmpSilentDrops')
nsnmpInBadVersions = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 20, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsnmpInBadVersions.setStatus('current')
if mibBuilder.loadTexts: nsnmpInBadVersions.setDescription('snmpInBadVersions')
nsnmpInBadCommunityUses = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 20, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsnmpInBadCommunityUses.setStatus('current')
if mibBuilder.loadTexts: nsnmpInBadCommunityUses.setDescription('snmpInBadCommunityUses')
nsnmpEnableAuthTraps = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 20, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsnmpEnableAuthTraps.setStatus('current')
if mibBuilder.loadTexts: nsnmpEnableAuthTraps.setDescription('snmpEnableAuthTraps')
nsnmpInBadTypes = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 20, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsnmpInBadTypes.setStatus('current')
if mibBuilder.loadTexts: nsnmpInBadTypes.setDescription('snmpInBadTypes')
nsnmpInNoSuchNames = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 20, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsnmpInNoSuchNames.setStatus('current')
if mibBuilder.loadTexts: nsnmpInNoSuchNames.setDescription('snmpInNoSuchNames')
nsnmpInReadOnlys = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 20, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsnmpInReadOnlys.setStatus('current')
if mibBuilder.loadTexts: nsnmpInReadOnlys.setDescription('snmpInReadOnlys')
nsnmpInTotalReqVars = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 20, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsnmpInTotalReqVars.setStatus('current')
if mibBuilder.loadTexts: nsnmpInTotalReqVars.setDescription('snmpInTotalReqVars')
nsnmpInGetRequests = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 20, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsnmpInGetRequests.setStatus('current')
if mibBuilder.loadTexts: nsnmpInGetRequests.setDescription('snmpInGetRequests')
nsnmpInSetRequests = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 20, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsnmpInSetRequests.setStatus('current')
if mibBuilder.loadTexts: nsnmpInSetRequests.setDescription('snmpInSetRequests')
nsnmpInTraps = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 20, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsnmpInTraps.setStatus('current')
if mibBuilder.loadTexts: nsnmpInTraps.setDescription('snmpInTraps')
nsnmpOutNoSuchNames = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 20, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsnmpOutNoSuchNames.setStatus('current')
if mibBuilder.loadTexts: nsnmpOutNoSuchNames.setDescription('snmpOutNoSuchNames')
nsnmpOutReadOnlys = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 20, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsnmpOutReadOnlys.setStatus('current')
if mibBuilder.loadTexts: nsnmpOutReadOnlys.setDescription('snmpOutReadOnlys')
nsnmpOutGetRequests = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 20, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsnmpOutGetRequests.setStatus('current')
if mibBuilder.loadTexts: nsnmpOutGetRequests.setDescription('snmpOutGetRequests')
nsnmpOutSetRequests = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 20, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsnmpOutSetRequests.setStatus('current')
if mibBuilder.loadTexts: nsnmpOutSetRequests.setDescription('snmpOutSetRequests')
nsnmpOutTraps = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 20, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsnmpOutTraps.setStatus('current')
if mibBuilder.loadTexts: nsnmpOutTraps.setDescription('snmpOutTraps')
nsnmpProxyDrops = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 2, 20, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsnmpProxyDrops.setStatus('current')
if mibBuilder.loadTexts: nsnmpProxyDrops.setDescription('snmpProxyDrops')
icmpStatsInMsgs = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 17, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmpStatsInMsgs.setStatus('current')
if mibBuilder.loadTexts: icmpStatsInMsgs.setDescription('icmp InMsgs')
icmpStatsInErrors = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 17, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmpStatsInErrors.setStatus('current')
if mibBuilder.loadTexts: icmpStatsInErrors.setDescription('icmp InErrors')
icmpStatsInDestUnreachs = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 17, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmpStatsInDestUnreachs.setStatus('current')
if mibBuilder.loadTexts: icmpStatsInDestUnreachs.setDescription('icmp InDestUnreachs')
icmpStatsInTimeExcds = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 17, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmpStatsInTimeExcds.setStatus('current')
if mibBuilder.loadTexts: icmpStatsInTimeExcds.setDescription('icmp InTimeExcds')
icmpStatsInParmProbs = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 17, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmpStatsInParmProbs.setStatus('current')
if mibBuilder.loadTexts: icmpStatsInParmProbs.setDescription('icmp InParmProbs')
icmpStatsInSrcQuenchs = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 17, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmpStatsInSrcQuenchs.setStatus('current')
if mibBuilder.loadTexts: icmpStatsInSrcQuenchs.setDescription('icmp InSrcQuenchs')
icmpStatsInRedirects = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 17, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmpStatsInRedirects.setStatus('current')
if mibBuilder.loadTexts: icmpStatsInRedirects.setDescription('icmp InRedirects')
icmpStatsInEchos = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 17, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmpStatsInEchos.setStatus('current')
if mibBuilder.loadTexts: icmpStatsInEchos.setDescription('icmp InEchos')
icmpStatsInEchoReps = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 17, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmpStatsInEchoReps.setStatus('current')
if mibBuilder.loadTexts: icmpStatsInEchoReps.setDescription('icmp InEchoReps')
icmpStatsInTimestamps = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 17, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmpStatsInTimestamps.setStatus('current')
if mibBuilder.loadTexts: icmpStatsInTimestamps.setDescription('icmp InTimestamps')
icmpStatsInTimestampReps = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 17, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmpStatsInTimestampReps.setStatus('current')
if mibBuilder.loadTexts: icmpStatsInTimestampReps.setDescription('icmp InTimestampReps')
icmpStatsInAddrMasks = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 17, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmpStatsInAddrMasks.setStatus('current')
if mibBuilder.loadTexts: icmpStatsInAddrMasks.setDescription('icmp InAddrMasks')
icmpStatsInAddrMaskReps = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 17, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmpStatsInAddrMaskReps.setStatus('current')
if mibBuilder.loadTexts: icmpStatsInAddrMaskReps.setDescription('icmp InAddrMaskReps')
icmpStatsOutMsgs = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 17, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmpStatsOutMsgs.setStatus('current')
if mibBuilder.loadTexts: icmpStatsOutMsgs.setDescription('icmp OutMsgs')
icmpStatsOutErrors = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 17, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmpStatsOutErrors.setStatus('current')
if mibBuilder.loadTexts: icmpStatsOutErrors.setDescription('icmp OutErrors')
icmpStatsOutDestUnreachs = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 17, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmpStatsOutDestUnreachs.setStatus('current')
if mibBuilder.loadTexts: icmpStatsOutDestUnreachs.setDescription('icmp OutDestUnreachs')
icmpStatsOutTimeExcds = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 17, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmpStatsOutTimeExcds.setStatus('current')
if mibBuilder.loadTexts: icmpStatsOutTimeExcds.setDescription('icmp OutTimeExcds')
icmpStatsOutParmProbs = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 17, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmpStatsOutParmProbs.setStatus('current')
if mibBuilder.loadTexts: icmpStatsOutParmProbs.setDescription('icmp OutParmProbs')
icmpStatsOutSrcQuenchs = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 17, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmpStatsOutSrcQuenchs.setStatus('current')
if mibBuilder.loadTexts: icmpStatsOutSrcQuenchs.setDescription('icmp OutSrcQuenchs')
icmpStatsOutRedirects = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 17, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmpStatsOutRedirects.setStatus('current')
if mibBuilder.loadTexts: icmpStatsOutRedirects.setDescription('icmp OutRedirects')
icmpStatsOutEchos = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 17, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmpStatsOutEchos.setStatus('current')
if mibBuilder.loadTexts: icmpStatsOutEchos.setDescription('icmp OutEchos')
icmpStatsOutEchoReps = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 17, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmpStatsOutEchoReps.setStatus('current')
if mibBuilder.loadTexts: icmpStatsOutEchoReps.setDescription('icmp OutEchoReps')
icmpStatsOutTimestamps = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 17, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmpStatsOutTimestamps.setStatus('current')
if mibBuilder.loadTexts: icmpStatsOutTimestamps.setDescription('icmp OutTimestamps')
icmpStatsOutTimestampReps = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 17, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmpStatsOutTimestampReps.setStatus('current')
if mibBuilder.loadTexts: icmpStatsOutTimestampReps.setDescription('icmp OutTimestampReps')
icmpStatsOutAddrMasks = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 17, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmpStatsOutAddrMasks.setStatus('current')
if mibBuilder.loadTexts: icmpStatsOutAddrMasks.setDescription('icmp OutAddrMasks')
icmpStatsOutAddrMaskReps = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 17, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmpStatsOutAddrMaskReps.setStatus('current')
if mibBuilder.loadTexts: icmpStatsOutAddrMaskReps.setDescription('icmp OutAddrMaskReps')
tcpStatsRtoAlgorithm = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 18, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpStatsRtoAlgorithm.setStatus('current')
if mibBuilder.loadTexts: tcpStatsRtoAlgorithm.setDescription('tcp RtoAlgorithm')
tcpStatsRtoMin = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 18, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpStatsRtoMin.setStatus('current')
if mibBuilder.loadTexts: tcpStatsRtoMin.setDescription('tcp RtoMin')
tcpStatsRtoMax = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 18, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpStatsRtoMax.setStatus('current')
if mibBuilder.loadTexts: tcpStatsRtoMax.setDescription('tcp RtoMax')
tcpStatsMaxConn = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 18, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpStatsMaxConn.setStatus('current')
if mibBuilder.loadTexts: tcpStatsMaxConn.setDescription('tcp MaxConn')
tcpStatsActiveOpens = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 18, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpStatsActiveOpens.setStatus('current')
if mibBuilder.loadTexts: tcpStatsActiveOpens.setDescription('tcp ActiveOpens')
tcpStatsPassiveOpens = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 18, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpStatsPassiveOpens.setStatus('current')
if mibBuilder.loadTexts: tcpStatsPassiveOpens.setDescription('tcp PassiveOpens')
tcpStatsAttemptFails = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 18, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpStatsAttemptFails.setStatus('current')
if mibBuilder.loadTexts: tcpStatsAttemptFails.setDescription('tcp AttemptFails')
tcpStatsEstabResets = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 18, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpStatsEstabResets.setStatus('current')
if mibBuilder.loadTexts: tcpStatsEstabResets.setDescription('tcp EstabResets')
tcpStatsInSegs = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 18, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpStatsInSegs.setStatus('current')
if mibBuilder.loadTexts: tcpStatsInSegs.setDescription('tcp InSegs')
tcpStatsOutSegs = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 18, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpStatsOutSegs.setStatus('current')
if mibBuilder.loadTexts: tcpStatsOutSegs.setDescription('tcp OutSegs')
tcpStatsRetransSegs = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 18, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpStatsRetransSegs.setStatus('current')
if mibBuilder.loadTexts: tcpStatsRetransSegs.setDescription('tcp RetransSegs')
tcpStatsInErrs = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 18, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpStatsInErrs.setStatus('current')
if mibBuilder.loadTexts: tcpStatsInErrs.setDescription('tcp InErrs')
tcpStatsCurrEstab = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 18, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpStatsCurrEstab.setStatus('current')
if mibBuilder.loadTexts: tcpStatsCurrEstab.setDescription('tcp CurrEstab')
tcpStatsCurrConn = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 18, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpStatsCurrConn.setStatus('current')
if mibBuilder.loadTexts: tcpStatsCurrConn.setDescription('tcp CurrConn')
tcpStatsOutRsts = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 18, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpStatsOutRsts.setStatus('current')
if mibBuilder.loadTexts: tcpStatsOutRsts.setDescription('tcp OutRsts')
udpStatsInDatagrams = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 19, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: udpStatsInDatagrams.setStatus('current')
if mibBuilder.loadTexts: udpStatsInDatagrams.setDescription('udp InDatagrams')
udpStatsOutDatagrams = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 19, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: udpStatsOutDatagrams.setStatus('current')
if mibBuilder.loadTexts: udpStatsOutDatagrams.setDescription('udp OutDatagrams')
udpStatsInErrors = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 19, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: udpStatsInErrors.setStatus('current')
if mibBuilder.loadTexts: udpStatsInErrors.setDescription('udp InErrors')
udpStatsNoPorts = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 19, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: udpStatsNoPorts.setStatus('current')
if mibBuilder.loadTexts: udpStatsNoPorts.setDescription('udp NoPorts')
bootpRelayStatsTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 20, 1), )
if mibBuilder.loadTexts: bootpRelayStatsTable.setStatus('current')
if mibBuilder.loadTexts: bootpRelayStatsTable.setDescription('The BOOTP relay agent statistics.')
bootpRelayStatsTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 20, 1, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "bootpRelayStatsIndex"))
if mibBuilder.loadTexts: bootpRelayStatsTableEntry.setStatus('current')
if mibBuilder.loadTexts: bootpRelayStatsTableEntry.setDescription('A row in the BOOTP relay agent statistics table.')
bootpRelayStatsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 20, 1, 1, 1), PortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bootpRelayStatsIndex.setStatus('current')
if mibBuilder.loadTexts: bootpRelayStatsIndex.setDescription('The port number of the port associated with this BOOTP relay statistics entry.')
bootpRelayStatsRequestsReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 20, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bootpRelayStatsRequestsReceived.setStatus('current')
if mibBuilder.loadTexts: bootpRelayStatsRequestsReceived.setDescription('The total number of BOOTP request packets received on the port.')
bootpRelayStatsRequestsRelayed = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 20, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bootpRelayStatsRequestsRelayed.setStatus('current')
if mibBuilder.loadTexts: bootpRelayStatsRequestsRelayed.setDescription('The number of request packets relayed to the BOOTP server. If there is more than one server, a request is relayed once for each server; hence, with two servers, this counter will be twice as many as the value of the bootpRelayStatsRequestsReceived object.')
bootpRelayStatsRequestsDroppedNoRelay = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 20, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bootpRelayStatsRequestsDroppedNoRelay.setStatus('current')
if mibBuilder.loadTexts: bootpRelayStatsRequestsDroppedNoRelay.setDescription('This counter increases each time a request could not be relayed because BOOTP relay is disabled or not allowed on the port.')
bootpRelayStatsRequestsDroppedNoServer = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 20, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bootpRelayStatsRequestsDroppedNoServer.setStatus('current')
if mibBuilder.loadTexts: bootpRelayStatsRequestsDroppedNoServer.setDescription('This counter increases each time a request is dropped because there is no configured server or the server is unreachable because there is no active IP interface that can be used for relaying the request to the server.')
bootpRelayStatsRequestsDroppedError = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 20, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bootpRelayStatsRequestsDroppedError.setStatus('current')
if mibBuilder.loadTexts: bootpRelayStatsRequestsDroppedError.setDescription("This counter increases each time a request is dropped due to various errors encountered while processing the request packet. Such errors include short packet length, invalid 'hops' value, and memory allocation errors.")
bootpRelayStatsRepliesReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 20, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bootpRelayStatsRepliesReceived.setStatus('current')
if mibBuilder.loadTexts: bootpRelayStatsRepliesReceived.setDescription('This is the total number of BOOTP response packets received on the port associated with this object.')
bootpRelayStatsRepliesRelayed = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 20, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bootpRelayStatsRepliesRelayed.setStatus('current')
if mibBuilder.loadTexts: bootpRelayStatsRepliesRelayed.setDescription('This is the total number of response packets that were relayed to the client.')
bootpRelayStatsRepliesDroppedError = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 20, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bootpRelayStatsRepliesDroppedError.setStatus('current')
if mibBuilder.loadTexts: bootpRelayStatsRepliesDroppedError.setDescription("This counter increases each time a response packet is dropped due to various errors encountered while processing the packet. Errors include unknown relay agent addresses ('giaddr'), and memory allocation errors.")
arpStatEntries = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 2, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: arpStatEntries.setStatus('current')
if mibBuilder.loadTexts: arpStatEntries.setDescription('The current number of ARP entries.')
arpStatHighWater = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 2, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: arpStatHighWater.setStatus('current')
if mibBuilder.loadTexts: arpStatHighWater.setDescription('The highest number of ARP entries.')
arpStatMaxEntries = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 2, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: arpStatMaxEntries.setStatus('current')
if mibBuilder.loadTexts: arpStatMaxEntries.setDescription('The maximum number of ARP entries.')
routeStatEntries = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 3, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: routeStatEntries.setStatus('current')
if mibBuilder.loadTexts: routeStatEntries.setDescription('The current number of IP routes.')
routeStatHighWater = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 3, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: routeStatHighWater.setStatus('current')
if mibBuilder.loadTexts: routeStatHighWater.setDescription('The highest number of IP routes.')
routeStatStaticEntries = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 3, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: routeStatStaticEntries.setStatus('current')
if mibBuilder.loadTexts: routeStatStaticEntries.setDescription('Current static routes.')
routeStatRipEntries = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 3, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: routeStatRipEntries.setStatus('current')
if mibBuilder.loadTexts: routeStatRipEntries.setDescription('Current RIP routes.')
routeStatOspfEntries = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 3, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: routeStatOspfEntries.setStatus('current')
if mibBuilder.loadTexts: routeStatOspfEntries.setDescription('Current OSPF routes.')
routeStatBgpEntries = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 3, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: routeStatBgpEntries.setStatus('current')
if mibBuilder.loadTexts: routeStatBgpEntries.setDescription('Current BGP routes.')
routeStatMaxEntries = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 3, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: routeStatMaxEntries.setStatus('current')
if mibBuilder.loadTexts: routeStatMaxEntries.setDescription('The maximum number of IP routes.')
routeStatEcmpMaxEntries = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 3, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: routeStatEcmpMaxEntries.setStatus('current')
if mibBuilder.loadTexts: routeStatEcmpMaxEntries.setDescription('Maximum number of ECMP routes.')
routeStatEcmpMaxStaticEntries = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 3, 9), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: routeStatEcmpMaxStaticEntries.setStatus('current')
if mibBuilder.loadTexts: routeStatEcmpMaxStaticEntries.setDescription('Maximum number of static ECMP routes.')
routeStatEcmpMaxDynamicEntries = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 3, 10), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: routeStatEcmpMaxDynamicEntries.setStatus('current')
if mibBuilder.loadTexts: routeStatEcmpMaxDynamicEntries.setDescription('Maximum number of dynamic ECMP routes.')
routeStatEcmpPathsEntries = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 3, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: routeStatEcmpPathsEntries.setStatus('current')
if mibBuilder.loadTexts: routeStatEcmpPathsEntries.setDescription('Number of routes with ECMP paths.')
dnsStatInGoodDnsRequests = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 4, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dnsStatInGoodDnsRequests.setStatus('current')
if mibBuilder.loadTexts: dnsStatInGoodDnsRequests.setDescription('The total number of DNS request packets which are received.')
dnsStatInBadDnsRequests = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 4, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dnsStatInBadDnsRequests.setStatus('current')
if mibBuilder.loadTexts: dnsStatInBadDnsRequests.setDescription('The total number of DNS request packets received that were dropped.')
dnsStatOutDnsRequests = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 4, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dnsStatOutDnsRequests.setStatus('current')
if mibBuilder.loadTexts: dnsStatOutDnsRequests.setDescription('The total number of DNS request packets that have been transmitted.')
vrrpStatInAdvers = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 5, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpStatInAdvers.setStatus('current')
if mibBuilder.loadTexts: vrrpStatInAdvers.setDescription('The number of good VRRP advertisements which are received.')
vrrpStatOutAdvers = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 5, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpStatOutAdvers.setStatus('current')
if mibBuilder.loadTexts: vrrpStatOutAdvers.setDescription('The number of good VRRP advertisements which are transmitted.')
vrrpStatBadAdvers = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 5, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpStatBadAdvers.setStatus('current')
if mibBuilder.loadTexts: vrrpStatBadAdvers.setDescription('The number of bad VRRP advertisements which are received.')
vrrpStatBadVersion = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 5, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpStatBadVersion.setStatus('current')
if mibBuilder.loadTexts: vrrpStatBadVersion.setDescription('The number of bad VRRP version adv which are received.')
vrrpStatBadAddress = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 5, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpStatBadAddress.setStatus('current')
if mibBuilder.loadTexts: vrrpStatBadAddress.setDescription('The number of bad VRRP addres adv which are received.')
vrrpStatBadPassword = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 5, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpStatBadPassword.setStatus('current')
if mibBuilder.loadTexts: vrrpStatBadPassword.setDescription('The number of bad VRRP advertisements which are received.')
vrrpStatBadVrid = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 5, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpStatBadVrid.setStatus('current')
if mibBuilder.loadTexts: vrrpStatBadVrid.setDescription('The number of bad VRRP version ID adv which are received.')
vrrpStatBadData = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 5, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpStatBadData.setStatus('current')
if mibBuilder.loadTexts: vrrpStatBadData.setDescription('The number of bad VRRP advertisements which are received.')
vrrpStatBadInterval = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 5, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpStatBadInterval.setStatus('current')
if mibBuilder.loadTexts: vrrpStatBadInterval.setDescription('The number of bad VRRP intervals which are received.')
vrrpStatOutGratuitousARPs = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 5, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpStatOutGratuitousARPs.setStatus('current')
if mibBuilder.loadTexts: vrrpStatOutGratuitousARPs.setDescription('The number of gratuitous ARP packets which are transmitted.')
ipClearStats = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 7, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("clear", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipClearStats.setStatus('current')
if mibBuilder.loadTexts: ipClearStats.setDescription('Setting this to clear(2) results in clearing the IP statistics.')
vrrpClearStats = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 7, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("clear", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrrpClearStats.setStatus('current')
if mibBuilder.loadTexts: vrrpClearStats.setDescription('Setting this to clear(2) results in clearing the VRRP statistics.')
ospfClearStats = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 7, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clear", 1), ("ok", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospfClearStats.setStatus('current')
if mibBuilder.loadTexts: ospfClearStats.setDescription('Setting this to clear(1) results in clearing the OSPF statistics.')
tcpClearStats = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 7, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clear", 1), ("ok", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tcpClearStats.setStatus('current')
if mibBuilder.loadTexts: tcpClearStats.setDescription('Setting this to clear(1) results in clearing the TCP statistics.')
udpClearStats = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 7, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clear", 1), ("ok", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: udpClearStats.setStatus('current')
if mibBuilder.loadTexts: udpClearStats.setDescription('Setting this to clear(1) results in clearing the UDP statistics.')
dnsClearStats = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 7, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clear", 1), ("ok", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dnsClearStats.setStatus('current')
if mibBuilder.loadTexts: dnsClearStats.setDescription('Setting this to clear(1) results in clearing the DNS statistics.')
arpClearStats = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 7, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clear", 1), ("ok", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: arpClearStats.setStatus('current')
if mibBuilder.loadTexts: arpClearStats.setDescription('Setting this to clear(1) results in clearing the ARP statistics.')
icmpClearStats = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 7, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clear", 1), ("ok", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: icmpClearStats.setStatus('current')
if mibBuilder.loadTexts: icmpClearStats.setDescription('Setting this to clear(1) results in clearing the ICMP statistics.')
routeClearStats = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 7, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clear", 1), ("ok", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: routeClearStats.setStatus('current')
if mibBuilder.loadTexts: routeClearStats.setDescription('Setting this to clear(1) results in clearing the Route statistics.')
ipv6ClearStats = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 7, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clear", 1), ("ok", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipv6ClearStats.setStatus('current')
if mibBuilder.loadTexts: ipv6ClearStats.setDescription('Setting this to clear(1) results in clearing the IPv6 statistics.')
ipv6ClearIcmpStats = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 7, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clear", 1), ("ok", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipv6ClearIcmpStats.setStatus('current')
if mibBuilder.loadTexts: ipv6ClearIcmpStats.setDescription('Setting this to clear(1) results in clearing the ICMP6 statistics.')
ipv6ClearUdpStats = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 7, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clear", 1), ("ok", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipv6ClearUdpStats.setStatus('current')
if mibBuilder.loadTexts: ipv6ClearUdpStats.setDescription('Setting this to clear(1) results in clearing the UDP6 statistics.')
ospf3ClearStats = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 7, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clear", 1), ("ok", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospf3ClearStats.setStatus('current')
if mibBuilder.loadTexts: ospf3ClearStats.setDescription('Setting this to clear(1) results in clearing the ospf3 statistics.')
ripClearStats = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 7, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clear", 1), ("ok", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ripClearStats.setStatus('current')
if mibBuilder.loadTexts: ripClearStats.setDescription('Setting this to clear(1) results in clearing the RIP statistics.')
ospfGeneralStats = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 1))
ospfCumRxTxStats = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 1, 1))
ospfCumNbrChangeStats = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 1, 2))
ospfCumIntfChangeStats = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 1, 3))
ospfTimersKickOffStats = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 1, 4))
ospfArea = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 2))
ospfAreaRxTxStats = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 2, 1), )
if mibBuilder.loadTexts: ospfAreaRxTxStats.setStatus('current')
if mibBuilder.loadTexts: ospfAreaRxTxStats.setDescription('The table of OSPF Area Rx/Tx Statistics.')
ospfAreaRxTxStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 2, 1, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ospfAreaRxTxIndex"))
if mibBuilder.loadTexts: ospfAreaRxTxStatsEntry.setStatus('current')
if mibBuilder.loadTexts: ospfAreaRxTxStatsEntry.setDescription('Rx Tx packet Statistics about a OSPF area.')
ospfAreaRxTxIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaRxTxIndex.setStatus('current')
if mibBuilder.loadTexts: ospfAreaRxTxIndex.setDescription('The index of the ospf Area for which these statistics apply.')
ospfAreaRxPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 2, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaRxPkts.setStatus('current')
if mibBuilder.loadTexts: ospfAreaRxPkts.setDescription('The total number of OSPF packets received in this OSPF area.')
ospfAreaTxPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 2, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaTxPkts.setStatus('current')
if mibBuilder.loadTexts: ospfAreaTxPkts.setDescription('The total number of OSPF packets transmitted in this OSPF area.')
ospfAreaRxHello = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 2, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaRxHello.setStatus('current')
if mibBuilder.loadTexts: ospfAreaRxHello.setDescription('The total number of Hello packets received in this OSPF area.')
ospfAreaTxHello = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 2, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaTxHello.setStatus('current')
if mibBuilder.loadTexts: ospfAreaTxHello.setDescription('The total number of Hello packets transmitted in this OSPF area.')
ospfAreaRxDatabase = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 2, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaRxDatabase.setStatus('current')
if mibBuilder.loadTexts: ospfAreaRxDatabase.setDescription('The total number of Database Description packets transmitted for this OSPF area.')
ospfAreaTxDatabase = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 2, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaTxDatabase.setStatus('current')
if mibBuilder.loadTexts: ospfAreaTxDatabase.setDescription('The total number of Database Description packets transmitted for this OSPF area.')
ospfAreaRxlsReqs = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 2, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaRxlsReqs.setStatus('current')
if mibBuilder.loadTexts: ospfAreaRxlsReqs.setDescription('The total number of Link State Request packets received for this OSPF area.')
ospfAreaTxlsReqs = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 2, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaTxlsReqs.setStatus('current')
if mibBuilder.loadTexts: ospfAreaTxlsReqs.setDescription('The total number of Link State Request packets transmitted for this OSPF area.')
ospfAreaRxlsAcks = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 2, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaRxlsAcks.setStatus('current')
if mibBuilder.loadTexts: ospfAreaRxlsAcks.setDescription('The total number of Link State Acknowledgement packets received for this OSPF area.')
ospfAreaTxlsAcks = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 2, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaTxlsAcks.setStatus('current')
if mibBuilder.loadTexts: ospfAreaTxlsAcks.setDescription('The total number of Link State Acknowledgement packets transmitted for this OSPF area.')
ospfAreaRxlsUpdates = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 2, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaRxlsUpdates.setStatus('current')
if mibBuilder.loadTexts: ospfAreaRxlsUpdates.setDescription('The total number of Link State Update packets received for this OSPF area.')
ospfAreaTxlsUpdates = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 2, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaTxlsUpdates.setStatus('current')
if mibBuilder.loadTexts: ospfAreaTxlsUpdates.setDescription('The total number of Link State Update packets transmitted for this OSPF area.')
ospfAreaNbrChangeStats = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 2, 2), )
if mibBuilder.loadTexts: ospfAreaNbrChangeStats.setStatus('current')
if mibBuilder.loadTexts: ospfAreaNbrChangeStats.setDescription('The table of OSPF Area Neighbour Statistics.')
ospfAreaNbrChangeStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 2, 2, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ospfAreaNbrIndex"))
if mibBuilder.loadTexts: ospfAreaNbrChangeStatsEntry.setStatus('current')
if mibBuilder.loadTexts: ospfAreaNbrChangeStatsEntry.setDescription('Area Neighbour Change Statistics about a OSPF area.')
ospfAreaNbrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 2, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaNbrIndex.setStatus('current')
if mibBuilder.loadTexts: ospfAreaNbrIndex.setDescription('The index of the ospf Area for which these statistics apply.')
ospfAreaNbrhello = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 2, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaNbrhello.setStatus('current')
if mibBuilder.loadTexts: ospfAreaNbrhello.setDescription('The total number of Hello packets received from neighbours in this OSPF area.')
ospfAreaNbrStart = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 2, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaNbrStart.setStatus('current')
if mibBuilder.loadTexts: ospfAreaNbrStart.setDescription('The total number of neighbours in this state (i.e. an indication that Hello packets should now be sent to the neighbour at intervals of HelloInterval seconds.) in this OSPF area.')
ospfAreaNbrAdjointOk = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 2, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaNbrAdjointOk.setStatus('current')
if mibBuilder.loadTexts: ospfAreaNbrAdjointOk.setDescription('The total number of decisions to be made (again) as to whether an adjacency should be established/maintained with the neighbour. for this OSPF area.')
ospfAreaNbrNegotiationDone = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 2, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaNbrNegotiationDone.setStatus('current')
if mibBuilder.loadTexts: ospfAreaNbrNegotiationDone.setDescription('The total number of neighbours in this state wherein the Master/slave relationship has been negotiated, and sequence numbers have been exchanged, for this OSPF area.')
ospfAreaNbrExchangeDone = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 2, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaNbrExchangeDone.setStatus('current')
if mibBuilder.loadTexts: ospfAreaNbrExchangeDone.setDescription("The total number of neighbours in this state (i.e. in an adjacency's final state) having transimitted a full sequence of Database Description packets, for this OSPF area.")
ospfAreaNbrBadRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 2, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaNbrBadRequests.setStatus('current')
if mibBuilder.loadTexts: ospfAreaNbrBadRequests.setDescription('The sum total number of Link State Requests which have been received for a link state advertisement not contained in the database across this OSPF area.')
ospfAreaNbrBadSequence = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 2, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaNbrBadSequence.setStatus('current')
if mibBuilder.loadTexts: ospfAreaNbrBadSequence.setDescription('The total number of Database Description packets which have been received that either a) has an unexpected DD sequence number b) Unexpectedly has the init bit set c) Has an options field differing from the last Options field received in a Database Description packet. Any of these conditions indicate that some error has occured during adjacency establishment for this OSPF area.')
ospfAreaNbrLoadingDone = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 2, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaNbrLoadingDone.setStatus('current')
if mibBuilder.loadTexts: ospfAreaNbrLoadingDone.setDescription('The total number of link state updates received for all out-of-date portions of the database in this OSPF area.')
ospfAreaNbrN1way = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 2, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaNbrN1way.setStatus('current')
if mibBuilder.loadTexts: ospfAreaNbrN1way.setDescription('The total number of Hello packets received from neighbours, in which this router is not mentioned in this OSPF area.')
ospfAreaNbrRstAd = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 2, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaNbrRstAd.setStatus('current')
if mibBuilder.loadTexts: ospfAreaNbrRstAd.setDescription('The total number of times the Neighbour adjacency has been reset across this OPSF area.')
ospfAreaNbrDown = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 2, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaNbrDown.setStatus('current')
if mibBuilder.loadTexts: ospfAreaNbrDown.setDescription('The total number of Neighbouring routers down (i.e. in the initial state of a neighbour conversation.) in this OSPF area.')
ospfAreaNbrN2way = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 2, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaNbrN2way.setStatus('current')
if mibBuilder.loadTexts: ospfAreaNbrN2way.setDescription('The total number of Hello packets received from neighbours, in which this router is mentioned in this OSPF area.')
ospfAreaChangeStats = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 2, 3), )
if mibBuilder.loadTexts: ospfAreaChangeStats.setStatus('current')
if mibBuilder.loadTexts: ospfAreaChangeStats.setDescription('The table of OSPF Area Change Statistics.')
ospfAreaChangeStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 2, 3, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ospfAreaIntfIndex"))
if mibBuilder.loadTexts: ospfAreaChangeStatsEntry.setStatus('current')
if mibBuilder.loadTexts: ospfAreaChangeStatsEntry.setDescription('Area Change Statistics about a OSPF area.')
ospfAreaIntfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 2, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaIntfIndex.setStatus('current')
if mibBuilder.loadTexts: ospfAreaIntfIndex.setDescription('The index of the OSPF Area for which these statistics apply.')
ospfAreaIntfHello = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 2, 3, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaIntfHello.setStatus('current')
if mibBuilder.loadTexts: ospfAreaIntfHello.setDescription('The total number of Hello packets sent on this OSPF area.')
ospfAreaIntfDown = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 2, 3, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaIntfDown.setStatus('current')
if mibBuilder.loadTexts: ospfAreaIntfDown.setDescription('The total number of interfaces down in this OSPF area.')
ospfAreaIntfLoop = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 2, 3, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaIntfLoop.setStatus('current')
if mibBuilder.loadTexts: ospfAreaIntfLoop.setDescription('The total number of interfaces no longer connected to the attatched network in this OSPF area.')
ospfAreaIntfUnloop = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 2, 3, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaIntfUnloop.setStatus('current')
if mibBuilder.loadTexts: ospfAreaIntfUnloop.setDescription('The total number of interfaces connected to the attatched network in this OSPF area..')
ospfAreaIntfWaitTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 2, 3, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaIntfWaitTimer.setStatus('current')
if mibBuilder.loadTexts: ospfAreaIntfWaitTimer.setDescription('The total number of times the Wait Timer has been fired, (indicating the end of the waiting period that is required before electing a (Backup) Designated Router) for this OSPF area.')
ospfAreaIntfBackup = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 2, 3, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaIntfBackup.setStatus('current')
if mibBuilder.loadTexts: ospfAreaIntfBackup.setDescription('The total number of Backup Designated Routers on the attatched network for this OSPF area.')
ospfAreaIntfNbrChange = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 2, 3, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaIntfNbrChange.setStatus('current')
if mibBuilder.loadTexts: ospfAreaIntfNbrChange.setDescription('The total number of changes in the set of bidirectional neighbours associated with the interface in this OSPF area.')
ospfAreaErrorStats = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 2, 4), )
if mibBuilder.loadTexts: ospfAreaErrorStats.setStatus('current')
if mibBuilder.loadTexts: ospfAreaErrorStats.setDescription('The table of OSPF Area Error Statistics.')
ospfAreaErrorStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 2, 4, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ospfAreaErrIndex"))
if mibBuilder.loadTexts: ospfAreaErrorStatsEntry.setStatus('current')
if mibBuilder.loadTexts: ospfAreaErrorStatsEntry.setDescription('Error Statistics for an OSPF area.')
ospfAreaErrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 2, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaErrIndex.setStatus('current')
if mibBuilder.loadTexts: ospfAreaErrIndex.setDescription('The index of the OSPF Area for which these statistics apply.')
ospfAreaErrAuthFailure = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 2, 4, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaErrAuthFailure.setStatus('current')
if mibBuilder.loadTexts: ospfAreaErrAuthFailure.setDescription('The total number of packets received with a wrong password in this area.')
ospfAreaErrNetmaskMismatch = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 2, 4, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaErrNetmaskMismatch.setStatus('current')
if mibBuilder.loadTexts: ospfAreaErrNetmaskMismatch.setDescription('The total number of packets received with a wrong netmask in this area.')
ospfAreaErrHelloMismatch = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 2, 4, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaErrHelloMismatch.setStatus('current')
if mibBuilder.loadTexts: ospfAreaErrHelloMismatch.setDescription('The total number of packets received with a different hello interval in this area.')
ospfAreaErrDeadMismatch = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 2, 4, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaErrDeadMismatch.setStatus('current')
if mibBuilder.loadTexts: ospfAreaErrDeadMismatch.setDescription('The total number of packets received with a different dead interval in this area.')
ospfAreaErrOptionsMismatch = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 2, 4, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaErrOptionsMismatch.setStatus('current')
if mibBuilder.loadTexts: ospfAreaErrOptionsMismatch.setDescription('The total number of packets received with a different options in this area.')
ospfAreaErrUnknownNbr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 2, 4, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaErrUnknownNbr.setStatus('current')
if mibBuilder.loadTexts: ospfAreaErrUnknownNbr.setDescription('The total number of packets received from an unknown neighbor in this area.')
ospfAreaErrAreaMismatch = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 2, 4, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaErrAreaMismatch.setStatus('current')
if mibBuilder.loadTexts: ospfAreaErrAreaMismatch.setDescription('The total number of packets received with a wrong area.')
ospfAreaErrInvalidSelfOrigLsa = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 2, 4, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaErrInvalidSelfOrigLsa.setStatus('current')
if mibBuilder.loadTexts: ospfAreaErrInvalidSelfOrigLsa.setDescription('The total number of packets received with invalid self originated LSAs.')
ospfInterface = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 3))
ospfIntfRxTxStats = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 3, 1), )
if mibBuilder.loadTexts: ospfIntfRxTxStats.setStatus('current')
if mibBuilder.loadTexts: ospfIntfRxTxStats.setDescription('The table of OSPF Interface Rx/Tx packet Statistics.')
ospfIntfRxTxStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 3, 1, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ospfIntfRxTxIndex"))
if mibBuilder.loadTexts: ospfIntfRxTxStatsEntry.setStatus('current')
if mibBuilder.loadTexts: ospfIntfRxTxStatsEntry.setDescription('OSPF interface Rx/Tx packet statistics.')
ospfIntfRxTxIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfRxTxIndex.setStatus('current')
if mibBuilder.loadTexts: ospfIntfRxTxIndex.setDescription('The OSPF interface for which these statistics apply.')
ospfIntfRxPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 3, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfRxPkts.setStatus('current')
if mibBuilder.loadTexts: ospfIntfRxPkts.setDescription('The total number of OSPF packets received for this OSPF interface.')
ospfIntfTxPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 3, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfTxPkts.setStatus('current')
if mibBuilder.loadTexts: ospfIntfTxPkts.setDescription('The total number of OSPF packets transmitted for this OSPF interface.')
ospfIntfRxHello = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 3, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfRxHello.setStatus('current')
if mibBuilder.loadTexts: ospfIntfRxHello.setDescription('The total number of Hello packets received for this OSPF interface.')
ospfIntfTxHello = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 3, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfTxHello.setStatus('current')
if mibBuilder.loadTexts: ospfIntfTxHello.setDescription('The total number of Hello packets transmitted for this OSPF interface.')
ospfIntfRxDatabase = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 3, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfRxDatabase.setStatus('current')
if mibBuilder.loadTexts: ospfIntfRxDatabase.setDescription('The total number of Database Description packets received for this OSPF interface.')
ospfIntfTxDatabase = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 3, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfTxDatabase.setStatus('current')
if mibBuilder.loadTexts: ospfIntfTxDatabase.setDescription('The total number of Database Description packets transmitted for this OSPF interface.')
ospfIntfRxlsReqs = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 3, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfRxlsReqs.setStatus('current')
if mibBuilder.loadTexts: ospfIntfRxlsReqs.setDescription('The total number of Link State Request packets received for this OSPF interface.')
ospfIntfTxlsReqs = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 3, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfTxlsReqs.setStatus('current')
if mibBuilder.loadTexts: ospfIntfTxlsReqs.setDescription('The total number of Link State Request packets transmitted for this OSPF interface.')
ospfIntfRxlsAcks = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 3, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfRxlsAcks.setStatus('current')
if mibBuilder.loadTexts: ospfIntfRxlsAcks.setDescription('The total number of Link State Acknowledgement packets received for this OSPF interface.')
ospfIntfTxlsAcks = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 3, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfTxlsAcks.setStatus('current')
if mibBuilder.loadTexts: ospfIntfTxlsAcks.setDescription('The total number of Link State Acknowledgement packets transmitted for this OSPF interface.')
ospfIntfRxlsUpdates = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 3, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfRxlsUpdates.setStatus('current')
if mibBuilder.loadTexts: ospfIntfRxlsUpdates.setDescription('The total number of Link State Update packets received for this OSPF interface.')
ospfIntfTxlsUpdates = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 3, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfTxlsUpdates.setStatus('current')
if mibBuilder.loadTexts: ospfIntfTxlsUpdates.setDescription('The total number of Link State Update packets transmitted for this OSPF interface.')
ospfIntfNbrChangeStats = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 3, 2), )
if mibBuilder.loadTexts: ospfIntfNbrChangeStats.setStatus('current')
if mibBuilder.loadTexts: ospfIntfNbrChangeStats.setDescription('The table of OSPF Interface Neighbour change Statistics.')
ospfIntfNbrChangeStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 3, 2, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ospfIntfNbrIndex"))
if mibBuilder.loadTexts: ospfIntfNbrChangeStatsEntry.setStatus('current')
if mibBuilder.loadTexts: ospfIntfNbrChangeStatsEntry.setDescription('OSPF interface Neighbour Change statistics.')
ospfIntfNbrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 3, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfNbrIndex.setStatus('current')
if mibBuilder.loadTexts: ospfIntfNbrIndex.setDescription('The index of the OSPF Interface for which these statistics apply.')
ospfIntfNbrhello = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 3, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfNbrhello.setStatus('current')
if mibBuilder.loadTexts: ospfIntfNbrhello.setDescription('The total number of Hello packets received from neighbours in this OSPF interface.')
ospfIntfNbrStart = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 3, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfNbrStart.setStatus('current')
if mibBuilder.loadTexts: ospfIntfNbrStart.setDescription('The total number of neighbours in this state (i.e. an indication that Hello packets should now be sent to the neighbour at intervals of HelloInterval seconds.) in this OSPF interface.')
ospfIntfNbrAdjointOk = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 3, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfNbrAdjointOk.setStatus('current')
if mibBuilder.loadTexts: ospfIntfNbrAdjointOk.setDescription('The total number of decisions to be made (again) as to whether an adjacency should be established/maintained with the neighbour. for this OSPF interface.')
ospfIntfNbrNegotiationDone = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 3, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfNbrNegotiationDone.setStatus('current')
if mibBuilder.loadTexts: ospfIntfNbrNegotiationDone.setDescription('The total number of neighbours in this state wherein the Master/slave relationship has been negotiated, and sequence numbers have been exchanged, for this OSPF interface.')
ospfIntfNbrExchangeDone = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 3, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfNbrExchangeDone.setStatus('current')
if mibBuilder.loadTexts: ospfIntfNbrExchangeDone.setDescription("The total number of neighbours in this state (i.e. in an adjacency's final state) having transimitted a full sequence of Database Description packets, for this OSPF interface.")
ospfIntfNbrBadRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 3, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfNbrBadRequests.setStatus('current')
if mibBuilder.loadTexts: ospfIntfNbrBadRequests.setDescription('The total number of Link State Requests which have been received for a link state advertisement not contained in the database for this interface.')
ospfIntfNbrBadSequence = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 3, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfNbrBadSequence.setStatus('current')
if mibBuilder.loadTexts: ospfIntfNbrBadSequence.setDescription('The total number of Database Description packets which have been received that either a) has an unexpected DD sequence number b) Unexpectedly has the init bit set c) Has an options field differing from the last Options field received in a Database Description packet. Any of these conditions indicate that some error has occured during adjacency establishment for this interface.')
ospfIntfNbrLoadingDone = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 3, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfNbrLoadingDone.setStatus('current')
if mibBuilder.loadTexts: ospfIntfNbrLoadingDone.setDescription('The total number of link state updates received for all out-of-date portions of the database for this OSPF interface.')
ospfIntfNbrN1way = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 3, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfNbrN1way.setStatus('current')
if mibBuilder.loadTexts: ospfIntfNbrN1way.setDescription('The total number of Hello packets received from neighbours, in which this router is not mentioned for this OSPF interface.')
ospfIntfNbrRstAd = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 3, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfNbrRstAd.setStatus('current')
if mibBuilder.loadTexts: ospfIntfNbrRstAd.setDescription('The sum total number of times the Neighbour adjacency has been reset on this interface.')
ospfIntfNbrDown = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 3, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfNbrDown.setStatus('current')
if mibBuilder.loadTexts: ospfIntfNbrDown.setDescription('The total number of Neighbouring routers down (i.e. in the initial state of a neighbour conversation.) for this interface.')
ospfIntfNbrN2way = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 3, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfNbrN2way.setStatus('current')
if mibBuilder.loadTexts: ospfIntfNbrN2way.setDescription('The total number of Hello packets received from neighbours, in which this router is mentioned for this OSPF interface.')
ospfIntfChangeStats = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 3, 3), )
if mibBuilder.loadTexts: ospfIntfChangeStats.setStatus('current')
if mibBuilder.loadTexts: ospfIntfChangeStats.setDescription('The table of OSPF Interface change Statistics.')
ospfIntfChangeStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 3, 3, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ospfIntfIndex"))
if mibBuilder.loadTexts: ospfIntfChangeStatsEntry.setStatus('current')
if mibBuilder.loadTexts: ospfIntfChangeStatsEntry.setDescription('OSPF interface Change statistics.')
ospfIntfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 3, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfIndex.setStatus('current')
if mibBuilder.loadTexts: ospfIntfIndex.setDescription('The index of the OSPF Interface for which these statistics apply.')
ospfIntfHello = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 3, 3, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfHello.setStatus('current')
if mibBuilder.loadTexts: ospfIntfHello.setDescription('The total number of Hello packets sent by this interface.')
ospfIntfDown = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 3, 3, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfDown.setStatus('current')
if mibBuilder.loadTexts: ospfIntfDown.setDescription('The total number of times the interface was down.')
ospfIntfLoop = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 3, 3, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfLoop.setStatus('current')
if mibBuilder.loadTexts: ospfIntfLoop.setDescription('The total number of times the interface was no longer connected to the attatched network.')
ospfIntfUnloop = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 3, 3, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfUnloop.setStatus('current')
if mibBuilder.loadTexts: ospfIntfUnloop.setDescription('The total number of times the interface, connected back to the attatched network.')
ospfIntfWaitTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 3, 3, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfWaitTimer.setStatus('current')
if mibBuilder.loadTexts: ospfIntfWaitTimer.setDescription('The total number of times the Wait Timer has been fired, (indicating the end of the waiting period that is required before electing a (Backup) Designated Router) for this OSPF interface.')
ospfIntfBackup = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 3, 3, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfBackup.setStatus('current')
if mibBuilder.loadTexts: ospfIntfBackup.setDescription('The total number of Backup Designated Routers on the attatched network for this OSPF interface.')
ospfIntfNbrChange = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 3, 3, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfNbrChange.setStatus('current')
if mibBuilder.loadTexts: ospfIntfNbrChange.setDescription('The total number of changes in the set of bidirectional neighbours associated with the interface for this OSPF interface.')
ospfIntfErrorStats = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 3, 4), )
if mibBuilder.loadTexts: ospfIntfErrorStats.setStatus('current')
if mibBuilder.loadTexts: ospfIntfErrorStats.setDescription('The table of OSPF Interface Error Statistics.')
ospfIntfErrorStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 3, 4, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ospfIntfErrIndex"))
if mibBuilder.loadTexts: ospfIntfErrorStatsEntry.setStatus('current')
if mibBuilder.loadTexts: ospfIntfErrorStatsEntry.setDescription('Error Statistics for an OSPF area.')
ospfIntfErrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 3, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfErrIndex.setStatus('current')
if mibBuilder.loadTexts: ospfIntfErrIndex.setDescription('The index of the OSPF Intf for which these statistics apply.')
ospfIntfErrAuthFailure = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 3, 4, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfErrAuthFailure.setStatus('current')
if mibBuilder.loadTexts: ospfIntfErrAuthFailure.setDescription('The total number of packets received with a wrong password in this area.')
ospfIntfErrNetmaskMismatch = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 3, 4, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfErrNetmaskMismatch.setStatus('current')
if mibBuilder.loadTexts: ospfIntfErrNetmaskMismatch.setDescription('The total number of packets received with a wrong netmask in this area.')
ospfIntfErrHelloMismatch = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 3, 4, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfErrHelloMismatch.setStatus('current')
if mibBuilder.loadTexts: ospfIntfErrHelloMismatch.setDescription('The total number of packets received with a different hello interval in this area.')
ospfIntfErrDeadMismatch = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 3, 4, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfErrDeadMismatch.setStatus('current')
if mibBuilder.loadTexts: ospfIntfErrDeadMismatch.setDescription('The total number of packets received with a different dead interval in this area.')
ospfIntfErrOptionsMismatch = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 3, 4, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfErrOptionsMismatch.setStatus('current')
if mibBuilder.loadTexts: ospfIntfErrOptionsMismatch.setDescription('The total number of packets received with a different options in this area.')
ospfIntfErrUnknownNbr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 3, 4, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfErrUnknownNbr.setStatus('current')
if mibBuilder.loadTexts: ospfIntfErrUnknownNbr.setDescription('The total number of packets received from an unknown neighbor in this area.')
ospfIntfErrAreaMismatch = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 3, 4, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfErrAreaMismatch.setStatus('current')
if mibBuilder.loadTexts: ospfIntfErrAreaMismatch.setDescription('The total number of packets received with a wrong area.')
ospfIntfErrInvalidSelfOrigLSA = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 3, 4, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfErrInvalidSelfOrigLSA.setStatus('current')
if mibBuilder.loadTexts: ospfIntfErrInvalidSelfOrigLSA.setDescription('The total number of packets received with invalid self-orig LSAs.')
ospfCumRxPkts = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 1, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCumRxPkts.setStatus('current')
if mibBuilder.loadTexts: ospfCumRxPkts.setDescription('The sum total of all OSPF packets received on all OSPF areas and interfaces.')
ospfCumTxPkts = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCumTxPkts.setStatus('current')
if mibBuilder.loadTexts: ospfCumTxPkts.setDescription('The sum total of all OSPF packets transmitted on all OSPF areas and interfaces.')
ospfCumRxHello = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCumRxHello.setStatus('current')
if mibBuilder.loadTexts: ospfCumRxHello.setDescription('The sum total of all Hello packets received on all OSPF areas and interfaces.')
ospfCumTxHello = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCumTxHello.setStatus('current')
if mibBuilder.loadTexts: ospfCumTxHello.setDescription('The sum total of all Hello packets transmitted on all OSPF areas and interfaces.')
ospfCumRxDatabase = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCumRxDatabase.setStatus('current')
if mibBuilder.loadTexts: ospfCumRxDatabase.setDescription('The sum total of all Database Description packets received on all OSPF areas and interfaces.')
ospfCumTxDatabase = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCumTxDatabase.setStatus('current')
if mibBuilder.loadTexts: ospfCumTxDatabase.setDescription('The sum total of all Database Description packets transmitted on all OSPF areas and interfaces.')
ospfCumRxlsReqs = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCumRxlsReqs.setStatus('current')
if mibBuilder.loadTexts: ospfCumRxlsReqs.setDescription('The sum total of all Link State Request packets received on all OSPF areas and interfaces.')
ospfCumTxlsReqs = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCumTxlsReqs.setStatus('current')
if mibBuilder.loadTexts: ospfCumTxlsReqs.setDescription('The sum total of all Link State Request packets transmitted on all OSPF areas and interfaces.')
ospfCumRxlsAcks = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCumRxlsAcks.setStatus('current')
if mibBuilder.loadTexts: ospfCumRxlsAcks.setDescription('The sum total of all Link State Acknowledgement packets received on all OSPF areas and interfaces.')
ospfCumTxlsAcks = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCumTxlsAcks.setStatus('current')
if mibBuilder.loadTexts: ospfCumTxlsAcks.setDescription('The sum total of all Link State Acknowledgement packets transmitted on all OSPF areas and interfaces.')
ospfCumRxlsUpdates = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCumRxlsUpdates.setStatus('current')
if mibBuilder.loadTexts: ospfCumRxlsUpdates.setDescription('The sum total of all Link State Update packets received on all OSPF areas and interfaces.')
ospfCumTxlsUpdates = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCumTxlsUpdates.setStatus('current')
if mibBuilder.loadTexts: ospfCumTxlsUpdates.setDescription('The sum total of all Link State Update packets transmitted on all OSPF areas and interfaces.')
ospfCumNbrhello = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 1, 2, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCumNbrhello.setStatus('current')
if mibBuilder.loadTexts: ospfCumNbrhello.setDescription('The sum total of all Hello packets received from neighbours on all OSPF areas and interfaces.')
ospfCumNbrStart = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 1, 2, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCumNbrStart.setStatus('current')
if mibBuilder.loadTexts: ospfCumNbrStart.setDescription('The sum total number of neighbours in this state (i.e. an indication that Hello packets should now be sent to the neighbour at intervals of HelloInterval seconds.) across all OSPF areas and interfaces.')
ospfCumNbrAdjointOk = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 1, 2, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCumNbrAdjointOk.setStatus('current')
if mibBuilder.loadTexts: ospfCumNbrAdjointOk.setDescription('The sum total number of decisions to be made (again) as to whether an adjacency should be established/maintained with the neighbour across all OSPF areas and interfaces.')
ospfCumNbrNegotiationDone = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 1, 2, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCumNbrNegotiationDone.setStatus('current')
if mibBuilder.loadTexts: ospfCumNbrNegotiationDone.setDescription('The sum total number of neighbours in this state wherein the Master/slave relationship has been negotiated, and sequence numbers have been exchanged, across all OSPF areas and interfaces.')
ospfCumNbrExchangeDone = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 1, 2, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCumNbrExchangeDone.setStatus('current')
if mibBuilder.loadTexts: ospfCumNbrExchangeDone.setDescription("The sum total number of neighbours in this state (i.e. in an adjacency's final state) having transimitted a full sequence of Database Description packets, across all OSPF areas and interfaces.")
ospfCumNbrBadRequests = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 1, 2, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCumNbrBadRequests.setStatus('current')
if mibBuilder.loadTexts: ospfCumNbrBadRequests.setDescription('The sum total number of Link State Requests which have been received for a link state advertisement not contained in the database across all interfaces and OSPF areas.')
ospfCumNbrBadSequence = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 1, 2, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCumNbrBadSequence.setStatus('current')
if mibBuilder.loadTexts: ospfCumNbrBadSequence.setDescription('The sum total number of Database Description packets which have been received that either a) has an unexpected DD sequence number b) Unexpectedly has the init bit set c) Has an options field differing from the last Options field received in a Database Description packet. Any of these conditions indicate that some error has occured during adjacency establishment for all OSPF areas and interfaces.')
ospfCumNbrLoadingDone = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 1, 2, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCumNbrLoadingDone.setStatus('current')
if mibBuilder.loadTexts: ospfCumNbrLoadingDone.setDescription('The sum total number of link state updates received for all out-of-date portions of the database across all OSPF areas and interfaces.')
ospfCumNbrN1way = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 1, 2, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCumNbrN1way.setStatus('current')
if mibBuilder.loadTexts: ospfCumNbrN1way.setDescription('The sum total number of Hello packets received from neighbours, in which this router is not mentioned across all OSPF interfaces and areas.')
ospfCumNbrRstAd = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 1, 2, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCumNbrRstAd.setStatus('current')
if mibBuilder.loadTexts: ospfCumNbrRstAd.setDescription('The sum total number of times the Neighbour adjacency has been reset across all OPSF areas and interfaces.')
ospfCumNbrDown = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 1, 2, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCumNbrDown.setStatus('current')
if mibBuilder.loadTexts: ospfCumNbrDown.setDescription('The total number of Neighbouring routers down (i.e. in the initial state of a neighbour conversation.) across all OSPF areas and interfaces.')
ospfCumNbrN2way = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 1, 2, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCumNbrN2way.setStatus('current')
if mibBuilder.loadTexts: ospfCumNbrN2way.setDescription('The sum total number of Hello packets received from neighbours, in which this router is mentioned across all OSPF interfaces and areas.')
ospfCumIntfHello = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 1, 3, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCumIntfHello.setStatus('current')
if mibBuilder.loadTexts: ospfCumIntfHello.setDescription('The sum total number of Hello packets sent on all interfaces and areas')
ospfCumIntfDown = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 1, 3, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCumIntfDown.setStatus('current')
if mibBuilder.loadTexts: ospfCumIntfDown.setDescription('The sum total number of interfaces down in all OSPF areas.')
ospfCumIntfLoop = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 1, 3, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCumIntfLoop.setStatus('current')
if mibBuilder.loadTexts: ospfCumIntfLoop.setDescription('The sum total of interfaces no longer connected to the attatched network across all OSPF areas and interfaces.')
ospfCumIntfUnloop = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 1, 3, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCumIntfUnloop.setStatus('current')
if mibBuilder.loadTexts: ospfCumIntfUnloop.setDescription('The sum total number of interfaces, connected to the attatched network in all OSPF areas.')
ospfCumIntfWaitTimer = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 1, 3, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCumIntfWaitTimer.setStatus('current')
if mibBuilder.loadTexts: ospfCumIntfWaitTimer.setDescription('The sum total number of times the Wait Timer has been fired, (indicating the end of the waiting period that is required before electing a (Backup) Designated Router) across all OSPF areas and interfaces.')
ospfCumIntfBackup = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 1, 3, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCumIntfBackup.setStatus('current')
if mibBuilder.loadTexts: ospfCumIntfBackup.setDescription('The sum total number of Backup Designated Routers on the attatched network for all OSPF areas and interfaces.')
ospfCumIntfNbrChange = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 1, 3, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCumIntfNbrChange.setStatus('current')
if mibBuilder.loadTexts: ospfCumIntfNbrChange.setDescription('The sum total number of changes in the set of bidirectional neighbours associated with any interface across all OSPF areas.')
ospfTmrsKckOffHello = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 1, 4, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfTmrsKckOffHello.setStatus('current')
if mibBuilder.loadTexts: ospfTmrsKckOffHello.setDescription('The sum total number of times the Hello timer has been fired (which triggers the send of a Hello packet) across all OPSF areas and interfaces.')
ospfTmrsKckOffRetransmit = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 1, 4, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfTmrsKckOffRetransmit.setStatus('current')
if mibBuilder.loadTexts: ospfTmrsKckOffRetransmit.setDescription('The sum total number of times the Retransmit timer has been fired across all OPSF areas and interfaces.')
ospfTmrsKckOffLsaLock = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 1, 4, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfTmrsKckOffLsaLock.setStatus('current')
if mibBuilder.loadTexts: ospfTmrsKckOffLsaLock.setDescription('The sum total number of times the Lsa Lock timer has been fired across all OSPF areas and interfaces.')
ospfTmrsKckOffLsaAck = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 1, 4, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfTmrsKckOffLsaAck.setStatus('current')
if mibBuilder.loadTexts: ospfTmrsKckOffLsaAck.setDescription('The sum total number of times the Lsa Ack timer has been fired across all ospf areas and interfaces.')
ospfTmrsKckOffDbage = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 1, 4, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfTmrsKckOffDbage.setStatus('current')
if mibBuilder.loadTexts: ospfTmrsKckOffDbage.setDescription('The total number of times the Dbage has been fired.')
ospfTmrsKckOffSummary = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 1, 4, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfTmrsKckOffSummary.setStatus('current')
if mibBuilder.loadTexts: ospfTmrsKckOffSummary.setDescription('The total number of times the Summary timer has been fired.')
ospfTmrsKckOffAseExport = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 6, 1, 4, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfTmrsKckOffAseExport.setStatus('current')
if mibBuilder.loadTexts: ospfTmrsKckOffAseExport.setDescription('The total number of times the ASE Export timer has been fired.')
igmpSnoopStats = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 9, 1), )
if mibBuilder.loadTexts: igmpSnoopStats.setStatus('current')
if mibBuilder.loadTexts: igmpSnoopStats.setDescription('Statistics for IGMP Snooping.')
igmpSnoopStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 9, 1, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "igmpSnoopVlanIndex"))
if mibBuilder.loadTexts: igmpSnoopStatsEntry.setStatus('current')
if mibBuilder.loadTexts: igmpSnoopStatsEntry.setDescription('Statistics for IGMP Snooping.')
igmpSnoopVlanIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 9, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpSnoopVlanIndex.setStatus('current')
if mibBuilder.loadTexts: igmpSnoopVlanIndex.setDescription('The index of the VLAN for which these statistics apply.')
rxIgmpValidPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 9, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxIgmpValidPkts.setStatus('current')
if mibBuilder.loadTexts: rxIgmpValidPkts.setDescription('The total number of valid IGMP packets received on this VLAN.')
rxIgmpInvalidPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 9, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxIgmpInvalidPkts.setStatus('current')
if mibBuilder.loadTexts: rxIgmpInvalidPkts.setDescription('The total number of invalid IGMP packets received on this VLAN.')
rxIgmpGenQueries = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 9, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxIgmpGenQueries.setStatus('current')
if mibBuilder.loadTexts: rxIgmpGenQueries.setDescription('The total number of IGMP General Query packets received on this VLAN.')
rxIgmpGrpSpecificQueries = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 9, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxIgmpGrpSpecificQueries.setStatus('current')
if mibBuilder.loadTexts: rxIgmpGrpSpecificQueries.setDescription('The total number of IGMP Group Specific Query packets received on this VLAN.')
rxIgmpLeaves = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 9, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxIgmpLeaves.setStatus('current')
if mibBuilder.loadTexts: rxIgmpLeaves.setDescription('The total number of IGMP Leave packets received on this VLAN.')
rxIgmpReports = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 9, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxIgmpReports.setStatus('current')
if mibBuilder.loadTexts: rxIgmpReports.setDescription('The total number of IGMP Report packets received on this VLAN.')
txIgmpGrpSpecificQueries = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 9, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txIgmpGrpSpecificQueries.setStatus('current')
if mibBuilder.loadTexts: txIgmpGrpSpecificQueries.setDescription('The total number of IGMP Group Specific Query packets transmitted on this VLAN.')
txIgmpReports = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 9, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txIgmpReports.setStatus('current')
if mibBuilder.loadTexts: txIgmpReports.setDescription('The total number of IGMP Report packets transmitted on this VLAN.')
txIgmpLeaves = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 9, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txIgmpLeaves.setStatus('current')
if mibBuilder.loadTexts: txIgmpLeaves.setDescription('The total number of IGMP Leave packets transmitted on this VLAN.')
rxIgmpGroupSourceSpecificQueries = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 9, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxIgmpGroupSourceSpecificQueries.setStatus('current')
if mibBuilder.loadTexts: rxIgmpGroupSourceSpecificQueries.setDescription('The total number of IGMP Group Source Specific (GSSQ) Queries received on this VLAN.')
rxIgmpV3CurrentStateRecords = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 9, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxIgmpV3CurrentStateRecords.setStatus('current')
if mibBuilder.loadTexts: rxIgmpV3CurrentStateRecords.setDescription('The total number of IGMP Current State Records (CSRs) received on this VLAN.')
rxIgmpV3SourceListChangeRecords = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 9, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxIgmpV3SourceListChangeRecords.setStatus('current')
if mibBuilder.loadTexts: rxIgmpV3SourceListChangeRecords.setDescription('The total number of IGMP Source List Change Records (SLCRs) received on this VLAN.')
rxIgmpV3FilterChangeRecords = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 9, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxIgmpV3FilterChangeRecords.setStatus('current')
if mibBuilder.loadTexts: rxIgmpV3FilterChangeRecords.setDescription('The total number of IGMP Filter Mode Change Records (FMCRs) received on this VLAN.')
txIgmpGenQueries = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 9, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txIgmpGenQueries.setStatus('current')
if mibBuilder.loadTexts: txIgmpGenQueries.setDescription('The total number of IGMP General Query packets send on this VLAN.')
rxIgmpDiscardPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 9, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxIgmpDiscardPkts.setStatus('current')
if mibBuilder.loadTexts: rxIgmpDiscardPkts.setDescription('The total number of IGMP packets discarded on this VLAN.')
rxIgmpPimHellos = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 9, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxIgmpPimHellos.setStatus('current')
if mibBuilder.loadTexts: rxIgmpPimHellos.setDescription('The total number of Pim Hello packets received on this VLAN.')
igmpClearVlanStats = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 9, 1, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clear", 1), ("ok", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igmpClearVlanStats.setStatus('current')
if mibBuilder.loadTexts: igmpClearVlanStats.setDescription('Setting this to clear(1) results in clearing the statistics for this snooping VLAN.')
igmpClearAllStats = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 9, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clear", 1), ("ok", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igmpClearAllStats.setStatus('current')
if mibBuilder.loadTexts: igmpClearAllStats.setDescription('Setting this to clear(1) results in clearing the IGMP statistics.')
igmpStatsTotalIgmpGroups = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 9, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpStatsTotalIgmpGroups.setStatus('current')
if mibBuilder.loadTexts: igmpStatsTotalIgmpGroups.setDescription('The total number of IGMP groups.')
igmpStatsTotalIpmcGroups = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 9, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpStatsTotalIpmcGroups.setStatus('current')
if mibBuilder.loadTexts: igmpStatsTotalIpmcGroups.setDescription('The total number of IPMC groups.')
ipv6InReceives = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 10, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6InReceives.setStatus('current')
if mibBuilder.loadTexts: ipv6InReceives.setDescription('The total number of input datagrams received from interfaces, including those received in error.')
ipv6InMcasts = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 10, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6InMcasts.setStatus('current')
if mibBuilder.loadTexts: ipv6InMcasts.setDescription('The total number of multicast packets received from interfaces, including those received in error.')
ipv6InDelivers = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 10, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6InDelivers.setStatus('current')
if mibBuilder.loadTexts: ipv6InDelivers.setDescription('Total datagrams given to upper layer - ICMP/UDP')
ipv6InDiscards = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 10, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6InDiscards.setStatus('current')
if mibBuilder.loadTexts: ipv6InDiscards.setDescription('Total datagrams discarded despite no errors')
ipv6InHdrerrs = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 10, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6InHdrerrs.setStatus('current')
if mibBuilder.loadTexts: ipv6InHdrerrs.setDescription('Total datagrams with error in IPv6/Option headers')
ipv6InAddrerrs = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 10, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6InAddrerrs.setStatus('current')
if mibBuilder.loadTexts: ipv6InAddrerrs.setDescription('Total datagrams with error in destination address')
ipv6InUnkprots = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 10, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6InUnkprots.setStatus('current')
if mibBuilder.loadTexts: ipv6InUnkprots.setDescription('Total datagrams with unknown/unsupported protocol')
ipv6InTruncs = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 10, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6InTruncs.setStatus('current')
if mibBuilder.loadTexts: ipv6InTruncs.setDescription('Total datagrams with insufficient data')
ipv6OutMcasts = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 10, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6OutMcasts.setStatus('current')
if mibBuilder.loadTexts: ipv6OutMcasts.setDescription('Total sent multicast pkts')
ipv6ForwDgrams = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 10, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6ForwDgrams.setStatus('current')
if mibBuilder.loadTexts: ipv6ForwDgrams.setDescription('Total datagrams attempted to be forwarded')
ipv6TooBigerrs = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 10, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6TooBigerrs.setStatus('current')
if mibBuilder.loadTexts: ipv6TooBigerrs.setDescription('Total datagrams which could not be forwarded as their size exceeds (Path) MTU')
ipv6OutReqs = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 10, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6OutReqs.setStatus('current')
if mibBuilder.loadTexts: ipv6OutReqs.setDescription('Total datagrams attempted to be sent')
ipv6OutDiscards = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 10, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6OutDiscards.setStatus('current')
if mibBuilder.loadTexts: ipv6OutDiscards.setDescription('Total outgoing Datagrams discarded despite no errors')
ipv6OutNorts = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 10, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6OutNorts.setStatus('current')
if mibBuilder.loadTexts: ipv6OutNorts.setDescription('Total datagrams discarded due to no routes')
ipv6Reasmreqs = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 10, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6Reasmreqs.setStatus('current')
if mibBuilder.loadTexts: ipv6Reasmreqs.setDescription('Total datagrams needing reassembly')
ipv6Reasmoks = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 10, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6Reasmoks.setStatus('current')
if mibBuilder.loadTexts: ipv6Reasmoks.setDescription('Total datagrams successfully reassembled')
ipv6Reasmfails = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 10, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6Reasmfails.setStatus('current')
if mibBuilder.loadTexts: ipv6Reasmfails.setDescription('Total datagrams for witch reassembly failured')
ipv6Fragoks = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 10, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6Fragoks.setStatus('current')
if mibBuilder.loadTexts: ipv6Fragoks.setDescription('Total datagrams successfully fragmented')
ipv6Fragfails = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 10, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6Fragfails.setStatus('current')
if mibBuilder.loadTexts: ipv6Fragfails.setDescription('Total datagrams for witch fragmentation failured')
ipv6Fragcreates = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 10, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6Fragcreates.setStatus('current')
if mibBuilder.loadTexts: ipv6Fragcreates.setDescription('Total number of fragments created')
ipv6InNsols = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 10, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6InNsols.setStatus('current')
if mibBuilder.loadTexts: ipv6InNsols.setDescription('Total number of received Neighbor Solicitations')
ipv6InNadvs = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 10, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6InNadvs.setStatus('current')
if mibBuilder.loadTexts: ipv6InNadvs.setDescription('Total number of received Neighbor Advertisements')
ipv6InRoutsols = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 10, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6InRoutsols.setStatus('current')
if mibBuilder.loadTexts: ipv6InRoutsols.setDescription('Total number of received Router Solicitations')
ipv6InRoutadvs = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 10, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6InRoutadvs.setStatus('current')
if mibBuilder.loadTexts: ipv6InRoutadvs.setDescription('Total number of received Router Advertisements')
ipv6InRoutRedirs = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 10, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6InRoutRedirs.setStatus('current')
if mibBuilder.loadTexts: ipv6InRoutRedirs.setDescription('Total number of received Router Redirect messages')
ipv6OutNsols = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 10, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6OutNsols.setStatus('current')
if mibBuilder.loadTexts: ipv6OutNsols.setDescription('Total number of sent Neighbor Solicitations')
ipv6OutNadvs = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 10, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6OutNadvs.setStatus('current')
if mibBuilder.loadTexts: ipv6OutNadvs.setDescription('Total number of sent Neighbor Advertisements')
ipv6OutRoutadvs = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 10, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6OutRoutadvs.setStatus('current')
if mibBuilder.loadTexts: ipv6OutRoutadvs.setDescription('Total number of sent Router Advertisements')
ipv6OutRedirs = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 10, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6OutRedirs.setStatus('current')
if mibBuilder.loadTexts: ipv6OutRedirs.setDescription('Total number of sent Redirects')
ipv6OutRoutSols = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 10, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6OutRoutSols.setStatus('current')
if mibBuilder.loadTexts: ipv6OutRoutSols.setDescription('Total number of sent Router Solicitations')
ipv6icmpInMsgs = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 10, 39), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6icmpInMsgs.setStatus('current')
if mibBuilder.loadTexts: ipv6icmpInMsgs.setDescription('The total number of ICMP messages received.')
ipv6icmpInErrs = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 10, 40), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6icmpInErrs.setStatus('current')
if mibBuilder.loadTexts: ipv6icmpInErrs.setDescription('The total number of ICMP messages attempted to send.')
ipv6icmpInBadcode = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 10, 41), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6icmpInBadcode.setStatus('current')
if mibBuilder.loadTexts: ipv6icmpInBadcode.setDescription('The total number of ICMP messages in bad code.')
ipv6icmpInToobig = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 10, 42), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6icmpInToobig.setStatus('current')
if mibBuilder.loadTexts: ipv6icmpInToobig.setDescription('The number of ICMP too big messages received.')
ipv6icmpInDstUnreach = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 10, 43), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6icmpInDstUnreach.setStatus('current')
if mibBuilder.loadTexts: ipv6icmpInDstUnreach.setDescription('The number of ICMP Destination Unreachable messages received.')
ipv6icmpInTmexceeded = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 10, 44), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6icmpInTmexceeded.setStatus('current')
if mibBuilder.loadTexts: ipv6icmpInTmexceeded.setDescription('The number of ICMP Time Exceeded messages received.')
ipv6icmpInParamprob = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 10, 45), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6icmpInParamprob.setStatus('current')
if mibBuilder.loadTexts: ipv6icmpInParamprob.setDescription('The number of ICMP Parameter Problem messages received.')
ipv6icmpInEchoReq = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 10, 46), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6icmpInEchoReq.setStatus('current')
if mibBuilder.loadTexts: ipv6icmpInEchoReq.setDescription('The number of ICMP Echo request messages received.')
ipv6icmpInEchoResp = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 10, 47), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6icmpInEchoResp.setStatus('current')
if mibBuilder.loadTexts: ipv6icmpInEchoResp.setDescription('The number of ICMP Echo Reply messages received.')
ipv6icmpOutMsgs = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 10, 48), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6icmpOutMsgs.setStatus('current')
if mibBuilder.loadTexts: ipv6icmpOutMsgs.setDescription('The total number of ICMP messages which this entity attempted to send.')
ipv6icmpOutErrs = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 10, 49), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6icmpOutErrs.setStatus('current')
if mibBuilder.loadTexts: ipv6icmpOutErrs.setDescription('The number of ICMP messages which this entity did not send due to problems discovered within ICMP such as a lack of buffers.')
ipv6icmpOutDstUnreach = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 10, 50), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6icmpOutDstUnreach.setStatus('current')
if mibBuilder.loadTexts: ipv6icmpOutDstUnreach.setDescription('The number of ICMP Destination Unreachable messages sent.')
ipv6icmpOutToobig = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 10, 51), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6icmpOutToobig.setStatus('current')
if mibBuilder.loadTexts: ipv6icmpOutToobig.setDescription('The number of ICMP too big messages sent.')
ipv6icmpOutTmexceeded = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 10, 52), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6icmpOutTmexceeded.setStatus('current')
if mibBuilder.loadTexts: ipv6icmpOutTmexceeded.setDescription('The number of ICMP Time Exceeded messages sent.')
ipv6icmpOutParamprob = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 10, 53), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6icmpOutParamprob.setStatus('current')
if mibBuilder.loadTexts: ipv6icmpOutParamprob.setDescription('The number of ICMP Parameter Problem messages sent.')
ipv6icmpOutEchoReq = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 10, 54), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6icmpOutEchoReq.setStatus('current')
if mibBuilder.loadTexts: ipv6icmpOutEchoReq.setDescription('The number of ICMP Echo request messages sent.')
ipv6icmpOutEchoResp = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 10, 55), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6icmpOutEchoResp.setStatus('current')
if mibBuilder.loadTexts: ipv6icmpOutEchoResp.setDescription('The number of ICMP Echo Reply messages sent.')
ipv6icmpInRouterSol = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 10, 56), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6icmpInRouterSol.setStatus('current')
if mibBuilder.loadTexts: ipv6icmpInRouterSol.setDescription('The number of ICMP router solicitations received.')
ipv6icmpInRouterAdv = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 10, 57), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6icmpInRouterAdv.setStatus('current')
if mibBuilder.loadTexts: ipv6icmpInRouterAdv.setDescription('The number of ICMP router advertisements received.')
ipv6icmpInNeighSol = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 10, 58), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6icmpInNeighSol.setStatus('current')
if mibBuilder.loadTexts: ipv6icmpInNeighSol.setDescription('The number of ICMP neighbor solicitations received.')
ipv6icmpInNeighAdv = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 10, 59), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6icmpInNeighAdv.setStatus('current')
if mibBuilder.loadTexts: ipv6icmpInNeighAdv.setDescription('The number of ICMP neighbor advertisements received.')
ipv6icmpInRedir = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 10, 60), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6icmpInRedir.setStatus('current')
if mibBuilder.loadTexts: ipv6icmpInRedir.setDescription('The number of ICMP Redirect messages received.')
ipv6icmpOutRouterSol = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 10, 61), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6icmpOutRouterSol.setStatus('current')
if mibBuilder.loadTexts: ipv6icmpOutRouterSol.setDescription('The number of ICMP router solicitations sent.')
ipv6icmpOutRouterAdv = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 10, 62), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6icmpOutRouterAdv.setStatus('current')
if mibBuilder.loadTexts: ipv6icmpOutRouterAdv.setDescription('The number of ICMP router advertisements sent.')
ipv6icmpOutNeighSol = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 10, 63), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6icmpOutNeighSol.setStatus('current')
if mibBuilder.loadTexts: ipv6icmpOutNeighSol.setDescription('The number of ICMP neighbor solicitations sent.')
ipv6icmpOutNeighAdv = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 10, 64), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6icmpOutNeighAdv.setStatus('current')
if mibBuilder.loadTexts: ipv6icmpOutNeighAdv.setDescription('The number of ICMP neighbor advertisements sent.')
ipv6icmpOutRedir = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 10, 65), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6icmpOutRedir.setStatus('current')
if mibBuilder.loadTexts: ipv6icmpOutRedir.setDescription('The number of ICMP Redirect messages sent.')
ipv6udpInDgrams = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 10, 66), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6udpInDgrams.setStatus('current')
if mibBuilder.loadTexts: ipv6udpInDgrams.setDescription('Total number of UDP received datagrams.')
ipv6udpInErrs = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 10, 67), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6udpInErrs.setStatus('current')
if mibBuilder.loadTexts: ipv6udpInErrs.setDescription('Total number of UDP error encountered during processing of packet.')
ipv6udpOutDgrams = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 10, 68), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6udpOutDgrams.setStatus('current')
if mibBuilder.loadTexts: ipv6udpOutDgrams.setDescription('Total number of UDP datagrams passed to IP6 layer.')
ipv6udpNumPorts = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 10, 69), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6udpNumPorts.setStatus('current')
if mibBuilder.loadTexts: ipv6udpNumPorts.setDescription('Total number of UDP ports that are currently open.')
ipv6icmpInAdminProhib = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 10, 70), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6icmpInAdminProhib.setStatus('current')
if mibBuilder.loadTexts: ipv6icmpInAdminProhib.setDescription('The total number of received Destination Unreachable ICMP packets.')
ipv6icmpOutAdminProhib = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 10, 71), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6icmpOutAdminProhib.setStatus('current')
if mibBuilder.loadTexts: ipv6icmpOutAdminProhib.setDescription('The total number of sent Destination Unreachable ICMP packets.')
ospf3GeneralStats = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 1))
ospf3CumRxTxDisdStats = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 1, 1))
ospf3CumNbrChangeStats = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 1, 2))
ospf3CumIntfChangeStats = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 1, 3))
ospf3TimersKickOffStats = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 1, 4))
ospf3Area = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 2))
ospf3AreaRxTxDisdStats = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 2, 1), )
if mibBuilder.loadTexts: ospf3AreaRxTxDisdStats.setStatus('current')
if mibBuilder.loadTexts: ospf3AreaRxTxDisdStats.setDescription('The table of Ospf3 Area Rx/Tx Statistics.')
ospf3AreaRxTxDisdStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 2, 1, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ospf3AreaRxTxDisdIndex"))
if mibBuilder.loadTexts: ospf3AreaRxTxDisdStatsEntry.setStatus('current')
if mibBuilder.loadTexts: ospf3AreaRxTxDisdStatsEntry.setDescription('Rx Tx packet Statistics about a Ospf3 area.')
ospf3AreaRxTxDisdIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3AreaRxTxDisdIndex.setStatus('current')
if mibBuilder.loadTexts: ospf3AreaRxTxDisdIndex.setDescription('The index of the ospf3 Area for which these statistics apply.')
ospf3AreaRxPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 2, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3AreaRxPkts.setStatus('current')
if mibBuilder.loadTexts: ospf3AreaRxPkts.setDescription('The total number of Ospf3 packets received in this Ospf3 area.')
ospf3AreaTxPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 2, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3AreaTxPkts.setStatus('current')
if mibBuilder.loadTexts: ospf3AreaTxPkts.setDescription('The total number of Ospf3 packets transmitted in this Ospf3 area.')
ospf3AreaDisdPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 2, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3AreaDisdPkts.setStatus('current')
if mibBuilder.loadTexts: ospf3AreaDisdPkts.setDescription('The total number of Ospf3 packets discaded in this Ospf3 area.')
ospf3AreaRxHello = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 2, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3AreaRxHello.setStatus('current')
if mibBuilder.loadTexts: ospf3AreaRxHello.setDescription('The total number of Hello packets received in this Ospf3 area.')
ospf3AreaTxHello = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 2, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3AreaTxHello.setStatus('current')
if mibBuilder.loadTexts: ospf3AreaTxHello.setDescription('The total number of Hello packets transmitted in this Ospf3 area.')
ospf3AreaDisdHello = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 2, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3AreaDisdHello.setStatus('current')
if mibBuilder.loadTexts: ospf3AreaDisdHello.setDescription('The total number of Hello packets discaded in this Ospf3 area.')
ospf3AreaRxDatabase = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 2, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3AreaRxDatabase.setStatus('current')
if mibBuilder.loadTexts: ospf3AreaRxDatabase.setDescription('The total number of Database Description packets transmitted for this Ospf3 area.')
ospf3AreaTxDatabase = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 2, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3AreaTxDatabase.setStatus('current')
if mibBuilder.loadTexts: ospf3AreaTxDatabase.setDescription('The total number of Database Description packets transmitted for this Ospf3 area.')
ospf3AreaDisdDatabase = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 2, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3AreaDisdDatabase.setStatus('current')
if mibBuilder.loadTexts: ospf3AreaDisdDatabase.setDescription('The total number of Database Description packets discarded for this Ospf3 area.')
ospf3AreaRxlsReqs = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 2, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3AreaRxlsReqs.setStatus('current')
if mibBuilder.loadTexts: ospf3AreaRxlsReqs.setDescription('The total number of Link State Request packets received for this Ospf3 area.')
ospf3AreaTxlsReqs = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 2, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3AreaTxlsReqs.setStatus('current')
if mibBuilder.loadTexts: ospf3AreaTxlsReqs.setDescription('The total number of Link State Request packets transmitted for this Ospf3 area.')
ospf3AreaDisdlsReqs = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 2, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3AreaDisdlsReqs.setStatus('current')
if mibBuilder.loadTexts: ospf3AreaDisdlsReqs.setDescription('The total number of Link State Request packets discarded for this Ospf3 area.')
ospf3AreaRxlsAcks = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 2, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3AreaRxlsAcks.setStatus('current')
if mibBuilder.loadTexts: ospf3AreaRxlsAcks.setDescription('The total number of Link State Acknowledgement packets received for this Ospf3 area.')
ospf3AreaTxlsAcks = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 2, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3AreaTxlsAcks.setStatus('current')
if mibBuilder.loadTexts: ospf3AreaTxlsAcks.setDescription('The total number of Link State Acknowledgement packets transmitted for this Ospf3 area.')
ospf3AreaDisdlsAcks = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 2, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3AreaDisdlsAcks.setStatus('current')
if mibBuilder.loadTexts: ospf3AreaDisdlsAcks.setDescription('The total number of Link State Acknowledgement packets discarded for this Ospf3 area.')
ospf3AreaRxlsUpdates = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 2, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3AreaRxlsUpdates.setStatus('current')
if mibBuilder.loadTexts: ospf3AreaRxlsUpdates.setDescription('The total number of Link State Update packets received for this Ospf3 area.')
ospf3AreaTxlsUpdates = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 2, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3AreaTxlsUpdates.setStatus('current')
if mibBuilder.loadTexts: ospf3AreaTxlsUpdates.setDescription('The total number of Link State Update packets transmitted for this Ospf3 area.')
ospf3AreaDisdlsUpdates = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 2, 1, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3AreaDisdlsUpdates.setStatus('current')
if mibBuilder.loadTexts: ospf3AreaDisdlsUpdates.setDescription('The total number of Link State Update packets discarded for this Ospf3 area.')
ospf3AreaNbrChangeStats = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 2, 2), )
if mibBuilder.loadTexts: ospf3AreaNbrChangeStats.setStatus('current')
if mibBuilder.loadTexts: ospf3AreaNbrChangeStats.setDescription('The table of Ospf3 Neighbor change Statistics.')
ospf3AreaNbrChangeStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 2, 2, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ospf3AreaNbrIndex"))
if mibBuilder.loadTexts: ospf3AreaNbrChangeStatsEntry.setStatus('current')
if mibBuilder.loadTexts: ospf3AreaNbrChangeStatsEntry.setDescription('Ospf3 Neighbor Change statistics.')
ospf3AreaNbrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 2, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3AreaNbrIndex.setStatus('current')
if mibBuilder.loadTexts: ospf3AreaNbrIndex.setDescription('The index of the Ospf3 Area for which these statistics apply.')
ospf3AreaNbrDown = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 2, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3AreaNbrDown.setStatus('current')
if mibBuilder.loadTexts: ospf3AreaNbrDown.setDescription('The total number of times neighbors now existing on this area have changed into DOWN state.')
ospf3AreaNbrAttempt = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 2, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3AreaNbrAttempt.setStatus('current')
if mibBuilder.loadTexts: ospf3AreaNbrAttempt.setDescription('The total number of times neighbors now existing on this area have changed into ATTEMPT state.')
ospf3AreaNbrInit = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 2, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3AreaNbrInit.setStatus('current')
if mibBuilder.loadTexts: ospf3AreaNbrInit.setDescription('The total number of times neighbors now existing on this area have changed into INIT state.')
ospf3AreaNbrN2way = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 2, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3AreaNbrN2way.setStatus('current')
if mibBuilder.loadTexts: ospf3AreaNbrN2way.setDescription('The total number of times neighbors now existing on this area have changed into 2WAY state.')
ospf3AreaNbrExStart = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 2, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3AreaNbrExStart.setStatus('current')
if mibBuilder.loadTexts: ospf3AreaNbrExStart.setDescription('The total number of times neighbors now existing on this area have changed into EXSTART state.')
ospf3AreaNbrExchange = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 2, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3AreaNbrExchange.setStatus('current')
if mibBuilder.loadTexts: ospf3AreaNbrExchange.setDescription('The total number of times neighbors now existing on this area have changed into EXCHANGE state.')
ospf3AreaNbrLoading = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 2, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3AreaNbrLoading.setStatus('current')
if mibBuilder.loadTexts: ospf3AreaNbrLoading.setDescription('The total number of times neighbors now existing on this area have changed into LOADING state.')
ospf3AreaNbrFull = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 2, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3AreaNbrFull.setStatus('current')
if mibBuilder.loadTexts: ospf3AreaNbrFull.setDescription('The total number of times neighbors now existing on this area have changed into FULL state.')
ospf3AreaNbrAllEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 2, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3AreaNbrAllEvents.setStatus('current')
if mibBuilder.loadTexts: ospf3AreaNbrAllEvents.setDescription('The total number of times neighbors now existing on this area have changed state or an error had occured.')
ospf3AreaIntfChangeStats = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 2, 3), )
if mibBuilder.loadTexts: ospf3AreaIntfChangeStats.setStatus('current')
if mibBuilder.loadTexts: ospf3AreaIntfChangeStats.setDescription('The table of Ospf3 Interface change Statistics.')
ospf3AreaIntfChangeStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 2, 3, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ospf3AreaIntfIndex"))
if mibBuilder.loadTexts: ospf3AreaIntfChangeStatsEntry.setStatus('current')
if mibBuilder.loadTexts: ospf3AreaIntfChangeStatsEntry.setDescription('Ospf3 interface Change statistics.')
ospf3AreaIntfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 2, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3AreaIntfIndex.setStatus('current')
if mibBuilder.loadTexts: ospf3AreaIntfIndex.setDescription('The index of the Ospf3 Interface for which these statistics apply.')
ospf3AreaIntfDown = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 2, 3, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3AreaIntfDown.setStatus('current')
if mibBuilder.loadTexts: ospf3AreaIntfDown.setDescription('The total number of changes into the DOWN State of the interfaces associated with this OSPF area.')
ospf3AreaIntfLoop = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 2, 3, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3AreaIntfLoop.setStatus('current')
if mibBuilder.loadTexts: ospf3AreaIntfLoop.setDescription('The total number of changes into the LOOP State of the interfaces associated with this OSPF area.')
ospf3AreaIntfWaiting = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 2, 3, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3AreaIntfWaiting.setStatus('current')
if mibBuilder.loadTexts: ospf3AreaIntfWaiting.setDescription('The total number of changes into the WAITING State of the interfaces associated with this OSPF area.')
ospf3AreaIntfPtop = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 2, 3, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3AreaIntfPtop.setStatus('current')
if mibBuilder.loadTexts: ospf3AreaIntfPtop.setDescription('The total number of changes into the PTOP State of the interfaces associated with this OSPF area.')
ospf3AreaIntfDr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 2, 3, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3AreaIntfDr.setStatus('current')
if mibBuilder.loadTexts: ospf3AreaIntfDr.setDescription('The total number of changes into the DR State of the interfaces associated with this OSPF area.')
ospf3AreaIntfBackup = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 2, 3, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3AreaIntfBackup.setStatus('current')
if mibBuilder.loadTexts: ospf3AreaIntfBackup.setDescription('The total number of changes into the BACKUP State of the interfaces associated with this OSPF area.')
ospf3AreaIntfDrOther = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 2, 3, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3AreaIntfDrOther.setStatus('current')
if mibBuilder.loadTexts: ospf3AreaIntfDrOther.setDescription('The total number of changes into the DROTHER State of the interfaces associated with this OSPF area.')
ospf3AreaIntfAllEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 2, 3, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3AreaIntfAllEvents.setStatus('current')
if mibBuilder.loadTexts: ospf3AreaIntfAllEvents.setDescription('The total number of State changes of the interfaces associated with this OSPF area')
ospf3AreaErrorStats = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 2, 4), )
if mibBuilder.loadTexts: ospf3AreaErrorStats.setStatus('current')
if mibBuilder.loadTexts: ospf3AreaErrorStats.setDescription('The table of Ospf3 Interface Error Statistics.')
ospf3AreaErrorStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 2, 4, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ospf3AreaErrIndex"))
if mibBuilder.loadTexts: ospf3AreaErrorStatsEntry.setStatus('current')
if mibBuilder.loadTexts: ospf3AreaErrorStatsEntry.setDescription('Error Statistics for an Ospf3 area.')
ospf3AreaErrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 2, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3AreaErrIndex.setStatus('current')
if mibBuilder.loadTexts: ospf3AreaErrIndex.setDescription('The index of the Ospf3 Area for which these statistics apply.')
ospf3AreaErrRxOnPasv = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 2, 4, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3AreaErrRxOnPasv.setStatus('current')
if mibBuilder.loadTexts: ospf3AreaErrRxOnPasv.setDescription('The total number of packets received by all of the interfaces in this area that are received on a passive interface.')
ospf3AreaErrRxOspfOff = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 2, 4, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3AreaErrRxOspfOff.setStatus('current')
if mibBuilder.loadTexts: ospf3AreaErrRxOspfOff.setDescription('The total number of packets received by all of the interfaces in this area that are received while OSPF was disabled.')
ospf3AreaErrRxOnNotup = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 2, 4, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3AreaErrRxOnNotup.setStatus('current')
if mibBuilder.loadTexts: ospf3AreaErrRxOnNotup.setDescription('The total number of packets received by all of the interfaces in this area that are received while the interface was disabled.')
ospf3AreaErrRxVerMismatch = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 2, 4, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3AreaErrRxVerMismatch.setStatus('current')
if mibBuilder.loadTexts: ospf3AreaErrRxVerMismatch.setDescription('The total number of packets received by all of the interfaces in this area that have an OSPF version number not equal to the one of the interface.')
ospf3AreaErrRxZeroRTRID = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 2, 4, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3AreaErrRxZeroRTRID.setStatus('current')
if mibBuilder.loadTexts: ospf3AreaErrRxZeroRTRID.setDescription('The total number of packets received by all of the interfaces in this area that have a RouterID of 0.')
ospf3AreaErrRxSameRTRID = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 2, 4, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3AreaErrRxSameRTRID.setStatus('current')
if mibBuilder.loadTexts: ospf3AreaErrRxSameRTRID.setDescription('The total number of packets received by all of the interfaces in this area that have the same RouterID as this Router.')
ospf3AreaErrRxMismatchInstID = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 2, 4, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3AreaErrRxMismatchInstID.setStatus('current')
if mibBuilder.loadTexts: ospf3AreaErrRxMismatchInstID.setDescription('The total number of packets received by all of the interfaces in this area that have an instance number not equal to the one of the interface.')
ospf3AreaErrBadAreaID = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 2, 4, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3AreaErrBadAreaID.setStatus('current')
if mibBuilder.loadTexts: ospf3AreaErrBadAreaID.setDescription('The total number of packets received by all of the interfaces in this area that have an area number not equal to the one of the area of the interface.')
ospf3AreaErrBadDestAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 2, 4, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3AreaErrBadDestAddr.setStatus('current')
if mibBuilder.loadTexts: ospf3AreaErrBadDestAddr.setDescription('The total number of packets discarded by all of the interfaces in this area because of a destination address mismatch.')
ospf3AreaErrBadChecksum = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 2, 4, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3AreaErrBadChecksum.setStatus('current')
if mibBuilder.loadTexts: ospf3AreaErrBadChecksum.setDescription('The total number of packets discarded by all of the interfaces in this area because of a bad checksum.')
ospf3AreaErrBadNeighbour = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 2, 4, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3AreaErrBadNeighbour.setStatus('current')
if mibBuilder.loadTexts: ospf3AreaErrBadNeighbour.setDescription('The total number of packets discarded by all of the interfaces in this area because they could not be associated with any neighbor.')
ospf3AreaErrBadPktType = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 2, 4, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3AreaErrBadPktType.setStatus('current')
if mibBuilder.loadTexts: ospf3AreaErrBadPktType.setDescription('The total number of packets discarded by all of the interfaces in this area because the packet type was not recognized.')
ospf3AreaErrHelloMismatch = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 2, 4, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3AreaErrHelloMismatch.setStatus('current')
if mibBuilder.loadTexts: ospf3AreaErrHelloMismatch.setDescription('The total number of packets received with a different hello interval by all of the interfaces in this area .')
ospf3AreaErrOptionsMismatch = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 2, 4, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3AreaErrOptionsMismatch.setStatus('current')
if mibBuilder.loadTexts: ospf3AreaErrOptionsMismatch.setDescription('The total number of packets received with a different options by all of the interfaces in this area .')
ospf3AreaErrDeadMismatch = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 2, 4, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3AreaErrDeadMismatch.setStatus('current')
if mibBuilder.loadTexts: ospf3AreaErrDeadMismatch.setDescription('The total number of packets received with a different dead interval in this area.')
ospf3AreaErrHelloNoNbr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 2, 4, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3AreaErrHelloNoNbr.setStatus('current')
if mibBuilder.loadTexts: ospf3AreaErrHelloNoNbr.setDescription('The total number of packets received from an unknown neighbor when all of the interfaces in this area has a Network Type of NBMA or PTOMP.')
ospf3Interface = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 3))
ospf3IntfRxTxDisdStats = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 3, 1), )
if mibBuilder.loadTexts: ospf3IntfRxTxDisdStats.setStatus('current')
if mibBuilder.loadTexts: ospf3IntfRxTxDisdStats.setDescription('The table of Ospf3 Intf Rx/Tx Statistics.')
ospf3IntfRxTxDisdStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 3, 1, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ospf3IntfRxTxDisdIndex"))
if mibBuilder.loadTexts: ospf3IntfRxTxDisdStatsEntry.setStatus('current')
if mibBuilder.loadTexts: ospf3IntfRxTxDisdStatsEntry.setDescription('Rx Tx packet Statistics about a Ospf3 area.')
ospf3IntfRxTxDisdIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IntfRxTxDisdIndex.setStatus('current')
if mibBuilder.loadTexts: ospf3IntfRxTxDisdIndex.setDescription('The index of the ospf3 Intf for which these statistics apply.')
ospf3IntfRxPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 3, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IntfRxPkts.setStatus('current')
if mibBuilder.loadTexts: ospf3IntfRxPkts.setDescription('The total number of Ospf3 packets received on this Ospf3 interface.')
ospf3IntfTxPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 3, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IntfTxPkts.setStatus('current')
if mibBuilder.loadTexts: ospf3IntfTxPkts.setDescription('The total number of Ospf3 packets transmitted on this Ospf3 interface.')
ospf3IntfDisdPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 3, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IntfDisdPkts.setStatus('current')
if mibBuilder.loadTexts: ospf3IntfDisdPkts.setDescription('The total number of Ospf3 packets discaded on this Ospf3 interface.')
ospf3IntfRxHello = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 3, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IntfRxHello.setStatus('current')
if mibBuilder.loadTexts: ospf3IntfRxHello.setDescription('The total number of Hello packets received on this Ospf3 interface.')
ospf3IntfTxHello = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 3, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IntfTxHello.setStatus('current')
if mibBuilder.loadTexts: ospf3IntfTxHello.setDescription('The total number of Hello packets transmitted on this Ospf3 interface.')
ospf3IntfDisdHello = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 3, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IntfDisdHello.setStatus('current')
if mibBuilder.loadTexts: ospf3IntfDisdHello.setDescription('The total number of Hello packets discaded in this Ospf3 interface.')
ospf3IntfRxDatabase = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 3, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IntfRxDatabase.setStatus('current')
if mibBuilder.loadTexts: ospf3IntfRxDatabase.setDescription('The total number of Database Description packets transmitted for this Ospf3 interface.')
ospf3IntfTxDatabase = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 3, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IntfTxDatabase.setStatus('current')
if mibBuilder.loadTexts: ospf3IntfTxDatabase.setDescription('The total number of Database Description packets transmitted for this Ospf3 interface.')
ospf3IntfDisdDatabase = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 3, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IntfDisdDatabase.setStatus('current')
if mibBuilder.loadTexts: ospf3IntfDisdDatabase.setDescription('The total number of Database Description packets discarded for this Ospf3 interface.')
ospf3IntfRxlsReqs = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 3, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IntfRxlsReqs.setStatus('current')
if mibBuilder.loadTexts: ospf3IntfRxlsReqs.setDescription('The total number of Link State Request packets received for this Ospf3 interface.')
ospf3IntfTxlsReqs = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 3, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IntfTxlsReqs.setStatus('current')
if mibBuilder.loadTexts: ospf3IntfTxlsReqs.setDescription('The total number of Link State Request packets transmitted for this Ospf3 interface.')
ospf3IntfDisdlsReqs = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 3, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IntfDisdlsReqs.setStatus('current')
if mibBuilder.loadTexts: ospf3IntfDisdlsReqs.setDescription('The total number of Link State Request packets discarded for this Ospf3 interface.')
ospf3IntfRxlsAcks = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 3, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IntfRxlsAcks.setStatus('current')
if mibBuilder.loadTexts: ospf3IntfRxlsAcks.setDescription('The total number of Link State Acknowledgement packets received for this Ospf3 interface.')
ospf3IntfTxlsAcks = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 3, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IntfTxlsAcks.setStatus('current')
if mibBuilder.loadTexts: ospf3IntfTxlsAcks.setDescription('The total number of Link State Acknowledgement packets transmitted for this Ospf3 interface.')
ospf3IntfDisdlsAcks = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 3, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IntfDisdlsAcks.setStatus('current')
if mibBuilder.loadTexts: ospf3IntfDisdlsAcks.setDescription('The total number of Link State Acknowledgement packets discarded for this Ospf3 interface.')
ospf3IntfRxlsUpdates = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 3, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IntfRxlsUpdates.setStatus('current')
if mibBuilder.loadTexts: ospf3IntfRxlsUpdates.setDescription('The total number of Link State Update packets received for this Ospf3 interface.')
ospf3IntfTxlsUpdates = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 3, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IntfTxlsUpdates.setStatus('current')
if mibBuilder.loadTexts: ospf3IntfTxlsUpdates.setDescription('The total number of Link State Update packets transmitted for this Ospf3 interface.')
ospf3IntfDisdlsUpdates = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 3, 1, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IntfDisdlsUpdates.setStatus('current')
if mibBuilder.loadTexts: ospf3IntfDisdlsUpdates.setDescription('The total number of Link State Update packets discarded for this Ospf3 interface.')
ospf3IntfNbrChangeStats = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 3, 2), )
if mibBuilder.loadTexts: ospf3IntfNbrChangeStats.setStatus('current')
if mibBuilder.loadTexts: ospf3IntfNbrChangeStats.setDescription('The table of Ospf3 Interface Neighbour change Statistics.')
ospf3IntfNbrChangeStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 3, 2, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ospf3IntfNbrIndex"))
if mibBuilder.loadTexts: ospf3IntfNbrChangeStatsEntry.setStatus('current')
if mibBuilder.loadTexts: ospf3IntfNbrChangeStatsEntry.setDescription('Ospf3 interface Neighbour Change statistics.')
ospf3IntfNbrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 3, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IntfNbrIndex.setStatus('current')
if mibBuilder.loadTexts: ospf3IntfNbrIndex.setDescription('The index of the Ospf3 Interface for which these statistics apply.')
ospf3IntfNbrDown = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 3, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IntfNbrDown.setStatus('current')
if mibBuilder.loadTexts: ospf3IntfNbrDown.setDescription('The total number of times neighbors now existing on this interface have changed into DOWN state.')
ospf3IntfNbrAttempt = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 3, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IntfNbrAttempt.setStatus('current')
if mibBuilder.loadTexts: ospf3IntfNbrAttempt.setDescription('The total number of times neighbors now existing on this interface have changed into ATTEMPT state.')
ospf3IntfNbrInit = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 3, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IntfNbrInit.setStatus('current')
if mibBuilder.loadTexts: ospf3IntfNbrInit.setDescription('The total number of times neighbors now existing on this interface have changed into INIT state.')
ospf3IntfNbrN2way = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 3, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IntfNbrN2way.setStatus('current')
if mibBuilder.loadTexts: ospf3IntfNbrN2way.setDescription('The total number of times neighbors now existing on this interface have changed into 2WAY state.')
ospf3IntfNbrExStart = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 3, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IntfNbrExStart.setStatus('current')
if mibBuilder.loadTexts: ospf3IntfNbrExStart.setDescription('The total number of times neighbors now existing on this interface have changed into EXSTART state.')
ospf3IntfNbrExchange = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 3, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IntfNbrExchange.setStatus('current')
if mibBuilder.loadTexts: ospf3IntfNbrExchange.setDescription('The total number of times neighbors now existing on this interface have changed into EXCHANGE state.')
ospf3IntfNbrLoading = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 3, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IntfNbrLoading.setStatus('current')
if mibBuilder.loadTexts: ospf3IntfNbrLoading.setDescription('The total number of times neighbors now existing on this interface have changed into LOADING state.')
ospf3IntfNbrFull = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 3, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IntfNbrFull.setStatus('current')
if mibBuilder.loadTexts: ospf3IntfNbrFull.setDescription('The total number of times neighbors now existing on this interface have changed into FULL state.')
ospf3IntfNbrAllEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 3, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IntfNbrAllEvents.setStatus('current')
if mibBuilder.loadTexts: ospf3IntfNbrAllEvents.setDescription('The total number of times neighbors now existing on this interface have changed state or an error had occured.')
ospf3IntfChangeStats = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 3, 3), )
if mibBuilder.loadTexts: ospf3IntfChangeStats.setStatus('current')
if mibBuilder.loadTexts: ospf3IntfChangeStats.setDescription('The table of Ospf3 Interface change Statistics.')
ospf3IntfChangeStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 3, 3, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ospf3IntfIndex"))
if mibBuilder.loadTexts: ospf3IntfChangeStatsEntry.setStatus('current')
if mibBuilder.loadTexts: ospf3IntfChangeStatsEntry.setDescription('Ospf3 interface Change statistics.')
ospf3IntfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 3, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IntfIndex.setStatus('current')
if mibBuilder.loadTexts: ospf3IntfIndex.setDescription('The index of the Ospf3 Interface for which these statistics apply.')
ospf3IntfDown = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 3, 3, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IntfDown.setStatus('current')
if mibBuilder.loadTexts: ospf3IntfDown.setDescription('The total number of times the interface was down.')
ospf3IntfLoop = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 3, 3, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IntfLoop.setStatus('current')
if mibBuilder.loadTexts: ospf3IntfLoop.setDescription('The total number of times this interface changed State into the LOOP State.')
ospf3IntfWaiting = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 3, 3, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IntfWaiting.setStatus('current')
if mibBuilder.loadTexts: ospf3IntfWaiting.setDescription('The total number of times this interface changed State into the Waiting State.')
ospf3IntfPtop = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 3, 3, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IntfPtop.setStatus('current')
if mibBuilder.loadTexts: ospf3IntfPtop.setDescription('The total number of times this interface changed State into the PTOP State.')
ospf3IntfDr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 3, 3, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IntfDr.setStatus('current')
if mibBuilder.loadTexts: ospf3IntfDr.setDescription('The total number of times this interface changed State into the DR State.')
ospf3IntfBackup = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 3, 3, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IntfBackup.setStatus('current')
if mibBuilder.loadTexts: ospf3IntfBackup.setDescription('The total number of times this interface changed State into the Backup State.')
ospf3IntfDrOther = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 3, 3, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IntfDrOther.setStatus('current')
if mibBuilder.loadTexts: ospf3IntfDrOther.setDescription('The total number of times this interface changed State into the DrOther State.')
ospf3IntfAllEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 3, 3, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IntfAllEvents.setStatus('current')
if mibBuilder.loadTexts: ospf3IntfAllEvents.setDescription('The total number of times this interface changed State.')
ospf3IntfErrorStats = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 3, 4), )
if mibBuilder.loadTexts: ospf3IntfErrorStats.setStatus('current')
if mibBuilder.loadTexts: ospf3IntfErrorStats.setDescription('The table of Ospf3 Interface Error Statistics.')
ospf3IntfErrorStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 3, 4, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ospf3IntfErrIndex"))
if mibBuilder.loadTexts: ospf3IntfErrorStatsEntry.setStatus('current')
if mibBuilder.loadTexts: ospf3IntfErrorStatsEntry.setDescription('Error Statistics for an Ospf3 interface.')
ospf3IntfErrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 3, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IntfErrIndex.setStatus('current')
if mibBuilder.loadTexts: ospf3IntfErrIndex.setDescription('The index of the Ospf3 Intf for which these statistics apply.')
ospf3IntfErrRxOnPasv = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 3, 4, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IntfErrRxOnPasv.setStatus('current')
if mibBuilder.loadTexts: ospf3IntfErrRxOnPasv.setDescription('The total number of packets received by this interface that are received on a passive interface.')
ospf3IntfErrRxOspfOff = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 3, 4, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IntfErrRxOspfOff.setStatus('current')
if mibBuilder.loadTexts: ospf3IntfErrRxOspfOff.setDescription('The total number of packets received by this interface that are received while OSPF was disabled.')
ospf3IntfErrRxOnNotup = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 3, 4, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IntfErrRxOnNotup.setStatus('current')
if mibBuilder.loadTexts: ospf3IntfErrRxOnNotup.setDescription('The total number of packets received by this interface that are received while the interface was disabled.')
ospf3IntfErrRxVerMismatch = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 3, 4, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IntfErrRxVerMismatch.setStatus('current')
if mibBuilder.loadTexts: ospf3IntfErrRxVerMismatch.setDescription('The total number of packets received by this interface that have an OSPF version number not equal to the one of the interface.')
ospf3IntfErrRxZeroRTRID = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 3, 4, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IntfErrRxZeroRTRID.setStatus('current')
if mibBuilder.loadTexts: ospf3IntfErrRxZeroRTRID.setDescription('The total number of packets received by this interface that have a RouterID of 0.')
ospf3IntfErrRxSameRTRID = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 3, 4, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IntfErrRxSameRTRID.setStatus('current')
if mibBuilder.loadTexts: ospf3IntfErrRxSameRTRID.setDescription('The total number of packets received by this interface that have the same RouterID as this Router.')
ospf3IntfErrRxMismatchInstID = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 3, 4, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IntfErrRxMismatchInstID.setStatus('current')
if mibBuilder.loadTexts: ospf3IntfErrRxMismatchInstID.setDescription('The total number of packets received by this interface that have an instance number not equal to the one of the interface.')
ospf3IntfErrBadAreaID = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 3, 4, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IntfErrBadAreaID.setStatus('current')
if mibBuilder.loadTexts: ospf3IntfErrBadAreaID.setDescription('The total number of packets received by this interface that have an area number not equal to the one of the area of the interface.')
ospf3IntfErrBadDestAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 3, 4, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IntfErrBadDestAddr.setStatus('current')
if mibBuilder.loadTexts: ospf3IntfErrBadDestAddr.setDescription('The total number of packets discarded by this interface because of a destination address mismatch.')
ospf3IntfErrBadChecksum = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 3, 4, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IntfErrBadChecksum.setStatus('current')
if mibBuilder.loadTexts: ospf3IntfErrBadChecksum.setDescription('The total number of packets discarded by this interface because of a bad checksum.')
ospf3IntfErrBadNeighbour = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 3, 4, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IntfErrBadNeighbour.setStatus('current')
if mibBuilder.loadTexts: ospf3IntfErrBadNeighbour.setDescription('The total number of packets discarded by this interface because they could not be associated with any neighbor.')
ospf3IntfErrBadPktType = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 3, 4, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IntfErrBadPktType.setStatus('current')
if mibBuilder.loadTexts: ospf3IntfErrBadPktType.setDescription('The total number of packets discarded by this interface because the packet type was not recognized.')
ospf3IntfErrHelloMismatch = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 3, 4, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IntfErrHelloMismatch.setStatus('current')
if mibBuilder.loadTexts: ospf3IntfErrHelloMismatch.setDescription('The total number of packets received with a different hello interval by this interface.')
ospf3IntfErrOptionsMismatch = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 3, 4, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IntfErrOptionsMismatch.setStatus('current')
if mibBuilder.loadTexts: ospf3IntfErrOptionsMismatch.setDescription('The total number of packets received with a different options by this interface.')
ospf3IntfErrDeadMismatch = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 3, 4, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IntfErrDeadMismatch.setStatus('current')
if mibBuilder.loadTexts: ospf3IntfErrDeadMismatch.setDescription('The total number of packets received with a different dead interval by this interface.')
ospf3IntfErrMTUMismatch = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 3, 4, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IntfErrMTUMismatch.setStatus('current')
if mibBuilder.loadTexts: ospf3IntfErrMTUMismatch.setDescription('The total number of packets received with a different MTU size by this interface.')
ospf3IntfErrHelloNoNbr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 3, 4, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IntfErrHelloNoNbr.setStatus('current')
if mibBuilder.loadTexts: ospf3IntfErrHelloNoNbr.setDescription('The total number of packets received from an unknown neighbor when this interface has a Network Type of NBMA or PTOMP.')
ospf3CumRxPkts = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 1, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CumRxPkts.setStatus('current')
if mibBuilder.loadTexts: ospf3CumRxPkts.setDescription("The total number of Ospf3 packets received on all of the router's interfaces.")
ospf3CumTxPkts = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CumTxPkts.setStatus('current')
if mibBuilder.loadTexts: ospf3CumTxPkts.setDescription("The total number of Ospf3 packets transmitted on all of the router's interfaces.")
ospf3CumDisdPkts = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CumDisdPkts.setStatus('current')
if mibBuilder.loadTexts: ospf3CumDisdPkts.setDescription("The total number of Ospf3 packets discaded on all of the router's interfaces.")
ospf3CumRxHello = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CumRxHello.setStatus('current')
if mibBuilder.loadTexts: ospf3CumRxHello.setDescription("The total number of Hello packets received on all of the router's interfaces.")
ospf3CumTxHello = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CumTxHello.setStatus('current')
if mibBuilder.loadTexts: ospf3CumTxHello.setDescription("The total number of Hello packets transmitted on all of the router's interfaces.")
ospf3CumDisdHello = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CumDisdHello.setStatus('current')
if mibBuilder.loadTexts: ospf3CumDisdHello.setDescription("The total number of Hello packets discaded on all of the router's interfaces.")
ospf3CumRxDatabase = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CumRxDatabase.setStatus('current')
if mibBuilder.loadTexts: ospf3CumRxDatabase.setDescription("The total number of Database Description packets received on all of the router's interfaces.")
ospf3CumTxDatabase = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CumTxDatabase.setStatus('current')
if mibBuilder.loadTexts: ospf3CumTxDatabase.setDescription("The total number of Database Description packets transmitted on all of the router's interfaces.")
ospf3CumDisdDatabase = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CumDisdDatabase.setStatus('current')
if mibBuilder.loadTexts: ospf3CumDisdDatabase.setDescription("The total number of Database Description packets discarded on all of the router's interfaces.")
ospf3CumRxlsReqs = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CumRxlsReqs.setStatus('current')
if mibBuilder.loadTexts: ospf3CumRxlsReqs.setDescription("The total number of Link State Request packets received on all of the router's interfaces.")
ospf3CumTxlsReqs = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CumTxlsReqs.setStatus('current')
if mibBuilder.loadTexts: ospf3CumTxlsReqs.setDescription("The total number of Link State Request packets transmitted on all of the router's interfaces.")
ospf3CumDisdlsReqs = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CumDisdlsReqs.setStatus('current')
if mibBuilder.loadTexts: ospf3CumDisdlsReqs.setDescription("The total number of Link State Request packets discarded on all of the router's interfaces.")
ospf3CumRxlsAcks = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CumRxlsAcks.setStatus('current')
if mibBuilder.loadTexts: ospf3CumRxlsAcks.setDescription("The total number of Link State Acknowledgement packets received on all of the router's interfaces.")
ospf3CumTxlsAcks = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CumTxlsAcks.setStatus('current')
if mibBuilder.loadTexts: ospf3CumTxlsAcks.setDescription("The total number of Link State Acknowledgement packets transmitted on all of the router's interfaces.")
ospf3CumDisdlsAcks = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CumDisdlsAcks.setStatus('current')
if mibBuilder.loadTexts: ospf3CumDisdlsAcks.setDescription("The total number of Link State Acknowledgement packets discarded on all of the router's interfaces.")
ospf3CumRxlsUpdates = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CumRxlsUpdates.setStatus('current')
if mibBuilder.loadTexts: ospf3CumRxlsUpdates.setDescription("The total number of Link State Update packets received on all of the router's interfaces.")
ospf3CumTxlsUpdates = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CumTxlsUpdates.setStatus('current')
if mibBuilder.loadTexts: ospf3CumTxlsUpdates.setDescription("The total number of Link State Update packets transmitted on all of the router's interfaces.")
ospf3CumDisdlsUpdates = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CumDisdlsUpdates.setStatus('current')
if mibBuilder.loadTexts: ospf3CumDisdlsUpdates.setDescription("The total number of Link State Update packets discarded on all of the router's interfaces.")
ospf3CumNbrDown = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 1, 2, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CumNbrDown.setStatus('current')
if mibBuilder.loadTexts: ospf3CumNbrDown.setDescription('The total number of times neighbors now existing on the interfaces now present on the router have changed into DOWN state.')
ospf3CumNbrAttempt = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 1, 2, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CumNbrAttempt.setStatus('current')
if mibBuilder.loadTexts: ospf3CumNbrAttempt.setDescription('The total number of times neighbors now existing the on interfaces now present on the router have changed into ATTEMPT state.')
ospf3CumNbrInit = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 1, 2, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CumNbrInit.setStatus('current')
if mibBuilder.loadTexts: ospf3CumNbrInit.setDescription('The total number of times neighbors now existing the on interfaces now present on the router have changed into INIT state.')
ospf3CumNbrN2way = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 1, 2, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CumNbrN2way.setStatus('current')
if mibBuilder.loadTexts: ospf3CumNbrN2way.setDescription('The total number of times neighbors now existing the on interfaces now present on the router have changed into 2WAY state.')
ospf3CumNbrExStart = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 1, 2, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CumNbrExStart.setStatus('current')
if mibBuilder.loadTexts: ospf3CumNbrExStart.setDescription('The total number of times neighbors now existing the on interfaces now present on the router have changed into EXSTART state.')
ospf3CumNbrExchange = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 1, 2, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CumNbrExchange.setStatus('current')
if mibBuilder.loadTexts: ospf3CumNbrExchange.setDescription('The total number of times neighbors now existing the on interfaces now present on the router have changed into EXCHANGE state.')
ospf3CumNbrLoading = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 1, 2, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CumNbrLoading.setStatus('current')
if mibBuilder.loadTexts: ospf3CumNbrLoading.setDescription('The total number of times neighbors now existing the on interfaces now present on the router have changed into LOADING state.')
ospf3CumNbrFull = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 1, 2, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CumNbrFull.setStatus('current')
if mibBuilder.loadTexts: ospf3CumNbrFull.setDescription('The total number of times neighbors now existing the on interfaces now present on the router have changed into FULL state.')
ospf3CumNbrAllEvents = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 1, 2, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CumNbrAllEvents.setStatus('current')
if mibBuilder.loadTexts: ospf3CumNbrAllEvents.setDescription('The total number of times neighbors now existing the on interfaces now present on the router have changed state.')
ospf3CumIntfDown = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 1, 3, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CumIntfDown.setStatus('current')
if mibBuilder.loadTexts: ospf3CumIntfDown.setDescription('The total number of times, for all the interfaces on the router, an interface was down.')
ospf3CumIntfLoop = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 1, 3, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CumIntfLoop.setStatus('current')
if mibBuilder.loadTexts: ospf3CumIntfLoop.setDescription('The total number of times , for all the interfaces on the router, an interface changed State into the LOOP State.')
ospf3CumIntfWaiting = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 1, 3, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CumIntfWaiting.setStatus('current')
if mibBuilder.loadTexts: ospf3CumIntfWaiting.setDescription('The total number of times , for all the interfaces on the router, an interface changed State into the WAITING State.')
ospf3CumIntfPtop = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 1, 3, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CumIntfPtop.setStatus('current')
if mibBuilder.loadTexts: ospf3CumIntfPtop.setDescription('The total number of times , for all the interfaces on the router, an interface changed State into the PTOP State.')
ospf3CumIntfDr = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 1, 3, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CumIntfDr.setStatus('current')
if mibBuilder.loadTexts: ospf3CumIntfDr.setDescription('The total number of times , for all the interfaces on the router, an interface changed State into the DR State.')
ospf3CumIntfBackup = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 1, 3, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CumIntfBackup.setStatus('current')
if mibBuilder.loadTexts: ospf3CumIntfBackup.setDescription('The total number of times , for all the interfaces on the router, an interface changed State into the BACKUP State.')
ospf3CumIntfDrOther = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 1, 3, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CumIntfDrOther.setStatus('current')
if mibBuilder.loadTexts: ospf3CumIntfDrOther.setDescription('The total number of times , for all the interfaces on the router, an interface changed State into the DROTHER State.')
ospf3CumIntfAllEvents = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 1, 3, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3CumIntfAllEvents.setStatus('current')
if mibBuilder.loadTexts: ospf3CumIntfAllEvents.setDescription("The total number of times , for all the interfaces on the router, an interface changed it's state.")
ospf3TmrsKckOffHello = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 1, 4, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3TmrsKckOffHello.setStatus('current')
if mibBuilder.loadTexts: ospf3TmrsKckOffHello.setDescription('The sum total number of times the Hello timer has been fired (which triggers the send of a Hello packet) across all OPSF areas and interfaces.')
ospf3TmrsKckOffWait = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 1, 4, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3TmrsKckOffWait.setStatus('current')
if mibBuilder.loadTexts: ospf3TmrsKckOffWait.setDescription('The sum total number of times the KickOffWait timer has been fired (which triggers the send of a KickOffWait packet) across all OPSF areas and interfaces.')
ospf3TmrsKckOffPoll = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 1, 4, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3TmrsKckOffPoll.setStatus('current')
if mibBuilder.loadTexts: ospf3TmrsKckOffPoll.setDescription('The sum total number of times the KickOffPoll timer has been fired (which triggers the send of a KickOffPoll packet) across all OPSF areas and interfaces.')
ospf3TmrsKckOffNbrProbe = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 22, 1, 4, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3TmrsKckOffNbrProbe.setStatus('current')
if mibBuilder.loadTexts: ospf3TmrsKckOffNbrProbe.setDescription('The sum total number of times the KickOffNbrProbe timer has been fired (which triggers the send of a KickOffNbrProbe packet) across all OPSF areas and interfaces.')
mldIfStatsTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 23, 1), )
if mibBuilder.loadTexts: mldIfStatsTable.setStatus('current')
if mibBuilder.loadTexts: mldIfStatsTable.setDescription('The table listing the interfaces on which MLD is enabled.')
mldIfStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 23, 1, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "mldIfStatsIfIndex"))
if mibBuilder.loadTexts: mldIfStatsEntry.setStatus('current')
if mibBuilder.loadTexts: mldIfStatsEntry.setDescription('An entry representing an interface stats on which MLD is enabled.')
mldIfStatsIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 23, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mldIfStatsIfIndex.setStatus('current')
if mibBuilder.loadTexts: mldIfStatsIfIndex.setDescription('The internetwork-layer interface value of the interface for which MLD msg stats is counted.')
rxMldIfStatsGeneralQuery = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 23, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxMldIfStatsGeneralQuery.setStatus('current')
if mibBuilder.loadTexts: rxMldIfStatsGeneralQuery.setDescription('The total number of MLD Listener Queries received.')
rxMldIfStatsMASQuery = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 23, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxMldIfStatsMASQuery.setStatus('current')
if mibBuilder.loadTexts: rxMldIfStatsMASQuery.setDescription('The total number of MLD Listener MAS Queries received.')
rxMldIfStatsMASSQQuery = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 23, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxMldIfStatsMASSQQuery.setStatus('current')
if mibBuilder.loadTexts: rxMldIfStatsMASSQQuery.setDescription('The total number of MLD Listener MASSQ Queries received.')
rxMldIfStatsMLDv1Report = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 23, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxMldIfStatsMLDv1Report.setStatus('current')
if mibBuilder.loadTexts: rxMldIfStatsMLDv1Report.setDescription('The total number of MLD Listener Reports (v1) received.')
rxMldIfStatsMLDv1Done = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 23, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxMldIfStatsMLDv1Done.setStatus('current')
if mibBuilder.loadTexts: rxMldIfStatsMLDv1Done.setDescription('The total number of MLD Listener Dones (v1/v2) received.')
rxMldIfStatsMLDv2Report = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 23, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxMldIfStatsMLDv2Report.setStatus('current')
if mibBuilder.loadTexts: rxMldIfStatsMLDv2Report.setDescription('The total number of MLD Listener Reports (v2) received.')
rxMldIfStatsIncCrsv2 = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 23, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxMldIfStatsIncCrsv2.setStatus('current')
if mibBuilder.loadTexts: rxMldIfStatsIncCrsv2.setDescription('The total number of MLD INC CRs (v2) received.')
rxMldIfStatsExcCrsv2 = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 23, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxMldIfStatsExcCrsv2.setStatus('current')
if mibBuilder.loadTexts: rxMldIfStatsExcCrsv2.setDescription('The total number of MLD EXC CRs (v2) received.')
rxMldIfStatsToIncFmcrsv2 = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 23, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxMldIfStatsToIncFmcrsv2.setStatus('current')
if mibBuilder.loadTexts: rxMldIfStatsToIncFmcrsv2.setDescription('The total number of MLD TO_INC FMCRs (v2) received.')
rxMldIfStatsToExcFmcrsv2 = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 23, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxMldIfStatsToExcFmcrsv2.setStatus('current')
if mibBuilder.loadTexts: rxMldIfStatsToExcFmcrsv2.setDescription('The total number of MLD TO_EXC FMCRs (v2) received.')
rxMldIfStatsAllowSlcrsv2 = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 23, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxMldIfStatsAllowSlcrsv2.setStatus('current')
if mibBuilder.loadTexts: rxMldIfStatsAllowSlcrsv2.setDescription('The total number of MLD ALLOW SLCRs (v2) received.')
rxMldIfStatsBlockSlcrsv2 = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 23, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxMldIfStatsBlockSlcrsv2.setStatus('current')
if mibBuilder.loadTexts: rxMldIfStatsBlockSlcrsv2.setDescription('The total number of MLD BLOCK SLCRs (v2) received.')
txMldIfStatsGeneralQuery = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 23, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txMldIfStatsGeneralQuery.setStatus('current')
if mibBuilder.loadTexts: txMldIfStatsGeneralQuery.setDescription('The total number of MLD Listener Queries sent.')
txMldIfStatsMASQuery = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 23, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txMldIfStatsMASQuery.setStatus('current')
if mibBuilder.loadTexts: txMldIfStatsMASQuery.setDescription('The total number of MLD Listener MAS Queries sent.')
txMldIfStatsMASSQQuery = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 23, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txMldIfStatsMASSQQuery.setStatus('current')
if mibBuilder.loadTexts: txMldIfStatsMASSQQuery.setDescription('The total number of MLD Listener MASSQ Queries sent.')
txMldIfStatsMLDv1Report = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 23, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txMldIfStatsMLDv1Report.setStatus('current')
if mibBuilder.loadTexts: txMldIfStatsMLDv1Report.setDescription('The total number of MLD Listener Reports (v1) sent.')
txMldIfStatsMLDv1Done = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 23, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txMldIfStatsMLDv1Done.setStatus('current')
if mibBuilder.loadTexts: txMldIfStatsMLDv1Done.setDescription('The total number of MLD Listener Dones (v1/v2) sent.')
txMldIfStatsMLDv2Report = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 23, 1, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txMldIfStatsMLDv2Report.setStatus('current')
if mibBuilder.loadTexts: txMldIfStatsMLDv2Report.setDescription('The total number of MLD Listener Reports (v2) sent.')
txMldIfStatsIncCrsv2 = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 23, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txMldIfStatsIncCrsv2.setStatus('current')
if mibBuilder.loadTexts: txMldIfStatsIncCrsv2.setDescription('The total number of MLD INC CRs (v2) sent')
txMldIfStatsExcCrsv2 = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 23, 1, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txMldIfStatsExcCrsv2.setStatus('current')
if mibBuilder.loadTexts: txMldIfStatsExcCrsv2.setDescription('The total number of MLD EXC CRs (v2) sent')
txMldIfStatsToIncFmcrsv2 = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 23, 1, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txMldIfStatsToIncFmcrsv2.setStatus('current')
if mibBuilder.loadTexts: txMldIfStatsToIncFmcrsv2.setDescription('The total number of MLD TO_INC FMCRs (v2) sent')
txMldIfStatsToExcFmcrsv2 = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 23, 1, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txMldIfStatsToExcFmcrsv2.setStatus('current')
if mibBuilder.loadTexts: txMldIfStatsToExcFmcrsv2.setDescription('The total number of MLD TO_EXC FMCRs (v2) sent')
txMldIfStatsAllowSlcrsv2 = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 23, 1, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txMldIfStatsAllowSlcrsv2.setStatus('current')
if mibBuilder.loadTexts: txMldIfStatsAllowSlcrsv2.setDescription('The total number of MLD ALLOW SLCRs (v2) sent')
txMldIfStatsBlockSlcrsv2 = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 23, 1, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txMldIfStatsBlockSlcrsv2.setStatus('current')
if mibBuilder.loadTexts: txMldIfStatsBlockSlcrsv2.setDescription('The total number of MLD BLOCK SLCRs (v2) received.')
errMldIfStatsGeneralQuery = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 23, 1, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: errMldIfStatsGeneralQuery.setStatus('current')
if mibBuilder.loadTexts: errMldIfStatsGeneralQuery.setDescription('The total number of MLD Listener Queries errors.')
errMldIfStatsMASQuery = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 23, 1, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: errMldIfStatsMASQuery.setStatus('current')
if mibBuilder.loadTexts: errMldIfStatsMASQuery.setDescription('The total number of MLD Listener MAS Queries errors.')
errMldIfStatsMASSQQuery = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 23, 1, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: errMldIfStatsMASSQQuery.setStatus('current')
if mibBuilder.loadTexts: errMldIfStatsMASSQQuery.setDescription('The total number of MLD Listener MASSQ Queries errors.')
errMldIfStatsMLDv1Report = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 23, 1, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: errMldIfStatsMLDv1Report.setStatus('current')
if mibBuilder.loadTexts: errMldIfStatsMLDv1Report.setDescription('The total number of MLD Listener Report (v1) errors.')
errMldIfStatsMLDv1Done = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 23, 1, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: errMldIfStatsMLDv1Done.setStatus('current')
if mibBuilder.loadTexts: errMldIfStatsMLDv1Done.setDescription('The total number of MLD Listener Done (v1/v2) errors.')
errMldIfStatsMLDv2Report = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 23, 1, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: errMldIfStatsMLDv2Report.setStatus('current')
if mibBuilder.loadTexts: errMldIfStatsMLDv2Report.setDescription('The total number of MLD Listener Report (v2) errors.')
errMldIfStatsIncCrsv2 = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 23, 1, 1, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: errMldIfStatsIncCrsv2.setStatus('current')
if mibBuilder.loadTexts: errMldIfStatsIncCrsv2.setDescription('The total number of MLD INC CRs (v2) errors.')
errMldIfStatsExcCrsv2 = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 23, 1, 1, 34), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: errMldIfStatsExcCrsv2.setStatus('current')
if mibBuilder.loadTexts: errMldIfStatsExcCrsv2.setDescription('The total number of MLD EXC CRs (v2) errors.')
errMldIfStatsToIncFmcrsv2 = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 23, 1, 1, 35), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: errMldIfStatsToIncFmcrsv2.setStatus('current')
if mibBuilder.loadTexts: errMldIfStatsToIncFmcrsv2.setDescription('The total number of MLD TO_INC FMCRs (v2) errors.')
errMldIfStatsToExcFmcrsv2 = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 23, 1, 1, 36), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: errMldIfStatsToExcFmcrsv2.setStatus('current')
if mibBuilder.loadTexts: errMldIfStatsToExcFmcrsv2.setDescription('The total number of MLD TO_EXC FMCRs (v2) errors.')
errMldIfStatsAllowSlcrsv2 = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 23, 1, 1, 37), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: errMldIfStatsAllowSlcrsv2.setStatus('current')
if mibBuilder.loadTexts: errMldIfStatsAllowSlcrsv2.setDescription('The total number of MLD ALLOW SLCRs (v2) errors.')
errMldIfStatsBlockSlcrsv2 = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 23, 1, 1, 38), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: errMldIfStatsBlockSlcrsv2.setStatus('current')
if mibBuilder.loadTexts: errMldIfStatsBlockSlcrsv2.setDescription('The total number of MLD BLOCK SLCRs (v2) errors.')
mldStatBadLength = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 23, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mldStatBadLength.setStatus('current')
if mibBuilder.loadTexts: mldStatBadLength.setDescription('The total number of bad length mld packet.')
mldStatBadChecksum = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 23, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mldStatBadChecksum.setStatus('current')
if mibBuilder.loadTexts: mldStatBadChecksum.setDescription('The total number of bad checksum mld packet.')
mldStatBadReceiveIf = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 23, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mldStatBadReceiveIf.setStatus('current')
if mibBuilder.loadTexts: mldStatBadReceiveIf.setDescription('The total number of bad reveive if mld packet.')
mldStatReceiveNonLocal = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 23, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mldStatReceiveNonLocal.setStatus('current')
if mibBuilder.loadTexts: mldStatReceiveNonLocal.setDescription('The total number of non local received mld packet.')
mldStatInvalidPkts = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 23, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mldStatInvalidPkts.setStatus('current')
if mibBuilder.loadTexts: mldStatInvalidPkts.setDescription('The total number of invalid packets.')
mldStatTotalL3Ipv6SgvEntries = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 23, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mldStatTotalL3Ipv6SgvEntries.setStatus('current')
if mibBuilder.loadTexts: mldStatTotalL3Ipv6SgvEntries.setDescription('Total L3 IPv6 (S, G, V) entries')
mldStatTotalMLDGroups = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 23, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mldStatTotalMLDGroups.setStatus('current')
if mibBuilder.loadTexts: mldStatTotalMLDGroups.setDescription('The total number of MLD Groups.')
mldStatClearAll = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 23, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("clear", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mldStatClearAll.setStatus('current')
if mibBuilder.loadTexts: mldStatClearAll.setDescription('Clear all MLD stats. Returns other(1) when read.')
ipInfoRouterID = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 8, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipInfoRouterID.setStatus('current')
if mibBuilder.loadTexts: ipInfoRouterID.setDescription('Router ID information.')
ipIntfInfoTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 9, 1), )
if mibBuilder.loadTexts: ipIntfInfoTable.setStatus('current')
if mibBuilder.loadTexts: ipIntfInfoTable.setDescription('The table of IP interface information.')
intfInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 9, 1, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "intfInfoIndex"))
if mibBuilder.loadTexts: intfInfoEntry.setStatus('current')
if mibBuilder.loadTexts: intfInfoEntry.setDescription('A row in IP interface information table.')
intfInfoIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 9, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: intfInfoIndex.setStatus('current')
if mibBuilder.loadTexts: intfInfoIndex.setDescription('The interface number for which the information is related.')
intfInfoAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 9, 1, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: intfInfoAddr.setStatus('current')
if mibBuilder.loadTexts: intfInfoAddr.setDescription('The IP address of the interface.')
intfInfoNetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 9, 1, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: intfInfoNetMask.setStatus('current')
if mibBuilder.loadTexts: intfInfoNetMask.setDescription('The subnet mask of the interface.')
intfInfoBcastAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 9, 1, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: intfInfoBcastAddr.setStatus('current')
if mibBuilder.loadTexts: intfInfoBcastAddr.setDescription('The broadcast address of the interface.')
intfInfoVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 9, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: intfInfoVlan.setStatus('current')
if mibBuilder.loadTexts: intfInfoVlan.setDescription('The VLAN number for this interface.')
intfInfoStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 9, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("disabled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: intfInfoStatus.setStatus('current')
if mibBuilder.loadTexts: intfInfoStatus.setDescription('The status of the interface.')
ipIntfLoopbackInfoTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 16, 1), )
if mibBuilder.loadTexts: ipIntfLoopbackInfoTable.setStatus('current')
if mibBuilder.loadTexts: ipIntfLoopbackInfoTable.setDescription('The table of IP Loopback interface information.')
intfLoopbackInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 16, 1, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "intfLoopbackInfoIndex"))
if mibBuilder.loadTexts: intfLoopbackInfoEntry.setStatus('current')
if mibBuilder.loadTexts: intfLoopbackInfoEntry.setDescription('A row in IP Loopback interface information table.')
intfLoopbackInfoIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 16, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: intfLoopbackInfoIndex.setStatus('current')
if mibBuilder.loadTexts: intfLoopbackInfoIndex.setDescription('The Loopback interface number for which the information is related.')
intfLoopbackInfoAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 16, 1, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: intfLoopbackInfoAddr.setStatus('current')
if mibBuilder.loadTexts: intfLoopbackInfoAddr.setDescription('The IP address of the interface.')
intfLoopbackInfoNetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 16, 1, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: intfLoopbackInfoNetMask.setStatus('current')
if mibBuilder.loadTexts: intfLoopbackInfoNetMask.setDescription('The subnet mask of the interface.')
intfLoopbackInfoBcastAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 16, 1, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: intfLoopbackInfoBcastAddr.setStatus('current')
if mibBuilder.loadTexts: intfLoopbackInfoBcastAddr.setDescription('The broadcast address of the interface.')
intfLoopbackInfoStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 16, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("disabled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: intfLoopbackInfoStatus.setStatus('current')
if mibBuilder.loadTexts: intfLoopbackInfoStatus.setDescription('The status of the interface.')
ipMgmtRouteInfoTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 1, 3), )
if mibBuilder.loadTexts: ipMgmtRouteInfoTable.setStatus('current')
if mibBuilder.loadTexts: ipMgmtRouteInfoTable.setDescription('The table of run-time IP routes.')
ipMgmtRouteInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 1, 3, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ipMgmtRouteInfoIndx"))
if mibBuilder.loadTexts: ipMgmtRouteInfoEntry.setStatus('current')
if mibBuilder.loadTexts: ipMgmtRouteInfoEntry.setDescription('A row in the run-time IP route table')
ipMgmtRouteInfoIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 1, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMgmtRouteInfoIndx.setStatus('current')
if mibBuilder.loadTexts: ipMgmtRouteInfoIndx.setDescription('The index of this route table.')
ipMgmtRouteInfoDestIp = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 1, 3, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMgmtRouteInfoDestIp.setStatus('current')
if mibBuilder.loadTexts: ipMgmtRouteInfoDestIp.setDescription('The destination IP address of this route.')
ipMgmtRouteInfoMask = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 1, 3, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMgmtRouteInfoMask.setStatus('current')
if mibBuilder.loadTexts: ipMgmtRouteInfoMask.setDescription('The destination IP mask of this route.')
ipMgmtRouteInfoGateway = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 1, 3, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMgmtRouteInfoGateway.setStatus('current')
if mibBuilder.loadTexts: ipMgmtRouteInfoGateway.setDescription('The next-hop router address for this route.')
ipMgmtRouteInfoTag = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 1, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))).clone(namedValues=NamedValues(("fixed", 1), ("static", 2), ("addr", 3), ("rip", 4), ("broadcast", 5), ("martian", 6), ("multicast", 7), ("vip", 8), ("bgp", 9), ("ospf", 10), ("none", 11)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMgmtRouteInfoTag.setStatus('current')
if mibBuilder.loadTexts: ipMgmtRouteInfoTag.setDescription('The tag-type for this route.')
ipMgmtRouteInfoType = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 1, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("indirect", 1), ("direct", 2), ("local", 3), ("broadcast", 4), ("martian", 5), ("multicast", 6), ("other", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMgmtRouteInfoType.setStatus('current')
if mibBuilder.loadTexts: ipMgmtRouteInfoType.setDescription('The type of the route.')
ipMgmtRouteInfoInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 1, 3, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMgmtRouteInfoInterface.setStatus('current')
if mibBuilder.loadTexts: ipMgmtRouteInfoInterface.setDescription('The interface number for which the destination address is applicable.')
ipMgmtRouteInfoGateway1 = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 1, 3, 1, 8), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMgmtRouteInfoGateway1.setStatus('current')
if mibBuilder.loadTexts: ipMgmtRouteInfoGateway1.setDescription('The next-hop router address for this route.')
ipMgmtRouteInfoGateway2 = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 1, 3, 1, 9), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMgmtRouteInfoGateway2.setStatus('current')
if mibBuilder.loadTexts: ipMgmtRouteInfoGateway2.setDescription('The next-hop router address for this route.')
ipMgmtRouteInfoMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 1, 3, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMgmtRouteInfoMetric.setStatus('current')
if mibBuilder.loadTexts: ipMgmtRouteInfoMetric.setDescription('The Metric for this route.')
ipDataRouteInfoTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 1, 1), )
if mibBuilder.loadTexts: ipDataRouteInfoTable.setStatus('current')
if mibBuilder.loadTexts: ipDataRouteInfoTable.setDescription('The table of run-time IP routes.')
ipDataRouteInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 1, 1, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ipDataRouteInfoIndx"))
if mibBuilder.loadTexts: ipDataRouteInfoEntry.setStatus('current')
if mibBuilder.loadTexts: ipDataRouteInfoEntry.setDescription('A row in the run-time IP route table')
ipDataRouteInfoIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipDataRouteInfoIndx.setStatus('current')
if mibBuilder.loadTexts: ipDataRouteInfoIndx.setDescription('The index of this route table.')
ipDataRouteInfoDestIp = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 1, 1, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipDataRouteInfoDestIp.setStatus('current')
if mibBuilder.loadTexts: ipDataRouteInfoDestIp.setDescription('The destination IP address of this route.')
ipDataRouteInfoMask = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 1, 1, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipDataRouteInfoMask.setStatus('current')
if mibBuilder.loadTexts: ipDataRouteInfoMask.setDescription('The destination IP mask of this route.')
ipDataRouteInfoGateway = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 1, 1, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipDataRouteInfoGateway.setStatus('current')
if mibBuilder.loadTexts: ipDataRouteInfoGateway.setDescription('The next-hop router address for this route.')
ipDataRouteInfoTag = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))).clone(namedValues=NamedValues(("fixed", 1), ("static", 2), ("addr", 3), ("rip", 4), ("broadcast", 5), ("martian", 6), ("multicast", 7), ("vip", 8), ("bgp", 9), ("ospf", 10), ("none", 11)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipDataRouteInfoTag.setStatus('current')
if mibBuilder.loadTexts: ipDataRouteInfoTag.setDescription('The tag-type for this route.')
ipDataRouteInfoType = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("indirect", 1), ("direct", 2), ("local", 3), ("broadcast", 4), ("martian", 5), ("multicast", 6), ("other", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipDataRouteInfoType.setStatus('current')
if mibBuilder.loadTexts: ipDataRouteInfoType.setDescription('The type of the route.')
ipDataRouteInfoInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 1, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipDataRouteInfoInterface.setStatus('current')
if mibBuilder.loadTexts: ipDataRouteInfoInterface.setDescription('The interface number for which the destination address is applicable. Loopback interfaces are numbered starting with maximum allowed IP interfaces +1.')
ipDataRouteInfoGateway1 = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 1, 1, 1, 8), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipDataRouteInfoGateway1.setStatus('current')
if mibBuilder.loadTexts: ipDataRouteInfoGateway1.setDescription('The next-hop router address for this route.')
ipDataRouteInfoGateway2 = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 1, 1, 1, 9), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipDataRouteInfoGateway2.setStatus('current')
if mibBuilder.loadTexts: ipDataRouteInfoGateway2.setDescription('The next-hop router address for this route.')
ipDataRouteInfoMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 1, 1, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipDataRouteInfoMetric.setStatus('current')
if mibBuilder.loadTexts: ipDataRouteInfoMetric.setDescription('The Metric for this route.')
routeTableClear = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("clear", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: routeTableClear.setStatus('current')
if mibBuilder.loadTexts: routeTableClear.setDescription('Setting this value to clear(2) clears the route table.')
ipRouteEcmpInfoTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 19, 1), )
if mibBuilder.loadTexts: ipRouteEcmpInfoTable.setStatus('current')
if mibBuilder.loadTexts: ipRouteEcmpInfoTable.setDescription('The table of run-time IP routes.')
ipRouteEcmpInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 19, 1, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ipRouteEcmpInfoDestIndx"), (0, "IBM-GbTOR-10G-L2L3-MIB", "ipRouteEcmpInfoGwIndx"))
if mibBuilder.loadTexts: ipRouteEcmpInfoEntry.setStatus('current')
if mibBuilder.loadTexts: ipRouteEcmpInfoEntry.setDescription('A row in the run-time IP route table')
ipRouteEcmpInfoDestIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 19, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipRouteEcmpInfoDestIndx.setStatus('current')
if mibBuilder.loadTexts: ipRouteEcmpInfoDestIndx.setDescription('The index of unique destinations IP.')
ipRouteEcmpInfoGwIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 19, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipRouteEcmpInfoGwIndx.setStatus('current')
if mibBuilder.loadTexts: ipRouteEcmpInfoGwIndx.setDescription('The index of the gateway per destination.')
ipRouteEcmpInfoDest = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 19, 1, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipRouteEcmpInfoDest.setStatus('current')
if mibBuilder.loadTexts: ipRouteEcmpInfoDest.setDescription('The destination IP of this route.')
ipRouteEcmpInfoMask = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 19, 1, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipRouteEcmpInfoMask.setStatus('current')
if mibBuilder.loadTexts: ipRouteEcmpInfoMask.setDescription('The destination IP mask of this route.')
ipRouteEcmpInfoGateway = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 19, 1, 1, 5), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipRouteEcmpInfoGateway.setStatus('current')
if mibBuilder.loadTexts: ipRouteEcmpInfoGateway.setDescription('The next-hop router address for this route.')
ipRouteEcmpInfoInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 19, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipRouteEcmpInfoInterface.setStatus('current')
if mibBuilder.loadTexts: ipRouteEcmpInfoInterface.setDescription('The interface for the next-hop.')
ipRouteEcmpInfoGwStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 19, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipRouteEcmpInfoGwStatus.setStatus('current')
if mibBuilder.loadTexts: ipRouteEcmpInfoGwStatus.setDescription('The Up/Down status of the gateway')
ipEcmpHashSIPAddr = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 20, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipEcmpHashSIPAddr.setStatus('current')
if mibBuilder.loadTexts: ipEcmpHashSIPAddr.setDescription('The SIP Address.')
ipEcmpHashDIPAddr = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 20, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipEcmpHashDIPAddr.setStatus('current')
if mibBuilder.loadTexts: ipEcmpHashDIPAddr.setDescription('The DIP Address (enter 0 for SIP only).')
ipEcmpHashNumberPaths = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 20, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 5))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipEcmpHashNumberPaths.setStatus('current')
if mibBuilder.loadTexts: ipEcmpHashNumberPaths.setDescription('The number of ECMP paths.')
ipEcmpHashRouteNumber = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 20, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipEcmpHashRouteNumber.setStatus('current')
if mibBuilder.loadTexts: ipEcmpHashRouteNumber.setDescription('The result of the hash algorithm. For this to work the values for ipEcmpHashSIPAddr, ipEcmpHashDIPAddr, ipEcmpHashNumberPaths must be set. If the result is 0 ipEcmpHashNumberPaths is not correctly set.')
mldInfoGroupsTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 22, 1), )
if mibBuilder.loadTexts: mldInfoGroupsTable.setStatus('current')
if mibBuilder.loadTexts: mldInfoGroupsTable.setDescription('The table listing the IPv6 multicast groups for which there are members on a particular interface.')
mldInfoGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 22, 1, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "mldInfoGroupIfIndex"))
if mibBuilder.loadTexts: mldInfoGroupEntry.setStatus('current')
if mibBuilder.loadTexts: mldInfoGroupEntry.setDescription('An entry in the mldInfoGroupsTable')
mldInfoGroupIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 22, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mldInfoGroupIfIndex.setStatus('current')
if mibBuilder.loadTexts: mldInfoGroupIfIndex.setDescription('The internetwork-layer interface for which this entry contains information for an IPv6 multicast group address.')
mldInfoGroupAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 22, 1, 1, 2), InetAddressIPv6()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mldInfoGroupAddress.setStatus('current')
if mibBuilder.loadTexts: mldInfoGroupAddress.setDescription('The IPv6 multicast group address for which this entry contains information. Its address MUST be of format: 2x:2x:2x:2x:2x:2x:2x:2x')
mldInfoGroupPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 22, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mldInfoGroupPortNumber.setStatus('current')
if mibBuilder.loadTexts: mldInfoGroupPortNumber.setDescription('The port number for which this entry contains information for an IPv6 multicast group address.')
mldInfoGroupVlanID = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 22, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mldInfoGroupVlanID.setStatus('current')
if mibBuilder.loadTexts: mldInfoGroupVlanID.setDescription('The VLAN ID for which this entry contains information for an IPv6 multicast group address.')
mldInfoGroupLastReporter = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 22, 1, 1, 5), InetAddressIPv6()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mldInfoGroupLastReporter.setStatus('current')
if mibBuilder.loadTexts: mldInfoGroupLastReporter.setDescription('The IPv6 address of the source of the last membership report received for this IPv6 Multicast group address on this interface. If no membership report has been received, this object has the value 00:0:00:00:00:00:00:00. Its address MUST be of format:2x:2x:2x:2x:2x:2x:2x:2x')
mldInfoGroupSource = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 22, 1, 1, 6), InetAddressIPv6()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mldInfoGroupSource.setStatus('current')
if mibBuilder.loadTexts: mldInfoGroupSource.setDescription("ONLY for MLDv2. The IPv6 address for which the this entry's filter is applied. Its address MUST be of format: 2x:2x:2x:2x:2x:2x:2x:2x")
mldInfoGroupFilterType = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 22, 1, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mldInfoGroupFilterType.setStatus('current')
if mibBuilder.loadTexts: mldInfoGroupFilterType.setDescription('ONLY for MLDv2. The filter type for the specified source.')
mldInfoGroupExpiryTime = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 22, 1, 1, 8), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mldInfoGroupExpiryTime.setStatus('current')
if mibBuilder.loadTexts: mldInfoGroupExpiryTime.setDescription('The minimum amount of time remaining before this entry will be aged out. A value of 0 indicates that the entry is only present because mldCacheSelf is true and that if the router left the group, this entry would be aged out immediately. Note that some implementations may process Membership Reports from the local system in the same way as reports from other hosts, so a value of 0 is not required.')
mldInfoGroupVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 22, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mldInfoGroupVersion.setStatus('current')
if mibBuilder.loadTexts: mldInfoGroupVersion.setDescription('The version of this MLD entry.')
mldInfoGroupFwd = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 22, 1, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mldInfoGroupFwd.setStatus('current')
if mibBuilder.loadTexts: mldInfoGroupFwd.setDescription('Specifies if forwarding is enabled for this entry.')
mldInfoMRoutersTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 22, 2), )
if mibBuilder.loadTexts: mldInfoMRoutersTable.setStatus('current')
if mibBuilder.loadTexts: mldInfoMRoutersTable.setDescription('The table listing the IPv6 multicast routers on an interface.')
mldInfoMRouterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 22, 2, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "mldInfoMRouterIfIndex"))
if mibBuilder.loadTexts: mldInfoMRouterEntry.setStatus('current')
if mibBuilder.loadTexts: mldInfoMRouterEntry.setDescription('An entry in the mldInfoMRoutersTable')
mldInfoMRouterIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 22, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mldInfoMRouterIfIndex.setStatus('current')
if mibBuilder.loadTexts: mldInfoMRouterIfIndex.setDescription('The interface on which the multicast router is learnt.')
mldInfoMRouterSrcIp = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 22, 2, 1, 2), InetAddressIPv6()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mldInfoMRouterSrcIp.setStatus('current')
if mibBuilder.loadTexts: mldInfoMRouterSrcIp.setDescription("The multicast router's ip.")
mldInfoMRouterPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 22, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mldInfoMRouterPortNumber.setStatus('current')
if mibBuilder.loadTexts: mldInfoMRouterPortNumber.setDescription('The port on which the multicast router is learnt.')
mldInfoMRouterVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 22, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mldInfoMRouterVlan.setStatus('current')
if mibBuilder.loadTexts: mldInfoMRouterVlan.setDescription('The vlan in which the multicast router is learnt.')
mldInfoMRouterQrv = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 22, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mldInfoMRouterQrv.setStatus('current')
if mibBuilder.loadTexts: mldInfoMRouterQrv.setDescription("This multicast router's Maximum Response Delay")
mldInfoMRouterQqic = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 22, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mldInfoMRouterQqic.setStatus('current')
if mibBuilder.loadTexts: mldInfoMRouterQqic.setDescription("ONLY for MLDv2. This multicast router's QQIC")
mldInfoMRouterMaxRespDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 22, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mldInfoMRouterMaxRespDelay.setStatus('current')
if mibBuilder.loadTexts: mldInfoMRouterMaxRespDelay.setDescription("This multicast router's Maximum Response Delay.")
mldInfoMRouterVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 22, 2, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mldInfoMRouterVersion.setStatus('current')
if mibBuilder.loadTexts: mldInfoMRouterVersion.setDescription("This multicast router's MLD version.")
mldInfoMRouterExpiryTime = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 22, 2, 1, 9), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mldInfoMRouterExpiryTime.setStatus('current')
if mibBuilder.loadTexts: mldInfoMRouterExpiryTime.setDescription("This multicast router's expiry time.")
mldClearTables = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 22, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("none", 0), ("clearGroups", 1), ("clearMrouters", 2), ("clearAll", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mldClearTables.setStatus('current')
if mibBuilder.loadTexts: mldClearTables.setDescription('Clear the MLD tables. When setting clearGroups(1), the dynamic groups are removed, when setting clearMrouters(2), the mrouter tables are removed and when setting clearAll(3), both the dynamic groups and the mrouter tables are removed. When read, none(0) is always returned.')
mldInfoInterfaceTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 22, 4), )
if mibBuilder.loadTexts: mldInfoInterfaceTable.setStatus('current')
if mibBuilder.loadTexts: mldInfoInterfaceTable.setDescription('The (conceptual) table listing the informatio of interfaces on which MLD is enabled.')
mldInfoInterfaceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 22, 4, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "mldInfoInterfaceIfIndex"))
if mibBuilder.loadTexts: mldInfoInterfaceEntry.setStatus('current')
if mibBuilder.loadTexts: mldInfoInterfaceEntry.setDescription('An entry (conceptual row) representing the information of an interface on which MLD is enabled.')
mldInfoInterfaceIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 22, 4, 1, 1), Integer32())
if mibBuilder.loadTexts: mldInfoInterfaceIfIndex.setStatus('current')
if mibBuilder.loadTexts: mldInfoInterfaceIfIndex.setDescription('The internetwork-layer interface value of the interface for which MLD is enabled.')
mldInfoInterfaceState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 22, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mldInfoInterfaceState.setStatus('current')
if mibBuilder.loadTexts: mldInfoInterfaceState.setDescription('The internetwork-layer interface value of the interface for which MLD is enabled.')
mldInfoInterfaceVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 22, 4, 1, 3), Integer32().clone(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mldInfoInterfaceVersion.setStatus('current')
if mibBuilder.loadTexts: mldInfoInterfaceVersion.setDescription('The version of MLD which is running on this interface. This object is a place holder to allow for new versions of MLD to be introduced. Version 1 of MLD is defined in RFC 2710.')
mldInfoInterfaceQuerierStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 22, 4, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mldInfoInterfaceQuerierStatus.setStatus('current')
if mibBuilder.loadTexts: mldInfoInterfaceQuerierStatus.setDescription('Specifies if the switch is Querier or not')
mldInfoInterfaceQuerier = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 22, 4, 1, 5), InetAddressIPv6()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mldInfoInterfaceQuerier.setStatus('current')
if mibBuilder.loadTexts: mldInfoInterfaceQuerier.setDescription('The address of the MLD Querier on the IPv6 subnet to which this interface is attached. Its address MUST be of format:2x:2x:2x:2x:2x:2x:2x:2x')
mldInfoInterfaceQuerierExpiryTime = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 22, 4, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mldInfoInterfaceQuerierExpiryTime.setStatus('current')
if mibBuilder.loadTexts: mldInfoInterfaceQuerierExpiryTime.setDescription('The time remaining before the Other Querier Present Timer expires. If the local system is the querier, the value of this object is zero.')
mldInfoInterfaceQuerierPort = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 22, 4, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mldInfoInterfaceQuerierPort.setStatus('current')
if mibBuilder.loadTexts: mldInfoInterfaceQuerierPort.setDescription('The port on which the Querier is learnt. If the local system is the querier, the value of this object is zero.')
mldInfoInterfaceGroups = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 22, 4, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mldInfoInterfaceGroups.setStatus('current')
if mibBuilder.loadTexts: mldInfoInterfaceGroups.setDescription('The current number of entries for this interface in the Cache Table.')
arpInfoTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 2, 1), )
if mibBuilder.loadTexts: arpInfoTable.setStatus('current')
if mibBuilder.loadTexts: arpInfoTable.setDescription('The table of ARP entries.')
arpInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 2, 1, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "arpInfoDestIp"))
if mibBuilder.loadTexts: arpInfoEntry.setStatus('current')
if mibBuilder.loadTexts: arpInfoEntry.setDescription('A row in the ARP table')
arpInfoDestIp = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 2, 1, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: arpInfoDestIp.setStatus('current')
if mibBuilder.loadTexts: arpInfoDestIp.setDescription('The destination IP address of the ARP entry.')
arpInfoMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 2, 1, 1, 2), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: arpInfoMacAddr.setStatus('current')
if mibBuilder.loadTexts: arpInfoMacAddr.setDescription('The MAC address for the ARP entry.')
arpInfoVLAN = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 2, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: arpInfoVLAN.setStatus('current')
if mibBuilder.loadTexts: arpInfoVLAN.setDescription('The VLAN identifier for the ARP entry.')
arpInfoSrcPort = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 2, 1, 1, 4), PortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: arpInfoSrcPort.setStatus('current')
if mibBuilder.loadTexts: arpInfoSrcPort.setDescription("The port number on which this entry's equivalence is effective.")
arpInfoFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("clear", 1), ("unresolved", 2), ("permanent", 3), ("indirect", 4), ("layer4", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: arpInfoFlag.setStatus('current')
if mibBuilder.loadTexts: arpInfoFlag.setDescription('The flag associated with this ARP entry.')
arpCacheClear = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("clear", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: arpCacheClear.setStatus('current')
if mibBuilder.loadTexts: arpCacheClear.setDescription('Setting this value to clear(2) clears the ARP cache.')
vrrpInfoVirtRtrTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 3, 1), )
if mibBuilder.loadTexts: vrrpInfoVirtRtrTable.setStatus('current')
if mibBuilder.loadTexts: vrrpInfoVirtRtrTable.setDescription('The table of VRRP virtual router run-time information.')
vrrpInfoVirtGroupState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 3, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpInfoVirtGroupState.setStatus('current')
if mibBuilder.loadTexts: vrrpInfoVirtGroupState.setDescription('VRRP group state.')
vrrpInfoVirtGroupPriority = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 3, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpInfoVirtGroupPriority.setStatus('current')
if mibBuilder.loadTexts: vrrpInfoVirtGroupPriority.setDescription('VRRP group priority.')
vrrpInfoVirtRtrTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 3, 1, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "vrrpInfoVirtRtrIndex"))
if mibBuilder.loadTexts: vrrpInfoVirtRtrTableEntry.setStatus('current')
if mibBuilder.loadTexts: vrrpInfoVirtRtrTableEntry.setDescription('The run-time information about a VRRP virtual router.')
vrrpInfoVirtRtrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpInfoVirtRtrIndex.setStatus('current')
if mibBuilder.loadTexts: vrrpInfoVirtRtrIndex.setDescription('The VRRP virtual router index.')
vrrpInfoVirtRtrState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("init", 1), ("master", 2), ("backup", 3), ("holdoff", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpInfoVirtRtrState.setStatus('current')
if mibBuilder.loadTexts: vrrpInfoVirtRtrState.setDescription('The VRRP virtual router state.')
vrrpInfoVirtRtrOwnership = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("owner", 1), ("renter", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpInfoVirtRtrOwnership.setStatus('current')
if mibBuilder.loadTexts: vrrpInfoVirtRtrOwnership.setDescription('The VRRP virtual router ownership status.')
vrrpInfoVirtRtrConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpInfoVirtRtrConfig.setStatus('current')
if mibBuilder.loadTexts: vrrpInfoVirtRtrConfig.setDescription('The status of the VRRP virtual router.')
vrrpInfoVirtRtrID = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpInfoVirtRtrID.setStatus('current')
if mibBuilder.loadTexts: vrrpInfoVirtRtrID.setDescription('The VRRP virtual router identifier.')
vrrpInfoVirtRtrAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 3, 1, 1, 6), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpInfoVirtRtrAddr.setStatus('current')
if mibBuilder.loadTexts: vrrpInfoVirtRtrAddr.setDescription('The VRRP virtual router IP address.')
vrrpInfoVirtRtrIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 3, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpInfoVirtRtrIfIndex.setStatus('current')
if mibBuilder.loadTexts: vrrpInfoVirtRtrIfIndex.setDescription('The IfIndex that the VRRP virtual router is representing.')
vrrpInfoVirtRtrPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 3, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 254))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpInfoVirtRtrPriority.setStatus('current')
if mibBuilder.loadTexts: vrrpInfoVirtRtrPriority.setDescription('The priority value to be used by the specified VRRP virtual routers.')
ospfGeneralInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 1))
ospfStartTime = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 1, 1), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfStartTime.setStatus('current')
if mibBuilder.loadTexts: ospfStartTime.setDescription('The time when ospf has been started.')
ospfProcessUptime = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 1, 2), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfProcessUptime.setStatus('current')
if mibBuilder.loadTexts: ospfProcessUptime.setDescription('The time since ospf has been started.')
ospfLsTypesSupported = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfLsTypesSupported.setStatus('current')
if mibBuilder.loadTexts: ospfLsTypesSupported.setDescription('The Link State Types that are supported.')
ospfIntfCountForRouter = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfCountForRouter.setStatus('current')
if mibBuilder.loadTexts: ospfIntfCountForRouter.setDescription('The number of interfaces for this router.')
ospfVlinkCountForRouter = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfVlinkCountForRouter.setStatus('current')
if mibBuilder.loadTexts: ospfVlinkCountForRouter.setDescription('The number of virtual links for this router.')
ospfTotalNeighbours = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfTotalNeighbours.setStatus('current')
if mibBuilder.loadTexts: ospfTotalNeighbours.setDescription('The total number of OSPF neighbours.')
ospfNbrInInitState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfNbrInInitState.setStatus('current')
if mibBuilder.loadTexts: ospfNbrInInitState.setDescription('The number of neighbours in the initial state of exchange.')
ospfNbrInExchState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfNbrInExchState.setStatus('current')
if mibBuilder.loadTexts: ospfNbrInExchState.setDescription('The number of neighbours in the exchange state.')
ospfNbrInFullState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfNbrInFullState.setStatus('current')
if mibBuilder.loadTexts: ospfNbrInFullState.setDescription('The number of neighbours in the Full state of exchange.')
ospfTotalAreas = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfTotalAreas.setStatus('current')
if mibBuilder.loadTexts: ospfTotalAreas.setDescription('The Total number of areas.')
ospfTotalTransitAreas = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfTotalTransitAreas.setStatus('current')
if mibBuilder.loadTexts: ospfTotalTransitAreas.setDescription('The Total number of Transit areas.')
ospfTotalNssaAreas = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfTotalNssaAreas.setStatus('current')
if mibBuilder.loadTexts: ospfTotalNssaAreas.setDescription('The Total number of NSSA areas.')
ospfTotalStubAreas = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfTotalStubAreas.setStatus('current')
if mibBuilder.loadTexts: ospfTotalStubAreas.setDescription('The Total number of STUB areas.')
ospfAreaInfoTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 2), )
if mibBuilder.loadTexts: ospfAreaInfoTable.setStatus('current')
if mibBuilder.loadTexts: ospfAreaInfoTable.setDescription('The table of OSPF Area information.')
ospfAreaInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 2, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ospfAreaInfoIndex"))
if mibBuilder.loadTexts: ospfAreaInfoEntry.setStatus('current')
if mibBuilder.loadTexts: ospfAreaInfoEntry.setDescription('Information about a OSPF area.')
ospfAreaInfoIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaInfoIndex.setStatus('current')
if mibBuilder.loadTexts: ospfAreaInfoIndex.setDescription('The OSPF area number for which the OSPF info table is related.')
ospfAreaInfoId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 2, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaInfoId.setStatus('current')
if mibBuilder.loadTexts: ospfAreaInfoId.setDescription('The IP address of the OSPF area.')
ospfTotalNumberOfInterfaces = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfTotalNumberOfInterfaces.setStatus('current')
if mibBuilder.loadTexts: ospfTotalNumberOfInterfaces.setDescription('The total number of interfaces for this OSPF area.')
ospfNumberOfInterfacesUp = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfNumberOfInterfacesUp.setStatus('current')
if mibBuilder.loadTexts: ospfNumberOfInterfacesUp.setDescription('The number of interfaces UP in area.')
ospfNumberOfLsdbEntries = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfNumberOfLsdbEntries.setStatus('current')
if mibBuilder.loadTexts: ospfNumberOfLsdbEntries.setDescription('The number of Link State Database entries for this OSPF area.')
ospfAreaInfoAuthType = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("password", 2), ("md5", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaInfoAuthType.setStatus('current')
if mibBuilder.loadTexts: ospfAreaInfoAuthType.setDescription('Area authentication.')
ospfAreaInfoLsTypesAccepted = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 2, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaInfoLsTypesAccepted.setStatus('current')
if mibBuilder.loadTexts: ospfAreaInfoLsTypesAccepted.setDescription('LS types accepted by this area.')
ospfAreaInfoSPF = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 2, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaInfoSPF.setStatus('current')
if mibBuilder.loadTexts: ospfAreaInfoSPF.setDescription('Number of times SPF algorithm has been executed.')
ospfAreaInfoAreaBorderRouter = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 2, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaInfoAreaBorderRouter.setStatus('current')
if mibBuilder.loadTexts: ospfAreaInfoAreaBorderRouter.setDescription('Count of ABR local to this area.')
ospfAreaInfoASBoundaryRouter = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 2, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaInfoASBoundaryRouter.setStatus('current')
if mibBuilder.loadTexts: ospfAreaInfoASBoundaryRouter.setDescription('Count of ASBR local to this area.')
ospfAreaInfoTotalNeighbours = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 2, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaInfoTotalNeighbours.setStatus('current')
if mibBuilder.loadTexts: ospfAreaInfoTotalNeighbours.setDescription('The total number of OSPF neighbors.')
ospfAreaInfoNeighborsINITstate = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 2, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaInfoNeighborsINITstate.setStatus('current')
if mibBuilder.loadTexts: ospfAreaInfoNeighborsINITstate.setDescription('Total neighbors in INIT state.')
ospfAreaInfoNeighborsEXCHstate = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 2, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaInfoNeighborsEXCHstate.setStatus('current')
if mibBuilder.loadTexts: ospfAreaInfoNeighborsEXCHstate.setDescription('Total neighbors in EXCH state.')
ospfAreaInfoNeighborsFULLstate = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 2, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaInfoNeighborsFULLstate.setStatus('current')
if mibBuilder.loadTexts: ospfAreaInfoNeighborsFULLstate.setDescription('Total neighbors in FULL state.')
ospfIntfInfoTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 3), )
if mibBuilder.loadTexts: ospfIntfInfoTable.setStatus('current')
if mibBuilder.loadTexts: ospfIntfInfoTable.setDescription('The table of OSPF Interface information.')
ospfIntfInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 3, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ospfIfInfoIndex"))
if mibBuilder.loadTexts: ospfIntfInfoEntry.setStatus('current')
if mibBuilder.loadTexts: ospfIntfInfoEntry.setDescription('Information about a OSPF interface.')
ospfIfInfoIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIfInfoIndex.setStatus('current')
if mibBuilder.loadTexts: ospfIfInfoIndex.setDescription('The OSPF interface number for which the OSPF info table is related.')
ospfIfInfoIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 3, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIfInfoIpAddress.setStatus('current')
if mibBuilder.loadTexts: ospfIfInfoIpAddress.setDescription('The IP address of the OSPF interface.')
ospfIfInfoArea = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 5))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIfInfoArea.setStatus('current')
if mibBuilder.loadTexts: ospfIfInfoArea.setDescription('The index of the area that the interface belongs.')
ospfIfInfoAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("down", 0), ("up", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIfInfoAdminStatus.setStatus('current')
if mibBuilder.loadTexts: ospfIfInfoAdminStatus.setDescription('Admin Status of the interface: down(0), up(1).')
ospfIfInfoPassive = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIfInfoPassive.setStatus('current')
if mibBuilder.loadTexts: ospfIfInfoPassive.setDescription('Passive status of the interface: disabled(0), enabled(1).')
ospfIfInfoPtop = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 3, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIfInfoPtop.setStatus('current')
if mibBuilder.loadTexts: ospfIfInfoPtop.setDescription('Point-to-point status of the interface: disabled(0), enabled(1).')
ospfIfInfoRouterIP = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 3, 1, 6), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIfInfoRouterIP.setStatus('current')
if mibBuilder.loadTexts: ospfIfInfoRouterIP.setDescription('The router ID of the switch.')
ospfIfInfoState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("down", 0), ("loopback", 1), ("waiting", 2), ("ptop", 3), ("dr", 4), ("backupdr", 5), ("drother", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIfInfoState.setStatus('current')
if mibBuilder.loadTexts: ospfIfInfoState.setDescription('The state of the interface: Down(0), Loopback(1), Waiting(2), P to P(3), DR(4), BackuDR(5), DR Other(6).')
ospfIfInfoPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 3, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIfInfoPriority.setStatus('current')
if mibBuilder.loadTexts: ospfIfInfoPriority.setDescription('Interface router priority')
ospfIfInfoDesignatedRouterIP = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 3, 1, 9), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIfInfoDesignatedRouterIP.setStatus('current')
if mibBuilder.loadTexts: ospfIfInfoDesignatedRouterIP.setDescription('The OSPF Designated Router IP (IP Address) for this OSPF interface.')
ospfIfInfoDesignatedRouterIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 3, 1, 10), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIfInfoDesignatedRouterIpAddress.setStatus('current')
if mibBuilder.loadTexts: ospfIfInfoDesignatedRouterIpAddress.setDescription('The OSPF Designated Router IP Address for this OSPF interface.')
ospfIfInfoBackupDesignatedRouterIP = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 3, 1, 11), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIfInfoBackupDesignatedRouterIP.setStatus('current')
if mibBuilder.loadTexts: ospfIfInfoBackupDesignatedRouterIP.setDescription('The OSPF Backup Designated Router IP for this OSPF interface.')
ospfIfInfoBackupDesignatedRouterIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 3, 1, 12), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIfInfoBackupDesignatedRouterIpAddress.setStatus('current')
if mibBuilder.loadTexts: ospfIfInfoBackupDesignatedRouterIpAddress.setDescription('The OSPF Backup Designated Router Ip Address for this OSPF interface.')
ospfIfInfoHello = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 3, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIfInfoHello.setStatus('current')
if mibBuilder.loadTexts: ospfIfInfoHello.setDescription('The hello timer for this OSPF interface.')
ospfIfInfoHelloMS = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 3, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("seconds", 0), ("milliseconds", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIfInfoHelloMS.setStatus('current')
if mibBuilder.loadTexts: ospfIfInfoHelloMS.setDescription('Units of time measurement for Hello interval seconds(0), milliseconds(1)')
ospfIfInfoDead = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 3, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIfInfoDead.setStatus('current')
if mibBuilder.loadTexts: ospfIfInfoDead.setDescription('The dead timer for this OSPF interface.')
ospfIfInfoDeadMS = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 3, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("seconds", 0), ("milliseconds", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIfInfoDeadMS.setStatus('current')
if mibBuilder.loadTexts: ospfIfInfoDeadMS.setDescription('Units of time measurement for Dead interval seconds(0), milliseconds(1)')
ospfIfInfoWaitInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 3, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIfInfoWaitInterval.setStatus('current')
if mibBuilder.loadTexts: ospfIfInfoWaitInterval.setDescription('The OSPF Wait interval for this OSPF interface.')
ospfIfInfoWaitIntervalMS = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 3, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("seconds", 0), ("milliseconds", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIfInfoWaitIntervalMS.setStatus('current')
if mibBuilder.loadTexts: ospfIfInfoWaitIntervalMS.setDescription('Units of time measurement for Wait interval seconds(0), milliseconds(1)')
ospfIfInfoRetransmit = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 3, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIfInfoRetransmit.setStatus('current')
if mibBuilder.loadTexts: ospfIfInfoRetransmit.setDescription('The retransmit interval for this OSPF interface.')
ospfIfInfoTransitDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 3, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIfInfoTransitDelay.setStatus('current')
if mibBuilder.loadTexts: ospfIfInfoTransitDelay.setDescription('The transit delay for this OSPF interface.')
ospfIfInfoTotalNeighbours = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 3, 1, 21), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIfInfoTotalNeighbours.setStatus('current')
if mibBuilder.loadTexts: ospfIfInfoTotalNeighbours.setDescription('The Total number of neighbours for this OSPF interface.')
ospfIfInfoEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 3, 1, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIfInfoEvents.setStatus('current')
if mibBuilder.loadTexts: ospfIfInfoEvents.setDescription('The total number of events for this OSPF interface.')
ospfIfInfoAuthType = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 3, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("password", 2), ("md5", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIfInfoAuthType.setStatus('current')
if mibBuilder.loadTexts: ospfIfInfoAuthType.setDescription('Type of authentication being used: none(1) - no authentication, password(2) - use password, md5(3) - use MD5 authentication.')
ospfVirtIntfInfoTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 4), )
if mibBuilder.loadTexts: ospfVirtIntfInfoTable.setStatus('current')
if mibBuilder.loadTexts: ospfVirtIntfInfoTable.setDescription('The table of OSPF virtual interfaces information.')
ospfVirtIntfInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 4, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ospfVirtIntfInfoIndex"))
if mibBuilder.loadTexts: ospfVirtIntfInfoEntry.setStatus('current')
if mibBuilder.loadTexts: ospfVirtIntfInfoEntry.setDescription('Information about an OSPF virtual interface.')
ospfVirtIntfInfoIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfVirtIntfInfoIndex.setStatus('current')
if mibBuilder.loadTexts: ospfVirtIntfInfoIndex.setDescription('The OSPF Virtual Interface number for which this table is related.')
ospfVirtIntfInfoIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 4, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfVirtIntfInfoIpAddr.setStatus('current')
if mibBuilder.loadTexts: ospfVirtIntfInfoIpAddr.setDescription('The IP Address of this virtual interface.')
ospfVirtIntfInfoArea = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 5))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfVirtIntfInfoArea.setStatus('current')
if mibBuilder.loadTexts: ospfVirtIntfInfoArea.setDescription('The index of the OSPF area to which this virtual interface belongs.')
ospfVirtIntfInfoRouterId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 4, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfVirtIntfInfoRouterId.setStatus('current')
if mibBuilder.loadTexts: ospfVirtIntfInfoRouterId.setDescription('The Router ID.')
ospfVirtIntfInfoState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfVirtIntfInfoState.setStatus('current')
if mibBuilder.loadTexts: ospfVirtIntfInfoState.setDescription('State disabled(0), enabled(1)')
ospfVirtIntfInfoCost = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 4, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfVirtIntfInfoCost.setStatus('current')
if mibBuilder.loadTexts: ospfVirtIntfInfoCost.setDescription('The cost of the virtual interface.')
ospfVirtIntfInfoTrans = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 4, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfVirtIntfInfoTrans.setStatus('current')
if mibBuilder.loadTexts: ospfVirtIntfInfoTrans.setDescription('The transit delay for the virtual interface.')
ospfVirtIntfInfoHello = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 4, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfVirtIntfInfoHello.setStatus('current')
if mibBuilder.loadTexts: ospfVirtIntfInfoHello.setDescription('Hello interval.')
ospfVirtIntfInfoHelloMS = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 4, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("seconds", 0), ("milliseconds", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfVirtIntfInfoHelloMS.setStatus('current')
if mibBuilder.loadTexts: ospfVirtIntfInfoHelloMS.setDescription('Units of time measurement for Hello interval seconds(0), milliseconds(1)')
ospfVirtIntfInfoDead = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 4, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfVirtIntfInfoDead.setStatus('current')
if mibBuilder.loadTexts: ospfVirtIntfInfoDead.setDescription('Dead interval.')
ospfVirtIntfInfoDeadMS = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 4, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("seconds", 0), ("milliseconds", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfVirtIntfInfoDeadMS.setStatus('current')
if mibBuilder.loadTexts: ospfVirtIntfInfoDeadMS.setDescription('Units of time measurement for Dead interval seconds(0), milliseconds(1)')
ospfVirtIntfInfoWait = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 4, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfVirtIntfInfoWait.setStatus('current')
if mibBuilder.loadTexts: ospfVirtIntfInfoWait.setDescription('Wait interval.')
ospfVirtIntfInfoWaitMS = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 4, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("seconds", 0), ("milliseconds", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfVirtIntfInfoWaitMS.setStatus('current')
if mibBuilder.loadTexts: ospfVirtIntfInfoWaitMS.setDescription('Units of time measurement for Wait interval seconds(0), milliseconds(1)')
ospfVirtIntfInfoRetra = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 4, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfVirtIntfInfoRetra.setStatus('current')
if mibBuilder.loadTexts: ospfVirtIntfInfoRetra.setDescription('Retransmit interval.')
ospfVirtIntfInfoAuth = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 4, 1, 15), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfVirtIntfInfoAuth.setStatus('current')
if mibBuilder.loadTexts: ospfVirtIntfInfoAuth.setDescription('Authentication.')
ospfVirtIntfInfoEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 4, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfVirtIntfInfoEvents.setStatus('current')
if mibBuilder.loadTexts: ospfVirtIntfInfoEvents.setDescription('Events.')
ospfVirtIntfInfoNbr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 4, 1, 17), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfVirtIntfInfoNbr.setStatus('current')
if mibBuilder.loadTexts: ospfVirtIntfInfoNbr.setDescription('The IP Address of the OSPF neighbor for this virtual interface.')
ospfVirtIntfInfoNbrState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 4, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("down", 0), ("attempt", 1), ("init", 2), ("twoway", 3), ("exstart", 4), ("exchange", 5), ("loading", 6), ("full", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfVirtIntfInfoNbrState.setStatus('current')
if mibBuilder.loadTexts: ospfVirtIntfInfoNbrState.setDescription('State down(0),attempt(1),init(2),2 way(3), exstart(4),exchange(5),loading(6),full(7)')
ospfVirtIntfInfoAreaId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 4, 1, 19), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfVirtIntfInfoAreaId.setStatus('current')
if mibBuilder.loadTexts: ospfVirtIntfInfoAreaId.setDescription('The AreaId of the virtual interface.')
ospfIfNbrTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 5), )
if mibBuilder.loadTexts: ospfIfNbrTable.setStatus('current')
if mibBuilder.loadTexts: ospfIfNbrTable.setDescription('The table of OSPF Interface Neighbor information.')
ospfIfNbrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 5, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ospfIfNbrIntfIndex"), (0, "IBM-GbTOR-10G-L2L3-MIB", "ospfIfNbrIpAddr"))
if mibBuilder.loadTexts: ospfIfNbrEntry.setStatus('current')
if mibBuilder.loadTexts: ospfIfNbrEntry.setDescription('Information about a OSPF interface, neighbor pair.')
ospfIfNbrIntfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIfNbrIntfIndex.setStatus('current')
if mibBuilder.loadTexts: ospfIfNbrIntfIndex.setDescription('The OSPF Interface number for which this Interface/Nbr table is related.')
ospfIfNbrIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 5, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIfNbrIpAddr.setStatus('current')
if mibBuilder.loadTexts: ospfIfNbrIpAddr.setDescription('The OSPF Neighbor ID .')
ospfIfNbrPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 5, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIfNbrPriority.setStatus('current')
if mibBuilder.loadTexts: ospfIfNbrPriority.setDescription('The priority of the OSPF neighbor.')
ospfIfNbrState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 5, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("down", 1), ("attempt", 2), ("init", 3), ("twoway", 4), ("exStart", 5), ("exchange", 6), ("loading", 7), ("full", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIfNbrState.setStatus('current')
if mibBuilder.loadTexts: ospfIfNbrState.setDescription('The state of the OSPF neighbor.')
ospfIfNbrDesignatedRtr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 5, 1, 5), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIfNbrDesignatedRtr.setStatus('current')
if mibBuilder.loadTexts: ospfIfNbrDesignatedRtr.setDescription('The IP Address of the Designated Router for this OSPF Neighbor.')
ospfIfNbrBackupDesignatedRtr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 5, 1, 6), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIfNbrBackupDesignatedRtr.setStatus('current')
if mibBuilder.loadTexts: ospfIfNbrBackupDesignatedRtr.setDescription('The IP Address of the backup designated Router for this OSPF Neighbor.')
ospfIfNbrIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 5, 1, 7), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIfNbrIpAddress.setStatus('current')
if mibBuilder.loadTexts: ospfIfNbrIpAddress.setDescription('The IP Address of the OSPF Neighbor.')
ospfSumRangesInfoTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 6), )
if mibBuilder.loadTexts: ospfSumRangesInfoTable.setStatus('current')
if mibBuilder.loadTexts: ospfSumRangesInfoTable.setDescription('The table of OSPF summary ranges information.')
ospfSumRangesInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 6, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ospfSumRangesInfoIndex"))
if mibBuilder.loadTexts: ospfSumRangesInfoEntry.setStatus('current')
if mibBuilder.loadTexts: ospfSumRangesInfoEntry.setDescription('Summary ranges information.')
ospfSumRangesInfoIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfSumRangesInfoIndex.setStatus('current')
if mibBuilder.loadTexts: ospfSumRangesInfoIndex.setDescription('The OSPF range index for which this table is related.')
ospfSumRangesInfoArea = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 6, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 5))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfSumRangesInfoArea.setStatus('current')
if mibBuilder.loadTexts: ospfSumRangesInfoArea.setDescription('Area.')
ospfSumRangesInfoNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 6, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfSumRangesInfoNetwork.setStatus('current')
if mibBuilder.loadTexts: ospfSumRangesInfoNetwork.setDescription('Network.')
ospfSumRangesInfoMask = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 6, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfSumRangesInfoMask.setStatus('current')
if mibBuilder.loadTexts: ospfSumRangesInfoMask.setDescription('Mask.')
ospfSumRangesInfoAction = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 6, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("propagate", 0), ("hide", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfSumRangesInfoAction.setStatus('current')
if mibBuilder.loadTexts: ospfSumRangesInfoAction.setDescription('Action propagate(0), hide(1)')
ospfSumRangesInfoListType = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 6, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("non-nssa", 0), ("nssa", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfSumRangesInfoListType.setStatus('current')
if mibBuilder.loadTexts: ospfSumRangesInfoListType.setDescription('Summary address list Non-NSSA(0), NSSA(1)')
ospfRoutesInfoTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 7), )
if mibBuilder.loadTexts: ospfRoutesInfoTable.setStatus('current')
if mibBuilder.loadTexts: ospfRoutesInfoTable.setDescription('The table of OSPF routes information.')
ospfRoutesInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 7, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ospfRoutesInfoIndex"))
if mibBuilder.loadTexts: ospfRoutesInfoEntry.setStatus('current')
if mibBuilder.loadTexts: ospfRoutesInfoEntry.setDescription('OSPF routes information.')
ospfRoutesInfoIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 7, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfRoutesInfoIndex.setStatus('current')
if mibBuilder.loadTexts: ospfRoutesInfoIndex.setDescription('The OSPF route table entry index for which this table is related.')
ospfRoutesInfoDestination = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 7, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfRoutesInfoDestination.setStatus('current')
if mibBuilder.loadTexts: ospfRoutesInfoDestination.setDescription('Destination.')
ospfRoutesInfoMask = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 7, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfRoutesInfoMask.setStatus('current')
if mibBuilder.loadTexts: ospfRoutesInfoMask.setDescription('Mask.')
ospfRoutesInfoVia = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 7, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfRoutesInfoVia.setStatus('current')
if mibBuilder.loadTexts: ospfRoutesInfoVia.setDescription('Next hop.')
ospfRoutesInfoType = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 7, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfRoutesInfoType.setStatus('current')
if mibBuilder.loadTexts: ospfRoutesInfoType.setDescription('Route type. Codes: IA - OSPF inter area, N1 - OSPF NSSA external type 1, N2 - OSPF NSSA external type 2 E1 - OSPF external type 1, E2 - OSPF external type 2 * - best')
ospfLsdbInfoTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 8), )
if mibBuilder.loadTexts: ospfLsdbInfoTable.setReference('OSPF Version 2, Section 12 Link State Adver- tisements')
if mibBuilder.loadTexts: ospfLsdbInfoTable.setStatus('current')
if mibBuilder.loadTexts: ospfLsdbInfoTable.setDescription("The OSPF Process's Link State Database.")
ospfLsdbInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 8, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ospfLsdbInfoIndex"))
if mibBuilder.loadTexts: ospfLsdbInfoEntry.setStatus('current')
if mibBuilder.loadTexts: ospfLsdbInfoEntry.setDescription('A single Link State Advertisement.')
ospfLsdbInfoIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 8, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfLsdbInfoIndex.setReference('Private MIBS')
if mibBuilder.loadTexts: ospfLsdbInfoIndex.setStatus('current')
if mibBuilder.loadTexts: ospfLsdbInfoIndex.setDescription('The 32 bit index in the table.')
ospfLsdbInfoAreaId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 8, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfLsdbInfoAreaId.setReference('OSPF Version 2, Appendix C.2 Area parameters')
if mibBuilder.loadTexts: ospfLsdbInfoAreaId.setStatus('current')
if mibBuilder.loadTexts: ospfLsdbInfoAreaId.setDescription('The 32 bit identifier of the Area from which the LSA was received.')
ospfLsdbInfoType = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 8, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("routerLink", 1), ("networkLink", 2), ("summaryLink", 3), ("asSummaryLink", 4), ("asExternalLink", 5), ("multicastLink", 6), ("nssaExternalLink", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfLsdbInfoType.setReference('OSPF Version 2, Appendix A.4.1 The Link State Advertisement header')
if mibBuilder.loadTexts: ospfLsdbInfoType.setStatus('current')
if mibBuilder.loadTexts: ospfLsdbInfoType.setDescription('The type of the link state advertisement. Each link state type has a separate advertise- ment format.')
ospfLsdbInfoLsid = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 8, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfLsdbInfoLsid.setReference('OSPF Version 2, Section 12.1.4 Link State ID')
if mibBuilder.loadTexts: ospfLsdbInfoLsid.setStatus('current')
if mibBuilder.loadTexts: ospfLsdbInfoLsid.setDescription('The Link State ID is an LS Type Specific field containing either a Router ID or an IP Address; it identifies the piece of the routing domain that is being described by the advertisement.')
ospfLsdbInfoRouterId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 8, 1, 5), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfLsdbInfoRouterId.setReference('OSPF Version 2, Appendix C.1 Global parameters')
if mibBuilder.loadTexts: ospfLsdbInfoRouterId.setStatus('current')
if mibBuilder.loadTexts: ospfLsdbInfoRouterId.setDescription('The 32 bit number that uniquely identifies the originating router in the Autonomous System.')
ospfLsdbInfoSequence = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 8, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(10, 10)).setFixedLength(10)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfLsdbInfoSequence.setReference('OSPF Version 2, Section 12.1.6 LS sequence number')
if mibBuilder.loadTexts: ospfLsdbInfoSequence.setStatus('current')
if mibBuilder.loadTexts: ospfLsdbInfoSequence.setDescription('The sequence number field is a signed 32-bit integer. It is used to detect old and dupli- cate link state advertisements. The space of sequence numbers is linearly ordered. The larger the sequence number the more recent the advertisement - displayed here in hexazecimal.')
ospfLsdbInfoAge = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 8, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfLsdbInfoAge.setReference('OSPF Version 2, Section 12.1.1 LS age')
if mibBuilder.loadTexts: ospfLsdbInfoAge.setStatus('current')
if mibBuilder.loadTexts: ospfLsdbInfoAge.setDescription('This field is the age of the link state adver- tisement in seconds.')
ospfLsdbInfoChecksum = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 8, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfLsdbInfoChecksum.setReference('OSPF Version 2, Section 12.1.7 LS checksum')
if mibBuilder.loadTexts: ospfLsdbInfoChecksum.setStatus('current')
if mibBuilder.loadTexts: ospfLsdbInfoChecksum.setDescription("This field is the checksum of the complete contents of the advertisement, excepting the age field. The age field is excepted so that an advertisement's age can be incremented without updating the checksum. The checksum used is the same that is used for ISO connec- tionless datagrams; it is commonly referred to as the Fletcher checksum.")
ospfLsdbInfoAdvertisement = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 8, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(36, 36)).setFixedLength(36)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfLsdbInfoAdvertisement.setReference('OSPF Version 2, Section 12 Link State Adver- tisements')
if mibBuilder.loadTexts: ospfLsdbInfoAdvertisement.setStatus('current')
if mibBuilder.loadTexts: ospfLsdbInfoAdvertisement.setDescription("The entire Link State Advertisement, including its header. When the LSA is invalid, it is message string 'Invalid LSDB'.")
ospfExtLsdbInfoTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 9), )
if mibBuilder.loadTexts: ospfExtLsdbInfoTable.setReference('OSPF Version 2, Section 12 Link State Adver- tisements')
if mibBuilder.loadTexts: ospfExtLsdbInfoTable.setStatus('current')
if mibBuilder.loadTexts: ospfExtLsdbInfoTable.setDescription("The OSPF Process's Links State Database.")
ospfExtLsdbInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 9, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ospfExtLsdbInfoIndex"))
if mibBuilder.loadTexts: ospfExtLsdbInfoEntry.setStatus('current')
if mibBuilder.loadTexts: ospfExtLsdbInfoEntry.setDescription('A single Link State Advertisement.')
ospfExtLsdbInfoIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 9, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfExtLsdbInfoIndex.setReference('Private MIBS')
if mibBuilder.loadTexts: ospfExtLsdbInfoIndex.setStatus('current')
if mibBuilder.loadTexts: ospfExtLsdbInfoIndex.setDescription('The 32 bit index in the table.')
ospfExtLsdbInfoType = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 9, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5))).clone(namedValues=NamedValues(("asExternalLink", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfExtLsdbInfoType.setReference('OSPF Version 2, Appendix A.4.1 The Link State Advertisement header')
if mibBuilder.loadTexts: ospfExtLsdbInfoType.setStatus('current')
if mibBuilder.loadTexts: ospfExtLsdbInfoType.setDescription('The type of the link state advertisement. Each link state type has a separate advertise- ment format.')
ospfExtLsdbInfoLsid = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 9, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfExtLsdbInfoLsid.setReference('OSPF Version 2, Section 12.1.4 Link State ID')
if mibBuilder.loadTexts: ospfExtLsdbInfoLsid.setStatus('current')
if mibBuilder.loadTexts: ospfExtLsdbInfoLsid.setDescription('The Link State ID is an LS Type Specific field containing either a Router ID or an IP Address; it identifies the piece of the routing domain that is being described by the advertisement.')
ospfExtLsdbInfoRouterId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 9, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfExtLsdbInfoRouterId.setReference('OSPF Version 2, Appendix C.1 Global parameters')
if mibBuilder.loadTexts: ospfExtLsdbInfoRouterId.setStatus('current')
if mibBuilder.loadTexts: ospfExtLsdbInfoRouterId.setDescription('The 32 bit number that uniquely identifies the originating router in the Autonomous System.')
ospfExtLsdbInfoSequence = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 9, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(10, 10)).setFixedLength(10)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfExtLsdbInfoSequence.setReference('OSPF Version 2, Section 12.1.6 LS sequence number')
if mibBuilder.loadTexts: ospfExtLsdbInfoSequence.setStatus('current')
if mibBuilder.loadTexts: ospfExtLsdbInfoSequence.setDescription('The sequence number field is a signed 32-bit integer. It is used to detect old and dupli- cate link state advertisements. The space of sequence numbers is linearly ordered. The larger the sequence number the more recent the advertisement - displayed here in hexazecimal.')
ospfExtLsdbInfoAge = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 9, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfExtLsdbInfoAge.setReference('OSPF Version 2, Section 12.1.1 LS age')
if mibBuilder.loadTexts: ospfExtLsdbInfoAge.setStatus('current')
if mibBuilder.loadTexts: ospfExtLsdbInfoAge.setDescription('This field is the age of the link state adver- tisement in seconds.')
ospfExtLsdbInfoChecksum = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 9, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfExtLsdbInfoChecksum.setReference('OSPF Version 2, Section 12.1.7 LS checksum')
if mibBuilder.loadTexts: ospfExtLsdbInfoChecksum.setStatus('current')
if mibBuilder.loadTexts: ospfExtLsdbInfoChecksum.setDescription("This field is the checksum of the complete contents of the advertisement, excepting the age field. The age field is excepted so that an advertisement's age can be incremented without updating the checksum. The checksum used is the same that is used for ISO connec- tionless datagrams; it is commonly referred to as the Fletcher checksum.")
ospfExtLsdbInfoAdvertisement = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 9, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(36, 36)).setFixedLength(36)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfExtLsdbInfoAdvertisement.setReference('OSPF Version 2, Section 12 Link State Adver- tisements')
if mibBuilder.loadTexts: ospfExtLsdbInfoAdvertisement.setStatus('current')
if mibBuilder.loadTexts: ospfExtLsdbInfoAdvertisement.setDescription('The entire Link State Advertisement, including its header.')
ospfLoopIfInfoTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 10), )
if mibBuilder.loadTexts: ospfLoopIfInfoTable.setStatus('current')
if mibBuilder.loadTexts: ospfLoopIfInfoTable.setDescription('The table of OSPF Loopback Interface information.')
ospfLoopIfInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 10, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ospfLoopIfInfoIndex"))
if mibBuilder.loadTexts: ospfLoopIfInfoEntry.setStatus('current')
if mibBuilder.loadTexts: ospfLoopIfInfoEntry.setDescription('Information about a OSPF loopback interface.')
ospfLoopIfInfoIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 10, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfLoopIfInfoIndex.setStatus('current')
if mibBuilder.loadTexts: ospfLoopIfInfoIndex.setDescription('The OSPF loopback interface number for which the OSPF info table is related.')
ospfLoopIfInfoIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 10, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfLoopIfInfoIpAddress.setStatus('current')
if mibBuilder.loadTexts: ospfLoopIfInfoIpAddress.setDescription('The IP address of the OSPF loopback interface.')
ospfLoopIfInfoArea = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 10, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfLoopIfInfoArea.setStatus('current')
if mibBuilder.loadTexts: ospfLoopIfInfoArea.setDescription('The index of the area that the loopback interface belongs.')
ospfLoopIfInfoAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("down", 0), ("up", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfLoopIfInfoAdminStatus.setStatus('current')
if mibBuilder.loadTexts: ospfLoopIfInfoAdminStatus.setDescription('Admin Status of the interface: down(0), up(1).')
ospfLoopIfInfoPassive = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 10, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfLoopIfInfoPassive.setStatus('current')
if mibBuilder.loadTexts: ospfLoopIfInfoPassive.setDescription('Passive status of the interface: disabled(0), enabled(1).')
ospfLoopIfInfoPtop = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 10, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfLoopIfInfoPtop.setStatus('current')
if mibBuilder.loadTexts: ospfLoopIfInfoPtop.setDescription('Point-to-point status of the interface: disabled(0), enabled(1).')
ospfLoopIfInfoRouterIP = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 10, 1, 6), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfLoopIfInfoRouterIP.setStatus('current')
if mibBuilder.loadTexts: ospfLoopIfInfoRouterIP.setDescription('The router ID of the switch.')
ospfLoopIfInfoState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 10, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("down", 0), ("loopback", 1), ("waiting", 2), ("ptop", 3), ("dr", 4), ("backupdr", 5), ("drother", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfLoopIfInfoState.setStatus('current')
if mibBuilder.loadTexts: ospfLoopIfInfoState.setDescription('The state of the interface: Down(0), Loopback(1), Waiting(2), P to P(3), DR(4), BackuDR(5), DR Other(6).')
ospfLoopIfInfoPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 10, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfLoopIfInfoPriority.setStatus('current')
if mibBuilder.loadTexts: ospfLoopIfInfoPriority.setDescription('Interface router priority')
ospfLoopIfInfoDesignatedRouterIP = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 10, 1, 9), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfLoopIfInfoDesignatedRouterIP.setStatus('current')
if mibBuilder.loadTexts: ospfLoopIfInfoDesignatedRouterIP.setDescription('The OSPF Designated Router IP (IP Address) for this OSPF interface.')
ospfLoopIfInfoDesignatedRouterIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 10, 1, 10), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfLoopIfInfoDesignatedRouterIpAddress.setStatus('current')
if mibBuilder.loadTexts: ospfLoopIfInfoDesignatedRouterIpAddress.setDescription('The OSPF Designated Router IP Address for this OSPF interface.')
ospfLoopIfInfoBackupDesignatedRouterIP = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 10, 1, 11), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfLoopIfInfoBackupDesignatedRouterIP.setStatus('current')
if mibBuilder.loadTexts: ospfLoopIfInfoBackupDesignatedRouterIP.setDescription('The OSPF Backup Designated Router IP for this OSPF interface.')
ospfLoopIfInfoBackupDesignatedRouterIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 10, 1, 12), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfLoopIfInfoBackupDesignatedRouterIpAddress.setStatus('current')
if mibBuilder.loadTexts: ospfLoopIfInfoBackupDesignatedRouterIpAddress.setDescription('The OSPF Backup Designated Router Ip Address for this OSPF interface.')
ospfLoopIfInfoHello = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 10, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfLoopIfInfoHello.setStatus('current')
if mibBuilder.loadTexts: ospfLoopIfInfoHello.setDescription('The hello timer for this OSPF interface.')
ospfLoopIfInfoHelloMS = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 10, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("seconds", 0), ("milliseconds", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfLoopIfInfoHelloMS.setStatus('current')
if mibBuilder.loadTexts: ospfLoopIfInfoHelloMS.setDescription('Units of time measurement for Hello interval seconds(0), milliseconds(1)')
ospfLoopIfInfoDead = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 10, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfLoopIfInfoDead.setStatus('current')
if mibBuilder.loadTexts: ospfLoopIfInfoDead.setDescription('The dead timer for this OSPF interface.')
ospfLoopIfInfoDeadMS = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 10, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("seconds", 0), ("milliseconds", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfLoopIfInfoDeadMS.setStatus('current')
if mibBuilder.loadTexts: ospfLoopIfInfoDeadMS.setDescription('Units of time measurement for Dead interval seconds(0), milliseconds(1)')
ospfLoopIfInfoWaitInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 10, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfLoopIfInfoWaitInterval.setStatus('current')
if mibBuilder.loadTexts: ospfLoopIfInfoWaitInterval.setDescription('The OSPF Wait interval for this OSPF interface.')
ospfLoopIfInfoWaitIntervalMS = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 10, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("seconds", 0), ("milliseconds", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfLoopIfInfoWaitIntervalMS.setStatus('current')
if mibBuilder.loadTexts: ospfLoopIfInfoWaitIntervalMS.setDescription('Units of time measurement for Wait interval seconds(0), milliseconds(1)')
ospfLoopIfInfoRetransmit = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 10, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfLoopIfInfoRetransmit.setStatus('current')
if mibBuilder.loadTexts: ospfLoopIfInfoRetransmit.setDescription('The retransmit interval for this OSPF interface.')
ospfLoopIfInfoTransitDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 10, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfLoopIfInfoTransitDelay.setStatus('current')
if mibBuilder.loadTexts: ospfLoopIfInfoTransitDelay.setDescription('The transit delay for this OSPF interface.')
ospfLoopIfInfoTotalNeighbours = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 10, 1, 21), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfLoopIfInfoTotalNeighbours.setStatus('current')
if mibBuilder.loadTexts: ospfLoopIfInfoTotalNeighbours.setDescription('The Total number of neighbours for this OSPF interface.')
ospfLoopIfInfoEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 10, 1, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfLoopIfInfoEvents.setStatus('current')
if mibBuilder.loadTexts: ospfLoopIfInfoEvents.setDescription('The total number of events for this OSPF interface.')
ospfLoopIfInfoAuthType = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 4, 10, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("password", 2), ("md5", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfLoopIfInfoAuthType.setStatus('current')
if mibBuilder.loadTexts: ospfLoopIfInfoAuthType.setDescription('Type of authentication being used: none(1) - no authentication, password(2) - use password, md5(3) - use MD5 authentication.')
ospf3GeneralInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 1))
ospf3Version = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3))).clone(namedValues=NamedValues(("ospfVersion3", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3Version.setStatus('current')
if mibBuilder.loadTexts: ospf3Version.setDescription('OSPF version.')
ospf3RouterID = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3RouterID.setStatus('current')
if mibBuilder.loadTexts: ospf3RouterID.setDescription('The router ID of the switch.')
ospf3StartTime = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3StartTime.setStatus('current')
if mibBuilder.loadTexts: ospf3StartTime.setDescription('The time when ospf has been started.')
ospf3ProcessUptime = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3ProcessUptime.setStatus('current')
if mibBuilder.loadTexts: ospf3ProcessUptime.setDescription('The time since ospf has been started.')
ospf3AreaBorderRouter = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3AreaBorderRouter.setStatus('current')
if mibBuilder.loadTexts: ospf3AreaBorderRouter.setDescription('Area Border Router Role.')
ospf3ASBoundaryRouter = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3ASBoundaryRouter.setStatus('current')
if mibBuilder.loadTexts: ospf3ASBoundaryRouter.setDescription('AS Boundary Router Role.')
ospf3ExternalLsa = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3ExternalLsa.setStatus('current')
if mibBuilder.loadTexts: ospf3ExternalLsa.setDescription('The number of external LSAs.')
ospf3IntfCountForRouter = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IntfCountForRouter.setStatus('current')
if mibBuilder.loadTexts: ospf3IntfCountForRouter.setDescription('The number of interfaces for this router.')
ospf3VlinkCountForRouter = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3VlinkCountForRouter.setStatus('current')
if mibBuilder.loadTexts: ospf3VlinkCountForRouter.setDescription('The number of virtual links for this router.')
ospf3NewLsaReceived = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3NewLsaReceived.setStatus('current')
if mibBuilder.loadTexts: ospf3NewLsaReceived.setDescription('The number of new LSAs reveived.')
ospf3TotalLsaOriginated = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3TotalLsaOriginated.setStatus('current')
if mibBuilder.loadTexts: ospf3TotalLsaOriginated.setDescription('The number of LSAs originated.')
ospf3TotalNumberOfAsScopeLsas = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3TotalNumberOfAsScopeLsas.setStatus('current')
if mibBuilder.loadTexts: ospf3TotalNumberOfAsScopeLsas.setDescription('Total number of entries in the Link State Database.')
ospf3TotalNeighbours = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3TotalNeighbours.setStatus('current')
if mibBuilder.loadTexts: ospf3TotalNeighbours.setDescription('The total number of OSPF neighbours.')
ospf3NbrInXchgOrLoadState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3NbrInXchgOrLoadState.setStatus('current')
if mibBuilder.loadTexts: ospf3NbrInXchgOrLoadState.setDescription('The number of neighbours in the exchange or loading state.')
ospf3TotalAreas = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3TotalAreas.setStatus('current')
if mibBuilder.loadTexts: ospf3TotalAreas.setDescription('The Total number of areas.')
ospf3TotalActiveAreas = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3TotalActiveAreas.setStatus('current')
if mibBuilder.loadTexts: ospf3TotalActiveAreas.setDescription('The Total number of areas containing active interfaces.')
ospf3TotalNssaAreas = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3TotalNssaAreas.setStatus('current')
if mibBuilder.loadTexts: ospf3TotalNssaAreas.setDescription('The Total number of NSSA areas.')
ospf3OverFlowState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2))).clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3OverFlowState.setStatus('current')
if mibBuilder.loadTexts: ospf3OverFlowState.setDescription('Indicates whether router is in overflow state or not.')
ospf3SpfDelay = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(5)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3SpfDelay.setStatus('current')
if mibBuilder.loadTexts: ospf3SpfDelay.setDescription(' The Delay at which routing calculation is carried after a topology change.')
ospf3SpfHoldTime = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(10)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3SpfHoldTime.setStatus('current')
if mibBuilder.loadTexts: ospf3SpfHoldTime.setDescription(' The minimum time between two consecutive SPF calculations.')
ospf3ABRType = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("standardABR", 1), ("ciscoABR", 2), ("ibmABR", 3))).clone('standardABR')).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3ABRType.setReference('RFC-3509 -- Alternative Implementations of OSPF Area Border Routers')
if mibBuilder.loadTexts: ospf3ABRType.setStatus('current')
if mibBuilder.loadTexts: ospf3ABRType.setDescription('Different Types of ABRs supported')
ospf3NssaAsbrDefRtTrans = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3NssaAsbrDefRtTrans.setStatus('current')
if mibBuilder.loadTexts: ospf3NssaAsbrDefRtTrans.setDescription('Specifies the P-Bit setting for the default Type-7 LSA generated by ASBR(which is not ABR).When disabled, P-Bit is clear in the generated default Lsa. When enabled, P-Bit is set in the generated Type-7 default Lsa. ')
ospf3AreaInfoTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 2), )
if mibBuilder.loadTexts: ospf3AreaInfoTable.setStatus('current')
if mibBuilder.loadTexts: ospf3AreaInfoTable.setDescription('The table of OSPFv3 Area information.')
ospf3AreaInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 2, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ospf3AreaInfoIndex"))
if mibBuilder.loadTexts: ospf3AreaInfoEntry.setStatus('current')
if mibBuilder.loadTexts: ospf3AreaInfoEntry.setDescription('Information about a OSPFv3 area.')
ospf3AreaInfoIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3AreaInfoIndex.setStatus('current')
if mibBuilder.loadTexts: ospf3AreaInfoIndex.setDescription('The OSPFv3 area number for which the OSPFv3 info table is related.')
ospf3AreaInfoId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 2, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3AreaInfoId.setStatus('current')
if mibBuilder.loadTexts: ospf3AreaInfoId.setDescription('The IP address of the OSPFv3 area.')
ospf3AreaInfoStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("active", 1), ("notInService", 2), ("notReady", 3), ("createAndGo", 4), ("createAndWait", 5), ("destroy", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3AreaInfoStatus.setStatus('current')
if mibBuilder.loadTexts: ospf3AreaInfoStatus.setDescription('Area Status: active(1), notInService(2), notReady(3).')
ospf3TotalNumberOfInterfaces = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3TotalNumberOfInterfaces.setStatus('current')
if mibBuilder.loadTexts: ospf3TotalNumberOfInterfaces.setDescription('The total number of interfaces for this OSPFv3 area.')
ospf3NumberOfInterfacesUp = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3NumberOfInterfacesUp.setStatus('current')
if mibBuilder.loadTexts: ospf3NumberOfInterfacesUp.setDescription('The number of interfaces UP in area.')
ospf3AreaInfoSPF = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3AreaInfoSPF.setStatus('current')
if mibBuilder.loadTexts: ospf3AreaInfoSPF.setDescription('The number of times SPF ran.')
ospf3NumberOfLsdbEntries = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3NumberOfLsdbEntries.setStatus('current')
if mibBuilder.loadTexts: ospf3NumberOfLsdbEntries.setDescription("The total number of Area-scope link state advertisements in this area's link state database.")
ospf3AreaInfoAreaBorderRouter = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 2, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3AreaInfoAreaBorderRouter.setStatus('current')
if mibBuilder.loadTexts: ospf3AreaInfoAreaBorderRouter.setDescription('The Area Border Router count.')
ospf3AreaInfoASBoundaryRouter = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 2, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3AreaInfoASBoundaryRouter.setStatus('current')
if mibBuilder.loadTexts: ospf3AreaInfoASBoundaryRouter.setDescription('The AS Boundary Router count.')
ospf3AreaInfoNeighborsFULLstate = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 2, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3AreaInfoNeighborsFULLstate.setStatus('current')
if mibBuilder.loadTexts: ospf3AreaInfoNeighborsFULLstate.setDescription('Total neighbors in FULL state.')
ospf3AreaInfoVirtNeighborsFULLstate = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 2, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3AreaInfoVirtNeighborsFULLstate.setStatus('current')
if mibBuilder.loadTexts: ospf3AreaInfoVirtNeighborsFULLstate.setDescription('Total neighbors in FULL state.')
ospf3IntfInfoTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 3), )
if mibBuilder.loadTexts: ospf3IntfInfoTable.setStatus('current')
if mibBuilder.loadTexts: ospf3IntfInfoTable.setDescription('The table of OSPFv3 Interface information.')
ospf3IntfInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 3, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ospf3IfInfoIndex"))
if mibBuilder.loadTexts: ospf3IntfInfoEntry.setStatus('current')
if mibBuilder.loadTexts: ospf3IntfInfoEntry.setDescription('Information about a OSPFv3 interface.')
ospf3IfInfoIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IfInfoIndex.setStatus('current')
if mibBuilder.loadTexts: ospf3IfInfoIndex.setDescription('The OSPFv3 interface number for which the OSPFv3 info table is related.')
ospf3IfInfoInstanceID = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 3, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IfInfoInstanceID.setStatus('current')
if mibBuilder.loadTexts: ospf3IfInfoInstanceID.setDescription('The OSPFv3 interface instance id.')
ospf3IfInfoLLocalAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 3, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IfInfoLLocalAddress.setStatus('current')
if mibBuilder.loadTexts: ospf3IfInfoLLocalAddress.setDescription('The IP address of the OSPFv3 interface.')
ospf3IfInfoAreaID = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 3, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IfInfoAreaID.setStatus('current')
if mibBuilder.loadTexts: ospf3IfInfoAreaID.setDescription('The AreaID of the area that the interface belongs.')
ospf3IfInfoAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("down", 0), ("up", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IfInfoAdminStatus.setStatus('current')
if mibBuilder.loadTexts: ospf3IfInfoAdminStatus.setDescription('Admin Status of the interface: down(0), up(1).')
ospf3IfInfoPassive = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IfInfoPassive.setStatus('current')
if mibBuilder.loadTexts: ospf3IfInfoPassive.setDescription('Passive status of the interface: disabled(0), enabled(1).')
ospf3IfInfoNetworkType = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 5))).clone(namedValues=NamedValues(("broadcast", 1), ("nbma", 2), ("pointToPoint", 3), ("pointToMultipoint", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IfInfoNetworkType.setStatus('current')
if mibBuilder.loadTexts: ospf3IfInfoNetworkType.setDescription('Network type of the interface: broadcast(1),nbma(2),pointToPoint(3),pointToMultipoint(5).')
ospf3IfInfoState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("down", 1), ("loopback", 2), ("waiting", 3), ("pointToPoint", 4), ("designatedRouter", 5), ("backupDesignatedRouter", 6), ("otherDesignatedRouter", 7), ("standby", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IfInfoState.setStatus('current')
if mibBuilder.loadTexts: ospf3IfInfoState.setDescription('The state of the interface: Down(0), Loopback(1), Waiting(2), P to P(3), DR(4), BackuDR(5), DR Other(6).')
ospf3IfInfoPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 3, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IfInfoPriority.setStatus('current')
if mibBuilder.loadTexts: ospf3IfInfoPriority.setDescription('Interface router priority')
ospf3IfInfoDesignatedRouterID = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 3, 1, 10), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IfInfoDesignatedRouterID.setStatus('current')
if mibBuilder.loadTexts: ospf3IfInfoDesignatedRouterID.setDescription('The OSPFv3 Designated Router ID for this OSPFv3 interface.')
ospf3IfInfoBackupDesignatedRouterID = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 3, 1, 11), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IfInfoBackupDesignatedRouterID.setStatus('current')
if mibBuilder.loadTexts: ospf3IfInfoBackupDesignatedRouterID.setDescription('The OSPFv3 Backup Designated Router ID for this OSPFv3 interface.')
ospf3IfInfoHello = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 3, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IfInfoHello.setStatus('current')
if mibBuilder.loadTexts: ospf3IfInfoHello.setDescription('The hello timer for this OSPF3 interface.')
ospf3IfInfoDead = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 3, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IfInfoDead.setStatus('current')
if mibBuilder.loadTexts: ospf3IfInfoDead.setDescription('The dead timer for this OSPFv3 interface.')
ospf3IfInfoPoll = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 3, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IfInfoPoll.setStatus('current')
if mibBuilder.loadTexts: ospf3IfInfoPoll.setDescription('The OSPFv3 Poll interval for this OSPFv3 interface.')
ospf3IfInfoRetransmit = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 3, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IfInfoRetransmit.setStatus('current')
if mibBuilder.loadTexts: ospf3IfInfoRetransmit.setDescription('The retransmit interval for this OSPFv3 interface.')
ospf3IfInfoTransitDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 3, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IfInfoTransitDelay.setStatus('current')
if mibBuilder.loadTexts: ospf3IfInfoTransitDelay.setDescription('The transit delay for this OSPFv3 interface.')
ospf3IfInfoTotalNeighbours = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 3, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IfInfoTotalNeighbours.setStatus('current')
if mibBuilder.loadTexts: ospf3IfInfoTotalNeighbours.setDescription('The total number of neighbours for this OSPFv3 interface.')
ospf3IfInfoEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 3, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IfInfoEvents.setStatus('current')
if mibBuilder.loadTexts: ospf3IfInfoEvents.setDescription('The total number of events for this OSPF3 interface.')
ospf3IfInfoMetricCost = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 3, 1, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IfInfoMetricCost.setStatus('current')
if mibBuilder.loadTexts: ospf3IfInfoMetricCost.setDescription('The cost of this OSPF3 interface.')
ospf3IfInfoAuthSpi = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 3, 1, 20), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(256, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IfInfoAuthSpi.setStatus('current')
if mibBuilder.loadTexts: ospf3IfInfoAuthSpi.setDescription('Authentication Spi Id(256 - 4294967295)')
ospf3IfInfoAuthEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 3, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IfInfoAuthEnable.setStatus('current')
if mibBuilder.loadTexts: ospf3IfInfoAuthEnable.setDescription('Authentication Status disabled(0), enabled(1)')
ospf3IfInfoAuthType = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 3, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2, 1))).clone(namedValues=NamedValues(("none", 0), ("md5", 2), ("sha1", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IfInfoAuthType.setStatus('current')
if mibBuilder.loadTexts: ospf3IfInfoAuthType.setDescription('Authentication Type none(0), md5(2), sha1(1)')
ospf3IfInfoAuthKey = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 3, 1, 23), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IfInfoAuthKey.setStatus('current')
if mibBuilder.loadTexts: ospf3IfInfoAuthKey.setDescription('Authentication Key Hex-string MD5 key - 32 chars (128 bits) Hex-string SHA-1 key - 40 chars (160 bits)')
ospf3IfInfoEncrySpi = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 3, 1, 24), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(256, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IfInfoEncrySpi.setStatus('current')
if mibBuilder.loadTexts: ospf3IfInfoEncrySpi.setDescription('Encryption Spi Id(256 - 4294967295)')
ospf3IfInfoEncryEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 3, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IfInfoEncryEnable.setStatus('current')
if mibBuilder.loadTexts: ospf3IfInfoEncryEnable.setDescription('Encryption Status disabled(0), enabled(1)')
ospf3IfInfoEncryType = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 3, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("null", 0), ("des", 1), ("tripledes", 2), ("aes", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IfInfoEncryType.setStatus('current')
if mibBuilder.loadTexts: ospf3IfInfoEncryType.setDescription('Encryption Authentication Type null(0), des(1), 3des(2), aes(3)')
ospf3IfInfoEncryKey = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 3, 1, 27), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 48))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IfInfoEncryKey.setStatus('current')
if mibBuilder.loadTexts: ospf3IfInfoEncryKey.setDescription('Encryption Key Hex-string DES key - 16 chars (64 bits) Hex-string AES key - 32 chars (128 bits) Hex-string 3DES key - 48 chars (192 bits)')
ospf3IfInfoEncryAuthType = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 3, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2, 1))).clone(namedValues=NamedValues(("none", 0), ("md5", 2), ("sha1", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IfInfoEncryAuthType.setStatus('current')
if mibBuilder.loadTexts: ospf3IfInfoEncryAuthType.setDescription('Encryption Authentication Type none(0), md5(2), sha1(1)')
ospf3IfInfoEncryAuthKey = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 3, 1, 29), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IfInfoEncryAuthKey.setStatus('current')
if mibBuilder.loadTexts: ospf3IfInfoEncryAuthKey.setDescription('Encryption Authentication Key Hex-string MD5 key - 32 chars (128 bits) Hex-string SHA-1 key - 40 chars (160 bits)')
ospf3IfInfoLsaSupress = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 3, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IfInfoLsaSupress.setStatus('current')
if mibBuilder.loadTexts: ospf3IfInfoLsaSupress.setDescription('Lsa supression status of the interface: disabled(0), enabled(1).')
ospf3VirtIntfInfoTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 4), )
if mibBuilder.loadTexts: ospf3VirtIntfInfoTable.setStatus('current')
if mibBuilder.loadTexts: ospf3VirtIntfInfoTable.setDescription('The table of OSPFv3 Virtual Interface information.')
ospf3VirtIntfInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 4, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ospf3VirtIfInfoIndex"))
if mibBuilder.loadTexts: ospf3VirtIntfInfoEntry.setStatus('current')
if mibBuilder.loadTexts: ospf3VirtIntfInfoEntry.setDescription('Information about a single virtual interface.')
ospf3VirtIfInfoIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3VirtIfInfoIndex.setStatus('current')
if mibBuilder.loadTexts: ospf3VirtIfInfoIndex.setDescription('The OSPFv3 virtual interface number for which the OSPFv3 info table is related.')
ospf3VirtIfInfoAreaId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 4, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3VirtIfInfoAreaId.setStatus('current')
if mibBuilder.loadTexts: ospf3VirtIfInfoAreaId.setDescription('The transit area that the virtual link traverses. By definition, this is not Area 0.')
ospf3VirtIfInfoNeighbor = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 4, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3VirtIfInfoNeighbor.setStatus('current')
if mibBuilder.loadTexts: ospf3VirtIfInfoNeighbor.setDescription('The Router ID of the virtual neighbor.')
ospf3VirtIfInfoTransitDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 4, 1, 5), Integer32().clone(1)).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3VirtIfInfoTransitDelay.setStatus('current')
if mibBuilder.loadTexts: ospf3VirtIfInfoTransitDelay.setDescription('The estimated number of seconds it takes to transmit a Link State Update packet over this interface.')
ospf3VirtIfInfoRetransInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 4, 1, 6), Integer32().clone(5)).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3VirtIfInfoRetransInterval.setStatus('current')
if mibBuilder.loadTexts: ospf3VirtIfInfoRetransInterval.setDescription('The number of seconds between link state advertisement retransmissions for adjacencies belonging to this interface. This value is also used when retransmitting database description and Link State Request packets. This value should be well over the expected round-trip time.')
ospf3VirtIfInfoHelloInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 4, 1, 7), Integer32().clone(10)).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3VirtIfInfoHelloInterval.setStatus('current')
if mibBuilder.loadTexts: ospf3VirtIfInfoHelloInterval.setDescription('The length of time, in seconds, between the Hello packets that the router sends on the interface. This value must be the same for the virtual neighbor.')
ospf3VirtIfInfoRtrDeadInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 4, 1, 8), Integer32().clone(60)).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3VirtIfInfoRtrDeadInterval.setStatus('current')
if mibBuilder.loadTexts: ospf3VirtIfInfoRtrDeadInterval.setDescription("The number of seconds that a router's Hello packets have not been seen before its neighbors declare the router down. This should be some multiple of the Hello interval. This value must be the same for the virtual neighbor.")
ospf3VirtIfInfoState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 4, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 4))).clone(namedValues=NamedValues(("down", 1), ("pointToPoint", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3VirtIfInfoState.setStatus('current')
if mibBuilder.loadTexts: ospf3VirtIfInfoState.setDescription('OSPF virtual interface states.')
ospf3VirtIfInfoEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 4, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3VirtIfInfoEvents.setStatus('current')
if mibBuilder.loadTexts: ospf3VirtIfInfoEvents.setDescription('The number of state changes or error events on this virtual link. Discontinuities in the value of this counter can occur at re-initialization of the management system and at other times as indicated by the value of ospfv3DiscontinuityTime.')
ospf3VirtIfInfoStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 4, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3VirtIfInfoStatus.setStatus('current')
if mibBuilder.loadTexts: ospf3VirtIfInfoStatus.setDescription('This object permits management of the table by facilitating actions such as row creation, construction, and destruction. The value of this object has no effect on whether other objects in this conceptual row can be modified.')
ospf3VirtIfInfoLinkScopeLsaCount = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 4, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3VirtIfInfoLinkScopeLsaCount.setStatus('current')
if mibBuilder.loadTexts: ospf3VirtIfInfoLinkScopeLsaCount.setDescription("The total number of Link-scope link state advertisements in this virtual link's link state database.")
ospf3VirtIfInfoLinkLsaCksumSum = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 4, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3VirtIfInfoLinkLsaCksumSum.setStatus('current')
if mibBuilder.loadTexts: ospf3VirtIfInfoLinkLsaCksumSum.setDescription("The 32-bit unsigned sum of the Link-scope link state advertisements' LS checksums contained in this virtual link's link state database. The sum can be used to determine if there has been a change in a router's link state database or to compare the link state database of two routers.")
ospf3IfNbrTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 5), )
if mibBuilder.loadTexts: ospf3IfNbrTable.setStatus('current')
if mibBuilder.loadTexts: ospf3IfNbrTable.setDescription('The table of OSPFv3 Interface Neighbor information.')
ospf3IfNbrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 5, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ospf3IfNbrInfoIndex"))
if mibBuilder.loadTexts: ospf3IfNbrEntry.setStatus('current')
if mibBuilder.loadTexts: ospf3IfNbrEntry.setDescription('Information about a OSPFv3 interface, neighbor pair.')
ospf3IfNbrInfoIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IfNbrInfoIndex.setStatus('current')
if mibBuilder.loadTexts: ospf3IfNbrInfoIndex.setDescription('The OSPFv3 neighbor table entry index for which this table is related.')
ospf3IfNbrIntfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 5, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IfNbrIntfIndex.setStatus('current')
if mibBuilder.loadTexts: ospf3IfNbrIntfIndex.setDescription('The OSPFv3 Interface number for which this Nbr table is related.')
ospf3IfNbrIntfInstanceID = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 5, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IfNbrIntfInstanceID.setStatus('current')
if mibBuilder.loadTexts: ospf3IfNbrIntfInstanceID.setDescription('The OSPFv3 Interface instance id for which this Nbr table is related.')
ospf3IfNbrRtrID = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 5, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IfNbrRtrID.setStatus('current')
if mibBuilder.loadTexts: ospf3IfNbrRtrID.setDescription('A 32-bit unsigned integer uniquely identifying the neighboring router in the Autonomous System.')
ospf3IfNbrIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 5, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IfNbrIpAddress.setStatus('current')
if mibBuilder.loadTexts: ospf3IfNbrIpAddress.setDescription('The IPv6 address of the neighbor associated with the local link.')
ospf3IfNbrPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 5, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IfNbrPriority.setStatus('current')
if mibBuilder.loadTexts: ospf3IfNbrPriority.setDescription('The priority of the OSPFv3 neighbor.')
ospf3IfNbrState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 5, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("down", 1), ("attempt", 2), ("init", 3), ("twoWay", 4), ("exchangeStart", 5), ("exchange", 6), ("loading", 7), ("full", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IfNbrState.setStatus('current')
if mibBuilder.loadTexts: ospf3IfNbrState.setDescription('The state of the relationship with this neighbor.')
ospf3IfNbrEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 5, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3IfNbrEvents.setStatus('current')
if mibBuilder.loadTexts: ospf3IfNbrEvents.setDescription('The number of times this neighbor relationship has changed state or an error has occurred.')
ospf3RoutesInfoTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 6), )
if mibBuilder.loadTexts: ospf3RoutesInfoTable.setStatus('current')
if mibBuilder.loadTexts: ospf3RoutesInfoTable.setDescription('The table of OSPFv3 routes information.')
ospf3RoutesInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 6, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ospf3RoutesInfoIndex"))
if mibBuilder.loadTexts: ospf3RoutesInfoEntry.setStatus('current')
if mibBuilder.loadTexts: ospf3RoutesInfoEntry.setDescription('OSPFv3 routes information.')
ospf3RoutesInfoIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3RoutesInfoIndex.setStatus('current')
if mibBuilder.loadTexts: ospf3RoutesInfoIndex.setDescription('The OSPFv3 route table entry index for which this table is related.')
ospf3RoutesInfoDestination = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 6, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3RoutesInfoDestination.setStatus('current')
if mibBuilder.loadTexts: ospf3RoutesInfoDestination.setDescription(' The Destination IPv6 Address of this route.')
ospf3RoutesInfoPrefixLen = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 6, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3RoutesInfoPrefixLen.setStatus('current')
if mibBuilder.loadTexts: ospf3RoutesInfoPrefixLen.setDescription(' Indicates the prefix length of the destination Address.')
ospf3RoutesInfoNextHop = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 6, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3RoutesInfoNextHop.setStatus('current')
if mibBuilder.loadTexts: ospf3RoutesInfoNextHop.setDescription('Next Hop IPv6 Address for this route. For direct routes it has the value ::0.')
ospf3RoutesInfoType = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 6, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("intraArea", 1), ("interArea", 2), ("type1External", 3), ("type2External", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3RoutesInfoType.setStatus('current')
if mibBuilder.loadTexts: ospf3RoutesInfoType.setDescription('Type of the route')
ospf3RoutesInfoAreaId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 6, 1, 6), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3RoutesInfoAreaId.setStatus('current')
if mibBuilder.loadTexts: ospf3RoutesInfoAreaId.setDescription(' Area ID associated with the route ')
ospf3RoutesInfoCost = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 6, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3RoutesInfoCost.setStatus('current')
if mibBuilder.loadTexts: ospf3RoutesInfoCost.setDescription(' It is a Type 1 external metrics which is expressed in the same units as OSPF interface cost ie. in terms of the OSPF link state metric. If Type1 and Type2 cost are present, Type1 external metrics always take precedence.')
ospf3RoutesInfoType2Cost = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 6, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3RoutesInfoType2Cost.setStatus('current')
if mibBuilder.loadTexts: ospf3RoutesInfoType2Cost.setDescription(' Type 2 external metrics are configured with the cost greater than any path internal to the AS. Use of Type 2 external metrics assumes that routing between AS is the major cost of routing a packet, and eliminates the need for conversion of external costs to internal link state metrics.')
ospf3RoutesInfoInterfaceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 18, 6, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospf3RoutesInfoInterfaceIndex.setStatus('current')
if mibBuilder.loadTexts: ospf3RoutesInfoInterfaceIndex.setDescription(' Interface Index associated with the route')
gatewayInfoTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 5, 1), )
if mibBuilder.loadTexts: gatewayInfoTable.setStatus('current')
if mibBuilder.loadTexts: gatewayInfoTable.setDescription('The table containing information for the default gateways.')
gatewayInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 5, 1, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "gatewayInfoIndex"))
if mibBuilder.loadTexts: gatewayInfoEntry.setStatus('current')
if mibBuilder.loadTexts: gatewayInfoEntry.setDescription('A row in the gateway information table')
gatewayInfoIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 5, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gatewayInfoIndex.setStatus('current')
if mibBuilder.loadTexts: gatewayInfoIndex.setDescription('The gateway number for which the information is related.')
gatewayInfoAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 5, 1, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gatewayInfoAddr.setStatus('current')
if mibBuilder.loadTexts: gatewayInfoAddr.setDescription('The IP address of the default gateway.')
gatewayInfoStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 5, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("failed", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gatewayInfoStatus.setStatus('current')
if mibBuilder.loadTexts: gatewayInfoStatus.setDescription('The status of the default gateway.')
ipInfoBootpRelayState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 8, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("enabled", 2), ("disabled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipInfoBootpRelayState.setStatus('current')
if mibBuilder.loadTexts: ipInfoBootpRelayState.setDescription('The state of BOOTP relay.')
ipInfoBootpRelayAddr = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 8, 5), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipInfoBootpRelayAddr.setStatus('current')
if mibBuilder.loadTexts: ipInfoBootpRelayAddr.setDescription('The IP address of BOOTP server.')
ipInfoBootpRelayAddr2 = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 8, 6), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipInfoBootpRelayAddr2.setStatus('current')
if mibBuilder.loadTexts: ipInfoBootpRelayAddr2.setDescription('The IP address of second BOOTP server.')
ipInfoFwdState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 8, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipInfoFwdState.setStatus('current')
if mibBuilder.loadTexts: ipInfoFwdState.setDescription('IP forwarding global state.')
ipInfoFwdDirectedBcast = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 8, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("enabled", 2), ("disabled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipInfoFwdDirectedBcast.setStatus('current')
if mibBuilder.loadTexts: ipInfoFwdDirectedBcast.setDescription('The state of forwarding directed broadcasts.')
igmpInfoTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 6, 1), )
if mibBuilder.loadTexts: igmpInfoTable.setStatus('current')
if mibBuilder.loadTexts: igmpInfoTable.setDescription('The table of IGMP group membership information.')
igmpInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 6, 1, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "igmpInfoIndex"))
if mibBuilder.loadTexts: igmpInfoEntry.setStatus('current')
if mibBuilder.loadTexts: igmpInfoEntry.setDescription('Information about an IGMP group member .')
igmpInfoIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 6, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpInfoIndex.setStatus('current')
if mibBuilder.loadTexts: igmpInfoIndex.setDescription('The igmp group number for which the IGMP info table is related.')
igmpInfoGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 6, 1, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpInfoGroupId.setStatus('current')
if mibBuilder.loadTexts: igmpInfoGroupId.setDescription('The IP address of the IGMP group.')
igmpInfoVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 6, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpInfoVlanId.setStatus('current')
if mibBuilder.loadTexts: igmpInfoVlanId.setDescription('The VLAN ID for this IGMP group.')
igmpInfoSrcTrunk = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 6, 1, 1, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpInfoSrcTrunk.setStatus('current')
if mibBuilder.loadTexts: igmpInfoSrcTrunk.setDescription('The downstream trunk number.')
igmpInfoSrcPort = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 6, 1, 1, 5), PortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpInfoSrcPort.setStatus('current')
if mibBuilder.loadTexts: igmpInfoSrcPort.setDescription('The downstream port number.')
igmpInfoVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 6, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("v3", 1), ("v2", 2), ("v1", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpInfoVersion.setStatus('current')
if mibBuilder.loadTexts: igmpInfoVersion.setDescription('The Version of IGMP host.')
igmpInfoExpires = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 6, 1, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpInfoExpires.setStatus('current')
if mibBuilder.loadTexts: igmpInfoExpires.setDescription('The expiration time for this host.')
igmpInfoMode = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 6, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("exclude", 1), ("include", 2), ("na", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpInfoMode.setStatus('current')
if mibBuilder.loadTexts: igmpInfoMode.setDescription('The IGMPv3 filter-mode for this host. Returned values: exclude(1) - the IGMPv3 filter-mode is exclude. include(2) - the IGMPv3 filter-mode is include. na(3) - not applicable(v1 and v2).')
igmpInfoSourceIp = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 6, 1, 1, 9), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpInfoSourceIp.setStatus('current')
if mibBuilder.loadTexts: igmpInfoSourceIp.setDescription('The source IP address of the IGMP group.')
igmpInfoFwd = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 6, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpInfoFwd.setStatus('current')
if mibBuilder.loadTexts: igmpInfoFwd.setDescription('The IGMPv3 forwarding for this source/group IP for this host.')
igmpInfoGrpExpires = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 6, 1, 1, 11), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpInfoGrpExpires.setStatus('current')
if mibBuilder.loadTexts: igmpInfoGrpExpires.setDescription('The expiration time for the group.')
igmpMrtrInfoTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 6, 2), )
if mibBuilder.loadTexts: igmpMrtrInfoTable.setStatus('current')
if mibBuilder.loadTexts: igmpMrtrInfoTable.setDescription('The table of IGMP mrouters.')
igmpMrtrInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 6, 2, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "igmpMrtrInfoIndex"))
if mibBuilder.loadTexts: igmpMrtrInfoEntry.setStatus('current')
if mibBuilder.loadTexts: igmpMrtrInfoEntry.setDescription('Information about an IGMP mrouter.')
igmpMrtrInfoIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 6, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpMrtrInfoIndex.setStatus('current')
if mibBuilder.loadTexts: igmpMrtrInfoIndex.setDescription('The mrouter number for which the IGMP mrouter info table is related.')
igmpMrtrInfoVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 6, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpMrtrInfoVlanId.setStatus('current')
if mibBuilder.loadTexts: igmpMrtrInfoVlanId.setDescription('The VLAN ID on which this IGMP mrouter is attached.')
igmpMrtrInfoPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 6, 2, 1, 3), PortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpMrtrInfoPortId.setStatus('current')
if mibBuilder.loadTexts: igmpMrtrInfoPortId.setDescription('The port on which this IGMP mrouter is attached.')
igmpMrtrInfoVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 6, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("v1", 1), ("v2", 2), ("v3", 3), ("pim", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpMrtrInfoVersion.setStatus('current')
if mibBuilder.loadTexts: igmpMrtrInfoVersion.setDescription('The version of this IGMP mrouter.')
igmpMrtrInfoExpires = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 6, 2, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpMrtrInfoExpires.setStatus('current')
if mibBuilder.loadTexts: igmpMrtrInfoExpires.setDescription('The expiration time for this mrouter.')
igmpMrtrInfoMrt = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 6, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpMrtrInfoMrt.setStatus('current')
if mibBuilder.loadTexts: igmpMrtrInfoMrt.setDescription('The Maximum Query Response time of this IGMP mrouter.')
igmpMrtrInfoQrv = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 6, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpMrtrInfoQrv.setStatus('current')
if mibBuilder.loadTexts: igmpMrtrInfoQrv.setDescription('The Querier Robustness value of this IGMP mrouter.')
igmpMrtrInfoQqic = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 6, 2, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpMrtrInfoQqic.setStatus('current')
if mibBuilder.loadTexts: igmpMrtrInfoQqic.setDescription('The Querier query interval code of this IGMP mrouter.')
igmpMrtrInfoSrcIp = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 6, 2, 1, 10), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpMrtrInfoSrcIp.setStatus('current')
if mibBuilder.loadTexts: igmpMrtrInfoSrcIp.setDescription('The Source IP of this IGMP mrouter.')
igmpClearTables = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 6, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("ok", 0), ("clearGroups", 1), ("clearMrouters", 2), ("clearAll", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igmpClearTables.setStatus('current')
if mibBuilder.loadTexts: igmpClearTables.setDescription('Clear the IGMP tables. When setting clearGroups(1), the dynamic groups are removed, when setting clearMrouters(2), the mrouter tables are removed and when setting clearAll(3), both the dynamic groups and the mrouter tables are removed. When read, ok(0) is always returned.')
nbrInfoTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 12, 1), )
if mibBuilder.loadTexts: nbrInfoTable.setStatus('current')
if mibBuilder.loadTexts: nbrInfoTable.setDescription('The table of nbrcache information.')
nbrInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 12, 1, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "nbrInfoIndex"))
if mibBuilder.loadTexts: nbrInfoEntry.setStatus('current')
if mibBuilder.loadTexts: nbrInfoEntry.setDescription('Information about neighbor discovery protocol.')
nbrInfoIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 12, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbrInfoIndex.setStatus('current')
if mibBuilder.loadTexts: nbrInfoIndex.setDescription('The index of the nbrcache entry.')
nbrInfoDestIp = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 12, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbrInfoDestIp.setStatus('current')
if mibBuilder.loadTexts: nbrInfoDestIp.setDescription('The destination IP address of the nbrcache entry.')
nbrInfoState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 12, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("static", 1), ("reach", 2), ("incomplete", 3), ("stale", 4), ("delay", 5), ("probe", 6), ("unknown", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbrInfoState.setStatus('current')
if mibBuilder.loadTexts: nbrInfoState.setDescription('The state of the nbrcache entry.')
nbrInfoMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 12, 1, 1, 4), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbrInfoMacAddr.setStatus('current')
if mibBuilder.loadTexts: nbrInfoMacAddr.setDescription('The MAC address for the nbrcache entry.')
nbrInfoVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 12, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbrInfoVlanId.setStatus('current')
if mibBuilder.loadTexts: nbrInfoVlanId.setDescription('The VLAN identifier for the nbrcache entry.')
nbrInfoPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 12, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbrInfoPortNum.setStatus('current')
if mibBuilder.loadTexts: nbrInfoPortNum.setDescription("The port number on which this entry's equivalence is effective.")
nbrInfoAge = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 12, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbrInfoAge.setStatus('current')
if mibBuilder.loadTexts: nbrInfoAge.setDescription('The used time for the nbrcache entry.')
nbrInfoInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 12, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbrInfoInterface.setStatus('current')
if mibBuilder.loadTexts: nbrInfoInterface.setDescription('The interface number for which the destination address is applicable.')
nbrClear = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 12, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("clear", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbrClear.setStatus('current')
if mibBuilder.loadTexts: nbrClear.setDescription('Setting this value to clear(2) clears the Nbr cache, When read ok(1) is returned.')
ipv6PmtuInfoTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 21, 1), )
if mibBuilder.loadTexts: ipv6PmtuInfoTable.setStatus('current')
if mibBuilder.loadTexts: ipv6PmtuInfoTable.setDescription('The table of Ipv6 PMTU entries.')
ipv6PmtuInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 21, 1, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ipv6PmtuInfoIndx"))
if mibBuilder.loadTexts: ipv6PmtuInfoEntry.setStatus('current')
if mibBuilder.loadTexts: ipv6PmtuInfoEntry.setDescription('A row in the ipv6 PMTU entries table.')
ipv6PmtuInfoIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 21, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6PmtuInfoIndx.setStatus('current')
if mibBuilder.loadTexts: ipv6PmtuInfoIndx.setDescription('The index of this ipv6 PMTU table entries.')
ipv6PmtuInfoDestIp = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 21, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6PmtuInfoDestIp.setStatus('current')
if mibBuilder.loadTexts: ipv6PmtuInfoDestIp.setDescription('The destination of the pMTU.')
ipv6PmtuInfoSinceTime = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 21, 1, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6PmtuInfoSinceTime.setStatus('current')
if mibBuilder.loadTexts: ipv6PmtuInfoSinceTime.setDescription('The addubt time of the pMTU.')
ipv6PmtuInfoValue = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 21, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6PmtuInfoValue.setStatus('current')
if mibBuilder.loadTexts: ipv6PmtuInfoValue.setDescription('The vlaue of this ipv6 PMTU table entries.')
ipRoute6InfoTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 14, 1), )
if mibBuilder.loadTexts: ipRoute6InfoTable.setStatus('current')
if mibBuilder.loadTexts: ipRoute6InfoTable.setDescription('The table of run-time IP6 routes.')
ipRoute6InfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 14, 1, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ipRoute6InfoIndx"))
if mibBuilder.loadTexts: ipRoute6InfoEntry.setStatus('current')
if mibBuilder.loadTexts: ipRoute6InfoEntry.setDescription('A row in the run-time IP6 route table.')
ipRoute6InfoIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 14, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipRoute6InfoIndx.setStatus('current')
if mibBuilder.loadTexts: ipRoute6InfoIndx.setDescription('The index of this route6 table.')
ipRoute6InfoDestIp = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 14, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipRoute6InfoDestIp.setStatus('current')
if mibBuilder.loadTexts: ipRoute6InfoDestIp.setDescription('The destination of the route.')
ipRoute6InfoPrefLen = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 14, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipRoute6InfoPrefLen.setStatus('current')
if mibBuilder.loadTexts: ipRoute6InfoPrefLen.setDescription('The destination prefix length of the route.')
ipRoute6InfoInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 14, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipRoute6InfoInterface.setStatus('current')
if mibBuilder.loadTexts: ipRoute6InfoInterface.setDescription('The interface of the route.')
ipRoute6InfoNextHop = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 14, 1, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipRoute6InfoNextHop.setStatus('current')
if mibBuilder.loadTexts: ipRoute6InfoNextHop.setDescription('The next hop of the route.')
ipRoute6InfoProto = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 14, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6, 10, 11))).clone(namedValues=NamedValues(("local", 2), ("static", 3), ("nbrdis", 4), ("ripng", 5), ("ospf", 6), ("intmgmt", 10), ("extmgmt", 11)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipRoute6InfoProto.setStatus('current')
if mibBuilder.loadTexts: ipRoute6InfoProto.setDescription('The protocol type of the route.')
gatewayIPv6InfoTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 13, 1), )
if mibBuilder.loadTexts: gatewayIPv6InfoTable.setStatus('current')
if mibBuilder.loadTexts: gatewayIPv6InfoTable.setDescription('The table containing information for the IPv6 default gateways.')
gatewayIPv6InfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 13, 1, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ipGatewayIPv6InfoIndex"))
if mibBuilder.loadTexts: gatewayIPv6InfoEntry.setStatus('current')
if mibBuilder.loadTexts: gatewayIPv6InfoEntry.setDescription('A row in the IPv6 gateway information table')
ipGatewayIPv6InfoIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 13, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipGatewayIPv6InfoIndex.setStatus('current')
if mibBuilder.loadTexts: ipGatewayIPv6InfoIndex.setDescription('The IPv6 gateway number for which the information is related.')
ipGatewayIPv6InfoAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 13, 1, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipGatewayIPv6InfoAddr.setStatus('current')
if mibBuilder.loadTexts: ipGatewayIPv6InfoAddr.setDescription('The IP address for the IPv6 default gateway.')
ipGatewayIPv6InfoState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 13, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipGatewayIPv6InfoState.setStatus('current')
if mibBuilder.loadTexts: ipGatewayIPv6InfoState.setDescription('The state for the IPv6 Default Gateway.')
rip2GeneralInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 10, 1))
ripInfoState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripInfoState.setStatus('current')
if mibBuilder.loadTexts: ripInfoState.setDescription('RIP global state.')
ripInfoUpdatePeriod = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 10, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 120))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripInfoUpdatePeriod.setStatus('current')
if mibBuilder.loadTexts: ripInfoUpdatePeriod.setDescription('Update Period in seconds.')
rip2InfoIntfTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 10, 2), )
if mibBuilder.loadTexts: rip2InfoIntfTable.setStatus('current')
if mibBuilder.loadTexts: rip2InfoIntfTable.setDescription('The information table of RIP.')
ripInfoIntfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 10, 2, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ripInfoIntfIndex"))
if mibBuilder.loadTexts: ripInfoIntfEntry.setStatus('current')
if mibBuilder.loadTexts: ripInfoIntfEntry.setDescription('Information about RIP on IP interface.')
ripInfoIntfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 10, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripInfoIntfIndex.setStatus('current')
if mibBuilder.loadTexts: ripInfoIntfIndex.setDescription('The interface number for which the RIP information is related.')
ripInfoIntfVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 10, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ripVersion1", 1), ("ripVersion2", 2), ("ripVersionBoth", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripInfoIntfVersion.setStatus('current')
if mibBuilder.loadTexts: ripInfoIntfVersion.setDescription('RIP version.')
ripInfoIntfAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 10, 2, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripInfoIntfAddress.setStatus('current')
if mibBuilder.loadTexts: ripInfoIntfAddress.setDescription('The interface address.')
ripInfoIntfState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 10, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripInfoIntfState.setStatus('current')
if mibBuilder.loadTexts: ripInfoIntfState.setDescription('The status of RIP protocol.')
ripInfoIntfListen = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 10, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripInfoIntfListen.setStatus('current')
if mibBuilder.loadTexts: ripInfoIntfListen.setDescription('The status of listening to route updates.')
ripInfoIntfTrigUpdate = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 10, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripInfoIntfTrigUpdate.setStatus('current')
if mibBuilder.loadTexts: ripInfoIntfTrigUpdate.setDescription('The status of triggered updates.')
ripInfoIntfMcastUpdate = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 10, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripInfoIntfMcastUpdate.setStatus('current')
if mibBuilder.loadTexts: ripInfoIntfMcastUpdate.setDescription('The status of multicast updates.')
ripInfoIntfPoisonReverse = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 10, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripInfoIntfPoisonReverse.setStatus('current')
if mibBuilder.loadTexts: ripInfoIntfPoisonReverse.setDescription('The status of RIP poison reverse.')
ripInfoIntfSupply = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 10, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripInfoIntfSupply.setStatus('current')
if mibBuilder.loadTexts: ripInfoIntfSupply.setDescription('The status of supplying route updates.')
ripInfoIntfMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 10, 2, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripInfoIntfMetric.setStatus('current')
if mibBuilder.loadTexts: ripInfoIntfMetric.setDescription('RIP route metric for this interface.')
ripInfoIntfAuth = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 10, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("none", 1), ("password", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripInfoIntfAuth.setStatus('current')
if mibBuilder.loadTexts: ripInfoIntfAuth.setDescription('The type of Authentication used on this interface.')
ripInfoIntfKey = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 10, 2, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripInfoIntfKey.setStatus('current')
if mibBuilder.loadTexts: ripInfoIntfKey.setDescription('RIP update authentication password.')
ripInfoIntfDefault = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 10, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("both", 1), ("listen", 2), ("supply", 3), ("none", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripInfoIntfDefault.setStatus('current')
if mibBuilder.loadTexts: ripInfoIntfDefault.setDescription('Specifies what RIP does with default routes.')
bgpInfoPeerTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 11, 1), )
if mibBuilder.loadTexts: bgpInfoPeerTable.setStatus('current')
if mibBuilder.loadTexts: bgpInfoPeerTable.setDescription('The table of BGP peer in the current configuration block.')
bgpInfoPeerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 11, 1, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "bgpInfoPeerIndex"))
if mibBuilder.loadTexts: bgpInfoPeerEntry.setStatus('current')
if mibBuilder.loadTexts: bgpInfoPeerEntry.setDescription('Information about a BGP peer.')
bgpInfoPeerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 11, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpInfoPeerIndex.setStatus('current')
if mibBuilder.loadTexts: bgpInfoPeerIndex.setDescription('The BGP peer number for which the BGP peer table is related.')
bgpInfoPeerRemoteAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 11, 1, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpInfoPeerRemoteAddr.setStatus('current')
if mibBuilder.loadTexts: bgpInfoPeerRemoteAddr.setDescription('The remote IP address of the BGP peer.')
bgpInfoPeerVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 11, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpInfoPeerVersion.setStatus('current')
if mibBuilder.loadTexts: bgpInfoPeerVersion.setDescription('The version negotiated by the BGP peer.')
bgpInfoPeerTtl = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 11, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpInfoPeerTtl.setStatus('current')
if mibBuilder.loadTexts: bgpInfoPeerTtl.setDescription('The time-to-live value of the BGP peer IP datagram.')
bgpInfoPeerRemoteAs = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 11, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpInfoPeerRemoteAs.setStatus('current')
if mibBuilder.loadTexts: bgpInfoPeerRemoteAs.setDescription('The remote IP address of the BGP peer.')
bgpInfoPeerRouterId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 11, 1, 1, 6), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpInfoPeerRouterId.setStatus('current')
if mibBuilder.loadTexts: bgpInfoPeerRouterId.setDescription('The router IP address.')
bgpInfoPeerState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 11, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("idle", 1), ("connect", 2), ("active", 3), ("openSent", 4), ("openConfirm", 5), ("established", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpInfoPeerState.setStatus('current')
if mibBuilder.loadTexts: bgpInfoPeerState.setDescription('The BGP status.')
bgpInfoPeerLastState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 11, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("idle", 1), ("connect", 2), ("active", 3), ("openSent", 4), ("openConfirm", 5), ("established", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpInfoPeerLastState.setStatus('current')
if mibBuilder.loadTexts: bgpInfoPeerLastState.setDescription('The BGP old status.')
bgpInfoTotalReceivedPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 11, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpInfoTotalReceivedPackets.setStatus('current')
if mibBuilder.loadTexts: bgpInfoTotalReceivedPackets.setDescription('The total number of received packets.')
bgpInfoTotalSentPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 11, 1, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpInfoTotalSentPackets.setStatus('current')
if mibBuilder.loadTexts: bgpInfoTotalSentPackets.setDescription('The total number of sent packets.')
bgpInfoReceivedUpdates = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 11, 1, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpInfoReceivedUpdates.setStatus('current')
if mibBuilder.loadTexts: bgpInfoReceivedUpdates.setDescription('The number of received updates.')
bgpInfoSentUpdates = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 11, 1, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpInfoSentUpdates.setStatus('current')
if mibBuilder.loadTexts: bgpInfoSentUpdates.setDescription('The number of sent updates.')
bgpInfoKeepalive = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 11, 1, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpInfoKeepalive.setStatus('current')
if mibBuilder.loadTexts: bgpInfoKeepalive.setDescription('The keep alive time.')
bgpInfoHoldtime = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 11, 1, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpInfoHoldtime.setStatus('current')
if mibBuilder.loadTexts: bgpInfoHoldtime.setDescription('The hold time.')
bgpInfoMinAdvTime = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 11, 1, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpInfoMinAdvTime.setStatus('current')
if mibBuilder.loadTexts: bgpInfoMinAdvTime.setDescription('The MinAdvTime.')
bgpInfoLastErrorCode = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 11, 1, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpInfoLastErrorCode.setStatus('current')
if mibBuilder.loadTexts: bgpInfoLastErrorCode.setDescription('The last error code.')
bgpInfoLastErrorSubCode = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 11, 1, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpInfoLastErrorSubCode.setStatus('current')
if mibBuilder.loadTexts: bgpInfoLastErrorSubCode.setDescription('The last error subcode.')
bgpInfoEstTransitions = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 11, 1, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpInfoEstTransitions.setStatus('current')
if mibBuilder.loadTexts: bgpInfoEstTransitions.setDescription('The established state transitions.')
bgpInfoSummaryTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 11, 2), )
if mibBuilder.loadTexts: bgpInfoSummaryTable.setStatus('current')
if mibBuilder.loadTexts: bgpInfoSummaryTable.setDescription('The table of BGP Peer Information.')
bgpInfoSummaryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 11, 2, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "bgpInfoSummaryIndex"))
if mibBuilder.loadTexts: bgpInfoSummaryEntry.setStatus('current')
if mibBuilder.loadTexts: bgpInfoSummaryEntry.setDescription('Information about a BGP Peer.')
bgpInfoSummaryIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 11, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpInfoSummaryIndex.setStatus('current')
if mibBuilder.loadTexts: bgpInfoSummaryIndex.setDescription('The BGP Peer number for which the BGP Peer table is related.')
bgpInfoSummaryRemoteAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 11, 2, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpInfoSummaryRemoteAddr.setStatus('current')
if mibBuilder.loadTexts: bgpInfoSummaryRemoteAddr.setDescription('The remote IP address of the BGP Peer.')
bgpInfoSummaryVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 11, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpInfoSummaryVersion.setStatus('current')
if mibBuilder.loadTexts: bgpInfoSummaryVersion.setDescription('The version negotiated by the BGP Peer.')
bgpInfoSummaryRemoteAs = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 11, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpInfoSummaryRemoteAs.setStatus('current')
if mibBuilder.loadTexts: bgpInfoSummaryRemoteAs.setDescription('The Remote AS.')
bgpInfoSummaryState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 11, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("idle", 1), ("connect", 2), ("active", 3), ("openSent", 4), ("openConfirm", 5), ("established", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpInfoSummaryState.setStatus('current')
if mibBuilder.loadTexts: bgpInfoSummaryState.setDescription('The BGP status.')
bgpInfoSummaryTotalReceivedPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 11, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpInfoSummaryTotalReceivedPackets.setStatus('current')
if mibBuilder.loadTexts: bgpInfoSummaryTotalReceivedPackets.setDescription('The total number of received packets.')
bgpInfoSummaryTotalSentPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 11, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpInfoSummaryTotalSentPackets.setStatus('current')
if mibBuilder.loadTexts: bgpInfoSummaryTotalSentPackets.setDescription('The total number of sent packets.')
bgpInfoRtrTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 11, 3), )
if mibBuilder.loadTexts: bgpInfoRtrTable.setStatus('current')
if mibBuilder.loadTexts: bgpInfoRtrTable.setDescription('The table of BGP router run-time information')
bgpInfoRtrTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 11, 3, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "bgpInfoIndex"))
if mibBuilder.loadTexts: bgpInfoRtrTableEntry.setStatus('current')
if mibBuilder.loadTexts: bgpInfoRtrTableEntry.setDescription('The run-time information about a BGP router')
bgpInfoIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 11, 3, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpInfoIndex.setStatus('current')
if mibBuilder.loadTexts: bgpInfoIndex.setDescription('The BGP router index which is the network address.')
bgpInfoNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 11, 3, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpInfoNetwork.setStatus('current')
if mibBuilder.loadTexts: bgpInfoNetwork.setDescription('The BGP network address.')
bgpInfoNextHop = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 11, 3, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpInfoNextHop.setStatus('current')
if mibBuilder.loadTexts: bgpInfoNextHop.setDescription('The BGPs NextHop addresses from a network.')
bgpInfoMetr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 11, 3, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpInfoMetr.setStatus('current')
if mibBuilder.loadTexts: bgpInfoMetr.setDescription('The BGPs metric from a network.')
bgpInfoLcPrf = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 11, 3, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpInfoLcPrf.setStatus('current')
if mibBuilder.loadTexts: bgpInfoLcPrf.setDescription('The BGPs local preference from a network.')
bgpInfoWght = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 11, 3, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpInfoWght.setStatus('current')
if mibBuilder.loadTexts: bgpInfoWght.setDescription('Total weight of AS paths from a network.')
bgpInfoPath = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 11, 3, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpInfoPath.setStatus('current')
if mibBuilder.loadTexts: bgpInfoPath.setDescription('The AS paths from a network.')
bgpInfoOrigin = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 11, 3, 1, 8), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpInfoOrigin.setStatus('current')
if mibBuilder.loadTexts: bgpInfoOrigin.setDescription('The BGPs route origin from a network')
bgpInfoMask = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 11, 3, 1, 9), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpInfoMask.setStatus('current')
if mibBuilder.loadTexts: bgpInfoMask.setDescription('The BGP router subnet mask.')
vrrpOperVirtRtrTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 4, 1, 1), )
if mibBuilder.loadTexts: vrrpOperVirtRtrTable.setStatus('current')
if mibBuilder.loadTexts: vrrpOperVirtRtrTable.setDescription('An entry in the table of virtual routers.')
vrrpOperVirtRtrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 4, 1, 1, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "vrrpOperVirtRtrIndex"))
if mibBuilder.loadTexts: vrrpOperVirtRtrEntry.setStatus('current')
if mibBuilder.loadTexts: vrrpOperVirtRtrEntry.setDescription('A row in the vrrpOperVirtRtrTable ')
vrrpOperVirtRtrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 4, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpOperVirtRtrIndex.setStatus('current')
if mibBuilder.loadTexts: vrrpOperVirtRtrIndex.setDescription('The index for the VRRP virtual router.')
vrrpOperVirtRtrBackup = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 4, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("backup", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrrpOperVirtRtrBackup.setStatus('current')
if mibBuilder.loadTexts: vrrpOperVirtRtrBackup.setDescription("When set to a value of 'backup(2)' it forces the specified master virtual router into backup mode. 'ok(1)' is returned when the object is read.")
vrrpOperVirtRtrGroupBackup = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("backup", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrrpOperVirtRtrGroupBackup.setStatus('current')
if mibBuilder.loadTexts: vrrpOperVirtRtrGroupBackup.setDescription("When set to a value of 'backup(2)' it forces the specified master virtual router group into backup mode. 'ok(1)' is returned when the object os read.")
class IPsecKeyString(TextualConvention, OctetString):
    description = "Represents textual information taken from the NVT ASCII character set, as defined in pages 4, 10-11 of RFC 854. To summarize RFC 854, the NVT ASCII repertoire specifies: - the use of character codes 0-127 (decimal) - the graphics characters (32-126) are interpreted as US ASCII - NUL, LF, CR, BEL, BS, HT, VT and FF have the special meanings specified in RFC 854 - the other 25 codes have no standard interpretation - the sequence 'CR LF' means newline - the sequence 'CR NUL' means carriage-return - an 'LF' not preceded by a 'CR' means moving to the same column on the next line. - the sequence 'CR x' for any x other than LF or NUL is illegal. (Note that this also means that a string may end with either 'CR LF' or 'CR NUL', but not with CR.) Any object defined using this syntax may not exceed 255 characters in length. "
    status = 'current'
    displayHint = '1024a'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 1024)

ikeGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 1))
ikeCurCfgProposal = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 1, 1))
ikeCurCfgPropCipher = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("des", 1), ("triple-des", 2), ("aes-cbc", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ikeCurCfgPropCipher.setStatus('current')
if mibBuilder.loadTexts: ikeCurCfgPropCipher.setDescription('Current encription algorithm used by IKEv2')
ikeCurCfgPropAuth = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("sha1", 1), ("md5", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ikeCurCfgPropAuth.setStatus('current')
if mibBuilder.loadTexts: ikeCurCfgPropAuth.setDescription('Current authentication algorithm used by IKEv2')
ikeCurCfgPropGroup = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("dhGroup1", 1), ("dhGroup2", 2), ("dhGroup5", 3), ("dhGroup14", 4), ("dhGroup24", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ikeCurCfgPropGroup.setStatus('current')
if mibBuilder.loadTexts: ikeCurCfgPropGroup.setDescription('Current Diffie-Hellman groups used by IKEv2')
ikeNewCfgProposal = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 1, 2))
ikeNewCfgPropCipher = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 1, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("des", 1), ("triple-des", 2), ("aes-cbc", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ikeNewCfgPropCipher.setStatus('current')
if mibBuilder.loadTexts: ikeNewCfgPropCipher.setDescription('New encription algorithm used by IKEv2')
ikeNewCfgPropAuth = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 1, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("sha1", 1), ("md5", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ikeNewCfgPropAuth.setStatus('current')
if mibBuilder.loadTexts: ikeNewCfgPropAuth.setDescription('New authentication algorithm used by IKEv2')
ikeNewCfgPropGroup = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 1, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("dhGroup1", 1), ("dhGroup2", 2), ("dhGroup5", 3), ("dhGroup14", 4), ("dhGroup24", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ikeNewCfgPropGroup.setStatus('current')
if mibBuilder.loadTexts: ikeNewCfgPropGroup.setDescription('New Diffie-Hellman groups used by IKEv2')
ikeCurCfgPsk = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 1, 3))
ikeCurCfgPskLocalKey = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 1, 3, 1), IPsecKeyString().subtype(subtypeSpec=ValueSizeConstraint(1, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ikeCurCfgPskLocalKey.setStatus('current')
if mibBuilder.loadTexts: ikeCurCfgPskLocalKey.setDescription('Current local pre-shared key.')
ikeCurCfgPskRemoteTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 1, 3, 2), )
if mibBuilder.loadTexts: ikeCurCfgPskRemoteTable.setStatus('current')
if mibBuilder.loadTexts: ikeCurCfgPskRemoteTable.setDescription('The (conceptual) table listing the remote pre-shared key by peer address used by IKEv2.')
ikeCurCfgPskRemoteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 1, 3, 2, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ikeCurCfgPskRemoteIndex"))
if mibBuilder.loadTexts: ikeCurCfgPskRemoteEntry.setStatus('current')
if mibBuilder.loadTexts: ikeCurCfgPskRemoteEntry.setDescription('An entry (conceptual row) representing a remote pre-shared key for a peer address.')
ikeCurCfgPskRemoteIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 1, 3, 2, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ikeCurCfgPskRemoteIndex.setStatus('current')
if mibBuilder.loadTexts: ikeCurCfgPskRemoteIndex.setDescription('The index of ikeCurCfgPskRemoteTable.')
ikeCurCfgPskRemoteAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 1, 3, 2, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ikeCurCfgPskRemoteAddr.setStatus('current')
if mibBuilder.loadTexts: ikeCurCfgPskRemoteAddr.setDescription('Current IPv6 address of peer.')
ikeCurCfgPskRemoteKey = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 1, 3, 2, 1, 3), IPsecKeyString().subtype(subtypeSpec=ValueSizeConstraint(1, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ikeCurCfgPskRemoteKey.setStatus('current')
if mibBuilder.loadTexts: ikeCurCfgPskRemoteKey.setDescription('Current remote pre-shared key.')
ikeCurCfgPskRemoteDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 1, 3, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("delete", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ikeCurCfgPskRemoteDelete.setStatus('current')
if mibBuilder.loadTexts: ikeCurCfgPskRemoteDelete.setDescription('Set a value of delete(2) for this object will delete the entry, A value of other(1) is always returned when this object is read.')
ikeNewCfgPsk = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 1, 4))
ikeNewCfgPskLocalKey = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 1, 4, 1), IPsecKeyString().subtype(subtypeSpec=ValueSizeConstraint(1, 256))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ikeNewCfgPskLocalKey.setStatus('current')
if mibBuilder.loadTexts: ikeNewCfgPskLocalKey.setDescription('New local pre-shared key.')
ikeNewCfgPskRemoteTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 1, 4, 2), )
if mibBuilder.loadTexts: ikeNewCfgPskRemoteTable.setStatus('current')
if mibBuilder.loadTexts: ikeNewCfgPskRemoteTable.setDescription('The (conceptual) table listing the remote pre-shared key by peer address used by IKEv2.')
ikeNewCfgPskRemoteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 1, 4, 2, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ikeNewCfgPskRemoteIndex"))
if mibBuilder.loadTexts: ikeNewCfgPskRemoteEntry.setStatus('current')
if mibBuilder.loadTexts: ikeNewCfgPskRemoteEntry.setDescription('An entry (conceptual row) representing a remote pre-shared key for a peer address.')
ikeNewCfgPskRemoteIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 1, 4, 2, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ikeNewCfgPskRemoteIndex.setStatus('current')
if mibBuilder.loadTexts: ikeNewCfgPskRemoteIndex.setDescription('The index of ikeNewCfgPskRemoteTable.')
ikeNewCfgPskRemoteAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 1, 4, 2, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ikeNewCfgPskRemoteAddr.setStatus('current')
if mibBuilder.loadTexts: ikeNewCfgPskRemoteAddr.setDescription('New IPv6 address of peer.')
ikeNewCfgPskRemoteKey = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 1, 4, 2, 1, 3), IPsecKeyString().subtype(subtypeSpec=ValueSizeConstraint(1, 256))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ikeNewCfgPskRemoteKey.setStatus('current')
if mibBuilder.loadTexts: ikeNewCfgPskRemoteKey.setDescription('New remote pre-shared key.')
ikeNewCfgPskRemoteDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 1, 4, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("delete", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ikeNewCfgPskRemoteDelete.setStatus('current')
if mibBuilder.loadTexts: ikeNewCfgPskRemoteDelete.setDescription('Set a value of delete(2) for this object will delete the entry, A value of other(1) is always returned when this object is read.')
ikeCurCfgIdentity = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 1, 5))
ikeCurCfgIdType = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 1, 5, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("ipv6-addr", 0), ("fqdn", 1), ("email", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ikeCurCfgIdType.setStatus('current')
if mibBuilder.loadTexts: ikeCurCfgIdType.setDescription('Specifies the type of Identification being used.')
ikeCurCfgIdData = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 1, 5, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ikeCurCfgIdData.setStatus('current')
if mibBuilder.loadTexts: ikeCurCfgIdData.setDescription('Value as indicated by the Identification Type. It can be a fully-qualified domain name string (example.com) or a fully-qualified email address string (jsmith@example.com).')
ikeNewCfgIdentity = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 1, 6))
ikeNewCfgIdType = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 1, 6, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("ipv6-addr", 0), ("fqdn", 1), ("email", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ikeNewCfgIdType.setStatus('current')
if mibBuilder.loadTexts: ikeNewCfgIdType.setDescription('Specifies the type of Identification being used.')
ikeNewCfgIdData = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 1, 6, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ikeNewCfgIdData.setStatus('current')
if mibBuilder.loadTexts: ikeNewCfgIdData.setDescription('Value as indicated by the Identification Type. It can be a fully-qualified domain name string (example.com) or a fully-qualified email address string (jsmith@example.com).')
ikeCurCfgTxTimeout = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ikeCurCfgTxTimeout.setStatus('current')
if mibBuilder.loadTexts: ikeCurCfgTxTimeout.setDescription('The value of this object specify the IKEv2 PDU retransmission timeout in seconds.')
ikeNewCfgTxTimeout = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ikeNewCfgTxTimeout.setStatus('current')
if mibBuilder.loadTexts: ikeNewCfgTxTimeout.setDescription('The value of this object specify the new IKEv2 PDU retransmission timeout.')
ikeCurCfgCookie = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ikeCurCfgCookie.setStatus('current')
if mibBuilder.loadTexts: ikeCurCfgCookie.setDescription('Globally enable/disable IKEv2 cookie notify.')
ikeNewCfgCookie = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ikeNewCfgCookie.setStatus('current')
if mibBuilder.loadTexts: ikeNewCfgCookie.setDescription('Globally enable/disable IKEv2 cookie notify.')
ipsecGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2))
ipsecCurCfgState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecCurCfgState.setStatus('current')
if mibBuilder.loadTexts: ipsecCurCfgState.setDescription('Globally enable/disable IPsec.')
ipsecNewCfgState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecNewCfgState.setStatus('current')
if mibBuilder.loadTexts: ipsecNewCfgState.setDescription('Globally enable/disable IPsec.')
ipsecCurCfgTxformTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 3), )
if mibBuilder.loadTexts: ipsecCurCfgTxformTable.setStatus('current')
if mibBuilder.loadTexts: ipsecCurCfgTxformTable.setDescription('The (conceptual) table listing all of the IPsec transform-set.')
ipsecCurCfgTxformEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 3, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ipsecCurCfgTxformIndex"))
if mibBuilder.loadTexts: ipsecCurCfgTxformEntry.setStatus('current')
if mibBuilder.loadTexts: ipsecCurCfgTxformEntry.setDescription('An entry (conceptual row) representing a IPsec transform-set.')
ipsecCurCfgTxformIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 3, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecCurCfgTxformIndex.setStatus('current')
if mibBuilder.loadTexts: ipsecCurCfgTxformIndex.setDescription('The index of ipsecCurCfgTxformTable.')
ipsecCurCfgTxformAuth = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("none", 0), ("ah-sha1", 1), ("ah-md5", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecCurCfgTxformAuth.setStatus('current')
if mibBuilder.loadTexts: ipsecCurCfgTxformAuth.setDescription('The authentication algorithm of the IPsec transform-set')
ipsecCurCfgTxformCipher = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("esp-null", 0), ("esp-des", 1), ("esp-3des", 2), ("esp-aes-cbc", 3), ("unspecified", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecCurCfgTxformCipher.setStatus('current')
if mibBuilder.loadTexts: ipsecCurCfgTxformCipher.setDescription('The encryption algorithm of the IPsec transform-set')
ipsecCurCfgTxformIntegrity = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("none", 0), ("esp-sha1", 1), ("esp-md5", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecCurCfgTxformIntegrity.setStatus('current')
if mibBuilder.loadTexts: ipsecCurCfgTxformIntegrity.setDescription('The interity algorithm of the IPsec transform-set')
ipsecCurCfgTxformMode = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("transport", 1), ("tunnel", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecCurCfgTxformMode.setStatus('current')
if mibBuilder.loadTexts: ipsecCurCfgTxformMode.setDescription('The tunnel/transport mode of the IPsec transform-set')
ipsecCurCfgTxformDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("delete", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecCurCfgTxformDelete.setStatus('current')
if mibBuilder.loadTexts: ipsecCurCfgTxformDelete.setDescription('Set a value of delete(2) for this object will delete the entry, A value of other(1) is always returned when this object is read.')
ipsecNewCfgTxformTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 4), )
if mibBuilder.loadTexts: ipsecNewCfgTxformTable.setStatus('current')
if mibBuilder.loadTexts: ipsecNewCfgTxformTable.setDescription('The (conceptual) table listing all of the new IPsec transform-set to be apply.')
ipsecNewCfgTxformEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 4, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ipsecNewCfgTxformIndex"))
if mibBuilder.loadTexts: ipsecNewCfgTxformEntry.setStatus('current')
if mibBuilder.loadTexts: ipsecNewCfgTxformEntry.setDescription('An entry (conceptual row) representing a IPsec transform-set.')
ipsecNewCfgTxformIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 4, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecNewCfgTxformIndex.setStatus('current')
if mibBuilder.loadTexts: ipsecNewCfgTxformIndex.setDescription('The index of ipsecNewCfgTxformTable.')
ipsecNewCfgTxformAuth = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("none", 0), ("ah-sha1", 1), ("ah-md5", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsecNewCfgTxformAuth.setStatus('current')
if mibBuilder.loadTexts: ipsecNewCfgTxformAuth.setDescription('The authentication algorithm of the IPsec transform-set')
ipsecNewCfgTxformCipher = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("esp-null", 0), ("esp-des", 1), ("esp-3des", 2), ("esp-aes-cbc", 3), ("unspecified", 4)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsecNewCfgTxformCipher.setStatus('current')
if mibBuilder.loadTexts: ipsecNewCfgTxformCipher.setDescription('The encryption algorithm of the IPsec transform-set')
ipsecNewCfgTxformIntegrity = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("none", 0), ("esp-sha1", 1), ("esp-md5", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsecNewCfgTxformIntegrity.setStatus('current')
if mibBuilder.loadTexts: ipsecNewCfgTxformIntegrity.setDescription('The interity algorithm of the IPsec transform-set')
ipsecNewCfgTxformMode = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("transport", 1), ("tunnel", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsecNewCfgTxformMode.setStatus('current')
if mibBuilder.loadTexts: ipsecNewCfgTxformMode.setDescription('The tunnel/transport mode of the IPsec transform-set')
ipsecNewCfgTxformDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 4, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("delete", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecNewCfgTxformDelete.setStatus('current')
if mibBuilder.loadTexts: ipsecNewCfgTxformDelete.setDescription('Set a value of delete(2) for this object will delete the entry, A value of other(1) is always returned when this object is read.')
ipsecCurCfgSelectorTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 5), )
if mibBuilder.loadTexts: ipsecCurCfgSelectorTable.setStatus('current')
if mibBuilder.loadTexts: ipsecCurCfgSelectorTable.setDescription('The (conceptual) table listing all of the IPsec selector.')
ipsecCurCfgSelectorEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 5, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ipsecCurCfgSelectorIndex"))
if mibBuilder.loadTexts: ipsecCurCfgSelectorEntry.setStatus('current')
if mibBuilder.loadTexts: ipsecCurCfgSelectorEntry.setDescription('An entry (conceptual row) representing a IPsec selector.')
ipsecCurCfgSelectorIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 5, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecCurCfgSelectorIndex.setStatus('current')
if mibBuilder.loadTexts: ipsecCurCfgSelectorIndex.setDescription('The index of ipsecCurCfgSelectorTable.')
ipsecCurCfgSelectorAction = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("unspecified", 0), ("permit", 1), ("deny", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecCurCfgSelectorAction.setStatus('current')
if mibBuilder.loadTexts: ipsecCurCfgSelectorAction.setDescription('The action of the IPsec selector')
ipsecCurCfgSelectorProto = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("unspecified", 0), ("tcp", 1), ("icmp", 2), ("any", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecCurCfgSelectorProto.setStatus('current')
if mibBuilder.loadTexts: ipsecCurCfgSelectorProto.setDescription('The protocol of the IPsec selector')
ipsecCurCfgSelectorIcmpType = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 5, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecCurCfgSelectorIcmpType.setStatus('current')
if mibBuilder.loadTexts: ipsecCurCfgSelectorIcmpType.setDescription('When the protocol of the IPsec selector is icmp(2), This object specify the ICMP type for the traffic selector. 0 = any.')
ipsecCurCfgSelectorDst = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 5, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecCurCfgSelectorDst.setStatus('current')
if mibBuilder.loadTexts: ipsecCurCfgSelectorDst.setDescription('The destination ip address of the IPsec selector')
ipsecCurCfgSelectorDstPrefix = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 5, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecCurCfgSelectorDstPrefix.setStatus('current')
if mibBuilder.loadTexts: ipsecCurCfgSelectorDstPrefix.setDescription('The destination ipv6 address prefix length of the IPsec selector')
ipsecCurCfgSelectorSrc = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 5, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecCurCfgSelectorSrc.setStatus('current')
if mibBuilder.loadTexts: ipsecCurCfgSelectorSrc.setDescription('The source ip address of the IPsec selector')
ipsecCurCfgSelectorDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 5, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("delete", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecCurCfgSelectorDelete.setStatus('current')
if mibBuilder.loadTexts: ipsecCurCfgSelectorDelete.setDescription('Set a value of delete(2) for this object will delete the entry, A value of other(1) is always returned when this object is read.')
ipsecNewCfgSelectorTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 6), )
if mibBuilder.loadTexts: ipsecNewCfgSelectorTable.setStatus('current')
if mibBuilder.loadTexts: ipsecNewCfgSelectorTable.setDescription('The (conceptual) table listing all of the IPsec selector.')
ipsecNewCfgSelectorEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 6, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ipsecNewCfgSelectorIndex"))
if mibBuilder.loadTexts: ipsecNewCfgSelectorEntry.setStatus('current')
if mibBuilder.loadTexts: ipsecNewCfgSelectorEntry.setDescription('An entry (conceptual row) representing a IPsec selector.')
ipsecNewCfgSelectorIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 6, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecNewCfgSelectorIndex.setStatus('current')
if mibBuilder.loadTexts: ipsecNewCfgSelectorIndex.setDescription('The index of ipsecNewCfgSelectorTable.')
ipsecNewCfgSelectorAction = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("unspecified", 0), ("permit", 1), ("deny", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsecNewCfgSelectorAction.setStatus('current')
if mibBuilder.loadTexts: ipsecNewCfgSelectorAction.setDescription('The action of the IPsec selector')
ipsecNewCfgSelectorProto = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 6, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("unspecified", 0), ("tcp", 1), ("icmp", 2), ("any", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsecNewCfgSelectorProto.setStatus('current')
if mibBuilder.loadTexts: ipsecNewCfgSelectorProto.setDescription('The protocol of the IPsec selector')
ipsecNewCfgSelectorIcmpType = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 6, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsecNewCfgSelectorIcmpType.setStatus('current')
if mibBuilder.loadTexts: ipsecNewCfgSelectorIcmpType.setDescription('When the protocol of the IPsec selector is icmp(2), This object specify the ICMP type for the traffic selector. 0 = any.')
ipsecNewCfgSelectorDst = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 6, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsecNewCfgSelectorDst.setStatus('current')
if mibBuilder.loadTexts: ipsecNewCfgSelectorDst.setDescription('The destination ipv6 address of the IPsec selector')
ipsecNewCfgSelectorDstPrefix = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 6, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 128))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsecNewCfgSelectorDstPrefix.setStatus('current')
if mibBuilder.loadTexts: ipsecNewCfgSelectorDstPrefix.setDescription('The destination ipv6 address prefix length of the IPsec selector')
ipsecNewCfgSelectorSrc = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 6, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsecNewCfgSelectorSrc.setStatus('current')
if mibBuilder.loadTexts: ipsecNewCfgSelectorSrc.setDescription('The source ip address of the IPsec selector')
ipsecNewCfgSelectorDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 6, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("delete", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecNewCfgSelectorDelete.setStatus('current')
if mibBuilder.loadTexts: ipsecNewCfgSelectorDelete.setDescription('Set a value of delete(2) for this object will delete the entry, A value of other(1) is always returned when this object is read.')
ipsecCurCfgDynamicPolicyTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 7), )
if mibBuilder.loadTexts: ipsecCurCfgDynamicPolicyTable.setStatus('current')
if mibBuilder.loadTexts: ipsecCurCfgDynamicPolicyTable.setDescription('The (conceptual) table listing all of the IPsec dynamic policies.')
ipsecCurCfgDynamicPolicyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 7, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ipsecCurCfgDynamicPolicyIndex"))
if mibBuilder.loadTexts: ipsecCurCfgDynamicPolicyEntry.setStatus('current')
if mibBuilder.loadTexts: ipsecCurCfgDynamicPolicyEntry.setDescription('An entry (conceptual row) representing a IPsec dynamic policy.')
ipsecCurCfgDynamicPolicyIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 7, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecCurCfgDynamicPolicyIndex.setStatus('current')
if mibBuilder.loadTexts: ipsecCurCfgDynamicPolicyIndex.setDescription('The index of ipsecCurCfgDynamicPolicyTable.')
ipsecCurCfgDynamicPolicyPeer = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 7, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecCurCfgDynamicPolicyPeer.setStatus('current')
if mibBuilder.loadTexts: ipsecCurCfgDynamicPolicyPeer.setDescription('The remote peer ip address.')
ipsecCurCfgDynamicPolicySelector = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 7, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecCurCfgDynamicPolicySelector.setStatus('current')
if mibBuilder.loadTexts: ipsecCurCfgDynamicPolicySelector.setDescription('The traffic selector index for IPsec policy to refer an entry in ipsecCurCfgSelectorTable. 0 = unspecified.')
ipsecCurCfgDynamicPolicyTxform = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 7, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecCurCfgDynamicPolicyTxform.setStatus('current')
if mibBuilder.loadTexts: ipsecCurCfgDynamicPolicyTxform.setDescription('The transform set index for IPSec policy to refer an entry in ipsecCurCfgTxformTable. 0 = unspecified.')
ipsecCurCfgDynamicPolicyLifetime = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 7, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(120, 86400))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecCurCfgDynamicPolicyLifetime.setStatus('current')
if mibBuilder.loadTexts: ipsecCurCfgDynamicPolicyLifetime.setDescription('The SA lifetime for an IPsec policy.')
ipsecCurCfgDynamicPolicyPfs = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 7, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecCurCfgDynamicPolicyPfs.setStatus('current')
if mibBuilder.loadTexts: ipsecCurCfgDynamicPolicyPfs.setDescription('Enable/disable perfect forward security.')
ipsecCurCfgDynamicPolicyDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 7, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("delete", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecCurCfgDynamicPolicyDelete.setStatus('current')
if mibBuilder.loadTexts: ipsecCurCfgDynamicPolicyDelete.setDescription('Set a value of delete(2) for this object will delete the entry, A value of other(1) is always returned when this object is read.')
ipsecNewCfgDynamicPolicyTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 8), )
if mibBuilder.loadTexts: ipsecNewCfgDynamicPolicyTable.setStatus('current')
if mibBuilder.loadTexts: ipsecNewCfgDynamicPolicyTable.setDescription('The (conceptual) table listing all of the IPsec dynamic policies.')
ipsecNewCfgDynamicPolicyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 8, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ipsecNewCfgDynamicPolicyIndex"))
if mibBuilder.loadTexts: ipsecNewCfgDynamicPolicyEntry.setStatus('current')
if mibBuilder.loadTexts: ipsecNewCfgDynamicPolicyEntry.setDescription('An entry (conceptual row) representing a IPsec dynamic policy.')
ipsecNewCfgDynamicPolicyIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 8, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecNewCfgDynamicPolicyIndex.setStatus('current')
if mibBuilder.loadTexts: ipsecNewCfgDynamicPolicyIndex.setDescription('The index of ipsecNewCfgDynamicPolicyTable.')
ipsecNewCfgDynamicPolicyPeer = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 8, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsecNewCfgDynamicPolicyPeer.setStatus('current')
if mibBuilder.loadTexts: ipsecNewCfgDynamicPolicyPeer.setDescription('The remote peer ip address.')
ipsecNewCfgDynamicPolicySelector = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 8, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsecNewCfgDynamicPolicySelector.setStatus('current')
if mibBuilder.loadTexts: ipsecNewCfgDynamicPolicySelector.setDescription('The traffic selector index for IPsec policy to refer an entry in ipsecNewCfgSelectorTable. 0 = unspecified.')
ipsecNewCfgDynamicPolicyTxform = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 8, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsecNewCfgDynamicPolicyTxform.setStatus('current')
if mibBuilder.loadTexts: ipsecNewCfgDynamicPolicyTxform.setDescription('The transform set index for IPSec policy to refer an entry in ipsecNewCfgTxformTable. 0 = unspecified.')
ipsecNewCfgDynamicPolicyLifetime = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 8, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(120, 86400))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsecNewCfgDynamicPolicyLifetime.setStatus('current')
if mibBuilder.loadTexts: ipsecNewCfgDynamicPolicyLifetime.setDescription('The SA lifetime for an IPsec policy.')
ipsecNewCfgDynamicPolicyPfs = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 8, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsecNewCfgDynamicPolicyPfs.setStatus('current')
if mibBuilder.loadTexts: ipsecNewCfgDynamicPolicyPfs.setDescription('Enable/disable perfect forward security.')
ipsecNewCfgDynamicPolicyDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 8, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("delete", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecNewCfgDynamicPolicyDelete.setStatus('current')
if mibBuilder.loadTexts: ipsecNewCfgDynamicPolicyDelete.setDescription('Set a value of delete(2) for this object will delete the entry, A value of other(1) is always returned when this object is read.')
ipsecCurCfgManualPolicyTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 9), )
if mibBuilder.loadTexts: ipsecCurCfgManualPolicyTable.setStatus('current')
if mibBuilder.loadTexts: ipsecCurCfgManualPolicyTable.setDescription('The (conceptual) table listing all of the IPsec manual policies.')
ipsecCurCfgManualPolicyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 9, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ipsecCurCfgManualPolicyIndex"))
if mibBuilder.loadTexts: ipsecCurCfgManualPolicyEntry.setStatus('current')
if mibBuilder.loadTexts: ipsecCurCfgManualPolicyEntry.setDescription('An entry (conceptual row) representing a IPsec manual policy.')
ipsecCurCfgManualPolicyIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 9, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecCurCfgManualPolicyIndex.setStatus('current')
if mibBuilder.loadTexts: ipsecCurCfgManualPolicyIndex.setDescription('The index of ipsecCurCfgManualPolicyTable.')
ipsecCurCfgManualPolicyPeer = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 9, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecCurCfgManualPolicyPeer.setStatus('current')
if mibBuilder.loadTexts: ipsecCurCfgManualPolicyPeer.setDescription('The remote peer ip address.')
ipsecCurCfgManualPolicySelector = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 9, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecCurCfgManualPolicySelector.setStatus('current')
if mibBuilder.loadTexts: ipsecCurCfgManualPolicySelector.setDescription('The traffic selector index for IPsec policy to refer an entry in ipsecCurCfgSelectorTable')
ipsecCurCfgManualPolicyTxform = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 9, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecCurCfgManualPolicyTxform.setStatus('current')
if mibBuilder.loadTexts: ipsecCurCfgManualPolicyTxform.setDescription('The transform set index for IPSec policy to refer an entry in ipsecCurCfgTxformTable')
ipsecCurCfgManualPolicyInAhKey = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 9, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecCurCfgManualPolicyInAhKey.setStatus('current')
if mibBuilder.loadTexts: ipsecCurCfgManualPolicyInAhKey.setDescription('The AH inbound session key for an IPsec policy.')
ipsecCurCfgManualPolicyInAhSpi = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 9, 1, 6), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(256, 4294967295), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecCurCfgManualPolicyInAhSpi.setStatus('current')
if mibBuilder.loadTexts: ipsecCurCfgManualPolicyInAhSpi.setDescription('The AH inbound SPI for an IPsec policy.')
ipsecCurCfgManualPolicyOutAhKey = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 9, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecCurCfgManualPolicyOutAhKey.setStatus('current')
if mibBuilder.loadTexts: ipsecCurCfgManualPolicyOutAhKey.setDescription('The AH outbound session key for an IPsec policy.')
ipsecCurCfgManualPolicyOutAhSpi = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 9, 1, 8), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(256, 4294967295), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecCurCfgManualPolicyOutAhSpi.setStatus('current')
if mibBuilder.loadTexts: ipsecCurCfgManualPolicyOutAhSpi.setDescription('The AH outbound SPI for an IPsec policy.')
ipsecCurCfgManualPolicyInEspEncKey = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 9, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecCurCfgManualPolicyInEspEncKey.setStatus('current')
if mibBuilder.loadTexts: ipsecCurCfgManualPolicyInEspEncKey.setDescription('The Esp inbound cipher key for an IPsec policy.')
ipsecCurCfgManualPolicyInEspAuthKey = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 9, 1, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecCurCfgManualPolicyInEspAuthKey.setStatus('current')
if mibBuilder.loadTexts: ipsecCurCfgManualPolicyInEspAuthKey.setDescription('The Esp inbound authenticator key for an IPsec policy.')
ipsecCurCfgManualPolicyInEspSpi = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 9, 1, 11), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(256, 4294967295), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecCurCfgManualPolicyInEspSpi.setStatus('current')
if mibBuilder.loadTexts: ipsecCurCfgManualPolicyInEspSpi.setDescription('The Esp inbound SPI for an IPsec policy.')
ipsecCurCfgManualPolicyOutEspEncKey = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 9, 1, 12), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecCurCfgManualPolicyOutEspEncKey.setStatus('current')
if mibBuilder.loadTexts: ipsecCurCfgManualPolicyOutEspEncKey.setDescription('The Esp outbound cipher key for an IPsec policy.')
ipsecCurCfgManualPolicyOutEspAuthKey = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 9, 1, 13), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecCurCfgManualPolicyOutEspAuthKey.setStatus('current')
if mibBuilder.loadTexts: ipsecCurCfgManualPolicyOutEspAuthKey.setDescription('The Esp outbound authenticator key for an IPsec policy.')
ipsecCurCfgManualPolicyOutEspSpi = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 9, 1, 14), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(256, 4294967295), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecCurCfgManualPolicyOutEspSpi.setStatus('current')
if mibBuilder.loadTexts: ipsecCurCfgManualPolicyOutEspSpi.setDescription('The Esp outbound SPI for an IPsec policy.')
ipsecCurCfgManualPolicyDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 9, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("delete", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecCurCfgManualPolicyDelete.setStatus('current')
if mibBuilder.loadTexts: ipsecCurCfgManualPolicyDelete.setDescription('Set a value of delete(2) for this object will delete the entry, A value of other(1) is always returned when this object is read.')
ipsecNewCfgManualPolicyTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 10), )
if mibBuilder.loadTexts: ipsecNewCfgManualPolicyTable.setStatus('current')
if mibBuilder.loadTexts: ipsecNewCfgManualPolicyTable.setDescription('The (conceptual) table listing all of the IPsec manual policies.')
ipsecNewCfgManualPolicyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 10, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ipsecNewCfgManualPolicyIndex"))
if mibBuilder.loadTexts: ipsecNewCfgManualPolicyEntry.setStatus('current')
if mibBuilder.loadTexts: ipsecNewCfgManualPolicyEntry.setDescription('An entry (conceptual row) representing a IPsec manual policy.')
ipsecNewCfgManualPolicyIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecNewCfgManualPolicyIndex.setStatus('current')
if mibBuilder.loadTexts: ipsecNewCfgManualPolicyIndex.setDescription('The index of ipsecNewCfgManualPolicyTable.')
ipsecNewCfgManualPolicyPeer = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 10, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsecNewCfgManualPolicyPeer.setStatus('current')
if mibBuilder.loadTexts: ipsecNewCfgManualPolicyPeer.setDescription('The remote peer ip address.')
ipsecNewCfgManualPolicySelector = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsecNewCfgManualPolicySelector.setStatus('current')
if mibBuilder.loadTexts: ipsecNewCfgManualPolicySelector.setDescription('The traffic selector index for IPsec policy to refer an entry in ipsecNewCfgSelectorTable')
ipsecNewCfgManualPolicyTxform = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsecNewCfgManualPolicyTxform.setStatus('current')
if mibBuilder.loadTexts: ipsecNewCfgManualPolicyTxform.setDescription('The transform set index for IPSec policy to refer an entry in ipsecNewCfgTxformTable')
ipsecNewCfgManualPolicyInAhKey = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 10, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsecNewCfgManualPolicyInAhKey.setStatus('current')
if mibBuilder.loadTexts: ipsecNewCfgManualPolicyInAhKey.setDescription('The AH inbound session key for an IPsec policy.')
ipsecNewCfgManualPolicyInAhSpi = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 10, 1, 6), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(256, 4294967295), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsecNewCfgManualPolicyInAhSpi.setStatus('current')
if mibBuilder.loadTexts: ipsecNewCfgManualPolicyInAhSpi.setDescription('The AH inbound SPI for an IPsec policy.')
ipsecNewCfgManualPolicyOutAhKey = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 10, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsecNewCfgManualPolicyOutAhKey.setStatus('current')
if mibBuilder.loadTexts: ipsecNewCfgManualPolicyOutAhKey.setDescription('The AH outbound session key for an IPsec policy.')
ipsecNewCfgManualPolicyOutAhSpi = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 10, 1, 8), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(256, 4294967295), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsecNewCfgManualPolicyOutAhSpi.setStatus('current')
if mibBuilder.loadTexts: ipsecNewCfgManualPolicyOutAhSpi.setDescription('The AH outbound SPI for an IPsec policy.')
ipsecNewCfgManualPolicyInEspEncKey = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 10, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsecNewCfgManualPolicyInEspEncKey.setStatus('current')
if mibBuilder.loadTexts: ipsecNewCfgManualPolicyInEspEncKey.setDescription('The Esp inbound cipher key for an IPsec policy.')
ipsecNewCfgManualPolicyInEspAuthKey = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 10, 1, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsecNewCfgManualPolicyInEspAuthKey.setStatus('current')
if mibBuilder.loadTexts: ipsecNewCfgManualPolicyInEspAuthKey.setDescription('The Esp inbound authenticator key for an IPsec policy.')
ipsecNewCfgManualPolicyInEspSpi = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 10, 1, 11), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(256, 4294967295), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsecNewCfgManualPolicyInEspSpi.setStatus('current')
if mibBuilder.loadTexts: ipsecNewCfgManualPolicyInEspSpi.setDescription('The Esp inbound SPI for an IPsec policy.')
ipsecNewCfgManualPolicyOutEspEncKey = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 10, 1, 12), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsecNewCfgManualPolicyOutEspEncKey.setStatus('current')
if mibBuilder.loadTexts: ipsecNewCfgManualPolicyOutEspEncKey.setDescription('The Esp outbound cipher key for an IPsec policy.')
ipsecNewCfgManualPolicyOutEspAuthKey = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 10, 1, 13), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsecNewCfgManualPolicyOutEspAuthKey.setStatus('current')
if mibBuilder.loadTexts: ipsecNewCfgManualPolicyOutEspAuthKey.setDescription('The Esp outbound authenticator key for an IPsec policy.')
ipsecNewCfgManualPolicyOutEspSpi = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 10, 1, 14), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(256, 4294967295), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsecNewCfgManualPolicyOutEspSpi.setStatus('current')
if mibBuilder.loadTexts: ipsecNewCfgManualPolicyOutEspSpi.setDescription('The Esp outbound SPI for an IPsec policy.')
ipsecNewCfgManualPolicyDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 10, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("delete", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecNewCfgManualPolicyDelete.setStatus('current')
if mibBuilder.loadTexts: ipsecNewCfgManualPolicyDelete.setDescription('Set a value of delete(2) for this object will delete the entry, A value of other(1) is always returned when this object is read.')
ipsecCurCfgIfTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 11), )
if mibBuilder.loadTexts: ipsecCurCfgIfTable.setStatus('current')
if mibBuilder.loadTexts: ipsecCurCfgIfTable.setDescription('The table of interface IPsec policy configuration.')
ipsecCurCfgIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 11, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ipsecCurCfgIfIndex"))
if mibBuilder.loadTexts: ipsecCurCfgIfEntry.setStatus('current')
if mibBuilder.loadTexts: ipsecCurCfgIfEntry.setDescription('The table of interface IPsec policy configuration.')
ipsecCurCfgIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 11, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecCurCfgIfIndex.setStatus('current')
if mibBuilder.loadTexts: ipsecCurCfgIfIndex.setDescription('The identifier of a particular interface.')
ipsecCurCfgIfDynamicPolicyBmap = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 11, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecCurCfgIfDynamicPolicyBmap.setStatus('current')
if mibBuilder.loadTexts: ipsecCurCfgIfDynamicPolicyBmap.setDescription('The IPsec dynamic policies applied to the IP interface. The policies are presented in bitmap format. This string displays policy number from 1 to 32. in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ policy 9 || || || ||___ policy 8 || |____ policy 7 || . . . ||_________ policy 2 |__________ policy 1 where x : 1 - The represented policy applied to the IP interface. 0 - The represented policy not applied to the IP interface.')
ipsecCurCfgIfManualPolicyBmap = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 11, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecCurCfgIfManualPolicyBmap.setStatus('current')
if mibBuilder.loadTexts: ipsecCurCfgIfManualPolicyBmap.setDescription('The manual policies applied to the IP interface. The policies are presented in bitmap format. This string displays policy number from 1 to 32. in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ policy 9 || || || ||___ policy 8 || |____ policy 7 || . . . ||_________ policy 2 |__________ policy 1 where x : 1 - The represented policy applied to the IP interface. 0 - The represented policy not applied to the IP interface.')
ipsecCurCfgIfDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 11, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("delete", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecCurCfgIfDelete.setStatus('current')
if mibBuilder.loadTexts: ipsecCurCfgIfDelete.setDescription('Set a value of delete(2) for this object will delete the entry, A value of other(1) is always returned when this object is read.')
ipsecNewCfgIfTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 12), )
if mibBuilder.loadTexts: ipsecNewCfgIfTable.setStatus('current')
if mibBuilder.loadTexts: ipsecNewCfgIfTable.setDescription('The table of interface IPsec policy configuration.')
ipsecNewCfgIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 12, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ipsecNewCfgIfIndex"))
if mibBuilder.loadTexts: ipsecNewCfgIfEntry.setStatus('current')
if mibBuilder.loadTexts: ipsecNewCfgIfEntry.setDescription('The table of interface IPsec policy configuration.')
ipsecNewCfgIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 12, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecNewCfgIfIndex.setStatus('current')
if mibBuilder.loadTexts: ipsecNewCfgIfIndex.setDescription('The identifier of a particular interface.')
ipsecNewCfgIfDynamicPolicyBmap = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 12, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecNewCfgIfDynamicPolicyBmap.setStatus('current')
if mibBuilder.loadTexts: ipsecNewCfgIfDynamicPolicyBmap.setDescription('The dynamic policies applied to the IP interface. The policies are presented in bitmap format. This string displays policy number from 1 to 32. in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ policy 9 || || || ||___ policy 8 || |____ policy 7 || . . . ||_________ policy 2 |__________ policy 1 where x : 1 - The represented policy applied to the IP interface. 0 - The represented policy not applied to the IP interface.')
ipsecNewCfgIfAddDynamicPolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 12, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsecNewCfgIfAddDynamicPolicy.setStatus('current')
if mibBuilder.loadTexts: ipsecNewCfgIfAddDynamicPolicy.setDescription('Set the value to a IPsec dynamic policy ID when add the policy to IP interface. A value of 0 is always returned when this object is read.')
ipsecNewCfgIfDelDynamicPolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 12, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsecNewCfgIfDelDynamicPolicy.setStatus('current')
if mibBuilder.loadTexts: ipsecNewCfgIfDelDynamicPolicy.setDescription('Set the value to a IPsec dynamic policy ID when delete the policy to IP interface. A value of 0 is always returned when this object is read.')
ipsecNewCfgIfManualPolicyBmap = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 12, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecNewCfgIfManualPolicyBmap.setStatus('current')
if mibBuilder.loadTexts: ipsecNewCfgIfManualPolicyBmap.setDescription('The manual policies applied to the IP interface. The policies are presented in bitmap format. This string displays policy number from 1 to 32. in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ policy 9 || || || ||___ policy 8 || |____ policy 7 || . . . ||_________ policy 2 |__________ policy 1 where x : 1 - The represented policy applied to the IP interface. 0 - The represented policy not applied to the IP interface.')
ipsecNewCfgIfAddManualPolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 12, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsecNewCfgIfAddManualPolicy.setStatus('current')
if mibBuilder.loadTexts: ipsecNewCfgIfAddManualPolicy.setDescription('Set the value to a IPsec manual policy ID when add the policy to IP interface. A value of 0 is always returned when this object is read.')
ipsecNewCfgIfDelManualPolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 12, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsecNewCfgIfDelManualPolicy.setStatus('current')
if mibBuilder.loadTexts: ipsecNewCfgIfDelManualPolicy.setDescription('Set the value to a IPsec manual policy ID when delete the policy to IP interface. A value of 0 is always returned when this object is read.')
ipsecNewCfgIfDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 1, 32, 2, 12, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("delete", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecNewCfgIfDelete.setStatus('current')
if mibBuilder.loadTexts: ipsecNewCfgIfDelete.setDescription('Set a value of delete(2) for this object will delete the entry, A value of other(1) is always returned when this object is read.')
ipsecSaStatsTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 24, 1), )
if mibBuilder.loadTexts: ipsecSaStatsTable.setStatus('current')
if mibBuilder.loadTexts: ipsecSaStatsTable.setDescription('The (conceptual) table listing all of the IPsec SA statistics.')
ipsecSaStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 24, 1, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ipsecSaStatsIndex"))
if mibBuilder.loadTexts: ipsecSaStatsEntry.setStatus('current')
if mibBuilder.loadTexts: ipsecSaStatsEntry.setDescription('An entry (conceptual row) representing a IPsec SA statistics.')
ipsecSaStatsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 24, 1, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaStatsIndex.setStatus('current')
if mibBuilder.loadTexts: ipsecSaStatsIndex.setDescription('The index of ipsecSaStatsEntry.')
ipsecSaStatsSpi = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 24, 1, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaStatsSpi.setStatus('current')
if mibBuilder.loadTexts: ipsecSaStatsSpi.setDescription('The SPI used by the SA.')
ipsecSaStatsProto = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 24, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("any", 0), ("ah", 1), ("esp", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaStatsProto.setStatus('current')
if mibBuilder.loadTexts: ipsecSaStatsProto.setDescription('The proto(AH,ESP,or Both) used by the SA.')
ipsecSaStatsDstAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 24, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaStatsDstAddr.setStatus('current')
if mibBuilder.loadTexts: ipsecSaStatsDstAddr.setDescription('The destination IP address for the SA.')
ipsecSaStatsUsageTime = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 24, 1, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaStatsUsageTime.setStatus('current')
if mibBuilder.loadTexts: ipsecSaStatsUsageTime.setDescription('The time (in seconds) since the SA was first used.')
ipsecSaStatsBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 24, 1, 1, 6), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaStatsBytes.setStatus('current')
if mibBuilder.loadTexts: ipsecSaStatsBytes.setDescription('The count of bytes for the SA.')
ipsecSaStatsPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 2, 24, 1, 1, 7), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaStatsPkts.setStatus('current')
if mibBuilder.loadTexts: ipsecSaStatsPkts.setDescription('The number of packets sent or received for the SA.')
ipsecSaInfoTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 23, 1), )
if mibBuilder.loadTexts: ipsecSaInfoTable.setStatus('current')
if mibBuilder.loadTexts: ipsecSaInfoTable.setDescription('The (conceptual) table listing all of the IPsec SA information.')
ipsecSaInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 23, 1, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ipsecSaInfoIndex"))
if mibBuilder.loadTexts: ipsecSaInfoEntry.setStatus('current')
if mibBuilder.loadTexts: ipsecSaInfoEntry.setDescription('An entry (conceptual row) representing a IPsec SA information.')
ipsecSaInfoIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 23, 1, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaInfoIndex.setStatus('current')
if mibBuilder.loadTexts: ipsecSaInfoIndex.setDescription('The index of ipsecSaInfoEntry.')
ipsecSaInfoSpi = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 23, 1, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaInfoSpi.setStatus('current')
if mibBuilder.loadTexts: ipsecSaInfoSpi.setDescription('The SPI used by the SA.')
ipsecSaInfoProto = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 23, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 51, 50))).clone(namedValues=NamedValues(("any", 0), ("ah", 51), ("esp", 50)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaInfoProto.setStatus('current')
if mibBuilder.loadTexts: ipsecSaInfoProto.setDescription('The proto(AH,ESP,or Both) used by the SA.')
ipsecSaInfoDstAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 23, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaInfoDstAddr.setStatus('current')
if mibBuilder.loadTexts: ipsecSaInfoDstAddr.setDescription('The destination IP address for the SA.')
ipsecSaInfoSrcAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 23, 1, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaInfoSrcAddr.setStatus('current')
if mibBuilder.loadTexts: ipsecSaInfoSrcAddr.setDescription('The source IP address for the SA.')
ipsecSaInfoFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 23, 1, 1, 6), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaInfoFlags.setStatus('current')
if mibBuilder.loadTexts: ipsecSaInfoFlags.setDescription('The direction, initiator and etc for an SA; see flag constants below: SA_FLAG_INUSE 0x0001 SA_FLAG_DELETED 0x0002 SA_FLAG_INBOUND 0x0004 SA_FLAG_INITIATOR 0x0008 SA_FLAG_MATURE 0x0010 SA_FLAG_MIRRORED 0x0100 SA_FLAG_IP6 0x0200 SA_FLAG_IKE2 0x0400 SA_FLAG_PFS 0x0800 ')
ipsecSaInfoUlp = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 23, 1, 1, 7), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaInfoUlp.setStatus('current')
if mibBuilder.loadTexts: ipsecSaInfoUlp.setDescription('The upper layer protocol for an SA; 0=any; see protocol constants below: ICMP 1 IPv4 4 TCP 6 UDP 17 ESP 50 AH 51 IPv6 41 ICMPv6 58 ')
ipsecSaInfoMode = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 23, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("any", 0), ("transport", 1), ("tunnel", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaInfoMode.setStatus('current')
if mibBuilder.loadTexts: ipsecSaInfoMode.setDescription('The mode for the SA.')
ipsecSaInfoAuthAlg = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 23, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("any", 0), ("md5", 1), ("sha1", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaInfoAuthAlg.setStatus('current')
if mibBuilder.loadTexts: ipsecSaInfoAuthAlg.setDescription('The authentication algorithm for the SA.')
ipsecSaInfoAuthKey = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 23, 1, 1, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(20, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaInfoAuthKey.setStatus('current')
if mibBuilder.loadTexts: ipsecSaInfoAuthKey.setDescription('The authentication key for the SA.')
ipsecSaInfoEncrAlg = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 23, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("any", 0), ("des", 1), ("triple-des", 2), ("blowfish", 3), ("aes", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaInfoEncrAlg.setStatus('current')
if mibBuilder.loadTexts: ipsecSaInfoEncrAlg.setDescription('The encryption algorithm for the SA.')
ipsecSaInfoEncrKey = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 23, 1, 1, 12), OctetString().subtype(subtypeSpec=ValueSizeConstraint(20, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaInfoEncrKey.setStatus('current')
if mibBuilder.loadTexts: ipsecSaInfoEncrKey.setDescription('The encryption key for the SA.')
ipsecSpdInfoTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 23, 2), )
if mibBuilder.loadTexts: ipsecSpdInfoTable.setStatus('current')
if mibBuilder.loadTexts: ipsecSpdInfoTable.setDescription('The (conceptual) table listing all of the IPsec security policy information.')
ipsecSpdInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 23, 2, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ipsecSpdInfoIndex"))
if mibBuilder.loadTexts: ipsecSpdInfoEntry.setStatus('current')
if mibBuilder.loadTexts: ipsecSpdInfoEntry.setDescription('An entry (conceptual row) representing a IPsec security policy information.')
ipsecSpdInfoIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 23, 2, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSpdInfoIndex.setStatus('current')
if mibBuilder.loadTexts: ipsecSpdInfoIndex.setDescription('The index of ipsecSpdInfoEntry.')
ipsecSpdInfoFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 23, 2, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSpdInfoFlags.setStatus('current')
if mibBuilder.loadTexts: ipsecSpdInfoFlags.setDescription('The direction, initiator and etc for an SA; see flag constants below: SP_FLAG_INUSE 0x00000001 SP_FLAG_DELETED 0x00000002 SP_FLAG_INBOUND 0x00000004 SP_FLAG_MIRRORED 0x00000008 SP_FLAG_PFP_LADDR 0x00000100 SP_FLAG_PFP_RADDR 0x00000200 SP_FLAG_PFP_LPORT 0x00000400 SP_FLAG_PFP_RPORT 0x00000800 SP_FLAG_PFP_ULP 0x00001000 SP_MASK_PFP 0x00001f00 SP_FLAG_DF 0x00002000 SP_FLAG_DF_BIT 0x00004000 SP_MASK_DF 0x00006000 SP_FLAG_DSCP 0x00008000 SP_FLAG_ECN 0x00010000 SP_FLAG_IP6 0x00000010 SP_FLAG_IP6_TUNNEL 0x00000020 SP_FLAG_INIT 0x00000040 ')
ipsecSpdInfoULP = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 23, 2, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSpdInfoULP.setStatus('current')
if mibBuilder.loadTexts: ipsecSpdInfoULP.setDescription('The transport layer protocol for the SA. 0 = any. see protocol constants below: ICMP 1 IPv4 4 TCP 6 UDP 17 ESP 50 AH 51 IPv6 41 ICMPv6 58 ')
ipsecSpdInfoAction = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 23, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("drop", 1), ("apply", 2), ("permit", 3), ("bypass", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSpdInfoAction.setStatus('current')
if mibBuilder.loadTexts: ipsecSpdInfoAction.setDescription('The IPsec action for the SA.')
ipsecSpdInfoDstAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 23, 2, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSpdInfoDstAddr.setStatus('current')
if mibBuilder.loadTexts: ipsecSpdInfoDstAddr.setDescription('The destination IP address for the SA.')
ipsecSpdInfoSrcAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 23, 2, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSpdInfoSrcAddr.setStatus('current')
if mibBuilder.loadTexts: ipsecSpdInfoSrcAddr.setDescription('The source IP address for the SA.')
ipsecSpdInfoMode = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 23, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("any", 0), ("transport", 1), ("tunnel", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSpdInfoMode.setStatus('current')
if mibBuilder.loadTexts: ipsecSpdInfoMode.setDescription('The mode for the SA.')
ipsecSpdInfoSaSize = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 23, 2, 1, 8), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSpdInfoSaSize.setStatus('current')
if mibBuilder.loadTexts: ipsecSpdInfoSaSize.setDescription('The SA bundle size of an Security policy.')
ipsecSpdInfoSaTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 23, 3), )
if mibBuilder.loadTexts: ipsecSpdInfoSaTable.setStatus('current')
if mibBuilder.loadTexts: ipsecSpdInfoSaTable.setDescription('The (conceptual) table listing all information of the SA nested in an IPsec security policy.')
ipsecSpdInfoSaEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 23, 3, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ipsecSpdInfoIndex"), (0, "IBM-GbTOR-10G-L2L3-MIB", "ipsecSpdInfoSaIndex"))
if mibBuilder.loadTexts: ipsecSpdInfoSaEntry.setStatus('current')
if mibBuilder.loadTexts: ipsecSpdInfoSaEntry.setDescription('An entry (conceptual row) representing a SA information netsted in an IPsec security policy.')
ipsecSpdInfoSaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 23, 3, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSpdInfoSaIndex.setStatus('current')
if mibBuilder.loadTexts: ipsecSpdInfoSaIndex.setDescription('The index that enumerates the IPsec nested SAs .')
ipsecSpdInfoSaSecuProto = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 23, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("ah", 0), ("esp", 1), ("esp-auth", 2), ("esp-null", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSpdInfoSaSecuProto.setStatus('current')
if mibBuilder.loadTexts: ipsecSpdInfoSaSecuProto.setDescription('The security protocol for the SA.')
ipsecSpdInfoSaAuthAlg = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 23, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("any", 0), ("md5", 1), ("sha1", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSpdInfoSaAuthAlg.setStatus('current')
if mibBuilder.loadTexts: ipsecSpdInfoSaAuthAlg.setDescription('The hash algorithm used by the SA.')
ipsecSpdInfoSaEncrAlg = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 23, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("any", 0), ("des", 1), ("triple-des", 2), ("blowfish", 3), ("aes", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSpdInfoSaEncrAlg.setStatus('current')
if mibBuilder.loadTexts: ipsecSpdInfoSaEncrAlg.setDescription('The encryption algorithm used by the SA.')
ipsecSpdInfoSaEncrKeyLen = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 3, 3, 23, 3, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSpdInfoSaEncrKeyLen.setStatus('current')
if mibBuilder.loadTexts: ipsecSpdInfoSaEncrKeyLen.setDescription('The encryption key length of an nested SA.')
traps = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 7))
swTrapDisplayString = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 7, 1000), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swTrapDisplayString.setStatus('current')
if mibBuilder.loadTexts: swTrapDisplayString.setDescription('Temporary string object used to store information being sent in a Switch trap.')
ibmSNMPv2Notifications = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 7, 0))
swPrimaryPowerSupplyFailureNotify = NotificationType((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 7, 0, 1)).setObjects(("IBM-GbTOR-10G-L2L3-MIB", "swTrapDisplayString"), ("SNMPv2-MIB", "sysName"), ("SNMPv2-MIB", "sysLocation"), ("SNMPv2-MIB", "sysContact"))
if mibBuilder.loadTexts: swPrimaryPowerSupplyFailureNotify.setStatus('current')
if mibBuilder.loadTexts: swPrimaryPowerSupplyFailureNotify.setDescription('A swPrimaryPowerSupplyFailure trap signifies that the primary power supply failed.')
swPrimaryPowerSupplyFixedNotify = NotificationType((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 7, 0, 97)).setObjects(("IBM-GbTOR-10G-L2L3-MIB", "swTrapDisplayString"), ("SNMPv2-MIB", "sysName"), ("SNMPv2-MIB", "sysLocation"), ("SNMPv2-MIB", "sysContact"))
if mibBuilder.loadTexts: swPrimaryPowerSupplyFixedNotify.setStatus('current')
if mibBuilder.loadTexts: swPrimaryPowerSupplyFixedNotify.setDescription('A swPrimaryPowerSupplyFixed trap signifies that the primary power supply has been restored.')
swPrimaryPowerSupplyFailure = NotificationType((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 7) + (0,1)).setObjects(("IBM-GbTOR-10G-L2L3-MIB", "swTrapDisplayString"), ("SNMPv2-MIB", "sysName"), ("SNMPv2-MIB", "sysLocation"), ("SNMPv2-MIB", "sysContact"))
if mibBuilder.loadTexts: swPrimaryPowerSupplyFailure.setDescription('A swPrimaryPowerSupplyFailure trap signifies that the primary power supply failed.')
swDefGwUp = NotificationType((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 7) + (0,2)).setObjects(("IBM-GbTOR-10G-L2L3-MIB", "swTrapDisplayString"), ("IBM-GbTOR-10G-L2L3-MIB", "ipCurCfgGwIndex"), ("IBM-GbTOR-10G-L2L3-MIB", "ipCurCfgGwAddr"), ("SNMPv2-MIB", "sysName"), ("SNMPv2-MIB", "sysLocation"), ("SNMPv2-MIB", "sysContact"))
if mibBuilder.loadTexts: swDefGwUp.setDescription('A swDefGwUp trap signifies that the default gateway is alive. ipCurCfgGwIndex is the index of the Gateway in ipCurCfgGwTable. The range for ipCurCfgGwIndex is from 1 to ipGatewayTableMax. ipCurCfgGwAddr is the IP address of the default gateway.')
swDefGwDown = NotificationType((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 7) + (0,3)).setObjects(("IBM-GbTOR-10G-L2L3-MIB", "swTrapDisplayString"), ("IBM-GbTOR-10G-L2L3-MIB", "ipCurCfgGwIndex"), ("IBM-GbTOR-10G-L2L3-MIB", "ipCurCfgGwAddr"), ("SNMPv2-MIB", "sysName"), ("SNMPv2-MIB", "sysLocation"), ("SNMPv2-MIB", "sysContact"))
if mibBuilder.loadTexts: swDefGwDown.setDescription('A swDefGwDown trap signifies that the default gateway is down. ipCurCfgGwIndex is the index of the Gateway in ipCurCfgGwTable. The range for ipCurCfgGwIndex is from 1 to ipGatewayTableMax. ipCurCfgGwAddr is the IP address of the default gateway.')
swDefGwInService = NotificationType((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 7) + (0,4)).setObjects(("IBM-GbTOR-10G-L2L3-MIB", "swTrapDisplayString"), ("IBM-GbTOR-10G-L2L3-MIB", "ipCurCfgGwIndex"), ("IBM-GbTOR-10G-L2L3-MIB", "ipCurCfgGwAddr"), ("SNMPv2-MIB", "sysName"), ("SNMPv2-MIB", "sysLocation"), ("SNMPv2-MIB", "sysContact"))
if mibBuilder.loadTexts: swDefGwInService.setDescription('A swDefGwInService trap signifies that the default gateway is up and in service. ipCurCfgGwIndex is the index of the Gateway in ipCurCfgGwTable. The range for ipCurCfgGwIndex is from 1 to ipGatewayTableMax. ipCurCfgGwAddr is the IP address of the default gateway.')
swDefGwNotInService = NotificationType((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 7) + (0,5)).setObjects(("IBM-GbTOR-10G-L2L3-MIB", "swTrapDisplayString"), ("IBM-GbTOR-10G-L2L3-MIB", "ipCurCfgGwIndex"), ("IBM-GbTOR-10G-L2L3-MIB", "ipCurCfgGwAddr"), ("SNMPv2-MIB", "sysName"), ("SNMPv2-MIB", "sysLocation"), ("SNMPv2-MIB", "sysContact"))
if mibBuilder.loadTexts: swDefGwNotInService.setDescription('A swDefGwNotInService trap signifies that the default gateway is alive but not in service. ipCurCfgGwIndex is the index of the Gateway in ipCurCfgGwTable. The range for ipCurCfgGwIndex is from 1 to ipGatewayTableMax. ipCurCfgGwAddr is the IP address of the default gateway.')
swVrrpNewMaster = NotificationType((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 7) + (0,16)).setObjects(("IBM-GbTOR-10G-L2L3-MIB", "swTrapDisplayString"), ("IBM-GbTOR-10G-L2L3-MIB", "vrrpCurCfgVirtRtrIndx"), ("IBM-GbTOR-10G-L2L3-MIB", "vrrpCurCfgVirtRtrAddr"), ("SNMPv2-MIB", "sysName"), ("SNMPv2-MIB", "sysLocation"), ("SNMPv2-MIB", "sysContact"))
if mibBuilder.loadTexts: swVrrpNewMaster.setDescription("The swVrrpNewMaster trap indicates that the sending agent has transitioned to 'Master' state. vrrpCurCfgVirtRtrIndx is the VRRP virtual router table index referenced in vrrpCurCfgVirtRtrTable. The range is from 1 to vrrpVirtRtrTableMaxSize. vrrpCurCfgVirtRtrAddr is the VRRP virtual router IP address.")
swVrrpNewBackup = NotificationType((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 7) + (0,17)).setObjects(("IBM-GbTOR-10G-L2L3-MIB", "swTrapDisplayString"), ("IBM-GbTOR-10G-L2L3-MIB", "vrrpCurCfgVirtRtrIndx"), ("IBM-GbTOR-10G-L2L3-MIB", "vrrpCurCfgVirtRtrAddr"), ("SNMPv2-MIB", "sysName"), ("SNMPv2-MIB", "sysLocation"), ("SNMPv2-MIB", "sysContact"))
if mibBuilder.loadTexts: swVrrpNewBackup.setDescription("The swVrrpNewBackup trap indicates that the sending agent has transitioned to 'Backup' state. vrrpCurCfgVirtRtrIndx is the VRRP virtual router table index referenced in vrrpCurCfgVirtRtrTable. The range is from 1 to vrrpVirtRtrTableMaxSize. vrrpCurCfgVirtRtrAddr is the VRRP virtual router IP address.")
swVrrpAuthFailure = NotificationType((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 7) + (0,18)).setObjects(("IBM-GbTOR-10G-L2L3-MIB", "swTrapDisplayString"), ("IBM-GbTOR-10G-L2L3-MIB", "vrrpCurCfgIfIndx"), ("IBM-GbTOR-10G-L2L3-MIB", "vrrpCurCfgIfPasswd"), ("SNMPv2-MIB", "sysName"), ("SNMPv2-MIB", "sysLocation"), ("SNMPv2-MIB", "sysContact"))
if mibBuilder.loadTexts: swVrrpAuthFailure.setDescription("A swVrrpAuthFailure trap signifies that a packet has been received from a router whose authentication key or authentication type conflicts with this router's authentication key or authentication type. Implementation of this trap is optional. vrrpCurCfgIfIndx is the VRRP interface index. This is equivalent to ifIndex in RFC 1213 mib. The range is from 1 to vrrpIfTableMaxSize. vrrpCurCfgIfPasswd is the password for authentication. It is a DisplayString of 0 to 7 characters.")
swLoginFailure = NotificationType((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 7) + (0,19)).setObjects(("IBM-GbTOR-10G-L2L3-MIB", "swTrapDisplayString"), ("SNMPv2-MIB", "sysName"), ("SNMPv2-MIB", "sysLocation"), ("SNMPv2-MIB", "sysContact"))
if mibBuilder.loadTexts: swLoginFailure.setDescription('A swLoginFailure trap signifies that someone failed to enter a valid username/password combination. swTrapDisplayString specifies whether the login attempt was from CONSOLE or TELNET. In case of TELNET login it also specifies the IP address of the host from which the attempt was made.')
swTempExceedThreshold = NotificationType((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 7) + (0,22)).setObjects(("IBM-GbTOR-10G-L2L3-MIB", "swTrapDisplayString"), ("SNMPv2-MIB", "sysName"), ("SNMPv2-MIB", "sysLocation"), ("SNMPv2-MIB", "sysContact"))
if mibBuilder.loadTexts: swTempExceedThreshold.setDescription('A swTempExceedThreshold trap signifies that the switch temperature has exceeded maximum safety limits.')
swFanFailure = NotificationType((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 7) + (0,24)).setObjects(("IBM-GbTOR-10G-L2L3-MIB", "swTrapDisplayString"), ("SNMPv2-MIB", "sysName"), ("SNMPv2-MIB", "sysLocation"), ("SNMPv2-MIB", "sysContact"))
if mibBuilder.loadTexts: swFanFailure.setDescription('A swFanFailure trap signifies that the fan failure has been detected.')
swValidLogin = NotificationType((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 7) + (0,25)).setObjects(("IBM-GbTOR-10G-L2L3-MIB", "swTrapDisplayString"), ("SNMPv2-MIB", "sysName"), ("SNMPv2-MIB", "sysLocation"), ("SNMPv2-MIB", "sysContact"))
if mibBuilder.loadTexts: swValidLogin.setDescription('A swValidLogin trap signifies that a user login has occured.')
swApplyComplete = NotificationType((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 7) + (0,27)).setObjects(("IBM-GbTOR-10G-L2L3-MIB", "swTrapDisplayString"), ("SNMPv2-MIB", "sysName"), ("SNMPv2-MIB", "sysLocation"), ("SNMPv2-MIB", "sysContact"))
if mibBuilder.loadTexts: swApplyComplete.setDescription('A swApplyComplete signifies that new configuration has been applied.')
swSaveComplete = NotificationType((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 7) + (0,28)).setObjects(("IBM-GbTOR-10G-L2L3-MIB", "swTrapDisplayString"), ("SNMPv2-MIB", "sysName"), ("SNMPv2-MIB", "sysLocation"), ("SNMPv2-MIB", "sysContact"))
if mibBuilder.loadTexts: swSaveComplete.setDescription('A swApplyComplete signifies that new configuration has been saved.')
swFwDownloadSucess = NotificationType((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 7) + (0,29)).setObjects(("IBM-GbTOR-10G-L2L3-MIB", "swTrapDisplayString"), ("SNMPv2-MIB", "sysName"), ("SNMPv2-MIB", "sysLocation"), ("SNMPv2-MIB", "sysContact"))
if mibBuilder.loadTexts: swFwDownloadSucess.setDescription('A swFwDownloadSuccess signifies that firmware has been downloaded to [image1|image2|boot image].')
swFwDownloadFailure = NotificationType((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 7) + (0,30)).setObjects(("IBM-GbTOR-10G-L2L3-MIB", "swTrapDisplayString"), ("SNMPv2-MIB", "sysName"), ("SNMPv2-MIB", "sysLocation"), ("SNMPv2-MIB", "sysContact"))
if mibBuilder.loadTexts: swFwDownloadFailure.setDescription('A swFwDownloadFailure signifies that firmware downloaded failed to [image1|image2|boot image].')
swFanFailureFixed = NotificationType((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 7) + (0,33)).setObjects(("IBM-GbTOR-10G-L2L3-MIB", "swTrapDisplayString"), ("SNMPv2-MIB", "sysName"), ("SNMPv2-MIB", "sysLocation"), ("SNMPv2-MIB", "sysContact"))
if mibBuilder.loadTexts: swFanFailureFixed.setDescription('A swFanFailureFixed trap signifies that the fan failure has been fixed.')
swStgNewRoot = NotificationType((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 7) + (0,42)).setObjects(("IBM-GbTOR-10G-L2L3-MIB", "swTrapDisplayString"), ("IBM-GbTOR-10G-L2L3-MIB", "stgCurCfgIndex"), ("SNMPv2-MIB", "sysName"), ("SNMPv2-MIB", "sysLocation"), ("SNMPv2-MIB", "sysContact"))
if mibBuilder.loadTexts: swStgNewRoot.setDescription('A swStgNewRoot trap signifies that the bridge has become the new root of the STG.')
swCistNewRoot = NotificationType((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 7) + (0,43)).setObjects(("IBM-GbTOR-10G-L2L3-MIB", "swTrapDisplayString"), ("SNMPv2-MIB", "sysName"), ("SNMPv2-MIB", "sysLocation"), ("SNMPv2-MIB", "sysContact"))
if mibBuilder.loadTexts: swCistNewRoot.setDescription('A swCistNewRoot trap signifies that the bridge has become the new root of the CIST.')
swStgTopologyChanged = NotificationType((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 7) + (0,44)).setObjects(("IBM-GbTOR-10G-L2L3-MIB", "swTrapDisplayString"), ("IBM-GbTOR-10G-L2L3-MIB", "stgCurCfgIndex"), ("SNMPv2-MIB", "sysName"), ("SNMPv2-MIB", "sysLocation"), ("SNMPv2-MIB", "sysContact"))
if mibBuilder.loadTexts: swStgTopologyChanged.setDescription('A swStgTopologyChanged trap signifies that there was a STG topology change.')
swCistTopologyChanged = NotificationType((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 7) + (0,45)).setObjects(("IBM-GbTOR-10G-L2L3-MIB", "swTrapDisplayString"), ("SNMPv2-MIB", "sysName"), ("SNMPv2-MIB", "sysLocation"), ("SNMPv2-MIB", "sysContact"))
if mibBuilder.loadTexts: swCistTopologyChanged.setDescription('A swCistTopologyChanged trap signifies that there was a CIST topology change.')
swHotlinksMasterUp = NotificationType((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 7) + (0,46)).setObjects(("IBM-GbTOR-10G-L2L3-MIB", "swTrapDisplayString"), ("SNMPv2-MIB", "sysName"), ("SNMPv2-MIB", "sysLocation"), ("SNMPv2-MIB", "sysContact"))
if mibBuilder.loadTexts: swHotlinksMasterUp.setDescription('A swHotlinksMasterUp trap signifies that the Master interface is active.')
swHotlinksMasterDn = NotificationType((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 7) + (0,47)).setObjects(("IBM-GbTOR-10G-L2L3-MIB", "swTrapDisplayString"), ("SNMPv2-MIB", "sysName"), ("SNMPv2-MIB", "sysLocation"), ("SNMPv2-MIB", "sysContact"))
if mibBuilder.loadTexts: swHotlinksMasterDn.setDescription('A swHotlinksMasterDn trap signifies that the Master interface is not active.')
swHotlinksBackupUp = NotificationType((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 7) + (0,48)).setObjects(("IBM-GbTOR-10G-L2L3-MIB", "swTrapDisplayString"), ("SNMPv2-MIB", "sysName"), ("SNMPv2-MIB", "sysLocation"), ("SNMPv2-MIB", "sysContact"))
if mibBuilder.loadTexts: swHotlinksBackupUp.setDescription('A swHotlinksBackupUp trap signifies that the Backup interface is active.')
swHotlinksBackupDn = NotificationType((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 7) + (0,49)).setObjects(("IBM-GbTOR-10G-L2L3-MIB", "swTrapDisplayString"), ("SNMPv2-MIB", "sysName"), ("SNMPv2-MIB", "sysLocation"), ("SNMPv2-MIB", "sysContact"))
if mibBuilder.loadTexts: swHotlinksBackupDn.setDescription('A swHotlinksBackupDn trap signifies that the Backup interface is not active.')
swHotlinksNone = NotificationType((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 7) + (0,50)).setObjects(("IBM-GbTOR-10G-L2L3-MIB", "swTrapDisplayString"), ("SNMPv2-MIB", "sysName"), ("SNMPv2-MIB", "sysLocation"), ("SNMPv2-MIB", "sysContact"))
if mibBuilder.loadTexts: swHotlinksNone.setDescription('A swHotlinksNone trap signifies that there are no active interfaces.')
swNTPSyncFailed = NotificationType((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 7) + (0,61)).setObjects(("IBM-GbTOR-10G-L2L3-MIB", "swTrapDisplayString"), ("SNMPv2-MIB", "sysName"), ("SNMPv2-MIB", "sysLocation"), ("SNMPv2-MIB", "sysContact"))
if mibBuilder.loadTexts: swNTPSyncFailed.setDescription('A swNTPSyncFailed trap signifies that sync with NTP server failed.')
swNTPUpdateClock = NotificationType((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 7) + (0,62)).setObjects(("IBM-GbTOR-10G-L2L3-MIB", "swTrapDisplayString"), ("SNMPv2-MIB", "sysName"), ("SNMPv2-MIB", "sysLocation"), ("SNMPv2-MIB", "sysContact"))
if mibBuilder.loadTexts: swNTPUpdateClock.setDescription('A swNTPUpdateClock trap signifies that update system clock with NTP server.')
swValidLogout = NotificationType((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 7) + (0,63)).setObjects(("IBM-GbTOR-10G-L2L3-MIB", "swTrapDisplayString"), ("SNMPv2-MIB", "sysName"), ("SNMPv2-MIB", "sysLocation"), ("SNMPv2-MIB", "sysContact"))
if mibBuilder.loadTexts: swValidLogout.setDescription('A swValidLogout trap signifies that a user logout has occured.')
swECMPGatewayUp = NotificationType((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 7) + (0,65)).setObjects(("IBM-GbTOR-10G-L2L3-MIB", "swTrapDisplayString"), ("SNMPv2-MIB", "sysName"), ("SNMPv2-MIB", "sysLocation"), ("SNMPv2-MIB", "sysContact"))
if mibBuilder.loadTexts: swECMPGatewayUp.setDescription('A swECMPGatewayUp trap signifies that the ECMP gateway is up.')
swECMPGatewayDown = NotificationType((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 7) + (0,66)).setObjects(("IBM-GbTOR-10G-L2L3-MIB", "swTrapDisplayString"), ("SNMPv2-MIB", "sysName"), ("SNMPv2-MIB", "sysLocation"), ("SNMPv2-MIB", "sysContact"))
if mibBuilder.loadTexts: swECMPGatewayDown.setDescription('A swECMPGatewayDown trap signifies that the ECMP gateway is down.')
swTeamingCtrlUp = NotificationType((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 7) + (0,67)).setObjects(("IBM-GbTOR-10G-L2L3-MIB", "swTrapDisplayString"), ("SNMPv2-MIB", "sysName"), ("SNMPv2-MIB", "sysLocation"), ("SNMPv2-MIB", "sysContact"))
if mibBuilder.loadTexts: swTeamingCtrlUp.setDescription('A swTeamingCtrlUp trap signifies that the teaming is up.')
swTeamingCtrlDown = NotificationType((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 7) + (0,68)).setObjects(("IBM-GbTOR-10G-L2L3-MIB", "swTrapDisplayString"), ("SNMPv2-MIB", "sysName"), ("SNMPv2-MIB", "sysLocation"), ("SNMPv2-MIB", "sysContact"))
if mibBuilder.loadTexts: swTeamingCtrlDown.setDescription('A swTeamingCtrlDown trap signifies that the teaming control is down.')
swTeamingCtrlDownTearDownBlked = NotificationType((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 7) + (0,69)).setObjects(("IBM-GbTOR-10G-L2L3-MIB", "swTrapDisplayString"), ("SNMPv2-MIB", "sysName"), ("SNMPv2-MIB", "sysLocation"), ("SNMPv2-MIB", "sysContact"))
if mibBuilder.loadTexts: swTeamingCtrlDownTearDownBlked.setDescription('A swTeamingCtrlDownTearDownBlked trap signifies that the teaming control is down but teardown is blocked.')
swTeamingCtrlError = NotificationType((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 7) + (0,70)).setObjects(("IBM-GbTOR-10G-L2L3-MIB", "swTrapDisplayString"), ("SNMPv2-MIB", "sysName"), ("SNMPv2-MIB", "sysLocation"), ("SNMPv2-MIB", "sysContact"))
if mibBuilder.loadTexts: swTeamingCtrlError.setDescription('A swTeamingCtrlError trap signifies error, action is undefined.')
swTempReturnThreshold = NotificationType((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 7) + (0,31)).setObjects(("IBM-GbTOR-10G-L2L3-MIB", "swTrapDisplayString"), ("SNMPv2-MIB", "sysName"), ("SNMPv2-MIB", "sysLocation"), ("SNMPv2-MIB", "sysContact"))
if mibBuilder.loadTexts: swTempReturnThreshold.setDescription('A swTempReturnThreshold trap signifies that the switch temperature has returned below maximum safety limits.')
swLACPPortBlocked = NotificationType((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 7) + (0,71)).setObjects(("IBM-GbTOR-10G-L2L3-MIB", "swTrapDisplayString"), ("SNMPv2-MIB", "sysName"), ("SNMPv2-MIB", "sysLocation"), ("SNMPv2-MIB", "sysContact"))
if mibBuilder.loadTexts: swLACPPortBlocked.setDescription('A swLACPPortBlocked trap signifies that LACP is operationally down on a port, and traffic is blocked on the port.')
swLACPPortUnblocked = NotificationType((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 7) + (0,72)).setObjects(("IBM-GbTOR-10G-L2L3-MIB", "swTrapDisplayString"), ("SNMPv2-MIB", "sysName"), ("SNMPv2-MIB", "sysLocation"), ("SNMPv2-MIB", "sysContact"))
if mibBuilder.loadTexts: swLACPPortUnblocked.setDescription('A swLACPPortUnblocked trap signifies that LACP is operationally up on a port, and traffic is no longer blocked on the port.')
swVMGroupVMotion = NotificationType((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 7) + (0,77)).setObjects(("IBM-GbTOR-10G-L2L3-MIB", "swTrapDisplayString"), ("SNMPv2-MIB", "sysName"), ("SNMPv2-MIB", "sysLocation"), ("SNMPv2-MIB", "sysContact"))
if mibBuilder.loadTexts: swVMGroupVMotion.setDescription('A altVMGroupVMotion trap signifies that a virtual machine has moved from a port to another.')
swVMGroupVMOnline = NotificationType((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 7) + (0,78)).setObjects(("IBM-GbTOR-10G-L2L3-MIB", "swTrapDisplayString"), ("SNMPv2-MIB", "sysName"), ("SNMPv2-MIB", "sysLocation"), ("SNMPv2-MIB", "sysContact"))
if mibBuilder.loadTexts: swVMGroupVMOnline.setDescription('A altVMGroupVMOnline trap signifies that a advance provisioned virtual machine has came online.')
swVMGroupVMVlanChange = NotificationType((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 7) + (0,79)).setObjects(("IBM-GbTOR-10G-L2L3-MIB", "swTrapDisplayString"), ("SNMPv2-MIB", "sysName"), ("SNMPv2-MIB", "sysLocation"), ("SNMPv2-MIB", "sysContact"))
if mibBuilder.loadTexts: swVMGroupVMVlanChange.setDescription('A altVMGroupVMVlanChange trap signifies that a virtual machine has entered into a vlan, or changed the vlan.')
swPrimaryPowerSupplyFixed = NotificationType((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 7) + (0,97)).setObjects(("IBM-GbTOR-10G-L2L3-MIB", "swTrapDisplayString"), ("SNMPv2-MIB", "sysName"), ("SNMPv2-MIB", "sysLocation"), ("SNMPv2-MIB", "sysContact"))
if mibBuilder.loadTexts: swPrimaryPowerSupplyFixed.setDescription('A swPrimaryPowerSupplyFixed trap signifies that the primary power supply has been restored.')
swLFDPortErrdisabled = NotificationType((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 7) + (0,103)).setObjects(("IBM-GbTOR-10G-L2L3-MIB", "swTrapDisplayString"), ("SNMPv2-MIB", "sysName"), ("SNMPv2-MIB", "sysLocation"), ("SNMPv2-MIB", "sysContact"))
if mibBuilder.loadTexts: swLFDPortErrdisabled.setDescription('An swLFDPortErrdisabled trap signifies that a port is error-disabled due to excessive link flaps.')
swVlagInstanceUp = NotificationType((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 7) + (0,106)).setObjects(("IBM-GbTOR-10G-L2L3-MIB", "swTrapDisplayString"), ("SNMPv2-MIB", "sysName"), ("SNMPv2-MIB", "sysLocation"), ("SNMPv2-MIB", "sysContact"))
if mibBuilder.loadTexts: swVlagInstanceUp.setDescription('A swVlagInstanceUp trap signifies that vLAG instance is up identified in the trap message.')
swVlagInstanceRemoteUp = NotificationType((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 7) + (0,107)).setObjects(("IBM-GbTOR-10G-L2L3-MIB", "swTrapDisplayString"), ("SNMPv2-MIB", "sysName"), ("SNMPv2-MIB", "sysLocation"), ("SNMPv2-MIB", "sysContact"))
if mibBuilder.loadTexts: swVlagInstanceRemoteUp.setDescription('A swVlagInstanceRemoteUp trap signifies that vLAG is down but remote instance is Up.')
swVlagInstanceLocalUp = NotificationType((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 7) + (0,108)).setObjects(("IBM-GbTOR-10G-L2L3-MIB", "swTrapDisplayString"), ("SNMPv2-MIB", "sysName"), ("SNMPv2-MIB", "sysLocation"), ("SNMPv2-MIB", "sysContact"))
if mibBuilder.loadTexts: swVlagInstanceLocalUp.setDescription('A swVlagInstanceLocalUp trap signifies that vLAG is down but local instance is Up.')
swVlagInstanceDown = NotificationType((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 7) + (0,109)).setObjects(("IBM-GbTOR-10G-L2L3-MIB", "swTrapDisplayString"), ("SNMPv2-MIB", "sysName"), ("SNMPv2-MIB", "sysLocation"), ("SNMPv2-MIB", "sysContact"))
if mibBuilder.loadTexts: swVlagInstanceDown.setDescription('A swVlagInstanceDown trap signifies that vLAG instance is down identified in the trap message.')
swVlagIslUp = NotificationType((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 7) + (0,110)).setObjects(("IBM-GbTOR-10G-L2L3-MIB", "swTrapDisplayString"), ("SNMPv2-MIB", "sysName"), ("SNMPv2-MIB", "sysLocation"), ("SNMPv2-MIB", "sysContact"))
if mibBuilder.loadTexts: swVlagIslUp.setDescription('A swVlagIslUp trap signifies that connection between vLAG switches is up.')
swVlagIslDown = NotificationType((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 7) + (0,111)).setObjects(("IBM-GbTOR-10G-L2L3-MIB", "swTrapDisplayString"), ("SNMPv2-MIB", "sysName"), ("SNMPv2-MIB", "sysLocation"), ("SNMPv2-MIB", "sysContact"))
if mibBuilder.loadTexts: swVlagIslDown.setDescription('A swVlagInstanceDown trap signifies that connection between vLAG switches is down.')
sw8021x = NotificationType((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 7) + (0,158)).setObjects(("IBM-GbTOR-10G-L2L3-MIB", "swTrapDisplayString"), ("SNMPv2-MIB", "sysName"), ("SNMPv2-MIB", "sysLocation"), ("SNMPv2-MIB", "sysContact"))
if mibBuilder.loadTexts: sw8021x.setDescription('A sw8021x trap is sent when dot1x feature is enabled.')
swDefAdminDisable = NotificationType((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 7) + (0,162)).setObjects(("IBM-GbTOR-10G-L2L3-MIB", "swTrapDisplayString"), ("SNMPv2-MIB", "sysName"), ("SNMPv2-MIB", "sysLocation"), ("SNMPv2-MIB", "sysContact"))
if mibBuilder.loadTexts: swDefAdminDisable.setDescription('A swDefAdminDisable trap signifies that default admin account has been disabled.')
swAcntStrngPswdNotMet = NotificationType((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 7) + (0,163)).setObjects(("IBM-GbTOR-10G-L2L3-MIB", "swTrapDisplayString"), ("SNMPv2-MIB", "sysName"), ("SNMPv2-MIB", "sysLocation"), ("SNMPv2-MIB", "sysContact"))
if mibBuilder.loadTexts: swAcntStrngPswdNotMet.setDescription('A swAcntStrngPswdNotMet trap signifies that configured password does not match strong password complexity.')
swAcntLocked = NotificationType((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 7) + (0,164)).setObjects(("IBM-GbTOR-10G-L2L3-MIB", "swTrapDisplayString"), ("SNMPv2-MIB", "sysName"), ("SNMPv2-MIB", "sysLocation"), ("SNMPv2-MIB", "sysContact"))
if mibBuilder.loadTexts: swAcntLocked.setDescription('A swAcntLocked trap signifies that account has been locked.')
swAcntUnlocked = NotificationType((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 7) + (0,165)).setObjects(("IBM-GbTOR-10G-L2L3-MIB", "swTrapDisplayString"), ("SNMPv2-MIB", "sysName"), ("SNMPv2-MIB", "sysLocation"), ("SNMPv2-MIB", "sysContact"))
if mibBuilder.loadTexts: swAcntUnlocked.setDescription('A swAcntUnlocked trap signifies that account has been unlocked.')
qos = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 8))
qosConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 8, 1))
qos8021p = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 8, 1, 1))
qosdscp = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 8, 1, 2))
qosCurCfgPortPriorityTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 8, 1, 1, 1), )
if mibBuilder.loadTexts: qosCurCfgPortPriorityTable.setStatus('current')
if mibBuilder.loadTexts: qosCurCfgPortPriorityTable.setDescription('The table of QOS Port Priority configuration.')
qosCurCfgPortPriorityEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 8, 1, 1, 1, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "qosCurCfgPortIndex"))
if mibBuilder.loadTexts: qosCurCfgPortPriorityEntry.setStatus('current')
if mibBuilder.loadTexts: qosCurCfgPortPriorityEntry.setDescription('Information about a particular QOS Port Priority configuration.')
qosCurCfgPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 8, 1, 1, 1, 1, 1), PortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: qosCurCfgPortIndex.setStatus('current')
if mibBuilder.loadTexts: qosCurCfgPortIndex.setDescription('Switch Port Number')
qosCurCfgPortPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 8, 1, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: qosCurCfgPortPriority.setStatus('current')
if mibBuilder.loadTexts: qosCurCfgPortPriority.setDescription('Switch Port Priority Should be between 0 and 7')
qosNewCfgPortPriorityTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 8, 1, 1, 2), )
if mibBuilder.loadTexts: qosNewCfgPortPriorityTable.setStatus('current')
if mibBuilder.loadTexts: qosNewCfgPortPriorityTable.setDescription('The table of QOS Port Priority configuration.')
qosNewCfgPortPriorityEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 8, 1, 1, 2, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "qosNewCfgPortIndex"))
if mibBuilder.loadTexts: qosNewCfgPortPriorityEntry.setStatus('current')
if mibBuilder.loadTexts: qosNewCfgPortPriorityEntry.setDescription('Information about a particular QOS Port Priority configuration.')
qosNewCfgPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 8, 1, 1, 2, 1, 1), PortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: qosNewCfgPortIndex.setStatus('current')
if mibBuilder.loadTexts: qosNewCfgPortIndex.setDescription('Switch Port Number')
qosNewCfgPortPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 8, 1, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qosNewCfgPortPriority.setStatus('current')
if mibBuilder.loadTexts: qosNewCfgPortPriority.setDescription('Switch Port Priority Should be between 0 and 7')
qosCurCfgPriorityCoSTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 8, 1, 1, 3), )
if mibBuilder.loadTexts: qosCurCfgPriorityCoSTable.setStatus('current')
if mibBuilder.loadTexts: qosCurCfgPriorityCoSTable.setDescription('The table of Frame Priority and COSq configuration.')
qosCurCfgPriorityCoSEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 8, 1, 1, 3, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "qosCurCfgPriorityIndex"))
if mibBuilder.loadTexts: qosCurCfgPriorityCoSEntry.setStatus('current')
if mibBuilder.loadTexts: qosCurCfgPriorityCoSEntry.setDescription('Information about a particular Frame Priority and COSq configuration.')
qosCurCfgPriorityIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 8, 1, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: qosCurCfgPriorityIndex.setStatus('current')
if mibBuilder.loadTexts: qosCurCfgPriorityIndex.setDescription('Frame priority Number')
qosCurCfgPriorityCoSq = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 8, 1, 1, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: qosCurCfgPriorityCoSq.setStatus('current')
if mibBuilder.loadTexts: qosCurCfgPriorityCoSq.setDescription('CoSq for a Frame Priority Should be between 0 and 7')
qosNewCfgPriorityCoSTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 8, 1, 1, 4), )
if mibBuilder.loadTexts: qosNewCfgPriorityCoSTable.setStatus('current')
if mibBuilder.loadTexts: qosNewCfgPriorityCoSTable.setDescription('The table of Frame Priority and COSq configuration.')
qosNewCfgPriorityCoSEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 8, 1, 1, 4, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "qosNewCfgPriorityIndex"))
if mibBuilder.loadTexts: qosNewCfgPriorityCoSEntry.setStatus('current')
if mibBuilder.loadTexts: qosNewCfgPriorityCoSEntry.setDescription('Information about a particular Frame Priority and COSq configuration.')
qosNewCfgPriorityIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 8, 1, 1, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: qosNewCfgPriorityIndex.setStatus('current')
if mibBuilder.loadTexts: qosNewCfgPriorityIndex.setDescription('Frame priority Number')
qosNewCfgPriorityCoSq = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 8, 1, 1, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qosNewCfgPriorityCoSq.setStatus('current')
if mibBuilder.loadTexts: qosNewCfgPriorityCoSq.setDescription('CoSq for a Frame Priority Should be between 0 and 7')
qosCurCfgCosWeightTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 8, 1, 1, 5), )
if mibBuilder.loadTexts: qosCurCfgCosWeightTable.setStatus('current')
if mibBuilder.loadTexts: qosCurCfgCosWeightTable.setDescription('The table of CoSq and Weight configuration.')
qosCurCfgCosWeightEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 8, 1, 1, 5, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "qosCurCfgCosIndex"))
if mibBuilder.loadTexts: qosCurCfgCosWeightEntry.setStatus('current')
if mibBuilder.loadTexts: qosCurCfgCosWeightEntry.setDescription('Information about a particular CoSq and Weight configuration.')
qosCurCfgCosIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 8, 1, 1, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: qosCurCfgCosIndex.setStatus('current')
if mibBuilder.loadTexts: qosCurCfgCosIndex.setDescription('CoSq Number')
qosCurCfgCosWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 8, 1, 1, 5, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: qosCurCfgCosWeight.setStatus('current')
if mibBuilder.loadTexts: qosCurCfgCosWeight.setDescription('Weight of CoSq')
qosNewCfgCosWeightTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 8, 1, 1, 6), )
if mibBuilder.loadTexts: qosNewCfgCosWeightTable.setStatus('current')
if mibBuilder.loadTexts: qosNewCfgCosWeightTable.setDescription('The table of CoSq and Weight configuration.')
qosNewCfgCosWeightEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 8, 1, 1, 6, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "qosNewCfgCosIndex"))
if mibBuilder.loadTexts: qosNewCfgCosWeightEntry.setStatus('current')
if mibBuilder.loadTexts: qosNewCfgCosWeightEntry.setDescription('Information about a particular CoSq and Weight configuration.')
qosNewCfgCosIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 8, 1, 1, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: qosNewCfgCosIndex.setStatus('current')
if mibBuilder.loadTexts: qosNewCfgCosIndex.setDescription('CoSq Number')
qosNewCfgCosWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 8, 1, 1, 6, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qosNewCfgCosWeight.setStatus('current')
if mibBuilder.loadTexts: qosNewCfgCosWeight.setDescription('Weight of CoSq')
qosDefaultCfg = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 8, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("none", 0), ("defaultCosNum", 1), ("defaultWeight", 2), ("defaultPriority", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qosDefaultCfg.setStatus('current')
if mibBuilder.loadTexts: qosDefaultCfg.setDescription('Load default configuration.')
qosCurCfgDscpTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 8, 1, 2, 1), )
if mibBuilder.loadTexts: qosCurCfgDscpTable.setStatus('current')
if mibBuilder.loadTexts: qosCurCfgDscpTable.setDescription('The table of Dscp to New Dscp/802.1p priority configuration.')
qosCurCfgDscpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 8, 1, 2, 1, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "qosCurCfgDscpIndex"))
if mibBuilder.loadTexts: qosCurCfgDscpEntry.setStatus('current')
if mibBuilder.loadTexts: qosCurCfgDscpEntry.setDescription('Information about a particular Dscp to New Dscp/802.1p priority configuration')
qosCurCfgDscpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 8, 1, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: qosCurCfgDscpIndex.setStatus('current')
if mibBuilder.loadTexts: qosCurCfgDscpIndex.setDescription('Dscp value')
qosCurCfgMapDscp = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 8, 1, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: qosCurCfgMapDscp.setStatus('current')
if mibBuilder.loadTexts: qosCurCfgMapDscp.setDescription('Map Dscp Value')
qosCurCfgMap8021p = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 8, 1, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: qosCurCfgMap8021p.setStatus('current')
if mibBuilder.loadTexts: qosCurCfgMap8021p.setDescription('Map 802.1p value')
qosNewCfgDscpTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 8, 1, 2, 2), )
if mibBuilder.loadTexts: qosNewCfgDscpTable.setStatus('current')
if mibBuilder.loadTexts: qosNewCfgDscpTable.setDescription('The table of Dscp to New Dscp/802.1p priority configuration.')
qosNewCfgDscpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 8, 1, 2, 2, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "qosNewCfgDscpIndex"))
if mibBuilder.loadTexts: qosNewCfgDscpEntry.setStatus('current')
if mibBuilder.loadTexts: qosNewCfgDscpEntry.setDescription('Information about a particular Dscp to New Dscp/802.1p priority configuration')
qosNewCfgDscpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 8, 1, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: qosNewCfgDscpIndex.setStatus('current')
if mibBuilder.loadTexts: qosNewCfgDscpIndex.setDescription('Dscp value')
qosNewCfgMapDscp = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 8, 1, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 63))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qosNewCfgMapDscp.setStatus('current')
if mibBuilder.loadTexts: qosNewCfgMapDscp.setDescription('Map Dscp Value')
qosNewCfgMap8021p = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 8, 1, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qosNewCfgMap8021p.setStatus('current')
if mibBuilder.loadTexts: qosNewCfgMap8021p.setDescription('Map 802.1p value')
qosCurCfgDscpState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 8, 1, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: qosCurCfgDscpState.setStatus('current')
if mibBuilder.loadTexts: qosCurCfgDscpState.setDescription('This is for turning on/off DSCP globally.')
qosNewCfgDscpState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 8, 1, 2, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qosNewCfgDscpState.setStatus('current')
if mibBuilder.loadTexts: qosNewCfgDscpState.setDescription('This is for turning on/off DSCP globally.')
acl = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9))
acConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1))
acList = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1))
aclCfg = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 4))
vmapConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3))
acl6List = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 5))
aclLog = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 6))
aclCurCfgTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 1), )
if mibBuilder.loadTexts: aclCurCfgTable.setStatus('current')
if mibBuilder.loadTexts: aclCurCfgTable.setDescription('The table of current ACL configuration.')
aclCurCfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 1, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "aclCurCfgIndex"))
if mibBuilder.loadTexts: aclCurCfgEntry.setStatus('current')
if mibBuilder.loadTexts: aclCurCfgEntry.setDescription('Current information about a particular ACL configuration entry.')
aclCurCfgIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 1, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aclCurCfgIndex.setStatus('current')
if mibBuilder.loadTexts: aclCurCfgIndex.setDescription('The index associated with this ACL entry.')
aclCurCfgFilterAction = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 5))).clone(namedValues=NamedValues(("none", 0), ("permit", 1), ("deny", 2), ("setprio", 3), ("changevlan", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aclCurCfgFilterAction.setStatus('current')
if mibBuilder.loadTexts: aclCurCfgFilterAction.setDescription('The action to be performed on a packet that matches the filter settings of this ACL entry.')
aclCurCfgFilterActionSetPrio = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("none", 0), ("prio0", 1), ("prio1", 2), ("prio2", 3), ("prio3", 4), ("prio4", 5), ("prio5", 6), ("prio6", 7), ("prio7", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aclCurCfgFilterActionSetPrio.setStatus('current')
if mibBuilder.loadTexts: aclCurCfgFilterActionSetPrio.setDescription('The value to be used when the action to be performed is setprio for this ACL entry.')
aclCurCfgSrcMACAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 1, 1, 9), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aclCurCfgSrcMACAddress.setStatus('current')
if mibBuilder.loadTexts: aclCurCfgSrcMACAddress.setDescription('The source MAC address to be filtered.')
aclCurCfgSrcMACMask = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 1, 1, 10), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aclCurCfgSrcMACMask.setStatus('current')
if mibBuilder.loadTexts: aclCurCfgSrcMACMask.setDescription('The address mask applied to aclCurCfgSrcMACAddress for filtering.')
aclCurCfgDstMACAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 1, 1, 11), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aclCurCfgDstMACAddress.setStatus('current')
if mibBuilder.loadTexts: aclCurCfgDstMACAddress.setDescription('The destination MAC address to be filtered.')
aclCurCfgDstMACMask = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 1, 1, 12), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aclCurCfgDstMACMask.setStatus('current')
if mibBuilder.loadTexts: aclCurCfgDstMACMask.setDescription('The address mask applied to aclCurCfgDstMACAddress for filtering.')
aclCurCfgEthernetTypeName = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("none", 0), ("arp", 1), ("ipv4", 2), ("ipv6", 3), ("mpls", 4), ("rarp", 5), ("any", 6), ("other", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aclCurCfgEthernetTypeName.setStatus('current')
if mibBuilder.loadTexts: aclCurCfgEthernetTypeName.setDescription('The Ethernet type to be filtered. If the value of this object is other(7), the value of aclNewCfgEthernetTypeValue indicates the ethernet type that will be filtered.')
aclCurCfgEthernetTypeValue = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1536, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aclCurCfgEthernetTypeValue.setStatus('current')
if mibBuilder.loadTexts: aclCurCfgEthernetTypeValue.setDescription('The Ethernet type value to be filtered. The value of this object is equivalent to the value of aclNewCfgEthernetTypeName except when the value of aclNewCfgEthernetTypeName is other(7), which can be any user-defined value for this object.')
aclCurCfgVLanId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aclCurCfgVLanId.setStatus('current')
if mibBuilder.loadTexts: aclCurCfgVLanId.setDescription('The virtual LAN identifier to be filtered.')
aclCurCfgVLanMask = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 1, 1, 16), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aclCurCfgVLanMask.setStatus('current')
if mibBuilder.loadTexts: aclCurCfgVLanMask.setDescription('The mask applied to aclCurCfgVLanId for filtering.')
aclCurCfg8021pPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("none", 0), ("priority0", 1), ("priority1", 2), ("priority2", 3), ("priority3", 4), ("priority4", 5), ("priority5", 6), ("priority6", 7), ("priority7", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aclCurCfg8021pPriority.setStatus('current')
if mibBuilder.loadTexts: aclCurCfg8021pPriority.setDescription('The 802.1p priority to be filtered.')
aclCurCfgTypeOfService = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 1, 1, 18), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aclCurCfgTypeOfService.setStatus('current')
if mibBuilder.loadTexts: aclCurCfgTypeOfService.setDescription("The type of service to be filtered. 'none' for not initialised, within the range 0-255")
aclCurCfgProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 1, 1, 19), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aclCurCfgProtocol.setStatus('current')
if mibBuilder.loadTexts: aclCurCfgProtocol.setDescription("The protocol to be filtered. 'none' for not initialised, within the range 0-255")
aclCurCfgSrcIPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 1, 1, 20), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aclCurCfgSrcIPAddress.setStatus('current')
if mibBuilder.loadTexts: aclCurCfgSrcIPAddress.setDescription('The source IP address to be filtered.')
aclCurCfgSrcIPMask = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 1, 1, 21), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aclCurCfgSrcIPMask.setStatus('current')
if mibBuilder.loadTexts: aclCurCfgSrcIPMask.setDescription('The address mask applied to aclCurCfgSrcIPAddress for filtering.')
aclCurCfgDstIPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 1, 1, 22), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aclCurCfgDstIPAddress.setStatus('current')
if mibBuilder.loadTexts: aclCurCfgDstIPAddress.setDescription('The destination IP address to be filtered.')
aclCurCfgDstIPMask = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 1, 1, 23), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aclCurCfgDstIPMask.setStatus('current')
if mibBuilder.loadTexts: aclCurCfgDstIPMask.setDescription('The address mask applied to aclCurCfgDstIPAddress for filtering.')
aclCurCfgSrcPort = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 1, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aclCurCfgSrcPort.setStatus('current')
if mibBuilder.loadTexts: aclCurCfgSrcPort.setDescription('The source TCP/UDP port number to be filtered.')
aclCurCfgSrcPortMask = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 1, 1, 25), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aclCurCfgSrcPortMask.setStatus('current')
if mibBuilder.loadTexts: aclCurCfgSrcPortMask.setDescription('The mask applied to aclCurCfgSrcPort for filtering.')
aclCurCfgDstPort = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 1, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aclCurCfgDstPort.setStatus('current')
if mibBuilder.loadTexts: aclCurCfgDstPort.setDescription('The destination TCP/UDP port number to be filtered.')
aclCurCfgDstPortMask = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 1, 1, 27), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aclCurCfgDstPortMask.setStatus('current')
if mibBuilder.loadTexts: aclCurCfgDstPortMask.setDescription('The mask applied to aclCurCfgDstPort for filtering.')
aclCurCfgTCPFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 1, 1, 28), Bits().clone(namedValues=NamedValues(("reserved1", 0), ("reserved2", 1), ("tcpURG", 2), ("tcpACK", 3), ("tcpPSH", 4), ("tcpRST", 5), ("tcpSYN", 6), ("tcpFIN", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aclCurCfgTCPFlags.setStatus('current')
if mibBuilder.loadTexts: aclCurCfgTCPFlags.setDescription('The TCP flags to be filtered. OCTET xxxxxxxx ||||..|| ||||..||_tcpFIN(7) ||||..|__tcpSYN(6) |||| ||||_____tcpACK(3) |||______tcpURG(2) ||_______reserved2(1) |________reserved1(0) where: - reserved1 - 0; - reserved2 - 0; - x - 0 or 1; ')
aclCurCfgTCPFlagsMask = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 1, 1, 39), Bits().clone(namedValues=NamedValues(("reserved1", 0), ("reserved2", 1), ("tcpURG", 2), ("tcpACK", 3), ("tcpPSH", 4), ("tcpRST", 5), ("tcpSYN", 6), ("tcpFIN", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aclCurCfgTCPFlagsMask.setStatus('current')
if mibBuilder.loadTexts: aclCurCfgTCPFlagsMask.setDescription('The TCP flags mask. OCTET xxxxxxxx ||||..|| ||||..||_tcpFIN(7) ||||..|__tcpSYN(6) |||| ||||_____tcpACK(3) |||______tcpURG(2) ||_______reserved2(1) |________reserved1(0) where: - reserved1 - 0; - reserved2 - 0; - x - 0 or 1; ')
aclCurCfgStatistics = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 1, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aclCurCfgStatistics.setStatus('current')
if mibBuilder.loadTexts: aclCurCfgStatistics.setDescription('Whether statistics collection for this ACL is enabled or not.')
aclCurCfgMeterAction = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 1, 1, 41), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("unconfigured", 0), ("outdrop", 1), ("outpass", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aclCurCfgMeterAction.setStatus('current')
if mibBuilder.loadTexts: aclCurCfgMeterAction.setDescription('Meter Action for this ACL.')
aclCurCfgMeterEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 1, 1, 42), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("enabled", 0), ("disabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aclCurCfgMeterEnable.setStatus('current')
if mibBuilder.loadTexts: aclCurCfgMeterEnable.setDescription('Meter state for this ACL.')
aclCurCfgKbitsSec = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 1, 1, 43), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(64, 10000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aclCurCfgKbitsSec.setStatus('current')
if mibBuilder.loadTexts: aclCurCfgKbitsSec.setDescription('The commited rate of meter associated with this ACL entry.')
aclCurCfgKbitsBurst = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 1, 1, 44), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(32, 64, 128, 256, 512, 1024, 2048, 4096))).clone(namedValues=NamedValues(("kbits32", 32), ("kbits64", 64), ("kbits128", 128), ("kbits256", 256), ("kbits512", 512), ("kbits1024", 1024), ("kbits2048", 2048), ("kbits4096", 4096)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aclCurCfgKbitsBurst.setStatus('current')
if mibBuilder.loadTexts: aclCurCfgKbitsBurst.setDescription('The maxmium burst sizeof meter associated with this ACL entry.')
aclCurCfgUser = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 1, 1, 45), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aclCurCfgUser.setStatus('current')
if mibBuilder.loadTexts: aclCurCfgUser.setDescription('Set user defined priority for this ACL.')
aclCurCfgInprofDscp = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 1, 1, 46), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aclCurCfgInprofDscp.setStatus('current')
if mibBuilder.loadTexts: aclCurCfgInprofDscp.setDescription('Set in profile pkts DSCP value.')
aclCurCfgInprofDscpEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 1, 1, 50), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aclCurCfgInprofDscpEnable.setStatus('current')
if mibBuilder.loadTexts: aclCurCfgInprofDscpEnable.setDescription('Whether in profile update DSCP for this ACL is enabled or not.')
aclCurCfgOutprofDscpEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 1, 1, 51), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aclCurCfgOutprofDscpEnable.setStatus('current')
if mibBuilder.loadTexts: aclCurCfgOutprofDscpEnable.setDescription('Whether out profile update DSCP for this ACL is enabled or not.')
aclCurCfgMirrorPort = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 1, 1, 74), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aclCurCfgMirrorPort.setStatus('current')
if mibBuilder.loadTexts: aclCurCfgMirrorPort.setDescription('Set port in the ACL for mirroring. n > 0 - the represented port is configured for mirroring. 0 - the represented port is not configured for mirroring.')
aclCurCfgLog = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 1, 1, 81), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aclCurCfgLog.setStatus('current')
if mibBuilder.loadTexts: aclCurCfgLog.setDescription('Whether log for this ACL is enabled or not.')
aclCurCfgFilterActionChangeVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 1, 1, 84), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4094))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aclCurCfgFilterActionChangeVlan.setStatus('current')
if mibBuilder.loadTexts: aclCurCfgFilterActionChangeVlan.setDescription('The classified VLAN only if the action is set as changevlan')
aclNewCfgTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 2), )
if mibBuilder.loadTexts: aclNewCfgTable.setStatus('current')
if mibBuilder.loadTexts: aclNewCfgTable.setDescription('The table of new ACL configuration.')
aclNewCfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 2, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "aclNewCfgIndex"))
if mibBuilder.loadTexts: aclNewCfgEntry.setStatus('current')
if mibBuilder.loadTexts: aclNewCfgEntry.setDescription('New information about a particular ACL configuration.')
aclNewCfgIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 2, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aclNewCfgIndex.setStatus('current')
if mibBuilder.loadTexts: aclNewCfgIndex.setDescription('The index associated with this ACL entry.')
aclNewCfgFilterAction = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 5))).clone(namedValues=NamedValues(("none", 0), ("permit", 1), ("deny", 2), ("setprio", 3), ("changevlan", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclNewCfgFilterAction.setStatus('current')
if mibBuilder.loadTexts: aclNewCfgFilterAction.setDescription('The action to be performed on a packet that matches the filter settings of this ACL entry.')
aclNewCfgFilterActionSetPrio = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("none", 0), ("prio0", 1), ("prio1", 2), ("prio2", 3), ("prio3", 4), ("prio4", 5), ("prio5", 6), ("prio6", 7), ("prio7", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclNewCfgFilterActionSetPrio.setStatus('current')
if mibBuilder.loadTexts: aclNewCfgFilterActionSetPrio.setDescription('The COS queue to be used when the action for this ACL entry is set to setprio.')
aclNewCfgSrcMACAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 2, 1, 9), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclNewCfgSrcMACAddress.setStatus('current')
if mibBuilder.loadTexts: aclNewCfgSrcMACAddress.setDescription('The source MAC address to be filtered. Whenever this object is set to a nonzero value, the aclNewCfgSrcMACMask object, if not yet set, will be automatically set to ff:ff:ff:ff:ff:ff.')
aclNewCfgSrcMACMask = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 2, 1, 10), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclNewCfgSrcMACMask.setStatus('current')
if mibBuilder.loadTexts: aclNewCfgSrcMACMask.setDescription('The address mask to be applied to aclNewCfgSrcMACAddress for filtering.')
aclNewCfgDstMACAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 2, 1, 11), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclNewCfgDstMACAddress.setStatus('current')
if mibBuilder.loadTexts: aclNewCfgDstMACAddress.setDescription('The destination MAC address to be filtered. Whenever this object is set to a nonzero value, the aclNewCfgDstMACMask object, if not yet set, will be automatically set to ff:ff:ff:ff:ff:ff.')
aclNewCfgDstMACMask = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 2, 1, 12), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclNewCfgDstMACMask.setStatus('current')
if mibBuilder.loadTexts: aclNewCfgDstMACMask.setDescription('The address mask to be applied to aclNewCfgDstMACAddress for filtering.')
aclNewCfgEthernetTypeName = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("none", 0), ("arp", 1), ("ipv4", 2), ("ipv6", 3), ("mpls", 4), ("rarp", 5), ("any", 6), ("other", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclNewCfgEthernetTypeName.setStatus('current')
if mibBuilder.loadTexts: aclNewCfgEthernetTypeName.setDescription('The Ethernet type to be filtered. If the value of this object is other(7), the value of aclNewCfgEthernetTypeValue indicates the ethernet type that will be filtered. If this object is set to a value other than other(7), the value of the aclNewCfgEthernetTypeValue object is automatically set, as follows: aclNewCfgEthernetTypeName aclNewCfgEthernetTypeValue none(0) 0 arp(1) 2054 (0x0806) ipv4(2) 2048 (0x0800) ipv6(3) 34525 (0x86dd) mpls(4) 34887 (0x8847) rarp(5) 32821 (0x8035) any(6) 65535 (0xffff) ')
aclNewCfgEthernetTypeValue = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 2, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1536, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclNewCfgEthernetTypeValue.setStatus('current')
if mibBuilder.loadTexts: aclNewCfgEthernetTypeValue.setDescription('The Ethernet type value to be filtered. The value of this object is equivalent to the value of aclNewCfgEthernetTypeName except when the value of aclNewCfgEthernetTypeName is other(7), which can be any user-defined value for this object.')
aclNewCfgVLanId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 2, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclNewCfgVLanId.setStatus('current')
if mibBuilder.loadTexts: aclNewCfgVLanId.setDescription('The virtual LAN identifier to be filtered. Whenever this object is set to a nonzero value, the aclNewCfgVLanMask object, if not yet set, will be automatically set to 4095 (0xfff). When this object is set to 0, the Vlan ACL filter is disabled.')
aclNewCfgVLanMask = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 2, 1, 16), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclNewCfgVLanMask.setStatus('current')
if mibBuilder.loadTexts: aclNewCfgVLanMask.setDescription('The mask to be applied to aclNewCfgVLanId for filtering.')
aclNewCfg8021pPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 2, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("none", 0), ("priority0", 1), ("priority1", 2), ("priority2", 3), ("priority3", 4), ("priority4", 5), ("priority5", 6), ("priority6", 7), ("priority7", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclNewCfg8021pPriority.setStatus('current')
if mibBuilder.loadTexts: aclNewCfg8021pPriority.setDescription('The 802.1p priority to be filtered.')
aclNewCfgTypeOfService = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 2, 1, 18), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclNewCfgTypeOfService.setStatus('current')
if mibBuilder.loadTexts: aclNewCfgTypeOfService.setDescription("The type of service to be filtered. 'none' for not initialised, within the range 0-255")
aclNewCfgProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 2, 1, 19), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclNewCfgProtocol.setStatus('current')
if mibBuilder.loadTexts: aclNewCfgProtocol.setDescription("The protocol to be filtered. 'none' for not initialised, within the range 0-255")
aclNewCfgSrcIPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 2, 1, 20), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclNewCfgSrcIPAddress.setStatus('current')
if mibBuilder.loadTexts: aclNewCfgSrcIPAddress.setDescription('The source IP address to be filtered. Whenever this object is set to a nonzero value, the aclNewCfgSrcIPMask object, if not yet set, will be automatically set to 255.255.255.255.')
aclNewCfgSrcIPMask = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 2, 1, 21), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclNewCfgSrcIPMask.setStatus('current')
if mibBuilder.loadTexts: aclNewCfgSrcIPMask.setDescription('The address mask to be applied to aclNewCfgSrcIPAddress for filtering.')
aclNewCfgDstIPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 2, 1, 22), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclNewCfgDstIPAddress.setStatus('current')
if mibBuilder.loadTexts: aclNewCfgDstIPAddress.setDescription('The destination IP address to be filtered. Whenever this object is set to a nonzero value, the aclNewCfgDstIPMask object, if not yet set, will be automatically set to 255.255.255.255.')
aclNewCfgDstIPMask = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 2, 1, 23), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclNewCfgDstIPMask.setStatus('current')
if mibBuilder.loadTexts: aclNewCfgDstIPMask.setDescription('The address mask to be applied to aclNewCfgDstIPAddress for filtering.')
aclNewCfgSrcPort = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 2, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclNewCfgSrcPort.setStatus('current')
if mibBuilder.loadTexts: aclNewCfgSrcPort.setDescription('The source TCP/UDP port number to be filtered. Whenever this object is set if the aclNewCfgSrcPortMask object is not set will be automatically set to 65535 (0xffff).')
aclNewCfgSrcPortMask = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 2, 1, 25), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclNewCfgSrcPortMask.setStatus('current')
if mibBuilder.loadTexts: aclNewCfgSrcPortMask.setDescription('The mask to be applied to aclNewCfgSrcPort for filtering.')
aclNewCfgDstPort = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 2, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclNewCfgDstPort.setStatus('current')
if mibBuilder.loadTexts: aclNewCfgDstPort.setDescription('The destination TCP/UDP port number to be filtered. Whenever this object is set the aclNewCfgSrcPortMask object, if not yet set, will be automatically set to 65535 (0xffff).')
aclNewCfgDstPortMask = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 2, 1, 27), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclNewCfgDstPortMask.setStatus('current')
if mibBuilder.loadTexts: aclNewCfgDstPortMask.setDescription('The mask to be applied to aclNewCfgDstPort for filtering.')
aclNewCfgTCPFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 2, 1, 28), Bits().clone(namedValues=NamedValues(("reserved1", 0), ("reserved2", 1), ("tcpURG", 2), ("tcpACK", 3), ("tcpPSH", 4), ("tcpRST", 5), ("tcpSYN", 6), ("tcpFIN", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclNewCfgTCPFlags.setStatus('current')
if mibBuilder.loadTexts: aclNewCfgTCPFlags.setDescription('The TCP flags to be filtered. The TCP flags are presented in bitmap format, as follows: OCTET xxxxxxxx ||||..|| ||||..||_tcpFIN(7) ||||..|__tcpSYN(6) |||| ||||_____tcpACK(3) |||______tcpURG(2) ||_______reserved2(1) |________reserved1(0) where: - reserved1 - 0; - reserved2 - 0; - x - 0 or 1; ')
aclNewCfgTCPFlagsMask = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 2, 1, 39), Bits().clone(namedValues=NamedValues(("reserved1", 0), ("reserved2", 1), ("tcpURG", 2), ("tcpACK", 3), ("tcpPSH", 4), ("tcpRST", 5), ("tcpSYN", 6), ("tcpFIN", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclNewCfgTCPFlagsMask.setStatus('current')
if mibBuilder.loadTexts: aclNewCfgTCPFlagsMask.setDescription('The TCP flags mask. The TCP flags are presented in bitmap format, as follows: OCTET xxxxxxxx ||||..|| ||||..||_tcpFIN(7) ||||..|__tcpSYN(6) |||| ||||_____tcpACK(3) |||______tcpURG(2) ||_______reserved2(1) |________reserved1(0) where: - reserved1 - 0; - reserved2 - 0; - x - 0 or 1; Default value is 0x3f.')
aclNewCfgStatistics = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 2, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclNewCfgStatistics.setStatus('current')
if mibBuilder.loadTexts: aclNewCfgStatistics.setDescription('Whether statistics collection for this ACL is enabled or not.')
aclNewCfgDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 2, 1, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("delete", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclNewCfgDelete.setStatus('current')
if mibBuilder.loadTexts: aclNewCfgDelete.setDescription('This is an action object to delete an ACL entry. A value of other(1) is always returned when this object is read.')
aclNewCfgMeterAction = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 2, 1, 41), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("unconfigured", 0), ("outdrop", 1), ("outpass", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclNewCfgMeterAction.setStatus('current')
if mibBuilder.loadTexts: aclNewCfgMeterAction.setDescription('Meter Action for this ACL.')
aclNewCfgMeterEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 2, 1, 42), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("enabled", 0), ("disabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclNewCfgMeterEnable.setStatus('current')
if mibBuilder.loadTexts: aclNewCfgMeterEnable.setDescription('Meter state for this ACL.')
aclNewCfgMbitsSec = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 2, 1, 43), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(128, 10000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclNewCfgMbitsSec.setStatus('current')
if mibBuilder.loadTexts: aclNewCfgMbitsSec.setDescription('The commited rate of (multiple of 64) meter associated with this ACL entry.')
aclNewCfgKbitsBurst = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 2, 1, 44), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(32, 64, 128, 256, 512, 1024, 2048, 4096))).clone(namedValues=NamedValues(("kbits32", 32), ("kbits64", 64), ("kbits128", 128), ("kbits256", 256), ("kbits512", 512), ("kbits1024", 1024), ("kbits2048", 2048), ("kbits4096", 4096)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclNewCfgKbitsBurst.setStatus('current')
if mibBuilder.loadTexts: aclNewCfgKbitsBurst.setDescription('The maximum burst size of the meter associated with this ACL entry.')
aclNewCfgUser = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 2, 1, 45), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclNewCfgUser.setStatus('current')
if mibBuilder.loadTexts: aclNewCfgUser.setDescription('Set user defined priority for this ACL.')
aclNewCfgInprofDscp = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 2, 1, 46), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 63))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclNewCfgInprofDscp.setStatus('current')
if mibBuilder.loadTexts: aclNewCfgInprofDscp.setDescription('Set in profile pkts DSCP value.')
aclNewCfgInprofDscpEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 2, 1, 50), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclNewCfgInprofDscpEnable.setStatus('current')
if mibBuilder.loadTexts: aclNewCfgInprofDscpEnable.setDescription('Whether in profile update DSCP for this ACL is enabled or not. Only the value disable(0) can be set, causing the in profile update DSCP to be disabled for this ACL. The value enable(1) is automatically set when setting a value for aclNewCfgInprofDscp object.')
aclNewCfgOutprofDscpEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 2, 1, 51), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclNewCfgOutprofDscpEnable.setStatus('current')
if mibBuilder.loadTexts: aclNewCfgOutprofDscpEnable.setDescription('Whether out profile update DSCP for this ACL is enabled or not. Only the value disable(0) can be set, causing the out profile update DSCP to be disabled for this ACL. The value enable(1) is automatically set when setting a value for aclNewCfgOutprofDscp object.')
aclNewCfgReset = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 2, 1, 52), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclNewCfgReset.setStatus('current')
if mibBuilder.loadTexts: aclNewCfgReset.setDescription('This is an action object to reset an ACL entry. A value of other(1) is always returned when this object is read.')
aclNewCfgEthernetReset = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 2, 1, 53), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclNewCfgEthernetReset.setStatus('current')
if mibBuilder.loadTexts: aclNewCfgEthernetReset.setDescription('This is an action object to reset an ACL Ethernet entry. A value of other(1) is always returned when this object is read.')
aclNewCfgIpv4Reset = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 2, 1, 54), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclNewCfgIpv4Reset.setStatus('current')
if mibBuilder.loadTexts: aclNewCfgIpv4Reset.setDescription('This is an action object to reset an ACL IPV4 entry. A value of other(1) is always returned when this object is read.')
aclNewCfgTcpudpReset = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 2, 1, 55), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclNewCfgTcpudpReset.setStatus('current')
if mibBuilder.loadTexts: aclNewCfgTcpudpReset.setDescription('This is an action object to reset an ACL Tcpudp entry. A value of other(1) is always returned when this object is read.')
aclNewCfgMirrorPort = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 2, 1, 74), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclNewCfgMirrorPort.setStatus('current')
if mibBuilder.loadTexts: aclNewCfgMirrorPort.setDescription('Set port in the ACL for mirroring. n > 0 - the represented port is configured for mirroring. 0 - the represented port is not configured for mirroring.')
aclNewCfgLog = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 2, 1, 81), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclNewCfgLog.setStatus('current')
if mibBuilder.loadTexts: aclNewCfgLog.setDescription('Whether log for this ACL is enabled or not.')
aclNewCfgFilterActionChangeVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 2, 1, 84), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4094))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclNewCfgFilterActionChangeVlan.setStatus('current')
if mibBuilder.loadTexts: aclNewCfgFilterActionChangeVlan.setDescription('The VLAN will be modified when the action for this ACL entry is changevlan, , when this object is set to 0, the changevlan action is disabled.')
aclCurCfgRemarkOutProfDscpTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 3), )
if mibBuilder.loadTexts: aclCurCfgRemarkOutProfDscpTable.setStatus('current')
if mibBuilder.loadTexts: aclCurCfgRemarkOutProfDscpTable.setDescription('The table of Dscp to out-profile DSCP configuration.')
aclCurCfgRemarkOutProfDscpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 3, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "aclCurCfgRemarkOutProfDscpIndex"))
if mibBuilder.loadTexts: aclCurCfgRemarkOutProfDscpEntry.setStatus('current')
if mibBuilder.loadTexts: aclCurCfgRemarkOutProfDscpEntry.setDescription('Information about a particular Dscp to out profile DSCP configuration')
aclCurCfgRemarkOutProfDscpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aclCurCfgRemarkOutProfDscpIndex.setStatus('current')
if mibBuilder.loadTexts: aclCurCfgRemarkOutProfDscpIndex.setDescription('Dscp value')
aclCurCfgRemarkOutProfDscpMkdnDscp = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aclCurCfgRemarkOutProfDscpMkdnDscp.setStatus('current')
if mibBuilder.loadTexts: aclCurCfgRemarkOutProfDscpMkdnDscp.setDescription('Out Profile DSCP Dscp Value')
aclNewCfgRemarkOutProfDscpTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 4), )
if mibBuilder.loadTexts: aclNewCfgRemarkOutProfDscpTable.setStatus('current')
if mibBuilder.loadTexts: aclNewCfgRemarkOutProfDscpTable.setDescription('The table of Dscp to out-profile DSCP configuration.')
aclNewCfgRemarkOutProfDscpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 4, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "aclNewCfgRemarkOutProfDscpIndex"))
if mibBuilder.loadTexts: aclNewCfgRemarkOutProfDscpEntry.setStatus('current')
if mibBuilder.loadTexts: aclNewCfgRemarkOutProfDscpEntry.setDescription('Information about a particular Dscp to out profile DSCP configuration')
aclNewCfgRemarkOutProfDscpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aclNewCfgRemarkOutProfDscpIndex.setStatus('current')
if mibBuilder.loadTexts: aclNewCfgRemarkOutProfDscpIndex.setDescription('Dscp value')
aclNewCfgRemarkOutProfDscpMkdnDscp = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 1, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 63))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclNewCfgRemarkOutProfDscpMkdnDscp.setStatus('current')
if mibBuilder.loadTexts: aclNewCfgRemarkOutProfDscpMkdnDscp.setDescription('Out Profile DSCP Dscp Value')
acl6CurCfgTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 5, 1), )
if mibBuilder.loadTexts: acl6CurCfgTable.setStatus('current')
if mibBuilder.loadTexts: acl6CurCfgTable.setDescription('The table of current ACL6 configuration.')
acl6CurCfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 5, 1, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "acl6CurCfgIndex"))
if mibBuilder.loadTexts: acl6CurCfgEntry.setStatus('current')
if mibBuilder.loadTexts: acl6CurCfgEntry.setDescription('Current information about a particular ACL6 configuration entry.')
acl6CurCfgIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 5, 1, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: acl6CurCfgIndex.setStatus('current')
if mibBuilder.loadTexts: acl6CurCfgIndex.setDescription('The index associated with this ACL6 entry.')
acl6CurCfgFilterAction = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 5, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 5))).clone(namedValues=NamedValues(("none", 0), ("permit", 1), ("deny", 2), ("setprio", 3), ("changevlan", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: acl6CurCfgFilterAction.setStatus('current')
if mibBuilder.loadTexts: acl6CurCfgFilterAction.setDescription('The action to be performed on a packet that matches the filter settings of this ACL6 entry.')
acl6CurCfgSrcIPv6Address = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 5, 1, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: acl6CurCfgSrcIPv6Address.setStatus('current')
if mibBuilder.loadTexts: acl6CurCfgSrcIPv6Address.setDescription('The source IPv6 address to be filtered. Address should be 4-byte hexadecimal colon notation. Valid IPv6 address should be in any of the following forms xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx or xxxx::xxxx:xxxx:xxxx:xxxx')
acl6CurCfgSrcIPv6PrefixLen = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 5, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: acl6CurCfgSrcIPv6PrefixLen.setStatus('current')
if mibBuilder.loadTexts: acl6CurCfgSrcIPv6PrefixLen.setDescription('The IPv6 prefix applied to acl6CurCfgSrcIPv6PrefixLen for filtering.')
acl6CurCfgDstIPv6Address = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 5, 1, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: acl6CurCfgDstIPv6Address.setStatus('current')
if mibBuilder.loadTexts: acl6CurCfgDstIPv6Address.setDescription('The destination IPv6 address to be filtered. Address should be 4-byte hexadecimal colon notation. Valid IPv6 address should be in any of the following forms xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx or xxxx::xxxx:xxxx:xxxx:xxxx')
acl6CurCfgDstIPv6PrefixLen = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 5, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: acl6CurCfgDstIPv6PrefixLen.setStatus('current')
if mibBuilder.loadTexts: acl6CurCfgDstIPv6PrefixLen.setDescription('The IPv6 prefix applied to acl6CurCfgDstIPv6PrefixLen for filtering.')
acl6CurCfgIPv6FlowLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 5, 1, 1, 9), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: acl6CurCfgIPv6FlowLabel.setStatus('current')
if mibBuilder.loadTexts: acl6CurCfgIPv6FlowLabel.setDescription("The IPv6 FlowLabel to be filtered. 'none' for not initialised, within the range 0-1048575")
acl6CurCfgIPv6TrafficClass = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 5, 1, 1, 10), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: acl6CurCfgIPv6TrafficClass.setStatus('current')
if mibBuilder.loadTexts: acl6CurCfgIPv6TrafficClass.setDescription("The IPv6 Traffic Class to be filtered. 'none' for not initialised, within the range 0-255")
acl6CurCfgIPv6NextHeader = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 5, 1, 1, 11), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: acl6CurCfgIPv6NextHeader.setStatus('current')
if mibBuilder.loadTexts: acl6CurCfgIPv6NextHeader.setDescription("The IPv6 next header to be filtered. 'none' for not initialised, within the range 0-255")
acl6CurCfgSrcPort = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 5, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: acl6CurCfgSrcPort.setStatus('current')
if mibBuilder.loadTexts: acl6CurCfgSrcPort.setDescription('The source TCP/UDP port number to be filtered.')
acl6CurCfgSrcPortMask = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 5, 1, 1, 13), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: acl6CurCfgSrcPortMask.setStatus('current')
if mibBuilder.loadTexts: acl6CurCfgSrcPortMask.setDescription('The mask applied to acl6CurCfgSrcPort for filtering.')
acl6CurCfgDstPort = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 5, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: acl6CurCfgDstPort.setStatus('current')
if mibBuilder.loadTexts: acl6CurCfgDstPort.setDescription('The destination TCP/UDP port number to be filtered.')
acl6CurCfgDstPortMask = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 5, 1, 1, 15), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: acl6CurCfgDstPortMask.setStatus('current')
if mibBuilder.loadTexts: acl6CurCfgDstPortMask.setDescription('The mask applied to acl6CurCfgDstPort for filtering.')
acl6CurCfgTCPFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 5, 1, 1, 16), Bits().clone(namedValues=NamedValues(("reserved1", 0), ("reserved2", 1), ("tcpURG", 2), ("tcpACK", 3), ("tcpPSH", 4), ("tcpRST", 5), ("tcpSYN", 6), ("tcpFIN", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: acl6CurCfgTCPFlags.setStatus('current')
if mibBuilder.loadTexts: acl6CurCfgTCPFlags.setDescription('The TCP flags to be filtered. OCTET xxxxxxxx ||||..|| ||||..||_tcpFIN(7) ||||..|__tcpSYN(6) |||| ||||_____tcpACK(3) |||______tcpURG(2) ||_______reserved2(1) |________reserved1(0) where: - reserved1 - 0; - reserved2 - 0; - x - 0 or 1; ')
acl6CurCfgTCPFlagsMask = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 5, 1, 1, 17), Bits().clone(namedValues=NamedValues(("reserved1", 0), ("reserved2", 1), ("tcpURG", 2), ("tcpACK", 3), ("tcpPSH", 4), ("tcpRST", 5), ("tcpSYN", 6), ("tcpFIN", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: acl6CurCfgTCPFlagsMask.setStatus('current')
if mibBuilder.loadTexts: acl6CurCfgTCPFlagsMask.setDescription('The TCP flags mask. OCTET xxxxxxxx ||||..|| ||||..||_tcpFIN(7) ||||..|__tcpSYN(6) |||| ||||_____tcpACK(3) |||______tcpURG(2) ||_______reserved2(1) |________reserved1(0) where: - reserved1 - 0; - reserved2 - 0; - x - 0 or 1; ')
acl6CurCfgStatistics = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 5, 1, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: acl6CurCfgStatistics.setStatus('current')
if mibBuilder.loadTexts: acl6CurCfgStatistics.setDescription('Whether statistics collection for this ACL6 is enabled or not.')
acl6CurCfgUser = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 5, 1, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: acl6CurCfgUser.setStatus('current')
if mibBuilder.loadTexts: acl6CurCfgUser.setDescription('Set user defined priority for this ACL6.')
acl6CurCfgInprofDscp = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 5, 1, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: acl6CurCfgInprofDscp.setStatus('current')
if mibBuilder.loadTexts: acl6CurCfgInprofDscp.setDescription('Set in profile pkts DSCP value.')
acl6CurCfgInprofDscpEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 5, 1, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: acl6CurCfgInprofDscpEnable.setStatus('current')
if mibBuilder.loadTexts: acl6CurCfgInprofDscpEnable.setDescription('Whether in profile update DSCP for this ACL6 is enabled or not.')
acl6CurCfgLog = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 5, 1, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: acl6CurCfgLog.setStatus('current')
if mibBuilder.loadTexts: acl6CurCfgLog.setDescription('Whether log for this ACL is enabled or not.')
acl6CurCfgFilterActionChangeVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 5, 1, 1, 27), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4094))).setMaxAccess("readonly")
if mibBuilder.loadTexts: acl6CurCfgFilterActionChangeVlan.setStatus('current')
if mibBuilder.loadTexts: acl6CurCfgFilterActionChangeVlan.setDescription('The classified VLAN only if the action is set as changevlan')
acl6NewCfgTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 5, 2), )
if mibBuilder.loadTexts: acl6NewCfgTable.setStatus('current')
if mibBuilder.loadTexts: acl6NewCfgTable.setDescription('The table of new ACL6 configuration.')
acl6NewCfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 5, 2, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "acl6NewCfgIndex"))
if mibBuilder.loadTexts: acl6NewCfgEntry.setStatus('current')
if mibBuilder.loadTexts: acl6NewCfgEntry.setDescription('New information about a particular ACL6 configuration.')
acl6NewCfgIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 5, 2, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: acl6NewCfgIndex.setStatus('current')
if mibBuilder.loadTexts: acl6NewCfgIndex.setDescription('The index associated with this ACL6 entry.')
acl6NewCfgFilterAction = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 5, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 5))).clone(namedValues=NamedValues(("none", 0), ("permit", 1), ("deny", 2), ("setprio", 3), ("changevlan", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: acl6NewCfgFilterAction.setStatus('current')
if mibBuilder.loadTexts: acl6NewCfgFilterAction.setDescription('The action to be performed on a packet that matches the filter settings of this ACL6 entry.')
acl6NewCfgSrcIPv6Address = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 5, 2, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: acl6NewCfgSrcIPv6Address.setStatus('current')
if mibBuilder.loadTexts: acl6NewCfgSrcIPv6Address.setDescription('The source IPv6 address to be filtered. Address should be 4-byte hexadecimal colon notation. Valid IPv6 address should be in any of the following forms xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx or xxxx::xxxx:xxxx:xxxx:xxxx')
acl6NewCfgSrcIPv6PrefixLen = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 5, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: acl6NewCfgSrcIPv6PrefixLen.setStatus('current')
if mibBuilder.loadTexts: acl6NewCfgSrcIPv6PrefixLen.setDescription('The IPv6 prefix applied to acl6CurCfgSrcIPv6PrefixLen for filtering.')
acl6NewCfgDstIPv6Address = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 5, 2, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: acl6NewCfgDstIPv6Address.setStatus('current')
if mibBuilder.loadTexts: acl6NewCfgDstIPv6Address.setDescription('The destination IPv6 address to be filtered. Address should be 4-byte hexadecimal colon notation. Valid IPv6 address should be in any of the following forms xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx or xxxx::xxxx:xxxx:xxxx:xxxx')
acl6NewCfgDstIPv6PrefixLen = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 5, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: acl6NewCfgDstIPv6PrefixLen.setStatus('current')
if mibBuilder.loadTexts: acl6NewCfgDstIPv6PrefixLen.setDescription('The IPv6 prefix applied to acl6CurCfgDstIPv6PrefixLen for filtering.')
acl6NewCfgIPv6FlowLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 5, 2, 1, 9), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: acl6NewCfgIPv6FlowLabel.setStatus('current')
if mibBuilder.loadTexts: acl6NewCfgIPv6FlowLabel.setDescription("The IPv6 flow label to be filtered. 'none' for not initialised, within the range 0-1048575")
acl6NewCfgIPv6TrafficClass = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 5, 2, 1, 10), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: acl6NewCfgIPv6TrafficClass.setStatus('current')
if mibBuilder.loadTexts: acl6NewCfgIPv6TrafficClass.setDescription("The IPv6 traffic class to be filtered. 'none' for not initialised, within the range 0-255")
acl6NewCfgIPv6NextHeader = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 5, 2, 1, 11), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: acl6NewCfgIPv6NextHeader.setStatus('current')
if mibBuilder.loadTexts: acl6NewCfgIPv6NextHeader.setDescription("The IPv6 next header to be filtered. 'none' for not initialised, within the range 0-255")
acl6NewCfgSrcPort = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 5, 2, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: acl6NewCfgSrcPort.setStatus('current')
if mibBuilder.loadTexts: acl6NewCfgSrcPort.setDescription('The source TCP/UDP port number to be filtered.')
acl6NewCfgSrcPortMask = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 5, 2, 1, 13), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: acl6NewCfgSrcPortMask.setStatus('current')
if mibBuilder.loadTexts: acl6NewCfgSrcPortMask.setDescription('The mask applied to acl6CurCfgSrcPort for filtering.')
acl6NewCfgDstPort = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 5, 2, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: acl6NewCfgDstPort.setStatus('current')
if mibBuilder.loadTexts: acl6NewCfgDstPort.setDescription('The destination TCP/UDP port number to be filtered.')
acl6NewCfgDstPortMask = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 5, 2, 1, 15), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: acl6NewCfgDstPortMask.setStatus('current')
if mibBuilder.loadTexts: acl6NewCfgDstPortMask.setDescription('The mask applied to acl6CurCfgDstPort for filtering.')
acl6NewCfgTCPFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 5, 2, 1, 16), Bits().clone(namedValues=NamedValues(("reserved1", 0), ("reserved2", 1), ("tcpURG", 2), ("tcpACK", 3), ("tcpPSH", 4), ("tcpRST", 5), ("tcpSYN", 6), ("tcpFIN", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: acl6NewCfgTCPFlags.setStatus('current')
if mibBuilder.loadTexts: acl6NewCfgTCPFlags.setDescription('The TCP flags to be filtered. OCTET xxxxxxxx ||||..|| ||||..||_tcpFIN(7) ||||..|__tcpSYN(6) |||| ||||_____tcpACK(3) |||______tcpURG(2) ||_______reserved2(1) |________reserved1(0) where: - reserved1 - 0; - reserved2 - 0; - x - 0 or 1; ')
acl6NewCfgTCPFlagsMask = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 5, 2, 1, 17), Bits().clone(namedValues=NamedValues(("reserved1", 0), ("reserved2", 1), ("tcpURG", 2), ("tcpACK", 3), ("tcpPSH", 4), ("tcpRST", 5), ("tcpSYN", 6), ("tcpFIN", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: acl6NewCfgTCPFlagsMask.setStatus('current')
if mibBuilder.loadTexts: acl6NewCfgTCPFlagsMask.setDescription('The TCP flags mask. OCTET xxxxxxxx ||||..|| ||||..||_tcpFIN(7) ||||..|__tcpSYN(6) |||| ||||_____tcpACK(3) |||______tcpURG(2) ||_______reserved2(1) |________reserved1(0) where: - reserved1 - 0; - reserved2 - 0; - x - 0 or 1; ')
acl6NewCfgStatistics = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 5, 2, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: acl6NewCfgStatistics.setStatus('current')
if mibBuilder.loadTexts: acl6NewCfgStatistics.setDescription('Whether statistics collection for this ACL6 is enabled or not.')
acl6NewCfgDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 5, 2, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("delete", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: acl6NewCfgDelete.setStatus('current')
if mibBuilder.loadTexts: acl6NewCfgDelete.setDescription('This is an action object to delete an ACL6 entry. A value of other(1) is always returned when this object is read.')
acl6NewCfgUser = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 5, 2, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: acl6NewCfgUser.setStatus('current')
if mibBuilder.loadTexts: acl6NewCfgUser.setDescription('Set user defined priority for this ACL6.')
acl6NewCfgInprofDscp = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 5, 2, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 63))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: acl6NewCfgInprofDscp.setStatus('current')
if mibBuilder.loadTexts: acl6NewCfgInprofDscp.setDescription('Set in profile pkts DSCP value.')
acl6NewCfgInprofDscpEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 5, 2, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: acl6NewCfgInprofDscpEnable.setStatus('current')
if mibBuilder.loadTexts: acl6NewCfgInprofDscpEnable.setDescription('Whether in profile update DSCP for this ACL6 is enabled or not. Only the value disable(0) can be set, causing the in profile update DSCP to be disabled for this ACL6. The value enable(1) is automatically set when setting a value for aclNewCfgInprofDscp object.')
acl6NewCfgIPv6Reset = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 5, 2, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: acl6NewCfgIPv6Reset.setStatus('current')
if mibBuilder.loadTexts: acl6NewCfgIPv6Reset.setDescription('This is an action object to reset an ACL IPV6 entry. A value of other(1) is always returned when this object is read.')
acl6NewCfgTcpudpReset = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 5, 2, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: acl6NewCfgTcpudpReset.setStatus('current')
if mibBuilder.loadTexts: acl6NewCfgTcpudpReset.setDescription('This is an action object to reset an ACL6 Tcpudp entry. A value of other(1) is always returned when this object is read.')
acl6NewCfgLog = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 5, 2, 1, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: acl6NewCfgLog.setStatus('current')
if mibBuilder.loadTexts: acl6NewCfgLog.setDescription('Whether log for this ACL is enabled or not.')
acl6NewCfgFilterActionChangeVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 5, 2, 1, 34), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4094))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: acl6NewCfgFilterActionChangeVlan.setStatus('current')
if mibBuilder.loadTexts: acl6NewCfgFilterActionChangeVlan.setDescription('The VLAN will be modified when the action for this ACL6 entry is changevlan, , when this object is set to 0, the changevlan action is disabled.')
aclLogCurInterval = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 6, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 600))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aclLogCurInterval.setStatus('current')
if mibBuilder.loadTexts: aclLogCurInterval.setDescription('The interval secends of displaying Logs. Default is 300s.')
aclLogNewInterval = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 6, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 600))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclLogNewInterval.setStatus('current')
if mibBuilder.loadTexts: aclLogNewInterval.setDescription('The interval secends of displaying Logs. Default is 300s.')
aclLogCurRateLimit = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 6, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aclLogCurRateLimit.setStatus('current')
if mibBuilder.loadTexts: aclLogCurRateLimit.setDescription('The rate limit of ACL Log queue. Default is 10pps.')
aclLogNewRateLimit = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 6, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclLogNewRateLimit.setStatus('current')
if mibBuilder.loadTexts: aclLogNewRateLimit.setDescription('The rate limit of ACL Log queue. Default is 10pps.')
aclCurCfgPortTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 4, 1), )
if mibBuilder.loadTexts: aclCurCfgPortTable.setStatus('current')
if mibBuilder.loadTexts: aclCurCfgPortTable.setDescription('The table of port acl groups configuration.')
aclCurCfgPortTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 4, 1, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "aclCurCfgPortIndex"))
if mibBuilder.loadTexts: aclCurCfgPortTableEntry.setStatus('current')
if mibBuilder.loadTexts: aclCurCfgPortTableEntry.setDescription('Information about a particular port acl configuration.')
aclCurCfgPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 4, 1, 1, 1), PortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aclCurCfgPortIndex.setStatus('current')
if mibBuilder.loadTexts: aclCurCfgPortIndex.setDescription('The identifier of a particular port. This is also index to the entLogicalTable of Entity MIB.')
aclCurCfgPortAclBmap = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 4, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 512))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aclCurCfgPortAclBmap.setStatus('current')
if mibBuilder.loadTexts: aclCurCfgPortAclBmap.setDescription('The acls applied to the port. The acls are presented in bitmap format. This string displays acl number from 1 to 896. in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ acl 9 || || || ||___ acl 8 || |____ acl 7 || . . . ||_________ acl 2 |__________ acl 1 where x : 1 - The represented acl applied to the port. 0 - The represented acl not applied to the port.')
aclCurCfgPortAcl6Bmap = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 4, 1, 1, 13), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aclCurCfgPortAcl6Bmap.setStatus('current')
if mibBuilder.loadTexts: aclCurCfgPortAcl6Bmap.setDescription('The acls applied to the port. The acls are presented in bitmap format. This string displays acl number from 1 to 128. in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ acl6 9 || || || ||___ acl6 8 || |____ acl6 7 || . . . ||_________ acl6 2 |__________ acl6 1 where x : 1 - The represented acl6 applied to the port. 0 - The represented acl6 not applied to the port.')
aclNewCfgPortTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 4, 2), )
if mibBuilder.loadTexts: aclNewCfgPortTable.setStatus('current')
if mibBuilder.loadTexts: aclNewCfgPortTable.setDescription('The table of port acl configuration.')
aclNewCfgPortTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 4, 2, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "aclNewCfgPortIndex"))
if mibBuilder.loadTexts: aclNewCfgPortTableEntry.setStatus('current')
if mibBuilder.loadTexts: aclNewCfgPortTableEntry.setDescription('Information about a particular port acl groups configuration.')
aclNewCfgPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 4, 2, 1, 1), PortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aclNewCfgPortIndex.setStatus('current')
if mibBuilder.loadTexts: aclNewCfgPortIndex.setDescription('The identifier of a particular port. This is also index to the entLogicalTable of Entity MIB.')
aclNewCfgPortAddAcl = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 4, 2, 1, 2), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclNewCfgPortAddAcl.setStatus('current')
if mibBuilder.loadTexts: aclNewCfgPortAddAcl.setDescription("The acl to be added to the specified port. A '0' value is returned when read.")
aclNewCfgPortRemoveAcl = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 4, 2, 1, 5), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclNewCfgPortRemoveAcl.setStatus('current')
if mibBuilder.loadTexts: aclNewCfgPortRemoveAcl.setDescription("The acl to be removed from the specified port. A '0' value is returned when read.")
aclNewCfgPortAclBmap = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 4, 2, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 512))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aclNewCfgPortAclBmap.setStatus('current')
if mibBuilder.loadTexts: aclNewCfgPortAclBmap.setDescription('The acls applied to the port. The acls are presented in bitmap format. This string displays acl number from 1 to 896. in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ acl 9 || || || ||___ acl 8 || |____ acl 7 || . . . ||_________ acl 2 |__________ acl 1 where x : 1 - The represented acl applied to the port. 0 - The represented acl not applied to the port.')
aclNewCfgPortAddAcl6 = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 4, 2, 1, 11), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclNewCfgPortAddAcl6.setStatus('current')
if mibBuilder.loadTexts: aclNewCfgPortAddAcl6.setDescription("The acl6 to be added to the specified port. A '0' value is returned when read.")
aclNewCfgPortRemoveAcl6 = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 4, 2, 1, 12), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclNewCfgPortRemoveAcl6.setStatus('current')
if mibBuilder.loadTexts: aclNewCfgPortRemoveAcl6.setDescription("The acl6 to be removed from the specified port. A '0' value is returned when read.")
aclNewCfgPortAcl6Bmap = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 1, 4, 2, 1, 13), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 512))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aclNewCfgPortAcl6Bmap.setStatus('current')
if mibBuilder.loadTexts: aclNewCfgPortAcl6Bmap.setDescription('The acl6s applied to the port. The acl6s are presented in bitmap format. This string displays acl number from 1 to 128. in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ acl6 9 || || || ||___ acl6 8 || |____ acl6 7 || . . . ||_________ acl6 2 |__________ acl6 1 where x : 1 - The represented acl6 applied to the port. 0 - The represented acl6 not applied to the port.')
vmapList = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1))
vmapCfg = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 2))
vmapVlanCfg = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 2, 1))
vmapGroupCfg = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 2, 2))
vmapVlanCfgNonServerPorts = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 2, 1, 1))
vmapVlanCfgServerPorts = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 2, 1, 2))
vmapVlanCfgAllPorts = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 2, 1, 3))
vmapGroupCfgNonServerPorts = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 2, 2, 1))
vmapGroupCfgServerPorts = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 2, 2, 2))
vmapGroupCfgAllPorts = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 2, 2, 3))
vmapCurCfgTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 1), )
if mibBuilder.loadTexts: vmapCurCfgTable.setStatus('current')
if mibBuilder.loadTexts: vmapCurCfgTable.setDescription('The table of current VMAP configuration.')
vmapCurCfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 1, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "vmapCurCfgIndex"))
if mibBuilder.loadTexts: vmapCurCfgEntry.setStatus('current')
if mibBuilder.loadTexts: vmapCurCfgEntry.setDescription('Current information about a particular VMAP configuration entry.')
vmapCurCfgIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 1, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmapCurCfgIndex.setStatus('current')
if mibBuilder.loadTexts: vmapCurCfgIndex.setDescription('The index associated with this VMAP entry.')
vmapCurCfgFilterAction = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 5))).clone(namedValues=NamedValues(("none", 0), ("permit", 1), ("deny", 2), ("setprio", 3), ("changevlan", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmapCurCfgFilterAction.setStatus('current')
if mibBuilder.loadTexts: vmapCurCfgFilterAction.setDescription('The action to be performed on a packet that matches the filter settings of this VMAP entry.')
vmapCurCfgFilterActionSetPrio = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("none", 0), ("prio0", 1), ("prio1", 2), ("prio2", 3), ("prio3", 4), ("prio4", 5), ("prio5", 6), ("prio6", 7), ("prio7", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmapCurCfgFilterActionSetPrio.setStatus('current')
if mibBuilder.loadTexts: vmapCurCfgFilterActionSetPrio.setDescription('The value to be used when the action to be performed is setprio for this VMAP entry.')
vmapCurCfgEthFmt = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("none", 0), ("ethernet2", 1), ("snap", 2), ("llc", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmapCurCfgEthFmt.setStatus('current')
if mibBuilder.loadTexts: vmapCurCfgEthFmt.setDescription('The packet ethernet format to be filtered.')
vmapCurCfgTagFmt = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("disabled", 1), ("any", 2), ("untagged", 3), ("tagged", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmapCurCfgTagFmt.setStatus('current')
if mibBuilder.loadTexts: vmapCurCfgTagFmt.setDescription('The packet tag format to be filtered.')
vmapCurCfgIPFmt = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("ipv4", 2), ("ipv6", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmapCurCfgIPFmt.setStatus('current')
if mibBuilder.loadTexts: vmapCurCfgIPFmt.setDescription('The packet IP format to be filtered.')
vmapCurCfgSrcMACAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 1, 1, 7), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmapCurCfgSrcMACAddress.setStatus('current')
if mibBuilder.loadTexts: vmapCurCfgSrcMACAddress.setDescription('The source MAC address to be filtered.')
vmapCurCfgSrcMACMask = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 1, 1, 8), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmapCurCfgSrcMACMask.setStatus('current')
if mibBuilder.loadTexts: vmapCurCfgSrcMACMask.setDescription('The address mask applied to aclCurCfgSrcMACAddress for filtering.')
vmapCurCfgDstMACAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 1, 1, 9), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmapCurCfgDstMACAddress.setStatus('current')
if mibBuilder.loadTexts: vmapCurCfgDstMACAddress.setDescription('The destination MAC address to be filtered.')
vmapCurCfgDstMACMask = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 1, 1, 10), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmapCurCfgDstMACMask.setStatus('current')
if mibBuilder.loadTexts: vmapCurCfgDstMACMask.setDescription('The address mask applied to aclCurCfgDstMACAddress for filtering.')
vmapCurCfgEthernetTypeName = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("none", 0), ("arp", 1), ("ipv4", 2), ("ipv6", 3), ("mpls", 4), ("rarp", 5), ("any", 6), ("other", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmapCurCfgEthernetTypeName.setStatus('current')
if mibBuilder.loadTexts: vmapCurCfgEthernetTypeName.setDescription('The Ethernet type to be filtered. If the value of this object is other(7), the value of aclNewCfgEthernetTypeValue indicates the ethernet type that will be filtered.')
vmapCurCfgEthernetTypeValue = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1536, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmapCurCfgEthernetTypeValue.setStatus('current')
if mibBuilder.loadTexts: vmapCurCfgEthernetTypeValue.setDescription('The Ethernet type value to be filtered. The value of this object is equivalent to the value of aclNewCfgEthernetTypeName except when the value of aclNewCfgEthernetTypeName is other(7), which can be any user-defined value for this object.')
vmapCurCfg8021pPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("none", 0), ("priority0", 1), ("priority1", 2), ("priority2", 3), ("priority3", 4), ("priority4", 5), ("priority5", 6), ("priority6", 7), ("priority7", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmapCurCfg8021pPriority.setStatus('current')
if mibBuilder.loadTexts: vmapCurCfg8021pPriority.setDescription('The 802.1p priority to be filtered.')
vmapCurCfgTypeOfService = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 1, 1, 14), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmapCurCfgTypeOfService.setStatus('current')
if mibBuilder.loadTexts: vmapCurCfgTypeOfService.setDescription("The type of service to be filtered. 'none' for not initialised, within the range 0-255")
vmapCurCfgProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 1, 1, 15), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmapCurCfgProtocol.setStatus('current')
if mibBuilder.loadTexts: vmapCurCfgProtocol.setDescription("The protocol to be filtered. 'none' for not initialised, within the range 0-255")
vmapCurCfgSrcIPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 1, 1, 16), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmapCurCfgSrcIPAddress.setStatus('current')
if mibBuilder.loadTexts: vmapCurCfgSrcIPAddress.setDescription('The source IP address to be filtered.')
vmapCurCfgSrcIPMask = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 1, 1, 17), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmapCurCfgSrcIPMask.setStatus('current')
if mibBuilder.loadTexts: vmapCurCfgSrcIPMask.setDescription('The address mask applied to aclCurCfgSrcIPAddress for filtering.')
vmapCurCfgDstIPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 1, 1, 18), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmapCurCfgDstIPAddress.setStatus('current')
if mibBuilder.loadTexts: vmapCurCfgDstIPAddress.setDescription('The destination IP address to be filtered.')
vmapCurCfgDstIPMask = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 1, 1, 19), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmapCurCfgDstIPMask.setStatus('current')
if mibBuilder.loadTexts: vmapCurCfgDstIPMask.setDescription('The address mask applied to aclCurCfgDstIPAddress for filtering.')
vmapCurCfgSrcPort = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 1, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmapCurCfgSrcPort.setStatus('current')
if mibBuilder.loadTexts: vmapCurCfgSrcPort.setDescription('The source TCP/UDP port number to be filtered.')
vmapCurCfgSrcPortMask = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 1, 1, 21), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmapCurCfgSrcPortMask.setStatus('current')
if mibBuilder.loadTexts: vmapCurCfgSrcPortMask.setDescription('The mask applied to aclCurCfgSrcPort for filtering.')
vmapCurCfgDstPort = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 1, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmapCurCfgDstPort.setStatus('current')
if mibBuilder.loadTexts: vmapCurCfgDstPort.setDescription('The destination TCP/UDP port number to be filtered.')
vmapCurCfgDstPortMask = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 1, 1, 23), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmapCurCfgDstPortMask.setStatus('current')
if mibBuilder.loadTexts: vmapCurCfgDstPortMask.setDescription('The mask applied to aclCurCfgDstPort for filtering.')
vmapCurCfgTCPFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 1, 1, 24), Bits().clone(namedValues=NamedValues(("reserved1", 0), ("reserved2", 1), ("tcpURG", 2), ("tcpACK", 3), ("tcpPSH", 4), ("tcpRST", 5), ("tcpSYN", 6), ("tcpFIN", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmapCurCfgTCPFlags.setStatus('current')
if mibBuilder.loadTexts: vmapCurCfgTCPFlags.setDescription('The TCP flags to be filtered. OCTET xxxxxxxx ||||..|| ||||..||_tcpFIN(7) ||||..|__tcpSYN(6) |||| ||||_____tcpACK(3) |||______tcpURG(2) ||_______reserved2(1) |________reserved1(0) where: - reserved1 - 0; - reserved2 - 0; - x - 0 or 1; ')
vmapCurCfgTCPFlagsMask = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 1, 1, 25), Bits().clone(namedValues=NamedValues(("reserved1", 0), ("reserved2", 1), ("tcpURG", 2), ("tcpACK", 3), ("tcpPSH", 4), ("tcpRST", 5), ("tcpSYN", 6), ("tcpFIN", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmapCurCfgTCPFlagsMask.setStatus('current')
if mibBuilder.loadTexts: vmapCurCfgTCPFlagsMask.setDescription('The TCP flags mask. OCTET xxxxxxxx ||||..|| ||||..||_tcpFIN(7) ||||..|__tcpSYN(6) |||| ||||_____tcpACK(3) |||______tcpURG(2) ||_______reserved2(1) |________reserved1(0) where: - reserved1 - 0; - reserved2 - 0; - x - 0 or 1; ')
vmapCurCfgEgressPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 1, 1, 26), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmapCurCfgEgressPorts.setStatus('current')
if mibBuilder.loadTexts: vmapCurCfgEgressPorts.setDescription('The port list in the VMAP configured for egress filtering. The ports are presented in bitmap format, as follows: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || | || || |_ port 9 || || || ||___ port 8 || |____ port 7 || . . . ||_________ port 2 |__________ port 1 where x: 1 - the represented port is configured for filtering. 0 - the represented port is not configured for filtering.')
vmapCurCfgStatistics = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 1, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmapCurCfgStatistics.setStatus('current')
if mibBuilder.loadTexts: vmapCurCfgStatistics.setDescription('Whether statistics collection for this VMAP is enabled or not.')
vmapCurCfgMeterAction = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 1, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("unconfigured", 0), ("outdrop", 1), ("outpass", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmapCurCfgMeterAction.setStatus('current')
if mibBuilder.loadTexts: vmapCurCfgMeterAction.setDescription('Meter Action for this VMAP.')
vmapCurCfgMeterEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 1, 1, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("enabled", 0), ("disabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmapCurCfgMeterEnable.setStatus('current')
if mibBuilder.loadTexts: vmapCurCfgMeterEnable.setDescription('Meter state for this VMAP.')
vmapCurCfgKbitsSec = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 1, 1, 33), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(64, 10000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmapCurCfgKbitsSec.setStatus('current')
if mibBuilder.loadTexts: vmapCurCfgKbitsSec.setDescription('The commited rate of meter associated with this VMAP entry.')
vmapCurCfgKbitsBurst = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 1, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(32, 64, 128, 256, 512, 1024, 2048, 4096))).clone(namedValues=NamedValues(("kbits32", 32), ("kbits64", 64), ("kbits128", 128), ("kbits256", 256), ("kbits512", 512), ("kbits1024", 1024), ("kbits2048", 2048), ("kbits4096", 4096)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmapCurCfgKbitsBurst.setStatus('current')
if mibBuilder.loadTexts: vmapCurCfgKbitsBurst.setDescription('The maxmium burst sizeof meter associated with this VMAP entry.')
vmapCurCfgUser = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 1, 1, 35), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmapCurCfgUser.setStatus('current')
if mibBuilder.loadTexts: vmapCurCfgUser.setDescription('Set user defined priority for this VMAP.')
vmapCurCfgInprofDscp = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 1, 1, 36), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmapCurCfgInprofDscp.setStatus('current')
if mibBuilder.loadTexts: vmapCurCfgInprofDscp.setDescription('Set in profile pkts DSCP value.')
vmapCurCfgTos = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 1, 1, 37), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmapCurCfgTos.setStatus('current')
if mibBuilder.loadTexts: vmapCurCfgTos.setDescription('To enable/disable setting pkts based on TOS bits.')
vmapCurCfgOutprofDscp = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 1, 1, 38), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmapCurCfgOutprofDscp.setStatus('current')
if mibBuilder.loadTexts: vmapCurCfgOutprofDscp.setDescription('Set out profile pkts DSCP value.')
vmapCurCfgUserEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 1, 1, 39), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("userdefined", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmapCurCfgUserEnable.setStatus('current')
if mibBuilder.loadTexts: vmapCurCfgUserEnable.setDescription('Set update method for this VMAP.')
vmapCurCfgInprofDscpEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 1, 1, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmapCurCfgInprofDscpEnable.setStatus('current')
if mibBuilder.loadTexts: vmapCurCfgInprofDscpEnable.setDescription('Whether in profile update DSCP for this VMAP is enabled or not.')
vmapCurCfgOutprofDscpEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 1, 1, 41), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmapCurCfgOutprofDscpEnable.setStatus('current')
if mibBuilder.loadTexts: vmapCurCfgOutprofDscpEnable.setDescription('Whether out profile update DSCP for this VMAP is enabled or not.')
vmapCurCfgMirrorPort = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 1, 1, 51), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmapCurCfgMirrorPort.setStatus('current')
if mibBuilder.loadTexts: vmapCurCfgMirrorPort.setDescription('Set port in the VMAP for mirroring. n > 0 - the represented port is configured for mirroring. 0 - the represented port is not configured for mirroring.')
vmapCurCfgFilterActionChangeVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 1, 1, 52), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4094))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmapCurCfgFilterActionChangeVlan.setStatus('current')
if mibBuilder.loadTexts: vmapCurCfgFilterActionChangeVlan.setDescription('The classified VLAN only if the action is set as changevlan')
vmapNewCfgTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 2), )
if mibBuilder.loadTexts: vmapNewCfgTable.setStatus('current')
if mibBuilder.loadTexts: vmapNewCfgTable.setDescription('The table of new VMAP configuration.')
vmapNewCfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 2, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "vmapNewCfgIndex"))
if mibBuilder.loadTexts: vmapNewCfgEntry.setStatus('current')
if mibBuilder.loadTexts: vmapNewCfgEntry.setDescription('New information about a particular VMAP configuration.')
vmapNewCfgIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 2, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmapNewCfgIndex.setStatus('current')
if mibBuilder.loadTexts: vmapNewCfgIndex.setDescription('The index associated with this VMAP entry.')
vmapNewCfgFilterAction = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 5))).clone(namedValues=NamedValues(("none", 0), ("permit", 1), ("deny", 2), ("setprio", 3), ("changevlan", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmapNewCfgFilterAction.setStatus('current')
if mibBuilder.loadTexts: vmapNewCfgFilterAction.setDescription('The action to be performed on a packet that matches the filter settings of this VMAP entry.')
vmapNewCfgFilterActionSetPrio = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("none", 0), ("prio0", 1), ("prio1", 2), ("prio2", 3), ("prio3", 4), ("prio4", 5), ("prio5", 6), ("prio6", 7), ("prio7", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmapNewCfgFilterActionSetPrio.setStatus('current')
if mibBuilder.loadTexts: vmapNewCfgFilterActionSetPrio.setDescription('The COS queue to be used when the action for this VMAP entry is set to setprio.')
vmapNewCfgEthFmt = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("none", 0), ("ethernet2", 1), ("snap", 2), ("llc", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmapNewCfgEthFmt.setStatus('current')
if mibBuilder.loadTexts: vmapNewCfgEthFmt.setDescription('The packet ethernet format to be filtered.')
vmapNewCfgTagFmt = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("disabled", 1), ("any", 2), ("none", 3), ("tagged", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmapNewCfgTagFmt.setStatus('current')
if mibBuilder.loadTexts: vmapNewCfgTagFmt.setDescription('The packet tagging format to be filtered.')
vmapNewCfgIPFmt = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("ipv4", 2), ("ipv6", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmapNewCfgIPFmt.setStatus('current')
if mibBuilder.loadTexts: vmapNewCfgIPFmt.setDescription('The packet IP format to be filtered.')
vmapNewCfgSrcMACAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 2, 1, 7), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmapNewCfgSrcMACAddress.setStatus('current')
if mibBuilder.loadTexts: vmapNewCfgSrcMACAddress.setDescription('The source MAC address to be filtered. Whenever this object is set to a nonzero value, the aclNewCfgSrcMACMask object, if not yet set, will be automatically set to ff:ff:ff:ff:ff:ff.')
vmapNewCfgSrcMACMask = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 2, 1, 8), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmapNewCfgSrcMACMask.setStatus('current')
if mibBuilder.loadTexts: vmapNewCfgSrcMACMask.setDescription('The address mask to be applied to aclNewCfgSrcMACAddress for filtering.')
vmapNewCfgDstMACAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 2, 1, 9), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmapNewCfgDstMACAddress.setStatus('current')
if mibBuilder.loadTexts: vmapNewCfgDstMACAddress.setDescription('The destination MAC address to be filtered. Whenever this object is set to a nonzero value, the aclNewCfgDstMACMask object, if not yet set, will be automatically set to ff:ff:ff:ff:ff:ff.')
vmapNewCfgDstMACMask = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 2, 1, 10), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmapNewCfgDstMACMask.setStatus('current')
if mibBuilder.loadTexts: vmapNewCfgDstMACMask.setDescription('The address mask to be applied to aclNewCfgDstMACAddress for filtering.')
vmapNewCfgEthernetTypeName = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("none", 0), ("arp", 1), ("ipv4", 2), ("ipv6", 3), ("mpls", 4), ("rarp", 5), ("any", 6), ("other", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmapNewCfgEthernetTypeName.setStatus('current')
if mibBuilder.loadTexts: vmapNewCfgEthernetTypeName.setDescription('The Ethernet type to be filtered. If the value of this object is other(7), the value of aclNewCfgEthernetTypeValue indicates the ethernet type that will be filtered. If this object is set to a value other than other(7), the value of the aclNewCfgEthernetTypeValue object is automatically set, as follows: aclNewCfgEthernetTypeName aclNewCfgEthernetTypeValue none(0) 0 arp(1) 2054 (0x0806) ipv4(2) 2048 (0x0800) ipv6(3) 34525 (0x86dd) mpls(4) 34887 (0x8847) rarp(5) 32821 (0x8035) any(6) 65535 (0xffff) ')
vmapNewCfgEthernetTypeValue = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 2, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1536, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmapNewCfgEthernetTypeValue.setStatus('current')
if mibBuilder.loadTexts: vmapNewCfgEthernetTypeValue.setDescription('The Ethernet type value to be filtered. The value of this object is equivalent to the value of aclNewCfgEthernetTypeName except when the value of aclNewCfgEthernetTypeName is other(7), which can be any user-defined value for this object.')
vmapNewCfg8021pPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("none", 0), ("priority0", 1), ("priority1", 2), ("priority2", 3), ("priority3", 4), ("priority4", 5), ("priority5", 6), ("priority6", 7), ("priority7", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmapNewCfg8021pPriority.setStatus('current')
if mibBuilder.loadTexts: vmapNewCfg8021pPriority.setDescription('The 802.1p priority to be filtered.')
vmapNewCfgTypeOfService = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 2, 1, 14), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmapNewCfgTypeOfService.setStatus('current')
if mibBuilder.loadTexts: vmapNewCfgTypeOfService.setDescription("The type of service to be filtered. 'none' for not initialised, within the range 0-255")
vmapNewCfgProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 2, 1, 15), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmapNewCfgProtocol.setStatus('current')
if mibBuilder.loadTexts: vmapNewCfgProtocol.setDescription("The protocol to be filtered. 'none' for not initialised, within the range 0-255")
vmapNewCfgSrcIPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 2, 1, 16), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmapNewCfgSrcIPAddress.setStatus('current')
if mibBuilder.loadTexts: vmapNewCfgSrcIPAddress.setDescription('The source IP address to be filtered. Whenever this object is set to a nonzero value, the aclNewCfgSrcIPMask object, if not yet set, will be automatically set to 255.255.255.255.')
vmapNewCfgSrcIPMask = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 2, 1, 17), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmapNewCfgSrcIPMask.setStatus('current')
if mibBuilder.loadTexts: vmapNewCfgSrcIPMask.setDescription('The address mask to be applied to aclNewCfgSrcIPAddress for filtering.')
vmapNewCfgDstIPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 2, 1, 18), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmapNewCfgDstIPAddress.setStatus('current')
if mibBuilder.loadTexts: vmapNewCfgDstIPAddress.setDescription('The destination IP address to be filtered. Whenever this object is set to a nonzero value, the aclNewCfgDstIPMask object, if not yet set, will be automatically set to 255.255.255.255.')
vmapNewCfgDstIPMask = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 2, 1, 19), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmapNewCfgDstIPMask.setStatus('current')
if mibBuilder.loadTexts: vmapNewCfgDstIPMask.setDescription('The address mask to be applied to aclNewCfgDstIPAddress for filtering.')
vmapNewCfgSrcPort = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 2, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmapNewCfgSrcPort.setStatus('current')
if mibBuilder.loadTexts: vmapNewCfgSrcPort.setDescription('The source TCP/UDP port number to be filtered. Whenever this object is set if the aclNewCfgSrcPortMask object is not set will be automatically set to 65535 (0xffff).')
vmapNewCfgSrcPortMask = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 2, 1, 21), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmapNewCfgSrcPortMask.setStatus('current')
if mibBuilder.loadTexts: vmapNewCfgSrcPortMask.setDescription('The mask to be applied to aclNewCfgSrcPort for filtering.')
vmapNewCfgDstPort = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 2, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmapNewCfgDstPort.setStatus('current')
if mibBuilder.loadTexts: vmapNewCfgDstPort.setDescription('The destination TCP/UDP port number to be filtered. Whenever this object is set the aclNewCfgSrcPortMask object, if not yet set, will be automatically set to 65535 (0xffff).')
vmapNewCfgDstPortMask = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 2, 1, 23), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmapNewCfgDstPortMask.setStatus('current')
if mibBuilder.loadTexts: vmapNewCfgDstPortMask.setDescription('The mask to be applied to aclNewCfgDstPort for filtering.')
vmapNewCfgTCPFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 2, 1, 24), Bits().clone(namedValues=NamedValues(("reserved1", 0), ("reserved2", 1), ("tcpURG", 2), ("tcpACK", 3), ("tcpPSH", 4), ("tcpRST", 5), ("tcpSYN", 6), ("tcpFIN", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmapNewCfgTCPFlags.setStatus('current')
if mibBuilder.loadTexts: vmapNewCfgTCPFlags.setDescription('The TCP flags to be filtered. The TCP flags are presented in bitmap format, as follows: OCTET xxxxxxxx ||||..|| ||||..||_tcpFIN(7) ||||..|__tcpSYN(6) |||| ||||_____tcpACK(3) |||______tcpURG(2) ||_______reserved2(1) |________reserved1(0) where: - reserved1 - 0; - reserved2 - 0; - x - 0 or 1; ')
vmapNewCfgTCPFlagsMask = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 2, 1, 25), Bits().clone(namedValues=NamedValues(("reserved1", 0), ("reserved2", 1), ("tcpURG", 2), ("tcpACK", 3), ("tcpPSH", 4), ("tcpRST", 5), ("tcpSYN", 6), ("tcpFIN", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmapNewCfgTCPFlagsMask.setStatus('current')
if mibBuilder.loadTexts: vmapNewCfgTCPFlagsMask.setDescription('The TCP flags mask. The TCP flags are presented in bitmap format, as follows: OCTET xxxxxxxx ||||..|| ||||..||_tcpFIN(7) ||||..|__tcpSYN(6) |||| ||||_____tcpACK(3) |||______tcpURG(2) ||_______reserved2(1) |________reserved1(0) where: - reserved1 - 0; - reserved2 - 0; - x - 0 or 1; Default value is 0x3f.')
vmapNewCfgEgressPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 2, 1, 26), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmapNewCfgEgressPorts.setStatus('current')
if mibBuilder.loadTexts: vmapNewCfgEgressPorts.setDescription('The port list in the VMAP configured for egress filtering. The ports are presented in bitmap format, as follows: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || | || || |_ port 9 || || || ||___ port 8 || |____ port 7 || . . . ||_________ port 2 |__________ port 1 where x: 1 - the represented port is configured for filtering. 0 - the represented port is not configured for filtering.')
vmapNewCfgStatistics = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 2, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmapNewCfgStatistics.setStatus('current')
if mibBuilder.loadTexts: vmapNewCfgStatistics.setDescription('Whether statistics collection for this VMAP is enabled or not.')
vmapNewCfgAddEgressPort = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 2, 1, 28), PortNumber()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmapNewCfgAddEgressPort.setStatus('current')
if mibBuilder.loadTexts: vmapNewCfgAddEgressPort.setDescription('The port to be added to the specified VMAP for egress filtering. A value of zero is always returned when this object is read.')
vmapNewCfgRemoveEgressPort = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 2, 1, 29), PortNumber()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmapNewCfgRemoveEgressPort.setStatus('current')
if mibBuilder.loadTexts: vmapNewCfgRemoveEgressPort.setDescription('The port to be removed from the specified VMAP. A value of zero is always returned when this object is read.')
vmapNewCfgDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 2, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("delete", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmapNewCfgDelete.setStatus('current')
if mibBuilder.loadTexts: vmapNewCfgDelete.setDescription('This is an action object to delete an VMAP entry. A value of other(1) is always returned when this object is read.')
vmapNewCfgMeterAction = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 2, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("unconfigured", 0), ("outdrop", 1), ("outpass", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmapNewCfgMeterAction.setStatus('current')
if mibBuilder.loadTexts: vmapNewCfgMeterAction.setDescription('Meter Action for this VMAP.')
vmapNewCfgMeterEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 2, 1, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("enabled", 0), ("disabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmapNewCfgMeterEnable.setStatus('current')
if mibBuilder.loadTexts: vmapNewCfgMeterEnable.setDescription('Meter state for this VMAP.')
vmapNewCfgKbitsSec = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 2, 1, 33), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(64, 10000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmapNewCfgKbitsSec.setStatus('current')
if mibBuilder.loadTexts: vmapNewCfgKbitsSec.setDescription('The commited rate of meter associated with this VMAP entry.')
vmapNewCfgKbitsBurst = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 2, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(32, 64, 128, 256, 512, 1024, 2048, 4096))).clone(namedValues=NamedValues(("kbits32", 32), ("kbits64", 64), ("kbits128", 128), ("kbits256", 256), ("kbits512", 512), ("kbits1024", 1024), ("kbits2048", 2048), ("kbits4096", 4096)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmapNewCfgKbitsBurst.setStatus('current')
if mibBuilder.loadTexts: vmapNewCfgKbitsBurst.setDescription('The maximum burst size of the meter associated with this VMAP entry.')
vmapNewCfgUser = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 2, 1, 35), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmapNewCfgUser.setStatus('current')
if mibBuilder.loadTexts: vmapNewCfgUser.setDescription('Set user defined priority for this VMAP.')
vmapNewCfgInprofDscp = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 2, 1, 36), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 63))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmapNewCfgInprofDscp.setStatus('current')
if mibBuilder.loadTexts: vmapNewCfgInprofDscp.setDescription('Set in profile pkts DSCP value.')
vmapNewCfgTos = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 2, 1, 37), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmapNewCfgTos.setStatus('current')
if mibBuilder.loadTexts: vmapNewCfgTos.setDescription('To enable/disable setting pkts based on TOS bits.')
vmapNewCfgOutprofDscp = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 2, 1, 38), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 63))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmapNewCfgOutprofDscp.setStatus('current')
if mibBuilder.loadTexts: vmapNewCfgOutprofDscp.setDescription('Set out profile pkts DSCP value.')
vmapNewCfgUserEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 2, 1, 39), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("userdefined", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmapNewCfgUserEnable.setStatus('current')
if mibBuilder.loadTexts: vmapNewCfgUserEnable.setDescription('Set update method for this VMAP.')
vmapNewCfgInprofDscpEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 2, 1, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmapNewCfgInprofDscpEnable.setStatus('current')
if mibBuilder.loadTexts: vmapNewCfgInprofDscpEnable.setDescription('Whether in profile update DSCP for this VMAP is enabled or not. Only the value disable(0) can be set, causing the in profile update DSCP to be disabled for this VMAP. The value enable(1) is automatically set when setting a value for aclNewCfgInprofDscp object.')
vmapNewCfgOutprofDscpEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 2, 1, 41), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmapNewCfgOutprofDscpEnable.setStatus('current')
if mibBuilder.loadTexts: vmapNewCfgOutprofDscpEnable.setDescription('Whether out profile update DSCP for this VMAP is enabled or not. Only the value disable(0) can be set, causing the out profile update DSCP to be disabled for this VMAP. The value enable(1) is automatically set when setting a value for aclNewCfgOutprofDscp object.')
vmapNewCfgReset = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 2, 1, 42), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmapNewCfgReset.setStatus('current')
if mibBuilder.loadTexts: vmapNewCfgReset.setDescription('This is an action object to reset an VMAP entry. A value of other(1) is always returned when this object is read.')
vmapNewCfgEthernetReset = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 2, 1, 43), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmapNewCfgEthernetReset.setStatus('current')
if mibBuilder.loadTexts: vmapNewCfgEthernetReset.setDescription('This is an action object to reset an VMAP Ethernet entry. A value of other(1) is always returned when this object is read.')
vmapNewCfgIpv4Reset = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 2, 1, 44), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmapNewCfgIpv4Reset.setStatus('current')
if mibBuilder.loadTexts: vmapNewCfgIpv4Reset.setDescription('This is an action object to reset an VMAP IPV4 entry. A value of other(1) is always returned when this object is read.')
vmapNewCfgTcpudpReset = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 2, 1, 45), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmapNewCfgTcpudpReset.setStatus('current')
if mibBuilder.loadTexts: vmapNewCfgTcpudpReset.setDescription('This is an action object to reset an VMAP Tcpudp entry. A value of other(1) is always returned when this object is read.')
vmapNewCfgMeterReset = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 2, 1, 46), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmapNewCfgMeterReset.setStatus('current')
if mibBuilder.loadTexts: vmapNewCfgMeterReset.setDescription('This is an action object to reset an VMAP Meter entry. A value of other(1) is always returned when this object is read.')
vmapNewCfgRemarkReset = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 2, 1, 47), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmapNewCfgRemarkReset.setStatus('current')
if mibBuilder.loadTexts: vmapNewCfgRemarkReset.setDescription('This is an action object to reset an VMAP Remark entry. A value of other(1) is always returned when this object is read.')
vmapNewCfgRemarkInprofReset = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 2, 1, 48), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmapNewCfgRemarkInprofReset.setStatus('current')
if mibBuilder.loadTexts: vmapNewCfgRemarkInprofReset.setDescription('This is an action object to reset an VMAP Remark Inprof entry. A value of other(1) is always returned when this object is read.')
vmapNewCfgRemarkOutprofReset = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 2, 1, 49), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmapNewCfgRemarkOutprofReset.setStatus('current')
if mibBuilder.loadTexts: vmapNewCfgRemarkOutprofReset.setDescription('This is an action object to reset an VMAP Remark Outprof entry. A value of other(1) is always returned when this object is read.')
vmapNewCfgPktfmtReset = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 2, 1, 50), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmapNewCfgPktfmtReset.setStatus('current')
if mibBuilder.loadTexts: vmapNewCfgPktfmtReset.setDescription('This is an action object to reset an VMAP Pktfmt entry. A value of other(1) is always returned when this object is read.')
vmapNewCfgMirrorPort = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 2, 1, 51), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmapNewCfgMirrorPort.setStatus('current')
if mibBuilder.loadTexts: vmapNewCfgMirrorPort.setDescription('Set port in the VMAP for mirroring. n > 0 - the represented port is configured for mirroring. 0 - the represented port is not configured for mirroring.')
vmapNewCfgFilterActionChangeVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 1, 2, 1, 52), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4094))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmapNewCfgFilterActionChangeVlan.setStatus('current')
if mibBuilder.loadTexts: vmapNewCfgFilterActionChangeVlan.setDescription('The VLAN will be modified when the action for this VMAP entry is changevlan, , when this object is set to 0, the changevlan action is disabled.')
vmapVlanCurCfgNonServerPortsTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 2, 1, 1, 1), )
if mibBuilder.loadTexts: vmapVlanCurCfgNonServerPortsTable.setStatus('current')
if mibBuilder.loadTexts: vmapVlanCurCfgNonServerPortsTable.setDescription('The table of the current configuration of vmaps for the non-server ports of vlans.')
vmapVlanCurCfgNonServerPortsTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 2, 1, 1, 1, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "vmapVlanCurCfgNonServerPortsVlanIdx"))
if mibBuilder.loadTexts: vmapVlanCurCfgNonServerPortsTableEntry.setStatus('current')
if mibBuilder.loadTexts: vmapVlanCurCfgNonServerPortsTableEntry.setDescription('A row in the table of current configuration of vmaps for the non-server ports of vlans.')
vmapVlanCurCfgNonServerPortsVlanIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 2, 1, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmapVlanCurCfgNonServerPortsVlanIdx.setStatus('current')
if mibBuilder.loadTexts: vmapVlanCurCfgNonServerPortsVlanIdx.setDescription('The vlan id in the table of configured vmaps for the non-server ports of vlan')
vmapVlanCurCfgNonServerPortsVmapBitmap = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 2, 1, 1, 1, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmapVlanCurCfgNonServerPortsVmapBitmap.setStatus('current')
if mibBuilder.loadTexts: vmapVlanCurCfgNonServerPortsVmapBitmap.setDescription('The bitmap of vmaps configured for the non-server ports of the vlan given as arguments. The vmaps are presented in bitmap format in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ vmap 9 || || || ||___ vmap 8 || |____ vmap 7 || . . . ||_________ vmap 2 |__________ vmap 1 where x : 1 - The represented vmap is active in the specified context 0 - The represented vmap is NOT active in the specified context')
vmapVlanNewCfgNonServerPortsTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 2, 1, 1, 2), )
if mibBuilder.loadTexts: vmapVlanNewCfgNonServerPortsTable.setStatus('current')
if mibBuilder.loadTexts: vmapVlanNewCfgNonServerPortsTable.setDescription('The table of the new configuration of vmaps for non-server ports of vlans.')
vmapVlanNewCfgNonServerPortsTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 2, 1, 1, 2, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "vmapVlanNewCfgNonServerPortsVlanIdx"))
if mibBuilder.loadTexts: vmapVlanNewCfgNonServerPortsTableEntry.setStatus('current')
if mibBuilder.loadTexts: vmapVlanNewCfgNonServerPortsTableEntry.setDescription('A row in the table of new configuration of vmaps for the non-server ports of vlans.')
vmapVlanNewCfgNonServerPortsVlanIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 2, 1, 1, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmapVlanNewCfgNonServerPortsVlanIdx.setStatus('current')
if mibBuilder.loadTexts: vmapVlanNewCfgNonServerPortsVlanIdx.setDescription('The vlan id in the table of configured vmaps for the non-server ports of vlan')
vmapVlanNewCfgNonServerPortsVmapBitmap = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 2, 1, 1, 2, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmapVlanNewCfgNonServerPortsVmapBitmap.setStatus('current')
if mibBuilder.loadTexts: vmapVlanNewCfgNonServerPortsVmapBitmap.setDescription('The bitmap of vmaps configured for the non-server ports of the vlan given as arguments. The vmaps are presented in bitmap format in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ vmap 9 || || || ||___ vmap 8 || |____ vmap 7 || . . . ||_________ vmap 2 |__________ vmap 1 where x : 1 - The represented vmap is active in the specified context 0 - The represented vmap is NOT active in the specified context')
vmapVlanNewCfgNonServerPortsAddVmap = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 2, 1, 1, 2, 1, 3), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmapVlanNewCfgNonServerPortsAddVmap.setStatus('current')
if mibBuilder.loadTexts: vmapVlanNewCfgNonServerPortsAddVmap.setDescription('Add a new vmap to the non-server ports of the vlan')
vmapVlanNewCfgNonServerPortsRemVmap = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 2, 1, 1, 2, 1, 4), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmapVlanNewCfgNonServerPortsRemVmap.setStatus('current')
if mibBuilder.loadTexts: vmapVlanNewCfgNonServerPortsRemVmap.setDescription('Remove a vmap from the non-server ports of the vlan')
vmapVlanCurCfgServerPortsTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 2, 1, 2, 1), )
if mibBuilder.loadTexts: vmapVlanCurCfgServerPortsTable.setStatus('current')
if mibBuilder.loadTexts: vmapVlanCurCfgServerPortsTable.setDescription('The table of the current configuration of vmaps for server ports of vlans.')
vmapVlanCurCfgServerPortsTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 2, 1, 2, 1, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "vmapVlanCurCfgServerPortsVlanIdx"))
if mibBuilder.loadTexts: vmapVlanCurCfgServerPortsTableEntry.setStatus('current')
if mibBuilder.loadTexts: vmapVlanCurCfgServerPortsTableEntry.setDescription('A row in the table of current configuration of vmaps for the server ports of vlans.')
vmapVlanCurCfgServerPortsVlanIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 2, 1, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmapVlanCurCfgServerPortsVlanIdx.setStatus('current')
if mibBuilder.loadTexts: vmapVlanCurCfgServerPortsVlanIdx.setDescription('The vlan id in the table of configured vmaps for the server ports of vlan')
vmapVlanCurCfgServerPortsVmapBitmap = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 2, 1, 2, 1, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmapVlanCurCfgServerPortsVmapBitmap.setStatus('current')
if mibBuilder.loadTexts: vmapVlanCurCfgServerPortsVmapBitmap.setDescription('The bitmap of vmaps configured for the server ports of the vlan given as arguments. The vmaps are presented in bitmap format in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ vmap 9 || || || ||___ vmap 8 || |____ vmap 7 || . . . ||_________ vmap 2 |__________ vmap 1 where x : 1 - The represented vmap is active in the specified context 0 - The represented vmap is NOT active in the specified context')
vmapVlanNewCfgServerPortsTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 2, 1, 2, 2), )
if mibBuilder.loadTexts: vmapVlanNewCfgServerPortsTable.setStatus('current')
if mibBuilder.loadTexts: vmapVlanNewCfgServerPortsTable.setDescription('The table of the new configuration of vmaps for server ports of vlans.')
vmapVlanNewCfgServerPortsTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 2, 1, 2, 2, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "vmapVlanNewCfgServerPortsVlanIdx"))
if mibBuilder.loadTexts: vmapVlanNewCfgServerPortsTableEntry.setStatus('current')
if mibBuilder.loadTexts: vmapVlanNewCfgServerPortsTableEntry.setDescription('A row in the table of new configuration of vmaps for the server ports of vlans.')
vmapVlanNewCfgServerPortsVlanIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 2, 1, 2, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmapVlanNewCfgServerPortsVlanIdx.setStatus('current')
if mibBuilder.loadTexts: vmapVlanNewCfgServerPortsVlanIdx.setDescription('The vlan id in the table of configured vmaps for the server ports of vlan')
vmapVlanNewCfgServerPortsVmapBitmap = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 2, 1, 2, 2, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmapVlanNewCfgServerPortsVmapBitmap.setStatus('current')
if mibBuilder.loadTexts: vmapVlanNewCfgServerPortsVmapBitmap.setDescription('The bitmap of vmaps configured for the server ports of the vlan given as arguments. The vmaps are presented in bitmap format in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ vmap 9 || || || ||___ vmap 8 || |____ vmap 7 || . . . ||_________ vmap 2 |__________ vmap 1 where x : 1 - The represented vmap is active in the specified context 0 - The represented vmap is NOT active in the specified context')
vmapVlanNewCfgServerPortsAddVmap = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 2, 1, 2, 2, 1, 3), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmapVlanNewCfgServerPortsAddVmap.setStatus('current')
if mibBuilder.loadTexts: vmapVlanNewCfgServerPortsAddVmap.setDescription('Add a new vmap to the server ports of the vlan')
vmapVlanNewCfgServerPortsRemVmap = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 2, 1, 2, 2, 1, 4), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmapVlanNewCfgServerPortsRemVmap.setStatus('current')
if mibBuilder.loadTexts: vmapVlanNewCfgServerPortsRemVmap.setDescription('Remove a vmap from the server ports of the vlan')
vmapVlanCurCfgAllPortsTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 2, 1, 3, 1), )
if mibBuilder.loadTexts: vmapVlanCurCfgAllPortsTable.setStatus('current')
if mibBuilder.loadTexts: vmapVlanCurCfgAllPortsTable.setDescription('The table of the current configuration of vmaps for all ports of vlans.')
vmapVlanCurCfgAllPortsTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 2, 1, 3, 1, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "vmapVlanCurCfgAllPortsVlanIdx"))
if mibBuilder.loadTexts: vmapVlanCurCfgAllPortsTableEntry.setStatus('current')
if mibBuilder.loadTexts: vmapVlanCurCfgAllPortsTableEntry.setDescription('A row in the table of current configuration of vmaps for all ports of vlans.')
vmapVlanCurCfgAllPortsVlanIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 2, 1, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmapVlanCurCfgAllPortsVlanIdx.setStatus('current')
if mibBuilder.loadTexts: vmapVlanCurCfgAllPortsVlanIdx.setDescription('The vlan id in the table of configured vmaps for all ports of vlan')
vmapVlanCurCfgAllPortsVmapBitmap = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 2, 1, 3, 1, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmapVlanCurCfgAllPortsVmapBitmap.setStatus('current')
if mibBuilder.loadTexts: vmapVlanCurCfgAllPortsVmapBitmap.setDescription('The bitmap of vmaps configured for the internal ports of the vlan given as arguments. The vmaps are presented in bitmap format in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ vmap 9 || || || ||___ vmap 8 || |____ vmap 7 || . . . ||_________ vmap 2 |__________ vmap 1 where x : 1 - The represented vmap is active in the specified context 0 - The represented vmap is NOT active in the specified context')
vmapVlanNewCfgAllPortsTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 2, 1, 3, 2), )
if mibBuilder.loadTexts: vmapVlanNewCfgAllPortsTable.setStatus('current')
if mibBuilder.loadTexts: vmapVlanNewCfgAllPortsTable.setDescription('The table of the new configuration of vmaps for all ports of vlans.')
vmapVlanNewCfgAllPortsTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 2, 1, 3, 2, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "vmapVlanNewCfgAllPortsVlanIdx"))
if mibBuilder.loadTexts: vmapVlanNewCfgAllPortsTableEntry.setStatus('current')
if mibBuilder.loadTexts: vmapVlanNewCfgAllPortsTableEntry.setDescription('A row in the table of new configuration of vmaps for all ports of vlans.')
vmapVlanNewCfgAllPortsVlanIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 2, 1, 3, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmapVlanNewCfgAllPortsVlanIdx.setStatus('current')
if mibBuilder.loadTexts: vmapVlanNewCfgAllPortsVlanIdx.setDescription('The vlan id in the table of configured vmaps for all ports of vlan')
vmapVlanNewCfgAllPortsVmapBitmap = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 2, 1, 3, 2, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmapVlanNewCfgAllPortsVmapBitmap.setStatus('current')
if mibBuilder.loadTexts: vmapVlanNewCfgAllPortsVmapBitmap.setDescription('The bitmap of vmaps configured for the internal ports of the vlan given as arguments. The vmaps are presented in bitmap format in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ vmap 9 || || || ||___ vmap 8 || |____ vmap 7 || . . . ||_________ vmap 2 |__________ vmap 1 where x : 1 - The represented vmap is active in the specified context 0 - The represented vmap is NOT active in the specified context')
vmapVlanNewCfgAllPortsAddVmap = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 2, 1, 3, 2, 1, 3), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmapVlanNewCfgAllPortsAddVmap.setStatus('current')
if mibBuilder.loadTexts: vmapVlanNewCfgAllPortsAddVmap.setDescription('Add a new vmap to all ports of the vlan')
vmapVlanNewCfgAllPortsRemVmap = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 2, 1, 3, 2, 1, 4), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmapVlanNewCfgAllPortsRemVmap.setStatus('current')
if mibBuilder.loadTexts: vmapVlanNewCfgAllPortsRemVmap.setDescription('Remove a vmap from all vlan ports')
vmapGroupCurCfgNonServerPortsTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 2, 2, 1, 1), )
if mibBuilder.loadTexts: vmapGroupCurCfgNonServerPortsTable.setStatus('current')
if mibBuilder.loadTexts: vmapGroupCurCfgNonServerPortsTable.setDescription('The table of the current configuration of vmaps for non-server ports of vm groups.')
vmapGroupCurCfgNonServerPortsTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 2, 2, 1, 1, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "vmapGroupCurCfgNonServerPortsGroupIdx"))
if mibBuilder.loadTexts: vmapGroupCurCfgNonServerPortsTableEntry.setStatus('current')
if mibBuilder.loadTexts: vmapGroupCurCfgNonServerPortsTableEntry.setDescription('A row in the table of current configuration of vmaps for the non-server ports of vm groups.')
vmapGroupCurCfgNonServerPortsGroupIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 2, 2, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmapGroupCurCfgNonServerPortsGroupIdx.setStatus('current')
if mibBuilder.loadTexts: vmapGroupCurCfgNonServerPortsGroupIdx.setDescription('The vm group id in the table of configured vmaps for the non-server ports of vm group')
vmapGroupCurCfgNonServerPortsVmapBitmap = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 2, 2, 1, 1, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmapGroupCurCfgNonServerPortsVmapBitmap.setStatus('current')
if mibBuilder.loadTexts: vmapGroupCurCfgNonServerPortsVmapBitmap.setDescription('The bitmap of vmaps configured for the non-server ports of the vm group given as arguments. The vmaps are presented in bitmap format in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ vmap 9 || || || ||___ vmap 8 || |____ vmap 7 || . . . ||_________ vmap 2 |__________ vmap 1 where x : 1 - The represented vmap is active in the specified context 0 - The represented vmap is NOT active in the specified context')
vmapGroupNewCfgNonServerPortsTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 2, 2, 1, 2), )
if mibBuilder.loadTexts: vmapGroupNewCfgNonServerPortsTable.setStatus('current')
if mibBuilder.loadTexts: vmapGroupNewCfgNonServerPortsTable.setDescription('The table of the new configuration of vmaps for non-server ports of vm groups.')
vmapGroupNewCfgNonServerPortsTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 2, 2, 1, 2, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "vmapGroupNewCfgNonServerPortsGroupIdx"))
if mibBuilder.loadTexts: vmapGroupNewCfgNonServerPortsTableEntry.setStatus('current')
if mibBuilder.loadTexts: vmapGroupNewCfgNonServerPortsTableEntry.setDescription('A row in the table of new configuration of vmaps for the non-server ports of vm groups.')
vmapGroupNewCfgNonServerPortsGroupIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 2, 2, 1, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmapGroupNewCfgNonServerPortsGroupIdx.setStatus('current')
if mibBuilder.loadTexts: vmapGroupNewCfgNonServerPortsGroupIdx.setDescription('The vm group id in the table of configured vmaps for the non-server ports of vm group')
vmapGroupNewCfgNonServerPortsVmapBitmap = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 2, 2, 1, 2, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmapGroupNewCfgNonServerPortsVmapBitmap.setStatus('current')
if mibBuilder.loadTexts: vmapGroupNewCfgNonServerPortsVmapBitmap.setDescription('The bitmap of vmaps configured for the non-server ports of the vm group given as arguments. The vmaps are presented in bitmap format in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ vmap 9 || || || ||___ vmap 8 || |____ vmap 7 || . . . ||_________ vmap 2 |__________ vmap 1 where x : 1 - The represented vmap is active in the specified context 0 - The represented vmap is NOT active in the specified context')
vmapGroupNewCfgNonServerPortsAddVmap = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 2, 2, 1, 2, 1, 3), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmapGroupNewCfgNonServerPortsAddVmap.setStatus('current')
if mibBuilder.loadTexts: vmapGroupNewCfgNonServerPortsAddVmap.setDescription('Add a new vmap to the non-server ports of the vm group')
vmapGroupNewCfgNonServerPortsRemVmap = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 2, 2, 1, 2, 1, 4), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmapGroupNewCfgNonServerPortsRemVmap.setStatus('current')
if mibBuilder.loadTexts: vmapGroupNewCfgNonServerPortsRemVmap.setDescription('Remove a vmap from the non-server ports of the vm group')
vmapGroupCurCfgServerPortsTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 2, 2, 2, 1), )
if mibBuilder.loadTexts: vmapGroupCurCfgServerPortsTable.setStatus('current')
if mibBuilder.loadTexts: vmapGroupCurCfgServerPortsTable.setDescription('The table of the current configuration of vmaps for server ports of vm groups.')
vmapGroupCurCfgServerPortsTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 2, 2, 2, 1, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "vmapGroupCurCfgServerPortsGroupIdx"))
if mibBuilder.loadTexts: vmapGroupCurCfgServerPortsTableEntry.setStatus('current')
if mibBuilder.loadTexts: vmapGroupCurCfgServerPortsTableEntry.setDescription('A row in the table of current configuration of vmaps for the server ports of vm groups.')
vmapGroupCurCfgServerPortsGroupIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 2, 2, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmapGroupCurCfgServerPortsGroupIdx.setStatus('current')
if mibBuilder.loadTexts: vmapGroupCurCfgServerPortsGroupIdx.setDescription('The vm group id in the table of configured vmaps for the server ports of vm group')
vmapGroupCurCfgServerPortsVmapBitmap = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 2, 2, 2, 1, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmapGroupCurCfgServerPortsVmapBitmap.setStatus('current')
if mibBuilder.loadTexts: vmapGroupCurCfgServerPortsVmapBitmap.setDescription('The bitmap of vmaps configured for the server ports of the vm group given as arguments. The vmaps are presented in bitmap format in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ vmap 9 || || || ||___ vmap 8 || |____ vmap 7 || . . . ||_________ vmap 2 |__________ vmap 1 where x : 1 - The represented vmap is active in the specified context 0 - The represented vmap is NOT active in the specified context')
vmapGroupNewCfgServerPortsTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 2, 2, 2, 2), )
if mibBuilder.loadTexts: vmapGroupNewCfgServerPortsTable.setStatus('current')
if mibBuilder.loadTexts: vmapGroupNewCfgServerPortsTable.setDescription('The table of the new configuration of vmaps for server ports of vm groups.')
vmapGroupNewCfgServerPortsTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 2, 2, 2, 2, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "vmapGroupNewCfgServerPortsGroupIdx"))
if mibBuilder.loadTexts: vmapGroupNewCfgServerPortsTableEntry.setStatus('current')
if mibBuilder.loadTexts: vmapGroupNewCfgServerPortsTableEntry.setDescription('A row in the table of new configuration of vmaps for the server ports of vm groups.')
vmapGroupNewCfgServerPortsGroupIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 2, 2, 2, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmapGroupNewCfgServerPortsGroupIdx.setStatus('current')
if mibBuilder.loadTexts: vmapGroupNewCfgServerPortsGroupIdx.setDescription('The vm group id in the table of configured vmaps for the server ports of vm group')
vmapGroupNewCfgServerPortsVmapBitmap = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 2, 2, 2, 2, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmapGroupNewCfgServerPortsVmapBitmap.setStatus('current')
if mibBuilder.loadTexts: vmapGroupNewCfgServerPortsVmapBitmap.setDescription('The bitmap of vmaps configured for the server ports of the vm group given as arguments. The vmaps are presented in bitmap format in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ vmap 9 || || || ||___ vmap 8 || |____ vmap 7 || . . . ||_________ vmap 2 |__________ vmap 1 where x : 1 - The represented vmap is active in the specified context 0 - The represented vmap is NOT active in the specified context')
vmapGroupNewCfgServerPortsAddVmap = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 2, 2, 2, 2, 1, 3), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmapGroupNewCfgServerPortsAddVmap.setStatus('current')
if mibBuilder.loadTexts: vmapGroupNewCfgServerPortsAddVmap.setDescription('Add a new vmap to the server ports of the vm group')
vmapGroupNewCfgServerPortsRemVmap = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 2, 2, 2, 2, 1, 4), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmapGroupNewCfgServerPortsRemVmap.setStatus('current')
if mibBuilder.loadTexts: vmapGroupNewCfgServerPortsRemVmap.setDescription('Remove a vmap from the server ports of the vm group')
vmapGroupCurCfgAllPortsTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 2, 2, 3, 1), )
if mibBuilder.loadTexts: vmapGroupCurCfgAllPortsTable.setStatus('current')
if mibBuilder.loadTexts: vmapGroupCurCfgAllPortsTable.setDescription('The table of the current configuration of vmaps for all ports of vm groups.')
vmapGroupCurCfgAllPortsTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 2, 2, 3, 1, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "vmapGroupCurCfgAllPortsGroupIdx"))
if mibBuilder.loadTexts: vmapGroupCurCfgAllPortsTableEntry.setStatus('current')
if mibBuilder.loadTexts: vmapGroupCurCfgAllPortsTableEntry.setDescription('A row in the table of current configuration of vmaps for all ports of vm groups.')
vmapGroupCurCfgAllPortsGroupIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 2, 2, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmapGroupCurCfgAllPortsGroupIdx.setStatus('current')
if mibBuilder.loadTexts: vmapGroupCurCfgAllPortsGroupIdx.setDescription('The vm group id in the table of configured vmaps for all ports of vm group')
vmapGroupCurCfgAllPortsVmapBitmap = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 2, 2, 3, 1, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmapGroupCurCfgAllPortsVmapBitmap.setStatus('current')
if mibBuilder.loadTexts: vmapGroupCurCfgAllPortsVmapBitmap.setDescription('The bitmap of vmaps configured for the internal ports of the vm group given as arguments. The vmaps are presented in bitmap format in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ vmap 9 || || || ||___ vmap 8 || |____ vmap 7 || . . . ||_________ vmap 2 |__________ vmap 1 where x : 1 - The represented vmap is active in the specified context 0 - The represented vmap is NOT active in the specified context')
vmapGroupNewCfgAllPortsTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 2, 2, 3, 2), )
if mibBuilder.loadTexts: vmapGroupNewCfgAllPortsTable.setStatus('current')
if mibBuilder.loadTexts: vmapGroupNewCfgAllPortsTable.setDescription('The table of the new configuration of vmaps for all ports of vm groups.')
vmapGroupNewCfgAllPortsTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 2, 2, 3, 2, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "vmapGroupNewCfgAllPortsGroupIdx"))
if mibBuilder.loadTexts: vmapGroupNewCfgAllPortsTableEntry.setStatus('current')
if mibBuilder.loadTexts: vmapGroupNewCfgAllPortsTableEntry.setDescription('A row in the table of new configuration of vmaps for all ports of vm groups.')
vmapGroupNewCfgAllPortsGroupIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 2, 2, 3, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmapGroupNewCfgAllPortsGroupIdx.setStatus('current')
if mibBuilder.loadTexts: vmapGroupNewCfgAllPortsGroupIdx.setDescription('The vm group id in the table of configured vmaps for all ports of vm group')
vmapGroupNewCfgAllPortsVmapBitmap = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 2, 2, 3, 2, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmapGroupNewCfgAllPortsVmapBitmap.setStatus('current')
if mibBuilder.loadTexts: vmapGroupNewCfgAllPortsVmapBitmap.setDescription('The bitmap of vmaps configured for the internal ports of the vm group given as arguments. The vmaps are presented in bitmap format in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ vmap 9 || || || ||___ vmap 8 || |____ vmap 7 || . . . ||_________ vmap 2 |__________ vmap 1 where x : 1 - The represented vmap is active in the specified context 0 - The represented vmap is NOT active in the specified context')
vmapGroupNewCfgAllPortsAddVmap = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 2, 2, 3, 2, 1, 3), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmapGroupNewCfgAllPortsAddVmap.setStatus('current')
if mibBuilder.loadTexts: vmapGroupNewCfgAllPortsAddVmap.setDescription('Add a new vmap to all ports of the vm group')
vmapGroupNewCfgAllPortsRemVmap = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 9, 3, 2, 2, 3, 2, 1, 4), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmapGroupNewCfgAllPortsRemVmap.setStatus('current')
if mibBuilder.loadTexts: vmapGroupNewCfgAllPortsRemVmap.setDescription('Remove a vmap from all vm group ports')
cee = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 13))
ceeConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 13, 1))
ceeCurCfgState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceeCurCfgState.setStatus('current')
if mibBuilder.loadTexts: ceeCurCfgState.setDescription('CEE is currently on or off.')
ceeNewCfgState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 13, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ceeNewCfgState.setStatus('current')
if mibBuilder.loadTexts: ceeNewCfgState.setDescription('Turn CEE on or off.')
fcoe = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 14))
fcoeConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 14, 1))
fcoeStats = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 14, 2))
fcoeInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 14, 3))
fcoeOper = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 14, 4))
fipsCfg = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 14, 1, 3))
fipsInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 14, 3, 1))
fipsOper = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 14, 4, 1))
fipsInfoFcf = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 14, 3, 1, 2))
fipsInfoFcoe = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 14, 3, 1, 3))
fipsInfoVlans = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 14, 3, 1, 4))
fipsCurCfgState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 14, 1, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fipsCurCfgState.setStatus('current')
if mibBuilder.loadTexts: fipsCurCfgState.setDescription('FIP snooping is currently on or off.')
fipsNewCfgState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 14, 1, 3, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: fipsNewCfgState.setStatus('current')
if mibBuilder.loadTexts: fipsNewCfgState.setDescription('Turn FIP snooping on or off.')
fipsCurAclTimeout = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 14, 1, 3, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fipsCurAclTimeout.setStatus('current')
if mibBuilder.loadTexts: fipsCurAclTimeout.setDescription('The removal of acls when FCF and FCOE connections timed out is enabled or disabled.')
fipsNewAclTimeout = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 14, 1, 3, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: fipsNewAclTimeout.setStatus('current')
if mibBuilder.loadTexts: fipsNewAclTimeout.setDescription('Enable or disable the removal of acls when FCF and FCOE connections timed out.')
fipsCurAutoVlan = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 14, 1, 3, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fipsCurAutoVlan.setStatus('current')
if mibBuilder.loadTexts: fipsCurAutoVlan.setDescription('The automatic creation of FCOE vlans is enabled or disabled.')
fipsNewAutoVlan = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 14, 1, 3, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: fipsNewAutoVlan.setStatus('current')
if mibBuilder.loadTexts: fipsNewAutoVlan.setDescription('Enable or disable the automatic creation of FCOE vlans.')
fipsPortCurCfgTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 14, 1, 3, 7), )
if mibBuilder.loadTexts: fipsPortCurCfgTable.setStatus('current')
if mibBuilder.loadTexts: fipsPortCurCfgTable.setDescription('The table of FIP Snooping port current config.')
fipsPortCurCfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 14, 1, 3, 7, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "fipsPortCurCfgIndex"))
if mibBuilder.loadTexts: fipsPortCurCfgEntry.setStatus('current')
if mibBuilder.loadTexts: fipsPortCurCfgEntry.setDescription('FIP Config for a particular port.')
fipsPortCurCfgIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 14, 1, 3, 7, 1, 1), PortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fipsPortCurCfgIndex.setStatus('current')
if mibBuilder.loadTexts: fipsPortCurCfgIndex.setDescription('The port number')
fipsPortCurCfgFcfMode = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 14, 1, 3, 7, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("auto", 0), ("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fipsPortCurCfgFcfMode.setStatus('current')
if mibBuilder.loadTexts: fipsPortCurCfgFcfMode.setDescription('Weither the port is set to have FCF auto detection, on, or off.')
fipsPortCurCfgFipsEna = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 14, 1, 3, 7, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fipsPortCurCfgFipsEna.setStatus('current')
if mibBuilder.loadTexts: fipsPortCurCfgFipsEna.setDescription('FIP snooping enabled or disabled on this port.')
fipsPortNewCfgTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 14, 1, 3, 8), )
if mibBuilder.loadTexts: fipsPortNewCfgTable.setStatus('current')
if mibBuilder.loadTexts: fipsPortNewCfgTable.setDescription('The table of FIP Snooping port new config.')
fipsPortNewCfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 14, 1, 3, 8, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "fipsPortNewCfgIndex"))
if mibBuilder.loadTexts: fipsPortNewCfgEntry.setStatus('current')
if mibBuilder.loadTexts: fipsPortNewCfgEntry.setDescription('FIP Config for a particular port.')
fipsPortNewCfgIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 14, 1, 3, 8, 1, 1), PortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fipsPortNewCfgIndex.setStatus('current')
if mibBuilder.loadTexts: fipsPortNewCfgIndex.setDescription('The port number')
fipsPortNewCfgFcfMode = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 14, 1, 3, 8, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("auto", 0), ("on", 1), ("off", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: fipsPortNewCfgFcfMode.setStatus('current')
if mibBuilder.loadTexts: fipsPortNewCfgFcfMode.setDescription('Set this port to have FCF on, off, or auto detection.')
fipsPortNewCfgFipsEna = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 14, 1, 3, 8, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: fipsPortNewCfgFipsEna.setStatus('current')
if mibBuilder.loadTexts: fipsPortNewCfgFipsEna.setDescription('Enable or disable FIP snooping on this port.')
fipsInfoPortTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 14, 3, 1, 1), )
if mibBuilder.loadTexts: fipsInfoPortTable.setStatus('current')
if mibBuilder.loadTexts: fipsInfoPortTable.setDescription('The table of fips port run-time information.')
fipsInfoPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 14, 3, 1, 1, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "fipsInfoPortIndex"), (0, "IBM-GbTOR-10G-L2L3-MIB", "fipsInfoAclSequencer"))
if mibBuilder.loadTexts: fipsInfoPortEntry.setStatus('current')
if mibBuilder.loadTexts: fipsInfoPortEntry.setDescription('A port in the fips information table.')
fipsInfoPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 14, 3, 1, 1, 1, 1), PortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fipsInfoPortIndex.setStatus('current')
if mibBuilder.loadTexts: fipsInfoPortIndex.setDescription('The port index for fips')
fipsInfoAclSequencer = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 14, 3, 1, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fipsInfoAclSequencer.setStatus('current')
if mibBuilder.loadTexts: fipsInfoAclSequencer.setDescription('The fip sequence number for an acl in this port')
fipsInfoAcl = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 14, 3, 1, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fipsInfoAcl.setStatus('current')
if mibBuilder.loadTexts: fipsInfoAcl.setDescription('An FIPS ACL entry')
fipsInfoFcfCount = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 14, 3, 1, 2, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fipsInfoFcfCount.setStatus('current')
if mibBuilder.loadTexts: fipsInfoFcfCount.setDescription('Total number of FCFs detected')
fipsInfoFcfTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 14, 3, 1, 2, 2), )
if mibBuilder.loadTexts: fipsInfoFcfTable.setStatus('current')
if mibBuilder.loadTexts: fipsInfoFcfTable.setDescription('The table of fips FCF detected.')
fipsInfoFcfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 14, 3, 1, 2, 2, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "fipsInfoFcfIndex"))
if mibBuilder.loadTexts: fipsInfoFcfEntry.setStatus('current')
if mibBuilder.loadTexts: fipsInfoFcfEntry.setDescription('A FCF in the fips information table.')
fipsInfoFcfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 14, 3, 1, 2, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fipsInfoFcfIndex.setStatus('current')
if mibBuilder.loadTexts: fipsInfoFcfIndex.setDescription('FCF index')
fipsInfoFcfMac = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 14, 3, 1, 2, 2, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fipsInfoFcfMac.setStatus('current')
if mibBuilder.loadTexts: fipsInfoFcfMac.setDescription('FCF MAC')
fipsInfoFcfPort = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 14, 3, 1, 2, 2, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fipsInfoFcfPort.setStatus('current')
if mibBuilder.loadTexts: fipsInfoFcfPort.setDescription('FCF Port')
fipsInfoFcfVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 14, 3, 1, 2, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fipsInfoFcfVlan.setStatus('current')
if mibBuilder.loadTexts: fipsInfoFcfVlan.setDescription('FCF Vlan')
fipsInfoVlansTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 14, 3, 1, 4, 1), )
if mibBuilder.loadTexts: fipsInfoVlansTable.setStatus('current')
if mibBuilder.loadTexts: fipsInfoVlansTable.setDescription('The table of FCOE VLANs detected.')
fipsInfoVlansEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 14, 3, 1, 4, 1, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "fipsInfoVlansId"), (0, "IBM-GbTOR-10G-L2L3-MIB", "fipsInfoVlansFeatureIndex"))
if mibBuilder.loadTexts: fipsInfoVlansEntry.setStatus('current')
if mibBuilder.loadTexts: fipsInfoVlansEntry.setDescription('A FCOE VLAN in the fipsInfoVlans information table.')
fipsInfoVlansId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 14, 3, 1, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fipsInfoVlansId.setStatus('current')
if mibBuilder.loadTexts: fipsInfoVlansId.setDescription('FCoE Vlan index')
fipsInfoVlansFeatureIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 14, 3, 1, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fipsInfoVlansFeatureIndex.setStatus('current')
if mibBuilder.loadTexts: fipsInfoVlansFeatureIndex.setDescription('FCoE Vlan feature index. The feature index will accept values from 1 to maximum SPAR ID(8) for the VLANs created by SPAR and 0 for the other types of VLANs.')
fipsInfoVlansCreator = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 14, 3, 1, 4, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fipsInfoVlansCreator.setStatus('current')
if mibBuilder.loadTexts: fipsInfoVlansCreator.setDescription('The FCoE VLAN Creator.')
fipsInfoVlansPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 14, 3, 1, 4, 1, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fipsInfoVlansPorts.setStatus('current')
if mibBuilder.loadTexts: fipsInfoVlansPorts.setDescription('The port list information in the VLAN. The ports are presented in bitmap format. in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ port 8 || || || ||___ port 7 || |____ port 6 || . . . ||_________ port 1 |__________ reserved where x : 1 - The represented port belongs to the VLAN 0 - The represented port does not belong to the VLAN')
fipsInfoFcoeCount = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 14, 3, 1, 3, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fipsInfoFcoeCount.setStatus('current')
if mibBuilder.loadTexts: fipsInfoFcoeCount.setDescription('Total number of FCOE connections')
fipsInfoFcoeTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 14, 3, 1, 3, 2), )
if mibBuilder.loadTexts: fipsInfoFcoeTable.setStatus('current')
if mibBuilder.loadTexts: fipsInfoFcoeTable.setDescription('The table of fips FCOE connections.')
fipsInfoFcoeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 14, 3, 1, 3, 2, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "fipsInfoFcoeIndex"))
if mibBuilder.loadTexts: fipsInfoFcoeEntry.setStatus('current')
if mibBuilder.loadTexts: fipsInfoFcoeEntry.setDescription('A FCOE connection in the fips information table.')
fipsInfoFcoeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 14, 3, 1, 3, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fipsInfoFcoeIndex.setStatus('current')
if mibBuilder.loadTexts: fipsInfoFcoeIndex.setDescription('FCOE connection index')
fipsInfoFcoeVNPortMac = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 14, 3, 1, 3, 2, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fipsInfoFcoeVNPortMac.setStatus('current')
if mibBuilder.loadTexts: fipsInfoFcoeVNPortMac.setDescription('FCOE connection VNPort MAC')
fipsInfoFcoeFcfMac = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 14, 3, 1, 3, 2, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fipsInfoFcoeFcfMac.setStatus('current')
if mibBuilder.loadTexts: fipsInfoFcoeFcfMac.setDescription('FCOE connection FCF MAC')
fipsInfoFcoePort = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 14, 3, 1, 3, 2, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fipsInfoFcoePort.setStatus('current')
if mibBuilder.loadTexts: fipsInfoFcoePort.setDescription('FCOE connection Port')
fipsInfoFcoeVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 14, 3, 1, 3, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fipsInfoFcoeVlan.setStatus('current')
if mibBuilder.loadTexts: fipsInfoFcoeVlan.setDescription('FCOE connection Vlan')
fipsOperFcfDelete = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 14, 4, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fipsOperFcfDelete.setStatus('current')
if mibBuilder.loadTexts: fipsOperFcfDelete.setDescription('Delete an FCF. Take an fcf mac address as the only parameter to delete this fcf from all vlans. Optionally take a vlan number as 2nd parameter to delete fcf from just this vlan. The 2 parameters are seperated by comma with no space allowed.')
fcoeStatsTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 14, 2, 1), )
if mibBuilder.loadTexts: fcoeStatsTable.setStatus('current')
if mibBuilder.loadTexts: fcoeStatsTable.setDescription('The table of fcoe statistics per switch unit.')
fcoeStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 14, 2, 1, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "fcoeStatsIndex"))
if mibBuilder.loadTexts: fcoeStatsEntry.setStatus('current')
if mibBuilder.loadTexts: fcoeStatsEntry.setDescription('A switch unit.')
fcoeStatsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 14, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcoeStatsIndex.setStatus('current')
if mibBuilder.loadTexts: fcoeStatsIndex.setDescription('The switch index for fips statistics')
fcoeStatsFcfAdded = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 14, 2, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcoeStatsFcfAdded.setStatus('current')
if mibBuilder.loadTexts: fcoeStatsFcfAdded.setDescription('The number of FCF added to the FCOE database.')
fcoeStatsFcfRemoved = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 14, 2, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcoeStatsFcfRemoved.setStatus('current')
if mibBuilder.loadTexts: fcoeStatsFcfRemoved.setDescription('The number of FCF removed to the FCOE database.')
fcoeStatsFcoeAdded = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 14, 2, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcoeStatsFcoeAdded.setStatus('current')
if mibBuilder.loadTexts: fcoeStatsFcoeAdded.setDescription('The number of FCOE connection added to the FCOE database.')
fcoeStatsFcoeRemoved = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 14, 2, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcoeStatsFcoeRemoved.setStatus('current')
if mibBuilder.loadTexts: fcoeStatsFcoeRemoved.setDescription('The number of FCOE connection removed to the FCOE database.')
fcoeStatsResetAllCounters = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 14, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("reset", 1), ("others", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcoeStatsResetAllCounters.setStatus('current')
if mibBuilder.loadTexts: fcoeStatsResetAllCounters.setDescription('Reset all FCOE statistics counters.')
virt = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15))
virtGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 1))
vmGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 2))
vmPolicy = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 3))
vmbw = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 3, 1))
vmProfiles = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 4))
virtVMware = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 5))
vmCheck = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 7))
virtCurCfgState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtCurCfgState.setStatus('current')
if mibBuilder.loadTexts: virtCurCfgState.setDescription('VM groups global state.')
virtNewCfgState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: virtNewCfgState.setStatus('current')
if mibBuilder.loadTexts: virtNewCfgState.setDescription('Enable/Disable Virtual Machine Groups')
virtCurCfgHbPort = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtCurCfgHbPort.setStatus('current')
if mibBuilder.loadTexts: virtCurCfgHbPort.setDescription('Current esx/esxi server to vcenter heartbeat UDP port')
virtNewCfgHbPort = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: virtNewCfgHbPort.setStatus('current')
if mibBuilder.loadTexts: virtNewCfgHbPort.setDescription('Set new esx/esxi server to vcenter heartbeat UDP port')
virtCurCfgVirtCenterIp = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 1, 5), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtCurCfgVirtCenterIp.setStatus('current')
if mibBuilder.loadTexts: virtCurCfgVirtCenterIp.setDescription('The IP address of the Virtual Center.')
virtNewCfgVirtCenterIp = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 1, 6), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: virtNewCfgVirtCenterIp.setStatus('current')
if mibBuilder.loadTexts: virtNewCfgVirtCenterIp.setDescription('The IP address of the Virtual Center.')
virtCurCfgVirtCenterUser = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtCurCfgVirtCenterUser.setStatus('current')
if mibBuilder.loadTexts: virtCurCfgVirtCenterUser.setDescription('Virtual Center username.')
virtNewCfgVirtCenterUser = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: virtNewCfgVirtCenterUser.setStatus('current')
if mibBuilder.loadTexts: virtNewCfgVirtCenterUser.setDescription('Virtual Center username.')
virtCurCfgVirtCenterSSLAuth = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtCurCfgVirtCenterSSLAuth.setStatus('current')
if mibBuilder.loadTexts: virtCurCfgVirtCenterSSLAuth.setDescription('Authenticate SSL Certificate.')
virtNewCfgVirtCenterSSLAuth = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: virtNewCfgVirtCenterSSLAuth.setStatus('current')
if mibBuilder.loadTexts: virtNewCfgVirtCenterSSLAuth.setDescription('Authenticate SSL Certificate.')
virtNewCfgVirtCenterPasswd = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 129))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: virtNewCfgVirtCenterPasswd.setStatus('current')
if mibBuilder.loadTexts: virtNewCfgVirtCenterPasswd.setDescription('Virtual Center password.')
virtNewCfgVirtCenterDelete = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("none", 1), ("delete", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: virtNewCfgVirtCenterDelete.setStatus('current')
if mibBuilder.loadTexts: virtNewCfgVirtCenterDelete.setDescription('Delete Virtual Center specifications')
vmCurCfgGroupTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 2, 1), )
if mibBuilder.loadTexts: vmCurCfgGroupTable.setStatus('current')
if mibBuilder.loadTexts: vmCurCfgGroupTable.setDescription('The table of VM groups in the current config')
vmCurCfgGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 2, 1, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "vmCurCfgGroupIndex"))
if mibBuilder.loadTexts: vmCurCfgGroupEntry.setStatus('current')
if mibBuilder.loadTexts: vmCurCfgGroupEntry.setDescription('Information about VM on a group in current config.')
vmNewCfgGroupTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 2, 2), )
if mibBuilder.loadTexts: vmNewCfgGroupTable.setStatus('current')
if mibBuilder.loadTexts: vmNewCfgGroupTable.setDescription('The table of VM groups in the new config')
vmNewCfgGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 2, 2, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "vmNewCfgGroupIndex"))
if mibBuilder.loadTexts: vmNewCfgGroupEntry.setStatus('current')
if mibBuilder.loadTexts: vmNewCfgGroupEntry.setDescription('Information about VM on a group in new config.')
vmCurCfgGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmCurCfgGroupIndex.setStatus('current')
if mibBuilder.loadTexts: vmCurCfgGroupIndex.setDescription('The index of the vm group table.')
vmCurCfgGroupVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 2, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmCurCfgGroupVlan.setStatus('current')
if mibBuilder.loadTexts: vmCurCfgGroupVlan.setDescription('Current Vlan used by the group.')
vmCurCfgGroupPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 2, 1, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmCurCfgGroupPorts.setStatus('current')
if mibBuilder.loadTexts: vmCurCfgGroupPorts.setDescription('The port list in the VM Group. The ports are presented in bitmap format. in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ port 8 || || || ||___ port 7 || |____ port 6 || . . . ||_________ port 1 |__________ reserved where x : 1 - The represented port belongs to the VM Group 0 - The represented port does not belong to the VM Group')
vmCurCfgGroupTagState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 0))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 0)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmCurCfgGroupTagState.setStatus('current')
if mibBuilder.loadTexts: vmCurCfgGroupTagState.setDescription('Enable VLAN tagging on all VM group ports.')
vmCurCfgGroupStg = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 2, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmCurCfgGroupStg.setStatus('current')
if mibBuilder.loadTexts: vmCurCfgGroupStg.setDescription('Current stg of the group vlan.')
vmCurCfgGroupProfileName = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 2, 1, 1, 17), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmCurCfgGroupProfileName.setStatus('current')
if mibBuilder.loadTexts: vmCurCfgGroupProfileName.setDescription('Current profile name used by the group.')
vmCurCfgGroupValidateMode = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 2, 1, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmCurCfgGroupValidateMode.setStatus('current')
if mibBuilder.loadTexts: vmCurCfgGroupValidateMode.setDescription('Current validation mode used by the group.')
vmNewCfgGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 2, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmNewCfgGroupIndex.setStatus('current')
if mibBuilder.loadTexts: vmNewCfgGroupIndex.setDescription('The index of the vm group table.')
vmNewCfgGroupVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 2, 2, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmNewCfgGroupVlan.setStatus('current')
if mibBuilder.loadTexts: vmNewCfgGroupVlan.setDescription('Set Vlan to be used by the group.')
vmNewCfgGroupAddVm = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 2, 2, 1, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmNewCfgGroupAddVm.setStatus('current')
if mibBuilder.loadTexts: vmNewCfgGroupAddVm.setDescription('Add a virtual machine to the group by UUID / Name / IP / MAC Address Note: MAC address format xx:xx:xx:xx:xx:xx')
vmNewCfgGroupRemVm = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 2, 2, 1, 5), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmNewCfgGroupRemVm.setStatus('current')
if mibBuilder.loadTexts: vmNewCfgGroupRemVm.setDescription('Remove a virtual machine from the group by UUID / Name / IP / MAC Address Note: MAC address format xx:xx:xx:xx:xx:xx')
vmNewCfgGroupAddVmIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 2, 2, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmNewCfgGroupAddVmIdx.setStatus('current')
if mibBuilder.loadTexts: vmNewCfgGroupAddVmIdx.setDescription('Add virtual MAC address by index to the group.')
vmNewCfgGroupRemVmIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 2, 2, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmNewCfgGroupRemVmIdx.setStatus('current')
if mibBuilder.loadTexts: vmNewCfgGroupRemVmIdx.setDescription('Remove a virtual MAC address by index from the group.')
vmNewCfgGroupAddPort = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 2, 2, 1, 8), PortNumber()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmNewCfgGroupAddPort.setStatus('current')
if mibBuilder.loadTexts: vmNewCfgGroupAddPort.setDescription('Add a port to the group.')
vmNewCfgGroupRemPort = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 2, 2, 1, 9), PortNumber()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmNewCfgGroupRemPort.setStatus('current')
if mibBuilder.loadTexts: vmNewCfgGroupRemPort.setDescription('Remove a port from the group.')
vmNewCfgGroupAddTrunk = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 2, 2, 1, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmNewCfgGroupAddTrunk.setStatus('current')
if mibBuilder.loadTexts: vmNewCfgGroupAddTrunk.setDescription('Add trunk to the group.')
vmNewCfgGroupRemTrunk = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 2, 2, 1, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmNewCfgGroupRemTrunk.setStatus('current')
if mibBuilder.loadTexts: vmNewCfgGroupRemTrunk.setDescription('Remove trunk from the group.')
vmNewCfgGroupTagState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 2, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 0))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmNewCfgGroupTagState.setStatus('current')
if mibBuilder.loadTexts: vmNewCfgGroupTagState.setDescription('Enable VLAN tagging on all VM group ports.')
vmNewCfgGroupAddLacpKey = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 2, 2, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmNewCfgGroupAddLacpKey.setStatus('current')
if mibBuilder.loadTexts: vmNewCfgGroupAddLacpKey.setDescription('Add LACP trunk to the group.')
vmNewCfgGroupRemLacpKey = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 2, 2, 1, 14), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmNewCfgGroupRemLacpKey.setStatus('current')
if mibBuilder.loadTexts: vmNewCfgGroupRemLacpKey.setDescription('Remove LACP trunk from the group.')
vmNewCfgGroupAddProfile = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 2, 2, 1, 15), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmNewCfgGroupAddProfile.setStatus('current')
if mibBuilder.loadTexts: vmNewCfgGroupAddProfile.setDescription('Add VM Profile to the group.')
vmNewCfgGroupRemProfile = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 2, 2, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("remove", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmNewCfgGroupRemProfile.setStatus('current')
if mibBuilder.loadTexts: vmNewCfgGroupRemProfile.setDescription('Remove any VM profile associated with the group.')
vmNewCfgGroupProfileName = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 2, 2, 1, 17), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmNewCfgGroupProfileName.setStatus('current')
if mibBuilder.loadTexts: vmNewCfgGroupProfileName.setDescription('New profile name to be used by the group.')
vmNewCfgGroupDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 2, 2, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("delete", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmNewCfgGroupDelete.setStatus('current')
if mibBuilder.loadTexts: vmNewCfgGroupDelete.setDescription('Delete VM Group.')
vmNewCfgGroupStg = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 2, 2, 1, 19), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmNewCfgGroupStg.setStatus('current')
if mibBuilder.loadTexts: vmNewCfgGroupStg.setDescription('Set group vlan spanning tree group.')
vmNewCfgGroupPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 2, 2, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmNewCfgGroupPorts.setStatus('current')
if mibBuilder.loadTexts: vmNewCfgGroupPorts.setDescription('The port list in the VM Group. The ports are presented in bitmap format. in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ port 8 || || || ||___ port 7 || |____ port 6 || . . . ||_________ port 1 |__________ reserved where x : 1 - The represented port belongs to the VM Group 0 - The represented port does not belong to the VM Group')
vmNewCfgGroupValidateMode = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 2, 2, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("noValidation", 0), ("basicCheck", 1), ("advancedCheck", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmNewCfgGroupValidateMode.setStatus('current')
if mibBuilder.loadTexts: vmNewCfgGroupValidateMode.setDescription('Set group validation mode: noValidation : no validation will be performed. basicCheck: validate ESX port. advancedCheck: validate ESX port and VM UUID.')
vmCurCfgGroupMacTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 2, 3), )
if mibBuilder.loadTexts: vmCurCfgGroupMacTable.setStatus('current')
if mibBuilder.loadTexts: vmCurCfgGroupMacTable.setDescription('Virtual machine group current configuration table.')
vmCurCfgGroupMaclistEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 2, 3, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "vmCurCfgGroupMacGroupIndex"), (0, "IBM-GbTOR-10G-L2L3-MIB", "vmCurCfgGroupMacVMIndex"))
if mibBuilder.loadTexts: vmCurCfgGroupMaclistEntry.setStatus('current')
if mibBuilder.loadTexts: vmCurCfgGroupMaclistEntry.setDescription('Information about virtual machine group configuration. Indexes are: - vmCurCfgGroupMacGroupIndex - group number - vmCurCfgGroupMacVMIndex - virtual machine config index')
vmCurCfgGroupMacGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 2, 3, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmCurCfgGroupMacGroupIndex.setStatus('current')
if mibBuilder.loadTexts: vmCurCfgGroupMacGroupIndex.setDescription('The group number for which the info is related.')
vmCurCfgGroupMacVMIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 2, 3, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmCurCfgGroupMacVMIndex.setStatus('current')
if mibBuilder.loadTexts: vmCurCfgGroupMacVMIndex.setDescription('The virtual machine number for which the info is related.')
vmCurCfgGroupMacVMMac = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 2, 3, 1, 3), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmCurCfgGroupMacVMMac.setStatus('current')
if mibBuilder.loadTexts: vmCurCfgGroupMacVMMac.setDescription('virtual machine MAC address.')
vmNewCfgGroupMacTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 2, 4), )
if mibBuilder.loadTexts: vmNewCfgGroupMacTable.setStatus('current')
if mibBuilder.loadTexts: vmNewCfgGroupMacTable.setDescription('virtual machine group new configuration table.')
vmNewCfgGroupMaclistEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 2, 4, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "vmNewCfgGroupMacGroupIndex"), (0, "IBM-GbTOR-10G-L2L3-MIB", "vmNewCfgGroupMacVMIndex"))
if mibBuilder.loadTexts: vmNewCfgGroupMaclistEntry.setStatus('current')
if mibBuilder.loadTexts: vmNewCfgGroupMaclistEntry.setDescription('Information about virtual machine group')
vmNewCfgGroupMacGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 2, 4, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmNewCfgGroupMacGroupIndex.setStatus('current')
if mibBuilder.loadTexts: vmNewCfgGroupMacGroupIndex.setDescription('The group number for which the info is related.')
vmNewCfgGroupMacVMIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 2, 4, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmNewCfgGroupMacVMIndex.setStatus('current')
if mibBuilder.loadTexts: vmNewCfgGroupMacVMIndex.setDescription('The virtual machine number for which the info is related.')
vmNewCfgGroupMacVMMac = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 2, 4, 1, 3), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmNewCfgGroupMacVMMac.setStatus('current')
if mibBuilder.loadTexts: vmNewCfgGroupMacVMMac.setDescription('The virtual machine MAC address.')
vmbwCurCfgTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 3, 1, 1), )
if mibBuilder.loadTexts: vmbwCurCfgTable.setStatus('current')
if mibBuilder.loadTexts: vmbwCurCfgTable.setDescription('The table of current VM Bandwidth configuration.')
vmbwCurCfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 3, 1, 1, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "vmbwCurCfgMac"))
if mibBuilder.loadTexts: vmbwCurCfgEntry.setStatus('current')
if mibBuilder.loadTexts: vmbwCurCfgEntry.setDescription('A row in the current VM bandwidth table.')
vmbwCurCfgMac = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 3, 1, 1, 1, 1), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmbwCurCfgMac.setStatus('current')
if mibBuilder.loadTexts: vmbwCurCfgMac.setDescription('MAC address of VM for which bandwidth control information is related.')
vmbwCurCfgTxRate = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 3, 1, 1, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmbwCurCfgTxRate.setStatus('current')
if mibBuilder.loadTexts: vmbwCurCfgTxRate.setDescription('VM transmit bandwidth committed rate in kbps (ingress for switch).')
vmbwCurCfgTxBurst = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 3, 1, 1, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmbwCurCfgTxBurst.setStatus('current')
if mibBuilder.loadTexts: vmbwCurCfgTxBurst.setDescription('VM transmit bandwidth max burst size in kilobits (ingress for switch).')
vmbwCurCfgTxAclId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 3, 1, 1, 1, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmbwCurCfgTxAclId.setStatus('current')
if mibBuilder.loadTexts: vmbwCurCfgTxAclId.setDescription('ACL used for VM transmit bandwidth.')
vmbwCurCfgCtrl = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 3, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmbwCurCfgCtrl.setStatus('current')
if mibBuilder.loadTexts: vmbwCurCfgCtrl.setDescription('Enable/Disable VM bandwidth control entry.')
vmbwNewCfgTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 3, 1, 2), )
if mibBuilder.loadTexts: vmbwNewCfgTable.setStatus('current')
if mibBuilder.loadTexts: vmbwNewCfgTable.setDescription('The table of new VM Bandwidth configuration.')
vmbwNewCfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 3, 1, 2, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "vmbwNewCfgMac"))
if mibBuilder.loadTexts: vmbwNewCfgEntry.setStatus('current')
if mibBuilder.loadTexts: vmbwNewCfgEntry.setDescription('A row in the new VM bandwidth table.')
vmbwNewCfgMac = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 3, 1, 2, 1, 1), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmbwNewCfgMac.setStatus('current')
if mibBuilder.loadTexts: vmbwNewCfgMac.setDescription('MAC address of VM for which bandwidth control information is related.')
vmbwNewCfgTxRate = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 3, 1, 2, 1, 2), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmbwNewCfgTxRate.setStatus('current')
if mibBuilder.loadTexts: vmbwNewCfgTxRate.setDescription('VM transmit bandwidth committed rate in kbps (ingress for switch). Set this to zero to disable transmit bandwidth control.')
vmbwNewCfgTxBurst = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 3, 1, 2, 1, 3), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmbwNewCfgTxBurst.setStatus('current')
if mibBuilder.loadTexts: vmbwNewCfgTxBurst.setDescription('VM transmit bandwidth max burst size in kilobits (ingress for switch). Set this to zero to disable transmit bandwidth control.')
vmbwNewCfgTxAclId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 3, 1, 2, 1, 4), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmbwNewCfgTxAclId.setStatus('current')
if mibBuilder.loadTexts: vmbwNewCfgTxAclId.setDescription('ACL used for VM transmit bandwidth. This is optional parameter. If set to zero the system will choose one ACL for tx bandwidth control.')
vmbwNewCfgCtrl = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 3, 1, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmbwNewCfgCtrl.setStatus('current')
if mibBuilder.loadTexts: vmbwNewCfgCtrl.setDescription('VM bandwidth control entry status')
vmbwNewCfgDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 3, 1, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("delete", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmbwNewCfgDelete.setStatus('current')
if mibBuilder.loadTexts: vmbwNewCfgDelete.setDescription('This is an action object to delete a VM Bandwidth entry. other(1) is returned always when read. To delete an entry enter delete(2).')
vmCurCfgCheck = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 7, 1))
vmNewCfgCheck = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 7, 2))
vmCurCfgCheckActionBasic = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 7, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("log", 1), ("link", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmCurCfgCheckActionBasic.setStatus('current')
if mibBuilder.loadTexts: vmCurCfgCheckActionBasic.setDescription('Current settings for basic checking mode')
vmCurCfgCheckActionAdvanced = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 7, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("log", 1), ("link", 2), ("acl", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmCurCfgCheckActionAdvanced.setStatus('current')
if mibBuilder.loadTexts: vmCurCfgCheckActionAdvanced.setDescription('Current settings for advanced checking mode')
vmCurCfgCheckAclsMax = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 7, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmCurCfgCheckAclsMax.setStatus('current')
if mibBuilder.loadTexts: vmCurCfgCheckAclsMax.setDescription('Current value for the maximum number of ACLs that can be used by Mac Spoofing Check feature')
vmCurCfgCheckTrust = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 7, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmCurCfgCheckTrust.setStatus('current')
if mibBuilder.loadTexts: vmCurCfgCheckTrust.setDescription('Current value for the configured trusted port list. The ports are presented in bitmap format. in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ port 8 || || || ||___ port 7 || |____ port 6 || . . . ||_________ port 1 |__________ reserved where x : 1 - The represented port belongs to the trusted ports list 0 - The represented port does not belong to the trusted ports list')
vmNewCfgCheckActionBasic = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 7, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("log", 1), ("link", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmNewCfgCheckActionBasic.setStatus('current')
if mibBuilder.loadTexts: vmNewCfgCheckActionBasic.setDescription('New settings for basic checking mode')
vmNewCfgCheckActionAdvanced = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 7, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("log", 1), ("link", 2), ("acl", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmNewCfgCheckActionAdvanced.setStatus('current')
if mibBuilder.loadTexts: vmNewCfgCheckActionAdvanced.setDescription('New settings for advanced checking mode')
vmNewCfgCheckAclsMax = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 7, 2, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmNewCfgCheckAclsMax.setStatus('current')
if mibBuilder.loadTexts: vmNewCfgCheckAclsMax.setDescription('New value for the maximum number of ACLs that can be used by Mac Spoofing Check feature')
vmNewCfgCheckTrust = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 7, 2, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmNewCfgCheckTrust.setStatus('current')
if mibBuilder.loadTexts: vmNewCfgCheckTrust.setDescription('New value for the configured trusted port list. The ports are presented in bitmap format. in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ port 8 || || || ||___ port 7 || |____ port 6 || . . . ||_________ port 1 |__________ reserved where x : 1 - The represented port belongs to the trusted ports list 0 - The represented port does not belong to the trusted ports list')
vmNewCfgCheckTrustAddPort = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 7, 2, 5), PortNumber()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmNewCfgCheckTrustAddPort.setStatus('current')
if mibBuilder.loadTexts: vmNewCfgCheckTrustAddPort.setDescription('Add port to the configured trusted port list.')
vmNewCfgCheckTrustRemPort = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 7, 2, 6), PortNumber()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmNewCfgCheckTrustRemPort.setStatus('current')
if mibBuilder.loadTexts: vmNewCfgCheckTrustRemPort.setDescription('Remove port from the configured trusted port list.')
vmCurCfgProfilesTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 4, 1), )
if mibBuilder.loadTexts: vmCurCfgProfilesTable.setStatus('current')
if mibBuilder.loadTexts: vmCurCfgProfilesTable.setDescription('The table of VM profiles in the current config')
vmCurCfgProfileEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 4, 1, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "vmCurCfgProfileIndex"))
if mibBuilder.loadTexts: vmCurCfgProfileEntry.setStatus('current')
if mibBuilder.loadTexts: vmCurCfgProfileEntry.setDescription('Information about a VM profile in current config.')
vmCurCfgProfileIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 4, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmCurCfgProfileIndex.setStatus('current')
if mibBuilder.loadTexts: vmCurCfgProfileIndex.setDescription('The index of the vm profiles table (1..32).')
vmCurCfgProfileName = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 4, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmCurCfgProfileName.setStatus('current')
if mibBuilder.loadTexts: vmCurCfgProfileName.setDescription('VM Profile name.')
vmCurCfgProfileVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 4, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmCurCfgProfileVlan.setStatus('current')
if mibBuilder.loadTexts: vmCurCfgProfileVlan.setDescription('Current VM Profile VLAN Id')
vmCurCfgProfileShapingAverage = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 4, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmCurCfgProfileShapingAverage.setStatus('current')
if mibBuilder.loadTexts: vmCurCfgProfileShapingAverage.setDescription('Current VM Profile Shaping Average.')
vmCurCfgProfileShapingBurst = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 4, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmCurCfgProfileShapingBurst.setStatus('current')
if mibBuilder.loadTexts: vmCurCfgProfileShapingBurst.setDescription('Current VM Profile Shaping Burst.')
vmCurCfgProfileShapingPeak = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 4, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmCurCfgProfileShapingPeak.setStatus('current')
if mibBuilder.loadTexts: vmCurCfgProfileShapingPeak.setDescription('Current VM Profile Shaping Peak.')
vmCurCfgProfileEgressShapingAverage = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 4, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmCurCfgProfileEgressShapingAverage.setStatus('current')
if mibBuilder.loadTexts: vmCurCfgProfileEgressShapingAverage.setDescription('Current VM Profile Egress Shaping Average.')
vmCurCfgProfileEgressShapingBurst = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 4, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmCurCfgProfileEgressShapingBurst.setStatus('current')
if mibBuilder.loadTexts: vmCurCfgProfileEgressShapingBurst.setDescription('Current VM Profile Egress Shaping Burst.')
vmCurCfgProfileEgressShapingPeak = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 4, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmCurCfgProfileEgressShapingPeak.setStatus('current')
if mibBuilder.loadTexts: vmCurCfgProfileEgressShapingPeak.setDescription('Current VM Profile Egress Shaping Peak.')
vmNewCfgProfilesTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 4, 2), )
if mibBuilder.loadTexts: vmNewCfgProfilesTable.setStatus('current')
if mibBuilder.loadTexts: vmNewCfgProfilesTable.setDescription('The table of VM profiles in the current config')
vmNewCfgProfileEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 4, 2, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "vmNewCfgProfileIndex"))
if mibBuilder.loadTexts: vmNewCfgProfileEntry.setStatus('current')
if mibBuilder.loadTexts: vmNewCfgProfileEntry.setDescription('Information about a VM profile in current config.')
vmNewCfgProfileIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 4, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmNewCfgProfileIndex.setStatus('current')
if mibBuilder.loadTexts: vmNewCfgProfileIndex.setDescription('The index of the vm profiles table (1..32).')
vmNewCfgProfileName = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 4, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 39))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmNewCfgProfileName.setStatus('current')
if mibBuilder.loadTexts: vmNewCfgProfileName.setDescription('VM Profile name.')
vmNewCfgProfileVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 4, 2, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmNewCfgProfileVlan.setStatus('current')
if mibBuilder.loadTexts: vmNewCfgProfileVlan.setDescription('Vlan to be used by the VM profile.')
vmNewCfgProfileShapingAverage = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 4, 2, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmNewCfgProfileShapingAverage.setStatus('current')
if mibBuilder.loadTexts: vmNewCfgProfileShapingAverage.setDescription('Shaping average to be used by the VM profile.')
vmNewCfgProfileShapingBurst = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 4, 2, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmNewCfgProfileShapingBurst.setStatus('current')
if mibBuilder.loadTexts: vmNewCfgProfileShapingBurst.setDescription('Shaping burst to be used by the VM profile.')
vmNewCfgProfileShapingPeak = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 4, 2, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmNewCfgProfileShapingPeak.setStatus('current')
if mibBuilder.loadTexts: vmNewCfgProfileShapingPeak.setDescription('Shaping peak to be used by the VM profile.')
vmNewCfgProfileDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 4, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("none", 1), ("delete", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmNewCfgProfileDelete.setStatus('current')
if mibBuilder.loadTexts: vmNewCfgProfileDelete.setDescription('Delete VM Profile.')
vmNewCfgProfileEgressShapingAverage = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 4, 2, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmNewCfgProfileEgressShapingAverage.setStatus('current')
if mibBuilder.loadTexts: vmNewCfgProfileEgressShapingAverage.setDescription('Egress shaping average to be used by the VM profile.')
vmNewCfgProfileEgressShapingBurst = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 4, 2, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmNewCfgProfileEgressShapingBurst.setStatus('current')
if mibBuilder.loadTexts: vmNewCfgProfileEgressShapingBurst.setDescription('Egress shaping burst to be used by the VM profile.')
vmNewCfgProfileEgressShapingPeak = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 4, 2, 1, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmNewCfgProfileEgressShapingPeak.setStatus('current')
if mibBuilder.loadTexts: vmNewCfgProfileEgressShapingPeak.setDescription('Egress shaping peak to be used by the VM profile.')
virtVMwareNameTableUpdate = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 5, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("get", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: virtVMwareNameTableUpdate.setStatus('current')
if mibBuilder.loadTexts: virtVMwareNameTableUpdate.setDescription('This is an action object to get information from the Virtual Center. Set this value to get(2) to update the host and VM name tables: virtVMwareHostNameTable, virtVMwareVMNameTable with information from the Virtual Center. These two tables can be querried by subsequent Get operations without accessing the Virtual Center. To refresh these two tables, set virtVMwareNameTableUpdate again. ok(1) is returned always when read.')
virtVMwareHostNameTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 5, 2), )
if mibBuilder.loadTexts: virtVMwareHostNameTable.setStatus('current')
if mibBuilder.loadTexts: virtVMwareHostNameTable.setDescription('The table of names of VMware hosts in the Virtual Center.')
virtVMwareHostNameEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 5, 2, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "virtVMwareHostNameIndex"))
if mibBuilder.loadTexts: virtVMwareHostNameEntry.setStatus('current')
if mibBuilder.loadTexts: virtVMwareHostNameEntry.setDescription('Information about names of VMware hosts in the Data Center.')
virtVMwareHostNameIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 5, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtVMwareHostNameIndex.setStatus('current')
if mibBuilder.loadTexts: virtVMwareHostNameIndex.setDescription('The index of the virtVMwareHostNameTable table.')
virtVMwareHostNameUUID = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 5, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtVMwareHostNameUUID.setStatus('current')
if mibBuilder.loadTexts: virtVMwareHostNameUUID.setDescription('The UUID of a VMware host.')
virtVMwareHostNameIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 5, 2, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtVMwareHostNameIpAddress.setStatus('current')
if mibBuilder.loadTexts: virtVMwareHostNameIpAddress.setDescription('The IP address of a VMware host.')
virtVMwareHostNameName = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 5, 2, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtVMwareHostNameName.setStatus('current')
if mibBuilder.loadTexts: virtVMwareHostNameName.setDescription('The name of a VMware host.')
virtVMwareVMNameTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 5, 3), )
if mibBuilder.loadTexts: virtVMwareVMNameTable.setStatus('current')
if mibBuilder.loadTexts: virtVMwareVMNameTable.setDescription('The table of VMware virtual machines in the Data Center.')
virtVMwareVMNameEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 5, 3, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "virtVMwareVMNameIndex"))
if mibBuilder.loadTexts: virtVMwareVMNameEntry.setStatus('current')
if mibBuilder.loadTexts: virtVMwareVMNameEntry.setDescription('Information about VMware virtual machines in the Data Center.')
virtVMwareVMNameIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 5, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtVMwareVMNameIndex.setStatus('current')
if mibBuilder.loadTexts: virtVMwareVMNameIndex.setDescription('The index of the VMware virtual machine table in the Data Center.')
virtVMwareVMNameUUID = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 5, 3, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtVMwareVMNameUUID.setStatus('current')
if mibBuilder.loadTexts: virtVMwareVMNameUUID.setDescription('The UUID of a virtual machine.')
virtVMwareVMNameVMwareName = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 5, 3, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtVMwareVMNameVMwareName.setStatus('current')
if mibBuilder.loadTexts: virtVMwareVMNameVMwareName.setDescription('The name of a virtual machine given by VMware.')
virtVMwareVMNameOsName = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 5, 3, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtVMwareVMNameOsName.setStatus('current')
if mibBuilder.loadTexts: virtVMwareVMNameOsName.setDescription('The name of a virtual machine given by the host OS.')
virtVMwareVMNameIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 5, 3, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtVMwareVMNameIpAddress.setStatus('current')
if mibBuilder.loadTexts: virtVMwareVMNameIpAddress.setDescription('The IP address of a virtual machine.')
virtVMwareHost = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 5, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: virtVMwareHost.setStatus('current')
if mibBuilder.loadTexts: virtVMwareHost.setDescription("VMware host ID This is an action object to get information about a specific host from the Virtual Center. This object specifies the host ID by UUID / IP Address / Name. Setting this objects populates the following 3 tables: virtVMwareHostVswitchTable, virtVMwareHostPGTable, virtVMwareHostDetailInfoTable with the host's networking information from the Virtul Center. These three tables can be querried by subsequent Get operations without accessing the Virtual Center. To refresh these tables, set this object to the target host.")
virtVMwareHostVswitchTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 5, 5), )
if mibBuilder.loadTexts: virtVMwareHostVswitchTable.setStatus('current')
if mibBuilder.loadTexts: virtVMwareHostVswitchTable.setDescription('The table of Vswitches available on the specified host.')
virtVMwareHostVswitchEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 5, 5, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "virtVMwareHostVswitchIndex"))
if mibBuilder.loadTexts: virtVMwareHostVswitchEntry.setStatus('current')
if mibBuilder.loadTexts: virtVMwareHostVswitchEntry.setDescription('Information about Vswitches available on the specified host.')
virtVMwareHostVswitchIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 5, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtVMwareHostVswitchIndex.setStatus('current')
if mibBuilder.loadTexts: virtVMwareHostVswitchIndex.setDescription('The index of the Vswitch table on the specified host.')
virtVMwareHostVswitchName = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 5, 5, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtVMwareHostVswitchName.setStatus('current')
if mibBuilder.loadTexts: virtVMwareHostVswitchName.setDescription('The name of a Vswitch on the specified host.')
virtVMwareHostPGTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 5, 6), )
if mibBuilder.loadTexts: virtVMwareHostPGTable.setStatus('current')
if mibBuilder.loadTexts: virtVMwareHostPGTable.setDescription('The table of Port Groups available on the specified host.')
virtVMwareHostPGEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 5, 6, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "virtVMwareHostPGIndex"))
if mibBuilder.loadTexts: virtVMwareHostPGEntry.setStatus('current')
if mibBuilder.loadTexts: virtVMwareHostPGEntry.setDescription('Information about Port Groups available on the specified host.')
virtVMwareHostPGIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 5, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtVMwareHostPGIndex.setStatus('current')
if mibBuilder.loadTexts: virtVMwareHostPGIndex.setDescription('The index of the Port Group table on the specified host.')
virtVMwareHostPGName = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 5, 6, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtVMwareHostPGName.setStatus('current')
if mibBuilder.loadTexts: virtVMwareHostPGName.setDescription('The name of a Port Group on the specified host.')
virtVMwareHostPGVswitchName = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 5, 6, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtVMwareHostPGVswitchName.setStatus('current')
if mibBuilder.loadTexts: virtVMwareHostPGVswitchName.setDescription('The name of a Vswitch on the specified host.')
virtVMwareHostDetailInfoTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 5, 7), )
if mibBuilder.loadTexts: virtVMwareHostDetailInfoTable.setStatus('current')
if mibBuilder.loadTexts: virtVMwareHostDetailInfoTable.setDescription('The table of detailed information available on the specified host/VM interface.')
virtVMwareHostDetailInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 5, 7, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "virtVMwareHostDetailInfoIndex"))
if mibBuilder.loadTexts: virtVMwareHostDetailInfoEntry.setStatus('current')
if mibBuilder.loadTexts: virtVMwareHostDetailInfoEntry.setDescription('Detailed information available on the specified host/VM interface.')
virtVMwareHostDetailInfoIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 5, 7, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtVMwareHostDetailInfoIndex.setStatus('current')
if mibBuilder.loadTexts: virtVMwareHostDetailInfoIndex.setDescription('The index of the detailed information table on the specified host/VM interface.')
virtVMwareHostDetailInfoMACAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 5, 7, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtVMwareHostDetailInfoMACAddr.setStatus('current')
if mibBuilder.loadTexts: virtVMwareHostDetailInfoMACAddr.setDescription('The MAC address of the host/VM interface.')
virtVMwareHostDetailInfoPort = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 5, 7, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtVMwareHostDetailInfoPort.setStatus('current')
if mibBuilder.loadTexts: virtVMwareHostDetailInfoPort.setDescription('The port number of the specified host/VM interface.')
virtVMwareHostDetailInfoType = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 5, 7, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtVMwareHostDetailInfoType.setStatus('current')
if mibBuilder.loadTexts: virtVMwareHostDetailInfoType.setDescription('Interface type')
virtVMwareHostDetailInfoIPAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 5, 7, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtVMwareHostDetailInfoIPAddr.setStatus('current')
if mibBuilder.loadTexts: virtVMwareHostDetailInfoIPAddr.setDescription('The IP address of the specified host/VM interface.')
virtVMwareHostDetailInfoUUID = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 5, 7, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtVMwareHostDetailInfoUUID.setStatus('current')
if mibBuilder.loadTexts: virtVMwareHostDetailInfoUUID.setDescription('The UUID of the specified host/VM interface.')
virtVMwareHostDetailInfoVswitch = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 5, 7, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtVMwareHostDetailInfoVswitch.setStatus('current')
if mibBuilder.loadTexts: virtVMwareHostDetailInfoVswitch.setDescription('The name of the virtual switch of the specified host/VM interface.')
virtVMwareHostDetailInfoPortGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 5, 7, 1, 8), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtVMwareHostDetailInfoPortGroup.setStatus('current')
if mibBuilder.loadTexts: virtVMwareHostDetailInfoPortGroup.setDescription('The name of the port group of the specified host/VM interface.')
virtVMwareHostDetailInfoVlanID = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 5, 7, 1, 9), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtVMwareHostDetailInfoVlanID.setStatus('current')
if mibBuilder.loadTexts: virtVMwareHostDetailInfoVlanID.setDescription('The VLAN ID of the specified host/VM interface.')
virtVMwareHostDetailInfoHostName = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 5, 7, 1, 10), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtVMwareHostDetailInfoHostName.setStatus('current')
if mibBuilder.loadTexts: virtVMwareHostDetailInfoHostName.setDescription('The name of the specified host interface. N/A for VMs.')
virtVMwareHostDetailInfoVMVCenterName = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 5, 7, 1, 11), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtVMwareHostDetailInfoVMVCenterName.setStatus('current')
if mibBuilder.loadTexts: virtVMwareHostDetailInfoVMVCenterName.setDescription('The name of the Virtual Center of the specified VM interface. N/A for host interfaces.')
virtVMwareHostDetailInfoVMOSHostName = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 5, 7, 1, 12), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtVMwareHostDetailInfoVMOSHostName.setStatus('current')
if mibBuilder.loadTexts: virtVMwareHostDetailInfoVMOSHostName.setDescription('The name of the VM set by the host operating system. N/A for host interfaces.')
virtVMwareHostDetailInfoVMCurrentHost = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 5, 7, 1, 13), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtVMwareHostDetailInfoVMCurrentHost.setStatus('current')
if mibBuilder.loadTexts: virtVMwareHostDetailInfoVMCurrentHost.setDescription('The name of the host of the specified VM. N/A for host interfaces.')
virtVMwareVM = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 5, 8), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: virtVMwareVM.setStatus('current')
if mibBuilder.loadTexts: virtVMwareVM.setDescription('VMware virtual machine ID This is an action object to get information about a specific virtual machine from the Virtual Center. This object specifies the VM ID by by UUID / IP Address / Name. Setting this object populates the virtVMwareVMInfoTable table with networking information for this VM from the Virtual Center. This table can be querried by subsequent Get operations without accessing the Virtual Center. To refresh the table, set this object to the target VM. ')
virtVMwareVMInfoTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 5, 9), )
if mibBuilder.loadTexts: virtVMwareVMInfoTable.setStatus('current')
if mibBuilder.loadTexts: virtVMwareVMInfoTable.setDescription('The table of networking information available on the specified VM.')
virtVMwareVMInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 5, 9, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "virtVMwareVMInfoIndex"))
if mibBuilder.loadTexts: virtVMwareVMInfoEntry.setStatus('current')
if mibBuilder.loadTexts: virtVMwareVMInfoEntry.setDescription('Detailed information available on the specified VM.')
virtVMwareVMInfoIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 5, 9, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtVMwareVMInfoIndex.setStatus('current')
if mibBuilder.loadTexts: virtVMwareVMInfoIndex.setDescription('The index of the table with information on the specified VM.')
virtVMwareVMInfoMACAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 5, 9, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtVMwareVMInfoMACAddr.setStatus('current')
if mibBuilder.loadTexts: virtVMwareVMInfoMACAddr.setDescription('The MAC address of the specified VM.')
virtVMwareVMInfoPort = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 5, 9, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtVMwareVMInfoPort.setStatus('current')
if mibBuilder.loadTexts: virtVMwareVMInfoPort.setDescription('The port number of the specified VM.')
virtVMwareVMInfoType = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 5, 9, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtVMwareVMInfoType.setStatus('current')
if mibBuilder.loadTexts: virtVMwareVMInfoType.setDescription('Interface type')
virtVMwareVMInfoIPAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 5, 9, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtVMwareVMInfoIPAddr.setStatus('current')
if mibBuilder.loadTexts: virtVMwareVMInfoIPAddr.setDescription('The IP address of the specified VM.')
virtVMwareVMInfoUUID = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 5, 9, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtVMwareVMInfoUUID.setStatus('current')
if mibBuilder.loadTexts: virtVMwareVMInfoUUID.setDescription('The UUID of the specified VM.')
virtVMwareVMInfoVswitch = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 5, 9, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtVMwareVMInfoVswitch.setStatus('current')
if mibBuilder.loadTexts: virtVMwareVMInfoVswitch.setDescription('The name of the virtual switch of the specified VM.')
virtVMwareVMInfoPortGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 5, 9, 1, 8), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtVMwareVMInfoPortGroup.setStatus('current')
if mibBuilder.loadTexts: virtVMwareVMInfoPortGroup.setDescription('The name of the port group of the specified VM.')
virtVMwareVMInfoVlanID = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 5, 9, 1, 9), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtVMwareVMInfoVlanID.setStatus('current')
if mibBuilder.loadTexts: virtVMwareVMInfoVlanID.setDescription('The VLAN ID of the specified VM.')
virtVMwareVMInfoVMVCenterName = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 5, 9, 1, 10), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtVMwareVMInfoVMVCenterName.setStatus('current')
if mibBuilder.loadTexts: virtVMwareVMInfoVMVCenterName.setDescription('The name of the Virtual Center of the specified VM.')
virtVMwareVMInfoVMOSHostName = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 5, 9, 1, 11), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtVMwareVMInfoVMOSHostName.setStatus('current')
if mibBuilder.loadTexts: virtVMwareVMInfoVMOSHostName.setDescription('The name of the VM set by the host operating system.')
virtVMwareVMInfoVMCurrentHost = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 5, 9, 1, 12), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtVMwareVMInfoVMCurrentHost.setStatus('current')
if mibBuilder.loadTexts: virtVMwareVMInfoVMCurrentHost.setDescription('The name of the host of the specified VM.')
virtCurCfgVMwareHello = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 5, 10))
virtNewCfgVMwareHello = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 5, 11))
virtCurCfgVMwareHelloEnable = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 5, 10, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtCurCfgVMwareHelloEnable.setStatus('current')
if mibBuilder.loadTexts: virtCurCfgVMwareHelloEnable.setDescription('Current value for hello advertising status')
virtCurCfgVMwareHelloTimer = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 5, 10, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtCurCfgVMwareHelloTimer.setStatus('current')
if mibBuilder.loadTexts: virtCurCfgVMwareHelloTimer.setDescription('Current hello packet send interval')
virtCurCfgVMwareHelloPorts = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 5, 10, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtCurCfgVMwareHelloPorts.setStatus('current')
if mibBuilder.loadTexts: virtCurCfgVMwareHelloPorts.setDescription('Current value for the configured hello port list. The ports are presented in bitmap format. in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ port 8 || || || ||___ port 7 || |____ port 6 || . . . ||_________ port 1 |__________ reserved where x : 1 - The represented port belongs to the hello ports list 0 - The represented port does not belong to the hello ports list')
virtCurCfgVMwareHelloAddr = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 5, 10, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtCurCfgVMwareHelloAddr.setStatus('current')
if mibBuilder.loadTexts: virtCurCfgVMwareHelloAddr.setDescription('Current VM hello IP address')
virtNewCfgVMwareHelloEnable = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 5, 11, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: virtNewCfgVMwareHelloEnable.setStatus('current')
if mibBuilder.loadTexts: virtNewCfgVMwareHelloEnable.setDescription('New value for hello advertising status')
virtNewCfgVMwareHelloTimer = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 5, 11, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: virtNewCfgVMwareHelloTimer.setStatus('current')
if mibBuilder.loadTexts: virtNewCfgVMwareHelloTimer.setDescription('New hello packet send interval')
virtNewCfgVMwareHelloPorts = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 5, 11, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtNewCfgVMwareHelloPorts.setStatus('current')
if mibBuilder.loadTexts: virtNewCfgVMwareHelloPorts.setDescription('New value for the configured hello port list. The ports are presented in bitmap format. in receiving order: OCTET 1 OCTET 2 ..... xxxxxxxx xxxxxxxx ..... || || |_ port 8 || || || ||___ port 7 || |____ port 6 || . . . ||_________ port 1 |__________ reserved where x : 1 - The represented port belongs to the hello ports list 0 - The represented port does not belong to the hello ports list')
virtNewCfgVMwareHelloAddPort = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 5, 11, 4), PortNumber()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: virtNewCfgVMwareHelloAddPort.setStatus('current')
if mibBuilder.loadTexts: virtNewCfgVMwareHelloAddPort.setDescription('Add a port to the hello port list')
virtNewCfgVMwareHelloRemovePort = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 5, 11, 5), PortNumber()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: virtNewCfgVMwareHelloRemovePort.setStatus('current')
if mibBuilder.loadTexts: virtNewCfgVMwareHelloRemovePort.setDescription('Remove a port from the hello port list')
virtNewCfgVMwareHelloAddr = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 15, 5, 11, 6), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: virtNewCfgVMwareHelloAddr.setStatus('current')
if mibBuilder.loadTexts: virtNewCfgVMwareHelloAddr.setDescription('New VM hello IP address')
agVMGroupInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 12))
vmGroupInfoTbl = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 12, 1), )
if mibBuilder.loadTexts: vmGroupInfoTbl.setStatus('current')
if mibBuilder.loadTexts: vmGroupInfoTbl.setDescription('Virtual MAC information table')
vmGroupInfolistEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 12, 1, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "vmGroupInfoIdx"))
if mibBuilder.loadTexts: vmGroupInfolistEntry.setStatus('current')
if mibBuilder.loadTexts: vmGroupInfolistEntry.setDescription('The run-time information about a virtual machine')
vmGroupInfoIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 12, 1, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmGroupInfoIdx.setStatus('current')
if mibBuilder.loadTexts: vmGroupInfoIdx.setDescription('Table index, 1 based.')
vmGroupInfoMac = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 12, 1, 1, 2), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmGroupInfoMac.setStatus('current')
if mibBuilder.loadTexts: vmGroupInfoMac.setDescription('The virtual machine MAC address.')
vmGroupInfoIP = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 12, 1, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmGroupInfoIP.setStatus('current')
if mibBuilder.loadTexts: vmGroupInfoIP.setDescription('The virtual machine IP address.')
vmGroupInfoPort = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 12, 1, 1, 4), PortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmGroupInfoPort.setStatus('current')
if mibBuilder.loadTexts: vmGroupInfoPort.setDescription('System port connected to the virtual machine.')
vmGroupInfoGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 12, 1, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmGroupInfoGroup.setStatus('current')
if mibBuilder.loadTexts: vmGroupInfoGroup.setDescription('The virtual machine group.')
vmGroupInfoVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 12, 1, 1, 6), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmGroupInfoVlan.setStatus('current')
if mibBuilder.loadTexts: vmGroupInfoVlan.setDescription('The virtual machine VLAN')
vmGroupInfoIsESXSvcCon = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 12, 1, 1, 7), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmGroupInfoIsESXSvcCon.setStatus('current')
if mibBuilder.loadTexts: vmGroupInfoIsESXSvcCon.setDescription('Set to 1 if ESX Service Console Interface, else 0.')
vmGroupInfoIsVMK = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 12, 1, 1, 8), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmGroupInfoIsVMK.setStatus('current')
if mibBuilder.loadTexts: vmGroupInfoIsVMK.setDescription('Set to 1 if VM Kernel Interface, else 0.')
vmGroupInfoName = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 12, 1, 1, 9), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmGroupInfoName.setStatus('current')
if mibBuilder.loadTexts: vmGroupInfoName.setDescription('Virtual Machine Name, if available.')
vmGroupInfoUUID = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 12, 1, 1, 10), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmGroupInfoUUID.setStatus('current')
if mibBuilder.loadTexts: vmGroupInfoUUID.setDescription('Virtual Machine UUID, if available.')
vmGroupInfoVSwitch = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 12, 1, 1, 11), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmGroupInfoVSwitch.setStatus('current')
if mibBuilder.loadTexts: vmGroupInfoVSwitch.setDescription('Virtual Machine VSwitch, if available.')
vmGroupInfoPortGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 12, 1, 1, 12), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmGroupInfoPortGroup.setStatus('current')
if mibBuilder.loadTexts: vmGroupInfoPortGroup.setDescription('Virtual Machine Port Group, if available.')
vmGroupInfoHost = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 1, 3, 12, 1, 1, 13), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmGroupInfoHost.setStatus('current')
if mibBuilder.loadTexts: vmGroupInfoHost.setDescription('Virtual Machine Host, if available.')
vnic = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 16))
vnicCurCfgState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 16, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vnicCurCfgState.setStatus('current')
if mibBuilder.loadTexts: vnicCurCfgState.setDescription('VNIC global state.')
vnicNewCfgState = MibScalar((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 16, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnicNewCfgState.setStatus('current')
if mibBuilder.loadTexts: vnicNewCfgState.setDescription('Enable/Disable vNIC.')
vnicCurCfgVnicTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 16, 7), )
if mibBuilder.loadTexts: vnicCurCfgVnicTable.setStatus('current')
if mibBuilder.loadTexts: vnicCurCfgVnicTable.setDescription('The table of vNICs')
vnicCurCfgVnicEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 16, 7, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "vnicCurCfgVnicPortIndex"), (0, "IBM-GbTOR-10G-L2L3-MIB", "vnicCurCfgVnicIndex"))
if mibBuilder.loadTexts: vnicCurCfgVnicEntry.setStatus('current')
if mibBuilder.loadTexts: vnicCurCfgVnicEntry.setDescription('A vNIC in the vnicCurCfgVnicTable')
vnicCurCfgVnicPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 16, 7, 1, 1), PortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vnicCurCfgVnicPortIndex.setStatus('current')
if mibBuilder.loadTexts: vnicCurCfgVnicPortIndex.setDescription('The port number of the vNIC.')
vnicCurCfgVnicIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 16, 7, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vnicCurCfgVnicIndex.setStatus('current')
if mibBuilder.loadTexts: vnicCurCfgVnicIndex.setDescription('The vNIC number of the vNIC.')
vnicCurCfgVnicState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 16, 7, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vnicCurCfgVnicState.setStatus('current')
if mibBuilder.loadTexts: vnicCurCfgVnicState.setDescription('The state the vNIC.')
vnicCurCfgVnicBw = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 16, 7, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vnicCurCfgVnicBw.setStatus('current')
if mibBuilder.loadTexts: vnicCurCfgVnicBw.setDescription('The maximum bandwidth the vNIC.')
vnicCurCfgVnicType = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 16, 7, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("default", 1), ("fcoe", 2), ("iscsi", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vnicCurCfgVnicType.setStatus('current')
if mibBuilder.loadTexts: vnicCurCfgVnicType.setDescription('The type of the vNIC.')
vnicCurCfgVnicMAC = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 16, 7, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vnicCurCfgVnicMAC.setStatus('current')
if mibBuilder.loadTexts: vnicCurCfgVnicMAC.setDescription('The MAC address of the vNIC.')
vnicNewCfgVnicTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 16, 8), )
if mibBuilder.loadTexts: vnicNewCfgVnicTable.setStatus('current')
if mibBuilder.loadTexts: vnicNewCfgVnicTable.setDescription('The table of vNICs')
vnicNewCfgVnicEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 16, 8, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "vnicNewCfgVnicPortIndex"), (0, "IBM-GbTOR-10G-L2L3-MIB", "vnicNewCfgVnicIndex"))
if mibBuilder.loadTexts: vnicNewCfgVnicEntry.setStatus('current')
if mibBuilder.loadTexts: vnicNewCfgVnicEntry.setDescription('A vNIC in the vnicNewCfgVnicTable')
vnicNewCfgVnicPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 16, 8, 1, 1), PortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vnicNewCfgVnicPortIndex.setStatus('current')
if mibBuilder.loadTexts: vnicNewCfgVnicPortIndex.setDescription('The port number of the vNIC.')
vnicNewCfgVnicIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 16, 8, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vnicNewCfgVnicIndex.setStatus('current')
if mibBuilder.loadTexts: vnicNewCfgVnicIndex.setDescription('The vNIC number of the vNIC.')
vnicNewCfgVnicState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 16, 8, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnicNewCfgVnicState.setStatus('current')
if mibBuilder.loadTexts: vnicNewCfgVnicState.setDescription('The state the vNIC.')
vnicNewCfgVnicBw = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 16, 8, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnicNewCfgVnicBw.setStatus('current')
if mibBuilder.loadTexts: vnicNewCfgVnicBw.setDescription('The maximum bandwidth the vNIC.')
vnicCurCfgGroupTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 16, 9), )
if mibBuilder.loadTexts: vnicCurCfgGroupTable.setStatus('current')
if mibBuilder.loadTexts: vnicCurCfgGroupTable.setDescription('The table of vNIC Groups')
vnicCurCfgGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 16, 9, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "vnicCurCfgGroupIndex"))
if mibBuilder.loadTexts: vnicCurCfgGroupEntry.setStatus('current')
if mibBuilder.loadTexts: vnicCurCfgGroupEntry.setDescription('A vNIC in the vnicCurCfgGroupTable')
vnicCurCfgGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 16, 9, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vnicCurCfgGroupIndex.setStatus('current')
if mibBuilder.loadTexts: vnicCurCfgGroupIndex.setDescription('The vNIC group number.')
vnicCurCfgGroupState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 16, 9, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vnicCurCfgGroupState.setStatus('current')
if mibBuilder.loadTexts: vnicCurCfgGroupState.setDescription('The vNIC group state.')
vnicCurCfgGroupVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 16, 9, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vnicCurCfgGroupVlan.setStatus('current')
if mibBuilder.loadTexts: vnicCurCfgGroupVlan.setDescription('The vNIC group vlan number.')
vnicCurCfgGroupFailoverState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 16, 9, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vnicCurCfgGroupFailoverState.setStatus('current')
if mibBuilder.loadTexts: vnicCurCfgGroupFailoverState.setDescription('The vNIC group failover state.')
vnicCurCfgGroupVnics = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 16, 9, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vnicCurCfgGroupVnics.setStatus('current')
if mibBuilder.loadTexts: vnicCurCfgGroupVnics.setDescription('The vNICs in the vNIC group.')
vnicCurCfgGroupPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 16, 9, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vnicCurCfgGroupPorts.setStatus('current')
if mibBuilder.loadTexts: vnicCurCfgGroupPorts.setDescription('Non-vNIC Ports and/or uplink port in the vNIC group.')
vnicCurCfgGroupTrunk = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 16, 9, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vnicCurCfgGroupTrunk.setStatus('current')
if mibBuilder.loadTexts: vnicCurCfgGroupTrunk.setDescription('Uplink trunk in the vNIC group.')
vnicNewCfgGroupTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 16, 10), )
if mibBuilder.loadTexts: vnicNewCfgGroupTable.setStatus('current')
if mibBuilder.loadTexts: vnicNewCfgGroupTable.setDescription('The table of vNIC Groups')
vnicNewCfgGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 16, 10, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "vnicNewCfgGroupIndex"))
if mibBuilder.loadTexts: vnicNewCfgGroupEntry.setStatus('current')
if mibBuilder.loadTexts: vnicNewCfgGroupEntry.setDescription('A vNIC in the vnicNewCfgGroupTable')
vnicNewCfgGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 16, 10, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vnicNewCfgGroupIndex.setStatus('current')
if mibBuilder.loadTexts: vnicNewCfgGroupIndex.setDescription('The vNIC group number.')
vnicNewCfgGroupState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 16, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnicNewCfgGroupState.setStatus('current')
if mibBuilder.loadTexts: vnicNewCfgGroupState.setDescription('Enable/disalbe the vNIC group.')
vnicNewCfgGroupVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 16, 10, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnicNewCfgGroupVlan.setStatus('current')
if mibBuilder.loadTexts: vnicNewCfgGroupVlan.setDescription('Set the vNIC group vlan number.')
vnicNewCfgGroupFailoverState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 16, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnicNewCfgGroupFailoverState.setStatus('current')
if mibBuilder.loadTexts: vnicNewCfgGroupFailoverState.setDescription('Set the vNIC group failover state.')
vnicNewCfgGroupAddVnic = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 16, 10, 1, 5), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnicNewCfgGroupAddVnic.setStatus('current')
if mibBuilder.loadTexts: vnicNewCfgGroupAddVnic.setDescription('Add a vNIC to the vNIC group.')
vnicNewCfgGroupRemVnic = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 16, 10, 1, 6), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnicNewCfgGroupRemVnic.setStatus('current')
if mibBuilder.loadTexts: vnicNewCfgGroupRemVnic.setDescription('Remove a vNIC to the vNIC group.')
vnicNewCfgGroupAddPort = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 16, 10, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnicNewCfgGroupAddPort.setStatus('current')
if mibBuilder.loadTexts: vnicNewCfgGroupAddPort.setDescription('Add a non-vNIC port or a uplink port to the vNIC group.')
vnicNewCfgGroupRemPort = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 16, 10, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnicNewCfgGroupRemPort.setStatus('current')
if mibBuilder.loadTexts: vnicNewCfgGroupRemPort.setDescription('Remove a non-vNIC port or a uplink port from the vNIC group.')
vnicNewCfgGroupAddTrunk = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 16, 10, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnicNewCfgGroupAddTrunk.setStatus('current')
if mibBuilder.loadTexts: vnicNewCfgGroupAddTrunk.setDescription('Add a uplink trunk to the vNIC group.')
vnicNewCfgGroupRemTrunk = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 16, 10, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("delete", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnicNewCfgGroupRemTrunk.setStatus('current')
if mibBuilder.loadTexts: vnicNewCfgGroupRemTrunk.setDescription('Remove the uplink trunk from the vNIC group. other(1) is returned always when read. The following values are writable: delete(2)...to delete the uplink trunk from the vNIC group')
vnicNewCfgGroupDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 16, 10, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("delete", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnicNewCfgGroupDelete.setStatus('current')
if mibBuilder.loadTexts: vnicNewCfgGroupDelete.setDescription('Delete the vNIC group. other(1) is returned always when read. The following values are writable: delete(2)...to delete the vNIC group')
vnicNewCfgGroupVnics = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 16, 10, 1, 14), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vnicNewCfgGroupVnics.setStatus('current')
if mibBuilder.loadTexts: vnicNewCfgGroupVnics.setDescription('The vNICs in the vNIC group.')
vnicNewCfgGroupPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 16, 10, 1, 15), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vnicNewCfgGroupPorts.setStatus('current')
if mibBuilder.loadTexts: vnicNewCfgGroupPorts.setDescription('Non-vNIC Ports and/or uplink port in the vNIC group.')
vnicNewCfgGroupTrunk = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 2, 7, 4, 16, 10, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vnicNewCfgGroupTrunk.setStatus('current')
if mibBuilder.loadTexts: vnicNewCfgGroupTrunk.setDescription('Uplink trunk in the vNIC group.')
ibmnos_BladeSwitch = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 102)).setLabel("ibmnos-BladeSwitch")
ibmnoscfa = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 102, 27))
pysmi_if = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 102, 27, 1)).setLabel("if")
ifMainTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 102, 27, 1, 4), )
if mibBuilder.loadTexts: ifMainTable.setStatus('current')
if mibBuilder.loadTexts: ifMainTable.setDescription('A list of all the interface entries in the system. This table contains objects which are applicable to all types of interfaces in the system. This table is a proprietary extension to the standard ifTable and ifXTable. The index to this table has the semantics of the MIB-2 ifIndex.')
ifMainEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 102, 27, 1, 4, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ifMainIndex"))
if mibBuilder.loadTexts: ifMainEntry.setStatus('current')
if mibBuilder.loadTexts: ifMainEntry.setDescription('An entry containing management information applicable to a particular interface.')
ifMainIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 102, 27, 1, 4, 1, 1), InterfaceIndex())
if mibBuilder.loadTexts: ifMainIndex.setStatus('current')
if mibBuilder.loadTexts: ifMainIndex.setDescription('A unique value, greater than zero, for each interface. This object is identical to the ifIndex of the standard MIB-2 ifTable.')
ifMainPortName = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 102, 27, 1, 4, 1, 9), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifMainPortName.setStatus('current')
if mibBuilder.loadTexts: ifMainPortName.setDescription('This is used to assign a alias to a port')
ibmnos = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 102, 81))
ibmnosSystem = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 102, 81, 1))
ibmnosConfigControl = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 102, 81, 2))
ibmnosConfigSaveOption = MibScalar((1, 3, 6, 1, 4, 1, 26543, 102, 81, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("noSave", 1), ("flashSave", 2), ("remoteTftpSave", 3), ("startupConfig", 4), ("backupConfig", 5), ("remoteTftpRestore", 6))).clone('noSave')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmnosConfigSaveOption.setStatus('current')
if mibBuilder.loadTexts: ibmnosConfigSaveOption.setDescription("Specifies whether the configurations of the switch has to be saved or not. The value 'noSave' specifies that the configurations need not be saved. The value 'flashSave' specifies that the configurations need to be saved in flash in the specified file name issConfigSaveFileName. The value 'remoteSave' specifies that the configurations need to be saved in specified remote system. The value 'startupConfig' specifies that the configurations need to be saved in flash in the 'Startup Configuration File'. The value 'backupConfig' specifies that the configurations need to be saved in flash in the 'backup Configuration File'. The value 'remoteTftpRestore' specifies that the configurations need to be restored from remote system and saved in the file as indicated by 'ibmnosConfigRemoteType'. This configuration are copied to configuration blocks and applied after restart.")
ibmnosConfigSaveFileName = MibScalar((1, 3, 6, 1, 4, 1, 26543, 102, 81, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 128)).clone('iss.conf')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmnosConfigSaveFileName.setStatus('current')
if mibBuilder.loadTexts: ibmnosConfigSaveFileName.setDescription("Name of the file in which the switch configurations are to be saved. This object is valid only if 'issConfigSaveOption' is chosen to be 'flashSave' or 'remoteSave'.")
ibmnosInitiateConfigSave = MibScalar((1, 3, 6, 1, 4, 1, 26543, 102, 81, 1, 13), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmnosInitiateConfigSave.setStatus('current')
if mibBuilder.loadTexts: ibmnosInitiateConfigSave.setDescription("When set as 'true' switch configurations save operation is initiated. As soon as the configuration save operation is completed, the value of this object reverts back to 'false'. All the configurations made via the three interfaces viz. -> commandline interface -> Web Interface -> SNMP interface are saved either in 'Startup Configuration File' in the flash or in the specified 'issConfigSaveFileName' in the flash or in the chosen remote system, depending upon 'ConfigSaveOption'.")
ibmnosConfigSaveStatus = MibScalar((1, 3, 6, 1, 4, 1, 26543, 102, 81, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("saveInProgress", 1), ("saveSuccessful", 2), ("saveFailed", 3), ("notInitiated", 4), ("saveNotRequired", 5))).clone('notInitiated')).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmnosConfigSaveStatus.setStatus('current')
if mibBuilder.loadTexts: ibmnosConfigSaveStatus.setDescription('Status of configuration save operation.')
ibmnosConfigRestoreOption = MibScalar((1, 3, 6, 1, 4, 1, 26543, 102, 81, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("factory", 1), ("activeConfig", 2), ("backupConfig", 3))).clone('factory')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmnosConfigRestoreOption.setStatus('current')
if mibBuilder.loadTexts: ibmnosConfigRestoreOption.setDescription("Specifies whether the switch configurations have to be restored or not. The value 'factory' specifies that the switch configurations need not be restored when the system is restarted. The value 'activeConfig' specifies that the configurations need to be restored from the 'Startup Configuration File' in the flash when the system is restarted. The value 'backupConfig' specifies that the configurations need to be restored from the 'Backup Configuration File' in the flash when the system is restarted.")
ibmnosLoggingOption = MibScalar((1, 3, 6, 1, 4, 1, 26543, 102, 81, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("console", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmnosLoggingOption.setStatus('current')
if mibBuilder.loadTexts: ibmnosLoggingOption.setDescription('The Logging option specifying whether the logging is to be done at console or to a file(system buffer) in the system.')
ibmnosLoginAuthentication = MibScalar((1, 3, 6, 1, 4, 1, 26543, 102, 81, 1, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("local", 1), ("remoteRadius", 2), ("remoteTacacs", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmnosLoginAuthentication.setStatus('current')
if mibBuilder.loadTexts: ibmnosLoginAuthentication.setDescription('The mechanism by which the user login to access the GUI for configuration has to be authenticated. Authentication is done either locally or in the remote side through a RADIUS Server.')
ibmnosConfigRestoreFileVersion = MibScalar((1, 3, 6, 1, 4, 1, 26543, 102, 81, 1, 40), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmnosConfigRestoreFileVersion.setStatus('current')
if mibBuilder.loadTexts: ibmnosConfigRestoreFileVersion.setDescription('Config Restoration file version. This version will be compared in each reboot against version stored in restoration file. Restoration will occur only if the first field in restoration file is this OID and the RestoreFileVersion value also matches.')
ibmnosPortCtrlTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 102, 81, 2, 2), )
if mibBuilder.loadTexts: ibmnosPortCtrlTable.setStatus('current')
if mibBuilder.loadTexts: ibmnosPortCtrlTable.setDescription('A table to control the port specific parameters of the device like speed, duplex mode, etc.')
ibmnosPortCtrlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 102, 81, 2, 2, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ibmnosPortCtrlIndex"))
if mibBuilder.loadTexts: ibmnosPortCtrlEntry.setStatus('current')
if mibBuilder.loadTexts: ibmnosPortCtrlEntry.setDescription('An entry appears in this table for each interface in the system. Index to the table is the interface index of the port.')
ibmnosPortCtrlIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 102, 81, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: ibmnosPortCtrlIndex.setStatus('current')
if mibBuilder.loadTexts: ibmnosPortCtrlIndex.setDescription('Interface index of the port for which the configuration in this entry applies.')
ibmnosPortCtrlMode = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 102, 81, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("auto", 1), ("noNegotiation", 2))).clone('auto')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmnosPortCtrlMode.setStatus('current')
if mibBuilder.loadTexts: ibmnosPortCtrlMode.setDescription("Speficies the mode in which the speed, duplex modes and flow control of the interface is determined. If set as 'auto', the hardware senses speed and negotiates with the port on the other end of the link for data transfer operation as 'full-duplex' or 'half-duplex' and about flow contol. If set as 'nonegotiation', the configured values for interface speed, duplex mode and flow control will be effective.")
ibmnosPortCtrlDuplex = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 102, 81, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("full", 1), ("half", 2), ("any", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmnosPortCtrlDuplex.setStatus('current')
if mibBuilder.loadTexts: ibmnosPortCtrlDuplex.setDescription("Configures interface data transfer mode as full-duplex or half-duplex. This object can be configured only if the 'PortCtrlMode' is 'nonegotiation'. If the 'PortCtrlMode' is 'auto', it obtains the value 'any'")
ibmnosPortCtrlSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 102, 81, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("tenMBPS", 1), ("hundredMBPS", 2), ("oneGB", 3), ("tenGB", 4), ("any", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmnosPortCtrlSpeed.setStatus('current')
if mibBuilder.loadTexts: ibmnosPortCtrlSpeed.setDescription("Configures interface speed. This object can be configured only if the 'PortCtrlMode' is 'nonegotiation'. If the 'PortCtrlMode' is 'auto', it obtains the value 'any'")
ibmnosPortCtrlFlowControl = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 102, 81, 2, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("send", 3), ("receive", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmnosPortCtrlFlowControl.setStatus('current')
if mibBuilder.loadTexts: ibmnosPortCtrlFlowControl.setDescription("Enables / disables flow control for the interface. This object be configured only if the 'PortCtrlMode' is 'nonegotiation'. If the 'PortCtrlMode' is 'auto', it obtains the value from Hardware after negotiating with its peer")
toraddon = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 102, 102))
cfa = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 102, 102, 2))
sys = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 102, 102, 7))
ibmnosFdb = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 102, 102, 13))
tor_switch = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 102, 102, 14)).setLabel("tor-switch")
ibmnosBladeHarmony = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 102, 102, 18))
dataCollection = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 102, 102, 18, 1))
imageConfigTransfer = MibIdentifier((1, 3, 6, 1, 4, 1, 26543, 102, 102, 18, 3))
ibmnosFdbTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 102, 102, 13, 5), )
if mibBuilder.loadTexts: ibmnosFdbTable.setStatus('current')
if mibBuilder.loadTexts: ibmnosFdbTable.setDescription('The table of FDB entries.')
ibmnosFdbEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 102, 102, 13, 5, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ibmnosFdbVlan"), (0, "IBM-GbTOR-10G-L2L3-MIB", "ibmnosFdbMacAddr"))
if mibBuilder.loadTexts: ibmnosFdbEntry.setStatus('current')
if mibBuilder.loadTexts: ibmnosFdbEntry.setDescription('A row in the FDB table')
ibmnosFdbVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 102, 102, 13, 5, 1, 1), Integer32())
if mibBuilder.loadTexts: ibmnosFdbVlan.setStatus('current')
if mibBuilder.loadTexts: ibmnosFdbVlan.setDescription('The VLAN ID for the FDB entry.')
ibmnosFdbMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 102, 102, 13, 5, 1, 2), PhysAddress())
if mibBuilder.loadTexts: ibmnosFdbMacAddr.setStatus('current')
if mibBuilder.loadTexts: ibmnosFdbMacAddr.setDescription('The MAC address for the FDB entry.')
ibmnosFdbMacAddrStr = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 102, 102, 13, 5, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmnosFdbMacAddrStr.setStatus('current')
if mibBuilder.loadTexts: ibmnosFdbMacAddrStr.setDescription('The MAC address in hex format for the FDB entry. This node is added for display purpose.')
ibmnosFdbVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 102, 102, 13, 5, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmnosFdbVlanId.setStatus('current')
if mibBuilder.loadTexts: ibmnosFdbVlanId.setDescription('The VLAN ID for the FDB entry. This node is added for display purpose.')
ibmnosFdbSrcPort = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 102, 102, 13, 5, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmnosFdbSrcPort.setStatus('current')
if mibBuilder.loadTexts: ibmnosFdbSrcPort.setDescription("Either the value '0', or the port number of the port on which a frame having a source address equal to the value of the corresponding instance has been seen. A value of '0' indicates that the port number has not been learned but that the bridge does have some forwarding/filtering information about this address.")
ibmnosFdbSrcTrunk = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 102, 102, 13, 5, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmnosFdbSrcTrunk.setStatus('current')
if mibBuilder.loadTexts: ibmnosFdbSrcTrunk.setDescription("Either the value '0', or the trunk number of the trunk on which a frame having a source address equal to the value of the corresponding instance has been seen. A value of '0' indicates that the source address is not associated with a trunk.")
ibmnosFdbState = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 102, 102, 13, 5, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("forward", 2), ("trunk", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmnosFdbState.setStatus('current')
if mibBuilder.loadTexts: ibmnosFdbState.setDescription('The state of the FDB entry. The meanings of the values are : unknown(1) : the MAC address has not yet been learned by the switch but has only been seen as a destination address forward(2) : the MAC address has been learned by the switch trunk(3) : frames with this MAC address are forwarded to trunk group')
ibmnosFdbStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 102, 102, 13, 5, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmnosFdbStatus.setStatus('current')
if mibBuilder.loadTexts: ibmnosFdbStatus.setDescription("'1' if it is permanent '0' if it is not permanent")
ibmnosFdbClearMac = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 102, 102, 13, 5, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("clear", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmnosFdbClearMac.setStatus('current')
if mibBuilder.loadTexts: ibmnosFdbClearMac.setDescription('Setting this value to clear(2) clears the corresponding table entry in FDB.')
ibmnosPortCfgTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 102, 102, 2, 1), )
if mibBuilder.loadTexts: ibmnosPortCfgTable.setStatus('current')
if mibBuilder.loadTexts: ibmnosPortCfgTable.setDescription('The table of port configuration in the new_configuration block.')
ibmnosPortCfgTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 102, 102, 2, 1, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ibmnosPortCfgIndx"))
if mibBuilder.loadTexts: ibmnosPortCfgTableEntry.setStatus('current')
if mibBuilder.loadTexts: ibmnosPortCfgTableEntry.setDescription('A row in the port configuration table in the new_configuration block.')
ibmnosPortCfgIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 102, 102, 2, 1, 1, 1), Integer32())
if mibBuilder.loadTexts: ibmnosPortCfgIndx.setStatus('current')
if mibBuilder.loadTexts: ibmnosPortCfgIndx.setDescription('The index of the row in port configurations table.')
ibmnosPortCfgVlanTag = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 102, 102, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmnosPortCfgVlanTag.setStatus('current')
if mibBuilder.loadTexts: ibmnosPortCfgVlanTag.setDescription('VLAN tag configured for the port')
agImageForNextReset = MibScalar((1, 3, 6, 1, 4, 1, 26543, 102, 102, 7, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("image1", 2), ("image2", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agImageForNextReset.setStatus('current')
if mibBuilder.loadTexts: agImageForNextReset.setDescription('The software image to be booted from at next reset. The following values are writable: image1(2)...image 1 image2(3)...image 2')
hardwarePartNumber = MibScalar((1, 3, 6, 1, 4, 1, 26543, 102, 102, 14, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hardwarePartNumber.setStatus('current')
if mibBuilder.loadTexts: hardwarePartNumber.setDescription('The hardware part number of the Blade Switch.')
hardwareRevision = MibScalar((1, 3, 6, 1, 4, 1, 26543, 102, 102, 14, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hardwareRevision.setStatus('current')
if mibBuilder.loadTexts: hardwareRevision.setDescription('The hardware revision. If the revision is not available, a zero length string should be returned.')
hardwareLastBoot = MibScalar((1, 3, 6, 1, 4, 1, 26543, 102, 102, 14, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("unkownReason", 0), ("powerCycle", 1), ("resetFromConsole", 2), ("resetFromTelnetOrSSH", 3), ("resetFromSNMP", 4), ("resetFromWEBUI", 5), ("resetFromScheduled", 6), ("resetFromWatchdogTimer", 7), ("resetFromSWPANIC", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hardwareLastBoot.setStatus('current')
if mibBuilder.loadTexts: hardwareLastBoot.setDescription('Reason of the last boot. ')
hardwareMACAddress = MibScalar((1, 3, 6, 1, 4, 1, 26543, 102, 102, 14, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 48))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hardwareMACAddress.setStatus('current')
if mibBuilder.loadTexts: hardwareMACAddress.setDescription('The MAC address.')
hardwareSwitchRunningSwVersion = MibScalar((1, 3, 6, 1, 4, 1, 26543, 102, 102, 14, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hardwareSwitchRunningSwVersion.setStatus('current')
if mibBuilder.loadTexts: hardwareSwitchRunningSwVersion.setDescription('The switch software version.')
hardwareFlashConfiguration = MibScalar((1, 3, 6, 1, 4, 1, 26543, 102, 102, 14, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("factory", 0), ("active", 1), ("backup", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hardwareFlashConfiguration.setStatus('current')
if mibBuilder.loadTexts: hardwareFlashConfiguration.setDescription('The active flash configuration.')
hardwarePCBAPartNumber = MibScalar((1, 3, 6, 1, 4, 1, 26543, 102, 102, 14, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hardwarePCBAPartNumber.setStatus('current')
if mibBuilder.loadTexts: hardwarePCBAPartNumber.setDescription('The PCBA part number.')
hardwareFABNumber = MibScalar((1, 3, 6, 1, 4, 1, 26543, 102, 102, 14, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hardwareFABNumber.setStatus('current')
if mibBuilder.loadTexts: hardwareFABNumber.setDescription('FAB Number')
hardwareSerialNumber = MibScalar((1, 3, 6, 1, 4, 1, 26543, 102, 102, 14, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hardwareSerialNumber.setStatus('current')
if mibBuilder.loadTexts: hardwareSerialNumber.setDescription('The switch serial number.')
hardwareManufacturingDate = MibScalar((1, 3, 6, 1, 4, 1, 26543, 102, 102, 14, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hardwareManufacturingDate.setStatus('current')
if mibBuilder.loadTexts: hardwareManufacturingDate.setDescription('The date of manufacturing.')
hwTemperatureSensor1 = MibScalar((1, 3, 6, 1, 4, 1, 26543, 102, 102, 14, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwTemperatureSensor1.setStatus('current')
if mibBuilder.loadTexts: hwTemperatureSensor1.setDescription('The temperature sensor 1.')
hwTemperatureSensor2 = MibScalar((1, 3, 6, 1, 4, 1, 26543, 102, 102, 14, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwTemperatureSensor2.setStatus('current')
if mibBuilder.loadTexts: hwTemperatureSensor2.setDescription('The temperature sensor 2.')
hwTemperatureSensor3 = MibScalar((1, 3, 6, 1, 4, 1, 26543, 102, 102, 14, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwTemperatureSensor3.setStatus('current')
if mibBuilder.loadTexts: hwTemperatureSensor3.setDescription('The temperature sensor 3.')
hwFan1RPMValue = MibScalar((1, 3, 6, 1, 4, 1, 26543, 102, 102, 14, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwFan1RPMValue.setStatus('current')
if mibBuilder.loadTexts: hwFan1RPMValue.setDescription('The Fan 1 RPM value.')
hwFan2RPMValue = MibScalar((1, 3, 6, 1, 4, 1, 26543, 102, 102, 14, 15), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 48))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwFan2RPMValue.setStatus('current')
if mibBuilder.loadTexts: hwFan2RPMValue.setDescription('The Fan 2 RPM value.')
hwFan3RPMValue = MibScalar((1, 3, 6, 1, 4, 1, 26543, 102, 102, 14, 16), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 48))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwFan3RPMValue.setStatus('current')
if mibBuilder.loadTexts: hwFan3RPMValue.setDescription('The Fan 3 RPM value.')
hwFan4RPMValue = MibScalar((1, 3, 6, 1, 4, 1, 26543, 102, 102, 14, 17), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 48))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwFan4RPMValue.setStatus('current')
if mibBuilder.loadTexts: hwFan4RPMValue.setDescription('The Fan 4 RPM value.')
hwFan5RPMValue = MibScalar((1, 3, 6, 1, 4, 1, 26543, 102, 102, 14, 18), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 48))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwFan5RPMValue.setStatus('current')
if mibBuilder.loadTexts: hwFan5RPMValue.setDescription('The Fan 5 RPM value.')
hwBoardRevision = MibScalar((1, 3, 6, 1, 4, 1, 26543, 102, 102, 14, 19), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 48))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwBoardRevision.setStatus('current')
if mibBuilder.loadTexts: hwBoardRevision.setDescription('The Board revision number.')
hwPowerSupply1State = MibScalar((1, 3, 6, 1, 4, 1, 26543, 102, 102, 14, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("off", 0), ("on", 1), ("absent", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPowerSupply1State.setStatus('current')
if mibBuilder.loadTexts: hwPowerSupply1State.setDescription('The Power Supply 1 state.')
hwPowerSupply2State = MibScalar((1, 3, 6, 1, 4, 1, 26543, 102, 102, 14, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("off", 0), ("on", 1), ("absent", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPowerSupply2State.setStatus('current')
if mibBuilder.loadTexts: hwPowerSupply2State.setDescription('The Power Supply 2 state.')
ibmnosSfpInfoTable = MibTable((1, 3, 6, 1, 4, 1, 26543, 102, 102, 14, 22), )
if mibBuilder.loadTexts: ibmnosSfpInfoTable.setStatus('current')
if mibBuilder.loadTexts: ibmnosSfpInfoTable.setDescription('The table of external port SFP information.')
ibmnosSfpInfoTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 26543, 102, 102, 14, 22, 1), ).setIndexNames((0, "IBM-GbTOR-10G-L2L3-MIB", "ibmnosSfpInfoIndx"))
if mibBuilder.loadTexts: ibmnosSfpInfoTableEntry.setStatus('current')
if mibBuilder.loadTexts: ibmnosSfpInfoTableEntry.setDescription('A row in the external port SFP information table.')
ibmnosSfpInfoIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 102, 102, 14, 22, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmnosSfpInfoIndx.setStatus('current')
if mibBuilder.loadTexts: ibmnosSfpInfoIndx.setDescription('Sfp Info index (port number)')
ibmnosSfpInfoDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 102, 102, 14, 22, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 6))).clone(namedValues=NamedValues(("none", 0), ("sfp", 1), ("cx4", 2), ("sfpplus", 3), ("dac", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmnosSfpInfoDescription.setStatus('current')
if mibBuilder.loadTexts: ibmnosSfpInfoDescription.setDescription('Type Ethernet device (None(0), SFP(1), CX4(2), SFPplus(3), DAC(6))')
ibmnosSfpInfoSerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 102, 102, 14, 22, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmnosSfpInfoSerialNumber.setStatus('current')
if mibBuilder.loadTexts: ibmnosSfpInfoSerialNumber.setDescription('Serial Number.')
ibmnosSfpInfoPartNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 102, 102, 14, 22, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmnosSfpInfoPartNumber.setStatus('current')
if mibBuilder.loadTexts: ibmnosSfpInfoPartNumber.setDescription('Part Number.')
ibmnosSfpInfoHWRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 26543, 102, 102, 14, 22, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmnosSfpInfoHWRevision.setStatus('current')
if mibBuilder.loadTexts: ibmnosSfpInfoHWRevision.setDescription('Hardware Revision')
swImage1Version = MibScalar((1, 3, 6, 1, 4, 1, 26543, 102, 102, 14, 24), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swImage1Version.setStatus('current')
if mibBuilder.loadTexts: swImage1Version.setDescription('Software image1 version')
swImage2Version = MibScalar((1, 3, 6, 1, 4, 1, 26543, 102, 102, 14, 25), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swImage2Version.setStatus('current')
if mibBuilder.loadTexts: swImage2Version.setDescription('Software image2 version')
swBootVersion = MibScalar((1, 3, 6, 1, 4, 1, 26543, 102, 102, 14, 26), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swBootVersion.setStatus('current')
if mibBuilder.loadTexts: swBootVersion.setDescription('Software boot version')
hwFan6RPMValue = MibScalar((1, 3, 6, 1, 4, 1, 26543, 102, 102, 14, 27), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 48))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwFan6RPMValue.setStatus('current')
if mibBuilder.loadTexts: hwFan6RPMValue.setDescription('The Fan 6 RPM value.')
hwTemperatureSensor4 = MibScalar((1, 3, 6, 1, 4, 1, 26543, 102, 102, 14, 32), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwTemperatureSensor4.setStatus('current')
if mibBuilder.loadTexts: hwTemperatureSensor4.setDescription('The temperature sensor 4.')
hwTemperatureSensor5 = MibScalar((1, 3, 6, 1, 4, 1, 26543, 102, 102, 14, 33), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwTemperatureSensor5.setStatus('current')
if mibBuilder.loadTexts: hwTemperatureSensor5.setDescription('The temperature sensor 5.')
ibmnosPortTableMaxEnt = MibScalar((1, 3, 6, 1, 4, 1, 26543, 102, 102, 18, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmnosPortTableMaxEnt.setStatus('current')
if mibBuilder.loadTexts: ibmnosPortTableMaxEnt.setDescription('The maximum number of rows in the port configuration host table.')
ibmnosImage1Ver = MibScalar((1, 3, 6, 1, 4, 1, 26543, 102, 102, 18, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmnosImage1Ver.setStatus('current')
if mibBuilder.loadTexts: ibmnosImage1Ver.setDescription("The version of the software image stored in image 1 storage in the form of 'major.minor.bugfix'. A zero length string is returned if version is not available or there is no valid software image.")
ibmnosImage2Ver = MibScalar((1, 3, 6, 1, 4, 1, 26543, 102, 102, 18, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmnosImage2Ver.setStatus('current')
if mibBuilder.loadTexts: ibmnosImage2Ver.setDescription("The version of the software image stored in image 2 storage in the form of 'major.minor.bugfix'. A zero length string is returned if version is not available or there is no valid software image.")
hwSwitchSoftwareVersion = MibScalar((1, 3, 6, 1, 4, 1, 26543, 102, 102, 18, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwSwitchSoftwareVersion.setStatus('current')
if mibBuilder.loadTexts: hwSwitchSoftwareVersion.setDescription('The switch software version.')
hwSerialNum = MibScalar((1, 3, 6, 1, 4, 1, 26543, 102, 102, 18, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 48))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwSerialNum.setStatus('current')
if mibBuilder.loadTexts: hwSerialNum.setDescription('The switch serial number.')
hwManufacturingDate = MibScalar((1, 3, 6, 1, 4, 1, 26543, 102, 102, 18, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 48))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwManufacturingDate.setStatus('current')
if mibBuilder.loadTexts: hwManufacturingDate.setDescription('The date of manufacturing.')
ibmnosReset = MibScalar((1, 3, 6, 1, 4, 1, 26543, 102, 102, 18, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmnosReset.setStatus('current')
if mibBuilder.loadTexts: ibmnosReset.setDescription('This is an action object to reboot the agent. other(1) is returned always when read.')
ibmnosBootVer = MibScalar((1, 3, 6, 1, 4, 1, 26543, 102, 102, 18, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmnosBootVer.setStatus('current')
if mibBuilder.loadTexts: ibmnosBootVer.setDescription("The version of the boot code in the form of 'major.minor.bugfix'. A zero length string is returned if version is not available.")
ibmnosConfigForNxtReset = MibScalar((1, 3, 6, 1, 4, 1, 26543, 102, 102, 18, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("active", 2), ("backup", 3), ("default", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmnosConfigForNxtReset.setStatus('current')
if mibBuilder.loadTexts: ibmnosConfigForNxtReset.setDescription('The configuration information to be loaded from at next reset. The following values are writable: active(2)...active configuration block backup(3)...backup configuration block default(4)..default configuration block')
ibmnosSoftwareVersion = MibScalar((1, 3, 6, 1, 4, 1, 26543, 102, 102, 18, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmnosSoftwareVersion.setStatus('current')
if mibBuilder.loadTexts: ibmnosSoftwareVersion.setDescription("The version of the software image that is currently running on the system in the form of 'major.minor.maintenance.bugfix'. A zero length string is returned if version is not available.")
agTftpServer = MibScalar((1, 3, 6, 1, 4, 1, 26543, 102, 102, 18, 3, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agTftpServer.setStatus('current')
if mibBuilder.loadTexts: agTftpServer.setDescription('The TFTP server IP address or domain name.')
mibBuilder.exportSymbols("IBM-GbTOR-10G-L2L3-MIB", ospf3IntfInfoTable=ospf3IntfInfoTable, ospfAreaIntfHello=ospfAreaIntfHello, clearPortsStats=clearPortsStats, ospf3IntfTableMaxSize=ospf3IntfTableMaxSize, ipNewCfgBootpOpt82State=ipNewCfgBootpOpt82State, vmNewCfgGroupMacVMMac=vmNewCfgGroupMacVMMac, swTeamingCtrlDown=swTeamingCtrlDown, swLACPPortUnblocked=swLACPPortUnblocked, ospf3AreaInfoVirtNeighborsFULLstate=ospf3AreaInfoVirtNeighborsFULLstate, stpInfoPortDesignatedRoot=stpInfoPortDesignatedRoot, bgpCurCfgGroupRASTable=bgpCurCfgGroupRASTable, ipStaticRouteNewEcmpHash=ipStaticRouteNewEcmpHash, ospf3IntfTxDatabase=ospf3IntfTxDatabase, ipNewCfgNwfState=ipNewCfgNwfState, ospf3CurCfgRedistPrefixLen=ospf3CurCfgRedistPrefixLen, ripCurCfgIbgpOutRmapList=ripCurCfgIbgpOutRmapList, portOperState=portOperState, fdbStats=fdbStats, aclCurCfgProtocol=aclCurCfgProtocol, bgpCurCfgGroupInRmapList=bgpCurCfgGroupInRmapList, igmpFltCurCfgTable=igmpFltCurCfgTable, vmNewCfgGroupMaclistEntry=vmNewCfgGroupMaclistEntry, ospfLoopIfInfoHello=ospfLoopIfInfoHello, agCurCfgSyslogTrapRmon=agCurCfgSyslogTrapRmon, stpInfoPortDesignatedCost=stpInfoPortDesignatedCost, virtVMwareVMInfoIPAddr=virtVMwareVMInfoIPAddr, swECMPGatewayDown=swECMPGatewayDown, ospf3CurCfgRedistEntry=ospf3CurCfgRedistEntry, ospf3AreaInfoEntry=ospf3AreaInfoEntry, hardwareLastBoot=hardwareLastBoot, vlagInfoIslPortState=vlagInfoIslPortState, agCfgMtm=agCfgMtm, ipCurCfgAlistNwf=ipCurCfgAlistNwf, ipNewCfgStaticNbrIndx=ipNewCfgStaticNbrIndx, ospfCurCfgRangeEntry=ospfCurCfgRangeEntry, sflowNewPortSampling=sflowNewPortSampling, acl6CurCfgIndex=acl6CurCfgIndex, ipv6icmpInDstUnreach=ipv6icmpInDstUnreach, ospfAreaNbrChangeStatsEntry=ospfAreaNbrChangeStatsEntry, ripInfoIntfAddress=ripInfoIntfAddress, lldpInfoTxTransmitDelay=lldpInfoTxTransmitDelay, agPortNewCfgLinkType=agPortNewCfgLinkType, agPortNewCfgMulticastThresholdRate=agPortNewCfgMulticastThresholdRate, vlagStatsPduRcvISLHello=vlagStatsPduRcvISLHello, lacpInfoPortActOpAggr=lacpInfoPortActOpAggr, ipNewCfgStaticRouteIndx=ipNewCfgStaticRouteIndx, ipNewCfgGwIpv6State=ipNewCfgGwIpv6State, mpCpuStats=mpCpuStats, portStatsTableEntry=portStatsTableEntry, agDiffTableEntry=agDiffTableEntry, virtVMwareVMNameTable=virtVMwareVMNameTable, icmpStatsOutRedirects=icmpStatsOutRedirects, ipsecNewCfgManualPolicyOutAhKey=ipsecNewCfgManualPolicyOutAhKey, ospf3NewCfgRedistAddr=ospf3NewCfgRedistAddr, agNewCfgCpuRateLimitBpdu=agNewCfgCpuRateLimitBpdu, traps=traps, ipNewCfgStaticNbrAction=ipNewCfgStaticNbrAction, aclLog=aclLog, igmpFltCurCfgAction=igmpFltCurCfgAction, aclNewCfgFilterActionSetPrio=aclNewCfgFilterActionSetPrio, agCurCfgMgmtNetIndex=agCurCfgMgmtNetIndex, serverPortsCurCfgPorts=serverPortsCurCfgPorts, txMldIfStatsAllowSlcrsv2=txMldIfStatsAllowSlcrsv2, mcastFdbNewCfgEntry=mcastFdbNewCfgEntry, ripCurCfgIntfState=ripCurCfgIntfState, ibmnosFdbTable=ibmnosFdbTable, aclNewCfgReset=aclNewCfgReset, ipsecCurCfgTxformEntry=ipsecCurCfgTxformEntry, igmpCurVlanOperVersion=igmpCurVlanOperVersion, icmpStatsOutDestUnreachs=icmpStatsOutDestUnreachs, virtCurCfgVirtCenterUser=virtCurCfgVirtCenterUser, ipsecSaInfoAuthKey=ipsecSaInfoAuthKey, ospf3NssaAsbrDefRtTrans=ospf3NssaAsbrDefRtTrans, vrrpStatInAdvers=vrrpStatInAdvers, ipsecCurCfgDynamicPolicyDelete=ipsecCurCfgDynamicPolicyDelete, acl6CurCfgFilterAction=acl6CurCfgFilterAction, igmpFltNewCfgMcastIp2=igmpFltNewCfgMcastIp2, oamInfoPortTable=oamInfoPortTable, vmapVlanCurCfgServerPortsTableEntry=vmapVlanCurCfgServerPortsTableEntry, agNewCfgSyslogFac=agNewCfgSyslogFac, agCurCfgLoginBanner=agCurCfgLoginBanner, l2ThashNewCfgSipState=l2ThashNewCfgSipState, fipsPortCurCfgTable=fipsPortCurCfgTable, agPortNewCfgStpExtGuard=agPortNewCfgStpExtGuard, tcpStatsOutRsts=tcpStatsOutRsts, vlagInfoIslGroup=vlagInfoIslGroup, lacpInfoCollDetState=lacpInfoCollDetState, ospf3RoutesInfoAreaId=ospf3RoutesInfoAreaId, portStatsPhyIfOutFctlPktsRate=portStatsPhyIfOutFctlPktsRate, lacpInfoPortActAdDist=lacpInfoPortActAdDist, hwTemperatureSensor2=hwTemperatureSensor2, bgpInfoIndex=bgpInfoIndex, sshNewCfgScpAdm=sshNewCfgScpAdm, vlagCurCfgGlobalEnable=vlagCurCfgGlobalEnable, ospfCurCfgIbgpOutRmapList=ospfCurCfgIbgpOutRmapList, lacpNewSystemPriority=lacpNewSystemPriority, ipv6OutNadvs=ipv6OutNadvs, fipsCfg=fipsCfg, failoverInfoTriggerMonPortEntry=failoverInfoTriggerMonPortEntry, ipv6OutDiscards=ipv6OutDiscards, ipCurCfgIntfBootpRelay=ipCurCfgIntfBootpRelay, ikeNewCfgPsk=ikeNewCfgPsk, vrrpCurCfgVirtRtrIndx=vrrpCurCfgVirtRtrIndx, ospf3IntfNbrChangeStats=ospf3IntfNbrChangeStats, cfa=cfa, tcpStatsAttemptFails=tcpStatsAttemptFails, ipNewCfgBootpBcastDomainEnable=ipNewCfgBootpBcastDomainEnable, ospf3VirtIfInfoRtrDeadInterval=ospf3VirtIfInfoRtrDeadInterval, ipsecNewCfgManualPolicyIndex=ipsecNewCfgManualPolicyIndex, ipv6icmpOutTmexceeded=ipv6icmpOutTmexceeded, agNewCfgMgmtNetSubnet=agNewCfgMgmtNetSubnet, igmpSnoopCurCfgVlanBmap=igmpSnoopCurCfgVlanBmap, ripRedistributeEbgp=ripRedistributeEbgp, state=state, swPrimaryPowerSupplyFixed=swPrimaryPowerSupplyFixed, fipsNewAutoVlan=fipsNewAutoVlan, ospfNewCfgFixedAddOutRmap=ospfNewCfgFixedAddOutRmap, hwTemperatureSensor5=hwTemperatureSensor5, lacpNewSystemSetToDefault=lacpNewSystemSetToDefault, ipsecCurCfgDynamicPolicyIndex=ipsecCurCfgDynamicPolicyIndex, ospfLoopIfInfoBackupDesignatedRouterIpAddress=ospfLoopIfInfoBackupDesignatedRouterIpAddress, agReset=agReset, ospfMdkeyTableMaxSize=ospfMdkeyTableMaxSize, ospfNewCfgRangeMask=ospfNewCfgRangeMask, bgpInfoPeerTable=bgpInfoPeerTable, agLog=agLog, routeStatRipEntries=routeStatRipEntries, ripNewCfgOspfOutRmapList=ripNewCfgOspfOutRmapList, aclNewCfgPortTable=aclNewCfgPortTable, igmpStaticMrtrNewCfgClear=igmpStaticMrtrNewCfgClear, tcpControlBlocksTable=tcpControlBlocksTable, ripRedistributeStatic=ripRedistributeStatic, fcoeStatsTable=fcoeStatsTable, ospf3NewCfgSpfDelay=ospf3NewCfgSpfDelay, fipsInfoVlansId=fipsInfoVlansId, lacpInfoPortLacpEna=lacpInfoPortLacpEna, igmpStaticMrtrNewCfgVlanId=igmpStaticMrtrNewCfgVlanId, vrrpCurCfgVirtRtrInterval=vrrpCurCfgVirtRtrInterval, ospfVirtIntfInfoTable=ospfVirtIntfInfoTable, agSyslogMsgTable=agSyslogMsgTable, ipsecSaInfoDstAddr=ipsecSaInfoDstAddr, ospfNewCfgAreaDelete=ospfNewCfgAreaDelete, lldpInfoRxBadFrame=lldpInfoRxBadFrame, ibmnosFdbSrcPort=ibmnosFdbSrcPort, ospfSumRangesInfoArea=ospfSumRangesInfoArea, ospf3CurCfgRedistRouteTag=ospf3CurCfgRedistRouteTag, ospfNewCfgIntfPassive=ospfNewCfgIntfPassive, ospf3IntfIndex=ospf3IntfIndex, agNewBootNxtCliMode=agNewBootNxtCliMode, acl6StatsTableEntry=acl6StatsTableEntry, mstCistCurCfgPortStpState=mstCistCurCfgPortStpState, ospf3AreaErrOptionsMismatch=ospf3AreaErrOptionsMismatch, ospfNewCfgMdkeyDelete=ospfNewCfgMdkeyDelete, acl6CurCfgUser=acl6CurCfgUser, agNewCfgDhcpMgta=agNewCfgDhcpMgta, stgStatsStpIndex=stgStatsStpIndex, vmNewCfgGroupMacGroupIndex=vmNewCfgGroupMacGroupIndex, agCurCfgErrDisableRecovery=agCurCfgErrDisableRecovery, vmapCurCfgKbitsBurst=vmapCurCfgKbitsBurst, aclCurCfgStatistics=aclCurCfgStatistics, udldInfoNeighborIndex=udldInfoNeighborIndex, tacCurBypassEnable=tacCurBypassEnable, ospfIntfIndex=ospfIntfIndex, agCurCfgSyslogTrapSystem=agCurCfgSyslogTrapSystem, ipmcNewCfgStaticRouteRemTrunk=ipmcNewCfgStaticRouteRemTrunk, ipNewCfgBootpGlobalServerTable=ipNewCfgBootpGlobalServerTable, ecpChnlRxCnt=ecpChnlRxCnt, vmbwCurCfgMac=vmbwCurCfgMac, ndprefixCurCfgPreferredLifetime=ndprefixCurCfgPreferredLifetime, mldInfoInterfaceQuerierExpiryTime=mldInfoInterfaceQuerierExpiryTime, igmpSnoopNewCfgSrcIp=igmpSnoopNewCfgSrcIp, qosNewCfgDscpState=qosNewCfgDscpState, igmpStaticMrtrNewCfgPortId=igmpStaticMrtrNewCfgPortId, failoverNewCfgTriggerTable=failoverNewCfgTriggerTable, acl6NewCfgTCPFlags=acl6NewCfgTCPFlags, portInfoSpeed=portInfoSpeed, qos8021p=qos8021p, mldInfoInterfaceState=mldInfoInterfaceState, igmpSnoopNewCfgRtrAlert=igmpSnoopNewCfgRtrAlert, acl6CurCfgStatistics=acl6CurCfgStatistics, ipEcmpRoutingInfo=ipEcmpRoutingInfo, aclStatsIndex=aclStatsIndex, bgpNewCfgGroupNexthopSelf=bgpNewCfgGroupNexthopSelf, ospf3RoutesInfoType2Cost=ospf3RoutesInfoType2Cost, agNewCfgSyslogTrapIgmpGroup=agNewCfgSyslogTrapIgmpGroup, ospfIntfTxlsUpdates=ospfIntfTxlsUpdates, ipsecNewCfgManualPolicyInEspSpi=ipsecNewCfgManualPolicyInEspSpi, accessUserInfoClearLock=accessUserInfoClearLock, qosNewCfgMapDscp=qosNewCfgMapDscp, vlagInfoAdminRole=vlagInfoAdminRole, stpInfoPortState=stpInfoPortState, swSaveComplete=swSaveComplete, virtVMwareHostVswitchTable=virtVMwareHostVswitchTable, fipsCurAutoVlan=fipsCurAutoVlan, bgpNewCfgAsn4Comp=bgpNewCfgAsn4Comp, fdbStatsHiwat=fdbStatsHiwat, aclCurCfgSrcIPAddress=aclCurCfgSrcIPAddress, aclNewCfgEntry=aclNewCfgEntry, ripCurCfgEospfMetric=ripCurCfgEospfMetric, hardwareSerialNumber=hardwareSerialNumber, ospf3CurCfgIntfStatus=ospf3CurCfgIntfStatus, ospf3CurCfgRangeIndex=ospf3CurCfgRangeIndex, ipStatsInDelivers=ipStatsInDelivers, vmapStatsIndex=vmapStatsIndex, agSystem=agSystem, igmpV3SnoopNewCfgSources=igmpV3SnoopNewCfgSources, hardwareRevision=hardwareRevision, ipv6icmpOutErrs=ipv6icmpOutErrs, agNewCfgSyslogHost=agNewCfgSyslogHost, vnicNewCfgGroupState=vnicNewCfgGroupState, fipsInfoVlansEntry=fipsInfoVlansEntry, hwPartNumber=hwPartNumber, trunkGroupInfoProtocol=trunkGroupInfoProtocol, tacCurCfgTimeout=tacCurCfgTimeout, ospf3AreaInfoASBoundaryRouter=ospf3AreaInfoASBoundaryRouter, vnicCurCfgGroupVlan=vnicCurCfgGroupVlan, gatewayInfoAddr=gatewayInfoAddr, sshNewCfgHKeyGen=sshNewCfgHKeyGen, ipsecSpdInfoSaSecuProto=ipsecSpdInfoSaSecuProto, allportsStatsOutErrorsRate=allportsStatsOutErrorsRate, geaportInfoPort=geaportInfoPort, virtVMwareHostNameUUID=virtVMwareHostNameUUID, ospfAreaIntfLoop=ospfAreaIntfLoop, agRackId=agRackId, cpuProcessUtil1Sec=cpuProcessUtil1Sec, ospf3NewCfgIntfHello=ospf3NewCfgIntfHello, mldIfStatsIfIndex=mldIfStatsIfIndex, agAccessUserMaxUserID=agAccessUserMaxUserID, vnicCurCfgGroupEntry=vnicCurCfgGroupEntry, acl6NewCfgStatistics=acl6NewCfgStatistics, vmNewCfgCheck=vmNewCfgCheck, igmpSnoopNewCfgVlanFastlvBmap=igmpSnoopNewCfgVlanFastlvBmap, ibmnos_BladeSwitch=ibmnos_BladeSwitch, ipCurCfgBootpBcastDomainIndex=ipCurCfgBootpBcastDomainIndex, agTransferImageFileName=agTransferImageFileName, mldNewInterfaceState=mldNewInterfaceState, ipsecGroup=ipsecGroup, virtCurCfgVMwareHelloPorts=virtCurCfgVMwareHelloPorts, ripNewCfgIntfSupply=ripNewCfgIntfSupply, ospf3IntfErrRxZeroRTRID=ospf3IntfErrRxZeroRTRID, igmpSnoopNewCfgVlanFastlvRem=igmpSnoopNewCfgVlanFastlvRem, mstCistNewCfgPortTableEntry=mstCistNewCfgPortTableEntry, agNewCfgSyslogTrapBgp=agNewCfgSyslogTrapBgp, bgpCurCfgPeerClient=bgpCurCfgPeerClient, acl6NewCfgInprofDscp=acl6NewCfgInprofDscp, allportsStatsPhysAddress=allportsStatsPhysAddress, ospf3NewCfgExtRangeAreaIndex=ospf3NewCfgExtRangeAreaIndex, agNewCfgSyslogTrapIpv6=agNewCfgSyslogTrapIpv6, bgpCurCfgEbgpMaxPaths=bgpCurCfgEbgpMaxPaths, bgpCurCfgGroupName=bgpCurCfgGroupName, ripInfoIntfMcastUpdate=ripInfoIntfMcastUpdate, ceeCurCfgState=ceeCurCfgState, failoverMaxTriggerEntries=failoverMaxTriggerEntries, nsnmpInBadCommunityNames=nsnmpInBadCommunityNames)
mibBuilder.exportSymbols("IBM-GbTOR-10G-L2L3-MIB", ipStaticRouteNewPingInterval=ipStaticRouteNewPingInterval, agTransferCaFileName=agTransferCaFileName, udldInfo=udldInfo, ceeConfig=ceeConfig, ipsecNewCfgManualPolicyTable=ipsecNewCfgManualPolicyTable, vrrpNewCfgVirtRtrPreempt=vrrpNewCfgVirtRtrPreempt, ipNewCfgIntfTable=ipNewCfgIntfTable, ipRmapCfg=ipRmapCfg, mldNewInterfaceQueryMaxResponseIntvl=mldNewInterfaceQueryMaxResponseIntvl, ipRouteEcmpInfoGwIndx=ipRouteEcmpInfoGwIndx, udldInfoPortIndex=udldInfoPortIndex, agCurCfgSyslogTrapBgp=agCurCfgSyslogTrapBgp, ospf3NewCfgNbrPriority=ospf3NewCfgNbrPriority, ipsecCurCfgSelectorEntry=ipsecCurCfgSelectorEntry, tacCurCfgPorttoUse=tacCurCfgPorttoUse, vrrpNewCfgVirtRtrFastAdvertisement=vrrpNewCfgVirtRtrFastAdvertisement, ospf3IfInfoDesignatedRouterID=ospf3IfInfoDesignatedRouterID, ospf3IntfNbrAllEvents=ospf3IntfNbrAllEvents, vrrpOperVirtRtrBackup=vrrpOperVirtRtrBackup, agPortNewCfgDLFThresholdRate=agPortNewCfgDLFThresholdRate, agTransferCfgFileName=agTransferCfgFileName, agNewCfgSyslogTrapRmon=agNewCfgSyslogTrapRmon, ospfCurCfgVirtIntfEntry=ospfCurCfgVirtIntfEntry, ospf3NewCfgNbrTable=ospf3NewCfgNbrTable, stgCurCfgBrgForwardDelay=stgCurCfgBrgForwardDelay, ospfLoopIfInfoPtop=ospfLoopIfInfoPtop, cpuUtilProcessStatsTableEntry=cpuUtilProcessStatsTableEntry, bgpNewCfgPeerRemoveInRmap=bgpNewCfgPeerRemoveInRmap, vmapConfig=vmapConfig, ripInfoState=ripInfoState, lacpInfoPortPartOpSync=lacpInfoPortPartOpSync, ospfNewCfgLoopIfTable=ospfNewCfgLoopIfTable, qosCurCfgCosWeightTable=qosCurCfgCosWeightTable, ospf3CurCfgRangeHideState=ospf3CurCfgRangeHideState, ospfAreaInfoSPF=ospfAreaInfoSPF, aclStatsTable=aclStatsTable, aclNewCfgKbitsBurst=aclNewCfgKbitsBurst, tcpStatsActiveOpens=tcpStatsActiveOpens, vlagInfoIslId=vlagInfoIslId, fipsPortNewCfgEntry=fipsPortNewCfgEntry, mldIfStatsTable=mldIfStatsTable, ospfCurCfgIntfTrans=ospfCurCfgIntfTrans, ospfAreaIntfWaitTimer=ospfAreaIntfWaitTimer, aclNewCfgRemarkOutProfDscpMkdnDscp=aclNewCfgRemarkOutProfDscpMkdnDscp, agNewCfgHttpsServerPort=agNewCfgHttpsServerPort, ospf3TotalNumberOfInterfaces=ospf3TotalNumberOfInterfaces, stgNewCfgPriority=stgNewCfgPriority, agRevert=agRevert, tacNewCfgSecondaryServer=tacNewCfgSecondaryServer, oamInfo=oamInfo, virtVMwareHostPGName=virtVMwareHostPGName, ipsecSaStatsBytes=ipsecSaStatsBytes, failoverNewCfgTriggerMmonPortAdd=failoverNewCfgTriggerMmonPortAdd, vmapNewCfgSrcMACMask=vmapNewCfgSrcMACMask, geaportInfoTable=geaportInfoTable, ipv6ClearUdpStats=ipv6ClearUdpStats, ipv6InAddrerrs=ipv6InAddrerrs, ndprefixNewCfgValidLifetime=ndprefixNewCfgValidLifetime, ipsecNewCfgManualPolicyPeer=ipsecNewCfgManualPolicyPeer, ospfIntfErrIndex=ospfIntfErrIndex, vnicCurCfgVnicType=vnicCurCfgVnicType, aclCurCfgKbitsSec=aclCurCfgKbitsSec, agAccessNewStrongPassword=agAccessNewStrongPassword, mldInfoGroupEntry=mldInfoGroupEntry, hotlinksStatsTriggerTableEntry=hotlinksStatsTriggerTableEntry, ipsecCurCfgState=ipsecCurCfgState, virtVMwareVMInfoType=virtVMwareVMInfoType, lacpInfoAggrMac=lacpInfoAggrMac, bootpRelayStatsRequestsDroppedError=bootpRelayStatsRequestsDroppedError, ripNewCfgIntfMetric=ripNewCfgIntfMetric, ipsecSpdInfoAction=ipsecSpdInfoAction, portInfoPhyIfMtu=portInfoPhyIfMtu, vlagNewCfgLacpKey=vlagNewCfgLacpKey, agNewCfgCpuRateLimitCntl=agNewCfgCpuRateLimitCntl, lacpInfoPortActOpExp=lacpInfoPortActOpExp, ipsecSpdInfoFlags=ipsecSpdInfoFlags, qosConfig=qosConfig, ospfCumNbrAdjointOk=ospfCumNbrAdjointOk, igmpFilterCfg=igmpFilterCfg, fipsNewAclTimeout=fipsNewAclTimeout, bgpInfoPeerLastState=bgpInfoPeerLastState, ibmnosImage2Ver=ibmnosImage2Ver, bgpCurCfgGroupMetric=bgpCurCfgGroupMetric, virtVMwareVMNameIpAddress=virtVMwareVMNameIpAddress, vmapNewCfgTypeOfService=vmapNewCfgTypeOfService, ospfNewCfgVirtIntfAreaId=ospfNewCfgVirtIntfAreaId, mstCistCfg=mstCistCfg, agNewCfgIdleCLITimeout=agNewCfgIdleCLITimeout, lldpInfoRemoteDevicesSystemCapEnabled=lldpInfoRemoteDevicesSystemCapEnabled, agCfgDumpTableSize=agCfgDumpTableSize, hotlinksCurCfgTriggerBackupTrunk=hotlinksCurCfgTriggerBackupTrunk, vmapGroupNewCfgNonServerPortsRemVmap=vmapGroupNewCfgNonServerPortsRemVmap, ospfNumberOfLsdbEntries=ospfNumberOfLsdbEntries, ospf3AreaBorderRouter=ospf3AreaBorderRouter, ospf3AreaErrRxOspfOff=ospf3AreaErrRxOspfOff, acl6CurCfgSrcIPv6Address=acl6CurCfgSrcIPv6Address, hardwareManufacturingDate=hardwareManufacturingDate, ipsecSpdInfoSaSize=ipsecSpdInfoSaSize, aclCurCfgTCPFlags=aclCurCfgTCPFlags, bgpInfoDynamicReceivedUpdates=bgpInfoDynamicReceivedUpdates, ospfNewCfgIntfPrio=ospfNewCfgIntfPrio, agCurCfgSyslogTrapStg=agCurCfgSyslogTrapStg, ipDataRouteInfoTable=ipDataRouteInfoTable, mirroring=mirroring, ospfNewCfgStaticMetric=ospfNewCfgStaticMetric, ibmnosFdb=ibmnosFdb, agPortCurCfgState=agPortCurCfgState, vlanNewCfgPorts=vlanNewCfgPorts, ospf3NewCfgNbrEntry=ospf3NewCfgNbrEntry, ospf3IfNbrTable=ospf3IfNbrTable, lldpInfoPortIndex=lldpInfoPortIndex, ipRoute6InfoEntry=ipRoute6InfoEntry, mldInfoGroupIfIndex=mldInfoGroupIfIndex, dot3RateStatsTable=dot3RateStatsTable, failoverCurCfgTriggerId=failoverCurCfgTriggerId, lldpStatsTableEntry=lldpStatsTableEntry, dnsCurCfgPriServerPort=dnsCurCfgPriServerPort, ibmnosPortCtrlEntry=ibmnosPortCtrlEntry, hotlinksNewCfgFdbUpdateState=hotlinksNewCfgFdbUpdateState, agNTP=agNTP, allportsStatsOutBcastRate=allportsStatsOutBcastRate, ospf3NewCfgIntfEncryReset=ospf3NewCfgIntfEncryReset, agNewCfgNTPService=agNewCfgNTPService, igmpNewQurCfgVlanIndex=igmpNewQurCfgVlanIndex, agSaveConfiguration=agSaveConfiguration, vmapNewCfgEthernetTypeName=vmapNewCfgEthernetTypeName, ospfIntfErrorStats=ospfIntfErrorStats, ospf3RouterID=ospf3RouterID, vrrpOperVirtRtrGroupBackup=vrrpOperVirtRtrGroupBackup, udldInfoPortTable=udldInfoPortTable, ospfCurCfgVirtIntfRetra=ospfCurCfgVirtIntfRetra, ospfLoopIfInfoIpAddress=ospfLoopIfInfoIpAddress, bgpNewCfgState=bgpNewCfgState, ospfLoopIfInfoTotalNeighbours=ospfLoopIfInfoTotalNeighbours, destAddr=destAddr, ripRedistributeFixed=ripRedistributeFixed, qosNewCfgPortPriorityTable=qosNewCfgPortPriorityTable, bgpAggrTableMax=bgpAggrTableMax, ipNewCfgGwEntry=ipNewCfgGwEntry, vmCurCfgGroupVlan=vmCurCfgGroupVlan, vmPolicy=vmPolicy, hotlinksNewCfgTriggerId=hotlinksNewCfgTriggerId, ipRouteEcmpInfoGwStatus=ipRouteEcmpInfoGwStatus, bgpInfoMetr=bgpInfoMetr, qosCurCfgDscpState=qosCurCfgDscpState, ripNewCfgEospfRemoveOutRmap=ripNewCfgEospfRemoveOutRmap, mldInfoMRouterSrcIp=mldInfoMRouterSrcIp, icmpStatsOutEchoReps=icmpStatsOutEchoReps, sentQ=sentQ, ospf3IntfErrHelloMismatch=ospf3IntfErrHelloMismatch, arpClearStats=arpClearStats, ospfCumNbrBadRequests=ospfCumNbrBadRequests, ipsecSaInfoEncrAlg=ipsecSaInfoEncrAlg, ikeNewCfgPropCipher=ikeNewCfgPropCipher, agCurCfgSyslogTrapLacp=agCurCfgSyslogTrapLacp, ripCurCfgStaticOutRmapList=ripCurCfgStaticOutRmapList, ospf3IntfPtop=ospf3IntfPtop, fdbSrcPort=fdbSrcPort, ospfAreaInfoNeighborsEXCHstate=ospfAreaInfoNeighborsEXCHstate, igmpInfoIndex=igmpInfoIndex, lacpInfoPortActOpSync=lacpInfoPortActOpSync, fdbStatus=fdbStatus, oamStatsPortInfoRx=oamStatsPortInfoRx, ospf3IntfDisdlsReqs=ospf3IntfDisdlsReqs, vlanInfoId=vlanInfoId, cistInfoPortPathCost=cistInfoPortPathCost, ospf3CurCfgStaticMetric=ospf3CurCfgStaticMetric, ospfCurCfgIntfTable=ospfCurCfgIntfTable, acl6StatsTable=acl6StatsTable, ripCurCfgIntfAuth=ripCurCfgIntfAuth, lldpCurCfgPortSnmpTrap=lldpCurCfgPortSnmpTrap, ospf3CumIntfWaiting=ospf3CumIntfWaiting, ipsecNewCfgDynamicPolicyEntry=ipsecNewCfgDynamicPolicyEntry, agNewCfgSyslogTrapVm=agNewCfgSyslogTrapVm, ospfAreaErrHelloMismatch=ospfAreaErrHelloMismatch, dhcpSnoopingCurCfgOnState=dhcpSnoopingCurCfgOnState, ospf3IntfRxHello=ospf3IntfRxHello, lldpNewCfgPortalltlv=lldpNewCfgPortalltlv, ospf3NewCfgVirtIntfDelete=ospf3NewCfgVirtIntfDelete, vnicCurCfgGroupFailoverState=vnicCurCfgGroupFailoverState, agPortCurCfgUdldMode=agPortCurCfgUdldMode, ipCurCfgAlistAction=ipCurCfgAlistAction, ospfIfNbrTable=ospfIfNbrTable, lldpStatsTLVsUnrecognizedTotal=lldpStatsTLVsUnrecognizedTotal, stpLoopGuardNewCfgState=stpLoopGuardNewCfgState, pktStatsAllocFails=pktStatsAllocFails, markerpdusRx=markerpdusRx, ospfNewCfgRipRemoveOutRmap=ospfNewCfgRipRemoveOutRmap, ospf3CurCfgIntfEntry=ospf3CurCfgIntfEntry, ipStaticArpClearAll=ipStaticArpClearAll, ospf3NewCfgVirtIntfRetra=ospf3NewCfgVirtIntfRetra, ipStaticRouteNewPingRetries=ipStaticRouteNewPingRetries, vmapCurCfgTCPFlagsMask=vmapCurCfgTCPFlagsMask, vrrpCurCfgVirtRtrTableEntry=vrrpCurCfgVirtRtrTableEntry, lldpNewCfgState=lldpNewCfgState, aclCurCfgDstIPAddress=aclCurCfgDstIPAddress, radCurCfgSecPorttoUse=radCurCfgSecPorttoUse, lldpCurCfgPortsysdescrtlv=lldpCurCfgPortsysdescrtlv, ospf3AreaNbrInit=ospf3AreaNbrInit, mstCistNewCfgBridgePriority=mstCistNewCfgBridgePriority, ospfNewCfgStaticRemoveOutRmap=ospfNewCfgStaticRemoveOutRmap, vmapVlanCfg=vmapVlanCfg, vmapStatsTable=vmapStatsTable, ospfIntfTxlsAcks=ospfIntfTxlsAcks, aclNewCfgSrcPort=aclNewCfgSrcPort, failoverInfoTriggerEntry=failoverInfoTriggerEntry, stgNewCfgTableEntry=stgNewCfgTableEntry, vlagInfoLocalPriority=vlagInfoLocalPriority, ospf3IntfRxlsAcks=ospf3IntfRxlsAcks, ospf3AreaIntfIndex=ospf3AreaIntfIndex, failoverNewCfgTriggerMmonTrunk=failoverNewCfgTriggerMmonTrunk, vrrpStatBadPassword=vrrpStatBadPassword, ipStaticNbrClearAll=ipStaticNbrClearAll, nbrInfoEntry=nbrInfoEntry, agPortCurCfgDscpRemarking=agPortCurCfgDscpRemarking, ipsecCurCfgManualPolicyOutEspAuthKey=ipsecCurCfgManualPolicyOutEspAuthKey, mldCurInterfaceVersion=mldCurInterfaceVersion, agCurCfgSyslogTrapNtp=agCurCfgSyslogTrapNtp, udpMGMTIndx=udpMGMTIndx, hotlinksNewCfgOnState=hotlinksNewCfgOnState, fipsPortCurCfgIndex=fipsPortCurCfgIndex, bgpCurCfgGroupHold=bgpCurCfgGroupHold, bgpNewCfgPeerHold=bgpNewCfgPeerHold, ipNewCfgIntfLoopbackTable=ipNewCfgIntfLoopbackTable, portInfoIndx=portInfoIndx, ospfCurCfgIntfPrio=ospfCurCfgIntfPrio, ospf3AreaErrRxOnPasv=ospf3AreaErrRxOnPasv, icmpStatsInTimestampReps=icmpStatsInTimestampReps, agApply=agApply, mcastFdbNewCfgEntryIndex=mcastFdbNewCfgEntryIndex, ospf3NewCfgIntfInstId=ospf3NewCfgIntfInstId, failoverInfoTriggerCtlPortId=failoverInfoTriggerCtlPortId, nsnmpInTotalSetVars=nsnmpInTotalSetVars, ospfExtLsdbInfoSequence=ospfExtLsdbInfoSequence, vlagStatsPduSentFdbInactiveAdd=vlagStatsPduSentFdbInactiveAdd, dhcpSnoopingStatDroppedPacketOther=dhcpSnoopingStatDroppedPacketOther, ospf3AreaRxPkts=ospf3AreaRxPkts, lldpNewCfgPortvlannametlv=lldpNewCfgPortvlannametlv, allportsStatsOutOctetsRate=allportsStatsOutOctetsRate, ospfCurCfgIbgpMetric=ospfCurCfgIbgpMetric, vrrpCurCfgVirtRtrGrpInterval=vrrpCurCfgVirtRtrGrpInterval, mstCistNewCfgVlanBmap=mstCistNewCfgVlanBmap, mcastFdbCurCfgTable=mcastFdbCurCfgTable, lldpInfoRxTable=lldpInfoRxTable, bgpInfoGroupState=bgpInfoGroupState, agNetboot=agNetboot, ipsecCurCfgManualPolicyEntry=ipsecCurCfgManualPolicyEntry, intfLoopbackInfoBcastAddr=intfLoopbackInfoBcastAddr, ospf3RouteRedistribution=ospf3RouteRedistribution, ospf3IfNbrState=ospf3IfNbrState, ospfAreaInfoAreaBorderRouter=ospfAreaInfoAreaBorderRouter, dhcpSnoopingCurCfgPortRateLimit=dhcpSnoopingCurCfgPortRateLimit, igmpCurQurCfgTable=igmpCurQurCfgTable, tcpStatsCurrEstab=tcpStatsCurrEstab)
mibBuilder.exportSymbols("IBM-GbTOR-10G-L2L3-MIB", agCurCfgBootp=agCurCfgBootp, ipCurCfgStaticNbrTable=ipCurCfgStaticNbrTable, vlanNewCfgPrVlanType=vlanNewCfgPrVlanType, virtNewCfgVMwareHelloRemovePort=virtNewCfgVMwareHelloRemovePort, ospfLoopIfInfoArea=ospfLoopIfInfoArea, vmapNewCfgOutprofDscpEnable=vmapNewCfgOutprofDscpEnable, mldDefaultCfgState=mldDefaultCfgState, acl6CurCfgDstPort=acl6CurCfgDstPort, ipNewCfgAlistDelete=ipNewCfgAlistDelete, ipv6ClearIcmpStats=ipv6ClearIcmpStats, dnsStatInGoodDnsRequests=dnsStatInGoodDnsRequests, hardwareFlashConfiguration=hardwareFlashConfiguration, layer3=layer3, ipCurCfgStaticRoute6Interface=ipCurCfgStaticRoute6Interface, pmNewCfgPmonDelete=pmNewCfgPmonDelete, aclCurCfgFilterActionSetPrio=aclCurCfgFilterActionSetPrio, ospfTotalAreas=ospfTotalAreas, bgpInfoPeerState=bgpInfoPeerState, igmpNewCfgOtherQurPresentInt=igmpNewCfgOtherQurPresentInt, mstGeneralCfg=mstGeneralCfg, vmapVlanCurCfgServerPortsVmapBitmap=vmapVlanCurCfgServerPortsVmapBitmap, portInfoFlowCtrl=portInfoFlowCtrl, ospfCumTxDatabase=ospfCumTxDatabase, virtCurCfgVMwareHello=virtCurCfgVMwareHello, ospf3AreaNbrDown=ospf3AreaNbrDown, bgpInfoPeerTtl=bgpInfoPeerTtl, layer2Stats=layer2Stats, ecpCurCfgRetrans=ecpCurCfgRetrans, ospf3IfNbrEntry=ospf3IfNbrEntry, ospfTimersKickOffStats=ospfTimersKickOffStats, ospfLoopIfInfoDesignatedRouterIpAddress=ospfLoopIfInfoDesignatedRouterIpAddress, hwTemperatureSensor4=hwTemperatureSensor4, ipsecNewCfgSelectorDelete=ipsecNewCfgSelectorDelete, agNewCfgSyslogTrapMld=agNewCfgSyslogTrapMld, vlagStatsPduSentFdbDynamicDel=vlagStatsPduSentFdbDynamicDel, agRadiusConfig=agRadiusConfig, vmNewCfgCheckTrust=vmNewCfgCheckTrust, radNewCfgRetries=radNewCfgRetries, ipsecNewCfgIfTable=ipsecNewCfgIfTable, mldInfoMRouterIfIndex=mldInfoMRouterIfIndex, arpInfoTable=arpInfoTable, ospf3CurCfgIntfArea=ospf3CurCfgIntfArea, bootpStats=bootpStats, ndprefixNewCfgPreferredLifetime=ndprefixNewCfgPreferredLifetime, ospfNewCfgEbgpMetricType=ospfNewCfgEbgpMetricType, bgpCurCfgPeerPassword=bgpCurCfgPeerPassword, vrrpInfoVirtRtrTable=vrrpInfoVirtRtrTable, errMldIfStatsToIncFmcrsv2=errMldIfStatsToIncFmcrsv2, errMldIfStatsBlockSlcrsv2=errMldIfStatsBlockSlcrsv2, nsnmpOutNoSuchNames=nsnmpOutNoSuchNames, ipsecNewCfgIfIndex=ipsecNewCfgIfIndex, fdbVlan=fdbVlan, ospf3IntfNbrExStart=ospf3IntfNbrExStart, agCfgBootReset=agCfgBootReset, ldapNewCfgState=ldapNewCfgState, bgpNewCfgDscp=bgpNewCfgDscp, failoverNewCfgTriggerMconKeyRem=failoverNewCfgTriggerMconKeyRem, virtCurCfgVMwareHelloEnable=virtCurCfgVMwareHelloEnable, agAccessUserCurCfgPswd=agAccessUserCurCfgPswd, acl6NewCfgTable=acl6NewCfgTable, vlagNewIslCfgAdminKey=vlagNewIslCfgAdminKey, nsnmpOutGetResponses=nsnmpOutGetResponses, ospf3AreaNbrLoading=ospf3AreaNbrLoading, ospf3NewCfgNbrState=ospf3NewCfgNbrState, nsnmpInNoSuchNames=nsnmpInNoSuchNames, ripCurCfgIntfSupply=ripCurCfgIntfSupply, lacpInfoPortActOperKey=lacpInfoPortActOperKey, oamStatsPortTable=oamStatsPortTable, aclCurCfgUser=aclCurCfgUser, trunkGroupInfoPortStatus=trunkGroupInfoPortStatus, virtVMwareVMInfoMACAddr=virtVMwareVMInfoMACAddr, vmapGroupCurCfgServerPortsTableEntry=vmapGroupCurCfgServerPortsTableEntry, mldInfoGroupVlanID=mldInfoGroupVlanID, vlanCurCfgTable=vlanCurCfgTable, ospf3ASBoundaryRouter=ospf3ASBoundaryRouter, ipStaticRoute6ClearAllByDestIp=ipStaticRoute6ClearAllByDestIp, ospf3CumIntfDr=ospf3CumIntfDr, virtNewCfgVirtCenterUser=virtNewCfgVirtCenterUser, ipmcCurCfgStaticRouteDestIp=ipmcCurCfgStaticRouteDestIp, allportsStatsOutDiscards=allportsStatsOutDiscards, markerpdusTx=markerpdusTx, ospf3NewCfgExtRangePrefixLen=ospf3NewCfgExtRangePrefixLen, rxMldIfStatsMLDv2Report=rxMldIfStatsMLDv2Report, ikeCurCfgPropGroup=ikeCurCfgPropGroup, portMgmtStatsTable=portMgmtStatsTable, stpInfoPortLinkType=stpInfoPortLinkType, portType=portType, ospf3NewCfgVirtIntfIndex=ospf3NewCfgVirtIntfIndex, vrrpStatOutGratuitousARPs=vrrpStatOutGratuitousARPs, ospfCurCfgRangeTable=ospfCurCfgRangeTable, icmpStatsInErrors=icmpStatsInErrors, ldapCurCfgPort=ldapCurCfgPort, ospf3IntfTxlsUpdates=ospf3IntfTxlsUpdates, ospf3AreaErrIndex=ospf3AreaErrIndex, ospf3NewCfgExtRangeTranslation=ospf3NewCfgExtRangeTranslation, ipCurCfgStaticNbrPort=ipCurCfgStaticNbrPort, ospfVirtIntfInfoArea=ospfVirtIntfInfoArea, vnicCurCfgGroupVnics=vnicCurCfgGroupVnics, virtVMwareHostDetailInfoType=virtVMwareHostDetailInfoType, agNewCfgSyslogTrapIgmpMrouter=agNewCfgSyslogTrapIgmpMrouter, ospf3NewCfgVirtIntfAreaId=ospf3NewCfgVirtIntfAreaId, ospf3CurCfgExitOverflow=ospf3CurCfgExitOverflow, vlagCurCfgLacpState=vlagCurCfgLacpState, lldpCurCfgMsgTxInt=lldpCurCfgMsgTxInt, trunkLacpGroupNewCfgTable=trunkLacpGroupNewCfgTable, agTransferHostCertFileName=agTransferHostCertFileName, ipmcCurCfgStaticRouteHostBmap=ipmcCurCfgStaticRouteHostBmap, nbrInfoInterface=nbrInfoInterface, bgpNewCfgAggrIndex=bgpNewCfgAggrIndex, ospfCurCfgIbgpMetricType=ospfCurCfgIbgpMetricType, ospfVirtIntfInfoDeadMS=ospfVirtIntfInfoDeadMS, mldNewInterfaceTable=mldNewInterfaceTable, ipsecNewCfgManualPolicySelector=ipsecNewCfgManualPolicySelector, agPortNewCfgTagPVID=agPortNewCfgTagPVID, ospf3NbrTableMaxSize=ospf3NbrTableMaxSize, qosCurCfgCosWeightEntry=qosCurCfgCosWeightEntry, bgpInfoNetwork=bgpInfoNetwork, routeStatStaticEntries=routeStatStaticEntries, aclNewCfgInprofDscp=aclNewCfgInprofDscp, ospfCurCfgFixedMetricType=ospfCurCfgFixedMetricType, dhcpSnoopingNewCfgPortTableEntry=dhcpSnoopingNewCfgPortTableEntry, ospf3CurCfgVirtIntfTable=ospf3CurCfgVirtIntfTable, ospfTotalNumberOfInterfaces=ospfTotalNumberOfInterfaces, ipNewCfgAspathAS=ipNewCfgAspathAS, ospf3NewCfgRedistRouteTagTypeManual=ospf3NewCfgRedistRouteTagTypeManual, ibmnosFdbMacAddr=ibmnosFdbMacAddr, agCurCfgSyslogTrapLink=agCurCfgSyslogTrapLink, bgpInfoNextHop=bgpInfoNextHop, lacpInfoPortSelected=lacpInfoPortSelected, agImageForNxtReset=agImageForNxtReset, lldpCurCfgPortprotidtlv=lldpCurCfgPortprotidtlv, ospf3CumIntfDown=ospf3CumIntfDown, vmGroupInfoVlan=vmGroupInfoVlan, vrrpInfoVirtRtrIndex=vrrpInfoVirtRtrIndex, vmCurCfgGroupTagState=vmCurCfgGroupTagState, routeStats=routeStats, ipsecCurCfgManualPolicyInEspEncKey=ipsecCurCfgManualPolicyInEspEncKey, vlanAutoStgNewCfgState=vlanAutoStgNewCfgState, vnicCurCfgState=vnicCurCfgState, ospfSumRangesInfoIndex=ospfSumRangesInfoIndex, dot1RateStpPortForwardTransitions=dot1RateStpPortForwardTransitions, vmNewCfgProfileEgressShapingPeak=vmNewCfgProfileEgressShapingPeak, ibmnosBootVer=ibmnosBootVer, vmapNewCfgSrcMACAddress=vmapNewCfgSrcMACAddress, lldpStatsClear=lldpStatsClear, stgCurCfgPortIndex=stgCurCfgPortIndex, vrrpVirtRtrTableMaxSize=vrrpVirtRtrTableMaxSize, ipmcNewCfgStaticRouteAdminkeys=ipmcNewCfgStaticRouteAdminkeys, agTransferServer=agTransferServer, ipNewCfgBootpBcastDomainServerIP=ipNewCfgBootpBcastDomainServerIP, vrrpCurCfgIfAuthType=vrrpCurCfgIfAuthType, ospf3TotalAreas=ospf3TotalAreas, vlagStatsIsl=vlagStatsIsl, ndprefixCurCfgIndx=ndprefixCurCfgIndx, ipsecNewCfgManualPolicyInAhSpi=ipsecNewCfgManualPolicyInAhSpi, ipsecNewCfgIfDelete=ipsecNewCfgIfDelete, lldpInfoPortmacphytlv=lldpInfoPortmacphytlv, ospf3AreaDisdlsAcks=ospf3AreaDisdlsAcks, stpInfoHoldTime=stpInfoHoldTime, ospfAreaErrorStats=ospfAreaErrorStats, agBoot=agBoot, mstCistCurCfgPortEdge=mstCistCurCfgPortEdge, sfpInfo=sfpInfo, bgpNewCfgPeerOspfState=bgpNewCfgPeerOspfState, udldInfoPortInterval=udldInfoPortInterval, vlagInfoSystem=vlagInfoSystem, ospf3CurCfgStaticMetricType=ospf3CurCfgStaticMetricType, vmapVlanNewCfgAllPortsVmapBitmap=vmapVlanNewCfgAllPortsVmapBitmap, ipv6Reasmoks=ipv6Reasmoks, ipsecNewCfgDynamicPolicyLifetime=ipsecNewCfgDynamicPolicyLifetime, bgpInfoGroupRemoteAddr=bgpInfoGroupRemoteAddr, ipv6icmpInToobig=ipv6icmpInToobig, stpInfoPortDesignatedPort=stpInfoPortDesignatedPort, ibmnosConfigForNxtReset=ibmnosConfigForNxtReset, ospfAreaErrOptionsMismatch=ospfAreaErrOptionsMismatch, allportsStatsInDiscardsRate=allportsStatsInDiscardsRate, radCurCfgAuthenSecondString=radCurCfgAuthenSecondString, lldpCurCfgNotifInt=lldpCurCfgNotifInt, igmpInfoExpires=igmpInfoExpires, agNewCfgSyslogTrapServer=agNewCfgSyslogTrapServer, nsnmpInGetResponses=nsnmpInGetResponses, ipNewCfgStaticArpPort=ipNewCfgStaticArpPort, ipNewCfgNwfDelete=ipNewCfgNwfDelete, swFwDownloadFailure=swFwDownloadFailure, agPortCurCfgDLFThreshold=agPortCurCfgDLFThreshold, txMldIfStatsToExcFmcrsv2=txMldIfStatsToExcFmcrsv2, lldpInfoTxTable=lldpInfoTxTable, stgStatsPortIndex=stgStatsPortIndex, fipsInfoFcfTable=fipsInfoFcfTable, vmapGroupCurCfgNonServerPortsTable=vmapGroupCurCfgNonServerPortsTable, ipStaticRouteCurHealthcheck=ipStaticRouteCurHealthcheck, fdbStatsClear=fdbStatsClear, agNewCfgSyslogTrapStg=agNewCfgSyslogTrapStg, mldCurInterfaceEntry=mldCurInterfaceEntry, lldpInfoPortframesztlv=lldpInfoPortframesztlv, fdbNewCfgDelStaticEntry=fdbNewCfgDelStaticEntry, nsnmpInTooBigs=nsnmpInTooBigs, lacpInfoAggrActSysId=lacpInfoAggrActSysId, agRevertApply=agRevertApply, agCurCfgSyslogSev=agCurCfgSyslogSev, ipCurCfgAspathRmapIndex=ipCurCfgAspathRmapIndex, genInfo=genInfo, igmpSnoopCurCfgAggrEnaDis=igmpSnoopCurCfgAggrEnaDis, ospf3IntfErrRxVerMismatch=ospf3IntfErrRxVerMismatch, agCurCfgSyslogTrapVlag=agCurCfgSyslogTrapVlag, fipsInfoFcoeVNPortMac=fipsInfoFcoeVNPortMac, dhcpSnoopingCurCfgVlanTable=dhcpSnoopingCurCfgVlanTable, rxMldIfStatsAllowSlcrsv2=rxMldIfStatsAllowSlcrsv2, ipNewCfgStaticArpMAC=ipNewCfgStaticArpMAC, ospfCurCfgVirtIntfDeadMS=ospfCurCfgVirtIntfDeadMS, ospf3AreaTxHello=ospf3AreaTxHello, dhcpSnoopingBindingInfoTable=dhcpSnoopingBindingInfoTable, mcastFdbNewCfgRemPort=mcastFdbNewCfgRemPort, ospfIntfNbrDown=ospfIntfNbrDown, ipCurCfgBootpGlobalServerEntry=ipCurCfgBootpGlobalServerEntry, failoverNewCfgTriggerDelete=failoverNewCfgTriggerDelete, vrrpClearStats=vrrpClearStats, vmapNewCfgMirrorPort=vmapNewCfgMirrorPort, ospfNewCfgFixedMetric=ospfNewCfgFixedMetric, vlagNewCfgHlthchkKeepaliveAttempts=vlagNewCfgHlthchkKeepaliveAttempts, ospfCurCfgAreaMetric=ospfCurCfgAreaMetric, aclNewCfgRemarkOutProfDscpEntry=aclNewCfgRemarkOutProfDscpEntry, pmCurCfgPmirrDirection=pmCurCfgPmirrDirection, ospfIntfRxTxStatsEntry=ospfIntfRxTxStatsEntry, aclNewCfgPortAddAcl=aclNewCfgPortAddAcl, vlanNewCfgStg=vlanNewCfgStg, vmapCurCfgTagFmt=vmapCurCfgTagFmt, vlagStatsLacp=vlagStatsLacp, ipNewCfgStaticRouteEntry=ipNewCfgStaticRouteEntry, ripRedistributeEospf=ripRedistributeEospf, aclCurCfgTypeOfService=aclCurCfgTypeOfService, allportsStatsIndx=allportsStatsIndx, ospf3AreaDisdDatabase=ospf3AreaDisdDatabase, tcpStatsMaxConn=tcpStatsMaxConn, igmpSnoopNewCfgVlanRem=igmpSnoopNewCfgVlanRem, fipsInfoPortIndex=fipsInfoPortIndex, vmCurCfgCheck=vmCurCfgCheck, ibmSNMPv2Notifications=ibmSNMPv2Notifications, ipCurCfgGwIpv6Entry=ipCurCfgGwIpv6Entry, ospfCurCfgRangeHideState=ospfCurCfgRangeHideState, ospfNewCfgVirtIntfNbr=ospfNewCfgVirtIntfNbr, ipCurCfgStaticRoute6Gateway=ipCurCfgStaticRoute6Gateway, vlagCurCfgAutoRecoveryInterval=vlagCurCfgAutoRecoveryInterval, lldpInfoTxTTL=lldpInfoTxTTL, portStatsPhyIfOutMulticastPkts=portStatsPhyIfOutMulticastPkts, mstCistNewCfgPortPriority=mstCistNewCfgPortPriority, ipsecNewCfgIfDelDynamicPolicy=ipsecNewCfgIfDelDynamicPolicy, udldInfoPortBidirectionalStatus=udldInfoPortBidirectionalStatus, vmapGroupNewCfgAllPortsTable=vmapGroupNewCfgAllPortsTable, ipsecCurCfgManualPolicyTxform=ipsecCurCfgManualPolicyTxform, cistInfoPortRole=cistInfoPortRole, ipFwdNewCfgState=ipFwdNewCfgState, ospfIntfNbrExchangeDone=ospfIntfNbrExchangeDone, intfInfoStatus=intfInfoStatus)
mibBuilder.exportSymbols("IBM-GbTOR-10G-L2L3-MIB", ospfIntfBackup=ospfIntfBackup, processStatus=processStatus, ospf3IfInfoTransitDelay=ospf3IfInfoTransitDelay, ospf3CurCfgNbrTable=ospf3CurCfgNbrTable, ipNewCfgIntfOtherCfg=ipNewCfgIntfOtherCfg, ospf3CurCfgNbrIndex=ospf3CurCfgNbrIndex, lldpInfoRemoteDevicesManAddrTable=lldpInfoRemoteDevicesManAddrTable, cistBridgeForwardDelay=cistBridgeForwardDelay, ospfCurCfgHostIndex=ospfCurCfgHostIndex, ipStatsInAddrErrors=ipStatsInAddrErrors, agCurBootNxtCliModePrompt=agCurBootNxtCliModePrompt, ospf3CumTxlsUpdates=ospf3CumTxlsUpdates, tacNewCfgBackdoor=tacNewCfgBackdoor, ospfSumRangesInfoEntry=ospfSumRangesInfoEntry, vmCurCfgProfileVlan=vmCurCfgProfileVlan, ipv6InDelivers=ipv6InDelivers, ospfAreaNbrBadSequence=ospfAreaNbrBadSequence, ipCurCfgRmapState=ipCurCfgRmapState, ipsecNewCfgManualPolicyOutEspSpi=ipsecNewCfgManualPolicyOutEspSpi, ospf3CurCfgIntfNetworkType=ospf3CurCfgIntfNetworkType, vlagStats=vlagStats, igmpCurCfgQurStartupCnt=igmpCurCfgQurStartupCnt, ospf3CurCfgConnectedRouteTagTypeManual=ospf3CurCfgConnectedRouteTagTypeManual, pktStatsMediumsHiWatermark=pktStatsMediumsHiWatermark, bgpNewCfgGroupUpdateSrcIf=bgpNewCfgGroupUpdateSrcIf, ikeNewCfgIdentity=ikeNewCfgIdentity, stpLoopGuardCurCfgState=stpLoopGuardCurCfgState, ospfNbrInExchState=ospfNbrInExchState, ndprefixCurCfgPreferredLifetimeFlag=ndprefixCurCfgPreferredLifetimeFlag, aclCurCfgInprofDscpEnable=aclCurCfgInprofDscpEnable, agNewCfgDefipData=agNewCfgDefipData, acl6CurCfgIPv6FlowLabel=acl6CurCfgIPv6FlowLabel, agCurCfgHttpServerPort=agCurCfgHttpServerPort, ipNewCfgIntfBootpRelay=ipNewCfgIntfBootpRelay, ospfCurCfgIntfHello=ospfCurCfgIntfHello, bgpCurCfgState=bgpCurCfgState, ndprefixNewCfgPrefixLen=ndprefixNewCfgPrefixLen, virtVMwareVMInfoPortGroup=virtVMwareVMInfoPortGroup, vlagCurIslCfgAdminKey=vlagCurIslCfgAdminKey, vlanNewCfgTable=vlanNewCfgTable, bgpCurCfgGroupDefaultAction=bgpCurCfgGroupDefaultAction, igmpClearAllStats=igmpClearAllStats, vmapCurCfgSrcPortMask=vmapCurCfgSrcPortMask, ospfNewCfgVirtIntfTrans=ospfNewCfgVirtIntfTrans, fipsInfoFcoeCount=fipsInfoFcoeCount, agCurCfgSyslog2Fac=agCurCfgSyslog2Fac, failoverInfoTriggerMonPortStatus=failoverInfoTriggerMonPortStatus, bgpNewCfgPeerAlive=bgpNewCfgPeerAlive, agDiffString=agDiffString, ospfVirtIntfInfoNbrState=ospfVirtIntfInfoNbrState, vmapVlanNewCfgAllPortsTable=vmapVlanNewCfgAllPortsTable, fipsInfoFcoeFcfMac=fipsInfoFcoeFcfMac, ibmGbTORG8124MIB=ibmGbTORG8124MIB, ikeCurCfgPskRemoteIndex=ikeCurCfgPskRemoteIndex, ospfIntfNbrBadRequests=ospfIntfNbrBadRequests, ipsecSaInfoTable=ipsecSaInfoTable, agCurCfgErrDisableTimeout=agCurCfgErrDisableTimeout, hardwareSwitchRunningSwVersion=hardwareSwitchRunningSwVersion, aclNewCfgDstIPAddress=aclNewCfgDstIPAddress, ospfCumTxlsAcks=ospfCumTxlsAcks, vmapCurCfg8021pPriority=vmapCurCfg8021pPriority, agCurCfgDhcpMgtb=agCurCfgDhcpMgtb, arpStatMaxEntries=arpStatMaxEntries, agCurCfgSyslogTrapConsole=agCurCfgSyslogTrapConsole, ipCurCfgBootpBcastDomainVlan=ipCurCfgBootpBcastDomainVlan, ipmcNewCfgStaticRouteRemPort=ipmcNewCfgStaticRouteRemPort, pktStatsMediums=pktStatsMediums, ipCurCfgIntfOtherCfg=ipCurCfgIntfOtherCfg, ospfAreaIntfIndex=ospfAreaIntfIndex, mldCurInterfaceQueryInterval=mldCurInterfaceQueryInterval, vlanCurCfgState=vlanCurCfgState, mldInfoMRouterPortNumber=mldInfoMRouterPortNumber, ipNewCfgNwfAddr=ipNewCfgNwfAddr, agSlotNumber=agSlotNumber, failoverInfoTriggerId=failoverInfoTriggerId, trunkLacpGroupTableMaxSize=trunkLacpGroupTableMaxSize, qosNewCfgCosIndex=qosNewCfgCosIndex, ipv6InRoutadvs=ipv6InRoutadvs, ipDataRouteInfoMask=ipDataRouteInfoMask, bgpCurCfgGroupTtlSecHops=bgpCurCfgGroupTtlSecHops, ospfIfNbrIntfIndex=ospfIfNbrIntfIndex, ipNewCfgStaticNbrIp=ipNewCfgStaticNbrIp, portInfoPhyIfLastChange=portInfoPhyIfLastChange, bootpRelayStatsRepliesRelayed=bootpRelayStatsRepliesRelayed, ospf3NewCfgHostAreaIndex=ospf3NewCfgHostAreaIndex, l2ThashNewCfgSmacState=l2ThashNewCfgSmacState, igmpInfoSourceIp=igmpInfoSourceIp, agAccessUserCurCfgState=agAccessUserCurCfgState, ospfAreaRxlsReqs=ospfAreaRxlsReqs, ibmnosPortCtrlSpeed=ibmnosPortCtrlSpeed, portStatsDot1PortOutFrames=portStatsDot1PortOutFrames, ipsecCurCfgIfIndex=ipsecCurCfgIfIndex, ospfAreaNbrhello=ospfAreaNbrhello, lacpInfoPortActAdminKey=lacpInfoPortActAdminKey, stpInfoPortRole=stpInfoPortRole, vmGroupInfoIsVMK=vmGroupInfoIsVMK, ripNewCfgIbgpRemoveOutRmap=ripNewCfgIbgpRemoveOutRmap, bgpPeerTableMax=bgpPeerTableMax, vmNewCfgProfileEgressShapingAverage=vmNewCfgProfileEgressShapingAverage, vlagStatsPduSentPeerInstanceEnable=vlagStatsPduSentPeerInstanceEnable, igmpCurCfgOtherQurAddress=igmpCurCfgOtherQurAddress, icmpStatsOutErrors=icmpStatsOutErrors, vmNewCfgGroupAddTrunk=vmNewCfgGroupAddTrunk, mcastFdbNewCfgAddMac=mcastFdbNewCfgAddMac, portInfoTable=portInfoTable, vmapCurCfgDstMACAddress=vmapCurCfgDstMACAddress, cistInfoPortDesignatedBridge=cistInfoPortDesignatedBridge, ipNewCfgGwAddr=ipNewCfgGwAddr, ldapNewCfgRetries=ldapNewCfgRetries, rxIgmpLeaves=rxIgmpLeaves, ipCurCfgRmapMetricType=ipCurCfgRmapMetricType, lacpStats=lacpStats, lldpNewCfgPortprotidtlv=lldpNewCfgPortprotidtlv, agTransferHostKeyFileName=agTransferHostKeyFileName, ipNewCfgStaticRouteMask=ipNewCfgStaticRouteMask, ospf3NewCfgAreaStatus=ospf3NewCfgAreaStatus, intfLoopbackInfoIndex=intfLoopbackInfoIndex, mldCurCfgState=mldCurCfgState, ipCurCfgStaticNbrVlan=ipCurCfgStaticNbrVlan, fipsInfoFcfEntry=fipsInfoFcfEntry, ospf3CurCfgSpfDelay=ospf3CurCfgSpfDelay, ipmcNewCfgStaticRouteHostBmap=ipmcNewCfgStaticRouteHostBmap, oamInfoPortEntry=oamInfoPortEntry, igmpStats=igmpStats, agNewCfgLoginNotice=agNewCfgLoginNotice, lacpInfoAggrTable=lacpInfoAggrTable, acl6NewCfgSrcPort=acl6NewCfgSrcPort, ipsecSaInfoSpi=ipsecSaInfoSpi, tacCurCfgPort=tacCurCfgPort, ldapCurCfgTimeout=ldapCurCfgTimeout, qosCurCfgMapDscp=qosCurCfgMapDscp, ipNewCfgBootpAddr2=ipNewCfgBootpAddr2, layer2Info=layer2Info, portMgmtStatsRxFrame=portMgmtStatsRxFrame, igmpSnoopCurCfgEnaDis=igmpSnoopCurCfgEnaDis, igmpCurQurCfgEntry=igmpCurQurCfgEntry, ospf3IntfErrBadPktType=ospf3IntfErrBadPktType, igmpV3SnoopNewCfgEnaDis=igmpV3SnoopNewCfgEnaDis, ripStatRouteTimeout=ripStatRouteTimeout, agNewCfgNTPSecServer=agNewCfgNTPSecServer, agCurCfgTftpServerPort=agCurCfgTftpServerPort, ospf3NewCfgIntfPrio=ospf3NewCfgIntfPrio, ospf3NewCfgRangeDelete=ospf3NewCfgRangeDelete, ospf3IfInfoEncryAuthType=ospf3IfInfoEncryAuthType, vmapGroupNewCfgAllPortsTableEntry=vmapGroupNewCfgAllPortsTableEntry, sentQUdp=sentQUdp, portInfo=portInfo, acl6ClearStats=acl6ClearStats, hotlinksNewCfgTriggerMasterAdminkey=hotlinksNewCfgTriggerMasterAdminkey, bgpNewCfgAggrAddr=bgpNewCfgAggrAddr, oamStatsPortRemoteCriticalEvents=oamStatsPortRemoteCriticalEvents, ipCurCfgStaticRouteGateway=ipCurCfgStaticRouteGateway, ospfIntfErrHelloMismatch=ospfIntfErrHelloMismatch, ibmnosPortCtrlFlowControl=ibmnosPortCtrlFlowControl, ipsecSaStatsDstAddr=ipsecSaStatsDstAddr, aclNewCfgEthernetTypeName=aclNewCfgEthernetTypeName, vmGroupInfolistEntry=vmGroupInfolistEntry, mldInfoMRouterMaxRespDelay=mldInfoMRouterMaxRespDelay, agCurCfgSyslogSrcLoopIf=agCurCfgSyslogSrcLoopIf, vmbwCurCfgTxAclId=vmbwCurCfgTxAclId, igmpFltCurCfgPortState=igmpFltCurCfgPortState, vmGroupInfoPortGroup=vmGroupInfoPortGroup, ospfAreaRxlsUpdates=ospfAreaRxlsUpdates, radNewCfgBackdoor=radNewCfgBackdoor, bgpCurCfgAggrState=bgpCurCfgAggrState, agNewCfgTrapSrcIf=agNewCfgTrapSrcIf, dot1RateStatsTable=dot1RateStatsTable, tacCurCfgCmdAuthor=tacCurCfgCmdAuthor, fipsInfoAclSequencer=fipsInfoAclSequencer, ifMainEntry=ifMainEntry, ipCurCfgStaticRoute6Entry=ipCurCfgStaticRoute6Entry, vmapVlanCfgServerPorts=vmapVlanCfgServerPorts, vlagInfo=vlagInfo, agNewCfgErrDisableTimeout=agNewCfgErrDisableTimeout, swVlagIslUp=swVlagIslUp, bgpCurCfgASNumber=bgpCurCfgASNumber, agPortCurCfgPVID=agPortCurCfgPVID, ipsecCurCfgSelectorDst=ipsecCurCfgSelectorDst, fdb=fdb, ospf3Area=ospf3Area, bgpNewCfgGroupEntry=bgpNewCfgGroupEntry, igmpSnoopCurCfgQInterval=igmpSnoopCurCfgQInterval, rxMldIfStatsExcCrsv2=rxMldIfStatsExcCrsv2, ipRouteEcmpInfoDest=ipRouteEcmpInfoDest, ipv6icmpOutAdminProhib=ipv6icmpOutAdminProhib, hwManufacturingDate=hwManufacturingDate, ipNewCfgRmapNexthop=ipNewCfgRmapNexthop, bgpCurCfgPeerTable=bgpCurCfgPeerTable, ntpPrimaryServerUpdates=ntpPrimaryServerUpdates, ndprefixCurCfgValidLifetimeFlag=ndprefixCurCfgValidLifetimeFlag, ipCurCfgGwIpv6Index=ipCurCfgGwIpv6Index, swStgNewRoot=swStgNewRoot, portMgmtStatsTxCollisions=portMgmtStatsTxCollisions, lacpInfoPortActOpTimeout=lacpInfoPortActOpTimeout, pptCurCfgPrecedence=pptCurCfgPrecedence, tcpControlBlocksTableEntry=tcpControlBlocksTableEntry, ospfNewCfgVirtIntfHello=ospfNewCfgVirtIntfHello, igmpSnoopNewCfgTimeout=igmpSnoopNewCfgTimeout, intfInfoVlan=intfInfoVlan, hwSerialNum=hwSerialNum, virtVMwareVMInfoVMOSHostName=virtVMwareVMInfoVMOSHostName, ipNewCfgGwState=ipNewCfgGwState, stgStatsPortRcvTcnBpdus=stgStatsPortRcvTcnBpdus, vmapGroupCfgNonServerPorts=vmapGroupCfgNonServerPorts, ipDataRouteInfoGateway1=ipDataRouteInfoGateway1, vnicCurCfgVnicPortIndex=vnicCurCfgVnicPortIndex, radNewCfgPorttoUse=radNewCfgPorttoUse, ipNewCfgRmapWeight=ipNewCfgRmapWeight, ospfCurCfgVirtIntfHello=ospfCurCfgVirtIntfHello, vmapNewCfgSrcPort=vmapNewCfgSrcPort, ospf3AreaErrBadPktType=ospf3AreaErrBadPktType, fdbCurCfgVlan=fdbCurCfgVlan, agTftpServer=agTftpServer, lldpNewCfgPortsysnametlv=lldpNewCfgPortsysnametlv, ospf3CumRxHello=ospf3CumRxHello, trunkLacpGroupNewCfgIndex=trunkLacpGroupNewCfgIndex, nsnmpOutPkts=nsnmpOutPkts, lacpInfoPortGeneralTableEntry=lacpInfoPortGeneralTableEntry, dot3RateStatsInternalMacTransmitErrors=dot3RateStatsInternalMacTransmitErrors, ospfNewCfgLoopIfIndex=ospfNewCfgLoopIfIndex, vrrpCurCfgVirtRtrPriority=vrrpCurCfgVirtRtrPriority, ipv6icmpInAdminProhib=ipv6icmpInAdminProhib, lldpInfoRemoteDevicesIndex=lldpInfoRemoteDevicesIndex, ospf3NewCfgIntfDelete=ospf3NewCfgIntfDelete, vlanCurCfgPrVlanMapPriId=vlanCurCfgPrVlanMapPriId, portInfoPhyIfType=portInfoPhyIfType, ospf3IfInfoInstanceID=ospf3IfInfoInstanceID, stgNewCfgDefaultCfg=stgNewCfgDefaultCfg, ipNewCfgIntfAdvInterval=ipNewCfgIntfAdvInterval, virtVMwareNameTableUpdate=virtVMwareNameTableUpdate, ospf3NewCfgRangeAddr=ospf3NewCfgRangeAddr, lldpInfoRemoteDevicesLocalPort=lldpInfoRemoteDevicesLocalPort, bgpNewCfgPeerPassword=bgpNewCfgPeerPassword, acl6NewCfgSrcIPv6PrefixLen=acl6NewCfgSrcIPv6PrefixLen, ipNewCfgIntfIndex=ipNewCfgIntfIndex, ipRoute6InfoIndx=ipRoute6InfoIndx, ospfIfInfoAdminStatus=ospfIfInfoAdminStatus, stpInfoPortIndex=stpInfoPortIndex, dot1RatePortInFrames=dot1RatePortInFrames, ospf3CumNbrExchange=ospf3CumNbrExchange, ipsecCfg=ipsecCfg, tacNewCfgPrimaryServer=tacNewCfgPrimaryServer, bgpNewCfgGroupClient=bgpNewCfgGroupClient, ipCurCfgStaticNbrEntry=ipCurCfgStaticNbrEntry, ldapNewCfgPorttoUse=ldapNewCfgPorttoUse, ipNewCfgBootpBcastDomainTable=ipNewCfgBootpBcastDomainTable, aclNewCfgPortAddAcl6=aclNewCfgPortAddAcl6, sshNewCfgSSHPort=sshNewCfgSSHPort, vnicNewCfgVnicPortIndex=vnicNewCfgVnicPortIndex, ipNewCfgStaticArpAction=ipNewCfgStaticArpAction, ospfNewCfgVirtIntfDeadMS=ospfNewCfgVirtIntfDeadMS, bgpInfoGroupPeersNum=bgpInfoGroupPeersNum, agent=agent, agNewCfgConsole=agNewCfgConsole)
mibBuilder.exportSymbols("IBM-GbTOR-10G-L2L3-MIB", mcastFdbCurCfgMac=mcastFdbCurCfgMac, allportsStatsOutBcast=allportsStatsOutBcast, vlanCurCfgTableEntry=vlanCurCfgTableEntry, trunkGroupNewCfgIndex=trunkGroupNewCfgIndex, swAcntLocked=swAcntLocked, lldpInfoRemoteDevicesChassisId=lldpInfoRemoteDevicesChassisId, vrrpCurCfgVirtRtrGrpTckIpIntf=vrrpCurCfgVirtRtrGrpTckIpIntf, ibm_switch=ibm_switch, agNewCfgSyslogHostPort=agNewCfgSyslogHostPort, ipStaticRoute6ClearAllByInterface=ipStaticRoute6ClearAllByInterface, igmpCurCfgQurStartupInt=igmpCurCfgQurStartupInt, ibmnosSfpInfoSerialNumber=ibmnosSfpInfoSerialNumber, vrrpCurCfgVirtRtrGrpTableEntry=vrrpCurCfgVirtRtrGrpTableEntry, ospf3NewCfgIntfTable=ospf3NewCfgIntfTable, allportsStatsInBcastRate=allportsStatsInBcastRate, aclCurCfg8021pPriority=aclCurCfg8021pPriority, ospf3CurCfgIntfLsaSupress=ospf3CurCfgIntfLsaSupress, vnicNewCfgVnicIndex=vnicNewCfgVnicIndex, ospfLsdbInfoAge=ospfLsdbInfoAge, bgpGroupTableMax=bgpGroupTableMax, bgpInfoDynamicPeerEntry=bgpInfoDynamicPeerEntry, lacpInfoPortGeneralIndex=lacpInfoPortGeneralIndex, ospf3CurCfgRangeAddr=ospf3CurCfgRangeAddr, ospf3NewCfgRedistTable=ospf3NewCfgRedistTable, mcastFdbTable=mcastFdbTable, swVMGroupVMOnline=swVMGroupVMOnline, agAccessUserNewCos=agAccessUserNewCos, virtVMwareHostDetailInfoVlanID=virtVMwareHostDetailInfoVlanID, udldInfoPortNeighborCount=udldInfoPortNeighborCount, tacCurCfgSecPorttoUse=tacCurCfgSecPorttoUse, ospfIntfNbrLoadingDone=ospfIntfNbrLoadingDone, ospf3General=ospf3General, lacpInfoPortMoved=lacpInfoPortMoved, hotlinksNewCfgTriggerBackupPort=hotlinksNewCfgTriggerBackupPort, vlanNewCfgRemovePort=vlanNewCfgRemovePort, virtVMwareHostNameName=virtVMwareHostNameName, stpInfoDesignatedRoot=stpInfoDesignatedRoot, stpInfoMaxAge=stpInfoMaxAge, fipsPortNewCfgTable=fipsPortNewCfgTable, ospf3IntfNbrDown=ospf3IntfNbrDown, ipEcmpHashDIPAddr=ipEcmpHashDIPAddr, ospf3CurCfgIntfEncryAuthType=ospf3CurCfgIntfEncryAuthType, ospfIfInfoTransitDelay=ospfIfInfoTransitDelay, ipv6InDiscards=ipv6InDiscards, ospf3CurCfgIntfIndex=ospf3CurCfgIntfIndex, nsnmpInGenErrs=nsnmpInGenErrs, lldpCurCfgPortportdesctlv=lldpCurCfgPortportdesctlv, ikeNewCfgPskRemoteEntry=ikeNewCfgPskRemoteEntry, vmbwCurCfgTxRate=vmbwCurCfgTxRate, ospf3NewCfgIntfTrans=ospf3NewCfgIntfTrans, rip2Stats=rip2Stats, bgpInfoKeepalive=bgpInfoKeepalive, ospf3IfInfoEncryKey=ospf3IfInfoEncryKey, failoverCurCfgTriggerTableEntry=failoverCurCfgTriggerTableEntry, ospf3CurCfgIntfPoll=ospf3CurCfgIntfPoll, ospf3NewCfgVirtIntfHello=ospf3NewCfgVirtIntfHello, vnicCurCfgGroupTable=vnicCurCfgGroupTable, ipv6icmpInTmexceeded=ipv6icmpInTmexceeded, qosNewCfgPriorityCoSTable=qosNewCfgPriorityCoSTable, vlanNewCfgAddPort=vlanNewCfgAddPort, ipNewCfgBootpState=ipNewCfgBootpState, igmpStaticMrtrNewCfgDelete=igmpStaticMrtrNewCfgDelete, lacpInfoPortReadyN=lacpInfoPortReadyN, ipsecCurCfgDynamicPolicyTxform=ipsecCurCfgDynamicPolicyTxform, ospfNewCfgIbgpMetric=ospfNewCfgIbgpMetric, aclNewCfgDstMACAddress=aclNewCfgDstMACAddress, ipsecSpdInfoEntry=ipsecSpdInfoEntry, ospfLsdbInfoChecksum=ospfLsdbInfoChecksum, vlagNewCfgTrunkTable=vlagNewCfgTrunkTable, agCurCfgResetControl=agCurCfgResetControl, ipNewCfgIntfIp6Host=ipNewCfgIntfIp6Host, bgpInfoDynamicPeerTtl=bgpInfoDynamicPeerTtl, ibmnosFdbVlanId=ibmnosFdbVlanId, ipNewCfgIntfAdvLifetime=ipNewCfgIntfAdvLifetime, geaportInfo=geaportInfo, ospf3AreaIntfAllEvents=ospf3AreaIntfAllEvents, ipCurCfgNwfEntry=ipCurCfgNwfEntry, ripStatInRequestPkts=ripStatInRequestPkts, vlagInfoSystemMac=vlagInfoSystemMac, tcpMGMTIndx=tcpMGMTIndx, ecpChnlPort=ecpChnlPort, agNewCfgDefipMgtb=agNewCfgDefipMgtb, vmapNewCfgEthernetReset=vmapNewCfgEthernetReset, agNetbootTftpAddr=agNetbootTftpAddr, oamInfoPortLocalSatisfied=oamInfoPortLocalSatisfied, mldNewInterfaceVersion=mldNewInterfaceVersion, agCurCfgSysDlight=agCurCfgSysDlight, vlagCurCfgLacpTable=vlagCurCfgLacpTable, portInfoLearning=portInfoLearning, mldStatBadChecksum=mldStatBadChecksum, ospf3ClearStats=ospf3ClearStats, vmapVlanCurCfgServerPortsVlanIdx=vmapVlanCurCfgServerPortsVlanIdx, swCistTopologyChanged=swCistTopologyChanged, ntpLastUpdateServer=ntpLastUpdateServer, bgpNewCfgPeerAdvert=bgpNewCfgPeerAdvert, ipStaticRouteTableMaxSize=ipStaticRouteTableMaxSize, fipsInfoFcfPort=fipsInfoFcfPort, failoverInfoMonPortStateTable=failoverInfoMonPortStateTable, ripStatInBadSizePkts=ripStatInBadSizePkts, virtVMwareHostDetailInfoUUID=virtVMwareHostDetailInfoUUID, virtVMwareVMInfoVlanID=virtVMwareVMInfoVlanID, bgpNewCfgGroupRipState=bgpNewCfgGroupRipState, vmCurCfgCheckAclsMax=vmCurCfgCheckAclsMax, vmapStatsHits=vmapStatsHits, acl=acl, ospf3TotalNumberOfAsScopeLsas=ospf3TotalNumberOfAsScopeLsas, ospfAreaNbrDown=ospfAreaNbrDown, virtGeneral=virtGeneral, lldpInfoRemoteDevicesSystemName=lldpInfoRemoteDevicesSystemName, agAccessUserCurCfgUId=agAccessUserCurCfgUId, ospfLoopIfInfoEvents=ospfLoopIfInfoEvents, rip2NewCfgUpdatePeriod=rip2NewCfgUpdatePeriod, agAccessUserNewCfgTable=agAccessUserNewCfgTable, ospfNewCfgAreaType=ospfNewCfgAreaType, lldpStatsFramesOutTotal=lldpStatsFramesOutTotal, ndprefixNewCfgInterfaceIndex=ndprefixNewCfgInterfaceIndex, tcpStats=tcpStats, ikeNewCfgPskRemoteAddr=ikeNewCfgPskRemoteAddr, ospfNewCfgIntfRetra=ospfNewCfgIntfRetra, stgNewCfgPortState=stgNewCfgPortState, dnsNewCfgSecondaryIpAddr=dnsNewCfgSecondaryIpAddr, ospfIfInfoRetransmit=ospfIfInfoRetransmit, ospf3CurCfgRangeRouteTag=ospf3CurCfgRangeRouteTag, dhcpSnoopingCurCfgVlanOnState=dhcpSnoopingCurCfgVlanOnState, failoverNewCfgTriggerMconTrunkAdd=failoverNewCfgTriggerMconTrunkAdd, vrrpInfo=vrrpInfo, ipInterfaceCfg=ipInterfaceCfg, bgpInfoPeerIndex=bgpInfoPeerIndex, ospf3TmrsKckOffWait=ospf3TmrsKckOffWait, bgpNewCfgGroupAlive=bgpNewCfgGroupAlive, agentOper=agentOper, sflowCurPortCfgTableId=sflowCurPortCfgTableId, igmpSnoopNewCfgFlood=igmpSnoopNewCfgFlood, stgNewCfgPortTableEntry=stgNewCfgPortTableEntry, swTempReturnThreshold=swTempReturnThreshold, portStatsPhyIfInUnknownProtos=portStatsPhyIfInUnknownProtos, vmNewCfgGroupRemLacpKey=vmNewCfgGroupRemLacpKey, vmapCurCfgMeterAction=vmapCurCfgMeterAction, igmpFltCurCfgState=igmpFltCurCfgState, ospfIntfErrDeadMismatch=ospfIntfErrDeadMismatch, ospfNewCfgAreaEntry=ospfNewCfgAreaEntry, acl6StatsHits=acl6StatsHits, lldpInfoRemoteDevicesTable=lldpInfoRemoteDevicesTable, routeStatBgpEntries=routeStatBgpEntries, ospf3IntfChangeStats=ospf3IntfChangeStats, ospfNewCfgMdkeyIndex=ospfNewCfgMdkeyIndex, ospfIntfRxlsReqs=ospfIntfRxlsReqs, ospfLoopIfInfoAdminStatus=ospfLoopIfInfoAdminStatus, aclNewCfgProtocol=aclNewCfgProtocol, ipStaticNbrTableMaxSize=ipStaticNbrTableMaxSize, virtNewCfgVMwareHelloAddr=virtNewCfgVMwareHelloAddr, ndprefixCurCfgState=ndprefixCurCfgState, vlagCurCfgHlthchkConnectRetryInterval=vlagCurCfgHlthchkConnectRetryInterval, vmapGroupCurCfgNonServerPortsVmapBitmap=vmapGroupCurCfgNonServerPortsVmapBitmap, ospf3NewCfgIntfCost=ospf3NewCfgIntfCost, allportsStatsOutOctets=allportsStatsOutOctets, hardwareMACAddress=hardwareMACAddress, aclNewCfgEthernetTypeValue=aclNewCfgEthernetTypeValue, ospfArea=ospfArea, ospf3CumNbrDown=ospf3CumNbrDown, accessUserInfoIndex=accessUserInfoIndex, mldCurInterfaceState=mldCurInterfaceState, sfpInfoApproved=sfpInfoApproved, ospfNewCfgEbgpOutRmapList=ospfNewCfgEbgpOutRmapList, bgpCurCfgPeerRetry=bgpCurCfgPeerRetry, bgpCurCfgGroupOutRmapList=bgpCurCfgGroupOutRmapList, cpuProcessUtil1Min=cpuProcessUtil1Min, ospf3AreaInfoNeighborsFULLstate=ospf3AreaInfoNeighborsFULLstate, ospfAreaTxlsAcks=ospfAreaTxlsAcks, mcastFdbNewCfgPorts=mcastFdbNewCfgPorts, ipmcCurCfgStaticRouteIndx=ipmcCurCfgStaticRouteIndx, mcastFdbNewCfgDelStaticEntry=mcastFdbNewCfgDelStaticEntry, virtNewCfgVMwareHello=virtNewCfgVMwareHello, ipsecCurCfgManualPolicyPeer=ipsecCurCfgManualPolicyPeer, rxIgmpV3SourceListChangeRecords=rxIgmpV3SourceListChangeRecords, igmpNewCfgQurStartupInt=igmpNewCfgQurStartupInt, ospfIntfNbrIndex=ospfIntfNbrIndex, nostpCurCfgState=nostpCurCfgState, agPortNewCfgLinkTrap=agPortNewCfgLinkTrap, vrrpCurCfgGenTckIpIntfInc=vrrpCurCfgGenTckIpIntfInc, ospfIntfNbrChange=ospfIntfNbrChange, portStatsPhyIfOutOctets=portStatsPhyIfOutOctets, sfpInfoRXSignal=sfpInfoRXSignal, ipNewCfgIntfHopLimit=ipNewCfgIntfHopLimit, acl6NewCfgDelete=acl6NewCfgDelete, ospf3NewCfgConnectedRouteTag=ospf3NewCfgConnectedRouteTag, failoverNewCfgTriggerMmonTrunkAdd=failoverNewCfgTriggerMmonTrunkAdd, trunkGroupNewCfgRemovePort=trunkGroupNewCfgRemovePort, sfpInfoTXFault=sfpInfoTXFault, fipsInfoPortTable=fipsInfoPortTable, hotlinksNewCfgTriggerMasterPort=hotlinksNewCfgTriggerMasterPort, vmNewCfgCheckTrustAddPort=vmNewCfgCheckTrustAddPort, sw8021x=sw8021x, txIgmpReports=txIgmpReports, ospf3NewCfgHostCost=ospf3NewCfgHostCost, bgpCurCfgPeerPassive=bgpCurCfgPeerPassive, ospf3CurCfgIntfInstId=ospf3CurCfgIntfInstId, vlagStatsPduRcvFdbInactiveAdd=vlagStatsPduRcvFdbInactiveAdd, ospfNewCfgIntfHello=ospfNewCfgIntfHello, ospf3VirtIfInfoHelloInterval=ospf3VirtIfInfoHelloInterval, ipNewCfgBootpGlobalServerEntry=ipNewCfgBootpGlobalServerEntry, agCurCfgSyslogTrapVrrp=agCurCfgSyslogTrapVrrp, tacCurCfgRetries=tacCurCfgRetries, ripInfoIntfAuth=ripInfoIntfAuth, ospf3AreaErrorStatsEntry=ospf3AreaErrorStatsEntry, ipv6InUnkprots=ipv6InUnkprots, lldpStatsAgeoutsTotal=lldpStatsAgeoutsTotal, bgpInfoDynamicPeerRemoteAddr=bgpInfoDynamicPeerRemoteAddr, pmNewCfgPmirrMoniPortIndex=pmNewCfgPmirrMoniPortIndex, ospfCumTxlsUpdates=ospfCumTxlsUpdates, mirrPortMirr=mirrPortMirr, ldapNewCfgTimeout=ldapNewCfgTimeout, tcpStatsPassiveOpens=tcpStatsPassiveOpens, mldNewInterfaceQueryInterval=mldNewInterfaceQueryInterval, portStatsPhyIfOutDiscards=portStatsPhyIfOutDiscards, mstNewCfgRegionRevision=mstNewCfgRegionRevision, vlanCurCfgPrVlanState=vlanCurCfgPrVlanState, lacpInfoPortActOpDist=lacpInfoPortActOpDist, ipmcNewCfgStaticRouteEntry=ipmcNewCfgStaticRouteEntry, ospf3IntfRxTxDisdStats=ospf3IntfRxTxDisdStats, tacNewCfgAttempts=tacNewCfgAttempts, acl6CurCfgIPv6TrafficClass=acl6CurCfgIPv6TrafficClass, ipmcNewCfgStaticRouteIndx=ipmcNewCfgStaticRouteIndx, agCurRFC4741NetconfSshAccess=agCurRFC4741NetconfSshAccess, g8124_mgmt=g8124_mgmt, agNewCfgSyslogTrapCfgchg=agNewCfgSyslogTrapCfgchg, agPortCurCfgOam=agPortCurCfgOam, ospf3NewCfgExtRangeDelete=ospf3NewCfgExtRangeDelete, ipStaticRouteClearAllByDestIp=ipStaticRouteClearAllByDestIp, vrrpCurCfgIfPasswd=vrrpCurCfgIfPasswd, ospf3NewCfgStaticRouteTag=ospf3NewCfgStaticRouteTag, ospf3NewCfgRangeLsaType=ospf3NewCfgRangeLsaType, bgpNewCfgPeerInRmapList=bgpNewCfgPeerInRmapList, ospfNewCfgRangeIndex=ospfNewCfgRangeIndex, ospfNewCfgState=ospfNewCfgState, txMldIfStatsMASQuery=txMldIfStatsMASQuery, ipNewCfgIntfLoopbackState=ipNewCfgIntfLoopbackState, ipsecInfo=ipsecInfo, portMgmtStatsTableEntry=portMgmtStatsTableEntry, ripNewCfgIntfSplitHorizon=ripNewCfgIntfSplitHorizon, portInfoErrDisableTimeLeft=portInfoErrDisableTimeLeft, fdbCurCfgAdminkey=fdbCurCfgAdminkey, agNewRFC4741NetconfSshPort=agNewRFC4741NetconfSshPort, failoverInfoTriggerCtlId=failoverInfoTriggerCtlId, ipCurCfgStaticRouteInterface=ipCurCfgStaticRouteInterface, vlanNewCfgPrVlanMapPriId=vlanNewCfgPrVlanMapPriId, ospfCumTxlsReqs=ospfCumTxlsReqs, dnsNewCfgPrimaryIpAddr=dnsNewCfgPrimaryIpAddr, mstNewCfgStpMode=mstNewCfgStpMode, ripNewCfgIntfMcastUpdate=ripNewCfgIntfMcastUpdate, lldpNewCfgPortframesztlv=lldpNewCfgPortframesztlv, vmapCurCfgMeterEnable=vmapCurCfgMeterEnable, agPortNewCfgEdge=agPortNewCfgEdge, agPortCurCfgLearning=agPortCurCfgLearning)
mibBuilder.exportSymbols("IBM-GbTOR-10G-L2L3-MIB", bgpNewCfgGroupDefaultAction=bgpNewCfgGroupDefaultAction, ospf3NewCfgNbrDelete=ospf3NewCfgNbrDelete, ipCurCfgBootpAddr2=ipCurCfgBootpAddr2, igmpFltCurCfgMcastIp1=igmpFltCurCfgMcastIp1, mldStatReceiveNonLocal=mldStatReceiveNonLocal, ospfCurCfgVirtIntfMdkey=ospfCurCfgVirtIntfMdkey, agCurCfgSysCustomDstState=agCurCfgSysCustomDstState, ospfCurCfgLoopIfTable=ospfCurCfgLoopIfTable, agApplyPending=agApplyPending, virt=virt, vrrpNewCfgVirtRtrGrpDelete=vrrpNewCfgVirtRtrGrpDelete, accessInfoClearAllUserFailAttempts=accessInfoClearAllUserFailAttempts, ndprefixCurCfgInterfaceIndex=ndprefixCurCfgInterfaceIndex, ipCurCfgIntfIp6Host=ipCurCfgIntfIp6Host, ripStatOutResponsePkts=ripStatOutResponsePkts, mstCistNewCfgAddVlan=mstCistNewCfgAddVlan, hwSwitchSoftwareVersion=hwSwitchSoftwareVersion, ipsecNewCfgIfAddDynamicPolicy=ipsecNewCfgIfAddDynamicPolicy, tacNewCfgCmdLogging=tacNewCfgCmdLogging, vlagStatsPduSentPeerInstanceDisable=vlagStatsPduSentPeerInstanceDisable, ipCurCfgIntfLoopbackState=ipCurCfgIntfLoopbackState, ospfIntfTableMaxSize=ospfIntfTableMaxSize, icmpStatsInRedirects=icmpStatsInRedirects, dhcpSnoopingNewCfgPortTable=dhcpSnoopingNewCfgPortTable, ipmcNewCfgStaticRouteTrunks=ipmcNewCfgStaticRouteTrunks, ipCurCfgNwfAddr=ipCurCfgNwfAddr, ospfCurCfgEbgpMetric=ospfCurCfgEbgpMetric, hotlinksInfoFdbUpdateRate=hotlinksInfoFdbUpdateRate, lldpInfoRemoteDevicesPortId=lldpInfoRemoteDevicesPortId, ikeNewCfgProposal=ikeNewCfgProposal, ipv6PmtuEntriesClearAll=ipv6PmtuEntriesClearAll, ipNewCfgAlistIndex=ipNewCfgAlistIndex, ospfLoopIfInfoDesignatedRouterIP=ospfLoopIfInfoDesignatedRouterIP, ospf3NewCfgAreaId=ospf3NewCfgAreaId, ospf3NewCfgAreaTranslRole=ospf3NewCfgAreaTranslRole, stgCfg=stgCfg, ipRouteEcmpInfoTable=ipRouteEcmpInfoTable, ospfNewCfgMdkeyKey=ospfNewCfgMdkeyKey, acl6CurCfgInprofDscpEnable=acl6CurCfgInprofDscpEnable, hotlinksNewCfgTriggerName=hotlinksNewCfgTriggerName, ipv6udpInDgrams=ipv6udpInDgrams, bgpInfoGroupTable=bgpInfoGroupTable, hotlinksStatsTriggerId=hotlinksStatsTriggerId, vmapGroupCurCfgServerPortsTable=vmapGroupCurCfgServerPortsTable, ospfCurCfgDefaultRouteMetricType=ospfCurCfgDefaultRouteMetricType, ospf3CurCfgStaticRouteTag=ospf3CurCfgStaticRouteTag, bgpInfoGroupName=bgpInfoGroupName, agCurCfgUserBBI=agCurCfgUserBBI, vmapCurCfgSrcIPAddress=vmapCurCfgSrcIPAddress, hotlinksInfoTriggerName=hotlinksInfoTriggerName, udldInfoNeighborDeviceName=udldInfoNeighborDeviceName, vlagInfoRemoteMac=vlagInfoRemoteMac, nsnmpInBadValues=nsnmpInBadValues, ospfIntfRxTxStats=ospfIntfRxTxStats, lacpInfoAggrNumPorts=lacpInfoAggrNumPorts, ospfCurCfgMdkeyIndex=ospfCurCfgMdkeyIndex, ipv6InReceives=ipv6InReceives, hotlinksStatsTriggerMasterActive=hotlinksStatsTriggerMasterActive, aclCurCfgTable=aclCurCfgTable, ipsecCurCfgManualPolicyOutEspSpi=ipsecCurCfgManualPolicyOutEspSpi, portInfoExtGuard=portInfoExtGuard, agCurCfgIdleCLITimeout=agCurCfgIdleCLITimeout, mldInfoInterfaceEntry=mldInfoInterfaceEntry, vlagStatsPduSentFdbDynamicAdd=vlagStatsPduSentFdbDynamicAdd, ipStaticRoute6ClearAll=ipStaticRoute6ClearAll, vmapNewCfgEntry=vmapNewCfgEntry, ospf3CurCfgIntfEncryType=ospf3CurCfgIntfEncryType, fdbNewCfgAddMac=fdbNewCfgAddMac, ospfIfInfoWaitIntervalMS=ospfIfInfoWaitIntervalMS, ospfIntfHello=ospfIntfHello, vnicNewCfgVnicEntry=vnicNewCfgVnicEntry, lacpCurSystemPriority=lacpCurSystemPriority, ipsecNewCfgTxformMode=ipsecNewCfgTxformMode, vlagCurCfgTrunkTable=vlagCurCfgTrunkTable, ipCurCfgGwInterval=ipCurCfgGwInterval, errMldIfStatsIncCrsv2=errMldIfStatsIncCrsv2, mldInfoGroupAddress=mldInfoGroupAddress, ipsecNewCfgDynamicPolicyPeer=ipsecNewCfgDynamicPolicyPeer, fdbNewCfgAddVlan=fdbNewCfgAddVlan, ospf3NewCfgExtRangeAggrEffect=ospf3NewCfgExtRangeAggrEffect, bgpNewCfgGroupRASTable=bgpNewCfgGroupRASTable, ospf3CumRxlsUpdates=ospf3CumRxlsUpdates, udldInfoNeighborLocalPortIndex=udldInfoNeighborLocalPortIndex, ipsecNewCfgManualPolicyOutAhSpi=ipsecNewCfgManualPolicyOutAhSpi, fipsInfoVlansFeatureIndex=fipsInfoVlansFeatureIndex, tor_switch=tor_switch, vmNewCfgProfileShapingPeak=vmNewCfgProfileShapingPeak, lldpCurCfgMsgTxHld=lldpCurCfgMsgTxHld, ripRedistributeIbgp=ripRedistributeIbgp, failoverCurCfgTriggerMmonTrunk=failoverCurCfgTriggerMmonTrunk, ipNewCfgIntfReachTime=ipNewCfgIntfReachTime, dataCollection=dataCollection, lldpInfoTxLocalChanged=lldpInfoTxLocalChanged, ospf3IntfDr=ospf3IntfDr, lacpCurPortState=lacpCurPortState, lacpStatsTable=lacpStatsTable, nsnmpInReadOnlys=nsnmpInReadOnlys, ospfIntfInfoTable=ospfIntfInfoTable, agSyslogMsgIndex=agSyslogMsgIndex, qosCurCfgPortPriority=qosCurCfgPortPriority, bgpCurCfgGroupAlive=bgpCurCfgGroupAlive, bgpCurCfgGroupRASIndex=bgpCurCfgGroupRASIndex, vlagInfoHlthchkStatus=vlagInfoHlthchkStatus, vmGroupInfoGroup=vmGroupInfoGroup, ipFloodCurCfgFlood=ipFloodCurCfgFlood, swTrapDisplayString=swTrapDisplayString, vrrpCurCfgIfTableEntry=vrrpCurCfgIfTableEntry, ospf3AreaInfoIndex=ospf3AreaInfoIndex, fcoeStatsFcfRemoved=fcoeStatsFcfRemoved, ospf3NewCfgRangeRouteTag=ospf3NewCfgRangeRouteTag, ospf3IntfErrDeadMismatch=ospf3IntfErrDeadMismatch, icmpStatsInTimestamps=icmpStatsInTimestamps, ripNewCfgIbgpAddOutRmap=ripNewCfgIbgpAddOutRmap, bgpNewCfgGroupLimit=bgpNewCfgGroupLimit, bgpNewCfgAggrEntry=bgpNewCfgAggrEntry, lacpInfoPortActSysPrio=lacpInfoPortActSysPrio, geaportInfoLogicalIndex=geaportInfoLogicalIndex, rxIgmpV3CurrentStateRecords=rxIgmpV3CurrentStateRecords, ospfCurCfgVirtIntfDead=ospfCurCfgVirtIntfDead, agCurCfgDcbx=agCurCfgDcbx, ospf3VlinkCountForRouter=ospf3VlinkCountForRouter, ospfCumNbrExchangeDone=ospfCumNbrExchangeDone, ospfExtLsdbInfoEntry=ospfExtLsdbInfoEntry, ipNewCfgStaticNbrTable=ipNewCfgStaticNbrTable, vmapGroupCurCfgAllPortsTableEntry=vmapGroupCurCfgAllPortsTableEntry, ospfIfInfoWaitInterval=ospfIfInfoWaitInterval, ospf3RoutesInfoEntry=ospf3RoutesInfoEntry, vmapGroupCurCfgNonServerPortsTableEntry=vmapGroupCurCfgNonServerPortsTableEntry, ibmnosConfigSaveOption=ibmnosConfigSaveOption, vlagInfoInstanceTable=vlagInfoInstanceTable, agNewCfgMgmtNetMask=agNewCfgMgmtNetMask, vlagStatsIgmpLeavesForwarded=vlagStatsIgmpLeavesForwarded, agPortNewCfgUdldMode=agPortNewCfgUdldMode, igmpSnoopCurCfgRtrAlert=igmpSnoopCurCfgRtrAlert, aclNewCfgPortAcl6Bmap=aclNewCfgPortAcl6Bmap, agTacacsUserMapNewCfgMapping=agTacacsUserMapNewCfgMapping, agNewCfgTelnetServerPort=agNewCfgTelnetServerPort, lldpInfoRxRcvFrame=lldpInfoRxRcvFrame, ospf3CurCfgHostIndex=ospf3CurCfgHostIndex, bgpCurCfgPeerNexthopSelf=bgpCurCfgPeerNexthopSelf, ospfNewCfgRangeAreaIndex=ospfNewCfgRangeAreaIndex, mcastFdbNewCfgTable=mcastFdbNewCfgTable, lacpInfoPortPerState=lacpInfoPortPerState, vlagNewCfgLacpState=vlagNewCfgLacpState, ospfNewCfgLoopIfArea=ospfNewCfgLoopIfArea, mldCurInterfaceDMrtrEna=mldCurInterfaceDMrtrEna, ipv6icmpOutToobig=ipv6icmpOutToobig, igmpInfoGrpExpires=igmpInfoGrpExpires, hotlinksCurCfgTriggerId=hotlinksCurCfgTriggerId, vmNewCfgGroupRemTrunk=vmNewCfgGroupRemTrunk, ospfAreaErrDeadMismatch=ospfAreaErrDeadMismatch, vmapVlanNewCfgAllPortsVlanIdx=vmapVlanNewCfgAllPortsVlanIdx, igmpNewCfgQurRobustness=igmpNewCfgQurRobustness, qosCurCfgPriorityIndex=qosCurCfgPriorityIndex, ipsecCurCfgIfEntry=ipsecCurCfgIfEntry, vmGroupInfoIdx=vmGroupInfoIdx, tcpStatsEstabResets=tcpStatsEstabResets, aclNewCfgTable=aclNewCfgTable, ospf3CurCfgAreaDefaultMetricType=ospf3CurCfgAreaDefaultMetricType, portInfoErrDisableRecovery=portInfoErrDisableRecovery, ipv6InNsols=ipv6InNsols, ipCurCfgBootpOpt82Policy=ipCurCfgBootpOpt82Policy, mldCurInterfaceRobustness=mldCurInterfaceRobustness, bgpNewCfgPeerDelete=bgpNewCfgPeerDelete, ipNewCfgRmapMetricType=ipNewCfgRmapMetricType, ospfIntfUnloop=ospfIntfUnloop, sflowNewPortPolling=sflowNewPortPolling, tacNewCfgSecBd=tacNewCfgSecBd, lldpInfoPortRxChanges=lldpInfoPortRxChanges, arpInfoDestIp=arpInfoDestIp, nbrInfoMacAddr=nbrInfoMacAddr, vmapCurCfgOutprofDscpEnable=vmapCurCfgOutprofDscpEnable, ospf3AreaErrBadDestAddr=ospf3AreaErrBadDestAddr, ipRouteEcmpInfoInterface=ipRouteEcmpInfoInterface, vmapCurCfgKbitsSec=vmapCurCfgKbitsSec, bgpCurCfgGroupStaticState=bgpCurCfgGroupStaticState, ospf3NewCfgHostState=ospf3NewCfgHostState, aclNewCfgMbitsSec=aclNewCfgMbitsSec, swVMGroupVMVlanChange=swVMGroupVMVlanChange, virtVMwareVMNameEntry=virtVMwareVMNameEntry, vmapGroupCurCfgServerPortsGroupIdx=vmapGroupCurCfgServerPortsGroupIdx, lldpNewCfgNotifInt=lldpNewCfgNotifInt, lldpStatsIndex=lldpStatsIndex, ospf3VirtIfInfoRetransInterval=ospf3VirtIfInfoRetransInterval, portStatsDot1StpPortForwardTransitions=portStatsDot1StpPortForwardTransitions, ipsecSaInfoSrcAddr=ipsecSaInfoSrcAddr, ndprefixNewCfgPrefix=ndprefixNewCfgPrefix, vmCurCfgGroupEntry=vmCurCfgGroupEntry, ripCurCfgFixedMetric=ripCurCfgFixedMetric, ospf3IntfErrRxOnPasv=ospf3IntfErrRxOnPasv, vmCurCfgProfileShapingAverage=vmCurCfgProfileShapingAverage, allportsStatsInUnknownProtos=allportsStatsInUnknownProtos, bgpInfoRtrTableEntry=bgpInfoRtrTableEntry, pktStatsFrees=pktStatsFrees, vmapCurCfgDstIPAddress=vmapCurCfgDstIPAddress, ospfCurCfgVirtIntfHelloMS=ospfCurCfgVirtIntfHelloMS, ipNewCfgBootpBcastDomainServerTable=ipNewCfgBootpBcastDomainServerTable, ospf3IntfErrorStatsEntry=ospf3IntfErrorStatsEntry, dhcpSnoopingNewCfgOption82OnState=dhcpSnoopingNewCfgOption82OnState, ipGatewayCfg=ipGatewayCfg, lacpInfoPortPartOpSysId=lacpInfoPortPartOpSysId, ospf3IfInfoDead=ospf3IfInfoDead, ospfRedistributeRip=ospfRedistributeRip, arpInfoEntry=arpInfoEntry, agNewCfgSysCustomDstState=agNewCfgSysCustomDstState, pptNewCfgIndx=pptNewCfgIndx, radNewCfgPrimaryServer=radNewCfgPrimaryServer, ntpPrimaryServerReqSent=ntpPrimaryServerReqSent, ospf3AreaInfoSPF=ospf3AreaInfoSPF, mldInfoInterfaceGroups=mldInfoInterfaceGroups, remotePort=remotePort, lldpInfoRemoteDevicesManAddrEntry=lldpInfoRemoteDevicesManAddrEntry, igmpMrtrInfoVlanId=igmpMrtrInfoVlanId, IPsecKeyString=IPsecKeyString, vmGroupInfoTbl=vmGroupInfoTbl, ospfNewCfgVirtIntfHelloMS=ospfNewCfgVirtIntfHelloMS, igmpStaticMrtrCurCfgTable=igmpStaticMrtrCurCfgTable, igmpStaticMrtrCurCfgPortId=igmpStaticMrtrCurCfgPortId, hwTemperatureSensor1=hwTemperatureSensor1, ipEcmpHashNumberPaths=ipEcmpHashNumberPaths, ospf3AreaDisdlsUpdates=ospf3AreaDisdlsUpdates, vlagNewCfgSwitchPriority=vlagNewCfgSwitchPriority, ipStaticRoute6TableMaxSize=ipStaticRoute6TableMaxSize, failoverInfo=failoverInfo, vmapGroupNewCfgAllPortsGroupIdx=vmapGroupNewCfgAllPortsGroupIdx, ospfLoopIfInfoTransitDelay=ospfLoopIfInfoTransitDelay, ipNewCfgIntfRetransmitTimer=ipNewCfgIntfRetransmitTimer, virtVMwareHostDetailInfoHostName=virtVMwareHostDetailInfoHostName, ipNewCfgStaticRoute6Interface=ipNewCfgStaticRoute6Interface, swFanFailure=swFanFailure, igmpFltNewCfgAction=igmpFltNewCfgAction, ipv6ForwDgrams=ipv6ForwDgrams, ospfNewCfgVirtIntfAuthKey=ospfNewCfgVirtIntfAuthKey, ecpChnlState=ecpChnlState, vlanInfoTableEntry=vlanInfoTableEntry, ceeNewCfgState=ceeNewCfgState, igmpFltCurCfgPortFiltBmap=igmpFltCurCfgPortFiltBmap, ipsecNewCfgManualPolicyOutEspAuthKey=ipsecNewCfgManualPolicyOutEspAuthKey, mldCurInterfaceQueryMaxResponseIntvl=mldCurInterfaceQueryMaxResponseIntvl, fdbInfo=fdbInfo, stpInfoPortEdge=stpInfoPortEdge, ospf3VirtIfInfoTransitDelay=ospf3VirtIfInfoTransitDelay, mstNewCfgRegionName=mstNewCfgRegionName, vlagStatsPduRcvRoleElection=vlagStatsPduRcvRoleElection, agNewCfgCpuRateLimitArp=agNewCfgCpuRateLimitArp, vmapNewCfgTable=vmapNewCfgTable, lacpInfoPortActAdExp=lacpInfoPortActAdExp, accessUserInfoTableEntry=accessUserInfoTableEntry, ospf3AreaTxPkts=ospf3AreaTxPkts, vmapNewCfgSrcIPAddress=vmapNewCfgSrcIPAddress, stgCurCfgPortTableEntry=stgCurCfgPortTableEntry, ripNewCfgEbgpAddOutRmap=ripNewCfgEbgpAddOutRmap, ipNewCfgStaticArpTable=ipNewCfgStaticArpTable, agAccessUserCurCfgTableEntry=agAccessUserCurCfgTableEntry)
mibBuilder.exportSymbols("IBM-GbTOR-10G-L2L3-MIB", vlagInfoIslAdminkey=vlagInfoIslAdminkey, ndprefixNewCfgProfileIndex=ndprefixNewCfgProfileIndex, vmapCurCfgSrcMACAddress=vmapCurCfgSrcMACAddress, accessUserInfoTable=accessUserInfoTable, ibmnosConfigRestoreFileVersion=ibmnosConfigRestoreFileVersion, ipCurCfgAspathTable=ipCurCfgAspathTable, swVlagInstanceDown=swVlagInstanceDown, ipsecNewCfgDynamicPolicyTable=ipsecNewCfgDynamicPolicyTable, mldNewCfgState=mldNewCfgState, lldpInfoPortprotidtlv=lldpInfoPortprotidtlv, tacChangePassForServer=tacChangePassForServer, vmapVlanNewCfgServerPortsTable=vmapVlanNewCfgServerPortsTable, vrrpNewCfgGenHoldoff=vrrpNewCfgGenHoldoff, lldpInfoRemoteDevicesPortSubtype=lldpInfoRemoteDevicesPortSubtype, ospfCurCfgIntfCost=ospfCurCfgIntfCost, ospf3StartTime=ospf3StartTime, igmpFltNewCfgEnaDis=igmpFltNewCfgEnaDis, vmapNewCfgTCPFlagsMask=vmapNewCfgTCPFlagsMask, agCurHttpAcces=agCurHttpAcces, aclCurCfgPortAclBmap=aclCurCfgPortAclBmap, vnicCurCfgGroupTrunk=vnicCurCfgGroupTrunk, mldInfo=mldInfo, lldpStatsFramesInErrorsTotal=lldpStatsFramesInErrorsTotal, bgpNewCfgPeerTtl=bgpNewCfgPeerTtl, ripInfoIntfKey=ripInfoIntfKey, lldpNewCfgTxDelay=lldpNewCfgTxDelay, mldNewInterfaceDefault=mldNewInterfaceDefault, sflowNewPortCfgTableEntry=sflowNewPortCfgTableEntry, ospfAreaNbrLoadingDone=ospfAreaNbrLoadingDone, aclCurCfgDstPort=aclCurCfgDstPort, sfpInfoSerial=sfpInfoSerial, bgpInfoOrigin=bgpInfoOrigin, ospfNewCfgHostIpAddr=ospfNewCfgHostIpAddr, ospfIfInfoPtop=ospfIfInfoPtop, ospf3AreaInfoStatus=ospf3AreaInfoStatus, localPort=localPort, agCurCfgSyslogTrapOspf=agCurCfgSyslogTrapOspf, vmapNewCfgDstPortMask=vmapNewCfgDstPortMask, lacpInfoPortPartOpDef=lacpInfoPortPartOpDef, trunkGroupInfo=trunkGroupInfo, ospf3IfInfoIndex=ospf3IfInfoIndex, vmapNewCfgDstMACMask=vmapNewCfgDstMACMask, vmCurCfgGroupProfileName=vmCurCfgGroupProfileName, ipCurCfgIntfIp6Dstun=ipCurCfgIntfIp6Dstun, ipDataRouteInfoMetric=ipDataRouteInfoMetric, lacpInfoPortPartOpTimeout=lacpInfoPortPartOpTimeout, stgNewCfgRemoveAllVlan=stgNewCfgRemoveAllVlan, lacpInfo=lacpInfo, igmpV3SnoopCurCfgV1V2EnaDis=igmpV3SnoopCurCfgV1V2EnaDis, ospf3NewCfgNbrIntfIndex=ospf3NewCfgNbrIntfIndex, ospfLoopIfInfoPassive=ospfLoopIfInfoPassive, hwPowerSupply1State=hwPowerSupply1State, mcastFdbCurCfgEntry=mcastFdbCurCfgEntry, aclCurCfgMeterEnable=aclCurCfgMeterEnable, lldpInfoRemoteDevicesPortDescription=lldpInfoRemoteDevicesPortDescription, ospf3CumNbrChangeStats=ospf3CumNbrChangeStats, intfInfoNetMask=intfInfoNetMask, markerresponsepdusRx=markerresponsepdusRx, ospf3CumNbrLoading=ospf3CumNbrLoading, ndprefixCfg=ndprefixCfg, ospfLoopIfInfoTable=ospfLoopIfInfoTable, ikeCurCfgPropAuth=ikeCurCfgPropAuth, vnicNewCfgVnicTable=vnicNewCfgVnicTable, udpStatsInDatagrams=udpStatsInDatagrams, ipCurCfgNwfTable=ipCurCfgNwfTable, ibmnosPortCfgIndx=ibmnosPortCfgIndx, ipv6ClearStats=ipv6ClearStats, bgpInfoPeerVersion=bgpInfoPeerVersion, lldpInfoRemoteDevicesChassisSubtype=lldpInfoRemoteDevicesChassisSubtype, cistInfoPortEdge=cistInfoPortEdge, aclCurCfgOutprofDscpEnable=aclCurCfgOutprofDscpEnable, vmapNewCfgEthernetTypeValue=vmapNewCfgEthernetTypeValue, aclCurCfgEthernetTypeName=aclCurCfgEthernetTypeName, vrrpNewCfgGenTckVirtRtrInc=vrrpNewCfgGenTckVirtRtrInc, ipMgmtRouteInfoTag=ipMgmtRouteInfoTag, lldpStats=lldpStats, ospf3AreaIntfLoop=ospf3AreaIntfLoop, virtVMwareHostNameIndex=virtVMwareHostNameIndex, bgpInfoSummaryTotalSentPackets=bgpInfoSummaryTotalSentPackets, agNewCfgTrapSrcLoopIf=agNewCfgTrapSrcLoopIf, agNewBootProfile=agNewBootProfile, gatewayInfoStatus=gatewayInfoStatus, ecpChnlRcvlast=ecpChnlRcvlast, dhcpSnoopingBindingInfoType=dhcpSnoopingBindingInfoType, oamInfoPortLocalStable=oamInfoPortLocalStable, ospf3IfInfoEncryEnable=ospf3IfInfoEncryEnable, ripInfoIntfSupply=ripInfoIntfSupply, nostpNewCfgState=nostpNewCfgState, ipNewCfgIntfIp6Dstun=ipNewCfgIntfIp6Dstun, bgpCurCfgGroupNexthopSelf=bgpCurCfgGroupNexthopSelf, ospfCumRxPkts=ospfCumRxPkts, ipForwardCfg=ipForwardCfg, ibmnosSfpInfoDescription=ibmnosSfpInfoDescription, ospf3NewCfgNssaAsbrDfRtTrans=ospf3NewCfgNssaAsbrDfRtTrans, vnicNewCfgGroupVnics=vnicNewCfgGroupVnics, bgpNewCfgPeerState=bgpNewCfgPeerState, igmpFltCurCfgPortTableEntry=igmpFltCurCfgPortTableEntry, portStatsPhyIfInFctlPktsRate=portStatsPhyIfInFctlPktsRate, agPortNewCfgDscpRemarking=agPortNewCfgDscpRemarking, memoryBufferStats=memoryBufferStats, ospf3CurCfgConnectedMetric=ospf3CurCfgConnectedMetric, snmpClearStats=snmpClearStats, agDiff=agDiff, ipsecCurCfgTxformAuth=ipsecCurCfgTxformAuth, vmapNewCfgSrcPortMask=vmapNewCfgSrcPortMask, stpInfoTableEntry=stpInfoTableEntry, vrrpInfoVirtRtrTableEntry=vrrpInfoVirtRtrTableEntry, vmGroupInfoUUID=vmGroupInfoUUID, vlagNewCfgHlthchkKeepaliveInterval=vlagNewCfgHlthchkKeepaliveInterval, vmNewCfgGroupVlan=vmNewCfgGroupVlan, bgpInfoRtrTable=bgpInfoRtrTable, vmapVlanCfgAllPorts=vmapVlanCfgAllPorts, hotlinksNewCfgTriggerState=hotlinksNewCfgTriggerState, mldInfoGroupLastReporter=mldInfoGroupLastReporter, ipNewCfgStaticRouteInterface=ipNewCfgStaticRouteInterface, portStatsPhyIfOutQLen=portStatsPhyIfOutQLen, ospfCurCfgStaticOutRmapList=ospfCurCfgStaticOutRmapList, ospf3NewCfgRouterId=ospf3NewCfgRouterId, ipGatewayIPv6InfoState=ipGatewayIPv6InfoState, cistInfoPortTableEntry=cistInfoPortTableEntry, vlanCurCfgVlanId=vlanCurCfgVlanId, igmpStaticMrtrNewCfgTableEntry=igmpStaticMrtrNewCfgTableEntry, oamStatsPortInfoTx=oamStatsPortInfoTx, ipsecNewCfgTxformEntry=ipsecNewCfgTxformEntry, ipGatewayIpv6TableMax=ipGatewayIpv6TableMax, ikeNewCfgPskRemoteTable=ikeNewCfgPskRemoteTable, dhcpSnoopingNewCfgVlanId=dhcpSnoopingNewCfgVlanId, ipCurCfgGwEntry=ipCurCfgGwEntry, dhcpInfoSubnetMask=dhcpInfoSubnetMask, agSyslogMsgTableMaxSize=agSyslogMsgTableMaxSize, ripInfoIntfPoisonReverse=ripInfoIntfPoisonReverse, ospfExtLsdbInfoLsid=ospfExtLsdbInfoLsid, agAccessNewDefaultAdmin=agAccessNewDefaultAdmin, aclCurCfgEthernetTypeValue=aclCurCfgEthernetTypeValue, ospfCumNbrN2way=ospfCumNbrN2way, agNewCfgSyslogTrapConsole=agNewCfgSyslogTrapConsole, ipsecCurCfgSelectorIcmpType=ipsecCurCfgSelectorIcmpType, vmapGroupNewCfgServerPortsAddVmap=vmapGroupNewCfgServerPortsAddVmap, ospfNewCfgHostAreaIndex=ospfNewCfgHostAreaIndex, tacCurCfgAttempts=tacCurCfgAttempts, failoverCurCfgTriggerMconTrunk=failoverCurCfgTriggerMconTrunk, ospfIntfRxlsUpdates=ospfIntfRxlsUpdates, ipmcNewCfgStaticRouteTable=ipmcNewCfgStaticRouteTable, vmapGroupCfgAllPorts=vmapGroupCfgAllPorts, vmapCurCfgFilterAction=vmapCurCfgFilterAction, ikeGroup=ikeGroup, bgpNewCfgGroupRASIndex=bgpNewCfgGroupRASIndex, ospf3IfInfoAdminStatus=ospf3IfInfoAdminStatus, bgpInfoLcPrf=bgpInfoLcPrf, dhcpInfoServer=dhcpInfoServer, lacpInfoPortOperState=lacpInfoPortOperState, ibmnosFdbSrcTrunk=ibmnosFdbSrcTrunk, lldpInfoPortportprottlv=lldpInfoPortportprottlv, vlagCurIslCfgPortChannel=vlagCurIslCfgPortChannel, agTacacsConfig=agTacacsConfig, ospfCurCfgVirtIntfTable=ospfCurCfgVirtIntfTable, fdbCurCfgStaticEntry=fdbCurCfgStaticEntry, vlagStatsIslOutPackets=vlagStatsIslOutPackets, ibmnosSoftwareVersion=ibmnosSoftwareVersion, virtVMwareVM=virtVMwareVM, vrrpNewCfgVirtRtrGrpTckIpIntf=vrrpNewCfgVirtRtrGrpTckIpIntf, lldpInfoPortEnabled=lldpInfoPortEnabled, aclNewCfgSrcMACAddress=aclNewCfgSrcMACAddress, vmapVlanCurCfgAllPortsVlanIdx=vmapVlanCurCfgAllPortsVlanIdx, ospfIntfRxDatabase=ospfIntfRxDatabase, ibmnosPortCfgVlanTag=ibmnosPortCfgVlanTag, bgpNewCfgGroupAddOutRmap=bgpNewCfgGroupAddOutRmap, agCurCfgHttpsServerPort=agCurCfgHttpsServerPort, ospfCurCfgIntfRetra=ospfCurCfgIntfRetra, lldpCurCfgPortpowermditlv=lldpCurCfgPortpowermditlv, stgNewCfgStgIndex=stgNewCfgStgIndex, dhcpSnoopingNewCfgVlanTableEntry=dhcpSnoopingNewCfgVlanTableEntry, vrrpInfoVirtRtrAddr=vrrpInfoVirtRtrAddr, ipNewCfgRmapState=ipNewCfgRmapState, ikeNewCfgPropGroup=ikeNewCfgPropGroup, agCurCfgSyslogTrapWeb=agCurCfgSyslogTrapWeb, ipNewCfgStaticRoute6DestIp=ipNewCfgStaticRoute6DestIp, failoverNewCfgTriggerMconPortAdd=failoverNewCfgTriggerMconPortAdd, failoverCurCfgTriggerLimit=failoverCurCfgTriggerLimit, dot1RateTpLearnedEntryDiscards=dot1RateTpLearnedEntryDiscards, bgpInfoGroupRASEntry=bgpInfoGroupRASEntry, rip2Info=rip2Info, ospf3GeneralStats=ospf3GeneralStats, portStats=portStats, ospf3IfNbrRtrID=ospf3IfNbrRtrID, bgpNewCfgAggrTable=bgpNewCfgAggrTable, ripNewCfgIntfIndex=ripNewCfgIntfIndex, hotlinksCurCfgTriggerState=hotlinksCurCfgTriggerState, ipCurCfgIntfReachTime=ipCurCfgIntfReachTime, vmbwNewCfgMac=vmbwNewCfgMac, ospf3AreaRxTxDisdStats=ospf3AreaRxTxDisdStats, arpNewCfgReARPPeriod=arpNewCfgReARPPeriod, ospf3CurCfgLSDB=ospf3CurCfgLSDB, bgpInfoLastErrorCode=bgpInfoLastErrorCode, ipsecNewCfgDynamicPolicyIndex=ipsecNewCfgDynamicPolicyIndex, igmpNewQurCfgTable=igmpNewQurCfgTable, ospfAreaTxPkts=ospfAreaTxPkts, ospfAreaIntfDown=ospfAreaIntfDown, ospf3AreaNbrAttempt=ospf3AreaNbrAttempt, bgpCurCfgGroupIndex=bgpCurCfgGroupIndex, vmapVlanCurCfgServerPortsTable=vmapVlanCurCfgServerPortsTable, fipsInfoFcoeEntry=fipsInfoFcoeEntry, agCurCfgSyslogTrapDifftrak=agCurCfgSyslogTrapDifftrak, ospfLsdbInfoRouterId=ospfLsdbInfoRouterId, ikeCurCfgPskLocalKey=ikeCurCfgPskLocalKey, vmbwNewCfgTxAclId=vmbwNewCfgTxAclId, ipNewCfgIntfLoopbackIndex=ipNewCfgIntfLoopbackIndex, rxMldIfStatsBlockSlcrsv2=rxMldIfStatsBlockSlcrsv2, ldapCurCfgSecondaryIpAddr=ldapCurCfgSecondaryIpAddr, swVlagInstanceUp=swVlagInstanceUp, agCfgDumpIndex=agCfgDumpIndex, agAccessNewStrongPassFailLog=agAccessNewStrongPassFailLog, swAcntStrngPswdNotMet=swAcntStrngPswdNotMet, vlagInfoISLId=vlagInfoISLId, ospf3CurCfgAreaIndex=ospf3CurCfgAreaIndex, igmpV3SnoopNewCfgExcludeEnaDis=igmpV3SnoopNewCfgExcludeEnaDis, agCurCfgLFDFlaps=agCurCfgLFDFlaps, trunkgroup=trunkgroup, agDiffIndex=agDiffIndex, ospf3IfInfoEvents=ospf3IfInfoEvents, ipsecNewCfgDynamicPolicySelector=ipsecNewCfgDynamicPolicySelector, dhcpSnoopingStatDroppedPacketInvalid=dhcpSnoopingStatDroppedPacketInvalid, aclCurCfgSrcPort=aclCurCfgSrcPort, udldInfoNeighborExpiration=udldInfoNeighborExpiration, fipsCurAclTimeout=fipsCurAclTimeout, lacpInfoPortGeneralTable=lacpInfoPortGeneralTable, vlagNewCfgStartupDelayInterval=vlagNewCfgStartupDelayInterval, ipNewCfgAspathDelete=ipNewCfgAspathDelete, ipCurCfgIntfHopLimit=ipCurCfgIntfHopLimit, lldpInfoRemoteDevicesSystemDescription=lldpInfoRemoteDevicesSystemDescription, ipCurCfgGwTable=ipCurCfgGwTable, agNewCfgSyslogTrapOspfv3=agNewCfgSyslogTrapOspfv3, ndprefixNewCfgTable=ndprefixNewCfgTable, ospf3NewCfgState=ospf3NewCfgState, portMgmtStatsRxDropped=portMgmtStatsRxDropped, ospf3CurCfgVirtIntfTrans=ospf3CurCfgVirtIntfTrans, hardware=hardware, aclCurCfgEntry=aclCurCfgEntry, lldpStatsTable=lldpStatsTable, ospfAreaRxPkts=ospfAreaRxPkts, rxMldIfStatsToIncFmcrsv2=rxMldIfStatsToIncFmcrsv2, stpInfoPortExtGuard=stpInfoPortExtGuard, ecpChnlInfoEntryIndex=ecpChnlInfoEntryIndex, accessInfo=accessInfo, stpInfoHelloTime=stpInfoHelloTime, ipNewCfgRmapIndex=ipNewCfgRmapIndex, bgpCurCfgPeerDefaultAction=bgpCurCfgPeerDefaultAction, ospfVirtIntfInfoState=ospfVirtIntfInfoState, lacpStatsIndex=lacpStatsIndex, igmpCfg=igmpCfg, ipv6OutMcasts=ipv6OutMcasts, vmapCurCfgDstMACMask=vmapCurCfgDstMACMask, vrrpNewCfgIfPasswd=vrrpNewCfgIfPasswd, acl6NewCfgIPv6Reset=acl6NewCfgIPv6Reset)
mibBuilder.exportSymbols("IBM-GbTOR-10G-L2L3-MIB", igmpNewCfgQurMaxRespTime=igmpNewCfgQurMaxRespTime, ospfIntfErrUnknownNbr=ospfIntfErrUnknownNbr, lacpNewPortActorPortPriority=lacpNewPortActorPortPriority, agCurCfgSyslogTrapServer=agCurCfgSyslogTrapServer, agTransferImage=agTransferImage, intfLoopbackInfoEntry=intfLoopbackInfoEntry, mldInfoInterfaceVersion=mldInfoInterfaceVersion, ospfCumIntfDown=ospfCumIntfDown, ipCurCfgRmapWeight=ipCurCfgRmapWeight, ospf3RedistributeStatic=ospf3RedistributeStatic, bgpInfoTotalReceivedPackets=bgpInfoTotalReceivedPackets, aclCurCfgSrcMACAddress=aclCurCfgSrcMACAddress, swLoginFailure=swLoginFailure, qosCurCfgDscpTable=qosCurCfgDscpTable, virtVMwareHost=virtVMwareHost, dhcpSnoopingCurCfgVlanTableEntry=dhcpSnoopingCurCfgVlanTableEntry, ipNewCfgBootpBcastDomainEntry=ipNewCfgBootpBcastDomainEntry, ipNewCfgNwfEntry=ipNewCfgNwfEntry, trunkGroupCurCfgTableEntry=trunkGroupCurCfgTableEntry, memorySharedStats=memorySharedStats, trunkLacpGroupNewCfgAdminKey=trunkLacpGroupNewCfgAdminKey, dhcpInfoMacAddr=dhcpInfoMacAddr, vnicNewCfgGroupEntry=vnicNewCfgGroupEntry, ipCurCfgAlistRmapIndex=ipCurCfgAlistRmapIndex, ipCurCfgBootpBcastDomainServIndex=ipCurCfgBootpBcastDomainServIndex, vrrpCurCfgIfTable=vrrpCurCfgIfTable, ospfTotalNeighbours=ospfTotalNeighbours, allportsStatsTableEntry=allportsStatsTableEntry, failoverNewCfgTriggerMconTrunkRem=failoverNewCfgTriggerMconTrunkRem, ipsecNewCfgSelectorSrc=ipsecNewCfgSelectorSrc, agPortNewCfgPortName=agPortNewCfgPortName, highFreeStats=highFreeStats, nbrInfoState=nbrInfoState, cistBridgeHelloTime=cistBridgeHelloTime, radNewCfgState=radNewCfgState, stgCurCfgIndex=stgCurCfgIndex, swTeamingCtrlError=swTeamingCtrlError, qosNewCfgPortPriorityEntry=qosNewCfgPortPriorityEntry, mcastFdbEntryIndex=mcastFdbEntryIndex, virtNewCfgVirtCenterIp=virtNewCfgVirtCenterIp, processName=processName, pptCurCfgEntry=pptCurCfgEntry, qosCurCfgPriorityCoSq=qosCurCfgPriorityCoSq, ospfCumIntfNbrChange=ospfCumIntfNbrChange, vlagInstanceAdminKey=vlagInstanceAdminKey, igmpSnoopNewCfgQInterval=igmpSnoopNewCfgQInterval, ipsecNewCfgManualPolicyInEspEncKey=ipsecNewCfgManualPolicyInEspEncKey, agPortNewCfgTable=agPortNewCfgTable, tacNewBypassEnable=tacNewBypassEnable, ipsecNewCfgManualPolicyInEspAuthKey=ipsecNewCfgManualPolicyInEspAuthKey, vlagStatsPduRcvFdbInactiveDel=vlagStatsPduRcvFdbInactiveDel, pysmi_if=pysmi_if, ipStaticRouteCurEcmpHash=ipStaticRouteCurEcmpHash, ospf3CumNbrExStart=ospf3CumNbrExStart, nsnmpOutTraps=nsnmpOutTraps, ipsecNewCfgSelectorTable=ipsecNewCfgSelectorTable, ospf3NewCfgExtRangeState=ospf3NewCfgExtRangeState, ipv6Fragoks=ipv6Fragoks, fipsInfoFcfCount=fipsInfoFcfCount, cistInfoPortTable=cistInfoPortTable, cistInfoPortLinkType=cistInfoPortLinkType, ospf3CurCfgRouterId=ospf3CurCfgRouterId, bgpCurCfgAggrTable=bgpCurCfgAggrTable, vmapGroupNewCfgAllPortsRemVmap=vmapGroupNewCfgAllPortsRemVmap, lacpInfoPortIndivState=lacpInfoPortIndivState, ospfNewCfgHostCost=ospfNewCfgHostCost, vlagStatsPduRcvPeerInstanceDisable=vlagStatsPduRcvPeerInstanceDisable, igmpCurCfgQuerier=igmpCurCfgQuerier, mldNewInterfaceRobustness=mldNewInterfaceRobustness, swHotlinksMasterDn=swHotlinksMasterDn, allportsStatsInUcast=allportsStatsInUcast, vmapVlanNewCfgNonServerPortsRemVmap=vmapVlanNewCfgNonServerPortsRemVmap, bootpRelayStatsRequestsRelayed=bootpRelayStatsRequestsRelayed, ospf3CurCfgIntfRetra=ospf3CurCfgIntfRetra, ospfTmrsKckOffSummary=ospfTmrsKckOffSummary, udpStatsOutDatagrams=udpStatsOutDatagrams, vlanNewCfgVlanName=vlanNewCfgVlanName, igmpClearTables=igmpClearTables, ospf3AreaErrorStats=ospf3AreaErrorStats, ospfIfInfoArea=ospfIfInfoArea, lldpInfoPortTable=lldpInfoPortTable, vmapCurCfgIPFmt=vmapCurCfgIPFmt, aclNewCfgPortIndex=aclNewCfgPortIndex, cee=cee, vlanInfo=vlanInfo, ipStatsInReceives=ipStatsInReceives, nsnmpInPkts=nsnmpInPkts, dot3RateStatsFrameTooLongs=dot3RateStatsFrameTooLongs, acl6NewCfgTCPFlagsMask=acl6NewCfgTCPFlagsMask, stgNewCfgVlanBmap=stgNewCfgVlanBmap, ospf3VirtIfInfoStatus=ospf3VirtIfInfoStatus, vmapNewCfgTCPFlags=vmapNewCfgTCPFlags, ikeCurCfgIdData=ikeCurCfgIdData, ipNewCfgBootpBcastDomainIndex=ipNewCfgBootpBcastDomainIndex, ibmnosFdbState=ibmnosFdbState, radNewCfgSrcLoopIf=radNewCfgSrcLoopIf, oamInfoPortLocalMode=oamInfoPortLocalMode, lacpNewPortState=lacpNewPortState, agNewCfgSyslogTrapAll=agNewCfgSyslogTrapAll, dhcpSnoopingNewCfgportRateLimit=dhcpSnoopingNewCfgportRateLimit, ibmnosPortCfgTable=ibmnosPortCfgTable, ospf3AreaRxlsUpdates=ospf3AreaRxlsUpdates, tacNewCfgAuthenString=tacNewCfgAuthenString, agCfgBootResetParameters=agCfgBootResetParameters, portInfoVlanTag=portInfoVlanTag, agNewCfgTelnetAccess=agNewCfgTelnetAccess, lacpInfoPortActOpActiv=lacpInfoPortActOpActiv, ipmcCurCfgStaticRouteVlanId=ipmcCurCfgStaticRouteVlanId, ipv6icmpOutEchoResp=ipv6icmpOutEchoResp, ospfLoopIfInfoEntry=ospfLoopIfInfoEntry, vrrpCurCfgVirtRtrAddr=vrrpCurCfgVirtRtrAddr, virtCurCfgVMwareHelloAddr=virtCurCfgVMwareHelloAddr, oamStatsPortLocalLinkFaults=oamStatsPortLocalLinkFaults, ipCurCfgIntfState=ipCurCfgIntfState, igmpFltNewCfgState=igmpFltNewCfgState, txMldIfStatsGeneralQuery=txMldIfStatsGeneralQuery, ipv6TooBigerrs=ipv6TooBigerrs, ikeCurCfgPskRemoteAddr=ikeCurCfgPskRemoteAddr, vrrpNewCfgVirtRtrPriority=vrrpNewCfgVirtRtrPriority, igmpSnoopVlanIndex=igmpSnoopVlanIndex, hotlinksInfoTriggerPreemptState=hotlinksInfoTriggerPreemptState, trunkLacpGroupCurCfgTable=trunkLacpGroupCurCfgTable, virtVMwareHostPGIndex=virtVMwareHostPGIndex, lldpCurCfgPortsyscaptlv=lldpCurCfgPortsyscaptlv, bgpCurCfgGroupOspfState=bgpCurCfgGroupOspfState, ipMgmtRouteInfoEntry=ipMgmtRouteInfoEntry, bgpInfoDynamicHoldtime=bgpInfoDynamicHoldtime, agSSHConfig=agSSHConfig, bgpCurCfgGroupRAS=bgpCurCfgGroupRAS, ipsecSaInfoUlp=ipsecSaInfoUlp, ospfIntfNbrChangeStatsEntry=ospfIntfNbrChangeStatsEntry, ospf3CurCfgIntfAuthType=ospf3CurCfgIntfAuthType, vmapVlanNewCfgAllPortsRemVmap=vmapVlanNewCfgAllPortsRemVmap, vmNewCfgProfileIndex=vmNewCfgProfileIndex, ipAspathTableMax=ipAspathTableMax, vrrpOperVirtRtrTable=vrrpOperVirtRtrTable, pptCfg=pptCfg, vmapGroupNewCfgNonServerPortsVmapBitmap=vmapGroupNewCfgNonServerPortsVmapBitmap, bgpInfoDynamicPeerTable=bgpInfoDynamicPeerTable, bgpNewCfgGroupDelete=bgpNewCfgGroupDelete, vrrpInfoVirtGroupState=vrrpInfoVirtGroupState, ospf3NewCfgIntfPoll=ospf3NewCfgIntfPoll, trunkGroupCurCfgPorts=trunkGroupCurCfgPorts, ospf3NewCfgConnectedMetric=ospf3NewCfgConnectedMetric, vmapStatsTableEntry=vmapStatsTableEntry, trunkLacpGroupNewCfgTableEntry=trunkLacpGroupNewCfgTableEntry, ospfCurCfgIntfEntry=ospfCurCfgIntfEntry, bgpInfo=bgpInfo, ospfIfInfoPassive=ospfIfInfoPassive, errMldIfStatsMLDv2Report=errMldIfStatsMLDv2Report, ipCurCfgIntfLoopbackBroadcast=ipCurCfgIntfLoopbackBroadcast, mldStatTotalMLDGroups=mldStatTotalMLDGroups, aclNewCfgEthernetReset=aclNewCfgEthernetReset, ipRouteEcmpInfoMask=ipRouteEcmpInfoMask, agCurCfgSyslogTrapCfgchg=agCurCfgSyslogTrapCfgchg, ipNewCfgAlistRmapIndex=ipNewCfgAlistRmapIndex, bgpNewCfgGroupStaticState=bgpNewCfgGroupStaticState, ospf3IfInfoAuthType=ospf3IfInfoAuthType, rxMldIfStatsMLDv1Done=rxMldIfStatsMLDv1Done, aclStatsHits=aclStatsHits, portMgmtStatsTxOverruns=portMgmtStatsTxOverruns, pptCurCfgPrefix=pptCurCfgPrefix, ldapCurCfgRetries=ldapCurCfgRetries, igmpNewCfgQueryInterval=igmpNewCfgQueryInterval, vrrpNewCfgVirtRtrGrpPredelay=vrrpNewCfgVirtRtrGrpPredelay, virtVMwareHostDetailInfoVMOSHostName=virtVMwareHostDetailInfoVMOSHostName, ripCurCfgOspfOutRmapList=ripCurCfgOspfOutRmapList, bgpNewCfgPeerMetric=bgpNewCfgPeerMetric, cistGeneralInfo=cistGeneralInfo, trunkGroupInfoPortTable=trunkGroupInfoPortTable, dot3RateStatsSingleCollisionFrames=dot3RateStatsSingleCollisionFrames, lldpInfoRxSNMPNotify=lldpInfoRxSNMPNotify, vlanCurCfgPrVlanType=vlanCurCfgPrVlanType, agNewCfgDefipMgta=agNewCfgDefipMgta, virtNewCfgVirtCenterSSLAuth=virtNewCfgVirtCenterSSLAuth, aclCurCfgSrcIPMask=aclCurCfgSrcIPMask, ipsecNewCfgIfDelManualPolicy=ipsecNewCfgIfDelManualPolicy, lacpInfoPortOperIndex=lacpInfoPortOperIndex, lacpNewPortActorAdminKey=lacpNewPortActorAdminKey, mldStatTotalL3Ipv6SgvEntries=mldStatTotalL3Ipv6SgvEntries, ipsecSpdInfoSaIndex=ipsecSpdInfoSaIndex, agNewCfgLFDFlaps=agNewCfgLFDFlaps, ipNewCfgBootpGlobalServerIndex=ipNewCfgBootpGlobalServerIndex, virtVMwareHostDetailInfoPort=virtVMwareHostDetailInfoPort, ospf3NewCfgIntfAuthKey=ospf3NewCfgIntfAuthKey, agsFlowConfig=agsFlowConfig, icmpStatsOutAddrMasks=icmpStatsOutAddrMasks, vrrpCurCfgIfIndx=vrrpCurCfgIfIndx, dhcpsnpCfg=dhcpsnpCfg, ripInfoIntfIndex=ripInfoIntfIndex, ospfNewCfgRipAddOutRmap=ospfNewCfgRipAddOutRmap, igmpStaticMrtrCurCfgIndx=igmpStaticMrtrCurCfgIndx, mldStats=mldStats, ipmcStaticRouteTableMaxSize=ipmcStaticRouteTableMaxSize, virtNewCfgHbPort=virtNewCfgHbPort, vlanMaxEnt=vlanMaxEnt, lldpInfoTxIndex=lldpInfoTxIndex, ospfNewCfgVirtIntfMdkey=ospfNewCfgVirtIntfMdkey, ipsecSaInfoIndex=ipsecSaInfoIndex, vrrpNewCfgVirtRtrIndx=vrrpNewCfgVirtRtrIndx, lldpInfoPortMacAddress=lldpInfoPortMacAddress, ospf3IntfRxDatabase=ospf3IntfRxDatabase, ripNewCfgIntfTrigUpdate=ripNewCfgIntfTrigUpdate, vmapNewCfgRemoveEgressPort=vmapNewCfgRemoveEgressPort, ospfNewCfgIntfDeadMS=ospfNewCfgIntfDeadMS, lldpInfoTxHoldMultiplier=lldpInfoTxHoldMultiplier, vrrpCurCfgGenTckVirtRtrInc=vrrpCurCfgGenTckVirtRtrInc, vmbw=vmbw, vrrpCurCfgVirtRtrGrpFastAdvertisement=vrrpCurCfgVirtRtrGrpFastAdvertisement, ospfIfInfoDesignatedRouterIpAddress=ospfIfInfoDesignatedRouterIpAddress, ospfIfInfoPriority=ospfIfInfoPriority, ipNewCfgRouterID=ipNewCfgRouterID, oamStatsPortEntry=oamStatsPortEntry, portInfoPhyIfPhysAddress=portInfoPhyIfPhysAddress, ipCurCfgIntfLoopbackTable=ipCurCfgIntfLoopbackTable, ospf3CurCfgRedistState=ospf3CurCfgRedistState, vlagStatsPduRcvFdbDynamicDel=vlagStatsPduRcvFdbDynamicDel, ospf3AreaTableMaxSize=ospf3AreaTableMaxSize, rxMldIfStatsMASQuery=rxMldIfStatsMASQuery, ospf3CurCfgExtRangePrefixLen=ospf3CurCfgExtRangePrefixLen, ospfCumTxPkts=ospfCumTxPkts, toraddon=toraddon, ospfAreaInfoTotalNeighbours=ospfAreaInfoTotalNeighbours, txMldIfStatsMASSQQuery=txMldIfStatsMASSQQuery, vmapVlanCurCfgNonServerPortsVmapBitmap=vmapVlanCurCfgNonServerPortsVmapBitmap, ipCurCfgSecIntfPrefix=ipCurCfgSecIntfPrefix, trunkGroupNewCfgPorts=trunkGroupNewCfgPorts, agNewCfgSnmpTimeout=agNewCfgSnmpTimeout, ospfCurCfgHostTable=ospfCurCfgHostTable, icmpStatsOutTimestamps=icmpStatsOutTimestamps, ospf3IfInfoLLocalAddress=ospf3IfInfoLLocalAddress, vlagStatsClear=vlagStatsClear, ipv6InTruncs=ipv6InTruncs, ospfAreaErrIndex=ospfAreaErrIndex, ospfCurCfgAreaType=ospfCurCfgAreaType, ospf3CurCfgState=ospf3CurCfgState, bgpInfoWght=bgpInfoWght, ipsecSaInfoFlags=ipsecSaInfoFlags, vmapVlanNewCfgNonServerPortsTable=vmapVlanNewCfgNonServerPortsTable, agNewCfgSyslogTrapCfg=agNewCfgSyslogTrapCfg, ospf3NewCfgStaticMetric=ospf3NewCfgStaticMetric, ospfNewCfgIntfTable=ospfNewCfgIntfTable, ipNewCfgBootpBcastDomainAction=ipNewCfgBootpBcastDomainAction, agCurCfgNTPServerPort=agCurCfgNTPServerPort, sys=sys, vnicNewCfgGroupAddPort=vnicNewCfgGroupAddPort, ibmnosConfigControl=ibmnosConfigControl, allportsStatsDescr=allportsStatsDescr, ipsecCurCfgTxformMode=ipsecCurCfgTxformMode, ospfVirtIntfInfoNbr=ospfVirtIntfInfoNbr, ipv6PmtuInfoTable=ipv6PmtuInfoTable, ibmnosReset=ibmnosReset, mldCurInterfaceIfIndex=mldCurInterfaceIfIndex, hotlinksNewCfgTriggerFdelay=hotlinksNewCfgTriggerFdelay)
mibBuilder.exportSymbols("IBM-GbTOR-10G-L2L3-MIB", ospf3NewCfgNbrIpAddr=ospf3NewCfgNbrIpAddr, ipCurCfgStaticRouteMask=ipCurCfgStaticRouteMask, agNewCfgSyslogConsoleSev=agNewCfgSyslogConsoleSev, ospfLoopIfInfoWaitInterval=ospfLoopIfInfoWaitInterval, ospf3CurCfgExtRangeEntry=ospf3CurCfgExtRangeEntry, igmpSnoopStats=igmpSnoopStats, agSavePending=agSavePending, vnicNewCfgState=vnicNewCfgState, swVrrpNewMaster=swVrrpNewMaster, ospfIfInfoState=ospfIfInfoState, oamStatsPortLocalDyingGasps=oamStatsPortLocalDyingGasps, ospfCumRxHello=ospfCumRxHello, igmpInfoMode=igmpInfoMode, vmapNewCfgMeterAction=vmapNewCfgMeterAction, ipNewCfgSecIntfAnycast=ipNewCfgSecIntfAnycast, clearStats=clearStats, ipCurCfgStaticArpMAC=ipCurCfgStaticArpMAC, ospfIfInfoRouterIP=ospfIfInfoRouterIP, qosCurCfgPriorityCoSEntry=qosCurCfgPriorityCoSEntry, agCfgDumpString=agCfgDumpString, vmapClearStats=vmapClearStats, ripCurCfgEbgpMetric=ripCurCfgEbgpMetric, txMldIfStatsBlockSlcrsv2=txMldIfStatsBlockSlcrsv2, vmCurCfgGroupMaclistEntry=vmCurCfgGroupMaclistEntry, ospfVirtIntfInfoIndex=ospfVirtIntfInfoIndex, ecpChnlSndlen=ecpChnlSndlen, stgNewCfgBrgForwardDelay=stgNewCfgBrgForwardDelay, ipCurCfgBootpGlobalServerIndex=ipCurCfgBootpGlobalServerIndex, swValidLogin=swValidLogin, ospfCurCfgRangeAreaIndex=ospfCurCfgRangeAreaIndex, virtNewCfgVMwareHelloTimer=virtNewCfgVMwareHelloTimer, ipClearStats=ipClearStats, ospfAreaErrAuthFailure=ospfAreaErrAuthFailure, qosNewCfgPriorityCoSEntry=qosNewCfgPriorityCoSEntry, ripCurCfgIntfPoisonReverse=ripCurCfgIntfPoisonReverse, ipv6OutRedirs=ipv6OutRedirs, ospfNewCfgIbgpRemoveOutRmap=ospfNewCfgIbgpRemoveOutRmap, lacpCurPortCfgTable=lacpCurPortCfgTable, aclCurCfgDstMACMask=aclCurCfgDstMACMask, radCurCfgRetries=radCurCfgRetries, ipGatewayIPv6InfoIndex=ipGatewayIPv6InfoIndex, agClrSyslogMsgs=agClrSyslogMsgs, ospfinfo=ospfinfo, ipNewCfgStaticRoute6Mask=ipNewCfgStaticRoute6Mask, ipRoute6InfoProto=ipRoute6InfoProto, ipInfoBootpRelayState=ipInfoBootpRelayState, dot3RateStatsExcessiveCollisions=dot3RateStatsExcessiveCollisions, igmpInfoSrcPort=igmpInfoSrcPort, lldpInfoRxRxInfoAge=lldpInfoRxRxInfoAge, pptTableMaxSize=pptTableMaxSize, layer2=layer2, agNewCfgSyslogTrapLacp=agNewCfgSyslogTrapLacp, lldpCurCfgPortmacphytlv=lldpCurCfgPortmacphytlv, pptCurCfgPrefixLen=pptCurCfgPrefixLen, vmapNewCfgMeterEnable=vmapNewCfgMeterEnable, ospf3IntfErrMTUMismatch=ospf3IntfErrMTUMismatch, ospf3NewCfgVirtIntfDead=ospf3NewCfgVirtIntfDead, sfpInfoTXEnable=sfpInfoTXEnable, ipsecCurCfgSelectorAction=ipsecCurCfgSelectorAction, bgpInfoPeerEntry=bgpInfoPeerEntry, bgpInfoTotalSentPackets=bgpInfoTotalSentPackets, ospf3IfInfoEncryType=ospf3IfInfoEncryType, acl6CurCfgSrcPort=acl6CurCfgSrcPort, ospf3CurCfgRangePrefixLen=ospf3CurCfgRangePrefixLen, bgpNewCfgIbgpMaxPaths=bgpNewCfgIbgpMaxPaths, vmbwNewCfgEntry=vmbwNewCfgEntry, routeClearStats=routeClearStats, ospf3NewCfgRangeHideState=ospf3NewCfgRangeHideState, igmpSnoopSetToDefault=igmpSnoopSetToDefault, failoverInfoTriggerMonId=failoverInfoTriggerMonId, vmCurCfgGroupTable=vmCurCfgGroupTable, igmpStaticMrtrCurCfgVlanId=igmpStaticMrtrCurCfgVlanId, portStatsPhyIfOutNUcastPkts=portStatsPhyIfOutNUcastPkts, portStatsPhyIfOutFctlPkts=portStatsPhyIfOutFctlPkts, ipFwdNewCfgDirectedBcast=ipFwdNewCfgDirectedBcast, ipCurCfgStaticRouteEntry=ipCurCfgStaticRouteEntry, sshNewCfgStatus=sshNewCfgStatus, ospf3CurCfgIntfCost=ospf3CurCfgIntfCost, ospfLoopIfInfoPriority=ospfLoopIfInfoPriority, swTeamingCtrlUp=swTeamingCtrlUp, nsnmpInASNParseErrs=nsnmpInASNParseErrs, aclCurCfgMeterAction=aclCurCfgMeterAction, dnsStats=dnsStats, lldpCurCfgPortvlannametlv=lldpCurCfgPortvlannametlv, ospfRoutesInfoMask=ospfRoutesInfoMask, vrrpCurCfgVirtRtrTckIpIntf=vrrpCurCfgVirtRtrTckIpIntf, ospfNbrInInitState=ospfNbrInInitState, ipFwdCurCfgICMP6Redirect=ipFwdCurCfgICMP6Redirect, pptNewCfgAction=pptNewCfgAction, tacNewCfgState=tacNewCfgState, lldpInfoRemoteDevicesEntry=lldpInfoRemoteDevicesEntry, ipv6PmtuCurTimeout=ipv6PmtuCurTimeout, fcoe=fcoe, ifMainTable=ifMainTable, ospf3IntfDisdPkts=ospf3IntfDisdPkts, ipNewCfgIntfLoopbackMask=ipNewCfgIntfLoopbackMask, ndprefixCurCfgPrefix=ndprefixCurCfgPrefix, bootpRelayStatsRepliesDroppedError=bootpRelayStatsRepliesDroppedError, bgpInfoHoldtime=bgpInfoHoldtime, dhcpSnoopingBindingInfoIp=dhcpSnoopingBindingInfoIp, ospf3TmrsKckOffNbrProbe=ospf3TmrsKckOffNbrProbe, recvQUdp=recvQUdp, dot3RateStatsFCSErrors=dot3RateStatsFCSErrors, mcastFdbCurCfgVlan=mcastFdbCurCfgVlan, qosNewCfgDscpIndex=qosNewCfgDscpIndex, ipCurCfgBootpBcastDomainEnable=ipCurCfgBootpBcastDomainEnable, hotlinksCurCfgTriggerPreemptState=hotlinksCurCfgTriggerPreemptState, vmapGroupNewCfgServerPortsGroupIdx=vmapGroupNewCfgServerPortsGroupIdx, ospfCurCfgMdkeyKey=ospfCurCfgMdkeyKey, tacNewCfgPorttoUse=tacNewCfgPorttoUse, ipNewCfgStaticRoute6Entry=ipNewCfgStaticRoute6Entry, portOperLearning=portOperLearning, ospfAreaTxlsUpdates=ospfAreaTxlsUpdates, ecpInfo=ecpInfo, ospf3IntfErrOptionsMismatch=ospf3IntfErrOptionsMismatch, vlagCurCfgStartupDelayInterval=vlagCurCfgStartupDelayInterval, ospf3NewCfgAreaTable=ospf3NewCfgAreaTable, lldpInfoTxTxTTR=lldpInfoTxTxTTR, nsnmpInGetNexts=nsnmpInGetNexts, vmapNewCfgUser=vmapNewCfgUser, agentStats=agentStats, qosNewCfgPriorityIndex=qosNewCfgPriorityIndex, ipsecCurCfgManualPolicyTable=ipsecCurCfgManualPolicyTable, ipCurCfgStaticArpEntry=ipCurCfgStaticArpEntry, intfLoopbackInfoAddr=intfLoopbackInfoAddr, radCurCfgBackdoor=radCurCfgBackdoor, ospfNewCfgLoopIfStatus=ospfNewCfgLoopIfStatus, agNewCfgUserBBI=agNewCfgUserBBI, agCurCfgSyslogTrapVnic=agCurCfgSyslogTrapVnic, lldpInfoRxTooManyNeighborTimer=lldpInfoRxTooManyNeighborTimer, bgpCurCfgPeerTtl=bgpCurCfgPeerTtl, agPortCurCfgTagPVID=agPortCurCfgTagPVID, cistInfo=cistInfo, tacNewCfgEnaPassChange=tacNewCfgEnaPassChange, fdbCurCfgAgingTime=fdbCurCfgAgingTime, ospfStats=ospfStats, dot1RateStatsIndx=dot1RateStatsIndx, ospf3IntfTxPkts=ospf3IntfTxPkts, vmapNewCfgDelete=vmapNewCfgDelete, cpuProcessUtil5Min=cpuProcessUtil5Min, errMldIfStatsToExcFmcrsv2=errMldIfStatsToExcFmcrsv2, ipv6icmpInNeighAdv=ipv6icmpInNeighAdv, ospf3AreaIntfChangeStatsEntry=ospf3AreaIntfChangeStatsEntry, vlagStatsIslInPackets=vlagStatsIslInPackets, bgpNewCfgGroupOspfState=bgpNewCfgGroupOspfState, trunkGroupCurCfgIndex=trunkGroupCurCfgIndex, ospfCurCfgVirtIntfIndex=ospfCurCfgVirtIntfIndex, ibmnosFdbStatus=ibmnosFdbStatus, agCurCfgSyslogTrapIgmpGroup=agCurCfgSyslogTrapIgmpGroup, igmpCurQuerierState=igmpCurQuerierState, ospf3RoutesInfoInterfaceIndex=ospf3RoutesInfoInterfaceIndex, bgpInfoPeerRemoteAddr=bgpInfoPeerRemoteAddr, mldNewInterfaceIfIndex=mldNewInterfaceIfIndex, ospfIntfInfoEntry=ospfIntfInfoEntry, mldInfoGroupExpiryTime=mldInfoGroupExpiryTime, ospf3OverFlowState=ospf3OverFlowState, agNewCfgMgmtNetTable=agNewCfgMgmtNetTable, ipCurCfgBootpGlobalServerAddress=ipCurCfgBootpGlobalServerAddress, ipCurCfgStaticArpIndx=ipCurCfgStaticArpIndx, igmpNewQurCfgEntry=igmpNewQurCfgEntry, mldInfoMRouterVersion=mldInfoMRouterVersion, lacpInfoPortPartOpActiv=lacpInfoPortPartOpActiv, mldInfoInterfaceQuerier=mldInfoInterfaceQuerier, nbrInfo=nbrInfo, igmpSnoopCurCfgVlanFastlvBmap=igmpSnoopCurCfgVlanFastlvBmap, agClearStats=agClearStats, virtVMwareHostNameEntry=virtVMwareHostNameEntry, ipv6InNadvs=ipv6InNadvs, mldNewInterfaceLastListenQueryIntvl=mldNewInterfaceLastListenQueryIntvl, swDefGwInService=swDefGwInService, dhcpSnoopingNewCfgVlanOnState=dhcpSnoopingNewCfgVlanOnState, agPortNewCfgRmon=agPortNewCfgRmon, ospfCurCfgAreaStatus=ospfCurCfgAreaStatus, portInfoLink=portInfoLink, vlagStatsIslInOctets=vlagStatsIslInOctets, ospfCumIntfWaitTimer=ospfCumIntfWaitTimer, vmapVlanNewCfgNonServerPortsVlanIdx=vmapVlanNewCfgNonServerPortsVlanIdx, ipNewCfgStaticArpVlan=ipNewCfgStaticArpVlan, swValidLogout=swValidLogout, ospfCumIntfLoop=ospfCumIntfLoop, mstCistCurCfgBridgePriority=mstCistCurCfgBridgePriority, routeTableClear=routeTableClear, ipRouteEcmpInfoEntry=ipRouteEcmpInfoEntry, portInfoTableEntry=portInfoTableEntry, ipNewCfgRmapDelete=ipNewCfgRmapDelete, ospf3CurCfgRangeEntry=ospf3CurCfgRangeEntry, ipNewCfgBootpAddr=ipNewCfgBootpAddr, routeStatMaxEntries=routeStatMaxEntries, ospf3NewCfgIntfArea=ospf3NewCfgIntfArea, ospfCurCfgFixedOutRmapList=ospfCurCfgFixedOutRmapList, ospf3CumIntfChangeStats=ospf3CumIntfChangeStats, agPortCurCfgMulticastThresholdRate=agPortCurCfgMulticastThresholdRate, ospfIfInfoTotalNeighbours=ospfIfInfoTotalNeighbours, tcpStatsRetransSegs=tcpStatsRetransSegs, igmpStatsTotalIpmcGroups=igmpStatsTotalIpmcGroups, aclLogNewRateLimit=aclLogNewRateLimit, hotlinksInfoTriggerTableEntry=hotlinksInfoTriggerTableEntry, bgpCurCfgPeerState=bgpCurCfgPeerState, vrrpOperVirtRtrEntry=vrrpOperVirtRtrEntry, stgNewCfgPortPathCost=stgNewCfgPortPathCost, ipEcmpHashSIPAddr=ipEcmpHashSIPAddr, ospfIfNbrState=ospfIfNbrState, agCurCfgMgmtNetSubnet=agCurCfgMgmtNetSubnet, vmNewCfgGroupPorts=vmNewCfgGroupPorts, ospf3AreaErrRxOnNotup=ospf3AreaErrRxOnNotup, aclNewCfgSrcIPAddress=aclNewCfgSrcIPAddress, agTransferLastActionStatus=agTransferLastActionStatus, virtVMwareHostDetailInfoMACAddr=virtVMwareHostDetailInfoMACAddr, fdbNewCfgStaticTable=fdbNewCfgStaticTable, ospf3CurCfgStaticRouteTagTypeManual=ospf3CurCfgStaticRouteTagTypeManual, ipMgmtRouteInfoGateway1=ipMgmtRouteInfoGateway1, bgpNewCfgPeerNexthopSelf=bgpNewCfgPeerNexthopSelf, ospf3IntfDisdlsAcks=ospf3IntfDisdlsAcks, ospfIfInfoDeadMS=ospfIfInfoDeadMS, ospfLoopIfInfoBackupDesignatedRouterIP=ospfLoopIfInfoBackupDesignatedRouterIP, portStatsPhyIfOutBroadcastPkts=portStatsPhyIfOutBroadcastPkts, portStatsDot1PortInDiscards=portStatsDot1PortInDiscards, ipv6icmpInRedir=ipv6icmpInRedir, swVlagInstanceRemoteUp=swVlagInstanceRemoteUp, ospf3IfInfoTotalNeighbours=ospf3IfInfoTotalNeighbours, ospfNewCfgAreaId=ospfNewCfgAreaId, ipMgmtRouteInfoDestIp=ipMgmtRouteInfoDestIp, fipsInfoFcfVlan=fipsInfoFcfVlan, mcastFdbMacAddr=mcastFdbMacAddr, ospfIfNbrBackupDesignatedRtr=ospfIfNbrBackupDesignatedRtr, unknownRx=unknownRx, ipNewCfgRmapTable=ipNewCfgRmapTable, ospfNewCfgVirtIntfDelete=ospfNewCfgVirtIntfDelete, vmNewCfgGroupRemVmIdx=vmNewCfgGroupRemVmIdx, bgpInfoSummaryRemoteAs=bgpInfoSummaryRemoteAs, ripCurCfgOspfMetric=ripCurCfgOspfMetric, ipsecSaInfoProto=ipsecSaInfoProto, ospf3CurCfgIntfEncryEnable=ospf3CurCfgIntfEncryEnable, ospfCurCfgRangeState=ospfCurCfgRangeState, ospf3CurCfgRangeLsaType=ospf3CurCfgRangeLsaType, igmpCurCfgVlanOperVersion=igmpCurCfgVlanOperVersion, ipsecNewCfgDynamicPolicyTxform=ipsecNewCfgDynamicPolicyTxform, dhcpInfoLeaseObtained=dhcpInfoLeaseObtained, ospfNewCfgFixedMetricType=ospfNewCfgFixedMetricType, ospfVirtIntfInfoAreaId=ospfVirtIntfInfoAreaId, aclCurCfgDstMACAddress=aclCurCfgDstMACAddress, pmNewCfgPmirrDelete=pmNewCfgPmirrDelete, vmapNewCfgRemarkInprofReset=vmapNewCfgRemarkInprofReset, fipsInfoFcoeIndex=fipsInfoFcoeIndex, vmapVlanNewCfgNonServerPortsAddVmap=vmapVlanNewCfgNonServerPortsAddVmap, ripCurCfgStaticMetric=ripCurCfgStaticMetric, vmapCurCfgEgressPorts=vmapCurCfgEgressPorts, oamStatsPortRemoteDyingGasps=oamStatsPortRemoteDyingGasps, ospfLoopIfInfoIndex=ospfLoopIfInfoIndex, snmpStats=snmpStats, ospf3IfInfoHello=ospf3IfInfoHello, vlanNewCfgPrVlanState=vlanNewCfgPrVlanState, ospfCurCfgRipMetric=ospfCurCfgRipMetric, ipv6Reasmfails=ipv6Reasmfails)
mibBuilder.exportSymbols("IBM-GbTOR-10G-L2L3-MIB", qosNewCfgPortIndex=qosNewCfgPortIndex, vmapNewCfgDstIPMask=vmapNewCfgDstIPMask, vrrpCurCfgVirtRtrGrpIfIndex=vrrpCurCfgVirtRtrGrpIfIndex, vrrpNewCfgIfAuthType=vrrpNewCfgIfAuthType, ospfAreaErrAreaMismatch=ospfAreaErrAreaMismatch, ospfCurCfgVirtIntfAuthKey=ospfCurCfgVirtIntfAuthKey, ospfCurCfgAreaId=ospfCurCfgAreaId, ripNewCfgEbgpOutRmapList=ripNewCfgEbgpOutRmapList, sshCurCfgScpApplySave=sshCurCfgScpApplySave, portStatsTable=portStatsTable, qosNewCfgCosWeightEntry=qosNewCfgCosWeightEntry, aclNewCfgTCPFlags=aclNewCfgTCPFlags, ospf3AreaErrBadChecksum=ospf3AreaErrBadChecksum, lacpdusTx=lacpdusTx, lacpCurPortCfgTableId=lacpCurPortCfgTableId, hotlinksCurCfgTriggerName=hotlinksCurCfgTriggerName, dnsClearStats=dnsClearStats, ospfRedistributeFixed=ospfRedistributeFixed, ospf3NewCfgRedistIndex=ospf3NewCfgRedistIndex, aclNewCfgDstPortMask=aclNewCfgDstPortMask, lldpNewCfgPortsysdescrtlv=lldpNewCfgPortsysdescrtlv, ospfCurCfgRipOutRmapList=ospfCurCfgRipOutRmapList, ospfNewCfgMdkeyTable=ospfNewCfgMdkeyTable, ospfAreaNbrBadRequests=ospfAreaNbrBadRequests, ospfIntfNbrBadSequence=ospfIntfNbrBadSequence, lldpStatsTableMaxEnt=lldpStatsTableMaxEnt, aclCurCfgPortAcl6Bmap=aclCurCfgPortAcl6Bmap, ipCurCfgIntfLoopbackEntry=ipCurCfgIntfLoopbackEntry, ospf3IntfErrorStats=ospf3IntfErrorStats, bgpInfoReceivedUpdates=bgpInfoReceivedUpdates, hotlinksCurCfgTriggerMasterAdminkey=hotlinksCurCfgTriggerMasterAdminkey, bgpInfoMask=bgpInfoMask, ipDataRouteInfoDestIp=ipDataRouteInfoDestIp, lacpdusRx=lacpdusRx, lacpInfoPortAdminIndex=lacpInfoPortAdminIndex, ospfRedistributeIbgp=ospfRedistributeIbgp, vrrpOperVirtRtrIndex=vrrpOperVirtRtrIndex, vlagStatsPduRcvPeerInstanceEnable=vlagStatsPduRcvPeerInstanceEnable, lacpInfoPortActAdActiv=lacpInfoPortActAdActiv, ospf3AreaErrHelloNoNbr=ospf3AreaErrHelloNoNbr, agAccessNewStrongPassLockout=agAccessNewStrongPassLockout, lldpInfoRxIndex=lldpInfoRxIndex, ldapCurCfgPrimaryIpAddr=ldapCurCfgPrimaryIpAddr, hotlinksInfoBpduState=hotlinksInfoBpduState, udldInfoPortOperationalStatus=udldInfoPortOperationalStatus, ospfTmrsKckOffHello=ospfTmrsKckOffHello, mldInfoMRouterQrv=mldInfoMRouterQrv, ospf3IfInfoState=ospf3IfInfoState, hotlinksInfoTriggerId=hotlinksInfoTriggerId, agCurCfgSyslogConsoleSev=agCurCfgSyslogConsoleSev, ipsecSpdInfoSaEncrKeyLen=ipsecSpdInfoSaEncrKeyLen, bgpNewCfgPeerStaticState=bgpNewCfgPeerStaticState, ospf3CurCfgAreaTable=ospf3CurCfgAreaTable, trunkGroupInfoPortTableEntry=trunkGroupInfoPortTableEntry, l2ThashCurCfgDipState=l2ThashCurCfgDipState, ipsecSaInfoEntry=ipsecSaInfoEntry, vrrpInfoVirtGroupPriority=vrrpInfoVirtGroupPriority, hotlinksNewCfgTriggerPreemptState=hotlinksNewCfgTriggerPreemptState, ospfNewCfgHostState=ospfNewCfgHostState, ipMgmtRouteInfoType=ipMgmtRouteInfoType, vlagStatsHealth=vlagStatsHealth, dot1RatePortOutFrames=dot1RatePortOutFrames, vmapGroupCurCfgAllPortsTable=vmapGroupCurCfgAllPortsTable, agLastSetErrorReason=agLastSetErrorReason, hotlinksInfoOnState=hotlinksInfoOnState, aclNewCfgIpv4Reset=aclNewCfgIpv4Reset, ospf3AreaErrBadAreaID=ospf3AreaErrBadAreaID, vmGroupInfoHost=vmGroupInfoHost, hotlinksStatsTriggerName=hotlinksStatsTriggerName, ikeNewCfgPskRemoteDelete=ikeNewCfgPskRemoteDelete, ipv6OutRoutadvs=ipv6OutRoutadvs, ospfAreaNbrNegotiationDone=ospfAreaNbrNegotiationDone, igmpInfoFwd=igmpInfoFwd, agCurCfgMgmtNetMask=agCurCfgMgmtNetMask, vmNewCfgCheckAclsMax=vmNewCfgCheckAclsMax, swBootVersion=swBootVersion, vrrpCurCfgVirtRtrTckVirtRtr=vrrpCurCfgVirtRtrTckVirtRtr, acl6CurCfgInprofDscp=acl6CurCfgInprofDscp, pvstCompatibilityNewCfgState=pvstCompatibilityNewCfgState, recvQ=recvQ, lacpCurPortActorPortPriority=lacpCurPortActorPortPriority, stgNewCfgPortPriority=stgNewCfgPortPriority, ospfIntfChangeStats=ospfIntfChangeStats, arpStats=arpStats, igmpMrtrInfoVersion=igmpMrtrInfoVersion, agAccessUserCurCfgTable=agAccessUserCurCfgTable, ospf3NewCfgRedistMetric=ospf3NewCfgRedistMetric, ospfSumRangesInfoAction=ospfSumRangesInfoAction, ipsecNewCfgState=ipsecNewCfgState, tacNewCfgRetries=tacNewCfgRetries, ospf3AreaNbrAllEvents=ospf3AreaNbrAllEvents, vrrpStats=vrrpStats, qos=qos, stgNewCfgState=stgNewCfgState, acl6CurCfgDstIPv6Address=acl6CurCfgDstIPv6Address, lldpNewCfgPortlinkaggrtlv=lldpNewCfgPortlinkaggrtlv, ospf3IfInfoAuthSpi=ospf3IfInfoAuthSpi, agCfgDump=agCfgDump, igmpV3SnoopCurCfgSources=igmpV3SnoopCurCfgSources, arpCacheClear=arpCacheClear, udldInfoNeighborPortID=udldInfoNeighborPortID, bootpRelayStatsRequestsReceived=bootpRelayStatsRequestsReceived, ospfCurCfgVirtIntfAreaId=ospfCurCfgVirtIntfAreaId, ospfLsdbInfoLsid=ospfLsdbInfoLsid, ndprefixCurCfgTable=ndprefixCurCfgTable, ospfNewCfgAreaSpfInterval=ospfNewCfgAreaSpfInterval, igmpNewCfgQuerierOnOff=igmpNewCfgQuerierOnOff, ospfNewCfgStaticOutRmapList=ospfNewCfgStaticOutRmapList, ospfIntfChangeStatsEntry=ospfIntfChangeStatsEntry, ospf3IntfLoop=ospf3IntfLoop, ospfLoopIfInfoHelloMS=ospfLoopIfInfoHelloMS, igmpSnoopCurCfgTimeout=igmpSnoopCurCfgTimeout, stpInfoForwardDelay=stpInfoForwardDelay, vmCurCfgProfileEgressShapingBurst=vmCurCfgProfileEgressShapingBurst, ospf3NewCfgVirtIntfStatus=ospf3NewCfgVirtIntfStatus, failoverNewCfgTriggerMmonKey=failoverNewCfgTriggerMmonKey, routeStatEcmpPathsEntries=routeStatEcmpPathsEntries, mldIfStatsEntry=mldIfStatsEntry, lldpCurCfgPortEntry=lldpCurCfgPortEntry, agAccessUserCurCos=agAccessUserCurCos, agPortNewCfgState=agPortNewCfgState, ipsecSaStatsEntry=ipsecSaStatsEntry, agCurCfgTrapSrcIf=agCurCfgTrapSrcIf, ndprefixNewCfgAutonomousFlag=ndprefixNewCfgAutonomousFlag, acConfig=acConfig, ipmcCurCfgStaticRouteEntry=ipmcCurCfgStaticRouteEntry, udpMpState=udpMpState, vmapNewCfgEthFmt=vmapNewCfgEthFmt, ospfAreaRxTxStatsEntry=ospfAreaRxTxStatsEntry, vnicNewCfgGroupIndex=vnicNewCfgGroupIndex, portInfoMode=portInfoMode, gatewayIPv6InfoEntry=gatewayIPv6InfoEntry, ipNewCfgIntfRouteAdv=ipNewCfgIntfRouteAdv, ospf3CumIntfDrOther=ospf3CumIntfDrOther, udldInfoPortEntry=udldInfoPortEntry, cistBridgeMaxAge=cistBridgeMaxAge, virtVMwareHostPGVswitchName=virtVMwareHostPGVswitchName, igmpNewQuerierState=igmpNewQuerierState, ripNewCfgStaticRemoveOutRmap=ripNewCfgStaticRemoveOutRmap, tacCurCfgState=tacCurCfgState, vmapCurCfgDstIPMask=vmapCurCfgDstIPMask, ipmcStaticRouteClearAll=ipmcStaticRouteClearAll, portStatsDot1TpLearnedEntryDiscards=portStatsDot1TpLearnedEntryDiscards, vmapNewCfgIpv4Reset=vmapNewCfgIpv4Reset, ospf3AreaIntfBackup=ospf3AreaIntfBackup, agCurCfgLFDStatus=agCurCfgLFDStatus, hwFan5RPMValue=hwFan5RPMValue, aclCurCfgTCPFlagsMask=aclCurCfgTCPFlagsMask, layer3Configs=layer3Configs, ospfNewCfgDefaultRouteMetricType=ospfNewCfgDefaultRouteMetricType, igmpInfoEntry=igmpInfoEntry, lacpInfoSelAggrId=lacpInfoSelAggrId, vlagStatsPduRcvHlthCheck=vlagStatsPduRcvHlthCheck, bgpCurCfgPeerHold=bgpCurCfgPeerHold, bootpRelayStatsTableEntry=bootpRelayStatsTableEntry, ipDataRouteInfoGateway2=ipDataRouteInfoGateway2, ospfAreaInfoNeighborsINITstate=ospfAreaInfoNeighborsINITstate, vmapList=vmapList, icmpStatsInEchos=icmpStatsInEchos, aclCurCfgRemarkOutProfDscpIndex=aclCurCfgRemarkOutProfDscpIndex, mldStatBadLength=mldStatBadLength, ospf3CurCfgRedistIndex=ospf3CurCfgRedistIndex, dhcpSnoopingBindingInfoExpiry=dhcpSnoopingBindingInfoExpiry, aclCurCfgFilterActionChangeVlan=aclCurCfgFilterActionChangeVlan, agPortNewCfgUdld=agPortNewCfgUdld, bgpCurCfgGroupClient=bgpCurCfgGroupClient, ospf3IntfAllEvents=ospf3IntfAllEvents, igmpInfoSrcTrunk=igmpInfoSrcTrunk, ospf3NewCfgHostEntry=ospf3NewCfgHostEntry, vnicNewCfgVnicBw=vnicNewCfgVnicBw, agPortNewCfgLearning=agPortNewCfgLearning, ospfLsdbInfoSequence=ospfLsdbInfoSequence, fdbCurCfgTrunk=fdbCurCfgTrunk, agNewCfgReminders=agNewCfgReminders, txMldIfStatsMLDv1Done=txMldIfStatsMLDv1Done, vrrpNewCfgIfIndx=vrrpNewCfgIfIndx, agAccessCurStrongPassValidity=agAccessCurStrongPassValidity, swNTPUpdateClock=swNTPUpdateClock, ipCurCfgIntfAddr=ipCurCfgIntfAddr, vrrpStatBadVersion=vrrpStatBadVersion, ipsecCurCfgManualPolicySelector=ipsecCurCfgManualPolicySelector, agCurCfgConsole=agCurCfgConsole, ospfNewCfgRangeEntry=ospfNewCfgRangeEntry, sfpInfoTable=sfpInfoTable, nbrInfoTable=nbrInfoTable, tacChangePassCurPass=tacChangePassCurPass, lacpStatsTableEntry=lacpStatsTableEntry, ndprefixNewCfgValidLifetimeFlag=ndprefixNewCfgValidLifetimeFlag, vmapNewCfgAddEgressPort=vmapNewCfgAddEgressPort, bgpCurCfgPeerRemoteAs=bgpCurCfgPeerRemoteAs, ospf3NewCfgIntfNetworkType=ospf3NewCfgIntfNetworkType, vnicCurCfgVnicIndex=vnicCurCfgVnicIndex, lacpInfoPortActAdTimeout=lacpInfoPortActAdTimeout, ospfCurCfgRangeMask=ospfCurCfgRangeMask, hotlinksStatsTriggerTable=hotlinksStatsTriggerTable, failoverInfoTriggerControlState=failoverInfoTriggerControlState, ipCurCfgIntfAdvInterval=ipCurCfgIntfAdvInterval, agNewCfgSyslogSev=agNewCfgSyslogSev, nsnmpOutGetRequests=nsnmpOutGetRequests, hotlinksCurCfgBpduState=hotlinksCurCfgBpduState, nsnmpOutGenErrs=nsnmpOutGenErrs, stateMgmt=stateMgmt, ndprefixNewCfgEntry=ndprefixNewCfgEntry, swFanFailureFixed=swFanFailureFixed, swHotlinksNone=swHotlinksNone, vmapCurCfgEthernetTypeName=vmapCurCfgEthernetTypeName, portInfoPvid=portInfoPvid, lldpNewCfgPortTable=lldpNewCfgPortTable, ospf3CumNbrN2way=ospf3CumNbrN2way, agPortCurCfgLinkTrap=agPortCurCfgLinkTrap, arpCfg=arpCfg, ipCurCfgRmapLp=ipCurCfgRmapLp, ospf3SpfDelay=ospf3SpfDelay, ospf3NewCfgHostTable=ospf3NewCfgHostTable, lacpInfoAggrPartOperKey=lacpInfoAggrPartOperKey, ospf3IntfErrRxSameRTRID=ospf3IntfErrRxSameRTRID, vmapNewCfgRemarkReset=vmapNewCfgRemarkReset, ipCurCfgIntfManagedCfg=ipCurCfgIntfManagedCfg, ospfIntfRxPkts=ospfIntfRxPkts, lacpInfoPortActPortNum=lacpInfoPortActPortNum, igmpMrtrInfoEntry=igmpMrtrInfoEntry, tcpStatsRtoMin=tcpStatsRtoMin, ospfLoopIfInfoAuthType=ospfLoopIfInfoAuthType, ipMgmtRouteInfoIndx=ipMgmtRouteInfoIndx, ospfNewCfgIntfHelloMS=ospfNewCfgIntfHelloMS, ospf3CurCfgIntfTrans=ospf3CurCfgIntfTrans, ospf3IntfErrBadChecksum=ospf3IntfErrBadChecksum, ospfStartTime=ospfStartTime, vrrpCurCfgVirtRtrGrpTable=vrrpCurCfgVirtRtrGrpTable, vmapCurCfgEntry=vmapCurCfgEntry, ospf3CurCfgVirtIntfRetra=ospf3CurCfgVirtIntfRetra, mstCistNewCfgPortIndex=mstCistNewCfgPortIndex, virtVMwareHostDetailInfoVMVCenterName=virtVMwareHostDetailInfoVMVCenterName, vmapGroupNewCfgNonServerPortsAddVmap=vmapGroupNewCfgNonServerPortsAddVmap, ospfCurCfgMdkeyEntry=ospfCurCfgMdkeyEntry, ospf3CumNbrFull=ospf3CumNbrFull, ipv6PmtuInfoValue=ipv6PmtuInfoValue, lldpInfoPortdcbxtlv=lldpInfoPortdcbxtlv, vmapNewCfgFilterActionChangeVlan=vmapNewCfgFilterActionChangeVlan, mldInfoInterfaceIfIndex=mldInfoInterfaceIfIndex, vlanNewCfgState=vlanNewCfgState, bgpNewCfgPeerRemoteAddr=bgpNewCfgPeerRemoteAddr, hotlinksInfoFdbUpdateState=hotlinksInfoFdbUpdateState, processId=processId, igmpFltNewCfgPortTableEntry=igmpFltNewCfgPortTableEntry, bgpNewCfgGroupRASEntry=bgpNewCfgGroupRASEntry, vmGroupInfoPort=vmGroupInfoPort, ospf3AreaRxHello=ospf3AreaRxHello, ikeNewCfgPskLocalKey=ikeNewCfgPskLocalKey, ospfAreaInfoLsTypesAccepted=ospfAreaInfoLsTypesAccepted, hotlinksCurCfgTriggerBackupAdminkey=hotlinksCurCfgTriggerBackupAdminkey, mldInfoGroupFilterType=mldInfoGroupFilterType, ospf3VirtIfInfoIndex=ospf3VirtIfInfoIndex, dot3RateStatsInternalMacReceiveErrors=dot3RateStatsInternalMacReceiveErrors)
mibBuilder.exportSymbols("IBM-GbTOR-10G-L2L3-MIB", swTeamingCtrlDownTearDownBlked=swTeamingCtrlDownTearDownBlked, ospfNewCfgLoopIfDelete=ospfNewCfgLoopIfDelete, ospf3CurCfgAreaNoSumm=ospf3CurCfgAreaNoSumm, ospf3NewCfgAreaIndex=ospf3NewCfgAreaIndex, ospfAreaErrUnknownNbr=ospfAreaErrUnknownNbr, vmapVlanNewCfgServerPortsTableEntry=vmapVlanNewCfgServerPortsTableEntry, ipNewCfgStaticRoute6Indx=ipNewCfgStaticRoute6Indx, sflowNewCfgMgmtPort=sflowNewCfgMgmtPort, vrrpInfoVirtRtrIfIndex=vrrpInfoVirtRtrIfIndex, ipmcCurCfgStaticRouteAdminkeys=ipmcCurCfgStaticRouteAdminkeys, ospf3AreaDisdPkts=ospf3AreaDisdPkts, ripNewCfgIntfState=ripNewCfgIntfState, lldpInfoPortpowermditlv=lldpInfoPortpowermditlv, ospf3ExtRangeTableMaxSize=ospf3ExtRangeTableMaxSize, ipInterfaceLoopbackTableMax=ipInterfaceLoopbackTableMax, ipCurCfgNwfIndex=ipCurCfgNwfIndex, ipv6PmtuInfoSinceTime=ipv6PmtuInfoSinceTime, ospf3VirtIfInfoNeighbor=ospf3VirtIfInfoNeighbor, qosCurCfgPortPriorityTable=qosCurCfgPortPriorityTable, fipsInfoFcf=fipsInfoFcf, ikeNewCfgTxTimeout=ikeNewCfgTxTimeout, ipStatsDefaultTTL=ipStatsDefaultTTL, ntpSecondaryServerRespRcvd=ntpSecondaryServerRespRcvd, allportsStatsOutPkts=allportsStatsOutPkts, stpInfoTopChanges=stpInfoTopChanges, ipRoute6InfoTable=ipRoute6InfoTable, ospf3NewCfgRangeState=ospf3NewCfgRangeState, dot3RateStatsIndx=dot3RateStatsIndx, ripNewCfgOspfAddOutRmap=ripNewCfgOspfAddOutRmap, nbrInfoPortNum=nbrInfoPortNum, agCurCfgSyslogTrapMld=agCurCfgSyslogTrapMld, ospf3CurCfgVirtIntfAreaId=ospf3CurCfgVirtIntfAreaId, ipsecStats=ipsecStats, vnicCurCfgGroupIndex=vnicCurCfgGroupIndex, portMgmtStatsTxBytes=portMgmtStatsTxBytes, agAccessCurStrongPassword=agAccessCurStrongPassword, vnicCurCfgGroupState=vnicCurCfgGroupState, aclLogCurRateLimit=aclLogCurRateLimit, ospfAreaRxTxStats=ospfAreaRxTxStats, failoverNewCfgTriggerMmonPort=failoverNewCfgTriggerMmonPort, ospf3IntfTxlsAcks=ospf3IntfTxlsAcks, lacpCurPortActorMinLinks=lacpCurPortActorMinLinks, allportsStatsInUcastRate=allportsStatsInUcastRate, lldpCurCfgPortportprottlv=lldpCurCfgPortportprottlv, ripCurCfgEbgpOutRmapList=ripCurCfgEbgpOutRmapList, ospf3CurCfgNssaAsbrDfRtTrans=ospf3CurCfgNssaAsbrDfRtTrans, vlagStatsPduSentRoleElection=vlagStatsPduSentRoleElection, virtVMwareVMInfoTable=virtVMwareVMInfoTable, ipNewCfgRmapEntry=ipNewCfgRmapEntry, lldpNewCfgPortmacphytlv=lldpNewCfgPortmacphytlv, vlagInfoOperaRole=vlagInfoOperaRole, bgpNewCfgGroupOutRmapList=bgpNewCfgGroupOutRmapList, ospf3Stats=ospf3Stats, fipsInfoVlansTable=fipsInfoVlansTable, agCurCfgTrapSrcLoopIf=agCurCfgTrapSrcLoopIf, bgpCfg=bgpCfg, ospfProcessUptime=ospfProcessUptime, ipInfoFwdState=ipInfoFwdState, ipv6icmpInNeighSol=ipv6icmpInNeighSol, ospf3RangeTableMaxSize=ospf3RangeTableMaxSize, aclNewCfgDstPort=aclNewCfgDstPort, bgpInfoDynamicTotalReceivedPackets=bgpInfoDynamicTotalReceivedPackets, cpuUtilProcessStatsTable=cpuUtilProcessStatsTable, swDefGwNotInService=swDefGwNotInService, ripCurCfgIntfDefault=ripCurCfgIntfDefault, ospf3CumTxDatabase=ospf3CumTxDatabase, agMgmtNetClear=agMgmtNetClear, agBootVer=agBootVer, bgpCurCfgAsn4Comp=bgpCurCfgAsn4Comp, vmapGroupNewCfgServerPortsTable=vmapGroupNewCfgServerPortsTable, agCurCfgSyslogFlashSev=agCurCfgSyslogFlashSev, agCurCfgSyslogHostPort=agCurCfgSyslogHostPort, ipRoute6Info=ipRoute6Info, agPortCurCfgTableEntry=agPortCurCfgTableEntry, igmpFltCurCfgMcastIp2=igmpFltCurCfgMcastIp2, bgpNewCfgPeerRemoteAs=bgpNewCfgPeerRemoteAs, allportsStatsInPkts=allportsStatsInPkts, igmpClearVlanStats=igmpClearVlanStats, bgpNewCfgPeerUpdateSrcLoopIf=bgpNewCfgPeerUpdateSrcLoopIf, fipsPortNewCfgFipsEna=fipsPortNewCfgFipsEna, ipCurCfgStaticNbrIp=ipCurCfgStaticNbrIp, nsnmpInSetRequests=nsnmpInSetRequests, ipCurCfgRmapPrec=ipCurCfgRmapPrec, dhcpsnpStats=dhcpsnpStats, arpStatEntries=arpStatEntries, vmapVlanCfgNonServerPorts=vmapVlanCfgNonServerPorts, qosCurCfgMap8021p=qosCurCfgMap8021p, vnic=vnic, ospfCurCfgLSDB=ospfCurCfgLSDB, vmNewCfgGroupValidateMode=vmNewCfgGroupValidateMode, agCurCfgNTPSecServer=agCurCfgNTPSecServer, ospfCumNbrRstAd=ospfCumNbrRstAd, ripInfoIntfTrigUpdate=ripInfoIntfTrigUpdate, ospf3NewCfgRedistRouteTag=ospf3NewCfgRedistRouteTag, vmCurCfgGroupMacGroupIndex=vmCurCfgGroupMacGroupIndex, ospf3NewCfgAreaDelete=ospf3NewCfgAreaDelete, swLACPPortBlocked=swLACPPortBlocked, lldpInfoTxEntry=lldpInfoTxEntry, vnicNewCfgGroupRemTrunk=vnicNewCfgGroupRemTrunk, ripNewCfgIntfTable=ripNewCfgIntfTable, agAccessCurStrongPassFailLog=agAccessCurStrongPassFailLog, stpStats=stpStats, vlagNewCfgTierId=vlagNewCfgTierId, ospfNewCfgLoopIfEntry=ospfNewCfgLoopIfEntry, ospf3CurCfgHostIpAddr=ospf3CurCfgHostIpAddr, agApplyString=agApplyString, agTacacsUserMapNewCfgUId=agTacacsUserMapNewCfgUId, swHotlinksMasterUp=swHotlinksMasterUp, ospf3CurCfgAreaId=ospf3CurCfgAreaId, ospfNewCfgEbgpAddOutRmap=ospfNewCfgEbgpAddOutRmap, hwFan3RPMValue=hwFan3RPMValue, layer3Stats=layer3Stats, vmGroupInfoIP=vmGroupInfoIP, bgpCurCfgPeerRipState=bgpCurCfgPeerRipState, ripStatInBadVersion=ripStatInBadVersion, stpInfoPortPriority=stpInfoPortPriority, ipNewCfgIntfAdvIntervalMin=ipNewCfgIntfAdvIntervalMin, ipCurCfgNwfMask=ipCurCfgNwfMask, l2ThashCurCfgSmacState=l2ThashCurCfgSmacState, mstCistCurCfgPortPriority=mstCistCurCfgPortPriority, ipsecNewCfgSelectorDstPrefix=ipsecNewCfgSelectorDstPrefix, agAccessCurDefaultAdmin=agAccessCurDefaultAdmin, swVlagIslDown=swVlagIslDown, ipv6icmpInEchoReq=ipv6icmpInEchoReq, bgpInfoSummaryTable=bgpInfoSummaryTable, vrrpNewCfgVirtRtrGrpPreempt=vrrpNewCfgVirtRtrGrpPreempt, igmpSnoopNewCfgVlanFastlvAdd=igmpSnoopNewCfgVlanFastlvAdd, hwTemperatureSensor3=hwTemperatureSensor3, rxMldIfStatsToExcFmcrsv2=rxMldIfStatsToExcFmcrsv2, vrrpCurCfgVirtRtrFastAdvertisement=vrrpCurCfgVirtRtrFastAdvertisement, ospf3NewCfgRedistState=ospf3NewCfgRedistState, ecpChnlRxDrop=ecpChnlRxDrop, ripNewCfgIntfDefault=ripNewCfgIntfDefault, portMgmtStatsRxErrors=portMgmtStatsRxErrors, agCurRFC4741NetconfAccess=agCurRFC4741NetconfAccess, ospf3NewCfgSpfHold=ospf3NewCfgSpfHold, arpStatHighWater=arpStatHighWater, ipDataRouteInfoIndx=ipDataRouteInfoIndx, agAccessNewStrongPassValidity=agAccessNewStrongPassValidity, ipGatewayIPv6InfoAddr=ipGatewayIPv6InfoAddr, fdbCurCfgPort=fdbCurCfgPort, ospfCurCfgRangeAddr=ospfCurCfgRangeAddr, acl6NewCfgTcpudpReset=acl6NewCfgTcpudpReset, fipsInfoFcfMac=fipsInfoFcfMac, ipCurCfgStaticArpPort=ipCurCfgStaticArpPort, ndprefixCurCfgValidLifetime=ndprefixCurCfgValidLifetime, acl6NewCfgIndex=acl6NewCfgIndex, agCurCfgSyslog2Sev=agCurCfgSyslog2Sev, vlagInfoIslPortchannel=vlagInfoIslPortchannel, cistRootPathCost=cistRootPathCost, igmpSnoopCurCfgFlood=igmpSnoopCurCfgFlood, bgpCurCfgAggrIndex=bgpCurCfgAggrIndex, ospf3IntfWaiting=ospf3IntfWaiting, ospf3AreaTxlsUpdates=ospf3AreaTxlsUpdates, mstCistNewCfgBridgeMaxAge=mstCistNewCfgBridgeMaxAge, ipMgmtRouteInfoInterface=ipMgmtRouteInfoInterface, agNewCfgSyslogTrapSsh=agNewCfgSyslogTrapSsh, ospfIntfErrAreaMismatch=ospfIntfErrAreaMismatch, bgpNewCfgGroupOrig=bgpNewCfgGroupOrig, vnicNewCfgGroupTable=vnicNewCfgGroupTable, vlagNewCfgHlthchkConnectRetryInterval=vlagNewCfgHlthchkConnectRetryInterval, mstCistCurCfgVlanBmap=mstCistCurCfgVlanBmap, ospfCurCfgHostState=ospfCurCfgHostState, ipmcNewCfgStaticRouteVlanId=ipmcNewCfgStaticRouteVlanId, vlagInfoState=vlagInfoState, igmpNewVlanOperVersion=igmpNewVlanOperVersion, routeStatEntries=routeStatEntries, dhcpSnoopingStatDroppedPacketRateLimit=dhcpSnoopingStatDroppedPacketRateLimit, failoverNewCfgTriggerLimit=failoverNewCfgTriggerLimit, ospfNewCfgFixedOutRmapList=ospfNewCfgFixedOutRmapList, acl6CurCfgSrcIPv6PrefixLen=acl6CurCfgSrcIPv6PrefixLen, vrrpNewCfgVirtRtrGrpID=vrrpNewCfgVirtRtrGrpID, ipNewCfgStaticRouteDestIp=ipNewCfgStaticRouteDestIp, ospf3NewCfgRangePrefixLen=ospf3NewCfgRangePrefixLen, vlagStatsIgmpReportsForwarded=vlagStatsIgmpReportsForwarded, vrrpCurCfgVirtRtrID=vrrpCurCfgVirtRtrID, ospf3IntfNbrAttempt=ospf3IntfNbrAttempt, bgpNewCfgPeerTable=bgpNewCfgPeerTable, ibmnosPortCfgTableEntry=ibmnosPortCfgTableEntry, ikeNewCfgCookie=ikeNewCfgCookie, ipRouteEcmpInfoDestIndx=ipRouteEcmpInfoDestIndx, ipsecCurCfgSelectorDstPrefix=ipsecCurCfgSelectorDstPrefix, qosCurCfgCosIndex=qosCurCfgCosIndex, agTransferAction=agTransferAction, mstCistCurCfgPortTableEntry=mstCistCurCfgPortTableEntry, agTransferPort=agTransferPort, ipNewCfgAspathState=ipNewCfgAspathState, failoverCurCfgTriggerMmonPort=failoverCurCfgTriggerMmonPort, swPrimaryPowerSupplyFixedNotify=swPrimaryPowerSupplyFixedNotify, icmpStatsInTimeExcds=icmpStatsInTimeExcds, ecpChnlStag=ecpChnlStag, ospf3AreaInfoTable=ospf3AreaInfoTable, agCfgDumpTableEntry=agCfgDumpTableEntry, agCurCfgSyslogTrapAll=agCurCfgSyslogTrapAll, fipsInfoFcoe=fipsInfoFcoe, arpCurCfgReARPPeriod=arpCurCfgReARPPeriod, ospf3NewCfgIntfEncryEnable=ospf3NewCfgIntfEncryEnable, ospf3VirtIfInfoLinkLsaCksumSum=ospf3VirtIfInfoLinkLsaCksumSum, ipsecCurCfgDynamicPolicyEntry=ipsecCurCfgDynamicPolicyEntry, ospf3NewCfgAreaDefaultMetric=ospf3NewCfgAreaDefaultMetric, ipNewCfgGwDelete=ipNewCfgGwDelete, ibmnosFdbClearMac=ibmnosFdbClearMac, mstCistCurCfgBridgeMaxAge=mstCistCurCfgBridgeMaxAge, ibmnosPortCtrlTable=ibmnosPortCtrlTable, ntpClearStats=ntpClearStats, vmCurCfgProfileShapingPeak=vmCurCfgProfileShapingPeak, ospfExtLsdbInfoType=ospfExtLsdbInfoType, ipv6InHdrerrs=ipv6InHdrerrs, agPortNewCfgFloodBlocking=agPortNewCfgFloodBlocking, stpInfoIndex=stpInfoIndex, bgpNewCfgGroupTtlSecHops=bgpNewCfgGroupTtlSecHops, mldInfoGroupsTable=mldInfoGroupsTable, ipv6icmpOutNeighAdv=ipv6icmpOutNeighAdv, igmpInfoTable=igmpInfoTable, virtVMwareHostVswitchEntry=virtVMwareHostVswitchEntry, ospfCurCfgEbgpMetricType=ospfCurCfgEbgpMetricType, ipsecNewCfgTxformAuth=ipsecNewCfgTxformAuth, ripNewCfgOspfRemoveOutRmap=ripNewCfgOspfRemoveOutRmap, geaportInfoUnit=geaportInfoUnit, bgpCurCfgPeerOrig=bgpCurCfgPeerOrig, nsnmpInGetRequests=nsnmpInGetRequests, ospf3CurCfgRangeState=ospf3CurCfgRangeState, aclCurCfgFilterAction=aclCurCfgFilterAction, acl6CurCfgFilterActionChangeVlan=acl6CurCfgFilterActionChangeVlan, ipCurCfgAlistTable=ipCurCfgAlistTable, oamStatsPortIndex=oamStatsPortIndex, pptNewCfgPrecedence=pptNewCfgPrecedence, thashL2=thashL2, ipCurCfgIntfLoopbackAddr=ipCurCfgIntfLoopbackAddr, ipsecNewCfgManualPolicyEntry=ipsecNewCfgManualPolicyEntry, mcastFdbNewCfgAddPort=mcastFdbNewCfgAddPort, ipv6icmpInBadcode=ipv6icmpInBadcode, ospf3CurCfgIntfPassive=ospf3CurCfgIntfPassive, igmpSnoopNewCfgVlanBmap=igmpSnoopNewCfgVlanBmap, hotlinksInfoTriggerTable=hotlinksInfoTriggerTable, allportsStatsInMcast=allportsStatsInMcast, nsnmpProxyDrops=nsnmpProxyDrops, lldpCurCfgTxDelay=lldpCurCfgTxDelay, ikeCurCfgIdentity=ikeCurCfgIdentity, ipv6icmpOutEchoReq=ipv6icmpOutEchoReq, ospfNewCfgIbgpAddOutRmap=ospfNewCfgIbgpAddOutRmap, agNewCfgSyslogTrapHotlinks=agNewCfgSyslogTrapHotlinks, ospfIntfRxTxIndex=ospfIntfRxTxIndex, vlagStatsSystem=vlagStatsSystem, ospf3CumIntfAllEvents=ospf3CumIntfAllEvents, ospfAreaIntfNbrChange=ospfAreaIntfNbrChange, trunkGroupCurCfgTable=trunkGroupCurCfgTable, vrrpCurCfgVirtRtrGrpState=vrrpCurCfgVirtRtrGrpState, ipCurCfgIntfIndex=ipCurCfgIntfIndex, ospf3IfNbrPriority=ospf3IfNbrPriority, ospfNewCfgIbgpOutRmapList=ospfNewCfgIbgpOutRmapList, acl6NewCfgIPv6TrafficClass=acl6NewCfgIPv6TrafficClass, ospf3NewCfgRangeTable=ospf3NewCfgRangeTable, agCurCfgSyslogTrapSsh=agCurCfgSyslogTrapSsh)
mibBuilder.exportSymbols("IBM-GbTOR-10G-L2L3-MIB", acl6CurCfgDstIPv6PrefixLen=acl6CurCfgDstIPv6PrefixLen, lacpNewPortActorMinLinks=lacpNewPortActorMinLinks, igmpCurCfgElectionType=igmpCurCfgElectionType, ospfCumRxlsReqs=ospfCumRxlsReqs, tacCurCfgDirectedRequest=tacCurCfgDirectedRequest, agAccessCurStrongPassAttemptsMaxFail=agAccessCurStrongPassAttemptsMaxFail, ospfTmrsKckOffRetransmit=ospfTmrsKckOffRetransmit, ospfExtLsdbInfoIndex=ospfExtLsdbInfoIndex, ipsecCurCfgManualPolicyIndex=ipsecCurCfgManualPolicyIndex, ibmnosSfpInfoPartNumber=ibmnosSfpInfoPartNumber, dot3RateStatsAlignmentErrors=dot3RateStatsAlignmentErrors, agCurCfgTelnetAccess=agCurCfgTelnetAccess, vlagStatsPduSentHlthCheck=vlagStatsPduSentHlthCheck, dot3RateStatsMultipleCollisionFrames=dot3RateStatsMultipleCollisionFrames, nsnmpInBadTypes=nsnmpInBadTypes, agNewCfgLFDStatus=agNewCfgLFDStatus, ipsecNewCfgTxformTable=ipsecNewCfgTxformTable, ipNewCfgAspathEntry=ipNewCfgAspathEntry, ibmnosConfigSaveStatus=ibmnosConfigSaveStatus, ipv6pmtuCfg=ipv6pmtuCfg, hwTempSensors=hwTempSensors, igmpCurQurCfgVlanIndex=igmpCurQurCfgVlanIndex, mstCurCfgRegionName=mstCurCfgRegionName, nsnmpOutGetNexts=nsnmpOutGetNexts, ipCurCfgIntfBroadcast=ipCurCfgIntfBroadcast, portStatsPhyIfInBroadcastPkts=portStatsPhyIfInBroadcastPkts, ipNwfTableMax=ipNwfTableMax, aclCurCfgDstPortMask=aclCurCfgDstPortMask, ipRouteEcmpInfoGateway=ipRouteEcmpInfoGateway, bgpInfoEstTransitions=bgpInfoEstTransitions, pktStats=pktStats, agPortNewCfgGigEthFctl=agPortNewCfgGigEthFctl, ipStatsOutRequests=ipStatsOutRequests, agAccessNewStrongPassAttemptsMaxFail=agAccessNewStrongPassAttemptsMaxFail, virtVMwareHostDetailInfoTable=virtVMwareHostDetailInfoTable, igmpFltNewCfgDelete=igmpFltNewCfgDelete, acl6CurCfgEntry=acl6CurCfgEntry, markerresponsepdusTx=markerresponsepdusTx, agNewCfgSysCustomDstEnd=agNewCfgSysCustomDstEnd, ikeCurCfgPropCipher=ikeCurCfgPropCipher, ibmnos=ibmnos, agRtcDate=agRtcDate, ospfSumRangesInfoNetwork=ospfSumRangesInfoNetwork, lldpNewCfgReinitDelay=lldpNewCfgReinitDelay, failoverNewCfgTriggerId=failoverNewCfgTriggerId, pptCurCfgLabel=pptCurCfgLabel, ipRoute6InfoDestIp=ipRoute6InfoDestIp, radCurCfgPort=radCurCfgPort, nsnmpInTotalReqVars=nsnmpInTotalReqVars, dhcpSnoopingBindingInfoPort=dhcpSnoopingBindingInfoPort, agCurCfgCpuRateLimitArp=agCurCfgCpuRateLimitArp, agApplyConfiguration=agApplyConfiguration, igmpNewCfgOnOff=igmpNewCfgOnOff, vmapCurCfgEthFmt=vmapCurCfgEthFmt, ipNewCfgIntfState=ipNewCfgIntfState, agNewCfgMgmtNetEntry=agNewCfgMgmtNetEntry, aclNewCfg8021pPriority=aclNewCfg8021pPriority, rxIgmpInvalidPkts=rxIgmpInvalidPkts, igmpFltCurCfgIndx=igmpFltCurCfgIndx, ospf3AreaInfoId=ospf3AreaInfoId, vlagStatsPduSentFdbInactiveDel=vlagStatsPduSentFdbInactiveDel, agPortCurCfgBroadcastThreshold=agPortCurCfgBroadcastThreshold, vrrpNewCfgVirtRtrGrpFastAdvertisement=vrrpNewCfgVirtRtrGrpFastAdvertisement, ospf3CurCfgRedistAddr=ospf3CurCfgRedistAddr, ipIntfInfoTable=ipIntfInfoTable, hwFan4RPMValue=hwFan4RPMValue, igmpInfoVersion=igmpInfoVersion, dnsCfg=dnsCfg, swDefAdminDisable=swDefAdminDisable, agChassis=agChassis, ipNewCfgAlistNwf=ipNewCfgAlistNwf, ospf3NewCfgRedistMetricType=ospf3NewCfgRedistMetricType, lldpInfoPortAdminStatus=lldpInfoPortAdminStatus, ipCurCfgBootpOpt82State=ipCurCfgBootpOpt82State, ospf3IfInfoAuthKey=ospf3IfInfoAuthKey, ospf3IntfErrIndex=ospf3IntfErrIndex, rxIgmpGrpSpecificQueries=rxIgmpGrpSpecificQueries, igmpInfo=igmpInfo, agNewCfgSyslogTrapSystem=agNewCfgSyslogTrapSystem, ospfNewCfgMdkeyEntry=ospfNewCfgMdkeyEntry, ospfIntfNbrRstAd=ospfIntfNbrRstAd, igmpFltNewCfgPortFiltBmap=igmpFltNewCfgPortFiltBmap, vrrpNewCfgVirtRtrTableEntry=vrrpNewCfgVirtRtrTableEntry, allportsStatsInOctets=allportsStatsInOctets, stgNewCfgRemoveVlan=stgNewCfgRemoveVlan, agAccessNewStrongPassWarning=agAccessNewStrongPassWarning, ospf3CurCfgAreaType=ospf3CurCfgAreaType, ospf3AreaRxTxDisdStatsEntry=ospf3AreaRxTxDisdStatsEntry, ospfSumRangesInfoMask=ospfSumRangesInfoMask, lacpInfoPortPartOpKey=lacpInfoPortPartOpKey, bgpInfoDynamicPeerVersion=bgpInfoDynamicPeerVersion, dhcpInfoLeaseExpires=dhcpInfoLeaseExpires, ospfAreaIntfBackup=ospfAreaIntfBackup, tacNewCfgTimeout=tacNewCfgTimeout, fipsInfoVlans=fipsInfoVlans, vmNewCfgGroupAddVm=vmNewCfgGroupAddVm, vlagNewCfgTrunkState=vlagNewCfgTrunkState, agAccessUserNewCfgDelete=agAccessUserNewCfgDelete, ipCurCfgGwRetry=ipCurCfgGwRetry, fdbCurCfgMac=fdbCurCfgMac, vlagInfoIslProtocol=vlagInfoIslProtocol, ipsecCurCfgSelectorTable=ipsecCurCfgSelectorTable, ospfRoutesInfoType=ospfRoutesInfoType, ospf3AreaRxDatabase=ospf3AreaRxDatabase, bgpCurCfgPeerOspfState=bgpCurCfgPeerOspfState, ibmnosLoginAuthentication=ibmnosLoginAuthentication, tacNewCfgSecPorttoUse=tacNewCfgSecPorttoUse, ipsecCurCfgSelectorProto=ipsecCurCfgSelectorProto, vmapCfg=vmapCfg, tacChangePassForUser=tacChangePassForUser, lacpInfoPortActAdDef=lacpInfoPortActAdDef, ospf3AreaErrDeadMismatch=ospf3AreaErrDeadMismatch, vrrpInfoVirtRtrState=vrrpInfoVirtRtrState, ospf3IntfErrRxOspfOff=ospf3IntfErrRxOspfOff, dnsNewCfgPriServerPort=dnsNewCfgPriServerPort, bgpCurCfgGroupTtl=bgpCurCfgGroupTtl, ospfIntfRxlsAcks=ospfIntfRxlsAcks, nbrClear=nbrClear, lldpInfoRemoteDevicesManAddr=lldpInfoRemoteDevicesManAddr, ldapCurCfgState=ldapCurCfgState, vmNewCfgGroupProfileName=vmNewCfgGroupProfileName, lldpInfoPortEntry=lldpInfoPortEntry, ipNewCfgStaticArpIndx=ipNewCfgStaticArpIndx, PYSNMP_MODULE_ID=ibmGbTORG8124MIB, aclCurCfgPortIndex=aclCurCfgPortIndex, ospfCurCfgHostAreaIndex=ospfCurCfgHostAreaIndex, ripInfoIntfState=ripInfoIntfState, agNewCfgSyslogTrapVrrp=agNewCfgSyslogTrapVrrp, mldInfoGroupSource=mldInfoGroupSource, ipv6InRoutsols=ipv6InRoutsols, ospf3NewCfgIntfAuthType=ospf3NewCfgIntfAuthType, igmpMrtrInfoTable=igmpMrtrInfoTable, igmpSnoopCfg=igmpSnoopCfg, agDiffState=agDiffState, ripNewCfgIntfEntry=ripNewCfgIntfEntry, bgpNewCfgGroupUpdateSrcLoopIf=bgpNewCfgGroupUpdateSrcLoopIf, Timeout=Timeout, layer3Oper=layer3Oper, nbrInfoIndex=nbrInfoIndex, ipCurCfgIntfVlan=ipCurCfgIntfVlan, ospfIfInfoBackupDesignatedRouterIpAddress=ospfIfInfoBackupDesignatedRouterIpAddress, lacpInfoPortPartOpDist=lacpInfoPortPartOpDist, igmpV3SnoopCfg=igmpV3SnoopCfg, ipCurCfgGwArp=ipCurCfgGwArp, ndprefixCurCfgEntry=ndprefixCurCfgEntry, ospfIntfTxPkts=ospfIntfTxPkts, ospfVirtIntfInfoRouterId=ospfVirtIntfInfoRouterId, lldpStatsClearAll=lldpStatsClearAll, bgpCurCfgAggrAddr=bgpCurCfgAggrAddr, ipsecCurCfgSelectorSrc=ipsecCurCfgSelectorSrc, lacpNewPortSetToDefault=lacpNewPortSetToDefault, ipsecCurCfgTxformCipher=ipsecCurCfgTxformCipher, nsnmpInBadCommunityUses=nsnmpInBadCommunityUses, ipDataRouteInfoGateway=ipDataRouteInfoGateway, ospf3IntfRxTxDisdIndex=ospf3IntfRxTxDisdIndex, ipDataRouteInfoTag=ipDataRouteInfoTag, portStatsLinkStateChange=portStatsLinkStateChange, stpInfoTable=stpInfoTable, ripCurCfgIntfListen=ripCurCfgIntfListen, ipv6icmpInMsgs=ipv6icmpInMsgs, ospfNewCfgHostEntry=ospfNewCfgHostEntry, agNewCfgNTPServer=agNewCfgNTPServer, radCurCfgPorttoUse=radCurCfgPorttoUse, vmapNewCfgMeterReset=vmapNewCfgMeterReset, lldpInfoPortsysnametlv=lldpInfoPortsysnametlv, ospf3IntfNbrFull=ospf3IntfNbrFull, oamInfoPortRemoteMAC=oamInfoPortRemoteMAC, vmapVlanCurCfgAllPortsTable=vmapVlanCurCfgAllPortsTable, ipNewCfgStaticNbrVlan=ipNewCfgStaticNbrVlan, virtVMwareHostPGEntry=virtVMwareHostPGEntry, mstCistNewCfgPortPvstProtection=mstCistNewCfgPortPvstProtection, lldpCurCfgPortsysnametlv=lldpCurCfgPortsysnametlv, ipStaticRoute6Cfg=ipStaticRoute6Cfg, agClearFlashDump=agClearFlashDump, radNewCfgSecondaryServer=radNewCfgSecondaryServer, ldapCurCfgBackdoor=ldapCurCfgBackdoor, vmGroupInfoMac=vmGroupInfoMac, agNewCfgSyslogTrapVnic=agNewCfgSyslogTrapVnic, ospf3AreaDisdlsReqs=ospf3AreaDisdlsReqs, vlanCurCfgPorts=vlanCurCfgPorts, ipCurCfgBootpGlobalServerTable=ipCurCfgBootpGlobalServerTable, stgCurCfgPortPathCost=stgCurCfgPortPathCost, fcoeStatsFcfAdded=fcoeStatsFcfAdded, bgpCurCfgGroupEntry=bgpCurCfgGroupEntry, ospf3CurCfgAbrType=ospf3CurCfgAbrType, igmpV3SnoopCurCfgEnaDis=igmpV3SnoopCurCfgEnaDis, ospf3CumRxTxDisdStats=ospf3CumRxTxDisdStats, ospf3AreaTxlsReqs=ospf3AreaTxlsReqs, vlagNewCfgLacpTable=vlagNewCfgLacpTable, ipCurCfgGwState=ipCurCfgGwState, vmapNewCfgDstPort=vmapNewCfgDstPort, bgpNewCfgAggrState=bgpNewCfgAggrState, ipsecCurCfgTxformTable=ipsecCurCfgTxformTable, vnicCurCfgVnicMAC=vnicCurCfgVnicMAC, ospfCumNbrLoadingDone=ospfCumNbrLoadingDone, ipCurCfgAspathAction=ipCurCfgAspathAction, agCurCfgLFDTime=agCurCfgLFDTime, vrrpIfTableMaxSize=vrrpIfTableMaxSize, vnicNewCfgGroupDelete=vnicNewCfgGroupDelete, lacpInfoPortOperTable=lacpInfoPortOperTable, ospf3CurCfgConnectedMetricType=ospf3CurCfgConnectedMetricType, bgpNewCfgPeerPassive=bgpNewCfgPeerPassive, ospfCumIntfBackup=ospfCumIntfBackup, virtVMwareHostDetailInfoIPAddr=virtVMwareHostDetailInfoIPAddr, ospfCurCfgVirtIntfNbr=ospfCurCfgVirtIntfNbr, ipmcNewCfgStaticRouteDelete=ipmcNewCfgStaticRouteDelete, mldInfoMRouterVlan=mldInfoMRouterVlan, bgpNewCfgGroupState=bgpNewCfgGroupState, mldStatClearAll=mldStatClearAll, bgpNewCfgGroupRemoveInRmap=bgpNewCfgGroupRemoveInRmap, vlagStatsPduSentSystemInfo=vlagStatsPduSentSystemInfo, accessInfoClearAllUserLocks=accessInfoClearAllUserLocks, acl6List=acl6List, ospfNewCfgRangeDelete=ospfNewCfgRangeDelete, icmpStatsOutAddrMaskReps=icmpStatsOutAddrMaskReps, agLdapConfig=agLdapConfig, vmNewCfgProfileDelete=vmNewCfgProfileDelete, mstCistCurCfgPortIndex=mstCistCurCfgPortIndex, mldStatBadReceiveIf=mldStatBadReceiveIf, memoryStats=memoryStats, portStatsIndx=portStatsIndx, tacNewCfgCmdAuthor=tacNewCfgCmdAuthor, ipDataRouteInfoInterface=ipDataRouteInfoInterface, agCurCfgSyslogFac=agCurCfgSyslogFac, lacpCurPortActorAdminKey=lacpCurPortActorAdminKey, rip2CurCfgState=rip2CurCfgState, ipStaticRoute6ClearAllByGatewayIp=ipStaticRoute6ClearAllByGatewayIp, lldpInfoPortsysdescrtlv=lldpInfoPortsysdescrtlv, bootpRelayStatsTable=bootpRelayStatsTable, aclCurCfgSrcMACMask=aclCurCfgSrcMACMask, vmapCurCfgFilterActionSetPrio=vmapCurCfgFilterActionSetPrio, vmapNewCfgDstIPAddress=vmapNewCfgDstIPAddress, ospf3NewCfgIntfAuthReset=ospf3NewCfgIntfAuthReset, ospfLoopIfInfoDeadMS=ospfLoopIfInfoDeadMS, ipmcNewCfgStaticRouteDestIp=ipmcNewCfgStaticRouteDestIp, igmpStaticMrtrNewCfgVersion=igmpStaticMrtrNewCfgVersion, ospfIntfTxlsReqs=ospfIntfTxlsReqs, ipInfo=ipInfo, ripNewCfgEospfMetric=ripNewCfgEospfMetric, ntpOperSendReq=ntpOperSendReq, hotlinksInfoTriggerActive=hotlinksInfoTriggerActive, igmpCurCfgQueryInterval=igmpCurCfgQueryInterval, ipRoute6InfoInterface=ipRoute6InfoInterface, vmapCurCfgFilterActionChangeVlan=vmapCurCfgFilterActionChangeVlan, vlagNewCfgTrunkTableEntry=vlagNewCfgTrunkTableEntry, ripCurCfgIntfKey=ripCurCfgIntfKey, ospfExtLsdbInfoAdvertisement=ospfExtLsdbInfoAdvertisement, agAccessCurStrongPassWarning=agAccessCurStrongPassWarning, vmCurCfgGroupMacTable=vmCurCfgGroupMacTable, vmapCurCfgUser=vmapCurCfgUser, sflowNewPortCfgTable=sflowNewPortCfgTable, vmCurCfgGroupStg=vmCurCfgGroupStg, ospfNbrInFullState=ospfNbrInFullState, mpCpuStatsUtil1Second=mpCpuStatsUtil1Second)
mibBuilder.exportSymbols("IBM-GbTOR-10G-L2L3-MIB", ospfCumNbrDown=ospfCumNbrDown, ospf3AreaRxlsAcks=ospf3AreaRxlsAcks, ospf3NewCfgIntfEncryAuthKey=ospf3NewCfgIntfEncryAuthKey, ospf3IntfRxlsUpdates=ospf3IntfRxlsUpdates, agNewCfgResetControl=agNewCfgResetControl, qosNewCfgDscpTable=qosNewCfgDscpTable, igmpCurCfgQurSrcIp=igmpCurCfgQurSrcIp, fcoeConfig=fcoeConfig, agPortNewCfgBpduGuard=agPortNewCfgBpduGuard, igmpFltNewCfgPortTable=igmpFltNewCfgPortTable, ipStaticArpTableMaxSize=ipStaticArpTableMaxSize, mcastFdbEntry=mcastFdbEntry, txMldIfStatsIncCrsv2=txMldIfStatsIncCrsv2, ospf3IfInfoNetworkType=ospf3IfInfoNetworkType, ospf3ExternalLsa=ospf3ExternalLsa, vlanNewCfgVlanId=vlanNewCfgVlanId, stgNewCfgBrgHelloTime=stgNewCfgBrgHelloTime, tacCurCfgEnableAccounting=tacCurCfgEnableAccounting, oamStatsPortRemoteLinkFaults=oamStatsPortRemoteLinkFaults, bgpNewCfgGroupTtl=bgpNewCfgGroupTtl, ldapNewCfgSecPorttoUse=ldapNewCfgSecPorttoUse, lldpNewCfgPortpowermditlv=lldpNewCfgPortpowermditlv, stgCurCfgTable=stgCurCfgTable, tcpStatsRtoAlgorithm=tcpStatsRtoAlgorithm, ipFwdCurCfgState=ipFwdCurCfgState, ospf3TotalLsaOriginated=ospf3TotalLsaOriginated, ospf3AreaNbrChangeStatsEntry=ospf3AreaNbrChangeStatsEntry, tacNewCfgCmap=tacNewCfgCmap, ospf3IntfErrHelloNoNbr=ospf3IntfErrHelloNoNbr, vmNewCfgCheckActionBasic=vmNewCfgCheckActionBasic, oamStats=oamStats, trunkGroupInfoPortTrunkId=trunkGroupInfoPortTrunkId, lldpCurCfgPortframesztlv=lldpCurCfgPortframesztlv, agDiffTable=agDiffTable, mcastFdbCurCfgEntryIndex=mcastFdbCurCfgEntryIndex, failoverCfg=failoverCfg, agCfgBootNxtResetTime=agCfgBootNxtResetTime, vrrpNewCfgGenState=vrrpNewCfgGenState, trunkGroupCurCfgState=trunkGroupCurCfgState, lacpInfoAttAggrId=lacpInfoAttAggrId, ospf3NewCfgAreaNoSumm=ospf3NewCfgAreaNoSumm, agCurCfgSyslogTrapFcoe=agCurCfgSyslogTrapFcoe, vlagInstanceId=vlagInstanceId, ospf3RedistributeConnected=ospf3RedistributeConnected, ripNewCfgIntfAuth=ripNewCfgIntfAuth, agImage1Ver=agImage1Ver, agHavePanicDump=agHavePanicDump, memoryFreeStats=memoryFreeStats, tcpMGMTTableEntry=tcpMGMTTableEntry, ipStaticRouteClearAll=ipStaticRouteClearAll, ospfIntfNbrAdjointOk=ospfIntfNbrAdjointOk, vmapNewCfgKbitsSec=vmapNewCfgKbitsSec, agentInfo=agentInfo, ipNewCfgStaticRoute6Gateway=ipNewCfgStaticRoute6Gateway, cistRegionalPathCost=cistRegionalPathCost, ripGeneral=ripGeneral, ipNewCfgIntfDelete=ipNewCfgIntfDelete, bgpInfoDynamicPeerIndex=bgpInfoDynamicPeerIndex, vmapCurCfgDstPort=vmapCurCfgDstPort, agNewCfgSyslogTrapDifftrak=agNewCfgSyslogTrapDifftrak, ibmnosInitiateConfigSave=ibmnosInitiateConfigSave, ospf3RoutesInfoIndex=ospf3RoutesInfoIndex, ipsecSpdInfoSrcAddr=ipsecSpdInfoSrcAddr, lacpDeleteTrunk=lacpDeleteTrunk, agCurRFC4741NetconfSessionTimeout=agCurRFC4741NetconfSessionTimeout, aclNewCfgMeterEnable=aclNewCfgMeterEnable, ripInfoIntfDefault=ripInfoIntfDefault, agNewCfgMgmtNetIndex=agNewCfgMgmtNetIndex, ipv6PmtuInfoIndx=ipv6PmtuInfoIndx, failoverNewCfgTriggerMconPortRem=failoverNewCfgTriggerMconPortRem, bgpCurCfgClusterId=bgpCurCfgClusterId, ipCurCfgAlistState=ipCurCfgAlistState, agSyslog=agSyslog, ipv6icmpOutDstUnreach=ipv6icmpOutDstUnreach, vrrpVirtRtrGrpTableMaxSize=vrrpVirtRtrGrpTableMaxSize, virtCurCfgState=virtCurCfgState, vmbwCurCfgTable=vmbwCurCfgTable, ripStatInPackets=ripStatInPackets, vrrpNewCfgVirtRtrInterval=vrrpNewCfgVirtRtrInterval, ipNewCfgNwfIndex=ipNewCfgNwfIndex, sflowNewCfgServerPort=sflowNewCfgServerPort, ospfGeneral=ospfGeneral, tacCurCfgSrcLoopIf=tacCurCfgSrcLoopIf, agCurCfgSyslogTrapCli=agCurCfgSyslogTrapCli, igmpFltNewCfgTableEntry=igmpFltNewCfgTableEntry, aclNewCfgTCPFlagsMask=aclNewCfgTCPFlagsMask, acl6NewCfgInprofDscpEnable=acl6NewCfgInprofDscpEnable, agNewCfgMgmtNetDelete=agNewCfgMgmtNetDelete, vmapNewCfg8021pPriority=vmapNewCfg8021pPriority, ipCurCfgAlistEntry=ipCurCfgAlistEntry, vmbwNewCfgTxRate=vmbwNewCfgTxRate, stpInfoPortDesignatedBridge=stpInfoPortDesignatedBridge, hotlinksCurCfgTriggerDelete=hotlinksCurCfgTriggerDelete, agNewCfgSyslogTrapIp=agNewCfgSyslogTrapIp, ospf3CurCfgNbrEntry=ospf3CurCfgNbrEntry, agCurCfgNTPService=agCurCfgNTPService, txMldIfStatsMLDv2Report=txMldIfStatsMLDv2Report, ipsecSpdInfoMode=ipsecSpdInfoMode, rip2CurCfgUpdatePeriod=rip2CurCfgUpdatePeriod, ospfAreaNbrExchangeDone=ospfAreaNbrExchangeDone, qosCurCfgDscpIndex=qosCurCfgDscpIndex, failoverInfoTriggerTable=failoverInfoTriggerTable, ospf3Version=ospf3Version, ospf3AreaIntfWaiting=ospf3AreaIntfWaiting, ospfCurCfgIntfHelloMS=ospfCurCfgIntfHelloMS, aclCurCfgSrcPortMask=aclCurCfgSrcPortMask, nbrInfoDestIp=nbrInfoDestIp, fcoeStatsResetAllCounters=fcoeStatsResetAllCounters, aclCurCfgKbitsBurst=aclCurCfgKbitsBurst, ipCurCfgStaticRoute6Indx=ipCurCfgStaticRoute6Indx, hwFan2RPMValue=hwFan2RPMValue, bgpCurCfgPeerUpdateSrcLoopIf=bgpCurCfgPeerUpdateSrcLoopIf, agCurCfgSyslogTrapIpv6=agCurCfgSyslogTrapIpv6, vmbwCurCfgCtrl=vmbwCurCfgCtrl, layer2Configs=layer2Configs, ospfCurCfgIntfDeadMS=ospfCurCfgIntfDeadMS, ipv6PmtuNewTimeout=ipv6PmtuNewTimeout, ikeCurCfgPskRemoteTable=ikeCurCfgPskRemoteTable, ospfCumNbrStart=ospfCumNbrStart, agCfgBootPendingReset=agCfgBootPendingReset, ospfIfNbrIpAddress=ospfIfNbrIpAddress, ospf3IntfDown=ospf3IntfDown, vrrpCurCfgVirtRtrGrpTckVlanPort=vrrpCurCfgVirtRtrGrpTckVlanPort, ospf3CurCfgSpfHold=ospf3CurCfgSpfHold, ipAlistTableMax=ipAlistTableMax, failoverInfoState=failoverInfoState, ipsecCurCfgIfManualPolicyBmap=ipsecCurCfgIfManualPolicyBmap, vmapNewCfgFilterAction=vmapNewCfgFilterAction, lldpInfoPortvlannametlv=lldpInfoPortvlannametlv, icmpStatsInEchoReps=icmpStatsInEchoReps, ipv6icmpOutMsgs=ipv6icmpOutMsgs, lacpInfoPortActAdPortState=lacpInfoPortActAdPortState, ospf3IntfDrOther=ospf3IntfDrOther, ospfIntfNbrN1way=ospfIntfNbrN1way, ipsecCurCfgTxformIntegrity=ipsecCurCfgTxformIntegrity, allportsStatsSpeed=allportsStatsSpeed, ipv6OutReqs=ipv6OutReqs, fdbState=fdbState, agPortNewCfgBroadcastThreshold=agPortNewCfgBroadcastThreshold, hotlinksStatsTriggerFdbFailed=hotlinksStatsTriggerFdbFailed, vmGroupInfoName=vmGroupInfoName, lacp=lacp, geaportInfoAlias=geaportInfoAlias, ipsecCurCfgSelectorIndex=ipsecCurCfgSelectorIndex, tacCurCfgEnaPassChange=tacCurCfgEnaPassChange, dhcpSnoopingCurCfgPortTable=dhcpSnoopingCurCfgPortTable, acl6CurCfgLog=acl6CurCfgLog, ripNewCfgFixedOutRmapList=ripNewCfgFixedOutRmapList, igmpStaticMrtrCfg=igmpStaticMrtrCfg, lldpCurCfgPortmgmtaddrtlv=lldpCurCfgPortmgmtaddrtlv, stgStatsPortRcvCfgBpdus=stgStatsPortRcvCfgBpdus, agCurCfgCpuRateLimitBpdu=agCurCfgCpuRateLimitBpdu, ospfNumberOfInterfacesUp=ospfNumberOfInterfacesUp, vmNewCfgProfileEntry=vmNewCfgProfileEntry, rxIgmpPimHellos=rxIgmpPimHellos, vrrpCurCfgGenTckVlanPortInc=vrrpCurCfgGenTckVlanPortInc, ospfNewCfgStaticMetricType=ospfNewCfgStaticMetricType, agApplyTableSize=agApplyTableSize, bgpInfoDynamicPeerRouterId=bgpInfoDynamicPeerRouterId, ospfCurCfgStaticMetric=ospfCurCfgStaticMetric, lacpInfoPortNtt=lacpInfoPortNtt, ospf3HostTableMaxSize=ospf3HostTableMaxSize, stateMgmtUdp=stateMgmtUdp, igmpCurVlanOlderVerTimer=igmpCurVlanOlderVerTimer, swImage2Version=swImage2Version, ipCurCfgStaticNbrIndx=ipCurCfgStaticNbrIndx, vnicNewCfgGroupRemVnic=vnicNewCfgGroupRemVnic, serverPortsNewCfgPorts=serverPortsNewCfgPorts, agentConfig=agentConfig, lacpInfoAggrId=lacpInfoAggrId, agNewCfgLFDTime=agNewCfgLFDTime, acl6NewCfgFilterAction=acl6NewCfgFilterAction, vmapNewCfgTagFmt=vmapNewCfgTagFmt, igmpSnoopNewCfgVlanClear=igmpSnoopNewCfgVlanClear, ipCurCfgIntfRetransmitTimer=ipCurCfgIntfRetransmitTimer, dhcpSnoopingStatInPacketRequest=dhcpSnoopingStatInPacketRequest, ospfCurCfgLoopIfIndex=ospfCurCfgLoopIfIndex, ospf3IntfDisdlsUpdates=ospf3IntfDisdlsUpdates, lldpInfoPortportvidtlv=lldpInfoPortportvidtlv, ecpChnlAckErr=ecpChnlAckErr, ldapNewCfgSecondaryIpAddr=ldapNewCfgSecondaryIpAddr, ospfAreaErrNetmaskMismatch=ospfAreaErrNetmaskMismatch, ospfExtLsdbInfoRouterId=ospfExtLsdbInfoRouterId, mldCurInterfaceLastListenQueryIntvl=mldCurInterfaceLastListenQueryIntvl, ospfIntfCountForRouter=ospfIntfCountForRouter, igmpSnoopCurCfgRobustness=igmpSnoopCurCfgRobustness, virtNewCfgVMwareHelloAddPort=virtNewCfgVMwareHelloAddPort, agTacacsUserMapNewCfgTable=agTacacsUserMapNewCfgTable, virtNewCfgState=virtNewCfgState, pmNewCfgPortMonitorTable=pmNewCfgPortMonitorTable, bgpInfoGroupEntry=bgpInfoGroupEntry, vrrpNewCfgIfTableEntry=vrrpNewCfgIfTableEntry, lldpPortTableMaxEnt=lldpPortTableMaxEnt, bgpCurCfgPeerStaticState=bgpCurCfgPeerStaticState, vmbwCurCfgTxBurst=vmbwCurCfgTxBurst, routeStatHighWater=routeStatHighWater, ospf3CumDisdDatabase=ospf3CumDisdDatabase, stgStatsPortXmtTcnBpdus=stgStatsPortXmtTcnBpdus, acl6NewCfgLog=acl6NewCfgLog, agCurCfgDefipMgtb=agCurCfgDefipMgtb, aclNewCfgFilterActionChangeVlan=aclNewCfgFilterActionChangeVlan, fcoeOper=fcoeOper, ospf3Cfg=ospf3Cfg, aclNewCfgLog=aclNewCfgLog, igmpMrtrInfoQrv=igmpMrtrInfoQrv, bgpInfoSentUpdates=bgpInfoSentUpdates, ospfIntfNbrN2way=ospfIntfNbrN2way, bgpNewCfgPeerUpdateSrcIf=bgpNewCfgPeerUpdateSrcIf, vlagCurCfgSwitchPriority=vlagCurCfgSwitchPriority, vmapGroupNewCfgServerPortsTableEntry=vmapGroupNewCfgServerPortsTableEntry, ipsecSaStatsProto=ipsecSaStatsProto, hwPowerSupply2State=hwPowerSupply2State, ipNewCfgAspathTable=ipNewCfgAspathTable, ndprefixCurCfgAutonomousFlag=ndprefixCurCfgAutonomousFlag, nbrInfoVlanId=nbrInfoVlanId, aclNewCfgStatistics=aclNewCfgStatistics, lldpNewCfgPortIndx=lldpNewCfgPortIndx, ipNewCfgIntfLoopbackAddr=ipNewCfgIntfLoopbackAddr, lacpInfoPortPartOpPortState=lacpInfoPortPartOpPortState, vnicNewCfgGroupTrunk=vnicNewCfgGroupTrunk, agCurBootNxtCliMode=agCurBootNxtCliMode, igmpNewCfgQurSrcIp=igmpNewCfgQurSrcIp, bgpInfoPeerRemoteAs=bgpInfoPeerRemoteAs, failoverCurCfgOnState=failoverCurCfgOnState, ipCurCfgStaticArpTable=ipCurCfgStaticArpTable, aclNewCfgUser=aclNewCfgUser, ipsecCurCfgTxformIndex=ipsecCurCfgTxformIndex, ipNewCfgIntfAddr=ipNewCfgIntfAddr, lldpInfoRemoteDevicesSystemCapSupported=lldpInfoRemoteDevicesSystemCapSupported, vmNewCfgGroupTable=vmNewCfgGroupTable, qosCurCfgPortPriorityEntry=qosCurCfgPortPriorityEntry, ospf3CumRxlsAcks=ospf3CumRxlsAcks, allportsStatsOutErrors=allportsStatsOutErrors, ospfIntfNbrhello=ospfIntfNbrhello, ospf3ABRType=ospf3ABRType, qosNewCfgCosWeightTable=qosNewCfgCosWeightTable, ospf3NewCfgAreaDefaultMetricType=ospf3NewCfgAreaDefaultMetricType, agCurCfgNTPSrcLoopIf=agCurCfgNTPSrcLoopIf, lldpNewCfgMsgTxHld=lldpNewCfgMsgTxHld, ospfExtLsdbInfoChecksum=ospfExtLsdbInfoChecksum, mstCurCfgStpMode=mstCurCfgStpMode, ospfTmrsKckOffLsaLock=ospfTmrsKckOffLsaLock, agImageForNextReset=agImageForNextReset, agCurCfgSyslogTrapMgmt=agCurCfgSyslogTrapMgmt, ospfVlinkCountForRouter=ospfVlinkCountForRouter, portMgmtStatsRxpackets=portMgmtStatsRxpackets, ospfSumRangesInfoTable=ospfSumRangesInfoTable, agNewCfgSyslog2Host=agNewCfgSyslog2Host, ospf3IntfBackup=ospf3IntfBackup, sflowCurCfgServerAddress=sflowCurCfgServerAddress, vmapCurCfgOutprofDscp=vmapCurCfgOutprofDscp, ipNewCfgIntfAnycast=ipNewCfgIntfAnycast, mstCistCurCfgPortPvstProtection=mstCistCurCfgPortPvstProtection, lacpInfoPortPartOpPortNum=lacpInfoPortPartOpPortNum)
mibBuilder.exportSymbols("IBM-GbTOR-10G-L2L3-MIB", bgpCurCfgGroupPassword=bgpCurCfgGroupPassword, ipsecCurCfgManualPolicyDelete=ipsecCurCfgManualPolicyDelete, hardwarePartNumber=hardwarePartNumber, agNewCfgSyslogTrapVlan=agNewCfgSyslogTrapVlan, dnsNewCfgFirstRequestAddr=dnsNewCfgFirstRequestAddr, fdbTable=fdbTable, aclCfg=aclCfg, ipNewCfgAspathRmapIndex=ipNewCfgAspathRmapIndex, vlagStatsPduSentOther=vlagStatsPduSentOther, ipFwdCurCfgDirectedBcast=ipFwdCurCfgDirectedBcast, ospf3IfInfoPassive=ospf3IfInfoPassive, ospfAreaRxlsAcks=ospfAreaRxlsAcks, ospfAreaTxDatabase=ospfAreaTxDatabase, agNewCfgSyslogTrapLldp=agNewCfgSyslogTrapLldp, intfLoopbackInfoNetMask=intfLoopbackInfoNetMask, ntpPrimaryServerRespRcvd=ntpPrimaryServerRespRcvd, ipCurCfgBootpBcastDomainBDIndex=ipCurCfgBootpBcastDomainBDIndex, ospfNewCfgAreaStatus=ospfNewCfgAreaStatus, routeStatEcmpMaxEntries=routeStatEcmpMaxEntries, oamStatsPortUnsupRx=oamStatsPortUnsupRx, ospf3NewCfgAreaType=ospf3NewCfgAreaType, ospfNewCfgHostDelete=ospfNewCfgHostDelete, bgpNewCfgClusterId=bgpNewCfgClusterId, vmNewCfgGroupRemPort=vmNewCfgGroupRemPort, igmpStaticMrtrCurCfgVersion=igmpStaticMrtrCurCfgVersion, virtNewCfgVirtCenterDelete=virtNewCfgVirtCenterDelete, ospfNewCfgIntfMdkey=ospfNewCfgIntfMdkey, lacpInfoPortAdminTable=lacpInfoPortAdminTable, igmpCurCfgQurRobustness=igmpCurCfgQurRobustness, ospfVirtIntfInfoEvents=ospfVirtIntfInfoEvents, agCurCfgHprompt=agCurCfgHprompt, agPortNewCfgTableEntry=agPortNewCfgTableEntry, totalMemoryStats=totalMemoryStats, vmapVlanNewCfgAllPortsTableEntry=vmapVlanNewCfgAllPortsTableEntry, lldpNewCfgPortportvidtlv=lldpNewCfgPortportvidtlv, agTransferTSDumpFileName=agTransferTSDumpFileName, vmGroupInfoVSwitch=vmGroupInfoVSwitch, aclNewCfgVLanId=aclNewCfgVLanId, vrrpStatBadAdvers=vrrpStatBadAdvers, agTacacsUserMapCurCfgMapping=agTacacsUserMapCurCfgMapping, agPortCurCfgUdld=agPortCurCfgUdld, aclNewCfgMeterAction=aclNewCfgMeterAction, ospf3NumberOfLsdbEntries=ospf3NumberOfLsdbEntries, agPortNewCfgLFDStatus=agPortNewCfgLFDStatus, vmapNewCfgStatistics=vmapNewCfgStatistics, ospfGeneralStats=ospfGeneralStats, vmNewCfgGroupIndex=vmNewCfgGroupIndex, ipStaticNbrCfg=ipStaticNbrCfg, igmpCurCfgQurMaxRespTime=igmpCurCfgQurMaxRespTime, agPortNewCfgMulticastThreshold=agPortNewCfgMulticastThreshold, ospf3IntfNbrN2way=ospf3IntfNbrN2way, mldInfoGroupVersion=mldInfoGroupVersion, agNewRFC4741NetconfAccess=agNewRFC4741NetconfAccess, ipsecSpdInfoULP=ipsecSpdInfoULP, virtVMwareVMInfoVswitch=virtVMwareVMInfoVswitch, ipNewCfgStaticRouteGateway=ipNewCfgStaticRouteGateway, bgpCurCfgAggrEntry=bgpCurCfgAggrEntry, ospf3CurCfgVirtIntfNbr=ospf3CurCfgVirtIntfNbr, ipsecNewCfgDynamicPolicyPfs=ipsecNewCfgDynamicPolicyPfs, hotlinksNewCfgTriggerTableEntry=hotlinksNewCfgTriggerTableEntry, ripCurCfgIntfSplitHorizon=ripCurCfgIntfSplitHorizon, ospf3NewCfgHostIndex=ospf3NewCfgHostIndex, udldInfoNeighborEntry=udldInfoNeighborEntry, routeStatEcmpMaxStaticEntries=routeStatEcmpMaxStaticEntries, failoverNewCfgOnState=failoverNewCfgOnState, cistRootPort=cistRootPort, vrrpNewCfgVirtRtrGrpTable=vrrpNewCfgVirtRtrGrpTable, bootpRelayStatsRepliesReceived=bootpRelayStatsRepliesReceived, ecpChnlStateMachine=ecpChnlStateMachine, vrrpCurCfgVirtRtrState=vrrpCurCfgVirtRtrState, pmCurCfgPortMonitorTable=pmCurCfgPortMonitorTable, stgCurCfgPortPriority=stgCurCfgPortPriority, ospfTotalTransitAreas=ospfTotalTransitAreas, portStatsPhyIfInErrors=portStatsPhyIfInErrors, aclNewCfgFilterAction=aclNewCfgFilterAction, lacpCurPortCfgTableEntry=lacpCurPortCfgTableEntry, sflowNewCfgServerAddress=sflowNewCfgServerAddress, nsnmpOutReadOnlys=nsnmpOutReadOnlys, ipsecCurCfgManualPolicyInAhSpi=ipsecCurCfgManualPolicyInAhSpi, failoverInfoTriggerCtlPortEntry=failoverInfoTriggerCtlPortEntry, trunkLacpGroupCurCfgAdminKey=trunkLacpGroupCurCfgAdminKey, vrrpNewCfgVirtRtrPreDelay=vrrpNewCfgVirtRtrPreDelay, pptNewCfgLabel=pptNewCfgLabel, radNewCfgSecPorttoUse=radNewCfgSecPorttoUse, vmapNewCfgKbitsBurst=vmapNewCfgKbitsBurst, agNewCfgHprompt=agNewCfgHprompt, igmpFltNewCfgPortState=igmpFltNewCfgPortState, ospf3NewCfgVirtIntfTable=ospf3NewCfgVirtIntfTable, nsnmpEnableAuthTraps=nsnmpEnableAuthTraps, fcoeStatsIndex=fcoeStatsIndex, failoverNewCfgTriggerTableEntry=failoverNewCfgTriggerTableEntry, radCurCfgState=radCurCfgState, ospf3RoutesInfoType=ospf3RoutesInfoType, agPortCurCfgTable=agPortCurCfgTable, mcastFdbSrcPorts=mcastFdbSrcPorts, vlagStatsPduSentISLHello=vlagStatsPduSentISLHello, agAccessUserNewCfgUId=agAccessUserNewCfgUId, bgpCurCfgPeerMetric=bgpCurCfgPeerMetric, ipNewCfgStaticRoute6Table=ipNewCfgStaticRoute6Table, ospf3NewCfgRedistPrefixLen=ospf3NewCfgRedistPrefixLen, oamStatsPortLocalCriticalEvents=oamStatsPortLocalCriticalEvents, ospfIntfErrNetmaskMismatch=ospfIntfErrNetmaskMismatch, vrrpNewCfgGenTckVlanPortInc=vrrpNewCfgGenTckVlanPortInc, sflowNewPortCfgTableId=sflowNewPortCfgTableId, ospf3NewCfgIntfPassive=ospf3NewCfgIntfPassive, ospfIntfErrOptionsMismatch=ospfIntfErrOptionsMismatch, tacCurCfgCmdLogging=tacCurCfgCmdLogging, agApplyConfig=agApplyConfig, udpControlBlocksTable=udpControlBlocksTable, ospfAreaErrInvalidSelfOrigLsa=ospfAreaErrInvalidSelfOrigLsa, lldpInfoTxDelayWhile=lldpInfoTxDelayWhile, swLFDPortErrdisabled=swLFDPortErrdisabled, mldInfoMRouterQqic=mldInfoMRouterQqic, agCurCfgNTPResyncInterval=agCurCfgNTPResyncInterval, ipNewCfgIntfAdvMtu=ipNewCfgIntfAdvMtu, fipsInfoFcoeTable=fipsInfoFcoeTable, registration=registration, vmapCurCfgTypeOfService=vmapCurCfgTypeOfService, mldInfoGroupPortNumber=mldInfoGroupPortNumber, ndprefixNewCfgPreferredLifetimeFlag=ndprefixNewCfgPreferredLifetimeFlag, ospfAreaRxDatabase=ospfAreaRxDatabase, tacNewCfgSrcLoopIf=tacNewCfgSrcLoopIf, vlagCurCfgTrunkIndex=vlagCurCfgTrunkIndex, tacCurCfgBackdoor=tacCurCfgBackdoor, ospf3CurCfgRedistMetric=ospf3CurCfgRedistMetric, ipsecSpdInfoTable=ipsecSpdInfoTable, ospf3IfInfoAuthEnable=ospf3IfInfoAuthEnable, stgNewCfgPortTable=stgNewCfgPortTable, arpInfoMacAddr=arpInfoMacAddr, agVMGroupInfo=agVMGroupInfo, lacpInfoPortAdminTableEntry=lacpInfoPortAdminTableEntry, vmapVlanCurCfgNonServerPortsTableEntry=vmapVlanCurCfgNonServerPortsTableEntry, vlagCurCfgLacpKey=vlagCurCfgLacpKey, ndprefixCurCfgPrefixLen=ndprefixCurCfgPrefixLen, bgpCurCfgGroupState=bgpCurCfgGroupState, ipCurCfgAspathEntry=ipCurCfgAspathEntry, ripInfoIntfVersion=ripInfoIntfVersion, swTempExceedThreshold=swTempExceedThreshold, bgpNewCfgPeerRetry=bgpNewCfgPeerRetry, vrrpCurCfgVirtRtrIfIndex=vrrpCurCfgVirtRtrIfIndex, ospf3RoutesInfoNextHop=ospf3RoutesInfoNextHop, bgpCurCfgPeerFixedState=bgpCurCfgPeerFixedState, ospfCfg=ospfCfg, ldapNewCfgDomain=ldapNewCfgDomain, vlanCurCfgVlanName=vlanCurCfgVlanName, dhcpSnoopingCurCfgPortTableEntry=dhcpSnoopingCurCfgPortTableEntry, failoverNewCfgTriggerMconKey=failoverNewCfgTriggerMconKey, ipNwfCfg=ipNwfCfg, ripCurCfgIntfEntry=ripCurCfgIntfEntry, cistRegionalRoot=cistRegionalRoot, ipsecSpdInfoDstAddr=ipsecSpdInfoDstAddr, agTransferPassword=agTransferPassword, pptCurCfgIndx=pptCurCfgIndx, agMgmtNetTableMaxSize=agMgmtNetTableMaxSize, bgpCurCfgPeerRemoteAddr=bgpCurCfgPeerRemoteAddr, nsnmpSilentDrops=nsnmpSilentDrops, ipRoutingInfo=ipRoutingInfo, vmapVlanCurCfgAllPortsVmapBitmap=vmapVlanCurCfgAllPortsVmapBitmap, virtNewCfgVMwareHelloEnable=virtNewCfgVMwareHelloEnable, vrrpNewCfgVirtRtrTckVirtRtr=vrrpNewCfgVirtRtrTckVirtRtr, vmNewCfgProfileShapingBurst=vmNewCfgProfileShapingBurst, lacpInfoPortActAdAggr=lacpInfoPortActAdAggr, fipsInfo=fipsInfo, radCurCfgSrcLoopIf=radCurCfgSrcLoopIf, ospfIfInfoIndex=ospfIfInfoIndex, agNewCfgHttpsServerAccess=agNewCfgHttpsServerAccess, ipNewCfgSecIntfPrefix=ipNewCfgSecIntfPrefix, vmCurCfgGroupIndex=vmCurCfgGroupIndex, ospfLsdbInfoAreaId=ospfLsdbInfoAreaId, ospf3AreaNbrChangeStats=ospf3AreaNbrChangeStats, aclNewCfgDelete=aclNewCfgDelete, portStatsPhyIfInUcastPkts=portStatsPhyIfInUcastPkts, lldpStatsFramesInTotal=lldpStatsFramesInTotal, ipIntfInfo=ipIntfInfo, bgpCurCfgPeerTtlSecHops=bgpCurCfgPeerTtlSecHops, ndprefixTableMaxSize=ndprefixTableMaxSize, mstCistCurCfgPortTable=mstCistCurCfgPortTable, ospf3AreaNbrFull=ospf3AreaNbrFull, hwFan6RPMValue=hwFan6RPMValue, ospfIntfLoop=ospfIntfLoop, lacpInfoPortActOpColl=lacpInfoPortActOpColl, vrrpNewCfgVirtRtrGrpState=vrrpNewCfgVirtRtrGrpState, vrrpCurCfgGenState=vrrpCurCfgGenState, agNewCfgSyslog2Sev=agNewCfgSyslog2Sev, swECMPGatewayUp=swECMPGatewayUp, ospfNewCfgRangeAddr=ospfNewCfgRangeAddr, aclNewCfgPortRemoveAcl=aclNewCfgPortRemoveAcl, vrrpNewCfgVirtRtrIfIndex=vrrpNewCfgVirtRtrIfIndex, fdbEntry=fdbEntry, lacpInfoPortPartOpColl=lacpInfoPortPartOpColl, ipStaticRouteClearAllByGatewayIp=ipStaticRouteClearAllByGatewayIp, portStatsPhyIfInMulticastPkts=portStatsPhyIfInMulticastPkts, virtVMwareHostNameTable=virtVMwareHostNameTable, ipNewCfgIntfEntry=ipNewCfgIntfEntry, pmCurCfgPmirrMirrPortIndex=pmCurCfgPmirrMirrPortIndex, rxIgmpGroupSourceSpecificQueries=rxIgmpGroupSourceSpecificQueries, mldInfoInterfaceQuerierPort=mldInfoInterfaceQuerierPort, bgpInfoDynamicTotalSentPackets=bgpInfoDynamicTotalSentPackets, failoverInfoTriggerCtlPortStatus=failoverInfoTriggerCtlPortStatus, agPortCurCfgFloodBlocking=agPortCurCfgFloodBlocking, ospfCurCfgAreaEntry=ospfCurCfgAreaEntry, dhcpInfoAddr=dhcpInfoAddr, trunkGroupNewCfgTable=trunkGroupNewCfgTable, bgpNewCfgPeerDefaultAction=bgpNewCfgPeerDefaultAction, swVMGroupVMotion=swVMGroupVMotion, ospfCurCfgRipMetricType=ospfCurCfgRipMetricType, ospf3NewCfgNbrIndex=ospf3NewCfgNbrIndex, gatewayIPv6Info=gatewayIPv6Info, ospf3CurCfgHostTable=ospf3CurCfgHostTable, ospfNewCfgFixedRemoveOutRmap=ospfNewCfgFixedRemoveOutRmap, lldpStatsFramesDiscardedTotal=lldpStatsFramesDiscardedTotal, ospf3NewCfgConnectedMetricType=ospf3NewCfgConnectedMetricType, ospf3IfNbrIntfInstanceID=ospf3IfNbrIntfInstanceID, agCurCfgSyslogTrapFailover=agCurCfgSyslogTrapFailover, igmpCurCfgOnOff=igmpCurCfgOnOff, ipNewCfgAlistTable=ipNewCfgAlistTable, nsnmpOutBadValues=nsnmpOutBadValues, lacpInfoAggrPartSysPrio=lacpInfoAggrPartSysPrio, ospfNewCfgAreaAuthType=ospfNewCfgAreaAuthType, ospf3CumDisdPkts=ospf3CumDisdPkts, ipv6OutNsols=ipv6OutNsols, geaportInfoTableEntry=geaportInfoTableEntry, fipsInfoFcfIndex=fipsInfoFcfIndex, vmapNewCfgInprofDscpEnable=vmapNewCfgInprofDscpEnable, ospfCurCfgLoopIfArea=ospfCurCfgLoopIfArea, VlanId=VlanId, ibm_switch_mgmt=ibm_switch_mgmt, ospfCurCfgAreaSpfInterval=ospfCurCfgAreaSpfInterval, layer3Info=layer3Info, vrrpCurCfgVirtRtrGrpIndx=vrrpCurCfgVirtRtrGrpIndx, ipsecCurCfgIfTable=ipsecCurCfgIfTable, vlagStatsPduSentUnknown=vlagStatsPduSentUnknown, vlagNewCfgGlobalEnable=vlagNewCfgGlobalEnable, ospf3AreaIntfDr=ospf3AreaIntfDr, udldInfoPortConfig=udldInfoPortConfig, routeStatEcmpMaxDynamicEntries=routeStatEcmpMaxDynamicEntries, aclCurCfgIndex=aclCurCfgIndex, aclNewCfgTcpudpReset=aclNewCfgTcpudpReset, tacNewCfgEnableAccounting=tacNewCfgEnableAccounting, ipCurCfgIntfAdvIntervalMin=ipCurCfgIntfAdvIntervalMin, ipNewCfgRmapMetric=ipNewCfgRmapMetric, swStgTopologyChanged=swStgTopologyChanged, fcoeStatsFcoeAdded=fcoeStatsFcoeAdded, agTacacsUserMapCurCfgUId=agTacacsUserMapCurCfgUId, ipNewCfgGwArp=ipNewCfgGwArp, ipFwdGeneralCfg=ipFwdGeneralCfg, ipv6InRoutRedirs=ipv6InRoutRedirs, ipsecNewCfgIfAddManualPolicy=ipsecNewCfgIfAddManualPolicy, allportsStatsOutDiscardsRate=allportsStatsOutDiscardsRate, ospf3RedistTableMaxSize=ospf3RedistTableMaxSize, agPortNewCfgPVID=agPortNewCfgPVID, ospfNewCfgVirtIntfStatus=ospfNewCfgVirtIntfStatus, fipsPortNewCfgIndex=fipsPortNewCfgIndex, tcpStatsOutSegs=tcpStatsOutSegs)
mibBuilder.exportSymbols("IBM-GbTOR-10G-L2L3-MIB", ospf3VirtIfInfoAreaId=ospf3VirtIfInfoAreaId, sshCurCfgSSHPort=sshCurCfgSSHPort, portMgmtStatsRxMulticast=portMgmtStatsRxMulticast, ospf3NewCfgExtRangeAddr=ospf3NewCfgExtRangeAddr, ospf3NewCfgIntfStatus=ospf3NewCfgIntfStatus, igmpNewCfgQuerier=igmpNewCfgQuerier, fdbGeneralCfg=fdbGeneralCfg, ospfNewCfgIntfArea=ospfNewCfgIntfArea, ospf3AreaErrBadNeighbour=ospf3AreaErrBadNeighbour, ospf3VirtIfInfoLinkScopeLsaCount=ospf3VirtIfInfoLinkScopeLsaCount, dnsStatOutDnsRequests=dnsStatOutDnsRequests, agNewCfgSyslogTrapCli=agNewCfgSyslogTrapCli, ospf3CumIntfLoop=ospf3CumIntfLoop, sflowCurCfgServerPort=sflowCurCfgServerPort, vrrpNewCfgVirtRtrGrpPriority=vrrpNewCfgVirtRtrGrpPriority, ospfAreaNbrIndex=ospfAreaNbrIndex, ntpStats=ntpStats, agCurCfgSyslogTrapIp=agCurCfgSyslogTrapIp, failoverInfoTriggerControlPorts=failoverInfoTriggerControlPorts, ipsecNewCfgIfDynamicPolicyBmap=ipsecNewCfgIfDynamicPolicyBmap, vlagCurCfgTrunkState=vlagCurCfgTrunkState, ospf3NbrInXchgOrLoadState=ospf3NbrInXchgOrLoadState, sfpInfoTableEntry=sfpInfoTableEntry, hwRevision=hwRevision, ospf3VirtIfInfoEvents=ospf3VirtIfInfoEvents, sflowCurPortCfgTable=sflowCurPortCfgTable, ospfCumRxDatabase=ospfCumRxDatabase, ripStatOutPackets=ripStatOutPackets, hotlinksCurCfgTriggerFdelay=hotlinksCurCfgTriggerFdelay, agNewCfgSyslogTrapIgmpQuerier=agNewCfgSyslogTrapIgmpQuerier, vlagCurCfgTrunkTableEntry=vlagCurCfgTrunkTableEntry, lacpInfoPortMuxState=lacpInfoPortMuxState, agCurCfgSyslogTrapVlan=agCurCfgSyslogTrapVlan, agCurCfgNTPServer=agCurCfgNTPServer, agPortNewCfgType=agPortNewCfgType, ospfIntfErrAuthFailure=ospfIntfErrAuthFailure, igmpStaticMrtrNewCfgTable=igmpStaticMrtrNewCfgTable, ipNewCfgBootpBcastDomainServerEntry=ipNewCfgBootpBcastDomainServerEntry, ospfLsdbInfoIndex=ospfLsdbInfoIndex, ospfNewCfgDefaultRouteMetric=ospfNewCfgDefaultRouteMetric, ospf3ProcessUptime=ospf3ProcessUptime, igmpV3SnoopCurCfgExcludeEnaDis=igmpV3SnoopCurCfgExcludeEnaDis, ipNewCfgGwRetry=ipNewCfgGwRetry, ipNewCfgRmapLp=ipNewCfgRmapLp, hotlinksStatsTriggerFdbUpdate=hotlinksStatsTriggerFdbUpdate, vlagCurCfgTierId=vlagCurCfgTierId, hotlinksInfoTriggerFdelay=hotlinksInfoTriggerFdelay, ospf3NewCfgIntfAuthSpi=ospf3NewCfgIntfAuthSpi, ripStatInResponsePkts=ripStatInResponsePkts, ospfIfNbrIpAddr=ospfIfNbrIpAddr, pktStatsSmalls=pktStatsSmalls, aclNewCfgIndex=aclNewCfgIndex, ibmnosSfpInfoTable=ibmnosSfpInfoTable, portStatsPhyIfInDiscards=portStatsPhyIfInDiscards, hotlinksNewCfgTriggerBackupAdminkey=hotlinksNewCfgTriggerBackupAdminkey, ldapNewCfgBackdoor=ldapNewCfgBackdoor, ospfVirtIntfInfoAuth=ospfVirtIntfInfoAuth, stgCurCfgState=stgCurCfgState, vmapCurCfgDstPortMask=vmapCurCfgDstPortMask, ospfIntfTxDatabase=ospfIntfTxDatabase, vmNewCfgGroupAddPort=vmNewCfgGroupAddPort, ipNewCfgStaticRouteAction=ipNewCfgStaticRouteAction, ipNewCfgBootpBcastDomainVlan=ipNewCfgBootpBcastDomainVlan, routeStatOspfEntries=routeStatOspfEntries, ipsecSpdInfoSaTable=ipsecSpdInfoSaTable, failoverInfoCtlPortStateTable=failoverInfoCtlPortStateTable, swImage1Version=swImage1Version, pmNewCfgPortMirrState=pmNewCfgPortMirrState, ospfCurCfgLoopIfEntry=ospfCurCfgLoopIfEntry, vmapGroupNewCfgServerPortsRemVmap=vmapGroupNewCfgServerPortsRemVmap, lacpNewPortCfgTableId=lacpNewPortCfgTableId, nsnmpInTraps=nsnmpInTraps, vlagCurCfgLacpTableEntry=vlagCurCfgLacpTableEntry, lldpCfg=lldpCfg, vrrpNewCfgVirtRtrID=vrrpNewCfgVirtRtrID, ospf3IntfErrBadAreaID=ospf3IntfErrBadAreaID, fdbNewCfgAddTrunk=fdbNewCfgAddTrunk, ospf3GeneralInfo=ospf3GeneralInfo, vrrpCurCfgVirtRtrTckVlanPort=vrrpCurCfgVirtRtrTckVlanPort, ospf3IntfTxHello=ospf3IntfTxHello, bgpNewCfgEbgpMaxPaths=bgpNewCfgEbgpMaxPaths, ipv6PmtuInfoEntry=ipv6PmtuInfoEntry, lacpInfoPortRxState=lacpInfoPortRxState, ipsecCurCfgManualPolicyOutAhKey=ipsecCurCfgManualPolicyOutAhKey, agCurCfgSyslogHost=agCurCfgSyslogHost, virtVMwareVMInfoVMVCenterName=virtVMwareVMInfoVMVCenterName, ospf3NewCfgLSDB=ospf3NewCfgLSDB, agCurCfgSyslogTrapCfg=agCurCfgSyslogTrapCfg, ipv6udpNumPorts=ipv6udpNumPorts, ibmnosLoggingOption=ibmnosLoggingOption, hotlinksCfg=hotlinksCfg, ospfVirtIntfInfoHello=ospfVirtIntfInfoHello, l2ThashCurCfgSipState=l2ThashCurCfgSipState, hwGlobalHealthStatus=hwGlobalHealthStatus, vmCurCfgProfilesTable=vmCurCfgProfilesTable, intfInfoBcastAddr=intfInfoBcastAddr, ndprefixNewCfgOnlinkFlag=ndprefixNewCfgOnlinkFlag, lldpInfoTxState=lldpInfoTxState, ospf3IntfNbrChangeStatsEntry=ospf3IntfNbrChangeStatsEntry, lldpCurCfgPortAdmStat=lldpCurCfgPortAdmStat, hwMainBoardRevision=hwMainBoardRevision, ospf3IfInfoMetricCost=ospf3IfInfoMetricCost, fipsInfoVlansCreator=fipsInfoVlansCreator, bgpNewCfgGroupInRmapList=bgpNewCfgGroupInRmapList, agNewCfgSyslogTrapVlag=agNewCfgSyslogTrapVlag, ospf3IntfNbrLoading=ospf3IntfNbrLoading, icmpStatsInAddrMasks=icmpStatsInAddrMasks, ospfCurCfgDefaultRouteMetric=ospfCurCfgDefaultRouteMetric, ripInfoIntfEntry=ripInfoIntfEntry, cpuProcessUtil5Sec=cpuProcessUtil5Sec, lldpCurCfgPortTable=lldpCurCfgPortTable, ipCurCfgAlistMetric=ipCurCfgAlistMetric, vmapNewCfgFilterActionSetPrio=vmapNewCfgFilterActionSetPrio, aclLogNewInterval=aclLogNewInterval, ospfAreaChangeStatsEntry=ospfAreaChangeStatsEntry, virtVMwareVMNameVMwareName=virtVMwareVMNameVMwareName, igmpStaticMrtrNewCfgIndx=igmpStaticMrtrNewCfgIndx, mldClearTables=mldClearTables, ospf3NewCfgExtRangeTable=ospf3NewCfgExtRangeTable, ospfLoopIfInfoRetransmit=ospfLoopIfInfoRetransmit, dnsCurCfgSecServerPort=dnsCurCfgSecServerPort, agAccessUserNewCfgState=agAccessUserNewCfgState, agNewCfgSyslogTrapNtp=agNewCfgSyslogTrapNtp, ospfIntfWaitTimer=ospfIntfWaitTimer, txIgmpGrpSpecificQueries=txIgmpGrpSpecificQueries, dhcpSnoopingBindingInfoEntry=dhcpSnoopingBindingInfoEntry, igmpSnoopNewCfgRobustness=igmpSnoopNewCfgRobustness, ospfNewCfgIntfAuthKey=ospfNewCfgIntfAuthKey, lacpInfoAggrIndivState=lacpInfoAggrIndivState, ospf3CurCfgIntfDead=ospf3CurCfgIntfDead, vmNewCfgGroupMacVMIndex=vmNewCfgGroupMacVMIndex, tacCurCfgSecBd=tacCurCfgSecBd, ospf3RoutesInfoPrefixLen=ospf3RoutesInfoPrefixLen, ipCurCfgAspathState=ipCurCfgAspathState, hotlinksCurCfgTriggerMasterTrunk=hotlinksCurCfgTriggerMasterTrunk, agCurCfgSyslogTrapHotlinks=agCurCfgSyslogTrapHotlinks, ospfAreaTxHello=ospfAreaTxHello, lacpInfoAggrActOperKey=lacpInfoAggrActOperKey, lldpNewCfgPortSnmpTrap=lldpNewCfgPortSnmpTrap, agPortNewCfgVlanTag=agPortNewCfgVlanTag, ospfCumNbrN1way=ospfCumNbrN1way, ripNewCfgIbgpOutRmapList=ripNewCfgIbgpOutRmapList, ospf3TotalNssaAreas=ospf3TotalNssaAreas, ipCurCfgBootpBcastDomainServerEntry=ipCurCfgBootpBcastDomainServerEntry, ipCurCfgBootpBcastDomainTable=ipCurCfgBootpBcastDomainTable, ipCurCfgSecIntfAddr=ipCurCfgSecIntfAddr, acl6StatsIndex=acl6StatsIndex, agCurCfgReminders=agCurCfgReminders, hwFan1RPMValue=hwFan1RPMValue, arpInfoVLAN=arpInfoVLAN, swDefGwDown=swDefGwDown, stgCurCfgPortTable=stgCurCfgPortTable, hotlinksCurCfgTriggerTableEntry=hotlinksCurCfgTriggerTableEntry, ndprefixCurCfgOnlinkFlag=ndprefixCurCfgOnlinkFlag, ipv6udpInErrs=ipv6udpInErrs, lldpInfoRemoteDevicesManAddrIfId=lldpInfoRemoteDevicesManAddrIfId, agNewRFC4741NetconfSshAccess=agNewRFC4741NetconfSshAccess, hardwarePCBAPartNumber=hardwarePCBAPartNumber, mldInfoInterfaceTable=mldInfoInterfaceTable, bgpCurCfgGroupOrig=bgpCurCfgGroupOrig, swVrrpAuthFailure=swVrrpAuthFailure, ospfNewCfgEbgpRemoveOutRmap=ospfNewCfgEbgpRemoveOutRmap, lldpInfoPortAlias=lldpInfoPortAlias, ipmcNewCfgStaticRouteAddTrunk=ipmcNewCfgStaticRouteAddTrunk, agNewCfgSyslogTrapFailover=agNewCfgSyslogTrapFailover, swapFreeStats=swapFreeStats, agNewCfgSyslogSrcLoopIf=agNewCfgSyslogSrcLoopIf, ripNewCfgEospfAddOutRmap=ripNewCfgEospfAddOutRmap, ospfCumNbrBadSequence=ospfCumNbrBadSequence, vnicNewCfgGroupFailoverState=vnicNewCfgGroupFailoverState, virtVMwareHostNameIpAddress=virtVMwareHostNameIpAddress, swApplyComplete=swApplyComplete, ospfNewCfgLSDB=ospfNewCfgLSDB, ibmnosConfigSaveFileName=ibmnosConfigSaveFileName, arpInfoFlag=arpInfoFlag, bgpNewCfgGroupName=bgpNewCfgGroupName, bgpNewCfgGroupHold=bgpNewCfgGroupHold, ospfLoopIfInfoState=ospfLoopIfInfoState, igmpMrtrInfoIndex=igmpMrtrInfoIndex, vrrpCurCfgVirtRtrGrpID=vrrpCurCfgVirtRtrGrpID, vnicCurCfgVnicEntry=vnicCurCfgVnicEntry, ipsecNewCfgDynamicPolicyDelete=ipsecNewCfgDynamicPolicyDelete, igmpInfoGroupId=igmpInfoGroupId, ndprefixCurCfgProfileIndex=ndprefixCurCfgProfileIndex, igmpStaticMrtrCurCfgTableEntry=igmpStaticMrtrCurCfgTableEntry, ospfLsdbInfoEntry=ospfLsdbInfoEntry, vmCurCfgGroupMacVMMac=vmCurCfgGroupMacVMMac, swNTPSyncFailed=swNTPSyncFailed, stgCurCfgTableEntry=stgCurCfgTableEntry, agPortTableMaxEnt=agPortTableMaxEnt, ipCurCfgGwIndex=ipCurCfgGwIndex, portInfoPhyIfDescr=portInfoPhyIfDescr, pmNewCfgPmirrDirection=pmNewCfgPmirrDirection, vlagInfoStartupDelayInterval=vlagInfoStartupDelayInterval, vmapNewCfgUserEnable=vmapNewCfgUserEnable, ospf3IntfErrBadDestAddr=ospf3IntfErrBadDestAddr, ipCurCfgRmapAp=ipCurCfgRmapAp, ospfAreaRxHello=ospfAreaRxHello, dnsStatInBadDnsRequests=dnsStatInBadDnsRequests, ipInfoRouterID=ipInfoRouterID, mstCfg=mstCfg, ospf3IfInfoRetransmit=ospf3IfInfoRetransmit, aclCurCfgPortTableEntry=aclCurCfgPortTableEntry, igmpSnoopNewCfgEnaDis=igmpSnoopNewCfgEnaDis, igmpSnoopNewCfgVlanAdd=igmpSnoopNewCfgVlanAdd, ipsecNewCfgManualPolicyInAhKey=ipsecNewCfgManualPolicyInAhKey, ospfCurCfgHostEntry=ospfCurCfgHostEntry, ipsecSaStatsSpi=ipsecSaStatsSpi, vlanInfoName=vlanInfoName, ipStatsInHdrErrors=ipStatsInHdrErrors, lacpInfoPortPartOpPortPrio=lacpInfoPortPartOpPortPrio, ospf3CumTxHello=ospf3CumTxHello, hotlinksNewCfgBpduState=hotlinksNewCfgBpduState, fipsPortCurCfgFcfMode=fipsPortCurCfgFcfMode, portMgmtStatsIndx=portMgmtStatsIndx, vmapNewCfgSrcIPMask=vmapNewCfgSrcIPMask, ecpNewCfgRetrans=ecpNewCfgRetrans, ospf3SpfHoldTime=ospf3SpfHoldTime, ipv6icmpOutRouterSol=ipv6icmpOutRouterSol, ospfNewCfgIbgpMetricType=ospfNewCfgIbgpMetricType, mstNewCfgMaxHopCount=mstNewCfgMaxHopCount, lldpInfoPortlinkaggrtlv=lldpInfoPortlinkaggrtlv, sflowCurPortPolling=sflowCurPortPolling, icmpStatsInAddrMaskReps=icmpStatsInAddrMaskReps, ospfCurCfgIntfDead=ospfCurCfgIntfDead, ospf3CumTxPkts=ospf3CumTxPkts, oamInfoPortRemoteStateValid=oamInfoPortRemoteStateValid, ipCurCfgRmapNexthop=ipCurCfgRmapNexthop, ipCurCfgAlistIndex=ipCurCfgAlistIndex, igmpCurCfgOtherQurPresentInt=igmpCurCfgOtherQurPresentInt, dhcpInfo=dhcpInfo, ospfAreaNbrN2way=ospfAreaNbrN2way, ospfNewCfgIntfDead=ospfNewCfgIntfDead, allportsStatsAdminStatus=allportsStatsAdminStatus, ldapCurCfgDomain=ldapCurCfgDomain, txIgmpLeaves=txIgmpLeaves, vlagInstanceState=vlagInstanceState, ipStaticRouteCurPingRetries=ipStaticRouteCurPingRetries, ipNewCfgBootpBcastDomainBDIndex=ipNewCfgBootpBcastDomainBDIndex, ospfCurCfgLoopIfStatus=ospfCurCfgLoopIfStatus, ripRedistributeOspf=ripRedistributeOspf, ripCurCfgIntfMetric=ripCurCfgIntfMetric, ikeNewCfgIdData=ikeNewCfgIdData, bgpCurCfgIbgpMaxPaths=bgpCurCfgIbgpMaxPaths, failoverInfoTriggerMonitorPorts=failoverInfoTriggerMonitorPorts, ipFwdNewCfgICMP6Redirect=ipFwdNewCfgICMP6Redirect, vrrpNewCfgVirtRtrGrpIndx=vrrpNewCfgVirtRtrGrpIndx, bgpNewCfgPeerOrig=bgpNewCfgPeerOrig, agCurCfgSyslog2Host=agCurCfgSyslog2Host, ipmcNewCfgStaticRouteRemAdminkey=ipmcNewCfgStaticRouteRemAdminkey, mpCpuStatsUtil4Seconds=mpCpuStatsUtil4Seconds, ospfLsdbInfoType=ospfLsdbInfoType, radNewCfgTimeout=radNewCfgTimeout, udpControlBlocksTableEntry=udpControlBlocksTableEntry)
mibBuilder.exportSymbols("IBM-GbTOR-10G-L2L3-MIB", allportsStatsOutMcastRate=allportsStatsOutMcastRate, ripStatInBadZeros=ripStatInBadZeros, ipNewCfgIntfVlan=ipNewCfgIntfVlan, ipCurCfgIntfAdvLifetime=ipCurCfgIntfAdvLifetime, ospf3CumNbrInit=ospf3CumNbrInit, ibmnosPortCtrlMode=ibmnosPortCtrlMode, ospf3Interface=ospf3Interface, agPortCurCfgRmon=agPortCurCfgRmon, radNewCfgAuthenSecondString=radNewCfgAuthenSecondString, ripNewCfgEbgpMetric=ripNewCfgEbgpMetric, lldpInfoRxRxTTL=lldpInfoRxRxTTL, agNewCfgHttpServerPort=agNewCfgHttpServerPort, failoverCurCfgTriggerMconKey=failoverCurCfgTriggerMconKey, vrrpStatBadVrid=vrrpStatBadVrid, vmapCurCfgTCPFlags=vmapCurCfgTCPFlags, ripNewCfgEospfOutRmapList=ripNewCfgEospfOutRmapList, virtVMwareVMNameOsName=virtVMwareVMNameOsName, stgStatsPortTableEntry=stgStatsPortTableEntry, ipmcStaticRouteCfg=ipmcStaticRouteCfg, cistInfoPortHelloTime=cistInfoPortHelloTime, agCurCfgDefipMgta=agCurCfgDefipMgta, ospf3CurCfgNbrIntfIndex=ospf3CurCfgNbrIntfIndex, agPortNewCfgMacAddrNotif=agPortNewCfgMacAddrNotif, qosCurCfgCosWeight=qosCurCfgCosWeight, aclNewCfgRemarkOutProfDscpTable=aclNewCfgRemarkOutProfDscpTable, ospf3IntfInfoEntry=ospf3IntfInfoEntry, ipMgmtRouteInfoTable=ipMgmtRouteInfoTable, agPortCurCfgBpduGuard=agPortCurCfgBpduGuard, tcpStatsInSegs=tcpStatsInSegs, failoverNewCfgTriggerState=failoverNewCfgTriggerState, ospf3IntfErrRxOnNotup=ospf3IntfErrRxOnNotup, ipNewCfgGwIpv6Table=ipNewCfgGwIpv6Table, ospf3CurCfgExtRangeTranslation=ospf3CurCfgExtRangeTranslation, ipStaticArpCfg=ipStaticArpCfg, acl6NewCfgFilterActionChangeVlan=acl6NewCfgFilterActionChangeVlan, ldapCurCfgSecPorttoUse=ldapCurCfgSecPorttoUse, ipCurCfgBootpState=ipCurCfgBootpState, agNewDaylightSavings=agNewDaylightSavings, vnicCurCfgGroupPorts=vnicCurCfgGroupPorts, intfInfoIndex=intfInfoIndex, agNewCfgDhcpMgtb=agNewCfgDhcpMgtb, agNTPOper=agNTPOper, bgpNewCfgGroupRemoteAddr=bgpNewCfgGroupRemoteAddr, ikeCurCfgCookie=ikeCurCfgCookie, lldpInfoTxShutdownWhile=lldpInfoTxShutdownWhile, ospf3CumRxlsReqs=ospf3CumRxlsReqs, ospfNewCfgIntfStatus=ospfNewCfgIntfStatus, bgpInfoDynamicSentUpdates=bgpInfoDynamicSentUpdates, vmapGroupCurCfgAllPortsVmapBitmap=vmapGroupCurCfgAllPortsVmapBitmap, virtVMwareHostVswitchIndex=virtVMwareHostVswitchIndex, ospfCumIntfChangeStats=ospfCumIntfChangeStats, ipCurCfgRmapMetric=ipCurCfgRmapMetric, ospf3CurCfgNbrPriority=ospf3CurCfgNbrPriority, ipv6OutRoutSols=ipv6OutRoutSols, qosNewCfgDscpEntry=qosNewCfgDscpEntry, ospf3NewCfgAreaStbInterval=ospf3NewCfgAreaStbInterval, agPortNewCfgIndx=agPortNewCfgIndx, vmCurCfgGroupPorts=vmCurCfgGroupPorts, vrrpStatOutAdvers=vrrpStatOutAdvers, ipsecSaStatsUsageTime=ipsecSaStatsUsageTime, agPortCurCfgOamMode=agPortCurCfgOamMode, igmpMrtrInfoQqic=igmpMrtrInfoQqic, ipNewCfgStaticArpEntry=ipNewCfgStaticArpEntry, vmbwCurCfgEntry=vmbwCurCfgEntry, ipInterfaceTableMax=ipInterfaceTableMax, vrrpNewCfgVirtRtrTckVlanPort=vrrpNewCfgVirtRtrTckVlanPort, mstCistCurCfgBridgeForwardDelay=mstCistCurCfgBridgeForwardDelay, hwFanSpeed=hwFanSpeed, mldInfoInterfaceQuerierStatus=mldInfoInterfaceQuerierStatus, ipmcCurCfgStaticRouteTrunks=ipmcCurCfgStaticRouteTrunks, ipsecCurCfgManualPolicyInAhKey=ipsecCurCfgManualPolicyInAhKey, ipMgmtRouteInfoGateway=ipMgmtRouteInfoGateway, failoverNewCfgTriggerMconKeyAdd=failoverNewCfgTriggerMconKeyAdd, mcastFdbCurCfgPorts=mcastFdbCurCfgPorts, ipCurCfgRmapTable=ipCurCfgRmapTable, pktStatsSmallsHiWatermark=pktStatsSmallsHiWatermark, vmNewCfgCheckActionAdvanced=vmNewCfgCheckActionAdvanced, trunkGroupInfoPorts=trunkGroupInfoPorts, bgpNewCfgPeerEntry=bgpNewCfgPeerEntry, ospfNewCfgVirtIntfIndex=ospfNewCfgVirtIntfIndex, vlagStatsPduRcvUnknown=vlagStatsPduRcvUnknown, cistInfoPortIndex=cistInfoPortIndex, lacpInfoPortCurWhileTimer=lacpInfoPortCurWhileTimer, mstCistNewCfgPortHelloTime=mstCistNewCfgPortHelloTime, lldpInfoRxRemoteChanged=lldpInfoRxRemoteChanged, ospfNewCfgIntfTrans=ospfNewCfgIntfTrans, agNewCfgNTPServerPort=agNewCfgNTPServerPort, vmbwNewCfgTxBurst=vmbwNewCfgTxBurst, ospf3CurCfgExtRangeIndex=ospf3CurCfgExtRangeIndex, pptNewCfgPrefixLen=pptNewCfgPrefixLen, ipNewCfgAlistAction=ipNewCfgAlistAction, ospfAreaInfoEntry=ospfAreaInfoEntry, aclNewCfgSrcPortMask=aclNewCfgSrcPortMask, vmNewCfgProfileName=vmNewCfgProfileName, bgpInfoDynamicKeepalive=bgpInfoDynamicKeepalive, bgpCurCfgPeerIndex=bgpCurCfgPeerIndex, fipsPortCurCfgEntry=fipsPortCurCfgEntry, rip2GeneralInfo=rip2GeneralInfo, ipNewCfgAlistMetric=ipNewCfgAlistMetric, bgpInfoGroupRASTable=bgpInfoGroupRASTable, lacpNewSystemTimeoutTime=lacpNewSystemTimeoutTime, stpInfoPortTable=stpInfoPortTable, vrrpCurCfgGenHoldoff=vrrpCurCfgGenHoldoff, igmpSnoopNewCfgMrto=igmpSnoopNewCfgMrto, failoverNewCfgTriggerMconTrunk=failoverNewCfgTriggerMconTrunk, portOperIdx=portOperIdx, bgpNewCfgPeerRemoveOutRmap=bgpNewCfgPeerRemoveOutRmap, fcoeStatsEntry=fcoeStatsEntry, txMldIfStatsExcCrsv2=txMldIfStatsExcCrsv2, agPortCurCfgIndx=agPortCurCfgIndx, vmapCurCfgSrcIPMask=vmapCurCfgSrcIPMask, fcoeStats=fcoeStats, vmapNewCfgDstMACAddress=vmapNewCfgDstMACAddress, ospf3CumNbrAllEvents=ospf3CumNbrAllEvents, ospfVirtIntfTableMaxSize=ospfVirtIntfTableMaxSize, lldpNewCfgPortdcbxtlv=lldpNewCfgPortdcbxtlv, ripNewCfgIntfKey=ripNewCfgIntfKey, ospfLsdbInfoAdvertisement=ospfLsdbInfoAdvertisement, ospfCurCfgIntfAuthKey=ospfCurCfgIntfAuthKey, portMgmtStatsTxpackets=portMgmtStatsTxpackets, hotlinksCurCfgTriggerMasterPort=hotlinksCurCfgTriggerMasterPort, ipCurCfgStaticRouteIndx=ipCurCfgStaticRouteIndx, agCurCfgHttpsServerAccess=agCurCfgHttpsServerAccess, bgpGeneral=bgpGeneral, ospfRoutesInfoEntry=ospfRoutesInfoEntry, ospf3IntfCountForRouter=ospf3IntfCountForRouter, virtVMwareHostDetailInfoVMCurrentHost=virtVMwareHostDetailInfoVMCurrentHost, ospfNewCfgIntfIndex=ospfNewCfgIntfIndex, ospfLsdbInfoTable=ospfLsdbInfoTable, ipCurCfgStaticRoute6Table=ipCurCfgStaticRoute6Table, agCurBootProfile=agCurBootProfile, ripNewCfgStaticMetric=ripNewCfgStaticMetric, vnicNewCfgGroupPorts=vnicNewCfgGroupPorts, ipRoute6InfoNextHop=ipRoute6InfoNextHop, ipNewCfgAlistState=ipNewCfgAlistState, ospfAreaIntfUnloop=ospfAreaIntfUnloop, acl6NewCfgDstIPv6PrefixLen=acl6NewCfgDstIPv6PrefixLen, vmGroupInfoIsESXSvcCon=vmGroupInfoIsESXSvcCon, vmapNewCfgReset=vmapNewCfgReset, bgpNewCfgGroupRemoteMask=bgpNewCfgGroupRemoteMask, vmapNewCfgIPFmt=vmapNewCfgIPFmt, vmNewCfgGroupRemProfile=vmNewCfgGroupRemProfile, g8124=g8124, igmpSnoopNewCfgAggrEnaDis=igmpSnoopNewCfgAggrEnaDis, lacpInfoAggrActSysPrio=lacpInfoAggrActSysPrio, ospf3NewCfgIntfIndex=ospf3NewCfgIntfIndex, ntpSecondaryServerReqSent=ntpSecondaryServerReqSent, agSyslogMessage=agSyslogMessage, aclNewCfgPortAclBmap=aclNewCfgPortAclBmap, vmapGroupCurCfgServerPortsVmapBitmap=vmapGroupCurCfgServerPortsVmapBitmap, agSyslogMsgTableEntry=agSyslogMsgTableEntry, sflowCurCfgState=sflowCurCfgState, ipCurCfgIntfAnycast=ipCurCfgIntfAnycast, ospf3CumDisdlsReqs=ospf3CumDisdlsReqs, allportsStatsInOctetsRate=allportsStatsInOctetsRate, vlanCurCfgStg=vlanCurCfgStg, ipStatsInDiscards=ipStatsInDiscards, lldpInfoPortMtu=lldpInfoPortMtu, ospf3CurCfgRedistMetricType=ospf3CurCfgRedistMetricType, txMldIfStatsToIncFmcrsv2=txMldIfStatsToIncFmcrsv2, swHotlinksBackupUp=swHotlinksBackupUp, pmCurCfgPortMonitorEntry=pmCurCfgPortMonitorEntry, acl6CurCfgTCPFlagsMask=acl6CurCfgTCPFlagsMask, failoverNewCfgTriggerMconPort=failoverNewCfgTriggerMconPort, ripNewCfgStaticAddOutRmap=ripNewCfgStaticAddOutRmap, ripInfoIntfListen=ripInfoIntfListen, swPrimaryPowerSupplyFailureNotify=swPrimaryPowerSupplyFailureNotify, lacpInfoPortActPortPrio=lacpInfoPortActPortPrio, ospf3CurCfgHostCost=ospf3CurCfgHostCost, icmpStatsInParmProbs=icmpStatsInParmProbs, mstCistCurCfgPortPathCost=mstCistCurCfgPortPathCost, vmapVlanNewCfgNonServerPortsTableEntry=vmapVlanNewCfgNonServerPortsTableEntry, aclStats=aclStats, igmpNewCfgQurStartupCnt=igmpNewCfgQurStartupCnt, dnsCurCfgSecondaryIpAddr=dnsCurCfgSecondaryIpAddr, igmpFltCurCfgPortTable=igmpFltCurCfgPortTable, vmapNewCfgOutprofDscp=vmapNewCfgOutprofDscp, ospf3AreaInfoAreaBorderRouter=ospf3AreaInfoAreaBorderRouter, ospf3VirtIntfTableMaxSize=ospf3VirtIntfTableMaxSize, lldpInfoPortmgmtaddrtlv=lldpInfoPortmgmtaddrtlv, ospf3NewCfgRangeAreaIndex=ospf3NewCfgRangeAreaIndex, virtCurCfgVirtCenterIp=virtCurCfgVirtCenterIp, allportsStatsInDiscards=allportsStatsInDiscards, ipNewCfgGwIpv6Index=ipNewCfgGwIpv6Index, bgpNewCfgASNumber=bgpNewCfgASNumber, ospf3CurCfgHostEntry=ospf3CurCfgHostEntry, vmbwNewCfgTable=vmbwNewCfgTable, gatewayInfoEntry=gatewayInfoEntry, swVrrpNewBackup=swVrrpNewBackup, tcpStatsRtoMax=tcpStatsRtoMax, vmNewCfgGroupRemVm=vmNewCfgGroupRemVm, ospf3AreaIntfDown=ospf3AreaIntfDown, portStatsPhyIfInFctlPkts=portStatsPhyIfInFctlPkts, vrrpNewCfgVirtRtrGrpIfIndex=vrrpNewCfgVirtRtrGrpIfIndex, vmapVlanCurCfgNonServerPortsVlanIdx=vmapVlanCurCfgNonServerPortsVlanIdx, allportsStatsOutMcast=allportsStatsOutMcast, ikeNewCfgPskRemoteKey=ikeNewCfgPskRemoteKey, ospfCumIntfUnloop=ospfCumIntfUnloop, agCurCfgDefipData=agCurCfgDefipData, errMldIfStatsMASSQQuery=errMldIfStatsMASSQQuery, ifMainIndex=ifMainIndex, swPrimaryPowerSupplyFailure=swPrimaryPowerSupplyFailure, agTacacsUserMapCurCfgTable=agTacacsUserMapCurCfgTable, pmCurCfgPortMirrState=pmCurCfgPortMirrState, arpInfo=arpInfo, accessUserInfoLockState=accessUserInfoLockState, ikeNewCfgPskRemoteIndex=ikeNewCfgPskRemoteIndex, aclClearStats=aclClearStats, igmpFltNewCfgPortAddFiltRule=igmpFltNewCfgPortAddFiltRule, ospfNewCfgAreaMetric=ospfNewCfgAreaMetric, ecpChnlTxDrop=ecpChnlTxDrop, foreignAddress=foreignAddress, ospfNewCfgHostIndex=ospfNewCfgHostIndex, lacpInfoPort=lacpInfoPort, agNewCfgSyslogTrapFcoe=agNewCfgSyslogTrapFcoe, agPortCurCfgEdge=agPortCurCfgEdge, vlagNewCfgLacpTableEntry=vlagNewCfgLacpTableEntry, fipsOper=fipsOper, ipInterfaceLoopbackCfg=ipInterfaceLoopbackCfg, vmCurCfgCheckActionAdvanced=vmCurCfgCheckActionAdvanced, virtVMwareHostPGTable=virtVMwareHostPGTable, lldpCurCfgPortdcbxtlv=lldpCurCfgPortdcbxtlv, tacChangePassNewPass=tacChangePassNewPass, lacpInfoPortActAdColl=lacpInfoPortActAdColl, failoverInfoTriggerState=failoverInfoTriggerState, igmpFltNewCfgPortIndx=igmpFltNewCfgPortIndx, vmapNewCfgInprofDscp=vmapNewCfgInprofDscp, ipsecNewCfgSelectorIndex=ipsecNewCfgSelectorIndex, trunkGroupInfoState=trunkGroupInfoState, ospfCurCfgIntfPtop=ospfCurCfgIntfPtop, vlanInfoStatus=vlanInfoStatus, virtCurCfgVirtCenterSSLAuth=virtCurCfgVirtCenterSSLAuth, igmpCurCfgQuerierOnOff=igmpCurCfgQuerierOnOff, bgpCurCfgPeerAdvert=bgpCurCfgPeerAdvert, ospf3IfNbrEvents=ospf3IfNbrEvents, ospf3CurCfgAreaStatus=ospf3CurCfgAreaStatus, ospf3NewCfgRedistEntry=ospf3NewCfgRedistEntry, acl6NewCfgDstPort=acl6NewCfgDstPort, ospfTotalStubAreas=ospfTotalStubAreas, ipsecNewCfgSelectorProto=ipsecNewCfgSelectorProto, bgpCurCfgPeerOutRmapList=bgpCurCfgPeerOutRmapList, ripStatOutRequestPkts=ripStatOutRequestPkts, dhcpSnoopingNewCfgportTrusted=dhcpSnoopingNewCfgportTrusted, ipNewCfgStaticRouteTable=ipNewCfgStaticRouteTable, vmapCurCfgTos=vmapCurCfgTos, bgpNewCfgGroupMetric=bgpNewCfgGroupMetric, acl6CurCfgDstPortMask=acl6CurCfgDstPortMask, pptNewCfgTable=pptNewCfgTable, vmapGroupNewCfgAllPortsAddVmap=vmapGroupNewCfgAllPortsAddVmap, ospfAreaChangeStats=ospfAreaChangeStats, dhcpSnoopingNewCfgVlanTable=dhcpSnoopingNewCfgVlanTable, agTacacsUserMapNewCfgTableEntry=agTacacsUserMapNewCfgTableEntry, l2GeneralCfg=l2GeneralCfg, ipGeneralCfg=ipGeneralCfg)
mibBuilder.exportSymbols("IBM-GbTOR-10G-L2L3-MIB", mldNewInterfaceDMrtrEna=mldNewInterfaceDMrtrEna, aclNewCfgSrcIPMask=aclNewCfgSrcIPMask, stgCurCfgVlanBmap=stgCurCfgVlanBmap, portInfoLFDState=portInfoLFDState, ospfCurCfgMdkeyTable=ospfCurCfgMdkeyTable, gatewayInfoTable=gatewayInfoTable, virtVMwareVMInfoPort=virtVMwareVMInfoPort, ospfCumRxlsAcks=ospfCumRxlsAcks, bgpCurCfgPeerAlive=bgpCurCfgPeerAlive, agCurCfgDhcpMgta=agCurCfgDhcpMgta, ipCurCfgStaticArpIp=ipCurCfgStaticArpIp, ospf3CurCfgExtRangeTable=ospf3CurCfgExtRangeTable, ipsecCurCfgManualPolicyInEspSpi=ipsecCurCfgManualPolicyInEspSpi, ipCurCfgBootpAddr=ipCurCfgBootpAddr, oamInfoPortLocalEvaluating=oamInfoPortLocalEvaluating, vmapVlanCurCfgNonServerPortsTable=vmapVlanCurCfgNonServerPortsTable, bgpInfoGroupRemoteMask=bgpInfoGroupRemoteMask, ospf3NewCfgStaticRouteTagTypeManual=ospf3NewCfgStaticRouteTagTypeManual, bgpCurCfgGroupUpdateSrcIf=bgpCurCfgGroupUpdateSrcIf, ipNewCfgStaticNbrEntry=ipNewCfgStaticNbrEntry, ospfNewCfgRangeTable=ospfNewCfgRangeTable, ospf3IfInfoEncryAuthKey=ospf3IfInfoEncryAuthKey, tacNewCfgDirectedRequest=tacNewCfgDirectedRequest, ospf3CumTxlsReqs=ospf3CumTxlsReqs, PortNumber=PortNumber, agCurCfgNTPSecServerPort=agCurCfgNTPSecServerPort, portStatsPhyIfInNUcastPkts=portStatsPhyIfInNUcastPkts, agAccessUserNewCfgName=agAccessUserNewCfgName, agPortNewCfgOam=agPortNewCfgOam, failoverCurCfgTriggerMconPort=failoverCurCfgTriggerMconPort, ibmnosPortCtrlIndex=ibmnosPortCtrlIndex, agNewCfgSyslogTrapDcbx=agNewCfgSyslogTrapDcbx, nbrInfoAge=nbrInfoAge, rxIgmpReports=rxIgmpReports, agNewCfgLoginBanner=agNewCfgLoginBanner, ikeCurCfgTxTimeout=ikeCurCfgTxTimeout, qosCurCfgPortIndex=qosCurCfgPortIndex, bgpCurCfgGroupLimit=bgpCurCfgGroupLimit, highTotalStats=highTotalStats, agCurCfgSyslogTrapVm=agCurCfgSyslogTrapVm, swVlagInstanceLocalUp=swVlagInstanceLocalUp, vmapCurCfgInprofDscpEnable=vmapCurCfgInprofDscpEnable, ospf3CurCfgIntfPrio=ospf3CurCfgIntfPrio, portStatsClear=portStatsClear, tacNewCfgPort=tacNewCfgPort, vnicNewCfgVnicState=vnicNewCfgVnicState, bgpNewCfgPeerAddInRmap=bgpNewCfgPeerAddInRmap, bgpCurCfgLocalPref=bgpCurCfgLocalPref, vrrpCurCfgVirtRtrTable=vrrpCurCfgVirtRtrTable, lldpInfoRemoteDevicesManAddrSubtype=lldpInfoRemoteDevicesManAddrSubtype, ipCurCfgStaticRoute6DestIp=ipCurCfgStaticRoute6DestIp, ospf3CumDisdlsAcks=ospf3CumDisdlsAcks, ospf3CurCfgExtRangeState=ospf3CurCfgExtRangeState, ospfHostTableMaxSize=ospfHostTableMaxSize, ospfIfInfoEvents=ospfIfInfoEvents, ospf3NewCfgIntfEncryType=ospf3NewCfgIntfEncryType, dhcpsnpInfo=dhcpsnpInfo, agRtcTime=agRtcTime, pvstCompatibilityCurCfgState=pvstCompatibilityCurCfgState, ipv6InMcasts=ipv6InMcasts, lacpInfoPortActOpDef=lacpInfoPortActOpDef, bgpInfoSummaryEntry=bgpInfoSummaryEntry, vmCurCfgProfileName=vmCurCfgProfileName, ospfIfInfoDesignatedRouterIP=ospfIfInfoDesignatedRouterIP, agCurCfgLoginNotice=agCurCfgLoginNotice, dnsCurCfgDomainName=dnsCurCfgDomainName, vmCurCfgProfileEgressShapingPeak=vmCurCfgProfileEgressShapingPeak, ipsecSaInfoEncrKey=ipsecSaInfoEncrKey, hotlinksInfoTriggerState=hotlinksInfoTriggerState, ripNewCfgFixedAddOutRmap=ripNewCfgFixedAddOutRmap, vmapCurCfgProtocol=vmapCurCfgProtocol, ospf3AreaErrRxSameRTRID=ospf3AreaErrRxSameRTRID, portOperRmon=portOperRmon, mstCistBridgeCfg=mstCistBridgeCfg, vmCheck=vmCheck, ipCurCfgBootpBcastDomainEntry=ipCurCfgBootpBcastDomainEntry, lldpInfoRxState=lldpInfoRxState, trunkGroupInfoTable=trunkGroupInfoTable, ospf3NewCfgIntfEncryKey=ospf3NewCfgIntfEncryKey, bgpCurCfgGroupRASEntry=bgpCurCfgGroupRASEntry, vmbwNewCfgCtrl=vmbwNewCfgCtrl, radCurCfgPrimaryServer=radCurCfgPrimaryServer, mpCpuStatsUtil64Seconds=mpCpuStatsUtil64Seconds, pptCurCfgTable=pptCurCfgTable, hardwareFABNumber=hardwareFABNumber, sfpInfoIndx=sfpInfoIndx, rxMldIfStatsMASSQQuery=rxMldIfStatsMASSQQuery, bgpNewCfgGroupIndex=bgpNewCfgGroupIndex, sflowNewCfgState=sflowNewCfgState, ospf3VirtIntfInfoTable=ospf3VirtIntfInfoTable, bgpInfoGroupLimit=bgpInfoGroupLimit, pmNewCfgPortMonitorEntry=pmNewCfgPortMonitorEntry, ripNewCfgFixedRemoveOutRmap=ripNewCfgFixedRemoveOutRmap, ospf3CumDisdHello=ospf3CumDisdHello, portMgmtStatsRxBytes=portMgmtStatsRxBytes, bgpNewCfgClientToClientReflection=bgpNewCfgClientToClientReflection, fdbMacAddr=fdbMacAddr, ripCurCfgIntfTable=ripCurCfgIntfTable, dhcpSnoopingCurCfgVlanId=dhcpSnoopingCurCfgVlanId, failoverCurCfgTriggerMmonKey=failoverCurCfgTriggerMmonKey, bootpRelayStatsRequestsDroppedNoRelay=bootpRelayStatsRequestsDroppedNoRelay, ospfRoutesInfoVia=ospfRoutesInfoVia, ipStaticRouteCfg=ipStaticRouteCfg, trunkGroupInfoPortPortId=trunkGroupInfoPortPortId, ospfNewCfgRipMetricType=ospfNewCfgRipMetricType, ospf3TimersKickOffStats=ospf3TimersKickOffStats, ospf3NewCfgExtRangeEntry=ospf3NewCfgExtRangeEntry, trunkGroupTableMaxSize=trunkGroupTableMaxSize, acl6NewCfgIPv6FlowLabel=acl6NewCfgIPv6FlowLabel, ospf3CurCfgExtRangeAddr=ospf3CurCfgExtRangeAddr, lldpNewCfgPortEntry=lldpNewCfgPortEntry, ospf3AreaNbrIndex=ospf3AreaNbrIndex, virtVMwareVMInfoEntry=virtVMwareVMInfoEntry, dot1RatePortInDiscards=dot1RatePortInDiscards, l2ThashNewCfgDmacState=l2ThashNewCfgDmacState, igmpSnoopCurCfgSrcIp=igmpSnoopCurCfgSrcIp, serverPortsNewCfgRemovePort=serverPortsNewCfgRemovePort, vmapCurCfgSrcMACMask=vmapCurCfgSrcMACMask, portInfoPhyIfOperStatus=portInfoPhyIfOperStatus, ospfAreaInfoId=ospfAreaInfoId, hotlinksCurCfgTriggerTable=hotlinksCurCfgTriggerTable, vmCurCfgProfileShapingBurst=vmCurCfgProfileShapingBurst, gatewayInfo=gatewayInfo, ospf3CurCfgHostState=ospf3CurCfgHostState, ospf3IfInfoBackupDesignatedRouterID=ospf3IfInfoBackupDesignatedRouterID, agPortNewCfgDLFThreshold=agPortNewCfgDLFThreshold, agPortCurCfgBroadcastThresholdRate=agPortCurCfgBroadcastThresholdRate, ipCurCfgAspathAS=ipCurCfgAspathAS, ospfIfInfoHello=ospfIfInfoHello, lldpNewCfgPortportprottlv=lldpNewCfgPortportprottlv, tacCurCfgAuthenString=tacCurCfgAuthenString, ospfCurCfgIntfIndex=ospfCurCfgIntfIndex, agConfigForNxtReset=agConfigForNxtReset, ipCurCfgGwIpv6Addr=ipCurCfgGwIpv6Addr, agCurCfgSyslogTrapDcbx=agCurCfgSyslogTrapDcbx, ldapCurCfgPorttoUse=ldapCurCfgPorttoUse, vrrpNewCfgGenTckIpIntfInc=vrrpNewCfgGenTckIpIntfInc, fipsInfoVlansPorts=fipsInfoVlansPorts, lacpInfoPortAdminEna=lacpInfoPortAdminEna, ospf3CurCfgIntfAuthEnable=ospf3CurCfgIntfAuthEnable, ospfNewCfgVirtIntfTable=ospfNewCfgVirtIntfTable, bgpCurCfgAggrMask=bgpCurCfgAggrMask, vmapCurCfgInprofDscp=vmapCurCfgInprofDscp, tacCurCfgSecondaryServer=tacCurCfgSecondaryServer, ibmnosSfpInfoIndx=ibmnosSfpInfoIndx, stgNewCfgTable=stgNewCfgTable, vmNewCfgGroupAddVmIdx=vmNewCfgGroupAddVmIdx, arpInfoSrcPort=arpInfoSrcPort, ntpSecondaryServerUpdates=ntpSecondaryServerUpdates, stpInfoPortForwardTransitions=stpInfoPortForwardTransitions, vmCurCfgProfileIndex=vmCurCfgProfileIndex, ospfAreaNbrStart=ospfAreaNbrStart, ipNewCfgIntfDadAttempts=ipNewCfgIntfDadAttempts, ntpLastUpdateTime=ntpLastUpdateTime, ipDataRouteInfoType=ipDataRouteInfoType, vlagStatsIgmp=vlagStatsIgmp, bgpCurCfgPeerUpdateSrcIf=bgpCurCfgPeerUpdateSrcIf, agNewCfgSyslog2Fac=agNewCfgSyslog2Fac, vlanMaxVlanID=vlanMaxVlanID, trunkGroupNewCfgState=trunkGroupNewCfgState, ospfCurCfgHostIpAddr=ospfCurCfgHostIpAddr, intfInfoEntry=intfInfoEntry, l2ThashNewCfgDipState=l2ThashNewCfgDipState, ipEcmpHashRouteNumber=ipEcmpHashRouteNumber, ospf3CurCfgRedistRouteTagTypeManual=ospf3CurCfgRedistRouteTagTypeManual, vmNewCfgProfileShapingAverage=vmNewCfgProfileShapingAverage, vlagIslCfg=vlagIslCfg, virtVMwareVMNameIndex=virtVMwareVMNameIndex, ospf3NewCfgVirtIntfNbr=ospf3NewCfgVirtIntfNbr, ipNewCfgStaticNbrMAC=ipNewCfgStaticNbrMAC, ospf3AreaRxlsReqs=ospf3AreaRxlsReqs, rip2NewCfgState=rip2NewCfgState, vmapCurCfgSrcPort=vmapCurCfgSrcPort, nsnmpOutTooBigs=nsnmpOutTooBigs, mstCurCfgRegionRevision=mstCurCfgRegionRevision, ipv6PmtuInfoDestIp=ipv6PmtuInfoDestIp, ospfCurCfgStaticMetricType=ospfCurCfgStaticMetricType, ipNewCfgBootpOpt82Policy=ipNewCfgBootpOpt82Policy, hotlinksMaxTriggerEntries=hotlinksMaxTriggerEntries, fipsInfoFcoePort=fipsInfoFcoePort, vmapVlanNewCfgServerPortsAddVmap=vmapVlanNewCfgServerPortsAddVmap, qosNewCfgMap8021p=qosNewCfgMap8021p, hotlinksNewCfgTriggerDelete=hotlinksNewCfgTriggerDelete, vlagCurCfgHlthchkKeepaliveAttempts=vlagCurCfgHlthchkKeepaliveAttempts, ospfVirtIntfInfoHelloMS=ospfVirtIntfInfoHelloMS, ospf3NewCfgIntfAuthEnable=ospf3NewCfgIntfAuthEnable, fdbClear=fdbClear, icmpStatsInSrcQuenchs=icmpStatsInSrcQuenchs, ospf3IntfChangeStatsEntry=ospf3IntfChangeStatsEntry, errMldIfStatsMLDv1Done=errMldIfStatsMLDv1Done, ipsecCurCfgDynamicPolicyTable=ipsecCurCfgDynamicPolicyTable, trunkGroupNewCfgTableEntry=trunkGroupNewCfgTableEntry, ecpChnlTxCnt=ecpChnlTxCnt, agCurCfgSyslogTrapIgmpMrouter=agCurCfgSyslogTrapIgmpMrouter, ipCurCfgGwAddr=ipCurCfgGwAddr, acl6CurCfgTable=acl6CurCfgTable, agPortNewCfgErrDisableRecovery=agPortNewCfgErrDisableRecovery, ipsecCurCfgSelectorDelete=ipsecCurCfgSelectorDelete, vmapCurCfgUserEnable=vmapCurCfgUserEnable, vmNewCfgGroupTagState=vmNewCfgGroupTagState, agPortCurCfgPortAlias=agPortCurCfgPortAlias, bgpNewCfgPeerOutRmapList=bgpNewCfgPeerOutRmapList, ospf3NewCfgAreaEntry=ospf3NewCfgAreaEntry, rxIgmpValidPkts=rxIgmpValidPkts, ipNewCfgGwTable=ipNewCfgGwTable, ospf3IntfErrBadNeighbour=ospf3IntfErrBadNeighbour, ospfAreaInfoASBoundaryRouter=ospfAreaInfoASBoundaryRouter, ospf3NewLsaReceived=ospf3NewLsaReceived, bgpInfoPeerRouterId=bgpInfoPeerRouterId, virtVMwareVMNameUUID=virtVMwareVMNameUUID, vlagNewCfgAutoRecoveryInterval=vlagNewCfgAutoRecoveryInterval, ospfCurCfgVirtIntfTrans=ospfCurCfgVirtIntfTrans, ipGatewayTableMax=ipGatewayTableMax, vmCurCfgProfileEntry=vmCurCfgProfileEntry, rxIgmpV3FilterChangeRecords=rxIgmpV3FilterChangeRecords, ospfIntfRxHello=ospfIntfRxHello, agPortConfig=agPortConfig, icmpStatsOutParmProbs=icmpStatsOutParmProbs, agCurCfgSyslogTrapLldp=agCurCfgSyslogTrapLldp, lacpNewPortCfgTableEntry=lacpNewPortCfgTableEntry, vrrpOper=vrrpOper, ospfIfNbrDesignatedRtr=ospfIfNbrDesignatedRtr, icmpStats=icmpStats, oamInfoPortLocalLinkStatus=oamInfoPortLocalLinkStatus, nsnmpInBadVersions=nsnmpInBadVersions, ospfNewCfgIntfDelete=ospfNewCfgIntfDelete, qosNewCfgPortPriority=qosNewCfgPortPriority, ripInfoIntfMetric=ripInfoIntfMetric, aclCurCfgMirrorPort=aclCurCfgMirrorPort, failoverInfoTriggerMonPortId=failoverInfoTriggerMonPortId, vmapNewCfgProtocol=vmapNewCfgProtocol, ikeCurCfgPskRemoteKey=ikeCurCfgPskRemoteKey, ospfIntfErrInvalidSelfOrigLSA=ospfIntfErrInvalidSelfOrigLSA, ospf3RoutesInfoCost=ospf3RoutesInfoCost, ospf3NewCfgRangeEntry=ospf3NewCfgRangeEntry, vlagNewCfgHlthchkPeerIp=vlagNewCfgHlthchkPeerIp, mldInfoMRouterExpiryTime=mldInfoMRouterExpiryTime, ibmnosBladeHarmony=ibmnosBladeHarmony, ospf3CurCfgRangeAreaIndex=ospf3CurCfgRangeAreaIndex, fipsInfoAcl=fipsInfoAcl, vmapCurCfgMirrorPort=vmapCurCfgMirrorPort, rxMldIfStatsGeneralQuery=rxMldIfStatsGeneralQuery, vrrpStatBadInterval=vrrpStatBadInterval, trunkLacpGroupCurCfgIndex=trunkLacpGroupCurCfgIndex, igmpInfoVlanId=igmpInfoVlanId, lldpInfoPortsyscaptlv=lldpInfoPortsyscaptlv, ecpCfg=ecpCfg, lacpInfoAggrTableEntry=lacpInfoAggrTableEntry, igmpMrtrInfoExpires=igmpMrtrInfoExpires, ipStatsOutDiscards=ipStatsOutDiscards, vlagInfoAutoRecoveryInterval=vlagInfoAutoRecoveryInterval, gatewayInfoIndex=gatewayInfoIndex, vmapVlanNewCfgNonServerPortsVmapBitmap=vmapVlanNewCfgNonServerPortsVmapBitmap, lldpInfoRxTooManyNeighbors=lldpInfoRxTooManyNeighbors)
mibBuilder.exportSymbols("IBM-GbTOR-10G-L2L3-MIB", lldpInfoTxReinitDelay=lldpInfoTxReinitDelay, agImage2Ver=agImage2Ver, vrrpInfoVirtRtrPriority=vrrpInfoVirtRtrPriority, ospfCumNbrNegotiationDone=ospfCumNbrNegotiationDone, bgpNewCfgGroupPassword=bgpNewCfgGroupPassword, ripNewCfgOspfMetric=ripNewCfgOspfMetric, ipInfoBootpRelayAddr=ipInfoBootpRelayAddr, igmpStatsTotalIgmpGroups=igmpStatsTotalIgmpGroups, ospfAreaInfoIndex=ospfAreaInfoIndex, ospf3NewCfgExtRangeIndex=ospf3NewCfgExtRangeIndex, imageConfigTransfer=imageConfigTransfer, agNewCfgSyslog2HostPort=agNewCfgSyslog2HostPort, ospf3RoutesInfoDestination=ospf3RoutesInfoDestination, mldCfg=mldCfg, ipIntfLoopbackInfo=ipIntfLoopbackInfo, ipCurCfgNwfState=ipCurCfgNwfState, fcoeStatsFcoeRemoved=fcoeStatsFcoeRemoved, bgpInfoPath=bgpInfoPath, pptNewCfgPrefix=pptNewCfgPrefix, agCfgDumpState=agCfgDumpState, ipv6icmpInErrs=ipv6icmpInErrs, bgpCurCfgDscp=bgpCurCfgDscp, mstCistNewCfgPortStpState=mstCistNewCfgPortStpState, txIgmpGenQueries=txIgmpGenQueries, vmapNewCfgIndex=vmapNewCfgIndex, ipsecSaInfoAuthAlg=ipsecSaInfoAuthAlg, acl6NewCfgDstIPv6Address=acl6NewCfgDstIPv6Address, thash=thash, bgpInfoDynamicPeerGroup=bgpInfoDynamicPeerGroup, ospfAreaNbrN1way=ospfAreaNbrN1way, ospfExtLsdbInfoTable=ospfExtLsdbInfoTable, ipsecCurCfgDynamicPolicyLifetime=ipsecCurCfgDynamicPolicyLifetime, vmCurCfgProfileEgressShapingAverage=vmCurCfgProfileEgressShapingAverage, ipNewCfgIntfManagedCfg=ipNewCfgIntfManagedCfg, ipsecCurCfgDynamicPolicyPfs=ipsecCurCfgDynamicPolicyPfs, vmCurCfgCheckTrust=vmCurCfgCheckTrust, vrrpNewCfgVirtRtrGrpTckVlanPort=vrrpNewCfgVirtRtrGrpTckVlanPort, bgpInfoGroupRASIndex=bgpInfoGroupRASIndex, vlanInfoPorts=vlanInfoPorts, ikeCurCfgPsk=ikeCurCfgPsk, ospfCurCfgIntfMdkey=ospfCurCfgIntfMdkey, allportsStatsInErrors=allportsStatsInErrors, ripCurCfgIntfVersion=ripCurCfgIntfVersion, igmpNewCfgOtherQurAddress=igmpNewCfgOtherQurAddress, ipNewCfgIntfMask=ipNewCfgIntfMask, bgpNewCfgGroupAddInRmap=bgpNewCfgGroupAddInRmap, ospf3CurCfgReferenceBw=ospf3CurCfgReferenceBw, portStatsPhyIfOutErrors=portStatsPhyIfOutErrors, sflowCurPortCfgTableEntry=sflowCurPortCfgTableEntry, ntpSystemCurrentTime=ntpSystemCurrentTime, virtVMwareHostDetailInfoEntry=virtVMwareHostDetailInfoEntry, ospf3CurCfgAreaStbInterval=ospf3CurCfgAreaStbInterval, ospf3AreaNbrN2way=ospf3AreaNbrN2way, ospf3CurCfgExtRangeAggrEffect=ospf3CurCfgExtRangeAggrEffect, ospfCurCfgIntfStatus=ospfCurCfgIntfStatus, agPortOperTableEntry=agPortOperTableEntry, ibmnosImage1Ver=ibmnosImage1Ver, vrrpGeneral=vrrpGeneral, vlanAutoStgCurCfgState=vlanAutoStgCurCfgState, vmNewCfgGroupStg=vmNewCfgGroupStg, trunkGroupInfoIndex=trunkGroupInfoIndex, failoverInfoTriggerMonitorState=failoverInfoTriggerMonitorState, virtVMwareVMInfoIndex=virtVMwareVMInfoIndex, ipsecNewCfgTxformIndex=ipsecNewCfgTxformIndex, ospfRoutesInfoTable=ospfRoutesInfoTable, vmapNewCfgRemarkOutprofReset=vmapNewCfgRemarkOutprofReset, ripStatInBadSourcePort=ripStatInBadSourcePort, ospfCumNbrhello=ospfCumNbrhello, ospf3NewCfgVirtIntfEntry=ospf3NewCfgVirtIntfEntry, ripClearStats=ripClearStats, dnsNewCfgSecServerPort=dnsNewCfgSecServerPort, vmapCurCfgEthernetTypeValue=vmapCurCfgEthernetTypeValue, vmapCurCfgTable=vmapCurCfgTable, ipv6icmpInEchoResp=ipv6icmpInEchoResp, hotlinksNewCfgTriggerTable=hotlinksNewCfgTriggerTable, aclNewCfgPortRemoveAcl6=aclNewCfgPortRemoveAcl6, agNewCfgNTPSrcLoopIf=agNewCfgNTPSrcLoopIf, oamInfoPortRemoteMode=oamInfoPortRemoteMode, igmpSnoopStatsEntry=igmpSnoopStatsEntry, udpMGMTTableEntry=udpMGMTTableEntry, bgpNewCfgPeerClient=bgpNewCfgPeerClient, ndprefixNewCfgIndx=ndprefixNewCfgIndx, agNewCfgDcbx=agNewCfgDcbx, agPortCurCfgMulticastThreshold=agPortCurCfgMulticastThreshold, ipsecCurCfgDynamicPolicyPeer=ipsecCurCfgDynamicPolicyPeer, vnicNewCfgGroupRemPort=vnicNewCfgGroupRemPort, icmpStatsOutTimeExcds=icmpStatsOutTimeExcds, acl6CurCfgSrcPortMask=acl6CurCfgSrcPortMask, vmapGroupCurCfgNonServerPortsGroupIdx=vmapGroupCurCfgNonServerPortsGroupIdx, hotlinksStatsTriggerBackupActive=hotlinksStatsTriggerBackupActive, ipv6icmpOutParamprob=ipv6icmpOutParamprob, vmapGroupNewCfgAllPortsVmapBitmap=vmapGroupNewCfgAllPortsVmapBitmap, bgpNewCfgPeerIndex=bgpNewCfgPeerIndex, agCurCfgMgmtNetTable=agCurCfgMgmtNetTable, l2ThashCurCfgDmacState=l2ThashCurCfgDmacState, ospfTmrsKckOffLsaAck=ospfTmrsKckOffLsaAck, ipCurCfgAspathIndex=ipCurCfgAspathIndex, fdbNewCfgStaticEntry=fdbNewCfgStaticEntry, lldpNewCfgPortAdmStat=lldpNewCfgPortAdmStat, agCurCfgSysCustomDstEnd=agCurCfgSysCustomDstEnd, ipEcmpHash=ipEcmpHash, qosNewCfgCosWeight=qosNewCfgCosWeight, mpTcbStats=mpTcbStats, pktStatsAllocs=pktStatsAllocs, agNewCfgCpuRateLimitOther=agNewCfgCpuRateLimitOther, ikeCurCfgIdType=ikeCurCfgIdType, ibmnosSystem=ibmnosSystem, ospfVirtIntfInfoCost=ospfVirtIntfInfoCost, acl6NewCfgIPv6NextHeader=acl6NewCfgIPv6NextHeader, failoverNewCfgTriggerMmonKeyRem=failoverNewCfgTriggerMmonKeyRem, agCurCfgSyslogTrapOspfv3=agCurCfgSyslogTrapOspfv3, ipv6icmpOutRedir=ipv6icmpOutRedir, bgpNewCfgPeerAddOutRmap=bgpNewCfgPeerAddOutRmap, ipCurCfgGwIpv6State=ipCurCfgGwIpv6State, ipNewCfgRmapPrec=ipNewCfgRmapPrec, ospf3IfInfoPriority=ospf3IfInfoPriority, sshCurCfgScpAdm=sshCurCfgScpAdm, aclNewCfgSrcMACMask=aclNewCfgSrcMACMask, aclCurCfgVLanId=aclCurCfgVLanId, ospfVirtIntfInfoRetra=ospfVirtIntfInfoRetra, dhcpSnoopingNewCfgportId=dhcpSnoopingNewCfgportId, fcoeInfo=fcoeInfo, lldpInfoTxTransmitInterval=lldpInfoTxTransmitInterval, virtVMwareVMInfoVMCurrentHost=virtVMwareVMInfoVMCurrentHost, vmapCurCfgIndex=vmapCurCfgIndex, ipv6icmpInRouterAdv=ipv6icmpInRouterAdv, acl6NewCfgEntry=acl6NewCfgEntry, vmNewCfgGroupMacTable=vmNewCfgGroupMacTable, hwFanStatus=hwFanStatus, ospfCurCfgState=ospfCurCfgState, ospf3CumRxPkts=ospf3CumRxPkts, ospfIfNbrEntry=ospfIfNbrEntry, ospf3NewCfgHostDelete=ospf3NewCfgHostDelete, agPortCurCfgType=agPortCurCfgType, ospfCumNbrChangeStats=ospfCumNbrChangeStats, bgpCurCfgGroupUpdateSrcLoopIf=bgpCurCfgGroupUpdateSrcLoopIf, swCistNewRoot=swCistNewRoot, stpInfoPortPathCost=stpInfoPortPathCost, ospf3NewCfgIntfLsaSupress=ospf3NewCfgIntfLsaSupress, vlagInfoAutoRecoveryStatus=vlagInfoAutoRecoveryStatus, lldpNewCfgMsgTxInt=lldpNewCfgMsgTxInt, ospf3AreaErrHelloMismatch=ospf3AreaErrHelloMismatch, agPortCurCfgMacAddrNotif=agPortCurCfgMacAddrNotif, lacpInfoPortPartOpAggr=lacpInfoPortPartOpAggr, ospfNewCfgVirtIntfEntry=ospfNewCfgVirtIntfEntry, vrrpNewCfgIfDelete=vrrpNewCfgIfDelete, ospf3TmrsKckOffHello=ospf3TmrsKckOffHello, vmGroups=vmGroups, udldInfoPortTimeout=udldInfoPortTimeout, ipv6Fragcreates=ipv6Fragcreates, ipStaticRouteCurPingInterval=ipStaticRouteCurPingInterval, agPortNewCfgOamMode=agPortNewCfgOamMode, ospfIntfNbrChangeStats=ospfIntfNbrChangeStats, ipMgmtRouteInfoMask=ipMgmtRouteInfoMask, ripInfoUpdatePeriod=ripInfoUpdatePeriod, aclNewCfgMirrorPort=aclNewCfgMirrorPort, lldpClearMsap=lldpClearMsap, lldpCurCfgPortportvidtlv=lldpCurCfgPortportvidtlv, acl6CurCfgTCPFlags=acl6CurCfgTCPFlags, foreignAddressUdp=foreignAddressUdp, udldInfoPortMode=udldInfoPortMode, ipDataRouteInfoEntry=ipDataRouteInfoEntry, vmbwNewCfgDelete=vmbwNewCfgDelete, ripCurCfgIbgpMetric=ripCurCfgIbgpMetric, ipsecNewCfgSelectorEntry=ipsecNewCfgSelectorEntry, sfpInfoPort=sfpInfoPort, ipStats=ipStats, ipCurCfgIntfMask=ipCurCfgIntfMask, ripCurCfgEospfOutRmapList=ripCurCfgEospfOutRmapList, tcpStatsInErrs=tcpStatsInErrs, ipNewCfgAspathAction=ipNewCfgAspathAction, ipNewCfgIntfLoopbackEntry=ipNewCfgIntfLoopbackEntry, bgpCurCfgPeerEntry=bgpCurCfgPeerEntry, agTacacsUserMapCurCfgTableEntry=agTacacsUserMapCurCfgTableEntry, agNewCfgSysDlight=agNewCfgSysDlight, ipCurCfgGwIpv6Table=ipCurCfgGwIpv6Table, lldpGeneral=lldpGeneral, errMldIfStatsMLDv1Report=errMldIfStatsMLDv1Report, aclNewCfgPortTableEntry=aclNewCfgPortTableEntry, vnicNewCfgGroupAddVnic=vnicNewCfgGroupAddVnic, lldpInfoRxEntry=lldpInfoRxEntry, tacNewCfgAuthenSecondString=tacNewCfgAuthenSecondString, vrrpCurCfgVirtRtrPreempt=vrrpCurCfgVirtRtrPreempt, ospfLoopIfInfoWaitIntervalMS=ospfLoopIfInfoWaitIntervalMS, vmapNewCfgTcpudpReset=vmapNewCfgTcpudpReset, agApplyTable=agApplyTable, ipsecSpdInfoIndex=ipsecSpdInfoIndex, vmNewCfgGroupEntry=vmNewCfgGroupEntry, agAccessUserNewCfgPswd=agAccessUserNewCfgPswd, ospfCurCfgIntfArea=ospfCurCfgIntfArea, ospf3IfInfoAreaID=ospf3IfInfoAreaID, ipsecSaStatsPkts=ipsecSaStatsPkts, ospf3AreaDisdHello=ospf3AreaDisdHello, mldNewInterfaceEntry=mldNewInterfaceEntry, ipCurCfgIntfLoopbackMask=ipCurCfgIntfLoopbackMask, ospf3AreaIntfDrOther=ospf3AreaIntfDrOther, ospfCurCfgHostCost=ospfCurCfgHostCost, ipsecCurCfgManualPolicyOutEspEncKey=ipsecCurCfgManualPolicyOutEspEncKey, ipsecNewCfgTxformIntegrity=ipsecNewCfgTxformIntegrity, agAccess=agAccess, mcastFdbVlan=mcastFdbVlan, ipStaticRouteClearAllByInterface=ipStaticRouteClearAllByInterface, ecpChnlInfoTable=ecpChnlInfoTable, ipsecNewCfgSelectorDst=ipsecNewCfgSelectorDst, allportsStatsOutUcastRate=allportsStatsOutUcastRate, ipsecSpdInfoSaEncrAlg=ipsecSpdInfoSaEncrAlg, ospf3CurCfgAreaEntry=ospf3CurCfgAreaEntry, swapTotalStats=swapTotalStats, ospfNewCfgEbgpMetric=ospfNewCfgEbgpMetric, rxMldIfStatsIncCrsv2=rxMldIfStatsIncCrsv2, ospf3CurCfgAreaDefaultMetric=ospf3CurCfgAreaDefaultMetric, ospfIfInfoDead=ospfIfInfoDead, fipsPortCurCfgFipsEna=fipsPortCurCfgFipsEna, bgpNewCfgLocalPref=bgpNewCfgLocalPref, stgStatsPortTable=stgStatsPortTable, lacpInfoPortPartOpExp=lacpInfoPortPartOpExp, ospfNewCfgVirtIntfDead=ospfNewCfgVirtIntfDead, vlanNewCfgDelete=vlanNewCfgDelete, ospfAreaRxTxIndex=ospfAreaRxTxIndex, aclCurCfgRemarkOutProfDscpTable=aclCurCfgRemarkOutProfDscpTable, agTransferLastConfigurationActionStatus=agTransferLastConfigurationActionStatus, ospfNewCfgStaticAddOutRmap=ospfNewCfgStaticAddOutRmap, portMgmtStatsTxCarrier=portMgmtStatsTxCarrier, ospf3CurCfgIntfEncrySpi=ospf3CurCfgIntfEncrySpi, oamStatsPortUnsupTx=oamStatsPortUnsupTx, ibmnosConfigRestoreOption=ibmnosConfigRestoreOption, ipv6icmpOutRouterAdv=ipv6icmpOutRouterAdv, ospf3IntfTxlsReqs=ospf3IntfTxlsReqs, lacpInfoAggrReadyState=lacpInfoAggrReadyState, vmapGroupCfg=vmapGroupCfg, acl6NewCfgSrcIPv6Address=acl6NewCfgSrcIPv6Address, agPortCurCfgGigEthFctl=agPortCurCfgGigEthFctl, rxIgmpGenQueries=rxIgmpGenQueries, vmapNewCfgPktfmtReset=vmapNewCfgPktfmtReset, vrrpNewCfgVirtRtrDelete=vrrpNewCfgVirtRtrDelete, nsnmpOutSetRequests=nsnmpOutSetRequests, stgCurCfgStgIndex=stgCurCfgStgIndex, agApplyIndex=agApplyIndex, portState=portState, ospf3TotalActiveAreas=ospf3TotalActiveAreas, udpMGMTControlBlocksTable=udpMGMTControlBlocksTable, vmCurCfgCheckActionBasic=vmCurCfgCheckActionBasic, ibmnosSfpInfoHWRevision=ibmnosSfpInfoHWRevision, ospf3IntfRxTxDisdStatsEntry=ospf3IntfRxTxDisdStatsEntry, agNewCfgSyslogTrapMgmt=agNewCfgSyslogTrapMgmt, ospf3NumberOfInterfacesUp=ospf3NumberOfInterfacesUp, agNewCfgNTPSecServerPort=agNewCfgNTPSecServerPort, lacpInfoPortActAdSync=lacpInfoPortActAdSync, lldpCurCfgReinitDelay=lldpCurCfgReinitDelay, ospfLoopIfInfoRouterIP=ospfLoopIfInfoRouterIP, vmNewCfgProfilesTable=vmNewCfgProfilesTable, ipIntfLoopbackInfoTable=ipIntfLoopbackInfoTable, ospf3IntfNbrInit=ospf3IntfNbrInit, bgpNewCfgAggrDelete=bgpNewCfgAggrDelete)
mibBuilder.exportSymbols("IBM-GbTOR-10G-L2L3-MIB", ospf3CumIntfPtop=ospf3CumIntfPtop, agNewCfgErrDisableRecovery=agNewCfgErrDisableRecovery, ospf3AreaErrRxVerMismatch=ospf3AreaErrRxVerMismatch, ospf3IfNbrIntfIndex=ospf3IfNbrIntfIndex, failoverCurCfgTriggerTable=failoverCurCfgTriggerTable, ripStatInBadSourceIP=ripStatInBadSourceIP, ipv6icmpInParamprob=ipv6icmpInParamprob, aclCurCfgRemarkOutProfDscpMkdnDscp=aclCurCfgRemarkOutProfDscpMkdnDscp, agCurDaylightSavings=agCurDaylightSavings, hotlinksNewCfgTriggerBackupTrunk=hotlinksNewCfgTriggerBackupTrunk, mcastFdbNewCfgAddVlan=mcastFdbNewCfgAddVlan, ipsecNewCfgIfEntry=ipsecNewCfgIfEntry, ospfExtLsdbInfoAge=ospfExtLsdbInfoAge, bgpInfoLastErrorSubCode=bgpInfoLastErrorSubCode, bootpRelayStatsIndex=bootpRelayStatsIndex, vlagInfoGroup=vlagInfoGroup, stpInfoPortStpIndex=stpInfoPortStpIndex, ipMgmtRouteInfoGateway2=ipMgmtRouteInfoGateway2, ipsecCurCfgTxformDelete=ipsecCurCfgTxformDelete, vrrpNewCfgIfTable=vrrpNewCfgIfTable, agCurCfgSyslog2HostPort=agCurCfgSyslog2HostPort, stgCurCfgBrgMaxAge=stgCurCfgBrgMaxAge, ospfClearStats=ospfClearStats, ospf3CurCfgIntfEncryAuthKey=ospf3CurCfgIntfEncryAuthKey, qosNewCfgPriorityCoSq=qosNewCfgPriorityCoSq, dhcpInfoDefaultGateway=dhcpInfoDefaultGateway, ipInfoBootpRelayAddr2=ipInfoBootpRelayAddr2, ipsecNewCfgSelectorIcmpType=ipsecNewCfgSelectorIcmpType, ospfNewCfgIntfPtop=ospfNewCfgIntfPtop, ipCurCfgStaticRouteTable=ipCurCfgStaticRouteTable, ipNewCfgNwfTable=ipNewCfgNwfTable, bgpInfoSummaryTotalReceivedPackets=bgpInfoSummaryTotalReceivedPackets, virtCurCfgHbPort=virtCurCfgHbPort, ipNewCfgAspathIndex=ipNewCfgAspathIndex, igmpNewCfgVlanOperVersion=igmpNewCfgVlanOperVersion, stpInfoPortTableEntry=stpInfoPortTableEntry, stgCurCfgPortState=stgCurCfgPortState, ospfIfInfoBackupDesignatedRouterIP=ospfIfInfoBackupDesignatedRouterIP, cistRoot=cistRoot, ipBootpCfg=ipBootpCfg, ospf3Info=ospf3Info, ipv6udpOutDgrams=ipv6udpOutDgrams, hwBoardRevision=hwBoardRevision, ospfCurCfgEbgpOutRmapList=ospfCurCfgEbgpOutRmapList, vmNewCfgProfileVlan=vmNewCfgProfileVlan, mpUdpStats=mpUdpStats, ospfIfInfoHelloMS=ospfIfInfoHelloMS, igmpMrtrInfoMrt=igmpMrtrInfoMrt, vmapVlanNewCfgAllPortsAddVmap=vmapVlanNewCfgAllPortsAddVmap, oamInfoPortRemoteEvaluating=oamInfoPortRemoteEvaluating, ipInfoFwdDirectedBcast=ipInfoFwdDirectedBcast, bgpInfoMinAdvTime=bgpInfoMinAdvTime, bgpNewCfgPeerFixedState=bgpNewCfgPeerFixedState, ospf3NewCfgIntfDead=ospf3NewCfgIntfDead, aclCurCfgVLanMask=aclCurCfgVLanMask, icmpStatsOutEchos=icmpStatsOutEchos, aclCurCfgLog=aclCurCfgLog, vlagStatsPduRcvOther=vlagStatsPduRcvOther, ipv6icmpInRouterSol=ipv6icmpInRouterSol, mstCistNewCfgPortTable=mstCistNewCfgPortTable, virtVMwareHostVswitchName=virtVMwareHostVswitchName, ripNewCfgFixedMetric=ripNewCfgFixedMetric, udpStatsInErrors=udpStatsInErrors, stgNewCfgAddVlan=stgNewCfgAddVlan, bootpRelayStatsRequestsDroppedNoServer=bootpRelayStatsRequestsDroppedNoServer, ibmnosPortCtrlDuplex=ibmnosPortCtrlDuplex, ospfIfInfoAuthType=ospfIfInfoAuthType, lldpInfoRemoteDevicesRxChanges=lldpInfoRemoteDevicesRxChanges, ospf3AreaRxTxDisdIndex=ospf3AreaRxTxDisdIndex, ikeNewCfgIdType=ikeNewCfgIdType, ipmcNewCfgStaticRouteAddAdminkey=ipmcNewCfgStaticRouteAddAdminkey, ipCurCfgIntfLoopbackIndex=ipCurCfgIntfLoopbackIndex, ospfIntfTxHello=ospfIntfTxHello, ipCurCfgIntfRouteAdv=ipCurCfgIntfRouteAdv, illegalRx=illegalRx, vlagInfoIslPorts=vlagInfoIslPorts, agTransferUserName=agTransferUserName, allportsStatsTable=allportsStatsTable, radNewCfgPort=radNewCfgPort, sfpInfoVendor=sfpInfoVendor, qosdscp=qosdscp, stpInfoTimeSinceTopChange=stpInfoTimeSinceTopChange, dot3RateStatsLateCollisions=dot3RateStatsLateCollisions, lldpInfoPortportdesctlv=lldpInfoPortportdesctlv, bgpNewCfgGroupRAS=bgpNewCfgGroupRAS, agNewCfgSyslogTrapLink=agNewCfgSyslogTrapLink, igmpNewCfgQuerierDefault=igmpNewCfgQuerierDefault, ipv6Reasmreqs=ipv6Reasmreqs, udpStats=udpStats, qosCurCfgDscpEntry=qosCurCfgDscpEntry, aclLogCurInterval=aclLogCurInterval, ipStaticRouteNewHealthcheck=ipStaticRouteNewHealthcheck, ipNewCfgGwIpv6Delete=ipNewCfgGwIpv6Delete, ipNewCfgNwfMask=ipNewCfgNwfMask, ospfVirtIntfInfoWaitMS=ospfVirtIntfInfoWaitMS, ospf3CurCfgExtRangeAreaIndex=ospf3CurCfgExtRangeAreaIndex, ospf3CumTxlsAcks=ospf3CumTxlsAcks, igmpFltNewCfgPortRemFiltRule=igmpFltNewCfgPortRemFiltRule, hotlinksCurCfgFdbUpdateState=hotlinksCurCfgFdbUpdateState, ospfVirtIntfInfoWait=ospfVirtIntfInfoWait, portMgmtStatsRxOverruns=portMgmtStatsRxOverruns, vlagInfoInstanceEntry=vlagInfoInstanceEntry, ospfNewCfgAreaTable=ospfNewCfgAreaTable, bgpNewCfgGroupRemoveOutRmap=bgpNewCfgGroupRemoveOutRmap, ospfCumRxTxStats=ospfCumRxTxStats, localAddress=localAddress, fipsPortNewCfgFcfMode=fipsPortNewCfgFcfMode, accessUserInfoClearFailAttempts=accessUserInfoClearFailAttempts, lacpNewPortCfgTable=lacpNewPortCfgTable, igmpSnoopCurCfgMrto=igmpSnoopCurCfgMrto, agPortCurCfgDLFThresholdRate=agPortCurCfgDLFThresholdRate, ospf3CurCfgIntfAuthSpi=ospf3CurCfgIntfAuthSpi, aclCurCfgPortTable=aclCurCfgPortTable, fipsNewCfgState=fipsNewCfgState, ripNewCfgStaticOutRmapList=ripNewCfgStaticOutRmapList, virtVMwareHostDetailInfoIndex=virtVMwareHostDetailInfoIndex, vlagNewIslCfgPortChannel=vlagNewIslCfgPortChannel, ospfIntfNbrNegotiationDone=ospfIntfNbrNegotiationDone, udpClearStats=udpClearStats, vmNewCfgProfileEgressShapingBurst=vmNewCfgProfileEgressShapingBurst, ospf3NewCfgRedistDelete=ospf3NewCfgRedistDelete, mldInfoGroupFwd=mldInfoGroupFwd, hotlinksInfo=hotlinksInfo, pmCurCfgPmirrMoniPortIndex=pmCurCfgPmirrMoniPortIndex, ospf3TmrsKckOffPoll=ospf3TmrsKckOffPoll, hotlinksNewCfgTriggerMasterTrunk=hotlinksNewCfgTriggerMasterTrunk, portStatsPhyIfInOctets=portStatsPhyIfInOctets, errMldIfStatsAllowSlcrsv2=errMldIfStatsAllowSlcrsv2, ldapNewCfgPrimaryIpAddr=ldapNewCfgPrimaryIpAddr, ospfInterface=ospfInterface, allportsStatsLinkStateChange=allportsStatsLinkStateChange, tcpClearStats=tcpClearStats, vlagCurCfgHlthchkPeerIp=vlagCurCfgHlthchkPeerIp, allportsStatsInBcast=allportsStatsInBcast, private_mibs=private_mibs, fipsCurCfgState=fipsCurCfgState, ospfNewCfgRipOutRmapList=ospfNewCfgRipOutRmapList, agDiffTableSize=agDiffTableSize, ospf3IntfErrRxMismatchInstID=ospf3IntfErrRxMismatchInstID, vmapNewCfgEgressPorts=vmapNewCfgEgressPorts, mldCurInterfaceTable=mldCurInterfaceTable, aclCurCfgInprofDscp=aclCurCfgInprofDscp, vmapCurCfgStatistics=vmapCurCfgStatistics, acl6NewCfgUser=acl6NewCfgUser, bgpCurCfgPeerInRmapList=bgpCurCfgPeerInRmapList, ospf3AreaErrRxZeroRTRID=ospf3AreaErrRxZeroRTRID, bgpInfoSummaryVersion=bgpInfoSummaryVersion, ripStatInSelfRcvPkts=ripStatInSelfRcvPkts, ospf3IfNbrInfoIndex=ospf3IfNbrInfoIndex, vmNewCfgCheckTrustRemPort=vmNewCfgCheckTrustRemPort, vlagNewCfgTrunkIndex=vlagNewCfgTrunkIndex, ospfCumIntfHello=ospfCumIntfHello, dhcpSnoopingBindingInfoIndex=dhcpSnoopingBindingInfoIndex, ospfNewCfgAreaIndex=ospfNewCfgAreaIndex, ndprefixNewCfgAction=ndprefixNewCfgAction, ldapNewCfgPort=ldapNewCfgPort, agNewCfgBootp=agNewCfgBootp, errMldIfStatsExcCrsv2=errMldIfStatsExcCrsv2, ipNewCfgIntfLoopbackDelete=ipNewCfgIntfLoopbackDelete, ipNewCfgGwIpv6Entry=ipNewCfgGwIpv6Entry, udldInfoNeighborTable=udldInfoNeighborTable, ospfNewCfgVirtIntfRetra=ospfNewCfgVirtIntfRetra, mstCistCurCfgPortHelloTime=mstCistCurCfgPortHelloTime, ospfNewCfgIntfEntry=ospfNewCfgIntfEntry, ipsecCurCfgManualPolicyOutAhSpi=ipsecCurCfgManualPolicyOutAhSpi, acl6NewCfgDstPortMask=acl6NewCfgDstPortMask, ifMainPortName=ifMainPortName, ospf3VirtIfInfoState=ospf3VirtIfInfoState, agNewCfgSysCustomDstStart=agNewCfgSysCustomDstStart, portMgmtStatsTxErrors=portMgmtStatsTxErrors, ospfIfInfoIpAddress=ospfIfInfoIpAddress, ibmnoscfa=ibmnoscfa, igmpFltNewCfgMcastIp1=igmpFltNewCfgMcastIp1, ospf3NewCfgStaticMetricType=ospf3NewCfgStaticMetricType, acList=acList, ripNewCfgIntfPoisonReverse=ripNewCfgIntfPoisonReverse, agNewBootNxtCliModePrompt=agNewBootNxtCliModePrompt, ipsecNewCfgManualPolicyDelete=ipsecNewCfgManualPolicyDelete, lldpNewCfgPortsyscaptlv=lldpNewCfgPortsyscaptlv, ikeCurCfgProposal=ikeCurCfgProposal, lldpInfoRemoteDevicesManAddrIfSubtype=lldpInfoRemoteDevicesManAddrIfSubtype, ospfAreaNbrAdjointOk=ospfAreaNbrAdjointOk, lldpNewCfgPortmgmtaddrtlv=lldpNewCfgPortmgmtaddrtlv, ospfTotalNssaAreas=ospfTotalNssaAreas, rip2Cfg=rip2Cfg, hotlinksNewCfgFdbUpdateRate=hotlinksNewCfgFdbUpdateRate, vnicCurCfgVnicBw=vnicCurCfgVnicBw, vlagCfg=vlagCfg, ipGatewayIpv6Cfg=ipGatewayIpv6Cfg, errMldIfStatsGeneralQuery=errMldIfStatsGeneralQuery, ospf3NewCfgReferenceBw=ospf3NewCfgReferenceBw, ospfAreaInfoNeighborsFULLstate=ospfAreaInfoNeighborsFULLstate, ospf3NewCfgVirtIntfTrans=ospf3NewCfgVirtIntfTrans, vrrpNewCfgVirtRtrTable=vrrpNewCfgVirtRtrTable, qosCurCfgPriorityCoSTable=qosCurCfgPriorityCoSTable, vrrpStatBadData=vrrpStatBadData, igmpFltCurCfgEnaDis=igmpFltCurCfgEnaDis, hotlinksCurCfgOnState=hotlinksCurCfgOnState, bgpInfoDynamicPeerRemoteAs=bgpInfoDynamicPeerRemoteAs, lacpInfoAggrPartSysId=lacpInfoAggrPartSysId, vlagInfoStartupDelayStatus=vlagInfoStartupDelayStatus, ipsecNewCfgTxformCipher=ipsecNewCfgTxformCipher, radCurCfgSecBd=radCurCfgSecBd, ospfVirtIntfInfoTrans=ospfVirtIntfInfoTrans, aclNewCfgDstMACMask=aclNewCfgDstMACMask, vrrpCurCfgVirtRtrGrpPreempt=vrrpCurCfgVirtRtrGrpPreempt, ipCurCfgBootpBcastDomainServerIP=ipCurCfgBootpBcastDomainServerIP, ospf3CurCfgNbrIpAddr=ospf3CurCfgNbrIpAddr, ikeCurCfgPskRemoteDelete=ikeCurCfgPskRemoteDelete, vrrpInfoVirtRtrID=vrrpInfoVirtRtrID, ospfAreaErrorStatsEntry=ospfAreaErrorStatsEntry, vmapGroupNewCfgNonServerPortsTableEntry=vmapGroupNewCfgNonServerPortsTableEntry, vmapGroupNewCfgServerPortsVmapBitmap=vmapGroupNewCfgServerPortsVmapBitmap, intfLoopbackInfoStatus=intfLoopbackInfoStatus, igmpMrtrInfoPortId=igmpMrtrInfoPortId, ipv6Stats=ipv6Stats, tacCurCfgAuthenSecondString=tacCurCfgAuthenSecondString, ospf3CurCfgVirtIntfHello=ospf3CurCfgVirtIntfHello, ospfCurCfgAreaIndex=ospfCurCfgAreaIndex, hotlinksCurCfgFdbUpdateRate=hotlinksCurCfgFdbUpdateRate, igmpV3SnoopNewCfgV1V2EnaDis=igmpV3SnoopNewCfgV1V2EnaDis, icmpStatsInMsgs=icmpStatsInMsgs, oamInfoPortRemoteStable=oamInfoPortRemoteStable, localAddressUdp=localAddressUdp, fdbCurCfgEntryIndex=fdbCurCfgEntryIndex, portStatsPhyIfOutUcastPkts=portStatsPhyIfOutUcastPkts, agAccessUserCurCfgName=agAccessUserCurCfgName, portMgmtStatsTxDropped=portMgmtStatsTxDropped, agCurCfgTelnetServerPort=agCurCfgTelnetServerPort, vlagInfoRemotePriority=vlagInfoRemotePriority, ipsecCurCfgIfDelete=ipsecCurCfgIfDelete, ospfAreaTableMaxSize=ospfAreaTableMaxSize, cistInfoPortDesignatedPort=cistInfoPortDesignatedPort, ospf3IntfDisdHello=ospf3IntfDisdHello, ipNewCfgRmapAp=ipNewCfgRmapAp, ospf3IntfRxlsReqs=ospf3IntfRxlsReqs, ipsecNewCfgManualPolicyTxform=ipsecNewCfgManualPolicyTxform, fdbStatsCurrent=fdbStatsCurrent, tcpStatsCurrConn=tcpStatsCurrConn, ospfIntfDown=ospfIntfDown, ospf3NewCfgIntfEntry=ospf3NewCfgIntfEntry, agCurCfgSyslogTrapIgmpQuerier=agCurCfgSyslogTrapIgmpQuerier, ipsecCurCfgDynamicPolicySelector=ipsecCurCfgDynamicPolicySelector, mldInfoMRoutersTable=mldInfoMRoutersTable, ospf3CurCfgVirtIntfIndex=ospf3CurCfgVirtIntfIndex, vnicCurCfgVnicState=vnicCurCfgVnicState, igmpFltNewCfgIndx=igmpFltNewCfgIndx, bgpInfoSummaryState=bgpInfoSummaryState, tacCurCfgPrimaryServer=tacCurCfgPrimaryServer, mstCistCurCfgPortLinkType=mstCistCurCfgPortLinkType, tcpMGMTControlBlocksTable=tcpMGMTControlBlocksTable, vrrpCurCfgVirtRtrGrpPredelay=vrrpCurCfgVirtRtrGrpPredelay, agTransferDumpFileName=agTransferDumpFileName, sflowCurPortSampling=sflowCurPortSampling)
mibBuilder.exportSymbols("IBM-GbTOR-10G-L2L3-MIB", ospf3AreaTxlsAcks=ospf3AreaTxlsAcks, dhcpSnoopingCurCfgPortTrusted=dhcpSnoopingCurCfgPortTrusted, lldpCurCfgState=lldpCurCfgState, oamInfoPortIndex=oamInfoPortIndex, rxIgmpDiscardPkts=rxIgmpDiscardPkts, ospf3IfNbrIpAddress=ospf3IfNbrIpAddress, trunkGroupInfoTableEntry=trunkGroupInfoTableEntry, ipNewCfgGwIndex=ipNewCfgGwIndex, ospfAreaTxlsReqs=ospfAreaTxlsReqs, ipCurCfgStaticRouteDestIp=ipCurCfgStaticRouteDestIp, vrrpCurCfgVirtRtrGrpPriority=vrrpCurCfgVirtRtrGrpPriority, ipFloodNewCfgFlood=ipFloodNewCfgFlood, agCurCfgCpuRateLimitOther=agCurCfgCpuRateLimitOther, hotlinksCurCfgTriggerBackupPort=hotlinksCurCfgTriggerBackupPort, igmpFltCurCfgPortIndx=igmpFltCurCfgPortIndx, mldInfoMRouterEntry=mldInfoMRouterEntry, intfInfoAddr=intfInfoAddr, failoverInfoTriggerLimit=failoverInfoTriggerLimit, swDefGwUp=swDefGwUp, vmapVlanNewCfgServerPortsRemVmap=vmapVlanNewCfgServerPortsRemVmap, bgpInfoSummaryIndex=bgpInfoSummaryIndex, ecpChnlInfoEntry=ecpChnlInfoEntry, ripCurCfgFixedOutRmapList=ripCurCfgFixedOutRmapList, trunkGroupNewCfgDelete=trunkGroupNewCfgDelete, vmapGroupCurCfgAllPortsGroupIdx=vmapGroupCurCfgAllPortsGroupIdx, aclStatsTableEntry=aclStatsTableEntry, bgpInfoGroupRAS=bgpInfoGroupRAS, vlagStatsPduRcvFdbDynamicAdd=vlagStatsPduRcvFdbDynamicAdd, ospf3AreaIntfPtop=ospf3AreaIntfPtop, radNewCfgSecBd=radNewCfgSecBd, lldpCurCfgPortIndx=lldpCurCfgPortIndx, ospf3AreaErrRxMismatchInstID=ospf3AreaErrRxMismatchInstID, ospfIntfNbrStart=ospfIntfNbrStart, agMgmtNetConfig=agMgmtNetConfig, failoverNewCfgTriggerMmonPortRem=failoverNewCfgTriggerMmonPortRem, agPortCurCfgLFDStatus=agPortCurCfgLFDStatus, ipCurCfgStaticArpVlan=ipCurCfgStaticArpVlan, ospf3CurCfgVirtIntfStatus=ospf3CurCfgVirtIntfStatus, bgpCurCfgGroupAdvert=bgpCurCfgGroupAdvert, ospf3CurCfgRangeTable=ospf3CurCfgRangeTable, rxMldIfStatsMLDv1Report=rxMldIfStatsMLDv1Report, ospf3CurCfgVirtIntfDead=ospf3CurCfgVirtIntfDead, stgNewCfgPortIndex=stgNewCfgPortIndex, ospf3CumRxDatabase=ospf3CumRxDatabase, ospf3NewCfgIntfRetra=ospf3NewCfgIntfRetra, ospfCurCfgAreaTable=ospfCurCfgAreaTable, allportsStatsInErrorsRate=allportsStatsInErrorsRate, ipNewCfgGwIpv6Addr=ipNewCfgGwIpv6Addr, aclNewCfgInprofDscpEnable=aclNewCfgInprofDscpEnable, sshCurCfgStatus=sshCurCfgStatus, lacpClearStats=lacpClearStats, fdbNewCfgEntryIndex=fdbNewCfgEntryIndex, vlagInfoLocalMac=vlagInfoLocalMac, ospfRangeTableMaxSize=ospfRangeTableMaxSize, vmCurCfgGroupValidateMode=vmCurCfgGroupValidateMode, fdbCurCfgStaticTable=fdbCurCfgStaticTable, aclCurCfgRemarkOutProfDscpEntry=aclCurCfgRemarkOutProfDscpEntry, hotlinksStats=hotlinksStats, allportsStatsInMcastRate=allportsStatsInMcastRate, ospf3CurCfgIntfTable=ospf3CurCfgIntfTable, ripCurCfgIntfMcastUpdate=ripCurCfgIntfMcastUpdate, ospf3NewCfgAbrType=ospf3NewCfgAbrType, icmpStatsOutSrcQuenchs=icmpStatsOutSrcQuenchs, fdbNewCfgAgingTime=fdbNewCfgAgingTime, vnicNewCfgGroupAddTrunk=vnicNewCfgGroupAddTrunk, pptNewCfgEntry=pptNewCfgEntry, ipCurCfgIntfAdvMtu=ipCurCfgIntfAdvMtu, ospf3CurCfgAreaTranslRole=ospf3CurCfgAreaTranslRole, ospf3NewCfgExitOverflow=ospf3NewCfgExitOverflow, radCurCfgSecondaryServer=radCurCfgSecondaryServer, ipRoute6InfoPrefLen=ipRoute6InfoPrefLen, agTransfer=agTransfer, portStatsDot1PortInFrames=portStatsDot1PortInFrames, igmpFltCurCfgTableEntry=igmpFltCurCfgTableEntry, ipNewCfgBootpGlobalServerAddress=ipNewCfgBootpGlobalServerAddress, virtNewCfgVirtCenterPasswd=virtNewCfgVirtCenterPasswd, ospf3CumNbrAttempt=ospf3CumNbrAttempt, lacpInfoPortPartOpSysPrio=lacpInfoPortPartOpSysPrio, lacpInfoPortActSysId=lacpInfoPortActSysId, agPortCurCfgStpExtGuard=agPortCurCfgStpExtGuard, ospfCurCfgVirtIntfStatus=ospfCurCfgVirtIntfStatus, ospfCurCfgRangeIndex=ospfCurCfgRangeIndex, bgpCurCfgGroupTable=bgpCurCfgGroupTable, agAccessCurStrongPassLockout=agAccessCurStrongPassLockout, ospfLoopIfInfoDead=ospfLoopIfInfoDead, ospf3IfInfoPoll=ospf3IfInfoPoll, vrrpNewCfgVirtRtrAddr=vrrpNewCfgVirtRtrAddr, vmNewCfgGroupAddProfile=vmNewCfgGroupAddProfile, blade=blade, ospf3AreaIntfChangeStats=ospf3AreaIntfChangeStats, dhcpSnoopingCurCfgPortId=dhcpSnoopingCurCfgPortId, ospfTmrsKckOffDbage=ospfTmrsKckOffDbage, ipNewCfgStaticNbrPort=ipNewCfgStaticNbrPort, swAcntUnlocked=swAcntUnlocked, fipsInfoFcoeVlan=fipsInfoFcoeVlan, failoverCurCfgTriggerState=failoverCurCfgTriggerState, lacpInfoPortPerTraTimer=lacpInfoPortPerTraTimer, trunkLacpGroupCurCfgTableEntry=trunkLacpGroupCurCfgTableEntry, bgpCurCfgClientToClientReflection=bgpCurCfgClientToClientReflection, agPortOperTable=agPortOperTable, agNewHttpAcces=agNewHttpAcces, ospf3CumDisdlsUpdates=ospf3CumDisdlsUpdates, icmpStatsOutMsgs=icmpStatsOutMsgs, dot3RateStatsTableEntry=dot3RateStatsTableEntry, ospf3NewCfgHostIpAddr=ospf3NewCfgHostIpAddr, ipCurCfgRmapIndex=ipCurCfgRmapIndex, udldInfoPortLink=udldInfoPortLink, vrrpCurCfgVirtRtrPreDelay=vrrpCurCfgVirtRtrPreDelay, ospfVirtIntfInfoIpAddr=ospfVirtIntfInfoIpAddr, stpInfoRootPort=stpInfoRootPort, ipsecNewCfgIfManualPolicyBmap=ipsecNewCfgIfManualPolicyBmap, ospfAreaInfoTable=ospfAreaInfoTable, ospf3AreaNbrExchange=ospf3AreaNbrExchange, ipmcNewCfgStaticRouteAddPort=ipmcNewCfgStaticRouteAddPort, ospfCumRxlsUpdates=ospfCumRxlsUpdates, ipCurCfgStaticRoute6Mask=ipCurCfgStaticRoute6Mask, ipsecSaStatsTable=ipsecSaStatsTable, vlagInstanceTrunkId=vlagInstanceTrunkId, acl6NewCfgSrcPortMask=acl6NewCfgSrcPortMask, vlanNewCfgTableEntry=vlanNewCfgTableEntry, dhcpSnoopingBindingInfoMac=dhcpSnoopingBindingInfoMac, virtVMwareHostDetailInfoVswitch=virtVMwareHostDetailInfoVswitch, ripNewCfgIbgpMetric=ripNewCfgIbgpMetric, ospfNewCfgHostTable=ospfNewCfgHostTable, ospfVirtIntfInfoEntry=ospfVirtIntfInfoEntry, vmProfiles=vmProfiles, ospf3AreaNbrExStart=ospf3AreaNbrExStart, dot1RateStatsTableEntry=dot1RateStatsTableEntry, ospfIntfErrorStatsEntry=ospfIntfErrorStatsEntry, lldpInfoRemoteDevicesManAddrOID=lldpInfoRemoteDevicesManAddrOID, agCurCfgSnmpTimeout=agCurCfgSnmpTimeout, bgpNewCfgGroupTable=bgpNewCfgGroupTable, ospf3CurCfgHostAreaIndex=ospf3CurCfgHostAreaIndex, dnsCurCfgPrimaryIpAddr=dnsCurCfgPrimaryIpAddr, radCurCfgTimeout=radCurCfgTimeout, ipNewCfgSecIntfAddr=ipNewCfgSecIntfAddr, ipCurCfgStaticNbrMAC=ipCurCfgStaticNbrMAC, vrrpStatBadAddress=vrrpStatBadAddress, ipsecSpdInfoSaAuthAlg=ipsecSpdInfoSaAuthAlg, ospf3TotalNeighbours=ospf3TotalNeighbours, ospfIfNbrPriority=ospfIfNbrPriority, icmpStatsOutTimestampReps=icmpStatsOutTimestampReps, ospfVirtIntfInfoDead=ospfVirtIntfInfoDead, lacpInfoPortOperTableEntry=lacpInfoPortOperTableEntry, aclNewCfgDstIPMask=aclNewCfgDstIPMask, ecpChnlSndnxt=ecpChnlSndnxt, swFwDownloadSucess=swFwDownloadSucess, ripNewCfgIntfVersion=ripNewCfgIntfVersion, vnicCurCfgVnicTable=vnicCurCfgVnicTable, ibmnosFdbMacAddrStr=ibmnosFdbMacAddrStr, ibmnosFdbEntry=ibmnosFdbEntry, ipNewCfgStaticArpIp=ipNewCfgStaticArpIp, agNewCfgSyslogFlashSev=agNewCfgSyslogFlashSev, ipsecCurCfgIfDynamicPolicyBmap=ipsecCurCfgIfDynamicPolicyBmap, ospf3CurCfgConnectedRouteTag=ospf3CurCfgConnectedRouteTag, ikeNewCfgPropAuth=ikeNewCfgPropAuth, ipsecSpdInfoSaEntry=ipsecSpdInfoSaEntry, vnicNewCfgGroupVlan=vnicNewCfgGroupVlan, fdbNewCfgAddAdminkey=fdbNewCfgAddAdminkey, radNewCfgAuthenString=radNewCfgAuthenString, ospf3VirtIntfInfoEntry=ospf3VirtIntfInfoEntry, qosDefaultCfg=qosDefaultCfg, agPortCurCfgErrDisableRecovery=agPortCurCfgErrDisableRecovery, ospfRoutesInfoDestination=ospfRoutesInfoDestination, ospfSumRangesInfoListType=ospfSumRangesInfoListType, ospfNewCfgRangeHideState=ospfNewCfgRangeHideState, vrrpNewCfgVirtRtrGrpTableEntry=vrrpNewCfgVirtRtrGrpTableEntry, sshNewCfgScpApplySave=sshNewCfgScpApplySave, failoverNewCfgTriggerMmonKeyAdd=failoverNewCfgTriggerMmonKeyAdd, ipv6OutNorts=ipv6OutNorts, vrrpInfoVirtRtrConfig=vrrpInfoVirtRtrConfig, vmapNewCfgTos=vmapNewCfgTos, mstpDigest=mstpDigest, agNewCfgSyslogTrapWeb=agNewCfgSyslogTrapWeb, icmpClearStats=icmpClearStats, ospfAreaInfoAuthType=ospfAreaInfoAuthType, aclNewCfgOutprofDscpEnable=aclNewCfgOutprofDscpEnable, agPortCurCfgLinkType=agPortCurCfgLinkType, agCurCfgMgmtNetEntry=agCurCfgMgmtNetEntry, vlagStatsPduRcvSystemInfo=vlagStatsPduRcvSystemInfo, ipRmapTableMax=ipRmapTableMax, vrrpNewCfgVirtRtrTckIpIntf=vrrpNewCfgVirtRtrTckIpIntf, aclCurCfgDstIPMask=aclCurCfgDstIPMask, lldpCurCfgPortlinkaggrtlv=lldpCurCfgPortlinkaggrtlv, ripNewCfgIntfListen=ripNewCfgIntfListen, agAccessUserNewCfgTableEntry=agAccessUserNewCfgTableEntry, dnsCurCfgFirstRequestAddr=dnsCurCfgFirstRequestAddr, agNetbootCfgFile=agNetbootCfgFile, ipsecNewCfgSelectorAction=ipsecNewCfgSelectorAction, agCfgDumpTable=agCfgDumpTable, ipStatsInUnknownProtos=ipStatsInUnknownProtos, ospf3IfInfoEncrySpi=ospf3IfInfoEncrySpi, vmapGroupNewCfgNonServerPortsTable=vmapGroupNewCfgNonServerPortsTable, ospf3NewCfgIntfEncrySpi=ospf3NewCfgIntfEncrySpi, fdbSrcTrunk=fdbSrcTrunk, swHotlinksBackupDn=swHotlinksBackupDn, vrrpNewCfgVirtRtrGrpInterval=vrrpNewCfgVirtRtrGrpInterval, ipCurCfgBootpBcastDomainServerTable=ipCurCfgBootpBcastDomainServerTable, mstCistNewCfgBridgeForwardDelay=mstCistNewCfgBridgeForwardDelay, lldpInfoRemoteDevicesRemoteTTL=lldpInfoRemoteDevicesRemoteTTL, dhcpSnoopingCurCfgOption82OnState=dhcpSnoopingCurCfgOption82OnState, sfpInfoDevice=sfpInfoDevice, aclNewCfgRemarkOutProfDscpIndex=aclNewCfgRemarkOutProfDscpIndex, ospfNewCfgRipMetric=ospfNewCfgRipMetric, igmpMrtrInfoSrcIp=igmpMrtrInfoSrcIp, lacpInfoPortActOpPortState=lacpInfoPortActOpPortState, ibmnosSfpInfoTableEntry=ibmnosSfpInfoTableEntry, udpStatsNoPorts=udpStatsNoPorts, stgStatsPortXmtCfgBpdus=stgStatsPortXmtCfgBpdus, vmapVlanNewCfgServerPortsVlanIdx=vmapVlanNewCfgServerPortsVlanIdx, ospf3NewCfgIntfEncryAuthType=ospf3NewCfgIntfEncryAuthType, radCurCfgAuthenString=radCurCfgAuthenString, ipsecNewCfgManualPolicyOutEspEncKey=ipsecNewCfgManualPolicyOutEspEncKey, acl6CurCfgIPv6NextHeader=acl6CurCfgIPv6NextHeader, mstCurCfgMaxHopCount=mstCurCfgMaxHopCount, vlagStatsPdu=vlagStatsPdu, oamInfoPortLocalState=oamInfoPortLocalState, stgCurCfgBrgHelloTime=stgCurCfgBrgHelloTime, ipCurCfgRouterID=ipCurCfgRouterID, ospfGeneralInfo=ospfGeneralInfo, cistInfoPortState=cistInfoPortState, ipCurCfgSecIntfAnycast=ipCurCfgSecIntfAnycast, bgpCurCfgGroupRemoteAddr=bgpCurCfgGroupRemoteAddr, icmpStatsInDestUnreachs=icmpStatsInDestUnreachs, ospfNewCfgRangeState=ospfNewCfgRangeState, ospf3CurCfgIntfEncryKey=ospf3CurCfgIntfEncryKey, mstCistDefaultCfg=mstCistDefaultCfg, stgNewCfgBrgMaxAge=stgNewCfgBrgMaxAge, vmapVlanCurCfgAllPortsTableEntry=vmapVlanCurCfgAllPortsTableEntry, allportsStatsOperStatus=allportsStatsOperStatus, vlagCurCfgHlthchkKeepaliveInterval=vlagCurCfgHlthchkKeepaliveInterval, ripCurCfgIntfTrigUpdate=ripCurCfgIntfTrigUpdate, ospf3CurCfgIntfAuthKey=ospf3CurCfgIntfAuthKey, ipNewCfgAlistEntry=ipNewCfgAlistEntry, ipCurCfgRmapEntry=ipCurCfgRmapEntry, agNewCfgTftpServerPort=agNewCfgTftpServerPort, virtVMwareHostDetailInfoPortGroup=virtVMwareHostDetailInfoPortGroup, pmNewCfgPmirrMirrPortIndex=pmNewCfgPmirrMirrPortIndex, ospfCurCfgAreaAuthType=ospfCurCfgAreaAuthType, ospfAreaNbrChangeStats=ospfAreaNbrChangeStats, failoverNewCfgTriggerMmonTrunkRem=failoverNewCfgTriggerMmonTrunkRem, ospfCumTxHello=ospfCumTxHello, igmpNewCfgElectionType=igmpNewCfgElectionType, vmapVlanNewCfgServerPortsVmapBitmap=vmapVlanNewCfgServerPortsVmapBitmap, agCurRFC4741NetconfSshPort=agCurRFC4741NetconfSshPort, bgpNewCfgAggrMask=bgpNewCfgAggrMask, cistInfoPortPriority=cistInfoPortPriority, agPortCurCfgVlanTag=agPortCurCfgVlanTag, igmpNewVlanOlderVerTimer=igmpNewVlanOlderVerTimer, bgpCurCfgGroupRemoteMask=bgpCurCfgGroupRemoteMask, allportsStatsOutUcast=allportsStatsOutUcast, bgpInfoSummaryRemoteAddr=bgpInfoSummaryRemoteAddr, vlagStatsIslOutOctets=vlagStatsIslOutOctets, virtCurCfgVMwareHelloTimer=virtCurCfgVMwareHelloTimer)
mibBuilder.exportSymbols("IBM-GbTOR-10G-L2L3-MIB", ospf3NewCfgConnectedRouteTagTypeManual=ospf3NewCfgConnectedRouteTagTypeManual, stgCurCfgPriority=stgCurCfgPriority, ospf3IntfDisdDatabase=ospf3IntfDisdDatabase, dhcpSnoopingStatInPacketReply=dhcpSnoopingStatInPacketReply, vmNewCfgGroupDelete=vmNewCfgGroupDelete, agNewRFC4741NetconfSessionTimeout=agNewRFC4741NetconfSessionTimeout, ripNewCfgEbgpRemoveOutRmap=ripNewCfgEbgpRemoveOutRmap, vrrpNewCfgVirtRtrState=vrrpNewCfgVirtRtrState, dhcpSnoopingBindingInfoVLAN=dhcpSnoopingBindingInfoVLAN, ospf3IntfNbrIndex=ospf3IntfNbrIndex, ibmnosFdbVlan=ibmnosFdbVlan, ospfCurCfgFixedMetric=ospfCurCfgFixedMetric, vmCurCfgGroupMacVMIndex=vmCurCfgGroupMacVMIndex, virtVMwareVMInfoUUID=virtVMwareVMInfoUUID, layer2Oper=layer2Oper, lacpInfoAggrActAdminKey=lacpInfoAggrActAdminKey, ospf3CurCfgRedistTable=ospf3CurCfgRedistTable, ospfTmrsKckOffAseExport=ospfTmrsKckOffAseExport, ipv6PmtuInfo=ipv6PmtuInfo, vmapGroupCfgServerPorts=vmapGroupCfgServerPorts, ipNewCfgBootpBcastDomainServIndex=ipNewCfgBootpBcastDomainServIndex, agCurCfgCpuRateLimitCntl=agCurCfgCpuRateLimitCntl, allportsStatsOutQLen=allportsStatsOutQLen, ipCurCfgIntfDadAttempts=ipCurCfgIntfDadAttempts, ipNewCfgGwInterval=ipNewCfgGwInterval, ipv6Fragfails=ipv6Fragfails, bgpNewCfgGroupFixedState=bgpNewCfgGroupFixedState, agNewCfgSyslogTrapOspf=agNewCfgSyslogTrapOspf, ikeCurCfgPskRemoteEntry=ikeCurCfgPskRemoteEntry, lldpNewCfgPortportdesctlv=lldpNewCfgPortportdesctlv, dhcpSnoopingNewCfgOnState=dhcpSnoopingNewCfgOnState, ripRouteRedistribution=ripRouteRedistribution, bgpCurCfgGroupFixedState=bgpCurCfgGroupFixedState, ipsecCurCfgManualPolicyInEspAuthKey=ipsecCurCfgManualPolicyInEspAuthKey, ospf3CumIntfBackup=ospf3CumIntfBackup, agPortNewCfgBroadcastThresholdRate=agPortNewCfgBroadcastThresholdRate, dnsNewCfgDomainName=dnsNewCfgDomainName, agCurCfgSysCustomDstStart=agCurCfgSysCustomDstStart, vlanInfoTable=vlanInfoTable, tcpControlBlocksIndx=tcpControlBlocksIndx, ospfRedistributeEbgp=ospfRedistributeEbgp, ospf3CurCfgVirtIntfEntry=ospf3CurCfgVirtIntfEntry, ospf3IntfRxPkts=ospf3IntfRxPkts, rip2InfoIntfTable=rip2InfoIntfTable, agSoftwareVersion=agSoftwareVersion, ospfRedistributeStatic=ospfRedistributeStatic, stgNewCfgIndex=stgNewCfgIndex, lldpInfo=lldpInfo, ipNewCfgStaticRoute6Action=ipNewCfgStaticRoute6Action, vrrpInfoVirtRtrOwnership=vrrpInfoVirtRtrOwnership, igmpFltNewCfgTable=igmpFltNewCfgTable, ospf3IntfNbrExchange=ospf3IntfNbrExchange, ipsecSaStatsIndex=ipsecSaStatsIndex, ibmnosPortTableMaxEnt=ibmnosPortTableMaxEnt, ripCurCfgIntfIndex=ripCurCfgIntfIndex, bgpCurCfgGroupRipState=bgpCurCfgGroupRipState, agApplyTableEntry=agApplyTableEntry, fipsInfoPortEntry=fipsInfoPortEntry, virtNewCfgVMwareHelloPorts=virtNewCfgVMwareHelloPorts, vmapGroupNewCfgNonServerPortsGroupIdx=vmapGroupNewCfgNonServerPortsGroupIdx, bgpInfoDynamicMinAdvTime=bgpInfoDynamicMinAdvTime, trunkGroupNewCfgAddPort=trunkGroupNewCfgAddPort, ipCurCfgIntfEntry=ipCurCfgIntfEntry, ospf3CurCfgIntfHello=ospf3CurCfgIntfHello, lacpCurSystemTimeoutTime=lacpCurSystemTimeoutTime, ipMgmtRouteInfoMetric=ipMgmtRouteInfoMetric, ospf3NewCfgRangeIndex=ospf3NewCfgRangeIndex, bgpNewCfgPeerRipState=bgpNewCfgPeerRipState, ospf3CurCfgNbrState=ospf3CurCfgNbrState, ospf3AreaTxDatabase=ospf3AreaTxDatabase, tacCurCfgCmap=tacCurCfgCmap, stpInfoRootCost=stpInfoRootCost, ospfRoutesInfoIndex=ospfRoutesInfoIndex, ospfNewCfgIntfCost=ospfNewCfgIntfCost, aclNewCfgTypeOfService=aclNewCfgTypeOfService, ospfRouteRedistribution=ospfRouteRedistribution, gatewayIPv6InfoTable=gatewayIPv6InfoTable, mldStatInvalidPkts=mldStatInvalidPkts, ospf3IfInfoLsaSupress=ospf3IfInfoLsaSupress, sourceAddr=sourceAddr, vmNewCfgGroupAddLacpKey=vmNewCfgGroupAddLacpKey, udldInfoNeighborDeviceID=udldInfoNeighborDeviceID, bgpInfoGroupIndex=bgpInfoGroupIndex, ipv6icmpOutNeighSol=ipv6icmpOutNeighSol, ospf3RoutesInfoTable=ospf3RoutesInfoTable, ipsecSaInfoMode=ipsecSaInfoMode, ospfAreaNbrRstAd=ospfAreaNbrRstAd, ipmcCurCfgStaticRouteTable=ipmcCurCfgStaticRouteTable, ospfCurCfgIntfPassive=ospfCurCfgIntfPassive, errMldIfStatsMASQuery=errMldIfStatsMASQuery, portInfoBpduGuard=portInfoBpduGuard, bgpNewCfgPeerTtlSecHops=bgpNewCfgPeerTtlSecHops, virtVMware=virtVMware, stpInfo=stpInfo, mstCistNewCfgPortPathCost=mstCistNewCfgPortPathCost, ndprefixNewCfgState=ndprefixNewCfgState, agPortCurCfgPortName=agPortCurCfgPortName, lacpInfoAggrIndex=lacpInfoAggrIndex, agNewCfgNTPResyncInterval=agNewCfgNTPResyncInterval, ipsecNewCfgTxformDelete=ipsecNewCfgTxformDelete, bgpNewCfgGroupAdvert=bgpNewCfgGroupAdvert, serverPortsNewCfgAddPort=serverPortsNewCfgAddPort, ipCurCfgIntfTable=ipCurCfgIntfTable, sflowCurCfgMgmtPort=sflowCurCfgMgmtPort, pktStatsJumbos=pktStatsJumbos, txMldIfStatsMLDv1Report=txMldIfStatsMLDv1Report, vlan=vlan, ospfLsTypesSupported=ospfLsTypesSupported, fdbNewCfgAddPort=fdbNewCfgAddPort, vrrpCfg=vrrpCfg, aclNewCfgVLanMask=aclNewCfgVLanMask, udpMpLocalPort=udpMpLocalPort, fipsOperFcfDelete=fipsOperFcfDelete, pktStatsJumbosHiWatermark=pktStatsJumbosHiWatermark)

#
# PySNMP MIB module JUNIPER-PFE-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/JUNIPER-PFE-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:00:43 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ValueRangeConstraint, ConstraintsUnion, ValueSizeConstraint, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ValueRangeConstraint", "ConstraintsUnion", "ValueSizeConstraint", "SingleValueConstraint")
jnxPfeMibRoot, = mibBuilder.importSymbols("JUNIPER-SMI", "jnxPfeMibRoot")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
TimeTicks, IpAddress, Integer32, ObjectIdentity, ModuleIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, MibIdentifier, Counter64, Counter32, NotificationType, Unsigned32, Gauge32, iso, Bits = mibBuilder.importSymbols("SNMPv2-SMI", "TimeTicks", "IpAddress", "Integer32", "ObjectIdentity", "ModuleIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "MibIdentifier", "Counter64", "Counter32", "NotificationType", "Unsigned32", "Gauge32", "iso", "Bits")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
jnxPfeMib = ModuleIdentity((1, 3, 6, 1, 4, 1, 2636, 3, 44, 1))
jnxPfeMib.setRevisions(('2014-11-14 00:00', '2014-03-12 00:00', '2011-09-09 00:00', '2010-02-07 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: jnxPfeMib.setRevisionsDescriptions(('Added jnxPfeMemoryTrapVars and jnxPfeMemoryNotifications.', 'Added new Table jnxPfeNotifyGlParAccSec which counts notifications for the packets parsed/processed by access-security.', 'Added new Table jnxPfeMemoryErrorsTable which gives parity and ecc errors. Added new Trap pfeMemoryErrors', 'Added new notification types.',))
if mibBuilder.loadTexts: jnxPfeMib.setLastUpdated('201109220000Z')
if mibBuilder.loadTexts: jnxPfeMib.setOrganization('Juniper Networks, Inc.')
if mibBuilder.loadTexts: jnxPfeMib.setContactInfo(' Juniper Technical Assistance Center Juniper Networks, Inc. 1194 N. Mathilda Avenue Sunnyvale, CA 94089 E-mail: support@juniper.net')
if mibBuilder.loadTexts: jnxPfeMib.setDescription('The MIB provides PFE specific data.')
class JnxPfeMemoryTypeEnum(TextualConvention, Integer32):
    description = 'PFE memory type, nh (1), fw (2), encap (3)'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("nh", 1), ("fw", 2), ("encap", 3))

jnxPfeNotification = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 44, 1, 1))
jnxPfeNotifyGlTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 44, 1, 1, 1), )
if mibBuilder.loadTexts: jnxPfeNotifyGlTable.setStatus('current')
if mibBuilder.loadTexts: jnxPfeNotifyGlTable.setDescription('This table provides global PFE notification statistics.')
jnxPfeNotifyGlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 44, 1, 1, 1, 1), ).setIndexNames((0, "JUNIPER-PFE-MIB", "jnxPfeNotifyGlSlot"))
if mibBuilder.loadTexts: jnxPfeNotifyGlEntry.setStatus('current')
if mibBuilder.loadTexts: jnxPfeNotifyGlEntry.setDescription('')
jnxPfeNotifyGlSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 44, 1, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)))
if mibBuilder.loadTexts: jnxPfeNotifyGlSlot.setStatus('current')
if mibBuilder.loadTexts: jnxPfeNotifyGlSlot.setDescription('The PFE slot number for this set of global PFE notification statistics.')
jnxPfeNotifyGlParsed = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 44, 1, 1, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPfeNotifyGlParsed.setStatus('current')
if mibBuilder.loadTexts: jnxPfeNotifyGlParsed.setDescription('Count of notifications reported by the routing chip.')
jnxPfeNotifyGlAged = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 44, 1, 1, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPfeNotifyGlAged.setStatus('current')
if mibBuilder.loadTexts: jnxPfeNotifyGlAged.setDescription('Count of notifications that are dropped due to the fact that the they have been in the system for too long and hence not valid anymore.')
jnxPfeNotifyGlCorrupt = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 44, 1, 1, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPfeNotifyGlCorrupt.setStatus('current')
if mibBuilder.loadTexts: jnxPfeNotifyGlCorrupt.setDescription('Count of notifications dropped due to the fact that they have an invalid notification result format. This counter is valid for Internet Processor-I and Internet Processor-II only.')
jnxPfeNotifyGlIllegal = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 44, 1, 1, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPfeNotifyGlIllegal.setStatus('current')
if mibBuilder.loadTexts: jnxPfeNotifyGlIllegal.setDescription('Count of notifications dropped due to the fact that they have an illegal notification type.')
jnxPfeNotifyGlSample = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 44, 1, 1, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPfeNotifyGlSample.setStatus('current')
if mibBuilder.loadTexts: jnxPfeNotifyGlSample.setDescription('Count of sample notifications reported by the routing chip.')
jnxPfeNotifyGlGiants = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 44, 1, 1, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPfeNotifyGlGiants.setStatus('current')
if mibBuilder.loadTexts: jnxPfeNotifyGlGiants.setDescription('Count of notifications dropped that are larger than the supported DMA size.')
jnxPfeNotifyGlTtlExceeded = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 44, 1, 1, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPfeNotifyGlTtlExceeded.setStatus('current')
if mibBuilder.loadTexts: jnxPfeNotifyGlTtlExceeded.setDescription('Count of options/TTL-expired notifications that need to be sent to service interfaces as transit packets. This counter is valid for Internet Processor-I and Internet Processor-II only.')
jnxPfeNotifyGlTtlExcErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 44, 1, 1, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPfeNotifyGlTtlExcErrors.setStatus('current')
if mibBuilder.loadTexts: jnxPfeNotifyGlTtlExcErrors.setDescription('Count of options/TTL-expired packet notifications that could not be sent as transit packets because the output interface could not be determined. This counter is valid for Internet Processor-I and Internet Processor-II only.')
jnxPfeNotifyGlSvcOptAsp = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 44, 1, 1, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPfeNotifyGlSvcOptAsp.setStatus('current')
if mibBuilder.loadTexts: jnxPfeNotifyGlSvcOptAsp.setDescription('Count of IP options packets that are sent out to a Services PIC.')
jnxPfeNotifyGlSvcOptRe = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 44, 1, 1, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPfeNotifyGlSvcOptRe.setStatus('current')
if mibBuilder.loadTexts: jnxPfeNotifyGlSvcOptRe.setDescription('Count of IP options packets that are sent out to the Routing Engine.')
jnxPfeNotifyGlPostSvcOptOut = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 44, 1, 1, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPfeNotifyGlPostSvcOptOut.setStatus('current')
if mibBuilder.loadTexts: jnxPfeNotifyGlPostSvcOptOut.setDescription('Count of notifications that were re-injected by the services PIC after it had processed the associated packets. These notifications now need to be forwarded out to their actual destination. This counter is valid for Internet Processor-I and Internet Processor-II only.')
jnxPfeNotifyGlOptTtlExp = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 44, 1, 1, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPfeNotifyGlOptTtlExp.setStatus('current')
if mibBuilder.loadTexts: jnxPfeNotifyGlOptTtlExp.setDescription('Count of TTL-expired transit packets.')
jnxPfeNotifyGlDiscSample = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 44, 1, 1, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPfeNotifyGlDiscSample.setStatus('current')
if mibBuilder.loadTexts: jnxPfeNotifyGlDiscSample.setDescription('Count of sample notifications that are dropped as they refer to discarded packets in PFE.')
jnxPfeNotifyGlRateLimited = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 44, 1, 1, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPfeNotifyGlRateLimited.setStatus('current')
if mibBuilder.loadTexts: jnxPfeNotifyGlRateLimited.setDescription('Count of notifications ignored because of PFE software throttling.')
jnxPfeNotifyGlPktGetFails = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 44, 1, 1, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPfeNotifyGlPktGetFails.setStatus('current')
if mibBuilder.loadTexts: jnxPfeNotifyGlPktGetFails.setDescription('Count of notifications where we could not allocate memory for DMA.')
jnxPfeNotifyGlDmaFails = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 44, 1, 1, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPfeNotifyGlDmaFails.setStatus('current')
if mibBuilder.loadTexts: jnxPfeNotifyGlDmaFails.setDescription('Count of notifications where the DMA of associated packets failed for miscellaneous reasons. Valid for T-series Internet Processor only.')
jnxPfeNotifyGlDmaTotals = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 44, 1, 1, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPfeNotifyGlDmaTotals.setStatus('current')
if mibBuilder.loadTexts: jnxPfeNotifyGlDmaTotals.setDescription('Count of notifications for which the packet DMA completed. Valid for T-series Internet Processor only.')
jnxPfeNotifyGlUnknowns = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 44, 1, 1, 1, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPfeNotifyGlUnknowns.setStatus('current')
if mibBuilder.loadTexts: jnxPfeNotifyGlUnknowns.setDescription('Count of notifications that could not be resolved to a known next hop destination. Valid for T-series Internet Processor only.')
jnxPfeNotifyGlParAccSec = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 44, 1, 1, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPfeNotifyGlParAccSec.setStatus('current')
if mibBuilder.loadTexts: jnxPfeNotifyGlParAccSec.setDescription('Count of notifications for the packets parsed/processed by access-security.')
jnxPfeNotifyTypeTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 44, 1, 1, 2), )
if mibBuilder.loadTexts: jnxPfeNotifyTypeTable.setStatus('current')
if mibBuilder.loadTexts: jnxPfeNotifyTypeTable.setDescription('This provides type-specific PFE notification stats')
jnxPfeNotifyTypeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 44, 1, 1, 2, 1), ).setIndexNames((0, "JUNIPER-PFE-MIB", "jnxPfeNotifyGlSlot"), (0, "JUNIPER-PFE-MIB", "jnxPfeNotifyTypeId"))
if mibBuilder.loadTexts: jnxPfeNotifyTypeEntry.setStatus('current')
if mibBuilder.loadTexts: jnxPfeNotifyTypeEntry.setDescription('')
jnxPfeNotifyTypeId = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 44, 1, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14))).clone(namedValues=NamedValues(("illegal", 1), ("unclassified", 2), ("option", 3), ("nextHop", 4), ("discard", 5), ("sample", 6), ("redirect", 7), ("dontFragment", 8), ("cfdf", 9), ("poison", 10), ("unknown", 11), ("specialMemPkt", 12), ("autoConfig", 13), ("reject", 14))))
if mibBuilder.loadTexts: jnxPfeNotifyTypeId.setStatus('current')
if mibBuilder.loadTexts: jnxPfeNotifyTypeId.setDescription("This identifies the PFE notification type for this row's stats. Below is a description of each notification type: 1. illegal Packets with invalid notification type. 2. unclassified Packets that did not have a key lookup performed on them. 3. option Packets which have L3 options present. 4. nextHop Packets that are destined to the host. 5. discard Used when a discarded packet is sent to the route processor. 6. sample Unused. 7. redirect This is used when a packet is being sent out on the interface it came in on. 8. dontFragment This is used that a packet needs to be fragmented but the DF (don't fragment) bit is set. 9. cfdf When an MTU exceeded indication is triggered by the CF chip and the packet has DF (don't fragment) set. 10. poison Packets that resolved to a poisoned next hop index. 11. unknown Packets of unknown notification type. 12. specialMemPkt Packets with special memory pkt type notification used in diagnostics. 13. autoconfig Packets with autoconfig PFE notification type used for dynamic VLANs. 14. reject Packets of reject PFE notification type.")
jnxPfeNotifyTypeDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 44, 1, 1, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPfeNotifyTypeDescr.setStatus('current')
if mibBuilder.loadTexts: jnxPfeNotifyTypeDescr.setDescription('The description of the Pfe Notification type for this entry.')
jnxPfeNotifyTypeParsed = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 44, 1, 1, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPfeNotifyTypeParsed.setStatus('current')
if mibBuilder.loadTexts: jnxPfeNotifyTypeParsed.setDescription('Count of successful parsing of notifications.')
jnxPfeNotifyTypeInput = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 44, 1, 1, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPfeNotifyTypeInput.setStatus('current')
if mibBuilder.loadTexts: jnxPfeNotifyTypeInput.setDescription("Count of notifications whose associated packets were DMA'ed into route processor memory.")
jnxPfeNotifyTypeFailed = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 44, 1, 1, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPfeNotifyTypeFailed.setStatus('current')
if mibBuilder.loadTexts: jnxPfeNotifyTypeFailed.setDescription('Count of failures in parsing the notifications.')
jnxPfeNotifyTypeIgnored = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 44, 1, 1, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPfeNotifyTypeIgnored.setStatus('current')
if mibBuilder.loadTexts: jnxPfeNotifyTypeIgnored.setDescription('Count of notifications where the notification type in the message does not match any of the valid types.')
jnxPfeMemoryErrorsTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 44, 1, 1, 3), )
if mibBuilder.loadTexts: jnxPfeMemoryErrorsTable.setStatus('current')
if mibBuilder.loadTexts: jnxPfeMemoryErrorsTable.setDescription('This provides PFE memory errors')
jnxPfeMemoryErrorsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 44, 1, 1, 3, 1), ).setIndexNames((0, "JUNIPER-PFE-MIB", "jnxPfeFpcSlot"), (0, "JUNIPER-PFE-MIB", "jnxPfeSlot"))
if mibBuilder.loadTexts: jnxPfeMemoryErrorsEntry.setStatus('current')
if mibBuilder.loadTexts: jnxPfeMemoryErrorsEntry.setDescription('')
jnxPfeFpcSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 44, 1, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)))
if mibBuilder.loadTexts: jnxPfeFpcSlot.setStatus('current')
if mibBuilder.loadTexts: jnxPfeFpcSlot.setDescription('The FPC slot number for this set of PFE notification')
jnxPfeSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 44, 1, 1, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)))
if mibBuilder.loadTexts: jnxPfeSlot.setStatus('current')
if mibBuilder.loadTexts: jnxPfeSlot.setDescription('The pfe slot number for this set of errors')
jnxPfeParityErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 44, 1, 1, 3, 1, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPfeParityErrors.setStatus('current')
if mibBuilder.loadTexts: jnxPfeParityErrors.setDescription('The parity error count')
jnxPfeEccErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 44, 1, 1, 3, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPfeEccErrors.setStatus('current')
if mibBuilder.loadTexts: jnxPfeEccErrors.setDescription('The ECC error count')
pfeMemoryErrorsNotificationPrefix = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 44, 1, 1, 0))
pfeMemoryErrors = NotificationType((1, 3, 6, 1, 4, 1, 2636, 3, 44, 1, 1, 0, 1)).setObjects(("JUNIPER-PFE-MIB", "jnxPfeParityErrors"), ("JUNIPER-PFE-MIB", "jnxPfeEccErrors"))
if mibBuilder.loadTexts: pfeMemoryErrors.setStatus('current')
if mibBuilder.loadTexts: pfeMemoryErrors.setDescription('A pfeMemoryErrors notification is sent when the value of jnxPfeParityErrors or jnxPfeEccErrors increases.')
jnxPfeMemory = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 44, 1, 2))
jnxPfeMemoryUkernTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 44, 1, 2, 1), )
if mibBuilder.loadTexts: jnxPfeMemoryUkernTable.setStatus('current')
if mibBuilder.loadTexts: jnxPfeMemoryUkernTable.setDescription('This table provides global PFE ukern memory statistics for specified slot.')
jnxPfeMemoryUkernEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 44, 1, 2, 1, 1), ).setIndexNames((0, "JUNIPER-PFE-MIB", "jnxPfeGlSlot"))
if mibBuilder.loadTexts: jnxPfeMemoryUkernEntry.setStatus('current')
if mibBuilder.loadTexts: jnxPfeMemoryUkernEntry.setDescription('Entry represent ukern memory percentage free.')
jnxPfeMemoryUkernFreePercent = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 44, 1, 2, 1, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setUnits('percent').setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPfeMemoryUkernFreePercent.setStatus('current')
if mibBuilder.loadTexts: jnxPfeMemoryUkernFreePercent.setDescription('The percent PFE ukern memory free within ukern heap.')
jnxPfeMemoryForwardingTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 44, 1, 2, 2), )
if mibBuilder.loadTexts: jnxPfeMemoryForwardingTable.setStatus('current')
if mibBuilder.loadTexts: jnxPfeMemoryForwardingTable.setDescription('This table provides PFE ASIC memory - NH/JTREE or FW/Filter or Encap memory utilization statistics.')
jnxPfeMemoryForwardingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 44, 1, 2, 2, 1), ).setIndexNames((0, "JUNIPER-PFE-MIB", "jnxPfeGlSlot"), (0, "JUNIPER-PFE-MIB", "jnxPfeMemoryForwardingChipSlot"), (0, "JUNIPER-PFE-MIB", "jnxPfeMemoryType"))
if mibBuilder.loadTexts: jnxPfeMemoryForwardingEntry.setStatus('current')
if mibBuilder.loadTexts: jnxPfeMemoryForwardingEntry.setDescription('Entry represent ASIC memory free percent of a specific type in specified pfe instance')
jnxPfeMemoryForwardingChipSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 44, 1, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3)))
if mibBuilder.loadTexts: jnxPfeMemoryForwardingChipSlot.setStatus('current')
if mibBuilder.loadTexts: jnxPfeMemoryForwardingChipSlot.setDescription('ASIC instance number or pfe complex instance number.')
jnxPfeMemoryType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 44, 1, 2, 2, 1, 2), JnxPfeMemoryTypeEnum())
if mibBuilder.loadTexts: jnxPfeMemoryType.setStatus('current')
if mibBuilder.loadTexts: jnxPfeMemoryType.setDescription('PFE ASIC memory type, nh = 1, fw = 2, encap = 3.')
jnxPfeMemoryForwardingPercentFree = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 44, 1, 2, 2, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setUnits('percent').setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPfeMemoryForwardingPercentFree.setStatus('current')
if mibBuilder.loadTexts: jnxPfeMemoryForwardingPercentFree.setDescription('Percentage ASIC memory free for a specific memory type. For Trio based linecards Encap memory is not available.Hence no value is returned')
jnxPfeMemoryTrapVars = ObjectIdentity((1, 3, 6, 1, 4, 1, 2636, 3, 44, 1, 2, 3))
if mibBuilder.loadTexts: jnxPfeMemoryTrapVars.setStatus('current')
if mibBuilder.loadTexts: jnxPfeMemoryTrapVars.setDescription('PFE notification object definitions.')
jnxPfeGlSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 44, 1, 2, 3, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: jnxPfeGlSlot.setStatus('current')
if mibBuilder.loadTexts: jnxPfeGlSlot.setDescription('Global slot number for line card resource monitoring.')
jnxPfeInstanceNumber = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 44, 1, 2, 3, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: jnxPfeInstanceNumber.setStatus('current')
if mibBuilder.loadTexts: jnxPfeInstanceNumber.setDescription('PFE instance number in pfe complex.')
jnxPfeMemoryThreshold = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 44, 1, 2, 3, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setUnits('percent').setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: jnxPfeMemoryThreshold.setStatus('current')
if mibBuilder.loadTexts: jnxPfeMemoryThreshold.setDescription('Configured high memory utilization threshold.')
jnxPfeMemoryNotificationsPrefix = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 44, 1, 2, 4))
jnxPfeMemoryNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 44, 1, 2, 4, 0))
jnxPfeHeapMemoryThresholdExceeded = NotificationType((1, 3, 6, 1, 4, 1, 2636, 3, 44, 1, 2, 4, 0, 1)).setObjects(("JUNIPER-PFE-MIB", "jnxPfeGlSlot"), ("JUNIPER-PFE-MIB", "jnxPfeMemoryThreshold"))
if mibBuilder.loadTexts: jnxPfeHeapMemoryThresholdExceeded.setStatus('current')
if mibBuilder.loadTexts: jnxPfeHeapMemoryThresholdExceeded.setDescription('Indicates that the Heap Memory utilization has crossed the configured watermark.')
jnxPfeHeapMemoryThresholdAbated = NotificationType((1, 3, 6, 1, 4, 1, 2636, 3, 44, 1, 2, 4, 0, 2)).setObjects(("JUNIPER-PFE-MIB", "jnxPfeGlSlot"), ("JUNIPER-PFE-MIB", "jnxPfeMemoryThreshold"))
if mibBuilder.loadTexts: jnxPfeHeapMemoryThresholdAbated.setStatus('current')
if mibBuilder.loadTexts: jnxPfeHeapMemoryThresholdAbated.setDescription('Indicates that the Heap Memory utilization has fallen below the configured watermark.')
jnxPfeNextHopMemoryThresholdExceeded = NotificationType((1, 3, 6, 1, 4, 1, 2636, 3, 44, 1, 2, 4, 0, 3)).setObjects(("JUNIPER-PFE-MIB", "jnxPfeGlSlot"), ("JUNIPER-PFE-MIB", "jnxPfeInstanceNumber"), ("JUNIPER-PFE-MIB", "jnxPfeMemoryThreshold"))
if mibBuilder.loadTexts: jnxPfeNextHopMemoryThresholdExceeded.setStatus('current')
if mibBuilder.loadTexts: jnxPfeNextHopMemoryThresholdExceeded.setDescription('Indicates that the Next Hop Memory utilization has crossed the configured watermark.')
jnxPfeNextHopMemoryThresholdAbated = NotificationType((1, 3, 6, 1, 4, 1, 2636, 3, 44, 1, 2, 4, 0, 4)).setObjects(("JUNIPER-PFE-MIB", "jnxPfeGlSlot"), ("JUNIPER-PFE-MIB", "jnxPfeInstanceNumber"), ("JUNIPER-PFE-MIB", "jnxPfeMemoryThreshold"))
if mibBuilder.loadTexts: jnxPfeNextHopMemoryThresholdAbated.setStatus('current')
if mibBuilder.loadTexts: jnxPfeNextHopMemoryThresholdAbated.setDescription('Indicates that the Next Hop Memory utilization has fallen below the configured watermark.')
jnxPfeFilterMemoryThresholdExceeded = NotificationType((1, 3, 6, 1, 4, 1, 2636, 3, 44, 1, 2, 4, 0, 5)).setObjects(("JUNIPER-PFE-MIB", "jnxPfeGlSlot"), ("JUNIPER-PFE-MIB", "jnxPfeInstanceNumber"), ("JUNIPER-PFE-MIB", "jnxPfeMemoryThreshold"))
if mibBuilder.loadTexts: jnxPfeFilterMemoryThresholdExceeded.setStatus('current')
if mibBuilder.loadTexts: jnxPfeFilterMemoryThresholdExceeded.setDescription('Indicates that the Filter Memory utilization has crossed the configured watermark.')
jnxPfeFilterMemoryThresholdAbated = NotificationType((1, 3, 6, 1, 4, 1, 2636, 3, 44, 1, 2, 4, 0, 6)).setObjects(("JUNIPER-PFE-MIB", "jnxPfeGlSlot"), ("JUNIPER-PFE-MIB", "jnxPfeInstanceNumber"), ("JUNIPER-PFE-MIB", "jnxPfeMemoryThreshold"))
if mibBuilder.loadTexts: jnxPfeFilterMemoryThresholdAbated.setStatus('current')
if mibBuilder.loadTexts: jnxPfeFilterMemoryThresholdAbated.setDescription('Indicates that the Filter Memory utilization has fallen below the configured watermark.')
jnxPfeEncapMemoryThresholdExceeded = NotificationType((1, 3, 6, 1, 4, 1, 2636, 3, 44, 1, 2, 4, 0, 7)).setObjects(("JUNIPER-PFE-MIB", "jnxPfeGlSlot"), ("JUNIPER-PFE-MIB", "jnxPfeInstanceNumber"), ("JUNIPER-PFE-MIB", "jnxPfeMemoryThreshold"))
if mibBuilder.loadTexts: jnxPfeEncapMemoryThresholdExceeded.setStatus('current')
if mibBuilder.loadTexts: jnxPfeEncapMemoryThresholdExceeded.setDescription('Indicates that the ENCAP Memory utilization has crossed the configured watermark.')
jnxPfeEncapMemoryThresholdAbated = NotificationType((1, 3, 6, 1, 4, 1, 2636, 3, 44, 1, 2, 4, 0, 8)).setObjects(("JUNIPER-PFE-MIB", "jnxPfeGlSlot"), ("JUNIPER-PFE-MIB", "jnxPfeInstanceNumber"), ("JUNIPER-PFE-MIB", "jnxPfeMemoryThreshold"))
if mibBuilder.loadTexts: jnxPfeEncapMemoryThresholdAbated.setStatus('current')
if mibBuilder.loadTexts: jnxPfeEncapMemoryThresholdAbated.setDescription('Indicates that the ENCAP Memory utilization has fallen below the configured watermark.')
mibBuilder.exportSymbols("JUNIPER-PFE-MIB", jnxPfeNotifyTypeTable=jnxPfeNotifyTypeTable, jnxPfeNotifyGlTtlExcErrors=jnxPfeNotifyGlTtlExcErrors, jnxPfeFpcSlot=jnxPfeFpcSlot, jnxPfeNotifyTypeEntry=jnxPfeNotifyTypeEntry, jnxPfeMemoryUkernFreePercent=jnxPfeMemoryUkernFreePercent, jnxPfeEncapMemoryThresholdExceeded=jnxPfeEncapMemoryThresholdExceeded, jnxPfeMemoryNotifications=jnxPfeMemoryNotifications, jnxPfeNotifyGlSlot=jnxPfeNotifyGlSlot, jnxPfeNotifyTypeIgnored=jnxPfeNotifyTypeIgnored, jnxPfeMemoryForwardingEntry=jnxPfeMemoryForwardingEntry, jnxPfeSlot=jnxPfeSlot, jnxPfeMemoryType=jnxPfeMemoryType, jnxPfeMib=jnxPfeMib, jnxPfeNotifyGlOptTtlExp=jnxPfeNotifyGlOptTtlExp, jnxPfeMemoryUkernTable=jnxPfeMemoryUkernTable, PYSNMP_MODULE_ID=jnxPfeMib, jnxPfeNotifyGlAged=jnxPfeNotifyGlAged, pfeMemoryErrors=pfeMemoryErrors, jnxPfeMemoryTrapVars=jnxPfeMemoryTrapVars, jnxPfeNotifyTypeDescr=jnxPfeNotifyTypeDescr, jnxPfeMemoryErrorsEntry=jnxPfeMemoryErrorsEntry, jnxPfeFilterMemoryThresholdExceeded=jnxPfeFilterMemoryThresholdExceeded, jnxPfeNotifyGlCorrupt=jnxPfeNotifyGlCorrupt, jnxPfeNextHopMemoryThresholdAbated=jnxPfeNextHopMemoryThresholdAbated, jnxPfeNotifyGlPktGetFails=jnxPfeNotifyGlPktGetFails, jnxPfeNotifyGlGiants=jnxPfeNotifyGlGiants, jnxPfeNotifyGlDiscSample=jnxPfeNotifyGlDiscSample, jnxPfeNotifyTypeParsed=jnxPfeNotifyTypeParsed, jnxPfeMemoryForwardingChipSlot=jnxPfeMemoryForwardingChipSlot, jnxPfeHeapMemoryThresholdExceeded=jnxPfeHeapMemoryThresholdExceeded, jnxPfeMemoryNotificationsPrefix=jnxPfeMemoryNotificationsPrefix, jnxPfeEccErrors=jnxPfeEccErrors, jnxPfeNotifyTypeFailed=jnxPfeNotifyTypeFailed, jnxPfeMemoryErrorsTable=jnxPfeMemoryErrorsTable, jnxPfeNotifyGlUnknowns=jnxPfeNotifyGlUnknowns, jnxPfeNotifyGlSvcOptAsp=jnxPfeNotifyGlSvcOptAsp, JnxPfeMemoryTypeEnum=JnxPfeMemoryTypeEnum, jnxPfeNextHopMemoryThresholdExceeded=jnxPfeNextHopMemoryThresholdExceeded, jnxPfeNotifyGlDmaFails=jnxPfeNotifyGlDmaFails, jnxPfeGlSlot=jnxPfeGlSlot, jnxPfeHeapMemoryThresholdAbated=jnxPfeHeapMemoryThresholdAbated, jnxPfeNotification=jnxPfeNotification, jnxPfeNotifyGlTable=jnxPfeNotifyGlTable, jnxPfeNotifyGlParAccSec=jnxPfeNotifyGlParAccSec, jnxPfeFilterMemoryThresholdAbated=jnxPfeFilterMemoryThresholdAbated, jnxPfeParityErrors=jnxPfeParityErrors, jnxPfeNotifyGlSvcOptRe=jnxPfeNotifyGlSvcOptRe, jnxPfeMemoryForwardingTable=jnxPfeMemoryForwardingTable, jnxPfeNotifyGlSample=jnxPfeNotifyGlSample, jnxPfeNotifyGlParsed=jnxPfeNotifyGlParsed, jnxPfeNotifyGlIllegal=jnxPfeNotifyGlIllegal, jnxPfeMemoryForwardingPercentFree=jnxPfeMemoryForwardingPercentFree, jnxPfeEncapMemoryThresholdAbated=jnxPfeEncapMemoryThresholdAbated, jnxPfeNotifyTypeInput=jnxPfeNotifyTypeInput, jnxPfeNotifyGlEntry=jnxPfeNotifyGlEntry, jnxPfeNotifyGlDmaTotals=jnxPfeNotifyGlDmaTotals, jnxPfeMemoryUkernEntry=jnxPfeMemoryUkernEntry, jnxPfeNotifyGlTtlExceeded=jnxPfeNotifyGlTtlExceeded, jnxPfeNotifyGlRateLimited=jnxPfeNotifyGlRateLimited, jnxPfeInstanceNumber=jnxPfeInstanceNumber, jnxPfeMemoryThreshold=jnxPfeMemoryThreshold, jnxPfeNotifyGlPostSvcOptOut=jnxPfeNotifyGlPostSvcOptOut, pfeMemoryErrorsNotificationPrefix=pfeMemoryErrorsNotificationPrefix, jnxPfeNotifyTypeId=jnxPfeNotifyTypeId, jnxPfeMemory=jnxPfeMemory)

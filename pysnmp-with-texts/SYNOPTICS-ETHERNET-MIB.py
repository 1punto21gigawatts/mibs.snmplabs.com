#
# PySNMP MIB module SYNOPTICS-ETHERNET-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/SYNOPTICS-ETHERNET-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:14:14 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint, ConstraintsIntersection, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint", "ConstraintsIntersection", "ValueSizeConstraint")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Unsigned32, MibScalar, MibTable, MibTableRow, MibTableColumn, Gauge32, Integer32, NotificationType, Counter64, IpAddress, Counter32, ModuleIdentity, TimeTicks, ObjectIdentity, MibIdentifier, iso, Bits = mibBuilder.importSymbols("SNMPv2-SMI", "Unsigned32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Gauge32", "Integer32", "NotificationType", "Counter64", "IpAddress", "Counter32", "ModuleIdentity", "TimeTicks", "ObjectIdentity", "MibIdentifier", "iso", "Bits")
PhysAddress, TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "PhysAddress", "TextualConvention", "DisplayString")
S3ModuleType, s3000Ethernet = mibBuilder.importSymbols("SYNOPTICS-COMMON-MIB", "S3ModuleType", "s3000Ethernet")
SnpxBackplaneType, SnpxChassisType = mibBuilder.importSymbols("SYNOPTICS-ROOT-MIB", "SnpxBackplaneType", "SnpxChassisType")
s3000EnetConcentrator = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 1))
s3000EnetBoard = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 2))
s3000EnetLocBridge = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 2, 2))
s3000EnetRemBridge = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 2, 3))
s3000EnetRouter = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 2, 4))
s3000EnetPort = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 3))
s3000EnetNmm = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 4))
s3000EnetNode = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 5))
s3000EnetTopology = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 6))
s3000EnetNmmTopology = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 6, 1))
s3000EnetBridTopology = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 6, 2))
s3000EnetTopInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 6, 3))
s3000EnetThreshold = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 8))
s3000EnetSADATraffic = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 9))
s3000EnetPlusStatistics = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 10))
s3000EnetPlusConc = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 10, 3))
s3000EnetFrameSizeDist = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 11))
s3000EnetFrameConc = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 11, 3))
s3000EnetProtoTypeDist = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 12))
s3000EnetProtoConc = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 12, 3))
s3000EnetHosts = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 13))
s3EnetConcRetimingStatus = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3EnetConcRetimingStatus.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetConcRetimingStatus.setDescription('Does this concentrator have retiming turned on. Writing a 1 will turn off retiming and writing a 2 will turn on retiming. This will change the active state of retiming but will change the value in EEPROM only when agentWriteEeprom is set.The factory default of this state is on. Retiming cannot be disabled in the 2810 concentrator. The 2810 agent will implement this object as read-only.')
s3EnetConcFrmsRxOk = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetConcFrmsRxOk.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetConcFrmsRxOk.setDescription('This contains a count of frames that are successfully received by the concentrator. This does not include frames received with a frame-too-long, runt, FCS, or alignment errors. This counter includes broadcast and multicast frames that are received.')
s3EnetConcOctetsRxOk = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetConcOctetsRxOk.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetConcOctetsRxOk.setDescription('Contains a count of data and padding octets in frames that are successfully received by the concentrator. This does not include frames received with a frame-too-long, runt, FCS, or alignment errors. This counter includes octets in broadcast and multicast frames that are received. This counter does not include the octets in the CRC field. The octets in the address and length/type fields are counted.')
s3EnetConcMcastFrmsRxOk = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetConcMcastFrmsRxOk.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetConcMcastFrmsRxOk.setDescription('This contains a count of frames that are successfully received by the concentrator and are directed to an active non-broadcast group address. This does not include frames received with a frame-too-long, runt, FCS, or alignment errors. Only frames that are for a multicast address that this interface is receiving are counted. Broadcast packets are not included.')
s3EnetConcBcastFrmsRxOk = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetConcBcastFrmsRxOk.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetConcBcastFrmsRxOk.setDescription('This contains a count of frames that are successfully received by the concentrator and are directed to the broadcast group address. This does not include frames received with a frame-too-long, runt, FCS, or alignment errors. Multicast packets are not included.')
s3EnetConcColls = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetConcColls.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetConcColls.setDescription("This contains a count of the collisions at the concentrator level. For NMM+ this is a true counter. For other NMMs this is a summation of all the port level collision 'flags' for all ports.")
s3EnetConcTooLongErrors = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetConcTooLongErrors.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetConcTooLongErrors.setDescription('This contains a count of frames that are received by the concentrator and exceed the maximum permitted frame size. This counter is incremented when the frameTooLong error is detected.')
s3EnetConcRuntErrors = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetConcRuntErrors.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetConcRuntErrors.setDescription('This contains a count of frames received by the concentrator that are less than the minimum permitted frame size and have a good FCS.')
s3EnetConcFragErrors = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetConcFragErrors.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetConcFragErrors.setDescription('This contains a count of frames received by the concentrator that are less than the minimum permitted frame size and have a bad FCS or alignment error.')
s3EnetConcAlignErrors = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetConcAlignErrors.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetConcAlignErrors.setDescription('This contains a count of frames received by the concentrator that are not an integral number of octets in length and do not pass the FCS check. This counter is incremented when the alignment Error status is detected.')
s3EnetConcFcsErrors = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetConcFcsErrors.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetConcFcsErrors.setDescription('This contains a count of frames received by the concentrator that are an integral number of octets in length that do not pass the FCS check. This counter is incremented when the frame Check Error status is detected.')
s3EnetConcLateCollErrors = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetConcLateCollErrors.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetConcLateCollErrors.setDescription("This contains a total concentrator count of the late collisions. For NMM+ this is a true counter. For other NMMs this is a summation of all the port level late collision 'flags' for all ports.")
s3EnetConcSecureStatus = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("concSecureOn", 2), ("portCheckOn", 3), ("slotCheckOn", 4), ("concSecureOff", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3EnetConcSecureStatus.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetConcSecureStatus.setDescription("This s3EnetConcSecureStatus object indicates whether the security features (both allowed nodes and LattisSecure) for the concentrator are active or inactive. If security is active, this object also indicates whether the allowed nodes feature is controlled at the concentrator, board, or port level. LattisSecure features are always controlled at the port level. (See the Authorized Nodes tables for more information about how the allowed nodes and LattisSecure receive security features are configured.) If this object is set to concSecureOn(2), then the allowed nodes feature is controlled at the concentrator level and activated for every non-LattisSecure Ethernet port in the concentrator. If an authorized node violation occurs on any port, the action specified in s3EnetConcAuthAction is taken. If this object is set to portCheckOn(3), then allowed nodes is controlled at the port level by the s3EnetPortSecureStatus object for that port. The port's s3EnetPortAuthAction determines the action taken when authorized nodes violations occur on that port. If this object is set to slotCheckOn(4), then allowed nodes is controlled at the board level by the s3EnetBoardSecureStatus object for that board. The board's s3EnetBoardAuthAction determines the action taken when authorized nodes violations occur on that board's ports. If this object is set to concentratorOff(5), then all security features, including LattisSecure, are deactivated for the entire concentrator. No matter what the status of this object, the board and port level SecureStatus and AuthAction are not lost even if they are not currently being used. Thus, the user can change a port's status even if this object is slotCheckOn(4). If this object is then changed to portCheckOn(3), then the change will take effect. The agent must support download of this object in the CFG file. In release 4.0, this object was called s3EnetConcAuthStatus.")
s3EnetConcAuthAction = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("noAction", 2), ("sendTrap", 3), ("partition", 4), ("sendTrapPartition", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3EnetConcAuthAction.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetConcAuthAction.setDescription('If s3EnetConcSecureStatus is concSecureOn(2) and a violation occurs, then the action specified by this object will take place. On a partition, only the port that the violation occurs on will be partitioned. This object does not apply to LattisSecure ports. The agent must support download of this object in the CFG file.')
s3EnetConcSecurityLock = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("locked", 2), ("notLocked", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetConcSecurityLock.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetConcSecurityLock.setDescription("If s3EnetConcSecurityLock is locked(2), the agent will refuse all requests to modify the 'security configuration' (defined below) by returning a BadValue return value. If s3EnetConcSecurityLock is notLocked(3), requests to modify security configuration will be handled in the usual manner. SetRequests for objects not included in the security configuration are not affected by the state of this object. Objects that are part of the security configuration are s3EnetConcAuthStatus, s3EnetConcAuthAction, s3EnetBoardAuthStatus, s3EnetBoardAuthAction, s3EnetPortAuthStatus, s3EnetPortAuthAction, s3EnetPortAddrLearnMode, s3EnetPortTxSecurity, and all of the objects in the s3EnetAuthNodesTable.")
s3EnetConcEnetChan = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("enetA", 2), ("enetB", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetConcEnetChan.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetConcEnetChan.setDescription('Identifies the channel to which this NMM is currently monitoring.')
s3EnetBoardTable = MibTable((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 2, 1), )
if mibBuilder.loadTexts: s3EnetBoardTable.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetBoardTable.setDescription('A table of board-related objects. The number of entries is given by the number of Ethernet host module and network management module boards that are contained in same backplane Ethernet segment as the reporting NMM.')
s3EnetBoardEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 2, 1, 1), ).setIndexNames((0, "SYNOPTICS-ETHERNET-MIB", "s3EnetBoardIndex"))
if mibBuilder.loadTexts: s3EnetBoardEntry.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetBoardEntry.setDescription('A table containing objects about Ethernet boards which are currently plugged into the 3000 chassis.')
s3EnetBoardIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetBoardIndex.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetBoardIndex.setDescription("A unique value for each board. Its value ranges between 1 and 12. The value for each board must remain constant at least from one re-initialization of the entity's network management system to the next re-initialization.")
s3EnetBoardType = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 16, 17, 18, 24, 25, 26, 32, 33, 34, 35, 36, 37, 38))).clone(namedValues=NamedValues(("empty", 1), ("other", 2), ("m3302", 3), ("m3304-ST", 4), ("m3305", 5), ("m3308", 6), ("m3313", 7), ("m3313M", 8), ("m3314-ST", 9), ("m3314M-ST", 10), ("m3323", 11), ("m3324-ST", 12), ("m3301", 16), ("m3307", 17), ("m3356", 18), ("m3383", 24), ("m3384", 25), ("m331x", 26), ("m3386", 32), ("m3394", 33), ("m3395", 34), ("m3323S", 35), ("m3324S-ST", 36), ("m3307A", 37), ("m3308A", 38)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetBoardType.setStatus('obsolete')
if mibBuilder.loadTexts: s3EnetBoardType.setDescription('See s3SlotModuleType')
s3EnetBoardHwVer = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 2, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetBoardHwVer.setStatus('obsolete')
if mibBuilder.loadTexts: s3EnetBoardHwVer.setDescription('See s3CommonBoardHwVer')
s3EnetBoardStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("fail", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetBoardStatus.setStatus('obsolete')
if mibBuilder.loadTexts: s3EnetBoardStatus.setDescription('See s3CommonBoardStatus')
s3EnetBoardReset = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noReset", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3EnetBoardReset.setStatus('obsolete')
if mibBuilder.loadTexts: s3EnetBoardReset.setDescription('See s3CommonBoardReset')
s3EnetBoardPartStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("partition", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3EnetBoardPartStatus.setStatus('obsolete')
if mibBuilder.loadTexts: s3EnetBoardPartStatus.setDescription('See s3CommonBoardPartStatus')
s3EnetBoardNmCntlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notNmControl", 1), ("nmControl", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetBoardNmCntlStatus.setStatus('obsolete')
if mibBuilder.loadTexts: s3EnetBoardNmCntlStatus.setDescription('See s3CommonBoardCntlStatus')
s3EnetBoardPsStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("fail", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetBoardPsStatus.setStatus('obsolete')
if mibBuilder.loadTexts: s3EnetBoardPsStatus.setDescription('See s3CommonBoardPsStatus')
s3EnetBoardFrmsRxOk = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 2, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetBoardFrmsRxOk.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetBoardFrmsRxOk.setDescription('This contains a count of frames that are successfully received by the board. This does not include frames received with a frame-too-long, runt, FCS, or alignment errors. This counter includes broadcast and multicast frames that are received.')
s3EnetBoardOctetsRxOk = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 2, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetBoardOctetsRxOk.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetBoardOctetsRxOk.setDescription('Contains a count of data and padding octets in frames that are successfully received by the board. This does not include frames received with a frame-too-long, runt, FCS, or alignment errors. This counter includes octets in broadcast and multicast frames that are received. This counter does not include the octets in the CRC field. The octets in the address and length/type fields are counted.')
s3EnetBoardMcastFrmsRxOk = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 2, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetBoardMcastFrmsRxOk.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetBoardMcastFrmsRxOk.setDescription('This contains a count of frames that are successfully received by the board and are directed to an active non-broadcast group address. This does not include frames received with a frame-too-long, runt, FCS, or alignment errors. Only frames that are for a multicast address that this interface is receiving are counted. Broadcast packets are not included.')
s3EnetBoardBcastFrmsRxOk = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 2, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetBoardBcastFrmsRxOk.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetBoardBcastFrmsRxOk.setDescription('This contains a count of frames that are successfully received by the board and are directed to the broadcast group address. This does not include frames received with a frame-too-long, runt, FCS, or alignment errors. Multicast packets are not included.')
s3EnetBoardColls = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 2, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetBoardColls.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetBoardColls.setDescription("This contains a board level count of collisions. For NMM+ this is a true counter. For other NMMs this is a summation of all the port level collision 'flags' for this board.")
s3EnetBoardTooLongErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 2, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetBoardTooLongErrors.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetBoardTooLongErrors.setDescription('This contains a count of frames that are received by the board and exceed the maximum permitted frame size. This counter is incremented when the frameTooLong error is detected.')
s3EnetBoardRuntErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 2, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetBoardRuntErrors.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetBoardRuntErrors.setDescription('This contains a count of frames received by the board that are less than the minimum permitted frame size and have a good FCS.')
s3EnetBoardAlignErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 2, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetBoardAlignErrors.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetBoardAlignErrors.setDescription('This contains a count of frames received by the board that are not an integral number of octets in length and do not pass the FCS check. This counter is incremented when the alignmentError status is detected.')
s3EnetBoardFcsErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 2, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetBoardFcsErrors.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetBoardFcsErrors.setDescription('This contains a count of frames received by the board that are an integral number of octets in length that do not pass the FCS check. This counter is incremented when the frameCheckError status is detected.')
s3EnetBoardLateCollErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 2, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetBoardLateCollErrors.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetBoardLateCollErrors.setDescription("This contains a count of the board level late collisions. For NMM+ this is a true counter. For other NMMs this is a summation of all the port level late collision 'flags' for this board.")
s3EnetBoardAuthStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 2, 1, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("on", 2), ("off", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3EnetBoardAuthStatus.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetBoardAuthStatus.setDescription('This object is only used if s3EnetConcSecureStatus is set to slotCheckOn(4). In this case, turning this object on(2) means that any node that is heard on this board which is not allowed on this board (i.e., not in AuthNode table with the slotIndex equal to this board or 0 for all boards) will cause the action specified in s3EnetBoardAuthAction to take place. If s3EnetConcSecureStatus is set to slotCheckOn(4) but this object is set to off(3), then the authorized nodes feature for this board is deactivated. If s3EnetConcSecureStatus is not set to slotCheckOn(4), then this object will not be used but will maintain its settings unless explicitly changed. This object does not affect the configuration or functioning of security features on LattisSecure Host Modules.')
s3EnetBoardAuthAction = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 2, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("noAction", 2), ("sendTrap", 3), ("partition", 4), ("sendTrapPartition", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3EnetBoardAuthAction.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetBoardAuthAction.setDescription('If s3EnetConcSecureStatus is slotCheckOn(4) and s3EnetBoardAuthStatus is on(2) and an authorized nodes violation occurs on the board, then the action specified by this object will take place. On a partition, only the port that the violation occurs on will be partitioned. This object does not apply to LattisSecure ports.')
s3EnetBoardUpStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 2, 1, 1, 21), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetBoardUpStamp.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetBoardUpStamp.setDescription("The time ( in hundredths of a second) that the board was first seen as a member of this NMM's segment.")
s3EnetLocBridgeSlotTable = MibTable((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 2, 2, 1), )
if mibBuilder.loadTexts: s3EnetLocBridgeSlotTable.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetLocBridgeSlotTable.setDescription('A table of Local Bridge Board entries. The number of entries is determined by the Concentrator Slot Configuration Table. Only those entries that are Ethernet local bridges will have entries in this list.')
s3EnetLocBridgeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 2, 2, 1, 1), ).setIndexNames((0, "SYNOPTICS-ETHERNET-MIB", "s3EnetLocBridgeIndex"))
if mibBuilder.loadTexts: s3EnetLocBridgeEntry.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetLocBridgeEntry.setDescription('A table containing objects about Boards which are local bridges that are currently plugged into the 3000 chassis.')
s3EnetLocBridgeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 2, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetLocBridgeIndex.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetLocBridgeIndex.setDescription("A unique value for each board. Its value ranges between 1 and 12. The value for each board must remain constant at least from one re-initialization of the entity's network management system to the next re-initialization.")
s3EnetLocBridgeDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 2, 2, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetLocBridgeDescr.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetLocBridgeDescr.setDescription('Description of the local bridge board.')
s3EnetLocBridgePortCount = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 2, 2, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetLocBridgePortCount.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetLocBridgePortCount.setDescription('Number of ports that are on the local bridge board.')
s3EnetLocBridgeDiagSts = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 2, 2, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetLocBridgeDiagSts.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetLocBridgeDiagSts.setDescription('Latest Diagnostic LED Status that has been recorded.')
s3EnetLocBridgeBootSts = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 2, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("reqstToBoot", 2), ("notReqstToBoot", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetLocBridgeBootSts.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetLocBridgeBootSts.setDescription('The current status of the board as it relates to rebooting.')
s3EnetLocBridgeStandbySts = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 2, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("standby", 2), ("notStandby", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetLocBridgeStandbySts.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetLocBridgeStandbySts.setDescription('This status says whether the local bridge is active or in standby mode.')
s3EnetLocBridgePortTable = MibTable((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 2, 2, 2), )
if mibBuilder.loadTexts: s3EnetLocBridgePortTable.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetLocBridgePortTable.setDescription('A table of Port entries that are part of a local bridge. The number of entries is determined by knowing the number of local bridge boards that are installed by looking at s3ChassisSlotConfigTable and by knowing how many ports are on a local bridge board by looking at s3EnetLocBridgePortCount.')
s3EnetLocBridgePortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 2, 2, 2, 1), ).setIndexNames((0, "SYNOPTICS-ETHERNET-MIB", "s3EnetLocBridgePortSlotIndex"), (0, "SYNOPTICS-ETHERNET-MIB", "s3EnetLocBridgePortIndex"))
if mibBuilder.loadTexts: s3EnetLocBridgePortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetLocBridgePortEntry.setDescription('A table containing objects about the ports of the local bridges that are currently plugged into the 3000 chassis.')
s3EnetLocBridgePortSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 2, 2, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetLocBridgePortSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetLocBridgePortSlotIndex.setDescription("A unique value for each board. Its value ranges between 1 and 12. The value for each board must remain constant at least from one re-initialization of the entity's network management system to the next re-initialization.")
s3EnetLocBridgePortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 2, 2, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetLocBridgePortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetLocBridgePortIndex.setDescription("A unique value for each port. Its value ranges between 1 and 12. The value for each port must remain constant at least from one re-initialization of the entity's network management system to the next re-initialization.")
s3EnetLocBridgePortMdaId = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 2, 2, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetLocBridgePortMdaId.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetLocBridgePortMdaId.setDescription('Medium dependent ID for the port. See s3SlotModuleMdaId in the SynOptics Common MIB.')
s3EnetLocBridgePortIf = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 2, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("etherEther", 2), ("etherTokenRing", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetLocBridgePortIf.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetLocBridgePortIf.setDescription('Bridge interface types.')
s3EnetLocBridgePortDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 2, 2, 2, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetLocBridgePortDescr.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetLocBridgePortDescr.setDescription('A text description of the port.')
s3EnetLocBridgePortOpSts = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 2, 2, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("standby", 2), ("notStandby", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetLocBridgePortOpSts.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetLocBridgePortOpSts.setDescription('Operating status of the port.')
s3EnetRemBridgeSlotTable = MibTable((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 2, 3, 1), )
if mibBuilder.loadTexts: s3EnetRemBridgeSlotTable.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetRemBridgeSlotTable.setDescription('A table of Remote Bridge Board entries. The number of entries is determined by the Concentrator Slot Configuration Table. Only those entries that are Ethernet remote bridges will have entries in this list.')
s3EnetRemBridgeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 2, 3, 1, 1), ).setIndexNames((0, "SYNOPTICS-ETHERNET-MIB", "s3EnetRemBridgeIndex"))
if mibBuilder.loadTexts: s3EnetRemBridgeEntry.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetRemBridgeEntry.setDescription('A table containing objects about Boards which are remote bridges that are currently plugged into the 3000 chassis.')
s3EnetRemBridgeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 2, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetRemBridgeIndex.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetRemBridgeIndex.setDescription("A unique value for each board. Its value ranges between 1 and 12. The value for each board must remain constant at least from one re-initialization of the entity's network management system to the next re-initialization.")
s3EnetRemBridgeDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 2, 3, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetRemBridgeDescr.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetRemBridgeDescr.setDescription('Description of the board.')
s3EnetRemBridgePortCount = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 2, 3, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetRemBridgePortCount.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetRemBridgePortCount.setDescription('Number of ports that are on the board.')
s3EnetRemBridgeDiagSts = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 2, 3, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetRemBridgeDiagSts.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetRemBridgeDiagSts.setDescription('Latest Diagnostic LED Status that has been recorded.')
s3EnetRemBridgeBootSts = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 2, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("reqstToBoot", 2), ("notReqstToBoot", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetRemBridgeBootSts.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetRemBridgeBootSts.setDescription('The current status of the board as it relates to rebooting.')
s3EnetRemBridgeStandbySts = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 2, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("standby", 2), ("notStandby", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetRemBridgeStandbySts.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetRemBridgeStandbySts.setDescription('This status says whether the remote bridge is active or in standby mode.')
s3EnetRemBridgePortTable = MibTable((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 2, 3, 2), )
if mibBuilder.loadTexts: s3EnetRemBridgePortTable.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetRemBridgePortTable.setDescription('A table of Port entries that are part of a remote bridge. The number of entries is determined by knowing the number of remote bridge boards that are installed by looking at s3ChassisSlotConfigTable and by knowing how many ports are on a remote bridge board by looking at s3EnetRemBridgePortCount.')
s3EnetRemBridgePortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 2, 3, 2, 1), ).setIndexNames((0, "SYNOPTICS-ETHERNET-MIB", "s3EnetRemBridgePortSlotIndex"), (0, "SYNOPTICS-ETHERNET-MIB", "s3EnetRemBridgePortIndex"))
if mibBuilder.loadTexts: s3EnetRemBridgePortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetRemBridgePortEntry.setDescription('A table containing objects about the ports of the remote bridges that are currently plugged into the 3000 chassis.')
s3EnetRemBridgePortSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 2, 3, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetRemBridgePortSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetRemBridgePortSlotIndex.setDescription("A unique value for each board. Its value ranges between 1 and 12. The value for each board must remain constant at least from one re-initialization of the entity's network management system to the next re-initialization.")
s3EnetRemBridgePortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 2, 3, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetRemBridgePortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetRemBridgePortIndex.setDescription("A unique value for each port. Its value ranges between 1 and 12. The value for each port must remain constant at least from one re-initialization of the entity's network management system to the next re-initialization.")
s3EnetRemBridgePortMdaId = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 2, 3, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("other", 1), ("ethernet", 2), ("x21Barrier", 3), ("x21Unbarrier", 4), ("rs232", 5), ("rs449", 6), ("v35", 7), ("g703", 8), ("t1", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetRemBridgePortMdaId.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetRemBridgePortMdaId.setDescription('Medium dependent ID for the port.')
s3EnetRemBridgePortDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 2, 3, 2, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetRemBridgePortDescr.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetRemBridgePortDescr.setDescription('A text description of the port.')
s3EnetRemBridgePortOpSts = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 2, 3, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("standby", 2), ("operational", 3), ("noLink", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetRemBridgePortOpSts.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetRemBridgePortOpSts.setDescription('Operating status of the port.')
s3EnetRemBridgePortRdySnd = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 2, 3, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("rdySnd", 2), ("notRdySnd", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetRemBridgePortRdySnd.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetRemBridgePortRdySnd.setDescription('Ready to send status of the port.')
s3EnetRemBridgePortClrSnd = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 2, 3, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("clrSnd", 2), ("notClrSnd", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetRemBridgePortClrSnd.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetRemBridgePortClrSnd.setDescription('Clear to send status of the port.')
s3EnetRemBridgePortCarDt = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 2, 3, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("carDt", 2), ("noCarDt", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetRemBridgePortCarDt.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetRemBridgePortCarDt.setDescription('Carrier detect status of the port.')
s3EnetRouterSlotTable = MibTable((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 2, 4, 1), )
if mibBuilder.loadTexts: s3EnetRouterSlotTable.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetRouterSlotTable.setDescription('A table of Router Board entries. The number of entries is determined by the Concentrator Slot Configuration Table. Only those entries that are Ethernet routers will have entries in this list.')
s3EnetRouterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 2, 4, 1, 1), ).setIndexNames((0, "SYNOPTICS-ETHERNET-MIB", "s3EnetRouterIndex"))
if mibBuilder.loadTexts: s3EnetRouterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetRouterEntry.setDescription('A table containing objects about Boards which are routers that are currently plugged into the 3000 chassis.')
s3EnetRouterIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 2, 4, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetRouterIndex.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetRouterIndex.setDescription("A unique value for each board. Its value ranges between 1 and 12. The value for each board must remain constant at least from one re-initialization of the entity's network management system to the next re-initialization.")
s3EnetRouterDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 2, 4, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetRouterDescr.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetRouterDescr.setDescription('Description of the router board.')
s3EnetRouterDiagSts = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 2, 4, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetRouterDiagSts.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetRouterDiagSts.setDescription('Latest Diagnostic LED Status that has been recorded.')
s3EnetRouterStandbySts = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 2, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("standby", 2), ("notStandby", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetRouterStandbySts.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetRouterStandbySts.setDescription('This status says whether the router is active or in standby mode.')
s3EnetCommonBoardTable = MibTable((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 2, 5), )
if mibBuilder.loadTexts: s3EnetCommonBoardTable.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetCommonBoardTable.setDescription('Information maintained for each Ethernet board. The information can be retrieved for any Ethernet board, even if the board is not on the same backplane Ethernet segment as this NMM. The instance is the slot number of the concentrator that the board occupies.')
s3EnetCommonBoardEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 2, 5, 1), ).setIndexNames((0, "SYNOPTICS-ETHERNET-MIB", "s3EnetCommonBoardIndex"))
if mibBuilder.loadTexts: s3EnetCommonBoardEntry.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetCommonBoardEntry.setDescription('There is one entry per Ethernet board in this table.')
s3EnetCommonBoardIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 2, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetCommonBoardIndex.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetCommonBoardIndex.setDescription("A unique value for each board. Its value ranges between 1 and 12. The value for each board must remain constant at least from one re-initialization of the entity's network management system to the next re-initialization.")
s3EnetCommonBoardEnetAB = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 2, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("enetA", 2), ("enetB", 3), ("enetAandEnetB", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3EnetCommonBoardEnetAB.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetCommonBoardEnetAB.setDescription('The channel to which the board is connected. The primary use of this object is for providing realtime switching of boards between channel A and channel B. It is also returned in the enetChannelChange trap, in which case it indicates a board is switched from one channel to the other. The write capability of this object can only apply to those modules with channel switching function. Any attempt to write this object for a non-switchable board, the agent will return badValue.')
s3EnetCommonBoardChanSwitch = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 2, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("switchCapable", 2), ("notSwitchCapable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetCommonBoardChanSwitch.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetCommonBoardChanSwitch.setDescription('The agent will return switchCapable(2) for any Ethernet host board which can be switched between Ethernet channels. The value notSwitchCapable(3) indicates that the Ethernet board can not be switched to another channel.')
s3EnetCommonBoardRedund = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 2, 5, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("redundCapable", 2), ("notRedundCapable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetCommonBoardRedund.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetCommonBoardRedund.setDescription('The agent will return redundCapable(2) for any Ethernet host board which can provide hardware and/or software controlled redundancy on the port level. The value notRedundCapable(3) indicates that the Ethernet board can not support port redundancy.')
s3EnetPortTable = MibTable((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 3, 1), )
if mibBuilder.loadTexts: s3EnetPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetPortTable.setDescription('A list of port entries. The number of entries is given by learning the type of board from the information in the s3ChassisSlotConfigTable.')
s3EnetPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 3, 1, 1), ).setIndexNames((0, "SYNOPTICS-ETHERNET-MIB", "s3EnetPortBoardIndex"), (0, "SYNOPTICS-ETHERNET-MIB", "s3EnetPortIndex"))
if mibBuilder.loadTexts: s3EnetPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetPortEntry.setDescription('A table containing objects about the Ports of each board plugged into the 3000 chassis which are on the same backplane Ethernet segment as the reporting NMM.')
s3EnetPortBoardIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetPortBoardIndex.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetPortBoardIndex.setDescription("A unique value for each board. Its value ranges between 1 and 12. The value for each board must remain constant at least from one reinitialization of the entity's network management system to the next reinitialization.")
s3EnetPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 3, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetPortIndex.setDescription("A unique value for each port. Its value is dependent on the board type. The value for each port must remain constant at least from one re-initialization of the entity's network management system to the next re-initialization.")
s3EnetPortLinkStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("on", 2), ("other", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetPortLinkStatus.setStatus('deprecated')
if mibBuilder.loadTexts: s3EnetPortLinkStatus.setDescription('Tells whether the port is receiving link status.')
s3EnetPortPartStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("enabled", 1), ("partition", 2), ("autoPartition", 3), ("timedPartition", 4), ("latSecPartition", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3EnetPortPartStatus.setStatus('deprecated')
if mibBuilder.loadTexts: s3EnetPortPartStatus.setDescription('This indicates the operational status of the Port. Writing a partition(2) will partition the port indefinitely and enabled(1) will enable the port. If a timed partition is desired, then writing timedPartition(4) to this object at the same time that a time value is supplied in s3EnetPortPartTime is required. Timed partitions will not survive across a reset. In this case the port will go to the partition(2) state. The value latSecPartition(5) is returned when the port has been automatically partitioned by the LattisSecure Host Module because of a security violation. The value autoPartition(3) is returned when the port has been automatically partitioned by the repeater using the 802.3 repeater auto-partition function. The agent will not allow this object to be set to autoPartition(3) or latSecPartition(5) using an SNMP request.')
s3EnetPortJabberStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("jabbering", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetPortJabberStatus.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetPortJabberStatus.setDescription('Tells whether the DTE connected to the Port is jabbering or not.')
s3EnetPortFrmsRxOk = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 3, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetPortFrmsRxOk.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetPortFrmsRxOk.setDescription('This contains a count of frames that are successfully received by the port. This does not include frames received with a frame-too-long, runt, FCS, or alignment errors. This counter includes broadcast and multicast frames that are received.')
s3EnetPortOctetsRxOk = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 3, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetPortOctetsRxOk.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetPortOctetsRxOk.setDescription('Contains a count of data and padding octets in frames that are successfully received by the port. This does not include frames received with a frame-too-long, runt, FCS, or alignment errors. This counter includes octets in broadcast and multicast frames that are received. This counter does not include the octets in the CRC field. The octets in the address and length/type fields are counted.')
s3EnetPortMcastFrmsRxOk = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 3, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetPortMcastFrmsRxOk.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetPortMcastFrmsRxOk.setDescription('This contains a count of frames that are successfully received by the port and are directed to an active non-broadcast group address. This does not include frames received with a frame-too-long, runt, FCS, or alignment errors. Only frames that are for a multicast address that this interface is receiving are counted. Broadcast packets are not included.')
s3EnetPortBcastFrmsRxOk = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 3, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetPortBcastFrmsRxOk.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetPortBcastFrmsRxOk.setDescription('This contains a count of frames that are successfully received by the port and are directed to the broadcast group address. This does not include frames received with a frame-too-long, runt, FCS, or alignment errors. Multicast packets are not included.')
s3EnetPortColls = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 3, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetPortColls.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetPortColls.setDescription('This contains a count of collisions. For NMM+ this is a true counter. For other NMMs this is a count of the collision flags.')
s3EnetPortTooLongErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 3, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetPortTooLongErrors.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetPortTooLongErrors.setDescription('This contains a count of frames that are received by the port and exceed the maximum permitted frame size. This counter is incremented when the frameTooLong error is detected.')
s3EnetPortRuntErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 3, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetPortRuntErrors.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetPortRuntErrors.setDescription('This contains a count of frames received by the port that are less than the minimum permitted frame size and have a good FCS.')
s3EnetPortAlignErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 3, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetPortAlignErrors.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetPortAlignErrors.setDescription('This contains a count of frames received by the port that are not an integral number of octets in length and do not pass the FCS check. This counter is incremented when the alignmentError status is detected.')
s3EnetPortFcsErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 3, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetPortFcsErrors.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetPortFcsErrors.setDescription('This contains a count of frames received the port that are an integral number of octets in length that do not pass the FCS check. This counter is incremented when the frameCheckError status is detected.')
s3EnetPortLateCollErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 3, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetPortLateCollErrors.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetPortLateCollErrors.setDescription('This contains a count of late collisions. For NMM+ this is a true counter. For other NMMs this is a count of the late collision flags.')
s3EnetPortAuthStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 3, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("on", 2), ("off", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3EnetPortAuthStatus.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetPortAuthStatus.setDescription('This object is only used if s3EnetConcSecureStatus is set to portCheckOn(3) or if the port is on a LattisSecure Host Module. In this case, turning this object on(2) means that any node that heard on this port which is not allowed on this port will cause the action specified in s3EnetPortAuthAction to take place. This object does not affect the LattisSecure transmit security feature for the port. It is incompatible with LattisSecure continuous learning mode. If the value of s3EnetPortAddrLearnMode for a LattisSecure port is continuousLearn(3), turning this object to on(2) for that port will not have any affect. If s3EnetConcSecureStatus is set to portCheckOn(3) but this object is set to off(3), then all authorized nodes or LattisSecure receive security features for this port are deactivated. If s3EnetConcSecureStatus is not set to portCheckOn(3), then this object will not be used for allowed nodes, but will be used for LattisSecure.')
s3EnetPortAuthAction = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 3, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("noAction", 2), ("sendTrap", 3), ("partition", 4), ("sendTrapPartition", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3EnetPortAuthAction.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetPortAuthAction.setDescription('If s3EnetConcSecureStatus is portCheckOn(3) or this port is on a LattisSecure Host Module, and s3EnetPortAuthStatus is on(2) and an authorized nodes violation occurs on this port, then the action specified by this object will take place on this port. If the port is a LattisSecure port, the authorized nodes security will be implemented by the LattisSecure Host Module.')
s3EnetPortPartTime = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 3, 1, 1, 18), TimeTicks()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3EnetPortPartTime.setStatus('deprecated')
if mibBuilder.loadTexts: s3EnetPortPartTime.setDescription('When partitioning the port for a specified time, s3EnetPortPartStatus must be set with timedpartition(4) and this object must be supplied with the duration value. If a PDU sets s3EnetPortPartStatus and not this object, the port will not be partitioned.')
s3EnetPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 3, 1, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("other", 1), ("tenBaseT", 2), ("tenBaseTMdi", 3), ("aui", 4), ("bnc", 5), ("foirl", 6), ("tenBaseFL", 7), ("switch", 8), ("switchMdi", 9), ("tenBaseFLRedund", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetPortType.setStatus('deprecated')
if mibBuilder.loadTexts: s3EnetPortType.setDescription('The media connection type for this port. Note that this object was called s3EnetPortMDIXSwitch in the Ethernet 3.3 and 4.0 MIBs.')
s3EnetPortInterconStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 3, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("interconnect", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetPortInterconStatus.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetPortInterconStatus.setDescription('This object tells whether the port is connected to a host or to an interconnect (defined to be another NMM that is sending hello messages). The NMM agent will assign this object the value other(1) on initialization. If it sees hello messages coming in on the port, it will change the InterconStatus to be interconnect(2).')
s3EnetPortAddrCollect = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 3, 1, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("default", 1), ("neverCollect", 2), ("alwaysCollect", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3EnetPortAddrCollect.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetPortAddrCollect.setDescription("This object tells whether the NMM should collect node address information from this port for the Find Nodes, Show Nodes, and Traffic Matrix (NMM+ only) tables. By default, the node addresses are collected only from ports that are not identified as interconnect ports. In addition, allowed nodes checking is done only on ports that are not interconnect ports. This object provides a means of overriding the default for collection and checking of node addresses. Setting this variable to default(1) tells the NMM to collect and check addresses if and only the port has not been identified as an interconnect port. To disable node address collection and checking on a port, set this object to neverCollect(2). To collect and check node addresses for an interconnect port, set this object to alwaysCollect(3). This object and its default setting has no affect on LattisSecure receive or transmit security features. To restore the 'natural' value for the port, set this object to default(1).")
s3EnetPortAddrLearnMode = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 3, 1, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("noAutoLearn", 2), ("continuousLearn", 3), ("oneShotLearn", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3EnetPortAddrLearnMode.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetPortAddrLearnMode.setDescription('This object indicates whether the port should automatically learn the port address by reading the source address on the incoming packets. This object applies only to ports on a LattisSecure Host Module. For other ports, the agent returns the value other. A Get will return the current learning mode of the port. Setting to noAutoLearn(2) can be used to turn off continuousLearn (3) or oneShotLearn(4). The value of this object is in effect regardless of the value of s3EnetConcSecureStatus or s3EnetPortAuthStatus. Continuous learning is not compatible with LattisSecure receive security, thus s3EnetPortAddrLearnMode should not be set to continuousLearn(3) when s3EnetPortAuthStatus is on(2). If this combination is set, the receive security will not function. If this object is set to oneShotLearn(4), the agent will store the address (when it is learned) into the allowed nodes tables. This can cause the current address to be written over. Because continuous learning is not compatible with receive security, addresses learned while the port is in continuous learning mode will not be stored in the allowed nodes tables. Attempts to set the value to other(1) on a LattisSecure port will be rejected by the agent. Likewise, attempts to set the value to noAutoLearn(2), continuousLearn(3), or oneShotLearn(4) on a non-LattisSecure port will be rejected.')
s3EnetPortTxSecurity = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 3, 1, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("on", 2), ("off", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3EnetPortTxSecurity.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetPortTxSecurity.setDescription('This value of this object is meaningful only when s3EnetConcSecureStatus is not set to concSecureOff(5) (i.e., if security features are activated on the concentrator). This object applies only to ports on LattisSecure Host Modules. For other ports, the agent will return other(1) in response to a get request. The value off(3) indicates that LattisSecure transmit security is disabled on this LattisSecure port. The value on(2) indicates that LattisSecure transmit security is enabled on this LattisSecure port. Attempts to set the value to other(1) on a LattisSecure port will be rejected by the agent. Likewise, attempts to set the value to on(2) or off(3) on a non-LattisSecure port will be rejected.')
s3EnetCommonPortTable = MibTable((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 3, 2), )
if mibBuilder.loadTexts: s3EnetCommonPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetCommonPortTable.setDescription('This table provides a list of port entries. The number of entries is given for any Ethernet board in the concentrator, even if the board is not on the same Ethernet segment as this NMM.')
s3EnetCommonPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 3, 2, 1), ).setIndexNames((0, "SYNOPTICS-ETHERNET-MIB", "s3EnetCommonPortBoardIndex"), (0, "SYNOPTICS-ETHERNET-MIB", "s3EnetCommonPortIndex"))
if mibBuilder.loadTexts: s3EnetCommonPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetCommonPortEntry.setDescription('A table containing objects about the ports of each Ethernet board plugged into the 3000-series chassis.')
s3EnetCommonPortBoardIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 3, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetCommonPortBoardIndex.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetCommonPortBoardIndex.setDescription("A unique value for each board. Its value ranges between 1 and 12. The value for each board must remain constant at least from one re-initialization of the entity's network management system to the next re-initialization.")
s3EnetCommonPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 3, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetCommonPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetCommonPortIndex.setDescription('A unique value for each port. Its value is dependent on the board type.')
s3EnetCommonPortLinkStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 3, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("on", 2), ("other", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetCommonPortLinkStatus.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetCommonPortLinkStatus.setDescription('Tells whether the port is receiving link status.')
s3EnetCommonPortPartStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 3, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("enabled", 1), ("partition", 2), ("autoPartition", 3), ("timedPartition", 4), ("latSecPartition", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3EnetCommonPortPartStatus.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetCommonPortPartStatus.setDescription('This indicates the operational status of the Port. Writing a partition(2) will partition the port indefinitely and enabled(1) will enable the port. If a timed partition is desired, then writing timedPartition(4) to this object at the same time that a time value is supplied in s3EnetCommonPortPartTime is required. Timed partitions will not survive across a reset. In this case the port will go to the partition(2) state. The value latSecPartition(5) is returned when the port has been automatically partitioned by the LattisSecure Host Module because of a security violation. The value autoPartition(3) is returned when the port has been automatically partitioned by the repeater using the 802.3 repeater auto-partition function. The agent will not allow this object to be set to autoPartition(3) or latSecPartition(5) using an SNMP request. Note that the value timedPartition(4) is returned only when the board is timed partitioned by this NMM.')
s3EnetCommonPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 3, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("other", 1), ("tenBaseT", 2), ("tenBaseTMdi", 3), ("aui", 4), ("bnc", 5), ("foirl", 6), ("tenBaseFL", 7), ("switch", 8), ("switchMdi", 9), ("tenBaseFLRedund", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetCommonPortType.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetCommonPortType.setDescription('The media connnection type for this port. Note that this object was called s3EnetPortMDIXSwitch in the Ethernet 3.3 and 4.0 MIBs.')
s3EnetCommonPortPartTime = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 3, 2, 1, 6), TimeTicks()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3EnetCommonPortPartTime.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetCommonPortPartTime.setDescription('When partitioning the port for a specified time, s3EnetCommonPortPartStatus must be set with timedPartition(4) and this object must be supplied with the duration value. If a PDU sets s3EnetCommonPortPartStatus and not this object, the port will not be partitioned.')
s3EnetRedPortTable = MibTable((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 3, 3), )
if mibBuilder.loadTexts: s3EnetRedPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetRedPortTable.setDescription('A table of ports for each 10BASE-FL board with redundancy capability. The number of boards is determined by checking s3EnetCommonBoardRedund having a value of redundCapable(2) for each board in table s3EnetCommonBoardTable.')
s3EnetRedPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 3, 3, 1), ).setIndexNames((0, "SYNOPTICS-ETHERNET-MIB", "s3EnetRedPortBoardIndex"), (0, "SYNOPTICS-ETHERNET-MIB", "s3EnetRedPortIndex"))
if mibBuilder.loadTexts: s3EnetRedPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetRedPortEntry.setDescription('An entry in the table of ports on boards with redundancy capability. Entries in the table cannot be created or deleted via SNMP. Row modification via SNMP is allowed only for ports that support either hardware or software redundancy, but the amount of modifications between the two varies. Entries for boards that support hardware-redundancy only allow the objects s3EnetRedPortRedundMode, s3EnetRedPortSwitchoverStatus, and s3EnetRedPortSwitchoverTime to be modified. The object s3EnetRedPortRedundMode can only be modified on certain agent versions (see the description of the object for more details). Entries for boards that support software-redundancy allow the objects s3EnetRedPortRedundMode, s3EnetRedPortCompanionSlotNo, s3EnetRedPortCompanionPortNo, s3EnetRedPortSwitchoverStatus, and s3EnetRedPortSwitchoverTime to be modified. Software-redundant pairs are configured by sending the objects s3EnetRedPortRedundMode, s3EnetRedPortCompanionSlotNo, and s3EnetRedPortCompanionPortNo in the same SNMP SET PDU, with the object s3EnetRedPortRedundMode set to the value of swActive(4) or swStandby(5). When changing an existing software-redundant pair, the existing pair must first be broken up by setting the object s3EnetRedPortRedundMode to standalone(1), and then a new pair must be configured as described above.')
s3EnetRedPortBoardIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 3, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetRedPortBoardIndex.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetRedPortBoardIndex.setDescription("The index of the slot containing the board. The value for each board must remain constant at least from one re-initialization of the entity's network management system to the next re-initialization.")
s3EnetRedPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 3, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetRedPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetRedPortIndex.setDescription('The index of the port on the module.')
s3EnetRedPortRedundMode = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 3, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("standAlone", 1), ("hwActive", 2), ("hwStandby", 3), ("swActive", 4), ("swStandby", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3EnetRedPortRedundMode.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetRedPortRedundMode.setDescription('The redundancy mode of the port. The possible values read, which report the redundancy mode of the port, are: standalone(1)...the port is not in any redundant pair. hwActive(2).....the port is the active companion in a hardware-redundant pair. hwStandby(3)....the port is the standby companion in a hardware-redundant pair. swActive(4).....the port is the active companion in a software-redundant pair. swStandby(5)....the port is the standby companion in a software-redundant pair. The values that can be written, which change the redundancy mode, are: standalone(1)...causes the software-redundant pair to be broken up. hwActive(2).....if the previous value was hwStandby(3), this value will cause the port to become the active port in the hardware-redundant pair (i.e., a switchover). hwStandby(3)....if the previous value was hwActive(2), this value will cause the port to become the standby port in the hardware-redundant pair (i.e., a switchover). swActive(4).....if the previous value was swStandby(5), this value will cause the port to become the active port in the software-redundant pair (i.e., a switchover). swStandby(5)....if the previous value was swActive(4), this value will cause the port to become the standby port in the software-redundant pair (i.e., a switchover). Notes: 1.) The value standalone(1) cannot be written to effect hardware-redundant pairs.')
s3EnetRedPortOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 3, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("localFault", 3), ("remoteFault", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetRedPortOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetRedPortOperStatus.setDescription("This object indicates port's redundancy status. The values are: other(1).........none of the following ok(2)............no fault localFault(3)....the local port has sensed a fault condition. remoteFault(4)...the remote port has sensed a fault condition and has signaled the local port accordingly. Either a localFault(3) or remoteFault(4) condition should cause a redundant port pair to switchover. Notes: If the redundant link is generating on 10BASE-FL without remote fault capability, the value remoteFault(4) will not be reported.")
s3EnetRedPortRemoteOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 3, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("snpxFLRemFltCpblPortUp", 1), ("snpxFLFBRemFltCpblPortUp", 2), ("tenBaseFLPortUp", 3), ("tenBaseFBPortUp", 4), ("snpxRemFltCpblPortFault", 5), ("tenBaseFBPortFault", 6), ("unknown", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetRedPortRemoteOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetRedPortRemoteOperStatus.setDescription('This object reflects the real time status of the received data from the remote port. A value of snpxFLRemFltCpblPortUp(1) indicates that the remote port is capable of 10BASE-FL signaling, as well as SynOptics proprietary remote fault signaling. A remote fault on such a port is indicated by snpxRemFltCpblPortFault(5). A value of snpxFLFBRemFltCpblPortUp(2) indicates that the remote port is capable of 10BASE-FL, 10BASE-FB and SynOptics proprietary remote fault signaling. A remote fault on such a port is indicated by snpxRemFltCpblPortFault(5). A value of tenBaseFLPortUp(3) indicates that the remote port uses regular idle 10BASE-FL signaling, and is incapable of remote fault signaling. A value of tenBaseFBPortUp(4) indicates that the remote port uses 10BASE-FB synchronous signaling. A remote fault on such a port is indicated by tenBaseFBPortFault(6). A value of unknown(7) indicates that the remote signal received is none of the above.')
s3EnetRedPortCompanionSlotNo = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 3, 3, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3EnetRedPortCompanionSlotNo.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetRedPortCompanionSlotNo.setDescription('The slot number of the other port which is in the redundant pair. In the case of a standalone port, a value of 0 will be returned. Note: This object is only writable for ports that support software-redundancy.')
s3EnetRedPortCompanionPortNo = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 3, 3, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3EnetRedPortCompanionPortNo.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetRedPortCompanionPortNo.setDescription('The port number of the other port which is in the redundant pair. In the case of a standalone port, a value of 0 will be returned. Note: This object is only writable for ports that support software-redundancy.')
s3EnetRedPortSwitchoverStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 3, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("timedSwitchover", 2))).clone('other')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3EnetRedPortSwitchoverStatus.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetRedPortSwitchoverStatus.setDescription('The switchover status of the redundant port pair. The following values can be written: timedSwitchover(2)...Immediately causes the active port to become the standby port, and the standby port to become the active port. Then once the value of s3EnetRedPortSwitchoverTime has elapsed to zero, the ports revert back to their orignal roles. The following values can be read: other(1).............The port is NOT undergoing a timed switchover. timedSwitchover(2)...The port is undergoing a timed switchover. Notes: 1.) When writing timedSwitchover(2) to this object, the SET request must also specify a value for the object s3EnetRedSwitchoverTime. 2.) Once the timed switchover has taken place, the value of this object reverts from timedSwitchover(2) to other(1).')
s3EnetRedPortSwitchoverTime = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 3, 3, 1, 9), TimeTicks()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3EnetRedPortSwitchoverTime.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetRedPortSwitchoverTime.setDescription('The length of time before the ports making up the redundant port pair revert back to their orignal active or standby roles as defined before the timed switchover was setup. The value of this object is meaningful (i.e., non-zero) only when the redundant port pair is undergoing a timed switchover, which is indicated by the object s3EnetRedPortSwitchoverStatus having the value of timedSwitchover(2). This object may only be written in the same SET request that changes the object s3EnetRedPortSwitchoverStatus to timedSwitchover(2). Afterwards, it indicates the amount of time left before the timed switchover is completed, at which time another switchover occurs and s3EnetRedPortSwitchoverStatus is changed to other(1). This object has the value of zero if the port is not undergoing a timed switchover, or if the amount of time is unavailable.')
s3EnetRedPortCapability = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 3, 3, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("hwRedOnly", 1), ("swRedOnly", 2), ("notRedunCapable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetRedPortCapability.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetRedPortCapability.setDescription('The redundancy capability of the port: hwRedOnly(1).........hardware redundancy only. swRedOnly(2).........software redundacy only. notRedunCapable(3)...port not capable of being configured into a redundant port pair. A value of hwRedOnly(1) or swRedOnly(2) means that the port is capable of being configured into a redundant port pair.')
s3EnetRedPortLastChg = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 3, 4), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetRedPortLastChg.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetRedPortLastChg.setDescription('The value of sysUptime when the last change in the redundant ports table was observed by the agent.')
s3EnetNmmType = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 4, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("m3313", 2), ("m3313M", 3), ("m3314-ST", 4), ("m3314M-ST", 5), ("m3138", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetNmmType.setStatus('obsolete')
if mibBuilder.loadTexts: s3EnetNmmType.setDescription('See s3AgentType')
s3EnetNmmMdaHwVer = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 4, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetNmmMdaHwVer.setStatus('obsolete')
if mibBuilder.loadTexts: s3EnetNmmMdaHwVer.setDescription('See AgentMdaHwVer')
s3EnetNmmFwVer = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 4, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetNmmFwVer.setStatus('obsolete')
if mibBuilder.loadTexts: s3EnetNmmFwVer.setDescription('See s3AgentFwVer')
s3EnetNmmSwMajorVer = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 4, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetNmmSwMajorVer.setStatus('obsolete')
if mibBuilder.loadTexts: s3EnetNmmSwMajorVer.setDescription('See s3AgentSwMajor')
s3EnetNmmSwMinorVer = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 4, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetNmmSwMinorVer.setStatus('obsolete')
if mibBuilder.loadTexts: s3EnetNmmSwMinorVer.setDescription('See s3AgentSwMinor')
s3EnetNmmStatus = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 4, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("offline", 1), ("online", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetNmmStatus.setStatus('obsolete')
if mibBuilder.loadTexts: s3EnetNmmStatus.setDescription('See s3AgentStatus')
s3EnetNmmMode = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 4, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("primary", 1), ("secondary", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3EnetNmmMode.setStatus('obsolete')
if mibBuilder.loadTexts: s3EnetNmmMode.setDescription('See s3AgentMode')
s3EnetNmmReset = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 4, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notreset", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3EnetNmmReset.setStatus('obsolete')
if mibBuilder.loadTexts: s3EnetNmmReset.setDescription('See s3AgentReset')
s3EnetNmmRestart = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 4, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notrestart", 1), ("restart", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3EnetNmmRestart.setStatus('obsolete')
if mibBuilder.loadTexts: s3EnetNmmRestart.setDescription('See s3AgentRestart')
s3EnetNmmIpAddr = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 4, 10), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3EnetNmmIpAddr.setStatus('obsolete')
if mibBuilder.loadTexts: s3EnetNmmIpAddr.setDescription('See s3AgentIpAddr')
s3EnetNmmNetMask = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 4, 11), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3EnetNmmNetMask.setStatus('obsolete')
if mibBuilder.loadTexts: s3EnetNmmNetMask.setDescription('See s3AgentNetMask')
s3EnetNmmDefaultGateway = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 4, 12), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3EnetNmmDefaultGateway.setStatus('obsolete')
if mibBuilder.loadTexts: s3EnetNmmDefaultGateway.setDescription('See s3AgentDefaultGateway')
s3EnetNmmFileServerAddr = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 4, 13), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3EnetNmmFileServerAddr.setStatus('obsolete')
if mibBuilder.loadTexts: s3EnetNmmFileServerAddr.setDescription('See s3AgentBootServerAddr')
s3EnetNmmBootFile = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 4, 14), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3EnetNmmBootFile.setStatus('obsolete')
if mibBuilder.loadTexts: s3EnetNmmBootFile.setDescription('See s3AgentBootFile')
s3EnetNmmBootMode = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 4, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eeprom", 1), ("bootp", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3EnetNmmBootMode.setStatus('obsolete')
if mibBuilder.loadTexts: s3EnetNmmBootMode.setDescription('See s3AgentBootMode')
s3EnetNmmWriteEeprom = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 4, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notWriteEeprom", 1), ("writeEeprom", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3EnetNmmWriteEeprom.setStatus('obsolete')
if mibBuilder.loadTexts: s3EnetNmmWriteEeprom.setDescription('See s3AgentWriteEeprom')
s3EnetNmmBaudRate = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 4, 17), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetNmmBaudRate.setStatus('obsolete')
if mibBuilder.loadTexts: s3EnetNmmBaudRate.setDescription('See s3AgentBaudRate')
s3EnetNmmInitString = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 4, 18), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3EnetNmmInitString.setStatus('obsolete')
if mibBuilder.loadTexts: s3EnetNmmInitString.setDescription('See s3AgentInitString')
s3EnetNmmLocation = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 4, 19), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3EnetNmmLocation.setStatus('obsolete')
if mibBuilder.loadTexts: s3EnetNmmLocation.setDescription('See s3AgentLocation')
s3EnetNmmTrapServerTable = MibTable((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 4, 20), )
if mibBuilder.loadTexts: s3EnetNmmTrapServerTable.setStatus('obsolete')
if mibBuilder.loadTexts: s3EnetNmmTrapServerTable.setDescription('See s3AgentTrapReceiverTable')
s3EnetNmmTrapServerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 4, 20, 1), ).setIndexNames((0, "SYNOPTICS-ETHERNET-MIB", "s3EnetNmmTrapServerAddress"))
if mibBuilder.loadTexts: s3EnetNmmTrapServerEntry.setStatus('obsolete')
if mibBuilder.loadTexts: s3EnetNmmTrapServerEntry.setDescription('See s3AgentTrapReceiverEntry')
s3EnetNmmTrapType = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 4, 20, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3EnetNmmTrapType.setStatus('obsolete')
if mibBuilder.loadTexts: s3EnetNmmTrapType.setDescription('See s3AgentTrapRcvrStatus')
s3EnetNmmTrapServerAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 4, 20, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3EnetNmmTrapServerAddress.setStatus('obsolete')
if mibBuilder.loadTexts: s3EnetNmmTrapServerAddress.setDescription('See s3AgentTrapRcvrNetAddress')
s3EnetNmmTrapServerComm = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 4, 20, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3EnetNmmTrapServerComm.setStatus('obsolete')
if mibBuilder.loadTexts: s3EnetNmmTrapServerComm.setDescription('See s3AgentTrapRcvrComm')
s3EnetNmmAuthTrap = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 4, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3EnetNmmAuthTrap.setStatus('obsolete')
if mibBuilder.loadTexts: s3EnetNmmAuthTrap.setDescription('See s3AgentAuthTrap')
s3EnetShowNodesTable = MibTable((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 5, 1), )
if mibBuilder.loadTexts: s3EnetShowNodesTable.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetShowNodesTable.setDescription('Table containing a list of all of the nodes that have been active during the aging interval that are currently connected to the network through this concentrator. This table is different from the FindNodes table in that this table is indexed using the slot, port, and MAC address attributes associated with the node. This allows a manager to get all nodes based on slot, slot-port, or slot-port-MAC.')
s3EnetShowNodesEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 5, 1, 1), ).setIndexNames((0, "SYNOPTICS-ETHERNET-MIB", "s3EnetShowNodesSlotIndex"), (0, "SYNOPTICS-ETHERNET-MIB", "s3EnetShowNodesPortIndex"), (0, "SYNOPTICS-ETHERNET-MIB", "s3EnetShowNodesMacAddress"))
if mibBuilder.loadTexts: s3EnetShowNodesEntry.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetShowNodesEntry.setDescription('List of nodes active on the concentrator and the slot and port the nodes are on.')
s3EnetShowNodesSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 5, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetShowNodesSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetShowNodesSlotIndex.setDescription('The board number the node is on. Valid entries are 1-12.')
s3EnetShowNodesPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 5, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetShowNodesPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetShowNodesPortIndex.setDescription('The port number the node is on. Valid entries are 1-12.')
s3EnetShowNodesMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 5, 1, 1, 3), PhysAddress().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetShowNodesMacAddress.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetShowNodesMacAddress.setDescription('This object contains the MAC address (i.e. the Ethernet address) of the node.')
s3EnetShowNodesStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 5, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetShowNodesStatus.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetShowNodesStatus.setDescription('The status of the node. Determines whether the node has actively transmitted or not over the last 5 seconds.')
s3EnetShowNodesVendorType = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 5, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("threeCom", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetShowNodesVendorType.setStatus('deprecated')
if mibBuilder.loadTexts: s3EnetShowNodesVendorType.setDescription('The vendor type of the adapter seen on this port. If the vendor is unknown other(1) should be returned.')
s3EnetShowNodesAuthStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 5, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("network", 2), ("nmm", 3), ("authorized", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetShowNodesAuthStatus.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetShowNodesAuthStatus.setDescription("The object is used determine how the node was added to this table. If the node was learned by listening to the network then on reads network(2) should be returned. If the node is another NMM or known concentrator device, then nmm(3) is returned. If the device's MAC address is unknown because of some unknown but legal configuration, then other(1) should be returned and s3EnetShowNodesMacAddress should return all zeros. If the node was entered into the AllowedNode list via management control, and was seen on a port that it was authorized to use, then authorized(4) should be returned.")
s3EnetNodeAgeInterval = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 5, 2), TimeTicks()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3EnetNodeAgeInterval.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetNodeAgeInterval.setDescription('The time used for aging of the nodes in tables s3EnetShowNodesTable and s3EnetFindNodesTable. Once a node has completely aged it will be removed from these tables. Note: Agents that implement the s3EnetSdTrafTable and s3EnetDsTrafTable tables and do not implement the the object s3EnetTrafAgeInterval (i.e., agents prior to version 5.3), also use s3EnetNodeAgeInterval to age the nodes in these two tables.')
s3EnetFindNodesTable = MibTable((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 5, 3), )
if mibBuilder.loadTexts: s3EnetFindNodesTable.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetFindNodesTable.setDescription('Table containing a list of all of the nodes that have been active during the aging interval that are currently connected to the network through this concentrator. This table is different than the ShowNodes table in that this table is index using only the MAC address attribute associated with the node. This allows a manager to be able to quickly determine if a node with a particular MAC address is located on this concentrator or not.')
s3EnetFindNodesEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 5, 3, 1), ).setIndexNames((0, "SYNOPTICS-ETHERNET-MIB", "s3EnetFindNodesMacAddress"))
if mibBuilder.loadTexts: s3EnetFindNodesEntry.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetFindNodesEntry.setDescription('Entry in the table containing the slot, port and MAC address of a node connected to the Ethernet through this concentrator.')
s3EnetFindNodesMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 5, 3, 1, 1), PhysAddress().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetFindNodesMacAddress.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetFindNodesMacAddress.setDescription('MAC address of node that this entry in the table is for.')
s3EnetFindNodesSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 5, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetFindNodesSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetFindNodesSlotIndex.setDescription('The board that the node is connected through.')
s3EnetFindNodesPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 5, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetFindNodesPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetFindNodesPortIndex.setDescription('The port that the node is connected through.')
s3EnetAuthNodesTable = MibTable((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 5, 4), )
if mibBuilder.loadTexts: s3EnetAuthNodesTable.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetAuthNodesTable.setDescription('Table containing a list of MAC addresses and the slot and ports that the MAC address is allowed to be heard on, in case the authorized node feature is turned on. If a MAC is allowed on any slot and port then the entry will have the slot=0 and the port=0. If the MAC address is allowed on a particular board then slot=allowed board and port=0. If the MAC is only allowed on one port then the entry will contain a slot value and port value between 1-12. Allowed nodes for LattisSecure ports must be configured for that specific port. The agent will reject an attempt to create a slot-level entry for slot=x, port=0, if the board in slot x is a LattisSecure Host Module. Only a single address may be configured for a LattisSecure port. Adding a second address (with the same LattisSecure slot-port number) to the table will cause the first address to be replaced with the new entry. A MAC address can only appear in the table one time. To determine when a station heard on the network must be verified in this table please read the complete description of the authorized node list feature as described with object S3EnetConcAuthStatus. Entries in this table may be downloaded via the CFG file or can be added via SNMP. All adds via SNMP will be lost when the system is reset.')
s3EnetAuthNodesEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 5, 4, 1), ).setIndexNames((0, "SYNOPTICS-ETHERNET-MIB", "s3EnetAuthNodesMacAddr"))
if mibBuilder.loadTexts: s3EnetAuthNodesEntry.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetAuthNodesEntry.setDescription('Entry in the table containing a MAC address of a node that is allowed on the ethernet through this concentrator.')
s3EnetAuthNodesMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 5, 4, 1, 1), PhysAddress().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3EnetAuthNodesMacAddr.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetAuthNodesMacAddr.setDescription('MAC address of node that this entry in the table is for.')
s3EnetAuthNodesSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 5, 4, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3EnetAuthNodesSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetAuthNodesSlotIndex.setDescription('The board that the node is allowed to be heard through. If this object is 0, then the MAC address is allowed on any board in the concentrator. In this case s3EnetAuthNodesPortIndex should also be 0. Otherwise, this object describes the slot that the MAC address of this entry is allowed to connect to.')
s3EnetAuthNodesPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 5, 4, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3EnetAuthNodesPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetAuthNodesPortIndex.setDescription('The port that the node is allowed to be heard through. If this object is 0, then the MAC address of this entry is allowed to connect to any port on the board (if s3EnetAuthNodesSlotIndex is not 0) or if s3EnetAuthNodesSlotIndex is 0, then the MAC address is allowed to be heard from any port on the concentrator. Otherwise, this object specifies which port on the s3EnetAuthNodesSlotIndex this MAC address is allowed to be heard on.')
s3EnetAuthNodesStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 5, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("invalid", 1), ("valid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3EnetAuthNodesStatus.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetAuthNodesStatus.setDescription('The status of the AuthNodes entry. The primary use of this object is for modifying the AuthNodes table. It is also returned in the enetAuthViolation trap, in which case it indicates whether the violating MAC address was found in the AuthNodes table. Setting this entry to invalid(1) causes the entry to be deleted from the table. Setting a new entry with valid(2) causes the entry to be created in the table. The response to a get request or get-next request will always indicate a status of valid(2), since invalid entries are removed from the table.')
s3EnetMaxNodesPerPort = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 5, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3EnetMaxNodesPerPort.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetMaxNodesPerPort.setDescription('Maximun number of MAC address remembered by the agent on a per port basis, this number should be smaller than the maximum limit imposed by the agent.')
s3EnetTopNmmTable = MibTable((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 6, 1, 1), )
if mibBuilder.loadTexts: s3EnetTopNmmTable.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetTopNmmTable.setDescription("A table of the NMM's in the flat network.")
s3EnetTopNmmEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 6, 1, 1, 1), ).setIndexNames((0, "SYNOPTICS-ETHERNET-MIB", "s3EnetTopNmmSlot"), (0, "SYNOPTICS-ETHERNET-MIB", "s3EnetTopNmmPort"), (0, "SYNOPTICS-ETHERNET-MIB", "s3EnetTopNmmIpAddr"))
if mibBuilder.loadTexts: s3EnetTopNmmEntry.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetTopNmmEntry.setDescription('Table that contains information about NMMs that are in the same flat network as this NMM.')
s3EnetTopNmmSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 6, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetTopNmmSlot.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetTopNmmSlot.setDescription('Slot that the NMM this entry is for can be found using the topology protocol. This is the slot from which a topology message was received.')
s3EnetTopNmmPort = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 6, 1, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetTopNmmPort.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetTopNmmPort.setDescription('Port that the NMM this entry is for can be found using the topology protocol. This is the port from which a topology message was received.')
s3EnetTopNmmIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 6, 1, 1, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetTopNmmIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetTopNmmIpAddr.setDescription('IpAddress of the NMM this entry is for. This is the IP address of the NMM that sent a topology message.')
s3EnetTopNmmMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 6, 1, 1, 1, 4), PhysAddress().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetTopNmmMacAddr.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetTopNmmMacAddr.setDescription('MAC Address of the NMM this entry is for.')
s3EnetTopNmmChassisType = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 6, 1, 1, 1, 5), SnpxChassisType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetTopNmmChassisType.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetTopNmmChassisType.setDescription('Concentrator type of the NMM this entry is for. The enumerated values of this object are the same as defined in the common MIB for object s3ChassisType.')
s3EnetTopNmmBkplType = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 6, 1, 1, 1, 6), SnpxBackplaneType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetTopNmmBkplType.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetTopNmmBkplType.setDescription('Concentrator backplane type of the NMM this entry is for. The enumerated values of this object are the same as defined in the common MIB for object s3ChassisBkplType.')
s3EnetTopNmmLocalSeg = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 6, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetTopNmmLocalSeg.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetTopNmmLocalSeg.setDescription('Does this entry NMM exist in the same segment as this (the reporting) NMM.')
s3EnetTopNmmNumSeen = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 6, 1, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetTopNmmNumSeen.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetTopNmmNumSeen.setDescription('Number of NMMs visible from the slot-port pair that this NMM is seen through.')
s3EnetTopNmmModuleType = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 6, 1, 1, 1, 9), S3ModuleType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetTopNmmModuleType.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetTopNmmModuleType.setDescription('The module type of the NMM that this entry is for. The values of this object are equivalent to those defined in the common MIB for object s3SlotModuleType.')
s3EnetTopNmmNumLinks = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 6, 1, 1, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetTopNmmNumLinks.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetTopNmmNumLinks.setDescription('Number of links through which NMMs are visible on this NMM.')
s3EnetTopNmmChgStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 6, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("changed", 1), ("noChange", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetTopNmmChgStatus.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetTopNmmChgStatus.setDescription('If this NMM has detected any change of topology relative to itself it will set this object to change(1), otherwise noChange(2) will be returned.')
s3EnetTopNmmHelloTime = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 6, 1, 2), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetTopNmmHelloTime.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetTopNmmHelloTime.setDescription('Hello Time interval used in the topology update protocol.')
s3EnetTopNmmSubsetTable = MibTable((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 6, 1, 3), )
if mibBuilder.loadTexts: s3EnetTopNmmSubsetTable.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetTopNmmSubsetTable.setDescription('Encoded octet string of the s3EnetTopNmmTable.')
s3EnetTopNmmSubsetEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 6, 1, 3, 1), ).setIndexNames((0, "SYNOPTICS-ETHERNET-MIB", "s3EnetTopNmmSlot"), (0, "SYNOPTICS-ETHERNET-MIB", "s3EnetTopNmmPort"), (0, "SYNOPTICS-ETHERNET-MIB", "s3EnetTopNmmIpAddr"))
if mibBuilder.loadTexts: s3EnetTopNmmSubsetEntry.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetTopNmmSubsetEntry.setDescription('Encoded octet string of the s3EnetTopNmmTable. Instance returned in Response PDU: On GETs: instance specified is the instance returned. On GET-NEXTs: instance returned is the instance of the last record contained in the octet string.')
s3EnetTopNmmSubset = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 6, 1, 3, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 1400))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetTopNmmSubset.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetTopNmmSubset.setDescription('Encoded octet string. On reads it contains an integral number of s3EnetTopNmmEntry records. All entries are the same size. Values are specified in SynOptics technical documents.')
s3EnetTopBridgeTable = MibTable((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 6, 2, 1), )
if mibBuilder.loadTexts: s3EnetTopBridgeTable.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetTopBridgeTable.setDescription('A table of Bridges that are in the same segment as this NMM network.')
s3EnetTopBridgeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 6, 2, 1, 1), ).setIndexNames((0, "SYNOPTICS-ETHERNET-MIB", "s3EnetTopBridgeIpAddr"))
if mibBuilder.loadTexts: s3EnetTopBridgeEntry.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetTopBridgeEntry.setDescription('Table that contains information about Bridges that are in the same segment as this NMM.')
s3EnetTopBridgeIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 6, 2, 1, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetTopBridgeIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetTopBridgeIpAddr.setDescription('IP address of the bridge from the Hello PDU.')
s3EnetTopBridgeNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 6, 2, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetTopBridgeNumber.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetTopBridgeNumber.setDescription('Bridge Number assigned to this bridge.')
s3EnetTopBridgeMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 6, 2, 1, 1, 3), PhysAddress().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetTopBridgeMacAddr.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetTopBridgeMacAddr.setDescription('MAC Address of this bridge.')
s3EnetTopBridgeType = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 6, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("localSyn2Port", 2), ("remoteSyn3Port", 3), ("etherSwitch", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetTopBridgeType.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetTopBridgeType.setDescription('Kind of bridge this entry represents.')
s3EnetTopBridgeStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 6, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("active", 2), ("standby", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetTopBridgeStatus.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetTopBridgeStatus.setDescription('Current operational status of this bridge.')
s3EnetTopBridgeSlotNum = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 6, 2, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetTopBridgeSlotNum.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetTopBridgeSlotNum.setDescription('Slot on the concentrator that the Hello PDU from the bridge was received.')
s3EnetTopBridgePortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 6, 2, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetTopBridgePortNum.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetTopBridgePortNum.setDescription('Port on concentrator that the Hello PDU from the bridge was received.')
s3EnetTopBridgeModuleType = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 6, 2, 1, 1, 8), S3ModuleType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetTopBridgeModuleType.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetTopBridgeModuleType.setDescription('Module type of the board that the Hello PDU from the Bridge was received.')
s3EnetTopBridgeHelloPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 6, 2, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetTopBridgeHelloPortNum.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetTopBridgeHelloPortNum.setDescription('Port Number on the Bridge from which the Hello PDU was sent.')
s3EnetTopBridgeHelloPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 6, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("ether", 2), ("tokenRing4", 3), ("tokenRing16", 4), ("fddi", 5), ("t1", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetTopBridgeHelloPortType.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetTopBridgeHelloPortType.setDescription('Type of the Port on the Bridge from which the Hello PDU was sent.')
s3EnetTopBridgeHelloPortStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 6, 2, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("active", 2), ("standby", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetTopBridgeHelloPortStatus.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetTopBridgeHelloPortStatus.setDescription('Status of the Port on the Bridge from which the Hello PDU was sent.')
s3EnetTopBridgeCompBridgeMac1 = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 6, 2, 1, 1, 12), PhysAddress().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetTopBridgeCompBridgeMac1.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetTopBridgeCompBridgeMac1.setDescription('Contains one of the 2 companion MAC addresses of the remote bridge. If this entry is for a local bridge or is unknown, then this object should contain the MAC address of 0:0:0:0:0:0.')
s3EnetTopBridgeCompBridgeMac2 = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 6, 2, 1, 1, 13), PhysAddress().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetTopBridgeCompBridgeMac2.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetTopBridgeCompBridgeMac2.setDescription('Contains one of the 2 companion MAC addresses of the remote bridge. If this entry is for a local bridge or is unknown, then this object should contain the MAC address of 0:0:0:0:0:0.')
s3EnetTopBdgSubsetTable = MibTable((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 6, 2, 2), )
if mibBuilder.loadTexts: s3EnetTopBdgSubsetTable.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetTopBdgSubsetTable.setDescription('Encoded octet string of the s3EnetTopBridgeTable.')
s3EnetTopBdgSubsetEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 6, 2, 2, 1), ).setIndexNames((0, "SYNOPTICS-ETHERNET-MIB", "s3EnetTopBridgeIpAddr"))
if mibBuilder.loadTexts: s3EnetTopBdgSubsetEntry.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetTopBdgSubsetEntry.setDescription('Encoded octet string of the s3EnetTopBridgeTable. Instance returned in Response PDU: On GETs: instance specified is the instance returned. On GET-NEXTs: instance returned is the instance of the last record contained in the octet string.')
s3EnetTopBdgSubset = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 6, 2, 2, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 1400))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetTopBdgSubset.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetTopBdgSubset.setDescription('Encoded octet string. On reads it contains an integral number of s3EnetTopBridgeEntry records. All entries are the same size. Values are specified in SynOptics technical documents.')
s3EnetTopNmmLstChg = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 6, 3, 1), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetTopNmmLstChg.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetTopNmmLstChg.setDescription('The value of sysUpTime the last time an entry in the NMM topology table was added, deleted, or modified. If the NMM topology table has not changed since cold/warm start of the agent, then the value is zero.')
s3EnetTopBridgeLstChg = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 6, 3, 2), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetTopBridgeLstChg.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetTopBridgeLstChg.setDescription('The value of sysUpTime the last time an entry in the bridge topology table was added, deleted, or modified. If the bridge topology table has not changed since cold/warm start of the agent, then the value is zero.')
s3EnetThreshTable = MibTable((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 8, 1), )
if mibBuilder.loadTexts: s3EnetThreshTable.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetThreshTable.setDescription('The table of thresholds. There are three kinds of thresholds supported in the threshold table: port thresholds, slot thresholds, and concentrator thresholds. The object s3EnetThreshObject in the threshold table is used to specify the kind of threshold for the table entry. When the value of the object s3EnetThreshObject is port(4), the threshold entry applies to a specific port, which is identified by the value of the objects s3EnetThreshSlot and s3EnetThreshPort. The port must be on the same segment as the NMM in order for the NMM to monitor the threshold. When the value of the object s3EnetThreshObject is slot(3), the threshold entry applies to a specific slot, which is identified by the value of the object s3EnetThreshSlot. The slot must be on the same segment as the NMM in order for the NMM to monitor the threshold. When the value of the object s3EnetThreshObject is concentrator(2), the threshold entry applies to the segment the NMM is connected to within the concentrator.')
s3EnetThreshEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 8, 1, 1), ).setIndexNames((0, "SYNOPTICS-ETHERNET-MIB", "s3EnetThreshIndex"))
if mibBuilder.loadTexts: s3EnetThreshEntry.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetThreshEntry.setDescription('A row in the Ethernet Threshold Table. The following columns must be specified in a SNMP SET request to create a row in the table for each of the three kinds of thresholds (each name is prefixed by s3EnetThresh): PORT SLOT CONCENTRATOR ========= ========= ============ Status=(1) Status=(1) Status=(1) Object=(4) Object=(3) Object=(2) Slot Slot Port Type Type Type Condition Condition Condition SetValue SetValue SetValue Action Action Action *Duration Duration Duration with the object s3EnetThreshStatus set to the value addActive(1). Notes: 1.) The value of s3EnetThreshObject selects the kind of threshold for the row (i.e., for port thresholds it is set to the value port(4), for slot thresholds it is set to the value slot(3), and for concentrator thresholds it is set to the value concentrator(2)). 2.) The object s3EnetThreshPort is not used for creating slot level thresholds, and is set to 0 by the agent when the row is created. 3.) The objects s3EnetThreshPort and s3EnetThreshSlot are not used for creating concentrator level thresholds, and are both set to 0 by the agent when the row is created. 4.) The value of s3EnetThreshDuration is ignored for port level link status thresholds. To delete a row in the table, the object s3EnetThreshStatus needs to be specified in a SNMP SET request with its value equal to delDead(2).')
s3EnetThreshIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 8, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetThreshIndex.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetThreshIndex.setDescription('The index into the threshold table.')
s3EnetThreshStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 8, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("addActive", 1), ("delDead", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3EnetThreshStatus.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetThreshStatus.setDescription('The status of the threshold. The possible values for a write are: addActive(1)...If the entry does not exist, the entry is created as long as the other necessary objects are in the SNMP SET request. If the entry does exist and is inactive, it is activated. delDead(2).....Causes the entry to be deleted from the table. It could take 5 seconds after delDead(2) is written to actually delete the entry due to task scheduling. The possible values for a read are: addActive(1)...This threshold entry is active. delDead(2).....This threshold entry is inactive and will be deleted in 5 seconds or less.')
s3EnetThreshObject = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 8, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("concentrator", 2), ("slot", 3), ("port", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3EnetThreshObject.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetThreshObject.setDescription('Specifies the part of the concentrator the threshold applies. The possible values are: other(1)..........Unknown threshold (error) concentrator(2)...The threshold applies to the segment the NMM is connected to within the concentrator slot(3)...........The threshold applies to a specific slot in the concentrator identified by s3EnetThreshSlot port(4)...........The threshold applies to a specific port in the concentrator identified by s3EnetThreshSlot and s3EnetThreshPort All values are read-write with the exception of other(1), which is read-only. See the description of the object s3EnetThreshType for the explanation of which thresholds are applicable to port(4), slot(3), and concentrator(2).')
s3EnetThreshSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 8, 1, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3EnetThreshSlot.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetThreshSlot.setDescription('If s3EnetThreshObject is slot(3) or port(4), then this contains a valid slot. Otherwise, the contents of this object is meaningless.')
s3EnetThreshPort = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 8, 1, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3EnetThreshPort.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetThreshPort.setDescription('If s3EnetThreshObject is port(4), then this contains a valid port. Otherwise, the contents of this object is meaningless.')
s3EnetThreshType = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 8, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22))).clone(namedValues=NamedValues(("other", 1), ("goodBytes", 2), ("goodPkts", 3), ("badPkts", 4), ("crcPkts", 5), ("misaligned", 6), ("runtPkts", 7), ("fragPkts", 8), ("tooLong", 9), ("collision", 10), ("lateColls", 11), ("linkStatus", 12), ("multicast", 13), ("broadcast", 14), ("shortEvents", 15), ("srcAddrChanges", 16), ("dataRateMismatches", 17), ("networkErrors", 18), ("badToGoodPktRatio", 19), ("netErrToGoodPktRatio", 20), ("colltoGoodPktRatio", 21), ("collBackOffErr", 22)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3EnetThreshType.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetThreshType.setDescription('Determines which type of threshold applies to this entry. The possible values that can be read and written are listed below. Applicable to ALL Thresholds ============================================== goodBytes(2).........Count of good bytes goodPkts(3)..........Count of good packets badPkts(4)...........Count of bad packets crcPkts(5)...........Count of packets with CRC errors misaligned(6)........Count of misaligned packets runtPkts(7)..........Count of runt packets fragPkts(8)..........Count of fragmented packets tooLong(9)...........Count of too long packets collision(10)........Count of collisions lateColls(11)........Count of late collisions multicast(13)........Count of multicast packets broadcast(14)........Count of broadcast packets shortEvents(15)......Count of short events dataRateMismatches(17).... Count of data rate mismatches networkErrors(18)......... Count of short events, late collisions, and data rate mismatches badToGoodPktRatio(19)..... Ratio of bad packets to good packets, where bad packets is the sum of packets with alignment errors, packets with FCS errors, runt packets, and packets that are too long netErrToGoodPktRatio(20)... Ratio of network error packets to good packets, where network error packets is the sum of short event packets, packets with late collisions, and data rate mismatch packets colltoGoodPktRatio(21)..... Ratio of collision packets to good packets Applicable ONLY to Port Thresholds ============================================== linkStatus(12).......Status of the link srcAddrChanges(16)...Count of source address changes Applicable ONLY to Concentrator Thresholds ============================================== collBackOffErr(22)...Count of collision backoff errors Note: 1.) The value other(1) can only be read and it indicates the entry has an invalid or unknown threshold type.')
s3EnetThreshCondition = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 8, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("other", 1), ("crossValue", 2), ("overValue", 3), ("overRate", 4), ("linkOn", 5), ("linkOff", 6), ("overRatio", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3EnetThreshCondition.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetThreshCondition.setDescription('Conditions that set off the threshold. The possible values are: other(1)........None of the following crossValue(2)...The value of s3EnetThreshActualValue crosses the value of s3EnetThreshSetValue (i.e., either from lower to higher or from higher to lower) overValue(3)....The value of s3EnetThreshActualValue is greater than s3EnetThreshSetValue overRate(4).....The rate of s3EnetThreshActualValue/sec is greater than s3EnetThreshSetValue/sec linkOn(5).......The link status of the port has changed to ON linkOff(6)......The link status of the port has changed to OFF overRatio(7)....The ratio in s3EnetThreshActualValue is greater than s3EnetThreshSetValue. Both values are in units of 0.01% (i.e., 100 equals 1.0%) The values that the object s3EnetThreshCondition can have is actually dependent on the value of the object s3EnetThreshType. The table below shows the valid combinations between the two objects. If s3EnetThreshType Allowed Values For Is Equal To s3EnetThreshCondition Are =================== ========================= goodBytes(2) 2, 3, 4 goodPkts(3) 2, 3, 4 badPkts(4) 2, 3, 4 crcPkts(5) 2, 3, 4 misaligned(6) 2, 3, 4 runtPkts(7) 2, 3, 4 fragPkts(8) 2, 3, 4 tooLong(9) 2, 3, 4 collision(10) 2, 3, 4 lateColls(11) 2, 3, 4 linkStatus(12) 5, 6 multicast(13) 2, 3, 4 broadcast(14) 2, 3, 4 shortEvents(15) 2, 3, 4 srcAddrChanges(16) 2, 3, 4 dataRateMismatches(17) 2, 3, 4 networkErrors(18) 2, 3, 4 badToGoodPktRatio(19) 7 netErrToGoodPktRatio(20) 7 colltoGoodPktRatio(21) 7 collBackOffErr(22) 2, 3, 4 When the condition specified is crossValue(2) or overValue(3), the value of s3EnetThreshActualValue is accumulated from the beginning of the duration window and is checked every 5 seconds. When the condition specified is overRate(4) or overRatio(5), and the duration is less than or equal to 5 seconds, the value of s3EnetThreshActualValue is based on the data accumulated during the 5 second sampling period. When the condition specified is overRate(4) or overRatio(5), and the duration is greater than 5 seconds, the value of s3EnetThreshActualValue is based on the data accumulated during the entire duration window.')
s3EnetThreshSetValue = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 8, 1, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3EnetThreshSetValue.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetThreshSetValue.setDescription('Threshold setting value.')
s3EnetThreshActualValue = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 8, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetThreshActualValue.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetThreshActualValue.setDescription('Current value of the threshold counter. This object is set to zero at the begining of each duration window.')
s3EnetThreshAction = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 8, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))).clone(namedValues=NamedValues(("other", 1), ("noAction", 2), ("sendTrap", 3), ("res4", 4), ("res5", 5), ("partSlot", 6), ("partSlotPort", 7), ("res8", 8), ("res9", 9), ("trapPartSlot", 10), ("trapPartSlotPort", 11)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3EnetThreshAction.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetThreshAction.setDescription('Determines what action is to take place if the threshold condition occurs. The possible values that can be read and written are listed below. Applicable to ALL Thresholds ============================================== noAction(2)............Take no action sendTrap(3)............Send a trap Applicable ONLY to Port Thresholds ============================================== partSlot(6)............Partition the slot identified by s3EnetThreshSlot partSlotPort(7)........Partition the port identified by s3EnetThreshSlot and s3EnetThreshPort Applicable ONLY to Slot Thresholds ============================================== trapPartSlot(10).......Send a trap and partition the slot identified by s3EnetThreshSlot trapPartSlotPort(11)...Send a trap and partition the port identified by s3EnetThreshSlot and s3EnetThreshPort Notes: 1.) The value other(1) can only be read and it indicates the entry has an invalid or unknown threshold action. 2.) The values res4(4), res5(5), res8(8), and res9(9) are no longer used and should never be read or written. The timing and frequency of the action taken when the threshold condition is met is dependent upon the type of condition (i.e., s3EnetThreshCondition) and the length of the duration window (i.e., s3EnetThreshDuration). If the threshold conditionis crossValue(2), the action will be taken only ONCE during the duration window at the sampling period the condition is first met. If the threshold condition is overValue(3), linkOn(5), or linkOff(6), the action will be taken at each sampling period the condition is met until the end of the duration window. If the threshold condition is overRate(4) or overRatio(5) the action will be taken only ONCE at the end of the duration window if the condition is met.')
s3EnetThreshExceedCount = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 8, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetThreshExceedCount.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetThreshExceedCount.setDescription('Counter for how many times the selected threshold has reached its setting value.')
s3EnetThreshDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 8, 1, 1, 12), TimeTicks()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3EnetThreshDuration.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetThreshDuration.setDescription('Length of window over which threshold counts are summed, specified in intervals of 500 TimeTicks (i.e., 5 seconds). This window is broken down into 5 second sampling periods for purposes of checking the threshold conditions, and determining when the actions specified need to take place when the condition occurs. If this object is written with a value that is not evenly divisible by 500, the agent will internally round the value up to the closest integral of 500 before it is used in threshold calculations (i.e., a value of 12 can be written, but will be interpreted as 15). Notes: 1.) A value of zero indicates an infinite duration window if the value of s3EnetThreshCondition is crossValue(2) or overValue(3). 2.) If the value of s3EnetThreshCondition is overRate(4) or overRatio(5), a value of zero is equivalent to a duration window of 5 seconds. 3.) If the value of s3EnetThreshType is linkStatus(12), this value of this object is ignore and assumed to be infinite.')
s3EnetThreshTableSize = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 8, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetThreshTableSize.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetThreshTableSize.setDescription('The maximum number of entries in the table s3EnetThreshTable.')
s3EnetSdTrafTable = MibTable((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 9, 1), )
if mibBuilder.loadTexts: s3EnetSdTrafTable.setStatus('deprecated')
if mibBuilder.loadTexts: s3EnetSdTrafTable.setDescription('This table contains a list of entries which provide SA-DA traffic information. Specifically frame and byte counter values are provided per unique SA-DA pair. The indexing scheme of this table allows an SA list to be retrieved using GETNEXT. An SA list is a list of entries that have a common SA, however, different DAs.')
s3EnetSdTrafEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 9, 1, 1), ).setIndexNames((0, "SYNOPTICS-ETHERNET-MIB", "s3EnetSdTrafMacSA"), (0, "SYNOPTICS-ETHERNET-MIB", "s3EnetSdTrafMacDA"))
if mibBuilder.loadTexts: s3EnetSdTrafEntry.setStatus('deprecated')
if mibBuilder.loadTexts: s3EnetSdTrafEntry.setDescription('An entry in the SA-DA traffic table.')
s3EnetSdTrafMacSA = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 9, 1, 1, 1), PhysAddress().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetSdTrafMacSA.setStatus('deprecated')
if mibBuilder.loadTexts: s3EnetSdTrafMacSA.setDescription('Source MAC address.')
s3EnetSdTrafMacDA = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 9, 1, 1, 2), PhysAddress().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetSdTrafMacDA.setStatus('deprecated')
if mibBuilder.loadTexts: s3EnetSdTrafMacDA.setDescription('Destination MAC address.')
s3EnetSdTrafFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 9, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetSdTrafFrames.setStatus('deprecated')
if mibBuilder.loadTexts: s3EnetSdTrafFrames.setDescription('The number of good frames received by the concentrator for a SA-DA pair.')
s3EnetSdTrafBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 9, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetSdTrafBytes.setStatus('deprecated')
if mibBuilder.loadTexts: s3EnetSdTrafBytes.setDescription('The number of bytes in good frames received by the concentrator for a SA-DA pair.')
s3EnetDsTrafTable = MibTable((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 9, 2), )
if mibBuilder.loadTexts: s3EnetDsTrafTable.setStatus('deprecated')
if mibBuilder.loadTexts: s3EnetDsTrafTable.setDescription('This table contains a list of entries which provide DA-SA traffic information. Specifically frame and byte counter values are provided per unique DA-SA pair. The indexing scheme of this table allows a DA list to be retrieved using GETNEXT. A DA list is a list of entries that have a common DA, however, different SAs.')
s3EnetDsTrafEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 9, 2, 1), ).setIndexNames((0, "SYNOPTICS-ETHERNET-MIB", "s3EnetDsTrafMacDA"), (0, "SYNOPTICS-ETHERNET-MIB", "s3EnetDsTrafMacSA"))
if mibBuilder.loadTexts: s3EnetDsTrafEntry.setStatus('deprecated')
if mibBuilder.loadTexts: s3EnetDsTrafEntry.setDescription('An entry in the DA-SA table.')
s3EnetDsTrafMacDA = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 9, 2, 1, 1), PhysAddress().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetDsTrafMacDA.setStatus('deprecated')
if mibBuilder.loadTexts: s3EnetDsTrafMacDA.setDescription('Destination MAC address.')
s3EnetDsTrafMacSA = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 9, 2, 1, 2), PhysAddress().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetDsTrafMacSA.setStatus('deprecated')
if mibBuilder.loadTexts: s3EnetDsTrafMacSA.setDescription('Source MAC address.')
s3EnetDsTrafFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 9, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetDsTrafFrames.setStatus('deprecated')
if mibBuilder.loadTexts: s3EnetDsTrafFrames.setDescription('The number of good frames received by the concentrator for a DA-SA pair.')
s3EnetDsTrafBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 9, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetDsTrafBytes.setStatus('deprecated')
if mibBuilder.loadTexts: s3EnetDsTrafBytes.setDescription('The number of bytes in good frames received by the concentrator for a DA-SA pair.')
s3EnetPagedTrafTable = MibTable((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 9, 3), )
if mibBuilder.loadTexts: s3EnetPagedTrafTable.setStatus('deprecated')
if mibBuilder.loadTexts: s3EnetPagedTrafTable.setDescription("This table contains a list of entries for the 'paged' Traffic Matrix table.")
s3EnetPagedTrafEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 9, 3, 1), ).setIndexNames((0, "SYNOPTICS-ETHERNET-MIB", "s3EnetTrafPageNo"))
if mibBuilder.loadTexts: s3EnetPagedTrafEntry.setStatus('deprecated')
if mibBuilder.loadTexts: s3EnetPagedTrafEntry.setDescription("A 'paged' entry in the Traffic Matrix table.")
s3EnetTrafPageNo = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 9, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetTrafPageNo.setStatus('deprecated')
if mibBuilder.loadTexts: s3EnetTrafPageNo.setDescription('A specific page in the Traffic Matrix table.')
s3EnetTrafPageEntries = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 9, 3, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 400))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetTrafPageEntries.setStatus('deprecated')
if mibBuilder.loadTexts: s3EnetTrafPageEntries.setDescription('This OCTET STRING contains up to 20 valid Traffic Matrix table entries. The entries will not be in any logical order. Each entry consists of a 20-byte octet string including a 6-byte source MAC address, a 6-byte destination MAC address, a received good frame count, and a byte count in good frames received. The counters are 4-bytes each where the first one is high-order byte and the last one is low-order byte.')
s3EnetTrafAgeInterval = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 9, 4), TimeTicks()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3EnetTrafAgeInterval.setStatus('deprecated')
if mibBuilder.loadTexts: s3EnetTrafAgeInterval.setDescription('The time used for aging of the nodes in tables s3EnetSdTrafTable and s3EnetDsTrafTable. Once a node has completely aged it will be removed from these tables. Note: Agents that do not implement this object (i.e., agents prior to version 5.3) use the object s3EnetNodeAgeInterval to perform this function.')
s3EnetPlusPortTable = MibTable((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 10, 1), )
if mibBuilder.loadTexts: s3EnetPlusPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetPlusPortTable.setDescription('This table provides a list of entries, each entry providing information related to frame MAC level error conditions per port. This table is conceptually an extension to the s3EnetPortTable and is only implemented by the 3313S and 3314S NMMs.')
s3EnetPlusPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 10, 1, 1), ).setIndexNames((0, "SYNOPTICS-ETHERNET-MIB", "s3EnetPlusPortBoardIndex"), (0, "SYNOPTICS-ETHERNET-MIB", "s3EnetPlusPortIndex"))
if mibBuilder.loadTexts: s3EnetPlusPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetPlusPortEntry.setDescription('An entry in the Plus Port table.')
s3EnetPlusPortBoardIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 10, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetPlusPortBoardIndex.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetPlusPortBoardIndex.setDescription('A unique value for each board. Its value ranges between 1 and 12. (This is the slot number.)')
s3EnetPlusPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 10, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetPlusPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetPlusPortIndex.setDescription('A unique value for each port. Its value typically ranges between 1 and 12.')
s3EnetPortFragments = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 10, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetPortFragments.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetPortFragments.setDescription('This contains a count of fragments received by the board between 80-512 bits (64 bytes), inclusively, with invalid FCS or alignment errors. (These commonly represent collision fragments, and are not errors. Collision fragments were called FragErrors in the rev 3.x MIB, and were counted only on a per-board basis.)')
s3EnetPortShortEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 10, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetPortShortEvents.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetPortShortEvents.setDescription('This contains a count of fragments received by the port shorter than 80 bits.')
s3EnetPortAutoPartitions = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 10, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetPortAutoPartitions.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetPortAutoPartitions.setDescription('This contains a count of times the ports on the board have autopartitioned due to excessive collisions (more than 32 consecutive collisions). This count is an approximation and may be less than the total count.')
s3EnetPortRateMismatches = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 10, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetPortRateMismatches.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetPortRateMismatches.setDescription('This contains a count of the occurrences of out of spec bit rates. This indicates the number of times FIFO buffer over-runs or underruns due to transmission rate errors.')
s3EnetPortJabbers = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 10, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetPortJabbers.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetPortJabbers.setDescription('This contains a count of the times that MAU jabber lockup protection (MJLP) was invoked because transmission of data from this port exceeded 5 msec in duration. This information can be useful in identifying faulty stations.')
s3EnetPortLastSrcAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 10, 1, 1, 8), PhysAddress().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetPortLastSrcAddr.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetPortLastSrcAddr.setDescription('This is the source address of the last packet received through this port.')
s3EnetPortSrcAddrChanges = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 10, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetPortSrcAddrChanges.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetPortSrcAddrChanges.setDescription('This is the number of times that the s3EnetPortLastSrcAddr object for this has changed.')
s3EnetPlusBoardTable = MibTable((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 10, 2), )
if mibBuilder.loadTexts: s3EnetPlusBoardTable.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetPlusBoardTable.setDescription('This table provides a list of entries, each entry providing information related to frame MAC level error conditions per board. This table is conceptually an extension to the s3EnetboardTable and is only implemented by the 3313S and 3314S NMMs.')
s3EnetPlusBoardEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 10, 2, 1), ).setIndexNames((0, "SYNOPTICS-ETHERNET-MIB", "s3EnetPlusBoardIndex"))
if mibBuilder.loadTexts: s3EnetPlusBoardEntry.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetPlusBoardEntry.setDescription('An entry in the Plus Board table.')
s3EnetPlusBoardIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 10, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetPlusBoardIndex.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetPlusBoardIndex.setDescription('The board number part of an index.')
s3EnetBoardFragments = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 10, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetBoardFragments.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetBoardFragments.setDescription('This contains a count of fragments received by the board between 80-512 bits (64 bytes), inclusively, with invalid FCS or alignment errors. (These commonly represent collision fragments, and are not errors. Collision fragments were called FragErrors in the rev 3.x MIB, and were counted only on a per-concentrator basis.)')
s3EnetBoardShortEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 10, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetBoardShortEvents.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetBoardShortEvents.setDescription('This contains a count of fragments received by the board shorter than 80 bits.')
s3EnetBoardAutoPartitions = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 10, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetBoardAutoPartitions.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetBoardAutoPartitions.setDescription('This contains a count of times the ports on this board have been autopartitioned due to excessive collisions (more than 32 consecutive collisions). This count is an approximation and may be less than the total count.')
s3EnetBoardRateMismatches = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 10, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetBoardRateMismatches.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetBoardRateMismatches.setDescription('This contains a count of the occurrences of out of spec bit rates. This indicates the number of times FIFO buffer over-runs or underruns due to transmission rate errors.')
s3EnetBoardJabbers = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 10, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetBoardJabbers.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetBoardJabbers.setDescription('This contains a count of the times that MAU jabber lockup protection (MJLP) was invoked because transmission of data from a port on this board exceeded 5 msec in duration. This information can be useful in identifying faulty stations.')
s3EnetConcShortEvents = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 10, 3, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetConcShortEvents.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetConcShortEvents.setDescription('This contains a count of fragments received by the concentrator shorter than 80 bits.')
s3EnetConcAutoPartitions = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 10, 3, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetConcAutoPartitions.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetConcAutoPartitions.setDescription('This contains a count of times the ports on this concentrator have been autopartitioned due to excessive collisions (more than 32 consecutive collisions). This count is based on a one-bit counter (flag) per port in the host modules, and will not always represent the total count.')
s3EnetConcRateMismatches = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 10, 3, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetConcRateMismatches.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetConcRateMismatches.setDescription('This contains a count of the occurrences of out of spec bit rates. This indicates the number of times FIFO buffer over-runs or underruns due to transmission rate errors.')
s3EnetConcJabbers = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 10, 3, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetConcJabbers.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetConcJabbers.setDescription('This contains a count of the times that MAU jabber lockup protection (MJLP) was invoked because transmission of data from a port on this concentrator exceeded 5 msec in duration. This information can be useful in identifying faulty stations.')
s3EnetConcCollBackoffErrors = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 10, 3, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetConcCollBackoffErrors.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetConcCollBackoffErrors.setDescription('This contains a total concentrator count of the collision events that occur during the normal collision window (i.e., the collisions is not a late collision) and do not have a runt error.')
s3EnetFrSizePortTable = MibTable((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 11, 1), )
if mibBuilder.loadTexts: s3EnetFrSizePortTable.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetFrSizePortTable.setDescription('This table provides a list of entries, each entry providing information related to frame sizes of packets received on a port. The variables defined for the entries are only supported by 3313S and 3314S NMM.')
s3EnetFrSizePortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 11, 1, 1), ).setIndexNames((0, "SYNOPTICS-ETHERNET-MIB", "s3EnetFrSizePortBoardIndex"), (0, "SYNOPTICS-ETHERNET-MIB", "s3EnetFrSizePortIndex"))
if mibBuilder.loadTexts: s3EnetFrSizePortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetFrSizePortEntry.setDescription('An entry in the FrSize Port table.')
s3EnetFrSizePortBoardIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 11, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetFrSizePortBoardIndex.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetFrSizePortBoardIndex.setDescription('A unique value for each board. Its value ranges between 1 and 12. (This is the slot number.)')
s3EnetFrSizePortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 11, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetFrSizePortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetFrSizePortIndex.setDescription('A unique value for each port. Its value typically ranges between 1 and 12.')
s3EnetFrSizePort64to127 = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 11, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetFrSizePort64to127.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetFrSizePort64to127.setDescription('This contains a count of frames received by the port that are in the range of 64 octets to 127 octets, inclusive.')
s3EnetFrSizePort128to255 = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 11, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetFrSizePort128to255.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetFrSizePort128to255.setDescription('This contains a count of frames received by the port that are in the range of 128 octets to 255 octets, inclusive.')
s3EnetFrSizePort256to511 = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 11, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetFrSizePort256to511.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetFrSizePort256to511.setDescription('This contains a count of frames received by the port that are in the range of 256 octets to 511 octets, inclusive.')
s3EnetFrSizePort512to1023 = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 11, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetFrSizePort512to1023.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetFrSizePort512to1023.setDescription('This contains a count of frames received by the port that are in the range of 512 octets to 1023 octets, inclusive.')
s3EnetFrSizePort1024to1518 = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 11, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetFrSizePort1024to1518.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetFrSizePort1024to1518.setDescription('This contains a count of frames received by the port that are in the range of 1024 octets to 1518 octets, inclusive.')
s3EnetFrSizeBoardTable = MibTable((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 11, 2), )
if mibBuilder.loadTexts: s3EnetFrSizeBoardTable.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetFrSizeBoardTable.setDescription('This table provides a list of entries, each entry providing information related to frame MAC level error conditions per board. The variables defined for the entries are only supported by 3313S and 3314S NMMs. The use of any variable in this table for other NMMs will cause the NMMs to return noSuchName error status in the response.')
s3EnetFrSizeBoardEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 11, 2, 1), ).setIndexNames((0, "SYNOPTICS-ETHERNET-MIB", "s3EnetFrSizeBoardIndex"))
if mibBuilder.loadTexts: s3EnetFrSizeBoardEntry.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetFrSizeBoardEntry.setDescription('An entry in the FrSize Board table.')
s3EnetFrSizeBoardIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 11, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetFrSizeBoardIndex.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetFrSizeBoardIndex.setDescription('A unique value for each board. Its value ranges between 1 and 12. (This is the slot number.)')
s3EnetFrSizeBoard64to127 = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 11, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetFrSizeBoard64to127.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetFrSizeBoard64to127.setDescription('This contains a count of frames received by the board that are in the range of 64 octets to 127 octets, inclusive.')
s3EnetFrSizeBoard128to255 = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 11, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetFrSizeBoard128to255.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetFrSizeBoard128to255.setDescription('This contains a count of frames received by the board that are in the range of 128 octets to 255 octets, inclusive.')
s3EnetFrSizeBoard256to511 = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 11, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetFrSizeBoard256to511.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetFrSizeBoard256to511.setDescription('This contains a count of frames received by the board that are in the range of 256 octets to 511 octets, inclusive.')
s3EnetFrSizeBoard512to1023 = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 11, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetFrSizeBoard512to1023.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetFrSizeBoard512to1023.setDescription('This contains a count of frames received by the board that are in the range of 512 octets to 1023 octets, inclusive.')
s3EnetFrSizeBoard1024to1518 = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 11, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetFrSizeBoard1024to1518.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetFrSizeBoard1024to1518.setDescription('This contains a count of frames received by the board that are in the range of 1024 octets to 1518 octets, inclusive.')
s3EnetFrSizeConc64to127 = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 11, 3, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetFrSizeConc64to127.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetFrSizeConc64to127.setDescription('This contains a count of frames received by the concentrator that are in the range of 64 octets to 127 octets, inclusive.')
s3EnetFrSizeConc128to255 = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 11, 3, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetFrSizeConc128to255.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetFrSizeConc128to255.setDescription('This contains a count of frames received by the concentrator that are in the range of 128 octets to 255 octets, inclusive.')
s3EnetFrSizeConc256to511 = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 11, 3, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetFrSizeConc256to511.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetFrSizeConc256to511.setDescription('This contains a count of frames received by the concentrator that are in the range of 256 octets to 511 octets, inclusive.')
s3EnetFrSizeConc512to1023 = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 11, 3, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetFrSizeConc512to1023.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetFrSizeConc512to1023.setDescription('This contains a count of frames received by the concentrator that are in the range of 512 octets to 1023 octets, inclusive.')
s3EnetFrSizeConc1024to1518 = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 11, 3, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetFrSizeConc1024to1518.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetFrSizeConc1024to1518.setDescription('This contains a count of frames received by the concentrator that are in the range of 1024 octets to 1518 octets, inclusive.')
s3EnetProtoPortTable = MibTable((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 12, 1), )
if mibBuilder.loadTexts: s3EnetProtoPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetProtoPortTable.setDescription('This table provides a list of entries, each entry providing information related to packet protocol type distributions per port. The variables defined for the entries are only supported by 3313S and 3314S NMMs. The use of any variable in this table for other NMMs will cause the NMMs to return noSuchName error status in the response.')
s3EnetProtoPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 12, 1, 1), ).setIndexNames((0, "SYNOPTICS-ETHERNET-MIB", "s3EnetProtoPortBoardIndex"), (0, "SYNOPTICS-ETHERNET-MIB", "s3EnetProtoPortIndex"))
if mibBuilder.loadTexts: s3EnetProtoPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetProtoPortEntry.setDescription('An entry in the Proto Port table.')
s3EnetProtoPortBoardIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 12, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetProtoPortBoardIndex.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetProtoPortBoardIndex.setDescription('A unique value for each board. Its value ranges between 1 and 12. (This is the slot number.)')
s3EnetProtoPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 12, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetProtoPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetProtoPortIndex.setDescription('A unique value for each port. Its value typically ranges between 1 and 12.')
s3EnetProtoPort8023Frames = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 12, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetProtoPort8023Frames.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetProtoPort8023Frames.setDescription('This contains a count of frames received by the port that are of 802.3 type.')
s3EnetProtoPortEthernetFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 12, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetProtoPortEthernetFrames.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetProtoPortEthernetFrames.setDescription('This contains a count of frames received by the port that are of Ethernet type.')
s3EnetProtoPortOtherFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 12, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetProtoPortOtherFrames.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetProtoPortOtherFrames.setDescription('This contains a count of frames received by the port that are of types not counted by individual counters below.')
s3EnetProtoPortSnaFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 12, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetProtoPortSnaFrames.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetProtoPortSnaFrames.setDescription('This contains a count of frames received by the port that are of SNA type.')
s3EnetProtoPortIpFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 12, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetProtoPortIpFrames.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetProtoPortIpFrames.setDescription('This contains a count of frames received by the port that are of IP type.')
s3EnetProtoPortIsoFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 12, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetProtoPortIsoFrames.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetProtoPortIsoFrames.setDescription('This contains a count of frames received by the port that are of ISO type.')
s3EnetProtoPortArpFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 12, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetProtoPortArpFrames.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetProtoPortArpFrames.setDescription('This contains a count of frames received by the port that are of ARP type.')
s3EnetProtoPortDecIVFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 12, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetProtoPortDecIVFrames.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetProtoPortDecIVFrames.setDescription('This contains a count of frames received by the port that are of DECIV type.')
s3EnetProtoPortDecLatFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 12, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetProtoPortDecLatFrames.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetProtoPortDecLatFrames.setDescription('This contains a count of frames received by the port that are of DECLAT type.')
s3EnetProtoPortEthTalkFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 12, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetProtoPortEthTalkFrames.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetProtoPortEthTalkFrames.setDescription('This contains a count of frames received by the port that are of EtherTalk type.')
s3EnetProtoPortXnsFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 12, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetProtoPortXnsFrames.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetProtoPortXnsFrames.setDescription('This contains a count of frames received by the port that are of XNS type.')
s3EnetProtoPortIpxFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 12, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetProtoPortIpxFrames.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetProtoPortIpxFrames.setDescription('This contains a count of frames received by the port that are of IPX type.')
s3EnetProtoPortDecLavcFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 12, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetProtoPortDecLavcFrames.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetProtoPortDecLavcFrames.setDescription('This contains a count of frames received by the port that are of DEC LAVC type.')
s3EnetProtoPortNetBiosFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 12, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetProtoPortNetBiosFrames.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetProtoPortNetBiosFrames.setDescription('This contains a count of frames received by the port that are of NETBIOS type.')
s3EnetProtoPortBrdgSpanTreeFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 12, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetProtoPortBrdgSpanTreeFrames.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetProtoPortBrdgSpanTreeFrames.setDescription('This contains a count of frames received by the port that are of Bridge Spanning Tree type.')
s3EnetProtoBoardTable = MibTable((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 12, 2), )
if mibBuilder.loadTexts: s3EnetProtoBoardTable.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetProtoBoardTable.setDescription('This table provides a list of entries, each entry providing information related to packet protocol type distribution per board. The variables defined for the entries are only supported by 3313S and 3314S NMMs. The use of any variable in this table for other NMMs will cause the NMMs to return noSuchName error status in the response.')
s3EnetProtoBoardEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 12, 2, 1), ).setIndexNames((0, "SYNOPTICS-ETHERNET-MIB", "s3EnetProtoBoardIndex"))
if mibBuilder.loadTexts: s3EnetProtoBoardEntry.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetProtoBoardEntry.setDescription('An entry in the Proto Board table.')
s3EnetProtoBoardIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 12, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetProtoBoardIndex.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetProtoBoardIndex.setDescription('A unique value for each board. Its value ranges between 1 and 12. (This is the slot number.)')
s3EnetProtoBoard8023Frames = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 12, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetProtoBoard8023Frames.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetProtoBoard8023Frames.setDescription('This contains a count of frames received by the board that are of 802.3 type.')
s3EnetProtoBoardEthernetFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 12, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetProtoBoardEthernetFrames.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetProtoBoardEthernetFrames.setDescription('This contains a count of frames received by the board that are of Ethernet type.')
s3EnetProtoBoardOtherFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 12, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetProtoBoardOtherFrames.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetProtoBoardOtherFrames.setDescription('This contains a count of frames received by the board that are of types not specified below.')
s3EnetProtoBoardSnaFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 12, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetProtoBoardSnaFrames.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetProtoBoardSnaFrames.setDescription('This contains a count of frames received by the board that are of SNA type.')
s3EnetProtoBoardIpFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 12, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetProtoBoardIpFrames.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetProtoBoardIpFrames.setDescription('This contains a count of frames received by the board that are of IP type.')
s3EnetProtoBoardIsoFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 12, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetProtoBoardIsoFrames.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetProtoBoardIsoFrames.setDescription('This contains a count of frames received by the board that are of ISO type.')
s3EnetProtoBoardArpFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 12, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetProtoBoardArpFrames.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetProtoBoardArpFrames.setDescription('This contains a count of frames received by the board that are of ARP type.')
s3EnetProtoBoardDecIVFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 12, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetProtoBoardDecIVFrames.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetProtoBoardDecIVFrames.setDescription('This contains a count of frames received by the board that are of DECIV type.')
s3EnetProtoBoardDecLatFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 12, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetProtoBoardDecLatFrames.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetProtoBoardDecLatFrames.setDescription('This contains a count of frames received by the board that are of DECLAT type.')
s3EnetProtoBoardEthTalkFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 12, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetProtoBoardEthTalkFrames.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetProtoBoardEthTalkFrames.setDescription('This contains a count of frames received by the board that are of EtherTalk type.')
s3EnetProtoBoardXnsFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 12, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetProtoBoardXnsFrames.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetProtoBoardXnsFrames.setDescription('This contains a count of frames received by the board that are of XNS type.')
s3EnetProtoBoardIpxFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 12, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetProtoBoardIpxFrames.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetProtoBoardIpxFrames.setDescription('This contains a count of frames received by the board that are of IPX type.')
s3EnetProtoBoardDecLavcFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 12, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetProtoBoardDecLavcFrames.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetProtoBoardDecLavcFrames.setDescription('This contains a count of frames received by the board that are of DEC LAVC type.')
s3EnetProtoBoardNetBiosFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 12, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetProtoBoardNetBiosFrames.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetProtoBoardNetBiosFrames.setDescription('This contains a count of frames received by the board that are of NETBIOS type.')
s3EnetProtoBoardBrdgSpanTreeFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 12, 2, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetProtoBoardBrdgSpanTreeFrames.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetProtoBoardBrdgSpanTreeFrames.setDescription('This contains a count of frames received by the board that are of Bridge Spanning Tree type.')
s3EnetProtoConc8023Frames = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 12, 3, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetProtoConc8023Frames.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetProtoConc8023Frames.setDescription('This contains a count of frames received by the concentrator that are of 802.3 type.')
s3EnetProtoConcEthernetFrames = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 12, 3, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetProtoConcEthernetFrames.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetProtoConcEthernetFrames.setDescription('This contains a count of frames received by the concentrator that are of Ethernet type.')
s3EnetProtoConcOtherFrames = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 12, 3, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetProtoConcOtherFrames.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetProtoConcOtherFrames.setDescription('This contains a count of frames received by the concentrator that are of types not specified below.')
s3EnetProtoConcSnaFrames = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 12, 3, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetProtoConcSnaFrames.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetProtoConcSnaFrames.setDescription('This contains a count of frames received by the concentrator that are of SNA type.')
s3EnetProtoConcIpFrames = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 12, 3, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetProtoConcIpFrames.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetProtoConcIpFrames.setDescription('This contains a count of frames received by the concentrator that are of IP type.')
s3EnetProtoConcIsoFrames = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 12, 3, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetProtoConcIsoFrames.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetProtoConcIsoFrames.setDescription('This contains a count of frames received by the concentrator that are of ISO type.')
s3EnetProtoConcArpFrames = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 12, 3, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetProtoConcArpFrames.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetProtoConcArpFrames.setDescription('This contains a count of frames received by the concentrator that are of ARP type.')
s3EnetProtoConcDecIVFrames = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 12, 3, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetProtoConcDecIVFrames.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetProtoConcDecIVFrames.setDescription('This contains a count of frames received by the concentrator that are of DECIV type.')
s3EnetProtoConcDecLatFrames = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 12, 3, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetProtoConcDecLatFrames.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetProtoConcDecLatFrames.setDescription('This contains a count of frames received by the concentrator that are of DECLAT type.')
s3EnetProtoConcEthTalkFrames = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 12, 3, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetProtoConcEthTalkFrames.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetProtoConcEthTalkFrames.setDescription('This contains a count of frames received by the concentrator that are of EtherTalk type.')
s3EnetProtoConcXnsFrames = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 12, 3, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetProtoConcXnsFrames.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetProtoConcXnsFrames.setDescription('This contains a count of frames received by the concentrator that are of XNS type.')
s3EnetProtoConcIpxFrames = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 12, 3, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetProtoConcIpxFrames.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetProtoConcIpxFrames.setDescription('This contains a count of frames received by the concentrator that are of IPX type.')
s3EnetProtoConcDecLavcFrames = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 12, 3, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetProtoConcDecLavcFrames.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetProtoConcDecLavcFrames.setDescription('This contains a count of frames received by the concentrator that are of DEC LAVC type.')
s3EnetProtoConcNetBiosFrames = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 12, 3, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetProtoConcNetBiosFrames.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetProtoConcNetBiosFrames.setDescription('This contains a count of frames received by the concentrator that are of NETBIOS type.')
s3EnetProtoConcBrdgSpanTreeFrames = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 12, 3, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetProtoConcBrdgSpanTreeFrames.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetProtoConcBrdgSpanTreeFrames.setDescription('This contains a count of frames received by the concentrator that are of Bridge Spanning Tree type.')
s3EnetHostTableSize = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 13, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetHostTableSize.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetHostTableSize.setDescription('The current number of entries in table s3EnetHostTable.')
s3EnetHostLastDeleteTime = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 13, 2), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetHostLastDeleteTime.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetHostLastDeleteTime.setDescription('The value of sysUpTime when the last entry was deleted from table s3EnetHostTable due to a shortage of resources. If no deletions have occurred, then the value is zero.')
s3EnetHostTable = MibTable((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 13, 3), )
if mibBuilder.loadTexts: s3EnetHostTable.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetHostTable.setDescription('A Table containing MAC/Network address pairs that have been detected on the segment.')
s3EnetHostEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 13, 3, 1), ).setIndexNames((0, "SYNOPTICS-ETHERNET-MIB", "s3EnetHostIndex"))
if mibBuilder.loadTexts: s3EnetHostEntry.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetHostEntry.setDescription('A row in the table of MAC/Network address pairs. Entries can not be created or deleted via SNMP operations. New entries are added when a new MAC/Network address pair is detected. An entry is removed to add a new entry when the table is full. The entry that is removed is the one that has been least recently observed.')
s3EnetHostIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 13, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetHostIndex.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetHostIndex.setDescription('The index of the MAC/Network address pair. The value is between 1 and N, where N is the value of s3EnetHostTableSize. The association of this index to a pair may change when a pair is removed from the table due to a resource shortage. s3EnetHostLastDeleteTime must be monitored to determine when this condition has occured.')
s3EnetHostObserveOrder = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 13, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetHostObserveOrder.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetHostObserveOrder.setDescription('The relative ordering of the MAC/Network adddress pair. There is a global value that starts at 1 and increases by one for each observation of an address pair. When the maximum value of 65535 is reached, the next value will be 1. The global value is used to update this object each time the MAC/Network address pair is observed (and when the entry is initially created). Since the global value starts over again after it reaches its maximum value, there may be more than one entry that has the same value.')
s3EnetHostNetAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 13, 3, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetHostNetAddr.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetHostNetAddr.setDescription('The network address (in network order) of the MAC/Network address pair.')
s3EnetHostAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 13, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("ip", 2), ("ipx", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetHostAddrType.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetHostAddrType.setDescription('The type of address that is stored in the object s3EnetHostNetAddr for this entry. The values are: other(1)...Unknown type ip(2)......IP address ipx(3).....IPX address')
s3EnetHostMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 13, 3, 1, 5), PhysAddress().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetHostMacAddress.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetHostMacAddress.setDescription('The MAC address (in canonical order) of the MAC/Network address pair.')
s3EnetHostSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 13, 3, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetHostSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetHostSlotIndex.setDescription('The board index that the host is connected through.')
s3EnetHostPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 13, 3, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetHostPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetHostPortIndex.setDescription('The port index that the host is connected through.')
s3EnetHostLearnMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 13, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("arpRequest", 2), ("arpResponse", 3), ("ripRequest", 4), ("ripResponse", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetHostLearnMethod.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetHostLearnMethod.setDescription('Indicates the method that was used to discover the MAC/Network address pair. The methods that can be used for discovery are shown below. other(1).........Indicates an unknown discovery method. arpRequest(2)....Indicates that ARP request packets were used for discovery. arpResponse(3)...Indicates that ARP response packets were used for discovery. ripRequest(4)....Indicates that RIP request packets were used for discovery. ripResponse(5)...Indicates that RIP response packets were used for discovery.')
s3EnetHostTimeStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 2, 13, 3, 1, 9), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3EnetHostTimeStamp.setStatus('mandatory')
if mibBuilder.loadTexts: s3EnetHostTimeStamp.setDescription('The value of sysUpTime when the MAC/Network address pair was last observed on the segment.')
mibBuilder.exportSymbols("SYNOPTICS-ETHERNET-MIB", s3EnetBoardRateMismatches=s3EnetBoardRateMismatches, s3000EnetNmmTopology=s3000EnetNmmTopology, s3EnetRemBridgePortEntry=s3EnetRemBridgePortEntry, s3EnetHostAddrType=s3EnetHostAddrType, s3000EnetFrameSizeDist=s3000EnetFrameSizeDist, s3EnetThreshTableSize=s3EnetThreshTableSize, s3EnetProtoConcIpxFrames=s3EnetProtoConcIpxFrames, s3EnetThreshDuration=s3EnetThreshDuration, s3EnetHostPortIndex=s3EnetHostPortIndex, s3EnetAuthNodesPortIndex=s3EnetAuthNodesPortIndex, s3EnetPortAlignErrors=s3EnetPortAlignErrors, s3EnetPortFcsErrors=s3EnetPortFcsErrors, s3EnetPortFrmsRxOk=s3EnetPortFrmsRxOk, s3EnetBoardReset=s3EnetBoardReset, s3EnetFrSizeBoard1024to1518=s3EnetFrSizeBoard1024to1518, s3EnetTopNmmSubsetEntry=s3EnetTopNmmSubsetEntry, s3EnetProtoBoardXnsFrames=s3EnetProtoBoardXnsFrames, s3EnetCommonPortIndex=s3EnetCommonPortIndex, s3EnetProtoPortArpFrames=s3EnetProtoPortArpFrames, s3EnetTopNmmSlot=s3EnetTopNmmSlot, s3EnetRemBridgePortIndex=s3EnetRemBridgePortIndex, s3EnetBoardStatus=s3EnetBoardStatus, s3EnetLocBridgePortSlotIndex=s3EnetLocBridgePortSlotIndex, s3EnetNmmTrapServerTable=s3EnetNmmTrapServerTable, s3EnetTopNmmTable=s3EnetTopNmmTable, s3EnetConcOctetsRxOk=s3EnetConcOctetsRxOk, s3EnetConcMcastFrmsRxOk=s3EnetConcMcastFrmsRxOk, s3EnetPagedTrafEntry=s3EnetPagedTrafEntry, s3EnetProtoBoardTable=s3EnetProtoBoardTable, s3EnetNmmMdaHwVer=s3EnetNmmMdaHwVer, s3EnetHostSlotIndex=s3EnetHostSlotIndex, s3EnetPlusBoardEntry=s3EnetPlusBoardEntry, s3EnetTopNmmMacAddr=s3EnetTopNmmMacAddr, s3EnetProtoPortNetBiosFrames=s3EnetProtoPortNetBiosFrames, s3EnetDsTrafBytes=s3EnetDsTrafBytes, s3000EnetSADATraffic=s3000EnetSADATraffic, s3EnetNmmLocation=s3EnetNmmLocation, s3EnetPortJabberStatus=s3EnetPortJabberStatus, s3EnetShowNodesStatus=s3EnetShowNodesStatus, s3EnetConcShortEvents=s3EnetConcShortEvents, s3EnetFindNodesSlotIndex=s3EnetFindNodesSlotIndex, s3EnetRemBridgePortRdySnd=s3EnetRemBridgePortRdySnd, s3EnetRemBridgePortMdaId=s3EnetRemBridgePortMdaId, s3000EnetPlusStatistics=s3000EnetPlusStatistics, s3EnetRedPortLastChg=s3EnetRedPortLastChg, s3EnetFindNodesEntry=s3EnetFindNodesEntry, s3EnetPortJabbers=s3EnetPortJabbers, s3EnetConcCollBackoffErrors=s3EnetConcCollBackoffErrors, s3EnetNmmTrapServerComm=s3EnetNmmTrapServerComm, s3EnetTopBridgeTable=s3EnetTopBridgeTable, s3EnetThreshObject=s3EnetThreshObject, s3EnetTopNmmHelloTime=s3EnetTopNmmHelloTime, s3EnetShowNodesTable=s3EnetShowNodesTable, s3EnetNmmWriteEeprom=s3EnetNmmWriteEeprom, s3EnetProtoPortSnaFrames=s3EnetProtoPortSnaFrames, s3EnetRemBridgeStandbySts=s3EnetRemBridgeStandbySts, s3EnetLocBridgeBootSts=s3EnetLocBridgeBootSts, s3EnetProtoPortDecLavcFrames=s3EnetProtoPortDecLavcFrames, s3EnetTopBridgeSlotNum=s3EnetTopBridgeSlotNum, s3000EnetProtoConc=s3000EnetProtoConc, s3EnetRemBridgeEntry=s3EnetRemBridgeEntry, s3EnetTopNmmNumSeen=s3EnetTopNmmNumSeen, s3EnetFrSizePort512to1023=s3EnetFrSizePort512to1023, s3EnetHostIndex=s3EnetHostIndex, s3EnetRedPortTable=s3EnetRedPortTable, s3EnetLocBridgePortIf=s3EnetLocBridgePortIf, s3EnetCommonBoardRedund=s3EnetCommonBoardRedund, s3EnetConcBcastFrmsRxOk=s3EnetConcBcastFrmsRxOk, s3EnetRemBridgePortCarDt=s3EnetRemBridgePortCarDt, s3EnetCommonBoardIndex=s3EnetCommonBoardIndex, s3EnetBoardRuntErrors=s3EnetBoardRuntErrors, s3EnetSdTrafMacSA=s3EnetSdTrafMacSA, s3EnetProtoBoard8023Frames=s3EnetProtoBoard8023Frames, s3EnetProtoBoardEthernetFrames=s3EnetProtoBoardEthernetFrames, s3EnetDsTrafTable=s3EnetDsTrafTable, s3EnetShowNodesEntry=s3EnetShowNodesEntry, s3EnetTopNmmChassisType=s3EnetTopNmmChassisType, s3EnetConcFragErrors=s3EnetConcFragErrors, s3EnetRemBridgePortTable=s3EnetRemBridgePortTable, s3EnetPortBoardIndex=s3EnetPortBoardIndex, s3EnetBoardPsStatus=s3EnetBoardPsStatus, s3EnetPortFragments=s3EnetPortFragments, s3EnetPortAutoPartitions=s3EnetPortAutoPartitions, s3EnetHostNetAddr=s3EnetHostNetAddr, s3EnetBoardLateCollErrors=s3EnetBoardLateCollErrors, s3EnetFrSizePortIndex=s3EnetFrSizePortIndex, s3EnetConcEnetChan=s3EnetConcEnetChan, s3EnetFrSizePort64to127=s3EnetFrSizePort64to127, s3EnetConcRateMismatches=s3EnetConcRateMismatches, s3EnetTopBridgeCompBridgeMac1=s3EnetTopBridgeCompBridgeMac1, s3EnetTopNmmPort=s3EnetTopNmmPort, s3EnetConcLateCollErrors=s3EnetConcLateCollErrors, s3EnetHostLearnMethod=s3EnetHostLearnMethod, s3EnetBoardOctetsRxOk=s3EnetBoardOctetsRxOk, s3EnetFrSizePort1024to1518=s3EnetFrSizePort1024to1518, s3EnetRedPortSwitchoverTime=s3EnetRedPortSwitchoverTime, s3EnetTrafPageEntries=s3EnetTrafPageEntries, s3EnetRedPortRemoteOperStatus=s3EnetRedPortRemoteOperStatus, s3EnetHostMacAddress=s3EnetHostMacAddress, s3EnetNmmBootFile=s3EnetNmmBootFile, s3EnetAuthNodesMacAddr=s3EnetAuthNodesMacAddr, s3EnetBoardBcastFrmsRxOk=s3EnetBoardBcastFrmsRxOk, s3EnetPagedTrafTable=s3EnetPagedTrafTable, s3000EnetFrameConc=s3000EnetFrameConc, s3EnetThreshSlot=s3EnetThreshSlot, s3EnetSdTrafTable=s3EnetSdTrafTable, s3EnetPortColls=s3EnetPortColls, s3EnetLocBridgePortTable=s3EnetLocBridgePortTable, s3EnetRouterSlotTable=s3EnetRouterSlotTable, s3EnetPortAddrLearnMode=s3EnetPortAddrLearnMode, s3EnetSdTrafMacDA=s3EnetSdTrafMacDA, s3EnetHostEntry=s3EnetHostEntry, s3EnetPortRateMismatches=s3EnetPortRateMismatches, s3EnetHostTable=s3EnetHostTable, s3000EnetLocBridge=s3000EnetLocBridge, s3EnetProtoBoardDecIVFrames=s3EnetProtoBoardDecIVFrames, s3EnetFrSizeBoardEntry=s3EnetFrSizeBoardEntry, s3EnetDsTrafMacDA=s3EnetDsTrafMacDA, s3EnetProtoConcIsoFrames=s3EnetProtoConcIsoFrames, s3EnetProtoBoardEntry=s3EnetProtoBoardEntry, s3EnetLocBridgePortOpSts=s3EnetLocBridgePortOpSts, s3EnetTopBridgeNumber=s3EnetTopBridgeNumber, s3EnetPortPartTime=s3EnetPortPartTime, s3EnetLocBridgeEntry=s3EnetLocBridgeEntry, s3EnetPortAuthAction=s3EnetPortAuthAction, s3EnetPlusBoardTable=s3EnetPlusBoardTable, s3EnetCommonBoardTable=s3EnetCommonBoardTable, s3EnetBoardFragments=s3EnetBoardFragments, s3EnetTopNmmBkplType=s3EnetTopNmmBkplType, s3EnetFrSizePortTable=s3EnetFrSizePortTable, s3EnetConcRetimingStatus=s3EnetConcRetimingStatus, s3000EnetNmm=s3000EnetNmm, s3000EnetProtoTypeDist=s3000EnetProtoTypeDist, s3EnetFrSizeConc256to511=s3EnetFrSizeConc256to511, s3EnetProtoBoardArpFrames=s3EnetProtoBoardArpFrames, s3EnetThreshAction=s3EnetThreshAction, s3EnetRedPortCompanionSlotNo=s3EnetRedPortCompanionSlotNo, s3EnetTopNmmIpAddr=s3EnetTopNmmIpAddr, s3EnetConcSecureStatus=s3EnetConcSecureStatus, s3EnetProtoConcDecLavcFrames=s3EnetProtoConcDecLavcFrames, s3EnetNmmAuthTrap=s3EnetNmmAuthTrap, s3EnetTopNmmSubsetTable=s3EnetTopNmmSubsetTable, s3EnetBoardMcastFrmsRxOk=s3EnetBoardMcastFrmsRxOk, s3EnetTopBridgeMacAddr=s3EnetTopBridgeMacAddr, s3EnetProtoBoardEthTalkFrames=s3EnetProtoBoardEthTalkFrames, s3EnetPortIndex=s3EnetPortIndex, s3EnetBoardPartStatus=s3EnetBoardPartStatus, s3EnetProtoConcEthTalkFrames=s3EnetProtoConcEthTalkFrames, s3EnetPlusPortBoardIndex=s3EnetPlusPortBoardIndex, s3EnetFindNodesTable=s3EnetFindNodesTable, s3EnetProtoPortOtherFrames=s3EnetProtoPortOtherFrames, s3EnetRemBridgeDiagSts=s3EnetRemBridgeDiagSts, s3EnetNmmStatus=s3EnetNmmStatus, s3EnetBoardTable=s3EnetBoardTable, s3EnetBoardIndex=s3EnetBoardIndex, s3EnetTopBridgeHelloPortType=s3EnetTopBridgeHelloPortType, s3EnetProtoPortBrdgSpanTreeFrames=s3EnetProtoPortBrdgSpanTreeFrames, s3EnetBoardAuthAction=s3EnetBoardAuthAction, s3EnetPortLinkStatus=s3EnetPortLinkStatus, s3EnetRedPortOperStatus=s3EnetRedPortOperStatus, s3EnetPortType=s3EnetPortType, s3EnetShowNodesAuthStatus=s3EnetShowNodesAuthStatus, s3EnetShowNodesSlotIndex=s3EnetShowNodesSlotIndex, s3EnetFrSizeBoard128to255=s3EnetFrSizeBoard128to255, s3EnetAuthNodesEntry=s3EnetAuthNodesEntry, s3EnetBoardFrmsRxOk=s3EnetBoardFrmsRxOk, s3EnetTopBridgeModuleType=s3EnetTopBridgeModuleType, s3EnetRemBridgeDescr=s3EnetRemBridgeDescr, s3EnetRemBridgeBootSts=s3EnetRemBridgeBootSts, s3EnetSdTrafBytes=s3EnetSdTrafBytes, s3EnetBoardAutoPartitions=s3EnetBoardAutoPartitions, s3EnetNodeAgeInterval=s3EnetNodeAgeInterval, s3EnetProtoBoardOtherFrames=s3EnetProtoBoardOtherFrames, s3EnetPlusPortEntry=s3EnetPlusPortEntry, s3EnetProtoPortEthTalkFrames=s3EnetProtoPortEthTalkFrames, s3EnetHostTimeStamp=s3EnetHostTimeStamp, s3EnetConcFrmsRxOk=s3EnetConcFrmsRxOk, s3EnetConcFcsErrors=s3EnetConcFcsErrors, s3EnetThreshType=s3EnetThreshType, s3EnetThreshSetValue=s3EnetThreshSetValue, s3EnetFrSizePort128to255=s3EnetFrSizePort128to255, s3EnetPortSrcAddrChanges=s3EnetPortSrcAddrChanges, s3EnetRedPortBoardIndex=s3EnetRedPortBoardIndex, s3EnetBoardColls=s3EnetBoardColls, s3EnetRemBridgeSlotTable=s3EnetRemBridgeSlotTable, s3EnetNmmSwMajorVer=s3EnetNmmSwMajorVer, s3EnetLocBridgeDescr=s3EnetLocBridgeDescr, s3EnetConcJabbers=s3EnetConcJabbers, s3000EnetHosts=s3000EnetHosts, s3EnetTopBridgeHelloPortStatus=s3EnetTopBridgeHelloPortStatus, s3EnetFrSizeConc1024to1518=s3EnetFrSizeConc1024to1518, s3EnetNmmNetMask=s3EnetNmmNetMask, s3EnetProtoConcArpFrames=s3EnetProtoConcArpFrames, s3EnetProtoBoardIpFrames=s3EnetProtoBoardIpFrames, s3EnetProtoBoardDecLatFrames=s3EnetProtoBoardDecLatFrames, s3EnetHostLastDeleteTime=s3EnetHostLastDeleteTime, s3EnetRedPortCompanionPortNo=s3EnetRedPortCompanionPortNo, s3EnetTopNmmSubset=s3EnetTopNmmSubset, s3EnetTopBridgeHelloPortNum=s3EnetTopBridgeHelloPortNum, s3EnetFrSizeBoardTable=s3EnetFrSizeBoardTable, s3EnetBoardTooLongErrors=s3EnetBoardTooLongErrors, s3EnetFindNodesPortIndex=s3EnetFindNodesPortIndex, s3EnetPortShortEvents=s3EnetPortShortEvents, s3EnetRouterStandbySts=s3EnetRouterStandbySts, s3EnetLocBridgePortEntry=s3EnetLocBridgePortEntry, s3EnetThreshIndex=s3EnetThreshIndex, s3EnetConcColls=s3EnetConcColls, s3EnetLocBridgePortIndex=s3EnetLocBridgePortIndex, s3EnetProtoPortTable=s3EnetProtoPortTable, s3EnetLocBridgeIndex=s3EnetLocBridgeIndex, s3EnetTopBridgeCompBridgeMac2=s3EnetTopBridgeCompBridgeMac2, s3EnetProtoPortIsoFrames=s3EnetProtoPortIsoFrames, s3EnetProtoPortDecIVFrames=s3EnetProtoPortDecIVFrames, s3EnetThreshStatus=s3EnetThreshStatus, s3EnetNmmType=s3EnetNmmType, s3000EnetNode=s3000EnetNode, s3EnetRemBridgePortOpSts=s3EnetRemBridgePortOpSts, s3EnetProtoBoardIpxFrames=s3EnetProtoBoardIpxFrames, s3000EnetPort=s3000EnetPort, s3EnetPortLastSrcAddr=s3EnetPortLastSrcAddr, s3EnetFindNodesMacAddress=s3EnetFindNodesMacAddress, s3EnetProtoConcSnaFrames=s3EnetProtoConcSnaFrames, s3EnetTopNmmChgStatus=s3EnetTopNmmChgStatus, s3EnetHostTableSize=s3EnetHostTableSize, s3EnetBoardAuthStatus=s3EnetBoardAuthStatus, s3000EnetTopology=s3000EnetTopology, s3EnetCommonPortBoardIndex=s3EnetCommonPortBoardIndex, s3EnetTopBdgSubsetEntry=s3EnetTopBdgSubsetEntry, s3EnetPortBcastFrmsRxOk=s3EnetPortBcastFrmsRxOk, s3EnetFrSizeConc64to127=s3EnetFrSizeConc64to127, s3EnetRouterIndex=s3EnetRouterIndex, s3EnetNmmSwMinorVer=s3EnetNmmSwMinorVer, s3EnetPortPartStatus=s3EnetPortPartStatus, s3EnetRemBridgePortDescr=s3EnetRemBridgePortDescr, s3EnetProtoPortIpFrames=s3EnetProtoPortIpFrames, s3EnetTopNmmLstChg=s3EnetTopNmmLstChg, s3EnetTopBridgeStatus=s3EnetTopBridgeStatus, s3EnetFrSizeConc128to255=s3EnetFrSizeConc128to255, s3EnetPlusPortIndex=s3EnetPlusPortIndex, s3EnetPortAddrCollect=s3EnetPortAddrCollect, s3EnetProtoConcNetBiosFrames=s3EnetProtoConcNetBiosFrames, s3000EnetThreshold=s3000EnetThreshold, s3EnetAuthNodesSlotIndex=s3EnetAuthNodesSlotIndex, s3EnetConcTooLongErrors=s3EnetConcTooLongErrors, s3EnetProtoConcDecIVFrames=s3EnetProtoConcDecIVFrames, s3EnetProtoBoardDecLavcFrames=s3EnetProtoBoardDecLavcFrames, s3EnetPortEntry=s3EnetPortEntry, s3EnetSdTrafEntry=s3EnetSdTrafEntry, s3EnetRouterEntry=s3EnetRouterEntry, s3EnetTopBridgeType=s3EnetTopBridgeType, s3EnetTopNmmLocalSeg=s3EnetTopNmmLocalSeg, s3EnetProtoConcXnsFrames=s3EnetProtoConcXnsFrames, s3EnetCommonBoardChanSwitch=s3EnetCommonBoardChanSwitch, s3EnetHostObserveOrder=s3EnetHostObserveOrder)
mibBuilder.exportSymbols("SYNOPTICS-ETHERNET-MIB", s3EnetTopBdgSubsetTable=s3EnetTopBdgSubsetTable, s3EnetProtoPortIpxFrames=s3EnetProtoPortIpxFrames, s3EnetCommonPortPartStatus=s3EnetCommonPortPartStatus, s3EnetNmmFwVer=s3EnetNmmFwVer, s3EnetPortAuthStatus=s3EnetPortAuthStatus, s3EnetDsTrafEntry=s3EnetDsTrafEntry, s3EnetBoardHwVer=s3EnetBoardHwVer, s3EnetLocBridgePortCount=s3EnetLocBridgePortCount, s3EnetFrSizeConc512to1023=s3EnetFrSizeConc512to1023, s3EnetPortMcastFrmsRxOk=s3EnetPortMcastFrmsRxOk, s3EnetPlusPortTable=s3EnetPlusPortTable, s3EnetDsTrafFrames=s3EnetDsTrafFrames, s3EnetFrSizePort256to511=s3EnetFrSizePort256to511, s3EnetNmmIpAddr=s3EnetNmmIpAddr, s3EnetNmmTrapServerAddress=s3EnetNmmTrapServerAddress, s3EnetRedPortEntry=s3EnetRedPortEntry, s3EnetTrafAgeInterval=s3EnetTrafAgeInterval, s3EnetMaxNodesPerPort=s3EnetMaxNodesPerPort, s3EnetProtoPortDecLatFrames=s3EnetProtoPortDecLatFrames, s3EnetNmmFileServerAddr=s3EnetNmmFileServerAddr, s3EnetRedPortRedundMode=s3EnetRedPortRedundMode, s3EnetFrSizePortBoardIndex=s3EnetFrSizePortBoardIndex, s3EnetCommonPortLinkStatus=s3EnetCommonPortLinkStatus, s3EnetNmmInitString=s3EnetNmmInitString, s3EnetPortLateCollErrors=s3EnetPortLateCollErrors, s3EnetLocBridgePortMdaId=s3EnetLocBridgePortMdaId, s3EnetLocBridgeSlotTable=s3EnetLocBridgeSlotTable, s3EnetProtoBoardBrdgSpanTreeFrames=s3EnetProtoBoardBrdgSpanTreeFrames, s3EnetProtoConcBrdgSpanTreeFrames=s3EnetProtoConcBrdgSpanTreeFrames, s3EnetBoardShortEvents=s3EnetBoardShortEvents, s3EnetTopBridgePortNum=s3EnetTopBridgePortNum, s3EnetProtoBoardIsoFrames=s3EnetProtoBoardIsoFrames, s3EnetConcAuthAction=s3EnetConcAuthAction, s3EnetTopBridgeEntry=s3EnetTopBridgeEntry, s3000EnetRemBridge=s3000EnetRemBridge, s3EnetFrSizeBoard512to1023=s3EnetFrSizeBoard512to1023, s3EnetBoardAlignErrors=s3EnetBoardAlignErrors, s3EnetCommonBoardEntry=s3EnetCommonBoardEntry, s3EnetConcRuntErrors=s3EnetConcRuntErrors, s3EnetThreshActualValue=s3EnetThreshActualValue, s3EnetPortTooLongErrors=s3EnetPortTooLongErrors, s3EnetAuthNodesTable=s3EnetAuthNodesTable, s3000EnetRouter=s3000EnetRouter, s3EnetCommonPortEntry=s3EnetCommonPortEntry, s3EnetPlusBoardIndex=s3EnetPlusBoardIndex, s3EnetFrSizeBoard256to511=s3EnetFrSizeBoard256to511, s3EnetFrSizeBoard64to127=s3EnetFrSizeBoard64to127, s3EnetProtoPortEntry=s3EnetProtoPortEntry, s3000EnetBridTopology=s3000EnetBridTopology, s3000EnetBoard=s3000EnetBoard, s3EnetProtoPortEthernetFrames=s3EnetProtoPortEthernetFrames, s3EnetCommonBoardEnetAB=s3EnetCommonBoardEnetAB, s3EnetProtoConcEthernetFrames=s3EnetProtoConcEthernetFrames, s3EnetSdTrafFrames=s3EnetSdTrafFrames, s3EnetConcAlignErrors=s3EnetConcAlignErrors, s3EnetThreshCondition=s3EnetThreshCondition, s3EnetRemBridgePortSlotIndex=s3EnetRemBridgePortSlotIndex, s3EnetTopNmmEntry=s3EnetTopNmmEntry, s3EnetCommonPortType=s3EnetCommonPortType, s3EnetShowNodesPortIndex=s3EnetShowNodesPortIndex, s3EnetLocBridgeStandbySts=s3EnetLocBridgeStandbySts, s3EnetProtoConcIpFrames=s3EnetProtoConcIpFrames, s3EnetProtoBoardSnaFrames=s3EnetProtoBoardSnaFrames, s3EnetProtoConcOtherFrames=s3EnetProtoConcOtherFrames, s3EnetProtoPortXnsFrames=s3EnetProtoPortXnsFrames, s3EnetBoardUpStamp=s3EnetBoardUpStamp, s3EnetTrafPageNo=s3EnetTrafPageNo, s3EnetRemBridgePortClrSnd=s3EnetRemBridgePortClrSnd, s3EnetProtoPortIndex=s3EnetProtoPortIndex, s3EnetBoardNmCntlStatus=s3EnetBoardNmCntlStatus, s3EnetProtoBoardNetBiosFrames=s3EnetProtoBoardNetBiosFrames, s3EnetShowNodesVendorType=s3EnetShowNodesVendorType, s3000EnetTopInfo=s3000EnetTopInfo, s3EnetThreshEntry=s3EnetThreshEntry, s3EnetNmmBootMode=s3EnetNmmBootMode, s3EnetBoardType=s3EnetBoardType, s3000EnetConcentrator=s3000EnetConcentrator, s3EnetPortOctetsRxOk=s3EnetPortOctetsRxOk, s3EnetShowNodesMacAddress=s3EnetShowNodesMacAddress, s3EnetFrSizeBoardIndex=s3EnetFrSizeBoardIndex, s3EnetPortTxSecurity=s3EnetPortTxSecurity, s3EnetThreshPort=s3EnetThreshPort, s3EnetNmmRestart=s3EnetNmmRestart, s3EnetConcAutoPartitions=s3EnetConcAutoPartitions, s3EnetCommonPortPartTime=s3EnetCommonPortPartTime, s3EnetConcSecurityLock=s3EnetConcSecurityLock, s3EnetTopBridgeLstChg=s3EnetTopBridgeLstChg, s3EnetProtoPort8023Frames=s3EnetProtoPort8023Frames, s3EnetDsTrafMacSA=s3EnetDsTrafMacSA, s3EnetNmmMode=s3EnetNmmMode, s3EnetBoardFcsErrors=s3EnetBoardFcsErrors, s3EnetFrSizePortEntry=s3EnetFrSizePortEntry, s3EnetNmmDefaultGateway=s3EnetNmmDefaultGateway, s3EnetNmmTrapServerEntry=s3EnetNmmTrapServerEntry, s3EnetTopBdgSubset=s3EnetTopBdgSubset, s3EnetNmmTrapType=s3EnetNmmTrapType, s3EnetProtoBoardIndex=s3EnetProtoBoardIndex, s3EnetNmmReset=s3EnetNmmReset, s3000EnetPlusConc=s3000EnetPlusConc, s3EnetCommonPortTable=s3EnetCommonPortTable, s3EnetProtoConc8023Frames=s3EnetProtoConc8023Frames, s3EnetThreshTable=s3EnetThreshTable, s3EnetRemBridgeIndex=s3EnetRemBridgeIndex, s3EnetRouterDescr=s3EnetRouterDescr, s3EnetLocBridgePortDescr=s3EnetLocBridgePortDescr, s3EnetBoardJabbers=s3EnetBoardJabbers, s3EnetPortTable=s3EnetPortTable, s3EnetNmmBaudRate=s3EnetNmmBaudRate, s3EnetTopBridgeIpAddr=s3EnetTopBridgeIpAddr, s3EnetLocBridgeDiagSts=s3EnetLocBridgeDiagSts, s3EnetAuthNodesStatus=s3EnetAuthNodesStatus, s3EnetRouterDiagSts=s3EnetRouterDiagSts, s3EnetPortInterconStatus=s3EnetPortInterconStatus, s3EnetRedPortCapability=s3EnetRedPortCapability, s3EnetRemBridgePortCount=s3EnetRemBridgePortCount, s3EnetTopNmmModuleType=s3EnetTopNmmModuleType, s3EnetRedPortSwitchoverStatus=s3EnetRedPortSwitchoverStatus, s3EnetRedPortIndex=s3EnetRedPortIndex, s3EnetProtoConcDecLatFrames=s3EnetProtoConcDecLatFrames, s3EnetPortRuntErrors=s3EnetPortRuntErrors, s3EnetProtoPortBoardIndex=s3EnetProtoPortBoardIndex, s3EnetThreshExceedCount=s3EnetThreshExceedCount, s3EnetTopNmmNumLinks=s3EnetTopNmmNumLinks, s3EnetBoardEntry=s3EnetBoardEntry)

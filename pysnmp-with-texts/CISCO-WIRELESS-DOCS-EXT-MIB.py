#
# PySNMP MIB module CISCO-WIRELESS-DOCS-EXT-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCO-WIRELESS-DOCS-EXT-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:21:13 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, SingleValueConstraint, ValueSizeConstraint, ValueRangeConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "SingleValueConstraint", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsIntersection")
ciscoMgmt, = mibBuilder.importSymbols("CISCO-SMI", "ciscoMgmt")
cwdIfHeSuStatusEntry, cwdIfHeServiceEntry, cwdIfQosProfileEntry, cwdIfHeSuStatusIndex, cwdIfHeSuStatusDownChanIfIndex, cwdIfHeMacEntry, cwdIfQosProfIndex, cwdIfHeSuStatusMacAddress, cwdIfHeSuStatusUpChanIfIndex, cwdIfHeSuStatusServiceId, cwdIfHeSuStatusIpAddress = mibBuilder.importSymbols("CISCO-WIRELESS-DOCS-IF-MIB", "cwdIfHeSuStatusEntry", "cwdIfHeServiceEntry", "cwdIfQosProfileEntry", "cwdIfHeSuStatusIndex", "cwdIfHeSuStatusDownChanIfIndex", "cwdIfHeMacEntry", "cwdIfQosProfIndex", "cwdIfHeSuStatusMacAddress", "cwdIfHeSuStatusUpChanIfIndex", "cwdIfHeSuStatusServiceId", "cwdIfHeSuStatusIpAddress")
ifIndex, = mibBuilder.importSymbols("IF-MIB", "ifIndex")
ModuleCompliance, ObjectGroup, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "ObjectGroup", "NotificationGroup")
Counter64, iso, Bits, MibIdentifier, Gauge32, IpAddress, Counter32, MibScalar, MibTable, MibTableRow, MibTableColumn, Unsigned32, Integer32, ObjectIdentity, TimeTicks, NotificationType, ModuleIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "Counter64", "iso", "Bits", "MibIdentifier", "Gauge32", "IpAddress", "Counter32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Unsigned32", "Integer32", "ObjectIdentity", "TimeTicks", "NotificationType", "ModuleIdentity")
TimeInterval, MacAddress, DisplayString, TimeStamp, TextualConvention, TruthValue, RowStatus = mibBuilder.importSymbols("SNMPv2-TC", "TimeInterval", "MacAddress", "DisplayString", "TimeStamp", "TextualConvention", "TruthValue", "RowStatus")
ciscoWirelessDocsExtMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 9, 9, 169))
ciscoWirelessDocsExtMIB.setRevisions(('2000-07-17 10:03',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ciscoWirelessDocsExtMIB.setRevisionsDescriptions(('Initial version',))
if mibBuilder.loadTexts: ciscoWirelessDocsExtMIB.setLastUpdated('200007171003Z')
if mibBuilder.loadTexts: ciscoWirelessDocsExtMIB.setOrganization('Cisco Systems, Inc.')
if mibBuilder.loadTexts: ciscoWirelessDocsExtMIB.setContactInfo('Cisco Systems Customer Service Postal: Cisco Systems 170 West Tasman Drive San Jose, CA 95134 U.S.A. Phone: +1 800 553-NETS E-mail: wireless-nms@cisco.com')
if mibBuilder.loadTexts: ciscoWirelessDocsExtMIB.setDescription('This MIB module defines Cisco-specific objects that add to the functionality defined in CISCO-WIRELESS-DOCS-IF-MIB. These objects configure the scheduler that supports Quality of Service (QoS) of MCNS/DOCSIS compliant Radio Frequency (RF) interfaces in Wireless Headends (HE).')
ciscoWirelessDocsExtMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 169, 1))
cwdxQosCtrlObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 1))
cwdxQosQueueObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 2))
cwdxHeSuCpeObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 3))
cwdxQosProfileExtObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 4))
cwdxQosCtrlUpTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 1, 1), )
if mibBuilder.loadTexts: cwdxQosCtrlUpTable.setStatus('current')
if mibBuilder.loadTexts: cwdxQosCtrlUpTable.setDescription('For each upstream interface, this table maintains a number of objects related to Quality of Service scheduler. These objects are used to control SU registration.')
cwdxQosCtrlUpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 1, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: cwdxQosCtrlUpEntry.setReference('Data-Over-Cable Service Interface Specifications (DOCSIS) Radio Frequency Interface Specification (SP-RFI-I04-980724), section 6.4 and appendix C. cwdIfQosProfileTable and cwdIfHeServiceTable in CISCO-WIRELESS-DOCS-IF-MIB.my.')
if mibBuilder.loadTexts: cwdxQosCtrlUpEntry.setStatus('current')
if mibBuilder.loadTexts: cwdxQosCtrlUpEntry.setDescription('A list of attributes for each upstream MAC scheduler that supports Quality of Service. Entries in this table exist for each ifEntry with ifType of propDocsWirelessUpstream(nnn).')
cwdxQosCtrlUpAdmissionCtrl = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 1, 1, 1, 1), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cwdxQosCtrlUpAdmissionCtrl.setStatus('current')
if mibBuilder.loadTexts: cwdxQosCtrlUpAdmissionCtrl.setDescription("The admission control status for this upstream entry. When this object is set to 'true', the upstream scheduler will check the virtual reserved bandwidth remaining before giving admission to this new SU. If there is not enough reserved bandwidth to serve the SU's minimum guaranteed bandwidth, the registration request will be rejected. This object is set to 'false' to disable admission control. That is, there will be no checking for bandwidth capacity and the upstream interface scheduler just admits SU registration requests.")
cwdxQosCtrlUpMaxRsvdBWPercent = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 1000))).setUnits('percent').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cwdxQosCtrlUpMaxRsvdBWPercent.setReference('Data-Over-Cable Service Interface Specifications (DOCSIS) Radio Frequency Interface Specification (SP-RFI-I04-980724). section 6.4 and appendix C.')
if mibBuilder.loadTexts: cwdxQosCtrlUpMaxRsvdBWPercent.setStatus('current')
if mibBuilder.loadTexts: cwdxQosCtrlUpMaxRsvdBWPercent.setDescription('The percentage of upstream maximum reserved bandwidth to the raw bandwidth if the admission control is enabled on this upstream. For example, if the upstream interface has raw bandwidth 1,600,000 bits/second and cwdxQosCtrlUpMaxRsvdBWPercent is 200 percent, then this upstream scheduler will set the maximum of virtual reserved bandwidth capacity to 3,200,000 bits/second (1,600,000 * 2) to serve Subscriber-units with minimum guaranteed upstream bandwidth. The default value is 100 percent (that is, maximum reserved bandwidth is the raw bandwidth.) Whenever the admission control is changed (on to off, off to on), this value will be reset to the default value 100. If the admission control is disabled, the value will be reset to 100 (the default value).')
cwdxQosCtrlUpAdmissionRejects = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 1, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cwdxQosCtrlUpAdmissionRejects.setStatus('current')
if mibBuilder.loadTexts: cwdxQosCtrlUpAdmissionRejects.setDescription("The count of SU registration requests rejected on this upstream interface. The rejection is due to insufficient available bandwidth for this SU. The requests are rejected only when cwdxQosCtrlUpAdmissionCtrl is 'true' on this upstream interface.")
cwdxQosCtrlUpReservedBW = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 102400000))).setUnits('bits/second').setMaxAccess("readonly")
if mibBuilder.loadTexts: cwdxQosCtrlUpReservedBW.setStatus('current')
if mibBuilder.loadTexts: cwdxQosCtrlUpReservedBW.setDescription("The current total reserved bandwidth in bits per second of this upstream interface. It is the sum of all SUs' minimum guaranteed bandwidth in bits per second currently supported on this upstream.")
cwdxQosCtrlUpMaxVirtualBW = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 102400000))).setUnits('bits/second').setMaxAccess("readonly")
if mibBuilder.loadTexts: cwdxQosCtrlUpMaxVirtualBW.setStatus('current')
if mibBuilder.loadTexts: cwdxQosCtrlUpMaxVirtualBW.setDescription('The maximum virtual bandwidth capacity of this upstream interface if the admission control is enabled. It is the raw bandwidth in bits per second times the percentage. If the admission control is disabled, then this object will contain the value zero.')
cwdxQosIfRateLimitTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 1, 2), )
if mibBuilder.loadTexts: cwdxQosIfRateLimitTable.setStatus('current')
if mibBuilder.loadTexts: cwdxQosIfRateLimitTable.setDescription('This table describes the attributes of rate limiting for schedulers in upstream and downstream interfaces that support Quality of Service. The rate limiting process is to ensure the Quality of Service and fairness.')
cwdxQosIfRateLimitEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 1, 2, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: cwdxQosIfRateLimitEntry.setReference('Data-Over-Cable Service Interface Specifications (DOCSIS) Radio Frequency Interface Specification (SP-RFI-I04-980724), section 6.4 and appendix C. cwdIfQosProfileTable and cwdIfHeServiceTable in CISCO-DOCS-WIRELESS-IF-MIB.my.')
if mibBuilder.loadTexts: cwdxQosIfRateLimitEntry.setStatus('current')
if mibBuilder.loadTexts: cwdxQosIfRateLimitEntry.setDescription('List of the rate limiting attributes for upstream and downstream interfaces schedulers that support Quality of Service. Entries in this table exist for each ifEntry with ifType of propDocsWirelessUpstream(nnn) and propDocsWirelessDownstream(nnn).')
cwdxQosIfRateLimitAlgo = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("noRateLimit", 1), ("oneSecBurst", 2), ("carLike", 3), ("wgtExPacketDiscard", 4), ("shaping", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cwdxQosIfRateLimitAlgo.setStatus('current')
if mibBuilder.loadTexts: cwdxQosIfRateLimitAlgo.setDescription("To ensure fairness, at the upstream, the HE will throttle the rate of bandwidth grants, such that the flow never gets more than its provisioned peak rate in bps. Similarly at the downstream, HE controls the packets sent such that flow never gets more than its provisioned peak rate in bps. There are two directions for every Service Id (Sid) traffic: downstream and upstream. Each direction is called a service flow here and is assigned one token bucket with chosen algorithm. The enumerations for the rate limiting algorithm are: noRateLimit(1): The rate limiting is disabled. No rate limiting. oneSecBurst(2): Bursty 1 second token bucket algorithm. carLike(3) : Average token usage (CAR-like) algorithm wgtExPacketDiscard(4) : Weighted excess packet discard algorithm. shaping(5): token bucket algorithm with shaping Upstream supports all the above except wgtExtPacketDiscard(4). Downstream supports all the above rate-limiting algorithms. Token bucket algorithm with shaping is the default algorithm for upstream. Bursty 1 second token bucket algorithm is the default algorithm for downstream. Each algorithm is described as below: No rate limiting: The rate limiting process is disabled and no checking against the maximum bandwidth allowed. Bursty 1 second token bucket rate limiting algorithm: In this algorithm, at the start of every 1 second interval, a service flow's token usage is reset to 0, and every time the modem for that service flow sends a request (upstream) / packet (downstream) the upstream/downstream bandwidth token usage is incremented by the size of the request/packet sent. As long as the service flow's bandwidth token usage is less than the maximum bandwidth in bits per second (peak rate limit) its QoS service class allows, the request/packets will not be restricted. Once the service flow has sent more than its peak rate in the one second interval, it is prevented from sending more data by rejecting request (upstream) or dropping packets (downstream). This is expected to slow down the higher layer sources. The token usage counter gets reset to 0 after the 1 second interval has elapsed. The modem for that service flow is free to send more data up to the peak rate limit in the new 1 second interval that follows. Average token usage (Cisco CAR like) algorithm: This algorithm maintains a continuous average of the burst token usage of a service flow. There is no sudden refilling of tokens every 1 second interval. Every time a request/packet is to be handled, the scheduler tries to see how much time has elapsed since last transmission, and computes the number of tokens accumulated by this service flow at its QoS class peak rate. If burst usage of the service flow is less than tokens accumulated, the burst usage is reset to 0 and request/packet is forwarded. If the service flow has accumulated fewer tokens than its burst usage, the burst usage shows an outstanding balance usage after decrementing by the tokens accumulated. In such cases, the request/packet is still forwarded, provided the service flow's outstanding usage does not exceed peak rate limit of its QoS class. If outstanding burst usage exceeds the peak rate of the class, the service flow is given some token credit up to a certain maximum credit limit and the request/packet is forwarded. The request/packet is dropped when outstanding usage exceeds peak rate and maximum credit has been used up by this service flow. This algorithm tracks long term average bandwidth usage of the service flow and controls this average usage at the peak rate limit. Weighted excess packet discard algorithm: This rate limiting algorithm is only available as an option for downstream rate limiting. The algorithm is to maintain an weighted exponential moving average of the loss rate of a service flow over time. The loss rate, expressed in packets, represents the number of packets that can be sent from this service flow in a one second interval before a packet will be dropped. At every one second interval, the loss rate gets updated using the ratio between the flow peak rate (in bps) in its QoS profile and the service flow actual usage (in bps). If the service flow begins to send more than its peak rate continuously, the number of packets it can send in an one second interval before experiencing a drop will slowly keep reducing until SU for that service flow slows down as indicated by actual usage less or equal to the peak rate. Token bucket algorithm with shaping: If there is no QoS class peak rate limit, forward the request/packet without delay. If there is a QoS peak rate limit, every time a request/packet is to be handled, the scheduler determines the number of bandwidth tokens that this service flow has accumulated over the elapsed time at its QoS class peak rate and increments the tokens counter of the service flow accordingly. The scheduler limits the token count to the maximum transmit burst (token bucket depth). If token count is greater than the number of tokens required to handle current request/packet, decrement token count by size of request/packet and forwards the request/packet without delay. If token count is less than the size of request/packet, compute the shaping delay time after which the deficit number of tokens would be available. If shaping delay time is less than the maximum shaping delay, decrement tokens count by size of request/packet and forward this request/packet with the shaping delay in the shaping delay queue. When the delay time expires, the request/packet is forwarded. If shaping delay time is greater than the maximum shaping delay that the subsequent shaper can handle, the request/packet is dropped. Users can use cwdxQosIfRateLimitShpMaxDelay to configure the maximum shaping delay and cwdxQosIfRateLimitShpGranularity to configure the shaping granularity.")
cwdxQosIfRateLimitExpWgt = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cwdxQosIfRateLimitExpWgt.setStatus('current')
if mibBuilder.loadTexts: cwdxQosIfRateLimitExpWgt.setDescription('Weight for exponential moving average of loss rate, when using weighted excess packet discard algorithm. The higher values of the weight make the algorithm more sensitive to the recent bandwidth usage by the Sid. The default value is 1. Whenever the rate limiting algorithm is changed to weighted excess packet discard algorithm, this value will be reset to the default 1. If the rate limiting algorithm is not weighted excess packet discard algorithm, the value will be always the default value 1. You will not be able to set it to anything other than 1 when it is not weighted excess packet discard algorithm.')
cwdxQosIfRateLimitShpMaxDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 1, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("na", 1), ("msec128", 2), ("msec256", 3), ("msec512", 4), ("msec1024", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cwdxQosIfRateLimitShpMaxDelay.setStatus('current')
if mibBuilder.loadTexts: cwdxQosIfRateLimitShpMaxDelay.setDescription("The maximum shaping delay in milliseconds. That is, the maximum amount of time for which the HE will allow buffering of any rate exceeded flow. If the max buffering delay is large, then grants/packets of the flow will be buffered for a longer period of time even though the flow is rate exceeded. This means fewer chances of drops for such rate exceeded flow. However, too large a max shaping delay can result in quick drainage of packet buffers at the HE, since several packets will be in the shaping (delay) queue waiting for their proper transmission time. Another important point to note is that delaying a flow's packets (especially TCP flows) for extended periods of time may be counter- productive, since the higher protocol layers may assume a packet loss after a certain amount of time. The maximum shaping delay is only applied to rate limit algorithm: Token bucket algorithm with shaping. If the rate limit algorithm is not Token bucket algorithm with shaping, the value is always na(1) which is not applicable. In this case, you will be allowed to set the value to na(1) only. If the token count is less than the size of request/packet, HE computes the shaping delay time after which the deficit number of tokens would be available. If the shaping delay time is greater than the maximum shaping delay, the request/packet will be dropped. The enumerations for cwdxQosIfRateLimitShpMaxDelay are: na(1): maximum shaping delay is not applied to the current rate limit algorithm msec128(2): maximum shaping delay is 128 milliseconds msec256(3): maximum shaping delay is 256 milliseconds msec512(4): maximum shaping delay is 512 milliseconds msec1024(5): maximum shaping delay is 1024 milliseconds At the downstream, cwdxQosIfRateLimitShpMaxDelay is configurable and the default value is msec128(2). Whenever the downstream rate limit algorithm is changed to Token bucket algorithm with shaping from other rate limit algorithm, the value will be reset to the default value. At the upstream, cwdxQosIfRateLimitShpMaxDelay is not configurable and it is read-only value.")
cwdxQosIfRateLimitShpGranularity = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 1, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("na", 1), ("msec1", 2), ("msec2", 3), ("msec4", 4), ("msec8", 5), ("msec16", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cwdxQosIfRateLimitShpGranularity.setStatus('current')
if mibBuilder.loadTexts: cwdxQosIfRateLimitShpGranularity.setDescription('The width in milliseconds of each element in shaping delay queue, that is, the shaping granularity. The shaping granularity is only applied to rate limit algorithm: Token bucket algorithm with shaping. It controls how accurately the algorithm quantizes the shaping delay for a rate exceeded flow. If granularity is large, several shaping delay values will all be quantized to the same element in the queue resulting in less accurate rate shaping for the flows in bits/sec. On the other hand, choosing too small granularity causes more memory to be used for the shaper block, and also can cost a bit more in runtime overhead. If the rate limit algorithm is not Token bucket algorithm with shaping, the value is always na(1) which is not applicable. Setting to any thing other than na(1) will be rejected. The enumerations for shaping granularity are: na(1): shaping granularity is not applied to the current rate limit algorithm msec1(2): shaping granularity in 1 milliseconds msec2(3): shaping granularity in 2 milliseconds msec4(4): shaping granularity in 4 milliseconds msec8(5): shaping granularity in 8 milliseconds msec16(6): shaping granularity in 16 milliseconds At the downstream, this object is configurable and the default value is msec4(4). Whenever the downstream rate limit algorithm is changed to Token bucket algorithm with shaping from other rate limit algorithm, the value will be reset to the default value. When the algorithm is Token bucket algorithm with shaping and set to same algorithm again the value will not be reset to default value. At the upstream, this object is not configurable and it is read-only value.')
cwdxHeServiceExtTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 1, 3), )
if mibBuilder.loadTexts: cwdxHeServiceExtTable.setStatus('current')
if mibBuilder.loadTexts: cwdxHeServiceExtTable.setDescription('The list contains the additional attributes of a single Service ID that provided by cwdIfHeServiceEntry.')
cwdxHeServiceExtEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 1, 3, 1), )
if mibBuilder.loadTexts: cwdxHeServiceExtEntry.setReference('Data-Over-Cable Service Interface Specifications (DOCSIS) Radio Frequency Interface Specification (SP-RFI-I04-980724), section 6.4 and appendix C. cwdIfQosProfileTable and cwdIfHeServiceTable in CISCO-WIRELESS-DOCS-IF-MIB.my.')
cwdIfHeServiceEntry.registerAugmentions(("CISCO-WIRELESS-DOCS-EXT-MIB", "cwdxHeServiceExtEntry"))
cwdxHeServiceExtEntry.setIndexNames(*cwdIfHeServiceEntry.getIndexNames())
if mibBuilder.loadTexts: cwdxHeServiceExtEntry.setStatus('current')
if mibBuilder.loadTexts: cwdxHeServiceExtEntry.setDescription('Additional objects for cwdIfHeServiceTable entry including downstream traffic statistics and excess counts against the Quality of Service limits for each Service ID.')
cwdxIfHeServiceOutOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 1, 3, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cwdxIfHeServiceOutOctets.setStatus('current')
if mibBuilder.loadTexts: cwdxIfHeServiceOutOctets.setDescription('The cumulative number of Packet Data octets sent for this Service ID.')
cwdxIfHeServiceOutPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 1, 3, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cwdxIfHeServiceOutPackets.setStatus('current')
if mibBuilder.loadTexts: cwdxIfHeServiceOutPackets.setDescription('The cumulative number of Packet data packets sent for this Service ID.')
cwdxQosMaxUpBWExcessRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 1, 3, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cwdxQosMaxUpBWExcessRequests.setReference('cwdIfQosProfMaxUpBandwidth object in CISCO-WIRELESS-DOCS-IF-MIB.my.')
if mibBuilder.loadTexts: cwdxQosMaxUpBWExcessRequests.setStatus('current')
if mibBuilder.loadTexts: cwdxQosMaxUpBWExcessRequests.setDescription("The number of upstream bandwidth requests which exceeds the maximum upstream bandwidth allowed for a service defined in the Quality of Service profile associated with this Sid. The request which exceeds the maximum upstream bandwidth allowed will be rejected by the upstream's rate limiting process using one of the rate limiting algorithm. Note that the value of this counter cannot be directly used to know the number of upstream packets that got dropped at the SU. A single upstream packet drop of a SU can result in up to 16 increments in this counter, since the SU keeps retrying and keeps getting bandwidth request drops at HE if it has consumed its peak rate.")
cwdxQosMaxDownBWExcessPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 1, 3, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cwdxQosMaxDownBWExcessPackets.setReference('cwdIfQosProfMaxDownBandwidth object in CISCO-WIRELESS-DOCS-IF-MIB.my.')
if mibBuilder.loadTexts: cwdxQosMaxDownBWExcessPackets.setStatus('current')
if mibBuilder.loadTexts: cwdxQosMaxDownBWExcessPackets.setDescription("The number of downstream bandwidth packets which exceeds the maximum downstream bandwidth allowed for a service defined in the Quality of Service profile associated with this Sid. The packet which exceeds the maximum downstream bandwidth allowed will be dropped by the downstream's rate limiting process using one of the rate limiting algorithm.")
cwdxBWQueueTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 2, 1), )
if mibBuilder.loadTexts: cwdxBWQueueTable.setStatus('current')
if mibBuilder.loadTexts: cwdxBWQueueTable.setDescription('This table describes the attributes of queues in wireless interfaces schedulers that support Quality of Service.')
cwdxBWQueueEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 2, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "CISCO-WIRELESS-DOCS-EXT-MIB", "cwdxBWQueueNameCode"))
if mibBuilder.loadTexts: cwdxBWQueueEntry.setReference('Data-Over-Cable Service Interface Specifications (DOCSIS) Radio Frequency Interface Specification (SP-RFI-I04-980724), section 6.4 and appendix C.')
if mibBuilder.loadTexts: cwdxBWQueueEntry.setStatus('current')
if mibBuilder.loadTexts: cwdxBWQueueEntry.setDescription('The list of queue attributes in upstream and downstream interfaces schedulers that supports Quality of Service. Entries in this table exist for each ifEntry with ifType of propDocsWirelessUpstream(nnn) and propDocsWirelessDownstream(nnn).')
cwdxBWQueueNameCode = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("cirQ", 1), ("tbeQ", 2))))
if mibBuilder.loadTexts: cwdxBWQueueNameCode.setReference('Data-Over-Cable Service Interface Specifications (DOCSIS) Radio Frequency Interface Specification (SP-RFI-I04-980724), section 6.4 and appendix C.')
if mibBuilder.loadTexts: cwdxBWQueueNameCode.setStatus('current')
if mibBuilder.loadTexts: cwdxBWQueueNameCode.setDescription('The name code for the queue. cirQ: CIR queue. The queue is for Committed Information Rate (CIR) type of service which serves Service IDs which have minimum guaranteed rate in its QoS profile. tbeQ: TBE queue. The queue is for TIERED BEST EFFORT type service which serves Service IDs which does not have minimum guaranteed rate in its QoS profile.')
cwdxBWQueueOrder = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cwdxBWQueueOrder.setStatus('current')
if mibBuilder.loadTexts: cwdxBWQueueOrder.setDescription('The relative order of this queue to the other queues within the wireless interface. The smaller number has higher order. That is, 0 is the highest order and 10 is the lowest order. The scheduler will serve the requests in higher order queue up to the number of requests defined in cwdxBWQueueNumServedBeforeYield before serving requests in the next higher order queue. The queues with higher priority will not be serviced (once the QueueNumServedBeforeYield number has been hit) until all remaining queues are processed. If there are n queues on this interface, the queue order will be 0 to n-1 and maximum number of requests defined as cwdxBWQueueNumServedBeforeYield in order 0 queue will be served before the requests in order 1 queue to be served.')
cwdxBWQueueNumServedBeforeYield = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 50))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cwdxBWQueueNumServedBeforeYield.setStatus('current')
if mibBuilder.loadTexts: cwdxBWQueueNumServedBeforeYield.setDescription('The maximum number of requests/packets the scheduler can serve before yielding to another queue. The value 0 means all requests must be served before yielding to another queue.')
cwdxBWQueueType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("other", 2), ("fifo", 3), ("priority", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cwdxBWQueueType.setStatus('current')
if mibBuilder.loadTexts: cwdxBWQueueType.setDescription('The queuing type which decides the position of a request/packet within the queue. unknown : queue type unknown. other : not fifo, and not priority. fifo : first in first out. priority: each bandwidth request has a priority and the position of the request within the queue depends on its priority.')
cwdxBWQueueMaxDepth = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 2, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cwdxBWQueueMaxDepth.setStatus('current')
if mibBuilder.loadTexts: cwdxBWQueueMaxDepth.setDescription('The maximum number of requests/packets which the queue can support.')
cwdxBWQueueDepth = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 2, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cwdxBWQueueDepth.setStatus('current')
if mibBuilder.loadTexts: cwdxBWQueueDepth.setDescription('The current number of requests/packets in the queue.')
cwdxBWQueueDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 2, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cwdxBWQueueDiscards.setStatus('current')
if mibBuilder.loadTexts: cwdxBWQueueDiscards.setDescription('The number of requests/packets discarded because of queue overflow (queue depth > queue maximum depth).')
cwdxCpeTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 3, 1), )
if mibBuilder.loadTexts: cwdxCpeTable.setStatus('current')
if mibBuilder.loadTexts: cwdxCpeTable.setDescription('This table contains information about Customer Premises Equipments (CPE).')
cwdxCpeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 3, 1, 1), ).setIndexNames((0, "CISCO-WIRELESS-DOCS-EXT-MIB", "cwdxCpeStatusIndex"), (0, "CISCO-WIRELESS-DOCS-EXT-MIB", "cwdxCpeMacAddress"))
if mibBuilder.loadTexts: cwdxCpeEntry.setReference('Data-Over-Cable Service Interface Specifications (DOCSIS) Radio Frequency Interface Specification (SP-RFI-I04-980724.) cwdIfHeSuStatusTable, cwdIfHeServiceTable in CISCO-DOCS-WIRELESS-IF-MIB.my.')
if mibBuilder.loadTexts: cwdxCpeEntry.setStatus('current')
if mibBuilder.loadTexts: cwdxCpeEntry.setDescription('The list contains information for a Customer Premises Equipment (CPE) connected to SUs. An entry exists for each Customer Premises Equipment connected to a subscriber-unit supported by HE.')
cwdxCpeStatusIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: cwdxCpeStatusIndex.setStatus('current')
if mibBuilder.loadTexts: cwdxCpeStatusIndex.setDescription('Index to an entry in cwdIfHeSuStatusTable identifying status of the SU (which the CPE connects to.)')
cwdxCpeMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 3, 1, 1, 2), MacAddress())
if mibBuilder.loadTexts: cwdxCpeMacAddress.setStatus('current')
if mibBuilder.loadTexts: cwdxCpeMacAddress.setDescription('The Mac address to identify a Customer Premises Equipment.')
cwdxCpeIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 3, 1, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cwdxCpeIpAddress.setStatus('current')
if mibBuilder.loadTexts: cwdxCpeIpAddress.setDescription('Ip address of the Customer Premises Equipment.')
cwdxCpeAccessGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 3, 1, 1, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cwdxCpeAccessGroup.setStatus('current')
if mibBuilder.loadTexts: cwdxCpeAccessGroup.setDescription('ASCII text to identify the Access Group for a CPE. Access Group is to filter the upstream traffic for that CPE.')
cwdxSuMappingTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 3, 2), )
if mibBuilder.loadTexts: cwdxSuMappingTable.setStatus('current')
if mibBuilder.loadTexts: cwdxSuMappingTable.setDescription('This table contains a mapping between the SU Mac Address and the cwdIfHeSuStatusIndex which identifies a row in cwdIfHeSuStatusTable which lists the attributes of an SU.')
cwdxSuMappingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 3, 2, 1), ).setIndexNames((0, "CISCO-WIRELESS-DOCS-EXT-MIB", "cwdxSuMappingMacAddress"))
if mibBuilder.loadTexts: cwdxSuMappingEntry.setReference('Data-Over-Cable Service Interface Specifications (DOCSIS) Radio Frequency Interface Specification (SP-RFI-I04-980724.) cwdIfHeSuStatusTable, cwdIfHeServiceTable in CISCO-DOCS-WIRELESS-IF-MIB.my.')
if mibBuilder.loadTexts: cwdxSuMappingEntry.setStatus('current')
if mibBuilder.loadTexts: cwdxSuMappingEntry.setDescription("There exists an entry in this table for every SU connected to the HE. Each entry contains a mapping from the SU's mac address to the cwdIfHeSuStatusIndex.")
cwdxSuMappingMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 3, 2, 1, 2), MacAddress())
if mibBuilder.loadTexts: cwdxSuMappingMacAddress.setStatus('current')
if mibBuilder.loadTexts: cwdxSuMappingMacAddress.setDescription('The Mac address to identify a Subscriber-unit.')
cwdxSuMappingStatusIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 3, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cwdxSuMappingStatusIndex.setStatus('current')
if mibBuilder.loadTexts: cwdxSuMappingStatusIndex.setDescription('Index to an entry in cwdIfHeSuStatusTable identifying status of the SU.')
cwdxHeSuStatusExtTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 3, 3), )
if mibBuilder.loadTexts: cwdxHeSuStatusExtTable.setStatus('current')
if mibBuilder.loadTexts: cwdxHeSuStatusExtTable.setDescription('The list contains the additional SU status information.')
cwdxHeSuStatusExtEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 3, 3, 1), )
if mibBuilder.loadTexts: cwdxHeSuStatusExtEntry.setReference('Data-Over-Cable Service Interface Specifications (DOCSIS) Radio Frequency Interface Specification (SP-RFI-I04-980724.) cwdIfHeSuStatusTable in DOCS-IF-MIB.my.')
cwdIfHeSuStatusEntry.registerAugmentions(("CISCO-WIRELESS-DOCS-EXT-MIB", "cwdxHeSuStatusExtEntry"))
cwdxHeSuStatusExtEntry.setIndexNames(*cwdIfHeSuStatusEntry.getIndexNames())
if mibBuilder.loadTexts: cwdxHeSuStatusExtEntry.setStatus('current')
if mibBuilder.loadTexts: cwdxHeSuStatusExtEntry.setDescription('Additional objects for cwdIfHeSuStatusTable entry.')
cwdxHeSuStatusValue = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 3, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14))).clone(namedValues=NamedValues(("offline", 1), ("others", 2), ("initRangingRcvd", 3), ("initDhcpReqRcvd", 4), ("onlineNetAccessDisabled", 5), ("onlineKekAssigned", 6), ("onlineTekAssigned", 7), ("rejectBadMic", 8), ("rejectBadCos", 9), ("kekRejected", 10), ("tekRejected", 11), ("online", 12), ("initTftpPacketRcvd", 13), ("initTodRequestRcvd", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cwdxHeSuStatusValue.setStatus('current')
if mibBuilder.loadTexts: cwdxHeSuStatusValue.setDescription("Current Subscriber-unit connectivity state. The object extends states in cwdIfHeSuStatusValue in more detail. The enumerations are: offline(1) : SU considered offline. others(2) : states is in cwdIfHeSuStatusValue. initRangingRcvd(3) : SU sent initial ranging. initDhcpReqRcvd(4) : dhcp request received. onlineNetAccessDisabled(5): SU registered, but network access for the SU is disabled. onlineKekAssigned(6) : SU registered, BPI enabled and KEK assigned. onlineTekAssigned(7) : SU registered, BPI enabled and TEK assigned. rejectBadMic(8) : SU did attempt to register but registration was refused due to bad mic. rejectBadCos(9) : SU did attempt to register but registration was refused due to bad COS. kekRejected(10) : KEK SU key assignment rejected. tekRejected(11) : TEK SU key assignment rejected. online(12) : SU registered, enabled for data. initTftpPacketRcvd(13): tftp packet received and option file transfer started. initTodRquestRcvd(14): Time of the Day (TOD) request received. The ranging, rangingAborted, rangingComplete, and ipComplete states in cwdIfHeSuStatusValue are all represented by the 'others' value in this object. The registrationComplete state in cwdIfHeSuStatusValue could be online, onlineNetAccessDisabled, onlineKekAssigned, or onlineTekAssigned in this object. The accessDenied state in cwdIfHeSuStatusValue could be rejectBadMic, rejectBadCos in this object for the possible reasons of Subscriber-unit registration abort. The HE only reports states it is able to detect.")
cwdxIfHeSuStatusOnlineTimes = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 3, 3, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cwdxIfHeSuStatusOnlineTimes.setReference('cwdxHeSuStatusValue object.')
if mibBuilder.loadTexts: cwdxIfHeSuStatusOnlineTimes.setStatus('current')
if mibBuilder.loadTexts: cwdxIfHeSuStatusOnlineTimes.setDescription("The number of times that the SU changes the connectivity state from 'offline' to 'online' over the time period from the SU's first ranging message received by HE until now. The SU is considered as 'online' when the value for cwdxHeSuStatusValue is any of the values: online(5), onlineNetAccessDisabled(6), onlineKekAssigned(7), and onlineTekAssigned(8), and the SU is considered as 'offline' for other values for cwdxHeSuStatusValue.")
cwdxIfHeSuStatusPercentOnline = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 3, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cwdxIfHeSuStatusPercentOnline.setReference('cwdxHeSuStatusValue object.')
if mibBuilder.loadTexts: cwdxIfHeSuStatusPercentOnline.setStatus('current')
if mibBuilder.loadTexts: cwdxIfHeSuStatusPercentOnline.setDescription("The percentage of time that the SU stays 'online' over the time period from the SU's first ranging message received by HE until now. The value for this object is 100 times bigger than the real percentage value. For example, 32.15% will be value 3215. The SU is considered as 'online' when the value for cwdxHeSuStatusValue is any of the values: online(5), onlineNetAccessDisabled(6), onlineKekAssigned(7), and onlineTekAssigned(8), and the SU is considered as 'offline' for other values for cwdxHeSuStatusValue.")
cwdxIfHeSuStatusMinOnlineTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 3, 3, 1, 4), TimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cwdxIfHeSuStatusMinOnlineTime.setReference('cwdxHeSuStatusValue object.')
if mibBuilder.loadTexts: cwdxIfHeSuStatusMinOnlineTime.setStatus('current')
if mibBuilder.loadTexts: cwdxIfHeSuStatusMinOnlineTime.setDescription("The minimum period of time the SU stayed 'online' over the time period from the SU's first ranging message received by HE until now. The SU is considered as 'online' when the value for cwdxHeSuStatusValue is any of the values: online(5), onlineNetAccessDisabled(6), onlineKekAssigned(7), and onlineTekAssigned(8), and the SU is considered as 'offline' for other values for cwdxHeSuStatusValue.")
cwdxIfHeSuStatusAvgOnlineTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 3, 3, 1, 5), TimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cwdxIfHeSuStatusAvgOnlineTime.setReference('cwdxHeSuStatusValue object.')
if mibBuilder.loadTexts: cwdxIfHeSuStatusAvgOnlineTime.setStatus('current')
if mibBuilder.loadTexts: cwdxIfHeSuStatusAvgOnlineTime.setDescription("The average period of time the SU stayed 'online' over the time period from the SU's first ranging message received by HE until now. The SU is considered as 'online' when the value for cwdxHeSuStatusValue is any of the values: online(5), onlineNetAccessDisabled(6), onlineKekAssigned(7), and onlineTekAssigned(8), and the SU is considered as 'offline' for other values for cwdxHeSuStatusValue.")
cwdxIfHeSuStatusMaxOnlineTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 3, 3, 1, 6), TimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cwdxIfHeSuStatusMaxOnlineTime.setReference('cwdxHeSuStatusValue object.')
if mibBuilder.loadTexts: cwdxIfHeSuStatusMaxOnlineTime.setStatus('current')
if mibBuilder.loadTexts: cwdxIfHeSuStatusMaxOnlineTime.setDescription("The maximum period of time the SU stayed 'online' over the time period from the SU's first ranging message received by HE until now. The SU is considered as 'online' when the value for cwdxHeSuStatusValue is any of the values: online(5), onlineNetAccessDisabled(6), onlineKekAssigned(7), and onlineTekAssigned(8), and the SU is considered as 'offline' for other values for cwdxHeSuStatusValue.")
cwdxIfHeSuStatusMinOfflineTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 3, 3, 1, 7), TimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cwdxIfHeSuStatusMinOfflineTime.setReference('cwdxHeSuStatusValue object.')
if mibBuilder.loadTexts: cwdxIfHeSuStatusMinOfflineTime.setStatus('current')
if mibBuilder.loadTexts: cwdxIfHeSuStatusMinOfflineTime.setDescription("The minimum period of time SU stayed 'offline' over the time period from the SU's first ranging message received by HE until now. The SU is considered as 'online' when the value for cwdxHeSuStatusValue is any of the values: online(5), onlineNetAccessDisabled(6), onlineKekAssigned(7), and onlineTekAssigned(8), and the SU is considered as 'offline' for other values for cwdxHeSuStatusValue.")
cwdxIfHeSuStatusAvgOfflineTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 3, 3, 1, 8), TimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cwdxIfHeSuStatusAvgOfflineTime.setReference('cwdxHeSuStatusValue object.')
if mibBuilder.loadTexts: cwdxIfHeSuStatusAvgOfflineTime.setStatus('current')
if mibBuilder.loadTexts: cwdxIfHeSuStatusAvgOfflineTime.setDescription("The average period of time the SU stayed 'offline' over the time period from the SU's first ranging message received by HE until now. The SU is considered as 'online' when the value for cwdxHeSuStatusValue is any of the values: online(5), onlineNetAccessDisabled(6), onlineKekAssigned(7), and onlineTekAssigned(8), and the SU is considered as 'offline' for other values for cwdxHeSuStatusValue.")
cwdxIfHeSuStatusMaxOfflineTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 3, 3, 1, 9), TimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cwdxIfHeSuStatusMaxOfflineTime.setReference('cwdxHeSuStatusValue object.')
if mibBuilder.loadTexts: cwdxIfHeSuStatusMaxOfflineTime.setStatus('current')
if mibBuilder.loadTexts: cwdxIfHeSuStatusMaxOfflineTime.setDescription("The maximum period of time the SU stayed 'offline' over the time period from the SU's first ranging message received by HE until now. The SU is considered as 'online' when the value for cwdxHeSuStatusValue is any of the values: online(5), onlineNetAccessDisabled(6), onlineKekAssigned(7), and onlineTekAssigned(8), and the SU is considered as 'offline' for other values for cwdxHeSuStatusValue.")
cwdxIfHeSuStatusDynSidCount = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 3, 3, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16383))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cwdxIfHeSuStatusDynSidCount.setStatus('current')
if mibBuilder.loadTexts: cwdxIfHeSuStatusDynSidCount.setDescription('The number of active dynamic sids on this SU.')
cwdxHeMacExtTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 3, 4), )
if mibBuilder.loadTexts: cwdxHeMacExtTable.setStatus('current')
if mibBuilder.loadTexts: cwdxHeMacExtTable.setDescription('This table contains the additions attributes of a HE MAC interface that provided by cwdIfHeMacTable.')
cwdxHeMacExtEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 3, 4, 1), )
if mibBuilder.loadTexts: cwdxHeMacExtEntry.setReference('cwdIfHeMacTable in CISCO-WIRELESS-DOCS-IF-MIB.my.')
cwdIfHeMacEntry.registerAugmentions(("CISCO-WIRELESS-DOCS-EXT-MIB", "cwdxHeMacExtEntry"))
cwdxHeMacExtEntry.setIndexNames(*cwdIfHeMacEntry.getIndexNames())
if mibBuilder.loadTexts: cwdxHeMacExtEntry.setStatus('current')
if mibBuilder.loadTexts: cwdxHeMacExtEntry.setDescription('Additional objects for cwdIfHeMacTable entry including the Subscriber-unit notification enable/disable and the interval of Subscriber-unit notification sent by the HE for a Subscriber-unit that the Mac interface supports. An entry in this table exists for each ifEntry with an ifType of propDocsWirelessMacLayer(nnn).')
cwdxHeSuOnOffTrapEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 3, 4, 1, 1), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cwdxHeSuOnOffTrapEnable.setStatus('current')
if mibBuilder.loadTexts: cwdxHeSuOnOffTrapEnable.setDescription('An indication of whether the cwdxHeSuOnOffNotification is enabled. The default value is false(2).')
cwdxHeSuOnOffTrapInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 3, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 86400))).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cwdxHeSuOnOffTrapInterval.setStatus('current')
if mibBuilder.loadTexts: cwdxHeSuOnOffTrapInterval.setDescription("The interval for cwdxHeSuOnOffNotification sent by HE for one online/offline state change if cwdxHeSuOnOffTrapEnable is true. If there are more than one state changes to online/offline for a Subscriber-unit during this interval, only one cwdxHeSuOnOffNotification is sent by HE for the first state change to online and one cwdxHeSuOnOffNotification for the first state changing to offline if cwdxHeSuOnOffTrapEnable is true. This is to avoid too many notifications sent for a SU online/offline state changes during a short period of time. If the value is 0, then cwdxHeSuOnOffNotification will be sent for every state change to online/offline for a SU if cwdxHeSuOnOffTrapEnable is true. This object's value will be retained even if the cwdxHeSuOnOffTrapEnable value changes. Thus disabling notifications will not result in this object's value being reset tot he default value. The default value is 600 seconds.")
cwdxHeSuDefaultMaxCpes = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 3, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cwdxHeSuDefaultMaxCpes.setStatus('current')
if mibBuilder.loadTexts: cwdxHeSuDefaultMaxCpes.setDescription('The default maximum number of permitted CPEs per SU in this wireless interface. A SU can override this value by setting the object cwdxHeSuMaxCpeNumber in the cwdxHeSuTable. The value 0 means no maximum limit. The default value for this object is 0. Setting the value will not affect the already connected CPEs to the SUs in this wireless interface.')
cwdxHeTotalSusRegistered = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 3, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cwdxHeTotalSusRegistered.setStatus('current')
if mibBuilder.loadTexts: cwdxHeTotalSusRegistered.setDescription('Total number of SUs that successfully registered at least once with this HE. This count will be decremented whenever the SUs are aged out at the HE.')
cwdxHeTotalSusOffline = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 3, 4, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cwdxHeTotalSusOffline.setStatus('current')
if mibBuilder.loadTexts: cwdxHeTotalSusOffline.setDescription("Total number of SU's that are offline at this time. The SU is considered as 'online' when the value for cwdxHeSuStatusValue is any of the values: online(5), onlineNetAccessDisabled(6), onlineKekAssigned(7), and onlineTekAssigned(8), and the SU is considered as 'offline' for other values for cwdxHeSuStatusValue.")
cwdxHeSuChOverTimeExpiration = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 3, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 86400))).setUnits('minutes').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cwdxHeSuChOverTimeExpiration.setReference('Data-Over-Cable Service Interface Specifications (DOCSIS) Radio Frequency Interface Specification (SP-RFI-I04-980724), 6.3.2.5.3 Overriding Channels.')
if mibBuilder.loadTexts: cwdxHeSuChOverTimeExpiration.setStatus('current')
if mibBuilder.loadTexts: cwdxHeSuChOverTimeExpiration.setDescription('The time period to expire a HE channel override operation. Within the time period, if the HE cannot send out a RNG-RSP message with channel override fields to a SU specified in the operation, the HE will abort the operation. The possible reason is that the SU does not repeat the initial ranging. The change to this object will not affect the already active operations in this cwdxHeSuChOverTable. Once the operation completes, the management station should retrieve the values of the cwdxHeSuChOverState object of interest, and should then delete the entry from cwdxHeSuChOverTable. In order to prevent old entries from clogging the table, entries will be aged out, but an entry will never be deleted within 15 minutes of completing.')
cwdxHeSuChOverTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 3, 6), )
if mibBuilder.loadTexts: cwdxHeSuChOverTable.setStatus('current')
if mibBuilder.loadTexts: cwdxHeSuChOverTable.setDescription('A table of HE operation entries to instruct Subscriber-units to move to a new downstream and/or upstream channel. An entry in this table is an operation that has been initiated from HE to generates downstream frequency and/or upstream channel override fields in the RNG-RSP message sent to a Subscriber-unit. A RNG-RSP message is sent to a SU during initial maintenance opportunity. This operation causes the HE to place an entry for the SU specified into the override request queue. The link is then broken by deleting the SU from its polling list. When the SU attempts initial ranging, the override request causes downstream frequency and upstream channel override fields to be inserted into the RNG-RSP message.')
cwdxHeSuChOverEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 3, 6, 1), ).setIndexNames((0, "CISCO-WIRELESS-DOCS-EXT-MIB", "cwdxHeSuChOverSerialNumber"))
if mibBuilder.loadTexts: cwdxHeSuChOverEntry.setReference('Data-Over-Cable Service Interface Specifications (DOCSIS) Radio Frequency Interface Specification (SP-RFI-I04-980724), 6.3.2.5.3 Overriding Channels.')
if mibBuilder.loadTexts: cwdxHeSuChOverEntry.setStatus('current')
if mibBuilder.loadTexts: cwdxHeSuChOverEntry.setDescription("An HE operation entry to instruct a Subscriber-unit to move to a new downstream and/or upstream channel. There can be more than one entry per Subscriber-unit, so there is a time stamp for each entry to show the time when this operation is initiated. A management station wishing to create an entry should first generate a pseudo-random serial number to be used as the index to this sparse table. The station should then create the associated instance of the row status object. It must also, either in the same or in successive PDUs, create the associated instance of the command and parameter objects. It should also modify the default values for any of the parameter objects if the defaults are not appropriate. Once the appropriate instances of all the command objects have been created, either by an explicit SNMP set request or by default, the row status should be set to active to initiate the operation. Note that this entire procedure may be initiated via a single set request which specifies a row status of createAndGo as well as specifies valid values for the non-defaulted parameter objects. Once an operation has been activated, it cannot be stopped. That is, it will run until either the HE has generated downstream frequency and/or upstream channel override fields in the RNG-RSP message sent to a Subscriber-unit or time out. In either case, the operation is completed. During this time the row cannot be destroyed. Once the operation is completed, the real result of the operation to the Subscriber-unit cannot be known from this table. The result of the Subscriber-unit's downstream frequency and the upstream channel id can be checked from other MIB tables. For example, cwdIfHeServiceTable from CISCO-WIRELESS-DOCS-IF-MIB can be used to check whether the Subscriber-unit's downstream frequency and upstream channel id are changed. Please note that even though HE has generated downstream frequency and/or upstream channel override fields in the RNG-RSP message sent to a SUs if the SU cannot lock at the instructed downstream frequency or no upstream channel id could be used, it may reconnect back to the original downstream frequency and upstream channel id. Once the operation completes, the management station should retrieve the values of the cwdxHeSuChOverState objects of interest, and should then delete the entry. In order to prevent old entries from clogging the table, entries will be aged out, but an entry will never be deleted within 15 minutes of completing.")
cwdxHeSuChOverSerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 3, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: cwdxHeSuChOverSerialNumber.setStatus('current')
if mibBuilder.loadTexts: cwdxHeSuChOverSerialNumber.setDescription('Object which specifies a unique entry in the table. A management station wishing to initiate a channel override operation should use a pseudo-random value for this object when creating or modifying an instance of a cwdxHeSuChOverEntry.')
cwdxHeSuChOverMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 3, 6, 1, 2), MacAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cwdxHeSuChOverMacAddress.setStatus('current')
if mibBuilder.loadTexts: cwdxHeSuChOverMacAddress.setDescription("The mac address of the Subscriber-unit that the HE instructs to move to a new downstream and/or upstream channel. This column must be set to a valid Mac address currently in the HE in order for this entry's row status to be set to active successfully.")
cwdxHeSuChOverDownFrequency = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 3, 6, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000000000))).setUnits('hertz').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cwdxHeSuChOverDownFrequency.setStatus('current')
if mibBuilder.loadTexts: cwdxHeSuChOverDownFrequency.setDescription('The new downstream frequency which the Subscriber-unit is instructed to move to. The value 0 is to ask the HE not to override the downstream frequency.')
cwdxHeSuChOverUpChannelId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 3, 6, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 255)).clone(-1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cwdxHeSuChOverUpChannelId.setStatus('current')
if mibBuilder.loadTexts: cwdxHeSuChOverUpChannelId.setDescription('The new channel Id which the Subscriber-unit is instructed to move to. The value -1 is to ask the HE not to override the upstream channel Id.')
cwdxHeSuChOverTrapOnCompletion = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 3, 6, 1, 5), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cwdxHeSuChOverTrapOnCompletion.setStatus('current')
if mibBuilder.loadTexts: cwdxHeSuChOverTrapOnCompletion.setDescription('Specifies whether or not a cwdxHeSuChOverNotification should be issued on completion of the operation. If such a notification is desired, it is the responsibility of the management entity to ensure that the SNMP administrative model is configured in such a way as to allow the notification to be delivered.')
cwdxHeSuChOverOpInitiatedTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 3, 6, 1, 6), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cwdxHeSuChOverOpInitiatedTime.setStatus('current')
if mibBuilder.loadTexts: cwdxHeSuChOverOpInitiatedTime.setDescription('The value of sysUpTime at which the operation was initiated. Since it is possible to have more than one entry in this table for a Subscriber-unit, this object can help to distinguish the entries for the same Subscriber-unit.')
cwdxHeSuChOverState = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 3, 6, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("messageSent", 1), ("commandNotActive", 2), ("noOpNeeded", 3), ("suNotFound", 4), ("waitToSendMessage", 5), ("timeOut", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cwdxHeSuChOverState.setReference('Data-Over-Cable Service Interface Specifications (DOCSIS) Radio Frequency Interface Specification (SP-RFI-I04-980724), 6.3.2.5.3 Overriding Channels.')
if mibBuilder.loadTexts: cwdxHeSuChOverState.setStatus('current')
if mibBuilder.loadTexts: cwdxHeSuChOverState.setDescription("The status of the specified channel override operation. The enumerations are: messageSent(1): the HE has sent a RNG-RSP message with channel override to the Subscriber-unit. commandNotActive(2): the command is not in active mode due to this entry's row status is not in active yet. noOpNeeded(3): The downstream frequency and the upstream channel Id in this entry are the same as original ones when this entry's row status is set to active, so HE does not need to do any operation. SuNotFound(4): The SU is not found in the HE at the time when the command becomes active. waitToSendMessage(5): specified the operation is active and HE is waiting to send a RNG-RSP message with channel override to the Subscriber-unit. timeOut(6): specified the operation is timed out. That is, the HE cannot send a RNG-RSP message with channel override to the Subscriber-unit within the time specified in the object of cwdxHeSuChOverTimeExpiration. The possible reason is that the Subscriber-unit does not repeat the initial ranging. The possible state change diagram is as below: [commandNotActive ->] waitToSendMessage -> messageSent or timeOut. [commandNotActive ->] noOpNeeded or SuNotFound.")
cwdxHeSuChOverRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 3, 6, 1, 8), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cwdxHeSuChOverRowStatus.setStatus('current')
if mibBuilder.loadTexts: cwdxHeSuChOverRowStatus.setDescription('The status of this table entry. This value for cwdxHeSuChOverMacAddress must be valid Mac address currently in the HE in order for the row status to be set to active successfully. Once the row status becomes active and state becomes waitToSendMessage, the entry cannot not be changed except to delete the entry by setting the row status to destroy(6) and since the operation cannot be stopped, the destroy(6) will just cause the SNMP agent to hide the entry from application and the SNMP agent will delete the entry right after the operation is completed.')
cwdxHeSuTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 3, 7), )
if mibBuilder.loadTexts: cwdxHeSuTable.setStatus('current')
if mibBuilder.loadTexts: cwdxHeSuTable.setDescription('This table contains attributes or configurable parameters for Subscriber-units from a HE.')
cwdxHeSuEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 3, 7, 1), ).setIndexNames((0, "CISCO-WIRELESS-DOCS-IF-MIB", "cwdIfHeSuStatusIndex"))
if mibBuilder.loadTexts: cwdxHeSuEntry.setStatus('current')
if mibBuilder.loadTexts: cwdxHeSuEntry.setDescription("The list contains a SU's attributes or configurable parameters from a HE.")
cwdxHeSuMaxCpeNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 3, 7, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cwdxHeSuMaxCpeNumber.setStatus('current')
if mibBuilder.loadTexts: cwdxHeSuMaxCpeNumber.setDescription('The maximum number of permitted CPEs connecting to the SU. The value -1 means to use the default value of maximum hosts per SU in the HE wireless interface which the SU connects to and the value is defined in cwdxHeSuDefaultMaxCpes in the cwdxHeMacExtTable. The value 0 means no maximum limit. The default value is -1. Setting the value will not affect the already connected CPEs to the SU.')
cwdxQosProfileExtTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 4, 1), )
if mibBuilder.loadTexts: cwdxQosProfileExtTable.setStatus('current')
if mibBuilder.loadTexts: cwdxQosProfileExtTable.setDescription('This table contains additional attributes to the Qos profiles that exists in cwdIfQosProfileTable in CISCO-WIRELESS-DOCS-IF-MIB.')
cwdxQosProfileExtEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 4, 1, 1), )
cwdIfQosProfileEntry.registerAugmentions(("CISCO-WIRELESS-DOCS-EXT-MIB", "cwdxQosProfileExtEntry"))
cwdxQosProfileExtEntry.setIndexNames(*cwdIfQosProfileEntry.getIndexNames())
if mibBuilder.loadTexts: cwdxQosProfileExtEntry.setStatus('current')
if mibBuilder.loadTexts: cwdxQosProfileExtEntry.setDescription('Each row extends the existing row in the cwdIfQosProfileTable with additional QOS parameters.')
cwdxQosProfGrantInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(20)).setUnits('milliseconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cwdxQosProfGrantInterval.setReference('Data over Cable Radio Frequency Interface Specification, SP-RFIv1.1-I02-990731 Appendix M.1.2')
if mibBuilder.loadTexts: cwdxQosProfGrantInterval.setStatus('current')
if mibBuilder.loadTexts: cwdxQosProfGrantInterval.setDescription('The value of this parameter specifies the interval between successive data grant opportunities for a service flow. This object is required for Unsolicited Grant and Unsolicited Grant with Activity Detection Service Flows. This object is optional for Real-Time Polling Service Flows.')
cwdxQosProfGrantSize = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(229)).setUnits('bytes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cwdxQosProfGrantSize.setReference('Data over Cable Radio Frequency Interface Specification, SP-RFIv1.1-I02-990731 Appendix M.1.2')
if mibBuilder.loadTexts: cwdxQosProfGrantSize.setStatus('current')
if mibBuilder.loadTexts: cwdxQosProfGrantSize.setDescription('This parameter specifies the unsolicited grant size.')
cwdxQosProfName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 4, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cwdxQosProfName.setStatus('current')
if mibBuilder.loadTexts: cwdxQosProfName.setDescription('This object is a string used to describe this Qos Profile. It has informational significance only.')
cwdxQosProfTosOverwriteMask = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cwdxQosProfTosOverwriteMask.setStatus('current')
if mibBuilder.loadTexts: cwdxQosProfTosOverwriteMask.setDescription('This object is the bit mask (8 bit wide) for tos-overwrite feature. The cwdxQosProfTosOverwriteValue is written where the mark bits are set to 1. Tos-overwrite allows the HE to mark egress IP packets (from the HE) with a specific TOS value. This relieves the subscriber unit from marking upstream packets with a specific TOS and is most useful when a subscriber unit is supplied by a third party vendor who may not have the option of applying a TOS to an IP packet. Each packet received from an SU that matches this QoS profile will be tagged with the TOS-overwrite value at the cwdxQosProfTosOverwriteMask and sent to the network.')
cwdxQosProfTosOverwriteValue = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 4, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cwdxQosProfTosOverwriteValue.setStatus('current')
if mibBuilder.loadTexts: cwdxQosProfTosOverwriteValue.setDescription('This object is the byte value for tos-overwrite. The cwdxQosProfTosOverwriteValue is written where the mark bits are set to 1. Each packet received from an SU that matches this QoS profile will be tagged with the cwdxQosProfTosOverwriteValue value at the cwdxQosProfTosOverwriteMask and sent to the network.')
cwdxQosIpTosRatelimitTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 4, 2), )
if mibBuilder.loadTexts: cwdxQosIpTosRatelimitTable.setStatus('current')
if mibBuilder.loadTexts: cwdxQosIpTosRatelimitTable.setDescription('Describes the Ip-precedence attached to every Qos Profile identified by a row in cwdIfQosProfileTable in CISCO-WIRELESS-DOCS-IF-MIB.')
cwdxQosIpTosRatelimitEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 4, 2, 1), ).setIndexNames((0, "CISCO-WIRELESS-DOCS-IF-MIB", "cwdIfQosProfIndex"), (0, "CISCO-WIRELESS-DOCS-EXT-MIB", "cwdxQosIpTosRatelimitIndex"))
if mibBuilder.loadTexts: cwdxQosIpTosRatelimitEntry.setStatus('current')
if mibBuilder.loadTexts: cwdxQosIpTosRatelimitEntry.setDescription('Describes the Ip Precedence parameters. For every QOS profile entry in the cwdIfQosProfileTable, there will be seven corresponding rows in this cwdxQosIpTosRatelimitTable. The default value of 0 will be assigned to cwdxQosIpTosRatelimitMaxDownRate for all the rows.')
cwdxQosIpTosRatelimitIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 4, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8)))
if mibBuilder.loadTexts: cwdxQosIpTosRatelimitIndex.setStatus('current')
if mibBuilder.loadTexts: cwdxQosIpTosRatelimitIndex.setDescription('The index value along with the primary index of cwdIfQosProfIndex which uniquely identifies an entry in the cwdxQosIpTosRatelimitEntry.')
cwdxQosIpTosRatelimitMaxDownRate = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 169, 1, 4, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100000000))).setUnits('bps').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cwdxQosIpTosRatelimitMaxDownRate.setStatus('current')
if mibBuilder.loadTexts: cwdxQosIpTosRatelimitMaxDownRate.setDescription('Maximum downstream rate that can be allowed with this IP precedence.')
ciscoWirelessDocsExtNotificationsPrefix = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 169, 2))
ciscoWirelessDocsExtNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 169, 2, 0))
cwdxHeSuOnOffNotification = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 169, 2, 0, 1)).setObjects(("CISCO-WIRELESS-DOCS-IF-MIB", "cwdIfHeSuStatusMacAddress"), ("CISCO-WIRELESS-DOCS-IF-MIB", "cwdIfHeSuStatusIpAddress"), ("CISCO-WIRELESS-DOCS-IF-MIB", "cwdIfHeSuStatusDownChanIfIndex"), ("CISCO-WIRELESS-DOCS-IF-MIB", "cwdIfHeSuStatusUpChanIfIndex"), ("CISCO-WIRELESS-DOCS-IF-MIB", "cwdIfHeSuStatusServiceId"), ("CISCO-WIRELESS-DOCS-EXT-MIB", "cwdxHeSuStatusValue"))
if mibBuilder.loadTexts: cwdxHeSuOnOffNotification.setStatus('current')
if mibBuilder.loadTexts: cwdxHeSuOnOffNotification.setDescription('This notification indicates that the SU coming online and going offline. A notification will be sent from HE for a SU status changing to online or offline within the interval specified in cwdxHeSuOnOffTrapInterval.')
cwdxHeSuChOverNotification = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 169, 2, 0, 2)).setObjects(("CISCO-WIRELESS-DOCS-EXT-MIB", "cwdxHeSuChOverMacAddress"), ("CISCO-WIRELESS-DOCS-EXT-MIB", "cwdxHeSuChOverDownFrequency"), ("CISCO-WIRELESS-DOCS-EXT-MIB", "cwdxHeSuChOverUpChannelId"), ("CISCO-WIRELESS-DOCS-EXT-MIB", "cwdxHeSuChOverOpInitiatedTime"), ("CISCO-WIRELESS-DOCS-EXT-MIB", "cwdxHeSuChOverState"))
if mibBuilder.loadTexts: cwdxHeSuChOverNotification.setStatus('current')
if mibBuilder.loadTexts: cwdxHeSuChOverNotification.setDescription('This notification is sent at the completion of a HE channel override operation if cwdxHeSuChOverTrapOnCompletion is true in the original entry. Once a channel override operation has been activated, it cannot be stopped. That is, it will run until either the HE has generated downstream frequency and/or upstream channel override fields in the RNG-RSP message sent to a HE or cwdxHeSuChOverTimeExpiration time expired. In either case, the operation is completed. State in the cwdxHeSuChOverState object will tell in which condition the operation is completed.')
ciscoWirelessDocsExtConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 169, 3))
cwdxDocsExtCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 169, 3, 1))
cwdxDocsExtGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 169, 3, 2))
cwdxDocsExtCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 169, 3, 1, 1)).setObjects(("CISCO-WIRELESS-DOCS-EXT-MIB", "cwdxQosCtrlGroup"), ("CISCO-WIRELESS-DOCS-EXT-MIB", "cwdxQosQueueGroup"), ("CISCO-WIRELESS-DOCS-EXT-MIB", "cwdxHeSuCpeGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cwdxDocsExtCompliance = cwdxDocsExtCompliance.setStatus('current')
if mibBuilder.loadTexts: cwdxDocsExtCompliance.setDescription('The compliance statement for devices that implement MCNS compliant Radio Frequency Interfaces and DOCSIS features.')
cwdxQosCtrlGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 169, 3, 2, 1)).setObjects(("CISCO-WIRELESS-DOCS-EXT-MIB", "cwdxQosCtrlUpAdmissionCtrl"), ("CISCO-WIRELESS-DOCS-EXT-MIB", "cwdxQosCtrlUpMaxRsvdBWPercent"), ("CISCO-WIRELESS-DOCS-EXT-MIB", "cwdxQosCtrlUpAdmissionRejects"), ("CISCO-WIRELESS-DOCS-EXT-MIB", "cwdxQosCtrlUpReservedBW"), ("CISCO-WIRELESS-DOCS-EXT-MIB", "cwdxQosCtrlUpMaxVirtualBW"), ("CISCO-WIRELESS-DOCS-EXT-MIB", "cwdxQosIfRateLimitAlgo"), ("CISCO-WIRELESS-DOCS-EXT-MIB", "cwdxQosIfRateLimitExpWgt"), ("CISCO-WIRELESS-DOCS-EXT-MIB", "cwdxQosIfRateLimitShpMaxDelay"), ("CISCO-WIRELESS-DOCS-EXT-MIB", "cwdxQosIfRateLimitShpGranularity"), ("CISCO-WIRELESS-DOCS-EXT-MIB", "cwdxIfHeServiceOutOctets"), ("CISCO-WIRELESS-DOCS-EXT-MIB", "cwdxIfHeServiceOutPackets"), ("CISCO-WIRELESS-DOCS-EXT-MIB", "cwdxQosMaxUpBWExcessRequests"), ("CISCO-WIRELESS-DOCS-EXT-MIB", "cwdxQosMaxDownBWExcessPackets"), ("CISCO-WIRELESS-DOCS-EXT-MIB", "cwdxQosProfGrantInterval"), ("CISCO-WIRELESS-DOCS-EXT-MIB", "cwdxQosProfGrantSize"), ("CISCO-WIRELESS-DOCS-EXT-MIB", "cwdxQosProfName"), ("CISCO-WIRELESS-DOCS-EXT-MIB", "cwdxQosProfTosOverwriteMask"), ("CISCO-WIRELESS-DOCS-EXT-MIB", "cwdxQosProfTosOverwriteValue"), ("CISCO-WIRELESS-DOCS-EXT-MIB", "cwdxQosIpTosRatelimitMaxDownRate"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cwdxQosCtrlGroup = cwdxQosCtrlGroup.setStatus('current')
if mibBuilder.loadTexts: cwdxQosCtrlGroup.setDescription('Group of objects implemented in HE wireless interfaces for states of the scheduler supporting Data-Over-Cable Service Interface Specifications (DOCSIS) 1.0 Quality of Service (QoS).')
cwdxQosQueueGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 169, 3, 2, 2)).setObjects(("CISCO-WIRELESS-DOCS-EXT-MIB", "cwdxBWQueueOrder"), ("CISCO-WIRELESS-DOCS-EXT-MIB", "cwdxBWQueueNumServedBeforeYield"), ("CISCO-WIRELESS-DOCS-EXT-MIB", "cwdxBWQueueType"), ("CISCO-WIRELESS-DOCS-EXT-MIB", "cwdxBWQueueMaxDepth"), ("CISCO-WIRELESS-DOCS-EXT-MIB", "cwdxBWQueueDepth"), ("CISCO-WIRELESS-DOCS-EXT-MIB", "cwdxBWQueueDiscards"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cwdxQosQueueGroup = cwdxQosQueueGroup.setStatus('current')
if mibBuilder.loadTexts: cwdxQosQueueGroup.setDescription('Group of objects implemented in HE wireless interfaces for the queuing states of the scheduler supporting Data-Over-Cable Service Interface Specifications (DOCSIS) 1.0 Quality of Service (QoS). Each upstream scheduler maintains a queue set, but the downstream schedulers does not in DOCSIS 1.0 QoS. So only each upstream has an entry for DOCSIS 1.0 QoS support.')
cwdxHeSuCpeGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 169, 3, 2, 3)).setObjects(("CISCO-WIRELESS-DOCS-EXT-MIB", "cwdxCpeIpAddress"), ("CISCO-WIRELESS-DOCS-EXT-MIB", "cwdxCpeAccessGroup"), ("CISCO-WIRELESS-DOCS-EXT-MIB", "cwdxSuMappingStatusIndex"), ("CISCO-WIRELESS-DOCS-EXT-MIB", "cwdxHeSuStatusValue"), ("CISCO-WIRELESS-DOCS-EXT-MIB", "cwdxIfHeSuStatusOnlineTimes"), ("CISCO-WIRELESS-DOCS-EXT-MIB", "cwdxIfHeSuStatusPercentOnline"), ("CISCO-WIRELESS-DOCS-EXT-MIB", "cwdxIfHeSuStatusMinOnlineTime"), ("CISCO-WIRELESS-DOCS-EXT-MIB", "cwdxIfHeSuStatusAvgOnlineTime"), ("CISCO-WIRELESS-DOCS-EXT-MIB", "cwdxIfHeSuStatusMaxOnlineTime"), ("CISCO-WIRELESS-DOCS-EXT-MIB", "cwdxIfHeSuStatusMinOfflineTime"), ("CISCO-WIRELESS-DOCS-EXT-MIB", "cwdxIfHeSuStatusAvgOfflineTime"), ("CISCO-WIRELESS-DOCS-EXT-MIB", "cwdxIfHeSuStatusMaxOfflineTime"), ("CISCO-WIRELESS-DOCS-EXT-MIB", "cwdxIfHeSuStatusDynSidCount"), ("CISCO-WIRELESS-DOCS-EXT-MIB", "cwdxHeSuOnOffTrapEnable"), ("CISCO-WIRELESS-DOCS-EXT-MIB", "cwdxHeSuOnOffTrapInterval"), ("CISCO-WIRELESS-DOCS-EXT-MIB", "cwdxHeSuDefaultMaxCpes"), ("CISCO-WIRELESS-DOCS-EXT-MIB", "cwdxHeTotalSusRegistered"), ("CISCO-WIRELESS-DOCS-EXT-MIB", "cwdxHeTotalSusOffline"), ("CISCO-WIRELESS-DOCS-EXT-MIB", "cwdxHeSuChOverTimeExpiration"), ("CISCO-WIRELESS-DOCS-EXT-MIB", "cwdxHeSuChOverMacAddress"), ("CISCO-WIRELESS-DOCS-EXT-MIB", "cwdxHeSuChOverDownFrequency"), ("CISCO-WIRELESS-DOCS-EXT-MIB", "cwdxHeSuChOverUpChannelId"), ("CISCO-WIRELESS-DOCS-EXT-MIB", "cwdxHeSuChOverTrapOnCompletion"), ("CISCO-WIRELESS-DOCS-EXT-MIB", "cwdxHeSuChOverOpInitiatedTime"), ("CISCO-WIRELESS-DOCS-EXT-MIB", "cwdxHeSuChOverState"), ("CISCO-WIRELESS-DOCS-EXT-MIB", "cwdxHeSuChOverRowStatus"), ("CISCO-WIRELESS-DOCS-EXT-MIB", "cwdxHeSuMaxCpeNumber"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cwdxHeSuCpeGroup = cwdxHeSuCpeGroup.setStatus('current')
if mibBuilder.loadTexts: cwdxHeSuCpeGroup.setDescription('Group of objects implemented in HE for managing and monitoring Customer Premises Equipments.')
mibBuilder.exportSymbols("CISCO-WIRELESS-DOCS-EXT-MIB", cwdxHeSuChOverOpInitiatedTime=cwdxHeSuChOverOpInitiatedTime, cwdxHeSuChOverSerialNumber=cwdxHeSuChOverSerialNumber, cwdxHeServiceExtTable=cwdxHeServiceExtTable, ciscoWirelessDocsExtMIBObjects=ciscoWirelessDocsExtMIBObjects, cwdxCpeMacAddress=cwdxCpeMacAddress, cwdxBWQueueTable=cwdxBWQueueTable, ciscoWirelessDocsExtNotifications=ciscoWirelessDocsExtNotifications, cwdxQosCtrlObjects=cwdxQosCtrlObjects, cwdxHeSuOnOffNotification=cwdxHeSuOnOffNotification, cwdxHeSuChOverUpChannelId=cwdxHeSuChOverUpChannelId, cwdxHeSuChOverTimeExpiration=cwdxHeSuChOverTimeExpiration, cwdxHeSuChOverTable=cwdxHeSuChOverTable, cwdxIfHeServiceOutOctets=cwdxIfHeServiceOutOctets, cwdxQosCtrlUpEntry=cwdxQosCtrlUpEntry, cwdxIfHeSuStatusMaxOfflineTime=cwdxIfHeSuStatusMaxOfflineTime, cwdxHeSuStatusValue=cwdxHeSuStatusValue, ciscoWirelessDocsExtMIB=ciscoWirelessDocsExtMIB, cwdxQosProfTosOverwriteValue=cwdxQosProfTosOverwriteValue, cwdxBWQueueDiscards=cwdxBWQueueDiscards, cwdxQosProfGrantSize=cwdxQosProfGrantSize, cwdxQosProfileExtEntry=cwdxQosProfileExtEntry, cwdxHeServiceExtEntry=cwdxHeServiceExtEntry, cwdxBWQueueDepth=cwdxBWQueueDepth, cwdxQosQueueGroup=cwdxQosQueueGroup, cwdxHeSuChOverNotification=cwdxHeSuChOverNotification, cwdxIfHeSuStatusAvgOfflineTime=cwdxIfHeSuStatusAvgOfflineTime, cwdxHeSuChOverTrapOnCompletion=cwdxHeSuChOverTrapOnCompletion, cwdxBWQueueEntry=cwdxBWQueueEntry, cwdxHeMacExtTable=cwdxHeMacExtTable, cwdxIfHeSuStatusOnlineTimes=cwdxIfHeSuStatusOnlineTimes, cwdxQosIfRateLimitShpMaxDelay=cwdxQosIfRateLimitShpMaxDelay, cwdxQosMaxUpBWExcessRequests=cwdxQosMaxUpBWExcessRequests, cwdxIfHeSuStatusPercentOnline=cwdxIfHeSuStatusPercentOnline, cwdxHeSuStatusExtTable=cwdxHeSuStatusExtTable, cwdxSuMappingTable=cwdxSuMappingTable, cwdxQosCtrlUpAdmissionRejects=cwdxQosCtrlUpAdmissionRejects, cwdxQosIpTosRatelimitIndex=cwdxQosIpTosRatelimitIndex, cwdxCpeEntry=cwdxCpeEntry, cwdxHeSuOnOffTrapInterval=cwdxHeSuOnOffTrapInterval, cwdxBWQueueOrder=cwdxBWQueueOrder, cwdxHeTotalSusOffline=cwdxHeTotalSusOffline, cwdxQosCtrlUpTable=cwdxQosCtrlUpTable, cwdxSuMappingMacAddress=cwdxSuMappingMacAddress, cwdxIfHeSuStatusAvgOnlineTime=cwdxIfHeSuStatusAvgOnlineTime, cwdxCpeTable=cwdxCpeTable, cwdxBWQueueType=cwdxBWQueueType, cwdxCpeAccessGroup=cwdxCpeAccessGroup, cwdxHeSuCpeObjects=cwdxHeSuCpeObjects, cwdxBWQueueNumServedBeforeYield=cwdxBWQueueNumServedBeforeYield, cwdxHeSuDefaultMaxCpes=cwdxHeSuDefaultMaxCpes, cwdxQosProfGrantInterval=cwdxQosProfGrantInterval, cwdxIfHeSuStatusDynSidCount=cwdxIfHeSuStatusDynSidCount, cwdxHeSuTable=cwdxHeSuTable, cwdxBWQueueNameCode=cwdxBWQueueNameCode, ciscoWirelessDocsExtNotificationsPrefix=ciscoWirelessDocsExtNotificationsPrefix, cwdxHeSuStatusExtEntry=cwdxHeSuStatusExtEntry, cwdxQosCtrlUpReservedBW=cwdxQosCtrlUpReservedBW, cwdxCpeIpAddress=cwdxCpeIpAddress, cwdxQosIpTosRatelimitEntry=cwdxQosIpTosRatelimitEntry, cwdxQosIfRateLimitTable=cwdxQosIfRateLimitTable, cwdxHeSuChOverDownFrequency=cwdxHeSuChOverDownFrequency, cwdxQosIpTosRatelimitMaxDownRate=cwdxQosIpTosRatelimitMaxDownRate, cwdxIfHeSuStatusMinOfflineTime=cwdxIfHeSuStatusMinOfflineTime, cwdxHeSuCpeGroup=cwdxHeSuCpeGroup, cwdxQosProfTosOverwriteMask=cwdxQosProfTosOverwriteMask, cwdxQosProfileExtTable=cwdxQosProfileExtTable, ciscoWirelessDocsExtConformance=ciscoWirelessDocsExtConformance, cwdxQosCtrlUpMaxRsvdBWPercent=cwdxQosCtrlUpMaxRsvdBWPercent, cwdxQosIfRateLimitExpWgt=cwdxQosIfRateLimitExpWgt, cwdxIfHeSuStatusMinOnlineTime=cwdxIfHeSuStatusMinOnlineTime, cwdxHeSuEntry=cwdxHeSuEntry, cwdxQosCtrlUpAdmissionCtrl=cwdxQosCtrlUpAdmissionCtrl, cwdxBWQueueMaxDepth=cwdxBWQueueMaxDepth, cwdxHeSuOnOffTrapEnable=cwdxHeSuOnOffTrapEnable, cwdxHeSuChOverEntry=cwdxHeSuChOverEntry, cwdxHeSuMaxCpeNumber=cwdxHeSuMaxCpeNumber, cwdxCpeStatusIndex=cwdxCpeStatusIndex, cwdxDocsExtGroups=cwdxDocsExtGroups, cwdxQosProfileExtObjects=cwdxQosProfileExtObjects, cwdxHeMacExtEntry=cwdxHeMacExtEntry, cwdxHeSuChOverMacAddress=cwdxHeSuChOverMacAddress, cwdxQosCtrlGroup=cwdxQosCtrlGroup, PYSNMP_MODULE_ID=ciscoWirelessDocsExtMIB, cwdxSuMappingStatusIndex=cwdxSuMappingStatusIndex, cwdxIfHeSuStatusMaxOnlineTime=cwdxIfHeSuStatusMaxOnlineTime, cwdxSuMappingEntry=cwdxSuMappingEntry, cwdxQosProfName=cwdxQosProfName, cwdxQosQueueObjects=cwdxQosQueueObjects, cwdxQosIfRateLimitShpGranularity=cwdxQosIfRateLimitShpGranularity, cwdxQosIpTosRatelimitTable=cwdxQosIpTosRatelimitTable, cwdxDocsExtCompliance=cwdxDocsExtCompliance, cwdxHeTotalSusRegistered=cwdxHeTotalSusRegistered, cwdxHeSuChOverRowStatus=cwdxHeSuChOverRowStatus, cwdxQosCtrlUpMaxVirtualBW=cwdxQosCtrlUpMaxVirtualBW, cwdxQosIfRateLimitAlgo=cwdxQosIfRateLimitAlgo, cwdxQosMaxDownBWExcessPackets=cwdxQosMaxDownBWExcessPackets, cwdxQosIfRateLimitEntry=cwdxQosIfRateLimitEntry, cwdxDocsExtCompliances=cwdxDocsExtCompliances, cwdxIfHeServiceOutPackets=cwdxIfHeServiceOutPackets, cwdxHeSuChOverState=cwdxHeSuChOverState)

#
# PySNMP MIB module IBM-LAN-EMULATION-EXTENSION-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/IBM-LAN-EMULATION-EXTENSION-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:51:04 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint, ValueSizeConstraint, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint", "ValueSizeConstraint", "ValueRangeConstraint")
BridgeId, Timeout = mibBuilder.importSymbols("BRIDGE-MIB", "BridgeId", "Timeout")
IfIndexOrZero, = mibBuilder.importSymbols("LAN-EMULATION-ELAN-MIB", "IfIndexOrZero")
lesConfEntry, = mibBuilder.importSymbols("LAN-EMULATION-LES-MIB", "lesConfEntry")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
NotificationType, MibIdentifier, ObjectIdentity, ModuleIdentity, IpAddress, enterprises, Integer32, MibScalar, MibTable, MibTableRow, MibTableColumn, iso, Bits, Counter64, TimeTicks, Counter32, Unsigned32, Gauge32 = mibBuilder.importSymbols("SNMPv2-SMI", "NotificationType", "MibIdentifier", "ObjectIdentity", "ModuleIdentity", "IpAddress", "enterprises", "Integer32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "iso", "Bits", "Counter64", "TimeTicks", "Counter32", "Unsigned32", "Gauge32")
TextualConvention, RowStatus, DisplayString, TimeStamp, MacAddress = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "RowStatus", "DisplayString", "TimeStamp", "MacAddress")
lanEmulation = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 5, 8))
ibm = MibIdentifier((1, 3, 6, 1, 4, 1, 2))
ibmArchitecture = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 5))
ibmLeServerX = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 5, 8, 3))
ibmLeClientX = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 5, 8, 4))
ibmLeMIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 5, 8, 5))
ibmLeServerXMonitoring = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 5, 8, 3, 1))
ibmLeServerXConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 5, 8, 3, 2))
ibmLeServerXMon = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 5, 8, 3, 1, 1))
ibmSuperELAN = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1))
ibmBbcmMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 2))
ibmBbcmConfigGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 2, 1))
ibmBbcmStatsGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 2, 2))
ibmVlan = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 3))
ibmVlanGGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 3, 1))
ibmVlanGOGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 3, 1, 1))
ibmVlanCGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 3, 2))
ibmVlanConfGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 3, 2, 1))
ibmVlanStatusGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 3, 3))
ibmLeMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 5, 8, 5, 1))
ibmLeMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 5, 8, 5, 2))
class IbmSEBridgeID(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 65535)

class IbmVlanPortMap(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(1, 65535)

class IbmVlanIndex(Integer32):
    pass

class IbmVlanType(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))
    namedValues = NamedValues(("ip", 1), ("ipx", 2), ("netbios", 3), ("userDefSldWindo", 4), ("mac", 5), ("byPort", 6), ("ipMulticast", 7))

ibmLeServerXMonLecsInstances = MibScalar((1, 3, 6, 1, 4, 1, 2, 5, 8, 3, 1, 1, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmLeServerXMonLecsInstances.setStatus('mandatory')
if mibBuilder.loadTexts: ibmLeServerXMonLecsInstances.setDescription('The number of LECS instances currently created on this agent.')
ibmLeServerXMonLesInstances = MibScalar((1, 3, 6, 1, 4, 1, 2, 5, 8, 3, 1, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmLeServerXMonLesInstances.setStatus('mandatory')
if mibBuilder.loadTexts: ibmLeServerXMonLesInstances.setDescription('The number of LES instances currently created on this agent.')
ibmLeServerXMonBusInstances = MibScalar((1, 3, 6, 1, 4, 1, 2, 5, 8, 3, 1, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmLeServerXMonBusInstances.setStatus('mandatory')
if mibBuilder.loadTexts: ibmLeServerXMonBusInstances.setDescription('The number of BUS instances currently created on this agent.')
ibmLeServerXLecsMonTable = MibTable((1, 3, 6, 1, 4, 1, 2, 5, 8, 3, 1, 2), )
if mibBuilder.loadTexts: ibmLeServerXLecsMonTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmLeServerXLecsMonTable.setDescription('This table provides monitoring of LECS instances.')
ibmLeServerXLecsMonEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 5, 8, 3, 1, 2, 1), ).setIndexNames((0, "IBM-LAN-EMULATION-EXTENSION-MIB", "ibmLeServerXLecsMonIndex"))
if mibBuilder.loadTexts: ibmLeServerXLecsMonEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmLeServerXLecsMonEntry.setDescription('Entries of ibmLeServerXLecsMonTable.')
ibmLeServerXLecsMonIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 3, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 214748364)))
if mibBuilder.loadTexts: ibmLeServerXLecsMonIndex.setReference('LAN-EMULATION-ELAN-MIB for definition of lecsConfIndex')
if mibBuilder.loadTexts: ibmLeServerXLecsMonIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmLeServerXLecsMonIndex.setDescription('The index used to identify this LECS instance on this agent. This variable has the same value as the lecsConfIndex used to identify this instance in the LECS MIB.')
ibmLeServerXLecsUsedConnections = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 3, 1, 2, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmLeServerXLecsUsedConnections.setStatus('mandatory')
if mibBuilder.loadTexts: ibmLeServerXLecsUsedConnections.setDescription('The number of virtual connections currently in use by this LECS instance.')
ibmLeServerXLesMonTable = MibTable((1, 3, 6, 1, 4, 1, 2, 5, 8, 3, 1, 3), )
if mibBuilder.loadTexts: ibmLeServerXLesMonTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmLeServerXLesMonTable.setDescription('This table provides monitoring of LES instances.')
ibmLeServerXLesMonEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 5, 8, 3, 1, 3, 1), ).setIndexNames((0, "IBM-LAN-EMULATION-EXTENSION-MIB", "ibmLeServerXLesMonIndex"))
if mibBuilder.loadTexts: ibmLeServerXLesMonEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmLeServerXLesMonEntry.setDescription('Entries of ibmLeServerXLesMonTable.')
ibmLeServerXLesMonIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 3, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 214748364)))
if mibBuilder.loadTexts: ibmLeServerXLesMonIndex.setReference('LAN-EMULATION-LES-MIB for definition of lesConfIndex')
if mibBuilder.loadTexts: ibmLeServerXLesMonIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmLeServerXLesMonIndex.setDescription('The index used to identify this LES instance on this agent. This variable has the same value as the lesConfIndex used to identify this instance in the LES MIB.')
ibmLeServerXLesMonUsedConnections = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 3, 1, 3, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmLeServerXLesMonUsedConnections.setStatus('mandatory')
if mibBuilder.loadTexts: ibmLeServerXLesMonUsedConnections.setDescription('The number of virtual connections currently in use by this LES instance.')
ibmLeServerXLesMonLesLecInstances = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 3, 1, 3, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmLeServerXLesMonLesLecInstances.setReference('LAN-EMULATION-LES-MIB for definition of lesLecTable')
if mibBuilder.loadTexts: ibmLeServerXLesMonLesLecInstances.setStatus('mandatory')
if mibBuilder.loadTexts: ibmLeServerXLesMonLesLecInstances.setDescription('The number of clients currently served by this LES instance. This is the number of entries in the lesLecTable which have successfully joined this LES instance.')
ibmLeServerXBusMonTable = MibTable((1, 3, 6, 1, 4, 1, 2, 5, 8, 3, 1, 4), )
if mibBuilder.loadTexts: ibmLeServerXBusMonTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmLeServerXBusMonTable.setDescription('This table provides monitoring of BUS instances.')
ibmLeServerXBusMonEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 5, 8, 3, 1, 4, 1), ).setIndexNames((0, "IBM-LAN-EMULATION-EXTENSION-MIB", "ibmLeServerXBusMonIndex"))
if mibBuilder.loadTexts: ibmLeServerXBusMonEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmLeServerXBusMonEntry.setDescription('Entries of ibmLeServerXBusMonTable.')
ibmLeServerXBusMonIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 3, 1, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 214748364)))
if mibBuilder.loadTexts: ibmLeServerXBusMonIndex.setReference('LAN-EMULATION-BUS-MIB for definition of busConfIndex')
if mibBuilder.loadTexts: ibmLeServerXBusMonIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmLeServerXBusMonIndex.setDescription('The index used to identify this BUS instance on this agent. This variable has the same value as the busConfIndex used to identify this instance in the BUS MIB.')
ibmLeServerXBusMonUsedConnections = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 3, 1, 4, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmLeServerXBusMonUsedConnections.setStatus('mandatory')
if mibBuilder.loadTexts: ibmLeServerXBusMonUsedConnections.setDescription('The number of virtual connections currently in use by this BUS instance.')
ibmLeServerXBusMonBusLecInstances = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 3, 1, 4, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmLeServerXBusMonBusLecInstances.setReference('LAN-EMULATION-BUS-MIB for definition of busLecTable')
if mibBuilder.loadTexts: ibmLeServerXBusMonBusLecInstances.setStatus('mandatory')
if mibBuilder.loadTexts: ibmLeServerXBusMonBusLecInstances.setDescription('The number of clients currently served by this BUS instance. This is the number of entries in the busLecTable.')
ibmLeServerXLesConfigTable = MibTable((1, 3, 6, 1, 4, 1, 2, 5, 8, 3, 2, 1), )
if mibBuilder.loadTexts: ibmLeServerXLesConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmLeServerXLesConfigTable.setDescription('This table provides extension for LES configuration.')
ibmLeServerXLesConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 5, 8, 3, 2, 1, 1), ).setIndexNames((0, "IBM-LAN-EMULATION-EXTENSION-MIB", "lesConfIndex"))
if mibBuilder.loadTexts: ibmLeServerXLesConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmLeServerXLesConfigEntry.setDescription('Entries of ibmLeServerXLesConfigTable.')
ibmLeServerXLesMinLecID = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 3, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65279)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmLeServerXLesMinLecID.setStatus('mandatory')
if mibBuilder.loadTexts: ibmLeServerXLesMinLecID.setDescription('The minimum number on the LEC ID range in use by by this LES instance. The default value is 1 the first possible LEC ID. ')
ibmLeServerXLesMaxLecID = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 3, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65279)).clone(65279)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmLeServerXLesMaxLecID.setStatus('mandatory')
if mibBuilder.loadTexts: ibmLeServerXLesMaxLecID.setDescription('The maximum number on the LEC ID range in use by by this LES instance. The default value is 65279 the last possible LEC ID. ')
ibmSEPortStatisticsTable = MibTable((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 1), )
if mibBuilder.loadTexts: ibmSEPortStatisticsTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEPortStatisticsTable.setDescription('This table contains statistics about LAN Emulation Control Frame Statistics for Super ELAN Bridge ports.')
ibmSEPortStatisticsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 1, 1), ).setIndexNames((0, "IBM-LAN-EMULATION-EXTENSION-MIB", "ibmSEBridgeId"), (0, "IBM-LAN-EMULATION-EXTENSION-MIB", "ibmSEPortNum"))
if mibBuilder.loadTexts: ibmSEPortStatisticsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEPortStatisticsEntry.setDescription('A list of LE Control Frame statistical information for each SEB port')
ibmSEBridgeId = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 1, 1, 1), IbmSEBridgeID())
if mibBuilder.loadTexts: ibmSEBridgeId.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEBridgeId.setDescription('The identifier of the Super ELAN Bridge which this LAN Emulation Client has joined.')
ibmSEPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: ibmSEPortNum.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEPortNum.setDescription('The bridge port number associated with this Super ELAN Bridge LAN Emulation Client. This variable directly corresponds, is equal to, the dot1dBasePort variable in rfc1493.')
ibmSEPortArpRequestsIn = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmSEPortArpRequestsIn.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEPortArpRequestsIn.setDescription('The number of LE ARP Requests received by the SEB port.')
ibmSEPortArpRequestsOut = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmSEPortArpRequestsOut.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEPortArpRequestsOut.setDescription('The number of bridged LE ARP Requests transmitted by the SEB port.')
ibmSEArpRequestsErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmSEArpRequestsErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEArpRequestsErrors.setDescription('The number of received LE ARP Requests that were not bridged by the SEB port')
ibmSEPortArpRequestsDroppedPortBlocked = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmSEPortArpRequestsDroppedPortBlocked.setReference('rfc1493: dot1dStpPortState')
if mibBuilder.loadTexts: ibmSEPortArpRequestsDroppedPortBlocked.setStatus('obsolete')
if mibBuilder.loadTexts: ibmSEPortArpRequestsDroppedPortBlocked.setDescription('The number of outgoing ARP Requests that were dropped by the SEB port because the port was in the blocking state.')
ibmSEPortArpRequestsFiltered = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmSEPortArpRequestsFiltered.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEPortArpRequestsFiltered.setDescription('The number of received LE ARP Requests discarded by the SEB port because the target MAC address in the LE ARP Request was filtered by the bridge.')
ibmSEPortArpRepliesIn = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmSEPortArpRepliesIn.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEPortArpRepliesIn.setDescription('The number of LE ARP Responses received by the SEB port.')
ibmSEPortArpRepliesOut = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmSEPortArpRepliesOut.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEPortArpRepliesOut.setDescription('The number of bridged LE ARP Responses transmitted by the SEB port.')
ibmSEPortArpRepliesErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmSEPortArpRepliesErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEPortArpRepliesErrors.setDescription('The number of received LE ARP Responses that were dropped by the SEB port because the SEB port originating the corresponding LE ARP Request could not be determined.')
ibmSEPortNarpRequestsIn = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmSEPortNarpRequestsIn.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEPortNarpRequestsIn.setDescription('The number of LE NARP Requests received by the SEB port.')
ibmSEPortNarpRequestsOut = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmSEPortNarpRequestsOut.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEPortNarpRequestsOut.setDescription('The number of bridged LE NARP Requests transmitted by the SEB port.')
ibmSEPortNarpRequestsDroppedPortBlocked = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmSEPortNarpRequestsDroppedPortBlocked.setReference('rfc1493: dot1dStpPortState')
if mibBuilder.loadTexts: ibmSEPortNarpRequestsDroppedPortBlocked.setStatus('obsolete')
if mibBuilder.loadTexts: ibmSEPortNarpRequestsDroppedPortBlocked.setDescription('The number of bridged LE NARP Requests that were dropped by the SEB port because the port was in the blocking state.')
ibmSEPortFlushRequestsIn = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmSEPortFlushRequestsIn.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEPortFlushRequestsIn.setDescription('The number of LE Flush Requests received by the SEB port.')
ibmSEPortFlushRequestsOut = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmSEPortFlushRequestsOut.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEPortFlushRequestsOut.setDescription('The number of bridged LE Flush Requests transmitted by the SEB port.')
ibmSEPortFlushRepliesIn = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmSEPortFlushRepliesIn.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEPortFlushRepliesIn.setDescription('The number of LE Flush Responses received by the SEB port.')
ibmSEPortFlushRepliesOut = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmSEPortFlushRepliesOut.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEPortFlushRepliesOut.setDescription('The number of bridged LE Flush Responses transmitted by the SEB port.')
ibmSEPortFlushRequestErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmSEPortFlushRequestErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEPortFlushRequestErrors.setDescription('The number of bridged LE Flush Request Errors for this SEB port.')
ibmSEPortFlushRepliesErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 1, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmSEPortFlushRepliesErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEPortFlushRepliesErrors.setDescription('The number of bridged LE Flush Replies Errors for this SEB port.')
ibmSEPortLeCtrlFramesIn = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmSEPortLeCtrlFramesIn.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEPortLeCtrlFramesIn.setDescription('The total number of LE Control frames received by the SEB port.')
ibmSEPortLeCtrlFramesOut = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 1, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmSEPortLeCtrlFramesOut.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEPortLeCtrlFramesOut.setDescription('The total number of LE Control frames transmitted by the SEB port.')
ibmSEPortLeCtrlFramesDiscSrcPortNotFwrd = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 1, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmSEPortLeCtrlFramesDiscSrcPortNotFwrd.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEPortLeCtrlFramesDiscSrcPortNotFwrd.setDescription('The total number of LE Control frames discarded because the SEB source port is not forwarding.')
ibmSEPortLeCtrlFramesDiscDestPortNotFwrd = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 1, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmSEPortLeCtrlFramesDiscDestPortNotFwrd.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEPortLeCtrlFramesDiscDestPortNotFwrd.setDescription('The total number of LE Control frames discarded because the SEB destination port is not forwarding.')
ibmSEBridgeConfigTable = MibTable((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 2), )
if mibBuilder.loadTexts: ibmSEBridgeConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEBridgeConfigTable.setDescription('A table that contains the Super ELAN Bridge (SEB) Configuration.')
ibmSEBridgeConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 2, 1), ).setIndexNames((0, "IBM-LAN-EMULATION-EXTENSION-MIB", "ibmSEBridgeId"))
if mibBuilder.loadTexts: ibmSEBridgeConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEBridgeConfigEntry.setDescription('The configuration information for each Super ELAN Bridge instance')
ibmSEAtmIfNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 2, 1, 1), IfIndexOrZero()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmSEAtmIfNumber.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEAtmIfNumber.setDescription(" The ATM interface number the Super ELAN (SE) bridging function is associated with. This number is used to determine the NETWORK ID. A SE Bridge (SEB) may span ATM adapters but they have to be on the same network, as specified by the Network ID. The specific requirement is that the LECs in the Super ELAN can establish a Data Direct VCC. The Network ID is an ATM configuration parameter that is required to allow Data Direct VCC's to be established. The value of this object must match an existing value in the ifTable. This object is set to zero when the ATM interface is not specified and the agent must determine itself which ATM interface it is to use. If the agent can not determine a default ATM interface an error should be returned by the agent.")
ibmSEEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmSEEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEEnabled.setDescription(' When enabled(1) the SE Bridge (SEB) will bridge frames to the ports defined in its bridging domain. When disabled(2) the SEB will not bridge frames.')
ibmSEName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 2, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmSEName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEName.setDescription(' This is a user provided name to associate with the SEB. The SEB name is independent of the ELANs names of the constituent ELANs of the SEB. No default, name must be specified.')
ibmSEFrameSize = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1516, 4544, 9234, 18190))).clone(namedValues=NamedValues(("en1516", 1516), ("tr4544", 4544), ("tr9234", 9234), ("tr18190", 18190))).clone('tr4544')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmSEFrameSize.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEFrameSize.setDescription(' Indicates the maximum SuperElan frame size. All ELANs in a single SEB must be set to the same maximum frame size. Valid Values 1516, 4544, 9234, 18190 Default for Ethernet 1516, the Default for Token Ring is 4544 Since ibmSEType defaults to Token Ring the MIB documents the ibmSEFrameSize DEFVAL to be 4544. However, if on row creation ibmSEType is set to Ethernet sebEN(1), and ibmSEFrameSize is not specified, the default value used by the agent should be 1516.')
ibmSEMacCacheAge = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 1000000)).clone(300)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmSEMacCacheAge.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEMacCacheAge.setDescription(' The number of seconds a learned MAC address remains in the data frame forwarding cache without revalidation.')
ibmSERDCacheAge = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 1000000)).clone(1800)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmSERDCacheAge.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSERDCacheAge.setDescription(' The number of seconds a learned route descriptor remains in the data frame forwarding cache without revalidation.')
ibmSEPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(32768)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmSEPriority.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEPriority.setDescription(' The SuperElan Bridge spanning tree priority. A lower value will increase the likelihood of a SuperElan bridge becoming the root. This value is appended to the SuperElan Spanning Tree MAC Address to form a SuperElan Bridge ID.')
ibmSEMaxAge = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(6, 40)).clone(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmSEMaxAge.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEMaxAge.setDescription(' The age at which the current Spanning Tree configuration is deemed too old. A value to small may cause the spanning tree to unnecessarily reconfigure. A value to large will increase the time it takes for the spanning tree to form once an outage is detected.')
ibmSEBridgeHelloTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmSEBridgeHelloTime.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEBridgeHelloTime.setDescription(' The interval of time in seconds between the generation of Spanning Tree configuration messages generate by the root. Lower values increase the spanning tree robustness, but increase network traffic overhead. Higher values decrease network control traffic but decrease spanning tree robustness.')
ibmSEBridgeForwardDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 2, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(4, 30)).clone(15)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmSEBridgeForwardDelay.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEBridgeForwardDelay.setDescription(' The delay in seconds that the SEB waits before transitioning to the next port state. The forward delay should be large enough to allow all Super ELAN bridges in the SuperELAN to disable ports in the new topology while the new spanning tree is being set up prior to forwarding data frames. Values too low might cause temporary loops in the SuperELAN, because not all bridges will complete the spanning tree updates. While values too large, lengthen network partitions after the spanning tree has converged, which causes data frame delays. The default value indicated that the bridge will begin forwarding frames 30 seconds after the spanning tree has converged: 15 seconds in listening state and 15 seconds in learning state.')
ibmSEBridgeAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 2, 1, 11), MacAddress().clone(hexValue="000000000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmSEBridgeAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEBridgeAddress.setDescription(' The Bridge MAC Address identifies the SuperELAN for the purposes of maintaining the SEB Spanning tree. If no value is configured, the SEB interface with the lowest MAC address will be used. This 6 octet Spanning Tree MAC Address is added to the value of the SuperELAN priority found in ibmSEPriority to create a SEB ID.')
ibmSEType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("sebEN", 1), ("sebTR", 2))).clone('sebTR')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmSEType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEType.setDescription(" This object indicates the type of SEB. sebEN(1) specifies a type of Ethernet, sebTR(2) specific's a type of Token Ring.")
ibmSEConfigRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 2, 1, 13), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmSEConfigRowStatus.setReference(' RFC 1903, Textual Conventions for version 2 of the Simple Network Management Protocol (SNMPv2).')
if mibBuilder.loadTexts: ibmSEConfigRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEConfigRowStatus.setDescription(' This object is used to create or delete entries (rows) in the SuperElan Bridge Configuration Table.')
ibmSEPortConfigTable = MibTable((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 3), )
if mibBuilder.loadTexts: ibmSEPortConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEPortConfigTable.setDescription('A table that contains SuperELAN Bridge Port Configuration.')
ibmSEPortConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 3, 1), ).setIndexNames((0, "IBM-LAN-EMULATION-EXTENSION-MIB", "ibmSEBridgeId"), (0, "IBM-LAN-EMULATION-EXTENSION-MIB", "ibmSEPortNum"))
if mibBuilder.loadTexts: ibmSEPortConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEPortConfigEntry.setDescription('The configuration information for each SuperELAN Bridge Port')
ibmSEPortIfNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmSEPortIfNumber.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEPortIfNumber.setDescription(' The interface number associated with this port.')
ibmSEPortElanName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 3, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmSEPortElanName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEPortElanName.setDescription(' The ELAN Name in which the SuperElan Bridge LEC participates. If the ELAN Name matches that of a LES/BUS on the same node, a SEB-LEC interface is automatically added to the configuration, and the SEB-LEC parameters needed to join the ELAN are read from the local ELAN configuration. If the ELAN name does not match that of a LES/BUS on the same node, the SEB-LEC must be configured to join the specified ELAN. No Default value a name must be specified.')
ibmSEPortRemoteElan = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2))).clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmSEPortRemoteElan.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEPortRemoteElan.setDescription(' This object indicates whether or not the Super ELAN LE Services (LES/BUS) for the ELAN specified by ibmSEPortElanName are local to the same node as the port or not. If false(2) the LE Services are local, if true(1) the LE Services are remote (not resident at the same node as the SuperElan). Default is local ELAN.')
ibmSEPortEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmSEPortEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEPortEnabled.setDescription(' When enabled(1) the SuperELAN will bridge frames through this SEB port. When disabled(2) the SuperELAN will not bridge frames through this port.')
ibmSEPortPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 3, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(128)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmSEPortPriority.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEPortPriority.setDescription(' This value influences which port is used when two or more ports are connected to the same network segment. This situation may cause a routing loop and a the priority provides a port selection method. A lower value represents a higher priority. ?Is Define ports and interfaces as bit 16 going to be a problem.? Put in to agent capabilities and check in agent. ')
ibmSEPortRootCost = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 3, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(32768)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmSEPortRootCost.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEPortRootCost.setDescription(' The cost added to the root path cost in the Spanning Tree configuration message received on this port in order to determine the path cost to get to the root bridge through this port. Setting this value small increases the probability that this port will be close to the root bridge, and thus asked to carry more broadcast and unknown unicast traffic.')
ibmSEPortRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 3, 1, 7), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmSEPortRowStatus.setReference(' RFC 1903, Textual Conventions for version 2 of the Simple Network Management Protocol (SNMPv2).')
if mibBuilder.loadTexts: ibmSEPortRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEPortRowStatus.setDescription(' This object is used to create or delete entries (rows) in the SuperElan Bridge Port Configuration Table.')
ibmSEBridgeTable = MibTable((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 4), )
if mibBuilder.loadTexts: ibmSEBridgeTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEBridgeTable.setDescription('A table that contains bridge information for the SEB.')
ibmSEBridgeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 4, 1), ).setIndexNames((0, "IBM-LAN-EMULATION-EXTENSION-MIB", "ibmSEBridgeId"))
if mibBuilder.loadTexts: ibmSEBridgeEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEBridgeEntry.setDescription('Each entry (row) contains additional SEB pertaining to a specific SEB instance.')
ibmSENumPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmSENumPorts.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSENumPorts.setDescription(' The number of ports defined for this SEB. This number can be used to determine the next available port number for row creation in any of the SEB Port Tables. Of course the next available index is determined by adding one to the number of ports defined.')
ibmSEProtocolSpecification = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("unknown", 1), ("tbSra", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmSEProtocolSpecification.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEProtocolSpecification.setDescription(" The protocol type used for this SEB. Currently only Transparent Bridging with Source Route Awareness (tbSra(2)) is the only defined protocol type for SEB's.")
ibmSETimeSinceTopologyChange = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 4, 1, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmSETimeSinceTopologyChange.setReference('IEEE 802.1D-1990: Section 6.8.1.1.3')
if mibBuilder.loadTexts: ibmSETimeSinceTopologyChange.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSETimeSinceTopologyChange.setDescription('The time (in hundredths of a second) since the last time a topology change was detected by the bridge entity.')
ibmSETopChanges = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 4, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmSETopChanges.setReference('IEEE 802.1D-1990: Section 6.8.1.1.3')
if mibBuilder.loadTexts: ibmSETopChanges.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSETopChanges.setDescription('The total number of topology changes detected by this bridge since the management entity was last reset or initialized.')
ibmSEDesignatedRoot = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 4, 1, 5), BridgeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmSEDesignatedRoot.setReference('IEEE 802.1D-1990: Section 4.5.3.1')
if mibBuilder.loadTexts: ibmSEDesignatedRoot.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEDesignatedRoot.setDescription('The bridge identifier of the root of the spanning tree as determined by the Spanning Tree Protocol as executed by this node. This value is used as the Root Identifier parameter in all Configuration Bridge PDUs originated by this node.')
ibmSERootCost = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 4, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmSERootCost.setReference('IEEE 802.1D-1990: Section 4.5.3.2')
if mibBuilder.loadTexts: ibmSERootCost.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSERootCost.setDescription('The cost of the path to the root as seen from this bridge.')
ibmSERootPort = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 4, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmSERootPort.setReference('IEEE 802.1D-1990: Section 4.5.3.3')
if mibBuilder.loadTexts: ibmSERootPort.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSERootPort.setDescription('The port number of the port which offers the lowest cost path from this bridge to the root bridge.')
ibmSEBridgeMaxAge = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 4, 1, 8), Timeout().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmSEBridgeMaxAge.setReference('IEEE 802.1D-1990: Section 4.5.3.4')
if mibBuilder.loadTexts: ibmSEBridgeMaxAge.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEBridgeMaxAge.setDescription('The maximum age of Spanning Tree Protocol information learned from the network on any port before it is discarded, in units of hundredths of a second. This is the actual value that this bridge is currently using.')
ibmSEHelloTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 4, 1, 9), Timeout().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmSEHelloTime.setReference('IEEE 802.1D-1990: Section 4.5.3.5')
if mibBuilder.loadTexts: ibmSEHelloTime.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEHelloTime.setDescription('The amount of time between the transmission of Configuration bridge PDUs by this node on any port when it is the root of the spanning tree or trying to become so, in units of hundredths of a second. This is the actual value that this bridge is currently using.')
ibmSEHoldTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 4, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmSEHoldTime.setReference('IEEE 802.1D-1990: Section 4.5.3.14')
if mibBuilder.loadTexts: ibmSEHoldTime.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEHoldTime.setDescription('This time value determines the interval length during which no more than two Configuration bridge PDUs shall be transmitted by this node, in units of hundredths of a second.')
ibmSEForwardDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 4, 1, 11), Timeout().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmSEForwardDelay.setReference('IEEE 802.1D-1990: Section 4.5.3.6')
if mibBuilder.loadTexts: ibmSEForwardDelay.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEForwardDelay.setDescription('This time value, measured in units of hundredths of a second, controls how fast a port changes its spanning state when moving towards the Forwarding state. The value determines how long the port stays in each of the Listening and Learning states, which precede the Forwarding state. This value is also used, when a topology change has been detected and is underway, to age all dynamic entries in the Forwarding Database. [Note that this value is the one that this bridge is currently using, in contrast to ibmSEBridgeForwardDelay which is the value that this bridge and all others would start using if/when this bridge were to become the root.]')
ibmSEMacLearnedEntryDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 4, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmSEMacLearnedEntryDiscards.setReference('IEEE 802.1D-1990: Section 6.7.1.1.3')
if mibBuilder.loadTexts: ibmSEMacLearnedEntryDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEMacLearnedEntryDiscards.setDescription('The total number of Mac Forwarding Database entries, which have been or would have been learnt, but have been discarded due to a lack of space to store them in the Forwarding Database. If this counter is increasing, it indicates that the Forwarding Database is regularly becoming full (a condition which has unpleasant performance effects on the subnetwork). If this counter has a significant value but is not presently increasing, it indicates that the problem has been occurring but is not persistent.')
ibmSERDLearnedEntryDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 4, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmSERDLearnedEntryDiscards.setReference('IEEE 802.1D-1990: Section 6.7.1.1.3')
if mibBuilder.loadTexts: ibmSERDLearnedEntryDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSERDLearnedEntryDiscards.setDescription('The total number of Route Descriptor Forwarding Database entries, which have been or would have been learnt, but have been discarded due to a lack of space to store them in the Forwarding Database. If this counter is increasing, it indicates that the Forwarding Database is regularly becoming full (a condition which has unpleasant performance effects on the subnetwork). If this counter has a significant value but is not presently increasing, it indicates that the problem has been occurring but is not persistent.')
ibmSEStpPortTable = MibTable((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 5), )
if mibBuilder.loadTexts: ibmSEStpPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEStpPortTable.setDescription('A table that contains port-specific information and Spanning Tree Protocol information for each SEB Port.')
ibmSEStpPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 5, 1), ).setIndexNames((0, "IBM-LAN-EMULATION-EXTENSION-MIB", "ibmSEBridgeId"), (0, "IBM-LAN-EMULATION-EXTENSION-MIB", "ibmSEPortNum"))
if mibBuilder.loadTexts: ibmSEStpPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEStpPortEntry.setDescription('A list of SEB information maintained for each SEB port.')
ibmSEStpPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 5, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("forwarding", 1), ("learning", 2), ("listening", 3), ("blocked", 4), ("configured", 5), ("netdown", 6), ("configuring", 7), ("unknown", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmSEStpPortState.setReference('IEEE 802.1D-1990: Section 4.5.5.2')
if mibBuilder.loadTexts: ibmSEStpPortState.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEStpPortState.setDescription("The port's current state as defined by application of the Spanning Tree Protocol. This state controls what action a port takes on reception of a frame. If the bridge has detected a port that is malfunctioning it will place that port into the broken(6) state. For ports which are disabled (see ibmSEPortEnable), this object will have a value of disabled(1). forwarding(1) - port is in forwarding state learning(2) - port is in learning state listening(3) - port is in listening state blocked(4) - this port is blocked by spanning tree configured(5) - this port is waiting for spanning tree netdown(6) - this ports network interface is down configuring(7) - this port is loading LEC configuration unknown(8) - this port is in some unknown state")
ibmSEStpPortDesignatedRoot = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 5, 1, 2), BridgeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmSEStpPortDesignatedRoot.setReference('IEEE 802.1D-1990: Section 4.5.5.4')
if mibBuilder.loadTexts: ibmSEStpPortDesignatedRoot.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEStpPortDesignatedRoot.setDescription('The unique Bridge Identifier of the Bridge recorded as the Root in the Configuration BPDUs transmitted by the Designated Bridge for the segment to which the port is attached.')
ibmSEStpPortDesignatedCost = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 5, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmSEStpPortDesignatedCost.setReference('IEEE 802.1D-1990: Section 4.5.5.5')
if mibBuilder.loadTexts: ibmSEStpPortDesignatedCost.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEStpPortDesignatedCost.setDescription('The path cost of the Designated Port of the segment connected to this port. This value is compared to the Root Path Cost field in received bridge PDUs.')
ibmSEStpPortDesignatedBridge = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 5, 1, 4), BridgeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmSEStpPortDesignatedBridge.setReference('IEEE 802.1D-1990: Section 4.5.5.6')
if mibBuilder.loadTexts: ibmSEStpPortDesignatedBridge.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEStpPortDesignatedBridge.setDescription("The Bridge Identifier of the bridge which this port considers to be the Designated Bridge for this port's segment.")
ibmSEStpPortDesignatedPort = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 5, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmSEStpPortDesignatedPort.setReference('IEEE 802.1D-1990: Section 4.5.5.7')
if mibBuilder.loadTexts: ibmSEStpPortDesignatedPort.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEStpPortDesignatedPort.setDescription("The Port Identifier of the port on the Designated Bridge for this port's segment.")
ibmSEStpPortForwardTransitions = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 5, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmSEStpPortForwardTransitions.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEStpPortForwardTransitions.setDescription('The number of times this port has transitioned from the Learning state to the Forwarding state.')
ibmSEPortMaxInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 5, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmSEPortMaxInfo.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEPortMaxInfo.setDescription('The maximum size of the INFO (non-MAC) field that this port will receive or transmit.')
ibmSEPortDataStatisticsTable = MibTable((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 8), )
if mibBuilder.loadTexts: ibmSEPortDataStatisticsTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEPortDataStatisticsTable.setDescription('This table contains statistics about LAN Emulation Data Frame Statistics for Super ELAN Bridge ports.')
ibmSEPortDataStatisticsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 8, 1), ).setIndexNames((0, "IBM-LAN-EMULATION-EXTENSION-MIB", "ibmSEBridgeId"), (0, "IBM-LAN-EMULATION-EXTENSION-MIB", "ibmSEPortNum"))
if mibBuilder.loadTexts: ibmSEPortDataStatisticsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEPortDataStatisticsEntry.setDescription('A list of LE Data Frame statistical information for each SEB port')
ibmSEPortInFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 8, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmSEPortInFrames.setReference('IEEE 802.1D-1990: Section 6.6.1.1.3')
if mibBuilder.loadTexts: ibmSEPortInFrames.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEPortInFrames.setDescription('The number of frames that have been received by this port from its segment. Note that a frame received on the interface corresponding to this port is only counted by this object if and only if it is for a protocol being processed by the local bridging function, including bridge management frames.')
ibmSEPortOutFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 8, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmSEPortOutFrames.setReference('IEEE 802.1D-1990: Section 6.6.1.1.3')
if mibBuilder.loadTexts: ibmSEPortOutFrames.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEPortOutFrames.setDescription('The number of frames that have been transmitted by this port to its segment. Note that a frame transmitted on the interface corresponding to this port is only counted by this object if and only if it is for a protocol being processed by the local bridging function, including bridge management frames.')
ibmSEPortRoutedInFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 8, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmSEPortRoutedInFrames.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEPortRoutedInFrames.setDescription(' Frames received on this port that were routed, rather than, or in addition to, bridged.')
ibmSEPortBpduFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 8, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmSEPortBpduFrames.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEPortBpduFrames.setDescription(' Count of SE BPDU Frames')
ibmSEPortInDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 8, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmSEPortInDiscards.setReference('IEEE 802.1D-1990: Section 6.6.1.1.3')
if mibBuilder.loadTexts: ibmSEPortInDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEPortInDiscards.setDescription('Count of valid frames received which were discarded (i.e., filtered) by the Forwarding Process.')
ibmSEPortDropSrcAddrFilters = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 8, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmSEPortDropSrcAddrFilters.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEPortDropSrcAddrFilters.setDescription(' Frames dropped due to Source Address filtering')
ibmSEPortDropDestAddrFilters = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 8, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmSEPortDropDestAddrFilters.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEPortDropDestAddrFilters.setDescription(' Frames dropped due to destination address filtering. These are frames to destinations on the same LAN that they arrived on, or otherwise filtered by the filtering database of the bridge.')
ibmSEPortDropProtocolFilters = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 8, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmSEPortDropProtocolFilters.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEPortDropProtocolFilters.setDescription(' Frames dropped due to user filtering of particular protocol identifiers.')
ibmSEPortDropSrcNotFwds = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 8, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmSEPortDropSrcNotFwds.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEPortDropSrcNotFwds.setDescription(' Frames received on this port when it was not in forwarding state (mostly in learning state).')
ibmSEPortDropDestNotFwds = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 8, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmSEPortDropDestNotFwds.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEPortDropDestNotFwds.setDescription(" Frames not sent because output port not in forwarding state. Don't know which port they tag on yet.")
ibmSEPortDropInputOverflows = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 8, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmSEPortDropInputOverflows.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEPortDropInputOverflows.setDescription(' Frames dropped due to input queue overflow.')
ibmSEPortDropBpduOverflows = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 8, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmSEPortDropBpduOverflows.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEPortDropBpduOverflows.setDescription(" BPDU's dropped due to BPDU input queue overflow.")
ibmSEPortDropSrOverflows = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 8, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmSEPortDropSrOverflows.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEPortDropSrOverflows.setDescription(' Source Route Frames dropped due to SR input queue overflow.')
ibmSEPortRecNoBuffFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 8, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmSEPortRecNoBuffFailures.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEPortRecNoBuffFailures.setDescription(' Receive frames discarded due to no buffer available.')
ibmSEPortTransmitFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 8, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmSEPortTransmitFailures.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEPortTransmitFailures.setDescription(' Frame Count of transmit failures.')
ibmSEPortToBigFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 8, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmSEPortToBigFailures.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEPortToBigFailures.setDescription(' Count of frames to big to sent on this port.')
ibmSEPortLanIdFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 8, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmSEPortLanIdFailures.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEPortLanIdFailures.setDescription(' Count of frames discarded due to mismatch in the LAN ID.')
ibmSEPortStpLanIdFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 1, 8, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmSEPortStpLanIdFailures.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSEPortStpLanIdFailures.setDescription(' Count of frames discarded due to duplicate LAN ID or spanning tree error.')
ibmBbcmConfigNextId = MibScalar((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 214748364))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmBbcmConfigNextId.setStatus('obsolete')
if mibBuilder.loadTexts: ibmBbcmConfigNextId.setDescription('The next available index in the ibmBbcmConfigTable. The value of this object can be used as the index by the network manager to create an entry in the table. This object is no longer required since the ibmBbcmConfigIndex is now specified as the superElanID.')
ibmBbcmConfigTable = MibTable((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 2, 1, 2), )
if mibBuilder.loadTexts: ibmBbcmConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmBbcmConfigTable.setDescription(' This table contains configuration values for the Bridging Broadcast Manager (BBCM).')
ibmBbcmConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 2, 1, 2, 1), ).setIndexNames((0, "IBM-LAN-EMULATION-EXTENSION-MIB", "ibmBbcmConfigIndex"))
if mibBuilder.loadTexts: ibmBbcmConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmBbcmConfigEntry.setDescription(' Each entry of the table represents a configured instance of the BBCM.')
ibmBbcmConfigIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 2, 1, 2, 1, 1), IbmSEBridgeID())
if mibBuilder.loadTexts: ibmBbcmConfigIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmBbcmConfigIndex.setDescription(' A value which uniquely identifies a conceptual row of the BBCM Configuration Table. Since BBCM is a bridge based function, each row of this table identifies a unique bridge instance.')
ibmBbcmName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 2, 1, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmBbcmName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmBbcmName.setDescription(' This is the name associated with the bridge instance. It is either the Super Elan Bridge name or the name assigned to the base bridge.')
ibmBbcmConfigRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 2, 1, 2, 1, 3), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmBbcmConfigRowStatus.setReference(' RFC 1903, Textual Conventions for version 2 of the Simple Network Management Protocol (SNMPv2).')
if mibBuilder.loadTexts: ibmBbcmConfigRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ibmBbcmConfigRowStatus.setDescription(' This object is used to create or delete entries in the ibmBbcmConfigTable.')
ibmBbcmProtocolConfigTable = MibTable((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 2, 1, 3), )
if mibBuilder.loadTexts: ibmBbcmProtocolConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmBbcmProtocolConfigTable.setDescription(' Each entry of the table represents a configured instance of a specific protocol for a particular BBCM instance.')
ibmBbcmProtocolConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 2, 1, 3, 1), ).setIndexNames((0, "IBM-LAN-EMULATION-EXTENSION-MIB", "ibmBbcmProtocolType"), (0, "IBM-LAN-EMULATION-EXTENSION-MIB", "ibmBbcmConfigIndex"))
if mibBuilder.loadTexts: ibmBbcmProtocolConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmBbcmProtocolConfigEntry.setDescription(' Each entry of the table represents a configuration information for a specific protocol supported by a specific BBCM.')
ibmBbcmProtocolType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 2, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("reserved", 1), ("ip", 2))))
if mibBuilder.loadTexts: ibmBbcmProtocolType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmBbcmProtocolType.setDescription(' BBCM Protocols Supported. For ease in implementation the enumerated types for ibmBbcmProtocolType and ibmBbcmStatProtocolType are equivalent. Note: 1 is reserved so ibmBbcmStatProtocolType of 1 can be all. This allows enumeration values to match between ibmBbcmProtocolType and ibmBbcmStatProtocolType.')
ibmBbcmProtocolOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 2, 1, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("up", 2), ("down", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmBbcmProtocolOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ibmBbcmProtocolOperStatus.setDescription(' The current BBCM Status Note for this implementation other is defined only to be consistent with standard LE server MIBs, it has no meaning for the definition.')
ibmBbcmProtocolAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 2, 1, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("up", 2), ("down", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmBbcmProtocolAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ibmBbcmProtocolAdminStatus.setDescription(' The desired state of the BBCM as prescribed by the operator. The actions of the agent will, if at all possible, eventually result in the desired state being reflected in the ibmBbcmProtocolOperStatus.')
ibmBbcmProtocolCacheAge = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 2, 1, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 214748364))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmBbcmProtocolCacheAge.setStatus('mandatory')
if mibBuilder.loadTexts: ibmBbcmProtocolCacheAge.setDescription(' The number of minutes a protocol is cached by BBCM before being added due to inactivity.')
ibmBbcmStatTable = MibTable((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 2, 2, 1), )
if mibBuilder.loadTexts: ibmBbcmStatTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmBbcmStatTable.setDescription(' This table contains activity statistics on a BBCM basis.')
ibmBbcmStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 2, 2, 1, 1), ).setIndexNames((0, "IBM-LAN-EMULATION-EXTENSION-MIB", "ibmBbcmStatProtocolType"), (0, "IBM-LAN-EMULATION-EXTENSION-MIB", "ibmBbcmConfigIndex"))
if mibBuilder.loadTexts: ibmBbcmStatEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmBbcmStatEntry.setDescription(' Each entry of the tables represents a BBCM protocol instance.')
ibmBbcmStatProtocolType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 2, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("allprotocols", 1), ("ip", 2))))
if mibBuilder.loadTexts: ibmBbcmStatProtocolType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmBbcmStatProtocolType.setDescription(' BBCM Protocols Supported. For ease in implementation the enumerated types for ibmBbcmProtocolType and ibmBbcmStatProtocolType are equivalent. When the protocol type is 1 (allprotocols) the response contains the total count for all protocols supported by this BBCM.')
ibmBbcmStatInReceives = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 2, 2, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmBbcmStatInReceives.setStatus('mandatory')
if mibBuilder.loadTexts: ibmBbcmStatInReceives.setDescription(' Number of packets processed by BBCM for this protocol')
ibmBbcmStatInOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 2, 2, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmBbcmStatInOctets.setStatus('mandatory')
if mibBuilder.loadTexts: ibmBbcmStatInOctets.setDescription(' Number of Octets processed by BBCM for this protocol. This count is of all octets seen, including control information like headers.')
ibmBbcmStatOutManaged = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 2, 2, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmBbcmStatOutManaged.setStatus('mandatory')
if mibBuilder.loadTexts: ibmBbcmStatOutManaged.setDescription(' Number of packets transformed by BBCM from broadcast to unicast for this protocol.')
ibmBbcmStatOutManagedOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 2, 2, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmBbcmStatOutManagedOctets.setStatus('mandatory')
if mibBuilder.loadTexts: ibmBbcmStatOutManagedOctets.setDescription(' Number of Octets transformed by BBCM from broadcast to unicast for this protocol. This count is of all octets seen, including control information like headers.')
ibmBbcmStatOutNotManaged = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 2, 2, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmBbcmStatOutNotManaged.setStatus('mandatory')
if mibBuilder.loadTexts: ibmBbcmStatOutNotManaged.setDescription(' The number of packets seen by BBCM that were left as they were originally broadcast.')
ibmBbcmStatOutNotManagedOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 2, 2, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmBbcmStatOutNotManagedOctets.setStatus('mandatory')
if mibBuilder.loadTexts: ibmBbcmStatOutNotManagedOctets.setDescription(' The number of octets seen by BBCM that were left as they were originally broadcast. This count is of all octets seen, including control information like headers.')
ibmBbcmStatOutFiltered = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 2, 2, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmBbcmStatOutFiltered.setStatus('mandatory')
if mibBuilder.loadTexts: ibmBbcmStatOutFiltered.setDescription(' Number of Packets Filtered by BBCM.')
ibmBbcmStatOutFilteredOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 2, 2, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmBbcmStatOutFilteredOctets.setStatus('mandatory')
if mibBuilder.loadTexts: ibmBbcmStatOutFilteredOctets.setDescription(' Number of Octets Filtered by BBCM.')
ibmVlanConfIndexNextID = MibScalar((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 3, 1, 1, 1), IbmVlanIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmVlanConfIndexNextID.setStatus('mandatory')
if mibBuilder.loadTexts: ibmVlanConfIndexNextID.setDescription(' This is the next available Vlan Index for this agent. If should be used when creating rows in the Vlan tables indexed by ibmVlanConfIndex.')
ibmVlanTopologyChange = MibScalar((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 3, 1, 1, 2), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmVlanTopologyChange.setStatus('mandatory')
if mibBuilder.loadTexts: ibmVlanTopologyChange.setDescription(' This is the time stamp at which time the last VLAN Topology Change occurred. This object can be used to monitor the change status of the VLANs controlled by this agent. A change is defined whenever a VLAN has been added, deleted or changes configuration. A change is also defined when a port is discovered or is aged out.')
ibmVlanMaxPortMap = MibScalar((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 3, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmVlanMaxPortMap.setStatus('mandatory')
if mibBuilder.loadTexts: ibmVlanMaxPortMap.setDescription(' This is the maximum number of octets this agent supports for representing ports in the the Port Map objects which use the textual convention IbmVlanPortMap.')
ibmVlanMaxUDSWMaskFilter = MibScalar((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 3, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmVlanMaxUDSWMaskFilter.setStatus('mandatory')
if mibBuilder.loadTexts: ibmVlanMaxUDSWMaskFilter.setDescription(' This is the maximum number of octets this agent supports for ibmVlanUDSWMask or ibmVlanUDSWFilter. The Mask and Filter must contain the same number of octets.')
ibmVlanConfTable = MibTable((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 3, 2, 1, 1), )
if mibBuilder.loadTexts: ibmVlanConfTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmVlanConfTable.setDescription(' The layout of the VLAN MIB tables relies on common information and VLAN type specific information. The ibmVlanConfTable is the base table. Columns are added to this table depending on the VLAN type, for example ibmVlanIPConfTable is for IP VLANs, ibmVlanIPXConfTable is for IPX VlANS, ibmVlanUDSWConfTable is for User Defined Sliding Window based VLANs, and ibmVlanMacConfTable is for MAC address defined VLANs. Associated with the extended configuration table is a base status table, ibmVlanStatusTable. This table covers generic status and the USDW and MAC VLAN status requirements are currently defined. Specific status table additions are provided by the ibmVlanIpStatusTable for IP criteria.')
ibmVlanConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 3, 2, 1, 1, 1), ).setIndexNames((0, "IBM-LAN-EMULATION-EXTENSION-MIB", "ibmVlanConfIndex"))
if mibBuilder.loadTexts: ibmVlanConfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmVlanConfEntry.setDescription(' Each entry of the ibmVlanConfTable provides configuration information pertaining to a specific instance of a VLAN.')
ibmVlanConfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 3, 2, 1, 1, 1, 1), IbmVlanIndex())
if mibBuilder.loadTexts: ibmVlanConfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmVlanConfIndex.setDescription(' An index assigned by the agent which uniquely identifies an instance of a VLAN. This objects value is NOT guaranteed to be the same value across agent restarts.')
ibmVlanConfBridgeId = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 3, 2, 1, 1, 1, 2), IbmSEBridgeID()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmVlanConfBridgeId.setStatus('mandatory')
if mibBuilder.loadTexts: ibmVlanConfBridgeId.setDescription('The identifier of the Base Bridge or Super ELAN Bridge which this VLAN is defined as an additional filter for.')
ibmVlanConfType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 3, 2, 1, 1, 1, 3), IbmVlanType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmVlanConfType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmVlanConfType.setDescription(' The type of VLAN.')
ibmVlanConfAgingTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 3, 2, 1, 1, 1, 4), Unsigned32().clone(5000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmVlanConfAgingTimer.setStatus('mandatory')
if mibBuilder.loadTexts: ibmVlanConfAgingTimer.setDescription(' The amount of time (in minutes) an auto-detect port will remain in the forwarding domain of the VLAN in the absence of traffic from that VLAN. A value of zero means forever.')
ibmVlanConfForwardingPortMap = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 3, 2, 1, 1, 1, 5), IbmVlanPortMap()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmVlanConfForwardingPortMap.setStatus('mandatory')
if mibBuilder.loadTexts: ibmVlanConfForwardingPortMap.setDescription(' Defines which ports are in forwarding state for this VLAN. The VLAN port is in forwarding state if one of the following is true: The port has been statically included by setting the corresponding port in ibmVlanIncludedPortMap. The port is not excluded, corresponding port in ibmVlanExcludedPortMap is zero, and the port has seen VLAN traffic in the current age out period, as defined by ibmVlanConfAgingTimer.')
ibmVlanConfIncludedPortMap = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 3, 2, 1, 1, 1, 6), IbmVlanPortMap().clone(hexValue="0")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmVlanConfIncludedPortMap.setStatus('mandatory')
if mibBuilder.loadTexts: ibmVlanConfIncludedPortMap.setDescription(' Each of the bits in the port map represents a bridge port and defines which ports are automatically and permanently included from the forwarding domain of the VLAN. A value of 1 for the port means it is included. A value of 0 means the port has to be discovered (port traffic seen) to be included in the VLAN.')
ibmVlanConfExcludedPortMap = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 3, 2, 1, 1, 1, 7), IbmVlanPortMap().clone(hexValue="0")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmVlanConfExcludedPortMap.setStatus('mandatory')
if mibBuilder.loadTexts: ibmVlanConfExcludedPortMap.setDescription(' Each of the bits in the port map represents a bridge port and defines which ports are automatically and permanently excluded from the forwarding domain of the VLAN. A value of 1 for the port means it is excluded from the VLAN even if traffic for this VLAN type is seen on this port. A value of 0 means the port can be discovered.')
ibmVlanConfName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 3, 2, 1, 1, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmVlanConfName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmVlanConfName.setDescription(' A node unique user defined name for the VLAN. This name must be unique across all bridge instances at that node (agent).')
ibmVlanConfRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 3, 2, 1, 1, 1, 9), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmVlanConfRowStatus.setReference(' RFC 1903, Textual Conventions for version 2 of the Simple Network Management Protocol (SNMPv2).')
if mibBuilder.loadTexts: ibmVlanConfRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ibmVlanConfRowStatus.setDescription(' This object is used to create or delete entries (rows) in the VLAN Configuration Table.')
ibmVlanIpConfTable = MibTable((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 3, 2, 1, 2), )
if mibBuilder.loadTexts: ibmVlanIpConfTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmVlanIpConfTable.setDescription(' The IBM VLAN Configuration Table provides the definitions required to configure an IBM IP or IP Multicast Protocol Virtual LAN (PVLAN) This table defines the filters for the IP or IP Multicast PVLAN Entries in this table must be provided when the corresponding row of the ibmVlanConfTable is being created.')
ibmVlanIpConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 3, 2, 1, 2, 1), ).setIndexNames((0, "IBM-LAN-EMULATION-EXTENSION-MIB", "ibmVlanConfIndex"))
if mibBuilder.loadTexts: ibmVlanIpConfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmVlanIpConfEntry.setDescription(' Each entry of the ibmVlanIpConfTable provides configuration information pertaining to a specific instance of an IP or IP Multicast PVLAN.')
ibmVlanIpNetworkAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 3, 2, 1, 2, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmVlanIpNetworkAddr.setStatus('mandatory')
if mibBuilder.loadTexts: ibmVlanIpNetworkAddr.setDescription(' The IP or IP Multicast address of the local forwarding component used to route or bridge traffic for this VLAN. No default value. A default value must be specified when creating an IP or IP Multicast VLAN.')
ibmVlanIpNetworkMask = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 3, 2, 1, 2, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmVlanIpNetworkMask.setStatus('mandatory')
if mibBuilder.loadTexts: ibmVlanIpNetworkMask.setDescription(" The IP address mask used to 'AND' against the IP address in a received IP frame. The result of the 'AND' operation is compared to the value given in the ibmVlanIPNetworkAddr in order to determine if the frame belongs to the VLAN and should be forwarded. There is no default value. A mask must be specified when creating an IP PVLAN entry in the ibmVlanConfTable. Note: if the ibmVlanConfType is IP Multicast ibmVlanIpNetworkMask the ibmVlanIpNetworkMask is not used. A value 0.0.0.0 should be returned by the agent.")
ibmVlanIpCutThruFromHere = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 3, 2, 1, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmVlanIpCutThruFromHere.setStatus('mandatory')
if mibBuilder.loadTexts: ibmVlanIpCutThruFromHere.setDescription(' Specifies whether IP cut through communications originating from this subnet are enabled.')
ibmVlanIpCutThruToHere = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 3, 2, 1, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmVlanIpCutThruToHere.setStatus('mandatory')
if mibBuilder.loadTexts: ibmVlanIpCutThruToHere.setDescription(' Specifies whether IP cut through communications destined for this subnet are enabled.')
ibmVlanIpxConfTable = MibTable((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 3, 2, 1, 3), )
if mibBuilder.loadTexts: ibmVlanIpxConfTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmVlanIpxConfTable.setDescription(' The IBM IPX VLAN Configuration Table provides the definitions required to configure an IBM IPX Protocol Virtual LAN (PVLAN). This table defines the filters for the IPX PVLAN. Entries in this table must be provided when the corresponding row of the ibmVlanConfTable is being created.')
ibmVlanIpxConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 3, 2, 1, 3, 1), ).setIndexNames((0, "IBM-LAN-EMULATION-EXTENSION-MIB", "ibmVlanConfIndex"))
if mibBuilder.loadTexts: ibmVlanIpxConfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmVlanIpxConfEntry.setDescription(' Each entry of the ibmVlanIpxConfTable provides configuration information pertaining to a specific instance of an IPX PVLAN.')
ibmVlanIpxNetworkAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 3, 2, 1, 3, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmVlanIpxNetworkAddr.setStatus('mandatory')
if mibBuilder.loadTexts: ibmVlanIpxNetworkAddr.setDescription(' This is the VLANs IPX Network Address. No Default Value, one must be specified when creating an IPX PVLAN in the ibmVlanConfTable.')
ibmVlanUDSWConfTable = MibTable((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 3, 2, 1, 4), )
if mibBuilder.loadTexts: ibmVlanUDSWConfTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmVlanUDSWConfTable.setDescription(" This table defines a 'sliding window' mechanism for the definition of 'policy' or 'user' defined VLANs. The mechanism is based on a set of mask and filter fields that when compared to traffic data permit forwarding decisions for the packet to be made for a VLAN. The window may be moved or slide by defining the appropriate offset type and offset values for the mask and filter object fields. Care must be taken to ensure the consistent configuration of VLAN policies. Once a VLAN entry has been made in the table if a change is made to any of the variables in that row for the VLAN then all other entries in other nodes associated with the VLAN must be updated in a corresponding manner! This table is an auxiliary extension to the base VLAN configuration table defined in ibmVlanConfTable. See that table for additional Vlan details. ")
ibmVlanUDSWConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 3, 2, 1, 4, 1), ).setIndexNames((0, "IBM-LAN-EMULATION-EXTENSION-MIB", "ibmVlanConfIndex"))
if mibBuilder.loadTexts: ibmVlanUDSWConfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmVlanUDSWConfEntry.setDescription(' Each entry of the ibmVlanUDSWConfTable provides configuration information pertaining to a specific instance of an UDSW VLAN. Entries in this table must be provided when the corresponding row of the ibmVlanConfTable is being created.')
ibmVlanUDSWOffsetType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 3, 2, 1, 4, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("udswMacOffset", 1), ("udswInfoOffset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmVlanUDSWOffsetType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmVlanUDSWOffsetType.setDescription(' This object specifies the base location in the traffic frame where the ibmVlanUDSWOffset will be used to start the comparison with the ibmVlanUDSWFilter value to determine if this frame is in a Sliding Window Vlan. Two starting location modes are predefined for LAN Emulation VLANs. udswMacOffset indicates that the starting location is the first byte of the MAC destination address in the traffic frame. This mode may be used for VLAN filtering on MAC addresses, for both Token Ring traffic and Ethernet traffic. The ibmVlanMacConfTable however should be used to define source MAC address based VLANs. This mode may also be used for VLAN filtering on protocol and address information or for other user specified information found in a portion of the LLC information field when source routed Token Ring traffic is NOT the traffic source (due to the presence of the variable size Routing Information Field). udswInfoOffset is a generic way of indicating that the starting location is at the first byte of the LLC information field. This mode may be used for VLAN filtering on protocol and address information or for other user specified information found in a portion of the LLC information field. For source routed Token Ring, this location is not static within the frame since the Routing Information Field (RIF) is of variable length depending on LAN segments in the route. Specifying this mode permits the offset to begin relative to the end of the last byte of the RIF. There is no default value for this entry. The offset type must be defined when creating a user defined sliding window VLAN in the ibmVlanConfTable.')
ibmVlanUDSWOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 3, 2, 1, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmVlanUDSWOffset.setStatus('mandatory')
if mibBuilder.loadTexts: ibmVlanUDSWOffset.setDescription(" This object determines the starting location in the traffic frame that will be used in the comparison with the ibmVlanUDSWFilter value to determine if this frame is in a Sliding Window Vlan. It is specified as a value offset indicating the number of octets from the base location determined by the mode selected in the ibmVlanUSDWOffsetType. udswMacOffset mode indicates that the starting location for the compare is ibmVlanUDSWOffset octets after the the first byte of the MAC destination address. udswInfoOffset mode indicates that the starting location is ibmVlanUDSWOffset octets after the start of the frame's information field. There is no default value and this offset selection mode must be defined when creating a UDSW VLAN in the ibmVlanConfTable.")
ibmVlanUDSWMask = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 3, 2, 1, 4, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 256))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmVlanUDSWMask.setStatus('mandatory')
if mibBuilder.loadTexts: ibmVlanUDSWMask.setDescription(" This object determines the size and bit pattern that is compared to the traffic frame at the location specified by the offset type and starting at the offset location in order to produce a result. The size of the mask must be equivalent to the size of the filter defined in ibmVlanUDSWFilter. The value of 1 in a mask bit location has the effect of making a comparison of the mask to the traffic frame significant. The value of a zero in a mask bit location has the effect of making the comparison of the mask with the traffic frame a 'don't care'. The octets in this object are transmitted in most significant byte first order. There is no default value and this mask must be specified when creating a UDSW VLAN in the ibmVlanConfTable.")
ibmVlanUDSWFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 3, 2, 1, 4, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 256))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmVlanUDSWFilter.setStatus('mandatory')
if mibBuilder.loadTexts: ibmVlanUDSWFilter.setDescription(' This object determines the size and bit pattern that is compared to the result after the mask being applied to the traffic frame at the location specified by the offset type and starting at the offset location. The size of the filter must be equivalent to the size of the mask defined in ibmVlanUDSWMask. If the result exactly matches the bit values defined in the filter then the frame is forwarded to the VLAN identified by the index for this table entry. The octets in this object are transmitted in most significant byte first order. There is no default value and this filter must be specified when creating a UDSW VLAN in the ibmVlanConfTable.')
ibmVlanMacConfTable = MibTable((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 3, 2, 1, 5), )
if mibBuilder.loadTexts: ibmVlanMacConfTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmVlanMacConfTable.setDescription(' The IBM MAC VLAN Configuration Table provides the definitions required to configure an IBM MAC Virtual LAN (VLAN). This table defines the filters for the IBM MAC VLAN. Entries in this table must be provided when the corresponding row of the ibmVlanConfTable is being created.')
ibmVlanMacConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 3, 2, 1, 5, 1), ).setIndexNames((0, "IBM-LAN-EMULATION-EXTENSION-MIB", "ibmVlanConfIndex"), (0, "IBM-LAN-EMULATION-EXTENSION-MIB", "ibmVlanMacAddrIndex"))
if mibBuilder.loadTexts: ibmVlanMacConfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmVlanMacConfEntry.setDescription(' Each entry of the ibmVlanMacConfTable provides configuration information pertaining to a specific instance of a MAC VLAN.')
ibmVlanMacAddrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 3, 2, 1, 5, 1, 1), Integer32())
if mibBuilder.loadTexts: ibmVlanMacAddrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmVlanMacAddrIndex.setDescription(' The MAC address index being used as a filter for this MAC address VLAN.')
ibmVlanMacAddresses = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 3, 2, 1, 5, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 600))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmVlanMacAddresses.setStatus('mandatory')
if mibBuilder.loadTexts: ibmVlanMacAddresses.setDescription(' A string of Source MAC addresses being used as a filter for this MAC address VLAN.')
ibmVlanMacAddrConfRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 3, 2, 1, 5, 1, 3), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmVlanMacAddrConfRowStatus.setReference(' RFC 1903, Textual Conventions for version 2 of the Simple Network Management Protocol (SNMPv2).')
if mibBuilder.loadTexts: ibmVlanMacAddrConfRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ibmVlanMacAddrConfRowStatus.setDescription(' This object is used to create or delete entries (rows) in the MAC Address Configuration Table.')
ibmVlanStatusTable = MibTable((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 3, 3, 1), )
if mibBuilder.loadTexts: ibmVlanStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmVlanStatusTable.setDescription(' The IBM VLAN Status Table provides the administration and statistics for an IBM Virtual LAN (VLAN).')
ibmVlanStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 3, 3, 1, 1), ).setIndexNames((0, "IBM-LAN-EMULATION-EXTENSION-MIB", "ibmVlanConfIndex"))
if mibBuilder.loadTexts: ibmVlanStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmVlanStatusEntry.setDescription(' Each entry in the ibmVlanStatusTable augments a specific instance of an IP VLAN.')
ibmVlanOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 3, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmVlanOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ibmVlanOperStatus.setDescription(' Current state of the VLAN')
ibmVlanAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 3, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmVlanAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ibmVlanAdminStatus.setDescription(' Desired state of the VLAN. This change becomes immediate on completion of the set operation and does not require system restart.')
ibmVlanProcessedPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 3, 3, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmVlanProcessedPackets.setStatus('mandatory')
if mibBuilder.loadTexts: ibmVlanProcessedPackets.setDescription(' The number of Broadcast/Multicast packets received by this VLAN.')
ibmVlanDiscardedPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 3, 3, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmVlanDiscardedPackets.setStatus('mandatory')
if mibBuilder.loadTexts: ibmVlanDiscardedPackets.setDescription(' The number of Broadcast packets discarded by this VLAN because the source VLAN was excluded on the port.')
ibmVlanDiscPktsMac = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 3, 3, 1, 1, 5), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmVlanDiscPktsMac.setStatus('mandatory')
if mibBuilder.loadTexts: ibmVlanDiscPktsMac.setDescription(' The object contains the Source MAC address from the last packet that was discarded because the source VLAN was excluded on the port. This will aid in finding the station that is being excluded. This object is defined as read-write so that a manager can clear the current Source MAC address after identifying the station that is trying to transmit on an excluded port. In order to clear the object the manager can specify a MAC address of all zeros 0x000000000000.')
ibmVlanIpStatusTable = MibTable((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 3, 3, 2), )
if mibBuilder.loadTexts: ibmVlanIpStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmVlanIpStatusTable.setDescription(' The IBM IP VLAN Status Table provides the administration and statistics for an IBM IP Protocol Virtual LAN (PVLAN).')
ibmVlanIpStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 3, 3, 2, 1), ).setIndexNames((0, "IBM-LAN-EMULATION-EXTENSION-MIB", "ibmVlanConfIndex"))
if mibBuilder.loadTexts: ibmVlanIpStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmVlanIpStatusEntry.setDescription(' Each entry in the ibmVlanIpStatusTable augments a specific instance of an IP PVLAN.')
ibmVlanIpCutThruFromPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 3, 3, 2, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmVlanIpCutThruFromPkts.setStatus('mandatory')
if mibBuilder.loadTexts: ibmVlanIpCutThruFromPkts.setDescription(' The number of Broadcast/Multicast packets cutThru from this VLAN.')
ibmVlanIpCutThruToPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 3, 3, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmVlanIpCutThruToPkts.setStatus('mandatory')
if mibBuilder.loadTexts: ibmVlanIpCutThruToPkts.setDescription(' The number of Broadcast/Multicast packets received to this VLAN.')
ibmVlanIpCutThruFromDiscPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 3, 3, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmVlanIpCutThruFromDiscPkts.setStatus('mandatory')
if mibBuilder.loadTexts: ibmVlanIpCutThruFromDiscPkts.setDescription(' The number of Broadcast/Multicast packets discarded because cutThru from this VLAN was disabled.')
ibmVlanIpCutThruToDiscPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 5, 8, 4, 3, 3, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmVlanIpCutThruToDiscPkts.setStatus('mandatory')
if mibBuilder.loadTexts: ibmVlanIpCutThruToDiscPkts.setDescription(' The number of Broadcast/Multicast packets discarded before it is forwarded because cutThru to this VLAN was disabled.')
ibmLeCServerXMonLECSGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 5, 8, 5, 1, 1))
ibmLeCServerXMonLESGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 5, 8, 5, 1, 2))
ibmLeCServerXMonBUSGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 5, 8, 5, 1, 3))
ibmCSuperELANGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 5, 8, 5, 1, 4))
ibmCBbcmMIBGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 5, 8, 5, 1, 5))
ibmCVlanMIBGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 5, 8, 5, 1, 6))
ibmLeMIBCompliance = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 5, 8, 5, 2, 1))
mibBuilder.exportSymbols("IBM-LAN-EMULATION-EXTENSION-MIB", ibmSEBridgeConfigTable=ibmSEBridgeConfigTable, ibmVlanIpConfEntry=ibmVlanIpConfEntry, ibmLeServerXMonitoring=ibmLeServerXMonitoring, ibmBbcmConfigNextId=ibmBbcmConfigNextId, IbmVlanType=IbmVlanType, ibmLeServerXBusMonBusLecInstances=ibmLeServerXBusMonBusLecInstances, ibmSEProtocolSpecification=ibmSEProtocolSpecification, ibmVlanConfType=ibmVlanConfType, ibmVlanGOGroup=ibmVlanGOGroup, ibmSEPortFlushRequestsIn=ibmSEPortFlushRequestsIn, ibmVlanIpStatusEntry=ibmVlanIpStatusEntry, ibmVlanIpConfTable=ibmVlanIpConfTable, ibmSEPortStatisticsEntry=ibmSEPortStatisticsEntry, ibmSEFrameSize=ibmSEFrameSize, ibmSEType=ibmSEType, ibmSEPortDropDestAddrFilters=ibmSEPortDropDestAddrFilters, ibmVlanMacAddresses=ibmVlanMacAddresses, ibmSEPortNarpRequestsOut=ibmSEPortNarpRequestsOut, ibmVlanTopologyChange=ibmVlanTopologyChange, ibmSEPortArpRepliesErrors=ibmSEPortArpRepliesErrors, ibmSEPortArpRequestsFiltered=ibmSEPortArpRequestsFiltered, ibmLeServerXMonLecsInstances=ibmLeServerXMonLecsInstances, ibmVlanUDSWFilter=ibmVlanUDSWFilter, ibmSEBridgeHelloTime=ibmSEBridgeHelloTime, ibmVlanStatusGroup=ibmVlanStatusGroup, ibmSEPortLanIdFailures=ibmSEPortLanIdFailures, ibmSEBridgeId=ibmSEBridgeId, ibmSEPortNum=ibmSEPortNum, ibmBbcmStatInOctets=ibmBbcmStatInOctets, ibmSEPortDropSrOverflows=ibmSEPortDropSrOverflows, ibmVlanMacAddrIndex=ibmVlanMacAddrIndex, ibmSEStpPortDesignatedBridge=ibmSEStpPortDesignatedBridge, lanEmulation=lanEmulation, IbmSEBridgeID=IbmSEBridgeID, ibmSEPortConfigEntry=ibmSEPortConfigEntry, ibmVlanIpCutThruFromDiscPkts=ibmVlanIpCutThruFromDiscPkts, ibmSEPortLeCtrlFramesOut=ibmSEPortLeCtrlFramesOut, ibmLeCServerXMonLECSGroup=ibmLeCServerXMonLECSGroup, ibmSEPortRoutedInFrames=ibmSEPortRoutedInFrames, ibmBbcmConfigEntry=ibmBbcmConfigEntry, ibmSEPortFlushRequestsOut=ibmSEPortFlushRequestsOut, ibmSEEnabled=ibmSEEnabled, ibmSEPortLeCtrlFramesDiscSrcPortNotFwrd=ibmSEPortLeCtrlFramesDiscSrcPortNotFwrd, ibmSEPortDropDestNotFwds=ibmSEPortDropDestNotFwds, ibmSEPortInFrames=ibmSEPortInFrames, ibmBbcmConfigTable=ibmBbcmConfigTable, ibmSEAtmIfNumber=ibmSEAtmIfNumber, ibmVlanProcessedPackets=ibmVlanProcessedPackets, ibmSEPortArpRepliesIn=ibmSEPortArpRepliesIn, ibmSuperELAN=ibmSuperELAN, ibmVlan=ibmVlan, ibmBbcmStatOutFilteredOctets=ibmBbcmStatOutFilteredOctets, ibmSEPortRootCost=ibmSEPortRootCost, ibmSEDesignatedRoot=ibmSEDesignatedRoot, ibmVlanConfAgingTimer=ibmVlanConfAgingTimer, ibmLeMIBGroups=ibmLeMIBGroups, ibmSEPortRecNoBuffFailures=ibmSEPortRecNoBuffFailures, ibmVlanOperStatus=ibmVlanOperStatus, ibmSEStpPortTable=ibmSEStpPortTable, ibmBbcmName=ibmBbcmName, ibmBbcmConfigGroup=ibmBbcmConfigGroup, ibmCVlanMIBGroup=ibmCVlanMIBGroup, ibmSEPortInDiscards=ibmSEPortInDiscards, ibmSEPriority=ibmSEPriority, ibmBbcmProtocolType=ibmBbcmProtocolType, ibmSEPortFlushRepliesErrors=ibmSEPortFlushRepliesErrors, ibmLeServerXMonBusInstances=ibmLeServerXMonBusInstances, ibmVlanIpNetworkMask=ibmVlanIpNetworkMask, ibmVlanIpCutThruToDiscPkts=ibmVlanIpCutThruToDiscPkts, ibmSEPortLeCtrlFramesDiscDestPortNotFwrd=ibmSEPortLeCtrlFramesDiscDestPortNotFwrd, ibmSEBridgeAddress=ibmSEBridgeAddress, ibmSEBridgeMaxAge=ibmSEBridgeMaxAge, ibmSEStpPortEntry=ibmSEStpPortEntry, IbmVlanIndex=IbmVlanIndex, ibmBbcmProtocolAdminStatus=ibmBbcmProtocolAdminStatus, ibmSERootCost=ibmSERootCost, ibmVlanUDSWConfEntry=ibmVlanUDSWConfEntry, ibmSEMacCacheAge=ibmSEMacCacheAge, ibmBbcmStatTable=ibmBbcmStatTable, ibmLeClientX=ibmLeClientX, ibmVlanConfForwardingPortMap=ibmVlanConfForwardingPortMap, ibmVlanIpCutThruToHere=ibmVlanIpCutThruToHere, ibmVlanMaxPortMap=ibmVlanMaxPortMap, ibmVlanUDSWConfTable=ibmVlanUDSWConfTable, ibm=ibm, ibmSEBridgeConfigEntry=ibmSEBridgeConfigEntry, ibmCSuperELANGroup=ibmCSuperELANGroup, ibmVlanUDSWMask=ibmVlanUDSWMask, ibmBbcmStatOutNotManaged=ibmBbcmStatOutNotManaged, ibmSEPortNarpRequestsIn=ibmSEPortNarpRequestsIn, ibmLeServerXLesMinLecID=ibmLeServerXLesMinLecID, ibmLeMIBCompliance=ibmLeMIBCompliance, ibmSEPortElanName=ibmSEPortElanName, ibmBbcmStatInReceives=ibmBbcmStatInReceives, ibmSEMaxAge=ibmSEMaxAge, ibmVlanMacAddrConfRowStatus=ibmVlanMacAddrConfRowStatus, ibmVlanIpCutThruFromPkts=ibmVlanIpCutThruFromPkts, ibmLeServerXLesConfigEntry=ibmLeServerXLesConfigEntry, ibmSETopChanges=ibmSETopChanges, ibmSEPortPriority=ibmSEPortPriority, ibmLeServerXMonLesInstances=ibmLeServerXMonLesInstances, ibmLeServerXMon=ibmLeServerXMon, ibmBbcmStatOutNotManagedOctets=ibmBbcmStatOutNotManagedOctets, ibmSEPortToBigFailures=ibmSEPortToBigFailures, ibmBbcmProtocolOperStatus=ibmBbcmProtocolOperStatus, ibmVlanConfTable=ibmVlanConfTable, ibmSEBridgeTable=ibmSEBridgeTable, ibmSEPortDropInputOverflows=ibmSEPortDropInputOverflows, ibmVlanConfIncludedPortMap=ibmVlanConfIncludedPortMap, ibmVlanGGroup=ibmVlanGGroup, ibmVlanIpCutThruFromHere=ibmVlanIpCutThruFromHere, ibmBbcmProtocolConfigTable=ibmBbcmProtocolConfigTable, ibmSEPortArpRequestsDroppedPortBlocked=ibmSEPortArpRequestsDroppedPortBlocked, ibmBbcmStatOutManaged=ibmBbcmStatOutManaged, ibmSEConfigRowStatus=ibmSEConfigRowStatus, ibmLeServerXLesConfigTable=ibmLeServerXLesConfigTable, ibmLeServerXBusMonEntry=ibmLeServerXBusMonEntry, ibmBbcmStatsGroup=ibmBbcmStatsGroup, ibmVlanConfGroup=ibmVlanConfGroup, ibmVlanConfBridgeId=ibmVlanConfBridgeId, ibmBbcmStatProtocolType=ibmBbcmStatProtocolType, ibmLeServerXBusMonTable=ibmLeServerXBusMonTable, ibmVlanIpxConfEntry=ibmVlanIpxConfEntry, ibmVlanDiscPktsMac=ibmVlanDiscPktsMac, ibmLeServerXLecsMonIndex=ibmLeServerXLecsMonIndex, ibmVlanConfRowStatus=ibmVlanConfRowStatus, ibmVlanIpStatusTable=ibmVlanIpStatusTable, ibmBbcmProtocolCacheAge=ibmBbcmProtocolCacheAge, ibmLeServerXBusMonUsedConnections=ibmLeServerXBusMonUsedConnections, ibmVlanStatusTable=ibmVlanStatusTable, ibmLeServerXLesMonLesLecInstances=ibmLeServerXLesMonLesLecInstances, ibmCBbcmMIBGroup=ibmCBbcmMIBGroup, ibmVlanIpCutThruToPkts=ibmVlanIpCutThruToPkts, ibmBbcmStatOutFiltered=ibmBbcmStatOutFiltered, ibmLeMIBConformance=ibmLeMIBConformance, ibmSEPortArpRequestsOut=ibmSEPortArpRequestsOut, ibmSEPortFlushRequestErrors=ibmSEPortFlushRequestErrors, ibmSEHoldTime=ibmSEHoldTime, ibmSEStpPortState=ibmSEStpPortState, ibmLeServerXLecsMonEntry=ibmLeServerXLecsMonEntry, ibmSEPortIfNumber=ibmSEPortIfNumber, ibmSEStpPortDesignatedRoot=ibmSEStpPortDesignatedRoot, ibmSEPortMaxInfo=ibmSEPortMaxInfo, ibmSEPortDropProtocolFilters=ibmSEPortDropProtocolFilters, ibmSEPortTransmitFailures=ibmSEPortTransmitFailures, ibmBbcmStatOutManagedOctets=ibmBbcmStatOutManagedOctets, ibmVlanMaxUDSWMaskFilter=ibmVlanMaxUDSWMaskFilter, ibmArchitecture=ibmArchitecture, ibmLeServerXConfig=ibmLeServerXConfig, ibmSEPortArpRequestsIn=ibmSEPortArpRequestsIn, ibmSEForwardDelay=ibmSEForwardDelay, ibmVlanConfExcludedPortMap=ibmVlanConfExcludedPortMap, ibmLeServerXLesMonIndex=ibmLeServerXLesMonIndex, ibmSERDCacheAge=ibmSERDCacheAge, IbmVlanPortMap=IbmVlanPortMap, ibmSEPortOutFrames=ibmSEPortOutFrames, ibmVlanMacConfTable=ibmVlanMacConfTable, ibmSEPortLeCtrlFramesIn=ibmSEPortLeCtrlFramesIn, ibmVlanStatusEntry=ibmVlanStatusEntry, ibmLeCServerXMonBUSGroup=ibmLeCServerXMonBUSGroup, ibmLeServerXLesMonUsedConnections=ibmLeServerXLesMonUsedConnections, ibmVlanConfName=ibmVlanConfName, ibmVlanUDSWOffset=ibmVlanUDSWOffset, ibmSENumPorts=ibmSENumPorts, ibmSEPortConfigTable=ibmSEPortConfigTable, ibmSEPortFlushRepliesIn=ibmSEPortFlushRepliesIn, ibmSEBridgeEntry=ibmSEBridgeEntry, ibmSEPortDataStatisticsTable=ibmSEPortDataStatisticsTable, ibmSEStpPortDesignatedCost=ibmSEStpPortDesignatedCost, ibmSEPortArpRepliesOut=ibmSEPortArpRepliesOut, ibmVlanConfEntry=ibmVlanConfEntry, ibmSEMacLearnedEntryDiscards=ibmSEMacLearnedEntryDiscards, ibmLeMIBCompliances=ibmLeMIBCompliances, ibmBbcmProtocolConfigEntry=ibmBbcmProtocolConfigEntry, ibmSEPortRemoteElan=ibmSEPortRemoteElan, ibmSEArpRequestsErrors=ibmSEArpRequestsErrors, ibmVlanIpxNetworkAddr=ibmVlanIpxNetworkAddr, ibmVlanMacConfEntry=ibmVlanMacConfEntry, ibmSEBridgeForwardDelay=ibmSEBridgeForwardDelay, ibmSEStpPortForwardTransitions=ibmSEStpPortForwardTransitions, ibmLeCServerXMonLESGroup=ibmLeCServerXMonLESGroup, ibmLeServerXLesMonTable=ibmLeServerXLesMonTable, ibmVlanIpxConfTable=ibmVlanIpxConfTable, ibmSETimeSinceTopologyChange=ibmSETimeSinceTopologyChange, ibmSERootPort=ibmSERootPort, ibmLeServerXLecsMonTable=ibmLeServerXLecsMonTable, ibmSEPortDropSrcNotFwds=ibmSEPortDropSrcNotFwds, ibmLeServerXLesMonEntry=ibmLeServerXLesMonEntry, ibmVlanIpNetworkAddr=ibmVlanIpNetworkAddr, ibmSEPortStpLanIdFailures=ibmSEPortStpLanIdFailures, ibmLeServerX=ibmLeServerX, ibmLeServerXBusMonIndex=ibmLeServerXBusMonIndex, ibmSEPortBpduFrames=ibmSEPortBpduFrames, ibmVlanUDSWOffsetType=ibmVlanUDSWOffsetType, ibmSEHelloTime=ibmSEHelloTime, ibmBbcmStatEntry=ibmBbcmStatEntry, ibmSEPortEnabled=ibmSEPortEnabled, ibmBbcmConfigRowStatus=ibmBbcmConfigRowStatus, ibmBbcmConfigIndex=ibmBbcmConfigIndex, ibmBbcmMIB=ibmBbcmMIB, ibmSEStpPortDesignatedPort=ibmSEStpPortDesignatedPort, ibmSERDLearnedEntryDiscards=ibmSERDLearnedEntryDiscards, ibmVlanCGroup=ibmVlanCGroup, ibmSEPortDropSrcAddrFilters=ibmSEPortDropSrcAddrFilters, ibmSEPortDropBpduOverflows=ibmSEPortDropBpduOverflows, ibmVlanConfIndexNextID=ibmVlanConfIndexNextID, ibmSEName=ibmSEName, ibmSEPortStatisticsTable=ibmSEPortStatisticsTable, ibmLeServerXLecsUsedConnections=ibmLeServerXLecsUsedConnections, ibmSEPortFlushRepliesOut=ibmSEPortFlushRepliesOut, ibmSEPortRowStatus=ibmSEPortRowStatus, ibmVlanAdminStatus=ibmVlanAdminStatus, ibmVlanDiscardedPackets=ibmVlanDiscardedPackets, ibmSEPortNarpRequestsDroppedPortBlocked=ibmSEPortNarpRequestsDroppedPortBlocked, ibmSEPortDataStatisticsEntry=ibmSEPortDataStatisticsEntry, ibmVlanConfIndex=ibmVlanConfIndex, ibmLeServerXLesMaxLecID=ibmLeServerXLesMaxLecID)

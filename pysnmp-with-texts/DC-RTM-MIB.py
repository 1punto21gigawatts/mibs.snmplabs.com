#
# PySNMP MIB module DC-RTM-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/DC-RTM-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:44:32 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ConstraintsUnion, ValueSizeConstraint, ConstraintsIntersection, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ConstraintsUnion", "ValueSizeConstraint", "ConstraintsIntersection", "SingleValueConstraint")
AdminDistance, InetSubAddressType, RouteAction, BfdSessionStatus, PathType, OperStatus, NumericIndexOrZero, AdminStatus = mibBuilder.importSymbols("DC-MASTER-TC", "AdminDistance", "InetSubAddressType", "RouteAction", "BfdSessionStatus", "PathType", "OperStatus", "NumericIndexOrZero", "AdminStatus")
IANAipRouteProtocol, = mibBuilder.importSymbols("IANA-RTPROTO-MIB", "IANAipRouteProtocol")
InetAddressType, InetAddress = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddressType", "InetAddress")
ModuleCompliance, ObjectGroup, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "ObjectGroup", "NotificationGroup")
MibScalar, MibTable, MibTableRow, MibTableColumn, Counter32, iso, ObjectIdentity, IpAddress, NotificationType, Unsigned32, ModuleIdentity, Counter64, Integer32, MibIdentifier, TimeTicks, Gauge32, Bits = mibBuilder.importSymbols("SNMPv2-SMI", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter32", "iso", "ObjectIdentity", "IpAddress", "NotificationType", "Unsigned32", "ModuleIdentity", "Counter64", "Integer32", "MibIdentifier", "TimeTicks", "Gauge32", "Bits")
TextualConvention, RowStatus, DisplayString, TruthValue = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "RowStatus", "DisplayString", "TruthValue")
rtmMib = ModuleIdentity((1, 2, 826, 0, 1, 1578918, 5, 61, 1))
rtmMib.setRevisions(('2014-04-17 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: rtmMib.setRevisionsDescriptions(('Arris changes to DCL June 2013 Release',))
if mibBuilder.loadTexts: rtmMib.setLastUpdated('201404170000Z')
if mibBuilder.loadTexts: rtmMib.setOrganization('Data Connection Ltd.')
if mibBuilder.loadTexts: rtmMib.setContactInfo('Postal: Data Connection Ltd. 100 Church Street Enfield Middlesex EN2 6BQ United Kingdom Tel: +44 20 83661177 E-mail: dcospf@dataconnection.com')
if mibBuilder.loadTexts: rtmMib.setDescription('The MIB module for management of the DC-RTM product.')
rtmObjects = MibIdentifier((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1))
rtmTrap = MibIdentifier((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 2))
class MplsIndexType(TextualConvention, Integer32):
    description = 'An index that can be used as a table index in cases where a large addressable space is required such as on an LSR where many applications may be provisioning labels.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 2147483647)

class FteIndex(TextualConvention, Unsigned32):
    description = 'The index value identifying a fault tolerant entity.'
    status = 'current'

class OspfTag(TextualConvention, Unsigned32):
    description = 'An OSPF Tag.'
    status = 'current'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(0, 4294967295)

class RtmMjStatus(TextualConvention, Integer32):
    description = 'The status of a master join.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))
    namedValues = NamedValues(("mjNotJoined", 1), ("mjSentAddJoin", 2), ("mjSentRegister", 3), ("mjJoinActive", 4), ("mjSentDelJoin", 5), ("mjSentUnregister", 6), ("mjJoinGone", 7), ("mjFailedToRegister", 8), ("mjFailingOver", 9), ("mjFailed", 10))

class RtmSjStatus(TextualConvention, Integer32):
    description = 'The status of a slave join.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))
    namedValues = NamedValues(("sjNotJoined", 1), ("sjJoined", 2), ("sjJoinActive", 3), ("sjJoinUnreg", 4), ("sjJoinGone", 5), ("sjFailingOver", 6), ("sjFailed", 7))

class InterfaceType(TextualConvention, Integer32):
    description = 'The type of interface to which a join applies.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("ifActiveRoutes", 1), ("ifRteProtInput", 2))

class AriPrtnrType(TextualConvention, Integer32):
    description = 'The type of slave partner to join to over the Active Routes Interface.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))
    namedValues = NamedValues(("ariPrtnrFt", 1), ("ariPrtnrLdf", 2), ("ariPrtnrRsm", 3), ("ariPrtnrBgp", 4), ("ariPrtnrPim", 5))

class RdstSetFieldType(TextualConvention, Integer32):
    description = 'The type of action a Set Field entry performs.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("rdstSetBgpComm", 1), ("rdstSetBgpExtComm", 2))

class EqualCostRouteOpts(TextualConvention, Integer32):
    description = 'The method used to determine how to choose which equal cost routes for a given destination to give to the active routing information consumers, if there is more than one route. This value is used in building responses to ATG_QCAR_GET_ROUTES and ATG_QCAR_QUERY_ROUTE signals, and also in building ATG_QCAR_ROUTE_UPDATE and ATG_QCAR_ROUTE_IND signals for consumers that require them. The permitted values for this field are as follows. all: All equal cost routes should be given to the active routing information consumers. one: DC-RTM picks one as soon as it can, and only tells the active routing information consumers about that one route. It only switches to another route if the chosen one is deleted, or if the chosen one no longer has the lowest administrative distance among routes to this destination (for example if a new route is added with a lower adminstrative distance).'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("equalCostAll", 1), ("equalCostOne", 2))

class MetricConversion(TextualConvention, Integer32):
    description = 'How to convert the metric in the source routing information to a new metric in the destination routing information. Possible actions are same: Use the supplied metric value constant: Ignore the supplied metric and use the constant value given in the metric numeric parameter field inverse: Map high values onto low ones, and vice-versa, by subtracting the supplied metric from 0xffffffff. scale up: Use the supplied metric multiplied by the value given in the metric numeric parameter field, or 0xffffffff if this is smaller. scale down: Use the supplied metric divided by the value given in the metric numeric parameter field (which must not be zero), rounding down to the next whole number. truncate: Use the smaller of the supplied metric or the metric numeric parameter field.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))
    namedValues = NamedValues(("metricConvSame", 1), ("metricConvConstant", 2), ("metricConvInverse", 3), ("metricConvScaleUp", 4), ("metricConvScaleDown", 5), ("metricConvTruncate", 6))

class InfoSourceDest(TextualConvention, Integer32):
    description = 'A source of, or destination for, routing information. These values are used when redistributing routing information.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 65536, 131072, 196608, 262144, 327680, 393216, 458752, 524288, 589824, 655360, 720896, 786432, 851968, 917504, 983040, 1048576, 1114112, 1179648))
    namedValues = NamedValues(("infoSourceAll", 0), ("infoSourceAllInclConnected", 1), ("infoSourceOther", 65536), ("infoSourceConnected", 131072), ("infoSourceStatic", 196608), ("infoSourceIcmp", 262144), ("infoSourceEgp", 327680), ("infoSourcePd", 393216), ("infoSourceHello", 458752), ("infoSourceRip", 524288), ("infoSourceIsis", 589824), ("infoSourceEsis", 655360), ("infoSourceIgrp", 720896), ("infoSourceBbnSpfIgp", 786432), ("infoSourceOspf", 851968), ("infoSourceBgp", 917504), ("infoSourceIdpr", 983040), ("infoSourceEigrp", 1048576), ("infoSourceDvmrp", 1114112), ("infoSourceEnni", 1179648))

class BgpOriginCode(TextualConvention, Integer32):
    description = 'A BGP origin code.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2))
    namedValues = NamedValues(("bgpOriginIgp", 0), ("bgpOriginEgp", 1), ("bgpOriginIncomplete", 2))

class BgpCommunity(TextualConvention, OctetString):
    description = 'The representation of a BGP Community.'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(4, 4)
    fixedLength = 4

class BgpExtendedCommunity(TextualConvention, OctetString):
    description = 'The representation of a BGP Extended Community.'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(8, 8)
    fixedLength = 8

class RouteInfo(TextualConvention, Integer32):
    description = 'A Routing Protocol Information Type. For OSPF, this is an integer representation of the OID which is required by RFC 2096. The RFCs which define the OIDs, and the represented OIDs, are show here. OSPF - RFC 1850. For ISIS, this is an integer representation of the types of route to IP reachable addresses.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10))
    namedValues = NamedValues(("none", 0), ("ospfIntraArea", 1), ("ospfInterArea", 2), ("ospfExternalType1", 3), ("ospfExternalType2", 4), ("isisL1Internal", 5), ("isisL2Internal", 6), ("isisL1InternalDown", 7), ("isisL1External", 8), ("isisL2External", 9), ("isisL1ExternalDown", 10))

class RouteType(TextualConvention, Integer32):
    description = 'Routing Type.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("other", 1), ("reject", 2), ("local", 3), ("remote", 4))

class RtmBfdSupport(TextualConvention, Integer32):
    description = 'BFD support level.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("none", 1), ("desired", 2), ("required", 3))

rtmEntityTable = MibTable((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 1), )
if mibBuilder.loadTexts: rtmEntityTable.setStatus('current')
if mibBuilder.loadTexts: rtmEntityTable.setDescription('The table of DC-RTM entities.')
rtmEntityEntry = MibTableRow((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 1, 1), ).setIndexNames((0, "DC-RTM-MIB", "rtmEntityFteIndex"))
if mibBuilder.loadTexts: rtmEntityEntry.setStatus('current')
if mibBuilder.loadTexts: rtmEntityEntry.setDescription('Each entry represents an instance of the DC-RTM entity.')
rtmEntityFteIndex = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 1, 1, 1), FteIndex())
if mibBuilder.loadTexts: rtmEntityFteIndex.setStatus('current')
if mibBuilder.loadTexts: rtmEntityFteIndex.setDescription('The index of this rtmEntityEntry. This is the HAF entity index passed on the entity create parameters.')
rtmEntityRowStatus = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 1, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmEntityRowStatus.setStatus('current')
if mibBuilder.loadTexts: rtmEntityRowStatus.setDescription('Used to create and delete a DC-RTM fault tolerant entity.')
rtmEntityAdminStat = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 1, 1, 3), AdminStatus().clone('adminStatusDown')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmEntityAdminStat.setStatus('current')
if mibBuilder.loadTexts: rtmEntityAdminStat.setDescription('The desired administrative state of the DC-RTM entity.')
rtmEntityOperStatus = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 1, 1, 4), OperStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtmEntityOperStatus.setStatus('current')
if mibBuilder.loadTexts: rtmEntityOperStatus.setDescription('The current operational state of the DC-RTM entity.')
rtmEntityDsConnctd = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 1, 1, 5), AdminDistance()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmEntityDsConnctd.setStatus('current')
if mibBuilder.loadTexts: rtmEntityDsConnctd.setDescription('The administrative distance used for directly connected routes. The lower the distance for a given type of route, the more likely a route of this type is to be used by DC-RTM as the active route for the given destination. See the DC-RTM Architecture Guide for more information about the use of administrative distances.')
rtmEntityDsStatDf = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 1, 1, 6), AdminDistance().clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmEntityDsStatDf.setStatus('current')
if mibBuilder.loadTexts: rtmEntityDsStatDf.setDescription('The default administrative distance used for statically defined routes in the static routes MIB table. It can be overridden for individual static routes. The lower the distance for a given route, the more likely that route is to be used by DC-RTM as the active route for the given destination. See the DC-RTM Architecture Guide for more information about the use of administrative distances.')
rtmEntityDsOspfInt = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 1, 1, 7), AdminDistance().clone(30)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmEntityDsOspfInt.setStatus('current')
if mibBuilder.loadTexts: rtmEntityDsOspfInt.setDescription('The administrative distance used for OSPF internal routes. The lower the distance for a given type of route, the more likely a route of this type is to be used by DC-RTM as the active route for the given destination. See the DC-RTM Architecture Guide for more information about the use of administrative distances.')
rtmEntityDsOspfExt = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 1, 1, 8), AdminDistance().clone(110)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmEntityDsOspfExt.setStatus('current')
if mibBuilder.loadTexts: rtmEntityDsOspfExt.setDescription('The administrative distance used for OSPF Autonomous System external routes. The lower the distance for a given type of route, the more likely a route of this type is to be used by DC-RTM as the active route for the given destination. See the DC-RTM Architecture Guide for more information about the use of administrative distances.')
rtmEntityDsIntBgp = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 1, 1, 9), AdminDistance().clone(200)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmEntityDsIntBgp.setStatus('current')
if mibBuilder.loadTexts: rtmEntityDsIntBgp.setDescription('The administrative distance used for internal and VPN BGP routes. The lower the distance for a given type of route, the more likely a route of this type is to be used by DC-RTM as the active route for the given destination. See the DC-RTM Architecture Guide for more information about the use of administrative distances.')
rtmEntityDsExtBgp = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 1, 1, 10), AdminDistance().clone(20)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmEntityDsExtBgp.setStatus('current')
if mibBuilder.loadTexts: rtmEntityDsExtBgp.setDescription('The administrative distance used for external BGP routes. The lower the distance for a given type of route, the more likely a route of this type is to be used by DC-RTM as the active route for the given destination. See the DC-RTM Architecture Guide for more information about the use of administrative distances.')
rtmEntityDsIsisInt1 = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 1, 1, 11), AdminDistance().clone(115)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmEntityDsIsisInt1.setStatus('current')
if mibBuilder.loadTexts: rtmEntityDsIsisInt1.setDescription('The administrative distance used for IS-IS level 1 internal routes. The lower the distance for a given type of route, the more likely a route of this type is to be used by DC-RTM as the active route for the given destination. See the DC-RTM Architecture Guide for more information about the use of administrative distances.')
rtmEntityDsIsisInt2 = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 1, 1, 12), AdminDistance().clone(116)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmEntityDsIsisInt2.setStatus('current')
if mibBuilder.loadTexts: rtmEntityDsIsisInt2.setDescription('The administrative distance used for IS-IS level 2 internal routes. The lower the distance for a given type of route, the more likely a route of this type is to be used by DC-RTM as the active route for the given destination. See the DC-RTM Architecture Guide for more information about the use of administrative distances.')
rtmEntityDsIsisExt1 = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 1, 1, 13), AdminDistance().clone(117)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmEntityDsIsisExt1.setStatus('current')
if mibBuilder.loadTexts: rtmEntityDsIsisExt1.setDescription('The administrative distance used for IS-IS level 1 external routes. The lower the distance for a given type of route, the more likely a route of this type is to be used by DC-RTM as the active route for the given destination. See the DC-RTM Architecture Guide for more information about the use of administrative distances.')
rtmEntityDsIsisExt2 = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 1, 1, 14), AdminDistance().clone(118)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmEntityDsIsisExt2.setStatus('current')
if mibBuilder.loadTexts: rtmEntityDsIsisExt2.setDescription('The administrative distance used for IS-IS level 2 external routes. The lower the distance for a given type of route, the more likely a route of this type is to be used by DC-RTM as the active route for the given destination. See the DC-RTM Architecture Guide for more information about the use of administrative distances.')
rtmEntityDsRip = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 1, 1, 15), AdminDistance().clone(120)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmEntityDsRip.setStatus('current')
if mibBuilder.loadTexts: rtmEntityDsRip.setDescription('The administrative distance used for RIP routes. The lower the distance for a given type of route, the more likely a route of this type is to be used by DC-RTM as the active route for the given destination. See the DC-RTM Architecture Guide for more information about the use of administrative distances.')
rtmEntityDsEgp = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 1, 1, 16), AdminDistance().clone(205)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmEntityDsEgp.setStatus('current')
if mibBuilder.loadTexts: rtmEntityDsEgp.setDescription('The administrative distance used for Exterior Gateway Protocol routes. The lower the distance for a given type of route, the more likely a route of this type is to be used by DC-RTM as the active route for the given destination. See the DC-RTM Architecture Guide for more information about the use of administrative distances.')
rtmEntityDsPd = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 1, 1, 17), AdminDistance().clone(2)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmEntityDsPd.setStatus('current')
if mibBuilder.loadTexts: rtmEntityDsPd.setDescription('The administrative distance used for routes injected using DHCPv6 prefix delegation protocol. The lower the distance for a given type of route, the more likely a route of this type is to be used by RTM as the active route for the given destination.')
rtmEntityDsHello = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 1, 1, 18), AdminDistance().clone(215)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmEntityDsHello.setStatus('current')
if mibBuilder.loadTexts: rtmEntityDsHello.setDescription('The administrative distance used for FuzzBall HelloSpeak routes. The lower the distance for a given type of route, the more likely a route of this type is to be used by DC-RTM as the active route for the given destination. See the DC-RTM Architecture Guide for more information about the use of administrative distances.')
rtmEntityDsEsis = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 1, 1, 19), AdminDistance().clone(225)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmEntityDsEsis.setStatus('current')
if mibBuilder.loadTexts: rtmEntityDsEsis.setDescription('The administrative distance used for ISO 9542 routes. The lower the distance for a given type of route, the more likely a route of this type is to be used by DC-RTM as the active route for the given destination. See the DC-RTM Architecture Guide for more information about the use of administrative distances.')
rtmEntityDsBbnspfigp = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 1, 1, 20), AdminDistance().clone(225)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmEntityDsBbnspfigp.setStatus('current')
if mibBuilder.loadTexts: rtmEntityDsBbnspfigp.setDescription('The administrative distance used for BBN SPF IGP routes. The lower the distance for a given type of route, the more likely a route of this type is to be used by DC-RTM as the active route for the given destination. See the DC-RTM Architecture Guide for more information about the use of administrative distances.')
rtmEntityDsIdpr = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 1, 1, 21), AdminDistance().clone(225)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmEntityDsIdpr.setStatus('current')
if mibBuilder.loadTexts: rtmEntityDsIdpr.setDescription('The administrative distance used for InterDomain Policy Routing routes. The lower the distance for a given type of route, the more likely a route of this type is to be used by DC-RTM as the active route for the given destination. See the DC-RTM Architecture Guide for more information about the use of administrative distances.')
rtmEntityDsIgrp = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 1, 1, 22), AdminDistance().clone(100)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmEntityDsIgrp.setStatus('current')
if mibBuilder.loadTexts: rtmEntityDsIgrp.setDescription('The administrative distance used for IGRP routes. The lower the distance for a given type of route, the more likely a route of this type is to be used by DC-RTM as the active route for the given destination. See the DC-RTM Architecture Guide for more information about the use of administrative distances.')
rtmEntityDsEigrpSmm = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 1, 1, 23), AdminDistance().clone(5)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmEntityDsEigrpSmm.setStatus('current')
if mibBuilder.loadTexts: rtmEntityDsEigrpSmm.setDescription('The administrative distance used for enhanced IGRP summary routes. The lower the distance for a given type of route, the more likely a route of this type is to be used by DC-RTM as the active route for the given destination. See the DC-RTM Architecture Guide for more information about the use of administrative distances.')
rtmEntityDsIntEigrp = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 1, 1, 24), AdminDistance().clone(90)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmEntityDsIntEigrp.setStatus('current')
if mibBuilder.loadTexts: rtmEntityDsIntEigrp.setDescription('The administrative distance used for internal enhanced IGRP routes. The lower the distance for a given type of route, the more likely a route of this type is to be used by DC-RTM as the active route for the given destination. See the DC-RTM Architecture Guide for more information about the use of administrative distances.')
rtmEntityDsEigrpExt = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 1, 1, 25), AdminDistance().clone(170)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmEntityDsEigrpExt.setStatus('current')
if mibBuilder.loadTexts: rtmEntityDsEigrpExt.setDescription('The administrative distance used for enhanced IGRP external routes. The lower the distance for a given type of route, the more likely a route of this type is to be used by DC-RTM as the active route for the given destination. See the DC-RTM Architecture Guide for more information about the use of administrative distances.')
rtmEntityDsUnknown = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 1, 1, 26), AdminDistance().clone(255)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmEntityDsUnknown.setStatus('current')
if mibBuilder.loadTexts: rtmEntityDsUnknown.setDescription('The administrative distance used for routes which come from an unrecognized routing protocol. The lower the distance for a given type of route, the more likely a route of this type is to be used by DC-RTM as the active route for the given destination. See the DC-RTM Architecture Guide for more information about the use of administrative distances.')
rtmEntityEqlCostOpt = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 1, 1, 27), EqualCostRouteOpts().clone('equalCostAll')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmEntityEqlCostOpt.setStatus('current')
if mibBuilder.loadTexts: rtmEntityEqlCostOpt.setDescription("How to select which equal cost routes to give to an active routing information consumer, if there is more than one route to a given destination with the lowest administrative distance. This parameter is used in building responses to ATG_QCAR_GET_ROUTES and ATG_QCAR_QUERY_ROUTE signals, and also in building ATG_QCAR_ROUTE_UPDATE and ATG_QCAR_ROUTE_IND signals for consumers that require them. The value of this field must not be changed while the row status of this MIB is AMB_ROW_STATUS_ACTIVE and the admin status is AMB_ADMIN_STATUS_UP. If you want to use IGP shortcuts for any routes then this field must be set to 'equalCostAll'.")
rtmEntityDelDeadRte = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 1, 1, 28), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmEntityDelDeadRte.setStatus('current')
if mibBuilder.loadTexts: rtmEntityDelDeadRte.setDescription("Whether to delete routes from a Routing Protocol Manager (RPM) whose join to DC-RTM goes down. If this is set to TRUE then the routes are deleted after the time specified in the 'dead RPM timer' parameter. If the join between an RPM and DC-RTM goes down, typically because the RPM is no longer running, then the routes received from that RPM gradually become out of date. This parameter allows DC-RTM to continue to use these routes regardless of whether the RPM ever restarts, or to stop using them after a period of time. This period of time should represent the maximum amount of time for which the RPM would be down if this were only a temporary state of affairs. The value of this field must not be changed while the row status of this MIB is AMB_ROW_STATUS_ACTIVE and the admin status is AMB_ADMIN_STATUS_UP.")
rtmEntityDeadRpmTmr = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 1, 1, 29), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmEntityDeadRpmTmr.setStatus('current')
if mibBuilder.loadTexts: rtmEntityDeadRpmTmr.setDescription('Only used if the option is set to TRUE to delete routes from an RPM which DC-RTM can no longer see. This field defines the period of time that the join to an RPM can be down before its routes are deleted. This period of time should represent the maximum amount of time for which the RPM would be down if this were only a temporary state of affairs. The units for this field are minutes by default. The value of this field must not be changed while the row status of this MIB is AMB_ROW_STATUS_ACTIVE and the admin status is AMB_ADMIN_STATUS_UP.')
rtmEntityRouteNumber = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 1, 1, 30), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtmEntityRouteNumber.setStatus('current')
if mibBuilder.loadTexts: rtmEntityRouteNumber.setDescription("The number of destination prefixes to which DC-RTM currently has a route. This is the same as the number of rows in the rtmRouteTable if the following are both true. - Either rtmEntityEqlCostOpt is set to 'one', or DC-RTM knows of at most one route to each destination prefix. This means that there is at most one route in rtmRouteTable for each destination prefix included in rtmEntityRouteNumber. - None of the routes which DC-RTM has learned about are loose next hops that cannot be resolved. This means that there is at least one route in rtmRouteTable per destination prefix included in rtmEntityRouteNumber.")
rtmEntityAddressFamily = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 1, 1, 31), InetAddressType().clone('ipv4')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmEntityAddressFamily.setStatus('current')
if mibBuilder.loadTexts: rtmEntityAddressFamily.setDescription('The address family that this instance of DC-RTM supports. The value of this field must not be changed while the row status of this MIB is AMB_ROW_STATUS_ACTIVE and the admin status is AMB_ADMIN_STATUS_UP.')
rtmEntityDsDvmrp = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 1, 1, 32), AdminDistance().clone(225)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmEntityDsDvmrp.setStatus('current')
if mibBuilder.loadTexts: rtmEntityDsDvmrp.setDescription('The administrative distance used for DVMRP routes. The lower the distance for a given type of route, the more likely a route of this type is to be used by DC-RTM as the active route for the given destination. See the DC-RTM Architecture Guide for more information about the use of administrative distances.')
rtmEntityI3Index = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 1, 1, 33), FteIndex().clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmEntityI3Index.setStatus('current')
if mibBuilder.loadTexts: rtmEntityI3Index.setDescription('The entity index of the instance of the I3 stub to which this instance of DC-RTM should join. The value of this field must not be changed while the row status of this MIB is AMB_ROW_STATUS_ACTIVE and the admin status is AMB_ADMIN_STATUS_UP.')
rtmEntityI3JoinStatus = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 1, 1, 34), RtmMjStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtmEntityI3JoinStatus.setStatus('current')
if mibBuilder.loadTexts: rtmEntityI3JoinStatus.setDescription('The status of the I3 master join.')
rtmEntityPartnerWaitTime = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 1, 1, 35), Integer32().clone(30000)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmEntityPartnerWaitTime.setStatus('current')
if mibBuilder.loadTexts: rtmEntityPartnerWaitTime.setDescription('The period that DC-RTM waits for joins from Routing Protocol Managers (RPMs) to be reestablished when DC-RTM is activated. DC-RTM checks for routing table convergence by waiting for a complete set of routes from all joins from RPMs that are established within this period. The partner wait timer duration effectively acts as the minimum restart interval. The value should be set to zero if the forwarding table does not maintain routing state when DC-RTM restarts.')
rtmEntityStartupTime = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 1, 1, 36), Integer32().clone(5000)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmEntityStartupTime.setStatus('current')
if mibBuilder.loadTexts: rtmEntityStartupTime.setDescription("This is the startup timer duration that is used when DC-RTM is activated and no routing state has been retained by the forwarding table as part of graceful restart procedures. This timer duration is used when rtmEntityFtStateRetained is 'false'. It determines the maximum length of time before DC-RTM deems that routing table convergence is complete and hence the maximum length of time before DC-RTM sends routing updates to the forwarding table. This is typically set to a small value to ensure that the forwarding table is populated in a timely manner. Time is in miliseconds")
rtmEntityRestartTime = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 1, 1, 37), Integer32().clone(180000)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmEntityRestartTime.setStatus('current')
if mibBuilder.loadTexts: rtmEntityRestartTime.setDescription("This is the startup timer duration that is used when DC-RTM is activated and routing state has been retained by the forwarding table as part of graceful restart procedures. This timer duration is used when rtmEntityFtStateRetained is 'true'. It determines the maximum length of time before DC-RTM deems that routing table convergence is complete and hence the maximum length of time before DC-RTM sends routing updates to the forwarding table. This is typically set to a value greater than the restart timer duration of each routing protocol, so that the routing table can converge before the forwarding table is updated.")
rtmEntityFtStateRetained = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 1, 1, 38), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmEntityFtStateRetained.setStatus('current')
if mibBuilder.loadTexts: rtmEntityFtStateRetained.setDescription("Whether state has been maintained by the forwarding table during a restart of DC-RTM. This indicates which startup timer duration DC-RTM should uses. Setting this to 'true' causes DC-RTM to use the value of rtmEntityRestartTime as the startup timer duration. Setting this to 'false' causes DC-RTM to use the value of rtmEntityStartupTime as the startup timer duration.")
rtmEntityUseUnidirectionalLinks = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 1, 1, 39), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmEntityUseUnidirectionalLinks.setStatus('current')
if mibBuilder.loadTexts: rtmEntityUseUnidirectionalLinks.setDescription("Are unidirectional links usable for the FIB maintained by this instance of DC-RTM? If set to 'false' then unidirectional interfaces reported over the I3 and IGP shortcuts reported over the RPI are discarded. If set to 'true' then unidirectional interfaces can be used for next hops reported over the Active Routes Interface. Note in particular that IGP shortcuts through TE-tunnel next hops are reported over the Active Routes Interface in addition to native adjacency next hops. If the active route consumers of this FIB cannot use unidirectional links then this field should be set to 'false'. An example of such an active route consumer is DC-PIM. Because DC-PIM uses paths for Reverse Path Forwarding, it cannot use unidirectional links. If this field is changed while DC-RTM is active, DC-RTM deactivates and then reactivates in order to refresh all routing information.")
rtmEntityBfdIndex = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 1, 1, 40), NumericIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmEntityBfdIndex.setStatus('current')
if mibBuilder.loadTexts: rtmEntityBfdIndex.setDescription('The entity index of the instance of the BFD stub to which this instance of DC-RTM should join. A value of zero indicates that no BFD join is required. If a non-zero value is specified then DC-RTM can only be active if the corresponding BFD stub is active.')
rtmEntityBfdJoinStatus = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 1, 1, 41), RtmMjStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtmEntityBfdJoinStatus.setStatus('current')
if mibBuilder.loadTexts: rtmEntityBfdJoinStatus.setDescription('The status of the BFD master join.')
rtmEntityEnableTrapSupport = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 1, 1, 42), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmEntityEnableTrapSupport.setStatus('current')
if mibBuilder.loadTexts: rtmEntityEnableTrapSupport.setDescription("Set this object to 'true' to enable trap support in DC-RTM. When this field is set to 'true', DC-RTM will generate the rtmOperStateChange, rtmStaticRouteChange and rtmPathActivityChange traps.")
rtmRedistTable = MibTable((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 2), )
if mibBuilder.loadTexts: rtmRedistTable.setStatus('current')
if mibBuilder.loadTexts: rtmRedistTable.setDescription("The table of DC-RTM redistribution information entries. This table is used to determine how routing information is redistributed to routing protocol managers (RPMs) using DC-RTM's Routing Protocol Input interface. The RPM to which the information may be redistributed is called the destination RPM. Routing information is received from RPMs and from the MIB (for static routes); these are referred to as the routing information source. In general, DC-RTM will not redistribute a route from an RPM back to the same RPM. The one exception to this is if it is explicitly configured to do so - in other words, if it is configured with a redistribution rule where the source and destination filters both indicate the same RPM instance. One example use for this is to inform an instance of BGP which of its routes are active - see the definition of bgpRmAfiSafiAdvertiseInactive in the BGP MIB for more details.")
rtmRedistEntry = MibTableRow((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 2, 1), ).setIndexNames((0, "DC-RTM-MIB", "rtmRedistFteIndex"), (0, "DC-RTM-MIB", "rtmRedistEntryId"))
if mibBuilder.loadTexts: rtmRedistEntry.setStatus('current')
if mibBuilder.loadTexts: rtmRedistEntry.setDescription('Information defining how routing information is redistributed to routing protocol managers (RPMs)by DC-RTM on its Routing Protocol Input interface. There are two key aspects to an entry in this table. Firstly, it contains a set of filters which determine whether or not the entry applies to a given pairing of a given set of routing information and a given destination RPM. There is a filter priority to determine which entry to use if there are multiple entries whose filters match a given pairing. Secondly, it contains parameters to use when redistributing the routing information to the destination RPM, including a flag which determines whether or not to redistribute at all.')
rtmRedistFteIndex = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 2, 1, 1), FteIndex())
if mibBuilder.loadTexts: rtmRedistFteIndex.setStatus('current')
if mibBuilder.loadTexts: rtmRedistFteIndex.setDescription('The HAF entity index identifying the instance of DC-RTM to which this redistribution table entry applies.')
rtmRedistEntryId = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 2, 1, 2), Unsigned32())
if mibBuilder.loadTexts: rtmRedistEntryId.setStatus('current')
if mibBuilder.loadTexts: rtmRedistEntryId.setDescription('The index of this DC-RTM redistribution table entry within the DC-RTM entity. This is an arbitrarily selected identifier.')
rtmRedistRowStatus = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 2, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmRedistRowStatus.setStatus('current')
if mibBuilder.loadTexts: rtmRedistRowStatus.setDescription('Used to create and delete a DC-RTM redistribution table entry.')
rtmRedistAdminStat = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 2, 1, 4), AdminStatus().clone('adminStatusDown')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmRedistAdminStat.setStatus('current')
if mibBuilder.loadTexts: rtmRedistAdminStat.setDescription('The administrative state of the redistribution table entry. The row status by itself does not indicate whether the redistribution is currently active. The row must be defined and the administrative status must be up. This enables a MIB agent to turn off a particular redistribution without deleting it from the table altogether.')
rtmRedistPriority = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 2, 1, 5), Integer32().clone(2147483647)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmRedistPriority.setStatus('current')
if mibBuilder.loadTexts: rtmRedistPriority.setDescription('The priority assigned to this table entry. The lower this value takes, the higher the priority of the entry. The priority takes effect when there is more than one entry in the table whose filters match a pairing of routing information and destination RPM.')
rtmRedistInfoSrc = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 2, 1, 6), InfoSourceDest().clone('infoSourceAll')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmRedistInfoSrc.setStatus('current')
if mibBuilder.loadTexts: rtmRedistInfoSrc.setDescription("The source of the routing information. This is one of: - an RPM, joined to DC-RTM on the Routing Protocol Input interface - 'static' for statically defined routes, defined in the static routes table with path type ATG_QC_PATH_STATIC - 'connected' for routes to local IP addresses and directly connected IP addresses and subnets, learned via the I3 interface, or defined in the static route table with path type ATG_QC_PATH_CONNECTED - 'all', meaning that this entry applies to routes from all RPMs and static routes, but not routes learnt via the I3 interface - 'all-incl-connected', meaning that this entry applies to routes from all RPMs, static routes, and routes learnt via the I3 interface.")
rtmRedistSrcInstFlt = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 2, 1, 7), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmRedistSrcInstFlt.setStatus('current')
if mibBuilder.loadTexts: rtmRedistSrcInstFlt.setDescription("Specifies whether or not a source instance filter is in use. If it is not in use then this entry applies to all instances of the source RPM. The purpose of this filter is to allow an entry to apply to only one instance of the source RPM if more than one instance is active. The filter must always be off if the routing information source is set to 'all' or 'all-incl-connected'.")
rtmRedistSrcInst = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 2, 1, 8), FteIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmRedistSrcInst.setStatus('current')
if mibBuilder.loadTexts: rtmRedistSrcInst.setDescription('Value of the source instance filter, if in use. If the filter is in use then do not match the source routing information to this entry if this filter value does not match the fault tolerant entity index of the RPM instance specified as the routing information source.')
rtmRedistInfoDest = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 2, 1, 9), InfoSourceDest().clone('infoSourceAll')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmRedistInfoDest.setStatus('current')
if mibBuilder.loadTexts: rtmRedistInfoDest.setDescription("The destination of the routing information. This is usually an RPM, joined to DC-RTM on the Routing Protocol Input interface. It can also be set to 'all' or 'all-incl-connected', meaning that this entry applies to all routing information destinations.")
rtmRedistDestInstFlt = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 2, 1, 10), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmRedistDestInstFlt.setStatus('current')
if mibBuilder.loadTexts: rtmRedistDestInstFlt.setDescription("Specifies whether or not a destination instance filter is in use. If it is not in use then this entry applies to all instances of the destination RPM. The purpose of this filter is to allow an entry to apply to only one instance of the destination RPM if more than one instance is active. The filter must always be off if the routing information destination is 'all' or 'all-incl-connected'.")
rtmRedistDestInst = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 2, 1, 11), FteIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmRedistDestInst.setStatus('current')
if mibBuilder.loadTexts: rtmRedistDestInst.setDescription('Value of the destination instance filter, if in use. If the filter is in use then do not redistribute this routing information to a given instance of an RPM if this filter value does not match the fault tolerant entity index of the RPM instance.')
rtmRedistAddrFilterType = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 2, 1, 12), InetAddressType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmRedistAddrFilterType.setStatus('current')
if mibBuilder.loadTexts: rtmRedistAddrFilterType.setDescription('The type of the address used as the destination address filter. This object must be set to the same value as rtmEntityAddressFamily, and this is its default value.')
rtmRedistAddrFilter = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 2, 1, 13), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(4, 4), ValueSizeConstraint(16, 16), )).clone(hexValue="00000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmRedistAddrFilter.setStatus('current')
if mibBuilder.loadTexts: rtmRedistAddrFilter.setDescription('Destination IP address filter. Do not match the source routing information to this entry if one of these fails: - the destination IP address in the source routing information, with the IP address filter prefix length applied, matches the IP address filter with the IP address filter prefix length applied - the destination IP address prefix length is greater than or equal to the IP address filter prefix length. The IP address filter prefix length is given by the rtmRedistAddrFltLen object. Applying the prefix length to an address means taking the first rtmRedistAddrFltLen bits of the address. To avoid having any destination IP address filtering, set the IP address filter to all zeroes and the IP address filter prefix length to zero. The length of this IP address must be the address length for the family given by rtmEntityAddressFamily.')
rtmRedistAddrFltLen = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 2, 1, 14), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmRedistAddrFltLen.setStatus('current')
if mibBuilder.loadTexts: rtmRedistAddrFltLen.setDescription('Destination IP address filter prefix length (in bits). Do not match the source routing information to this entry if one of these fails: - the destination IP address in the source routing information, with the IP address filter prefix length applied, matches the IP address filter with the IP address filter prefix length applied - the destination IP address prefix length is greater than or equal to the IP address filter prefix length. If the IP address filter prefix length is L, then applying the length to an address means taking the first L bits of the address. To avoid having any destination IP address filtering, set the IP address filter to all zeroes and the IP address filter prefix length to zero.')
rtmRedistHopFltValType = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 2, 1, 15), InetAddressType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmRedistHopFltValType.setStatus('current')
if mibBuilder.loadTexts: rtmRedistHopFltValType.setDescription('The type of the address used as the next hop address filter. This object must be set to the same value as rtmEntityAddressFamily, and this is its default value.')
rtmRedistHopFltVal = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 2, 1, 16), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(4, 4), ValueSizeConstraint(16, 16), )).clone(hexValue="00000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmRedistHopFltVal.setStatus('current')
if mibBuilder.loadTexts: rtmRedistHopFltVal.setDescription('Value of next hop filter. Do not match the source routing information to this entry if none of the next hop values in the source routing information, with the next hop filter prefix length applied, matches the next hop filter value with the next hop filter prefix length applied. The next hop filter prefix length is given by the rtmRedistHopFltLen object. Applying the prefix length to an address means taking the first rtmRedistHopFltLen bits of the address. To avoid having any next hop filtering, set the next hop filter to all zeroes and the next hop filter prefix length to zero. The length of this next hop filter must be the address length for the family given by rtmEntityAddressFamily.')
rtmRedistHopFltLen = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 2, 1, 17), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmRedistHopFltLen.setStatus('current')
if mibBuilder.loadTexts: rtmRedistHopFltLen.setDescription('Next hop filter prefix length. Do not match the source routing information to this entry if none of the next hop values in the source routing information, with the next hop filter prefix length applied, matches the next hop filter value with the next hop filter prefix length applied. If the next hop filter prefix length is L, then applying the length to an address means taking the first L bits of the address. To avoid having any next hop filtering, set the next hop filter to all zeroes and the next hop filter prefix length to zero.')
rtmRedistIfIndexFlt = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 2, 1, 18), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmRedistIfIndexFlt.setStatus('current')
if mibBuilder.loadTexts: rtmRedistIfIndexFlt.setDescription('Specifies whether or not an output network interface index filter is in use.')
rtmRedistIfIndex = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 2, 1, 19), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmRedistIfIndex.setStatus('current')
if mibBuilder.loadTexts: rtmRedistIfIndex.setDescription('Value of output network interface index filter, if in use. If the filter is in use then do not match the source routing information to this entry if none of the output network interface indexes in the source routing information matches this filter value.')
rtmRedistPathTypeFlt = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 2, 1, 20), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmRedistPathTypeFlt.setStatus('current')
if mibBuilder.loadTexts: rtmRedistPathTypeFlt.setDescription("Specifies whether or not a path type filter is in use. If it is not in use then this entry applies to all path type values. A path type filter can only be used if the routing information source filter _info_src_ is not set to 'all' or 'all-incl-connected'. The value of the path type filter, if used, must be one of the path types which matches the routing information source. For example, a path type filter of 'OSPF external type 1' can only be used if the routing information source filter is set to OSPF.")
rtmRedistPathType = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 2, 1, 21), PathType().clone('pathTypeNone')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmRedistPathType.setStatus('current')
if mibBuilder.loadTexts: rtmRedistPathType.setDescription("Value of path type filter, if in use. If the filter is in use then do not match the source routing information to this entry if the path type in the source routing information does not match this filter value. A path type filter can only be used if the routing information source filter _info_src_ is not set to 'all' or 'all-incl-connected'. The value of the path type filter, if used, must be one of the path types which matches the routing information source. For example, a path type filter of 'OSPF external type 1' can only be used if the routing information source filter is set to OSPF.")
rtmRedistOspfAreaFlt = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 2, 1, 22), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmRedistOspfAreaFlt.setStatus('current')
if mibBuilder.loadTexts: rtmRedistOspfAreaFlt.setDescription('Specifies whether or not an OSPF area filter is in use. The filter can only be on if the routing information source field is OSPF.')
rtmRedistOspfArea = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 2, 1, 23), IpAddress().clone(hexValue="00000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmRedistOspfArea.setStatus('current')
if mibBuilder.loadTexts: rtmRedistOspfArea.setDescription('Value of OSPF area filter, if in use. If the filter is in use then do not match the source routing information to this entry if the OSPF area ID in the information does not match this area ID.')
rtmRedistOspfTagFlt = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 2, 1, 24), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmRedistOspfTagFlt.setStatus('current')
if mibBuilder.loadTexts: rtmRedistOspfTagFlt.setDescription('Specifies whether or not an OSPF tag filter is in use. The filter can only be on if the routing information source field is OSPF.')
rtmRedistOspfTag = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 2, 1, 25), OspfTag()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmRedistOspfTag.setStatus('current')
if mibBuilder.loadTexts: rtmRedistOspfTag.setDescription('Value of OSPF tag filter, if in use. If the filter is in use then do not match the source routing information to this entry if the tag in the information does not match this tag.')
rtmRedistCommunityFlt = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 2, 1, 26), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmRedistCommunityFlt.setStatus('current')
if mibBuilder.loadTexts: rtmRedistCommunityFlt.setDescription('Specifies whether or not a BGP community number filter is in use. The filter can only be on if the routing information source field is BGP.')
rtmRedistCommunity = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 2, 1, 27), BgpCommunity().clone(hexValue="00000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmRedistCommunity.setStatus('current')
if mibBuilder.loadTexts: rtmRedistCommunity.setDescription('Value of BGP community number filter, if in use. If the filter is in use then do not match the source routing information to this entry if there is no match between one of the community numbers in the source routing information and the value of this filter.')
rtmRedistExtCommFlt = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 2, 1, 28), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmRedistExtCommFlt.setStatus('current')
if mibBuilder.loadTexts: rtmRedistExtCommFlt.setDescription('Specifies whether or not a BGP extended community number filter is in use. The filter can only be on if the routing information source field is BGP.')
rtmRedistExtComm = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 2, 1, 29), BgpExtendedCommunity().clone(hexValue="0000000000000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmRedistExtComm.setStatus('current')
if mibBuilder.loadTexts: rtmRedistExtComm.setDescription('Value of BGP extended community number filter, if in use. If the filter is in use then do not match the source routing information to this entry if there is no match between one of the extended community numbers in the source routing information and the value of this filter.')
rtmRedistRedistFlag = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 2, 1, 30), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmRedistRedistFlag.setStatus('current')
if mibBuilder.loadTexts: rtmRedistRedistFlag.setDescription('Flag determining whether or not DC-RTM redistributes routing information from the given source to the given destination.')
rtmRedistMetricConv = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 2, 1, 31), MetricConversion().clone('metricConvSame')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmRedistMetricConv.setStatus('current')
if mibBuilder.loadTexts: rtmRedistMetricConv.setDescription('How to act on the value of the metric in the routing information received from the source to create a value for the metric in the routing information sent to the destination. This field is only used if the redistribution flag is TRUE.')
rtmRedistMetricValue = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 2, 1, 32), Unsigned32().clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmRedistMetricValue.setStatus('current')
if mibBuilder.loadTexts: rtmRedistMetricValue.setDescription("Numerical parameter to use when creating a value for the metric in the routing information sent to the destination based on the supplied metric in the routing information received from the source. This field is only used if the redistribution flag is TRUE and the metric conversion field is set to 'constant', 'scale up', 'scale down' or 'truncate'. If the metric conversion field is 'constant' then the new metric value is just the value of the numerical parameter. If the metric conversion field is 'scale up' then the new metric value is the supplied metric multiplied by the value of the numerical parameter (or 0xffffffff if this is smaller). If the metric conversion method is 'scale down' then the new metric value is the supplied metric divided by the value of the numerical parameter (rounded down to the next integer). The numerical parameter cannot be zero in this case. If the metric conversion field is 'truncate' then the new metric value is the lower value of the supplied metric value and the numerical parameter.")
rtmRedistNwPathType = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 2, 1, 33), PathType().clone('pathTypeNone')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmRedistNwPathType.setStatus('current')
if mibBuilder.loadTexts: rtmRedistNwPathType.setDescription("Type of path to set in routing information sent to destination. This field is only used if the redistribution flag is TRUE. If the information destination filter _info_dest_ is set to 'all' or 'all-incl-connected', the new path type must be set to 'none'. Otherwise it must be set either to 'none' or to a path type which matches the routing information destination filter. For example, a new path type of 'OSPF external type 1' can only be used if the routing information destination filter is set to OSPF.")
rtmRedistNwOspfTag = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 2, 1, 34), OspfTag()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmRedistNwOspfTag.setStatus('current')
if mibBuilder.loadTexts: rtmRedistNwOspfTag.setDescription("Value of OSPF tag to set in routing information sent to destination. This field is only used if the redistribution flag is TRUE and the destination for the routing information is OSPF or 'all' or 'all-incl-connected'.")
rtmRedistOspfPropagate = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 2, 1, 35), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmRedistOspfPropagate.setStatus('current')
if mibBuilder.loadTexts: rtmRedistOspfPropagate.setDescription("Value of OSPF propagate flag to set in routing information sent to destination. This field is only used if the redistribution flag is TRUE and the destination for the routing information is OSPF or 'all' or 'all-incl-connected'.")
rtmRedistAddCommunity = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 2, 1, 36), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmRedistAddCommunity.setStatus('obsolete')
if mibBuilder.loadTexts: rtmRedistAddCommunity.setDescription("Flag determining whether or not DC-RTM adds a BGP community value in routing information sent to the destination. This field is only used if the redistribution flag is TRUE and the destination for the routing information is BGP or 'all' or 'all-incl-connected'.")
rtmRedistNwCommunity = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 2, 1, 37), BgpCommunity().clone(hexValue="00000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmRedistNwCommunity.setStatus('obsolete')
if mibBuilder.loadTexts: rtmRedistNwCommunity.setDescription("Value to use for BGP community number in routing information sent to the destination if the add community flag is TRUE. This field is only used if the redistribution flag is TRUE and the destination for the routing information is BGP or 'all' or 'all-incl-connected'.")
rtmRedistAddExtComm = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 2, 1, 38), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmRedistAddExtComm.setStatus('obsolete')
if mibBuilder.loadTexts: rtmRedistAddExtComm.setDescription("Flag determining whether or not DC-RTM adds a BGP extended community value in routing information sent to the destination. This field is only used if the redistribution flag is TRUE and the destination for the routing information is BGP or 'all' or 'all-incl-connected'.")
rtmRedistNwExtComm = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 2, 1, 39), BgpExtendedCommunity().clone(hexValue="0000000000000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmRedistNwExtComm.setStatus('obsolete')
if mibBuilder.loadTexts: rtmRedistNwExtComm.setDescription("Value to use for BGP extended community number in routing information sent to destination if the add extended community flag is TRUE. This field is only used if the redistribution flag is TRUE and the destination for the routing information is BGP or 'all' or 'all-incl-connected'.")
rtmRedistNwOrigin = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 2, 1, 40), BgpOriginCode().clone('bgpOriginIncomplete')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmRedistNwOrigin.setStatus('current')
if mibBuilder.loadTexts: rtmRedistNwOrigin.setDescription("Value to use for the BGP origin code in the routing information sent to the destination. This field is only used if the redistribution flag is TRUE and the destination for the routing information is BGP or 'all' or 'all-incl-connected'.")
rtmRedistAddMed = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 2, 1, 41), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmRedistAddMed.setStatus('current')
if mibBuilder.loadTexts: rtmRedistAddMed.setDescription("Flag determining whether or not DC-RTM adds a BGP Multi-Exit Discriminator value in routing information sent to the destination. This field is only used if the redistribution flag is TRUE and the destination for the routing information is BGP or 'all' or 'all-incl-connected'.")
rtmRedistNwMed = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 2, 1, 42), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmRedistNwMed.setStatus('current')
if mibBuilder.loadTexts: rtmRedistNwMed.setDescription("Value to use for the BGP Multi-Exit Discriminator in the routing information sent to the destination of the add MED flag is TRUE. This field is only used if the redistribution flag is TRUE and the destination for the routing information is BGP or 'all' or 'all-incl-connected'.")
rtmRedistAddLocalPref = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 2, 1, 43), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmRedistAddLocalPref.setStatus('current')
if mibBuilder.loadTexts: rtmRedistAddLocalPref.setDescription("Flag determining whether or not DC-RTM adds a BGP Local Preference value in routing information sent to the destination. This field is only used if the redistribution flag is TRUE and the destination for the routing information is BGP or 'all' or 'all-incl-connected'.")
rtmRedistNwLocalPref = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 2, 1, 44), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmRedistNwLocalPref.setStatus('current')
if mibBuilder.loadTexts: rtmRedistNwLocalPref.setDescription("Value to use for the BGP Local Preference in the routing information sent to the destination if the add local pref flag is TRUE. This field is only used if the redistribution flag is TRUE and the destination for the routing information is BGP or 'all' or 'all-incl-connected'.")
rtmRedistSetListId = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 2, 1, 45), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmRedistSetListId.setStatus('current')
if mibBuilder.loadTexts: rtmRedistSetListId.setDescription('List identifier for the list of set actions to apply. The list of set actions are defined in the rtmRdstSetFieldTable, and are the group of entries in that table with the rtmRdstSetFieldListId field equal to the list identifier specified here. This field is only used if the redistribution flag is TRUE. A value of 0 indicates no list is specified.')
rtmRedistAddAsLimUpper = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 2, 1, 46), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmRedistAddAsLimUpper.setStatus('current')
if mibBuilder.loadTexts: rtmRedistAddAsLimUpper.setDescription("Flag determining whether or not DC-RTM adds a BGP AS_PATHLIMIT attribute upper bound value to routing information sent to the destination. The destination will automatically add the AS number part of the attribute. This field is only used if the redistribution flag is TRUE and the destination for the routing information is BGP or 'all' or 'all-incl-connected'.")
rtmRedistNwAsLimUpper = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 2, 1, 47), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmRedistNwAsLimUpper.setStatus('current')
if mibBuilder.loadTexts: rtmRedistNwAsLimUpper.setDescription("Value to use for the BGP AS_PATHLIMIT upper bound in the routing information sent to the destination if the rtmRedistAddAsLimUpper flag is TRUE. This field is only used if the redistribution flag is TRUE and the destination for the routing information is BGP or 'all' or 'all-incl-connected'.")
rtmRedistOspfVpnPeCeSupport = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 2, 1, 48), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmRedistOspfVpnPeCeSupport.setStatus('current')
if mibBuilder.loadTexts: rtmRedistOspfVpnPeCeSupport.setDescription('Flag determining whether or not DC-RTM translates between OSPF routes and BGP routes in order to facilitate use of OSPF between provider edge (PE) routers and customer edge (CE) routers in a BGP/MPLS IP VPN. Setting this field to true enables translation between OSPF routes and BGP routes as described in RFC 4577 and draft-ietf-l3vpn-ospfv3-pece-07. This function should only be enabled for OSPF instances for customer VPNs on PE routers. It should be disabled for CE routers, and on PE routers it should be disabled for any OSPF instances for the provider backbone network. The translation between OSPF routes and BGP routes can be overridden by other fields in the redistribution table entry, including rtmRedistNwPathType, rtmRedistMetricConv, rtmRedistMetricValue, rtmRedistAddMed and rtmRedistNwMed. The translation between OSPF routes and BGP routes also depends on route translation performed by OSPF according to the OSPF Domain ID configuration. This field is only used if the redistribution flag is TRUE and the source or destination for the routing information include OSPF and BGP.')
rtmStaticRtTable = MibTable((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 3), )
if mibBuilder.loadTexts: rtmStaticRtTable.setStatus('current')
if mibBuilder.loadTexts: rtmStaticRtTable.setDescription('The table of DC-RTM static routes.')
rtmStaticRtEntry = MibTableRow((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 3, 1), ).setIndexNames((0, "DC-RTM-MIB", "rtmStaticRtFteIndex"), (0, "DC-RTM-MIB", "rtmStaticRtPathType"), (0, "DC-RTM-MIB", "rtmStaticRtDestAddrType"), (0, "DC-RTM-MIB", "rtmStaticRtDestAddr"), (0, "DC-RTM-MIB", "rtmStaticRtDestLen"), (0, "DC-RTM-MIB", "rtmStaticRtNextHopType"), (0, "DC-RTM-MIB", "rtmStaticRtNextHop"), (0, "DC-RTM-MIB", "rtmStaticRtIfIndex"))
if mibBuilder.loadTexts: rtmStaticRtEntry.setStatus('current')
if mibBuilder.loadTexts: rtmStaticRtEntry.setDescription('Information about static routes, containing next hop information or instruction to discard/reject matching packets.')
rtmStaticRtFteIndex = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 3, 1, 1), FteIndex())
if mibBuilder.loadTexts: rtmStaticRtFteIndex.setStatus('current')
if mibBuilder.loadTexts: rtmStaticRtFteIndex.setDescription('The HAF entity index identifying the instance of DC-RTM to which this static route entry applies.')
rtmStaticRtDestAddrType = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 3, 1, 2), InetAddressType())
if mibBuilder.loadTexts: rtmStaticRtDestAddrType.setStatus('current')
if mibBuilder.loadTexts: rtmStaticRtDestAddrType.setDescription('The type of the address used as the destination internetwork address or subnet address. This object must be set to the same value as rtmEntityAddressFamily.')
rtmStaticRtDestAddr = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 3, 1, 3), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(4, 4), ValueSizeConstraint(16, 16), )))
if mibBuilder.loadTexts: rtmStaticRtDestAddr.setStatus('current')
if mibBuilder.loadTexts: rtmStaticRtDestAddr.setDescription('Destination internetwork address or subnet address. The destination prefix length is applied to this value, and to a particular destination address, to determine whether the route applies to the particular address. If the prefix length is L, then applying the length to an address means taking the first L bits of the address.')
rtmStaticRtDestLen = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 128)))
if mibBuilder.loadTexts: rtmStaticRtDestLen.setStatus('current')
if mibBuilder.loadTexts: rtmStaticRtDestLen.setDescription('Prefix length (in bits) to apply to the destination internetwork address or subnet address, to obtain the set of addresses to which this route applies. If the prefix length is L, then applying the length to an address means taking the first L bits of the address.')
rtmStaticRtNextHopType = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 3, 1, 5), InetAddressType())
if mibBuilder.loadTexts: rtmStaticRtNextHopType.setStatus('current')
if mibBuilder.loadTexts: rtmStaticRtNextHopType.setDescription('The type of the address used as the next-hop address for this route. This object must be set to the same value as rtmEntityAddressFamily, even if the rtmStaticRtNextHop object is set to all zeroes.')
rtmStaticRtNextHop = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 3, 1, 6), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(4, 4), ValueSizeConstraint(16, 16), )))
if mibBuilder.loadTexts: rtmStaticRtNextHop.setStatus('current')
if mibBuilder.loadTexts: rtmStaticRtNextHop.setDescription("The next-hop IP address, if any. If rtmStaticRtAction is 'forward', there may or may not be a next-hop IP address. A next-hop IP address is not required if an output interface index is specified (in other words, if rtmStaticRtIfIndex is non-zero). It is possible to supply a next-hop IP address, but to set the output interface index (rtmStaticRtIfIndex) to zero. In this case - the next hop is referred to as a loose next hop - the next-hop address does not need to be on a directly connected device - if DC-RTM cannot find a route to the specified next-hop address, it does not return the static route on the rtmRouteTable, it does not redistribute the static route to routing protocol managers, and it does not program the static route to a forwarding table (unless the forwarding table has registered to receive loose next hops) or to a partner that is querying route information (such as BGP or PIM). If rtmStaticRtAction is not 'forward', there is no next-hop IP address. If there is no next-hop IP address, the rtmStaticRtNextHop object is set to all zeroes.")
rtmStaticRtIfIndex = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 3, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)))
if mibBuilder.loadTexts: rtmStaticRtIfIndex.setStatus('current')
if mibBuilder.loadTexts: rtmStaticRtIfIndex.setDescription('This field contains the network interface index of the interface configured to reach the next hop. If 0, then the rtmStaticRtOutIfIndex is determined by a subnet match of the configured next hop IP address. Otherwise, the rtmStaticRtOutIfIndex is equal to this value.')
rtmStaticRtOutIfIndex = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 3, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtmStaticRtOutIfIndex.setStatus('current')
if mibBuilder.loadTexts: rtmStaticRtOutIfIndex.setDescription('If the action to perform is to forward the packet, this field contains the network interface index of the output network interface used to reach the next hop. It is not defined for other action values.')
rtmStaticRtRowStatus = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 3, 1, 9), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmStaticRtRowStatus.setStatus('current')
if mibBuilder.loadTexts: rtmStaticRtRowStatus.setDescription('Used to create and delete a DC-RTM static route.')
rtmStaticRtAdminStat = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 3, 1, 10), AdminStatus().clone('adminStatusDown')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmStaticRtAdminStat.setStatus('current')
if mibBuilder.loadTexts: rtmStaticRtAdminStat.setDescription('The administrative state of the static route. The row status by itself does not indicate whether the static route definition is currently active. The row must be defined and the administrative status must be up. This enables a MIB agent to turn off a particular static route without deleting it from the table altogether.')
rtmStaticRtOverride = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 3, 1, 11), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmStaticRtOverride.setStatus('current')
if mibBuilder.loadTexts: rtmStaticRtOverride.setDescription("The administrative distance for this route is by default taken to be the administrative distance configured in the DC-RTM entity table associated with the route's path type (rtmStaticRtPathType). If rtmStaticRtOverride is set to AMB_TRUE, this admin distance is overridden and we use the rtmStaticRtAdminDist instead. The lower the administrative distance for a given route, the more likely that route is to be used by DC-RTM as the active route for the given destination. See the DC-RTM Architecture Guide for more information about the use of administrative distances.")
rtmStaticRtAdminDist = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 3, 1, 12), AdminDistance().clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmStaticRtAdminDist.setStatus('current')
if mibBuilder.loadTexts: rtmStaticRtAdminDist.setDescription('Administrative distance for static route, if overriding the default administrative distance for this route given in the DC-RTM entity table. This field is not defined if overriding is not being performed. The lower the administrative distance for a given route, the more likely that route is to be used by DC-RTM as the active route for the given destination. See the DC-RTM Architecture Guide for more information about the use of administrative distances.')
rtmStaticRtAction = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 3, 1, 13), RouteAction().clone('routeActionForward')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmStaticRtAction.setStatus('current')
if mibBuilder.loadTexts: rtmStaticRtAction.setDescription("The action to perform on receipt of a packet to the specified destination. If the action type is 'forward', one or both of the rtmStaticRtNextHop and rtmStaticRtIfIndex objects must be set to a non-zero value. If the action type is not 'forward', the rtmStaticRtNextHop and rtmStaticRtIfIndex objects must both be set to zero. The action type cannot be set to 'tunnel' for a static route. The value of this field must not be changed while the row status of this MIB is AMB_ROW_STATUS_ACTIVE.")
rtmStaticRtFwdAddrType = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 3, 1, 14), InetAddressType().clone('ipv4')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmStaticRtFwdAddrType.setStatus('current')
if mibBuilder.loadTexts: rtmStaticRtFwdAddrType.setDescription('The type of the address used as the forwarding address for this route. This object must be set to the same value as rtmEntityAddressFamily.')
rtmStaticRtForwardingAddr = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 3, 1, 15), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(4, 4), ValueSizeConstraint(16, 16), )).clone(hexValue="00000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmStaticRtForwardingAddr.setStatus('current')
if mibBuilder.loadTexts: rtmStaticRtForwardingAddr.setDescription('Forwarding address to advertise for this route. The value of this field must not be changed while the row status of this MIB is AMB_ROW_STATUS_ACTIVE.')
rtmStaticRtPathType = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 3, 1, 16), PathType())
if mibBuilder.loadTexts: rtmStaticRtPathType.setStatus('current')
if mibBuilder.loadTexts: rtmStaticRtPathType.setDescription('Type of path associated with this route.')
rtmStaticRtUsePathCost = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 3, 1, 17), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmStaticRtUsePathCost.setStatus('current')
if mibBuilder.loadTexts: rtmStaticRtUsePathCost.setDescription('Used to enable/disable the usage of the path cost metric for this route')
rtmStaticRtPathCost = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 3, 1, 18), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmStaticRtPathCost.setStatus('current')
if mibBuilder.loadTexts: rtmStaticRtPathCost.setDescription('Path cost for this static route, if overriding the default setting. This field is not used if rtmStaticRtUsePathCost is set to AMB_FALSE. When deciding which path for a given route should be marked as active, the administrative distance is considered first. If multiple paths have the same administrative distance, the path with the lowest path cost is chosen as the active path. If multiple paths have the same path cost, one or more paths may be marked as active depending on the value of rtmEntityEqlCostOpt.')
rtmStaticRtUserData = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 3, 1, 19), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmStaticRtUserData.setStatus('current')
if mibBuilder.loadTexts: rtmStaticRtUserData.setDescription('User data for this static route. This user data is passed to the QCRT_USER_STATIC_RT_EVENT user exit.')
rtmStaticRtLooseNextHop = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 3, 1, 20), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtmStaticRtLooseNextHop.setStatus('current')
if mibBuilder.loadTexts: rtmStaticRtLooseNextHop.setDescription('This object indicates whether this static route contains a loose next hop (see rtmStaticRtNextHop for details).')
rtmStaticRtBfdSupport = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 3, 1, 21), RtmBfdSupport().clone('desired')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmStaticRtBfdSupport.setStatus('current')
if mibBuilder.loadTexts: rtmStaticRtBfdSupport.setDescription("This object indicates whether DC-RTM should use BFD to check IP reachability to the static route's next hop. DC-RTM will only attempt to use BFD if rtmEntityBfdIndex is non-zero and the static route has rtmStaticRtAction set to 'forward' and rtmStaticRtNextHop set to a non-null IP address. This object should be set as follows. - Set to 'none' if BFD is not required for this static route. - Set to 'desired' if it is not known whether the next hop router supports BFD. DC-RTM will use BFD for reachability checking if BFD is able to contact the next hop router. If the BFD session fails, the static route will be removed from the forwarding table and will not be used for redistribution. - Set to 'required' if it is known that the next hop router supports BFD. DC-RTM will use BFD to check reachability of the next hop. If BFD is unable to contact the next hop router or if the BFD session fails, the static route will be removed from the forwarding table and will not be used for redistribution. The current state of the BFD session is indicated by rtmStaticRtBfdStatus.")
rtmStaticRtBfdStatus = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 3, 1, 22), BfdSessionStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtmStaticRtBfdStatus.setStatus('current')
if mibBuilder.loadTexts: rtmStaticRtBfdStatus.setDescription('The current BFD session state for this static route.')
rtmMjTable = MibTable((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 4), )
if mibBuilder.loadTexts: rtmMjTable.setStatus('current')
if mibBuilder.loadTexts: rtmMjTable.setDescription('This table controls which entities DC-RTM should join to as master. Each join is represented by a row in this table. The status of each join is represented by a read-only object within each row.')
rtmMjEntry = MibTableRow((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 4, 1), ).setIndexNames((0, "DC-RTM-MIB", "rtmMjRtmFteIndex"), (0, "DC-RTM-MIB", "rtmMjSlaveFteId"), (0, "DC-RTM-MIB", "rtmMjSlaveType"))
if mibBuilder.loadTexts: rtmMjEntry.setStatus('current')
if mibBuilder.loadTexts: rtmMjEntry.setDescription('Represents a join for which DC-RTM is master.')
rtmMjRtmFteIndex = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 4, 1, 1), FteIndex())
if mibBuilder.loadTexts: rtmMjRtmFteIndex.setStatus('current')
if mibBuilder.loadTexts: rtmMjRtmFteIndex.setDescription('The HAF entity index identifying the instance of DC-RTM to which this master join table entry applies.')
rtmMjSlaveFteId = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 4, 1, 2), FteIndex())
if mibBuilder.loadTexts: rtmMjSlaveFteId.setStatus('current')
if mibBuilder.loadTexts: rtmMjSlaveFteId.setDescription('The HAF entity index identifying the instance of the slave entity to which this master join table entry applies. This index is used in the join user data, to enable FTI-specific code within System Manager to select a suitable slave entity instance.')
rtmMjSlaveType = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 4, 1, 8), AriPrtnrType())
if mibBuilder.loadTexts: rtmMjSlaveType.setStatus('current')
if mibBuilder.loadTexts: rtmMjSlaveType.setDescription('The type of entity which the slave side of this join should be. This value is used in the join user data, to enable FTI-specific code within System Manager to select a suitable slave entity instance.')
rtmMjIfType = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 4, 1, 3), InterfaceType().clone('ifActiveRoutes')).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtmMjIfType.setStatus('current')
if mibBuilder.loadTexts: rtmMjIfType.setDescription('Identifies the interface type for this master join.')
rtmMjRowStatus = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 4, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmMjRowStatus.setStatus('current')
if mibBuilder.loadTexts: rtmMjRowStatus.setDescription('The row status for this DC-RTM master join table entry, used to create and destroy table entries.')
rtmMjAdminStatus = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 4, 1, 5), AdminStatus().clone('adminStatusUp')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmMjAdminStatus.setStatus('current')
if mibBuilder.loadTexts: rtmMjAdminStatus.setDescription('The administrative status of this master join, used to start and stop the join.')
rtmMjOperStatus = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 4, 1, 6), OperStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtmMjOperStatus.setStatus('current')
if mibBuilder.loadTexts: rtmMjOperStatus.setDescription('The current operational status of this master join.')
rtmMjJoinStatus = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 4, 1, 7), RtmMjStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtmMjJoinStatus.setStatus('current')
if mibBuilder.loadTexts: rtmMjJoinStatus.setDescription('The status of the master join.')
rtmMjSafi = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 4, 1, 9), InetSubAddressType().clone('none')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmMjSafi.setStatus('current')
if mibBuilder.loadTexts: rtmMjSafi.setDescription('Sub-address family indicating the type of routes that can be queried on the join. This field is only relevant for joins to BGP or PIM. Allowed values are none, unicast and multicast. An example use is where unicast and multicast topologies are different. In this scenario the system requires separate RTM instances to hold the unicast and multicast routing tables. In this case, ARI queries from PIM relate to the multicast routing table, but ARI queries from BGP could be either for the unicast or multicast routing table. If only a single sub-address family need be supported then this can be left with the default value of none. The value of this field must not be changed while the row status of this MIB is AMB_ROW_STATUS_ACTIVE and the admin status is AMB_ADMIN_STATUS_UP.')
rtmSjTable = MibTable((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 5), )
if mibBuilder.loadTexts: rtmSjTable.setStatus('current')
if mibBuilder.loadTexts: rtmSjTable.setDescription('This table contains information on joins for which DC-RTM entities are acting as slaves. Each row in this table represents one slave join in a particular DC-RTM entity.')
rtmSjEntry = MibTableRow((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 5, 1), ).setIndexNames((0, "DC-RTM-MIB", "rtmSjRtmFteIndex"), (0, "DC-RTM-MIB", "rtmSjRtmRpmIndex"))
if mibBuilder.loadTexts: rtmSjEntry.setStatus('current')
if mibBuilder.loadTexts: rtmSjEntry.setDescription('Represents a join for which DC-RTM is slave.')
rtmSjRtmFteIndex = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 5, 1, 1), FteIndex())
if mibBuilder.loadTexts: rtmSjRtmFteIndex.setStatus('current')
if mibBuilder.loadTexts: rtmSjRtmFteIndex.setDescription('The HAF entity index identifying the instance of DC-RTM to which this slave join table entry applies.')
rtmSjRtmRpmIndex = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 5, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)))
if mibBuilder.loadTexts: rtmSjRtmRpmIndex.setStatus('current')
if mibBuilder.loadTexts: rtmSjRtmRpmIndex.setDescription('Internal index used by DC-RTM for this RPM.')
rtmSjIfType = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 5, 1, 3), InterfaceType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtmSjIfType.setStatus('current')
if mibBuilder.loadTexts: rtmSjIfType.setDescription('Identifies the interface type for this master join.')
rtmSjMastFteType = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 5, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtmSjMastFteType.setStatus('current')
if mibBuilder.loadTexts: rtmSjMastFteType.setDescription('Additional information about the type of master entity which created the join, where this is not uniquely defined by the interface type. For joins to Routing Protocol Managers using the Routing Protocol Input interface, this field contains the routing protocol type.')
rtmSjMastFteId = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 5, 1, 5), FteIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtmSjMastFteId.setStatus('current')
if mibBuilder.loadTexts: rtmSjMastFteId.setDescription('The HAF entity index identifying the instance of the master entity to which this slave join table entry applies.')
rtmSjJoinStatus = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 5, 1, 6), RtmSjStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtmSjJoinStatus.setStatus('current')
if mibBuilder.loadTexts: rtmSjJoinStatus.setDescription('The status of the slave join.')
rtmRouteTable = MibTable((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 6), )
if mibBuilder.loadTexts: rtmRouteTable.setReference('RFC 1213 Section 6.6, The IP Group')
if mibBuilder.loadTexts: rtmRouteTable.setStatus('current')
if mibBuilder.loadTexts: rtmRouteTable.setDescription("This entity's IP Routing table. A route is present in this table if and only if it has been programmed to an Active Routes Interface consumer. This may be a consumer that asks for all route updates (such as a forwarding table), or it may be a consumer that queries information about specific routes (such as BGP or PIM).")
rtmRouteEntry = MibTableRow((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 6, 1), ).setIndexNames((0, "DC-RTM-MIB", "rtmRouteFteIndex"), (0, "DC-RTM-MIB", "rtmRouteDestType"), (0, "DC-RTM-MIB", "rtmRouteDest"), (0, "DC-RTM-MIB", "rtmRouteDestLen"), (0, "DC-RTM-MIB", "rtmRouteTos"), (0, "DC-RTM-MIB", "rtmRouteNextHopType"), (0, "DC-RTM-MIB", "rtmRouteNextHop"), (0, "DC-RTM-MIB", "rtmRouteIfIndex"))
if mibBuilder.loadTexts: rtmRouteEntry.setStatus('current')
if mibBuilder.loadTexts: rtmRouteEntry.setDescription('A particular route to a particular destina- tion, under a particular policy.')
rtmRouteFteIndex = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 6, 1, 1), FteIndex())
if mibBuilder.loadTexts: rtmRouteFteIndex.setStatus('current')
if mibBuilder.loadTexts: rtmRouteFteIndex.setDescription('The HAF entity index identifying the instance of DC-RTM to which this static route entry applies.')
rtmRouteStatus = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 6, 1, 2), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtmRouteStatus.setStatus('current')
if mibBuilder.loadTexts: rtmRouteStatus.setDescription('The row status variable, used according to row installation and removal conventions.')
rtmRouteDestType = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 6, 1, 3), InetAddressType())
if mibBuilder.loadTexts: rtmRouteDestType.setStatus('current')
if mibBuilder.loadTexts: rtmRouteDestType.setDescription('The type of the address used as the destination IP address for this route.')
rtmRouteDest = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 6, 1, 4), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(4, 4), ValueSizeConstraint(16, 16), )))
if mibBuilder.loadTexts: rtmRouteDest.setStatus('current')
if mibBuilder.loadTexts: rtmRouteDest.setDescription('Destination internetwork address or subnet address. The destination prefix length is applied to this value, and to a particular destination address, to determine whether the route applies to the particular address. If the prefix length is L, then applying the length to an address means taking the first L bits of the address.')
rtmRouteDestLen = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 6, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 128)))
if mibBuilder.loadTexts: rtmRouteDestLen.setStatus('current')
if mibBuilder.loadTexts: rtmRouteDestLen.setDescription('Prefix length (in bits) to apply to the rtmRouteDest object, to obtain the set of addresses to which this route applies. If the prefix length is L, then applying the length to an address means taking the first L bits of the address.')
rtmRouteTos = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 6, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)))
if mibBuilder.loadTexts: rtmRouteTos.setStatus('current')
if mibBuilder.loadTexts: rtmRouteTos.setDescription('The policy specifier is the IP TOS Field. The encoding of IP TOS is as specified by the following convention. Zero indicates the default path if no more specific policy applies. +=====+=====+=====+=====+=====+=====+=====+=====+ | | | | | PRECEDENCE | TYPE OF SERVICE | 0 | | | | | +=====+=====+=====+=====+=====+=====+=====+=====+ IP TOS IP TOS Field Policy Field Policy Contents Code Contents Code 0 0 0 0 ==> 0 0 0 0 1 ==> 2 0 0 1 0 ==> 4 0 0 1 1 ==> 6 0 1 0 0 ==> 8 0 1 0 1 ==> 10 0 1 1 0 ==> 12 0 1 1 1 ==> 14 1 0 0 0 ==> 16 1 0 0 1 ==> 18 1 0 1 0 ==> 20 1 0 1 1 ==> 22 1 1 0 0 ==> 24 1 1 0 1 ==> 26 1 1 1 0 ==> 28 1 1 1 1 ==> 30 RTM always returns a default value of 0 for this field.')
rtmRouteNextHopType = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 6, 1, 7), InetAddressType())
if mibBuilder.loadTexts: rtmRouteNextHopType.setStatus('current')
if mibBuilder.loadTexts: rtmRouteNextHopType.setDescription('The type of the address used as the next-hop address for this route.')
rtmRouteNextHop = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 6, 1, 8), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(4, 4), ValueSizeConstraint(16, 16), )))
if mibBuilder.loadTexts: rtmRouteNextHop.setStatus('current')
if mibBuilder.loadTexts: rtmRouteNextHop.setDescription('On remote routes, the address of the next system en route; Otherwise, zero.')
rtmRouteIfIndex = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 6, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)))
if mibBuilder.loadTexts: rtmRouteIfIndex.setStatus('current')
if mibBuilder.loadTexts: rtmRouteIfIndex.setDescription('The ifIndex value which identifies the local interface through which the next hop of this route should be reached.')
rtmRouteType = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 6, 1, 10), RouteType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtmRouteType.setStatus('current')
if mibBuilder.loadTexts: rtmRouteType.setDescription('The type of route. local(3) refers to a route for which the destination is a local IP address or for which the next hop is the final destination. This includes routes to local IP addresses and routes to directly connected IP addresses or subnets. remote(4) refers to a route for which the next hop is not the final destination. reject (2) refers to a route which, if matched, discards the message as unreachable. This is used in some protocols as a means of correctly aggregating routes.')
rtmRouteProto = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 6, 1, 11), IANAipRouteProtocol()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtmRouteProto.setStatus('current')
if mibBuilder.loadTexts: rtmRouteProto.setDescription('The routing mechanism via which this route was learned. Inclusion of values for gateway routing protocols is not intended to imply that hosts should support those protocols.')
rtmRouteAge = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 6, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtmRouteAge.setStatus('current')
if mibBuilder.loadTexts: rtmRouteAge.setDescription("The number of seconds since this route was last updated or otherwise determined to be correct. Note that no semantics of 'too old' can be implied except through knowledge of the routing protocol by which the route was learned. This age is only accurate for entries which are less that 49 days old.")
rtmRouteInfo = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 6, 1, 13), RouteInfo().clone('none')).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtmRouteInfo.setStatus('current')
if mibBuilder.loadTexts: rtmRouteInfo.setDescription("A reference to MIB definitions specific to the particular routing protocol which is responsible for this route, as determined by the value specified in the route's rtmRouteProto value. RTM returns the following. - For OSPF, an integer representation of the OID which is required by RFC 2096. - For ISIS, an integer representation of the types of route to IP reachable addresses.")
rtmRouteNextHopAS = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 6, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtmRouteNextHopAS.setStatus('current')
if mibBuilder.loadTexts: rtmRouteNextHopAS.setDescription("The Autonomous System Number of the Next Hop. The semantics of this object are determined by the routing-protocol specified in the route's rtmRouteProto value. When this object is unknown or not relevant its value should be set to zero.")
rtmRouteMetric1 = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 6, 1, 15), Integer32().clone(-1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtmRouteMetric1.setStatus('current')
if mibBuilder.loadTexts: rtmRouteMetric1.setDescription("The primary routing metric for this route. The semantics of this metric are determined by the routing-protocol specified in the route's rtmRouteProto value. If this metric is not used, its value should be set to -1.")
rtmRouteMetric2 = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 6, 1, 16), Integer32().clone(-1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtmRouteMetric2.setStatus('current')
if mibBuilder.loadTexts: rtmRouteMetric2.setDescription("An alternate routing metric for this route. The semantics of this metric are determined by the routing-protocol specified in the route's rtmRouteProto value. If this metric is not used, its value should be set to -1.")
rtmRouteMetric3 = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 6, 1, 17), Integer32().clone(-1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtmRouteMetric3.setStatus('current')
if mibBuilder.loadTexts: rtmRouteMetric3.setDescription("An alternate routing metric for this route. The semantics of this metric are determined by the routing-protocol specified in the route's rtmRouteProto value. If this metric is not used, its value should be set to -1.")
rtmRouteMetric4 = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 6, 1, 18), Integer32().clone(-1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtmRouteMetric4.setStatus('current')
if mibBuilder.loadTexts: rtmRouteMetric4.setDescription("An alternate routing metric for this route. The semantics of this metric are determined by the routing-protocol specified in the route's rtmRouteProto value. If this metric is not used, its value should be set to -1.")
rtmRouteMetric5 = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 6, 1, 19), Integer32().clone(-1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtmRouteMetric5.setStatus('current')
if mibBuilder.loadTexts: rtmRouteMetric5.setDescription("An alternate routing metric for this route. The semantics of this metric are determined by the routing-protocol specified in the route's rtmRouteProto value. If this metric is not used, its value should be set to -1.")
rtmRouteConnected = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 6, 1, 20), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtmRouteConnected.setStatus('current')
if mibBuilder.loadTexts: rtmRouteConnected.setDescription("Indicates whether the route destination is directly connected. A directly connected route can be reached without going through any IP routers. Route destinations that are local IP addresses are not considered to be directly connected. This field can only be true if rtmRouteType is set to 'local'.")
rtmRouteXCIndex = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 6, 1, 21), MplsIndexType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtmRouteXCIndex.setReference('RFC 3813 - Multiprotocol Label Switching (MPLS) Label Switching Router (LSR) Management Information base (MIB), C. Srinivasan, A. Vishwanathan, and T. Nadeau, June 2004')
if mibBuilder.loadTexts: rtmRouteXCIndex.setStatus('current')
if mibBuilder.loadTexts: rtmRouteXCIndex.setDescription('Index into mplsXCTable that identifies which cross- connect entry is associated with this route entry by containing the mplsXCIndex of that cross-connect entry. This field is only valid for a VPN BGP route where rtmRouteType is remote and rtmRouteProto is bgp. Where valid, a zero value for this field indicates that a label stack is not associated with this route entry. This can be the case because the label bindings have not yet been established, or because some change in the agent has removed them.')
rtmRouteLocalDestIfIndex = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 6, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtmRouteLocalDestIfIndex.setStatus('current')
if mibBuilder.loadTexts: rtmRouteLocalDestIfIndex.setDescription('If the route destination is a local IP address then this is the interface index that the local IP address is assigned to. Otherwise this field is zero.')
rtmRibTable = MibTable((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 7), )
if mibBuilder.loadTexts: rtmRibTable.setStatus('current')
if mibBuilder.loadTexts: rtmRibTable.setDescription("Read-only copy of this entity's Routing Information Base. This is the complete set of routes known by DC-RTM and is a superset of the routes accessible through the rtmRouteTable (which accesses only the active routes from the Forwarding Information Base).")
rtmRibEntry = MibTableRow((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 7, 1), ).setIndexNames((0, "DC-RTM-MIB", "rtmRibFteIndex"), (0, "DC-RTM-MIB", "rtmRibDestType"), (0, "DC-RTM-MIB", "rtmRibDest"), (0, "DC-RTM-MIB", "rtmRibDestLen"), (0, "DC-RTM-MIB", "rtmRibTos"), (0, "DC-RTM-MIB", "rtmRibNextHopType"), (0, "DC-RTM-MIB", "rtmRibNextHop"), (0, "DC-RTM-MIB", "rtmRibIfIndex"), (0, "DC-RTM-MIB", "rtmRibProto"), (0, "DC-RTM-MIB", "rtmRibRpmIndex"))
if mibBuilder.loadTexts: rtmRibEntry.setStatus('current')
if mibBuilder.loadTexts: rtmRibEntry.setDescription('A particular entry in the Routing Information Base.')
rtmRibFteIndex = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 7, 1, 1), FteIndex())
if mibBuilder.loadTexts: rtmRibFteIndex.setStatus('current')
if mibBuilder.loadTexts: rtmRibFteIndex.setDescription('The HAF entity index identifying the instance of DC-RTM to which this RIB entry applies.')
rtmRibStatus = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 7, 1, 2), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtmRibStatus.setStatus('current')
if mibBuilder.loadTexts: rtmRibStatus.setDescription('The row status variable, used according to row installation and removal conventions.')
rtmRibDestType = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 7, 1, 3), InetAddressType())
if mibBuilder.loadTexts: rtmRibDestType.setStatus('current')
if mibBuilder.loadTexts: rtmRibDestType.setDescription('The type of the address used as the destination IP address for this route.')
rtmRibDest = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 7, 1, 4), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(4, 4), ValueSizeConstraint(16, 16), )))
if mibBuilder.loadTexts: rtmRibDest.setStatus('current')
if mibBuilder.loadTexts: rtmRibDest.setDescription('Destination internetwork address or subnet address. The destination prefix length is applied to this value, and to a particular destination address, to determine whether the route applies to the particular address. If the prefix length is L, then applying the length to an address means taking the first L bits of the address.')
rtmRibDestLen = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 7, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 128)))
if mibBuilder.loadTexts: rtmRibDestLen.setStatus('current')
if mibBuilder.loadTexts: rtmRibDestLen.setDescription('Prefix length (in bits) to apply to the rtmRibDest object, to obtain the set of addresses to which this route applies. If the prefix length is L, then applying the length to an address means taking the first L bits of the address.')
rtmRibTos = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 7, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)))
if mibBuilder.loadTexts: rtmRibTos.setStatus('current')
if mibBuilder.loadTexts: rtmRibTos.setDescription('The policy specifier is the IP TOS Field. The encoding of IP TOS is as specified by the following convention. Zero indicates the default path if no more specific policy applies. +=====+=====+=====+=====+=====+=====+=====+=====+ | | | | | PRECEDENCE | TYPE OF SERVICE | 0 | | | | | +=====+=====+=====+=====+=====+=====+=====+=====+ IP TOS IP TOS Field Policy Field Policy Contents Code Contents Code 0 0 0 0 ==> 0 0 0 0 1 ==> 2 0 0 1 0 ==> 4 0 0 1 1 ==> 6 0 1 0 0 ==> 8 0 1 0 1 ==> 10 0 1 1 0 ==> 12 0 1 1 1 ==> 14 1 0 0 0 ==> 16 1 0 0 1 ==> 18 1 0 1 0 ==> 20 1 0 1 1 ==> 22 1 1 0 0 ==> 24 1 1 0 1 ==> 26 1 1 1 0 ==> 28 1 1 1 1 ==> 30 RTM always returns a default value of 0 for this field.')
rtmRibNextHopType = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 7, 1, 7), InetAddressType())
if mibBuilder.loadTexts: rtmRibNextHopType.setStatus('current')
if mibBuilder.loadTexts: rtmRibNextHopType.setDescription('The type of the address used as the next-hop address for this route.')
rtmRibNextHop = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 7, 1, 8), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(4, 4), ValueSizeConstraint(16, 16), )))
if mibBuilder.loadTexts: rtmRibNextHop.setStatus('current')
if mibBuilder.loadTexts: rtmRibNextHop.setDescription('On remote routes, the address of the next system en route; Otherwise, zero.')
rtmRibIfIndex = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 7, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)))
if mibBuilder.loadTexts: rtmRibIfIndex.setStatus('current')
if mibBuilder.loadTexts: rtmRibIfIndex.setDescription('The ifIndex value which identifies the local interface through which the next hop of this route should be reached.')
rtmRibType = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 7, 1, 10), RouteType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtmRibType.setStatus('current')
if mibBuilder.loadTexts: rtmRibType.setDescription('The type of route. local(3) refers to a route for which the destination is a local IP address or for which the next hop is the final destination. This includes routes to local IP addresses and routes to directly connected IP addresses or subnets. remote(4) refers to a route for which the next hop is not the final destination. reject (2) refers to a route which, if matched, discards the message as unreachable. This is used in some protocols as a means of correctly aggregating routes.')
rtmRibProto = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 7, 1, 11), IANAipRouteProtocol())
if mibBuilder.loadTexts: rtmRibProto.setStatus('current')
if mibBuilder.loadTexts: rtmRibProto.setDescription('The routing mechanism via which this route was learned. Inclusion of values for gateway routing protocols is not intended to imply that hosts should support those protocols.')
rtmRibAge = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 7, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtmRibAge.setStatus('current')
if mibBuilder.loadTexts: rtmRibAge.setDescription("The number of seconds since this route was last updated or otherwise determined to be correct. Note that no semantics of 'too old' can be implied except through knowledge of the routing protocol by which the route was learned. This age is only accurate for entries which are less that 49 days old.")
rtmRibInfo = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 7, 1, 13), RouteInfo().clone('none')).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtmRibInfo.setStatus('current')
if mibBuilder.loadTexts: rtmRibInfo.setDescription("A reference to MIB definitions specific to the particular routing protocol which is responsible for this route, as determined by the value specified in the route's rtmRibProto value. RTM returns the following. - For OSPF, an integer representation of the OID which is required by RFC 2096. - For ISIS, an integer representation of the types of route to IP reachable addresses.")
rtmRibNextHopAS = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 7, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtmRibNextHopAS.setStatus('current')
if mibBuilder.loadTexts: rtmRibNextHopAS.setDescription("The Autonomous System Number of the Next Hop. The semantics of this object are determined by the routing-protocol specified in the route's rtmRibProto value. When this object is unknown or not relevant its value is returned as zero.")
rtmRibMetric1 = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 7, 1, 15), Integer32().clone(-1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtmRibMetric1.setStatus('current')
if mibBuilder.loadTexts: rtmRibMetric1.setDescription("The primary routing metric for this route. The semantics of this metric are determined by the routing-protocol specified in the route's rtmRibProto value. If this metric is not used, its value is returned as -1.")
rtmRibMetric2 = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 7, 1, 16), Integer32().clone(-1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtmRibMetric2.setStatus('current')
if mibBuilder.loadTexts: rtmRibMetric2.setDescription("An alternate routing metric for this route. The semantics of this metric are determined by the routing-protocol specified in the route's rtmRibProto value. If this metric is not used, its value is returned as -1.")
rtmRibMetric3 = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 7, 1, 17), Integer32().clone(-1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtmRibMetric3.setStatus('current')
if mibBuilder.loadTexts: rtmRibMetric3.setDescription("An alternate routing metric for this route. The semantics of this metric are determined by the routing-protocol specified in the route's rtmRibProto value. If this metric is not used, its value is returned as -1.")
rtmRibMetric4 = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 7, 1, 18), Integer32().clone(-1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtmRibMetric4.setStatus('current')
if mibBuilder.loadTexts: rtmRibMetric4.setDescription("An alternate routing metric for this route. The semantics of this metric are determined by the routing-protocol specified in the route's rtmRibProto value. If this metric is not used, its value is returned as -1.")
rtmRibMetric5 = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 7, 1, 19), Integer32().clone(-1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtmRibMetric5.setStatus('current')
if mibBuilder.loadTexts: rtmRibMetric5.setDescription("An alternate routing metric for this route. The semantics of this metric are determined by the routing-protocol specified in the route's rtmRibProto value. If this metric is not used, its value is returned as -1.")
rtmRibFibRoute = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 7, 1, 20), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtmRibFibRoute.setStatus('current')
if mibBuilder.loadTexts: rtmRibFibRoute.setDescription("Flag indicating whether or not this route has been programmed either to a forwarding table, or to a partner that queries route information (such as BGP or PIM). If there is no forwarding table and no partners are querying route information then this object is set to 'false' for every route. If this route has rtmRibLooseNextHop set to 'true', it is possible that RTM knows of more than one explicit next hop to the loose next hop address. If so, RTM programs these explicit next hops separately to a forwarding table (unless the forwarding table registers to receive loose next hops) and to a partner that queries route information; in this case the rtmRibFibRoute flag is set to 'true' if and only if one or more of these explicit next hops has been programmed.")
rtmRibRpmIndex = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 7, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)))
if mibBuilder.loadTexts: rtmRibRpmIndex.setStatus('current')
if mibBuilder.loadTexts: rtmRibRpmIndex.setDescription('The HAF entity index for the RPM that supplied this route, or zero for static routes or automatically configured routes. This is used to distinguish routes in the system where multiple copies of a given protocol (for example BGP) are providing routes to DC-RTM.')
rtmRibConnected = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 7, 1, 22), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtmRibConnected.setStatus('current')
if mibBuilder.loadTexts: rtmRibConnected.setDescription("Indicates whether the route destination is directly connected. A directly connected route can be reached without going through any IP routers. Route destinations that are local IP addresses are not considered to be directly connected. This field can only be true if rtmRibType is set to 'local'.")
rtmRibLooseNextHop = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 7, 1, 23), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtmRibLooseNextHop.setStatus('current')
if mibBuilder.loadTexts: rtmRibLooseNextHop.setDescription("This flag indicates whether DC-RTM considers that the next-hop address for this route is a loose next hop. If DC-RTM sets this object to 'true' then - it must also have set rtmRibType to 'remote' - the next-hop address (rtmRibNextHop) may not be on a directly connected device - if DC-RTM cannot find a route to the next-hop address, it does not return the route on the rtmRouteTable, it does not redistribute the route to routing protocol managers, and it does not program the route to a forwarding table (unless the forwarding table has registered to receive loose next hops) or to a partner that is querying route information (such as BGP or PIM).")
rtmRibLocalDestIfIndex = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 7, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtmRibLocalDestIfIndex.setStatus('current')
if mibBuilder.loadTexts: rtmRibLocalDestIfIndex.setDescription('If the route destination is a local IP address then this is the interface index that the local IP address is assigned to. Otherwise this field is zero.')
rtmRdstSetFieldTable = MibTable((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 8), )
if mibBuilder.loadTexts: rtmRdstSetFieldTable.setStatus('current')
if mibBuilder.loadTexts: rtmRdstSetFieldTable.setDescription('This table defines route attributes which are to be set by redistribution filters. A list of set actions is made up of one or more entries in this table with the same list_id. Actions in a list are applied in increasing set_number order. Each list may be referenced by 0, 1 or more redistribution entries. Only actions which are active at the point where the redistribution entry is being evaluated (i.e. at the point where the route is actually being redistributed) are applied. Also, only those set actions which are relevant to the route being redistributed are applied, so BGP attributes will not be set for a route being redistributed to OSPF.')
rtmRdstSetFieldEntry = MibTableRow((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 8, 1), ).setIndexNames((0, "DC-RTM-MIB", "rtmRdstSetFieldFteIndex"), (0, "DC-RTM-MIB", "rtmRdstSetFieldListId"), (0, "DC-RTM-MIB", "rtmRdstSetFieldNumber"))
if mibBuilder.loadTexts: rtmRdstSetFieldEntry.setStatus('current')
if mibBuilder.loadTexts: rtmRdstSetFieldEntry.setDescription('A particular entry in the Redistribution Set Field table.')
rtmRdstSetFieldFteIndex = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 8, 1, 1), FteIndex())
if mibBuilder.loadTexts: rtmRdstSetFieldFteIndex.setStatus('current')
if mibBuilder.loadTexts: rtmRdstSetFieldFteIndex.setDescription('The HAF entity index identifying the instance of DC-RTM to which this set field entry applies.')
rtmRdstSetFieldListId = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 8, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: rtmRdstSetFieldListId.setStatus('current')
if mibBuilder.loadTexts: rtmRdstSetFieldListId.setDescription('The index of the list of set actions which this action belongs to. It is this identifier which is referenced by the redistribution table entry. A value of 0 is not permitted.')
rtmRdstSetFieldNumber = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 8, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: rtmRdstSetFieldNumber.setStatus('current')
if mibBuilder.loadTexts: rtmRdstSetFieldNumber.setDescription("Identifies this set field entry's position in the list of set field entries with the same list identifier.")
rtmRdstSetFieldRowStatus = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 8, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmRdstSetFieldRowStatus.setStatus('current')
if mibBuilder.loadTexts: rtmRdstSetFieldRowStatus.setDescription('Used to create and delete a DC-RTM set field table entry.')
rtmRdstSetFieldType = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 8, 1, 5), RdstSetFieldType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmRdstSetFieldType.setStatus('current')
if mibBuilder.loadTexts: rtmRdstSetFieldType.setDescription('The type of field set by this set field entry.')
rtmRdstSetFieldValue = MibTableColumn((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 1, 8, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rtmRdstSetFieldValue.setStatus('current')
if mibBuilder.loadTexts: rtmRdstSetFieldValue.setDescription('The value set by this set field entry.')
rtmConformance = MibIdentifier((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 3))
rtmCompliances = MibIdentifier((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 3, 1))
rtmGroups = MibIdentifier((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 3, 2))
rtmCompliance = ModuleCompliance((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 3, 1, 1)).setObjects(("DC-RTM-MIB", "rtmEntityMandatoryGroup"), ("DC-RTM-MIB", "rtmRedistMandatoryGroup"), ("DC-RTM-MIB", "rtmStaticRtMandatoryGroup"), ("DC-RTM-MIB", "rtmMjMandatoryGroup"), ("DC-RTM-MIB", "rtmSjMandatoryGroup"), ("DC-RTM-MIB", "rtmRdstSetFieldMandatoryGroup"), ("DC-RTM-MIB", "rtmNotificationObjectGroup"), ("DC-RTM-MIB", "rtmNotificationEventGroup"), ("DC-RTM-MIB", "rtmEntityGroup"), ("DC-RTM-MIB", "rtmRedistGroup"), ("DC-RTM-MIB", "rtmStaticRtGroup"), ("DC-RTM-MIB", "rtmMjGroup"), ("DC-RTM-MIB", "rtmSjGroup"), ("DC-RTM-MIB", "rtmRouteGroup"), ("DC-RTM-MIB", "rtmRibGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rtmCompliance = rtmCompliance.setStatus('current')
if mibBuilder.loadTexts: rtmCompliance.setDescription('The compliance statement for the DC-RTM module.')
rtmEntityMandatoryGroup = ObjectGroup((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 3, 2, 1)).setObjects(("DC-RTM-MIB", "rtmEntityRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rtmEntityMandatoryGroup = rtmEntityMandatoryGroup.setStatus('current')
if mibBuilder.loadTexts: rtmEntityMandatoryGroup.setDescription('Mandatory objects for the rtmEntityTable.')
rtmEntityGroup = ObjectGroup((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 3, 2, 2)).setObjects(("DC-RTM-MIB", "rtmEntityAdminStat"), ("DC-RTM-MIB", "rtmEntityOperStatus"), ("DC-RTM-MIB", "rtmEntityDsConnctd"), ("DC-RTM-MIB", "rtmEntityDsStatDf"), ("DC-RTM-MIB", "rtmEntityDsOspfInt"), ("DC-RTM-MIB", "rtmEntityDsOspfExt"), ("DC-RTM-MIB", "rtmEntityDsIntBgp"), ("DC-RTM-MIB", "rtmEntityDsExtBgp"), ("DC-RTM-MIB", "rtmEntityDsIsisInt1"), ("DC-RTM-MIB", "rtmEntityDsIsisInt2"), ("DC-RTM-MIB", "rtmEntityDsIsisExt1"), ("DC-RTM-MIB", "rtmEntityDsIsisExt2"), ("DC-RTM-MIB", "rtmEntityDsRip"), ("DC-RTM-MIB", "rtmEntityDsEgp"), ("DC-RTM-MIB", "rtmEntityDsPd"), ("DC-RTM-MIB", "rtmEntityDsHello"), ("DC-RTM-MIB", "rtmEntityDsEsis"), ("DC-RTM-MIB", "rtmEntityDsBbnspfigp"), ("DC-RTM-MIB", "rtmEntityDsIdpr"), ("DC-RTM-MIB", "rtmEntityDsIgrp"), ("DC-RTM-MIB", "rtmEntityDsEigrpSmm"), ("DC-RTM-MIB", "rtmEntityDsIntEigrp"), ("DC-RTM-MIB", "rtmEntityDsEigrpExt"), ("DC-RTM-MIB", "rtmEntityDsUnknown"), ("DC-RTM-MIB", "rtmEntityEqlCostOpt"), ("DC-RTM-MIB", "rtmEntityDelDeadRte"), ("DC-RTM-MIB", "rtmEntityDeadRpmTmr"), ("DC-RTM-MIB", "rtmEntityRouteNumber"), ("DC-RTM-MIB", "rtmEntityAddressFamily"), ("DC-RTM-MIB", "rtmEntityDsDvmrp"), ("DC-RTM-MIB", "rtmEntityI3Index"), ("DC-RTM-MIB", "rtmEntityI3JoinStatus"), ("DC-RTM-MIB", "rtmEntityPartnerWaitTime"), ("DC-RTM-MIB", "rtmEntityStartupTime"), ("DC-RTM-MIB", "rtmEntityRestartTime"), ("DC-RTM-MIB", "rtmEntityFtStateRetained"), ("DC-RTM-MIB", "rtmEntityUseUnidirectionalLinks"), ("DC-RTM-MIB", "rtmEntityBfdIndex"), ("DC-RTM-MIB", "rtmEntityBfdJoinStatus"), ("DC-RTM-MIB", "rtmEntityEnableTrapSupport"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rtmEntityGroup = rtmEntityGroup.setStatus('current')
if mibBuilder.loadTexts: rtmEntityGroup.setDescription('Optional objects for rtmEntityTable.')
rtmRedistMandatoryGroup = ObjectGroup((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 3, 2, 3)).setObjects(("DC-RTM-MIB", "rtmRedistRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rtmRedistMandatoryGroup = rtmRedistMandatoryGroup.setStatus('current')
if mibBuilder.loadTexts: rtmRedistMandatoryGroup.setDescription('Mandatory objects for rtmRedistTable.')
rtmRedistGroup = ObjectGroup((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 3, 2, 4)).setObjects(("DC-RTM-MIB", "rtmRedistAdminStat"), ("DC-RTM-MIB", "rtmRedistPriority"), ("DC-RTM-MIB", "rtmRedistInfoSrc"), ("DC-RTM-MIB", "rtmRedistSrcInstFlt"), ("DC-RTM-MIB", "rtmRedistSrcInst"), ("DC-RTM-MIB", "rtmRedistInfoDest"), ("DC-RTM-MIB", "rtmRedistDestInstFlt"), ("DC-RTM-MIB", "rtmRedistDestInst"), ("DC-RTM-MIB", "rtmRedistAddrFilterType"), ("DC-RTM-MIB", "rtmRedistAddrFilter"), ("DC-RTM-MIB", "rtmRedistAddrFltLen"), ("DC-RTM-MIB", "rtmRedistHopFltValType"), ("DC-RTM-MIB", "rtmRedistHopFltVal"), ("DC-RTM-MIB", "rtmRedistHopFltLen"), ("DC-RTM-MIB", "rtmRedistIfIndexFlt"), ("DC-RTM-MIB", "rtmRedistIfIndex"), ("DC-RTM-MIB", "rtmRedistPathTypeFlt"), ("DC-RTM-MIB", "rtmRedistPathType"), ("DC-RTM-MIB", "rtmRedistOspfAreaFlt"), ("DC-RTM-MIB", "rtmRedistOspfArea"), ("DC-RTM-MIB", "rtmRedistOspfTagFlt"), ("DC-RTM-MIB", "rtmRedistOspfTag"), ("DC-RTM-MIB", "rtmRedistCommunityFlt"), ("DC-RTM-MIB", "rtmRedistCommunity"), ("DC-RTM-MIB", "rtmRedistExtCommFlt"), ("DC-RTM-MIB", "rtmRedistExtComm"), ("DC-RTM-MIB", "rtmRedistRedistFlag"), ("DC-RTM-MIB", "rtmRedistMetricConv"), ("DC-RTM-MIB", "rtmRedistMetricValue"), ("DC-RTM-MIB", "rtmRedistNwPathType"), ("DC-RTM-MIB", "rtmRedistNwOspfTag"), ("DC-RTM-MIB", "rtmRedistOspfPropagate"), ("DC-RTM-MIB", "rtmRedistNwOrigin"), ("DC-RTM-MIB", "rtmRedistAddMed"), ("DC-RTM-MIB", "rtmRedistNwMed"), ("DC-RTM-MIB", "rtmRedistAddLocalPref"), ("DC-RTM-MIB", "rtmRedistNwLocalPref"), ("DC-RTM-MIB", "rtmRedistSetListId"), ("DC-RTM-MIB", "rtmRedistAddAsLimUpper"), ("DC-RTM-MIB", "rtmRedistNwAsLimUpper"), ("DC-RTM-MIB", "rtmRedistOspfVpnPeCeSupport"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rtmRedistGroup = rtmRedistGroup.setStatus('current')
if mibBuilder.loadTexts: rtmRedistGroup.setDescription('Optional objects for rtmRedistTable.')
rtmStaticRtMandatoryGroup = ObjectGroup((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 3, 2, 5)).setObjects(("DC-RTM-MIB", "rtmStaticRtRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rtmStaticRtMandatoryGroup = rtmStaticRtMandatoryGroup.setStatus('current')
if mibBuilder.loadTexts: rtmStaticRtMandatoryGroup.setDescription('Mandatory objects for rtmStaticRtTable.')
rtmStaticRtGroup = ObjectGroup((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 3, 2, 6)).setObjects(("DC-RTM-MIB", "rtmStaticRtAdminStat"), ("DC-RTM-MIB", "rtmStaticRtOverride"), ("DC-RTM-MIB", "rtmStaticRtAdminDist"), ("DC-RTM-MIB", "rtmStaticRtAction"), ("DC-RTM-MIB", "rtmStaticRtFwdAddrType"), ("DC-RTM-MIB", "rtmStaticRtForwardingAddr"), ("DC-RTM-MIB", "rtmStaticRtUsePathCost"), ("DC-RTM-MIB", "rtmStaticRtPathCost"), ("DC-RTM-MIB", "rtmStaticRtUserData"), ("DC-RTM-MIB", "rtmStaticRtLooseNextHop"), ("DC-RTM-MIB", "rtmStaticRtBfdSupport"), ("DC-RTM-MIB", "rtmStaticRtBfdStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rtmStaticRtGroup = rtmStaticRtGroup.setStatus('current')
if mibBuilder.loadTexts: rtmStaticRtGroup.setDescription('Optional objects for rtmStaticRtTable.')
rtmMjMandatoryGroup = ObjectGroup((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 3, 2, 7)).setObjects(("DC-RTM-MIB", "rtmMjRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rtmMjMandatoryGroup = rtmMjMandatoryGroup.setStatus('current')
if mibBuilder.loadTexts: rtmMjMandatoryGroup.setDescription('Mandatory objects for rtmMjTable.')
rtmMjGroup = ObjectGroup((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 3, 2, 8)).setObjects(("DC-RTM-MIB", "rtmMjIfType"), ("DC-RTM-MIB", "rtmMjAdminStatus"), ("DC-RTM-MIB", "rtmMjOperStatus"), ("DC-RTM-MIB", "rtmMjJoinStatus"), ("DC-RTM-MIB", "rtmMjSafi"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rtmMjGroup = rtmMjGroup.setStatus('current')
if mibBuilder.loadTexts: rtmMjGroup.setDescription('Optional objects for rtmMjTable.')
rtmSjMandatoryGroup = ObjectGroup((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 3, 2, 9)).setObjects(("DC-RTM-MIB", "rtmSjIfType"), ("DC-RTM-MIB", "rtmSjMastFteType"), ("DC-RTM-MIB", "rtmSjMastFteId"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rtmSjMandatoryGroup = rtmSjMandatoryGroup.setStatus('current')
if mibBuilder.loadTexts: rtmSjMandatoryGroup.setDescription('Mandatory objects for rtmSjTable.')
rtmSjGroup = ObjectGroup((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 3, 2, 10)).setObjects(("DC-RTM-MIB", "rtmSjJoinStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rtmSjGroup = rtmSjGroup.setStatus('current')
if mibBuilder.loadTexts: rtmSjGroup.setDescription('Optional objects for rtmSjTable.')
rtmRouteGroup = ObjectGroup((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 3, 2, 11)).setObjects(("DC-RTM-MIB", "rtmRouteStatus"), ("DC-RTM-MIB", "rtmRouteType"), ("DC-RTM-MIB", "rtmRouteProto"), ("DC-RTM-MIB", "rtmRouteAge"), ("DC-RTM-MIB", "rtmRouteInfo"), ("DC-RTM-MIB", "rtmRouteNextHopAS"), ("DC-RTM-MIB", "rtmRouteMetric1"), ("DC-RTM-MIB", "rtmRouteMetric2"), ("DC-RTM-MIB", "rtmRouteMetric3"), ("DC-RTM-MIB", "rtmRouteMetric4"), ("DC-RTM-MIB", "rtmRouteMetric5"), ("DC-RTM-MIB", "rtmRouteConnected"), ("DC-RTM-MIB", "rtmRouteXCIndex"), ("DC-RTM-MIB", "rtmRouteLocalDestIfIndex"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rtmRouteGroup = rtmRouteGroup.setStatus('current')
if mibBuilder.loadTexts: rtmRouteGroup.setDescription('Optional objects for rtmRouteTable.')
rtmRibGroup = ObjectGroup((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 3, 2, 12)).setObjects(("DC-RTM-MIB", "rtmRibStatus"), ("DC-RTM-MIB", "rtmRibType"), ("DC-RTM-MIB", "rtmRibAge"), ("DC-RTM-MIB", "rtmRibInfo"), ("DC-RTM-MIB", "rtmRibNextHopAS"), ("DC-RTM-MIB", "rtmRibMetric1"), ("DC-RTM-MIB", "rtmRibMetric2"), ("DC-RTM-MIB", "rtmRibMetric3"), ("DC-RTM-MIB", "rtmRibMetric4"), ("DC-RTM-MIB", "rtmRibMetric5"), ("DC-RTM-MIB", "rtmRibFibRoute"), ("DC-RTM-MIB", "rtmRibConnected"), ("DC-RTM-MIB", "rtmRibLooseNextHop"), ("DC-RTM-MIB", "rtmRibLocalDestIfIndex"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rtmRibGroup = rtmRibGroup.setStatus('current')
if mibBuilder.loadTexts: rtmRibGroup.setDescription('Optional objects for rtmRibTable.')
rtmObsoleteGroup = ObjectGroup((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 3, 2, 13)).setObjects(("DC-RTM-MIB", "rtmRedistAddCommunity"), ("DC-RTM-MIB", "rtmRedistNwCommunity"), ("DC-RTM-MIB", "rtmRedistAddExtComm"), ("DC-RTM-MIB", "rtmRedistNwExtComm"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rtmObsoleteGroup = rtmObsoleteGroup.setStatus('obsolete')
if mibBuilder.loadTexts: rtmObsoleteGroup.setDescription('This group contains obsolete objects.')
rtmRdstSetFieldMandatoryGroup = ObjectGroup((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 3, 2, 14)).setObjects(("DC-RTM-MIB", "rtmRdstSetFieldRowStatus"), ("DC-RTM-MIB", "rtmRdstSetFieldType"), ("DC-RTM-MIB", "rtmRdstSetFieldValue"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rtmRdstSetFieldMandatoryGroup = rtmRdstSetFieldMandatoryGroup.setStatus('current')
if mibBuilder.loadTexts: rtmRdstSetFieldMandatoryGroup.setDescription('Mandatory objects for rtmRdstSetFieldTable.')
rtmNotificationObjectGroup = ObjectGroup((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 3, 2, 15)).setObjects(("DC-RTM-MIB", "rtmStaticRtTrapReason"), ("DC-RTM-MIB", "rtmPathTrapReason"), ("DC-RTM-MIB", "rtmTrapEntityFteIndex"), ("DC-RTM-MIB", "rtmTrapStaticRtDestAddrType"), ("DC-RTM-MIB", "rtmTrapStaticRtDestAddr"), ("DC-RTM-MIB", "rtmTrapStaticRtDestLen"), ("DC-RTM-MIB", "rtmTrapStaticRtNextHopType"), ("DC-RTM-MIB", "rtmTrapStaticRtNextHop"), ("DC-RTM-MIB", "rtmTrapStaticRtIfIndex"), ("DC-RTM-MIB", "rtmTrapRibDestType"), ("DC-RTM-MIB", "rtmTrapRibDest"), ("DC-RTM-MIB", "rtmTrapRibDestLen"), ("DC-RTM-MIB", "rtmTrapRibTos"), ("DC-RTM-MIB", "rtmTrapRibNextHopType"), ("DC-RTM-MIB", "rtmTrapRibNextHop"), ("DC-RTM-MIB", "rtmTrapRibIfIndex"), ("DC-RTM-MIB", "rtmTrapRibProto"), ("DC-RTM-MIB", "rtmTrapRibRpmIndex"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rtmNotificationObjectGroup = rtmNotificationObjectGroup.setStatus('current')
if mibBuilder.loadTexts: rtmNotificationObjectGroup.setDescription('The objects used to record notification parameters.')
rtmTraps = MibIdentifier((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 2, 0))
rtmTrapControl = MibIdentifier((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 2, 1))
rtmStaticRtTrapReason = MibScalar((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eligible", 1), ("ineligible", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtmStaticRtTrapReason.setStatus('current')
if mibBuilder.loadTexts: rtmStaticRtTrapReason.setDescription('Event that caused the trap to be made. Used by the rtmStaticRouteChange trap.')
rtmPathTrapReason = MibScalar((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtmPathTrapReason.setStatus('current')
if mibBuilder.loadTexts: rtmPathTrapReason.setDescription('Event that caused the trap to be made. Used by the rtmPathActivityChange trap.')
rtmTrapEntityFteIndex = MibScalar((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 2, 1, 3), FteIndex()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: rtmTrapEntityFteIndex.setStatus('current')
if mibBuilder.loadTexts: rtmTrapEntityFteIndex.setDescription('Version of rtmEntityFteIndex used for traps.')
rtmTrapStaticRtDestAddrType = MibScalar((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 2, 1, 4), InetAddressType()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: rtmTrapStaticRtDestAddrType.setStatus('current')
if mibBuilder.loadTexts: rtmTrapStaticRtDestAddrType.setDescription('Version of rtmStaticRtDestAddrType used for traps.')
rtmTrapStaticRtDestAddr = MibScalar((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 2, 1, 5), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(4, 4), ValueSizeConstraint(16, 16), ))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: rtmTrapStaticRtDestAddr.setStatus('current')
if mibBuilder.loadTexts: rtmTrapStaticRtDestAddr.setDescription('Version of rtmStaticRtDestAddr used for traps.')
rtmTrapStaticRtDestLen = MibScalar((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 128))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: rtmTrapStaticRtDestLen.setStatus('current')
if mibBuilder.loadTexts: rtmTrapStaticRtDestLen.setDescription('Version of rtmStaticRtDestLen used for traps.')
rtmTrapStaticRtNextHopType = MibScalar((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 2, 1, 7), InetAddressType()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: rtmTrapStaticRtNextHopType.setStatus('current')
if mibBuilder.loadTexts: rtmTrapStaticRtNextHopType.setDescription('Version of rtmStaticRtNextHopType used for traps.')
rtmTrapStaticRtNextHop = MibScalar((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 2, 1, 8), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(4, 4), ValueSizeConstraint(16, 16), ))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: rtmTrapStaticRtNextHop.setStatus('current')
if mibBuilder.loadTexts: rtmTrapStaticRtNextHop.setDescription('Version of rtmStaticRtNextHop used for traps.')
rtmTrapStaticRtIfIndex = MibScalar((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: rtmTrapStaticRtIfIndex.setStatus('current')
if mibBuilder.loadTexts: rtmTrapStaticRtIfIndex.setDescription('Version of rtmStaticRtIfIndex used for traps.')
rtmTrapRibDestType = MibScalar((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 2, 1, 10), InetAddressType()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: rtmTrapRibDestType.setStatus('current')
if mibBuilder.loadTexts: rtmTrapRibDestType.setDescription('Version of rtmRibDestType used for traps.')
rtmTrapRibDest = MibScalar((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 2, 1, 11), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(4, 4), ValueSizeConstraint(16, 16), ))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: rtmTrapRibDest.setStatus('current')
if mibBuilder.loadTexts: rtmTrapRibDest.setDescription('Version of rtmRibDest used for traps.')
rtmTrapRibDestLen = MibScalar((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 2, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 128))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: rtmTrapRibDestLen.setStatus('current')
if mibBuilder.loadTexts: rtmTrapRibDestLen.setDescription('Version of rtmRibDestLen used for traps.')
rtmTrapRibTos = MibScalar((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 2, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: rtmTrapRibTos.setStatus('current')
if mibBuilder.loadTexts: rtmTrapRibTos.setDescription('Version of rtmRibTos used for traps.')
rtmTrapRibNextHopType = MibScalar((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 2, 1, 14), InetAddressType()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: rtmTrapRibNextHopType.setStatus('current')
if mibBuilder.loadTexts: rtmTrapRibNextHopType.setDescription('Version of rtmRibNextHopType used for traps.')
rtmTrapRibNextHop = MibScalar((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 2, 1, 15), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(4, 4), ValueSizeConstraint(16, 16), ))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: rtmTrapRibNextHop.setStatus('current')
if mibBuilder.loadTexts: rtmTrapRibNextHop.setDescription('Version of rtmRibNextHop used for traps.')
rtmTrapRibIfIndex = MibScalar((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 2, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: rtmTrapRibIfIndex.setStatus('current')
if mibBuilder.loadTexts: rtmTrapRibIfIndex.setDescription('Version of rtmRibIfIndex used for traps.')
rtmTrapRibProto = MibScalar((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 2, 1, 17), IANAipRouteProtocol()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: rtmTrapRibProto.setStatus('current')
if mibBuilder.loadTexts: rtmTrapRibProto.setDescription('Version of rtmRibProto used for traps.')
rtmTrapRibRpmIndex = MibScalar((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 2, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: rtmTrapRibRpmIndex.setStatus('current')
if mibBuilder.loadTexts: rtmTrapRibRpmIndex.setDescription('Version of rtmRibRpmIndex used for traps.')
rtmOperStateChange = NotificationType((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 2, 0, 1)).setObjects(("DC-RTM-MIB", "rtmTrapEntityFteIndex"), ("DC-RTM-MIB", "rtmEntityOperStatus"))
if mibBuilder.loadTexts: rtmOperStateChange.setStatus('current')
if mibBuilder.loadTexts: rtmOperStateChange.setDescription("DC-RTM generates this trap when the operational state of RTM enters 'up', 'down' or 'act_failed' state.")
rtmStaticRouteChange = NotificationType((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 2, 0, 2)).setObjects(("DC-RTM-MIB", "rtmTrapEntityFteIndex"), ("DC-RTM-MIB", "rtmTrapStaticRtDestAddrType"), ("DC-RTM-MIB", "rtmTrapStaticRtDestAddr"), ("DC-RTM-MIB", "rtmTrapStaticRtDestLen"), ("DC-RTM-MIB", "rtmTrapStaticRtNextHopType"), ("DC-RTM-MIB", "rtmTrapStaticRtNextHop"), ("DC-RTM-MIB", "rtmTrapStaticRtIfIndex"), ("DC-RTM-MIB", "rtmStaticRtTrapReason"), ("DC-RTM-MIB", "rtmStaticRtBfdSupport"), ("DC-RTM-MIB", "rtmStaticRtBfdStatus"))
if mibBuilder.loadTexts: rtmStaticRouteChange.setStatus('current')
if mibBuilder.loadTexts: rtmStaticRouteChange.setDescription('DC-RTM generates this trap when a static route becomes eligible or ineligible for installation in the FIB.')
rtmPathActivityChange = NotificationType((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 2, 0, 3)).setObjects(("DC-RTM-MIB", "rtmTrapEntityFteIndex"), ("DC-RTM-MIB", "rtmTrapRibDestType"), ("DC-RTM-MIB", "rtmTrapRibDest"), ("DC-RTM-MIB", "rtmTrapRibDestLen"), ("DC-RTM-MIB", "rtmTrapRibTos"), ("DC-RTM-MIB", "rtmTrapRibNextHopType"), ("DC-RTM-MIB", "rtmTrapRibNextHop"), ("DC-RTM-MIB", "rtmTrapRibIfIndex"), ("DC-RTM-MIB", "rtmTrapRibProto"), ("DC-RTM-MIB", "rtmTrapRibRpmIndex"), ("DC-RTM-MIB", "rtmPathTrapReason"))
if mibBuilder.loadTexts: rtmPathActivityChange.setStatus('current')
if mibBuilder.loadTexts: rtmPathActivityChange.setDescription('DC-RTM generates this trap when a path becomes active or inactive.')
rtmNotificationEventGroup = NotificationGroup((1, 2, 826, 0, 1, 1578918, 5, 61, 1, 3, 2, 16)).setObjects(("DC-RTM-MIB", "rtmOperStateChange"), ("DC-RTM-MIB", "rtmStaticRouteChange"), ("DC-RTM-MIB", "rtmPathActivityChange"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rtmNotificationEventGroup = rtmNotificationEventGroup.setStatus('current')
if mibBuilder.loadTexts: rtmNotificationEventGroup.setDescription('A grouping of RTM trap events, as specified in NOTIFICATION-TYPE constructs.')
mibBuilder.exportSymbols("DC-RTM-MIB", rtmRibIfIndex=rtmRibIfIndex, rtmEntityDelDeadRte=rtmEntityDelDeadRte, rtmStaticRtBfdSupport=rtmStaticRtBfdSupport, rtmRibTos=rtmRibTos, rtmRedistAddrFltLen=rtmRedistAddrFltLen, BgpExtendedCommunity=BgpExtendedCommunity, rtmCompliances=rtmCompliances, rtmEntityDsConnctd=rtmEntityDsConnctd, rtmEntityAdminStat=rtmEntityAdminStat, rtmStaticRtAdminStat=rtmStaticRtAdminStat, rtmRibStatus=rtmRibStatus, rtmRibNextHop=rtmRibNextHop, InterfaceType=InterfaceType, rtmRedistAddExtComm=rtmRedistAddExtComm, RdstSetFieldType=RdstSetFieldType, rtmSjIfType=rtmSjIfType, MetricConversion=MetricConversion, rtmRdstSetFieldType=rtmRdstSetFieldType, rtmRedistMetricValue=rtmRedistMetricValue, rtmCompliance=rtmCompliance, rtmStaticRtPathType=rtmStaticRtPathType, rtmMjEntry=rtmMjEntry, rtmMjAdminStatus=rtmMjAdminStatus, rtmRouteTable=rtmRouteTable, rtmStaticRtGroup=rtmStaticRtGroup, rtmRedistOspfTagFlt=rtmRedistOspfTagFlt, rtmRouteMetric3=rtmRouteMetric3, rtmSjMandatoryGroup=rtmSjMandatoryGroup, rtmNotificationObjectGroup=rtmNotificationObjectGroup, rtmStaticRtNextHop=rtmStaticRtNextHop, rtmStaticRtOverride=rtmStaticRtOverride, rtmRedistRedistFlag=rtmRedistRedistFlag, rtmRouteLocalDestIfIndex=rtmRouteLocalDestIfIndex, rtmStaticRtTable=rtmStaticRtTable, rtmTrapEntityFteIndex=rtmTrapEntityFteIndex, rtmRedistEntry=rtmRedistEntry, rtmRouteDestType=rtmRouteDestType, rtmStaticRtIfIndex=rtmStaticRtIfIndex, rtmStaticRtDestAddr=rtmStaticRtDestAddr, rtmRedistGroup=rtmRedistGroup, rtmEntityUseUnidirectionalLinks=rtmEntityUseUnidirectionalLinks, rtmTrapRibDestLen=rtmTrapRibDestLen, rtmNotificationEventGroup=rtmNotificationEventGroup, rtmEntityRestartTime=rtmEntityRestartTime, RtmSjStatus=RtmSjStatus, rtmRedistNwExtComm=rtmRedistNwExtComm, rtmRouteXCIndex=rtmRouteXCIndex, rtmGroups=rtmGroups, rtmTrap=rtmTrap, rtmRibInfo=rtmRibInfo, rtmRedistFteIndex=rtmRedistFteIndex, rtmTrapRibDest=rtmTrapRibDest, rtmEntityDsIsisInt2=rtmEntityDsIsisInt2, rtmEntityDsIdpr=rtmEntityDsIdpr, rtmEntityEnableTrapSupport=rtmEntityEnableTrapSupport, rtmRedistMetricConv=rtmRedistMetricConv, rtmRedistNwOrigin=rtmRedistNwOrigin, rtmRibMetric3=rtmRibMetric3, rtmEntityAddressFamily=rtmEntityAddressFamily, rtmStaticRtBfdStatus=rtmStaticRtBfdStatus, rtmMjSlaveFteId=rtmMjSlaveFteId, rtmRibTable=rtmRibTable, rtmRedistSrcInst=rtmRedistSrcInst, rtmRibConnected=rtmRibConnected, rtmRedistInfoDest=rtmRedistInfoDest, rtmEntityDeadRpmTmr=rtmEntityDeadRpmTmr, rtmRedistOspfTag=rtmRedistOspfTag, rtmRibMetric1=rtmRibMetric1, rtmEntityDsStatDf=rtmEntityDsStatDf, rtmRedistExtCommFlt=rtmRedistExtCommFlt, rtmRedistOspfPropagate=rtmRedistOspfPropagate, rtmRedistTable=rtmRedistTable, rtmEntityDsIsisExt2=rtmEntityDsIsisExt2, rtmSjRtmFteIndex=rtmSjRtmFteIndex, rtmEntityDsUnknown=rtmEntityDsUnknown, FteIndex=FteIndex, rtmEntityRowStatus=rtmEntityRowStatus, rtmTrapStaticRtDestLen=rtmTrapStaticRtDestLen, rtmRedistOspfAreaFlt=rtmRedistOspfAreaFlt, rtmStaticRtUserData=rtmStaticRtUserData, rtmRouteNextHopAS=rtmRouteNextHopAS, rtmEntityMandatoryGroup=rtmEntityMandatoryGroup, rtmStaticRtMandatoryGroup=rtmStaticRtMandatoryGroup, rtmStaticRouteChange=rtmStaticRouteChange, rtmEntityDsDvmrp=rtmEntityDsDvmrp, rtmEntityI3JoinStatus=rtmEntityI3JoinStatus, rtmMjSafi=rtmMjSafi, rtmRedistAddrFilter=rtmRedistAddrFilter, rtmEntityOperStatus=rtmEntityOperStatus, rtmRdstSetFieldTable=rtmRdstSetFieldTable, rtmRdstSetFieldNumber=rtmRdstSetFieldNumber, rtmRedistAdminStat=rtmRedistAdminStat, rtmRedistIfIndexFlt=rtmRedistIfIndexFlt, rtmStaticRtAdminDist=rtmStaticRtAdminDist, rtmStaticRtFteIndex=rtmStaticRtFteIndex, rtmRouteMetric2=rtmRouteMetric2, rtmTrapControl=rtmTrapControl, rtmRedistCommunity=rtmRedistCommunity, rtmEntityDsIsisExt1=rtmEntityDsIsisExt1, rtmRouteIfIndex=rtmRouteIfIndex, EqualCostRouteOpts=EqualCostRouteOpts, rtmMjGroup=rtmMjGroup, rtmPathTrapReason=rtmPathTrapReason, rtmRdstSetFieldEntry=rtmRdstSetFieldEntry, rtmEntityBfdIndex=rtmEntityBfdIndex, rtmRedistMandatoryGroup=rtmRedistMandatoryGroup, rtmEntityI3Index=rtmEntityI3Index, rtmRouteInfo=rtmRouteInfo, rtmEntityStartupTime=rtmEntityStartupTime, rtmRedistNwCommunity=rtmRedistNwCommunity, rtmSjJoinStatus=rtmSjJoinStatus, rtmRouteFteIndex=rtmRouteFteIndex, rtmMjJoinStatus=rtmMjJoinStatus, rtmRibDestLen=rtmRibDestLen, rtmMib=rtmMib, rtmEntityDsEigrpSmm=rtmEntityDsEigrpSmm, rtmRedistNwAsLimUpper=rtmRedistNwAsLimUpper, rtmSjEntry=rtmSjEntry, rtmRouteMetric5=rtmRouteMetric5, rtmRibAge=rtmRibAge, rtmEntityDsOspfInt=rtmEntityDsOspfInt, rtmStaticRtAction=rtmStaticRtAction, rtmSjRtmRpmIndex=rtmSjRtmRpmIndex, rtmRedistIfIndex=rtmRedistIfIndex, rtmMjMandatoryGroup=rtmMjMandatoryGroup, rtmTrapStaticRtDestAddr=rtmTrapStaticRtDestAddr, rtmEntityDsPd=rtmEntityDsPd, rtmRouteProto=rtmRouteProto, rtmRouteEntry=rtmRouteEntry, rtmRibNextHopAS=rtmRibNextHopAS, rtmRouteConnected=rtmRouteConnected, rtmRibEntry=rtmRibEntry, rtmRibDestType=rtmRibDestType, rtmRedistPathType=rtmRedistPathType, rtmStaticRtForwardingAddr=rtmStaticRtForwardingAddr, rtmRouteTos=rtmRouteTos, rtmRdstSetFieldRowStatus=rtmRdstSetFieldRowStatus, rtmRedistHopFltVal=rtmRedistHopFltVal, rtmEntityRouteNumber=rtmEntityRouteNumber, rtmMjIfType=rtmMjIfType, rtmRedistOspfVpnPeCeSupport=rtmRedistOspfVpnPeCeSupport, rtmMjTable=rtmMjTable, rtmRouteDestLen=rtmRouteDestLen, rtmTrapStaticRtDestAddrType=rtmTrapStaticRtDestAddrType, BgpOriginCode=BgpOriginCode, rtmTrapStaticRtIfIndex=rtmTrapStaticRtIfIndex, rtmEntityDsBbnspfigp=rtmEntityDsBbnspfigp, rtmRedistAddCommunity=rtmRedistAddCommunity, rtmRdstSetFieldValue=rtmRdstSetFieldValue, rtmRedistHopFltValType=rtmRedistHopFltValType, RouteType=RouteType, rtmRibRpmIndex=rtmRibRpmIndex, rtmRedistEntryId=rtmRedistEntryId, rtmStaticRtTrapReason=rtmStaticRtTrapReason, rtmTrapRibDestType=rtmTrapRibDestType, rtmStaticRtDestLen=rtmStaticRtDestLen, rtmSjGroup=rtmSjGroup, rtmEntityDsEsis=rtmEntityDsEsis, rtmMjOperStatus=rtmMjOperStatus, rtmStaticRtPathCost=rtmStaticRtPathCost, rtmRibMetric2=rtmRibMetric2, rtmEntityDsIgrp=rtmEntityDsIgrp, rtmRouteNextHop=rtmRouteNextHop, rtmTrapStaticRtNextHopType=rtmTrapStaticRtNextHopType, rtmEntityDsEgp=rtmEntityDsEgp, rtmEntityFtStateRetained=rtmEntityFtStateRetained, rtmRouteMetric1=rtmRouteMetric1, rtmRibGroup=rtmRibGroup, rtmSjTable=rtmSjTable, rtmRdstSetFieldMandatoryGroup=rtmRdstSetFieldMandatoryGroup, rtmSjMastFteId=rtmSjMastFteId, rtmRibFteIndex=rtmRibFteIndex, rtmMjRowStatus=rtmMjRowStatus, rtmEntityTable=rtmEntityTable, rtmEntityDsIntEigrp=rtmEntityDsIntEigrp, rtmStaticRtLooseNextHop=rtmStaticRtLooseNextHop, rtmStaticRtEntry=rtmStaticRtEntry, rtmStaticRtFwdAddrType=rtmStaticRtFwdAddrType, rtmObsoleteGroup=rtmObsoleteGroup, rtmRedistNwOspfTag=rtmRedistNwOspfTag, rtmTrapRibNextHop=rtmTrapRibNextHop, rtmEntityDsOspfExt=rtmEntityDsOspfExt, rtmRedistNwPathType=rtmRedistNwPathType, rtmRouteType=rtmRouteType, rtmConformance=rtmConformance, rtmTrapStaticRtNextHop=rtmTrapStaticRtNextHop, MplsIndexType=MplsIndexType, rtmRibNextHopType=rtmRibNextHopType, rtmRedistCommunityFlt=rtmRedistCommunityFlt, OspfTag=OspfTag, rtmRibMetric5=rtmRibMetric5, rtmEntityDsEigrpExt=rtmEntityDsEigrpExt, rtmRedistRowStatus=rtmRedistRowStatus, rtmEntityDsExtBgp=rtmEntityDsExtBgp, rtmRedistInfoSrc=rtmRedistInfoSrc, rtmEntityDsHello=rtmEntityDsHello, rtmStaticRtDestAddrType=rtmStaticRtDestAddrType, rtmRouteMetric4=rtmRouteMetric4, rtmStaticRtRowStatus=rtmStaticRtRowStatus, rtmRouteDest=rtmRouteDest, rtmRibProto=rtmRibProto, rtmRedistAddrFilterType=rtmRedistAddrFilterType, rtmRdstSetFieldFteIndex=rtmRdstSetFieldFteIndex, rtmOperStateChange=rtmOperStateChange, rtmRedistDestInstFlt=rtmRedistDestInstFlt, BgpCommunity=BgpCommunity, rtmEntityEntry=rtmEntityEntry, rtmStaticRtUsePathCost=rtmStaticRtUsePathCost, rtmTrapRibProto=rtmTrapRibProto, rtmTrapRibRpmIndex=rtmTrapRibRpmIndex, rtmStaticRtOutIfIndex=rtmStaticRtOutIfIndex, rtmRedistNwLocalPref=rtmRedistNwLocalPref, rtmRibFibRoute=rtmRibFibRoute, rtmRedistHopFltLen=rtmRedistHopFltLen, rtmRibType=rtmRibType, rtmRedistNwMed=rtmRedistNwMed, rtmRouteAge=rtmRouteAge, rtmEntityPartnerWaitTime=rtmEntityPartnerWaitTime, rtmRedistDestInst=rtmRedistDestInst, rtmRibDest=rtmRibDest, rtmRedistAddLocalPref=rtmRedistAddLocalPref, InfoSourceDest=InfoSourceDest, rtmRibMetric4=rtmRibMetric4, rtmEntityDsIsisInt1=rtmEntityDsIsisInt1, RtmBfdSupport=RtmBfdSupport, rtmObjects=rtmObjects, rtmRouteNextHopType=rtmRouteNextHopType, rtmRedistPathTypeFlt=rtmRedistPathTypeFlt, rtmRedistOspfArea=rtmRedistOspfArea, rtmRdstSetFieldListId=rtmRdstSetFieldListId, rtmSjMastFteType=rtmSjMastFteType, rtmTraps=rtmTraps, rtmEntityDsRip=rtmEntityDsRip, rtmMjRtmFteIndex=rtmMjRtmFteIndex, rtmRouteStatus=rtmRouteStatus, rtmRouteGroup=rtmRouteGroup, AriPrtnrType=AriPrtnrType, rtmRedistAddAsLimUpper=rtmRedistAddAsLimUpper, rtmMjSlaveType=rtmMjSlaveType, rtmRibLooseNextHop=rtmRibLooseNextHop, rtmTrapRibIfIndex=rtmTrapRibIfIndex, rtmEntityGroup=rtmEntityGroup, rtmEntityFteIndex=rtmEntityFteIndex, rtmTrapRibTos=rtmTrapRibTos, rtmRedistExtComm=rtmRedistExtComm, rtmRedistSetListId=rtmRedistSetListId, PYSNMP_MODULE_ID=rtmMib, rtmEntityEqlCostOpt=rtmEntityEqlCostOpt, rtmTrapRibNextHopType=rtmTrapRibNextHopType, RtmMjStatus=RtmMjStatus, rtmEntityDsIntBgp=rtmEntityDsIntBgp, rtmRedistPriority=rtmRedistPriority, rtmEntityBfdJoinStatus=rtmEntityBfdJoinStatus, RouteInfo=RouteInfo)
mibBuilder.exportSymbols("DC-RTM-MIB", rtmRedistSrcInstFlt=rtmRedistSrcInstFlt, rtmStaticRtNextHopType=rtmStaticRtNextHopType, rtmRibLocalDestIfIndex=rtmRibLocalDestIfIndex, rtmRedistAddMed=rtmRedistAddMed, rtmPathActivityChange=rtmPathActivityChange)

#
# PySNMP MIB module Nortel-Magellan-Passport-TimeMIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/Nortel-Magellan-Passport-TimeMIB
# Produced by pysmi-0.3.4 at Wed May  1 14:28:28 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, SingleValueConstraint, ValueSizeConstraint, ValueRangeConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "SingleValueConstraint", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsUnion")
Counter32, Unsigned32, RowPointer, DisplayString, RowStatus, Integer32, StorageType = mibBuilder.importSymbols("Nortel-Magellan-Passport-StandardTextualConventionsMIB", "Counter32", "Unsigned32", "RowPointer", "DisplayString", "RowStatus", "Integer32", "StorageType")
NonReplicated, EnterpriseDateAndTime = mibBuilder.importSymbols("Nortel-Magellan-Passport-TextualConventionsMIB", "NonReplicated", "EnterpriseDateAndTime")
passportMIBs, components = mibBuilder.importSymbols("Nortel-Magellan-Passport-UsefulDefinitionsMIB", "passportMIBs", "components")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
IpAddress, ObjectIdentity, Gauge32, MibIdentifier, iso, Counter32, TimeTicks, Counter64, Unsigned32, MibScalar, MibTable, MibTableRow, MibTableColumn, NotificationType, Bits, ModuleIdentity, Integer32 = mibBuilder.importSymbols("SNMPv2-SMI", "IpAddress", "ObjectIdentity", "Gauge32", "MibIdentifier", "iso", "Counter32", "TimeTicks", "Counter64", "Unsigned32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "NotificationType", "Bits", "ModuleIdentity", "Integer32")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
timeMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 13))
time = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 19))
timeRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 19, 1), )
if mibBuilder.loadTexts: timeRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: timeRowStatusTable.setDescription('This entry controls the addition and deletion of time components.')
timeRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 19, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-TimeMIB", "timeIndex"))
if mibBuilder.loadTexts: timeRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: timeRowStatusEntry.setDescription('A single entry in the table represents a single time component.')
timeRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 19, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: timeRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: timeRowStatus.setDescription('This variable is used as the basis for SNMP naming of time components. These components cannot be added nor deleted.')
timeComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 19, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: timeComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: timeComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
timeStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 19, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: timeStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: timeStorageType.setDescription('This variable represents the storage type value for the time tables.')
timeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 19, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: timeIndex.setStatus('mandatory')
if mibBuilder.loadTexts: timeIndex.setDescription('This variable represents the index for the time tables.')
timeOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 19, 10), )
if mibBuilder.loadTexts: timeOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: timeOperTable.setDescription('This group contains the operational attributes of the Time component.')
timeOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 19, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-TimeMIB", "timeIndex"))
if mibBuilder.loadTexts: timeOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: timeOperEntry.setDescription('An entry in the timeOperTable.')
timeNetworkTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 19, 10, 1, 1), EnterpriseDateAndTime().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(19, 19), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: timeNetworkTime.setStatus('obsolete')
if mibBuilder.loadTexts: timeNetworkTime.setDescription('The networkTime attribute represents the current date and time. The operator resets the current date and time by setting this attribute. If syncStatus is synchronized or synchronizing, the set verb is disabled.')
timeSyncStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 19, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 4, 5))).clone(namedValues=NamedValues(("synchronized", 0), ("unsynchronized", 1), ("synchronizing", 4), ("unspecified", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: timeSyncStatus.setStatus('mandatory')
if mibBuilder.loadTexts: timeSyncStatus.setDescription('This attribute indicates the XNTP (Network Time Protocol) synchronization status of this module. If the value is synchronized or synchronizing, the syncSource attribute indicates the IP address of the main network time server. The values have the following meanings: synchronized -- The module is synchronized with the network time server. unsynchronized -- There is no network time server selected as XNTP server for the module to synchronize its time with. synchronizing -- The module is trying to synchronize with the network time server. unknown -- The synchronization status of the module is unknown.')
timeSyncSource = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 19, 10, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: timeSyncSource.setStatus('obsolete')
if mibBuilder.loadTexts: timeSyncSource.setDescription("The syncSource is the IP address of the time server host to which the module's syncStatus is synchronized. If the module's syncStatus is unsynchronized, the address is 0.0.0.0.")
timeTimeOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 19, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1440))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: timeTimeOffset.setStatus('obsolete')
if mibBuilder.loadTexts: timeTimeOffset.setDescription('The timeOffset attribute is the number of minutes, to add to the reference time, which is equal to the Universal Coordinated Time (UTC), to obtain the moduleTime.')
timeModuleTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 19, 10, 1, 5), EnterpriseDateAndTime().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(19, 19), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: timeModuleTime.setStatus('mandatory')
if mibBuilder.loadTexts: timeModuleTime.setDescription('This attribute indicates the current date and time on this module. The moduleTime is obtained by adding an offset to the reference time, which is the Universal Time Coordinated (UTC). When the moduleTime is set, it keeps the value even if the card boots. It is the time used for time stamps, such as in alarms and accounting data. The operator resets the current date and time by setting this attribute when syncStatus is unsynchronized. Setting this attribute is not allowed if syncStatus is synchronized or synchronizing.')
timeOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 19, 10, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-720, 1440))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: timeOffset.setStatus('mandatory')
if mibBuilder.loadTexts: timeOffset.setDescription('This attribute specifies the number of minutes to be added to the reference time, which is Universal Coordinated Time (UTC), to obtain the moduleTime. It keeps its value even if the card boots. However, if the node is powered-off for more than 24 hours, it resets to the default value, which is 0. The specified value should be in the range -720 (-12 hours) to 720 (+12 hours). Values greater than 720 are accepted for backward compatibility; for example, 780 (13 hours) corresponds to an offset of -11 hours. If a value greater than 720 is entered, it will be displayed as a negative offset.')
timeMainServer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 19, 10, 1, 7), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: timeMainServer.setStatus('mandatory')
if mibBuilder.loadTexts: timeMainServer.setDescription('This attribute indicates the IP address of the main network time server that this module synchronizes with. If syncStatus is unsynchronized, then mainServer is 0.0.0.0.')
timeXntpVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 19, 10, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: timeXntpVersion.setStatus('mandatory')
if mibBuilder.loadTexts: timeXntpVersion.setDescription('This attribute indicates the current protocol version of XNTP running on this module.')
timeSyncSourcesTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 19, 391), )
if mibBuilder.loadTexts: timeSyncSourcesTable.setStatus('mandatory')
if mibBuilder.loadTexts: timeSyncSourcesTable.setDescription('This attribute indicates the IP addresses of the network time servers that this module synchronizes with. XNTP uses the clock values of the network time servers to set its moduleTime.')
timeSyncSourcesEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 19, 391, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-TimeMIB", "timeIndex"), (0, "Nortel-Magellan-Passport-TimeMIB", "timeSyncSourcesValue"))
if mibBuilder.loadTexts: timeSyncSourcesEntry.setStatus('mandatory')
if mibBuilder.loadTexts: timeSyncSourcesEntry.setDescription('An entry in the timeSyncSourcesTable.')
timeSyncSourcesValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 19, 391, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: timeSyncSourcesValue.setStatus('mandatory')
if mibBuilder.loadTexts: timeSyncSourcesValue.setDescription('This variable represents both the value and the index for the timeSyncSourcesTable.')
timeServer = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 19, 3))
timeServerRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 19, 3, 1), )
if mibBuilder.loadTexts: timeServerRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: timeServerRowStatusTable.setDescription('This entry controls the addition and deletion of timeServer components.')
timeServerRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 19, 3, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-TimeMIB", "timeIndex"), (0, "Nortel-Magellan-Passport-TimeMIB", "timeServerIndex"))
if mibBuilder.loadTexts: timeServerRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: timeServerRowStatusEntry.setDescription('A single entry in the table represents a single timeServer component.')
timeServerRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 19, 3, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: timeServerRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: timeServerRowStatus.setDescription('This variable is used as the basis for SNMP naming of timeServer components. These components can be added and deleted.')
timeServerComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 19, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: timeServerComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: timeServerComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
timeServerStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 19, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: timeServerStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: timeServerStorageType.setDescription('This variable represents the storage type value for the timeServer tables.')
timeServerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 19, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10)))
if mibBuilder.loadTexts: timeServerIndex.setStatus('mandatory')
if mibBuilder.loadTexts: timeServerIndex.setDescription('This variable represents the index for the timeServer tables.')
timeServerProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 19, 3, 11), )
if mibBuilder.loadTexts: timeServerProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: timeServerProvTable.setDescription('This group contains the provisionable attributes of the Server component.')
timeServerProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 19, 3, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-TimeMIB", "timeIndex"), (0, "Nortel-Magellan-Passport-TimeMIB", "timeServerIndex"))
if mibBuilder.loadTexts: timeServerProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: timeServerProvEntry.setDescription('An entry in the timeServerProvTable.')
timeServerIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 19, 3, 11, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: timeServerIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: timeServerIpAddress.setDescription('This attribute specifies the IP address of a network time server that the module will attempt to synchronize with. The value of ipAddress must be unique across all Server components.')
timeServerIpStack = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 19, 3, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ipiFrIpiVc", 1), ("vrIp", 2))).clone('ipiFrIpiVc')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: timeServerIpStack.setStatus('mandatory')
if mibBuilder.loadTexts: timeServerIpStack.setDescription('This attribute specifies the IP stack that XNTP uses to communi- cate with the network time server. If ipiFrIpiVc is selected, then an IpiFr or IpiVc component must be provisioned on this module. If vrIp is selected, then Ip must be provisioned under the management Vr on this module.')
timeServerStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 19, 3, 12), )
if mibBuilder.loadTexts: timeServerStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: timeServerStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
timeServerStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 19, 3, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-TimeMIB", "timeIndex"), (0, "Nortel-Magellan-Passport-TimeMIB", "timeServerIndex"))
if mibBuilder.loadTexts: timeServerStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: timeServerStateEntry.setDescription('An entry in the timeServerStateTable.')
timeServerAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 19, 3, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: timeServerAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: timeServerAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
timeServerOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 19, 3, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: timeServerOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: timeServerOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
timeServerUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 19, 3, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: timeServerUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: timeServerUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
timeServerOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 19, 3, 13), )
if mibBuilder.loadTexts: timeServerOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: timeServerOperTable.setDescription('This group contains the operational attributes of the Server component.')
timeServerOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 19, 3, 13, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-TimeMIB", "timeIndex"), (0, "Nortel-Magellan-Passport-TimeMIB", "timeServerIndex"))
if mibBuilder.loadTexts: timeServerOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: timeServerOperEntry.setDescription('An entry in the timeServerOperTable.')
timeServerXntpVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 19, 3, 13, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: timeServerXntpVersion.setStatus('mandatory')
if mibBuilder.loadTexts: timeServerXntpVersion.setDescription('This attribute indicates the version of XNTP currently in use by the network time server.')
timeServerStratum = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 19, 3, 13, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: timeServerStratum.setStatus('mandatory')
if mibBuilder.loadTexts: timeServerStratum.setDescription('This attribute indicates the stratum level of the clock on the network time server.')
timeServerPoll = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 19, 3, 13, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: timeServerPoll.setStatus('mandatory')
if mibBuilder.loadTexts: timeServerPoll.setDescription('This attribute indicates the time interval for the Passport module to poll the network time server for time synchronization.')
timeServerPktSent = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 19, 3, 13, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: timeServerPktSent.setStatus('mandatory')
if mibBuilder.loadTexts: timeServerPktSent.setDescription('This attribute counts the packets sent to the network time server.')
timeServerPktRecv = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 19, 3, 13, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: timeServerPktRecv.setStatus('mandatory')
if mibBuilder.loadTexts: timeServerPktRecv.setDescription('This attribute counts the packets received from the network time server, including the invalid packets.')
timeServerPktValid = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 19, 3, 13, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: timeServerPktValid.setStatus('mandatory')
if mibBuilder.loadTexts: timeServerPktValid.setDescription('This attribute counts the valid packets received from the network time server.')
timeServerStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 19, 3, 13, 1, 392), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: timeServerStatus.setStatus('mandatory')
if mibBuilder.loadTexts: timeServerStatus.setDescription("This attribute indicates the status of the network time server. main -- This network time server is working properly, and is the system servers (synchronization sources) of the module. primary -- This network time server is working properly, and is the primary servers (one of the synchronization sources) of the module secondary -- This network time server is working properly, but its offset and dispersion is not stable or too high so that it can not be selected as one of the primary time synchronization sources. But if the primary synchronization sources are not available, it can take over the responsibility and become the time synchronization source of the module. unused -- This network time server is not used as a server (synchronization source) of the module. noResponse -- This network time server is not responding to the module's time synchronization request. This could be caused by network error or protocol error, or network time server configuration error. stratumTooHigh -- This network time server has the bad stratum (higher than 16), or its stratum is higher than the module's stratum. leapUnsync -- This network time server's leap value indicates that this network time server is not synchronized. clockUnsync -- This network time server's clock values indicates that this network time server is not synchronized. rootTooNoisy -- This network time server's root dispersion is too high, so that its time stamp is not used. peerTooNoisy -- The modules dispersion relative to this network time server is too high, so this network time server's time stamp is not used. faultStick -- This offset of the module relative to this network time server is out of the range or too high, so that it can not be selected as one of the primary time synchronization source. Description of bits: main(0) primary(1) secondary(2) unused(3) noResponse(4) stratumTooHigh(5) leapUnsync(6) clockUnsync(7) rootTooNoisy(8) peerTooNoisy(9) faultStick(10)")
nS = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 20))
nSRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 20, 1), )
if mibBuilder.loadTexts: nSRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: nSRowStatusTable.setDescription('This entry controls the addition and deletion of nS components.')
nSRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 20, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-TimeMIB", "nSIndex"))
if mibBuilder.loadTexts: nSRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nSRowStatusEntry.setDescription('A single entry in the table represents a single nS component.')
nSRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 20, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nSRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: nSRowStatus.setDescription('This variable is used as the basis for SNMP naming of nS components. These components can be added and deleted.')
nSComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 20, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nSComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: nSComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
nSStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 20, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nSStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: nSStorageType.setDescription('This variable represents the storage type value for the nS tables.')
nSIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 20, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: nSIndex.setStatus('mandatory')
if mibBuilder.loadTexts: nSIndex.setDescription('This variable represents the index for the nS tables.')
nSProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 20, 10), )
if mibBuilder.loadTexts: nSProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: nSProvTable.setDescription('This group contains all of the provisioning data for the NetworkSynchronization component.')
nSProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 20, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-TimeMIB", "nSIndex"))
if mibBuilder.loadTexts: nSProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nSProvEntry.setDescription('An entry in the nSProvTable.')
nSPrimaryReference = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 20, 10, 1, 1), RowPointer()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nSPrimaryReference.setStatus('mandatory')
if mibBuilder.loadTexts: nSPrimaryReference.setDescription('This component name is the port that is the preferred choice as the reference for the network clock.')
nSSecondaryReference = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 20, 10, 1, 2), RowPointer()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nSSecondaryReference.setStatus('mandatory')
if mibBuilder.loadTexts: nSSecondaryReference.setDescription('This component name is the port that is the second choice for the reference for the network clock.')
nSTertiaryReference = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 20, 10, 1, 3), RowPointer()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nSTertiaryReference.setStatus('mandatory')
if mibBuilder.loadTexts: nSTertiaryReference.setDescription('This component name is the port that is the third choice for the reference for the network clock.')
nSStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 20, 11), )
if mibBuilder.loadTexts: nSStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: nSStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
nSStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 20, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-TimeMIB", "nSIndex"))
if mibBuilder.loadTexts: nSStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nSStateEntry.setDescription('An entry in the nSStateTable.')
nSAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 20, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: nSAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: nSAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
nSOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 20, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: nSOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: nSOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
nSUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 20, 11, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: nSUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: nSUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
nSOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 20, 12), )
if mibBuilder.loadTexts: nSOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: nSOperTable.setDescription('This group contains the operational attributes for the network clock sync')
nSOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 20, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-TimeMIB", "nSIndex"))
if mibBuilder.loadTexts: nSOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nSOperEntry.setDescription('An entry in the nSOperTable.')
nSClockSyncState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 20, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 3))).clone(namedValues=NamedValues(("freeRun", 0), ("synchronizing", 1), ("synchronized", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nSClockSyncState.setStatus('mandatory')
if mibBuilder.loadTexts: nSClockSyncState.setDescription('When the clockSyncState is in the freeRun state, either no reference have beed provisioned or none of the provisioned references have been found to be valid. The Stratum-3 clock is allowed to run freely at its last adjusted frequency. When the clockSyncState is in the synchronizing state, the Stratum-3 is trying to synchronize in frequency to a valid provisioned reference. This state should last approximately 1-2 minutes, provided the reference is stable. Once frequency synchronization is acheived, a null phase is acquired and the clockSyncState enters the synchronized state. In this state, both phase and frequency are tracked and compensated for. This node is now ready to support transparent data services.')
nSActiveReference = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 20, 12, 1, 2), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nSActiveReference.setStatus('mandatory')
if mibBuilder.loadTexts: nSActiveReference.setDescription('Indicates the active 8Khz clock reference source')
nSStandbyReference = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 20, 12, 1, 3), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nSStandbyReference.setStatus('mandatory')
if mibBuilder.loadTexts: nSStandbyReference.setDescription('Indicates the standby 8Khz clock reference source which will be selected if a failure is detected on the active source.')
timeGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 13, 1))
timeGroupBE = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 13, 1, 5))
timeGroupBE01 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 13, 1, 5, 2))
timeGroupBE01A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 13, 1, 5, 2, 2))
timeCapabilities = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 13, 3))
timeCapabilitiesBE = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 13, 3, 5))
timeCapabilitiesBE01 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 13, 3, 5, 2))
timeCapabilitiesBE01A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 13, 3, 5, 2, 2))
mibBuilder.exportSymbols("Nortel-Magellan-Passport-TimeMIB", timeOperEntry=timeOperEntry, timeCapabilitiesBE01A=timeCapabilitiesBE01A, nSOperationalState=nSOperationalState, timeServerPktSent=timeServerPktSent, timeIndex=timeIndex, timeModuleTime=timeModuleTime, timeCapabilitiesBE=timeCapabilitiesBE, nSIndex=nSIndex, timeSyncSource=timeSyncSource, timeOperTable=timeOperTable, timeSyncSourcesValue=timeSyncSourcesValue, nSProvEntry=nSProvEntry, timeServerPktValid=timeServerPktValid, timeMainServer=timeMainServer, timeServerStateTable=timeServerStateTable, timeRowStatus=timeRowStatus, timeServerAdminState=timeServerAdminState, timeServerStratum=timeServerStratum, timeServerStateEntry=timeServerStateEntry, timeServer=timeServer, timeTimeOffset=timeTimeOffset, nSStateTable=nSStateTable, nSStandbyReference=nSStandbyReference, nSStorageType=nSStorageType, timeGroupBE01=timeGroupBE01, nSProvTable=nSProvTable, nSActiveReference=nSActiveReference, timeServerPktRecv=timeServerPktRecv, nSRowStatusTable=nSRowStatusTable, timeSyncSourcesTable=timeSyncSourcesTable, timeServerOperTable=timeServerOperTable, timeServerXntpVersion=timeServerXntpVersion, nSRowStatusEntry=nSRowStatusEntry, nSStateEntry=nSStateEntry, nSClockSyncState=nSClockSyncState, timeServerUsageState=timeServerUsageState, timeCapabilities=timeCapabilities, timeXntpVersion=timeXntpVersion, timeCapabilitiesBE01=timeCapabilitiesBE01, timeServerOperEntry=timeServerOperEntry, nSOperEntry=nSOperEntry, timeGroup=timeGroup, timeServerOperationalState=timeServerOperationalState, timeRowStatusEntry=timeRowStatusEntry, time=time, timeServerProvTable=timeServerProvTable, nSRowStatus=nSRowStatus, timeGroupBE=timeGroupBE, nSTertiaryReference=nSTertiaryReference, nSOperTable=nSOperTable, nS=nS, nSPrimaryReference=nSPrimaryReference, nSComponentName=nSComponentName, timeOffset=timeOffset, timeServerStatus=timeServerStatus, timeComponentName=timeComponentName, timeMIB=timeMIB, timeSyncSourcesEntry=timeSyncSourcesEntry, timeServerIpStack=timeServerIpStack, timeServerRowStatus=timeServerRowStatus, timeServerProvEntry=timeServerProvEntry, timeServerPoll=timeServerPoll, timeRowStatusTable=timeRowStatusTable, nSSecondaryReference=nSSecondaryReference, nSUsageState=nSUsageState, timeServerRowStatusTable=timeServerRowStatusTable, timeServerComponentName=timeServerComponentName, timeServerRowStatusEntry=timeServerRowStatusEntry, timeServerIpAddress=timeServerIpAddress, timeServerStorageType=timeServerStorageType, timeServerIndex=timeServerIndex, nSAdminState=nSAdminState, timeNetworkTime=timeNetworkTime, timeStorageType=timeStorageType, timeGroupBE01A=timeGroupBE01A, timeSyncStatus=timeSyncStatus)

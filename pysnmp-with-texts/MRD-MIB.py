#
# PySNMP MIB module MRD-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/MRD-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:15:03 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ValueRangeConstraint, ConstraintsUnion, SingleValueConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsUnion", "SingleValueConstraint", "ConstraintsIntersection")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
ObjectIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, ModuleIdentity, NotificationType, Gauge32, iso, MibIdentifier, Unsigned32, IpAddress, TimeTicks, Counter32, Counter64, Integer32, Bits = mibBuilder.importSymbols("SNMPv2-SMI", "ObjectIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ModuleIdentity", "NotificationType", "Gauge32", "iso", "MibIdentifier", "Unsigned32", "IpAddress", "TimeTicks", "Counter32", "Counter64", "Integer32", "Bits")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
xylanMrouted, = mibBuilder.importSymbols("XYLAN-BASE-MIB", "xylanMrouted")
mrdMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1))
mrdMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1))
class DisplayString(OctetString):
    pass

mrdGeneralGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 1))
mrdVersion = MibScalar((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 1, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdVersion.setStatus('mandatory')
if mibBuilder.loadTexts: mrdVersion.setDescription('The current version of Mrouted.')
mrdCachedRouteResTime = MibScalar((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mrdCachedRouteResTime.setStatus('mandatory')
if mibBuilder.loadTexts: mrdCachedRouteResTime.setDescription('The amount of time cached routes stay in memory in seconds. The minimum value is 300, the maximum value is 86,400.')
mrdPruneFlag = MibScalar((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("pruningrouter", 1), ("non-pruningrouter", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mrdPruneFlag.setStatus('mandatory')
if mibBuilder.loadTexts: mrdPruneFlag.setDescription('This flag indicates whether or not this router is a pruning router or not.')
mrdConfigUpdate = MibScalar((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("configUpdate", 1), ("noConfigUpdate", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mrdConfigUpdate.setStatus('mandatory')
if mibBuilder.loadTexts: mrdConfigUpdate.setDescription('This flag indicates whether or not the system software will update the online system with the changes entered into the configuration file. This will cause a stop and restart of the Mrouted software.')
mrdEnableDisable = MibScalar((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("doEnable", 1), ("doDisable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mrdEnableDisable.setStatus('mandatory')
if mibBuilder.loadTexts: mrdEnableDisable.setDescription('This flag indicates whether or not mrouted will be enabled or disabled.')
mrdIntfBoundaryTable = MibTable((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 2), )
if mibBuilder.loadTexts: mrdIntfBoundaryTable.setStatus('mandatory')
if mibBuilder.loadTexts: mrdIntfBoundaryTable.setDescription('The mrdBoundaryTable contains the entries that describe the mrd boundary table')
mrdIntfBoundaryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 2, 1), ).setIndexNames((0, "MRD-MIB", "mrdIntfPhyIntAddr"), (0, "MRD-MIB", "mrdIntfScopedAddress"))
if mibBuilder.loadTexts: mrdIntfBoundaryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mrdIntfBoundaryEntry.setDescription('An entry in the table, containing information about a PNNI logical node in this switching system.')
mrdIntfPhyIntAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 2, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mrdIntfPhyIntAddr.setStatus('mandatory')
if mibBuilder.loadTexts: mrdIntfPhyIntAddr.setDescription('This value indicates the physical interface or tunnel address associated with this boundary entry.')
mrdIntfScopedAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 2, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mrdIntfScopedAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mrdIntfScopedAddress.setDescription('This value indicates the scoped address for the given boundary.')
mrdIntfBoundMaskLength = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 2, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mrdIntfBoundMaskLength.setStatus('mandatory')
if mibBuilder.loadTexts: mrdIntfBoundMaskLength.setDescription('This value gives the mask length of the scoped address. ')
mrdIntfAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("delete", 1), ("normal", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mrdIntfAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mrdIntfAdminState.setDescription('This value gives current state of this interface. ')
mrdTunBoundaryTable = MibTable((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 3), )
if mibBuilder.loadTexts: mrdTunBoundaryTable.setStatus('mandatory')
if mibBuilder.loadTexts: mrdTunBoundaryTable.setDescription('The mrdBoundaryTable contains the entries that describe the mrd boundary table')
mrdTunBoundaryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 3, 1), ).setIndexNames((0, "MRD-MIB", "mrdTunLocalAddress"), (0, "MRD-MIB", "mrdTunRemoteAddress"), (0, "MRD-MIB", "mrdTunScopedAddress"))
if mibBuilder.loadTexts: mrdTunBoundaryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mrdTunBoundaryEntry.setDescription('An entry in the table, containing information about a PNNI logical node in this switching system.')
mrdTunLocalAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 3, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mrdTunLocalAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mrdTunLocalAddress.setDescription('This value indicates the physical interface or tunnel address associated with this boundary entry.')
mrdTunRemoteAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 3, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mrdTunRemoteAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mrdTunRemoteAddress.setDescription('This value indicates the physical interface or tunnel address associated with this boundary entry.')
mrdTunScopedAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 3, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mrdTunScopedAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mrdTunScopedAddress.setDescription('This value indicates the scoped address for the given boundary.')
mrdTunBoundMaskLength = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 3, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mrdTunBoundMaskLength.setStatus('mandatory')
if mibBuilder.loadTexts: mrdTunBoundMaskLength.setDescription('This value gives the mask length of the scoped address. ')
mrdTunAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("delete", 1), ("normal", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mrdTunAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mrdTunAdminState.setDescription('This value gives current state of this interface. ')
mrdAltNetTable = MibTable((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 4), )
if mibBuilder.loadTexts: mrdAltNetTable.setStatus('mandatory')
if mibBuilder.loadTexts: mrdAltNetTable.setDescription('The mrdBoundaryTable contains the entries that describe the mrd boundary table')
mrdAltNetEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 4, 1), ).setIndexNames((0, "MRD-MIB", "mrdAltNetAddr"), (0, "MRD-MIB", "mrdNetworkAddress"))
if mibBuilder.loadTexts: mrdAltNetEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mrdAltNetEntry.setDescription('An entry in the table, containing information about a PNNI logical node in this switching system.')
mrdAltNetAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 4, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mrdAltNetAddr.setStatus('mandatory')
if mibBuilder.loadTexts: mrdAltNetAddr.setDescription('This value indicates the address of the Physical Interface that this alternate network is associated with network.')
mrdNetworkAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 4, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mrdNetworkAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mrdNetworkAddress.setDescription('This value indicates the network address for the given alternate network.')
mrdANetMaskLength = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 4, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mrdANetMaskLength.setStatus('mandatory')
if mibBuilder.loadTexts: mrdANetMaskLength.setDescription('This value gives the mask length of the alternate network address. ')
mrdANetAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("delete", 1), ("normal", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mrdANetAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mrdANetAdminState.setDescription('This value gives current state of this interface. ')
mrdInterfaceTable = MibTable((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 5), )
if mibBuilder.loadTexts: mrdInterfaceTable.setStatus('mandatory')
if mibBuilder.loadTexts: mrdInterfaceTable.setDescription('The mrdInterfaceTable contains the entries that describe the Multicast Interface table.')
mrdInterfaceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 5, 1), ).setIndexNames((0, "MRD-MIB", "mrdIFAddress"))
if mibBuilder.loadTexts: mrdInterfaceEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mrdInterfaceEntry.setDescription('An entry in the table, containing information about a Multicast Interace Table.')
mrdIFAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 5, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mrdIFAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mrdIFAddress.setDescription('This value indicates the network address for the given multicast interface table entry.')
mrdIFEnabledFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mrdIFEnabledFlag.setStatus('mandatory')
if mibBuilder.loadTexts: mrdIFEnabledFlag.setDescription('This value indicates this entry in the Multicast interface table is enabled or not.')
mrdIFMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 5, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mrdIFMetric.setStatus('mandatory')
if mibBuilder.loadTexts: mrdIFMetric.setDescription('This value indicates path metric for this entry in the Multicast Interface table.')
mrdIFThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 5, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mrdIFThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: mrdIFThreshold.setDescription('This value indicates the threshold for this entry in the Multicast Interface table.')
mrdIFRateLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 5, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mrdIFRateLimit.setStatus('mandatory')
if mibBuilder.loadTexts: mrdIFRateLimit.setDescription('This value indicates the rate limit for this entry in the Multicast Interface table.')
mrdIFBoundary = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 5, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdIFBoundary.setStatus('mandatory')
if mibBuilder.loadTexts: mrdIFBoundary.setDescription('This flag indicates whether or not there is a list of boundary addresses associated with this interface table.')
mrdIFAlternateNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 5, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdIFAlternateNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: mrdIFAlternateNetwork.setDescription('This value indicates whether or not there is a list of alternate network addresses associated with this interface.')
mrdIFAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 5, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("delete", 1), ("normal", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mrdIFAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mrdIFAdminState.setDescription('This value gives current state of this interface. ')
mrdTunnelTable = MibTable((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 6), )
if mibBuilder.loadTexts: mrdTunnelTable.setStatus('mandatory')
if mibBuilder.loadTexts: mrdTunnelTable.setDescription('The mrdTunnelTable contains the entries that describe the Multicast Tunnel table.')
mrdTunnelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 6, 1), ).setIndexNames((0, "MRD-MIB", "mrdLocalAddress"), (0, "MRD-MIB", "mrdRemoteAddress"))
if mibBuilder.loadTexts: mrdTunnelEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mrdTunnelEntry.setDescription('An entry in the table, containing information about a Multicast Tunnel Table.')
mrdLocalAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 6, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mrdLocalAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mrdLocalAddress.setDescription('This value indicates the local network address for the given multicast tunnel table entry.')
mrdRemoteAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 6, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mrdRemoteAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mrdRemoteAddress.setDescription('This value indicates the remote network address for the given multicast tunnel.')
mrdTunnelMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 6, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mrdTunnelMetric.setStatus('mandatory')
if mibBuilder.loadTexts: mrdTunnelMetric.setDescription('This value indicates path metric for this entry in the Multicast Tunnel table.')
mrdTunnelThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 6, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mrdTunnelThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: mrdTunnelThreshold.setDescription('This value indicates the threshold for this entry in the Multicast Tunnel table.')
mrdTunnelRateLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 6, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mrdTunnelRateLimit.setStatus('mandatory')
if mibBuilder.loadTexts: mrdTunnelRateLimit.setDescription('This value indicates the rate limit for this entry in the Multicast Tunnel table.')
mrdTunnelBoundary = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 6, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdTunnelBoundary.setStatus('mandatory')
if mibBuilder.loadTexts: mrdTunnelBoundary.setDescription('This flag indicates whether or not there is a list of boundaries for this tunnel entry.')
mrdTunnelAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 6, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("delete", 1), ("normal", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mrdTunnelAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mrdTunnelAdminState.setDescription('This value gives current state of this interface. ')
mrdGroupTable = MibTable((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 7), )
if mibBuilder.loadTexts: mrdGroupTable.setStatus('mandatory')
if mibBuilder.loadTexts: mrdGroupTable.setDescription('The mrdGroupTable contains one entry for each group or subnet that is defined on the switch.')
mrdGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 7, 1), ).setIndexNames((0, "MRD-MIB", "mrdGroupID"), (0, "MRD-MIB", "mrdGroupVlanMask"), (0, "MRD-MIB", "mrdGroupSrcIP"))
if mibBuilder.loadTexts: mrdGroupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mrdGroupEntry.setDescription('An entry in the table, containing information about a Multicast Group Table.')
mrdGroupID = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 7, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdGroupID.setStatus('mandatory')
if mibBuilder.loadTexts: mrdGroupID.setDescription('This value indicates the Vlan Group of this entry.')
mrdGroupVlanMask = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 7, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdGroupVlanMask.setStatus('mandatory')
if mibBuilder.loadTexts: mrdGroupVlanMask.setDescription('This value indicates the Vlan Mask of the group.')
mrdGroupSrcIP = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 7, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdGroupSrcIP.setStatus('mandatory')
if mibBuilder.loadTexts: mrdGroupSrcIP.setDescription('This value indicates the source IP address of the group.')
mrdGroupSrcIPNet = MibScalar((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 7, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdGroupSrcIPNet.setStatus('mandatory')
if mibBuilder.loadTexts: mrdGroupSrcIPNet.setDescription('This value indicates the source IP network address of the group.')
mrdGroupSrcNetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 7, 1, 5), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdGroupSrcNetMask.setStatus('mandatory')
if mibBuilder.loadTexts: mrdGroupSrcNetMask.setDescription('This value contains the network mask for the source IP address.')
mrdGroupMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 7, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdGroupMetric.setStatus('mandatory')
if mibBuilder.loadTexts: mrdGroupMetric.setDescription('This value indicates the metric for this group.')
mrdGroupThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 7, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdGroupThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: mrdGroupThreshold.setDescription('This field indicates how may hops the multicast stream can take.')
mrdGroupRate = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 7, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdGroupRate.setStatus('mandatory')
if mibBuilder.loadTexts: mrdGroupRate.setDescription('This value describes the maximum data rate allowed on this interface.')
mrdGroupPacketsIn = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 7, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdGroupPacketsIn.setStatus('mandatory')
if mibBuilder.loadTexts: mrdGroupPacketsIn.setDescription('This value describes the number of packets received on this interface.')
mrdGroupPacketsOut = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 7, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdGroupPacketsOut.setStatus('mandatory')
if mibBuilder.loadTexts: mrdGroupPacketsOut.setDescription('This value describes the maximum data rate allowed on this interface.')
mrdGroupOneWayFlg = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 7, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("isOneWay", 1), ("isNotOneWay", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdGroupOneWayFlg.setStatus('mandatory')
if mibBuilder.loadTexts: mrdGroupOneWayFlg.setDescription('This flag indicates whether or not this interface is in one-way mode.')
mrdGroupDownFlg = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 7, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("isDown", 1), ("isNotDown", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdGroupDownFlg.setStatus('mandatory')
if mibBuilder.loadTexts: mrdGroupDownFlg.setDescription('This flag indicates whether or not this interface is down.')
mrdGroupDisabledFlg = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 7, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("isDisabled", 1), ("isNotDisabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdGroupDisabledFlg.setStatus('mandatory')
if mibBuilder.loadTexts: mrdGroupDisabledFlg.setDescription('This flag indicates whether or not this interface is disabled.')
mrdGroupQuerierFlg = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 7, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("isQuerier", 1), ("isNotQuerier", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdGroupQuerierFlg.setStatus('mandatory')
if mibBuilder.loadTexts: mrdGroupQuerierFlg.setDescription('This flag indicates whether or not this interface is a querier.')
mrdGroupSrcRteFlg = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 7, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("isSourceRouted", 1), ("isNotSourceRouted", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdGroupSrcRteFlg.setStatus('mandatory')
if mibBuilder.loadTexts: mrdGroupSrcRteFlg.setDescription('This flag indicates whether or not this interface is source routed.')
mrdGroupLeafFlg = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 7, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("isLeaf", 1), ("isNotLeaf", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdGroupLeafFlg.setStatus('mandatory')
if mibBuilder.loadTexts: mrdGroupLeafFlg.setDescription('This flag indicates whether or not this interface is a leaf.')
mrdGroupIgmpv1Flg = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 7, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("isIgmpV1", 1), ("isNotIgmpV1", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdGroupIgmpv1Flg.setStatus('mandatory')
if mibBuilder.loadTexts: mrdGroupIgmpv1Flg.setDescription('This flag indicates whether or not this interface is running IGMP V1.')
mrdTunnelListTable = MibTable((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 8), )
if mibBuilder.loadTexts: mrdTunnelListTable.setStatus('mandatory')
if mibBuilder.loadTexts: mrdTunnelListTable.setDescription('The mrdTunnelListTable contains one entry for each group or subnet that is defined on the switch.')
mrdTunnelListEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 8, 1), ).setIndexNames((0, "MRD-MIB", "mrdTunnelListGrpID"), (0, "MRD-MIB", "mrdTunnelListVlanMask"), (0, "MRD-MIB", "mrdTunnelListSrcIP"), (0, "MRD-MIB", "mrdTunnelListDstIP"))
if mibBuilder.loadTexts: mrdTunnelListEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mrdTunnelListEntry.setDescription('An entry in the table, containing information about a Multicast Tunnel List Table.')
mrdTunnelListGrpID = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 8, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdTunnelListGrpID.setStatus('mandatory')
if mibBuilder.loadTexts: mrdTunnelListGrpID.setDescription('This value indicates the Vlan Group of this entry.')
mrdTunnelListVlanMask = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 8, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdTunnelListVlanMask.setStatus('mandatory')
if mibBuilder.loadTexts: mrdTunnelListVlanMask.setDescription('This value indicates the Vlan Mask of the tunnel.')
mrdTunnelListSrcIP = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 8, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdTunnelListSrcIP.setStatus('mandatory')
if mibBuilder.loadTexts: mrdTunnelListSrcIP.setDescription('This value indicates the source IP address of the tunnel.')
mrdTunnelListDstIP = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 8, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdTunnelListDstIP.setStatus('mandatory')
if mibBuilder.loadTexts: mrdTunnelListDstIP.setDescription('This value indicates the destination or remote IP address of the tunnel.')
mrdTunnelListMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 8, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdTunnelListMetric.setStatus('mandatory')
if mibBuilder.loadTexts: mrdTunnelListMetric.setDescription('This value indicates the metric for this tunnel.')
mrdTunnelListThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 8, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdTunnelListThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: mrdTunnelListThreshold.setDescription('This field indicates how may hops the multicast stream can take.')
mrdTunnelListRate = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 8, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdTunnelListRate.setStatus('mandatory')
if mibBuilder.loadTexts: mrdTunnelListRate.setDescription('This value describes the maximum data rate allowed on this interface.')
mrdTunnelListPacketsIn = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 8, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdTunnelListPacketsIn.setStatus('mandatory')
if mibBuilder.loadTexts: mrdTunnelListPacketsIn.setDescription('This value describes the number of packets received on this interface.')
mrdTunnelListPacketsOut = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 8, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdTunnelListPacketsOut.setStatus('mandatory')
if mibBuilder.loadTexts: mrdTunnelListPacketsOut.setDescription('This value describes the maximum data rate allowed on this interface.')
mrdTunnelListOneWayFlg = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 8, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("isOneWay", 1), ("isNotOneWay", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdTunnelListOneWayFlg.setStatus('mandatory')
if mibBuilder.loadTexts: mrdTunnelListOneWayFlg.setDescription('This flag indicates whether or not this interface is in one-way mode.')
mrdTunnelListDownFlg = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 8, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("isDown", 1), ("isNotDown", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdTunnelListDownFlg.setStatus('mandatory')
if mibBuilder.loadTexts: mrdTunnelListDownFlg.setDescription('This flag indicates whether or not this interface is down.')
mrdTunnelListDisabledFlg = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 8, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("isDisabled", 1), ("isNotDisabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdTunnelListDisabledFlg.setStatus('mandatory')
if mibBuilder.loadTexts: mrdTunnelListDisabledFlg.setDescription('This flag indicates whether or not this interface is disabled.')
mrdTunnelListQuerierFlg = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 8, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("isQuerier", 1), ("isNotQuerier", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdTunnelListQuerierFlg.setStatus('mandatory')
if mibBuilder.loadTexts: mrdTunnelListQuerierFlg.setDescription('This flag indicates whether or not this interface is a querier.')
mrdTunnelListSrcRteFlg = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 8, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("isSourceRouted", 1), ("isNotSourceRouted", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdTunnelListSrcRteFlg.setStatus('mandatory')
if mibBuilder.loadTexts: mrdTunnelListSrcRteFlg.setDescription('This flag indicates whether or not this interface is source routed.')
mrdTunnelListLeafFlg = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 8, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("isLeaf", 1), ("isNotLeaf", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdTunnelListLeafFlg.setStatus('mandatory')
if mibBuilder.loadTexts: mrdTunnelListLeafFlg.setDescription('This flag indicates whether or not this interface is a leaf.')
mrdTunnelListIgmpv1Flg = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 8, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("isIgmpV1", 1), ("isNotIgmpV1", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdTunnelListIgmpv1Flg.setStatus('mandatory')
if mibBuilder.loadTexts: mrdTunnelListIgmpv1Flg.setDescription('This flag indicates whether or not this interface is running IGMP V1.')
mrdPeerTable = MibTable((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 9), )
if mibBuilder.loadTexts: mrdPeerTable.setStatus('mandatory')
if mibBuilder.loadTexts: mrdPeerTable.setDescription('The mrdPeerTable contains one entry for each group or subnet that is defined on the switch.')
mrdPeerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 9, 1), ).setIndexNames((0, "MRD-MIB", "mrdPeerGrpID"), (0, "MRD-MIB", "mrdPeerVlanMask"), (0, "MRD-MIB", "mrdPeerSrcIP"), (0, "MRD-MIB", "mrdPeerPeerIP"))
if mibBuilder.loadTexts: mrdPeerEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mrdPeerEntry.setDescription('An entry in the table, containing information about a Multicast Tunnel List Table.')
mrdPeerGrpID = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 9, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdPeerGrpID.setStatus('mandatory')
if mibBuilder.loadTexts: mrdPeerGrpID.setDescription('This value indicates the Vlan Group of this entry.')
mrdPeerVlanMask = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 9, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdPeerVlanMask.setStatus('mandatory')
if mibBuilder.loadTexts: mrdPeerVlanMask.setDescription('This value indicates the Vlan Mask of this entry.')
mrdPeerSrcIP = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 9, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdPeerSrcIP.setStatus('mandatory')
if mibBuilder.loadTexts: mrdPeerSrcIP.setDescription('This value indicates the source IP address of the interface.')
mrdPeerPeerIP = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 9, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdPeerPeerIP.setStatus('mandatory')
if mibBuilder.loadTexts: mrdPeerPeerIP.setDescription('This value indicates the IP address of the peer.')
mrdPeerMajorLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 9, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdPeerMajorLevel.setStatus('mandatory')
if mibBuilder.loadTexts: mrdPeerMajorLevel.setDescription('This value indicates the major version level of this peer.')
mrdPeerMinorLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 9, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdPeerMinorLevel.setStatus('mandatory')
if mibBuilder.loadTexts: mrdPeerMinorLevel.setDescription('This field indicates the minor version level of this peer.')
mrdPeerTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 9, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdPeerTimer.setStatus('mandatory')
if mibBuilder.loadTexts: mrdPeerTimer.setDescription('This value indicates the number of seconds since a neighbor probe has been received.')
mrdPeerFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 9, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdPeerFlags.setStatus('mandatory')
if mibBuilder.loadTexts: mrdPeerFlags.setDescription("This value describes the raw contents of the peer's flag byte.")
mrdPeerLeafFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 9, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("isALeaf", 1), ("isNotALeaf", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdPeerLeafFlag.setStatus('mandatory')
if mibBuilder.loadTexts: mrdPeerLeafFlag.setDescription('This flag indicates whether or not this peer is a leaf.')
mrdPeerPruneFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 9, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("isAPruningRouter", 1), ("isNotAPruningRouter", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdPeerPruneFlag.setStatus('mandatory')
if mibBuilder.loadTexts: mrdPeerPruneFlag.setDescription('This flag indicates whether or not this peer supports pruning.')
mrdPeerGenIdFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 9, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("isIncludingGenID", 1), ("isNotIncludingGenID", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdPeerGenIdFlag.setStatus('mandatory')
if mibBuilder.loadTexts: mrdPeerGenIdFlag.setDescription('This flag indicates whether or not this peer includes the genid and rtlist in probes.')
mrdPeerMtraceFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 9, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("isSupportingMtrace", 1), ("isNotSupportingMtrace", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdPeerMtraceFlag.setStatus('mandatory')
if mibBuilder.loadTexts: mrdPeerMtraceFlag.setDescription('This flag indicates whether or not this peer supports mtrace requests.')
mrdAltNetList = MibTable((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 10), )
if mibBuilder.loadTexts: mrdAltNetList.setStatus('mandatory')
if mibBuilder.loadTexts: mrdAltNetList.setDescription('The mrdAltNetListTable contains one entry for each alternate Network that is currently running in the switch.')
mrdAltNetListEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 10, 1), ).setIndexNames((0, "MRD-MIB", "mrdAltNetListGrpID"), (0, "MRD-MIB", "mrdAltNetListVlanMask"), (0, "MRD-MIB", "mrdAltNetListSrcIP"), (0, "MRD-MIB", "mrdAltNetListAltNetIP"))
if mibBuilder.loadTexts: mrdAltNetListEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mrdAltNetListEntry.setDescription('An entry in the table, containing information about an Alternate Network List Table.')
mrdAltNetListGrpID = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 10, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdAltNetListGrpID.setStatus('mandatory')
if mibBuilder.loadTexts: mrdAltNetListGrpID.setDescription('This value indicates the Vlan Group of this entry.')
mrdAltNetListVlanMask = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 10, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdAltNetListVlanMask.setStatus('mandatory')
if mibBuilder.loadTexts: mrdAltNetListVlanMask.setDescription('This value indicates the Vlan Mask of this entry.')
mrdAltNetListSrcIP = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 10, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdAltNetListSrcIP.setStatus('mandatory')
if mibBuilder.loadTexts: mrdAltNetListSrcIP.setDescription('This value indicates the source IP address of the interface.')
mrdAltNetListAltNetIP = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 10, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdAltNetListAltNetIP.setStatus('mandatory')
if mibBuilder.loadTexts: mrdAltNetListAltNetIP.setDescription('This value indicates the IP address of the Alternate Network.')
mrdAltNetListAltNetNetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 10, 1, 5), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdAltNetListAltNetNetMask.setStatus('mandatory')
if mibBuilder.loadTexts: mrdAltNetListAltNetNetMask.setDescription('This value contains the network mask for the Alternate Network IP address.')
mrdBoundaryList = MibTable((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 11), )
if mibBuilder.loadTexts: mrdBoundaryList.setStatus('mandatory')
if mibBuilder.loadTexts: mrdBoundaryList.setDescription('The mrdBoundaryListTable contains one entry for each boundary entry that is running in the switch.')
mrdBoundaryListEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 11, 1), ).setIndexNames((0, "MRD-MIB", "mrdBoundaryListGrpID"), (0, "MRD-MIB", "mrdBoundaryListVlanMask"), (0, "MRD-MIB", "mrdBoundaryListSrcIP"), (0, "MRD-MIB", "mrdBoundaryListBoundaryIP"))
if mibBuilder.loadTexts: mrdBoundaryListEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mrdBoundaryListEntry.setDescription('An entry in the table, containing information about a Boundary List Table.')
mrdBoundaryListGrpID = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 11, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdBoundaryListGrpID.setStatus('mandatory')
if mibBuilder.loadTexts: mrdBoundaryListGrpID.setDescription('This value indicates the Vlan Group of this entry.')
mrdBoundaryListVlanMask = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 11, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdBoundaryListVlanMask.setStatus('mandatory')
if mibBuilder.loadTexts: mrdBoundaryListVlanMask.setDescription('This value indicates the Vlan Mask of this entry.')
mrdBoundaryListSrcIP = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 11, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdBoundaryListSrcIP.setStatus('mandatory')
if mibBuilder.loadTexts: mrdBoundaryListSrcIP.setDescription('This value indicates the source IP address of the interface.')
mrdBoundaryListBoundaryIP = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 11, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdBoundaryListBoundaryIP.setStatus('mandatory')
if mibBuilder.loadTexts: mrdBoundaryListBoundaryIP.setDescription('This value indicates the IP address of the Boundary entry.')
mrdBoundaryListBoundaryNetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 11, 1, 5), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdBoundaryListBoundaryNetMask.setStatus('mandatory')
if mibBuilder.loadTexts: mrdBoundaryListBoundaryNetMask.setDescription('This value contains the network mask for the Boundary Network IP address.')
mrdGroupMemTable = MibTable((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 12), )
if mibBuilder.loadTexts: mrdGroupMemTable.setStatus('mandatory')
if mibBuilder.loadTexts: mrdGroupMemTable.setDescription('The mrdGroupMem contains one entry for each Multicast Group membership entry that is running in the switch.')
mrdGroupMemEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 12, 1), ).setIndexNames((0, "MRD-MIB", "mrdGroupMemGrpID"), (0, "MRD-MIB", "mrdGroupMemVlanMask"), (0, "MRD-MIB", "mrdGroupMemSrcIP"), (0, "MRD-MIB", "mrdGroupMemIP"))
if mibBuilder.loadTexts: mrdGroupMemEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mrdGroupMemEntry.setDescription('An entry in the table, containing information about a Group Membership Table.')
mrdGroupMemGrpID = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 12, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdGroupMemGrpID.setStatus('mandatory')
if mibBuilder.loadTexts: mrdGroupMemGrpID.setDescription('This value indicates the Vlan Group of this entry.')
mrdGroupMemVlanMask = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 12, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdGroupMemVlanMask.setStatus('mandatory')
if mibBuilder.loadTexts: mrdGroupMemVlanMask.setDescription('This value indicates the Vlan Mask of this entry.')
mrdGroupMemSrcIP = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 12, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdGroupMemSrcIP.setStatus('mandatory')
if mibBuilder.loadTexts: mrdGroupMemSrcIP.setDescription('This value indicates the source IP address of the interface.')
mrdGroupMemIP = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 12, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdGroupMemIP.setStatus('mandatory')
if mibBuilder.loadTexts: mrdGroupMemIP.setDescription('This value indicates the IP address of the IP Multicast group membership.')
mrdGroupMemTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 12, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdGroupMemTimer.setStatus('mandatory')
if mibBuilder.loadTexts: mrdGroupMemTimer.setDescription('This value indicates the number of seconds before this membership times out.')
mrdForwardingTable = MibTable((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 13), )
if mibBuilder.loadTexts: mrdForwardingTable.setStatus('mandatory')
if mibBuilder.loadTexts: mrdForwardingTable.setDescription('The mrdForwardingTable contains one entry for each entry in the forwarding table on the switch.')
mrdForwardingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 13, 1), ).setIndexNames((0, "MRD-MIB", "mrdForwardingSrcIP"), (0, "MRD-MIB", "mrdForwardingDstIP"), (0, "MRD-MIB", "mrdForwardingGrpID"), (0, "MRD-MIB", "mrdForwardingVlanMask"))
if mibBuilder.loadTexts: mrdForwardingEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mrdForwardingEntry.setDescription('An entry in the table, containing information about a Forwarding Table.')
mrdForwardingSrcIP = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 13, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdForwardingSrcIP.setStatus('mandatory')
if mibBuilder.loadTexts: mrdForwardingSrcIP.setDescription('This value indicates the Source IP address of this multicast stream.')
mrdForwardingDstIP = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 13, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdForwardingDstIP.setStatus('mandatory')
if mibBuilder.loadTexts: mrdForwardingDstIP.setDescription('This value indicates the destination IP address of this multicast stream.')
mrdForwardingGrpID = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 13, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdForwardingGrpID.setStatus('mandatory')
if mibBuilder.loadTexts: mrdForwardingGrpID.setDescription('This value indicates the Destination Group ID for this multicast stream.')
mrdForwardingVlanMask = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 13, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdForwardingVlanMask.setStatus('mandatory')
if mibBuilder.loadTexts: mrdForwardingVlanMask.setDescription('This value indicates the Vlan mask of the forwarding group.')
mrdForwardingSrcGrpID = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 13, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdForwardingSrcGrpID.setStatus('mandatory')
if mibBuilder.loadTexts: mrdForwardingSrcGrpID.setDescription('This value contains the Vlan Group ID where this stream originates.')
mrdForwardingSrcVlanMask = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 13, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdForwardingSrcVlanMask.setStatus('mandatory')
if mibBuilder.loadTexts: mrdForwardingSrcVlanMask.setDescription('This value contains the Vlan mask of the source group.')
mrdPruneTable = MibTable((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 14), )
if mibBuilder.loadTexts: mrdPruneTable.setStatus('mandatory')
if mibBuilder.loadTexts: mrdPruneTable.setDescription('The mrdPruneTable contains one entry for each entry in the prune table on the switch.')
mrdPruneEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 14, 1), ).setIndexNames((0, "MRD-MIB", "mrdPruneDstGroup"), (0, "MRD-MIB", "mrdPrunePruningRouter"))
if mibBuilder.loadTexts: mrdPruneEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mrdPruneEntry.setDescription('An entry in the table, containing information about a Prune Table.')
mrdPruneDstGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 14, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdPruneDstGroup.setStatus('mandatory')
if mibBuilder.loadTexts: mrdPruneDstGroup.setDescription('This value indicates the Destination IP address that is being pruned.')
mrdPrunePruningRouter = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 14, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdPrunePruningRouter.setStatus('mandatory')
if mibBuilder.loadTexts: mrdPrunePruningRouter.setDescription('This value indicates the IP address of the router that is pruning.')
mrdPruneGrpID = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 14, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdPruneGrpID.setStatus('mandatory')
if mibBuilder.loadTexts: mrdPruneGrpID.setDescription('This value indicates the Group ID of the pruning router.')
mrdPruneVlanMask = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 14, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdPruneVlanMask.setStatus('mandatory')
if mibBuilder.loadTexts: mrdPruneVlanMask.setDescription('This value indicates the Vlan mask of the pruning router.')
mrdPruneTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 14, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdPruneTimer.setStatus('mandatory')
if mibBuilder.loadTexts: mrdPruneTimer.setDescription('This value contains the timer value associated with this prune entry.')
mrdRouteTable = MibTable((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 15), )
if mibBuilder.loadTexts: mrdRouteTable.setStatus('mandatory')
if mibBuilder.loadTexts: mrdRouteTable.setDescription('The mrdRouteTable contains one entry for each entry in the forwarding table on the switch.')
mrdRouteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 15, 1), ).setIndexNames((0, "MRD-MIB", "mrdRouteOriginIP"), (0, "MRD-MIB", "mrdRouteGatewayIP"), (0, "MRD-MIB", "mrdRouteGrpID"), (0, "MRD-MIB", "mrdRouteVlanMask"), (0, "MRD-MIB", "mrdRouteTunFlag"))
if mibBuilder.loadTexts: mrdRouteEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mrdRouteEntry.setDescription('An entry in the table, containing information about a Route Table.')
mrdRouteOriginIP = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 15, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdRouteOriginIP.setStatus('mandatory')
if mibBuilder.loadTexts: mrdRouteOriginIP.setDescription('This value indicates the IP address of origin of this route.')
mrdRouteOriginMask = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 15, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdRouteOriginMask.setStatus('mandatory')
if mibBuilder.loadTexts: mrdRouteOriginMask.setDescription('This value indicates the network mask of the origin.')
mrdRouteGatewayIP = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 15, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdRouteGatewayIP.setStatus('mandatory')
if mibBuilder.loadTexts: mrdRouteGatewayIP.setDescription('This value indicates the IP address of the gateway.')
mrdRouteGrpID = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 15, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdRouteGrpID.setStatus('mandatory')
if mibBuilder.loadTexts: mrdRouteGrpID.setDescription('This value indicates the Group ID for which the entry has a route.')
mrdRouteVlanMask = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 15, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdRouteVlanMask.setStatus('mandatory')
if mibBuilder.loadTexts: mrdRouteVlanMask.setDescription('This value contains the Vlan mask for the group.')
mrdRouteLeafFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 15, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("isLeaf", 1), ("isNotLeaf", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdRouteLeafFlag.setStatus('mandatory')
if mibBuilder.loadTexts: mrdRouteLeafFlag.setDescription('This value contains a flag indicating if the router in the route entry is a leaf router or not.')
mrdRouteTunFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 15, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("isTunnel", 1), ("isNotTunnel", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdRouteTunFlag.setStatus('mandatory')
if mibBuilder.loadTexts: mrdRouteTunFlag.setDescription('This value contains a flag indicating if the router in the route entry is a tunnel or not.')
mrdRouteSrcGrpID = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 15, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdRouteSrcGrpID.setStatus('mandatory')
if mibBuilder.loadTexts: mrdRouteSrcGrpID.setDescription('This value contains the Vlan group of the interface that received this route entry.')
mrdRouteSrcVlanMask = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 15, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdRouteSrcVlanMask.setStatus('mandatory')
if mibBuilder.loadTexts: mrdRouteSrcVlanMask.setDescription('This value contains the Vlan mask of the source group.')
mrdRouteMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 15, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdRouteMetric.setStatus('mandatory')
if mibBuilder.loadTexts: mrdRouteMetric.setDescription('This value contains the metric for this route.')
mrdRouteTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 3, 1, 1, 15, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrdRouteTimer.setStatus('mandatory')
if mibBuilder.loadTexts: mrdRouteTimer.setDescription('This value contains the timer value for this route entry.')
mibBuilder.exportSymbols("MRD-MIB", mrdRouteLeafFlag=mrdRouteLeafFlag, mrdPeerSrcIP=mrdPeerSrcIP, mrdGroupMemGrpID=mrdGroupMemGrpID, mrdPrunePruningRouter=mrdPrunePruningRouter, mrdTunLocalAddress=mrdTunLocalAddress, mrdGroupVlanMask=mrdGroupVlanMask, mrdGroupID=mrdGroupID, mrdGroupMemSrcIP=mrdGroupMemSrcIP, mrdTunnelThreshold=mrdTunnelThreshold, mrdTunnelListDisabledFlg=mrdTunnelListDisabledFlg, mrdANetAdminState=mrdANetAdminState, mrdPeerPeerIP=mrdPeerPeerIP, mrdTunnelListLeafFlg=mrdTunnelListLeafFlg, mrdTunnelTable=mrdTunnelTable, mrdPruneTable=mrdPruneTable, mrdGroupSrcIP=mrdGroupSrcIP, mrdPruneEntry=mrdPruneEntry, mrdGroupIgmpv1Flg=mrdGroupIgmpv1Flg, mrdGroupDownFlg=mrdGroupDownFlg, mrdIntfBoundaryEntry=mrdIntfBoundaryEntry, mrdAltNetListAltNetIP=mrdAltNetListAltNetIP, mrdAltNetAddr=mrdAltNetAddr, mrdPeerEntry=mrdPeerEntry, mrdPeerMinorLevel=mrdPeerMinorLevel, mrdGroupMemEntry=mrdGroupMemEntry, mrdBoundaryListGrpID=mrdBoundaryListGrpID, mrdForwardingVlanMask=mrdForwardingVlanMask, mrdTunnelListSrcRteFlg=mrdTunnelListSrcRteFlg, mrdTunBoundaryEntry=mrdTunBoundaryEntry, mrdInterfaceEntry=mrdInterfaceEntry, mrdForwardingGrpID=mrdForwardingGrpID, mrdANetMaskLength=mrdANetMaskLength, mrdGroupSrcNetMask=mrdGroupSrcNetMask, mrdBoundaryListEntry=mrdBoundaryListEntry, mrdTunnelListPacketsOut=mrdTunnelListPacketsOut, mrdAltNetList=mrdAltNetList, mrdIFAlternateNetwork=mrdIFAlternateNetwork, mrdForwardingTable=mrdForwardingTable, mrdAltNetListAltNetNetMask=mrdAltNetListAltNetNetMask, mrdRouteVlanMask=mrdRouteVlanMask, mrdPeerTable=mrdPeerTable, mrdIFRateLimit=mrdIFRateLimit, mrdBoundaryListSrcIP=mrdBoundaryListSrcIP, mrdPruneFlag=mrdPruneFlag, mrdVersion=mrdVersion, mrdIntfPhyIntAddr=mrdIntfPhyIntAddr, mrdPeerVlanMask=mrdPeerVlanMask, mrdGroupMemIP=mrdGroupMemIP, mrdIFAddress=mrdIFAddress, mrdTunnelListSrcIP=mrdTunnelListSrcIP, mrdGroupSrcIPNet=mrdGroupSrcIPNet, mrdRouteTimer=mrdRouteTimer, mrdIFEnabledFlag=mrdIFEnabledFlag, mrdTunnelListIgmpv1Flg=mrdTunnelListIgmpv1Flg, mrdGroupPacketsOut=mrdGroupPacketsOut, mrdPeerLeafFlag=mrdPeerLeafFlag, mrdTunnelListEntry=mrdTunnelListEntry, mrdCachedRouteResTime=mrdCachedRouteResTime, mrdGroupMemVlanMask=mrdGroupMemVlanMask, mrdGroupMemTable=mrdGroupMemTable, mrdRouteEntry=mrdRouteEntry, mrdGroupPacketsIn=mrdGroupPacketsIn, mrdIntfBoundaryTable=mrdIntfBoundaryTable, mrdForwardingSrcVlanMask=mrdForwardingSrcVlanMask, mrdRouteOriginMask=mrdRouteOriginMask, mrdTunnelListMetric=mrdTunnelListMetric, mrdForwardingDstIP=mrdForwardingDstIP, mrdIFBoundary=mrdIFBoundary, mrdLocalAddress=mrdLocalAddress, mrdPeerFlags=mrdPeerFlags, mrdConfigUpdate=mrdConfigUpdate, mrdGroupThreshold=mrdGroupThreshold, mrdForwardingSrcIP=mrdForwardingSrcIP, mrdAltNetListVlanMask=mrdAltNetListVlanMask, mrdPruneTimer=mrdPruneTimer, mrdGroupTable=mrdGroupTable, mrdGroupMetric=mrdGroupMetric, mrdRouteGrpID=mrdRouteGrpID, mrdTunnelListDstIP=mrdTunnelListDstIP, mrdRouteTunFlag=mrdRouteTunFlag, mrdGroupLeafFlg=mrdGroupLeafFlg, mrdTunnelEntry=mrdTunnelEntry, mrdMIBObjects=mrdMIBObjects, mrdTunnelListGrpID=mrdTunnelListGrpID, mrdPeerPruneFlag=mrdPeerPruneFlag, mrdBoundaryListBoundaryNetMask=mrdBoundaryListBoundaryNetMask, mrdTunnelMetric=mrdTunnelMetric, mrdGroupMemTimer=mrdGroupMemTimer, mrdPeerGenIdFlag=mrdPeerGenIdFlag, mrdGroupRate=mrdGroupRate, mrdIFAdminState=mrdIFAdminState, mrdTunnelListTable=mrdTunnelListTable, mrdTunnelListThreshold=mrdTunnelListThreshold, mrdPeerGrpID=mrdPeerGrpID, mrdGroupOneWayFlg=mrdGroupOneWayFlg, mrdRouteSrcVlanMask=mrdRouteSrcVlanMask, mrdPeerMtraceFlag=mrdPeerMtraceFlag, mrdTunRemoteAddress=mrdTunRemoteAddress, mrdForwardingEntry=mrdForwardingEntry, mrdAltNetEntry=mrdAltNetEntry, mrdTunnelListVlanMask=mrdTunnelListVlanMask, mrdRouteTable=mrdRouteTable, mrdEnableDisable=mrdEnableDisable, mrdPruneDstGroup=mrdPruneDstGroup, mrdNetworkAddress=mrdNetworkAddress, mrdRemoteAddress=mrdRemoteAddress, mrdGroupEntry=mrdGroupEntry, mrdTunnelListQuerierFlg=mrdTunnelListQuerierFlg, mrdBoundaryList=mrdBoundaryList, mrdTunnelListPacketsIn=mrdTunnelListPacketsIn, mrdTunnelListRate=mrdTunnelListRate, mrdRouteMetric=mrdRouteMetric, mrdIntfScopedAddress=mrdIntfScopedAddress, mrdIFThreshold=mrdIFThreshold, mrdBoundaryListBoundaryIP=mrdBoundaryListBoundaryIP, mrdBoundaryListVlanMask=mrdBoundaryListVlanMask, DisplayString=DisplayString, mrdAltNetListEntry=mrdAltNetListEntry, mrdAltNetTable=mrdAltNetTable, mrdInterfaceTable=mrdInterfaceTable, mrdTunBoundaryTable=mrdTunBoundaryTable, mrdGeneralGroup=mrdGeneralGroup, mrdGroupDisabledFlg=mrdGroupDisabledFlg, mrdIFMetric=mrdIFMetric, mrdAltNetListGrpID=mrdAltNetListGrpID, mrdTunAdminState=mrdTunAdminState, mrdTunBoundMaskLength=mrdTunBoundMaskLength, mrdRouteGatewayIP=mrdRouteGatewayIP, mrdRouteOriginIP=mrdRouteOriginIP, mrdTunnelListOneWayFlg=mrdTunnelListOneWayFlg, mrdTunnelListDownFlg=mrdTunnelListDownFlg, mrdTunnelRateLimit=mrdTunnelRateLimit, mrdRouteSrcGrpID=mrdRouteSrcGrpID, mrdPruneGrpID=mrdPruneGrpID, mrdIntfBoundMaskLength=mrdIntfBoundMaskLength, mrdAltNetListSrcIP=mrdAltNetListSrcIP, mrdPeerTimer=mrdPeerTimer, mrdIntfAdminState=mrdIntfAdminState, mrdGroupQuerierFlg=mrdGroupQuerierFlg, mrdGroupSrcRteFlg=mrdGroupSrcRteFlg, mrdPruneVlanMask=mrdPruneVlanMask, mrdForwardingSrcGrpID=mrdForwardingSrcGrpID, mrdMIB=mrdMIB, mrdPeerMajorLevel=mrdPeerMajorLevel, mrdTunScopedAddress=mrdTunScopedAddress, mrdTunnelAdminState=mrdTunnelAdminState, mrdTunnelBoundary=mrdTunnelBoundary)

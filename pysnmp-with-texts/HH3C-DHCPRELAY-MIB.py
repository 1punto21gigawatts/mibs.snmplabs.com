#
# PySNMP MIB module HH3C-DHCPRELAY-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/HH3C-DHCPRELAY-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:25:58 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ValueRangeConstraint, SingleValueConstraint, ValueSizeConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ValueRangeConstraint", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsIntersection")
hh3cCommon, = mibBuilder.importSymbols("HH3C-OID-MIB", "hh3cCommon")
ifIndex, = mibBuilder.importSymbols("IF-MIB", "ifIndex")
InetAddress, InetAddressType = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddress", "InetAddressType")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
ObjectIdentity, TimeTicks, MibScalar, MibTable, MibTableRow, MibTableColumn, Gauge32, ModuleIdentity, iso, Unsigned32, Integer32, MibIdentifier, Counter32, NotificationType, Bits, IpAddress, Counter64 = mibBuilder.importSymbols("SNMPv2-SMI", "ObjectIdentity", "TimeTicks", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Gauge32", "ModuleIdentity", "iso", "Unsigned32", "Integer32", "MibIdentifier", "Counter32", "NotificationType", "Bits", "IpAddress", "Counter64")
TextualConvention, DisplayString, MacAddress, TruthValue, RowStatus = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString", "MacAddress", "TruthValue", "RowStatus")
hh3cDhcpRelay = ModuleIdentity((1, 3, 6, 1, 4, 1, 25506, 2, 58))
hh3cDhcpRelay.setRevisions(('2005-06-08 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: hh3cDhcpRelay.setRevisionsDescriptions(('The initial version of this MIB module.',))
if mibBuilder.loadTexts: hh3cDhcpRelay.setLastUpdated('200506080000Z')
if mibBuilder.loadTexts: hh3cDhcpRelay.setOrganization('Hangzhou H3C Tech. Co., Ltd.')
if mibBuilder.loadTexts: hh3cDhcpRelay.setContactInfo('Platform Team Hangzhou H3C Tech. Co., Ltd. Hai-Dian District Beijing P.R. China http://www.h3c.com Zip:100085 ')
if mibBuilder.loadTexts: hh3cDhcpRelay.setDescription('H3C DHCPR MIB')
hh3cDHCPRMibObject = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 58, 1))
hh3cDHCPRIfSelectTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 58, 1, 1), )
if mibBuilder.loadTexts: hh3cDHCPRIfSelectTable.setStatus('current')
if mibBuilder.loadTexts: hh3cDHCPRIfSelectTable.setDescription('A table for configuring relay mode for interfaces. ')
hh3cDHCPRIfSelectEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 58, 1, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: hh3cDHCPRIfSelectEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cDHCPRIfSelectEntry.setDescription('An entry for configuring relay mode for an interface. ')
hh3cDHCPRIfSelectRelayMode = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 58, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDHCPRIfSelectRelayMode.setStatus('current')
if mibBuilder.loadTexts: hh3cDHCPRIfSelectRelayMode.setDescription('If the value is on, the DHCP relay function would be enabled on this interface. ')
hh3cDHCPRIpToGroupTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 58, 1, 2), )
if mibBuilder.loadTexts: hh3cDHCPRIpToGroupTable.setStatus('current')
if mibBuilder.loadTexts: hh3cDHCPRIpToGroupTable.setDescription('A table for configuring ip addresses for DHCP server groups. ')
hh3cDHCPRIpToGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 58, 1, 2, 1), ).setIndexNames((0, "HH3C-DHCPRELAY-MIB", "hh3cDHCPRIpToGroupGroupId"), (0, "HH3C-DHCPRELAY-MIB", "hh3cDHCPRIpToGroupServerIpType"), (0, "HH3C-DHCPRELAY-MIB", "hh3cDHCPRIpToGroupServerIp"))
if mibBuilder.loadTexts: hh3cDHCPRIpToGroupEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cDHCPRIpToGroupEntry.setDescription('An entry for configuring ip addresses for a DHCP server group. ')
hh3cDHCPRIpToGroupGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 58, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 19)))
if mibBuilder.loadTexts: hh3cDHCPRIpToGroupGroupId.setStatus('current')
if mibBuilder.loadTexts: hh3cDHCPRIpToGroupGroupId.setDescription('Group identifier of DHCP server group. ')
hh3cDHCPRIpToGroupServerIpType = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 58, 1, 2, 1, 2), InetAddressType())
if mibBuilder.loadTexts: hh3cDHCPRIpToGroupServerIpType.setStatus('current')
if mibBuilder.loadTexts: hh3cDHCPRIpToGroupServerIpType.setDescription('Ip address type of DHCP server. ')
hh3cDHCPRIpToGroupServerIp = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 58, 1, 2, 1, 3), InetAddress().subtype(subtypeSpec=ValueSizeConstraint(1, 64)))
if mibBuilder.loadTexts: hh3cDHCPRIpToGroupServerIp.setStatus('current')
if mibBuilder.loadTexts: hh3cDHCPRIpToGroupServerIp.setDescription('Ip address of DHCP server. ')
hh3cDHCPRIpToGroupRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 58, 1, 2, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDHCPRIpToGroupRowStatus.setStatus('current')
if mibBuilder.loadTexts: hh3cDHCPRIpToGroupRowStatus.setDescription('Operation status of this table entry. Three actions are used: active, createAndGo, destroy. ')
hh3cDHCPRIfToGroupTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 58, 1, 3), )
if mibBuilder.loadTexts: hh3cDHCPRIfToGroupTable.setStatus('current')
if mibBuilder.loadTexts: hh3cDHCPRIfToGroupTable.setDescription('A table for configuring DHCP server groups for interfaces. ')
hh3cDHCPRIfToGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 58, 1, 3, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: hh3cDHCPRIfToGroupEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cDHCPRIfToGroupEntry.setDescription('An entry for configuring DHCP server group for an interface. ')
hh3cDHCPRIfToGroupGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 58, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 19))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDHCPRIfToGroupGroupId.setStatus('current')
if mibBuilder.loadTexts: hh3cDHCPRIfToGroupGroupId.setDescription('The DHCP server group for this interface. ')
hh3cDHCPRIfToGroupRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 58, 1, 3, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDHCPRIfToGroupRowStatus.setStatus('current')
if mibBuilder.loadTexts: hh3cDHCPRIfToGroupRowStatus.setDescription('Operation status of this table entry. Three actions are used: active, createAndGo, destroy')
hh3cDHCPRAddrCheckTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 58, 1, 4), )
if mibBuilder.loadTexts: hh3cDHCPRAddrCheckTable.setStatus('current')
if mibBuilder.loadTexts: hh3cDHCPRAddrCheckTable.setDescription('A table containing the states of dhcp security address check switchs for interfaces. ')
hh3cDHCPRAddrCheckEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 58, 1, 4, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: hh3cDHCPRAddrCheckEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cDHCPRAddrCheckEntry.setDescription('An entry containing the state of dhcp security address check switch for an interface. ')
hh3cDHCPRAddrCheckSwitch = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 58, 1, 4, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDHCPRAddrCheckSwitch.setStatus('current')
if mibBuilder.loadTexts: hh3cDHCPRAddrCheckSwitch.setDescription('The state of dhcp security address check switch for this interface. It has two defined values: enabled and disabled. If the value is enabled, the address check function would be enabled. The default value is disabled. ')
hh3cDHCPRSecurityTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 58, 1, 5), )
if mibBuilder.loadTexts: hh3cDHCPRSecurityTable.setStatus('current')
if mibBuilder.loadTexts: hh3cDHCPRSecurityTable.setDescription('A table containing the information of DHCP security. ')
hh3cDHCPRSecurityEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 58, 1, 5, 1), ).setIndexNames((0, "HH3C-DHCPRELAY-MIB", "hh3cDHCPRSecurityClientIpAddrType"), (0, "HH3C-DHCPRELAY-MIB", "hh3cDHCPRSecurityClientIpAddr"))
if mibBuilder.loadTexts: hh3cDHCPRSecurityEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cDHCPRSecurityEntry.setDescription('An entry containing the information of DHCP security. ')
hh3cDHCPRSecurityClientIpAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 58, 1, 5, 1, 1), InetAddressType())
if mibBuilder.loadTexts: hh3cDHCPRSecurityClientIpAddrType.setStatus('current')
if mibBuilder.loadTexts: hh3cDHCPRSecurityClientIpAddrType.setDescription("DHCP client's net ip address type")
hh3cDHCPRSecurityClientIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 58, 1, 5, 1, 2), InetAddress().subtype(subtypeSpec=ValueSizeConstraint(1, 64)))
if mibBuilder.loadTexts: hh3cDHCPRSecurityClientIpAddr.setStatus('current')
if mibBuilder.loadTexts: hh3cDHCPRSecurityClientIpAddr.setDescription("DHCP client's net ip address")
hh3cDHCPRSecurityClientMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 58, 1, 5, 1, 3), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDHCPRSecurityClientMacAddr.setStatus('current')
if mibBuilder.loadTexts: hh3cDHCPRSecurityClientMacAddr.setDescription("DHCP client's mac address")
hh3cDHCPRSecurityClientProperty = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 58, 1, 5, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("static", 1), ("dynamic", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDHCPRSecurityClientProperty.setStatus('current')
if mibBuilder.loadTexts: hh3cDHCPRSecurityClientProperty.setDescription('Property of client address')
hh3cDHCPRSecurityClientRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 58, 1, 5, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDHCPRSecurityClientRowStatus.setStatus('current')
if mibBuilder.loadTexts: hh3cDHCPRSecurityClientRowStatus.setDescription('Operation status of this table entry. Three actions are used: active, createAndGo, destroy')
hh3cDHCPRStatisticsGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 58, 1, 6))
hh3cDHCPRRxClientPktNum = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 58, 1, 6, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDHCPRRxClientPktNum.setStatus('current')
if mibBuilder.loadTexts: hh3cDHCPRRxClientPktNum.setDescription('The total number of the packets received from DHCP clients by DHCP relay. ')
hh3cDHCPRTxClientPktNum = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 58, 1, 6, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDHCPRTxClientPktNum.setStatus('current')
if mibBuilder.loadTexts: hh3cDHCPRTxClientPktNum.setDescription('The total number of the brodcast packets transmitted to DHCP clients by DHCP relay. ')
hh3cDHCPRRxServerPktNum = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 58, 1, 6, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDHCPRRxServerPktNum.setStatus('current')
if mibBuilder.loadTexts: hh3cDHCPRRxServerPktNum.setDescription('The total number of the packets received from DHCP Servers by DHCP relay. ')
hh3cDHCPRTxServerPktNum = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 58, 1, 6, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDHCPRTxServerPktNum.setStatus('current')
if mibBuilder.loadTexts: hh3cDHCPRTxServerPktNum.setDescription('The total number of the packets transmitted to DHCP Servers by DHCP relay. ')
hh3cDHCPRDiscoverPktNum = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 58, 1, 6, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDHCPRDiscoverPktNum.setStatus('current')
if mibBuilder.loadTexts: hh3cDHCPRDiscoverPktNum.setDescription('The total number of the DHCP Discover packets handled by DHCP relay. ')
hh3cDHCPRRequestPktNum = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 58, 1, 6, 6), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDHCPRRequestPktNum.setStatus('current')
if mibBuilder.loadTexts: hh3cDHCPRRequestPktNum.setDescription('The total number of the DHCP Request packets handled by DHCP relay. ')
hh3cDHCPRDeclinePktNum = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 58, 1, 6, 7), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDHCPRDeclinePktNum.setStatus('current')
if mibBuilder.loadTexts: hh3cDHCPRDeclinePktNum.setDescription('The total number of the DHCP Decline packets handled by DHCP relay. ')
hh3cDHCPRReleasePktNum = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 58, 1, 6, 8), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDHCPRReleasePktNum.setStatus('current')
if mibBuilder.loadTexts: hh3cDHCPRReleasePktNum.setDescription('The total number of the DHCP Release packets handled by DHCP relay. ')
hh3cDHCPRInformPktNum = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 58, 1, 6, 9), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDHCPRInformPktNum.setStatus('current')
if mibBuilder.loadTexts: hh3cDHCPRInformPktNum.setDescription('The total number of the DHCP Inform packets handled by DHCP relay. ')
hh3cDHCPROfferPktNum = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 58, 1, 6, 10), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDHCPROfferPktNum.setStatus('current')
if mibBuilder.loadTexts: hh3cDHCPROfferPktNum.setDescription('The total number of the DHCP Offer packets handled by DHCP relay. ')
hh3cDHCPRAckPktNum = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 58, 1, 6, 11), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDHCPRAckPktNum.setStatus('current')
if mibBuilder.loadTexts: hh3cDHCPRAckPktNum.setDescription('The total number of the DHCP Ack packets handled by DHCP relay. ')
hh3cDHCPRNakPktNum = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 58, 1, 6, 12), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDHCPRNakPktNum.setStatus('current')
if mibBuilder.loadTexts: hh3cDHCPRNakPktNum.setDescription('The total number of the DHCP Nak packets handled by DHCP relay. ')
hh3cDHCPRStatisticsReset = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 58, 1, 6, 13), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDHCPRStatisticsReset.setStatus('current')
if mibBuilder.loadTexts: hh3cDHCPRStatisticsReset.setDescription('This node only supports set operation. If the value is true,it will clear all of the packet statistics. ')
hh3cDHCPRCycleGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 58, 1, 7))
hh3cDHCPRCycleStatus = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 58, 1, 7, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDHCPRCycleStatus.setStatus('current')
if mibBuilder.loadTexts: hh3cDHCPRCycleStatus.setDescription('If the value is on, the cycle function would be enabled. ')
hh3cDHCPRConfigOption82Group = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 58, 1, 8))
hh3cDHCPROption82Switch = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 58, 1, 8, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDHCPROption82Switch.setStatus('current')
if mibBuilder.loadTexts: hh3cDHCPROption82Switch.setDescription('If the value is enabled, DHCP relay supporting option 82 function would be enabled. ')
hh3cDHCPROption82HandleStrategy = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 58, 1, 8, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("drop", 1), ("keep", 2), ("replace", 3))).clone('replace')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDHCPROption82HandleStrategy.setStatus('current')
if mibBuilder.loadTexts: hh3cDHCPROption82HandleStrategy.setDescription("The strategies of DHCP relay handling option 82. 'drop' indicates DHCP relay discarding the request packet including option 82. 'keep' indicates DHCP relay accepting the request packet without any change of the option 82. 'replace' indicates DHCP relay accepting the request packet on condition that it generates a new option 82 to replace the original one. ")
hh3cDHCPRConfigOption82IfTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 58, 1, 8, 3), )
if mibBuilder.loadTexts: hh3cDHCPRConfigOption82IfTable.setStatus('current')
if mibBuilder.loadTexts: hh3cDHCPRConfigOption82IfTable.setDescription('A table containing the information of DHCP option 82. This table depends on hh3cDHCPRIfToGroupTable. An entry of this table will be created when an entry of hh3cDHCPRIfToGroupTable is created. ')
hh3cDHCPRConfigOption82IfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 58, 1, 8, 3, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: hh3cDHCPRConfigOption82IfEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cDHCPRConfigOption82IfEntry.setDescription('An entry containing the information of DHCP option 82. ')
hh3cDHCPROption82IfSwitch = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 58, 1, 8, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDHCPROption82IfSwitch.setStatus('current')
if mibBuilder.loadTexts: hh3cDHCPROption82IfSwitch.setDescription("If DHCP relay supports option 82 functions, the value is 'enabled'. If DHCP relay does not support option 82 functions, the value is 'disabled'. ")
hh3cDHCPROption82IfStrategy = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 58, 1, 8, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("drop", 1), ("keep", 2), ("replace", 3))).clone('replace')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDHCPROption82IfStrategy.setStatus('current')
if mibBuilder.loadTexts: hh3cDHCPROption82IfStrategy.setDescription("The strategies of DHCP relay handling option 82. 'drop' indicates DHCP relay discarding the request packet including option 82. 'keep' indicates DHCP relay accepting the request packet without any change of the option 82. 'replace' indicates DHCP relay accepting the request packet on condition that it generates a new option 82 to replace the original one. ")
hh3cDHCPROption82IfFormat = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 58, 1, 8, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normal", 1), ("verbose", 2))).clone('normal')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDHCPROption82IfFormat.setStatus('current')
if mibBuilder.loadTexts: hh3cDHCPROption82IfFormat.setDescription("The format of DHCP relay option 82. 'normal' is the standard format. 'verbose' is the detailed format. ")
hh3cDHCPROption82IfNodeType = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 58, 1, 8, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("invalid", 1), ("mac", 2), ("sysname", 3), ("userdefine", 4))).clone('invalid')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDHCPROption82IfNodeType.setStatus('current')
if mibBuilder.loadTexts: hh3cDHCPROption82IfNodeType.setDescription("Property of DHCP relay option 82 verbose format. The value can be set by user only when the value of hh3cDHCPROption82IfFormat is set with 'verbose'. If the value of hh3cDHCPROption82IfFormat is 'normal', the value is automatically set with 'invalid'. the value can not be set with 'invalid' by user. 'mac' indicates the option 82 verbose format is filled in with the mac of DHCP relay input interface. If the value of hh3cDHCPROption82IfFormat is set with 'verbose', the value is automatically set with 'mac'. 'sysname' indicates the option 82 verbose format is filled in with the name of the DHCP relay. 'userdefine' indicates the option 82 verbose format is filled in with the string defined by user. If the value is set with 'userdefine', the value of hh3cDHCPROption82IfUsrDefString must be set simultaneously. ")
hh3cDHCPROption82IfUsrDefString = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 58, 1, 8, 3, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 256))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDHCPROption82IfUsrDefString.setStatus('current')
if mibBuilder.loadTexts: hh3cDHCPROption82IfUsrDefString.setDescription("The string defined by user to fill in the option 82 verbose format. If the value of hh3cDHCPROption82IfFormat is 'normal', or the value of hh3cDHCPROption82IfNodeType is 'mac' or 'sysname', it is set with a null string automatically and can not be modified by user. It must be set with a non-zero length string when the value of hh3cDHCPROption82IfNodeType is set with 'userdefine'. ")
mibBuilder.exportSymbols("HH3C-DHCPRELAY-MIB", hh3cDHCPRSecurityEntry=hh3cDHCPRSecurityEntry, hh3cDHCPRTxClientPktNum=hh3cDHCPRTxClientPktNum, hh3cDHCPROption82HandleStrategy=hh3cDHCPROption82HandleStrategy, hh3cDHCPROption82IfFormat=hh3cDHCPROption82IfFormat, hh3cDHCPRIfSelectEntry=hh3cDHCPRIfSelectEntry, hh3cDHCPRIfToGroupGroupId=hh3cDHCPRIfToGroupGroupId, hh3cDHCPRIfToGroupTable=hh3cDHCPRIfToGroupTable, hh3cDHCPRMibObject=hh3cDHCPRMibObject, hh3cDHCPROption82IfNodeType=hh3cDHCPROption82IfNodeType, hh3cDhcpRelay=hh3cDhcpRelay, hh3cDHCPRIpToGroupEntry=hh3cDHCPRIpToGroupEntry, hh3cDHCPRAddrCheckSwitch=hh3cDHCPRAddrCheckSwitch, hh3cDHCPRRxClientPktNum=hh3cDHCPRRxClientPktNum, hh3cDHCPRReleasePktNum=hh3cDHCPRReleasePktNum, hh3cDHCPRInformPktNum=hh3cDHCPRInformPktNum, hh3cDHCPROption82IfStrategy=hh3cDHCPROption82IfStrategy, hh3cDHCPRIfToGroupEntry=hh3cDHCPRIfToGroupEntry, hh3cDHCPRIfToGroupRowStatus=hh3cDHCPRIfToGroupRowStatus, hh3cDHCPRStatisticsGroup=hh3cDHCPRStatisticsGroup, hh3cDHCPRConfigOption82Group=hh3cDHCPRConfigOption82Group, hh3cDHCPRRequestPktNum=hh3cDHCPRRequestPktNum, hh3cDHCPRSecurityClientIpAddr=hh3cDHCPRSecurityClientIpAddr, hh3cDHCPRCycleStatus=hh3cDHCPRCycleStatus, hh3cDHCPRTxServerPktNum=hh3cDHCPRTxServerPktNum, hh3cDHCPRDeclinePktNum=hh3cDHCPRDeclinePktNum, hh3cDHCPRIpToGroupGroupId=hh3cDHCPRIpToGroupGroupId, hh3cDHCPRIpToGroupRowStatus=hh3cDHCPRIpToGroupRowStatus, hh3cDHCPROption82Switch=hh3cDHCPROption82Switch, hh3cDHCPRIpToGroupServerIp=hh3cDHCPRIpToGroupServerIp, hh3cDHCPRRxServerPktNum=hh3cDHCPRRxServerPktNum, hh3cDHCPRConfigOption82IfEntry=hh3cDHCPRConfigOption82IfEntry, hh3cDHCPRSecurityTable=hh3cDHCPRSecurityTable, hh3cDHCPRIpToGroupTable=hh3cDHCPRIpToGroupTable, hh3cDHCPRSecurityClientProperty=hh3cDHCPRSecurityClientProperty, hh3cDHCPRIpToGroupServerIpType=hh3cDHCPRIpToGroupServerIpType, hh3cDHCPRAckPktNum=hh3cDHCPRAckPktNum, hh3cDHCPRStatisticsReset=hh3cDHCPRStatisticsReset, hh3cDHCPROfferPktNum=hh3cDHCPROfferPktNum, hh3cDHCPROption82IfSwitch=hh3cDHCPROption82IfSwitch, hh3cDHCPRSecurityClientRowStatus=hh3cDHCPRSecurityClientRowStatus, hh3cDHCPRNakPktNum=hh3cDHCPRNakPktNum, hh3cDHCPRAddrCheckEntry=hh3cDHCPRAddrCheckEntry, hh3cDHCPRAddrCheckTable=hh3cDHCPRAddrCheckTable, hh3cDHCPRDiscoverPktNum=hh3cDHCPRDiscoverPktNum, PYSNMP_MODULE_ID=hh3cDhcpRelay, hh3cDHCPROption82IfUsrDefString=hh3cDHCPROption82IfUsrDefString, hh3cDHCPRIfSelectTable=hh3cDHCPRIfSelectTable, hh3cDHCPRSecurityClientIpAddrType=hh3cDHCPRSecurityClientIpAddrType, hh3cDHCPRConfigOption82IfTable=hh3cDHCPRConfigOption82IfTable, hh3cDHCPRIfSelectRelayMode=hh3cDHCPRIfSelectRelayMode, hh3cDHCPRCycleGroup=hh3cDHCPRCycleGroup, hh3cDHCPRSecurityClientMacAddr=hh3cDHCPRSecurityClientMacAddr)

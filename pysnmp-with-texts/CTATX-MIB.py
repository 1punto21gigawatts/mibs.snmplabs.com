#
# PySNMP MIB module CTATX-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CTATX-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:29:11 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ConstraintsIntersection, ValueSizeConstraint, ValueRangeConstraint, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ConstraintsIntersection", "ValueSizeConstraint", "ValueRangeConstraint", "SingleValueConstraint")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Unsigned32, NotificationType, MibIdentifier, ModuleIdentity, enterprises, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter32, Integer32, ObjectIdentity, Gauge32, iso, Counter64, Bits, IpAddress, TimeTicks = mibBuilder.importSymbols("SNMPv2-SMI", "Unsigned32", "NotificationType", "MibIdentifier", "ModuleIdentity", "enterprises", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter32", "Integer32", "ObjectIdentity", "Gauge32", "iso", "Counter64", "Bits", "IpAddress", "TimeTicks")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
class Boolean(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("true", 1), ("false", 2))

sigma = MibIdentifier((1, 3, 6, 1, 4, 1, 97))
sys = MibIdentifier((1, 3, 6, 1, 4, 1, 97, 1))
ecs_1 = MibIdentifier((1, 3, 6, 1, 4, 1, 97, 3)).setLabel("ecs-1")
atext = MibIdentifier((1, 3, 6, 1, 4, 1, 97, 6))
hw = MibIdentifier((1, 3, 6, 1, 4, 1, 97, 3, 1))
sw = MibIdentifier((1, 3, 6, 1, 4, 1, 97, 3, 2))
admin = MibIdentifier((1, 3, 6, 1, 4, 1, 97, 3, 3))
config = MibIdentifier((1, 3, 6, 1, 4, 1, 97, 3, 3, 1))
lma = MibIdentifier((1, 3, 6, 1, 4, 1, 97, 3, 3, 2))
ppe = MibIdentifier((1, 3, 6, 1, 4, 1, 97, 3, 3, 3))
st = MibIdentifier((1, 3, 6, 1, 4, 1, 97, 3, 3, 4))
mesh = MibIdentifier((1, 3, 6, 1, 4, 1, 97, 3, 3, 5))
atextsystem = MibIdentifier((1, 3, 6, 1, 4, 1, 97, 6, 1))
atextport = MibIdentifier((1, 3, 6, 1, 4, 1, 97, 6, 2))
swdis = MibIdentifier((1, 3, 6, 1, 4, 1, 97, 3, 4))
addr = MibIdentifier((1, 3, 6, 1, 4, 1, 97, 3, 5))
snmpsmt = MibIdentifier((1, 3, 6, 1, 4, 1, 97, 3, 6))
sinterfaces = MibIdentifier((1, 3, 6, 1, 4, 1, 97, 3, 7))
sfddi = MibIdentifier((1, 3, 6, 1, 4, 1, 97, 3, 8))
suart = MibIdentifier((1, 3, 6, 1, 4, 1, 97, 3, 9))
filter = MibIdentifier((1, 3, 6, 1, 4, 1, 97, 3, 10))
reboot = MibIdentifier((1, 3, 6, 1, 4, 1, 97, 3, 11))
debug = MibIdentifier((1, 3, 6, 1, 4, 1, 97, 3, 12))
lpbk = MibIdentifier((1, 3, 6, 1, 4, 1, 97, 3, 13))
swan = MibIdentifier((1, 3, 6, 1, 4, 1, 97, 3, 14))
srepeater = MibIdentifier((1, 3, 6, 1, 4, 1, 97, 3, 16))
sproto = MibIdentifier((1, 3, 6, 1, 4, 1, 97, 3, 17))
sipx = MibIdentifier((1, 3, 6, 1, 4, 1, 97, 3, 18))
sipxsfGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 97, 3, 18, 6))
sipxsrGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 97, 3, 18, 7))
srtrdisc = MibIdentifier((1, 3, 6, 1, 4, 1, 97, 3, 19))
sipm = MibIdentifier((1, 3, 6, 1, 4, 1, 97, 3, 20))
sipmroute = MibIdentifier((1, 3, 6, 1, 4, 1, 97, 3, 20, 1))
sipmgroup = MibIdentifier((1, 3, 6, 1, 4, 1, 97, 3, 20, 2))
sipmneighbor = MibIdentifier((1, 3, 6, 1, 4, 1, 97, 3, 20, 3))
sipmstat = MibIdentifier((1, 3, 6, 1, 4, 1, 97, 3, 20, 4))
sipckt = MibIdentifier((1, 3, 6, 1, 4, 1, 97, 3, 21))
ssecure = MibIdentifier((1, 3, 6, 1, 4, 1, 97, 3, 23))
spvc = MibIdentifier((1, 3, 6, 1, 4, 1, 97, 3, 24))
strunk = MibIdentifier((1, 3, 6, 1, 4, 1, 97, 3, 25))
ipMRouteMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 97, 3, 26))
igmpMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 97, 3, 27))
ipMRouteMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 97, 3, 26, 1))
ipMRoute = MibIdentifier((1, 3, 6, 1, 4, 1, 97, 3, 26, 1, 1))
igmpMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 97, 3, 27, 1))
igmp = MibIdentifier((1, 3, 6, 1, 4, 1, 97, 3, 27, 1, 1))
slog = MibIdentifier((1, 3, 6, 1, 4, 1, 97, 3, 28))
strap = MibIdentifier((1, 3, 6, 1, 4, 1, 97, 3, 29))
smirror = MibIdentifier((1, 3, 6, 1, 4, 1, 97, 3, 30))
sworkgroup = MibIdentifier((1, 3, 6, 1, 4, 1, 97, 3, 31))
sping = MibIdentifier((1, 3, 6, 1, 4, 1, 97, 3, 32))
strace = MibIdentifier((1, 3, 6, 1, 4, 1, 97, 3, 33))
srtb = MibIdentifier((1, 3, 6, 1, 4, 1, 97, 3, 34))
nbcache = MibIdentifier((1, 3, 6, 1, 4, 1, 97, 3, 35))
ipMRouteEnable = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 26, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipMRouteEnable.setStatus('mandatory')
if mibBuilder.loadTexts: ipMRouteEnable.setDescription('The enabled status of IP Multicast routing on this router.')
ipMRouteTable = MibTable((1, 3, 6, 1, 4, 1, 97, 3, 26, 1, 1, 2), )
if mibBuilder.loadTexts: ipMRouteTable.setStatus('mandatory')
if mibBuilder.loadTexts: ipMRouteTable.setDescription('The (conceptual) table containg multicast routing information for IP datagrams sent by particular sources to the IP multicast groups known to this router.')
ipMRouteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 97, 3, 26, 1, 1, 2, 1), ).setIndexNames((0, "CTATX-MIB", "ipMRouteGroup"), (0, "CTATX-MIB", "ipMRouteSource"), (0, "CTATX-MIB", "ipMRouteSourceMask"))
if mibBuilder.loadTexts: ipMRouteEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ipMRouteEntry.setDescription('An entry (conceptual row) containing the multicast routing information for IP datagrams from a particular source and addressed to a particular IP multicast group address.')
ipMRouteGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 26, 1, 1, 2, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMRouteGroup.setStatus('mandatory')
if mibBuilder.loadTexts: ipMRouteGroup.setDescription('The IP multicast group address for which this entry contains multicast routing information.')
ipMRouteSource = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 26, 1, 1, 2, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMRouteSource.setStatus('mandatory')
if mibBuilder.loadTexts: ipMRouteSource.setDescription('The source network address for which this entry contains multicast routing information.')
ipMRouteSourceMask = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 26, 1, 1, 2, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMRouteSourceMask.setStatus('mandatory')
if mibBuilder.loadTexts: ipMRouteSourceMask.setDescription('The network mask of the source address for which this entry contains multicast routing information.')
ipMRouteRpfNeighbor = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 26, 1, 1, 2, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMRouteRpfNeighbor.setStatus('mandatory')
if mibBuilder.loadTexts: ipMRouteRpfNeighbor.setDescription('The address of the RPF neighbor from which IP datagrams from this source to this multicast address are received.')
ipMRouteInIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 26, 1, 1, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMRouteInIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ipMRouteInIfIndex.setDescription('The value of ifIndex for the interface on which IP datagrams sent by this source to this multicast address are received.')
ipMRouteOutList = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 26, 1, 1, 2, 1, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMRouteOutList.setStatus('mandatory')
if mibBuilder.loadTexts: ipMRouteOutList.setDescription('The value of ipMRouteNextHopList which identifies the list of entries in the ipMRouteNextHopTable representing outgoing interfaces to which IP datagrams from this source to this multicast group address are forwarded.')
ipMRouteUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 26, 1, 1, 2, 1, 7), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMRouteUpTime.setStatus('mandatory')
if mibBuilder.loadTexts: ipMRouteUpTime.setDescription('The time since the multicast routing information represented by this entry was learned by the router.')
ipMRouteExpiryTime = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 26, 1, 1, 2, 1, 8), TimeTicks()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipMRouteExpiryTime.setStatus('mandatory')
if mibBuilder.loadTexts: ipMRouteExpiryTime.setDescription('The minimum amount of time remaining before this entry will be aged out.')
ipMRoutePkts = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 26, 1, 1, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMRoutePkts.setStatus('mandatory')
if mibBuilder.loadTexts: ipMRoutePkts.setDescription('The number of packets which this router has received from this source and addressed to this multicast group address.')
ipMRouteRpfFails = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 26, 1, 1, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMRouteRpfFails.setStatus('mandatory')
if mibBuilder.loadTexts: ipMRouteRpfFails.setDescription('The number of packets which this router has received from this source and addressed to this multicast group address, which were not received from the interface indicated by ipMRouteInIfIndex.')
ipMRouteOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 26, 1, 1, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMRouteOctets.setStatus('mandatory')
if mibBuilder.loadTexts: ipMRouteOctets.setDescription('The number of octets contained in IP datagrams which were received from this source and addressed to this multicast group address, and which were forwarded by this router.')
ipMRouteNextHopState = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 26, 1, 1, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("pruned", 1), ("forwarding", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMRouteNextHopState.setStatus('mandatory')
if mibBuilder.loadTexts: ipMRouteNextHopState.setDescription("An indication of whether the outgoing interface and next hop represented by this entry is currently being used to forward IP datagrams. The value 'forwarding' indicates it is currently being used; the value 'pruned' indicates it is not.")
ipMRouteInterfaceTable = MibTable((1, 3, 6, 1, 4, 1, 97, 3, 26, 1, 1, 3), )
if mibBuilder.loadTexts: ipMRouteInterfaceTable.setStatus('mandatory')
if mibBuilder.loadTexts: ipMRouteInterfaceTable.setDescription('The (conceptual) table containg multicast routing information specific to interfaces.')
ipMRouteInterfaceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 97, 3, 26, 1, 1, 3, 1), ).setIndexNames((0, "CTATX-MIB", "ipMRouteInterfaceIfIndex"))
if mibBuilder.loadTexts: ipMRouteInterfaceEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ipMRouteInterfaceEntry.setDescription('An entry (conceptual row) containing the multicast routing information for a particular interface.')
ipMRouteInterfaceIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 26, 1, 1, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMRouteInterfaceIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ipMRouteInterfaceIfIndex.setDescription('The ifIndex value of the interface for which this entry contains information.')
ipMRouteInterfaceTtl = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 26, 1, 1, 3, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipMRouteInterfaceTtl.setStatus('mandatory')
if mibBuilder.loadTexts: ipMRouteInterfaceTtl.setDescription('The datagram TTL threshold for the interface. Any IP multicast datagrams with a TTL less than this threshold will not be forwarded out the interface. The default value of 0 means all multicast packets are forwarded out interface.')
igmpInterfaceTable = MibTable((1, 3, 6, 1, 4, 1, 97, 3, 27, 1, 1, 1), )
if mibBuilder.loadTexts: igmpInterfaceTable.setStatus('mandatory')
if mibBuilder.loadTexts: igmpInterfaceTable.setDescription('The (conceptual) table listing the interfaces on which IGMP is enabled.')
igmpInterfaceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 97, 3, 27, 1, 1, 1, 1), ).setIndexNames((0, "CTATX-MIB", "igmpInterfaceIfIndex"))
if mibBuilder.loadTexts: igmpInterfaceEntry.setStatus('mandatory')
if mibBuilder.loadTexts: igmpInterfaceEntry.setDescription('An entry (conceptual row) representing an interface on which IGMP is enabled.')
igmpInterfaceIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 27, 1, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpInterfaceIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: igmpInterfaceIfIndex.setDescription('The interface for which IGMP is enabled.')
igmpInterfaceQueryInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 27, 1, 1, 1, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igmpInterfaceQueryInterval.setStatus('mandatory')
if mibBuilder.loadTexts: igmpInterfaceQueryInterval.setDescription('The frequency at which IGMP Host-Query packets are transmitted on this interface.')
igmpInterfaceStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 27, 1, 1, 1, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igmpInterfaceStatus.setStatus('mandatory')
if mibBuilder.loadTexts: igmpInterfaceStatus.setDescription('The activation of a row enables IGMP on the interface. The destruction of a row disables IGMP on the interface.')
igmpCacheTable = MibTable((1, 3, 6, 1, 4, 1, 97, 3, 27, 1, 1, 2), )
if mibBuilder.loadTexts: igmpCacheTable.setStatus('mandatory')
if mibBuilder.loadTexts: igmpCacheTable.setDescription('The (conceptual) table listing the IP multicast groups for which there are members on a particular interface.')
igmpCacheEntry = MibTableRow((1, 3, 6, 1, 4, 1, 97, 3, 27, 1, 1, 2, 1), ).setIndexNames((0, "CTATX-MIB", "igmpCacheAddress"), (0, "CTATX-MIB", "igmpCacheIfIndex"))
if mibBuilder.loadTexts: igmpCacheEntry.setStatus('mandatory')
if mibBuilder.loadTexts: igmpCacheEntry.setDescription('An entry (conceptual row) in the igmpCacheTable.')
igmpCacheAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 27, 1, 1, 2, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpCacheAddress.setStatus('mandatory')
if mibBuilder.loadTexts: igmpCacheAddress.setDescription('The IP multicast group address for which this entry contains information.')
igmpCacheIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 27, 1, 1, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpCacheIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: igmpCacheIfIndex.setDescription('The interface for which this entry contains information for an IP multicast group address.')
igmpCacheSelf = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 27, 1, 1, 2, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igmpCacheSelf.setStatus('mandatory')
if mibBuilder.loadTexts: igmpCacheSelf.setDescription('An indication of whether the local system is a member of this group address on this interface.')
igmpCacheLastReporter = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 27, 1, 1, 2, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpCacheLastReporter.setStatus('mandatory')
if mibBuilder.loadTexts: igmpCacheLastReporter.setDescription('The IP address of the source of the last membership report received for this IP Multicast group address on this interface. If no membership report has been received, this object has the value 0.0.0.0.')
igmpCacheUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 27, 1, 1, 2, 1, 5), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpCacheUpTime.setStatus('mandatory')
if mibBuilder.loadTexts: igmpCacheUpTime.setDescription('The time since the system joined this group address, or zero if the system is not currently a member.')
igmpCacheExpiryTime = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 27, 1, 1, 2, 1, 6), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpCacheExpiryTime.setStatus('mandatory')
if mibBuilder.loadTexts: igmpCacheExpiryTime.setDescription('The minimum amount of time remaining before this entry will be aged out.')
igmpCacheStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 27, 1, 1, 2, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igmpCacheStatus.setStatus('mandatory')
if mibBuilder.loadTexts: igmpCacheStatus.setDescription('The status of this entry.')
sysID = MibScalar((1, 3, 6, 1, 4, 1, 97, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3))).clone(namedValues=NamedValues(("es-1-bridge-router", 1), ("es-1-atx-br-router", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysID.setStatus('mandatory')
if mibBuilder.loadTexts: sysID.setDescription('An integer which serves to identify the type of ES/1.')
sysReset = MibScalar((1, 3, 6, 1, 4, 1, 97, 1, 2), TimeTicks()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysReset.setStatus('mandatory')
if mibBuilder.loadTexts: sysReset.setDescription('The time, in centiseconds, before the ES/1 should reboot. A GetResponse value of zero indicates that no reboot time has been specified.')
sysTrapAck = MibScalar((1, 3, 6, 1, 4, 1, 97, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("traps-need-acks", 1), ("traps-not-acked", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysTrapAck.setStatus('mandatory')
if mibBuilder.loadTexts: sysTrapAck.setDescription('Whether the NMS will acknowledge the enterprise specific traps.')
sysTrapTime = MibScalar((1, 3, 6, 1, 4, 1, 97, 1, 4), TimeTicks()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysTrapTime.setStatus('mandatory')
if mibBuilder.loadTexts: sysTrapTime.setDescription('The time, in centiseconds, which should expire between the sending of traps. This value is used when no ICMP source quench datagrams have been received. The ES/1 uses sysTrapTime if any SNMP requests from the NMS has been received within the previous sixty seconds. If no requests have been received, then the ES/1 reverts to its default of a fifteen second wait between the sending of traps.')
sysTrapRetry = MibScalar((1, 3, 6, 1, 4, 1, 97, 1, 5), TimeTicks()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysTrapRetry.setStatus('mandatory')
if mibBuilder.loadTexts: sysTrapRetry.setDescription('The time, in centiseconds, which should expire before an unacknowledged Trap is re-transmitted.')
sysTrapPort = MibScalar((1, 3, 6, 1, 4, 1, 97, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysTrapPort.setStatus('mandatory')
if mibBuilder.loadTexts: sysTrapPort.setDescription('Zero, or the UDP port number to which a second copy of SNMP traps should be sent. Valid values are zero through 65535.')
hwNumber = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwNumber.setStatus('mandatory')
if mibBuilder.loadTexts: hwNumber.setDescription('The number of slots available for hardware modules, regardless of whether or not the slots are currently populated. This number is fixed as 7.')
hwSlotTable = MibTable((1, 3, 6, 1, 4, 1, 97, 3, 1, 2), )
if mibBuilder.loadTexts: hwSlotTable.setStatus('mandatory')
if mibBuilder.loadTexts: hwSlotTable.setDescription('A list of the most recent occupants of the slots; one per slot.')
hwEntry = MibTableRow((1, 3, 6, 1, 4, 1, 97, 3, 1, 2, 1), ).setIndexNames((0, "CTATX-MIB", "hwIndex"))
if mibBuilder.loadTexts: hwEntry.setStatus('mandatory')
if mibBuilder.loadTexts: hwEntry.setDescription('A set of objects for each slot.')
hwIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 1, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwIndex.setStatus('mandatory')
if mibBuilder.loadTexts: hwIndex.setDescription("The slot number, beginning with 1 for the top-most slot. This number always matches the instance of the hwEntry. For example, {hwIndex 3} contains the value '3'.")
hwType = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("vacant", 1), ("unknown", 2), ("packet-processing-engine", 3), ("turbo", 4), ("csma-iom", 5), ("hssi-iom", 6), ("tpr-iom", 7), ("fddi-iom", 8), ("ifddi-iom", 9), ("ttpr-iom", 10), ("eiom8-iom", 11), ("feiom-iom", 12)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwType.setStatus('mandatory')
if mibBuilder.loadTexts: hwType.setDescription("The module type of the slot's most recent occupant since the ES/1 was started. The values for hwType correspond to the values for hwPortType.")
hwUseMod = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 1, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("reset", 1), ("run-diagnostics", 2), ("run", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwUseMod.setStatus('mandatory')
if mibBuilder.loadTexts: hwUseMod.setDescription('Whether to use this module, not applicable for the Packet Processing Engine. The value of hwUseMod is not saved if the ES/1 reboots. If the module fails diagnostics, it will not be used, regardless of hwUseMod.')
hwDefType = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 1, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("vacant", 1), ("unknown", 2), ("packet-processing-engine", 3), ("turbo", 4), ("csma-iom", 5), ("hssi-iom", 6), ("tpr-iom", 7), ("fddi-iom", 8), ("ifddi-iom", 9), ("ttpr-iom", 10), ("eiom8-iom", 11), ("feiom-iom", 12)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwDefType.setStatus('mandatory')
if mibBuilder.loadTexts: hwDefType.setDescription('The module type defined for the slot. Certain pre-defined relationships exist. Slot 1 always contains the Packet Processing Engine board. Slots 2-6 are either unoccupied, or contain IOM boards. Slot 7 is either unoccupied or contains the Turbo processor board. If hwDefType does not match hwType, then the module will not be used, regardless of the value of hwUseMod. Note that hwDefType can only be changed by rebooting the ES/1. ')
hwDiagStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 1, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("diag-failed", 1), ("diag-not-present", 2), ("diag-passed", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwDiagStatus.setStatus('mandatory')
if mibBuilder.loadTexts: hwDiagStatus.setDescription('Results of diagnostics, when diagnostics were last performed on the module (whenever a module is released from reset, which is usually at power-up).')
hwInuse = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 1, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwInuse.setStatus('mandatory')
if mibBuilder.loadTexts: hwInuse.setDescription('Whether the module is currently executing its operational software.')
hwDiagCode = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 1, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwDiagCode.setStatus('mandatory')
if mibBuilder.loadTexts: hwDiagCode.setDescription("Additional diagnostics information concerning the slot's module. The meaning of hwDiagCode depends upon the slot's module type described by the hwType parameter. For the Packet Processing Engine board, any error (except where noted otherwise) will prevent the ES/1 from booting. For the Turbo processor board, FDDI IOM board (FIOM), the intelligent FDDI IOM board (IFIOM), the Ethernet/802.3 IOM boards, the Token-Ring/802.5 IOM boards, the HSSI IOM board, any error will prevent the board from being used.")
hwManufData = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 1, 2, 1, 8), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwManufData.setStatus('mandatory')
if mibBuilder.loadTexts: hwManufData.setDescription("This is a 24 byte array which contains the part number, serial number and hardware revision level of this module. The Turbo's hwManufData will be all blanks since it is manufactured as part of the Packet Processing Engine module.")
hwPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 1, 2, 1, 9), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPortType.setStatus('mandatory')
if mibBuilder.loadTexts: hwPortType.setDescription("This is a variable-length byte array, where each element represents the port types belonging to this module. The Packet Processing Engine's ports are fixed as 'uart' for the first port, and 'none' for any other ports. The Turbo's ports are fixed as 'none' for all ports. The following port types are supported: none (0) there is no port csma (1) Ethernet or 802.3 port fddi-das (2) FDDI DAS port fddi-sas (3) FDDI SAS port tpr (4) Token Passing Ring port wan (5) Wide Area Network port uart (6) UART port")
hwPortStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 1, 2, 1, 10), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPortStatus.setStatus('mandatory')
if mibBuilder.loadTexts: hwPortStatus.setDescription('This is a variable-length byte array, where each element represents the status of the port belonging to this module. Values of 01 (status-good) or hex ff (status-bad) are supported. For the Packet Processing Engine, the first byte is the status of the UART port.')
hwUsePort = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 1, 2, 1, 11), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwUsePort.setStatus('mandatory')
if mibBuilder.loadTexts: hwUsePort.setDescription('')
hwDefPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 1, 2, 1, 12), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwDefPortType.setStatus('mandatory')
if mibBuilder.loadTexts: hwDefPortType.setDescription('This is a variable-length byte array, where each element represents the port types defined for the module. If hwDefPortType does not match hwPortType, then the port will not be used. Note that hwDefPortType can only be changed by rebooting the ES/1.')
hwAddr1 = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 1, 2, 1, 13), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwAddr1.setStatus('mandatory')
if mibBuilder.loadTexts: hwAddr1.setDescription("The unique hard-wired 48 bit MAC address for the module's 1st port. For the Packet Processing Engine, it's a unique MAC address to be used as part of the ES/1's Spanning Tree Bridge Identifier. For the Turbo, not applicable.")
hwAddr2 = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 1, 2, 1, 14), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwAddr2.setStatus('mandatory')
if mibBuilder.loadTexts: hwAddr2.setDescription("The unique hard-wired 48 bit MAC address for the module's 2nd port, only applicable for IOMs.")
hwAddr3 = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 1, 2, 1, 15), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwAddr3.setStatus('mandatory')
if mibBuilder.loadTexts: hwAddr3.setDescription("The unique hard-wired 48 bit MAC address for the module's 3rd port, only applicable for IOMs.")
hwAddr4 = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 1, 2, 1, 16), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwAddr4.setStatus('mandatory')
if mibBuilder.loadTexts: hwAddr4.setDescription("The unique hard-wired 48 bit MAC address for the module's 4th port, only applicable for IOMs.")
hwTempOK = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 1, 2, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("temperature-normal", 1), ("temperature-too-hot", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwTempOK.setStatus('mandatory')
if mibBuilder.loadTexts: hwTempOK.setDescription('The temperature condition of the module, where True indicates temperature okay, and False indicates temperature too hot.')
hwFirstPort = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 1, 2, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwFirstPort.setStatus('mandatory')
if mibBuilder.loadTexts: hwFirstPort.setDescription('The ifIndex number of the first port which resides within this module. [Not applicable for the Turbo.] ')
hwFatalErr = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 1, 2, 1, 19), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwFatalErr.setStatus('mandatory')
if mibBuilder.loadTexts: hwFatalErr.setDescription("This is a 32 byte array which contains information about the cause of the module's last unexpected self-reset, since the ES/1 booted.For the Packet Processing Engine and Turbo, this will always be all zeroes, since failure of such a module will cause the ES/1 to reboot. For the other modules, this field either contains all zeroes (if the module has not self-reset), or it contains values according to the format of configFatalErr, with a first byte of either 'Watchdog Timeout' (1) or 'Fatal Error' (3).")
hwRptrPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 1, 2, 1, 20), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwRptrPorts.setStatus('mandatory')
if mibBuilder.loadTexts: hwRptrPorts.setDescription('This is a variable-length byte array, where each element represents the repeater capability of the port belonging to this module. The element value is zero if the port is not present or does not have any repeater capability; otherwise, the element value indicates the number of repeater ports at that port.')
hwPortSubType = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 1, 2, 1, 21), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPortSubType.setStatus('mandatory')
if mibBuilder.loadTexts: hwPortSubType.setDescription('This is a variable-length byte array, where each element represents additional port type information.')
hwAddr5 = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 1, 2, 1, 22), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwAddr5.setStatus('mandatory')
if mibBuilder.loadTexts: hwAddr5.setDescription('')
hwAddr6 = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 1, 2, 1, 23), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwAddr6.setStatus('mandatory')
if mibBuilder.loadTexts: hwAddr6.setDescription('')
hwAddr7 = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 1, 2, 1, 24), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwAddr7.setStatus('mandatory')
if mibBuilder.loadTexts: hwAddr7.setDescription('')
hwAddr8 = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 1, 2, 1, 25), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwAddr8.setStatus('mandatory')
if mibBuilder.loadTexts: hwAddr8.setDescription('')
hwSysBus = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("bus-800-mbit", 1), ("bus-1p6-gbit", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwSysBus.setStatus('mandatory')
if mibBuilder.loadTexts: hwSysBus.setDescription('')
hwPpeType = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ppe2", 1), ("ppe3", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPpeType.setStatus('mandatory')
if mibBuilder.loadTexts: hwPpeType.setDescription('')
hwSysProcessor = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dual-29000", 1), ("dual-29030", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwSysProcessor.setStatus('mandatory')
if mibBuilder.loadTexts: hwSysProcessor.setDescription('')
swNumber = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 2, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swNumber.setStatus('mandatory')
if mibBuilder.loadTexts: swNumber.setDescription('The number of file sets. This number is fixed as 2.')
swFilesetTable = MibTable((1, 3, 6, 1, 4, 1, 97, 3, 2, 2), )
if mibBuilder.loadTexts: swFilesetTable.setStatus('mandatory')
if mibBuilder.loadTexts: swFilesetTable.setDescription('A list of the software file sets stored in the ES/1. The first file set refers to the file set that was used when the ES/1 last booted. The second file set refers to the file set that will be used when the ES/1 reboots or reloads any hardware module.')
swFileset = MibTableRow((1, 3, 6, 1, 4, 1, 97, 3, 2, 2, 1), ).setIndexNames((0, "CTATX-MIB", "swIndex"))
if mibBuilder.loadTexts: swFileset.setStatus('mandatory')
if mibBuilder.loadTexts: swFileset.setDescription('A set of objects for each file set.')
swIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("currently-executing", 1), ("next-boot", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swIndex.setStatus('mandatory')
if mibBuilder.loadTexts: swIndex.setDescription("The file set number, beginning with 1 for the first file set. This number always matches the instance of the swFiles. For example, {swIndex 2} contains the value '2'.")
swDesc = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 2, 2, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swDesc.setStatus('mandatory')
if mibBuilder.loadTexts: swDesc.setDescription('The description (0-255 bytes) of the software file set.')
swCount = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 2, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swCount.setStatus('mandatory')
if mibBuilder.loadTexts: swCount.setDescription('The number of files in the file set. This number may range from 1 to 255.')
swTypes = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 2, 2, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swTypes.setStatus('mandatory')
if mibBuilder.loadTexts: swTypes.setDescription('The types of the files within the file set.The size of swFileTypes may be determined by swCount. The possible file types are none (0) File not present ppe-turbo (1) Packet Processing Engine and/or Turbo Code ppe-only(2) Packet Processing Engine Code turbo-only (3) Turbo Code eiom (4) EIOM Code (for many Ethernet/802.3 IOMs) hiom (5) HSSI IOM Code tiom (6) Token Ring IOM Code fiom (7) FIOM Code ifiom (8) Intelligent FIOM Code ttiom (9) Turbo Token Ring IOM Code eiom8 (10) Octal EIOM Code feiom (11) Fast Ethernet IOM code.')
swSizes = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 2, 2, 1, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swSizes.setStatus('mandatory')
if mibBuilder.loadTexts: swSizes.setDescription('An array (4 octets per file), containing the size of each of the files. Each size is encoded as a series of 4 bytes, which should be converted into a 32 bit integer.')
swStarts = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 2, 2, 1, 7), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swStarts.setStatus('mandatory')
if mibBuilder.loadTexts: swStarts.setDescription("An array (4 octets per file), containing the software's execution starting address of each of the files. Each address is encoded as a series of 4 bytes, which should be converted into a 32 bit integer.")
swBases = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 2, 2, 1, 8), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swBases.setStatus('mandatory')
if mibBuilder.loadTexts: swBases.setDescription("An array (4 octets per file), containing the software's base loading address of each of the files. Each address is encoded as a series of 4 bytes, which should be converted into a 32 bit integer.")
swFlashBank = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 2, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("first-bank", 1), ("second-bank", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swFlashBank.setStatus('mandatory')
if mibBuilder.loadTexts: swFlashBank.setDescription('The bank number where the software file set resides.')
configFatalErr = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 1, 1), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: configFatalErr.setStatus('mandatory')
if mibBuilder.loadTexts: configFatalErr.setDescription('This is a 32 byte array which contains information about the cause of the previous system reset. This will describe the circumstances which forced the system software to perform a reboot. The values in the first byte have the following meanings (0) Power failure, (1) Watchdog Timeout, (2) NMS Requested Shutdown, (3-255) Fatal Error (next byte contains the hwIndex of the module which encountered the error; remaining 30 bytes contain additional information).')
configAnyPass = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 1, 2), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configAnyPass.setStatus('mandatory')
if mibBuilder.loadTexts: configAnyPass.setDescription('The authentication password (0-24 bytes) which must match the community name in an SNMP PDU, in order for the operation to be performed. A zero length password indicates that any community name is acceptable.')
configGetPass = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 1, 3), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configGetPass.setStatus('mandatory')
if mibBuilder.loadTexts: configGetPass.setDescription('The authentication password (0-24 bytes) which must match the community name in an SNMP Get PDU (except for Debug or password parameters). A zero length password indicates that any community name is acceptable. Alternatively, it is acceptable if the community name matches configAnyPass.')
configNMSAddress = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configNMSAddress.setStatus('mandatory')
if mibBuilder.loadTexts: configNMSAddress.setDescription('The address of the NMS to which Trap PDUs are to be sent. A value of zero indicates that Trap PDUs should be sent to the NMS last heard from.')
configFunctions = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: configFunctions.setStatus('mandatory')
if mibBuilder.loadTexts: configFunctions.setDescription('A bit field which describes the software functions supported by this ES/1. The possible values are: 0x0001 NMS, 0x0002 TBRIDGE, 0x0004 SBRIDGE, 0x0008 MESH, 0x0010 IPROUTER, 0x0020 NO_BPDU, 0x0040 RIP, 0x0100 PROXY, 0x0200 OSPF, 0x0400 IPX.')
configPowerAc1 = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ac-good", 1), ("ac-bad", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configPowerAc1.setStatus('mandatory')
if mibBuilder.loadTexts: configPowerAc1.setDescription('Whether the first power supply has AC input.')
configPowerAc2 = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ac-good", 1), ("ac-bad", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configPowerAc2.setStatus('mandatory')
if mibBuilder.loadTexts: configPowerAc2.setDescription('Whether the second power supply has AC input.')
configPowerDc1 = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dc-good", 1), ("dc-bad", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configPowerDc1.setStatus('mandatory')
if mibBuilder.loadTexts: configPowerDc1.setDescription('Whether the first power supply provides DC voltage.')
configPowerDc2 = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dc-good", 1), ("dc-bad", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configPowerDc2.setStatus('mandatory')
if mibBuilder.loadTexts: configPowerDc2.setDescription('Whether the second power supply provides DC voltage.')
configPowerPresent1 = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("supply-present", 1), ("supply-absent", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configPowerPresent1.setStatus('mandatory')
if mibBuilder.loadTexts: configPowerPresent1.setDescription('Whether the first power supply is present.')
configPowerPresent2 = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("supply-present", 1), ("supply-absent", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configPowerPresent2.setStatus('mandatory')
if mibBuilder.loadTexts: configPowerPresent2.setDescription('Whether the second power supply is present.')
configAlarmDynamic = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configAlarmDynamic.setStatus('mandatory')
if mibBuilder.loadTexts: configAlarmDynamic.setDescription('Whether changes in dynamic parameters (except for the dynamically learned addresses) should cause enterprise specific trap PDUs to be generated.')
configAlarmAddresses = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configAlarmAddresses.setStatus('mandatory')
if mibBuilder.loadTexts: configAlarmAddresses.setDescription('Whether changes in the dynamically learned addresses should cause enterprise specific trap PDUs to be generated.')
configStorageFailure = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configStorageFailure.setStatus('mandatory')
if mibBuilder.loadTexts: configStorageFailure.setDescription("Whether the ES/1's storage facility for its configuration parameters has failed (the ES/1 may not be able to reboot after such a failure).")
configAuthenticationFailure = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 1, 15), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: configAuthenticationFailure.setStatus('mandatory')
if mibBuilder.loadTexts: configAuthenticationFailure.setDescription('All nulls, or the IP source address within the last SNMP PDU which caused an SNMP authentication failure.')
configFddiPriority = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 1, 16), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configFddiPriority.setStatus('mandatory')
if mibBuilder.loadTexts: configFddiPriority.setDescription('Priority to use when forwarding packets to any FDDI port from any non-FDDI port.')
configTprPriority = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 1, 17), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configTprPriority.setStatus('mandatory')
if mibBuilder.loadTexts: configTprPriority.setDescription('Priority to use when forwarding packets to any Token-Ring port from any non-Token-Ring port.')
configDumpModule = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 1, 19), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configDumpModule.setStatus('mandatory')
if mibBuilder.loadTexts: configDumpModule.setDescription("Flag to select the module to dump on a crash. If set to a value of 1 to 7 the relevant module's memory will be sent to the UART port on detecting a fatal error situation. A value of zero will disable the dump option. A value of 1 selects the ME, 7 selects the TURBO, and 2-6 select IOMs. ")
configDumpStart = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 1, 20), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configDumpStart.setStatus('mandatory')
if mibBuilder.loadTexts: configDumpStart.setDescription('Starting address of memory to dump upon detecting a fatal error. ')
configDumpEnd = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 1, 21), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configDumpEnd.setStatus('mandatory')
if mibBuilder.loadTexts: configDumpEnd.setDescription('Ending address of memory to dump upon detecting a fatal error.')
lmaAllAddr = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 2, 1), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lmaAllAddr.setStatus('mandatory')
if mibBuilder.loadTexts: lmaAllAddr.setDescription('The IEEE All LANs Bridge Management Group Address 01-80-c2-00-00-10. Changing lmaAllAddr will not take effect until the ES/1 reboots.')
lmaAnyAddr = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 2, 2), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lmaAnyAddr.setStatus('mandatory')
if mibBuilder.loadTexts: lmaAnyAddr.setDescription('A spare LMA address, which is always all zeroes. Changing lmaAllAny will not take effect until the ES/1 reboots.')
ppeLrgUxRxCnt = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 3, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ppeLrgUxRxCnt.setStatus('mandatory')
if mibBuilder.loadTexts: ppeLrgUxRxCnt.setDescription('The number of large data buffers to allocate for the PPE to create packets. This value may be changed automatically by the ES/1 as a result of enabling IPX routing. The ES/1 will calculate the minimum number of such buffers that are needed for the number of configured ports and may adjust this count upward if needed.')
ppeSmlUxRxCnt = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 3, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ppeSmlUxRxCnt.setStatus('mandatory')
if mibBuilder.loadTexts: ppeSmlUxRxCnt.setDescription('The number of small data buffers to allocate for the PPE to create packets.')
ppeUxTxCnt = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 3, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ppeUxTxCnt.setStatus('mandatory')
if mibBuilder.loadTexts: ppeUxTxCnt.setDescription('The maximum number of received packets destined to the ES/1 itself (versus those received packets to be forwarded) which can be stored, until the PPE is able to process them.')
ppeSmlBuffSize = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 3, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ppeSmlBuffSize.setStatus('mandatory')
if mibBuilder.loadTexts: ppeSmlBuffSize.setDescription("The size (in bytes) of the PPE's small data buffers.")
ppeBridgingMemory = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 3, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ppeBridgingMemory.setStatus('mandatory')
if mibBuilder.loadTexts: ppeBridgingMemory.setDescription("The percentage (1 - 99) of the PPE's memory that is allocated for MAC bridging. The PPE's remaining memory will be used for communicating with the NMS and for routing. Operationally, a value between 70 percent and 99 percent will be treated as 70 percent. This allows for approximately 8000 learned addresses (bridging) and either 1600 TCP/IP routes or 1200 IPX RIP/SAP pairs. To increase the space available for routing, set rebootBridgingMemory to a value less than 70 percent.")
ppeExtendStats = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 3, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ppeExtendStats.setStatus('mandatory')
if mibBuilder.loadTexts: ppeExtendStats.setDescription('Whether the PPE should accumulate extended statistics. Extended statistics are tallies, such as byte counts, which are not essential for everyday ES/1 management, and which may have a slightly detrimental effect on performance.')
ppeBAddrLimit = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 3, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ppeBAddrLimit.setStatus('mandatory')
if mibBuilder.loadTexts: ppeBAddrLimit.setDescription('The maximum number of addresses that the PPE should learn for bridging purposes. The remaining address entries will be used for routing related addresses.')
ppeTxCongests = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 3, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ppeTxCongests.setStatus('mandatory')
if mibBuilder.loadTexts: ppeTxCongests.setDescription('Number of packets not received due to internal buffer congestion.')
ppeArpEntries = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 3, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ppeArpEntries.setStatus('mandatory')
if mibBuilder.loadTexts: ppeArpEntries.setDescription('The number of ARP entries for all interfaces.')
ppeArpStatics = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 3, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ppeArpStatics.setStatus('mandatory')
if mibBuilder.loadTexts: ppeArpStatics.setDescription('The number of statically defined ARP entries for all interfaces.')
ppeArpOverflows = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 3, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ppeArpOverflows.setStatus('mandatory')
if mibBuilder.loadTexts: ppeArpOverflows.setDescription('The number of times a ARP entry could not be learned due to insufficient address table space.')
ppeIpEntries = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 3, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ppeIpEntries.setStatus('mandatory')
if mibBuilder.loadTexts: ppeIpEntries.setDescription('The number of IP Routing Database entries.')
ppeIpStatics = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 3, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ppeIpStatics.setStatus('mandatory')
if mibBuilder.loadTexts: ppeIpStatics.setDescription('The number of statically defined IP Routing Database entries.')
ppeStaticPreference = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 3, 14), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ppeStaticPreference.setStatus('mandatory')
if mibBuilder.loadTexts: ppeStaticPreference.setDescription('The value to assign to ipRouteMetric2, when adding a statically-defined entry to the IP Routing Table.')
ppeOspfPreference = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 3, 15), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ppeOspfPreference.setStatus('mandatory')
if mibBuilder.loadTexts: ppeOspfPreference.setDescription('The value to assign to ipRouteMetric2, when adding an OSPF-learned entry to the IP Routing Table.')
ppeRipPreference = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 3, 16), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ppeRipPreference.setStatus('mandatory')
if mibBuilder.loadTexts: ppeRipPreference.setDescription('The value to assign to ipRouteMetric2, when adding a RIP-learned entry to the IP Routing Table.')
ppeEgpPreference = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 3, 17), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ppeEgpPreference.setStatus('mandatory')
if mibBuilder.loadTexts: ppeEgpPreference.setDescription('The value to assign to ipRouteMetric2, when adding an EGP-learned entry to the IP Routing Table.')
ppeCpuUtilization = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 3, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("low-cpu", 1), ("medium-cpu", 2), ("high-cpu", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ppeCpuUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: ppeCpuUtilization.setDescription('The current CPU utilization on the Packet Processing Engine.')
ppeRipRouteDiscards = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 3, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ppeRipRouteDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: ppeRipRouteDiscards.setDescription('The number of times a route learned via RIP was not added to the IP Routing Table due to insufficient Routing Table space.')
ppeOspfRouteDiscards = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 3, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ppeOspfRouteDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: ppeOspfRouteDiscards.setDescription('The number of times a route learned via OSPF was not added to the IP Routing Table due to insufficient Routing Table space (currently always zero).')
ppeRouteMemorySize = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 3, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ppeRouteMemorySize.setStatus('mandatory')
if mibBuilder.loadTexts: ppeRouteMemorySize.setDescription('The number of bytes originally given to the routing table heap.')
ppeRouteMemoryAvail = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 3, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ppeRouteMemoryAvail.setStatus('mandatory')
if mibBuilder.loadTexts: ppeRouteMemoryAvail.setDescription('The number of bytes currently available in the routing table heap.')
ppeRouteMemoryFailures = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 3, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ppeRouteMemoryFailures.setStatus('mandatory')
if mibBuilder.loadTexts: ppeRouteMemoryFailures.setDescription('The number of unsuccessful attempts to allocate from the routing table heap.')
ppePacketMemorySize = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 3, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ppePacketMemorySize.setStatus('mandatory')
if mibBuilder.loadTexts: ppePacketMemorySize.setDescription('The number of bytes originally given to the packet heap.')
ppePacketMemoryAvail = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 3, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ppePacketMemoryAvail.setStatus('mandatory')
if mibBuilder.loadTexts: ppePacketMemoryAvail.setDescription('The number of bytes currently available in the packet heap.')
ppePacketMemoryFailures = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 3, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ppePacketMemoryFailures.setStatus('mandatory')
if mibBuilder.loadTexts: ppePacketMemoryFailures.setDescription('The number of unsuccessful attempts to allocate from the packet heap.')
ppeOspfPduMemoryFailures = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 3, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ppeOspfPduMemoryFailures.setStatus('mandatory')
if mibBuilder.loadTexts: ppeOspfPduMemoryFailures.setDescription('Number of unsuccessful attempts to allocate memory for an OSPF PDU.')
ppeOspfPduMemoryAllocs = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 3, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ppeOspfPduMemoryAllocs.setStatus('mandatory')
if mibBuilder.loadTexts: ppeOspfPduMemoryAllocs.setDescription('Number of times memory was allocated for an OSPF PDU.')
ppeIcmpPduMemoryFailures = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 3, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ppeIcmpPduMemoryFailures.setStatus('mandatory')
if mibBuilder.loadTexts: ppeIcmpPduMemoryFailures.setDescription('Number of unsuccessful attempts to allocate memory for an ICMP PDU.')
ppeIcmpPduMemoryAllocs = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 3, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ppeIcmpPduMemoryAllocs.setStatus('mandatory')
if mibBuilder.loadTexts: ppeIcmpPduMemoryAllocs.setDescription('Number of times memory was allocated for an ICMP PDU.')
ppeRipPduMemoryFailures = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 3, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ppeRipPduMemoryFailures.setStatus('mandatory')
if mibBuilder.loadTexts: ppeRipPduMemoryFailures.setDescription('Number of unsuccessful attempts to allocate memory for a RIP PDU.')
ppeRipPduMemoryAllocs = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 3, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ppeRipPduMemoryAllocs.setStatus('mandatory')
if mibBuilder.loadTexts: ppeRipPduMemoryAllocs.setDescription('Number of times memory was allocated for a RIP PDU.')
ppeBootpPduMemoryFailures = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 3, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ppeBootpPduMemoryFailures.setStatus('mandatory')
if mibBuilder.loadTexts: ppeBootpPduMemoryFailures.setDescription('Number of unsuccessful attempts to allocate memory for a BOOTP PDU.')
ppeBootpPduMemoryAllocs = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 3, 34), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ppeBootpPduMemoryAllocs.setStatus('mandatory')
if mibBuilder.loadTexts: ppeBootpPduMemoryAllocs.setDescription('Number of times memory was allocated for a BOOTP PDU.')
ppeSnmpPduMemoryFailures = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 3, 35), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ppeSnmpPduMemoryFailures.setStatus('mandatory')
if mibBuilder.loadTexts: ppeSnmpPduMemoryFailures.setDescription('Number of unsuccessful attempts to allocate memory for an SNMP PDU.')
ppeSnmpPduMemoryAllocs = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 3, 36), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ppeSnmpPduMemoryAllocs.setStatus('mandatory')
if mibBuilder.loadTexts: ppeSnmpPduMemoryAllocs.setDescription('Number of times memory was allocated for an SNMP PDU.')
ppeTftpPduMemoryFailures = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 3, 37), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ppeTftpPduMemoryFailures.setStatus('mandatory')
if mibBuilder.loadTexts: ppeTftpPduMemoryFailures.setDescription('Number of unsuccessful attempts to allocate memory for a TFTP PDU.')
ppeTftpPduMemoryAllocs = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 3, 38), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ppeTftpPduMemoryAllocs.setStatus('mandatory')
if mibBuilder.loadTexts: ppeTftpPduMemoryAllocs.setDescription('Number of times memory was allocated for a TFTP PDU.')
ppeTraceroutePduMemoryFailures = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 3, 39), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ppeTraceroutePduMemoryFailures.setStatus('mandatory')
if mibBuilder.loadTexts: ppeTraceroutePduMemoryFailures.setDescription('Number of unsuccessful attempts to allocate memory for a TraceRoute PDU.')
ppeTraceroutePduMemoryAllocs = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 3, 40), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ppeTraceroutePduMemoryAllocs.setStatus('mandatory')
if mibBuilder.loadTexts: ppeTraceroutePduMemoryAllocs.setDescription('Number of times memory was allocated for a TraceRoute PDU.')
ppeArpPduMemoryFailures = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 3, 41), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ppeArpPduMemoryFailures.setStatus('mandatory')
if mibBuilder.loadTexts: ppeArpPduMemoryFailures.setDescription('Number of unsuccessful attempts to allocate memory for a ARP PDU.')
ppeArpPduMemoryAllocs = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 3, 42), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ppeArpPduMemoryAllocs.setStatus('mandatory')
if mibBuilder.loadTexts: ppeArpPduMemoryAllocs.setDescription('Number of times memory was allocated for a ARP PDU.')
ppeIgmpPduMemoryFailures = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 3, 43), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ppeIgmpPduMemoryFailures.setStatus('mandatory')
if mibBuilder.loadTexts: ppeIgmpPduMemoryFailures.setDescription('Number of unsuccessful attempts to allocate memory for a IGMP PDU.')
ppeIgmpPduMemoryAllocs = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 3, 44), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ppeIgmpPduMemoryAllocs.setStatus('mandatory')
if mibBuilder.loadTexts: ppeIgmpPduMemoryAllocs.setDescription('Number of times memory was allocated for a IGMP PDU.')
ppeAresAsStes = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 3, 45), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ppeAresAsStes.setStatus('mandatory')
if mibBuilder.loadTexts: ppeAresAsStes.setDescription('If true, all-routes-explorers will be treated as if they were spanning-tree-explorers.')
ppeRoutePercent = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 3, 46), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ppeRoutePercent.setStatus('mandatory')
if mibBuilder.loadTexts: ppeRoutePercent.setDescription('')
ppeMgtMemorySize = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 3, 48), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ppeMgtMemorySize.setStatus('mandatory')
if mibBuilder.loadTexts: ppeMgtMemorySize.setDescription('The number of bytes originally given to the local management agent heap.')
ppeMgtMemoryAvail = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 3, 49), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ppeMgtMemoryAvail.setStatus('mandatory')
if mibBuilder.loadTexts: ppeMgtMemoryAvail.setDescription('The number of bytes currently available in the local management agent heap.')
ppeMgtMemoryFailures = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 3, 50), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ppeMgtMemoryFailures.setStatus('mandatory')
if mibBuilder.loadTexts: ppeMgtMemoryFailures.setDescription('The number of unsuccessful attempts to allocate from the local management agent heap.')
stGroupAddr = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 4, 1), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: stGroupAddr.setStatus('mandatory')
if mibBuilder.loadTexts: stGroupAddr.setDescription('The Spanning Tree Group address, normally 01-80-c2-00-00-00. Changing stGroupAddr will not take effect until the ES/1 reboots.')
stResAddr = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 4, 2), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: stResAddr.setStatus('mandatory')
if mibBuilder.loadTexts: stResAddr.setDescription("A series of 90 octets containing the Spanning Tree's 15 reserved addres 01-80-c2-00-00-01 through 01-80-c2-00-00-0f). Changing stResAddr will not take effect until the ES/1 reboots.")
stBridgeId = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 4, 3), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: stBridgeId.setStatus('mandatory')
if mibBuilder.loadTexts: stBridgeId.setDescription('')
stRootMaxAge = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 4, 4), TimeTicks()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: stRootMaxAge.setStatus('mandatory')
if mibBuilder.loadTexts: stRootMaxAge.setDescription('')
stRootHello = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 4, 5), TimeTicks()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: stRootHello.setStatus('mandatory')
if mibBuilder.loadTexts: stRootHello.setDescription('')
stRootDelay = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 4, 6), TimeTicks()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: stRootDelay.setStatus('mandatory')
if mibBuilder.loadTexts: stRootDelay.setDescription('')
stRootID = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 4, 7), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stRootID.setStatus('mandatory')
if mibBuilder.loadTexts: stRootID.setDescription('')
stRootCost = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 4, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stRootCost.setStatus('mandatory')
if mibBuilder.loadTexts: stRootCost.setDescription('')
stRootPort = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 4, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stRootPort.setStatus('mandatory')
if mibBuilder.loadTexts: stRootPort.setDescription('')
stTopChange = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 4, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stTopChange.setStatus('mandatory')
if mibBuilder.loadTexts: stTopChange.setDescription('Whether a topology change is currently in progress.')
stActMaxAge = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 4, 11), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stActMaxAge.setStatus('mandatory')
if mibBuilder.loadTexts: stActMaxAge.setDescription('')
stActHello = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 4, 12), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stActHello.setStatus('mandatory')
if mibBuilder.loadTexts: stActHello.setDescription('')
stActDelay = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 4, 13), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stActDelay.setStatus('mandatory')
if mibBuilder.loadTexts: stActDelay.setDescription('')
stTopChangeCount = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 4, 14), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: stTopChangeCount.setStatus('mandatory')
if mibBuilder.loadTexts: stTopChangeCount.setDescription('The number of spanning tree topology changes which have occurred, since the ES/1 was last booted (or this parameter was last reset by the NMS).')
stTopChangeTime = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 4, 15), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stTopChangeTime.setStatus('mandatory')
if mibBuilder.loadTexts: stTopChangeTime.setDescription('If stTopChange is True, then the time since stTopChange changed from False to True. If stTopChange is False, then the time since stTopChange changed from True to False.')
stAgeTime = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 4, 16), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: stAgeTime.setStatus('mandatory')
if mibBuilder.loadTexts: stAgeTime.setDescription('')
meshCostPercent = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 5, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: meshCostPercent.setStatus('mandatory')
if mibBuilder.loadTexts: meshCostPercent.setDescription('')
meshCost = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 5, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: meshCost.setStatus('mandatory')
if mibBuilder.loadTexts: meshCost.setDescription('')
meshCostChange = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 5, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: meshCostChange.setStatus('mandatory')
if mibBuilder.loadTexts: meshCostChange.setDescription('')
meshCostChangeCount = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 5, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: meshCostChangeCount.setStatus('mandatory')
if mibBuilder.loadTexts: meshCostChangeCount.setDescription('')
meshCostChangeTime = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 5, 5), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: meshCostChangeTime.setStatus('mandatory')
if mibBuilder.loadTexts: meshCostChangeTime.setDescription('')
meshSubnet = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 3, 5, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: meshSubnet.setStatus('mandatory')
if mibBuilder.loadTexts: meshSubnet.setDescription('')
swdisDesc = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 4, 1), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swdisDesc.setStatus('mandatory')
if mibBuilder.loadTexts: swdisDesc.setDescription('The description (0-32 bytes) of the software set currently being downloaded, or a description of the software set last downloaded since the ES/1 booted.')
swdisAccess = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 4, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("protected", 1), ("any-software", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swdisAccess.setStatus('mandatory')
if mibBuilder.loadTexts: swdisAccess.setDescription('The version of software that may be downloaded. Attempts to download other versions of software will be rejected. The value for swdisAccess is embedded within the software files that are to be distributed via TFTP. Its value may be derived from the names of the software files. the NMS operator may wish to use the following special values: protected (1) No software downloads will be accepted any-software (2) A software download of any version of new software will be accepted - this is the factory default')
swdisWriteStatus = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 4, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("in-progress", 1), ("success", 2), ("config-error", 3), ("flash-error", 4), ("config-and-flash-errors", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swdisWriteStatus.setStatus('mandatory')
if mibBuilder.loadTexts: swdisWriteStatus.setDescription('The status of the erase/write operation.')
swdisConfigIp = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 4, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swdisConfigIp.setStatus('mandatory')
if mibBuilder.loadTexts: swdisConfigIp.setDescription('The IP address of the NMS (i.e., any IP host) that is allowed to use TFTP to send/retrieve the configuration file of the ES/1. A value of 0.0.0.0 (which is the factory specified default) prevents any NMS from obtaining access, while a value of 255.255.255.255 gives every NMS permission.')
swdisConfigRetryTime = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 4, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swdisConfigRetryTime.setStatus('mandatory')
if mibBuilder.loadTexts: swdisConfigRetryTime.setDescription('The number of seconds that the ES/1 will wait for an acknowledgment before it retransmits an unacknowledged TFTP data block. The factory specified default is 5 seconds.')
swdisConfigTotalTimeout = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 4, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swdisConfigTotalTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: swdisConfigTotalTimeout.setDescription('The number of seconds that the ES/1 will wait for an acknowledgment to a data block before it cancels a TFTP session. The factory specified default is 25 seconds.')
addrStatics = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 5, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: addrStatics.setStatus('mandatory')
if mibBuilder.loadTexts: addrStatics.setDescription('The number of static addresses which are currently stored in the ES/1.')
addrDynamics = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 5, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: addrDynamics.setStatus('mandatory')
if mibBuilder.loadTexts: addrDynamics.setDescription('The number of learned addresses in the address table.')
addrDynamicMax = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 5, 3), Gauge32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: addrDynamicMax.setStatus('mandatory')
if mibBuilder.loadTexts: addrDynamicMax.setDescription('The maximum number of spanning tree addresses which have been learned since the ES/1 was last booted (or this parameter was last reset by the NMS).')
addrMeshs = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 5, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: addrMeshs.setStatus('mandatory')
if mibBuilder.loadTexts: addrMeshs.setDescription('The number of ATM, Frame Relay, and/or SMDS addresses in the address table. These addresses are not reflected within addrStatics nor addrDynamics. [ATM, Frame Relay, and SMDS are not yet implemented.]')
addrDynamicOverflows = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 5, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: addrDynamicOverflows.setStatus('mandatory')
if mibBuilder.loadTexts: addrDynamicOverflows.setDescription('The number times an address was not learned due to insufficient address table space.')
addrMeshOverflows = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 5, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: addrMeshOverflows.setStatus('mandatory')
if mibBuilder.loadTexts: addrMeshOverflows.setDescription('The number of times an ATM, Frame Relay, or SMDS address could not be learned due to insufficient address table space. [ATM, Frame Relay, and SMDS are not yet implemented.]')
addrFlags = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 5, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: addrFlags.setStatus('mandatory')
if mibBuilder.loadTexts: addrFlags.setDescription('Flags to describe the use and control of this address entry. Each bit has a different meaning. The NMS must always set either entry-static, entry-none, or entry-mesh; however, for GetRequests, the NMS will see either no bits set (if the entry does not exist), or exactly one of the following bits set: entry-dynamic-local = 30,entry-dynamic-remote = 29, entry-static = 28, entry-other = 27, entry-none = 26, entry-mesh = 25, entry-statistics = 24,Bit 31 is reserved. Any combination of the restriction bits (bits 23-21) may be set for any type of entry, except entry-other or entry-mesh: entry-no-source = 23, entry-no-multi = 22, Bit 21 is reserved, Bits 20-18 are reserved. Exactly one of the special entry bits (bits 17-10) must be set for entry-other entries, and none of the bits may be set for other than entry-other entries: entry-all-lmas = 17, entry-any-lma = 16, entry-lma = 15, entry-port = 14, entry-bpdu = 13, entry-reserved = 12, Bits 11-10 are reserved for future expansion. Bits 9-0 are reserved. ')
addrMAC = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 5, 8), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: addrMAC.setStatus('mandatory')
if mibBuilder.loadTexts: addrMAC.setDescription('The MAC address for this address definition.')
addrPort = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 5, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: addrPort.setStatus('mandatory')
if mibBuilder.loadTexts: addrPort.setDescription('The port through which this address is connected to the ES/1 (only valid for entry-dynamic-local, entry-statistics, and entry-port entries).')
addrPortMap = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 5, 10), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: addrPortMap.setStatus('obsolete')
if mibBuilder.loadTexts: addrPortMap.setDescription("This is a bitmap of up to 32 sets of 32 bits each (128 octets), which defines which source ports are allowed to forward packets to which destination ports. Within each set of four octets, each bit is set if a packet with a matching destination address may be forwarded to that port.Since only the ES/1's ports 2 through 21 are available for bridging, all unused bits as well as the first 8 octets as well as the last 40 octets are meaningless.")
addrOperation = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 5, 41), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("read-random", 1), ("read-next", 2), ("zero-stats", 3), ("update", 4), ("delete", 5), ("read-block", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: addrOperation.setStatus('mandatory')
if mibBuilder.loadTexts: addrOperation.setDescription('The operation to be performed upon the described address. The possibilities include: read-random (1), read-next (2), zero-stats (3), update (4), delete (5), read-block (6).')
addrIndex = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 5, 42), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: addrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: addrIndex.setDescription('The index number to be used for read-next and read-block operations. When the ES/1 boots, addrIndex is initialized to -1.')
addrNext = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 5, 44), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: addrNext.setStatus('mandatory')
if mibBuilder.loadTexts: addrNext.setDescription('The next value to use for addrIndex, when you use read-next or read-block operations to read the address table. When the ES/1 boots, addrNext is initialized to -1.')
addrAge = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 5, 45), TimeTicks()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: addrAge.setStatus('mandatory')
if mibBuilder.loadTexts: addrAge.setDescription('The time, in centiseconds, since a packet was last received from the address on a port that was in Spanning Tree learning or forwarding state. If no packets have been received, then addrAge contains the time that the address was created on the ES/1.')
addrRxPkts = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 5, 46), Counter32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: addrRxPkts.setStatus('mandatory')
if mibBuilder.loadTexts: addrRxPkts.setDescription('The number of packets received from the address on a port that was in Spanning Tree learning or forwarding state (can be zeroed by zero-stats).')
addrRxChars = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 5, 47), Counter32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: addrRxChars.setStatus('mandatory')
if mibBuilder.loadTexts: addrRxChars.setDescription('The number of characters in the packets received from the address on a port that was in Spanning Tree Learning or Forwarding state (can be zeroed by zero-stats).')
addrRxMultiPkts = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 5, 48), Counter32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: addrRxMultiPkts.setStatus('mandatory')
if mibBuilder.loadTexts: addrRxMultiPkts.setDescription('The number of multicast packets received from the address on a port that was in Spanning Tree Learning or Forwarding state (can be zeroed by zero-stats).')
addrRxFwdPkts = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 5, 49), Counter32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: addrRxFwdPkts.setStatus('mandatory')
if mibBuilder.loadTexts: addrRxFwdPkts.setDescription("The number of packets received from the address which were forwarded (can be zeroed by zero-stats). This includes packets that were MAC-layer bridged because they were received on a port that was in Spanning Tree forwarding state, and packets that were routed regardless of the port's Spanning Tree state.")
addrTxPkts = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 5, 50), Counter32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: addrTxPkts.setStatus('mandatory')
if mibBuilder.loadTexts: addrTxPkts.setDescription('The number of packets transmitted to the address (can be zeroed by zero-stats).')
addrTxChars = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 5, 51), Counter32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: addrTxChars.setStatus('mandatory')
if mibBuilder.loadTexts: addrTxChars.setDescription('The number of characters in the packets transmitted to the address (can be zeroed by zero-stats).')
addrBlockSize = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 5, 52), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: addrBlockSize.setStatus('mandatory')
if mibBuilder.loadTexts: addrBlockSize.setDescription('The number of addresses contained by addrBlock.This parameter is only used for dumping blocks of MAC addresses.')
addrBlock = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 5, 53), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: addrBlock.setStatus('mandatory')
if mibBuilder.loadTexts: addrBlock.setDescription('A series of 0-700 octets, which represents 0-100 addresses. Each address consists of a 6 octet MacAddress followed by a 1 byte port number. If the port number is zero, then the address is that of a specially configured address; otherwise, the address is a dynamically learned address. This parameter is only used for dumping blocks of MAC addresses.')
addrAlarmMAC = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 5, 54), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: addrAlarmMAC.setStatus('mandatory')
if mibBuilder.loadTexts: addrAlarmMAC.setDescription("The MAC address for an address entry. This parameter is only used by the ES/1's enterprise specific trap mechanism.")
addrRptrPort = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 5, 55), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: addrRptrPort.setStatus('mandatory')
if mibBuilder.loadTexts: addrRptrPort.setDescription("The repeater port through which this address is connected to the port indicated by addrPort. This parameter is only valid if the port's srepeaterExtendedStats is enabled, and if the ES/1's ppeExtendStats is true.")
snmpsmtUpstreamReq = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 6, 1), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpsmtUpstreamReq.setStatus('mandatory')
if mibBuilder.loadTexts: snmpsmtUpstreamReq.setDescription('')
snmpsmtUpstreamRsp = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 6, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpsmtUpstreamRsp.setStatus('mandatory')
if mibBuilder.loadTexts: snmpsmtUpstreamRsp.setDescription('')
snmpsmtUpstreamDescriptor = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 6, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpsmtUpstreamDescriptor.setStatus('mandatory')
if mibBuilder.loadTexts: snmpsmtUpstreamDescriptor.setDescription('')
snmpsmtUpstreamState = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 6, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpsmtUpstreamState.setStatus('mandatory')
if mibBuilder.loadTexts: snmpsmtUpstreamState.setDescription('')
fddismtTable = MibTable((1, 3, 6, 1, 4, 1, 97, 3, 6, 5), )
if mibBuilder.loadTexts: fddismtTable.setStatus('mandatory')
if mibBuilder.loadTexts: fddismtTable.setDescription('A list of snmpsmt entries, one per FDDI board.')
fddismtEntry = MibTableRow((1, 3, 6, 1, 4, 1, 97, 3, 6, 5, 1), ).setIndexNames((0, "CTATX-MIB", "fddismtIndex"))
if mibBuilder.loadTexts: fddismtEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fddismtEntry.setDescription('A set of objects for an interface entry.')
fddismtIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 6, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddismtIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fddismtIndex.setDescription('A unique value for each SMT. It represents the sequence number of the FDDI board in ES/1.')
fddismtUpstreamReq = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 6, 5, 1, 2), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fddismtUpstreamReq.setStatus('mandatory')
if mibBuilder.loadTexts: fddismtUpstreamReq.setDescription("When this variable is written, the ES/1 converts it into a big-endian FDDI address and issues an SMT NIF request to determine that address's upstream neighbor. When the NIF response is received, snmpsmtUpstreamRsp will hold the address of the upstream neighbor and a trap will be sent to the NMS.")
fddismtUpstreamRsp = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 6, 5, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddismtUpstreamRsp.setStatus('mandatory')
if mibBuilder.loadTexts: fddismtUpstreamRsp.setDescription('The address of the upstream neighbor of the ES/1 whose address was written into snmpsmtUpstreamReq. If the address has not yet been learned, then an address of all zeroes is returned.')
fddismtUpstreamDescriptor = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 6, 5, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddismtUpstreamDescriptor.setStatus('mandatory')
if mibBuilder.loadTexts: fddismtUpstreamDescriptor.setDescription("A four byte string containing the upstream neighbor's Station Descriptor parameter, as defined by the SMT frame protocols. If the upstream neighbor has not yet been learned, then a string of all zeroes is returned.")
fddismtUpstreamState = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 6, 5, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddismtUpstreamState.setStatus('mandatory')
if mibBuilder.loadTexts: fddismtUpstreamState.setDescription("A four byte string containing the upstream neighbor's Station State parameter, as defined by the SMT frame protocols. If the upstream neighbor has not yet been learned, then a string of all zeroes is returned.")
sifUX = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 7, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sifUX.setStatus('mandatory')
if mibBuilder.loadTexts: sifUX.setDescription('The maximum number of receive data buffers supported by the ES/1. The sum of sifSmlRxCnt and sifLrgRxCnt for all ports, plus ppeSmlRxCnt and ppeLrgRxCnt must be less than or equal to sifUX.')
sifTable = MibTable((1, 3, 6, 1, 4, 1, 97, 3, 7, 2), )
if mibBuilder.loadTexts: sifTable.setStatus('mandatory')
if mibBuilder.loadTexts: sifTable.setDescription('A list of interface entries; one per port.')
sifEntry = MibTableRow((1, 3, 6, 1, 4, 1, 97, 3, 7, 2, 1), ).setIndexNames((0, "CTATX-MIB", "sifIndex"))
if mibBuilder.loadTexts: sifEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sifEntry.setDescription('A set of objects for an interface entry.')
sifIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 7, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sifIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sifIndex.setDescription('The port number, beginning with 1 for the first port.')
sifSmlRxCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 7, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sifSmlRxCnt.setStatus('mandatory')
if mibBuilder.loadTexts: sifSmlRxCnt.setDescription('The number of small data buffers for receiving packets.')
sifLrgRxCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 7, 2, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sifLrgRxCnt.setStatus('mandatory')
if mibBuilder.loadTexts: sifLrgRxCnt.setDescription('The number of large data buffers for receiving packets; must be zero for CSMA and UART ports.')
sifUxTxCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 7, 2, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sifUxTxCnt.setStatus('mandatory')
if mibBuilder.loadTexts: sifUxTxCnt.setDescription("The maximum size of the port's transmit queue, i.e., the number of packets that can be in the port's transmit queue, waiting to be transmitted.")
sifThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 7, 2, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sifThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: sifThreshold.setDescription('Maximum number of combined receive and transmit packet hardware errors before an alarm should be generated.')
sifThresholdTime = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 7, 2, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sifThresholdTime.setStatus('mandatory')
if mibBuilder.loadTexts: sifThresholdTime.setDescription('The time period (in seconds) to which sifThreshold applies. A value of zero will disable the sifThreshold alarm.')
sifRxQueueThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 7, 2, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sifRxQueueThresh.setStatus('mandatory')
if mibBuilder.loadTexts: sifRxQueueThresh.setDescription('Maximum number of receive packet queue overflow errors before an alarm should be generated.')
sifRxQueueThreshTime = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 7, 2, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sifRxQueueThreshTime.setStatus('mandatory')
if mibBuilder.loadTexts: sifRxQueueThreshTime.setDescription('The time period (in seconds) to which sifRxQueueThresh applies. A value of zero will disable the sifRxQueueThresh alarm.')
sifTxStormCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 7, 2, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sifTxStormCnt.setStatus('mandatory')
if mibBuilder.loadTexts: sifTxStormCnt.setDescription('The maximum number of multicasts to transmit with a certain period of time (not applicable for UART ports).')
sifTxStormTime = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 7, 2, 1, 10), TimeTicks()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sifTxStormTime.setStatus('mandatory')
if mibBuilder.loadTexts: sifTxStormTime.setDescription('The period of time, in centiseconds, which qualifies sifTxStormCnt (not applicable for UART ports).')
sifFilterFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 7, 2, 1, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sifFilterFlags.setStatus('mandatory')
if mibBuilder.loadTexts: sifFilterFlags.setDescription('Special filter flags; any combination of the following bits: 0x0001 NO_SOURCE_SAME, 0x0002 NO_SOURCE_LEARNT, 0x0004 NO_LEARNING, 0x0008 NO_DEST_LEARNT ')
sifCongestTime = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 7, 2, 1, 12), TimeTicks()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sifCongestTime.setStatus('mandatory')
if mibBuilder.loadTexts: sifCongestTime.setDescription('When a port becomes congested, the PPE will discard any packets destined to the port for this many centiseconds following the congestion alarm. Possible values 0 through 5 minutes, except for port 1 (the out-of-band management port) which is always 0.')
sifQueueTime = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 7, 2, 1, 13), TimeTicks()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sifQueueTime.setStatus('mandatory')
if mibBuilder.loadTexts: sifQueueTime.setDescription('The time, in centiseconds, after which an element in a transmit queue will be flushed.')
sifPortCost = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 7, 2, 1, 14), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sifPortCost.setStatus('mandatory')
if mibBuilder.loadTexts: sifPortCost.setDescription('')
sifStPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 7, 2, 1, 15), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sifStPriority.setStatus('mandatory')
if mibBuilder.loadTexts: sifStPriority.setDescription('')
sifFunctions = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 7, 2, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sifFunctions.setStatus('mandatory')
if mibBuilder.loadTexts: sifFunctions.setDescription('The current functional state (protocols which have been activated and are operational) of the port. The following values or combinations are supported: 0x0001 NMS, 0x0002 TBRIDGE, 0x0004 SBRIDGE, 0x0006 SRTBRIDGE, 0x0008 MESH, 0x0010 IPROUTE, 0x0020 NO_BPDU, 0x0040 RIP, 0x0080 SRSPAN, 0x0100 PROXY, 0x0200 OSPF. These values can be configured through the sprotoTable. Combining TBRIDGE and SBRIDGE always produces SRTBRIDGE.')
sifCongested = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 7, 2, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sifCongested.setStatus('mandatory')
if mibBuilder.loadTexts: sifCongested.setDescription('Whether the port is out-bound congested.')
sifState = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 7, 2, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("spanning-tree-disabled", 1), ("spanning-tree-listening", 2), ("spanning-tree-learning", 3), ("spanning-tree-forwarding", 4), ("spanning-tree-blocking", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sifState.setStatus('mandatory')
if mibBuilder.loadTexts: sifState.setDescription('')
sifDesigCost = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 7, 2, 1, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sifDesigCost.setStatus('mandatory')
if mibBuilder.loadTexts: sifDesigCost.setDescription('')
sifDesigRoot = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 7, 2, 1, 20), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sifDesigRoot.setStatus('mandatory')
if mibBuilder.loadTexts: sifDesigRoot.setDescription('')
sifDesigBridge = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 7, 2, 1, 21), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sifDesigBridge.setStatus('mandatory')
if mibBuilder.loadTexts: sifDesigBridge.setDescription('')
sifDesigPort = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 7, 2, 1, 22), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sifDesigPort.setStatus('mandatory')
if mibBuilder.loadTexts: sifDesigPort.setDescription('')
sifRxPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 7, 2, 1, 23), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sifRxPackets.setStatus('mandatory')
if mibBuilder.loadTexts: sifRxPackets.setDescription('A 100 byte array, containing the number of received packets broken down into 25 categories. The number of packets in each category is encoded as a series of 4 bytes, which should be converted into a 32 bit counter. The 25 categories are determined by combining each possible DEST_xxx value with each possible OUTCOME_xxx value, as listed below: DEST_UBRIDGE = 0, DEST_MBRIDGE = 1, DEST_KNOWN = 2, DEST_UNKNOWN = 3, DEST_MULTI = 4, OUTCOME_FWD = 0, OUTCOME_LOCAL = 5, OUTCOME_BLOCK = 10, OUTCOME_SOURCE = 15, OUTCOME_DEST = 20')
sifRxChar0s = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 7, 2, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sifRxChar0s.setStatus('mandatory')
if mibBuilder.loadTexts: sifRxChar0s.setDescription('Number of characters in the forwarded received packets.')
sifRxChar1s = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 7, 2, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sifRxChar1s.setStatus('mandatory')
if mibBuilder.loadTexts: sifRxChar1s.setDescription('Number of characters in the filtered received packets.')
sifRxSizeErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 7, 2, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sifRxSizeErrors.setStatus('mandatory')
if mibBuilder.loadTexts: sifRxSizeErrors.setDescription('Number of received packets discarded due to size errors.')
sifRxHwFCSs = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 7, 2, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sifRxHwFCSs.setStatus('mandatory')
if mibBuilder.loadTexts: sifRxHwFCSs.setDescription('Number of received packets discarded due to FCS errors.')
sifRxQueues = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 7, 2, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sifRxQueues.setStatus('mandatory')
if mibBuilder.loadTexts: sifRxQueues.setDescription('Number of received packets lost because of insufficient receive buffers.(For certain interfaces with multi-packet FIFO hardware, this count might be approximate.)')
sifTxPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 7, 2, 1, 30), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sifTxPackets.setStatus('mandatory')
if mibBuilder.loadTexts: sifTxPackets.setDescription('A 20 byte array, containing the number of transmitted packets broken down into 5 categories. The number of packets in each category is encoded as a series of 4 bytes, which should be converted into a 32 bit counter.')
sifTxCongests = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 7, 2, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sifTxCongests.setStatus('obsolete')
if mibBuilder.loadTexts: sifTxCongests.setDescription('')
sifTxStorms = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 7, 2, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sifTxStorms.setStatus('mandatory')
if mibBuilder.loadTexts: sifTxStorms.setDescription('Number of packets not sent due to protection against a multicast storm.')
sifTxDests = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 7, 2, 1, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sifTxDests.setStatus('mandatory')
if mibBuilder.loadTexts: sifTxDests.setDescription('Number of packets not sent due to a destination port filtering restriction.')
sifErrorsFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 7, 2, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sifErrorsFlag.setStatus('mandatory')
if mibBuilder.loadTexts: sifErrorsFlag.setDescription('Whether the port has exceeded the limits specified by sifThreshold and sifThresholdTime.')
sifTxStormFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 7, 2, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sifTxStormFlag.setStatus('mandatory')
if mibBuilder.loadTexts: sifTxStormFlag.setDescription('Whether PPE has invoked multicast storm protection.')
sifTxSizes = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 7, 2, 1, 36), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sifTxSizes.setStatus('mandatory')
if mibBuilder.loadTexts: sifTxSizes.setDescription('Number of packets not sent due to size limitations.')
sifTxAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 7, 2, 1, 37), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sifTxAddr.setStatus('mandatory')
if mibBuilder.loadTexts: sifTxAddr.setDescription('A series of 16 MAC addresses (96 octets in total), of the source addresses of the last 16 packets that were not sent due to packet size limitations. If fewer than 16 packets were not sent, then the unspecified MAC addresses will be all zeroes.')
sifLan = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 7, 2, 1, 38), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sifLan.setStatus('mandatory')
if mibBuilder.loadTexts: sifLan.setDescription("Up to four group identifiers assigned to the port. The sifLan identifier is only used by combination filter testing, i.e., for comparisons against filterSrcLan. Possible values are 0 through 255, for each of the parameter's four bytes.")
sifStatisticsTime = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 7, 2, 1, 39), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sifStatisticsTime.setStatus('mandatory')
if mibBuilder.loadTexts: sifStatisticsTime.setDescription('Length of time during which statistics were collected. In particular, the following statistics may be examined to determine the exact utilization rate of a port: ifInOctets, ifInUcastPkts, ifInNUcastPkts ifOutOctets, ifOutUcastPkts, ifOutNUcastPkts sifRxChar0s, sifRxChar1s.')
sifIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 7, 2, 1, 40), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sifIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: sifIpAddress.setDescription("The IP address assigned to the port. If this is zero, then the port must learn its IP address via Reverse ARP or PPP's IPCP.")
sifIpGroupAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 7, 2, 1, 41), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sifIpGroupAddress.setStatus('mandatory')
if mibBuilder.loadTexts: sifIpGroupAddress.setDescription('Zero, or an IP Group address assigned to the port.')
sifMaxPacketSize = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 7, 2, 1, 42), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sifMaxPacketSize.setStatus('mandatory')
if mibBuilder.loadTexts: sifMaxPacketSize.setDescription('The maximum packet size, in bytes (octets), which may be transmitted through this port. This parameter may not be changed, except for PPP ports, in which case, changing sifMaxPacketSize automatically causes ifMtu and pppLinkLocalMRU to change.')
sifExpectSqe = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 7, 2, 1, 43), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sifExpectSqe.setStatus('mandatory')
if mibBuilder.loadTexts: sifExpectSqe.setDescription('Whether the port should expect SQE, also known as heartbeat (not applicable for ports other than CSMA/CD ports).')
sifFilterLocal = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 7, 2, 1, 44), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sifFilterLocal.setStatus('mandatory')
if mibBuilder.loadTexts: sifFilterLocal.setDescription('Whether the port should attempt to filter local traffic, bypassing all statistics accumulation, rather than passing the local traffic to the Packet Processing Engine. Filtering local traffic is not available for UART and WAN ports.')
sifInQLen = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 7, 2, 1, 45), Gauge32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sifInQLen.setStatus('mandatory')
if mibBuilder.loadTexts: sifInQLen.setDescription("The maximum length ever obtained by the port's inbound packet queue (in packets). The size of a port's inbound packet queue is periodically polled (rather than recalculated whenever a packet is added), so sifInQLen is an approximation of the maximum length.")
sifFrameSwitching = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 7, 2, 1, 46), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sifFrameSwitching.setStatus('mandatory')
if mibBuilder.loadTexts: sifFrameSwitching.setDescription('Valid only for Token Ring ports. Options include: enabled (1), disabled (2).Defaults to disabled(2). If enabled, frames may be bridged between token ring ports on the same board at higher throughput and lower latency than is otherwise possible. Address statistics will not reflect any frames forwarded in this manner. This applies only to transparent bridging, and must be enabled on both the entry and the exit port.')
sifRingDrops = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 7, 2, 1, 47), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sifRingDrops.setStatus('mandatory')
if mibBuilder.loadTexts: sifRingDrops.setDescription('Only valid for 802.5 token ring. Number of times the ring left the open state.')
sifAdapterChecks = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 7, 2, 1, 48), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sifAdapterChecks.setStatus('mandatory')
if mibBuilder.loadTexts: sifAdapterChecks.setDescription('Only valid for 802.5 token ring. Number of times the MAC chip experienced an internal hardware failure and had to be reset.')
sifIpRipPortMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 7, 2, 1, 49), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sifIpRipPortMetric.setStatus('mandatory')
if mibBuilder.loadTexts: sifIpRipPortMetric.setDescription('Port metric for backup RIP interface.')
sifDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 7, 2, 1, 50), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sifDescr.setStatus('mandatory')
if mibBuilder.loadTexts: sifDescr.setDescription('A textual string containing information about the interface. This string should include the name of the manufacturer, the product name and the version of the hardware interface.')
sifUtilInterval = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 7, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sifUtilInterval.setStatus('mandatory')
if mibBuilder.loadTexts: sifUtilInterval.setDescription('The number of seconds in each utilization sample.')
sifUtilCount = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 7, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sifUtilCount.setStatus('mandatory')
if mibBuilder.loadTexts: sifUtilCount.setDescription('The number of same-kind peak samples per physical port accumulated in sifUtilPortPeakTable or sifUtilSysPeakTable.')
sifUtilPortPeakReset = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 7, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("true", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sifUtilPortPeakReset.setStatus('mandatory')
if mibBuilder.loadTexts: sifUtilPortPeakReset.setDescription('This object is set to true (1) to erase earlier per-physical-port utilization samples on all specified port(s).')
sifUtilPortPeakTable = MibTable((1, 3, 6, 1, 4, 1, 97, 3, 7, 6), )
if mibBuilder.loadTexts: sifUtilPortPeakTable.setStatus('mandatory')
if mibBuilder.loadTexts: sifUtilPortPeakTable.setDescription('A list of interface utilization entries; one per sifUtilCount per physical port, plus one per physical port for the most recently completed samples.')
sifUtilPortPeakEntry = MibTableRow((1, 3, 6, 1, 4, 1, 97, 3, 7, 6, 1), ).setIndexNames((0, "CTATX-MIB", "sifUtilPortPeakIndex"), (0, "CTATX-MIB", "sifUtilPortPeakOrdinal"))
if mibBuilder.loadTexts: sifUtilPortPeakEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sifUtilPortPeakEntry.setDescription('A set of utilization statistics recorded for an interface entry at per-port throughput peaks.')
sifUtilPortPeakIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 7, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sifUtilPortPeakIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sifUtilPortPeakIndex.setDescription('The port number.')
sifUtilPortPeakOrdinal = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 7, 6, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sifUtilPortPeakOrdinal.setStatus('mandatory')
if mibBuilder.loadTexts: sifUtilPortPeakOrdinal.setDescription("The ordinal of the entry, with 1 representing 'Now' (i.e. the sample most recently accumulated), with 2 representing the sample taken at the highest per-port throughput peak, 3 at the next highest, and so on.")
sifUtilPortPeakBRTimestamp = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 7, 6, 1, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sifUtilPortPeakBRTimestamp.setStatus('mandatory')
if mibBuilder.loadTexts: sifUtilPortPeakBRTimestamp.setDescription('The value of sysUpTime associated with the end of the sample period for the associated sifUtilPortPeakTBitRate/sifUtilPortPeakRBitRate sample, or the most recent timestamp for the sample currently being accumulated. This will be 0 for any ports for which utilization statistics are not kept, or where statistics have been reset too recently to have accumulated an appropriate sample.')
sifUtilPortPeakTBitRate = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 7, 6, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 99))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sifUtilPortPeakTBitRate.setStatus('mandatory')
if mibBuilder.loadTexts: sifUtilPortPeakTBitRate.setDescription('The ratio of the number of bits transmitted per second during the per-physical-port sample interval to the linespeed in bits per second, expressed in integer units of 1/100, maximum 99. This will be 0 for any ports for which utilization statistics are not kept, or where statistics have been reset too recently to have accumulated an appropriate sample.')
sifUtilPortPeakRBitRate = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 7, 6, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 99))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sifUtilPortPeakRBitRate.setStatus('mandatory')
if mibBuilder.loadTexts: sifUtilPortPeakRBitRate.setDescription('The ratio of the number of bits received per second during the per-physical-port sample interval to the linespeed in bits per second, expressed in integer units of 1/100, maximum 99, and excluding some or all locally-filtered traffic per sifFilterLocal. This will be 0 for any ports for which utilization statistics are not kept, or where statistics have been reset too recently to have accumulated an appropriate sample.')
sifUtilSysPeakReset = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 7, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("true", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sifUtilSysPeakReset.setStatus('mandatory')
if mibBuilder.loadTexts: sifUtilSysPeakReset.setDescription('This object is set to true (1) to erase earlier per-system utilization samples.')
sifUtilSysPeakTable = MibTable((1, 3, 6, 1, 4, 1, 97, 3, 7, 8), )
if mibBuilder.loadTexts: sifUtilSysPeakTable.setStatus('mandatory')
if mibBuilder.loadTexts: sifUtilSysPeakTable.setDescription('A list of interface utilization entries; one per sifUtilCount per physical port, plus one per physical port for the most recently completed samples.')
sifUtilSysPeakEntry = MibTableRow((1, 3, 6, 1, 4, 1, 97, 3, 7, 8, 1), ).setIndexNames((0, "CTATX-MIB", "sifUtilSysPeakIndex"), (0, "CTATX-MIB", "sifUtilSysPeakOrdinal"))
if mibBuilder.loadTexts: sifUtilSysPeakEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sifUtilSysPeakEntry.setDescription('A set of utilization statistics recorded for an interface entry at overall system throughput peaks.')
sifUtilSysPeakIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 7, 8, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sifUtilSysPeakIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sifUtilSysPeakIndex.setDescription('The port number.')
sifUtilSysPeakOrdinal = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 7, 8, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sifUtilSysPeakOrdinal.setStatus('mandatory')
if mibBuilder.loadTexts: sifUtilSysPeakOrdinal.setDescription("The ordinal of the entry, with 1 representing 'Now' (i.e. the sample most recently accumulated), with 2 representing the sample taken at the highest peak system throughput, 3 at the next highest, and so on.")
sifUtilSysPeakTimestamp = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 7, 8, 1, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sifUtilSysPeakTimestamp.setStatus('mandatory')
if mibBuilder.loadTexts: sifUtilSysPeakTimestamp.setDescription('The value of sysUpTime associated with the end of the sample period for the associated sifUtilSysPeakTBitRate/sifUtilSysPeakRBitRate sample, or the most recent timestamp for the sample currently being accumulated. This will be 0 for any ports for which utilization statistics are not kept, or where statistics have been reset too recently to have accumulated an appropriate sample.')
sifUtilSysPeakTBitRate = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 7, 8, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 99))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sifUtilSysPeakTBitRate.setStatus('mandatory')
if mibBuilder.loadTexts: sifUtilSysPeakTBitRate.setDescription('The ratio of the number of bits transmitted per second during the per-system-peak sample interval to the linespeed in bits per second, expressed in integer units of 1/100, maximum 99. This will be 0 for any ports for which utilization statistics are not kept, or where statistics have been reset too recently to have accumulated an appropriate sample.')
sifUtilSysPeakRBitRate = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 7, 8, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 99))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sifUtilSysPeakRBitRate.setStatus('mandatory')
if mibBuilder.loadTexts: sifUtilSysPeakRBitRate.setDescription('The ratio of the number of bits received per second during the per-system-peak sample interval to the linespeed in bits per second, expressed in integer units of 1/100, maximum 99, and excluding some or all locally-filtered traffic per sifFilterLocal. This will be 0 for any ports for which utilization statistics are not kept, or where statistics have been reset too recently to have accumulated an appropriate sample.')
sfddiTable = MibTable((1, 3, 6, 1, 4, 1, 97, 3, 8, 1), )
if mibBuilder.loadTexts: sfddiTable.setStatus('mandatory')
if mibBuilder.loadTexts: sfddiTable.setDescription('A list of interface entries; one per FDDI port.')
sfddiEntry = MibTableRow((1, 3, 6, 1, 4, 1, 97, 3, 8, 1, 1), ).setIndexNames((0, "CTATX-MIB", "sfddiIndex"))
if mibBuilder.loadTexts: sfddiEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sfddiEntry.setDescription('A set of objects for an interface entry.')
sfddiIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 8, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfddiIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sfddiIndex.setDescription("The ES/1's port number of the port.")
sfddiRxHwAborts = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 8, 1, 1, 2), Counter32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfddiRxHwAborts.setStatus('mandatory')
if mibBuilder.loadTexts: sfddiRxHwAborts.setDescription('The number of packets that were discarded due to receive abort errors.')
sfddiRxParitys = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 8, 1, 1, 3), Counter32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfddiRxParitys.setStatus('mandatory')
if mibBuilder.loadTexts: sfddiRxParitys.setDescription('The number of packets that were discarded due to parity errors.')
sfddiRxShorts = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 8, 1, 1, 4), Counter32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfddiRxShorts.setStatus('mandatory')
if mibBuilder.loadTexts: sfddiRxShorts.setDescription('The number of packets that were discarded because they were too short.')
sfddiDpcErrCnts = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 8, 1, 1, 5), Counter32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfddiDpcErrCnts.setStatus('mandatory')
if mibBuilder.loadTexts: sfddiDpcErrCnts.setDescription('The number of DPC errors.')
sfddiDpcErrValue = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 8, 1, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfddiDpcErrValue.setStatus('mandatory')
if mibBuilder.loadTexts: sfddiDpcErrValue.setDescription('Detailed status of the last DPC error.')
sfddiRbcErrCnts = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 8, 1, 1, 7), Counter32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfddiRbcErrCnts.setStatus('mandatory')
if mibBuilder.loadTexts: sfddiRbcErrCnts.setDescription('The number of RBC errors.')
sfddiRbcErrValue = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 8, 1, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfddiRbcErrValue.setStatus('mandatory')
if mibBuilder.loadTexts: sfddiRbcErrValue.setDescription('Detailed status of the last RBC error. (FIOM MIB only)')
sfddiTxAsync = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 8, 1, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfddiTxAsync.setStatus('mandatory')
if mibBuilder.loadTexts: sfddiTxAsync.setDescription('Number of bytes to reserve in the DPC Buffer Memory for transmitting asynchronous packets.')
sfddiShortAddressing = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 8, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfddiShortAddressing.setStatus('mandatory')
if mibBuilder.loadTexts: sfddiShortAddressing.setDescription('Whether any packets were received with 16 bit MAC addresses.')
sfddiSmtConditions = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 8, 1, 1, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfddiSmtConditions.setStatus('mandatory')
if mibBuilder.loadTexts: sfddiSmtConditions.setDescription('SMT conditions which should be reported to the NMS via SNMP Traps. Possible values are any combination of the following bits: ring = 0x00000001, claim = 0x00000002, beacon = 0x00000004, tvx = 0x00000008, trt = 0x00000010, phy-invalid = 0x00000020, reset = 0x00000040, overflow = 0x00000080, dup = 0x00000100, lost = 0x00000200, restricted = 0x00000400, congestion = 0x00000800, token = 0x00001000, t4 = 0x00002000.')
sfddiSrfConditions = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 8, 1, 1, 12), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfddiSrfConditions.setStatus('mandatory')
if mibBuilder.loadTexts: sfddiSrfConditions.setDescription('SRF conditions which should be reported to the NMS via SNMP Traps. Possible values are any combination of the following bits: srf-frame-error = 0x00000001, srf-port-ler = 0x00000002, srf-not-copied = 0x00000004,srf-dup-addr = 0x00000008, srf-eb-error = 0x00000010,srf-config = 0x00000020, srf-connect = 0x00000040, srf-trace = 0x00000080, srf-neighbor = 0x00000100,srf-peer-wrap = 0x00000400, srf-path-change = 0x00000800 ')
sfddiSmtConditionsStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 8, 1, 1, 13), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfddiSmtConditionsStatus.setStatus('mandatory')
if mibBuilder.loadTexts: sfddiSmtConditionsStatus.setDescription('Requested SMT conditions which are currently present. Writing to sfddiSmtConditionsStatus is used to acknowledge the SNMP traps.')
sfddiSrfConditionsStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 8, 1, 1, 14), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfddiSrfConditionsStatus.setStatus('mandatory')
if mibBuilder.loadTexts: sfddiSrfConditionsStatus.setDescription('Requested SRF conditions which are currently present. Writing to sfddiSrfConditionsStatus is used to acknowledge the SNMP traps.')
sfddiSrfReportLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 8, 1, 1, 15), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfddiSrfReportLimit.setStatus('mandatory')
if mibBuilder.loadTexts: sfddiSrfReportLimit.setDescription('')
sfddiFrameErrorThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 8, 1, 1, 16), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfddiFrameErrorThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: sfddiFrameErrorThreshold.setDescription('')
sfddiNotCopiedThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 8, 1, 1, 17), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfddiNotCopiedThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: sfddiNotCopiedThreshold.setDescription('Value for the fddiMACNotCopiedThreshold variable.')
sfddiSBFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 8, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfddiSBFlag.setStatus('mandatory')
if mibBuilder.loadTexts: sfddiSBFlag.setDescription("Whether the ECM's optical bypass is stuck, i.e., the current value of the SMT SB_Flag variable.")
sfddiRxEbits = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 8, 1, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfddiRxEbits.setStatus('mandatory')
if mibBuilder.loadTexts: sfddiRxEbits.setDescription('The number of packets that were discarded because another station had already set the E bit.')
sfddiOBSFuseBad = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 8, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfddiOBSFuseBad.setStatus('mandatory')
if mibBuilder.loadTexts: sfddiOBSFuseBad.setDescription("Whether the fuse to the FDDI port's optical bypass is bad.")
sfddiThruB = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 8, 1, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfddiThruB.setStatus('mandatory')
if mibBuilder.loadTexts: sfddiThruB.setDescription('Whether to connect to the FDDI port B (not applicable for SAS).')
sfddiStationDescriptor = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 8, 1, 1, 22), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfddiStationDescriptor.setStatus('mandatory')
if mibBuilder.loadTexts: sfddiStationDescriptor.setDescription("A four byte string containing the FDDI port's Station Descriptor parameter, as defined by the SMT frame protocols.")
sfddiStationState = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 8, 1, 1, 23), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfddiStationState.setStatus('mandatory')
if mibBuilder.loadTexts: sfddiStationState.setDescription("A four byte string containing the FDDI port's Station State parameter, as defined by the SMT frame protocols.")
sfddiDownstreamNbr = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 8, 1, 1, 24), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfddiDownstreamNbr.setStatus('mandatory')
if mibBuilder.loadTexts: sfddiDownstreamNbr.setDescription("The MAC address of the FDDI port's downstream neighbor.")
sfddiSMTBufferSize = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 8, 1, 1, 25), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfddiSMTBufferSize.setStatus('mandatory')
if mibBuilder.loadTexts: sfddiSMTBufferSize.setDescription('The amount of packet buffer space to reserve for processing SMT frames. Possible values 9000 - 18000. (FIOM MIB only)')
suartTable = MibTable((1, 3, 6, 1, 4, 1, 97, 3, 9, 1), )
if mibBuilder.loadTexts: suartTable.setStatus('mandatory')
if mibBuilder.loadTexts: suartTable.setDescription('A list of interface entries; one per UART port.')
suartEntry = MibTableRow((1, 3, 6, 1, 4, 1, 97, 3, 9, 1, 1), ).setIndexNames((0, "CTATX-MIB", "suartIndex"))
if mibBuilder.loadTexts: suartEntry.setStatus('mandatory')
if mibBuilder.loadTexts: suartEntry.setDescription('A set of objects for an interface entry. ')
suartIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 9, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: suartIndex.setStatus('mandatory')
if mibBuilder.loadTexts: suartIndex.setDescription("The ES/1's port number of the port.")
suartBaud = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 9, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))).clone(namedValues=NamedValues(("external-clock", 1), ("b1200-baud", 2), ("b2400-baud", 3), ("b4800-baud", 4), ("b9600-baud", 5), ("b19200-baud", 6), ("b38400-baud", 7), ("b56-kilobits", 8), ("b1544-kilobits", 9), ("b2048-kilobits", 10), ("b45-megabits", 11)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: suartBaud.setStatus('mandatory')
if mibBuilder.loadTexts: suartBaud.setDescription('This is the desired baud rate. Only 1200 baud through 19,200 baud are supported by the ES/1.')
suartModem = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 9, 1, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: suartModem.setStatus('mandatory')
if mibBuilder.loadTexts: suartModem.setDescription('The expected modem signals; definitions of the different values are TBD.')
suartIpNeighborAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 9, 1, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: suartIpNeighborAddress.setStatus('mandatory')
if mibBuilder.loadTexts: suartIpNeighborAddress.setDescription('')
suartPPPActive = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 9, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: suartPPPActive.setStatus('mandatory')
if mibBuilder.loadTexts: suartPPPActive.setDescription('')
suartAlignmentErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 9, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: suartAlignmentErrors.setStatus('mandatory')
if mibBuilder.loadTexts: suartAlignmentErrors.setDescription('Number of received packets with frame alignment errors, since the port was last enabled.')
suartOverrunErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 9, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: suartOverrunErrors.setStatus('mandatory')
if mibBuilder.loadTexts: suartOverrunErrors.setDescription('Number of received packets with data overrun errors, since the port was last enabled.')
filterMaxCount = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 10, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: filterMaxCount.setStatus('mandatory')
if mibBuilder.loadTexts: filterMaxCount.setDescription('The maximum number of combination filters that may be defined for the ES/1. This is always 100.')
filterCurrentCount = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 10, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: filterCurrentCount.setStatus('mandatory')
if mibBuilder.loadTexts: filterCurrentCount.setDescription('The number of combination filters currently defined for the ES/1.')
filterDeleteID = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 10, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: filterDeleteID.setStatus('mandatory')
if mibBuilder.loadTexts: filterDeleteID.setDescription('A filter identifier used for deleting filters. After the NMS sets this field, the ES/1 deletes the filterEntry that has a matching filter ID field, and resets this field to zero. The ES/1 then updates filterCurrentCount, filterNextID, and the entire filterTable.')
filterNextID = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 10, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: filterNextID.setStatus('mandatory')
if mibBuilder.loadTexts: filterNextID.setDescription('A filter identifier used for adding filters.')
filterAddID = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 10, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: filterAddID.setStatus('mandatory')
if mibBuilder.loadTexts: filterAddID.setDescription('A filter identifier used for adding filters. After the NMS sets this field, the ES/1 adds the filterEntry indexed by filterAddIndex. The ES/1 then updates filterCurrentCount, filterNextID, and the entire filterTable. Note that if filterAddID does not match filterNextID, then the ES/1 will not add the entry, since the SetRequest for filterAddID must have been a duplicate packet.')
filterAddIndex = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 10, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: filterAddIndex.setStatus('mandatory')
if mibBuilder.loadTexts: filterAddIndex.setDescription('The index within filterTable, after which a filter should be added. If filterAddIndex contains zero, then the filter should be added as the first filterEntry within filterTable.')
filterTable = MibTable((1, 3, 6, 1, 4, 1, 97, 3, 10, 7), )
if mibBuilder.loadTexts: filterTable.setStatus('mandatory')
if mibBuilder.loadTexts: filterTable.setDescription('A list of combination filters; one per defined filter. If fewer than filterMaxCount filters have been defined, then an additional filterEntry exists, which is used as part of the sequence for defining a new filter.')
filterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 97, 3, 10, 7, 1), ).setIndexNames((0, "CTATX-MIB", "filterIndex"))
if mibBuilder.loadTexts: filterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: filterEntry.setDescription('A set of objects for a combination filter.')
filterIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 10, 7, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: filterIndex.setStatus('mandatory')
if mibBuilder.loadTexts: filterIndex.setDescription('This number always matches the instance of the filterEntry.')
filterID = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 10, 7, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: filterID.setStatus('mandatory')
if mibBuilder.loadTexts: filterID.setDescription('Identifier assigned to the filter, used for obtaining the value for filterDeleteID so that the filter can be deleted.')
filterPortNo = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 10, 7, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: filterPortNo.setStatus('mandatory')
if mibBuilder.loadTexts: filterPortNo.setDescription('The port number related to this filter.')
filterComboType = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 10, 7, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: filterComboType.setStatus('mandatory')
if mibBuilder.loadTexts: filterComboType.setDescription('Whether this is an entry filter (0), an exit filter(1), a port mirror entry filter (3), or a port mirror exit filter (4).')
filterFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 10, 7, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: filterFlags.setStatus('mandatory')
if mibBuilder.loadTexts: filterFlags.setDescription('A set of flag bits which control the operation of the filter. Filters will not prevent packets from being accepted by the ES/1 as a final destination. The following bits are used: bit 13, bit 12, bit 11, bit 10. bits 9-8 used for filterFrame. bits 7-6 used for filterSource, filterSourceEnd, and filterSourceMask. bits 5-4 used for filterDest, filterDestEnd, and filterDestMask. bits 3-2 used for filterSrcLan. bits 1-0 used for filterField, filterOffset, and filterMask.')
filterFrame = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 10, 7, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: filterFrame.setStatus('mandatory')
if mibBuilder.loadTexts: filterFrame.setDescription('Ethernet protocol type (1501-65535), or one (1) to indicate any 802 frame, or two (2) to indicate any Ethernet frame, Note that a specific Ethernet protocol type may appear in either Ethernet format frames, or encapsulated within 802 format frames.')
filterSource = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 10, 7, 1, 7), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: filterSource.setStatus('mandatory')
if mibBuilder.loadTexts: filterSource.setDescription('Beginning source address.')
filterSourceEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 10, 7, 1, 8), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: filterSourceEnd.setStatus('mandatory')
if mibBuilder.loadTexts: filterSourceEnd.setDescription('Ending source address.')
filterDest = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 10, 7, 1, 9), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: filterDest.setStatus('mandatory')
if mibBuilder.loadTexts: filterDest.setDescription('Beginning destination address.')
filterDestEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 10, 7, 1, 10), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: filterDestEnd.setStatus('mandatory')
if mibBuilder.loadTexts: filterDestEnd.setDescription('Ending destination address.')
filterSourceMask = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 10, 7, 1, 11), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: filterSourceMask.setStatus('mandatory')
if mibBuilder.loadTexts: filterSourceMask.setDescription("A bitmask to be applied to the packet's source address before checking it against filterSource and filterSourceEnd.")
filterDestMask = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 10, 7, 1, 12), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: filterDestMask.setStatus('mandatory')
if mibBuilder.loadTexts: filterDestMask.setDescription("A bitmask to be applied to the packet's destination address before checking it against filterDest and filterDestEnd.")
filterSrcLan = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 10, 7, 1, 13), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: filterSrcLan.setStatus('mandatory')
if mibBuilder.loadTexts: filterSrcLan.setDescription('Either the port number from which the packet is received, or the value of any one of the group identifiers defined by sifLan for that port.')
filterOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 10, 7, 1, 14), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: filterOffset.setStatus('mandatory')
if mibBuilder.loadTexts: filterOffset.setDescription('Zero-based offset of an arbitrary field within the packet. Depending upon the value of filterFlags, the offset is relative to the start of the translated packet, beginning with the big endian MAC addresses; or, the offset is relative to the start of the data past the IP header (and, the packet must be an IP packet with a valid IP header); or, the offset is relative to the start of the data past the Source Routing information (presence of Source Routing information is optional). ')
filterField = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 10, 7, 1, 15), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: filterField.setStatus('mandatory')
if mibBuilder.loadTexts: filterField.setDescription('An 8 octet value to be compared to the contents of the arbitrary field within the packet.')
filterMask = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 10, 7, 1, 16), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: filterMask.setStatus('mandatory')
if mibBuilder.loadTexts: filterMask.setDescription('An 8 octet mask to be applied to the arbitrary field within the packet, before comparing it to filterField.')
filterThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 10, 7, 1, 17), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: filterThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: filterThreshold.setDescription('The number of filter invocations at which an alarm to the NMS should be generated.')
filterThreshTime = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 10, 7, 1, 18), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: filterThreshTime.setStatus('mandatory')
if mibBuilder.loadTexts: filterThreshTime.setDescription('The length of time, in seconds, to which filterThreshold applies. A value of zero indicates that no alarms should be sent to the NMS. Values greater than 3600 (i.e., one hour) are not allowed.')
filterThreshFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 10, 7, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: filterThreshFlag.setStatus('mandatory')
if mibBuilder.loadTexts: filterThreshFlag.setDescription('Whether usage of this filter has exceeded the limits specified by filterThreshold and filterThreshTime, and the NMS has not yet acknowledged the alarm. Therefore, whenever the NMS reads this value, it will always be False; however, the NMS may receive alarms with this value set to True.')
filterPktCnts = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 10, 7, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: filterPktCnts.setStatus('mandatory')
if mibBuilder.loadTexts: filterPktCnts.setDescription('The total number of packets which were discarded due to this filter.')
filterLastSrc = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 10, 7, 1, 21), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: filterLastSrc.setStatus('mandatory')
if mibBuilder.loadTexts: filterLastSrc.setDescription('The source MAC address of the last packet which was discarded due to this filter ')
rebootBridgingMemory = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 11, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rebootBridgingMemory.setStatus('mandatory')
if mibBuilder.loadTexts: rebootBridgingMemory.setDescription("The percentage (1 - 99) of the PPE's memory to be allocated for MAC bridging. The PPE's remaining memory will be used for communicating with the NMS and for routing. ")
rebootSlotTable = MibTable((1, 3, 6, 1, 4, 1, 97, 3, 11, 2), )
if mibBuilder.loadTexts: rebootSlotTable.setStatus('mandatory')
if mibBuilder.loadTexts: rebootSlotTable.setDescription('A list of the desired occupants of the slots; one per slot.')
rebootEntry = MibTableRow((1, 3, 6, 1, 4, 1, 97, 3, 11, 2, 1), ).setIndexNames((0, "CTATX-MIB", "rebootIndex"))
if mibBuilder.loadTexts: rebootEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rebootEntry.setDescription('A set of objects for each slot.')
rebootIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 11, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rebootIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rebootIndex.setDescription('The slot number, beginning with 1 for the first slot. This number always matches the instance of the rebootEntry.')
rebootType = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 11, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("vacant", 1), ("unknown", 2), ("packet-processing-engine", 3), ("turbo", 4), ("csma-iom", 5), ("hssi-iom", 6), ("tpr-iom", 7), ("fddi-iom", 8), ("ifddi-iom", 9), ("ttpr-iom", 10), ("eiom8-iom", 11), ("feiom-iom", 12)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rebootType.setStatus('mandatory')
if mibBuilder.loadTexts: rebootType.setDescription('The desired module type of the slot.')
rebootUseMod = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 11, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3))).clone(namedValues=NamedValues(("reset", 1), ("run", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rebootUseMod.setStatus('mandatory')
if mibBuilder.loadTexts: rebootUseMod.setDescription('Whether to use this module, not applicable for the Packet Processing Engine.')
rebootPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 11, 2, 1, 4), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rebootPortType.setStatus('mandatory')
if mibBuilder.loadTexts: rebootPortType.setDescription('This is a variable-length byte array where each element represents the types of the ports belonging to this module.')
rebootConfig = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 11, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("no-change", 1), ("tftp-config", 2), ("revert-to-defaults", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rebootConfig.setStatus('mandatory')
if mibBuilder.loadTexts: rebootConfig.setDescription('The configuration file that will be used when the ES/1 reboots. This parameter is normally automatically set by the ES/1; however, an NMS may explicitly set it to either no-change (1) or revert-to-defaults (3).')
rebootRouteMemory = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 11, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rebootRouteMemory.setStatus('mandatory')
if mibBuilder.loadTexts: rebootRouteMemory.setDescription('Percentage of non-bridging memory to allocate for routing tables. The remainder will be used for transient packets such as ARP and RIP.')
debugStringID = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 12, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: debugStringID.setStatus('mandatory')
if mibBuilder.loadTexts: debugStringID.setDescription("The number of debug text strings sent by the ES/1. This parameter is used by the ES/1's enterprise specific trap mechanism.")
debugString = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 12, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: debugString.setStatus('mandatory')
if mibBuilder.loadTexts: debugString.setDescription('The last debug text string (0-80 bytes) sent by the ES/1.')
debugTable = MibTable((1, 3, 6, 1, 4, 1, 97, 3, 12, 3), )
if mibBuilder.loadTexts: debugTable.setStatus('mandatory')
if mibBuilder.loadTexts: debugTable.setDescription('A list of the modules which may be debugged, with one module per slot defined by hwSlotTable.')
debugEntry = MibTableRow((1, 3, 6, 1, 4, 1, 97, 3, 12, 3, 1), ).setIndexNames((0, "CTATX-MIB", "debugIndex"))
if mibBuilder.loadTexts: debugEntry.setStatus('mandatory')
if mibBuilder.loadTexts: debugEntry.setDescription('A set of objects for each module.')
debugIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 12, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: debugIndex.setStatus('mandatory')
if mibBuilder.loadTexts: debugIndex.setDescription('The module number, beginning with 1 for the module in the first slot. This number always matches the instance of the debugEntry.')
debugOperation = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 12, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("examine", 1), ("modify", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: debugOperation.setStatus('mandatory')
if mibBuilder.loadTexts: debugOperation.setDescription('Type of debug operation requested.')
debugBase = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 12, 3, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: debugBase.setStatus('mandatory')
if mibBuilder.loadTexts: debugBase.setDescription('The base address of the memory region to be examined or modified.')
debugLength = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 12, 3, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: debugLength.setStatus('mandatory')
if mibBuilder.loadTexts: debugLength.setDescription('The desired length, in words, of the memory region to be examined or modified. After the ES/1 performs the operation, debugLength is updated to indicate the length of memory that was actually examined or modified. If debugLength is updated to contain zero, then the module was not operational.')
debugData = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 12, 3, 1, 5), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: debugData.setStatus('mandatory')
if mibBuilder.loadTexts: debugData.setDescription('A series of 0-64 octets, which represents 0-16 words (this may change in the future, if the ES/1 has processors with word sizes of other than 4 bytes per word). When this variable is read, the LMA will use the values in debugBase and debugLength to return the contents of a specified memory range to the NMS. Similarly, when this variable is written, a specified area of memory will be overwritten with data supplied by the NMS.')
lpbkTable = MibTable((1, 3, 6, 1, 4, 1, 97, 3, 13, 1), )
if mibBuilder.loadTexts: lpbkTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpbkTable.setDescription('A list of interface entries; one per port.')
lpbkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 97, 3, 13, 1, 1), ).setIndexNames((0, "CTATX-MIB", "lpbkIndex"))
if mibBuilder.loadTexts: lpbkEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpbkEntry.setDescription('A set of objects for an interface entry.')
lpbkIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 13, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpbkIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpbkIndex.setDescription('The port number, beginning with 1 for the first port.')
lpbkOperation = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 13, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("loopback-off", 1), ("loopback-local", 2), ("loopback-remote", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpbkOperation.setStatus('mandatory')
if mibBuilder.loadTexts: lpbkOperation.setDescription('The type of loopback being performed. Setting lpbkOperation to loopback-off causes loop back operation to terminate. Setting lpbkOperation to loopback-local or loopback-remote causes loopback operation to commence, and the ES/1 automatically resets lpbkOperation to loopback-off when the loopback operation has completed.')
lpbkDestAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 13, 1, 1, 3), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpbkDestAddr.setStatus('mandatory')
if mibBuilder.loadTexts: lpbkDestAddr.setDescription('The MAC address of the target device, only needed for remote loopback.')
lpbkPktNum = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 13, 1, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpbkPktNum.setStatus('mandatory')
if mibBuilder.loadTexts: lpbkPktNum.setDescription('The number of loopback packets to be transmitted.')
lpbkInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 13, 1, 1, 5), TimeTicks()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpbkInterval.setStatus('mandatory')
if mibBuilder.loadTexts: lpbkInterval.setDescription('The desired time delay between the reception of a looped back packet, and the transmission of the next packet to be looped back.')
lpbkPktLength = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 13, 1, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpbkPktLength.setStatus('mandatory')
if mibBuilder.loadTexts: lpbkPktLength.setDescription('The length (in octets) of the loopback packet. The values of the data itself are automatically selected by the ES/1.')
lpbkIncrements = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 13, 1, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpbkIncrements.setStatus('mandatory')
if mibBuilder.loadTexts: lpbkIncrements.setDescription("The number of bytes of data to be added to the loopback packet after each successful loopback packet transmission and reception. When the port's maximum packet size has been reached, the ES/1 automatically begins again, starting with lpbkPktLength.")
lpbkGoods = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 13, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpbkGoods.setStatus('mandatory')
if mibBuilder.loadTexts: lpbkGoods.setDescription('The number of packets successfully looped back. This number is automatically reset to zero, whenever loopback operation is initiated.')
lpbkErrorNoReceives = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 13, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpbkErrorNoReceives.setStatus('mandatory')
if mibBuilder.loadTexts: lpbkErrorNoReceives.setDescription('The number of packets which were transmitted, but not received. This number is automatically reset to zero, whenever loopback operation is initiated.')
lpbkErrorBadReceives = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 13, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpbkErrorBadReceives.setStatus('mandatory')
if mibBuilder.loadTexts: lpbkErrorBadReceives.setDescription('The number of transmitted packets which were received with different data patterns. This number is automatically reset to zero, whenever loopback operation is initiated. ')
lpbkErrorSize = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 13, 1, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpbkErrorSize.setStatus('mandatory')
if mibBuilder.loadTexts: lpbkErrorSize.setDescription('The length of the last loopback packet which caused either lpbkErrorNoReceives or lpbkErrorBadReceives to be incremented. This number is automatically reset to zero, whenever loopback operation is initiated.')
lpbkErrorSent = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 13, 1, 1, 12), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpbkErrorSent.setStatus('mandatory')
if mibBuilder.loadTexts: lpbkErrorSent.setDescription('The transmitted bytes (0-4) of data within the last loopback packet which caused lpbkErrorBadReceives to be incremented. This parameter is automatically reset to the null string, whenever loopback operation is initiated.')
lpbkErrorReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 13, 1, 1, 13), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpbkErrorReceived.setStatus('mandatory')
if mibBuilder.loadTexts: lpbkErrorReceived.setDescription('The received bytes (0-4) of data within the last loopback packet which caused lpbkErrorBadReceives to be incremented. This parameter is automatically reset to the null string, whenever loopback operation is initiated.')
lpbkErrorOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 13, 1, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpbkErrorOffset.setStatus('mandatory')
if mibBuilder.loadTexts: lpbkErrorOffset.setDescription('The byte offset (one being the first byte) within the loopback packet where lpbkErrorSent begins. This number is automatically reset to zero, whenever loopback operation is initiated.')
swanTable = MibTable((1, 3, 6, 1, 4, 1, 97, 3, 14, 1), )
if mibBuilder.loadTexts: swanTable.setStatus('mandatory')
if mibBuilder.loadTexts: swanTable.setDescription('A list of interface entries; one per WAN port.')
swanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 97, 3, 14, 1, 1), ).setIndexNames((0, "CTATX-MIB", "swanIndex"))
if mibBuilder.loadTexts: swanEntry.setStatus('mandatory')
if mibBuilder.loadTexts: swanEntry.setDescription('A set of objects for an interface entry.')
swanIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 14, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swanIndex.setStatus('mandatory')
if mibBuilder.loadTexts: swanIndex.setDescription("The ES/1's port number of the port.")
swanDesiredSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 14, 1, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swanDesiredSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: swanDesiredSpeed.setDescription('')
swanActualSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 14, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6, 7, 8, 9, 10, 11))).clone(namedValues=NamedValues(("b1200-baud", 2), ("b2400-baud", 3), ("b4800-baud", 4), ("b9600-baud", 5), ("b19200-baud", 6), ("b38400-baud", 7), ("b56-kilobits", 8), ("b1544-kilobits", 9), ("b2048-kilobits", 10), ("b45-megabits", 11)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swanActualSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: swanActualSpeed.setDescription('This is the actual line speed. The possible values are defined by suartSpeed. For HSSI, the speed is 45-megabits(11). If the RS-449 interface is being used on the HSSI IOM, the speed is always reported as 1.544-megabits(9); however, the external clock may be generating a slower speed.')
swanIpNeighborAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 14, 1, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swanIpNeighborAddress.setStatus('mandatory')
if mibBuilder.loadTexts: swanIpNeighborAddress.setDescription("Zero, or an IP address to assign to the port's neighbor.")
swanPPPActive = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 14, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swanPPPActive.setStatus('mandatory')
if mibBuilder.loadTexts: swanPPPActive.setDescription('')
swanAlignmentErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 14, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swanAlignmentErrors.setStatus('mandatory')
if mibBuilder.loadTexts: swanAlignmentErrors.setDescription('')
swanOverrunErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 14, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swanOverrunErrors.setStatus('mandatory')
if mibBuilder.loadTexts: swanOverrunErrors.setDescription('Number of received packets with data overrun errors, since the port was last enabled.')
swanPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 14, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("wan-unknown", 1), ("wan-v11", 2), ("wan-v24", 3), ("wan-v35", 4), ("wan-e1", 5), ("wan-t1", 6), ("wan-rs530", 7), ("wan-t3", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swanPortType.setStatus('mandatory')
if mibBuilder.loadTexts: swanPortType.setDescription('')
swanLinkCost = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 14, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swanLinkCost.setStatus('mandatory')
if mibBuilder.loadTexts: swanLinkCost.setDescription('')
swanMeshState = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 14, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swanMeshState.setStatus('mandatory')
if mibBuilder.loadTexts: swanMeshState.setDescription('')
swanLinkSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 14, 1, 1, 11), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swanLinkSubnet.setStatus('mandatory')
if mibBuilder.loadTexts: swanLinkSubnet.setDescription('')
swanLinkBridge = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 14, 1, 1, 12), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swanLinkBridge.setStatus('mandatory')
if mibBuilder.loadTexts: swanLinkBridge.setDescription('')
swanLinkPort = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 14, 1, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swanLinkPort.setStatus('mandatory')
if mibBuilder.loadTexts: swanLinkPort.setDescription('')
swanNegotiate = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 14, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swanNegotiate.setStatus('mandatory')
if mibBuilder.loadTexts: swanNegotiate.setDescription('')
swanSwitches = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 14, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("wan-hssi", 1), ("wan-t1", 2), ("wan-hssi-switching-disabled", 3), ("wan-t1-switching-disabled", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swanSwitches.setStatus('mandatory')
if mibBuilder.loadTexts: swanSwitches.setDescription('Current port selected.')
swanDCEDrops = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 14, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swanDCEDrops.setStatus('mandatory')
if mibBuilder.loadTexts: swanDCEDrops.setDescription('Number of instances when loss of DCE has been detected.')
swanOutPacketType = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 14, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("token-ring-without-FCS", 1), ("token-ring-with-FCS", 2), ("ethernet-without-FCS", 3), ("ethernet-with-FCS", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swanOutPacketType.setStatus('mandatory')
if mibBuilder.loadTexts: swanOutPacketType.setDescription('The type of out going packet to generate on the HSSI link.')
swanLinkErrorPercentage = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 14, 1, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swanLinkErrorPercentage.setStatus('mandatory')
if mibBuilder.loadTexts: swanLinkErrorPercentage.setDescription('The percentage of acceptible errors in hundreths of percent. ')
swanLinkErrorDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 14, 1, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swanLinkErrorDuration.setStatus('mandatory')
if mibBuilder.loadTexts: swanLinkErrorDuration.setDescription('The time period in hundredths of a second over which the error percentage should be applied. ')
swanLinkErrorFailPeriods = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 14, 1, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swanLinkErrorFailPeriods.setStatus('mandatory')
if mibBuilder.loadTexts: swanLinkErrorFailPeriods.setDescription('The maximum number of periods allowed to contain the error percentage before the link quality is determined to have failed.')
swanLinkErrorMaxPeriods = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 14, 1, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swanLinkErrorMaxPeriods.setStatus('mandatory')
if mibBuilder.loadTexts: swanLinkErrorMaxPeriods.setDescription('The maximum number of periods to be used for calculation of link quality. Default is 10.')
swanLinkRestartTime = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 14, 1, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swanLinkRestartTime.setStatus('mandatory')
if mibBuilder.loadTexts: swanLinkRestartTime.setDescription('The time period in centiseconds which must contain error free LQR operation before restarting link. ')
swanPreserveFCS = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 14, 1, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swanPreserveFCS.setStatus('mandatory')
if mibBuilder.loadTexts: swanPreserveFCS.setDescription('Preserve received FCS if true, else regenerate FCS on packet transmission. ')
srepeaterTable = MibTable((1, 3, 6, 1, 4, 1, 97, 3, 16, 1), )
if mibBuilder.loadTexts: srepeaterTable.setStatus('mandatory')
if mibBuilder.loadTexts: srepeaterTable.setDescription('SMC-specific status information and control variables for a collection of repeater groups in a particular system.')
srepeaterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 97, 3, 16, 1, 1), ).setIndexNames((0, "CTATX-MIB", "srepeaterGroupID"))
if mibBuilder.loadTexts: srepeaterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: srepeaterEntry.setDescription('SMC-specific status information and control variables for a particular repeater domain (group) in the system.')
srepeaterGroupID = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 16, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: srepeaterGroupID.setStatus('mandatory')
if mibBuilder.loadTexts: srepeaterGroupID.setDescription('The value of srepeaterGroupID is assigned so as to uniquely identify a repeater domain (group) in a system where a single agent manages multiple repeater domains.')
srepeaterLinkStatusMask = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 16, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srepeaterLinkStatusMask.setStatus('mandatory')
if mibBuilder.loadTexts: srepeaterLinkStatusMask.setDescription('This mask provides quick access to the general connectivity of the repeater. Each bit corresponds to the link status of a repeater port. If the bit is set to 1 then link pulses are being received, as per the IEEE specification. A bit value of zero indicates one of four conditions: - There is nothing physically attached to the port. - The port is not configured for twisted-pair. The AUI interface, for example, does not generate or test for link pulses. - The device attached to the port does not generate the link pulses specified by the IEEE standard. STARLAN devices, for example, do not generate such pulses. - The port is configured to ignore link pulses (see srepeaterPortLinkPulse). The least significant bit in the mask corresponds to repeater port 1; the high-order eight bits are always zero.')
srepeaterExtendedStats = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 16, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: srepeaterExtendedStats.setStatus('mandatory')
if mibBuilder.loadTexts: srepeaterExtendedStats.setDescription('When enabled(1), the rptrMonitorGroup, rptrMonitorPort, and rptrAddrTrack tables are available, and the CEIOM maintains frame-by-frame tallies for the repeater in order to support these tables. Bridging performance may be slightly degraded due to the extra processing required, although the effect will not ordinarily be noticeable. When disabled(2), the rptrMonitorGroup, rptrMonitorPort, and rptrAddrTrack tables are not available.')
srepeaterPortTable = MibTable((1, 3, 6, 1, 4, 1, 97, 3, 16, 2), )
if mibBuilder.loadTexts: srepeaterPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: srepeaterPortTable.setDescription('SMC-specific status information and control variables for a collection of repeater ports in a particular system.')
srepeaterPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 97, 3, 16, 2, 1), ).setIndexNames((0, "CTATX-MIB", "srepeaterPortGroupID"), (0, "CTATX-MIB", "srepeaterPortPortID"))
if mibBuilder.loadTexts: srepeaterPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: srepeaterPortEntry.setDescription('SMC-specific status information and control variables for a particular repeater port in the system.')
srepeaterPortGroupID = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 16, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: srepeaterPortGroupID.setStatus('mandatory')
if mibBuilder.loadTexts: srepeaterPortGroupID.setDescription('The value of srepeaterPortGroupID is assigned so as to uniquely identify a group (repeater ID) in a system where a single agent manages multiple repeater groups. This corresponds to ifIndex, as well as rptr...GroupIndex. As with the standard rptr MIB, this table treats a CEIOM, which is actually a complete repeater domain, as a repeater group.')
srepeaterPortPortID = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 16, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srepeaterPortPortID.setStatus('mandatory')
if mibBuilder.loadTexts: srepeaterPortPortID.setDescription('Identifies a repeater port within a repeater group/domain. Values correspond to physical connector position on the CEIOM. For the CEIOM-24, the leftmost position is port 1, the rightmost port 24.')
srepeaterPortLinkPulse = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 16, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: srepeaterPortLinkPulse.setStatus('mandatory')
if mibBuilder.loadTexts: srepeaterPortLinkPulse.setDescription('When enabled (the default), the repeater port generates and expects to receive a link pulse, as per 10BaseT specification. When disabled, the port does not generate or expect link pulse, in order to accommodate pre-10BaseT twisted-pair Ethernet attachments.')
sprotoTable = MibTable((1, 3, 6, 1, 4, 1, 97, 3, 17, 1), )
if mibBuilder.loadTexts: sprotoTable.setStatus('mandatory')
if mibBuilder.loadTexts: sprotoTable.setDescription('This table contains configuration information specifying the types of protocols used to bridge, route, translate, and filter frames for each port.')
sprotoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 97, 3, 17, 1, 1), ).setIndexNames((0, "CTATX-MIB", "sprotoIfIndex"))
if mibBuilder.loadTexts: sprotoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sprotoEntry.setDescription('Each entry in this table specifies which protocols are used by a particular port in the ES/1.')
sprotoIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 17, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sprotoIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sprotoIfIndex.setDescription("Identifies the interface (port) to which this entry's information belongs. The value of this variable corresponds to ifIndex, as well as most of the other port identification values in related MIBs.")
sprotoBridge = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 17, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("transparent", 1), ("sr", 2), ("srt", 3), ("none", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sprotoBridge.setStatus('mandatory')
if mibBuilder.loadTexts: sprotoBridge.setDescription('Defines the bridging method to be applied to frames received at, or destined for, this port. Ethernet and FDDI ports may be configured for transparent, srt, or none. Token Ring ports may be configured for any of the four options. The UART may only be configured to none.')
sprotoSuppressBpdus = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 17, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normal", 1), ("suppressed", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sprotoSuppressBpdus.setStatus('mandatory')
if mibBuilder.loadTexts: sprotoSuppressBpdus.setDescription('Allows transmission of spanning tree protocol packets to be suppressed. If normal(1), 802.1d spanning tree packets and source-routing spanning tree packets are transmitted as usual. If suppressed(2), these packets are not transmitted. This option may be needed for in- teroperability with non-802.1d spanning tree protocols (e.g., DEC LanBridge 100).')
sprotoIpRoute = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 17, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sprotoIpRoute.setStatus('mandatory')
if mibBuilder.loadTexts: sprotoIpRoute.setDescription('Specifies whether or not this port is to be used for IP routing.')
sprotoIpxRoute = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 17, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("ipxsr", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sprotoIpxRoute.setStatus('mandatory')
if mibBuilder.loadTexts: sprotoIpxRoute.setDescription('Specifies whether or not this port is to be used for Novell NetWare IPX routing.')
sprotoAppleRoute = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 17, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sprotoAppleRoute.setStatus('mandatory')
if mibBuilder.loadTexts: sprotoAppleRoute.setDescription('Specifies whether or not this port is to be used for AppleTalk (tm) routing.')
sprotoArpTranslate = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 17, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("none", 1), ("bitswap1", 2), ("bitswap6", 3), ("bitswap61", 4), ("oneto6", 5), ("oneto6swap", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sprotoArpTranslate.setStatus('mandatory')
if mibBuilder.loadTexts: sprotoArpTranslate.setDescription('These options are intended to compensate for any like- ly implementation of internet ARP on 802.5 token ring. If set to bitswap1(2), then embedded MAC addresses for ARP packets with hardwareType 1 (Ethernet) will be bitswapped. If bitswap6(3) then embedded MAC addresses for ARP packets with hardware type 6 (IEEE 802) will be bitswapped. If bitswap61(4) then both type-1 and type-6 ARP packets will be bitswapped. If oneto6(5), then in- coming type-6 ARP packets will be changed to type-1 and outgoing type-1 ARP packets will be changed to type-6, both without bitswapping. If oneto6swap(6), then incom- ing type-6 ARP packets will be converted to type-1 and outgoing type-1 to type-6, with embedded addresses bitswapped. This option only applies to token ring ports. The fac- tory default for all ports is none(1).')
sprotoArpSourceRoute = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 17, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("passRif", 1), ("stripRif", 2), ("passBoth", 3), ("none", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sprotoArpSourceRoute.setStatus('mandatory')
if mibBuilder.loadTexts: sprotoArpSourceRoute.setDescription('Specifies whether, when bridging TCP/IP ARP packets which are source-routing explorer frames, the routing information is to be stripped or propagated. If pass- Rif(1), the frame is bridged as is, with route- discovery proceeding as expected. If stripRif(2), then the routing information field is stripped before being propagated. This option allows non-source-routing (e.g., Ethernet) IP hosts to communicate tran- sparently. If passBoth(3), then both the original source-routed frame and the transparent equivalent are propagated. This choice provides maximum connectivity at some expense in network traffic. None(4) is identical to passRif. This option applies only to token ring ports.')
sprotoIpxTranslate = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 17, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sprotoIpxTranslate.setStatus('mandatory')
if mibBuilder.loadTexts: sprotoIpxTranslate.setDescription('Specifies whether, when bridging Novell IPX frames, they are to be translated to Ethernet-like frame for- mat. This option applies only to token ring ports.')
sprotoAppleTranslate = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 17, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sprotoAppleTranslate.setStatus('mandatory')
if mibBuilder.loadTexts: sprotoAppleTranslate.setDescription('Specifies whether, when bridging AppleTalk ELAP, TLAP, and AARP frames, those frames are to be translated between token ring and Ethernet format before being forwarded. This option applies only to token ring ports.')
sprotoIbmLlcTranslate = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 17, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sprotoIbmLlcTranslate.setStatus('mandatory')
if mibBuilder.loadTexts: sprotoIbmLlcTranslate.setDescription('Specifies whether, when bridging IBM LLC frames, an 8209-style translation between token ring and Ethernet format is to be performed before being forwarded. This option applies only to token ring ports.')
sprotoRip = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 17, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sprotoRip.setStatus('mandatory')
if mibBuilder.loadTexts: sprotoRip.setDescription('Specifies whether the internet Routing Information Protocol (RFC-1058) is to be used over this port. Only valid if sprotoIpRoute is enabled.')
sprotoEgp = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 17, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sprotoEgp.setStatus('mandatory')
if mibBuilder.loadTexts: sprotoEgp.setDescription('Specifies whether the internet External Gateway Proto- col (RFC-904) is to be used over this port. Only valid if sprotoIpRoute is enabled.')
sprotoOspf = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 17, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sprotoOspf.setStatus('mandatory')
if mibBuilder.loadTexts: sprotoOspf.setDescription('Specifies whether the internet Open Shortest Path First protocol (RFC-1247) is to be used over this port. Only valid if sprotoIpRoute is enabled.')
sprotoArpProxy = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 17, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sprotoArpProxy.setStatus('mandatory')
if mibBuilder.loadTexts: sprotoArpProxy.setDescription('Specifies whether the port is to respond to internet ARP requests for which the unit is the next hop in a routed path. Only valid if sprotoIpRoute is enabled.')
sprotoIbm8209Lsaps = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 17, 1, 1, 16), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sprotoIbm8209Lsaps.setStatus('mandatory')
if mibBuilder.loadTexts: sprotoIbm8209Lsaps.setDescription('Specifies up to eight LSAPs for which IBM 8209-style token-ring-to-Ethernet encapsulation is to be performed. Only valid if sprotoIbmLLcTranslate is enabled. This option applies only to token ring ports.')
sprotoBootpRelay = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 17, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sprotoBootpRelay.setStatus('mandatory')
if mibBuilder.loadTexts: sprotoBootpRelay.setDescription('Specifies whether or not this port is to relay BOOTP packets, as described in RFC-951 and subsequent internet-drafts. Only valid if IP routing is also enabled for this interface.')
sprotoNetbiosTranslate = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 17, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("passRif", 1), ("stripRif", 2), ("passBoth", 3), ("none", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sprotoNetbiosTranslate.setStatus('mandatory')
if mibBuilder.loadTexts: sprotoNetbiosTranslate.setDescription('Specifies whether, when bridging Netbios packets which are source-routing explorer frames, the routing information is to be stripped or propagated. If pass- Rif(1), the frame is bridged as is, with route- discovery proceeding as expected. If stripRif(2), then the routing information field is stripped before being propagated. This option allows non-source-routing (e.g., Ethernet) Netbios hosts to communicate tran- sparently. If passBoth(3), then both the original source-routed frame and the transparent equivalent are propagated. This choice provides maximum connectivity at some expense in network traffic. None(4) is identical to passRif. This option applies only to token ring ports.')
sprotoIpMulticast = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 17, 1, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sprotoIpMulticast.setStatus('mandatory')
if mibBuilder.loadTexts: sprotoIpMulticast.setDescription('Specifies whether the internet Multicast Routing Protocol (RFC-1075) is to be used over this port. Only valid if sprotoIpRoute is enabled.')
sprotoTrunking = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 17, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sprotoTrunking.setStatus('mandatory')
if mibBuilder.loadTexts: sprotoTrunking.setDescription("Specifies whether SMC's trunking protocol (an extension to the standard Spanning Tree) is to be used over this port.")
sprotoIpxSrTranslate = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 17, 1, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("passRif", 1), ("stripRif", 2), ("passBoth", 3), ("none", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sprotoIpxSrTranslate.setStatus('mandatory')
if mibBuilder.loadTexts: sprotoIpxSrTranslate.setDescription('Specifies whether, when bridging IPX packets which are source-routing explorer frames, the routing information is to be stripped or propagated. If pass- Rif(1), the frame is bridged as is, with route- discovery proceeding as expected. If stripRif(2), then the routing information field is stripped before being propagated. This option allows non-source-routing (e.g., Ethernet) IPX hosts to communicate tran- sparently. If passBoth(3), then both the original source-routed frame and the transparent equivalent are propagated. This choice provides maximum connectivity at some expense in network traffic. None(4) is identical to passRif. This option applies only to token ring ports.')
sprotoAllTranslate = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 17, 1, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("passRif", 1), ("stripRif", 2), ("passBoth", 3), ("none", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sprotoAllTranslate.setStatus('mandatory')
if mibBuilder.loadTexts: sprotoAllTranslate.setDescription('Specifies whether, when bridging any source-routed explorer frames, the routing information is to be stripped or propagated. If passRif(1), the frame is bridged as is, with route-discovery proceeding as expected. If stripRif(2), then the routing information field is stripped before being propagated. This option allows non-source-routing (e.g., Ethernet) IPX hosts to communicate tran- sparently. If passBoth(3), then both the original source-routed frame and the transparent equivalent are propagated. This choice provides maximum connectivity at some expense in network traffic. None(4) is identical to passRif. This option applies only to token ring ports.')
sprotoSteHopCountAppliedRule = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 17, 1, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("hopcountnotapplied", 1), ("hopcountapplied", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sprotoSteHopCountAppliedRule.setStatus('mandatory')
if mibBuilder.loadTexts: sprotoSteHopCountAppliedRule.setDescription("hopcountnotapplied(1), STE hop count rules are not applied to STE frames. Default for SR ports. Follows IBM's specifications. hopcountapplied(2), STE hop count rules are applied to STE frames. Default SRT ports. Follows IEEE specifications.")
sprotoIpxDot3Framing = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 17, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ethernet8023", 1), ("ethernet2", 2), ("ethernet8022", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sprotoIpxDot3Framing.setStatus('mandatory')
if mibBuilder.loadTexts: sprotoIpxDot3Framing.setDescription('If sprotoIpxRoute or sprotoIpxTranslate is enabled, specifies the type of framing to be used for NetWare IPX packets on 802.3 networks. ethernet8023(1) speci- fies that the 802.3 header is to be used without an 802.2 header. ethernet2(2) specifies that Ethernet-2 framing is to be used, with etherType 8137. ether- net8022(3) specifies that an LLC header e0,e0,03 is to be used in conjunction with the 802.3 header.')
sipxIfTable = MibTable((1, 3, 6, 1, 4, 1, 97, 3, 18, 1), )
if mibBuilder.loadTexts: sipxIfTable.setStatus('mandatory')
if mibBuilder.loadTexts: sipxIfTable.setDescription('Describes per-interface attributes of IPX routing.')
sipxIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 97, 3, 18, 1, 1), ).setIndexNames((0, "CTATX-MIB", "sipxIfIndex"))
if mibBuilder.loadTexts: sipxIfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sipxIfEntry.setDescription('For a particular interface, defines the IPX routing information.')
sipxIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 18, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sipxIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sipxIfIndex.setDescription('Used to index through the interfaces (ports) on the ES/1, when used as an IPX router. Identical to ifIndex. Entries exist for all external interfaces, whether or not they are actually populated or configured for IPX routing.')
sipxIfNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 18, 1, 1, 2), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sipxIfNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: sipxIfNetwork.setDescription('The IPX network number associated with this interface.')
sipxIfFraming = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 18, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("ethernet8023", 1), ("ethernet2", 2), ("ieee8022", 3), ("snap", 4), ("rawfddi", 5), ("ppp", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sipxIfFraming.setStatus('mandatory')
if mibBuilder.loadTexts: sipxIfFraming.setDescription('Defines the link-level framing to be used for this interface. Options 1-4 are available for Ethernet; options 3 and 4 are valid for token ring; options 3-5 are valid for FDDI links.')
sipxIfInRipPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 18, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sipxIfInRipPkts.setStatus('mandatory')
if mibBuilder.loadTexts: sipxIfInRipPkts.setDescription('Number of IPX Routing Information Protocol packets received on this interface.')
sipxIfOutRipPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 18, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sipxIfOutRipPkts.setStatus('mandatory')
if mibBuilder.loadTexts: sipxIfOutRipPkts.setDescription('Number of IPX Routing Information Protocol packets transmitted on this interface.')
sipxIfInSapPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 18, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sipxIfInSapPkts.setStatus('mandatory')
if mibBuilder.loadTexts: sipxIfInSapPkts.setDescription('Number of IPX Service Advertising Protocol packets received on this interface.')
sipxIfOutSapPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 18, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sipxIfOutSapPkts.setStatus('mandatory')
if mibBuilder.loadTexts: sipxIfOutSapPkts.setDescription('Number of IPX Service Advertising Protocol packets transmitted on this interface.')
sipxRouteTable = MibTable((1, 3, 6, 1, 4, 1, 97, 3, 18, 2), )
if mibBuilder.loadTexts: sipxRouteTable.setStatus('mandatory')
if mibBuilder.loadTexts: sipxRouteTable.setDescription("This router's IPX Routing table.")
sipxRouteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 97, 3, 18, 2, 1), ).setIndexNames((0, "CTATX-MIB", "sipxRouteDest"))
if mibBuilder.loadTexts: sipxRouteEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sipxRouteEntry.setDescription('A route to a particular destination.')
sipxRouteDest = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 18, 2, 1, 1), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sipxRouteDest.setStatus('mandatory')
if mibBuilder.loadTexts: sipxRouteDest.setDescription('The destination network address of this route.')
sipxRouteIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 18, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sipxRouteIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sipxRouteIfIndex.setDescription('The index value which uniquely identifies the local interface through which the next hop of this route should be reached. The interface identified by a particular value of this index is the same interface as identified by the same value of ifIndex.')
sipxRouteTickCount = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 18, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sipxRouteTickCount.setStatus('mandatory')
if mibBuilder.loadTexts: sipxRouteTickCount.setDescription('The primary routing metric for this route, which is an estimate of the number of 55 millisecond ticks that are needed to reach the destination.')
sipxRouteHopCount = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 18, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sipxRouteHopCount.setStatus('mandatory')
if mibBuilder.loadTexts: sipxRouteHopCount.setDescription('The secondary routing metric for this route, which is the number of routers that must be traversed to reach the destination.')
sipxRouteNextHop = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 18, 2, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sipxRouteNextHop.setStatus('mandatory')
if mibBuilder.loadTexts: sipxRouteNextHop.setDescription('The IPX node address of the next hop of this route, if indirect. If direct, the address of the local interface.')
sipxRouteAge = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 18, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sipxRouteAge.setStatus('mandatory')
if mibBuilder.loadTexts: sipxRouteAge.setDescription('The number of seconds since this route was last updated.')
sipxSapTable = MibTable((1, 3, 6, 1, 4, 1, 97, 3, 18, 3), )
if mibBuilder.loadTexts: sipxSapTable.setStatus('mandatory')
if mibBuilder.loadTexts: sipxSapTable.setDescription("This router's IPX service advertising cache table.")
sipxSapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 97, 3, 18, 3, 1), ).setIndexNames((0, "CTATX-MIB", "sipxSapIndex"))
if mibBuilder.loadTexts: sipxSapEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sipxSapEntry.setDescription('An IPX service definition, as advertised by the SAP protocol and distributed through the SAP cache of this router.')
sipxSapIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 18, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sipxSapIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sipxSapIndex.setDescription('Used only as an artificial index to this table. Has no independent meaning.')
sipxSapType = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 18, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sipxSapType.setStatus('mandatory')
if mibBuilder.loadTexts: sipxSapType.setDescription('Identifies the type of service provided by the server. Values range 0..ffff, and are defined by Novell.')
sipxSapName = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 18, 3, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sipxSapName.setStatus('mandatory')
if mibBuilder.loadTexts: sipxSapName.setDescription('Server Name.')
sipxSapNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 18, 3, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sipxSapNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: sipxSapNetwork.setDescription('The IPX network address of the server providing the indicated service.')
sipxSapNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 18, 3, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sipxSapNodeId.setStatus('mandatory')
if mibBuilder.loadTexts: sipxSapNodeId.setDescription('The IPX node address of the server. With NetWare 2.x, this corresponds to a physical MAC address, represented here in canonical (little-endian) bit order. With NetWare 3.x, it is typically 00:00:00:00:00:01.')
sipxSapSocket = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 18, 3, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sipxSapSocket.setStatus('mandatory')
if mibBuilder.loadTexts: sipxSapSocket.setDescription('The socket number to which service requests should be addressed.')
sipxSapHopCount = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 18, 3, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sipxSapHopCount.setStatus('mandatory')
if mibBuilder.loadTexts: sipxSapHopCount.setDescription('A count of the number of routers that must be traversed to reach this server.')
sipxDiscardedRoutes = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 18, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sipxDiscardedRoutes.setStatus('mandatory')
if mibBuilder.loadTexts: sipxDiscardedRoutes.setDescription('A count of the number of received routes that were lost due to insufficient resources.')
sipxDiscardedServices = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 18, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sipxDiscardedServices.setStatus('mandatory')
if mibBuilder.loadTexts: sipxDiscardedServices.setDescription('A count of the number of received SAP services that were lost due to insufficient resources.')
sipxsfNextIndex = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 18, 6, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sipxsfNextIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sipxsfNextIndex.setDescription('Next available filter index for adding filters. Starting with 1, in sequetianl ascending order.')
sipxsfTable = MibTable((1, 3, 6, 1, 4, 1, 97, 3, 18, 6, 2), )
if mibBuilder.loadTexts: sipxsfTable.setStatus('mandatory')
if mibBuilder.loadTexts: sipxsfTable.setDescription('This table defines the filtering criteria to be applied to Netware service advertisements. There can be no more than one filter per service name. Each filter is identified by a simple integer, which is more concise than the name if it were to be used as an index.')
sipxsfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 97, 3, 18, 6, 2, 1), ).setIndexNames((0, "CTATX-MIB", "sipxsfIndex"))
if mibBuilder.loadTexts: sipxsfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sipxsfEntry.setDescription('Defines the filtering criteria to be applied to a particular service name.')
sipxsfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 18, 6, 2, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sipxsfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sipxsfIndex.setDescription('Assigned by the configurer to identify this filter. This index has no relationship to sipxSapIndex.')
sipxsfSAPName = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 18, 6, 2, 1, 2), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sipxsfSAPName.setStatus('mandatory')
if mibBuilder.loadTexts: sipxsfSAPName.setDescription("The service name. `*' can be used as wild card character which match all names.")
sipxsfSAPType = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 18, 6, 2, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sipxsfSAPType.setStatus('mandatory')
if mibBuilder.loadTexts: sipxsfSAPType.setDescription('The service type. Minus one or 65535 indicates all services of this name. Otherwise, the values are defined by Novell and other service providers (e.g., file server = 4).')
sipxsfAccessMode = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 18, 6, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("permitted", 1), ("denied", 2), ("invalid", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sipxsfAccessMode.setStatus('mandatory')
if mibBuilder.loadTexts: sipxsfAccessMode.setDescription('Permitted(1) allows the service name to be accepted or broadcasted. Denied(2) ignores the service name. Invalid(3) invalidates the filter entry.')
sipxsfFilterType = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 18, 6, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("entry", 1), ("exit", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sipxsfFilterType.setStatus('mandatory')
if mibBuilder.loadTexts: sipxsfFilterType.setDescription('If entry(1), filter is for the incoming named service. If exit(2), filter is for the outgoing named service.')
sipxsfPortMap = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 18, 6, 2, 1, 6), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sipxsfPortMap.setStatus('mandatory')
if mibBuilder.loadTexts: sipxsfPortMap.setDescription('A bit map defining port numbers to which the filter is applied. Octet 1 specifies port 1 to 8, octet 2 specifies port 9 to 16, and so on. Within each octet, the MSB maps to the lowerest port, and LSB maps to the highest port. For filters with FilterType entry(1), this parameter is ignored.')
sipxsfNetworks = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 18, 6, 2, 1, 7), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sipxsfNetworks.setStatus('mandatory')
if mibBuilder.loadTexts: sipxsfNetworks.setDescription('A list of network addresses to which the filter is applied. Each network address consists of 4 octets (i.e. a LONG word). For filter with FilterType entry(1), this parameter is ignored. Initial implementation also ignores this parameter.')
sipxsfFiltered = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 18, 6, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sipxsfFiltered.setStatus('mandatory')
if mibBuilder.loadTexts: sipxsfFiltered.setDescription('Number of times the service has been filtered.')
sipxsrAgingTime = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 18, 7, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sipxsrAgingTime.setStatus('mandatory')
if mibBuilder.loadTexts: sipxsrAgingTime.setDescription('IPX source route cache age time, in seconds.')
sipxsrExplorerTable = MibTable((1, 3, 6, 1, 4, 1, 97, 3, 18, 7, 2), )
if mibBuilder.loadTexts: sipxsrExplorerTable.setStatus('mandatory')
if mibBuilder.loadTexts: sipxsrExplorerTable.setDescription('IPX SR explorer configuration Table.')
sipxsrExplorerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 97, 3, 18, 7, 2, 1), ).setIndexNames((0, "CTATX-MIB", "sipxsrPort"))
if mibBuilder.loadTexts: sipxsrExplorerEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sipxsrExplorerEntry.setDescription('IPX SR explorer configuration for each port.')
sipxsrPort = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 18, 7, 2, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sipxsrPort.setStatus('mandatory')
if mibBuilder.loadTexts: sipxsrPort.setDescription('Port number.')
sipxsrStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 18, 7, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sipxsrStatus.setStatus('mandatory')
if mibBuilder.loadTexts: sipxsrStatus.setDescription('valid(1) to configure explorer type; invalid(2) to remove explorer configuration and default to STE.')
sipxsrExplorerType = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 18, 7, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("are", 1), ("ste", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sipxsrExplorerType.setStatus('mandatory')
if mibBuilder.loadTexts: sipxsrExplorerType.setDescription('use ARE or STE for explorer frame.')
srtrdiscTable = MibTable((1, 3, 6, 1, 4, 1, 97, 3, 19, 1), )
if mibBuilder.loadTexts: srtrdiscTable.setStatus('mandatory')
if mibBuilder.loadTexts: srtrdiscTable.setDescription('This table contains configuration information controlling operation of the router discovery protocol (RFC-1256).')
srtrdiscEntry = MibTableRow((1, 3, 6, 1, 4, 1, 97, 3, 19, 1, 1), ).setIndexNames((0, "CTATX-MIB", "srtrdiscIfIndex"))
if mibBuilder.loadTexts: srtrdiscEntry.setStatus('mandatory')
if mibBuilder.loadTexts: srtrdiscEntry.setDescription('Each entry in this table configures the router discovery protocol for the particular interface.')
srtrdiscIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 19, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srtrdiscIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: srtrdiscIfIndex.setDescription("Identifies the interface (port) to which this entry's information belongs. The value of this variable corresponds to ifIndex, as well as most of the other port identification values in related MIBs.")
srtrdiscState = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 19, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: srtrdiscState.setStatus('mandatory')
if mibBuilder.loadTexts: srtrdiscState.setDescription('Specifies whether or not the router discovery protocol is in use for this interface. Defaults to disabled(2).')
srtrdiscAdvertisementAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 19, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("multicast", 1), ("broadcast", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: srtrdiscAdvertisementAddress.setStatus('mandatory')
if mibBuilder.loadTexts: srtrdiscAdvertisementAddress.setDescription('The IP address to be used for multicast router advertisements for this interface. If multicast(1), the all-systems multicast 224.0.0.1 is used. If broadcast, the limited-broadcast 255.255.255.255 is used.')
srtrdiscAdvertisementInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 19, 1, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: srtrdiscAdvertisementInterval.setStatus('mandatory')
if mibBuilder.loadTexts: srtrdiscAdvertisementInterval.setDescription('The interval at which multicast router advertisements are to be transmitted, in seconds. Allowable values range between 4 and 1800.')
srtrdiscLifetime = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 19, 1, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: srtrdiscLifetime.setStatus('mandatory')
if mibBuilder.loadTexts: srtrdiscLifetime.setDescription('The value to be used for the Lifetime field of router advertisements. Values range from srtrdiscAdvertisementInterval to 9000.')
srtrdiscPreference = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 19, 1, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: srtrdiscPreference.setStatus('mandatory')
if mibBuilder.loadTexts: srtrdiscPreference.setDescription("The preferability of this interface's address as a default router, relative to other routers on the same subnet.")
sipmRouteTable = MibTable((1, 3, 6, 1, 4, 1, 97, 3, 20, 1, 1), )
if mibBuilder.loadTexts: sipmRouteTable.setStatus('mandatory')
if mibBuilder.loadTexts: sipmRouteTable.setDescription('The (conceptual) table listing the origin routes that this router learns from neighboring routers and from initial installations of directly-connected routes. Origin is defined to be the subnetwork that can originate multicast packets.')
sipmRouteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 97, 3, 20, 1, 1, 1), ).setIndexNames((0, "CTATX-MIB", "sipmRouteOrigin"), (0, "CTATX-MIB", "sipmRouteOriginMask"))
if mibBuilder.loadTexts: sipmRouteEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sipmRouteEntry.setDescription('An entry (conceptual row) representing information on an origin route when IPM is enabled.')
sipmRouteOrigin = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 20, 1, 1, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sipmRouteOrigin.setStatus('mandatory')
if mibBuilder.loadTexts: sipmRouteOrigin.setDescription('The subnetwork address of the origin.')
sipmRouteOriginMask = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 20, 1, 1, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sipmRouteOriginMask.setStatus('mandatory')
if mibBuilder.loadTexts: sipmRouteOriginMask.setDescription('The subnetwork mask of the origin.')
sipmRouteGateway = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 20, 1, 1, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sipmRouteGateway.setStatus('mandatory')
if mibBuilder.loadTexts: sipmRouteGateway.setDescription('The next hop gateway toward the origin. This object has the value 0.0.0.0 for directly-connected routes.')
sipmRouteMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 20, 1, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sipmRouteMetric.setStatus('mandatory')
if mibBuilder.loadTexts: sipmRouteMetric.setDescription('The distance to this origin in number of hops.')
sipmRouteAge = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 20, 1, 1, 1, 5), TimeTicks()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sipmRouteAge.setStatus('mandatory')
if mibBuilder.loadTexts: sipmRouteAge.setDescription('The time left for this origin route before aged out.')
sipmRouteParents = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 20, 1, 1, 1, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sipmRouteParents.setStatus('mandatory')
if mibBuilder.loadTexts: sipmRouteParents.setDescription('The bitmapped incoming port(s) for which this origin is learned. This is an octet string of length 8. The least significant bit of the eighth octet is port 0. The least significant bit of the seventh octet is port 9 and so on up to a maximum of 64 ports.')
sipmNeighborTable = MibTable((1, 3, 6, 1, 4, 1, 97, 3, 20, 3, 1), )
if mibBuilder.loadTexts: sipmNeighborTable.setStatus('mandatory')
if mibBuilder.loadTexts: sipmNeighborTable.setDescription('The (conceptual) table listing the neighboring routers on each interface port.')
sipmNeighborEntry = MibTableRow((1, 3, 6, 1, 4, 1, 97, 3, 20, 3, 1, 1), ).setIndexNames((0, "CTATX-MIB", "sipmNeighborIfIndex"), (0, "CTATX-MIB", "sipmNeighbors"))
if mibBuilder.loadTexts: sipmNeighborEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sipmNeighborEntry.setDescription('An entry (conceptual row) all neighbors which are learned from this local interface port.')
sipmNeighborIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 20, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sipmNeighborIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sipmNeighborIfIndex.setDescription('The ifIndex value of the interface for which this entry contains information.')
sipmNeighbors = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 20, 3, 1, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sipmNeighbors.setStatus('mandatory')
if mibBuilder.loadTexts: sipmNeighbors.setDescription("The neighbor's IP address which was learned.")
sipmNeighborLastHeard = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 20, 3, 1, 1, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sipmNeighborLastHeard.setStatus('mandatory')
if mibBuilder.loadTexts: sipmNeighborLastHeard.setDescription('The elapsed time since the neighbor was last heard.')
sipmOutOfMemory = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 20, 4, 1), Counter32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sipmOutOfMemory.setStatus('mandatory')
if mibBuilder.loadTexts: sipmOutOfMemory.setDescription('The number of times IP Multicast routines try to allocate memory for routes which failed.')
sipmStatTable = MibTable((1, 3, 6, 1, 4, 1, 97, 3, 20, 4, 2), )
if mibBuilder.loadTexts: sipmStatTable.setStatus('mandatory')
if mibBuilder.loadTexts: sipmStatTable.setDescription('The (conceptual) table containing multicast routing statistics for IP datagrams on a per port basis.')
sipmStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 97, 3, 20, 4, 2, 1), ).setIndexNames((0, "CTATX-MIB", "sipmStatIfIndex"))
if mibBuilder.loadTexts: sipmStatEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sipmStatEntry.setDescription('An entry (conceptual row) containing the multicast routing statistic for IP datagrams on a particular port.')
sipmStatIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 20, 4, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sipmStatIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sipmStatIfIndex.setDescription('The interface port number on which corresponding IPM statistics gather.')
sipmInBadPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 20, 4, 2, 1, 2), Counter32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sipmInBadPackets.setStatus('mandatory')
if mibBuilder.loadTexts: sipmInBadPackets.setDescription('The number of bad packets received which may include unknown DVMRP/IGMP messages, short packets, and checksum errors.')
sipmCacheMiss = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 20, 4, 2, 1, 3), Counter32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sipmCacheMiss.setStatus('mandatory')
if mibBuilder.loadTexts: sipmCacheMiss.setDescription('The number of times IP Multicast packets need to lookup a route at the IP layer for determining forwarding path.')
sipcktTable = MibTable((1, 3, 6, 1, 4, 1, 97, 3, 21, 1), )
if mibBuilder.loadTexts: sipcktTable.setStatus('mandatory')
if mibBuilder.loadTexts: sipcktTable.setDescription('Defines attributes of IP circuits. A circuit is defined as a binding of a network number to a physical interface.')
sipcktEntry = MibTableRow((1, 3, 6, 1, 4, 1, 97, 3, 21, 1, 1), ).setIndexNames((0, "CTATX-MIB", "sipcktIndex"), (0, "CTATX-MIB", "sipcktIpAddress"))
if mibBuilder.loadTexts: sipcktEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sipcktEntry.setDescription('Defines the attributes of a binding of IP address and network to physical interface.')
sipcktIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 21, 1, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sipcktIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sipcktIndex.setDescription('Identifies the physical interface. Identical to ifIndex.')
sipcktIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 21, 1, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sipcktIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: sipcktIpAddress.setDescription('Identifies the IP network that is bound to this interface.')
sipcktState = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 21, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2), ("invalid-all", 3), ("netmask-conflict", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sipcktState.setStatus('mandatory')
if mibBuilder.loadTexts: sipcktState.setDescription('The status of this binding.')
sipcktNetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 21, 1, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sipcktNetMask.setStatus('mandatory')
if mibBuilder.loadTexts: sipcktNetMask.setDescription('The subnet mask for the network associated with this address binding. If set to 0.0.0.0, will default to standard class A/B/C mask, depending on the value of sipcktIpAddress.')
sipcktSourceRoute = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 21, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("default", 1), ("sr", 2), ("no-sr", 3), ("both", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sipcktSourceRoute.setStatus('mandatory')
if mibBuilder.loadTexts: sipcktSourceRoute.setDescription('Specifies the behavior of IP routing with respect to (link-layer) source routing for this circuit. If default(1) then behavior depends on whether the port is token ring or not. If token ring then ARP requests are sent both as source-routing explorers and as local frames; if not token ring then only local frames are sent. If sr(2) then ARP requests are sent as source-routing explorers only. If no-sr(3) then ARP requests are sent as local frames only. If both(4), ARP requests are sent both as source-routing explorers and as local frames. Default(1) should be adequate for most uses unless either source routing is being used on FDDI, or the ARP traffic is excessive on token ring.')
sipNetToMediaTable = MibTable((1, 3, 6, 1, 4, 1, 97, 3, 22), )
if mibBuilder.loadTexts: sipNetToMediaTable.setStatus('mandatory')
if mibBuilder.loadTexts: sipNetToMediaTable.setDescription('An extension to the standard ipNetToMedia table, containing other ARP cache attributes, specifically the current source route to the destination.')
sipNetToMediaEntry = MibTableRow((1, 3, 6, 1, 4, 1, 97, 3, 22, 1), ).setIndexNames((0, "CTATX-MIB", "sipNetToMediaIfIndex"), (0, "CTATX-MIB", "sipNetToMediaNetAddress"))
if mibBuilder.loadTexts: sipNetToMediaEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sipNetToMediaEntry.setDescription("Each entry contains one IpAddress to `physical' address equivalence. Entries in this table exist even when there is no source route attached.")
sipNetToMediaIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 22, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sipNetToMediaIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sipNetToMediaIfIndex.setDescription("The interface on which this entry's equivalence is effective. The interface identified by a particular value of this index is the same interface as identified by the same value of ifIndex.")
sipNetToMediaNetAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 22, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sipNetToMediaNetAddress.setStatus('mandatory')
if mibBuilder.loadTexts: sipNetToMediaNetAddress.setDescription("The IpAddress corresponding to the media- dependent `physical' address.")
sipNetToMediaSourceRoute = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 22, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sipNetToMediaSourceRoute.setStatus('mandatory')
if mibBuilder.loadTexts: sipNetToMediaSourceRoute.setDescription('The source route to this destination.')
sipNetToMediaAge = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 22, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sipNetToMediaAge.setStatus('mandatory')
if mibBuilder.loadTexts: sipNetToMediaAge.setDescription('The age, in seconds, of the entry to this destination.')
profileTable = MibTable((1, 3, 6, 1, 4, 1, 97, 3, 23, 1), )
if mibBuilder.loadTexts: profileTable.setStatus('mandatory')
if mibBuilder.loadTexts: profileTable.setDescription('')
profileEntry = MibTableRow((1, 3, 6, 1, 4, 1, 97, 3, 23, 1, 1), ).setIndexNames((0, "CTATX-MIB", "profileIndex"), (0, "CTATX-MIB", "profileSourceStart"), (0, "CTATX-MIB", "profileSourceEnd"), (0, "CTATX-MIB", "profileDestStart"), (0, "CTATX-MIB", "profileDestEnd"))
if mibBuilder.loadTexts: profileEntry.setStatus('mandatory')
if mibBuilder.loadTexts: profileEntry.setDescription('There may be up to 16,368 entries. A profile consists of up to 16 entries, all with the same value for profileIndex. and there may be no more than 1,023 profiles. Entries are added by setting the profileType field to valid(1) - the variables with no defval clause will be automatically assigned a value based on the key. Entries are removed by setting the profileType field to invalid(2). Entries may not be modified other than by being added or removed completely.')
profileIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 23, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: profileIndex.setStatus('mandatory')
if mibBuilder.loadTexts: profileIndex.setDescription('A value from 1 to 1,023. All entries with the same profileIndex are part of the same profile.')
profileSourceStart = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 23, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: profileSourceStart.setStatus('mandatory')
if mibBuilder.loadTexts: profileSourceStart.setDescription('Acceptable lowest value for the source port of a UDP or TCP packet.')
profileSourceEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 23, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: profileSourceEnd.setStatus('mandatory')
if mibBuilder.loadTexts: profileSourceEnd.setDescription('Acceptable highest value for the source port of a UDP or TCP packet.')
profileDestStart = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 23, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: profileDestStart.setStatus('mandatory')
if mibBuilder.loadTexts: profileDestStart.setDescription('Acceptable lowest value for the destination port of a UDP or TCP packet.')
profileDestEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 23, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: profileDestEnd.setStatus('mandatory')
if mibBuilder.loadTexts: profileDestEnd.setDescription('Acceptable highest value for the destination port of a UDP or TCP packet.')
profileType = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 23, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: profileType.setStatus('mandatory')
if mibBuilder.loadTexts: profileType.setDescription('')
ruleTable = MibTable((1, 3, 6, 1, 4, 1, 97, 3, 23, 2), )
if mibBuilder.loadTexts: ruleTable.setStatus('mandatory')
if mibBuilder.loadTexts: ruleTable.setDescription('')
ruleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 97, 3, 23, 2, 1), ).setIndexNames((0, "CTATX-MIB", "ruleIndex"), (0, "CTATX-MIB", "ruleSourceIp"), (0, "CTATX-MIB", "ruleDestIp"), (0, "CTATX-MIB", "ruleSourceIpMask"), (0, "CTATX-MIB", "ruleDestIpMask"))
if mibBuilder.loadTexts: ruleEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ruleEntry.setDescription('There may be up to 8,000 entries. Rules with 255.255.255.255 for both masks are accessed quickly; other rules are accessed less quickly. When adding a rule, at least one field must be specified, since there are defval clauses for most of the other fields (the fields without defval clauses will be obtained from the key itself).')
ruleIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 23, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ruleIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ruleIndex.setDescription('An ES/1 port number.')
ruleSourceIp = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 23, 2, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ruleSourceIp.setStatus('mandatory')
if mibBuilder.loadTexts: ruleSourceIp.setDescription('Source IP address.')
ruleDestIp = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 23, 2, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ruleDestIp.setStatus('mandatory')
if mibBuilder.loadTexts: ruleDestIp.setDescription('Destination IP address.')
ruleSourceIpMask = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 23, 2, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ruleSourceIpMask.setStatus('mandatory')
if mibBuilder.loadTexts: ruleSourceIpMask.setDescription('Mask to apply to the packet before comparing to ruleSourceIp.')
ruleDestIpMask = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 23, 2, 1, 5), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ruleDestIpMask.setStatus('mandatory')
if mibBuilder.loadTexts: ruleDestIpMask.setDescription('Mask to apply to the packet before comparing to ruleSourceIp.')
ruleType = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 23, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ruleType.setStatus('mandatory')
if mibBuilder.loadTexts: ruleType.setDescription('')
ruleUdpProfile = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 23, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1023))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ruleUdpProfile.setStatus('mandatory')
if mibBuilder.loadTexts: ruleUdpProfile.setDescription('Which profile to use (i.e., the value of profileIndex) for UDP packets. A value of 0 means no profile, i.e., filter all packets. This rule only applies to packets with a fragment offset of zero.')
ruleTcpProfile = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 23, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1023))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ruleTcpProfile.setStatus('mandatory')
if mibBuilder.loadTexts: ruleTcpProfile.setDescription('Which profile to use (i.e., the value of profileIndex) for TCP packets for non-established sessions. A non-established session is indicated by neither the ACK nor RST bit being set in the TCP packet. A value of 0 means no profile, i.e., filter all packets. This rule only applies to packets with a fragment offset of zero.')
ruleTcpEstProfile = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 23, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1023))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ruleTcpEstProfile.setStatus('mandatory')
if mibBuilder.loadTexts: ruleTcpEstProfile.setDescription('Which profile to use (i.e., the value of profileIndex) for TCP packets for established sessions. An established session is indicated by the ACK or RST bit being set in the TCP packet. A value of 0 means no profile, i.e., filter all packets. This rule only applies to packets with a fragment offset of zero.')
ruleFilterUdpFragment = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 23, 2, 1, 10), Boolean()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ruleFilterUdpFragment.setStatus('mandatory')
if mibBuilder.loadTexts: ruleFilterUdpFragment.setDescription('Whether to filter UDP packets with a non-zero IP fragment offset.')
ruleFilterTcpFragment = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 23, 2, 1, 11), Boolean()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ruleFilterTcpFragment.setStatus('mandatory')
if mibBuilder.loadTexts: ruleFilterTcpFragment.setDescription('Whether to filter TCP packets with a non-zero IP fragment offset.')
ruleFilterIpOption = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 23, 2, 1, 12), Boolean()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ruleFilterIpOption.setStatus('mandatory')
if mibBuilder.loadTexts: ruleFilterIpOption.setDescription('Whether to filter packets with an IP header length of other than 5.')
ruleAllowIcmp = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 23, 2, 1, 13), Boolean()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ruleAllowIcmp.setStatus('mandatory')
if mibBuilder.loadTexts: ruleAllowIcmp.setDescription('Whether to forward ICMP packets (IP protocol 1).')
ruleAllowIpWithinIp = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 23, 2, 1, 14), Boolean()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ruleAllowIpWithinIp.setStatus('mandatory')
if mibBuilder.loadTexts: ruleAllowIpWithinIp.setDescription('Whether to forward IP encapsulated within IP packets (IP protocol 4).')
ruleAllowEgp = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 23, 2, 1, 15), Boolean()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ruleAllowEgp.setStatus('mandatory')
if mibBuilder.loadTexts: ruleAllowEgp.setDescription('Whether to forward EGP packets (IP protocol 8).')
ruleAllowIgp = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 23, 2, 1, 16), Boolean()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ruleAllowIgp.setStatus('mandatory')
if mibBuilder.loadTexts: ruleAllowIgp.setDescription('Whether to forward IGP packets (IP protocol 9).')
ruleAllowIgrp = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 23, 2, 1, 17), Boolean()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ruleAllowIgrp.setStatus('mandatory')
if mibBuilder.loadTexts: ruleAllowIgrp.setDescription('Whether to forward IGP packets (IP protocol 88).')
ruleAllowOspf = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 23, 2, 1, 18), Boolean()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ruleAllowOspf.setStatus('mandatory')
if mibBuilder.loadTexts: ruleAllowOspf.setDescription('Whether to forward OSPF packets (IP protocol 89).')
ruleAllowAnyOther = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 23, 2, 1, 19), Boolean()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ruleAllowAnyOther.setStatus('mandatory')
if mibBuilder.loadTexts: ruleAllowAnyOther.setDescription('Whether to forward all other types of IP packets (i.e., other than UDP, TCP, ICMP, IP encapsulated, EGP, IGP, IGRP, and OSPF).')
spvcTable = MibTable((1, 3, 6, 1, 4, 1, 97, 3, 24, 1), )
if mibBuilder.loadTexts: spvcTable.setStatus('mandatory')
if mibBuilder.loadTexts: spvcTable.setDescription('This table maps pseudo-port indices to permanent virtual circuits.')
spvcEntry = MibTableRow((1, 3, 6, 1, 4, 1, 97, 3, 24, 1, 1), ).setIndexNames((0, "CTATX-MIB", "spvcIfIndex"))
if mibBuilder.loadTexts: spvcEntry.setStatus('mandatory')
if mibBuilder.loadTexts: spvcEntry.setDescription('Each entry in this table describes one permanent virtual circuit.')
spvcIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 24, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: spvcIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: spvcIfIndex.setDescription('Identifies the virtual interface (port) on which this virtual circuit exists. The value of this variable corresponds to ifIndex, as well as most of the other port identification values in related MIBs.')
spvcPathRX = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 24, 1, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: spvcPathRX.setStatus('mandatory')
if mibBuilder.loadTexts: spvcPathRX.setDescription('Where virtual circuit identifiers are split into two parts, as in ATM, this is the most-significant part, and is identical to the ATM virtual path identifier.')
spvcCircuitRX = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 24, 1, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: spvcCircuitRX.setStatus('mandatory')
if mibBuilder.loadTexts: spvcCircuitRX.setDescription('Where virtual circuit identifiers are split into two parts, as in ATM, this is the least-significant part, and is identical to the ATM virtual circuit identifier.')
spvcPathTX = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 24, 1, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: spvcPathTX.setStatus('mandatory')
if mibBuilder.loadTexts: spvcPathTX.setDescription('Where virtual circuit identifiers are split into two parts, as in ATM, this is the most-significant part, and is identical to the ATM virtual path identifier.')
spvcCircuitTX = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 24, 1, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: spvcCircuitTX.setStatus('mandatory')
if mibBuilder.loadTexts: spvcCircuitTX.setDescription('Where virtual circuit identifiers are split into two parts, as in ATM, this is the least-significant part, and is identical to the ATM virtual circuit identifier.')
spvcState = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 24, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("exists", 1), ("removed", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: spvcState.setStatus('mandatory')
if mibBuilder.loadTexts: spvcState.setDescription('Controls the existence of this table entry.')
spvcPhysPort = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 24, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: spvcPhysPort.setStatus('mandatory')
if mibBuilder.loadTexts: spvcPhysPort.setDescription('Identifies the physical interface (port) on which this virtual circuit exists. The value of this variable corresponds to ifIndex, as well as most of the other port identification values in related MIBs.')
spvcMinPort = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 24, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: spvcMinPort.setStatus('mandatory')
if mibBuilder.loadTexts: spvcMinPort.setDescription('The lowest-numbered PVC pseudo-port number.')
spvcMaxPort = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 24, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: spvcMaxPort.setStatus('mandatory')
if mibBuilder.loadTexts: spvcMaxPort.setDescription('The highest-numbered PVC pseudo-port number.')
strunkTable = MibTable((1, 3, 6, 1, 4, 1, 97, 3, 25, 1), )
if mibBuilder.loadTexts: strunkTable.setStatus('mandatory')
if mibBuilder.loadTexts: strunkTable.setDescription('This table describes the trunking status and attributes of the interfaces that are configured for bridge trunking.')
strunkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 97, 3, 25, 1, 1), ).setIndexNames((0, "CTATX-MIB", "strunkIfIndex"))
if mibBuilder.loadTexts: strunkEntry.setStatus('mandatory')
if mibBuilder.loadTexts: strunkEntry.setDescription('An entry exists in this table for each physical interface (port) that is configured for trunking.')
strunkIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 25, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: strunkIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: strunkIfIndex.setDescription('Identifies a physical interface (port) which is configured for LAN trunking. The value of this variable corresponds to ifIndex, as well as most of the other port identification values in related MIBs.')
strunkState = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 25, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("off", 1), ("closed", 2), ("oneway", 3), ("joined", 4), ("perturbed", 5), ("helddown", 6), ("broken", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: strunkState.setStatus('mandatory')
if mibBuilder.loadTexts: strunkState.setDescription('If off(1) then this link has not been enabled for trunking. If closed(2) then this link has not yet received any Trunking PDUs. If oneway(3) then incoming Trunking PDUs do not indicate that our PDUs are being successfully received by the far end. If joined(4) then this link is actively participating in the trunk group. If perturbed(5) then this link is actively participating in the trunk group; however, the transmission of data packets has been temporarily stopped due to a change in membership of the group. If helddown(6) then an error has been detected and the link is being held out-of-service until the error clears. If broken(7) then this link has been configured for trunking, but the port is physically non-operational.')
strunkRemoteBridgeAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 25, 1, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: strunkRemoteBridgeAddr.setStatus('mandatory')
if mibBuilder.loadTexts: strunkRemoteBridgeAddr.setDescription('The MAC address portion of the bridge ID of the remote bridge.')
strunkRemoteIp = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 25, 1, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: strunkRemoteIp.setStatus('mandatory')
if mibBuilder.loadTexts: strunkRemoteIp.setDescription('The IP address of the remote bridge, as reported by that bridge for administrative purposes.')
strunkLastError = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 25, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))).clone(namedValues=NamedValues(("none", 1), ("in-bpdu", 2), ("multiple-bridges", 3), ("ack-lost", 4), ("standby", 5), ("too-many-groups", 6), ("no-ack", 7), ("perturbed-threshold", 8), ("self-connect", 9), ("port-moved", 10), ("multiple-lan-types", 11)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: strunkLastError.setStatus('mandatory')
if mibBuilder.loadTexts: strunkLastError.setDescription('The last reason for failure when the link is in closed, oneway, or helddown state.')
strunkLinkOrdinal = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 25, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: strunkLinkOrdinal.setStatus('mandatory')
if mibBuilder.loadTexts: strunkLinkOrdinal.setDescription('The position of this link within the trunk group.')
strunkLinkCount = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 25, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: strunkLinkCount.setStatus('mandatory')
if mibBuilder.loadTexts: strunkLinkCount.setDescription('The number of links within the trunk group.')
strunkLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 25, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: strunkLastChange.setStatus('mandatory')
if mibBuilder.loadTexts: strunkLastChange.setDescription('The number of seconds since strunkState changed.')
atextsysOperState = MibScalar((1, 3, 6, 1, 4, 1, 97, 6, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atextsysOperState.setStatus('mandatory')
if mibBuilder.loadTexts: atextsysOperState.setDescription('The operational state of AppleTalk routing.')
atextportTable = MibTable((1, 3, 6, 1, 4, 1, 97, 6, 2, 1), )
if mibBuilder.loadTexts: atextportTable.setStatus('mandatory')
if mibBuilder.loadTexts: atextportTable.setDescription('A list of AppleTalk ports for this entity.')
atextportEntry = MibTableRow((1, 3, 6, 1, 4, 1, 97, 6, 2, 1, 1), ).setIndexNames((0, "CTATX-MIB", "atextportIndex"))
if mibBuilder.loadTexts: atextportEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atextportEntry.setDescription('The description of one of the AppleTalk ports on this entity.')
atextportIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 6, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atextportIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atextportIndex.setDescription("A unique value for each AppleTalk port. Its value is between 1 and the total number of AppleTalk ports. The value for each port must remain constant at least from the re-initialization of the entity's network management system to the next re-initialization.")
atextportNetStart = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 6, 2, 1, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atextportNetStart.setStatus('mandatory')
if mibBuilder.loadTexts: atextportNetStart.setDescription('The first AppleTalk network address in the configured range for this port. This is a two octet DDP network address in network byte order.')
atextportNetEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 6, 2, 1, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atextportNetEnd.setStatus('mandatory')
if mibBuilder.loadTexts: atextportNetEnd.setDescription('The last AppleTalk network address in the configured range for this port. This is a two octet DDP network address in network byte order. ')
atextportNetAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 6, 2, 1, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atextportNetAddress.setStatus('mandatory')
if mibBuilder.loadTexts: atextportNetAddress.setDescription('The AppleTalk network address configured for this port.')
atextportZone = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 6, 2, 1, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atextportZone.setStatus('mandatory')
if mibBuilder.loadTexts: atextportZone.setDescription('The default zone name configured for this AppleTalk port.')
atextportzipTable = MibTable((1, 3, 6, 1, 4, 1, 97, 6, 2, 2), )
if mibBuilder.loadTexts: atextportzipTable.setStatus('mandatory')
if mibBuilder.loadTexts: atextportzipTable.setDescription('The table of zone information configured for a port.')
atextportzipEntry = MibTableRow((1, 3, 6, 1, 4, 1, 97, 6, 2, 2, 1), ).setIndexNames((0, "CTATX-MIB", "atextportZonePort"), (0, "CTATX-MIB", "atextportZoneIndex"))
if mibBuilder.loadTexts: atextportzipEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atextportzipEntry.setDescription('An entry of zone information for a particular zone and port combination.')
atextportZonePort = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 6, 2, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atextportZonePort.setStatus('mandatory')
if mibBuilder.loadTexts: atextportZonePort.setDescription('A unique value for each AppleTalk port.')
atextportZoneIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 6, 2, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atextportZoneIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atextportZoneIndex.setDescription('An integer that is unique to the ZoneName that is present in this entry. For any given zone name, every Entry that has an equal zone name will have the same ZoneIndex.')
atextportZoneName = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 6, 2, 2, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atextportZoneName.setStatus('mandatory')
if mibBuilder.loadTexts: atextportZoneName.setDescription('The ASCII zone name of this entry.')
slogFilter = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 28, 1), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: slogFilter.setStatus('mandatory')
if mibBuilder.loadTexts: slogFilter.setDescription('The current event logging filter, represented as a bitmask.')
slogTrap = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 28, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: slogTrap.setStatus('mandatory')
if mibBuilder.loadTexts: slogTrap.setDescription('When enabled, logging entries will cause SNMP traps to be generated.')
slogOverwrite = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 28, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: slogOverwrite.setStatus('mandatory')
if mibBuilder.loadTexts: slogOverwrite.setDescription('When enabled, logging entries will be overwritten in the logging queue. When disabled, the entries in the logging queue will not be overwritten until someone reads them.')
slogEntryNumber = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 28, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slogEntryNumber.setStatus('mandatory')
if mibBuilder.loadTexts: slogEntryNumber.setDescription('The number of entries in the logging entry table.')
slogEntryTable = MibTable((1, 3, 6, 1, 4, 1, 97, 3, 28, 5), )
if mibBuilder.loadTexts: slogEntryTable.setStatus('mandatory')
if mibBuilder.loadTexts: slogEntryTable.setDescription('This table contains the event logging entries.')
slogEntry = MibTableRow((1, 3, 6, 1, 4, 1, 97, 3, 28, 5, 1), ).setIndexNames((0, "CTATX-MIB", "slogIndex"))
if mibBuilder.loadTexts: slogEntry.setStatus('mandatory')
if mibBuilder.loadTexts: slogEntry.setDescription('')
slogIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 28, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slogIndex.setStatus('mandatory')
if mibBuilder.loadTexts: slogIndex.setDescription('The index of the logging entry in the logging entry table.')
slogEntryTimeStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 28, 5, 1, 2), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slogEntryTimeStamp.setStatus('mandatory')
if mibBuilder.loadTexts: slogEntryTimeStamp.setDescription('The time at which the event logging entry was generated.')
slogEntryMessageText = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 28, 5, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slogEntryMessageText.setStatus('mandatory')
if mibBuilder.loadTexts: slogEntryMessageText.setDescription('The text of the eventlogging entry message.')
slogEntryName = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 28, 5, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slogEntryName.setStatus('mandatory')
if mibBuilder.loadTexts: slogEntryName.setDescription('The name of the event logging entry.')
strapControlTable = MibTable((1, 3, 6, 1, 4, 1, 97, 3, 29, 1), )
if mibBuilder.loadTexts: strapControlTable.setStatus('mandatory')
if mibBuilder.loadTexts: strapControlTable.setDescription('This table contains information about the severity of each trap and whether the trap is currently enabled.')
strapControl = MibTableRow((1, 3, 6, 1, 4, 1, 97, 3, 29, 1, 1), ).setIndexNames((0, "CTATX-MIB", "strapIndex"))
if mibBuilder.loadTexts: strapControl.setStatus('mandatory')
if mibBuilder.loadTexts: strapControl.setDescription('')
strapIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 29, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: strapIndex.setStatus('mandatory')
if mibBuilder.loadTexts: strapIndex.setDescription('The specific trap number.')
strapEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 29, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: strapEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: strapEnabled.setDescription('Enable or disable the generation of this trap.')
strapSeverity = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 29, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("informational", 1), ("warning", 2), ("minor", 3), ("major", 4), ("critical", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: strapSeverity.setStatus('mandatory')
if mibBuilder.loadTexts: strapSeverity.setDescription('A user-definable severity, indicating the importance of the trap.')
strapText = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 29, 1, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: strapText.setStatus('mandatory')
if mibBuilder.loadTexts: strapText.setDescription('A description of the trap.')
strapSeverityControlTable = MibTable((1, 3, 6, 1, 4, 1, 97, 3, 29, 2), )
if mibBuilder.loadTexts: strapSeverityControlTable.setStatus('mandatory')
if mibBuilder.loadTexts: strapSeverityControlTable.setDescription('This table contains information about the whether a class of traps of a particular severity are enabled or disabled.')
strapSeverityControl = MibTableRow((1, 3, 6, 1, 4, 1, 97, 3, 29, 2, 1), ).setIndexNames((0, "CTATX-MIB", "strapSeveritySeverity"))
if mibBuilder.loadTexts: strapSeverityControl.setStatus('mandatory')
if mibBuilder.loadTexts: strapSeverityControl.setDescription('')
strapSeveritySeverity = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 29, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("informational", 1), ("warning", 2), ("minor", 3), ("major", 4), ("critical", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: strapSeveritySeverity.setStatus('mandatory')
if mibBuilder.loadTexts: strapSeveritySeverity.setDescription('A user-definable severity, indicating the importance of the trap.')
strapSeverityEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 29, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: strapSeverityEnable.setStatus('mandatory')
if mibBuilder.loadTexts: strapSeverityEnable.setDescription('Enable or disable all traps of a given severity level.')
strapIncludeText = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 29, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: strapIncludeText.setStatus('mandatory')
if mibBuilder.loadTexts: strapIncludeText.setDescription('Whether or not a formatted text string is included in the trap PDU.')
strapTime = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 29, 4), TimeTicks()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: strapTime.setStatus('mandatory')
if mibBuilder.loadTexts: strapTime.setDescription('(This MIB variable replaces sysTrapTime). The time, in centiseconds, which should expire between the sending of traps.')
strapRetry = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 29, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: strapRetry.setStatus('mandatory')
if mibBuilder.loadTexts: strapRetry.setDescription('The number of times any enterprise-specific trap is to be sent for a given event. PDUs are retried using a truncated exponential backoff: 2 seconds, 4 seconds, 8 seconds, 16 seconds, and then 32 seconds for all succeeding intervals.')
strapEntryNumber = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 29, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: strapEntryNumber.setStatus('mandatory')
if mibBuilder.loadTexts: strapEntryNumber.setDescription('The number of traps that are in the strapTable.')
strapTable = MibTable((1, 3, 6, 1, 4, 1, 97, 3, 29, 7), )
if mibBuilder.loadTexts: strapTable.setStatus('mandatory')
if mibBuilder.loadTexts: strapTable.setDescription('This table contains the latest traps that have been generated.')
strapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 97, 3, 29, 7, 1), ).setIndexNames((0, "CTATX-MIB", "strapEntryIndex"))
if mibBuilder.loadTexts: strapEntry.setStatus('mandatory')
if mibBuilder.loadTexts: strapEntry.setDescription('')
strapEntryIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 29, 7, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: strapEntryIndex.setStatus('mandatory')
if mibBuilder.loadTexts: strapEntryIndex.setDescription('A number representing the order in which the trap occurred in time. This 32 bit number can wrap.')
strapEntryTimeStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 29, 7, 1, 2), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: strapEntryTimeStamp.setStatus('mandatory')
if mibBuilder.loadTexts: strapEntryTimeStamp.setDescription('The time at which the trap occurred.')
strapEntryText = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 29, 7, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: strapEntryText.setStatus('mandatory')
if mibBuilder.loadTexts: strapEntryText.setDescription('A description of the trap.')
strapNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 29, 7, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: strapNumber.setStatus('mandatory')
if mibBuilder.loadTexts: strapNumber.setDescription('The specific-trap number, as specified in the TRAP PDU.')
strapEntrySeverity = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 29, 7, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("informational", 1), ("warning", 2), ("minor", 3), ("major", 4), ("critical", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: strapEntrySeverity.setStatus('mandatory')
if mibBuilder.loadTexts: strapEntrySeverity.setDescription('A user-definable severity, indicating the importance of the trap.')
smirrorStatus = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 30, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("invalid", 1), ("local", 2), ("remote", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: smirrorStatus.setStatus('mandatory')
if mibBuilder.loadTexts: smirrorStatus.setDescription('invalid(1) to turn off port mirroring. local(2) to mirror either to a local port or to a remote ATX. remote(3) to mirror traffics from a remote ATX to a local port.')
smirrorDiagPort = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 30, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: smirrorDiagPort.setStatus('mandatory')
if mibBuilder.loadTexts: smirrorDiagPort.setDescription('This entry defines the diagnostic port to output mirrored packets. It can be one of the Ethernet, Token Ring or FDDI interfaces in the ATX.')
smirrorIPaddr = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 30, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: smirrorIPaddr.setStatus('mandatory')
if mibBuilder.loadTexts: smirrorIPaddr.setDescription('This entry defines the IP address for remote mirroring. It must be a valid host address.')
smirrorTargetPortLists = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 30, 4), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: smirrorTargetPortLists.setStatus('mandatory')
if mibBuilder.loadTexts: smirrorTargetPortLists.setDescription('An octet string specifies the list of ports to be mirrored, with each octet representing a single port number.')
smirrorOversizePkt = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 30, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("discard", 1), ("truncate", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: smirrorOversizePkt.setStatus('mandatory')
if mibBuilder.loadTexts: smirrorOversizePkt.setDescription('Specified whether to discard or truncate oversized mirrored packets.')
smirrorEntryMirroredPkts = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 30, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smirrorEntryMirroredPkts.setStatus('mandatory')
if mibBuilder.loadTexts: smirrorEntryMirroredPkts.setDescription('Number of entry packets mirrored.')
smirrorExitMirroredPkts = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 30, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smirrorExitMirroredPkts.setStatus('mandatory')
if mibBuilder.loadTexts: smirrorExitMirroredPkts.setDescription('Number of exit packets mirrored.')
smirrorNotreadyDroppedPkts = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 30, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smirrorNotreadyDroppedPkts.setStatus('mandatory')
if mibBuilder.loadTexts: smirrorNotreadyDroppedPkts.setDescription('Number of packets not mirrored either because the diagnostic port is not ready (local mirroring) or the tunnel to remote ATX is not ready (remote mirroring).')
smirrorOversizeDroppedPkts = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 30, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smirrorOversizeDroppedPkts.setStatus('mandatory')
if mibBuilder.loadTexts: smirrorOversizeDroppedPkts.setDescription('Number of oversized packets not mirrored.')
smirrorEntryFilteredPkts = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 30, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smirrorEntryFilteredPkts.setStatus('mandatory')
if mibBuilder.loadTexts: smirrorEntryFilteredPkts.setDescription('Number of entry packets filtered.')
smirrorExitFilteredPkts = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 30, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smirrorExitFilteredPkts.setStatus('mandatory')
if mibBuilder.loadTexts: smirrorExitFilteredPkts.setDescription('Number of exit packets filtered.')
smirrorCongestionDroppedPkts = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 30, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smirrorCongestionDroppedPkts.setStatus('mandatory')
if mibBuilder.loadTexts: smirrorCongestionDroppedPkts.setDescription('Number of packets not mirrored due to exit port congestion.')
smirrorNowrapperDroppedPkts = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 30, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smirrorNowrapperDroppedPkts.setStatus('mandatory')
if mibBuilder.loadTexts: smirrorNowrapperDroppedPkts.setDescription('Number of packets not mirrored due to shortage of wrapper buffers (in mirroring frames to remote ATX).')
smirrorRemoteStatus = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 30, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 6, 7, 8, 9))).clone(namedValues=NamedValues(("mirrorOff", 0), ("handshakeInProgress", 1), ("arpRefreshInProgress", 2), ("remoteHostUnreachable", 3), ("mirroring", 6), ("versionIncompatible", 7), ("remoteDiagnosticPortBroken", 8), ("remoteMirrorNotOn", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: smirrorRemoteStatus.setStatus('mandatory')
if mibBuilder.loadTexts: smirrorRemoteStatus.setDescription('Status when mirroring to remote ATX.')
smirrorRemoteExitPort = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 30, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smirrorRemoteExitPort.setStatus('mandatory')
if mibBuilder.loadTexts: smirrorRemoteExitPort.setDescription('Mirrored packets exit port number to remote ATX.')
sWorkGroupNextNumber = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 31, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sWorkGroupNextNumber.setStatus('mandatory')
if mibBuilder.loadTexts: sWorkGroupNextNumber.setDescription('The next available workgroup number to be used. When creating a new workgroup, it is recommended to read the value of the variable and use it to key into the workgroup table.')
sWorkGroupCurrentCount = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 31, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sWorkGroupCurrentCount.setStatus('mandatory')
if mibBuilder.loadTexts: sWorkGroupCurrentCount.setDescription('The total number of workgroups currently defined.')
sWorkGroupMaxCount = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 31, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sWorkGroupMaxCount.setStatus('mandatory')
if mibBuilder.loadTexts: sWorkGroupMaxCount.setDescription('The maximum number of workgroups allowed.')
sWorkGroupTable = MibTable((1, 3, 6, 1, 4, 1, 97, 3, 31, 4), )
if mibBuilder.loadTexts: sWorkGroupTable.setStatus('mandatory')
if mibBuilder.loadTexts: sWorkGroupTable.setDescription('This table contains work group definitions for the interfaces.')
sWorkGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 97, 3, 31, 4, 1), ).setIndexNames((0, "CTATX-MIB", "sWorkGroupNumber"))
if mibBuilder.loadTexts: sWorkGroupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sWorkGroupEntry.setDescription('Each entry in this table contains a definition of a work group.')
sWorkGroupNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 31, 4, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sWorkGroupNumber.setStatus('mandatory')
if mibBuilder.loadTexts: sWorkGroupNumber.setDescription('An integer that identifies the work group, used as an index to this table.')
sWorkGroupName = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 31, 4, 1, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sWorkGroupName.setStatus('mandatory')
if mibBuilder.loadTexts: sWorkGroupName.setDescription('A 1-16 character work group name.')
sWorkGroupPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 31, 4, 1, 3), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sWorkGroupPorts.setStatus('mandatory')
if mibBuilder.loadTexts: sWorkGroupPorts.setDescription('A list of all ports within the group. The first octet specified ports 1-8, the second 9-16, etc.')
sWorkGroupType = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 31, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("ip", 1), ("ipx", 2), ("all", 3), ("invalid", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sWorkGroupType.setStatus('mandatory')
if mibBuilder.loadTexts: sWorkGroupType.setDescription('The type of work group: all - no additional information needs to be supplied. ip - the IP network (and optionally, IP mask) must be supplied. ipx - the IPX network number may be supplied, or else all IPX network number will be assumed.')
sWorkGroupIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 31, 4, 1, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sWorkGroupIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: sWorkGroupIpAddress.setDescription('The IP network address.')
sWorkGroupIpMask = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 31, 4, 1, 6), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sWorkGroupIpMask.setStatus('mandatory')
if mibBuilder.loadTexts: sWorkGroupIpMask.setDescription('The IP network mask, if set to 0, the default network mask is applied.')
sWorkGroupIpxNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 31, 4, 1, 7), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sWorkGroupIpxNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: sWorkGroupIpxNetwork.setDescription('The IPX network number, 0 means all networks.')
spingDataTimeout = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 32, 1), TimeTicks()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: spingDataTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: spingDataTimeout.setDescription('The time, in centiseconds, from the last ping activity (a send or receive of an ECHO_RESPONSE or ECHO_REQUEST message), to when the spingEntry information for that ping request will be deleted.')
spingTable = MibTable((1, 3, 6, 1, 4, 1, 97, 3, 32, 2), )
if mibBuilder.loadTexts: spingTable.setStatus('mandatory')
if mibBuilder.loadTexts: spingTable.setDescription('The set of information describing the active ping requests and their results.')
spingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 97, 3, 32, 2, 1), ).setIndexNames((0, "CTATX-MIB", "spingNMSAddr"), (0, "CTATX-MIB", "spingDestAddr"))
if mibBuilder.loadTexts: spingEntry.setStatus('mandatory')
if mibBuilder.loadTexts: spingEntry.setDescription('The parameters, state and results of a ping request.')
spingNMSAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 32, 2, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: spingNMSAddr.setStatus('mandatory')
if mibBuilder.loadTexts: spingNMSAddr.setDescription('The IP address of the NMS, used to determine which ping request to return information on.')
spingDestAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 32, 2, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: spingDestAddr.setStatus('mandatory')
if mibBuilder.loadTexts: spingDestAddr.setDescription('The IP address which is to be the destination of the ping ECHO_REQUEST. This variable cannot be set while spingOperation is on.')
spingState = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 32, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("not-started", 0), ("active", 1), ("timed-out", 2), ("completed", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: spingState.setStatus('mandatory')
if mibBuilder.loadTexts: spingState.setDescription('The current state of the ping request. ')
spingCount = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 32, 2, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: spingCount.setStatus('mandatory')
if mibBuilder.loadTexts: spingCount.setDescription('The number of ping requests which are to be sent. This variable cannot be set while spingOperation is on.')
spingDataSize = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 32, 2, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: spingDataSize.setStatus('mandatory')
if mibBuilder.loadTexts: spingDataSize.setDescription('The datagram packet size which will be sent with the ECHO_REQUEST, in bytes. This variable cannot be set while spingOperation is on.')
spingWait = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 32, 2, 1, 6), TimeTicks()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: spingWait.setStatus('mandatory')
if mibBuilder.loadTexts: spingWait.setDescription('The time, in centiseconds, between the sending of each ECHO_REQUEST message. This variable cannot be set while spingOperation is on.')
spingTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 32, 2, 1, 7), TimeTicks()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: spingTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: spingTimeout.setDescription('The time, in centiseconds, since the last ECHO_RESPONSE was received (or the last ECHO_REQUEST was sent, if there have been no responses) when the ping request will time out. This variable cannot be set while spingOperation is on.')
spingOperation = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 32, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: spingOperation.setStatus('mandatory')
if mibBuilder.loadTexts: spingOperation.setDescription('Setting spingOperation to on will begin the ping request. Setting spingOperation to off will terminate the ping request.')
spingMin = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 32, 2, 1, 9), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: spingMin.setStatus('mandatory')
if mibBuilder.loadTexts: spingMin.setDescription('The minimum round trip time for the ping requests and responses, in centiseconds.')
spingMax = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 32, 2, 1, 10), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: spingMax.setStatus('mandatory')
if mibBuilder.loadTexts: spingMax.setDescription('The maximum round trip for the ping requests and responses, in centiseconds.')
spingAvg = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 32, 2, 1, 11), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: spingAvg.setStatus('mandatory')
if mibBuilder.loadTexts: spingAvg.setDescription('The average round trip time for the ping requests and responses, in centiseconds.')
spingNumTransmitted = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 32, 2, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: spingNumTransmitted.setStatus('mandatory')
if mibBuilder.loadTexts: spingNumTransmitted.setDescription('The number of ICMP ECHO_REQUEST messages that have been transmitted during this ping request.')
spingNumReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 32, 2, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: spingNumReceived.setStatus('mandatory')
if mibBuilder.loadTexts: spingNumReceived.setDescription('The number of ICMP ECHO_RESPONSE messages that have been received as a result of this ping request.')
straceDataTimeout = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 33, 1), TimeTicks()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: straceDataTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: straceDataTimeout.setDescription('The time, in centiseconds, from the last traceroute activity (the response to or timeout of the last probe sent), to when the straceEntry information for that traceroute request will be deleted.')
straceTable = MibTable((1, 3, 6, 1, 4, 1, 97, 3, 33, 2), )
if mibBuilder.loadTexts: straceTable.setStatus('mandatory')
if mibBuilder.loadTexts: straceTable.setDescription('The set of information describing the active traceroute requests and their results.')
straceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 97, 3, 33, 2, 1), ).setIndexNames((0, "CTATX-MIB", "straceNMSAddr"), (0, "CTATX-MIB", "straceDestAddr"), (0, "CTATX-MIB", "straceHop"), (0, "CTATX-MIB", "straceProbe"))
if mibBuilder.loadTexts: straceEntry.setStatus('mandatory')
if mibBuilder.loadTexts: straceEntry.setDescription('The parameters, state, and results of a traceroute request.')
straceNMSAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 33, 2, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: straceNMSAddr.setStatus('mandatory')
if mibBuilder.loadTexts: straceNMSAddr.setDescription('The IP address of the NMS, used to determine which traceroute request to return information on.')
straceDestAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 33, 2, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: straceDestAddr.setStatus('mandatory')
if mibBuilder.loadTexts: straceDestAddr.setDescription('The IP address which is to be the destination of the traceroute request.This variable cannot be set while straceOperation is on.')
straceMaxTTL = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 33, 2, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: straceMaxTTL.setStatus('mandatory')
if mibBuilder.loadTexts: straceMaxTTL.setDescription('The maximum time-to-live for outgoing traceroute probe packets. This determines the number of hops that can be in a traceroute. This variable cannot be set while straceOperation is on.')
straceDataSize = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 33, 2, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: straceDataSize.setStatus('mandatory')
if mibBuilder.loadTexts: straceDataSize.setDescription('The size of the datagram sent with each probe. This variable cannot be set while straceOperation is on.')
straceNumProbes = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 33, 2, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: straceNumProbes.setStatus('mandatory')
if mibBuilder.loadTexts: straceNumProbes.setDescription('The number of probes which are sent for each hop. This variable cannot be set while straceOperation is on.')
straceWait = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 33, 2, 1, 6), TimeTicks()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: straceWait.setStatus('mandatory')
if mibBuilder.loadTexts: straceWait.setDescription('The time to wait in response to a probe. This variable cannot be set while straceOperation is on.')
straceOperation = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 33, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: straceOperation.setStatus('mandatory')
if mibBuilder.loadTexts: straceOperation.setDescription('Setting straceOperation to on will begin the traceroute request. Setting straceOperation to off will terminate the traceroute request.')
straceHop = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 33, 2, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: straceHop.setStatus('mandatory')
if mibBuilder.loadTexts: straceHop.setDescription('The hop count for a set of probes with a particular TTL.')
straceHopAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 33, 2, 1, 9), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: straceHopAddress.setStatus('mandatory')
if mibBuilder.loadTexts: straceHopAddress.setDescription('The IP address of the host which responded for a probe with a particular TTL.')
straceProbe = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 33, 2, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: straceProbe.setStatus('mandatory')
if mibBuilder.loadTexts: straceProbe.setDescription('The probe instance for a particular hop.')
straceState = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 33, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("not-started", 0), ("active", 1), ("time-exceeded", 2), ("host-unreachable", 3), ("net-unreachable", 4), ("completed", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: straceState.setStatus('mandatory')
if mibBuilder.loadTexts: straceState.setDescription('The current state of the trace probe.')
straceTime = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 33, 2, 1, 12), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: straceTime.setStatus('mandatory')
if mibBuilder.loadTexts: straceTime.setDescription('Round trip time of a probe for a particular hop.')
srtbProto = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 34, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 7))).clone(namedValues=NamedValues(("off", 0), ("ip", 1), ("ipx", 2), ("others", 3), ("all", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: srtbProto.setStatus('mandatory')
if mibBuilder.loadTexts: srtbProto.setDescription('Bit mapped representation of srtb protocol configuration.')
srtbExplorer = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 34, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("are", 1), ("ste", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: srtbExplorer.setStatus('mandatory')
if mibBuilder.loadTexts: srtbExplorer.setDescription('Type of explorer to transmit.')
srtbAgingTime = MibScalar((1, 3, 6, 1, 4, 1, 97, 3, 34, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srtbAgingTime.setStatus('mandatory')
if mibBuilder.loadTexts: srtbAgingTime.setDescription('RIF aging time value.')
nbCacheifTable = MibTable((1, 3, 6, 1, 4, 1, 97, 3, 35, 3), )
if mibBuilder.loadTexts: nbCacheifTable.setStatus('mandatory')
if mibBuilder.loadTexts: nbCacheifTable.setDescription('')
nbCacheifEntry = MibTableRow((1, 3, 6, 1, 4, 1, 97, 3, 35, 3, 1), ).setIndexNames((0, "CTATX-MIB", "nbCacheIfIndex"))
if mibBuilder.loadTexts: nbCacheifEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nbCacheifEntry.setDescription('')
nbCacheIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 35, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbCacheIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: nbCacheIfIndex.setDescription('This is the primary index into the Netbios Interface Table. It is the port number which you intend to enable/disable Netbios Caching.')
nbCacheIfOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 3, 35, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbCacheIfOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: nbCacheIfOperStatus.setDescription('Indicates the operating state of netbios name caching for this port.')
mibBuilder.exportSymbols("CTATX-MIB", profileType=profileType, strapSeverityEnable=strapSeverityEnable, ipMRouteTable=ipMRouteTable, snmpsmt=snmpsmt, spingOperation=spingOperation, sfddiSrfConditionsStatus=sfddiSrfConditionsStatus, srtrdiscAdvertisementAddress=srtrdiscAdvertisementAddress, sifDesigBridge=sifDesigBridge, sifEntry=sifEntry, swdis=swdis, spingNumTransmitted=spingNumTransmitted, configFatalErr=configFatalErr, swanLinkPort=swanLinkPort, igmpInterfaceQueryInterval=igmpInterfaceQueryInterval, spvcIfIndex=spvcIfIndex, stTopChangeTime=stTopChangeTime, straceWait=straceWait, sifInQLen=sifInQLen, stActHello=stActHello, strace=strace, ipMRouteRpfFails=ipMRouteRpfFails, swanLinkRestartTime=swanLinkRestartTime, ipMRouteEnable=ipMRouteEnable, hwType=hwType, atextportTable=atextportTable, hwSysBus=hwSysBus, hwFatalErr=hwFatalErr, atextportzipTable=atextportzipTable, igmpCacheEntry=igmpCacheEntry, meshCost=meshCost, filterAddIndex=filterAddIndex, swanPreserveFCS=swanPreserveFCS, straceDataSize=straceDataSize, igmpMIB=igmpMIB, debugString=debugString, strapTime=strapTime, sfddiRbcErrCnts=sfddiRbcErrCnts, ruleAllowEgp=ruleAllowEgp, suartAlignmentErrors=suartAlignmentErrors, spvcEntry=spvcEntry, sysReset=sysReset, sipcktTable=sipcktTable, sfddiStationDescriptor=sfddiStationDescriptor, filterID=filterID, spvcState=spvcState, igmpInterfaceTable=igmpInterfaceTable, sprotoSteHopCountAppliedRule=sprotoSteHopCountAppliedRule, igmpCacheIfIndex=igmpCacheIfIndex, sipmRouteGateway=sipmRouteGateway, strunkLinkOrdinal=strunkLinkOrdinal, swIndex=swIndex, stRootPort=stRootPort, lpbkInterval=lpbkInterval, smirrorTargetPortLists=smirrorTargetPortLists, sipmNeighborEntry=sipmNeighborEntry, ppeRouteMemoryFailures=ppeRouteMemoryFailures, sipxIfTable=sipxIfTable, ruleTcpProfile=ruleTcpProfile, straceHop=straceHop, strapControlTable=strapControlTable, swanLinkErrorMaxPeriods=swanLinkErrorMaxPeriods, sprotoTable=sprotoTable, sfddiIndex=sfddiIndex, sifRxQueueThreshTime=sifRxQueueThreshTime, swanLinkCost=swanLinkCost, ruleFilterUdpFragment=ruleFilterUdpFragment, ipMRouteInIfIndex=ipMRouteInIfIndex, srtrdiscTable=srtrdiscTable, ppeArpPduMemoryFailures=ppeArpPduMemoryFailures, sipxsrExplorerTable=sipxsrExplorerTable, sfddiRxEbits=sfddiRxEbits, stAgeTime=stAgeTime, sifState=sifState, spingNMSAddr=spingNMSAddr, sipxRouteTable=sipxRouteTable, addrFlags=addrFlags, sifFrameSwitching=sifFrameSwitching, spingDestAddr=spingDestAddr, hwManufData=hwManufData, ppeMgtMemoryAvail=ppeMgtMemoryAvail, configDumpStart=configDumpStart, sipxsfSAPName=sipxsfSAPName, spvcTable=spvcTable, srtbExplorer=srtbExplorer, strapIncludeText=strapIncludeText, hwInuse=hwInuse, sifLan=sifLan, swanOutPacketType=swanOutPacketType, stResAddr=stResAddr, configPowerDc2=configPowerDc2, sipxIfNetwork=sipxIfNetwork, sprotoIpxTranslate=sprotoIpxTranslate, nbCacheifEntry=nbCacheifEntry, ipMRouteSourceMask=ipMRouteSourceMask, swdisDesc=swdisDesc, ppeIgmpPduMemoryAllocs=ppeIgmpPduMemoryAllocs, sipmRouteOriginMask=sipmRouteOriginMask, ruleAllowIgrp=ruleAllowIgrp, sipmRouteParents=sipmRouteParents, reboot=reboot, swFlashBank=swFlashBank, sifUtilSysPeakTBitRate=sifUtilSysPeakTBitRate, straceProbe=straceProbe, addrAge=addrAge, hw=hw, sifDesigPort=sifDesigPort, sprotoIpxSrTranslate=sprotoIpxSrTranslate, strapEntrySeverity=strapEntrySeverity, strunkLinkCount=strunkLinkCount, ruleAllowIcmp=ruleAllowIcmp, sWorkGroupName=sWorkGroupName, snmpsmtUpstreamReq=snmpsmtUpstreamReq, sys=sys, sifFunctions=sifFunctions, filterSourceEnd=filterSourceEnd, configPowerDc1=configPowerDc1, sipxRouteDest=sipxRouteDest, ipMRouteOctets=ipMRouteOctets, addrRptrPort=addrRptrPort, profileEntry=profileEntry, sprotoIbm8209Lsaps=sprotoIbm8209Lsaps, ruleAllowIpWithinIp=ruleAllowIpWithinIp, sipmgroup=sipmgroup, filterField=filterField, rebootSlotTable=rebootSlotTable, swanDesiredSpeed=swanDesiredSpeed, lpbkOperation=lpbkOperation, meshCostChangeTime=meshCostChangeTime, sipckt=sipckt, ipMRouteEntry=ipMRouteEntry, ecs_1=ecs_1, filterDest=filterDest, ppeTftpPduMemoryAllocs=ppeTftpPduMemoryAllocs, filterTable=filterTable, hwAddr2=hwAddr2, profileIndex=profileIndex, sworkgroup=sworkgroup, sifRxQueues=sifRxQueues, sipxDiscardedRoutes=sipxDiscardedRoutes, sigma=sigma, ppeRoutePercent=ppeRoutePercent, stTopChangeCount=stTopChangeCount, strapSeverityControlTable=strapSeverityControlTable, smirrorStatus=smirrorStatus, meshCostChangeCount=meshCostChangeCount, hwPpeType=hwPpeType, sipxsfPortMap=sipxsfPortMap, strapEntryNumber=strapEntryNumber, spingState=spingState, swanDCEDrops=swanDCEDrops, ppeMgtMemorySize=ppeMgtMemorySize, sysTrapAck=sysTrapAck, sifMaxPacketSize=sifMaxPacketSize, swanAlignmentErrors=swanAlignmentErrors, sifUtilPortPeakTBitRate=sifUtilPortPeakTBitRate, sprotoNetbiosTranslate=sprotoNetbiosTranslate, spingCount=spingCount, sipxSapNodeId=sipxSapNodeId, slogOverwrite=slogOverwrite, snmpsmtUpstreamState=snmpsmtUpstreamState, sifRingDrops=sifRingDrops, filterSourceMask=filterSourceMask, configFunctions=configFunctions, lpbkPktLength=lpbkPktLength, srtbProto=srtbProto, lmaAllAddr=lmaAllAddr, ppeArpStatics=ppeArpStatics, hwTempOK=hwTempOK, addrAlarmMAC=addrAlarmMAC, addrMeshs=addrMeshs, ruleDestIp=ruleDestIp, strapSeverity=strapSeverity, straceTime=straceTime, configAlarmAddresses=configAlarmAddresses, igmpInterfaceEntry=igmpInterfaceEntry, swTypes=swTypes, srepeaterGroupID=srepeaterGroupID, sipcktNetMask=sipcktNetMask, suartIpNeighborAddress=suartIpNeighborAddress, sipxsfNextIndex=sipxsfNextIndex, sifFilterFlags=sifFilterFlags, sfddiRxShorts=sfddiRxShorts, sifStPriority=sifStPriority, filterThreshold=filterThreshold, spvc=spvc, sipxRouteIfIndex=sipxRouteIfIndex, spingDataTimeout=spingDataTimeout, ppeRipRouteDiscards=ppeRipRouteDiscards, sifIpAddress=sifIpAddress, ruleUdpProfile=ruleUdpProfile, ppeOspfPduMemoryFailures=ppeOspfPduMemoryFailures, addrStatics=addrStatics, configStorageFailure=configStorageFailure, swanSwitches=swanSwitches, filterDestEnd=filterDestEnd, hwPortSubType=hwPortSubType, straceOperation=straceOperation, sifDesigRoot=sifDesigRoot, ppeRipPreference=ppeRipPreference, filterMask=filterMask, srtrdiscAdvertisementInterval=srtrdiscAdvertisementInterval, ppeStaticPreference=ppeStaticPreference, rebootType=rebootType, lpbkErrorSize=lpbkErrorSize, sipxsrExplorerEntry=sipxsrExplorerEntry, rebootBridgingMemory=rebootBridgingMemory, straceEntry=straceEntry, srtrdiscState=srtrdiscState, sipxSapType=sipxSapType, swanLinkErrorFailPeriods=swanLinkErrorFailPeriods, sipxsrStatus=sipxsrStatus, igmpCacheUpTime=igmpCacheUpTime, hwAddr8=hwAddr8, filter=filter, sprotoIpRoute=sprotoIpRoute, sifTxCongests=sifTxCongests, ruleDestIpMask=ruleDestIpMask, sfddiDpcErrValue=sfddiDpcErrValue, swSizes=swSizes, srtrdiscLifetime=srtrdiscLifetime, addrDynamicMax=addrDynamicMax, debugStringID=debugStringID, igmpInterfaceStatus=igmpInterfaceStatus, sifUtilPortPeakTable=sifUtilPortPeakTable, lpbkErrorNoReceives=lpbkErrorNoReceives, ppeIpStatics=ppeIpStatics, ppeBootpPduMemoryAllocs=ppeBootpPduMemoryAllocs, sifIpRipPortMetric=sifIpRipPortMetric, lmaAnyAddr=lmaAnyAddr, sipxIfOutSapPkts=sipxIfOutSapPkts, profileDestEnd=profileDestEnd, slogEntryNumber=slogEntryNumber, hwAddr5=hwAddr5, spingWait=spingWait, sifRxChar1s=sifRxChar1s, nbcache=nbcache, sifUtilSysPeakTable=sifUtilSysPeakTable, swanOverrunErrors=swanOverrunErrors, ppeTraceroutePduMemoryFailures=ppeTraceroutePduMemoryFailures, sifRxPackets=sifRxPackets, sprotoArpTranslate=sprotoArpTranslate, sipcktSourceRoute=sipcktSourceRoute, strap=strap, filterPortNo=filterPortNo, suartIndex=suartIndex, lpbkIncrements=lpbkIncrements, hwUseMod=hwUseMod, sipxsfNetworks=sipxsfNetworks, ruleIndex=ruleIndex, swanIpNeighborAddress=swanIpNeighborAddress, configPowerPresent1=configPowerPresent1, srtrdiscEntry=srtrdiscEntry, sifTxStormFlag=sifTxStormFlag, srepeaterPortGroupID=srepeaterPortGroupID)
mibBuilder.exportSymbols("CTATX-MIB", srtbAgingTime=srtbAgingTime, swanEntry=swanEntry, hwAddr4=hwAddr4, sprotoIpMulticast=sprotoIpMulticast, ppeEgpPreference=ppeEgpPreference, addrOperation=addrOperation, ppeIcmpPduMemoryFailures=ppeIcmpPduMemoryFailures, addrBlockSize=addrBlockSize, configDumpEnd=configDumpEnd, sifRxSizeErrors=sifRxSizeErrors, sipmNeighborLastHeard=sipmNeighborLastHeard, strapEntryText=strapEntryText, sipcktIpAddress=sipcktIpAddress, ppePacketMemoryAvail=ppePacketMemoryAvail, ipMRouteInterfaceEntry=ipMRouteInterfaceEntry, fddismtUpstreamDescriptor=fddismtUpstreamDescriptor, sipxSapHopCount=sipxSapHopCount, spingMax=spingMax, meshSubnet=meshSubnet, sipxsfTable=sipxsfTable, sifIndex=sifIndex, ppeArpOverflows=ppeArpOverflows, strunkLastError=strunkLastError, sprotoSuppressBpdus=sprotoSuppressBpdus, sifThresholdTime=sifThresholdTime, ipMRouteGroup=ipMRouteGroup, ipMRouteUpTime=ipMRouteUpTime, sipxIfFraming=sipxIfFraming, rebootIndex=rebootIndex, ruleFilterIpOption=ruleFilterIpOption, stActDelay=stActDelay, atextportZoneIndex=atextportZoneIndex, smirrorOversizeDroppedPkts=smirrorOversizeDroppedPkts, sifSmlRxCnt=sifSmlRxCnt, sipxIfInSapPkts=sipxIfInSapPkts, swStarts=swStarts, spvcPathTX=spvcPathTX, sfddiOBSFuseBad=sfddiOBSFuseBad, ppeOspfPreference=ppeOspfPreference, atext=atext, smirrorCongestionDroppedPkts=smirrorCongestionDroppedPkts, sinterfaces=sinterfaces, sifLrgRxCnt=sifLrgRxCnt, hwIndex=hwIndex, rebootConfig=rebootConfig, ppeRipPduMemoryAllocs=ppeRipPduMemoryAllocs, sifDescr=sifDescr, sWorkGroupPorts=sWorkGroupPorts, sifCongestTime=sifCongestTime, smirrorEntryFilteredPkts=smirrorEntryFilteredPkts, sfddiRbcErrValue=sfddiRbcErrValue, addrDynamics=addrDynamics, atextportzipEntry=atextportzipEntry, hwRptrPorts=hwRptrPorts, strapSeverityControl=strapSeverityControl, strapSeveritySeverity=strapSeveritySeverity, spingMin=spingMin, ipMRouteNextHopState=ipMRouteNextHopState, sprotoIbmLlcTranslate=sprotoIbmLlcTranslate, sping=sping, suartOverrunErrors=suartOverrunErrors, swdisAccess=swdisAccess, sipxsfGrp=sipxsfGrp, filterDestMask=filterDestMask, srepeaterExtendedStats=srepeaterExtendedStats, slog=slog, configTprPriority=configTprPriority, sipmstat=sipmstat, smirrorOversizePkt=smirrorOversizePkt, strunkState=strunkState, sipxIfIndex=sipxIfIndex, sipxRouteHopCount=sipxRouteHopCount, strapRetry=strapRetry, sipmOutOfMemory=sipmOutOfMemory, srepeaterPortLinkPulse=srepeaterPortLinkPulse, stBridgeId=stBridgeId, sprotoIpxRoute=sprotoIpxRoute, ppeOspfPduMemoryAllocs=ppeOspfPduMemoryAllocs, spingDataSize=spingDataSize, sipcktIndex=sipcktIndex, sipmRouteOrigin=sipmRouteOrigin, sWorkGroupTable=sWorkGroupTable, ppeLrgUxRxCnt=ppeLrgUxRxCnt, debugOperation=debugOperation, sysID=sysID, hwAddr6=hwAddr6, ruleAllowOspf=ruleAllowOspf, spingAvg=spingAvg, sprotoIfIndex=sprotoIfIndex, atextportNetEnd=atextportNetEnd, strunkEntry=strunkEntry, sWorkGroupMaxCount=sWorkGroupMaxCount, sipx=sipx, spingTimeout=spingTimeout, sipNetToMediaNetAddress=sipNetToMediaNetAddress, sifTxStormCnt=sifTxStormCnt, fddismtUpstreamState=fddismtUpstreamState, sifExpectSqe=sifExpectSqe, sipmRouteTable=sipmRouteTable, lpbkTable=lpbkTable, spingNumReceived=spingNumReceived, ruleEntry=ruleEntry, ppeArpEntries=ppeArpEntries, ipMRoute=ipMRoute, ppeUxTxCnt=ppeUxTxCnt, lpbkGoods=lpbkGoods, strunkIfIndex=strunkIfIndex, sifUtilSysPeakTimestamp=sifUtilSysPeakTimestamp, lma=lma, ruleAllowAnyOther=ruleAllowAnyOther, sipxSapSocket=sipxSapSocket, spingTable=spingTable, lpbk=lpbk, debug=debug, ppePacketMemorySize=ppePacketMemorySize, Boolean=Boolean, ppePacketMemoryFailures=ppePacketMemoryFailures, filterThreshFlag=filterThreshFlag, swanNegotiate=swanNegotiate, sipxsrExplorerType=sipxsrExplorerType, smirrorNowrapperDroppedPkts=smirrorNowrapperDroppedPkts, nbCacheIfOperStatus=nbCacheIfOperStatus, sipxRouteAge=sipxRouteAge, hwDefType=hwDefType, swFileset=swFileset, sipmNeighborIfIndex=sipmNeighborIfIndex, atextportNetAddress=atextportNetAddress, sipmStatIfIndex=sipmStatIfIndex, sfddiRxHwAborts=sfddiRxHwAborts, ruleTcpEstProfile=ruleTcpEstProfile, suartEntry=suartEntry, filterPktCnts=filterPktCnts, filterLastSrc=filterLastSrc, suartModem=suartModem, swanLinkErrorPercentage=swanLinkErrorPercentage, srepeaterEntry=srepeaterEntry, sWorkGroupIpxNetwork=sWorkGroupIpxNetwork, ppeIgmpPduMemoryFailures=ppeIgmpPduMemoryFailures, atextportIndex=atextportIndex, swFilesetTable=swFilesetTable, sifStatisticsTime=sifStatisticsTime, sipNetToMediaEntry=sipNetToMediaEntry, spvcPathRX=spvcPathRX, sprotoBootpRelay=sprotoBootpRelay, smirrorExitFilteredPkts=smirrorExitFilteredPkts, sfddiNotCopiedThreshold=sfddiNotCopiedThreshold, sprotoIpxDot3Framing=sprotoIpxDot3Framing, lpbkErrorBadReceives=lpbkErrorBadReceives, filterCurrentCount=filterCurrentCount, swanPPPActive=swanPPPActive, ruleSourceIpMask=ruleSourceIpMask, strapEntry=strapEntry, addrRxFwdPkts=addrRxFwdPkts, configFddiPriority=configFddiPriority, sifUtilSysPeakOrdinal=sifUtilSysPeakOrdinal, sfddiStationState=sfddiStationState, strapIndex=strapIndex, lpbkErrorReceived=lpbkErrorReceived, slogIndex=slogIndex, smirrorExitMirroredPkts=smirrorExitMirroredPkts, slogEntryMessageText=slogEntryMessageText, filterSrcLan=filterSrcLan, strunk=strunk, ppeSnmpPduMemoryAllocs=ppeSnmpPduMemoryAllocs, addrDynamicOverflows=addrDynamicOverflows, suartPPPActive=suartPPPActive, sifCongested=sifCongested, stRootHello=stRootHello, hwDiagCode=hwDiagCode, swNumber=swNumber, stRootDelay=stRootDelay, sipxIfInRipPkts=sipxIfInRipPkts, swBases=swBases, sifRxHwFCSs=sifRxHwFCSs, filterThreshTime=filterThreshTime, sipmRouteAge=sipmRouteAge, spvcCircuitRX=spvcCircuitRX, ppeIcmpPduMemoryAllocs=ppeIcmpPduMemoryAllocs, stTopChange=stTopChange, straceNumProbes=straceNumProbes, sipNetToMediaIfIndex=sipNetToMediaIfIndex, smirror=smirror, configAnyPass=configAnyPass, hwAddr1=hwAddr1, debugIndex=debugIndex, swdisConfigIp=swdisConfigIp, ppeRouteMemorySize=ppeRouteMemorySize, fddismtTable=fddismtTable, hwDiagStatus=hwDiagStatus, srepeaterPortTable=srepeaterPortTable, addrMAC=addrMAC, sifTxSizes=sifTxSizes, hwUsePort=hwUsePort, ppeTftpPduMemoryFailures=ppeTftpPduMemoryFailures, sifDesigCost=sifDesigCost, meshCostChange=meshCostChange, sproto=sproto, sipm=sipm, swDesc=swDesc, addrBlock=addrBlock, sifUtilSysPeakEntry=sifUtilSysPeakEntry, swanLinkBridge=swanLinkBridge, lpbkErrorSent=lpbkErrorSent, hwSlotTable=hwSlotTable, addrRxChars=addrRxChars, configPowerPresent2=configPowerPresent2, swanLinkSubnet=swanLinkSubnet, srepeaterPortEntry=srepeaterPortEntry, strapControl=strapControl, ruleSourceIp=ruleSourceIp, sWorkGroupIpAddress=sWorkGroupIpAddress, addrRxMultiPkts=addrRxMultiPkts, ppeOspfRouteDiscards=ppeOspfRouteDiscards, spingEntry=spingEntry, srepeaterTable=srepeaterTable, ppeTxCongests=ppeTxCongests, sifUtilPortPeakBRTimestamp=sifUtilPortPeakBRTimestamp, smirrorNotreadyDroppedPkts=smirrorNotreadyDroppedPkts, sipxsfAccessMode=sipxsfAccessMode, ruleTable=ruleTable, sipcktEntry=sipcktEntry, addrTxPkts=addrTxPkts, rebootRouteMemory=rebootRouteMemory, addr=addr, sysTrapRetry=sysTrapRetry, slogEntryTable=slogEntryTable, configNMSAddress=configNMSAddress, ruleAllowIgp=ruleAllowIgp, addrNext=addrNext, suartTable=suartTable, sipxIfEntry=sipxIfEntry, stActMaxAge=stActMaxAge, filterSource=filterSource, configAlarmDynamic=configAlarmDynamic, meshCostPercent=meshCostPercent, sifUtilPortPeakEntry=sifUtilPortPeakEntry, sipcktState=sipcktState, filterMaxCount=filterMaxCount, sWorkGroupIpMask=sWorkGroupIpMask, mesh=mesh, profileTable=profileTable, stGroupAddr=stGroupAddr, spvcMinPort=spvcMinPort, sprotoArpSourceRoute=sprotoArpSourceRoute, srepeaterLinkStatusMask=srepeaterLinkStatusMask, ppeSnmpPduMemoryFailures=ppeSnmpPduMemoryFailures, fddismtUpstreamRsp=fddismtUpstreamRsp, admin=admin, sysTrapTime=sysTrapTime, sprotoBridge=sprotoBridge, slogEntry=slogEntry, sipmneighbor=sipmneighbor, ppeBridgingMemory=ppeBridgingMemory, sipxRouteNextHop=sipxRouteNextHop)
mibBuilder.exportSymbols("CTATX-MIB", swanLinkErrorDuration=swanLinkErrorDuration, suartBaud=suartBaud, addrIndex=addrIndex, profileSourceStart=profileSourceStart, sWorkGroupNumber=sWorkGroupNumber, sifUtilSysPeakReset=sifUtilSysPeakReset, swdisConfigRetryTime=swdisConfigRetryTime, sipmStatEntry=sipmStatEntry, ppeRipPduMemoryFailures=ppeRipPduMemoryFailures, sifUtilPortPeakReset=sifUtilPortPeakReset, sprotoOspf=sprotoOspf, lpbkEntry=lpbkEntry, igmpCacheSelf=igmpCacheSelf, straceTable=straceTable, igmpCacheAddress=igmpCacheAddress, ipMRouteInterfaceIfIndex=ipMRouteInterfaceIfIndex, straceDestAddr=straceDestAddr, sifFilterLocal=sifFilterLocal, ppeTraceroutePduMemoryAllocs=ppeTraceroutePduMemoryAllocs, srepeater=srepeater, rebootPortType=rebootPortType, sipxSapTable=sipxSapTable, lpbkPktNum=lpbkPktNum, sifTable=sifTable, sifUtilSysPeakRBitRate=sifUtilSysPeakRBitRate, sipxsfSAPType=sipxsfSAPType, sprotoEntry=sprotoEntry, ppeExtendStats=ppeExtendStats, sipNetToMediaAge=sipNetToMediaAge, strapText=strapText, debugData=debugData, igmpInterfaceIfIndex=igmpInterfaceIfIndex, srepeaterPortPortID=srepeaterPortPortID, sifUtilPortPeakRBitRate=sifUtilPortPeakRBitRate, sfddiSmtConditions=sfddiSmtConditions, swanActualSpeed=swanActualSpeed, swCount=swCount, sipNetToMediaSourceRoute=sipNetToMediaSourceRoute, swdisConfigTotalTimeout=swdisConfigTotalTimeout, sfddiThruB=sfddiThruB, sifAdapterChecks=sifAdapterChecks, fddismtIndex=fddismtIndex, ipMRouteInterfaceTable=ipMRouteInterfaceTable, srtrdiscPreference=srtrdiscPreference, ipMRouteMIBObjects=ipMRouteMIBObjects, sprotoTrunking=sprotoTrunking, straceHopAddress=straceHopAddress, stRootCost=stRootCost, sipxRouteEntry=sipxRouteEntry, igmpMIBObjects=igmpMIBObjects, swdisWriteStatus=swdisWriteStatus, configAuthenticationFailure=configAuthenticationFailure, sprotoRip=sprotoRip, sipmRouteMetric=sipmRouteMetric, ppeBAddrLimit=ppeBAddrLimit, filterAddID=filterAddID, spvcPhysPort=spvcPhysPort, filterComboType=filterComboType, fddismtEntry=fddismtEntry, strapNumber=strapNumber, ppeBootpPduMemoryFailures=ppeBootpPduMemoryFailures, sipmCacheMiss=sipmCacheMiss, addrPortMap=addrPortMap, lpbkErrorOffset=lpbkErrorOffset, snmpsmtUpstreamRsp=snmpsmtUpstreamRsp, slogEntryName=slogEntryName, swanPortType=swanPortType, sfddiFrameErrorThreshold=sfddiFrameErrorThreshold, filterOffset=filterOffset, sifIpGroupAddress=sifIpGroupAddress, snmpsmtUpstreamDescriptor=snmpsmtUpstreamDescriptor, sipxsfFiltered=sipxsfFiltered, sipxsrPort=sipxsrPort, sipxSapEntry=sipxSapEntry, sipmNeighbors=sipmNeighbors, igmpCacheLastReporter=igmpCacheLastReporter, sifUtilCount=sifUtilCount, ipMRouteOutList=ipMRouteOutList, sfddiSBFlag=sfddiSBFlag, filterFlags=filterFlags, filterDeleteID=filterDeleteID, ruleType=ruleType, sifUX=sifUX, slogFilter=slogFilter, sfddiTable=sfddiTable, smirrorRemoteExitPort=smirrorRemoteExitPort, ipMRouteSource=ipMRouteSource, sifQueueTime=sifQueueTime, srtrdisc=srtrdisc, sifUxTxCnt=sifUxTxCnt, ipMRouteInterfaceTtl=ipMRouteInterfaceTtl, sWorkGroupCurrentCount=sWorkGroupCurrentCount, sWorkGroupEntry=sWorkGroupEntry, debugLength=debugLength, addrTxChars=addrTxChars, slogEntryTimeStamp=slogEntryTimeStamp, addrRxPkts=addrRxPkts, ppeMgtMemoryFailures=ppeMgtMemoryFailures, sifTxStorms=sifTxStorms, sipxsrAgingTime=sipxsrAgingTime, sipxSapName=sipxSapName, igmp=igmp, atextportNetStart=atextportNetStart, smirrorEntryMirroredPkts=smirrorEntryMirroredPkts, ipMRouteRpfNeighbor=ipMRouteRpfNeighbor, srtrdiscIfIndex=srtrdiscIfIndex, sipNetToMediaTable=sipNetToMediaTable, swan=swan, profileSourceEnd=profileSourceEnd, nbCacheIfIndex=nbCacheIfIndex, ppeRouteMemoryAvail=ppeRouteMemoryAvail, sfddiTxAsync=sfddiTxAsync, hwSysProcessor=hwSysProcessor, sifUtilPortPeakIndex=sifUtilPortPeakIndex, ssecure=ssecure, ipMRoutePkts=ipMRoutePkts, hwAddr7=hwAddr7, sifRxChar0s=sifRxChar0s, sfddiSrfReportLimit=sfddiSrfReportLimit, filterIndex=filterIndex, sifUtilSysPeakIndex=sifUtilSysPeakIndex, strapEntryTimeStamp=strapEntryTimeStamp, sipxsfIndex=sipxsfIndex, igmpCacheExpiryTime=igmpCacheExpiryTime, filterEntry=filterEntry, sifPortCost=sifPortCost, sifRxQueueThresh=sifRxQueueThresh, sifErrorsFlag=sifErrorsFlag, sfddiDpcErrCnts=sfddiDpcErrCnts, st=st, sipmroute=sipmroute, strunkTable=strunkTable, strapTable=strapTable, ipMRouteExpiryTime=ipMRouteExpiryTime, ppeSmlBuffSize=ppeSmlBuffSize, strunkRemoteIp=strunkRemoteIp, sipmNeighborTable=sipmNeighborTable, strunkLastChange=strunkLastChange, atextsysOperState=atextsysOperState, configGetPass=configGetPass, swanMeshState=swanMeshState, spvcMaxPort=spvcMaxPort, sipxsrGrp=sipxsrGrp, atextportEntry=atextportEntry, smirrorRemoteStatus=smirrorRemoteStatus, sprotoAppleRoute=sprotoAppleRoute, atextport=atextport, hwPortStatus=hwPortStatus, sfddiSmtConditionsStatus=sfddiSmtConditionsStatus, sifTxAddr=sifTxAddr, sfddi=sfddi, sfddiRxParitys=sfddiRxParitys, sprotoAppleTranslate=sprotoAppleTranslate, stRootMaxAge=stRootMaxAge, addrMeshOverflows=addrMeshOverflows, configDumpModule=configDumpModule, suart=suart, fddismtUpstreamReq=fddismtUpstreamReq, sw=sw, sifTxPackets=sifTxPackets, hwNumber=hwNumber, config=config, sfddiDownstreamNbr=sfddiDownstreamNbr, profileDestStart=profileDestStart, sfddiShortAddressing=sfddiShortAddressing, ppeIpEntries=ppeIpEntries, debugTable=debugTable, sWorkGroupType=sWorkGroupType, igmpCacheTable=igmpCacheTable, swanTable=swanTable, ppeArpPduMemoryAllocs=ppeArpPduMemoryAllocs, strunkRemoteBridgeAddr=strunkRemoteBridgeAddr, rebootEntry=rebootEntry, configPowerAc2=configPowerAc2, stRootID=stRootID, atextportZone=atextportZone, debugEntry=debugEntry, straceDataTimeout=straceDataTimeout, smirrorIPaddr=smirrorIPaddr, sipmRouteEntry=sipmRouteEntry, configPowerAc1=configPowerAc1, atextportZonePort=atextportZonePort, sysTrapPort=sysTrapPort, sipxSapNetwork=sipxSapNetwork, sprotoArpProxy=sprotoArpProxy, sfddiSMTBufferSize=sfddiSMTBufferSize, straceMaxTTL=straceMaxTTL, sipxSapIndex=sipxSapIndex, straceNMSAddr=straceNMSAddr, hwAddr3=hwAddr3, debugBase=debugBase, sifUtilInterval=sifUtilInterval, filterFrame=filterFrame, sipmInBadPackets=sipmInBadPackets, straceState=straceState, ppe=ppe, sipxRouteTickCount=sipxRouteTickCount, spvcCircuitTX=spvcCircuitTX, ppeAresAsStes=ppeAresAsStes, sprotoAllTranslate=sprotoAllTranslate, nbCacheifTable=nbCacheifTable, ppeSmlUxRxCnt=ppeSmlUxRxCnt, sprotoEgp=sprotoEgp, hwEntry=hwEntry, sipxIfOutRipPkts=sipxIfOutRipPkts, sipmStatTable=sipmStatTable, sfddiEntry=sfddiEntry, sfddiSrfConditions=sfddiSrfConditions, ruleFilterTcpFragment=ruleFilterTcpFragment, atextsystem=atextsystem, sWorkGroupNextNumber=sWorkGroupNextNumber, igmpCacheStatus=igmpCacheStatus, srtb=srtb, smirrorDiagPort=smirrorDiagPort, ipMRouteMIB=ipMRouteMIB, sifUtilPortPeakOrdinal=sifUtilPortPeakOrdinal, sipxDiscardedServices=sipxDiscardedServices, ppeCpuUtilization=ppeCpuUtilization, swanIndex=swanIndex, sipxsfEntry=sipxsfEntry, sifTxDests=sifTxDests, filterNextID=filterNextID, sipxsfFilterType=sipxsfFilterType, strapEnabled=strapEnabled, sifTxStormTime=sifTxStormTime, strapEntryIndex=strapEntryIndex, atextportZoneName=atextportZoneName, lpbkIndex=lpbkIndex, slogTrap=slogTrap, addrPort=addrPort, lpbkDestAddr=lpbkDestAddr, hwDefPortType=hwDefPortType, sifThreshold=sifThreshold, rebootUseMod=rebootUseMod, hwFirstPort=hwFirstPort, hwPortType=hwPortType)

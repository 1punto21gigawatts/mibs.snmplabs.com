#
# PySNMP MIB module SWL3MGMT-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/SWL3MGMT-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:13:38 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, SingleValueConstraint, ConstraintsUnion, ConstraintsIntersection, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsUnion", "ConstraintsIntersection", "ValueSizeConstraint")
ifIndex, = mibBuilder.importSymbols("IF-MIB", "ifIndex")
Metric, AreaID, TOSType = mibBuilder.importSymbols("OSPF-MIB", "Metric", "AreaID", "TOSType")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
ModuleIdentity, IpAddress, TimeTicks, Unsigned32, MibScalar, MibTable, MibTableRow, MibTableColumn, ObjectIdentity, MibIdentifier, Gauge32, Counter32, iso, Counter64, Integer32, NotificationType, Bits = mibBuilder.importSymbols("SNMPv2-SMI", "ModuleIdentity", "IpAddress", "TimeTicks", "Unsigned32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ObjectIdentity", "MibIdentifier", "Gauge32", "Counter32", "iso", "Counter64", "Integer32", "NotificationType", "Bits")
TruthValue, DisplayString, TextualConvention, PhysAddress, RowStatus, TimeStamp, MacAddress = mibBuilder.importSymbols("SNMPv2-TC", "TruthValue", "DisplayString", "TextualConvention", "PhysAddress", "RowStatus", "TimeStamp", "MacAddress")
privateMgmt, = mibBuilder.importSymbols("SWPRIMGMT-MIB", "privateMgmt")
swL3MgmtMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3))
if mibBuilder.loadTexts: swL3MgmtMIB.setLastUpdated('0007150000Z')
if mibBuilder.loadTexts: swL3MgmtMIB.setOrganization('enterprise, Inc.')
if mibBuilder.loadTexts: swL3MgmtMIB.setContactInfo(' Customer Service Postal: Tel: E-mail: ')
if mibBuilder.loadTexts: swL3MgmtMIB.setDescription('The Structure of Layer 3 Network Management Information for the proprietary enterprise.')
class NodeAddress(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(6, 6)
    fixedLength = 6

class NetAddress(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(4, 4)
    fixedLength = 4

swL3DevMgmt = MibIdentifier((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 1))
swL3IpMgmt = MibIdentifier((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 2))
swL3RelayMgmt = MibIdentifier((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 3))
swL3IpCtrlMgmt = MibIdentifier((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 2, 1))
swL3IpFdbMgmt = MibIdentifier((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 2, 2))
swL3IpFilterMgmt = MibIdentifier((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 2, 3))
swL3RelayBootpMgmt = MibIdentifier((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 3, 1))
swL3RelayDnsMgmt = MibIdentifier((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 3, 2))
swL3DevCtrl = MibIdentifier((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 1, 1))
swL3DevCtrlRIPState = MibScalar((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3DevCtrlRIPState.setStatus('current')
if mibBuilder.loadTexts: swL3DevCtrlRIPState.setDescription('This object indicates Routing Information Protocol (RIP) version 2 function is enabled or disabled.')
swL3DevCtrlOSPFState = MibScalar((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3DevCtrlOSPFState.setStatus('current')
if mibBuilder.loadTexts: swL3DevCtrlOSPFState.setDescription('This object indicates OSPF protocol is enabled or disabled.')
swL3DevCtrlDVMRPState = MibScalar((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3DevCtrlDVMRPState.setStatus('current')
if mibBuilder.loadTexts: swL3DevCtrlDVMRPState.setDescription('This object indicates DVMRP protocol is enabled or disabled.')
swL3DevCtrlVRRPState = MibScalar((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3DevCtrlVRRPState.setStatus('current')
if mibBuilder.loadTexts: swL3DevCtrlVRRPState.setDescription('This object indicates VRRP protocol is enabled or disabled.')
swL3DevCtrlVRRPPingVirtualAddrState = MibScalar((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3DevCtrlVRRPPingVirtualAddrState.setStatus('current')
if mibBuilder.loadTexts: swL3DevCtrlVRRPPingVirtualAddrState.setDescription('This object let host can ping the virtual ip address or not. Default is disabled(2).')
swL3IpCtrlTable = MibTable((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 2, 1, 1), )
if mibBuilder.loadTexts: swL3IpCtrlTable.setStatus('current')
if mibBuilder.loadTexts: swL3IpCtrlTable.setDescription('This table contain IP interface information.')
swL3IpCtrlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 2, 1, 1, 1), ).setIndexNames((0, "SWL3MGMT-MIB", "swL3IpCtrlInterfaceName"))
if mibBuilder.loadTexts: swL3IpCtrlEntry.setStatus('current')
if mibBuilder.loadTexts: swL3IpCtrlEntry.setDescription('A list of information about a specific IP interface.')
swL3IpCtrlInterfaceName = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 2, 1, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3IpCtrlInterfaceName.setStatus('current')
if mibBuilder.loadTexts: swL3IpCtrlInterfaceName.setDescription('This object indicates the name of the IP interface.')
swL3IpCtrlIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 2, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3IpCtrlIfIndex.setStatus('current')
if mibBuilder.loadTexts: swL3IpCtrlIfIndex.setDescription('This object uniquely identifies the IP interface number in the swL3IpCtrlTable.')
swL3IpCtrlIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 2, 1, 1, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3IpCtrlIpAddr.setStatus('current')
if mibBuilder.loadTexts: swL3IpCtrlIpAddr.setDescription('The IP address of the interface. This object only can take the value of the unicast IP address.')
swL3IpCtrlIpSubnetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 2, 1, 1, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3IpCtrlIpSubnetMask.setStatus('current')
if mibBuilder.loadTexts: swL3IpCtrlIpSubnetMask.setDescription('The IP net mask for this interface.')
swL3IpCtrlVlanName = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 2, 1, 1, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3IpCtrlVlanName.setStatus('current')
if mibBuilder.loadTexts: swL3IpCtrlVlanName.setDescription("This object indicates the IP control entry's VLAN name. The VLAN name in each entry must be unique in the IP Control Table.")
swL3IpCtrlMode = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 2, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("manual", 2), ("bootp", 3), ("dhcp", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3IpCtrlMode.setStatus('current')
if mibBuilder.loadTexts: swL3IpCtrlMode.setDescription('This object indicates the IP operation mode. other(1) - this entry is currently in use but the conditions under which it will remain so are different from each of the following values. manual(2) - the IP address will be set by manual. bootp(3) - the IP address will be set automatically from BOOTP server. dhcp(4) - the IP address will be set automatically from DHCP server.')
swL3IpCtrlState = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 2, 1, 1, 1, 7), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: swL3IpCtrlState.setStatus('current')
if mibBuilder.loadTexts: swL3IpCtrlState.setDescription('This variable displays the status of the entry. The status used for creating, modifying, and deleting instances of the objects in this table.')
swL3IpCtrlOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 2, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("up", 2), ("down", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3IpCtrlOperState.setStatus('current')
if mibBuilder.loadTexts: swL3IpCtrlOperState.setDescription('The current operational state of the IP interface.')
swL3IpFdbInfoTable = MibTable((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 2, 2, 1), )
if mibBuilder.loadTexts: swL3IpFdbInfoTable.setStatus('current')
if mibBuilder.loadTexts: swL3IpFdbInfoTable.setDescription('A table that contains forwarding and/or filtering information. This information is used by the switch in determining how to propagate the received IP packets.')
swL3IpFdbInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 2, 2, 1, 1), ).setIndexNames((0, "SWL3MGMT-MIB", "swL3IpFdbInfoIpAddr"))
if mibBuilder.loadTexts: swL3IpFdbInfoEntry.setStatus('current')
if mibBuilder.loadTexts: swL3IpFdbInfoEntry.setDescription('Information about a specific IP address for which the bridge has some forwarding and/or filtering information.')
swL3IpFdbInfoIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 2, 2, 1, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3IpFdbInfoIpAddr.setStatus('current')
if mibBuilder.loadTexts: swL3IpFdbInfoIpAddr.setDescription('A IP address for which switch has forwarding and/or filtering information.')
swL3IpFdbInfoIpSubnetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 2, 2, 1, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3IpFdbInfoIpSubnetMask.setStatus('current')
if mibBuilder.loadTexts: swL3IpFdbInfoIpSubnetMask.setDescription('A IP net mask for this interface.for which switch has forwarding and/or filtering information.')
swL3IpFdbInfoPort = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 2, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3IpFdbInfoPort.setStatus('current')
if mibBuilder.loadTexts: swL3IpFdbInfoPort.setDescription("Either the value '0', or the port number of the port on which packet having a IP address equal to the value of the corresponding instance of swL3IpFdbInfoIpAddr has been seen. A value of '0' indicates that the port number has not been learned but that switch does have some forwarding/filtering information about this address.")
swL3IpFdbInfoType = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 2, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("static", 2), ("dynamic", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3IpFdbInfoType.setStatus('current')
if mibBuilder.loadTexts: swL3IpFdbInfoType.setDescription('The status of this entry.')
swL3IpFilterAddrConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 2, 3, 1))
swL3IpFilterAddrMaxSupportedEntries = MibScalar((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3IpFilterAddrMaxSupportedEntries.setStatus('current')
if mibBuilder.loadTexts: swL3IpFilterAddrMaxSupportedEntries.setDescription('Maximum number of entries in the IP address filtering table (swL3IpFilterAddrCtrlTable) .')
swL3IpFilterAddrCurrentTotalEntries = MibScalar((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 2, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3IpFilterAddrCurrentTotalEntries.setStatus('current')
if mibBuilder.loadTexts: swL3IpFilterAddrCurrentTotalEntries.setDescription('Current applied number of entries in the IP address filtering table. If the swL3IpFilterAddrCtrlState = dst-src-addr, then it means there are two entries in swL3IpFilterAddrCtrlTable.')
swL3IpFilterAddrCtrlTable = MibTable((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 2, 3, 1, 3), )
if mibBuilder.loadTexts: swL3IpFilterAddrCtrlTable.setStatus('current')
if mibBuilder.loadTexts: swL3IpFilterAddrCtrlTable.setDescription('This table defines information for the device to filter packets with specific IP address (either as the DA and/or as the SA). The IP address can be a unicast address or multicast address. This table has higher priority than both static FDB table and IGMP table. It means that if a IP address appears on this table also appears on the static FDB table, the device will use the information provide by this table to process the packet.')
swL3IpFilterAddrCtrlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 2, 3, 1, 3, 1), ).setIndexNames((0, "SWL3MGMT-MIB", "swL3IpFilterAddrIpAddr"))
if mibBuilder.loadTexts: swL3IpFilterAddrCtrlEntry.setStatus('current')
if mibBuilder.loadTexts: swL3IpFilterAddrCtrlEntry.setDescription('A list of information about a specific unicast/multicast IP address for which the switch has filtering information.')
swL3IpFilterAddrIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 2, 3, 1, 3, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3IpFilterAddrIpAddr.setStatus('current')
if mibBuilder.loadTexts: swL3IpFilterAddrIpAddr.setDescription('This object indicates a unicast/multicast IP address for which the switch has filtering information. But if the swL3IpFilterAddrCtrlState = src-addr, then the object can not be a multicast IP address (Class D IP address).')
swL3IpFilterAddrCtrlState = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 2, 3, 1, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("dst-addr", 2), ("src-addr", 3), ("dst-src-addr", 4), ("invalid", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3IpFilterAddrCtrlState.setStatus('current')
if mibBuilder.loadTexts: swL3IpFilterAddrCtrlState.setDescription("This object indicates the status of this entry. other(1) - this entry is currently in use but the conditions under which it will remain so are different from each of the following values. dst-addr(2) - recieved frames's destination address are currently used to be filtered as it meets with the IP address entry of the table. src-addr(3) - recieved frames's source address are currently used to be filtered as it meets with the IP address entry of the table. dst-src-addr(4) - recieved frames's destination address or source address are currently used to be filtered as it meets with the IP address entry of the table. invalid(5) - writing this value to the object, and then the corresponding entry will be removed from the table.")
swL3IpArpAgingTime = MibScalar((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 2, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3IpArpAgingTime.setStatus('current')
if mibBuilder.loadTexts: swL3IpArpAgingTime.setDescription('The timeout period in minutes for aging out dynamically learned arp information.')
swL3IpStaticRouteTable = MibTable((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 2, 5), )
if mibBuilder.loadTexts: swL3IpStaticRouteTable.setStatus('current')
if mibBuilder.loadTexts: swL3IpStaticRouteTable.setDescription("This entity's IP static Routing table.")
swL3IpStaticRouteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 2, 5, 1), ).setIndexNames((0, "SWL3MGMT-MIB", "swL3IpStaticRouteDest"), (0, "SWL3MGMT-MIB", "swL3IpStaticRouteMask"), (0, "SWL3MGMT-MIB", "swL3IpStaticRouteNextHop"))
if mibBuilder.loadTexts: swL3IpStaticRouteEntry.setStatus('current')
if mibBuilder.loadTexts: swL3IpStaticRouteEntry.setDescription('A particular route to a particular destination, under a particular policy.')
swL3IpStaticRouteDest = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 2, 5, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3IpStaticRouteDest.setStatus('current')
if mibBuilder.loadTexts: swL3IpStaticRouteDest.setDescription('The destination IP address of this route. This object may not take a Multicast (Class D) address value. Any assignment (implicit or otherwise) of an instance of this object to a value x must be rejected if the bitwise logical-AND of x with the value of the corresponding instance of the swL3IpStaticRouteMask object is not equal to x.')
swL3IpStaticRouteMask = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 2, 5, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3IpStaticRouteMask.setStatus('current')
if mibBuilder.loadTexts: swL3IpStaticRouteMask.setDescription('Indicate the mask to be logical-ANDed with the destination address before being compared to the value in the swL3IpStaticRouteDest field. For those systems that do not support arbitrary subnet masks, an agent constructs the value of the swL3IpStaticRouteMask by reference to the IP Address Class. Any assignment (implicit or otherwise) of an instance of this object to a value x must be rejected if the bitwise logical-AND of x with the value of the corresponding instance of the swL3IpStaticRouteDest object is not equal to swL3IpStaticRouteDest.')
swL3IpStaticRouteNextHop = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 2, 5, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3IpStaticRouteNextHop.setStatus('current')
if mibBuilder.loadTexts: swL3IpStaticRouteNextHop.setDescription('On remote routes, the address of the next sys- tem en route; Otherwise, 0.0.0.0.')
swL3IpStaticRouteMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 2, 5, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: swL3IpStaticRouteMetric.setStatus('current')
if mibBuilder.loadTexts: swL3IpStaticRouteMetric.setDescription('The routing metric for this route.')
swL3IpStaticRouteStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 2, 5, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("invalid", 2), ("valid", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: swL3IpStaticRouteStatus.setStatus('current')
if mibBuilder.loadTexts: swL3IpStaticRouteStatus.setDescription('This object indicates the status of this entry. other(1) - this entry is currently in use but the conditions under which it will remain so are different from each of the following values. invalid(2) - writing this value to the object, and then the corresponding entry will be removed from the table. valid(3) - this entry is reside in the table.')
swL3IpArpTable = MibTable((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 2, 6), )
if mibBuilder.loadTexts: swL3IpArpTable.setStatus('current')
if mibBuilder.loadTexts: swL3IpArpTable.setDescription('The ARP table used for mapping from IP addresses to physical addresses.')
swL3IpArpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 2, 6, 1), ).setIndexNames((0, "SWL3MGMT-MIB", "swL3IpArpIfIndex"), (0, "SWL3MGMT-MIB", "swL3IpArpNetAddress"))
if mibBuilder.loadTexts: swL3IpArpEntry.setStatus('current')
if mibBuilder.loadTexts: swL3IpArpEntry.setDescription("Each entry contains one IpAddress to `physical' address equivalence.")
swL3IpArpIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 2, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3IpArpIfIndex.setStatus('current')
if mibBuilder.loadTexts: swL3IpArpIfIndex.setDescription("The interface on which this entry's equivalence is effective. The interface identified by a particular value of this index is the same interface as identified by the same value of ifIndex.")
swL3IpArpNetAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 2, 6, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3IpArpNetAddress.setStatus('current')
if mibBuilder.loadTexts: swL3IpArpNetAddress.setDescription("The IpAddress corresponding to the media-dependent `physical' address.")
swL3IpArpPhysAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 2, 6, 1, 3), MacAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: swL3IpArpPhysAddress.setStatus('current')
if mibBuilder.loadTexts: swL3IpArpPhysAddress.setDescription("The media-dependent `physical' address.")
swL3IpArpType = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 2, 6, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("invalid", 2), ("dynamic", 3), ("static", 4), ("local", 5), ("local-broadcast", 6)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: swL3IpArpType.setStatus('current')
if mibBuilder.loadTexts: swL3IpArpType.setDescription('The type of mapping. Setting this object to the value invalid(2) has the effect of invalidating the corresponding entry in the swL3IpArpTable. That is, it effectively dissasociates the interface identified with said entry from the mapping identified with said entry. It is an implementation-specific matter as to whether the agent removes an invalidated entry from the table. Accordingly, management stations must be prepared to receive tabular information from agents that corresponds to entries not currently in use. Proper interpretation of such entries requires examination of the relevant swL3IpArpType object.')
swL3IpArpDynamicAgingTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 2, 6, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3IpArpDynamicAgingTime.setStatus('current')
if mibBuilder.loadTexts: swL3IpArpDynamicAgingTime.setDescription('The timeout period in seconds for aging out dynamically learned arp information. If the swL3IpArpType is not dynamic(3), this object will display zero.')
swL3IpArpReqRateLimitState = MibScalar((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 2, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3IpArpReqRateLimitState.setStatus('current')
if mibBuilder.loadTexts: swL3IpArpReqRateLimitState.setDescription('To enable limit ARP requests trapped to CPU or disabled.')
swL3IpArpReqRateLimitValue = MibScalar((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 2, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 100)).clone(50)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3IpArpReqRateLimitValue.setStatus('current')
if mibBuilder.loadTexts: swL3IpArpReqRateLimitValue.setDescription('To configure how much frames per second that ARP request limit. This value will be usefull only when swL3IpArpReqRateLimitState is enabled.')
swL3RelayBootpState = MibScalar((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3RelayBootpState.setStatus('current')
if mibBuilder.loadTexts: swL3RelayBootpState.setDescription('This object indicates BOOTP Relay function is enabled or disabled.')
swL3RelayBootpHopCount = MibScalar((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3RelayBootpHopCount.setStatus('current')
if mibBuilder.loadTexts: swL3RelayBootpHopCount.setDescription('This object indicates the maximum number of router hops that the BOOTP packets can cross.')
swL3RelayBootpTimeThreshold = MibScalar((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3RelayBootpTimeThreshold.setStatus('current')
if mibBuilder.loadTexts: swL3RelayBootpTimeThreshold.setDescription('This object indicates the minimum time in seconds within which the switch must relay the BOOTP request. If this time is exceeded, the switch will drop the BOOTP packet.')
swL3RelayBootpCtrlTable = MibTable((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 3, 1, 4), )
if mibBuilder.loadTexts: swL3RelayBootpCtrlTable.setStatus('current')
if mibBuilder.loadTexts: swL3RelayBootpCtrlTable.setDescription('This table specifys the IP address as a destination to forward (relay) BOOTP packets to.')
swL3RelayBootpCtrlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 3, 1, 4, 1), ).setIndexNames((0, "SWL3MGMT-MIB", "swL3RelayBootpCtrlInterfaceName"), (0, "SWL3MGMT-MIB", "swL3RelayBootpCtrlServer"))
if mibBuilder.loadTexts: swL3RelayBootpCtrlEntry.setStatus('current')
if mibBuilder.loadTexts: swL3RelayBootpCtrlEntry.setDescription('A list of information specifies the IP address as a destination to forward (relay) BOOTP packets to.')
swL3RelayBootpCtrlInterfaceName = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 3, 1, 4, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3RelayBootpCtrlInterfaceName.setStatus('current')
if mibBuilder.loadTexts: swL3RelayBootpCtrlInterfaceName.setDescription('The name of the IP interface.')
swL3RelayBootpCtrlServer = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 3, 1, 4, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3RelayBootpCtrlServer.setStatus('current')
if mibBuilder.loadTexts: swL3RelayBootpCtrlServer.setDescription('The BOOTP server IP address.')
swL3RelayBootpCtrlState = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 3, 1, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("invalid", 2), ("valid", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3RelayBootpCtrlState.setStatus('current')
if mibBuilder.loadTexts: swL3RelayBootpCtrlState.setDescription('This object indicates the status of this entry. other(1) - this entry is currently in use but the conditions under which it will remain so are different from each of the following values. invalid(2) - writing this value to the object, and then the corresponding entry will be removed from the table. valid(3) - this entry is reside in the table.')
swL3RelayDnsState = MibScalar((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 3, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3RelayDnsState.setStatus('current')
if mibBuilder.loadTexts: swL3RelayDnsState.setDescription('This object indicates DNS Relay function is enabled or disabled.')
swL3RelayDnsPrimaryServer = MibScalar((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 3, 2, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3RelayDnsPrimaryServer.setStatus('current')
if mibBuilder.loadTexts: swL3RelayDnsPrimaryServer.setDescription('This object indicates the address of the primary DNS server.')
swL3RelayDnsSecondaryServer = MibScalar((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 3, 2, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3RelayDnsSecondaryServer.setStatus('current')
if mibBuilder.loadTexts: swL3RelayDnsSecondaryServer.setDescription('This object indicates the address of the secondary DNS server.')
swL3RelayDnsCacheState = MibScalar((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 3, 2, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3RelayDnsCacheState.setStatus('current')
if mibBuilder.loadTexts: swL3RelayDnsCacheState.setDescription('This object indicates DNS Relay cache is enabled or disabled.')
swL3RelayDnsStaticTableState = MibScalar((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 3, 2, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3RelayDnsStaticTableState.setStatus('current')
if mibBuilder.loadTexts: swL3RelayDnsStaticTableState.setDescription('This object indicates DNS Relay static table is enabled or disabled.')
swL3RelayDnsCtrlTable = MibTable((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 3, 2, 6), )
if mibBuilder.loadTexts: swL3RelayDnsCtrlTable.setStatus('current')
if mibBuilder.loadTexts: swL3RelayDnsCtrlTable.setDescription('This table display the current DNS relay static table.')
swL3RelayDnsCtrlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 3, 2, 6, 1), ).setIndexNames((0, "SWL3MGMT-MIB", "swL3RelayDnsCtrlDomainName"), (0, "SWL3MGMT-MIB", "swL3RelayDnsCtrlIpAddr"))
if mibBuilder.loadTexts: swL3RelayDnsCtrlEntry.setStatus('current')
if mibBuilder.loadTexts: swL3RelayDnsCtrlEntry.setDescription('A list of information display the current DNS relay static table.')
swL3RelayDnsCtrlDomainName = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 3, 2, 6, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3RelayDnsCtrlDomainName.setStatus('current')
if mibBuilder.loadTexts: swL3RelayDnsCtrlDomainName.setDescription('The domain name of the entry.')
swL3RelayDnsCtrlIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 3, 2, 6, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3RelayDnsCtrlIpAddr.setStatus('current')
if mibBuilder.loadTexts: swL3RelayDnsCtrlIpAddr.setDescription('The IP address of the entry.')
swL3RelayDnsCtrlState = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 3, 2, 6, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("invalid", 2), ("valid", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3RelayDnsCtrlState.setStatus('current')
if mibBuilder.loadTexts: swL3RelayDnsCtrlState.setDescription('This object indicates the status of this entry. other(1) - this entry is currently in use but the conditions under which it will remain so are different from each of the following values. invalid(2) - writing this value to the object, and then the corresponding entry will be removed from the table. valid(3) - this entry is reside in the table.')
swL3Md5Table = MibTable((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 4), )
if mibBuilder.loadTexts: swL3Md5Table.setStatus('current')
if mibBuilder.loadTexts: swL3Md5Table.setDescription('This table display the current MD5 key table.')
swL3Md5Entry = MibTableRow((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 4, 1), ).setIndexNames((0, "SWL3MGMT-MIB", "swL3Md5KeyId"))
if mibBuilder.loadTexts: swL3Md5Entry.setStatus('current')
if mibBuilder.loadTexts: swL3Md5Entry.setDescription('A list of information display the current MD5 key table.')
swL3Md5KeyId = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3Md5KeyId.setStatus('current')
if mibBuilder.loadTexts: swL3Md5KeyId.setDescription('The MD5 key ID.')
swL3Md5Key = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 4, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3Md5Key.setStatus('current')
if mibBuilder.loadTexts: swL3Md5Key.setDescription('An MD5 password of up to 16 bytes.')
swL3Md5State = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("invalid", 2), ("valid", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3Md5State.setStatus('current')
if mibBuilder.loadTexts: swL3Md5State.setDescription('This object indicates the status of this entry. other(1) - this entry is currently in use but the conditions under which it will remain so are different from each of the following values. invalid(2) - writing this value to the object, and then the corresponding entry will be removed from the table. valid(3) - this entry is reside in the table.')
swL3RouteRedistriTable = MibTable((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 5), )
if mibBuilder.loadTexts: swL3RouteRedistriTable.setStatus('current')
if mibBuilder.loadTexts: swL3RouteRedistriTable.setDescription('Route redistribution allows routers on the network. That are running different routing protocols to exchange routing information. This is accomplished by comparing the routes stored in the vairous routers routing tables and assinging appropriate metrics. This information is then exchanged among the various routers according to the individual routers current routing protocol.')
swL3RouteRedistriEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 5, 1), ).setIndexNames((0, "SWL3MGMT-MIB", "swL3RouteRedistriSrcProtocol"), (0, "SWL3MGMT-MIB", "swL3RouteRedistriDstProtocol"))
if mibBuilder.loadTexts: swL3RouteRedistriEntry.setStatus('current')
if mibBuilder.loadTexts: swL3RouteRedistriEntry.setDescription('A list of information display the route redistribution table.')
swL3RouteRedistriSrcProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 5, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("rip", 2), ("ospf", 3), ("static", 4), ("local", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3RouteRedistriSrcProtocol.setStatus('current')
if mibBuilder.loadTexts: swL3RouteRedistriSrcProtocol.setDescription('Allows the selection of the protocol of the source device.')
swL3RouteRedistriDstProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("rip", 2), ("ospf", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3RouteRedistriDstProtocol.setStatus('current')
if mibBuilder.loadTexts: swL3RouteRedistriDstProtocol.setDescription('Allows the selection of the protocol of the destination device.')
swL3RouteRedistriType = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("other", 1), ("all", 2), ("type-1", 3), ("type-2", 4), ("internal", 5), ("external", 6), ("inter-E1", 7), ("inter-E2", 8), ("extType1", 9), ("extType2", 10)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3RouteRedistriType.setStatus('current')
if mibBuilder.loadTexts: swL3RouteRedistriType.setDescription('Allows the selection of one of the methods for calcalculating the metric value.')
swL3RouteRedistriMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 5, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777214))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3RouteRedistriMetric.setStatus('current')
if mibBuilder.loadTexts: swL3RouteRedistriMetric.setDescription("Allows the entry of an OSPF interface cost. This is analogous to a Hop Count in the RIP routing protocol. The value '0' indicates default value.")
swL3RouteRedistriState = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 5, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("invalid", 2), ("valid", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3RouteRedistriState.setStatus('current')
if mibBuilder.loadTexts: swL3RouteRedistriState.setDescription('This object indicates the status of this entry. other(1) - this entry is currently in use but the conditions under which it will remain so are different from each of the following values. invalid(2) - writing this value to the object, and then the corresponding entry will be removed from the table. valid(3) - this entry is reside in the table.')
swL3OspfHostTable = MibTable((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 6), )
if mibBuilder.loadTexts: swL3OspfHostTable.setStatus('current')
if mibBuilder.loadTexts: swL3OspfHostTable.setDescription('The list of Hosts, and their metrics, that the router will advertise as host routes.')
swL3OspfHostEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 6, 1), ).setIndexNames((0, "SWL3MGMT-MIB", "swL3OspfHostIpAddress"), (0, "SWL3MGMT-MIB", "swL3OspfHostTOS"))
if mibBuilder.loadTexts: swL3OspfHostEntry.setStatus('current')
if mibBuilder.loadTexts: swL3OspfHostEntry.setDescription('A metric to be advertised, for a given type of service, when a given host is reachable.')
swL3OspfHostIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 6, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3OspfHostIpAddress.setStatus('current')
if mibBuilder.loadTexts: swL3OspfHostIpAddress.setDescription('The IP Address of the Host.')
swL3OspfHostTOS = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 6, 1, 2), TOSType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3OspfHostTOS.setStatus('current')
if mibBuilder.loadTexts: swL3OspfHostTOS.setDescription('The Type of Service of the route being configured.')
swL3OspfHostMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 6, 1, 3), Metric()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3OspfHostMetric.setStatus('current')
if mibBuilder.loadTexts: swL3OspfHostMetric.setDescription('The Metric to be advertised.')
swL3OspfHostStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 6, 1, 4), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3OspfHostStatus.setStatus('current')
if mibBuilder.loadTexts: swL3OspfHostStatus.setDescription("This variable displays the status of the entry. Setting it to 'invalid' has the effect of rendering it inoperative. The internal effect (row removal) is implementation dependent.")
swL3OspfHostAreaID = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 6, 1, 5), AreaID()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3OspfHostAreaID.setStatus('current')
if mibBuilder.loadTexts: swL3OspfHostAreaID.setDescription('The Area the Host Entry is to be found within. By default, the area that a subsuming OSPF interface is in, or 0.0.0.0')
swL3VrrpMgmt = MibIdentifier((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 7))
swL3VrrpOperTable = MibTable((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 7, 1), )
if mibBuilder.loadTexts: swL3VrrpOperTable.setStatus('current')
if mibBuilder.loadTexts: swL3VrrpOperTable.setDescription("Operations table for a VRRP router which consists of a sequence (i.e., one or more conceptual rows) of 'swL3VrrpOperEntry' items.")
swL3VrrpOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 7, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "SWL3MGMT-MIB", "swL3VrrpOperVrId"))
if mibBuilder.loadTexts: swL3VrrpOperEntry.setStatus('current')
if mibBuilder.loadTexts: swL3VrrpOperEntry.setDescription('An entry in the swL3VrrpOperTable containing the operational characteristics of a virtual router. On a VRRP router, a given virtual router is identified by a combination of the IF index and VRID.')
swL3VrrpOperVrId = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 7, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)))
if mibBuilder.loadTexts: swL3VrrpOperVrId.setStatus('current')
if mibBuilder.loadTexts: swL3VrrpOperVrId.setDescription('This object contains the Virtual Router Identifier (VRID).')
swL3VrrpOperCriticalIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 7, 1, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3VrrpOperCriticalIpAddr.setStatus('current')
if mibBuilder.loadTexts: swL3VrrpOperCriticalIpAddr.setDescription('To make sure the ip interface connected by this virtual router is alive or not.')
swL3VrrpOperCriticalIpState = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 7, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3VrrpOperCriticalIpState.setStatus('current')
if mibBuilder.loadTexts: swL3VrrpOperCriticalIpState.setDescription('To enable or disable the feature of critical IP.')
swL3VrrpOperHoldDownTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 7, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 21600))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3VrrpOperHoldDownTimer.setStatus('current')
if mibBuilder.loadTexts: swL3VrrpOperHoldDownTimer.setDescription('When VRRP is started, it need to spend this period of time to let the routing would be leared as well. The unit of this object is second.')
swL3RoutePrefTable = MibTable((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 8), )
if mibBuilder.loadTexts: swL3RoutePrefTable.setStatus('current')
if mibBuilder.loadTexts: swL3RoutePrefTable.setDescription('IP Route Pref table.')
swL3RoutePrefEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 8, 1), ).setIndexNames((0, "SWL3MGMT-MIB", "swL3RoutePrefProtocol"))
if mibBuilder.loadTexts: swL3RoutePrefEntry.setStatus('current')
if mibBuilder.loadTexts: swL3RoutePrefEntry.setDescription('An entry of Ip Route Pref Table.')
swL3RoutePrefProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 8, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("isis", 1), ("rip", 2), ("ospfIntra", 3), ("static", 4), ("local", 5), ("bgp", 6), ("staticLow", 7), ("ospfInter", 8), ("ospfExternal", 9), ("ospfExternal1", 10), ("ospfExternal2", 11), ("ospfNssa1", 12), ("ospfNssa2", 13)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3RoutePrefProtocol.setStatus('current')
if mibBuilder.loadTexts: swL3RoutePrefProtocol.setDescription('Protocol')
swL3RoutePrefValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 8, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 999))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3RoutePrefValue.setStatus('current')
if mibBuilder.loadTexts: swL3RoutePrefValue.setDescription('This value is a preference value for the given protocol.')
swL3DvmrpInterfaceTable = MibTable((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 9), )
if mibBuilder.loadTexts: swL3DvmrpInterfaceTable.setStatus('current')
if mibBuilder.loadTexts: swL3DvmrpInterfaceTable.setDescription("The (conceptual) table listing the router's multicast- capable interfaces.")
swL3DvmrpInterfaceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 9, 1), ).setIndexNames((0, "SWL3MGMT-MIB", "swL3DvmrpInterfaceIfIndex"))
if mibBuilder.loadTexts: swL3DvmrpInterfaceEntry.setStatus('current')
if mibBuilder.loadTexts: swL3DvmrpInterfaceEntry.setDescription('An entry (conceptual row) in the swL3DvmrpInterfaceTable.')
swL3DvmrpInterfaceIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 9, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: swL3DvmrpInterfaceIfIndex.setStatus('current')
if mibBuilder.loadTexts: swL3DvmrpInterfaceIfIndex.setDescription('The ifIndex value of the interface for which DVMRP is enabled.')
swL3DvmrpInterfaceNeighborTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 9, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(35)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3DvmrpInterfaceNeighborTimeout.setStatus('current')
if mibBuilder.loadTexts: swL3DvmrpInterfaceNeighborTimeout.setDescription('The time period for DVMRP will hold Neithbor Router reports before issuing poison route messages. The unit is second.')
swL3DvmrpInterfaceProbe = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 201, 1, 3, 9, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3DvmrpInterfaceProbe.setStatus('current')
if mibBuilder.loadTexts: swL3DvmrpInterfaceProbe.setDescription("DVMRP defines an extension to IGMP that allows routers to query other routers to determine if a multicast group is present on an given router subnetwork or not. This is referred to as a 'probe'. The unit is second.")
mibBuilder.exportSymbols("SWL3MGMT-MIB", swL3DevCtrlVRRPState=swL3DevCtrlVRRPState, swL3IpFilterAddrCtrlTable=swL3IpFilterAddrCtrlTable, swL3RelayBootpCtrlState=swL3RelayBootpCtrlState, swL3DevCtrlRIPState=swL3DevCtrlRIPState, swL3DevMgmt=swL3DevMgmt, swL3RouteRedistriType=swL3RouteRedistriType, swL3DevCtrl=swL3DevCtrl, swL3IpStaticRouteEntry=swL3IpStaticRouteEntry, swL3IpStaticRouteStatus=swL3IpStaticRouteStatus, swL3RoutePrefValue=swL3RoutePrefValue, swL3RelayDnsCtrlIpAddr=swL3RelayDnsCtrlIpAddr, swL3VrrpOperCriticalIpState=swL3VrrpOperCriticalIpState, swL3IpFdbInfoIpSubnetMask=swL3IpFdbInfoIpSubnetMask, swL3RelayDnsCtrlDomainName=swL3RelayDnsCtrlDomainName, NetAddress=NetAddress, swL3IpArpPhysAddress=swL3IpArpPhysAddress, swL3RelayBootpCtrlInterfaceName=swL3RelayBootpCtrlInterfaceName, swL3RelayDnsPrimaryServer=swL3RelayDnsPrimaryServer, swL3OspfHostTOS=swL3OspfHostTOS, swL3IpArpNetAddress=swL3IpArpNetAddress, swL3RoutePrefEntry=swL3RoutePrefEntry, swL3RelayBootpCtrlEntry=swL3RelayBootpCtrlEntry, swL3IpArpIfIndex=swL3IpArpIfIndex, swL3OspfHostMetric=swL3OspfHostMetric, swL3IpCtrlState=swL3IpCtrlState, swL3VrrpMgmt=swL3VrrpMgmt, swL3IpCtrlInterfaceName=swL3IpCtrlInterfaceName, swL3RelayDnsCtrlTable=swL3RelayDnsCtrlTable, swL3IpFilterMgmt=swL3IpFilterMgmt, swL3DvmrpInterfaceEntry=swL3DvmrpInterfaceEntry, swL3RelayDnsCtrlEntry=swL3RelayDnsCtrlEntry, swL3IpCtrlOperState=swL3IpCtrlOperState, swL3IpFdbMgmt=swL3IpFdbMgmt, swL3OspfHostTable=swL3OspfHostTable, swL3IpCtrlEntry=swL3IpCtrlEntry, swL3RoutePrefProtocol=swL3RoutePrefProtocol, swL3VrrpOperCriticalIpAddr=swL3VrrpOperCriticalIpAddr, swL3Md5State=swL3Md5State, swL3IpCtrlMode=swL3IpCtrlMode, swL3IpCtrlIfIndex=swL3IpCtrlIfIndex, swL3RelayMgmt=swL3RelayMgmt, swL3Md5Key=swL3Md5Key, swL3IpFilterAddrCurrentTotalEntries=swL3IpFilterAddrCurrentTotalEntries, swL3VrrpOperEntry=swL3VrrpOperEntry, swL3Md5Table=swL3Md5Table, swL3MgmtMIB=swL3MgmtMIB, swL3OspfHostIpAddress=swL3OspfHostIpAddress, swL3DevCtrlOSPFState=swL3DevCtrlOSPFState, swL3IpArpReqRateLimitState=swL3IpArpReqRateLimitState, swL3IpFdbInfoTable=swL3IpFdbInfoTable, swL3Md5KeyId=swL3Md5KeyId, swL3RelayDnsMgmt=swL3RelayDnsMgmt, swL3DvmrpInterfaceTable=swL3DvmrpInterfaceTable, swL3IpFdbInfoIpAddr=swL3IpFdbInfoIpAddr, swL3RoutePrefTable=swL3RoutePrefTable, swL3IpCtrlIpAddr=swL3IpCtrlIpAddr, swL3Md5Entry=swL3Md5Entry, swL3IpStaticRouteDest=swL3IpStaticRouteDest, swL3IpStaticRouteNextHop=swL3IpStaticRouteNextHop, swL3IpArpTable=swL3IpArpTable, PYSNMP_MODULE_ID=swL3MgmtMIB, swL3RouteRedistriState=swL3RouteRedistriState, swL3DevCtrlDVMRPState=swL3DevCtrlDVMRPState, swL3RelayBootpState=swL3RelayBootpState, swL3RouteRedistriMetric=swL3RouteRedistriMetric, swL3DvmrpInterfaceProbe=swL3DvmrpInterfaceProbe, swL3DvmrpInterfaceIfIndex=swL3DvmrpInterfaceIfIndex, swL3RouteRedistriSrcProtocol=swL3RouteRedistriSrcProtocol, swL3IpArpEntry=swL3IpArpEntry, NodeAddress=NodeAddress, swL3IpStaticRouteMetric=swL3IpStaticRouteMetric, swL3DevCtrlVRRPPingVirtualAddrState=swL3DevCtrlVRRPPingVirtualAddrState, swL3IpFdbInfoEntry=swL3IpFdbInfoEntry, swL3VrrpOperHoldDownTimer=swL3VrrpOperHoldDownTimer, swL3IpArpReqRateLimitValue=swL3IpArpReqRateLimitValue, swL3RelayBootpMgmt=swL3RelayBootpMgmt, swL3IpCtrlIpSubnetMask=swL3IpCtrlIpSubnetMask, swL3IpCtrlTable=swL3IpCtrlTable, swL3RelayDnsCacheState=swL3RelayDnsCacheState, swL3RelayBootpTimeThreshold=swL3RelayBootpTimeThreshold, swL3IpCtrlVlanName=swL3IpCtrlVlanName, swL3RouteRedistriEntry=swL3RouteRedistriEntry, swL3RelayDnsSecondaryServer=swL3RelayDnsSecondaryServer, swL3IpStaticRouteMask=swL3IpStaticRouteMask, swL3RelayBootpCtrlTable=swL3RelayBootpCtrlTable, swL3IpStaticRouteTable=swL3IpStaticRouteTable, swL3IpArpType=swL3IpArpType, swL3RelayBootpCtrlServer=swL3RelayBootpCtrlServer, swL3IpFilterAddrCtrlEntry=swL3IpFilterAddrCtrlEntry, swL3IpFdbInfoType=swL3IpFdbInfoType, swL3RelayDnsState=swL3RelayDnsState, swL3OspfHostAreaID=swL3OspfHostAreaID, swL3IpFilterAddrIpAddr=swL3IpFilterAddrIpAddr, swL3OspfHostStatus=swL3OspfHostStatus, swL3DvmrpInterfaceNeighborTimeout=swL3DvmrpInterfaceNeighborTimeout, swL3RouteRedistriDstProtocol=swL3RouteRedistriDstProtocol, swL3IpCtrlMgmt=swL3IpCtrlMgmt, swL3IpMgmt=swL3IpMgmt, swL3IpFilterAddrMaxSupportedEntries=swL3IpFilterAddrMaxSupportedEntries, swL3IpFilterAddrCtrlState=swL3IpFilterAddrCtrlState, swL3OspfHostEntry=swL3OspfHostEntry, swL3IpFdbInfoPort=swL3IpFdbInfoPort, swL3RouteRedistriTable=swL3RouteRedistriTable, swL3IpFilterAddrConfig=swL3IpFilterAddrConfig, swL3IpArpDynamicAgingTime=swL3IpArpDynamicAgingTime, swL3VrrpOperTable=swL3VrrpOperTable, swL3VrrpOperVrId=swL3VrrpOperVrId, swL3RelayDnsStaticTableState=swL3RelayDnsStaticTableState, swL3IpArpAgingTime=swL3IpArpAgingTime, swL3RelayBootpHopCount=swL3RelayBootpHopCount, swL3RelayDnsCtrlState=swL3RelayDnsCtrlState)

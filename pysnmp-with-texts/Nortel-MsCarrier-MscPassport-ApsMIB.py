#
# PySNMP MIB module Nortel-MsCarrier-MscPassport-ApsMIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/Nortel-MsCarrier-MscPassport-ApsMIB
# Produced by pysmi-0.3.4 at Wed May  1 14:28:58 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, SingleValueConstraint, ValueSizeConstraint, ValueRangeConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "SingleValueConstraint", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsUnion")
DisplayString, Counter32, RowStatus, StorageType, Integer32, Unsigned32 = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-StandardTextualConventionsMIB", "DisplayString", "Counter32", "RowStatus", "StorageType", "Integer32", "Unsigned32")
AsciiString, Link, Hex, PassportCounter64, FixedPoint1, NonReplicated = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-TextualConventionsMIB", "AsciiString", "Link", "Hex", "PassportCounter64", "FixedPoint1", "NonReplicated")
mscPassportMIBs, mscComponents = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-UsefulDefinitionsMIB", "mscPassportMIBs", "mscComponents")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
ModuleIdentity, MibIdentifier, Gauge32, TimeTicks, Counter32, ObjectIdentity, Bits, iso, IpAddress, Counter64, NotificationType, Integer32, MibScalar, MibTable, MibTableRow, MibTableColumn, Unsigned32 = mibBuilder.importSymbols("SNMPv2-SMI", "ModuleIdentity", "MibIdentifier", "Gauge32", "TimeTicks", "Counter32", "ObjectIdentity", "Bits", "iso", "IpAddress", "Counter64", "NotificationType", "Integer32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Unsigned32")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
apsMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 136))
mscAps = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 134))
mscApsRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 134, 1), )
if mibBuilder.loadTexts: mscApsRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscApsRowStatusTable.setDescription('This entry controls the addition and deletion of mscAps components.')
mscApsRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 134, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-ApsMIB", "mscApsIndex"))
if mibBuilder.loadTexts: mscApsRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscApsRowStatusEntry.setDescription('A single entry in the table represents a single mscAps component.')
mscApsRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 134, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscApsRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscApsRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAps components. These components can be added and deleted.')
mscApsComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 134, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscApsComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscApsComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscApsStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 134, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscApsStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscApsStorageType.setDescription('This variable represents the storage type value for the mscAps tables.')
mscApsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 134, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15999)))
if mibBuilder.loadTexts: mscApsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscApsIndex.setDescription('This variable represents the index for the mscAps tables.')
mscApsCidDataTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 134, 10), )
if mibBuilder.loadTexts: mscApsCidDataTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscApsCidDataTable.setDescription("This group contains the attribute for a component's Customer Identifier (CID). Refer to the attribute description for a detailed explanation of CIDs.")
mscApsCidDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 134, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-ApsMIB", "mscApsIndex"))
if mibBuilder.loadTexts: mscApsCidDataEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscApsCidDataEntry.setDescription('An entry in the mscApsCidDataTable.')
mscApsCustomerIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 134, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 8191), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscApsCustomerIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: mscApsCustomerIdentifier.setDescription("This attribute holds the Customer Identifier (CID). Every component has a CID. If a component has a cid attribute, the component's CID is the provisioned value of that attribute; otherwise the component inherits the CID of its parent. The top- level component has a CID of 0. Every operator session also has a CID, which is the CID provisioned for the operator's user ID. An operator will see only the stream data for components having a matching CID. Also, the operator will be allowed to issue commands for only those components which have a matching CID. An operator CID of 0 is used to identify the Network Manager (referred to as 'NetMan' in DPN). This CID matches the CID of any component. Values 1 to 8191 inclusive (equivalent to 'basic CIDs' in DPN) may be assigned to specific customers.")
mscApsProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 134, 11), )
if mibBuilder.loadTexts: mscApsProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscApsProvTable.setDescription('This group contains the provisioned attributes for the Aps component.')
mscApsProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 134, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-ApsMIB", "mscApsIndex"))
if mibBuilder.loadTexts: mscApsProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscApsProvEntry.setDescription('An entry in the mscApsProvTable.')
mscApsApplicationFramerName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 134, 11, 1, 1), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscApsApplicationFramerName.setStatus('mandatory')
if mibBuilder.loadTexts: mscApsApplicationFramerName.setDescription('This attribute is a link to the service component which utilizes the protected Sonet or Sdh interface managed by the Aps component.')
mscApsWorkingLine = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 134, 11, 1, 2), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscApsWorkingLine.setStatus('mandatory')
if mibBuilder.loadTexts: mscApsWorkingLine.setDescription("This attribute is a link to the Path component whose parent Sonet or Sdh component provides the Aps' working line. A value must be defined for this component. The working line must exist under the same Lp as the protection line and must link to a Path component under the same type of port component (Sonet or Sdh) as the protection line. Valid workingLine and protectionLine pairs must exist. For the 1pOC12SmLrAtm card, the workingLine must be lp/n sonet/0 path/ 0. For other APS compatible cards, the workingLine and protectionLine pairs must use port 0 with port 1 and port 2 with port 3. For example, if the workingLine is linked to a path on port 0, then the protectionLine must be linked to a path on port 1. Sonet APS is available on cards of type 2pOC3SmAtm2, 2pOC3MmAtm2, 4pOC3SmIrAtm, 4pOC3MmAtm, and 1pOC12SmLrAtm.")
mscApsProtectionLine = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 134, 11, 1, 3), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscApsProtectionLine.setStatus('mandatory')
if mibBuilder.loadTexts: mscApsProtectionLine.setDescription("This attribute is a link to the Path component whose parent Sonet or Sdh component provides the Aps' protection line. A value must be defined for this component. This attribute is critical because the APS process runs on the LP associated with the protectionLine. The protection line must exist under the same Lp as the working line, and must link to a Path component under the same type of port component (Sonet or Sdh) as the protection line. Valid workingLine and protectionLine pairs must exist. For the 1pOC12SmLrAtm, the protectionLine must be lp/n sonet/1 path/0. For other APS compatible cards, the workingLine and protectionLine pairs must use port 0 with port 1 and port 2 with port 3. For example, if the workingLine is linked to a path on port 0, then the protectionLine must be linked to a path on port 1. Sonet APS is available on cards of type 2pOC3SmAtm2, 2pOC3MmAtm2, 4pOC3SmIrAtm, 4pOC3MmAtm, and 1pOC12SmLrAtm.")
mscApsMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 134, 11, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4, 5))).clone(namedValues=NamedValues(("unidirectional", 4), ("bidirectional", 5))).clone('unidirectional')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscApsMode.setStatus('mandatory')
if mibBuilder.loadTexts: mscApsMode.setDescription('This attribute specifies the protection mode to use. It has possible values of unidirectional and bidirectional. The unidirectional mode allows the Aps to decide independently of the far end which channel, either working or protection, will be active for receive. The bidirectional mode instructs the Aps to decide jointly with the far end which channel, either working or protection, will be active for receive. Note that while an Aps Test is being run the Aps will operate in unidirectional mode, regardless of the actual provisioned mode.')
mscApsRevertive = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 134, 11, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscApsRevertive.setStatus('mandatory')
if mibBuilder.loadTexts: mscApsRevertive.setDescription('This attribute specifies whether revertive switching is to be used. It has possible values of no or yes. When this attribute is no, the Aps will not revert the receive active line from protection back to working when a working line request is cleared. When this attribute is yes, the Aps will revert the receive active line from protection back to working when a working line request is cleared, after the provisioned waitToRestorePeriod has expired. Note that it is acceptable for the near end and far end to be provisioned with a mix of revertive and nonrevertive switching.')
mscApsHoldOffTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 134, 11, 1, 6), FixedPoint1().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscApsHoldOffTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscApsHoldOffTime.setDescription('The hold off time is the delay between the detection of a Signal Fail or Signal Degrade on the active line and the initiation of a switchover.')
mscApsWaitToRestorePeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 134, 11, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(5, 12)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscApsWaitToRestorePeriod.setStatus('mandatory')
if mibBuilder.loadTexts: mscApsWaitToRestorePeriod.setDescription('This attribute specifies the time during which the protection line will remain the receive active line after the working line recovers from the fault that caused the switch. This attribute is only applicable when the provisionable attribute revertive is yes.')
mscApsSignalDegradeRatio = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 134, 11, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-9, -5)).clone(-5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscApsSignalDegradeRatio.setStatus('mandatory')
if mibBuilder.loadTexts: mscApsSignalDegradeRatio.setDescription('This attribute specifies the minimum bit error ratio (BER) for which a Signal Degrade failure is declared. Its value is the exponent of the BER, with possible values of -5 through -9 inclusive, which correspond to a BER range of 10-5 through 10-9. The switch initiation time for a Signal Degrade varies depending on the observed BER (not the provisioned signalDegradeRatio), as described in the following table. Observed BER Switch Initiation Time 10-3 10 milliseconds 10-4 100 milliseconds 10-5 1 second 10-6 10 seconds 10-7 100 seconds 10-8 16 minutes 40 seconds 10-9 2 hours 46 minutes 40 seconds The clearing threshold for a Signal Degrade is one-tenth the signalDegradeRatio; for example, if the provisioned signalDegradeRatio is -5, the corresponding clearing threshold will be 10-6. The clearing time varies depending on the clearing threshold (not the observed BER), and can be determined from the above table.')
mscApsStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 134, 12), )
if mibBuilder.loadTexts: mscApsStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscApsStateTable.setDescription('This group contains the three OSI State attributes and the six OSI Status attributes. The descriptions generically indicate what each attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241- 7001-150, Passport Operations and Maintenance Guide.')
mscApsStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 134, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-ApsMIB", "mscApsIndex"))
if mibBuilder.loadTexts: mscApsStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscApsStateEntry.setDescription('An entry in the mscApsStateTable.')
mscApsAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 134, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscApsAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscApsAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscApsOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 134, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscApsOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscApsOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscApsUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 134, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscApsUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscApsUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscApsAvailabilityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 134, 12, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscApsAvailabilityStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscApsAvailabilityStatus.setDescription('If supported by the component, this attribute indicates the OSI Availability status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value inTest indicates that the resource is undergoing a test procedure. If adminState is locked or shuttingDown, the normal users are precluded from using the resource and controlStatus is reservedForTest. Tests that do not exclude additional users can be present in any operational or administrative state but the reservedForTest condition should not be present. The value failed indicates that the component has an internal fault that prevents it from operating. The operationalState is disabled. The value dependency indicates that the component cannot operate because some other resource on which it depends is unavailable. The operationalState is disabled. The value powerOff indicates the resource requires power to be applied and it is not powered on. The operationalState is disabled. The value offLine indicates the resource requires a routine operation (either manual, automatic, or both) to be performed to place it on-line and make it available for use. The operationalState is disabled. The value offDuty indicates the resource is inactive in accordance with a predetermined time schedule. In the absence of other disabling conditions, the operationalState is enabled or disabled. The value degraded indicates the service provided by the component is degraded in some way, such as in speed or operating capacity. However, the resource remains available for service. The operationalState is enabled. The value notInstalled indicates the resource is not present. The operationalState is disabled. The value logFull is not used. Description of bits: inTest(0) failed(1) powerOff(2) offLine(3) offDuty(4) dependency(5) degraded(6) notInstalled(7) logFull(8)')
mscApsProceduralStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 134, 12, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscApsProceduralStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscApsProceduralStatus.setDescription("If supported by the component, this attribute indicates the OSI Procedural status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value initializationRequired indicates (for a resource which doesn't initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState is disabled. The value notInitialized indicates (for a resource which does initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState may be enabled or disabled. The value initializing indicates that initialization has been initiated but is not yet complete. The operationalState may be enabled or disabled. The value reporting indicates the resource has completed some processing operation and is notifying the results. The operationalState is enabled. The value terminating indicates the component is in a termination phase. If the resource doesn't reinitialize autonomously, operationalState is disabled; otherwise it is enabled or disabled. Description of bits: initializationRequired(0) notInitialized(1) initializing(2) reporting(3) terminating(4)")
mscApsControlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 134, 12, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscApsControlStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscApsControlStatus.setDescription('If supported by the component, this attribute indicates the OSI Control status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value subjectToTest indicates the resource is available but tests may be conducted simultaneously at unpredictable times, which may cause it to exhibit unusual characteristics. The value partOfServicesLocked indicates that part of the service is restricted from users of a resource. The adminState is unlocked. The value reservedForTest indicates that the component is administratively unavailable because it is undergoing a test procedure. The adminState is locked. The value suspended indicates that the service has been administratively suspended. Description of bits: subjectToTest(0) partOfServicesLocked(1) reservedForTest(2) suspended(3)')
mscApsAlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 134, 12, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscApsAlarmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscApsAlarmStatus.setDescription('If supported by the component, this attribute indicates the OSI Alarm status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value underRepair indicates the component is currently being repaired. The operationalState is enabled or disabled. The value critical indicates one or more critical alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value major indicates one or more major alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value minor indicates one or more minor alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value alarmOutstanding generically indicates that an alarm of some severity is outstanding against the component. Description of bits: underRepair(0) critical(1) major(2) minor(3) alarmOutstanding(4)')
mscApsStandbyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 134, 12, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 15))).clone(namedValues=NamedValues(("hotStandby", 0), ("coldStandby", 1), ("providingService", 2), ("notSet", 15))).clone('notSet')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscApsStandbyStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscApsStandbyStatus.setDescription('If supported by the component, this attribute indicates the OSI Standby status of the component. The value notSet indicates that either the attribute is not supported or that none of the status conditions described below are present. Note that this is a non-standard value, used because the original specification indicated this attribute was set-valued and thus, did not provide a value to indicate that none of the other three are applicable. The value hotStandby indicates that the resource is not providing service but will be immediately able to take over the role of the resource to be backed up, without initialization activity, and containing the same information as the resource to be backed up. The value coldStandby indicates the resource is a backup for another resource but will not be immediately able to take over the role of the backed up resource and will require some initialization activity. The value providingService indicates that this component, as a backup resource, is currently backing up another resource.')
mscApsUnknownStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 134, 12, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1))).clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscApsUnknownStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscApsUnknownStatus.setDescription('This attribute indicates the OSI Unknown status of the component. The value false indicates that all of the other OSI State and Status attribute values can be considered accurate. The value true indicates that the actual state of the component is not known for sure.')
mscApsOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 134, 13), )
if mibBuilder.loadTexts: mscApsOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscApsOperTable.setDescription('This group contains the operational attributes for the Aps component.')
mscApsOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 134, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-ApsMIB", "mscApsIndex"))
if mibBuilder.loadTexts: mscApsOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscApsOperEntry.setDescription('An entry in the mscApsOperTable.')
mscApsNearEndRxActiveLine = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 134, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("protection", 0), ("working", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscApsNearEndRxActiveLine.setStatus('mandatory')
if mibBuilder.loadTexts: mscApsNearEndRxActiveLine.setDescription('This attribute indicates which near end line is active for receiving data from the far end.')
mscApsNearEndRequest = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 134, 13, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 6, 8, 10, 12, 14, 15))).clone(namedValues=NamedValues(("noRequest", 0), ("doNotRevert", 1), ("reverseRequest", 2), ("waitToRestore", 6), ("manualSwitch", 8), ("signalDegrade", 10), ("signalFail", 12), ("forcedSwitch", 14), ("lockoutOfProtection", 15)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscApsNearEndRequest.setStatus('mandatory')
if mibBuilder.loadTexts: mscApsNearEndRequest.setDescription('This attribute indicates the request currently being transmitted to the far end in the SONET/SDH line overhead K1 byte of the protection line. Requests are prioritized so that high priority requests preempt or block those with a lower priority. The possible requests, in order of priority from highest to lowest, are as follows. lockoutOfProtection the working line is prevented from switching to the protection line under any circumstances due to an ProtectionLockout command being in effect. forcedSwitch the line indicated by attribute nearEndRequestChannel has a Switch -force command in effect against it. Note that a signalFail on the protection line has higher priority than a forcedSwitch. signalFail the line indicated by attribute nearEndRequestChannel is experiencing a signal failure (SF). Failures include LOS, LOF, received AIS-L, a signal BER exceeding 10-3, LOP, received AIS-P, LCD, or a locked Sonet, Sdh, or Path component. Note that a signalFail on the protection line has higher priority than a forcedSwitch. signalDegrade the line indicated by attribute nearEndRequestChannel is experiencing a signal degradation (SD). For more information on the conditions required to declare and clear an SD please refer to the desription for attribute signalDegradeRatio. A such that the signal BER exceeds the value provisioned in the signalDegradeRatio attribute, or is still exceeding manualSwitch the line indicated by attribute nearEndRequestChannel has a Switch command in effect against it. waitToRestore the protection line is active, provisioned attribute revertive is yes, and the working line has recovered from a Signal Fail or Signal Degrade. After the period defined by attribute waitToRestorePeriod the working line will automatically revert to being the receive active line and the request will change to noRequest. reverseRequest the line indicated by attribute nearEndRequestChannel is active due to a request from the far end. This request is only applicable when the provisioned mode is bidirectional. doNotRevert the protection line is active, provisioned attribute revertive is no, and either: (1) the working line has recovered from a signalFail or signalDegrade; or (2) a forcedSwitch or manualSwitch request has been cleared. The receive active line will not automatically revert to the working line. noRequest the working line is active and no other requests are in effect.')
mscApsNearEndRequestChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 134, 13, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("protection", 0), ("working", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscApsNearEndRequestChannel.setStatus('mandatory')
if mibBuilder.loadTexts: mscApsNearEndRequestChannel.setDescription('This attribute indicates to which channel the nearEndRequest applies.')
mscApsFarEndRequest = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 134, 13, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 6, 8, 10, 12, 14, 15))).clone(namedValues=NamedValues(("noRequest", 0), ("doNotRevert", 1), ("reverseRequest", 2), ("waitToRestore", 6), ("manualSwitch", 8), ("signalDegrade", 10), ("signalFail", 12), ("forcedSwitch", 14), ("lockoutOfProtection", 15)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscApsFarEndRequest.setStatus('mandatory')
if mibBuilder.loadTexts: mscApsFarEndRequest.setDescription('This attribute indicates the request currently being received from the far end in the SONET/SDH line overhead K1 byte of the protection line. Requests are prioritized so that high priority requests preempt or block those with a lower priority. The possible requests, in order of priority from highest to lowest, are as follows. lockoutOfProtection the working line is prevented from switching to the protection line under any circumstances due to an ProtectionLockout command being in effect. forcedSwitch the line indicated by attribute nearEndRequestChannel has a Switch -force command in effect against it. Note that a signalFail on the protection line has higher priority than a forcedSwitch. signalFail the line indicated by attribute nearEndRequestChannel is experiencing a signal failure (SF). Failures include LOS, LOF, received AIS-L, a signal BER exceeding 10-3, LOP, received AIS-P, LCD, or a locked Sonet, Sdh, or Path component. Note that a signalFail on the protection line has higher priority than a forcedSwitch. signalDegrade the line indicated by attribute nearEndRequestChannel is experiencing a signal degradation (SD). For more information on the conditions required to declare and clear an SD please refer to the desription for attribute signalDegradeRatio. A such that the signal BER exceeds the value provisioned in the signalDegradeRatio attribute, or is still exceeding manualSwitch the line indicated by attribute nearEndRequestChannel has a Switch command in effect against it. waitToRestore the protection line is active, provisioned attribute revertive is yes, and the working line has recovered from a Signal Fail or Signal Degrade. After the period defined by attribute waitToRestorePeriod the working line will automatically revert to being the receive active line and the request will change to noRequest. reverseRequest the line indicated by attribute nearEndRequestChannel is active due to a request from the far end. This request is only applicable when the provisioned mode is bidirectional. doNotRevert the protection line is active, provisioned attribute revertive is no, and either: (1) the working line has recovered from a signalFail or signalDegrade; or (2) a forcedSwitch or manualSwitch request has been cleared. The receive active line will not automatically revert to the working line. noRequest the working line is active and no other requests are in effect. DESCRIPTION')
mscApsFarEndRequestChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 134, 13, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("protection", 0), ("working", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscApsFarEndRequestChannel.setStatus('mandatory')
if mibBuilder.loadTexts: mscApsFarEndRequestChannel.setDescription('This attribute indicates to which channel the farEndRequest applies.')
mscApsSdOnLines = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 134, 13, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscApsSdOnLines.setStatus('mandatory')
if mibBuilder.loadTexts: mscApsSdOnLines.setDescription('This attribute indicates which lines (if any) are currently experiencing a Signal Degrade (SD). Description of bits: protection(0) working(1)')
mscApsSwitchovers = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 134, 13, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscApsSwitchovers.setStatus('mandatory')
if mibBuilder.loadTexts: mscApsSwitchovers.setDescription('This attributes counts the number of times that a switchover of the active line has occurred since the Aps component became active.')
mscApsTimeUntilRestore = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 134, 13, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscApsTimeUntilRestore.setStatus('mandatory')
if mibBuilder.loadTexts: mscApsTimeUntilRestore.setDescription('This attribute indicates the amount of time in minutes until the receive active line is automatically switched back from the protection line to the working line. It is only applicable for Aps components that are provisioned to be revertive, and which currently have the protection line as the receive active line and a nearEndRequest of waitToRestore.')
mscApsProtocolFailureAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 134, 13, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscApsProtocolFailureAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: mscApsProtocolFailureAlarm.setDescription('This attribute indicates whether the Aps component is experiencing an APS protocol failure alarm. Protocol failure alarms include the protection switching byte mismatch alarm (code 7011 5270) and the channel mismatch failure alarm (code 7011 5271).')
mscApsModeMismatchAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 134, 13, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscApsModeMismatchAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: mscApsModeMismatchAlarm.setDescription("This attribute indicates whether the Aps component is experiencing an APS mode mismatch alarm (code 7011 5272). This alarm indicates either: (1) that the far end is operating with a 1:n switching architecture (not supported by Passport), as opposed to 1+1; or (2) that the far end's provisioned mode is not the same as the nears end's provisioned mode. When a mode mismatch occurs: (1) if the far end is operating with a 1:n switching architecture it will operate as 1+1; and (2) if either end has a provisioned mode of unidirectional then both ends will operate unidirectionally.")
mscApsTest = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 134, 2))
mscApsTestRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 134, 2, 1), )
if mibBuilder.loadTexts: mscApsTestRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscApsTestRowStatusTable.setDescription('This entry controls the addition and deletion of mscApsTest components.')
mscApsTestRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 134, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-ApsMIB", "mscApsIndex"), (0, "Nortel-MsCarrier-MscPassport-ApsMIB", "mscApsTestIndex"))
if mibBuilder.loadTexts: mscApsTestRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscApsTestRowStatusEntry.setDescription('A single entry in the table represents a single mscApsTest component.')
mscApsTestRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 134, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscApsTestRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscApsTestRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscApsTest components. These components cannot be added nor deleted.')
mscApsTestComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 134, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscApsTestComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscApsTestComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscApsTestStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 134, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscApsTestStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscApsTestStorageType.setDescription('This variable represents the storage type value for the mscApsTest tables.')
mscApsTestIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 134, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscApsTestIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscApsTestIndex.setDescription('This variable represents the index for the mscApsTest tables.')
mscApsTestStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 134, 2, 10), )
if mibBuilder.loadTexts: mscApsTestStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscApsTestStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscApsTestStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 134, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-ApsMIB", "mscApsIndex"), (0, "Nortel-MsCarrier-MscPassport-ApsMIB", "mscApsTestIndex"))
if mibBuilder.loadTexts: mscApsTestStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscApsTestStateEntry.setDescription('An entry in the mscApsTestStateTable.')
mscApsTestAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 134, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscApsTestAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscApsTestAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscApsTestOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 134, 2, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscApsTestOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscApsTestOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscApsTestUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 134, 2, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscApsTestUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscApsTestUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscApsTestSetupTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 134, 2, 11), )
if mibBuilder.loadTexts: mscApsTestSetupTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscApsTestSetupTable.setDescription('This group contains all of the operational data for a Test component.')
mscApsTestSetupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 134, 2, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-ApsMIB", "mscApsIndex"), (0, "Nortel-MsCarrier-MscPassport-ApsMIB", "mscApsTestIndex"))
if mibBuilder.loadTexts: mscApsTestSetupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscApsTestSetupEntry.setDescription('An entry in the mscApsTestSetupTable.')
mscApsTestPurpose = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 134, 2, 11, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscApsTestPurpose.setStatus('mandatory')
if mibBuilder.loadTexts: mscApsTestPurpose.setDescription('This attribute records the purpose of the test so that the test results can be associated and properly analyzed.')
mscApsTestType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 134, 2, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("card", 0), ("manual", 1), ("localLoop", 2), ("remoteLoop", 3), ("externalLoop", 4), ("payloadLoop", 5), ("remoteLoopThisTrib", 6), ("v54RemoteLoop", 7), ("pn127RemoteLoop", 8))).clone('card')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscApsTestType.setStatus('mandatory')
if mibBuilder.loadTexts: mscApsTestType.setDescription('This attribute is the type of test to be run. The available test types include the following: card test sets up an internal loop on the board and runs a bit error rate test. manual test assumes the line is looped back externally and a bit error rate test is performed. localLoop test loops back the local modem and performs a bit error rate test. remoteLoop test loops back the remote modem (or CSU) and performs a bit error rate test. externalLoop test loops back the line to the far end. payloadLoop test only loops back the payload data received from the incoming line. remoteLoopThisTrib loops this particular tributary back at the far end, using services provided by the parent. v54RemoteLoop initiates a V.54 Remote Loopback test. pn127RemoteLoop initiates a PN127 Remote Loopback test. Note that not all test types are not supported by all function processors.')
mscApsTestFrmSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 134, 2, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(4, 4096)).clone(1024)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscApsTestFrmSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscApsTestFrmSize.setDescription('This attribute defines the size of the test data frames in number of bytes.')
mscApsTestFrmPatternType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 134, 2, 11, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("ccitt32kBitPattern", 0), ("ccitt8MBitPattern", 1), ("customizedPattern", 2))).clone('ccitt32kBitPattern')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscApsTestFrmPatternType.setStatus('mandatory')
if mibBuilder.loadTexts: mscApsTestFrmPatternType.setDescription('This attribute defines the type of data pattern generation to use. The following lists the available pattern types: ccitt32kBitPattern is a pseudo-random sequence of 32 kbit. ccitt8MBitPattern is a pseudo-random sequence of 8Mbit. customizedPattern is the pattern defined in the customizedPattern attribute.')
mscApsTestCustomizedPattern = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 134, 2, 11, 1, 5), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(1431655765)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscApsTestCustomizedPattern.setStatus('mandatory')
if mibBuilder.loadTexts: mscApsTestCustomizedPattern.setDescription('This attribute allows a customized 32 bit pattern to be defined for use in the test data frames. This attribute is used when the attribute frmPatternType is set to CustomizedPattern. Note that a 55 hex pattern is an alternating 1 and 0 pattern.')
mscApsTestDataStartDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 134, 2, 11, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1814400))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscApsTestDataStartDelay.setStatus('mandatory')
if mibBuilder.loadTexts: mscApsTestDataStartDelay.setDescription('This attribute specifies the time delay (in seconds) between when the test expects the loop to have been set up, to when the test data actually starts to be transmitted. This attribute is to accommodate some non-standard equipment that requires extra time for setting up a requested loop. This attribute is ignored when the test type is set to externalLoop.')
mscApsTestDisplayInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 134, 2, 11, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 30240)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscApsTestDisplayInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mscApsTestDisplayInterval.setDescription('This attribute defines the interval (in minutes) between which interim test results are to be displayed. Results are displayed at the operator console at which the test was started. When the test type is set to externalLoop, this attribute is ignored. There will be no display of results if displayInterval is set to 0. This attribute can be changed anytime.')
mscApsTestDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 134, 2, 11, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 30240)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscApsTestDuration.setStatus('mandatory')
if mibBuilder.loadTexts: mscApsTestDuration.setDescription('This attribute is the duration (in minutes) that test data will be transmitted. In the case of an externalLoop, this is the time that the loop is in effect. Note that dataStartDelay does not apply to the externalLoop.')
mscApsTestResultsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 134, 2, 12), )
if mibBuilder.loadTexts: mscApsTestResultsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscApsTestResultsTable.setDescription('This group contains all the statistics related attributes of the Test component.')
mscApsTestResultsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 134, 2, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-ApsMIB", "mscApsIndex"), (0, "Nortel-MsCarrier-MscPassport-ApsMIB", "mscApsTestIndex"))
if mibBuilder.loadTexts: mscApsTestResultsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscApsTestResultsEntry.setDescription('An entry in the mscApsTestResultsTable.')
mscApsTestElapsedTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 134, 2, 12, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscApsTestElapsedTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscApsTestElapsedTime.setDescription('This attribute is the number of minutes elapsed since the test started for an externalLoop test. For a data test, this is the time since test data was first transmitted.')
mscApsTestTimeRemaining = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 134, 2, 12, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscApsTestTimeRemaining.setStatus('mandatory')
if mibBuilder.loadTexts: mscApsTestTimeRemaining.setDescription('This attribute is the number of minutes remaining before the test is to be stopped according to the duration attribute.')
mscApsTestCauseOfTermination = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 134, 2, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("testTimeExpired", 0), ("stoppedByOperator", 1), ("unknown", 2), ("neverStarted", 3), ("testRunning", 4), ("hardwareReconfigured", 5), ("loopCodeSyncFailed", 6), ("patternSyncFailed", 7), ("patternSyncLost", 8))).clone('neverStarted')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscApsTestCauseOfTermination.setStatus('mandatory')
if mibBuilder.loadTexts: mscApsTestCauseOfTermination.setDescription("This attribute indicates either the status of the test or the cause of the test's termination: neverStarted indicates that the test has not yet been started. testRunning indicates that the test has been started. stoppedByOperator indicates that the operator issued a stop command on a test that was running. testTimeExpired indicates that the test ran for the time specified by the test's duration. loopCodeSyncFailed indicates that the local end failed to synchronize to the loopCode pattern. The local end transmits the loopCode pattern to cause the remote end to apply a loopback, after which the local end should receive the loopCode pattern. The exact pattern used to request loopCode depends on the test type. This failure indicates a high rate of transmission errors, or that the remote end has failed to apply the loopback. patternSyncFailed indicates that the local end failed to synchronize to the frmPatternType test pattern, that should have been looped back at the remote end. This failure indicates a high rate of transmission errors or the absence of a loopback. patternSyncLost indicates that the local end gained and then lost synchronization to the returned frmPatternType test pattern. This failure indicates a sudden increase in transmission errors, frame slippage, or the removal of an existing loopback. unknown is set when a reason to terminate other than those listed here is encountered. Note: Only MSA cards support recognition of the failures loopCodeSyncFailed, patternSyncFailed and patternSyncLost. Other cards will not terminate the test under the conditions described by these values.")
mscApsTestBitsTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 134, 2, 12, 1, 4), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscApsTestBitsTx.setStatus('mandatory')
if mibBuilder.loadTexts: mscApsTestBitsTx.setDescription('This attribute is the total number of bits sent during the test period. As long as the line speed of the hardware interface is less than 70 Mbit/s, this counter is not expected to reach the maximum value.')
mscApsTestBytesTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 134, 2, 12, 1, 5), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscApsTestBytesTx.setStatus('mandatory')
if mibBuilder.loadTexts: mscApsTestBytesTx.setDescription('This attribute is the total number of bytes sent during the test period. This counter is not expected to reach its maximum value.')
mscApsTestFrmTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 134, 2, 12, 1, 6), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscApsTestFrmTx.setStatus('mandatory')
if mibBuilder.loadTexts: mscApsTestFrmTx.setDescription('This attribute is the total number of frames sent during the test period. This counter is not expected to reach its maximum value.')
mscApsTestBitsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 134, 2, 12, 1, 7), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscApsTestBitsRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscApsTestBitsRx.setDescription('This attribute is the total number of bits received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach the maximum value.')
mscApsTestBytesRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 134, 2, 12, 1, 8), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscApsTestBytesRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscApsTestBytesRx.setDescription('This attribute is the total number of bytes received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach its maximum value.')
mscApsTestFrmRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 134, 2, 12, 1, 9), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscApsTestFrmRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscApsTestFrmRx.setDescription('This attribute is the total number of frames received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach its maximum value.')
mscApsTestErroredFrmRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 134, 2, 12, 1, 10), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscApsTestErroredFrmRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscApsTestErroredFrmRx.setDescription('This attribute is not displayed for ATM cards because the physical layer drops all errored frames at the controller interface. For all other card types, this attribute is the total number of errored frames received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach its maximum value.')
mscApsTestBitErrorRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 134, 2, 12, 1, 11), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(5, 5)).setFixedLength(5)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscApsTestBitErrorRate.setStatus('mandatory')
if mibBuilder.loadTexts: mscApsTestBitErrorRate.setDescription('This attribute is not displayed for ATM cards because the physical layer drops all errored frames at the controller interface. For all other card types, this attribute is the calculated bit error rate on the link. Test data are generated and sent in frames of a preset size (frameSize). The Test component will try to estimate the number of bit errors in any errored frame which is identifiable. The statistics will be updated accordingly. A lost frame (may be due to an error on the flag sequence) will be discarded for the bit error rate calculation. The result is presented in the form of xEsyy, where x is the mantissa, syy is the exponent, for example 0E+00, 2E-09. Note that the bitErrorRate is an estimate only. For more reliable test results, the test should be done over a long period. Multiple tests would also improve the confidence level of the test results.')
apsGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 136, 1))
apsGroupCA = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 136, 1, 1))
apsGroupCA02 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 136, 1, 1, 3))
apsGroupCA02A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 136, 1, 1, 3, 2))
apsCapabilities = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 136, 3))
apsCapabilitiesCA = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 136, 3, 1))
apsCapabilitiesCA02 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 136, 3, 1, 3))
apsCapabilitiesCA02A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 136, 3, 1, 3, 2))
mibBuilder.exportSymbols("Nortel-MsCarrier-MscPassport-ApsMIB", mscApsRowStatusEntry=mscApsRowStatusEntry, mscApsNearEndRequestChannel=mscApsNearEndRequestChannel, mscApsStorageType=mscApsStorageType, mscApsCidDataTable=mscApsCidDataTable, mscApsSwitchovers=mscApsSwitchovers, mscApsModeMismatchAlarm=mscApsModeMismatchAlarm, mscApsTestBitsRx=mscApsTestBitsRx, apsGroupCA02=apsGroupCA02, mscApsTestType=mscApsTestType, mscApsIndex=mscApsIndex, mscApsTestStateTable=mscApsTestStateTable, mscApsTestFrmSize=mscApsTestFrmSize, mscApsTestTimeRemaining=mscApsTestTimeRemaining, mscApsNearEndRequest=mscApsNearEndRequest, mscApsTestBitErrorRate=mscApsTestBitErrorRate, mscApsRevertive=mscApsRevertive, mscApsStandbyStatus=mscApsStandbyStatus, mscApsTestCustomizedPattern=mscApsTestCustomizedPattern, mscApsTestDuration=mscApsTestDuration, mscApsStateTable=mscApsStateTable, mscApsTestAdminState=mscApsTestAdminState, apsGroup=apsGroup, mscApsTestComponentName=mscApsTestComponentName, mscApsUnknownStatus=mscApsUnknownStatus, mscApsTestUsageState=mscApsTestUsageState, apsCapabilitiesCA02A=apsCapabilitiesCA02A, mscApsCustomerIdentifier=mscApsCustomerIdentifier, mscApsOperTable=mscApsOperTable, apsGroupCA02A=apsGroupCA02A, mscApsStateEntry=mscApsStateEntry, mscApsProtocolFailureAlarm=mscApsProtocolFailureAlarm, mscApsAvailabilityStatus=mscApsAvailabilityStatus, mscApsTestStateEntry=mscApsTestStateEntry, mscApsTestFrmTx=mscApsTestFrmTx, mscAps=mscAps, mscApsTestRowStatus=mscApsTestRowStatus, mscApsTestOperationalState=mscApsTestOperationalState, mscApsProvTable=mscApsProvTable, mscApsTestIndex=mscApsTestIndex, mscApsRowStatus=mscApsRowStatus, mscApsTestRowStatusTable=mscApsTestRowStatusTable, mscApsTestStorageType=mscApsTestStorageType, mscApsApplicationFramerName=mscApsApplicationFramerName, apsGroupCA=apsGroupCA, mscApsFarEndRequest=mscApsFarEndRequest, mscApsTestCauseOfTermination=mscApsTestCauseOfTermination, mscApsTestErroredFrmRx=mscApsTestErroredFrmRx, mscApsTimeUntilRestore=mscApsTimeUntilRestore, mscApsOperationalState=mscApsOperationalState, mscApsAlarmStatus=mscApsAlarmStatus, mscApsTestSetupEntry=mscApsTestSetupEntry, mscApsComponentName=mscApsComponentName, apsCapabilitiesCA=apsCapabilitiesCA, mscApsTestBitsTx=mscApsTestBitsTx, mscApsCidDataEntry=mscApsCidDataEntry, mscApsFarEndRequestChannel=mscApsFarEndRequestChannel, mscApsWorkingLine=mscApsWorkingLine, mscApsRowStatusTable=mscApsRowStatusTable, mscApsTestFrmRx=mscApsTestFrmRx, mscApsNearEndRxActiveLine=mscApsNearEndRxActiveLine, mscApsTestBytesRx=mscApsTestBytesRx, mscApsTestBytesTx=mscApsTestBytesTx, mscApsSdOnLines=mscApsSdOnLines, mscApsUsageState=mscApsUsageState, mscApsTest=mscApsTest, mscApsTestResultsTable=mscApsTestResultsTable, mscApsProtectionLine=mscApsProtectionLine, mscApsControlStatus=mscApsControlStatus, mscApsMode=mscApsMode, apsMIB=apsMIB, mscApsTestFrmPatternType=mscApsTestFrmPatternType, mscApsProceduralStatus=mscApsProceduralStatus, mscApsTestDataStartDelay=mscApsTestDataStartDelay, mscApsProvEntry=mscApsProvEntry, mscApsOperEntry=mscApsOperEntry, mscApsTestPurpose=mscApsTestPurpose, mscApsHoldOffTime=mscApsHoldOffTime, mscApsTestDisplayInterval=mscApsTestDisplayInterval, mscApsTestRowStatusEntry=mscApsTestRowStatusEntry, apsCapabilitiesCA02=apsCapabilitiesCA02, mscApsAdminState=mscApsAdminState, mscApsTestResultsEntry=mscApsTestResultsEntry, apsCapabilities=apsCapabilities, mscApsTestElapsedTime=mscApsTestElapsedTime, mscApsWaitToRestorePeriod=mscApsWaitToRestorePeriod, mscApsTestSetupTable=mscApsTestSetupTable, mscApsSignalDegradeRatio=mscApsSignalDegradeRatio)

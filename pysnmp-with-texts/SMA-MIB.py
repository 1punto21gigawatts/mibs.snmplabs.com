#
# PySNMP MIB module SMA-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/SMA-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:07:35 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ValueRangeConstraint, ConstraintsIntersection, SingleValueConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsIntersection", "SingleValueConstraint", "ConstraintsUnion")
IbMulticastLid, IbUnicastLid, IbDataPortAndInvalid, IbGuid, IbDataPort, infinibandMIB, IbSmPortList = mibBuilder.importSymbols("IB-TC-MIB", "IbMulticastLid", "IbUnicastLid", "IbDataPortAndInvalid", "IbGuid", "IbDataPort", "infinibandMIB", "IbSmPortList")
InterfaceIndex, = mibBuilder.importSymbols("IF-MIB", "InterfaceIndex")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
ObjectGroup, ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "ModuleCompliance", "NotificationGroup")
Gauge32, Integer32, iso, TimeTicks, Unsigned32, ObjectIdentity, experimental, MibIdentifier, Counter64, MibScalar, MibTable, MibTableRow, MibTableColumn, IpAddress, NotificationType, Bits, ModuleIdentity, Counter32 = mibBuilder.importSymbols("SNMPv2-SMI", "Gauge32", "Integer32", "iso", "TimeTicks", "Unsigned32", "ObjectIdentity", "experimental", "MibIdentifier", "Counter64", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "IpAddress", "NotificationType", "Bits", "ModuleIdentity", "Counter32")
TruthValue, DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "TruthValue", "DisplayString", "TextualConvention")
ibSmaMIB = ModuleIdentity((1, 3, 6, 1, 3, 117, 3))
ibSmaMIB.setRevisions(('2003-06-06 12:00', '2003-01-01 12:00', '2002-09-16 12:00', '2002-07-31 12:00', '2002-07-18 12:00', '2002-05-10 12:00', '2002-03-01 12:00', '2001-10-20 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ibSmaMIB.setRevisionsDescriptions(('Removed IBA Trap numbers 64, 65, 66 and 67 as per IBTA spec version 1.1. These traps are only sent by Subnet manager and not by Subnet Management Agent', 'Updated MIB for new IBTA spec version 1.1.', 'Corrected ranges for number of entries, updated names, fixed several enum values, and added LMC object to Port Info table (-03).', 'Removed ibSmaNodeTrapBuffer; added explicit var bind objects and corrected notifications to use them (-03).', 'Syntax corrections (to build with Omegaband tools). (-03).', 'Fixed TC assignments; LED table; GUID table index; (-02).', 'Added IANA SMI value; moved TCs to separate ID; renamed OIDs (-01).', 'Initial IETF Draft Revision (-00).',))
if mibBuilder.loadTexts: ibSmaMIB.setLastUpdated('200306061200Z')
if mibBuilder.loadTexts: ibSmaMIB.setOrganization('IETF IP Over IB Working Group Email: ipoib@ietf.org')
if mibBuilder.loadTexts: ibSmaMIB.setContactInfo('Sean Harnedy (sharnedy@mangrovesystems.com) Mangrove Systems, Inc. Bhargavi Shah (bshah@infiniswitch.com) InfiniSwitch Corporation Bill Swortwood')
if mibBuilder.loadTexts: ibSmaMIB.setDescription('This module contains managed object definitions for the Subnet Management Agent instrumentation for an InfiniBand Subnet Management Agent (SMA).')
ibSmaObjects = MibIdentifier((1, 3, 6, 1, 3, 117, 3, 1))
ibSmaNotifications = MibIdentifier((1, 3, 6, 1, 3, 117, 3, 2))
ibSmaConformance = MibIdentifier((1, 3, 6, 1, 3, 117, 3, 3))
ibSmaNodeInfo = MibIdentifier((1, 3, 6, 1, 3, 117, 3, 1, 1))
ibSmaNodeString = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaNodeString.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.2; Table 127 NodeDescription.')
if mibBuilder.loadTexts: ibSmaNodeString.setStatus('current')
if mibBuilder.loadTexts: ibSmaNodeString.setDescription('The node description. This is the Node description string from the NodeDescription attribute. The contents of the NodeDescription attribute is the same for all ports on a node.')
ibSmaNodeBaseVersion = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaNodeBaseVersion.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.3; Table 128 NodeInfo.')
if mibBuilder.loadTexts: ibSmaNodeBaseVersion.setStatus('current')
if mibBuilder.loadTexts: ibSmaNodeBaseVersion.setDescription('The supported Management Datagram (MAD) base version. This value indicates that the node supports up to and including this version. This value is the same for all ports on a node. (NOTE: for InfiniBand Release 1 this value should be set to 1.)')
ibSmaNodeClassVersion = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaNodeClassVersion.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.3; Table 128 NodeInfo.')
if mibBuilder.loadTexts: ibSmaNodeClassVersion.setStatus('current')
if mibBuilder.loadTexts: ibSmaNodeClassVersion.setDescription('The supported Subnet Management Class (SMP) version. This value indicates that the node supports up to and including this version. This value is the same for all ports on a node. (NOTE: for InfiniBand Release 1 this value should be set to 1.)')
ibSmaNodeType = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("channelAdapter", 1), ("switch", 2), ("router", 3), ("other", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaNodeType.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.3; Table 128 NodeInfo.')
if mibBuilder.loadTexts: ibSmaNodeType.setStatus('current')
if mibBuilder.loadTexts: ibSmaNodeType.setDescription('Type of IBA device this SMA is supporting. Types are 1: Channel Adapter 2: Switch 3: Router 0,4-255: reserved NOTE: all reserved values are reported as other.')
ibSmaNodeNumPorts = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 254))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaNodeNumPorts.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.3; Table 128 NodeInfo.')
if mibBuilder.loadTexts: ibSmaNodeNumPorts.setStatus('current')
if mibBuilder.loadTexts: ibSmaNodeNumPorts.setDescription('The number of physical InfiniBand ports on this node.')
ibSmaSystemImageGuid = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 1, 6), IbGuid()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaSystemImageGuid.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.3; Table 128 NodeInfo.')
if mibBuilder.loadTexts: ibSmaSystemImageGuid.setStatus('current')
if mibBuilder.loadTexts: ibSmaSystemImageGuid.setDescription('The GUID of this node that associates this node with other nodes in the same administrative domain. These nodes are controlled by common supervisory code. This object provides a way for system software to indicate the availability of multiple paths to the same destination via multiple nodes. If this value is 0, there is no association. This object may be equal to the ibSmaNodeGuid of one of the associated nodes if that node is not field-replaceable.')
ibSmaNodeGuid = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 1, 7), IbGuid()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaNodeGuid.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.3; Table 128 NodeInfo.')
if mibBuilder.loadTexts: ibSmaNodeGuid.setStatus('current')
if mibBuilder.loadTexts: ibSmaNodeGuid.setDescription('The GUID of this node. The node can be an HCA, TCA, switch, or router. All ports on the same node shall report the same NodeGUID value. This provides a means for uniquely identifing a node within a subnet and helps to determine the co-location of the ports.')
ibSmaNodePortGuid = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 1, 8), IbGuid()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaNodePortGuid.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.3; Table 128 NodeInfo.')
if mibBuilder.loadTexts: ibSmaNodePortGuid.setStatus('current')
if mibBuilder.loadTexts: ibSmaNodePortGuid.setDescription('The GUID of this port. One port within a node can return the NodeGUID as its PortGUID if the port is an integral part of the node and is not field-replaceable.')
ibSmaNodePartitionTableNum = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaNodePartitionTableNum.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.3; Table 128 NodeInfo.')
if mibBuilder.loadTexts: ibSmaNodePartitionTableNum.setStatus('current')
if mibBuilder.loadTexts: ibSmaNodePartitionTableNum.setDescription('Number of entries in the Partition Table for CA, router, and the switch management port. This is at a minimum set to 1 for all nodes including switches. This value shall be the same for all ports on a node.')
ibSmaNodeDeviceId = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 1, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaNodeDeviceId.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.3; Table 128 NodeInfo.')
if mibBuilder.loadTexts: ibSmaNodeDeviceId.setStatus('current')
if mibBuilder.loadTexts: ibSmaNodeDeviceId.setDescription('Device ID information as assigned by the device manufacturer. This value shall be the same for all ports on a node.')
ibSmaNodeRevision = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 1, 11), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaNodeRevision.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.3; Table 128 NodeInfo.')
if mibBuilder.loadTexts: ibSmaNodeRevision.setStatus('current')
if mibBuilder.loadTexts: ibSmaNodeRevision.setDescription('Device revision as assigned by manufacturer. This value shall be the same for all ports on a node.')
ibSmaNodeLocalPortNumOrZero = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 254))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaNodeLocalPortNumOrZero.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.3; Table 128 NodeInfo.')
if mibBuilder.loadTexts: ibSmaNodeLocalPortNumOrZero.setStatus('current')
if mibBuilder.loadTexts: ibSmaNodeLocalPortNumOrZero.setDescription('The number of the IBA port which received this SNMP request. If the port is unknown a 0 is returned.')
ibSmaNodeVendorId = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 1, 13), OctetString().subtype(subtypeSpec=ValueSizeConstraint(3, 3)).setFixedLength(3)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaNodeVendorId.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.3; Table 128 NodeInfo.')
if mibBuilder.loadTexts: ibSmaNodeVendorId.setStatus('current')
if mibBuilder.loadTexts: ibSmaNodeVendorId.setDescription('Device vendor Identifier as specified by the IEEE. This value shall be the same for all ports on a node.')
ibSmaNodeLid = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: ibSmaNodeLid.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.1; Tables 119--126 Traps and Notice Data Details For Traps nnn.')
if mibBuilder.loadTexts: ibSmaNodeLid.setStatus('current')
if mibBuilder.loadTexts: ibSmaNodeLid.setDescription('Local Identifier value. Used for notification var bind list object. Retrieved from InfiniBand traps 128, 129, 130, 131, 144, 145, 256, 257, 258, and 259.')
ibSmaNodePortNum = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 1, 15), IbDataPort()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: ibSmaNodePortNum.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.1; Tables 119--126 Traps and Notice Data Details For Traps nnn.')
if mibBuilder.loadTexts: ibSmaNodePortNum.setStatus('current')
if mibBuilder.loadTexts: ibSmaNodePortNum.setDescription('Port number. Used for notification var bind list object. Retrieved from InfiniBand traps 129, 130, 131, and 259.')
ibSmaNodeMethod = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: ibSmaNodeMethod.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.1; Tables 119--126 Traps and Notice Data Details For Traps nnn.')
if mibBuilder.loadTexts: ibSmaNodeMethod.setStatus('current')
if mibBuilder.loadTexts: ibSmaNodeMethod.setDescription('Method. Used for notification var bind list object. Retrieved from InfiniBand trap 256.')
ibSmaNodeAttributeId = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 1, 17), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: ibSmaNodeAttributeId.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.1; Tables 119--126 Traps and Notice Data Details For Traps nnn.')
if mibBuilder.loadTexts: ibSmaNodeAttributeId.setStatus('current')
if mibBuilder.loadTexts: ibSmaNodeAttributeId.setDescription('Attribute ID. Used for notification var bind list object. Retrieved from InfiniBand trap 256.')
ibSmaNodeAttributeModifier = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 1, 18), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: ibSmaNodeAttributeModifier.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.1; Tables 119--126 Traps and Notice Data Details For Traps nnn.')
if mibBuilder.loadTexts: ibSmaNodeAttributeModifier.setStatus('current')
if mibBuilder.loadTexts: ibSmaNodeAttributeModifier.setDescription('Attribute Modifier. Used for notification var bind list object. Retrieved from InfiniBand trap 256.')
ibSmaNodeKey = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 1, 19), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: ibSmaNodeKey.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.1; Tables 119--126 Traps and Notice Data Details For Traps nnn.')
if mibBuilder.loadTexts: ibSmaNodeKey.setStatus('current')
if mibBuilder.loadTexts: ibSmaNodeKey.setDescription('M_Key, Q_Key or P_Key. Used for notification var bind list object. Retrieved from InfiniBand traps 256, 257, 258, and 259. Note: If it is a P_Key, the 16 most significant bits of the field shall be set to 0 and the least significant bits of the field will be set to the P_Key.')
ibSmaNodeLid2 = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: ibSmaNodeLid2.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.1; Tables 119--126 Traps and Notice Data Details For Traps nnn.')
if mibBuilder.loadTexts: ibSmaNodeLid2.setStatus('current')
if mibBuilder.loadTexts: ibSmaNodeLid2.setDescription('To Local Identifier (LID). Used for notification var bind list object. Retrieved from InfiniBand traps 257, 258, and 259.')
ibSmaNodeServiceLevel = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: ibSmaNodeServiceLevel.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.1; Tables 119--126 Traps and Notice Data Details For Traps nnn.')
if mibBuilder.loadTexts: ibSmaNodeServiceLevel.setStatus('current')
if mibBuilder.loadTexts: ibSmaNodeServiceLevel.setDescription('Service Level. Used for notification var bind list object. Retrieved from InfiniBand traps 257, 258, and 259.')
ibSmaNodeQueuePair1 = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: ibSmaNodeQueuePair1.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.1; Tables 119--126 Traps and Notice Data Details For Traps nnn.')
if mibBuilder.loadTexts: ibSmaNodeQueuePair1.setStatus('current')
if mibBuilder.loadTexts: ibSmaNodeQueuePair1.setDescription('Queue Pair (QP) 1. Used for notification var bind list object. Retrieved from InfiniBand traps 257, 258, and 259.')
ibSmaNodeQueuePair2 = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: ibSmaNodeQueuePair2.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.1; Tables 119--126 Traps and Notice Data Details For Traps nnn.')
if mibBuilder.loadTexts: ibSmaNodeQueuePair2.setStatus('current')
if mibBuilder.loadTexts: ibSmaNodeQueuePair2.setDescription('Queue Pair (QP) 2. Used for notification var bind list object. Retrieved from InfiniBand traps 257, 258, and 259.')
ibSmaNodeGid1 = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 1, 24), OctetString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: ibSmaNodeGid1.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.1; Tables 119--126 Traps and Notice Data Details For Traps nnn.')
if mibBuilder.loadTexts: ibSmaNodeGid1.setStatus('current')
if mibBuilder.loadTexts: ibSmaNodeGid1.setDescription('Global Identifier 1. Used for notification var bind list object. Retrieved from InfiniBand traps 64, 65, 66, 67, 257, 258, and 259. Note: If no GRH is present in the offending packet, this value will be 0.')
ibSmaNodeGid2 = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 1, 25), OctetString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: ibSmaNodeGid2.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.1; Tables 119--126 Traps and Notice Data Details For Traps nnn.')
if mibBuilder.loadTexts: ibSmaNodeGid2.setStatus('current')
if mibBuilder.loadTexts: ibSmaNodeGid2.setDescription('Global Identifier 2. Used for notification var bind list object. Retrieved from InfiniBand traps 257, 258, and 258. Note: If no GRH is present in the offending packet, this value will be 0.')
ibSmaNodeCapMask = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 1, 26), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: ibSmaNodeCapMask.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.1; Tables 119--126 Traps and Notice Data Details For Traps nnn.')
if mibBuilder.loadTexts: ibSmaNodeCapMask.setStatus('current')
if mibBuilder.loadTexts: ibSmaNodeCapMask.setDescription('Contents of Capability Mask. Retrieved from InfiniBand trap 144.')
ibSmaNodeSwitchLid = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 1, 27), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: ibSmaNodeSwitchLid.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.1; Tables 119--126 Traps and Notice Data Details For Traps nnn.')
if mibBuilder.loadTexts: ibSmaNodeSwitchLid.setStatus('current')
if mibBuilder.loadTexts: ibSmaNodeSwitchLid.setDescription('The switch Local Identifier (LID). Used for notification var bind list object. Retrieved from InfiniBand traps 259.')
ibSmaNodeDataValid = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 1, 28), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: ibSmaNodeDataValid.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.1; Tables 119--126 Traps and Notice Data Details For Traps nnn.')
if mibBuilder.loadTexts: ibSmaNodeDataValid.setStatus('current')
if mibBuilder.loadTexts: ibSmaNodeDataValid.setDescription('Data valid field retrieved from InfiniBand trap 259. It is a bit mask. If the bit is set, the field is valid. bit 0: LIDADDR1 bit 1: LIDADDR2 bit 2: PKEY bit 3: SL bit 4: QP1 bit 5: QP2 bit 6: GIDADDR1 bit 7: GIDADDR2 bit 8-15: reserved (0).')
ibSmaSwitchInfo = MibIdentifier((1, 3, 6, 1, 3, 117, 3, 1, 2))
ibSmaSwLinearFdbTableNum = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 2, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 49151))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaSwLinearFdbTableNum.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.4; Table 129 SwitchInfo.')
if mibBuilder.loadTexts: ibSmaSwLinearFdbTableNum.setStatus('current')
if mibBuilder.loadTexts: ibSmaSwLinearFdbTableNum.setDescription('Number of entries in the Linear Forwarding Data Base. This counts the number of entries supported in the Linear Unicast Forwarding Table (starting at LID=0x0000 and going up). The InfiniBand SwitchInfo component is called LinearFDBCap. When this count is 0, this indicates that there is no Linear Forwarding Database present.')
ibSmaSwRandomFdbTableNum = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 2, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 49151))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaSwRandomFdbTableNum.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.4; Table 129 SwitchInfo.')
if mibBuilder.loadTexts: ibSmaSwRandomFdbTableNum.setStatus('current')
if mibBuilder.loadTexts: ibSmaSwRandomFdbTableNum.setDescription('Number of entries in the Random Forwarding Data Base. This counts the number of entries supported in the Random Unicast Forwarding Table. The InfiniBand SwitchInfo component is called RandomFDBCap. When this count is 0, this indicates that there is no Random Forwarding Database present.')
ibSmaSwMulticastFdbTableNum = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 2, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16383))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaSwMulticastFdbTableNum.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.4; Table 129 SwitchInfo.')
if mibBuilder.loadTexts: ibSmaSwMulticastFdbTableNum.setStatus('current')
if mibBuilder.loadTexts: ibSmaSwMulticastFdbTableNum.setDescription('Number of entries in the Multicast Forwarding Data Base. This counts the number of entries supported in the Multicast Forwarding Table (starting at LID=0xC000 and going up). The InfiniBand SwitchInfo component is called MulticastFDBCap.')
ibSmaSwLinearFdbTop = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 2, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 49151))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaSwLinearFdbTop.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.4; Table 129 SwitchInfo.')
if mibBuilder.loadTexts: ibSmaSwLinearFdbTop.setStatus('current')
if mibBuilder.loadTexts: ibSmaSwLinearFdbTop.setDescription('Indicates the top of the linear forwarding database. Packets received with unicast DLIDs greater than this value are discarded by the switch. A valid LinearFdbTop is less than LinearFdbCap. This component applies only to switches that implement linear forwarding tables and is ignored by switches that implement random forwarding tables. For the latter cases a 0 is returned.')
ibSmaSwDefaultPort = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 2, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 254))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaSwDefaultPort.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.4; Table 129 SwitchInfo.')
if mibBuilder.loadTexts: ibSmaSwDefaultPort.setStatus('current')
if mibBuilder.loadTexts: ibSmaSwDefaultPort.setDescription('Default forwarding port for unicast packets from the other ports whose DLID does not exist in the random forwarding table. If the port number is unknown, a 0 is returned. If this object is set to a non-existent port, subsequent responses may contain any non-existent port number.')
ibSmaSwDefMcastPriPort = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 2, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 254))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaSwDefMcastPriPort.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.4; Table 129 SwitchInfo. Also section 18.2.4.3.3 on Required Multicast Relay.')
if mibBuilder.loadTexts: ibSmaSwDefMcastPriPort.setStatus('current')
if mibBuilder.loadTexts: ibSmaSwDefMcastPriPort.setDescription('Default forwarding port for multicast packets from the other ports whose DLID does not exist in the forwarding table. If port number is unknown, a 0 is returned. If this object is set to a non-existent port, subsequent responses may contain any non-existent port number.')
ibSmaSwDefMcastNotPriPort = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 2, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 254))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaSwDefMcastNotPriPort.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.4; Table 129 SwitchInfo. Also section 18.2.4.3.3 on Required Multicast Relay.')
if mibBuilder.loadTexts: ibSmaSwDefMcastNotPriPort.setStatus('current')
if mibBuilder.loadTexts: ibSmaSwDefMcastNotPriPort.setDescription('Forward to this port all the multicast packets from the Default Primary port whose DLID does not exist in the forwarding table. If it is unknown, a 0 is returned. If this object is set to a non-existent port, subsequent responses may contain any non-existent port number.')
ibSmaSwLifeTimeValue = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 2, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaSwLifeTimeValue.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.4; Table 129 SwitchInfo. Also section 18.2.5.4 on Transmitter Queueing.')
if mibBuilder.loadTexts: ibSmaSwLifeTimeValue.setStatus('current')
if mibBuilder.loadTexts: ibSmaSwLifeTimeValue.setDescription('Sets the time a packet can live in the switch. This Lifetime Value (LV) is used as a parameter to calculate Switch Lifetime Limit (SLL) value. To calculate a valid SLL, the LV must be between 0 and 19, inclusive. If the LV value is greater than 19, the SLL is to be interpreted as infinite.')
ibSmaSwPortStateChange = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 2, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaSwPortStateChange.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.4; Table 129 SwitchInfo.')
if mibBuilder.loadTexts: ibSmaSwPortStateChange.setStatus('current')
if mibBuilder.loadTexts: ibSmaSwPortStateChange.setDescription('This object is set to 1 whenever the PortState component makes any of the following state changes in the link FSM: Down-->Initialize, Initialize-->Down, Armed-->Down, or Active-->Down Also, changes in PortState resulting from SubnSet IBA command do not change this bit. This object is set to 0 when the SMA writes a 1; writing a 0 is ignored.')
ibSmaSwLidsPerPort = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 2, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaSwLidsPerPort.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.4; Table 129 SwitchInfo.')
if mibBuilder.loadTexts: ibSmaSwLidsPerPort.setStatus('current')
if mibBuilder.loadTexts: ibSmaSwLidsPerPort.setDescription('Specifies the number of LID/LMC combinations that may be assigned to a given external port for switches that support the Random Forwarding table.')
ibSmaSwPartitionEnforceNum = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 2, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaSwPartitionEnforceNum.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.4; Table 129 SwitchInfo.')
if mibBuilder.loadTexts: ibSmaSwPartitionEnforceNum.setStatus('current')
if mibBuilder.loadTexts: ibSmaSwPartitionEnforceNum.setDescription('Specifies the number of entries in the partition enforcement table per physical IBA port. The 0 value indicates that partition enforcement is not supported by the switch.')
ibSmaSwInboundEnforceCap = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 2, 12), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaSwInboundEnforceCap.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.4; Table 129 SwitchInfo.')
if mibBuilder.loadTexts: ibSmaSwInboundEnforceCap.setStatus('current')
if mibBuilder.loadTexts: ibSmaSwInboundEnforceCap.setDescription('Flag that indicates whether the switch is capable of partition enforcement on received packets.')
ibSmaSwOutboundEnforceCap = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 2, 13), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaSwOutboundEnforceCap.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.4; Table 129 SwitchInfo.')
if mibBuilder.loadTexts: ibSmaSwOutboundEnforceCap.setStatus('current')
if mibBuilder.loadTexts: ibSmaSwOutboundEnforceCap.setDescription('Flag that indicates whether the switch is capable of partition enforcement on transmitted packets.')
ibSmaSwFilterRawPktInputCap = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 2, 14), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaSwFilterRawPktInputCap.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.4; Table 129 SwitchInfo.')
if mibBuilder.loadTexts: ibSmaSwFilterRawPktInputCap.setStatus('current')
if mibBuilder.loadTexts: ibSmaSwFilterRawPktInputCap.setDescription('Flag to indicate whether the switch is capable of raw packet enforcement on received packets.')
ibSmaSwFilterRawPktOutputCap = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 2, 15), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaSwFilterRawPktOutputCap.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.4; Table 129 SwitchInfo.')
if mibBuilder.loadTexts: ibSmaSwFilterRawPktOutputCap.setStatus('current')
if mibBuilder.loadTexts: ibSmaSwFilterRawPktOutputCap.setDescription('Flag to indicate whether the switch is capable of raw packet enforcement on transmitted packets.')
ibSmaSwEnhancedPort0 = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 2, 16), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaSwEnhancedPort0.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.4; Table 129 SwitchInfo.')
if mibBuilder.loadTexts: ibSmaSwEnhancedPort0.setStatus('current')
if mibBuilder.loadTexts: ibSmaSwEnhancedPort0.setDescription('Flag to indicate whether switch port 0 supports enhanced functions (TCA port). If false, switch port 0 is a base switch port 0.')
ibSmaGuidInfo = MibIdentifier((1, 3, 6, 1, 3, 117, 3, 1, 3))
ibSmaGuidInfoTable = MibTable((1, 3, 6, 1, 3, 117, 3, 1, 3, 1), )
if mibBuilder.loadTexts: ibSmaGuidInfoTable.setStatus('current')
if mibBuilder.loadTexts: ibSmaGuidInfoTable.setDescription('A table containing SMA GUID information.')
ibGuidInfoEntry = MibTableRow((1, 3, 6, 1, 3, 117, 3, 1, 3, 1, 1), ).setIndexNames((0, "SMA-MIB", "ibSmaGuidPortIndex"), (0, "SMA-MIB", "ibSmaGuidIndex"))
if mibBuilder.loadTexts: ibGuidInfoEntry.setStatus('current')
if mibBuilder.loadTexts: ibGuidInfoEntry.setDescription('A conceptual row of the ibSmaGuidInfoTable containing information about a particular GUID entry.')
ibSmaGuidPortIndex = MibTableColumn((1, 3, 6, 1, 3, 117, 3, 1, 3, 1, 1, 1), IbDataPort())
if mibBuilder.loadTexts: ibSmaGuidPortIndex.setStatus('current')
if mibBuilder.loadTexts: ibSmaGuidPortIndex.setDescription('Index that identifies IB port assoicated with this GUID table.')
ibSmaGuidIndex = MibTableColumn((1, 3, 6, 1, 3, 117, 3, 1, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)))
if mibBuilder.loadTexts: ibSmaGuidIndex.setStatus('current')
if mibBuilder.loadTexts: ibSmaGuidIndex.setDescription('Index that identifies the GUID entry for this port. For any IB port there can be multiple 64 bit GUIDs assigned. The maximum number is implementationdependent. If the port does not have a GUID assigned to it, the row will have 1 entry with a 0 value.')
ibSmaGuidVal = MibTableColumn((1, 3, 6, 1, 3, 117, 3, 1, 3, 1, 1, 3), IbGuid()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaGuidVal.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.5; Table 130 GUIDInfo and Table 131 GUID Block Element.')
if mibBuilder.loadTexts: ibSmaGuidVal.setStatus('current')
if mibBuilder.loadTexts: ibSmaGuidVal.setDescription('The Global Unique Identifier (GUID) for this port entity.')
ibSmaMgmtPortInfo = MibIdentifier((1, 3, 6, 1, 3, 117, 3, 1, 4))
ibSmaDataPortInfo = MibIdentifier((1, 3, 6, 1, 3, 117, 3, 1, 5))
ibSmaPortMKey = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 4, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaPortMKey.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.6; Table 132 PortInfo. Also see Section 14.2.4.')
if mibBuilder.loadTexts: ibSmaPortMKey.setStatus('current')
if mibBuilder.loadTexts: ibSmaPortMKey.setDescription("The 8-byte management key that is kept locally on each port. If the value is 0's, no authentication is done.")
ibSmaPortGidPrefix = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 4, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaPortGidPrefix.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.6; Table 132 PortInfo.')
if mibBuilder.loadTexts: ibSmaPortGidPrefix.setStatus('current')
if mibBuilder.loadTexts: ibSmaPortGidPrefix.setDescription('GID prefix for this port.')
ibSmaPortLid = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 4, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 49151))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaPortLid.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.6; Table 132 PortInfo.')
if mibBuilder.loadTexts: ibSmaPortLid.setStatus('current')
if mibBuilder.loadTexts: ibSmaPortLid.setDescription('The base LID of this port.')
ibSmaPortMasterSmLid = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 4, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 49151))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaPortMasterSmLid.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.6; Table 132 PortInfo.')
if mibBuilder.loadTexts: ibSmaPortMasterSmLid.setStatus('current')
if mibBuilder.loadTexts: ibSmaPortMasterSmLid.setDescription('The LID of the master SM that is managing this port.')
ibSmaPortIsSubnetManager = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 4, 5), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaPortIsSubnetManager.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.6; Table 132 PortInfo.')
if mibBuilder.loadTexts: ibSmaPortIsSubnetManager.setStatus('current')
if mibBuilder.loadTexts: ibSmaPortIsSubnetManager.setDescription('Capability flag for this node: Is Subnet Manager?')
ibSmaPortIsNoticeSupported = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 4, 6), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaPortIsNoticeSupported.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.6; Table 132 PortInfo.')
if mibBuilder.loadTexts: ibSmaPortIsNoticeSupported.setStatus('current')
if mibBuilder.loadTexts: ibSmaPortIsNoticeSupported.setDescription('Capability flag for this node: Are Notices Supported?')
ibSmaPortIsTrapSupported = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 4, 7), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaPortIsTrapSupported.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.6; Table 132 PortInfo.')
if mibBuilder.loadTexts: ibSmaPortIsTrapSupported.setStatus('current')
if mibBuilder.loadTexts: ibSmaPortIsTrapSupported.setDescription('Capability flag for this node: Are IBA Traps Supported?')
ibSmaPortIsAutoMigrateSupported = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 4, 8), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaPortIsAutoMigrateSupported.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.6; Table 132 PortInfo.')
if mibBuilder.loadTexts: ibSmaPortIsAutoMigrateSupported.setStatus('current')
if mibBuilder.loadTexts: ibSmaPortIsAutoMigrateSupported.setDescription('Capability flag for this node: Is Automatic Migration Supported?')
ibSmaPortIsSlMappingSupported = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 4, 9), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaPortIsSlMappingSupported.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.6; Table 132 PortInfo.')
if mibBuilder.loadTexts: ibSmaPortIsSlMappingSupported.setStatus('current')
if mibBuilder.loadTexts: ibSmaPortIsSlMappingSupported.setDescription('Capability flag for this node: Is SL Mapping Supported?')
ibSmaPortIsMKeyNvram = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 4, 10), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaPortIsMKeyNvram.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.6; Table 132 PortInfo.')
if mibBuilder.loadTexts: ibSmaPortIsMKeyNvram.setStatus('current')
if mibBuilder.loadTexts: ibSmaPortIsMKeyNvram.setDescription('Capability flag for this node: Is M_Key in NVRAM?')
ibSmaPortIsPKeyNvram = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 4, 11), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaPortIsPKeyNvram.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.6; Table 132 PortInfo.')
if mibBuilder.loadTexts: ibSmaPortIsPKeyNvram.setStatus('current')
if mibBuilder.loadTexts: ibSmaPortIsPKeyNvram.setDescription('Capability flag for this node: Is P_Key in NVRAM?')
ibSmaPortIsLedInfoSupported = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 4, 12), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaPortIsLedInfoSupported.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.6; Table 132 PortInfo.')
if mibBuilder.loadTexts: ibSmaPortIsLedInfoSupported.setStatus('current')
if mibBuilder.loadTexts: ibSmaPortIsLedInfoSupported.setDescription('Capability flag for this node: Is LED Information Supported?')
ibSmaPortIsSmDisabled = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 4, 13), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaPortIsSmDisabled.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.6; Table 132 PortInfo.')
if mibBuilder.loadTexts: ibSmaPortIsSmDisabled.setStatus('current')
if mibBuilder.loadTexts: ibSmaPortIsSmDisabled.setDescription('Capability flag for this node: Is Subnet Manager Disabeld?')
ibSmaPortIsSysImgGuidSupported = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 4, 14), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaPortIsSysImgGuidSupported.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.6; Table 132 PortInfo.')
if mibBuilder.loadTexts: ibSmaPortIsSysImgGuidSupported.setStatus('current')
if mibBuilder.loadTexts: ibSmaPortIsSysImgGuidSupported.setDescription('Capability flag for this node: Is System Image GUID Supported?')
ibSmaPortIsPKeyExtPortTrapSup = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 4, 15), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaPortIsPKeyExtPortTrapSup.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.6; Table 132 PortInfo.')
if mibBuilder.loadTexts: ibSmaPortIsPKeyExtPortTrapSup.setStatus('current')
if mibBuilder.loadTexts: ibSmaPortIsPKeyExtPortTrapSup.setDescription('Capability flag for this node: Is P_Key Switch External Port Trap supported?')
ibSmaPortIsCommManageSupported = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 4, 16), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaPortIsCommManageSupported.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.6; Table 132 PortInfo.')
if mibBuilder.loadTexts: ibSmaPortIsCommManageSupported.setStatus('current')
if mibBuilder.loadTexts: ibSmaPortIsCommManageSupported.setDescription('Capability flag for this node: Is Communication Management Supported?')
ibSmaPortIsSnmpTunnelSupported = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 4, 17), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaPortIsSnmpTunnelSupported.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.6; Table 132 PortInfo.')
if mibBuilder.loadTexts: ibSmaPortIsSnmpTunnelSupported.setStatus('current')
if mibBuilder.loadTexts: ibSmaPortIsSnmpTunnelSupported.setDescription('Capability flag for this node: Is SNMP Tunneling Supported?')
ibSmaPortIsReinitSupported = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 4, 18), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaPortIsReinitSupported.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.6; Table 132 PortInfo.')
if mibBuilder.loadTexts: ibSmaPortIsReinitSupported.setStatus('current')
if mibBuilder.loadTexts: ibSmaPortIsReinitSupported.setDescription('Capability flag for this node: Is Reinitialization Supported?')
ibSmaPortIsDevManageSupported = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 4, 19), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaPortIsDevManageSupported.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.6; Table 132 PortInfo.')
if mibBuilder.loadTexts: ibSmaPortIsDevManageSupported.setStatus('current')
if mibBuilder.loadTexts: ibSmaPortIsDevManageSupported.setDescription('Capability flag for this node: Is Device Management Supported?')
ibSmaPortIsVendorClassSupported = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 4, 20), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaPortIsVendorClassSupported.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.6; Table 132 PortInfo.')
if mibBuilder.loadTexts: ibSmaPortIsVendorClassSupported.setStatus('current')
if mibBuilder.loadTexts: ibSmaPortIsVendorClassSupported.setDescription('Capability flag for this node: Is Vendor Class Supported?')
ibSmaPortIsDrNoticeSupported = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 4, 21), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaPortIsDrNoticeSupported.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.6; Table 132 PortInfo.')
if mibBuilder.loadTexts: ibSmaPortIsDrNoticeSupported.setStatus('current')
if mibBuilder.loadTexts: ibSmaPortIsDrNoticeSupported.setDescription('Capability flag for this node: Is DR Notice Supported?')
ibSmaPortIsCapMaskNoticSupported = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 4, 22), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaPortIsCapMaskNoticSupported.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.6; Table 132 PortInfo.')
if mibBuilder.loadTexts: ibSmaPortIsCapMaskNoticSupported.setStatus('current')
if mibBuilder.loadTexts: ibSmaPortIsCapMaskNoticSupported.setDescription('Capability flag for this node: Is Capability Mask Notice Supported?')
ibSmaPortIsBootMgmtSupported = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 4, 23), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaPortIsBootMgmtSupported.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.6; Table 132 PortInfo.')
if mibBuilder.loadTexts: ibSmaPortIsBootMgmtSupported.setStatus('current')
if mibBuilder.loadTexts: ibSmaPortIsBootMgmtSupported.setDescription('Capability flag for this node: Is Boot Management Supported?')
ibSmaPortMKeyLeasePeriod = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 4, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaPortMKeyLeasePeriod.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.6; Table 132 PortInfo; Also Section 14.2.4.2.')
if mibBuilder.loadTexts: ibSmaPortMKeyLeasePeriod.setStatus('current')
if mibBuilder.loadTexts: ibSmaPortMKeyLeasePeriod.setDescription('Specifies the initial value of the lease period timer (in seconds). The lease period is the length of time that the M_Key Protection bits are to remain non-zero after a SubnSet(PortInfo) fails the M_Key authentication check. When the value is 0, the lease period shall never expire.')
ibSmaPortMKeyProtectBits = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 4, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("noMKeyProtection", 1), ("succeedWithReturnKey", 2), ("succeedWithReturnZeroes", 3), ("failOnNoMatch", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaPortMKeyProtectBits.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.6; Table 132 PortInfo; Also Section 14.2.4.1; Table 115 explains the Protection Levels.')
if mibBuilder.loadTexts: ibSmaPortMKeyProtectBits.setStatus('current')
if mibBuilder.loadTexts: ibSmaPortMKeyProtectBits.setDescription('Management Key (M_Key) protection bits. Management Key must have a non-zero value.')
ibSmaPortMasterSmSl = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 4, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaPortMasterSmSl.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.6; Table 132 PortInfo.')
if mibBuilder.loadTexts: ibSmaPortMasterSmSl.setStatus('current')
if mibBuilder.loadTexts: ibSmaPortMasterSmSl.setDescription('The administrative Service Level of the master SM that is managing this port. ')
ibSmaPortInitTypeLoad = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 4, 27), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaPortInitTypeLoad.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.6; Table 132 PortInfo.')
if mibBuilder.loadTexts: ibSmaPortInitTypeLoad.setStatus('current')
if mibBuilder.loadTexts: ibSmaPortInitTypeLoad.setDescription('The initialization type flags indicate the type of intialization requested by this port before SM moves it to Active or Armed state. Initialization Type flag: NoLoad. If the value is false(2), the attributes should be initialized. If the value is true(1), no data should be loaded into the attributes at all, asserting that the last-loaded data still exists and is valid.')
ibSmaPortInitTypeContent = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 4, 28), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaPortInitTypeContent.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.6; Table 132 PortInfo.')
if mibBuilder.loadTexts: ibSmaPortInitTypeContent.setStatus('current')
if mibBuilder.loadTexts: ibSmaPortInitTypeContent.setDescription('Initialization Type flag: PreserveContent. If the value is false(2), the port makes no request regarding the content of the data that is loaded into its attributes. If it is true(1), the port is requesting that all such data, if loaded, be set to the most recent content loaded by the SM.')
ibSmaPortInitTypePresence = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 4, 29), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaPortInitTypePresence.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.6; Table 132 PortInfo.')
if mibBuilder.loadTexts: ibSmaPortInitTypePresence.setStatus('current')
if mibBuilder.loadTexts: ibSmaPortInitTypePresence.setDescription('Initialization Type flag: PreservePresence. If the value is false(2), the port is requesting that all settable SA attributes referencing this port be removed prior to activating this port and Traps 64/65 be sent. If the value is true(1), the port is requesting that all such data be preserved, and that the traps not be sent.')
ibSmaPortInitTypeResuscitate = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 4, 30), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaPortInitTypeResuscitate.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.6; Table 132 PortInfo.')
if mibBuilder.loadTexts: ibSmaPortInitTypeResuscitate.setStatus('current')
if mibBuilder.loadTexts: ibSmaPortInitTypeResuscitate.setDescription('Initialization Type flag: DoNotResuscitate. If the value is false(2), ibSmaPortInitTypeLoad, ibSmaPortInitTypeContent, and ibSmaPortInitTypePresence ARE valid. If the value is true(1), ibSmaPortInitTypeLoad, ibSmaPortInitTypeContent, and ibSmaPortInitTypePresence ARE NOT valid. The port is requesting that reinitialization of this port and the in/out of service traps (64/65) be delayed until this flag is set to false(1).')
ibSmaPortInitNoLoadReply = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 4, 31), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaPortInitNoLoadReply.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.6; Table 132 PortInfo.')
if mibBuilder.loadTexts: ibSmaPortInitNoLoadReply.setStatus('current')
if mibBuilder.loadTexts: ibSmaPortInitNoLoadReply.setDescription('The Init Reply flags are written by the SM prior to changing the port to Active or Armed state. Initialization Type Reply flag: NoLoadReply. If this value is false(2), the port attributes were initialized. If the value is true(1), no data was loaded into the port attributes.')
ibSmaPortInitPreserveContReply = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 4, 32), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaPortInitPreserveContReply.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.6; Table 132 PortInfo.')
if mibBuilder.loadTexts: ibSmaPortInitPreserveContReply.setStatus('current')
if mibBuilder.loadTexts: ibSmaPortInitPreserveContReply.setDescription('Initialization Type flag: PreserveContentReply. If this value is false(2), no information is available regarding the content of the data loaded into the port attributes. If the value is true(1), the data loaded into the port attributes was set to the content most recently loaded by the SM.')
ibSmaPortInitPreservePresReply = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 4, 33), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaPortInitPreservePresReply.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.6; Table 132 PortInfo.')
if mibBuilder.loadTexts: ibSmaPortInitPreservePresReply.setStatus('current')
if mibBuilder.loadTexts: ibSmaPortInitPreservePresReply.setDescription('Initialization Type Reply flag: PreservePresenceReply. If this value is false(2), all settable SA attributes referencing this port were removed prior to activating this port and the in/out service traps 64 and 65 were sent. If the value is true(1), all such data existing when this port was last active was not removed and the traps 64/65 were not sent.')
ibSmaPortMKeyViolations = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 4, 34), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaPortMKeyViolations.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.6; Table 132 PortInfo.')
if mibBuilder.loadTexts: ibSmaPortMKeyViolations.setStatus('current')
if mibBuilder.loadTexts: ibSmaPortMKeyViolations.setDescription("Counts the number of SMP packets that have been received at this port that have invalid M_Keys. This object is a latching gauge, in that whenever the maximum gauge value is encounterd (i.e., the count reaches all 1's), the SMA must reset the gauge to 0, before this object begins incrementing its count again.")
ibSmaPortPKeyViolations = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 4, 35), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaPortPKeyViolations.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.6; Table 132 PortInfo; Also Section 10.9.4.')
if mibBuilder.loadTexts: ibSmaPortPKeyViolations.setStatus('current')
if mibBuilder.loadTexts: ibSmaPortPKeyViolations.setDescription("Counts the number of SMP packets that have been received at this port that have invalid P_Keys. This object is a latching gauge, in that whenever the maximum gauge value is encounterd (i.e., the count reaches all 1's), the SMA must reset the gauge to 0, before this object begins incrementing its count again.")
ibSmaPortQKeyViolations = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 4, 36), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaPortQKeyViolations.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.6; Table 132 PortInfo; Also see Section 10.2.4.')
if mibBuilder.loadTexts: ibSmaPortQKeyViolations.setStatus('current')
if mibBuilder.loadTexts: ibSmaPortQKeyViolations.setDescription("Counts the number of SMP packets that have been received at this port that have invalid Q_Keys. This object is a latching gauge, in that whenever the maximum gauge value is encounterd (i.e., the count reaches all 1's), the SMA must reset the gauge to 0, before this object begins incrementing its count again.")
ibSmaPortNumGuid = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 4, 37), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaPortNumGuid.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.6; Table 132 PortInfo.')
if mibBuilder.loadTexts: ibSmaPortNumGuid.setStatus('current')
if mibBuilder.loadTexts: ibSmaPortNumGuid.setDescription('Number of GUID entries supported in the GUIDInfo attribute for this port.')
ibSmaPortSubnetTimeout = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 4, 38), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaPortSubnetTimeout.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.6; Table 132 PortInfo.')
if mibBuilder.loadTexts: ibSmaPortSubnetTimeout.setStatus('current')
if mibBuilder.loadTexts: ibSmaPortSubnetTimeout.setDescription('Specifies the maximum expected subnet propagation delay, which depends upon the configuration of the switches, to reach any other port in the subnet and shall also be used to determine the maximum rate which SubnTraps() can be sent from this port by the SMA.')
ibSmaPortResponseTimeValue = MibScalar((1, 3, 6, 1, 3, 117, 3, 1, 4, 39), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaPortResponseTimeValue.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.6; Table 132 PortInfo.')
if mibBuilder.loadTexts: ibSmaPortResponseTimeValue.setStatus('current')
if mibBuilder.loadTexts: ibSmaPortResponseTimeValue.setDescription('Specifies the expected maximum time between the port reception of a SMP and the transmission of the associated response.')
ibSmaPortInfoTable = MibTable((1, 3, 6, 1, 3, 117, 3, 1, 5, 1), )
if mibBuilder.loadTexts: ibSmaPortInfoTable.setStatus('current')
if mibBuilder.loadTexts: ibSmaPortInfoTable.setDescription('A table containing SMA PortInfo information.')
ibSmaPortInfoEntry = MibTableRow((1, 3, 6, 1, 3, 117, 3, 1, 5, 1, 1), ).setIndexNames((0, "SMA-MIB", "ibSmaPortIndex"))
if mibBuilder.loadTexts: ibSmaPortInfoEntry.setStatus('current')
if mibBuilder.loadTexts: ibSmaPortInfoEntry.setDescription('A conceptual row of the ibSmaPortInfoTable containing information about a particular data port and its attributes.')
ibSmaPortIndex = MibTableColumn((1, 3, 6, 1, 3, 117, 3, 1, 5, 1, 1, 1), IbDataPort())
if mibBuilder.loadTexts: ibSmaPortIndex.setStatus('current')
if mibBuilder.loadTexts: ibSmaPortIndex.setDescription('Index that identifies the InfiniBand data port.')
ibSmaPortLinkWidthEnabled = MibTableColumn((1, 3, 6, 1, 3, 117, 3, 1, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("noStateChange", 1), ("oneX", 2), ("fourX", 3), ("oneXOr4X", 4), ("twelveX", 5), ("oneXOr12X", 6), ("fourXOr12X", 7), ("oneX4XOr12X", 8), ("linkWidthSupported", 9), ("other", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaPortLinkWidthEnabled.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.6; Table 132 PortInfo.')
if mibBuilder.loadTexts: ibSmaPortLinkWidthEnabled.setStatus('current')
if mibBuilder.loadTexts: ibSmaPortLinkWidthEnabled.setDescription('Enabled link width, indicated as follows: 0: No State Change (NOP) 1: 1x 2: 4x 3: 1x or 4x 8: 12x 9: 1x or 12x 10: 4x or 12x 11: 1x, 4x or 12x 4 - 7, 12 - 254: Reserved (Ignored) 255: Set to LinkWidthSupported value.')
ibSmaPortLinkWidthSupported = MibTableColumn((1, 3, 6, 1, 3, 117, 3, 1, 5, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("oneX", 1), ("oneXOr4X", 2), ("oneX4XOr12X", 3), ("other", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaPortLinkWidthSupported.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.6; Table 132 PortInfo.')
if mibBuilder.loadTexts: ibSmaPortLinkWidthSupported.setStatus('current')
if mibBuilder.loadTexts: ibSmaPortLinkWidthSupported.setDescription('Supported link width for this port. This is indicated as follows by the SMA: 1: 1x 3: 1x or 4x 11: 1x, 4x or 12x 0, 2, 4-10, 12-255: Reserved.')
ibSmaPortLinkWidthActive = MibTableColumn((1, 3, 6, 1, 3, 117, 3, 1, 5, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("oneX", 1), ("fourX", 2), ("twelveX", 3), ("other", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaPortLinkWidthActive.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.6; Table 132 PortInfo.')
if mibBuilder.loadTexts: ibSmaPortLinkWidthActive.setStatus('current')
if mibBuilder.loadTexts: ibSmaPortLinkWidthActive.setDescription('Currently active link width on this port. This is indicated as follows by the SMA: 1: 1x 2: 4x 8: 12x 0, 3, 4-7, 9-255: Reserved.')
ibSmaPortLinkSpeedSupported = MibTableColumn((1, 3, 6, 1, 3, 117, 3, 1, 5, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("twoPoint5Gbps", 1), ("other", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaPortLinkSpeedSupported.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.6; Table 132 PortInfo.')
if mibBuilder.loadTexts: ibSmaPortLinkSpeedSupported.setStatus('current')
if mibBuilder.loadTexts: ibSmaPortLinkSpeedSupported.setDescription('Supported link speed, indicated as follows: 1: 2.5Gbps 0, 2 - 15: reserved ')
ibSmaPortLinkState = MibTableColumn((1, 3, 6, 1, 3, 117, 3, 1, 5, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("noChange", 1), ("down", 2), ("init", 3), ("armed", 4), ("active", 5), ("other", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaPortLinkState.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.6; Table 132 PortInfo.')
if mibBuilder.loadTexts: ibSmaPortLinkState.setStatus('current')
if mibBuilder.loadTexts: ibSmaPortLinkState.setDescription('The state of the link on this port. 0: No state change 1: Down (includes failed links) 2: Initialize 3: Armed 4: Active 5-15: Reserved')
ibSmaPortPhysState = MibTableColumn((1, 3, 6, 1, 3, 117, 3, 1, 5, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("noChange", 1), ("sleep", 2), ("polling", 3), ("disabled", 4), ("portConfigTraining", 5), ("linkUp", 6), ("linkErrorRecovery", 7), ("other", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaPortPhysState.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.6; Table 132 PortInfo.')
if mibBuilder.loadTexts: ibSmaPortPhysState.setStatus('current')
if mibBuilder.loadTexts: ibSmaPortPhysState.setDescription('Physical Port State. Enumerated as: 0: No state change 1: Sleep 2: Polling 3: Disabled 4: PortConfigurationTraining 5: LinkUp 6: LinkErrorRecovery 7 - 15: Reserved')
ibSmaPortLinkDownDefaultState = MibTableColumn((1, 3, 6, 1, 3, 117, 3, 1, 5, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("noChange", 1), ("sleep", 2), ("polling", 3), ("other", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaPortLinkDownDefaultState.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.6; Table 132 PortInfo.')
if mibBuilder.loadTexts: ibSmaPortLinkDownDefaultState.setStatus('current')
if mibBuilder.loadTexts: ibSmaPortLinkDownDefaultState.setDescription('LinkDownDefault-State 0: No state change 1: Sleep 2: Polling 3-15: Reserved')
ibSmaPortLidMaskCount = MibTableColumn((1, 3, 6, 1, 3, 117, 3, 1, 5, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaPortLidMaskCount.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.6; Table 132 PortInfo. Also Section 7.11.1 Multipathing Requirements on End Node.')
if mibBuilder.loadTexts: ibSmaPortLidMaskCount.setStatus('current')
if mibBuilder.loadTexts: ibSmaPortLidMaskCount.setDescription('LID Mask Control count for multipath support for CA and router ports.')
ibSmaPortLinkSpeedActive = MibTableColumn((1, 3, 6, 1, 3, 117, 3, 1, 5, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("twoPoint5Gbps", 1), ("other", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaPortLinkSpeedActive.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.6; Table 132 PortInfo.')
if mibBuilder.loadTexts: ibSmaPortLinkSpeedActive.setStatus('current')
if mibBuilder.loadTexts: ibSmaPortLinkSpeedActive.setDescription('Currently active link speed, indicated as follows: 1: 2.5Gbps 0, 2 - 15: reserved.')
ibSmaPortLinkSpeedEnabled = MibTableColumn((1, 3, 6, 1, 3, 117, 3, 1, 5, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("noStateChange", 1), ("twoPoint5Gbps", 2), ("linkSpeedSupported", 3), ("other", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaPortLinkSpeedEnabled.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.6; Table 132 PortInfo.')
if mibBuilder.loadTexts: ibSmaPortLinkSpeedEnabled.setStatus('current')
if mibBuilder.loadTexts: ibSmaPortLinkSpeedEnabled.setDescription('Enabled link speed, indicated as follows: 0: No State Change (NOP) 1: 2.5 Gbps 2 - 14: Reserved (Ignored) 15: Set to LinkSpeedSupported value.')
ibSmaPortNeighborMtu = MibTableColumn((1, 3, 6, 1, 3, 117, 3, 1, 5, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("mtu256", 1), ("mtu512", 2), ("mtu1024", 3), ("mtu2048", 4), ("mtu4096", 5), ("other", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaPortNeighborMtu.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.6; Table 132 PortInfo.')
if mibBuilder.loadTexts: ibSmaPortNeighborMtu.setStatus('current')
if mibBuilder.loadTexts: ibSmaPortNeighborMtu.setDescription('Active maximum MTU enabled on this port for transmit: 1: 256 bytes 2: 512 bytes 3: 1024 bytes 4: 2048 bytes 5: 4096 bytes 0, 6 - 15: reserved ')
ibSmaPortVirtLaneSupport = MibTableColumn((1, 3, 6, 1, 3, 117, 3, 1, 5, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("vl0", 1), ("vl0ToVl1", 2), ("vl0ToVl3", 3), ("vl0ToVl7", 4), ("vl0ToVl14", 5), ("other", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaPortVirtLaneSupport.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.6; Table 132 PortInfo.')
if mibBuilder.loadTexts: ibSmaPortVirtLaneSupport.setStatus('current')
if mibBuilder.loadTexts: ibSmaPortVirtLaneSupport.setDescription('Virtual Lane configuration supported on this port. Indicated as as follows by the SMA: 1: VL0 2: VL0, VL1 3: VL0 - VL3 4: VL0 - VL7 5: VL0 - VL14 0, 6 - 15: reserved.')
ibSmaPortVlHighPriorityLimit = MibTableColumn((1, 3, 6, 1, 3, 117, 3, 1, 5, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaPortVlHighPriorityLimit.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.6; Table 132 PortInfo; See also Section 7.6.9.')
if mibBuilder.loadTexts: ibSmaPortVlHighPriorityLimit.setStatus('current')
if mibBuilder.loadTexts: ibSmaPortVlHighPriorityLimit.setDescription('Limit of High Priority component of VL Arbitration Table. This object indicates the amount of high priority packets that can be trasnmitted wihout an opportunity to send a low priority packet. Specifically, the number of bytes that can be sent is this value times 4K bytes. A 255 value means the byte limit is unbounded and a value of 0 means that only a single packet from the high-priority table may be sent before an opportunity is given to the low- priority table.')
ibSmaPortVlArbHighCapacity = MibTableColumn((1, 3, 6, 1, 3, 117, 3, 1, 5, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaPortVlArbHighCapacity.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.6; Table 132 PortInfo; Also Section 7.6.9.')
if mibBuilder.loadTexts: ibSmaPortVlArbHighCapacity.setStatus('current')
if mibBuilder.loadTexts: ibSmaPortVlArbHighCapacity.setDescription('VL/Weight pairs supported on this port in the VLArbitration table for high priority. Shall be 1 to 64 if more than one data VL is supported on this port, 0 otherwise.')
ibSmaPortVlArbLowCapacity = MibTableColumn((1, 3, 6, 1, 3, 117, 3, 1, 5, 1, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaPortVlArbLowCapacity.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.6; Table 132 PortInfo; Also see Section 7.6.9.')
if mibBuilder.loadTexts: ibSmaPortVlArbLowCapacity.setStatus('current')
if mibBuilder.loadTexts: ibSmaPortVlArbLowCapacity.setDescription('VL/Weight pairs supported on this port in the VLArbitration table for low priority. Shall be N to 64 if more than one data VL is supported on this port, 0 otherwise, N being the number of data VLs supported.')
ibSmaPortMtuCapacity = MibTableColumn((1, 3, 6, 1, 3, 117, 3, 1, 5, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("mtu256", 1), ("mtu512", 2), ("mtu1024", 3), ("mtu2048", 4), ("mtu4096", 5), ("other", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaPortMtuCapacity.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.6; Table 132 PortInfo.')
if mibBuilder.loadTexts: ibSmaPortMtuCapacity.setStatus('current')
if mibBuilder.loadTexts: ibSmaPortMtuCapacity.setDescription('Maximum MTU supported by this port. 1: 256 bytes 2: 512 bytes 3: 1024 bytes 4: 2048 bytes 5: 4096 bytes 0, 6 - 15: reserved ')
ibSmaPortVlStallCount = MibTableColumn((1, 3, 6, 1, 3, 117, 3, 1, 5, 1, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaPortVlStallCount.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.6; Table 132 PortInfo; Section 18.2.4.4.')
if mibBuilder.loadTexts: ibSmaPortVlStallCount.setStatus('current')
if mibBuilder.loadTexts: ibSmaPortVlStallCount.setDescription('Specifies the number of sequential packets dropped that causes the port to enter the VLStalled state. The result of setting this value to 0 is undefined.')
ibSmaPortHeadOfQueueLife = MibTableColumn((1, 3, 6, 1, 3, 117, 3, 1, 5, 1, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaPortHeadOfQueueLife.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.6; Table 132 PortInfo; Also Section 18.2.5.4.')
if mibBuilder.loadTexts: ibSmaPortHeadOfQueueLife.setStatus('current')
if mibBuilder.loadTexts: ibSmaPortHeadOfQueueLife.setDescription('Sets the time a packet can live at the head of a Virtual Lane queue. This variable (HL) is used to compute the Head of the Queue Lifetime Limit (HLL). It is used in the formula when the HL value is between 0 and 19, inclusive. When HL is greater than 19, the HLL is to be interpreted as infinite.')
ibSmaPortOperationalVls = MibTableColumn((1, 3, 6, 1, 3, 117, 3, 1, 5, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("vl0", 1), ("vl0ToVl1", 2), ("vl0ToVl3", 3), ("vl0ToVl7", 4), ("vl0ToVl14", 5), ("other", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaPortOperationalVls.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.6; Table 132 PortInfo.')
if mibBuilder.loadTexts: ibSmaPortOperationalVls.setStatus('current')
if mibBuilder.loadTexts: ibSmaPortOperationalVls.setDescription('Virtual Lanes operational on this port, indicated as follows: 0: No change 1: VL0 2: VL0 - VL1 3: VL0 - VL3 4: VL0 - VL7 5: VL0 - VL14 6 - 15: reserved')
ibSmaPortPartEnforceInbound = MibTableColumn((1, 3, 6, 1, 3, 117, 3, 1, 5, 1, 1, 21), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaPortPartEnforceInbound.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.6; Table 132 PortInfo.')
if mibBuilder.loadTexts: ibSmaPortPartEnforceInbound.setStatus('current')
if mibBuilder.loadTexts: ibSmaPortPartEnforceInbound.setDescription('Indicates support of optional inbound partition enforcement. If true, partition enforcement on packets received on this port is enabled. If false partition enforcement on packets received from this port is disabled.')
ibSmaPortPartEnforceOutbound = MibTableColumn((1, 3, 6, 1, 3, 117, 3, 1, 5, 1, 1, 22), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaPortPartEnforceOutbound.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.6; Table 132 PortInfo.')
if mibBuilder.loadTexts: ibSmaPortPartEnforceOutbound.setStatus('current')
if mibBuilder.loadTexts: ibSmaPortPartEnforceOutbound.setDescription('Indicates support of optional outbound partition enforcement. If true, partition enforcement on packets transmitted on this port is enabled. If false partition enforcement on packets transmitted from this port is disabled.')
ibSmaPortFilterRawPktInbound = MibTableColumn((1, 3, 6, 1, 3, 117, 3, 1, 5, 1, 1, 23), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaPortFilterRawPktInbound.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.6; Table 132 PortInfo.')
if mibBuilder.loadTexts: ibSmaPortFilterRawPktInbound.setStatus('current')
if mibBuilder.loadTexts: ibSmaPortFilterRawPktInbound.setDescription('Indicates support of optional inbound raw packet enforcement. If true, raw packets arriving on this port are discarded. If false, raw enforcement on packets received from this port is disabled.')
ibSmaPortFilterRawPktOutbound = MibTableColumn((1, 3, 6, 1, 3, 117, 3, 1, 5, 1, 1, 24), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaPortFilterRawPktOutbound.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.6; Table 132 PortInfo.')
if mibBuilder.loadTexts: ibSmaPortFilterRawPktOutbound.setStatus('current')
if mibBuilder.loadTexts: ibSmaPortFilterRawPktOutbound.setDescription('Indicates support of optional outbound raw packet enforcement. If true, raw packets departing on this port are discarded. If false, raw enforcement on packets leaving from this port is disabled.')
ibSmaPortLocalPhysErrorThreshold = MibTableColumn((1, 3, 6, 1, 3, 117, 3, 1, 5, 1, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaPortLocalPhysErrorThreshold.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.6; Table 132 PortInfo; Also Section 7.12.2.')
if mibBuilder.loadTexts: ibSmaPortLocalPhysErrorThreshold.setStatus('current')
if mibBuilder.loadTexts: ibSmaPortLocalPhysErrorThreshold.setDescription('Local Physical Error threshold value. When the count of marginal link errors exceeds this threshold, the local link integrity error shall be detected.')
ibSmaPortOverrunErrorThreshold = MibTableColumn((1, 3, 6, 1, 3, 117, 3, 1, 5, 1, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaPortOverrunErrorThreshold.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.6; Table 132 PortInfo; Also Section 7.12.2.')
if mibBuilder.loadTexts: ibSmaPortOverrunErrorThreshold.setStatus('current')
if mibBuilder.loadTexts: ibSmaPortOverrunErrorThreshold.setDescription('Overrun error threshold value. When the count of buffer overruns over consecutive flow control update periods exceeds this threshold, the excessive buffer overrun error shall be detected.')
ibSmaPKeyInfo = MibIdentifier((1, 3, 6, 1, 3, 117, 3, 1, 6))
ibSmaPKeyTable = MibTable((1, 3, 6, 1, 3, 117, 3, 1, 6, 1), )
if mibBuilder.loadTexts: ibSmaPKeyTable.setStatus('current')
if mibBuilder.loadTexts: ibSmaPKeyTable.setDescription('This table contains SMA Partition Key information for this port.')
ibSmaPKeyEntry = MibTableRow((1, 3, 6, 1, 3, 117, 3, 1, 6, 1, 1), ).setIndexNames((0, "SMA-MIB", "ibSmaPKeyIBAPortIndex"), (0, "SMA-MIB", "ibSmaPKeyIndex"))
if mibBuilder.loadTexts: ibSmaPKeyEntry.setStatus('current')
if mibBuilder.loadTexts: ibSmaPKeyEntry.setDescription('A conceptual row of the ibPKeyTable containing information about the partition keys.')
ibSmaPKeyIBAPortIndex = MibTableColumn((1, 3, 6, 1, 3, 117, 3, 1, 6, 1, 1, 1), IbDataPortAndInvalid())
if mibBuilder.loadTexts: ibSmaPKeyIBAPortIndex.setStatus('current')
if mibBuilder.loadTexts: ibSmaPKeyIBAPortIndex.setDescription('The IB data port index for the switch data ports. For switch management port 0 and for CAs and routers, the index value should be 255. This indicates that the entry is not referring to a valid switch data port. (In the IB attribute modifier the upper 16 bits indicate the data port, else it is 0).')
ibSmaPKeyIndex = MibTableColumn((1, 3, 6, 1, 3, 117, 3, 1, 6, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65505)))
if mibBuilder.loadTexts: ibSmaPKeyIndex.setStatus('current')
if mibBuilder.loadTexts: ibSmaPKeyIndex.setDescription('The 1-based entry Identifier for each Partition Key defined on a port. (The IB spec specifies 0..2047 blocks of 32 entries each for a total of 65,504 maximum entries, although the implemented limit is defined by PartitionCap for CAs, routers, and switch port 0, and by PartitionEnforcementCap for the switch data ports).')
ibSmaPKeyMembership = MibTableColumn((1, 3, 6, 1, 3, 117, 3, 1, 6, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("limited", 2), ("full", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaPKeyMembership.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.7; Table 134 P_KeyTable and Table 135 P_Key Block Element.')
if mibBuilder.loadTexts: ibSmaPKeyMembership.setStatus('current')
if mibBuilder.loadTexts: ibSmaPKeyMembership.setDescription('If the P_Key type is limitedi(2), the switch may accept a packet with a matching full P_Key, but may not accept a packet with a matching limited key. If the P_Key type is full(3), the switch can accept packets with either a full or limited P_Key. If the P_Key type is none(1), there is no associated Key Base value.')
ibSmaPKeyBase = MibTableColumn((1, 3, 6, 1, 3, 117, 3, 1, 6, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65527))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaPKeyBase.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.7; Table 134 P_KeyTable and Table 135 P_Key Block Element.')
if mibBuilder.loadTexts: ibSmaPKeyBase.setStatus('current')
if mibBuilder.loadTexts: ibSmaPKeyBase.setDescription('15-bit base value of the P_Key that the switch will use to check against incoming packets.')
ibSmaSlToVlMapInfo = MibIdentifier((1, 3, 6, 1, 3, 117, 3, 1, 7))
ibSmaSL2VLMapTable = MibTable((1, 3, 6, 1, 3, 117, 3, 1, 7, 1), )
if mibBuilder.loadTexts: ibSmaSL2VLMapTable.setStatus('current')
if mibBuilder.loadTexts: ibSmaSL2VLMapTable.setDescription('This table provides the virtual lane value for the output port/input port/service level mapping. Each output port contains a VL mapping for the next hop based on the input port the packet arrived on and its SL value.')
ibSmaSL2VLMapEntry = MibTableRow((1, 3, 6, 1, 3, 117, 3, 1, 7, 1, 1), ).setIndexNames((0, "SMA-MIB", "ibSmaIBAOutPortIndex"), (0, "SMA-MIB", "ibSmaIBAInPortIndex"), (0, "SMA-MIB", "ibSmaServiceLevelIndex"))
if mibBuilder.loadTexts: ibSmaSL2VLMapEntry.setStatus('current')
if mibBuilder.loadTexts: ibSmaSL2VLMapEntry.setDescription('Column definitions for the VL from output/input/SL entry.')
ibSmaIBAOutPortIndex = MibTableColumn((1, 3, 6, 1, 3, 117, 3, 1, 7, 1, 1, 1), IbDataPortAndInvalid())
if mibBuilder.loadTexts: ibSmaIBAOutPortIndex.setStatus('current')
if mibBuilder.loadTexts: ibSmaIBAOutPortIndex.setDescription('The egress port index for the service level mapping. A value of 255 indicates the switch management port 0.')
ibSmaIBAInPortIndex = MibTableColumn((1, 3, 6, 1, 3, 117, 3, 1, 7, 1, 1, 2), IbDataPortAndInvalid())
if mibBuilder.loadTexts: ibSmaIBAInPortIndex.setStatus('current')
if mibBuilder.loadTexts: ibSmaIBAInPortIndex.setDescription('The ingress port index for the service level mapping. A value of 255 indicates the switch management port 0.')
ibSmaServiceLevelIndex = MibTableColumn((1, 3, 6, 1, 3, 117, 3, 1, 7, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16)))
if mibBuilder.loadTexts: ibSmaServiceLevelIndex.setStatus('current')
if mibBuilder.loadTexts: ibSmaServiceLevelIndex.setDescription('The (1-based) Service Level value index for this mapping.')
ibSmaVirtualLane = MibTableColumn((1, 3, 6, 1, 3, 117, 3, 1, 7, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaVirtualLane.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.8.; Table 136 SLtoVLMappingTable.')
if mibBuilder.loadTexts: ibSmaVirtualLane.setStatus('current')
if mibBuilder.loadTexts: ibSmaVirtualLane.setDescription("The outgoing packet's Virtual Lane value for this Service Level Mapping.")
ibSmaVLArbitInfo = MibIdentifier((1, 3, 6, 1, 3, 117, 3, 1, 8))
ibSmaHiPriVlArbTable = MibTable((1, 3, 6, 1, 3, 117, 3, 1, 8, 1), )
if mibBuilder.loadTexts: ibSmaHiPriVlArbTable.setStatus('current')
if mibBuilder.loadTexts: ibSmaHiPriVlArbTable.setDescription('This table provides visibility into the High Priority Arbitration process for configuring VL/Weight pairs for the IB data ports.')
ibSmaHiPriVlArbEntry = MibTableRow((1, 3, 6, 1, 3, 117, 3, 1, 8, 1, 1), ).setIndexNames((0, "SMA-MIB", "ibSmaHiPriIBAPortIndex"), (0, "SMA-MIB", "ibSmaHiPriNIndex"))
if mibBuilder.loadTexts: ibSmaHiPriVlArbEntry.setStatus('current')
if mibBuilder.loadTexts: ibSmaHiPriVlArbEntry.setDescription('Column definitions for High Priority Arbitration Table.')
ibSmaHiPriIBAPortIndex = MibTableColumn((1, 3, 6, 1, 3, 117, 3, 1, 8, 1, 1, 1), IbDataPort())
if mibBuilder.loadTexts: ibSmaHiPriIBAPortIndex.setStatus('current')
if mibBuilder.loadTexts: ibSmaHiPriIBAPortIndex.setDescription('The index for the IBA port that is being configured.')
ibSmaHiPriNIndex = MibTableColumn((1, 3, 6, 1, 3, 117, 3, 1, 8, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 64)))
if mibBuilder.loadTexts: ibSmaHiPriNIndex.setStatus('current')
if mibBuilder.loadTexts: ibSmaHiPriNIndex.setDescription('The High Priority list index.')
ibSmaHiPriVirtLane = MibTableColumn((1, 3, 6, 1, 3, 117, 3, 1, 8, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 14))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaHiPriVirtLane.setStatus('current')
if mibBuilder.loadTexts: ibSmaHiPriVirtLane.setDescription('The virtual lane this entry applies to.')
ibSmaHiPriWeight = MibTableColumn((1, 3, 6, 1, 3, 117, 3, 1, 8, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaHiPriWeight.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.9; Table 137 VLArbitrationTable.')
if mibBuilder.loadTexts: ibSmaHiPriWeight.setStatus('current')
if mibBuilder.loadTexts: ibSmaHiPriWeight.setDescription('Number of 64-byte units that may be transmitted from this VL when its turn in the arbitration process occurs. A weight of 0 indicates that the entry should be skipped.')
ibSmaLowPriVlArbTable = MibTable((1, 3, 6, 1, 3, 117, 3, 1, 8, 2), )
if mibBuilder.loadTexts: ibSmaLowPriVlArbTable.setStatus('current')
if mibBuilder.loadTexts: ibSmaLowPriVlArbTable.setDescription('This table provides visibility into the Low Priority Arbitration process.')
ibSmaLowPriVlArbEntry = MibTableRow((1, 3, 6, 1, 3, 117, 3, 1, 8, 2, 1), ).setIndexNames((0, "SMA-MIB", "ibSmaLowPriIBAPortIndex"), (0, "SMA-MIB", "ibSmaLowPriNIndex"))
if mibBuilder.loadTexts: ibSmaLowPriVlArbEntry.setStatus('current')
if mibBuilder.loadTexts: ibSmaLowPriVlArbEntry.setDescription('Column definitions for Low Priority Arbitration Table.')
ibSmaLowPriIBAPortIndex = MibTableColumn((1, 3, 6, 1, 3, 117, 3, 1, 8, 2, 1, 1), IbDataPort())
if mibBuilder.loadTexts: ibSmaLowPriIBAPortIndex.setStatus('current')
if mibBuilder.loadTexts: ibSmaLowPriIBAPortIndex.setDescription('The index for the IB data port that is being configured.')
ibSmaLowPriNIndex = MibTableColumn((1, 3, 6, 1, 3, 117, 3, 1, 8, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 64)))
if mibBuilder.loadTexts: ibSmaLowPriNIndex.setStatus('current')
if mibBuilder.loadTexts: ibSmaLowPriNIndex.setDescription('The Low Priority list index.')
ibSmaLowPriVirtLane = MibTableColumn((1, 3, 6, 1, 3, 117, 3, 1, 8, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 14))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaLowPriVirtLane.setStatus('current')
if mibBuilder.loadTexts: ibSmaLowPriVirtLane.setDescription('The Virtual Lane this entry applies to.')
ibSmaLowPriWeight = MibTableColumn((1, 3, 6, 1, 3, 117, 3, 1, 8, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaLowPriWeight.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.9; Table 137 VLArbitrationTable.')
if mibBuilder.loadTexts: ibSmaLowPriWeight.setStatus('current')
if mibBuilder.loadTexts: ibSmaLowPriWeight.setDescription('Number of 64-byte units that may be transmitted from this VL when its turn in the arbitration process occurs. A weight of 0 indicates that the entry should be skipped.')
ibSmaLFTInfo = MibIdentifier((1, 3, 6, 1, 3, 117, 3, 1, 9))
ibSmaLinForTable = MibTable((1, 3, 6, 1, 3, 117, 3, 1, 9, 1), )
if mibBuilder.loadTexts: ibSmaLinForTable.setStatus('current')
if mibBuilder.loadTexts: ibSmaLinForTable.setDescription('A table containing information about the Linear Forwarding Table.')
ibSmaLinForEntry = MibTableRow((1, 3, 6, 1, 3, 117, 3, 1, 9, 1, 1), ).setIndexNames((0, "SMA-MIB", "ibSmaLinDestDLIDIndex"))
if mibBuilder.loadTexts: ibSmaLinForEntry.setStatus('current')
if mibBuilder.loadTexts: ibSmaLinForEntry.setDescription('Current unicast forwarding Table entry configured by the Subnet Manager based on destination LID.')
ibSmaLinDestDLIDIndex = MibTableColumn((1, 3, 6, 1, 3, 117, 3, 1, 9, 1, 1, 1), IbUnicastLid())
if mibBuilder.loadTexts: ibSmaLinDestDLIDIndex.setReference('InfiniBand Architecture Release 1.1 Vol 1. Section 14.2.5.10 LinearForwardingTable; Table 139 and Table 140.')
if mibBuilder.loadTexts: ibSmaLinDestDLIDIndex.setStatus('current')
if mibBuilder.loadTexts: ibSmaLinDestDLIDIndex.setDescription('Index that identifies Destination Local Identifier (DLID) that the forwarding entry refers to in the Linear Forwarding Table.')
ibSmaLinForwEgressPort = MibTableColumn((1, 3, 6, 1, 3, 117, 3, 1, 9, 1, 1, 2), IbDataPortAndInvalid()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaLinForwEgressPort.setReference('InfiniBand Architecture Release 1.1 Vol 1. Section 14.2.5.10 LinearForwardingTable; Table 139 and Table 140.')
if mibBuilder.loadTexts: ibSmaLinForwEgressPort.setStatus('current')
if mibBuilder.loadTexts: ibSmaLinForwEgressPort.setDescription('The port to which packets with the LID corresponding to this entry are to be forwarded.')
ibSmaRFTInfo = MibIdentifier((1, 3, 6, 1, 3, 117, 3, 1, 10))
ibSmaRandomForwardingTable = MibTable((1, 3, 6, 1, 3, 117, 3, 1, 10, 1), )
if mibBuilder.loadTexts: ibSmaRandomForwardingTable.setStatus('current')
if mibBuilder.loadTexts: ibSmaRandomForwardingTable.setDescription('A table containing SMA Random Forwarding information.')
ibSmaRandomForwardingEntry = MibTableRow((1, 3, 6, 1, 3, 117, 3, 1, 10, 1, 1), ).setIndexNames((0, "SMA-MIB", "ibSmaRandomForwardingPortIndex"))
if mibBuilder.loadTexts: ibSmaRandomForwardingEntry.setStatus('current')
if mibBuilder.loadTexts: ibSmaRandomForwardingEntry.setDescription('A conceptual row of the ibSmaRandomForwardingTable containing information about the Random Forwarding Table.')
ibSmaRandomForwardingPortIndex = MibTableColumn((1, 3, 6, 1, 3, 117, 3, 1, 10, 1, 1, 1), IbDataPort())
if mibBuilder.loadTexts: ibSmaRandomForwardingPortIndex.setStatus('current')
if mibBuilder.loadTexts: ibSmaRandomForwardingPortIndex.setDescription('The port index value.')
ibSmaRandomDestLID = MibTableColumn((1, 3, 6, 1, 3, 117, 3, 1, 10, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 49152))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaRandomDestLID.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.11 RandomForwardingTable; Table 141 and Table 142.')
if mibBuilder.loadTexts: ibSmaRandomDestLID.setStatus('current')
if mibBuilder.loadTexts: ibSmaRandomDestLID.setDescription('Identifies Destination Local Identifier (DLID) that the forwarding entry refers to.')
ibSmaRandomForwEgressPort = MibTableColumn((1, 3, 6, 1, 3, 117, 3, 1, 10, 1, 1, 3), IbDataPort()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaRandomForwEgressPort.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.11 RandomForwardingTable; Table 141 and Table 142.')
if mibBuilder.loadTexts: ibSmaRandomForwEgressPort.setStatus('current')
if mibBuilder.loadTexts: ibSmaRandomForwEgressPort.setDescription('The port to which packets with the LID corresponding to this entry are to be forwarded.')
ibSmaRandomLMC = MibTableColumn((1, 3, 6, 1, 3, 117, 3, 1, 10, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaRandomLMC.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.11 RandomForwardingTable; Table 141 and Table 142.')
if mibBuilder.loadTexts: ibSmaRandomLMC.setStatus('current')
if mibBuilder.loadTexts: ibSmaRandomLMC.setDescription('The LID Mask Control (LMC) of this LID. The LMC specifies the number of Path Bits in the Local Identifier.')
ibSmaRandomIsValid = MibTableColumn((1, 3, 6, 1, 3, 117, 3, 1, 10, 1, 1, 5), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaRandomIsValid.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.11 RandomForwardingTable; Table 141 and Table 142.')
if mibBuilder.loadTexts: ibSmaRandomIsValid.setStatus('current')
if mibBuilder.loadTexts: ibSmaRandomIsValid.setDescription('If true this LID/Port pair is valid. Note that when the SMA sets this parameter to 0, entries can be removed.')
ibSmaMFTInfo = MibIdentifier((1, 3, 6, 1, 3, 117, 3, 1, 11))
ibSmaMulForTable = MibTable((1, 3, 6, 1, 3, 117, 3, 1, 11, 1), )
if mibBuilder.loadTexts: ibSmaMulForTable.setStatus('current')
if mibBuilder.loadTexts: ibSmaMulForTable.setDescription('A table containing information about the Multicast Forwarding Table.')
ibSmaMulForEntry = MibTableRow((1, 3, 6, 1, 3, 117, 3, 1, 11, 1, 1), ).setIndexNames((0, "SMA-MIB", "ibSmaMulDestDLIDIndex"))
if mibBuilder.loadTexts: ibSmaMulForEntry.setStatus('current')
if mibBuilder.loadTexts: ibSmaMulForEntry.setDescription('Current multicast forwarding table entry as configured by the Subnet Manager based on destination LID.')
ibSmaMulDestDLIDIndex = MibTableColumn((1, 3, 6, 1, 3, 117, 3, 1, 11, 1, 1, 1), IbMulticastLid())
if mibBuilder.loadTexts: ibSmaMulDestDLIDIndex.setStatus('current')
if mibBuilder.loadTexts: ibSmaMulDestDLIDIndex.setDescription('Identifies Destination Local Identifier (DLID) that the forwarding entry refers to in the Multicast Forwarding Table.')
ibSmaMulForwMask = MibTableColumn((1, 3, 6, 1, 3, 117, 3, 1, 11, 1, 1, 2), IbSmPortList()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaMulForwMask.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.12 MulticastForwardingTable; Table 143 and Table 144.')
if mibBuilder.loadTexts: ibSmaMulForwMask.setStatus('current')
if mibBuilder.loadTexts: ibSmaMulForwMask.setDescription('A 256-bit mask that represents the port list. An incoming packet with this LID table entry will be forwarded to all ports for which the bit in the port mask is set to 1.')
ibSmaSMInfo = MibIdentifier((1, 3, 6, 1, 3, 117, 3, 1, 12))
ibSmaSubMgrInfo = MibIdentifier((1, 3, 6, 1, 3, 117, 3, 1, 12, 1))
ibSmaSmInfoTable = MibTable((1, 3, 6, 1, 3, 117, 3, 1, 12, 1, 1), )
if mibBuilder.loadTexts: ibSmaSmInfoTable.setStatus('current')
if mibBuilder.loadTexts: ibSmaSmInfoTable.setDescription('A table containing SMA Subnet Manager information.')
ibSmaSmInfoEntry = MibTableRow((1, 3, 6, 1, 3, 117, 3, 1, 12, 1, 1, 1), ).setIndexNames((0, "SMA-MIB", "ibSmaSmInfoPortIndex"))
if mibBuilder.loadTexts: ibSmaSmInfoEntry.setStatus('current')
if mibBuilder.loadTexts: ibSmaSmInfoEntry.setDescription('A conceptual row of the ibSmaSmInfoTable containing information about the Subnet Manager Table.')
ibSmaSmInfoPortIndex = MibTableColumn((1, 3, 6, 1, 3, 117, 3, 1, 12, 1, 1, 1, 1), IbDataPort())
if mibBuilder.loadTexts: ibSmaSmInfoPortIndex.setStatus('current')
if mibBuilder.loadTexts: ibSmaSmInfoPortIndex.setDescription('The port index value.')
ibSmaSmGuid = MibTableColumn((1, 3, 6, 1, 3, 117, 3, 1, 12, 1, 1, 1, 2), IbGuid()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaSmGuid.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.13; Table 145 SMInfo Table.')
if mibBuilder.loadTexts: ibSmaSmGuid.setStatus('current')
if mibBuilder.loadTexts: ibSmaSmGuid.setDescription('The Port GUID of the port where the SM resides.')
ibSmaSmSmKey = MibTableColumn((1, 3, 6, 1, 3, 117, 3, 1, 12, 1, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaSmSmKey.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.13; Table 145 SMInfo Table.')
if mibBuilder.loadTexts: ibSmaSmSmKey.setStatus('current')
if mibBuilder.loadTexts: ibSmaSmSmKey.setDescription('Key for this SM. This is shown as zeroes unless the requesting SM is proven to be the master, or the requester is otherwise authenticated.')
ibSmaSmSmpCount = MibTableColumn((1, 3, 6, 1, 3, 117, 3, 1, 12, 1, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaSmSmpCount.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.13; Table 145 SMInfo Table.')
if mibBuilder.loadTexts: ibSmaSmSmpCount.setStatus('current')
if mibBuilder.loadTexts: ibSmaSmSmpCount.setDescription('Counter that increments each time the SM issues an SMP or performs other management activities. This counter is used as a heartbeat indicator by standby SMs.')
ibSmaSmPriority = MibTableColumn((1, 3, 6, 1, 3, 117, 3, 1, 12, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaSmPriority.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.13; Table 145 SMInfo Table.')
if mibBuilder.loadTexts: ibSmaSmPriority.setStatus('current')
if mibBuilder.loadTexts: ibSmaSmPriority.setDescription('Administratively assigned priority for this SM. This can be reset by master SM. 0 is the lowest priority. An out-of-band mechanism shall be provided to set this value. The default value shall be 0.')
ibSmaSmState = MibTableColumn((1, 3, 6, 1, 3, 117, 3, 1, 12, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unknown", 1), ("notActive", 2), ("discovering", 3), ("standby", 4), ("master", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaSmState.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.13; Table 145 SMInfo Table.')
if mibBuilder.loadTexts: ibSmaSmState.setStatus('current')
if mibBuilder.loadTexts: ibSmaSmState.setDescription("Enumerated value indicating this SM's state. The InfiniBand enumeration values are: 0 - not active 1 - discovering 2 - standby 3 - master 4-15 - reserved. Note: a value of reserved returns unknown(1).")
ibSmaVendDiagInfo = MibIdentifier((1, 3, 6, 1, 3, 117, 3, 1, 13))
ibSmaVendDiagInfoTable = MibTable((1, 3, 6, 1, 3, 117, 3, 1, 13, 1), )
if mibBuilder.loadTexts: ibSmaVendDiagInfoTable.setStatus('current')
if mibBuilder.loadTexts: ibSmaVendDiagInfoTable.setDescription('A table containing SMA Vendor Diagnostic Info information.')
ibSmaVendDiagInfoEntry = MibTableRow((1, 3, 6, 1, 3, 117, 3, 1, 13, 1, 1), ).setIndexNames((0, "SMA-MIB", "ibSmaVendDiagPortIndex"))
if mibBuilder.loadTexts: ibSmaVendDiagInfoEntry.setStatus('current')
if mibBuilder.loadTexts: ibSmaVendDiagInfoEntry.setDescription("A conceptual row of the ibSmaVendDiagInfoTable containing information about a particular data port's diagnostic status.")
ibSmaVendDiagPortIndex = MibTableColumn((1, 3, 6, 1, 3, 117, 3, 1, 13, 1, 1, 1), IbDataPortAndInvalid())
if mibBuilder.loadTexts: ibSmaVendDiagPortIndex.setStatus('current')
if mibBuilder.loadTexts: ibSmaVendDiagPortIndex.setDescription('Index that identifies the port for the diagnostics. If the index value is 255, information about the management port is returned.')
ibSmaPortGenericDiagCode = MibTableColumn((1, 3, 6, 1, 3, 117, 3, 1, 13, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("portReady", 1), ("performingSelfTest", 2), ("initializing", 3), ("softError", 4), ("hardError", 5), ("other", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaPortGenericDiagCode.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.6; Table 132 PortInfo. Also see Section 14.2.5.6.1; Table 133: Standard Encoding of DiagCode Bits 3-0.')
if mibBuilder.loadTexts: ibSmaPortGenericDiagCode.setStatus('current')
if mibBuilder.loadTexts: ibSmaPortGenericDiagCode.setDescription('The generic portion of the Port Info Diagnostic code.')
ibSmaPortVendorDiagCode = MibTableColumn((1, 3, 6, 1, 3, 117, 3, 1, 13, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2047))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaPortVendorDiagCode.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.6; Table 132 PortInfo. Also see Section 14.2.5.6.1 and Figure 188.')
if mibBuilder.loadTexts: ibSmaPortVendorDiagCode.setStatus('current')
if mibBuilder.loadTexts: ibSmaPortVendorDiagCode.setDescription('The vendor specific portion of the Port Info Diagnostic code.')
ibSmaPortVendorDiagIndexFwd = MibTableColumn((1, 3, 6, 1, 3, 117, 3, 1, 13, 1, 1, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaPortVendorDiagIndexFwd.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.14 and Table 146 VendorDiag.')
if mibBuilder.loadTexts: ibSmaPortVendorDiagIndexFwd.setStatus('current')
if mibBuilder.loadTexts: ibSmaPortVendorDiagIndexFwd.setDescription('Flag to control ibSmaPortVendorDiagData data buffer. If this boolean is true(1), the data buffer contains meaningful vendor-supplied additional diagnostic information. If this object is false(2), the buffer is empty.')
ibSmaPortVendorDiagData = MibTableColumn((1, 3, 6, 1, 3, 117, 3, 1, 13, 1, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(124, 124)).setFixedLength(124)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaPortVendorDiagData.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.6; Table 132 PortInfo. Also see Section 14.2.5.6.1 and Figure 188.')
if mibBuilder.loadTexts: ibSmaPortVendorDiagData.setStatus('current')
if mibBuilder.loadTexts: ibSmaPortVendorDiagData.setDescription('Data buffer that can contain additional vendor-specific diagnostic information. The ibSmaPortVendorDiagIndexFwd flag controls whether this object contains meaningful data. Note: in IB, this buffer comprises n number of 62 byte buffers. This object defines a buffer that can hold up to 2 of these IB chained buffers.')
ibSmaLedInfo = MibIdentifier((1, 3, 6, 1, 3, 117, 3, 1, 14))
ibSmaLedInfoTable = MibTable((1, 3, 6, 1, 3, 117, 3, 1, 14, 1), )
if mibBuilder.loadTexts: ibSmaLedInfoTable.setStatus('current')
if mibBuilder.loadTexts: ibSmaLedInfoTable.setDescription('A table containing SMA LED Info information.')
ibSmaLedInfoEntry = MibTableRow((1, 3, 6, 1, 3, 117, 3, 1, 14, 1, 1), ).setIndexNames((0, "SMA-MIB", "ibSmaLedIndex"))
if mibBuilder.loadTexts: ibSmaLedInfoEntry.setStatus('current')
if mibBuilder.loadTexts: ibSmaLedInfoEntry.setDescription("A conceptual row of the ibSmaLedInfoTable containing information about a particular data port's LED status.")
ibSmaLedIndex = MibTableColumn((1, 3, 6, 1, 3, 117, 3, 1, 14, 1, 1, 1), IbDataPort())
if mibBuilder.loadTexts: ibSmaLedIndex.setStatus('current')
if mibBuilder.loadTexts: ibSmaLedIndex.setDescription('Index that identifies the IB data port that can have an LED associated with it.')
ibSmaLedState = MibTableColumn((1, 3, 6, 1, 3, 117, 3, 1, 14, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("on", 2), ("off", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibSmaLedState.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.15 LedInfo; Table 147 LedInfo Table.')
if mibBuilder.loadTexts: ibSmaLedState.setStatus('current')
if mibBuilder.loadTexts: ibSmaLedState.setDescription('State of the LED.')
ibSmaNotificationPrefix = MibIdentifier((1, 3, 6, 1, 3, 117, 3, 2, 0))
ibSmaPortLinkStateChange = NotificationType((1, 3, 6, 1, 3, 117, 3, 2, 1)).setObjects(("SMA-MIB", "ibSmaNodeLid"))
if mibBuilder.loadTexts: ibSmaPortLinkStateChange.setStatus('current')
if mibBuilder.loadTexts: ibSmaPortLinkStateChange.setDescription('This notification translates InfiniBand SMA Trap 128: Link State of at least one port of switch at <LIDADDR> has changed.')
if mibBuilder.loadTexts: ibSmaPortLinkStateChange.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.1; Table 118 and 120.')
ibSmaLinkIntegrityThresReached = NotificationType((1, 3, 6, 1, 3, 117, 3, 2, 2)).setObjects(("SMA-MIB", "ibSmaNodeLid"), ("SMA-MIB", "ibSmaNodePortNum"))
if mibBuilder.loadTexts: ibSmaLinkIntegrityThresReached.setStatus('current')
if mibBuilder.loadTexts: ibSmaLinkIntegrityThresReached.setDescription('This notification translates InfiniBand SMA Trap 129: Local Link Integrity threshold reached at <LIDADDR><PORTNO>.')
if mibBuilder.loadTexts: ibSmaLinkIntegrityThresReached.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.1; Table 118 and 121.')
ibSmaExcessBuffOverrunThres = NotificationType((1, 3, 6, 1, 3, 117, 3, 2, 3)).setObjects(("SMA-MIB", "ibSmaNodeLid"), ("SMA-MIB", "ibSmaNodePortNum"))
if mibBuilder.loadTexts: ibSmaExcessBuffOverrunThres.setStatus('current')
if mibBuilder.loadTexts: ibSmaExcessBuffOverrunThres.setDescription('This notification translates InfiniBand SMA Trap 130: Exccessive Buffer Overrun threshold reached at <LIDADDR><PORTNO>.')
if mibBuilder.loadTexts: ibSmaExcessBuffOverrunThres.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.1; Table 118 and 121.')
ibSmaFlowCntrlUpdateTimerExpire = NotificationType((1, 3, 6, 1, 3, 117, 3, 2, 4)).setObjects(("SMA-MIB", "ibSmaNodeLid"), ("SMA-MIB", "ibSmaNodePortNum"))
if mibBuilder.loadTexts: ibSmaFlowCntrlUpdateTimerExpire.setStatus('current')
if mibBuilder.loadTexts: ibSmaFlowCntrlUpdateTimerExpire.setDescription('This notification translates InfiniBand SMA Trap 131: Switch Flow Control Update watchdog timer expired at <LIDADDR><PORTNO>.')
if mibBuilder.loadTexts: ibSmaFlowCntrlUpdateTimerExpire.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.1; Table 118 and 121.')
ibSmaCapabilityMaskModified = NotificationType((1, 3, 6, 1, 3, 117, 3, 2, 5)).setObjects(("SMA-MIB", "ibSmaNodeLid"), ("SMA-MIB", "ibSmaNodeCapMask"))
if mibBuilder.loadTexts: ibSmaCapabilityMaskModified.setStatus('current')
if mibBuilder.loadTexts: ibSmaCapabilityMaskModified.setDescription('This notification translates InfiniBand SMA Trap 144: The capability mask at <LIDADDR> has been modified to <CAPMASK>.')
if mibBuilder.loadTexts: ibSmaCapabilityMaskModified.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.1; Table 118 and 122.')
ibSmaSysImageGuidModified = NotificationType((1, 3, 6, 1, 3, 117, 3, 2, 6)).setObjects(("SMA-MIB", "ibSmaNodeLid"), ("SMA-MIB", "ibSmaSystemImageGuid"))
if mibBuilder.loadTexts: ibSmaSysImageGuidModified.setStatus('current')
if mibBuilder.loadTexts: ibSmaSysImageGuidModified.setDescription('This notification translates InfiniBand SMA Trap 145: The System Image GUID at <LIDADDR> has been modified to <SYSTEMIMAGEGUID>.')
if mibBuilder.loadTexts: ibSmaSysImageGuidModified.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.1; Table 118 and 123.')
ibSmaBadManagementKey = NotificationType((1, 3, 6, 1, 3, 117, 3, 2, 7)).setObjects(("SMA-MIB", "ibSmaNodeKey"), ("SMA-MIB", "ibSmaNodeLid"), ("SMA-MIB", "ibSmaNodeMethod"), ("SMA-MIB", "ibSmaNodeAttributeId"), ("SMA-MIB", "ibSmaNodeAttributeModifier"))
if mibBuilder.loadTexts: ibSmaBadManagementKey.setStatus('current')
if mibBuilder.loadTexts: ibSmaBadManagementKey.setDescription('This notification translates InfiniBand SMA Trap 256: Bad M_Key, <KEY> from <LIDADDR> attempted <METHOD> with <ATTRIBUTEID> and <ATTRIBUTEMODIFIER>.')
if mibBuilder.loadTexts: ibSmaBadManagementKey.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.1; Table 118 and 124.')
ibSmaBadPartitionKey = NotificationType((1, 3, 6, 1, 3, 117, 3, 2, 8)).setObjects(("SMA-MIB", "ibSmaNodeKey"), ("SMA-MIB", "ibSmaNodeLid"), ("SMA-MIB", "ibSmaNodeGid1"), ("SMA-MIB", "ibSmaNodeQueuePair1"), ("SMA-MIB", "ibSmaNodeLid2"), ("SMA-MIB", "ibSmaNodeGid2"), ("SMA-MIB", "ibSmaNodeQueuePair2"), ("SMA-MIB", "ibSmaNodeServiceLevel"))
if mibBuilder.loadTexts: ibSmaBadPartitionKey.setStatus('current')
if mibBuilder.loadTexts: ibSmaBadPartitionKey.setDescription('This notification translates InfiniBand SMA Trap 257: Bad P_Key, <KEY> from <LIDADDR1> /<GIDADDR1>/<QP1> to <LIDADDR2>/<GIDADDR2>/<QP2> on <SL>.')
if mibBuilder.loadTexts: ibSmaBadPartitionKey.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.1; Table 118 and 125.')
ibSmaBadQueueKey = NotificationType((1, 3, 6, 1, 3, 117, 3, 2, 9)).setObjects(("SMA-MIB", "ibSmaNodeKey"), ("SMA-MIB", "ibSmaNodeLid"), ("SMA-MIB", "ibSmaNodeGid1"), ("SMA-MIB", "ibSmaNodeQueuePair1"), ("SMA-MIB", "ibSmaNodeLid2"), ("SMA-MIB", "ibSmaNodeGid2"), ("SMA-MIB", "ibSmaNodeQueuePair2"), ("SMA-MIB", "ibSmaNodeServiceLevel"))
if mibBuilder.loadTexts: ibSmaBadQueueKey.setStatus('current')
if mibBuilder.loadTexts: ibSmaBadQueueKey.setDescription('This notification translates InfiniBand SMA Trap 258: Bad Q_Key, <KEY> from <LIDADDR1>/<GIDADDR1>/<QP1> to <LIDADDR2>/<GIDADDR2>/<QP2> on <SL>.')
if mibBuilder.loadTexts: ibSmaBadQueueKey.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.1; Table 118 and 125.')
ibSmaBadPKeyAtSwitchPort = NotificationType((1, 3, 6, 1, 3, 117, 3, 2, 10)).setObjects(("SMA-MIB", "ibSmaNodeKey"), ("SMA-MIB", "ibSmaNodeLid"), ("SMA-MIB", "ibSmaNodeGid1"), ("SMA-MIB", "ibSmaNodeQueuePair1"), ("SMA-MIB", "ibSmaNodeLid2"), ("SMA-MIB", "ibSmaNodeGid2"), ("SMA-MIB", "ibSmaNodeQueuePair2"), ("SMA-MIB", "ibSmaNodeServiceLevel"), ("SMA-MIB", "ibSmaNodeSwitchLid"), ("SMA-MIB", "ibSmaNodeDataValid"))
if mibBuilder.loadTexts: ibSmaBadPKeyAtSwitchPort.setStatus('current')
if mibBuilder.loadTexts: ibSmaBadPKeyAtSwitchPort.setDescription('This notification translates InfiniBand SMA Trap 259: Bad P_Key, <KEY> from <LIDADDR1> /<GIDADDR1>/<QP1> to <LIDADDR2>/<GIDADDR2>/<QP2> on <SL> at switch <LIDADRR> external port <PORTNO>, where the validity of the fields is indicated by <DataValid>.')
if mibBuilder.loadTexts: ibSmaBadPKeyAtSwitchPort.setReference('InfiniBand Architecture Release 1.1. Vol 1. Section 14.2.5.1; Table 118 and 126.')
ibSmaCompliances = MibIdentifier((1, 3, 6, 1, 3, 117, 3, 3, 1))
ibSmaGroups = MibIdentifier((1, 3, 6, 1, 3, 117, 3, 3, 2))
ibSmaBasicNodeCompliance = ModuleCompliance((1, 3, 6, 1, 3, 117, 3, 3, 1, 1)).setObjects(("SMA-MIB", "ibSmaNodeGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibSmaBasicNodeCompliance = ibSmaBasicNodeCompliance.setStatus('current')
if mibBuilder.loadTexts: ibSmaBasicNodeCompliance.setDescription('The basic node implementation requirements for agents that support the IPOIB SMA MIB.')
ibSmaFullSwitchCompliance = ModuleCompliance((1, 3, 6, 1, 3, 117, 3, 3, 1, 2)).setObjects(("SMA-MIB", "ibSmaNodeGroup"), ("SMA-MIB", "ibSmaSwitchGroup"), ("SMA-MIB", "ibSmaGuidGroup"), ("SMA-MIB", "ibSmaMgmtPortGroup"), ("SMA-MIB", "ibSmaDataPortGroup"), ("SMA-MIB", "ibSmaPKeyGroup"), ("SMA-MIB", "ibSmaSlToVlMapGroup"), ("SMA-MIB", "ibSmaVLArbitGroup"), ("SMA-MIB", "ibSmaLFTGroup"), ("SMA-MIB", "ibSmaRFTGroup"), ("SMA-MIB", "ibSmaMFTGroup"), ("SMA-MIB", "ibSmaSMGroup"), ("SMA-MIB", "ibSmaVendDiagGroup"), ("SMA-MIB", "ibSmaLedGroup"), ("SMA-MIB", "ibSmaNotificationsGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibSmaFullSwitchCompliance = ibSmaFullSwitchCompliance.setStatus('current')
if mibBuilder.loadTexts: ibSmaFullSwitchCompliance.setDescription('The full node implementation requirements for agents that support the IPOIB SMA MIB for InfiniBand switches.')
ibSmaFullRouterCACompliance = ModuleCompliance((1, 3, 6, 1, 3, 117, 3, 3, 1, 3)).setObjects(("SMA-MIB", "ibSmaNodeGroup"), ("SMA-MIB", "ibSmaGuidGroup"), ("SMA-MIB", "ibSmaMgmtPortGroup"), ("SMA-MIB", "ibSmaDataPortGroup"), ("SMA-MIB", "ibSmaPKeyGroup"), ("SMA-MIB", "ibSmaSlToVlMapGroup"), ("SMA-MIB", "ibSmaVLArbitGroup"), ("SMA-MIB", "ibSmaSMGroup"), ("SMA-MIB", "ibSmaVendDiagGroup"), ("SMA-MIB", "ibSmaLedGroup"), ("SMA-MIB", "ibSmaNotificationsGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibSmaFullRouterCACompliance = ibSmaFullRouterCACompliance.setStatus('current')
if mibBuilder.loadTexts: ibSmaFullRouterCACompliance.setDescription('The full node implementation requirements for agents that support the IPOIB SMA MIB for InfiniBand CAs and routers.')
ibSmaNodeGroup = ObjectGroup((1, 3, 6, 1, 3, 117, 3, 3, 2, 1)).setObjects(("SMA-MIB", "ibSmaNodeString"), ("SMA-MIB", "ibSmaNodeBaseVersion"), ("SMA-MIB", "ibSmaNodeClassVersion"), ("SMA-MIB", "ibSmaNodeType"), ("SMA-MIB", "ibSmaNodeNumPorts"), ("SMA-MIB", "ibSmaSystemImageGuid"), ("SMA-MIB", "ibSmaNodeGuid"), ("SMA-MIB", "ibSmaNodePortGuid"), ("SMA-MIB", "ibSmaNodePartitionTableNum"), ("SMA-MIB", "ibSmaNodeDeviceId"), ("SMA-MIB", "ibSmaNodeRevision"), ("SMA-MIB", "ibSmaNodeLocalPortNumOrZero"), ("SMA-MIB", "ibSmaNodeVendorId"), ("SMA-MIB", "ibSmaNodeLid"), ("SMA-MIB", "ibSmaNodePortNum"), ("SMA-MIB", "ibSmaNodeMethod"), ("SMA-MIB", "ibSmaNodeAttributeId"), ("SMA-MIB", "ibSmaNodeAttributeModifier"), ("SMA-MIB", "ibSmaNodeKey"), ("SMA-MIB", "ibSmaNodeLid2"), ("SMA-MIB", "ibSmaNodeServiceLevel"), ("SMA-MIB", "ibSmaNodeQueuePair1"), ("SMA-MIB", "ibSmaNodeQueuePair2"), ("SMA-MIB", "ibSmaNodeGid1"), ("SMA-MIB", "ibSmaNodeGid2"), ("SMA-MIB", "ibSmaNodeCapMask"), ("SMA-MIB", "ibSmaNodeSwitchLid"), ("SMA-MIB", "ibSmaNodeDataValid"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibSmaNodeGroup = ibSmaNodeGroup.setStatus('current')
if mibBuilder.loadTexts: ibSmaNodeGroup.setDescription('The ibSmaNodeGroup defines the MIB objects that describe this InfiniBand subnet node.')
ibSmaSwitchGroup = ObjectGroup((1, 3, 6, 1, 3, 117, 3, 3, 2, 2)).setObjects(("SMA-MIB", "ibSmaSwLinearFdbTableNum"), ("SMA-MIB", "ibSmaSwRandomFdbTableNum"), ("SMA-MIB", "ibSmaSwMulticastFdbTableNum"), ("SMA-MIB", "ibSmaSwLinearFdbTop"), ("SMA-MIB", "ibSmaSwDefaultPort"), ("SMA-MIB", "ibSmaSwDefMcastPriPort"), ("SMA-MIB", "ibSmaSwDefMcastNotPriPort"), ("SMA-MIB", "ibSmaSwLifeTimeValue"), ("SMA-MIB", "ibSmaSwPortStateChange"), ("SMA-MIB", "ibSmaSwLidsPerPort"), ("SMA-MIB", "ibSmaSwPartitionEnforceNum"), ("SMA-MIB", "ibSmaSwInboundEnforceCap"), ("SMA-MIB", "ibSmaSwOutboundEnforceCap"), ("SMA-MIB", "ibSmaSwFilterRawPktInputCap"), ("SMA-MIB", "ibSmaSwFilterRawPktOutputCap"), ("SMA-MIB", "ibSmaSwEnhancedPort0"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibSmaSwitchGroup = ibSmaSwitchGroup.setStatus('current')
if mibBuilder.loadTexts: ibSmaSwitchGroup.setDescription('The ibSmaSwitchGroup defines the MIB objects that describe this InfiniBand switch.')
ibSmaGuidGroup = ObjectGroup((1, 3, 6, 1, 3, 117, 3, 3, 2, 3)).setObjects(("SMA-MIB", "ibSmaGuidVal"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibSmaGuidGroup = ibSmaGuidGroup.setStatus('current')
if mibBuilder.loadTexts: ibSmaGuidGroup.setDescription('The ibSmaGuidGroup defines the MIB object that describes the GUIDs associated with this node.')
ibSmaMgmtPortGroup = ObjectGroup((1, 3, 6, 1, 3, 117, 3, 3, 2, 4)).setObjects(("SMA-MIB", "ibSmaPortMKey"), ("SMA-MIB", "ibSmaPortGidPrefix"), ("SMA-MIB", "ibSmaPortLid"), ("SMA-MIB", "ibSmaPortMasterSmLid"), ("SMA-MIB", "ibSmaPortIsSubnetManager"), ("SMA-MIB", "ibSmaPortIsNoticeSupported"), ("SMA-MIB", "ibSmaPortIsTrapSupported"), ("SMA-MIB", "ibSmaPortIsAutoMigrateSupported"), ("SMA-MIB", "ibSmaPortIsSlMappingSupported"), ("SMA-MIB", "ibSmaPortIsMKeyNvram"), ("SMA-MIB", "ibSmaPortIsPKeyNvram"), ("SMA-MIB", "ibSmaPortIsLedInfoSupported"), ("SMA-MIB", "ibSmaPortIsSmDisabled"), ("SMA-MIB", "ibSmaPortIsSysImgGuidSupported"), ("SMA-MIB", "ibSmaPortIsPKeyExtPortTrapSup"), ("SMA-MIB", "ibSmaPortIsCommManageSupported"), ("SMA-MIB", "ibSmaPortIsSnmpTunnelSupported"), ("SMA-MIB", "ibSmaPortIsReinitSupported"), ("SMA-MIB", "ibSmaPortIsDevManageSupported"), ("SMA-MIB", "ibSmaPortIsVendorClassSupported"), ("SMA-MIB", "ibSmaPortIsDrNoticeSupported"), ("SMA-MIB", "ibSmaPortIsCapMaskNoticSupported"), ("SMA-MIB", "ibSmaPortIsBootMgmtSupported"), ("SMA-MIB", "ibSmaPortMKeyLeasePeriod"), ("SMA-MIB", "ibSmaPortMKeyProtectBits"), ("SMA-MIB", "ibSmaPortMasterSmSl"), ("SMA-MIB", "ibSmaPortInitTypeLoad"), ("SMA-MIB", "ibSmaPortInitTypeContent"), ("SMA-MIB", "ibSmaPortInitTypePresence"), ("SMA-MIB", "ibSmaPortInitTypeResuscitate"), ("SMA-MIB", "ibSmaPortInitNoLoadReply"), ("SMA-MIB", "ibSmaPortInitPreserveContReply"), ("SMA-MIB", "ibSmaPortInitPreservePresReply"), ("SMA-MIB", "ibSmaPortMKeyViolations"), ("SMA-MIB", "ibSmaPortPKeyViolations"), ("SMA-MIB", "ibSmaPortQKeyViolations"), ("SMA-MIB", "ibSmaPortNumGuid"), ("SMA-MIB", "ibSmaPortSubnetTimeout"), ("SMA-MIB", "ibSmaPortResponseTimeValue"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibSmaMgmtPortGroup = ibSmaMgmtPortGroup.setStatus('current')
if mibBuilder.loadTexts: ibSmaMgmtPortGroup.setDescription('The ibSmaMgmtPortGroup defines the MIB objects that describe the management port.')
ibSmaDataPortGroup = ObjectGroup((1, 3, 6, 1, 3, 117, 3, 3, 2, 5)).setObjects(("SMA-MIB", "ibSmaPortLinkWidthEnabled"), ("SMA-MIB", "ibSmaPortLinkWidthSupported"), ("SMA-MIB", "ibSmaPortLinkWidthActive"), ("SMA-MIB", "ibSmaPortLinkSpeedSupported"), ("SMA-MIB", "ibSmaPortLinkState"), ("SMA-MIB", "ibSmaPortPhysState"), ("SMA-MIB", "ibSmaPortLinkDownDefaultState"), ("SMA-MIB", "ibSmaPortLidMaskCount"), ("SMA-MIB", "ibSmaPortLinkSpeedActive"), ("SMA-MIB", "ibSmaPortLinkSpeedEnabled"), ("SMA-MIB", "ibSmaPortNeighborMtu"), ("SMA-MIB", "ibSmaPortVirtLaneSupport"), ("SMA-MIB", "ibSmaPortVlHighPriorityLimit"), ("SMA-MIB", "ibSmaPortVlArbHighCapacity"), ("SMA-MIB", "ibSmaPortVlArbLowCapacity"), ("SMA-MIB", "ibSmaPortMtuCapacity"), ("SMA-MIB", "ibSmaPortVlStallCount"), ("SMA-MIB", "ibSmaPortHeadOfQueueLife"), ("SMA-MIB", "ibSmaPortOperationalVls"), ("SMA-MIB", "ibSmaPortPartEnforceInbound"), ("SMA-MIB", "ibSmaPortPartEnforceOutbound"), ("SMA-MIB", "ibSmaPortFilterRawPktInbound"), ("SMA-MIB", "ibSmaPortFilterRawPktOutbound"), ("SMA-MIB", "ibSmaPortLocalPhysErrorThreshold"), ("SMA-MIB", "ibSmaPortOverrunErrorThreshold"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibSmaDataPortGroup = ibSmaDataPortGroup.setStatus('current')
if mibBuilder.loadTexts: ibSmaDataPortGroup.setDescription('The ibSmaDataPortGroup defines MIB objects for IB data ports.')
ibSmaPKeyGroup = ObjectGroup((1, 3, 6, 1, 3, 117, 3, 3, 2, 6)).setObjects(("SMA-MIB", "ibSmaPKeyMembership"), ("SMA-MIB", "ibSmaPKeyBase"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibSmaPKeyGroup = ibSmaPKeyGroup.setStatus('current')
if mibBuilder.loadTexts: ibSmaPKeyGroup.setDescription('The ibSmaPKeyGroup defines the MIB objects that describe the Partition Keys.')
ibSmaSlToVlMapGroup = ObjectGroup((1, 3, 6, 1, 3, 117, 3, 3, 2, 7)).setObjects(("SMA-MIB", "ibSmaVirtualLane"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibSmaSlToVlMapGroup = ibSmaSlToVlMapGroup.setStatus('current')
if mibBuilder.loadTexts: ibSmaSlToVlMapGroup.setDescription('The ibSmaSlToVlMapGroup defines the MIB objects that describe the Service Level to Virtual Lane mapping.')
ibSmaVLArbitGroup = ObjectGroup((1, 3, 6, 1, 3, 117, 3, 3, 2, 8)).setObjects(("SMA-MIB", "ibSmaHiPriVirtLane"), ("SMA-MIB", "ibSmaHiPriWeight"), ("SMA-MIB", "ibSmaLowPriVirtLane"), ("SMA-MIB", "ibSmaLowPriWeight"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibSmaVLArbitGroup = ibSmaVLArbitGroup.setStatus('current')
if mibBuilder.loadTexts: ibSmaVLArbitGroup.setDescription('The ibSmaVLArbitGroup defines the MIB objects that describe the Virtual Lane High and Low Arbitrations.')
ibSmaLFTGroup = ObjectGroup((1, 3, 6, 1, 3, 117, 3, 3, 2, 9)).setObjects(("SMA-MIB", "ibSmaLinForwEgressPort"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibSmaLFTGroup = ibSmaLFTGroup.setStatus('current')
if mibBuilder.loadTexts: ibSmaLFTGroup.setDescription('The ibSmaLFTGroup defines the MIB objects that describe the Linear Forwarding Table.')
ibSmaRFTGroup = ObjectGroup((1, 3, 6, 1, 3, 117, 3, 3, 2, 10)).setObjects(("SMA-MIB", "ibSmaRandomDestLID"), ("SMA-MIB", "ibSmaRandomForwEgressPort"), ("SMA-MIB", "ibSmaRandomLMC"), ("SMA-MIB", "ibSmaRandomIsValid"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibSmaRFTGroup = ibSmaRFTGroup.setStatus('current')
if mibBuilder.loadTexts: ibSmaRFTGroup.setDescription('The ibSmaRFTGroup defines the MIB objects that describe the Random Forwarding Table.')
ibSmaMFTGroup = ObjectGroup((1, 3, 6, 1, 3, 117, 3, 3, 2, 11)).setObjects(("SMA-MIB", "ibSmaMulForwMask"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibSmaMFTGroup = ibSmaMFTGroup.setStatus('current')
if mibBuilder.loadTexts: ibSmaMFTGroup.setDescription('The ibSmaMFTGroup defines the MIB objects that describe the Multicast Forwarding Table.')
ibSmaSMGroup = ObjectGroup((1, 3, 6, 1, 3, 117, 3, 3, 2, 12)).setObjects(("SMA-MIB", "ibSmaSmGuid"), ("SMA-MIB", "ibSmaSmSmKey"), ("SMA-MIB", "ibSmaSmSmpCount"), ("SMA-MIB", "ibSmaSmPriority"), ("SMA-MIB", "ibSmaSmState"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibSmaSMGroup = ibSmaSMGroup.setStatus('current')
if mibBuilder.loadTexts: ibSmaSMGroup.setDescription('The ibSmaSMGroup defines the MIB objects that describe the Subnet Manager Information Table.')
ibSmaVendDiagGroup = ObjectGroup((1, 3, 6, 1, 3, 117, 3, 3, 2, 13)).setObjects(("SMA-MIB", "ibSmaPortGenericDiagCode"), ("SMA-MIB", "ibSmaPortVendorDiagCode"), ("SMA-MIB", "ibSmaPortVendorDiagIndexFwd"), ("SMA-MIB", "ibSmaPortVendorDiagData"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibSmaVendDiagGroup = ibSmaVendDiagGroup.setStatus('current')
if mibBuilder.loadTexts: ibSmaVendDiagGroup.setDescription('The ibSmaVendDiagGroup defines the MIB objects that describe the vendor diagnostics table.')
ibSmaLedGroup = ObjectGroup((1, 3, 6, 1, 3, 117, 3, 3, 2, 14)).setObjects(("SMA-MIB", "ibSmaLedState"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibSmaLedGroup = ibSmaLedGroup.setStatus('current')
if mibBuilder.loadTexts: ibSmaLedGroup.setDescription('The ibSmaSMGroup defines the MIB objects that describe the LED table.')
ibSmaNotificationsGroup = NotificationGroup((1, 3, 6, 1, 3, 117, 3, 3, 2, 15)).setObjects(("SMA-MIB", "ibSmaPortLinkStateChange"), ("SMA-MIB", "ibSmaLinkIntegrityThresReached"), ("SMA-MIB", "ibSmaExcessBuffOverrunThres"), ("SMA-MIB", "ibSmaFlowCntrlUpdateTimerExpire"), ("SMA-MIB", "ibSmaCapabilityMaskModified"), ("SMA-MIB", "ibSmaSysImageGuidModified"), ("SMA-MIB", "ibSmaBadManagementKey"), ("SMA-MIB", "ibSmaBadPartitionKey"), ("SMA-MIB", "ibSmaBadQueueKey"), ("SMA-MIB", "ibSmaBadPKeyAtSwitchPort"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibSmaNotificationsGroup = ibSmaNotificationsGroup.setStatus('current')
if mibBuilder.loadTexts: ibSmaNotificationsGroup.setDescription('The notifications that an IPOIB SNMP agent transmits on the behalf of the SMA Trap message implementation.')
mibBuilder.exportSymbols("SMA-MIB", ibSmaSwDefaultPort=ibSmaSwDefaultPort, ibSmaRandomForwardingTable=ibSmaRandomForwardingTable, PYSNMP_MODULE_ID=ibSmaMIB, ibSmaFlowCntrlUpdateTimerExpire=ibSmaFlowCntrlUpdateTimerExpire, ibSmaPortMasterSmLid=ibSmaPortMasterSmLid, ibSmaPortVlArbHighCapacity=ibSmaPortVlArbHighCapacity, ibSmaGuidInfoTable=ibSmaGuidInfoTable, ibSmaSystemImageGuid=ibSmaSystemImageGuid, ibSmaPKeyInfo=ibSmaPKeyInfo, ibSmaPKeyIBAPortIndex=ibSmaPKeyIBAPortIndex, ibSmaMFTInfo=ibSmaMFTInfo, ibSmaVendDiagInfoTable=ibSmaVendDiagInfoTable, ibSmaPortMKeyLeasePeriod=ibSmaPortMKeyLeasePeriod, ibSmaNodeAttributeModifier=ibSmaNodeAttributeModifier, ibSmaPortMKeyViolations=ibSmaPortMKeyViolations, ibSmaGuidVal=ibSmaGuidVal, ibSmaLFTInfo=ibSmaLFTInfo, ibSmaPortIsAutoMigrateSupported=ibSmaPortIsAutoMigrateSupported, ibSmaSmInfoPortIndex=ibSmaSmInfoPortIndex, ibSmaPortIsPKeyExtPortTrapSup=ibSmaPortIsPKeyExtPortTrapSup, ibSmaNodeInfo=ibSmaNodeInfo, ibSmaPortGidPrefix=ibSmaPortGidPrefix, ibSmaSwLinearFdbTop=ibSmaSwLinearFdbTop, ibSmaNodePortGuid=ibSmaNodePortGuid, ibSmaLowPriVlArbTable=ibSmaLowPriVlArbTable, ibSmaPortLinkState=ibSmaPortLinkState, ibSmaPortIsMKeyNvram=ibSmaPortIsMKeyNvram, ibSmaNodePartitionTableNum=ibSmaNodePartitionTableNum, ibSmaSMInfo=ibSmaSMInfo, ibSmaGuidIndex=ibSmaGuidIndex, ibSmaPortIsPKeyNvram=ibSmaPortIsPKeyNvram, ibSmaSysImageGuidModified=ibSmaSysImageGuidModified, ibSmaVendDiagInfoEntry=ibSmaVendDiagInfoEntry, ibSmaLedInfoEntry=ibSmaLedInfoEntry, ibSmaLowPriVlArbEntry=ibSmaLowPriVlArbEntry, ibSmaPortNeighborMtu=ibSmaPortNeighborMtu, ibSmaSwFilterRawPktInputCap=ibSmaSwFilterRawPktInputCap, ibSmaHiPriVlArbEntry=ibSmaHiPriVlArbEntry, ibSmaNodeKey=ibSmaNodeKey, ibSmaSL2VLMapEntry=ibSmaSL2VLMapEntry, ibSmaRandomLMC=ibSmaRandomLMC, ibSmaLowPriNIndex=ibSmaLowPriNIndex, ibSmaNodeClassVersion=ibSmaNodeClassVersion, ibSmaPortIsDrNoticeSupported=ibSmaPortIsDrNoticeSupported, ibSmaLedInfo=ibSmaLedInfo, ibSmaSwRandomFdbTableNum=ibSmaSwRandomFdbTableNum, ibSmaPortLinkDownDefaultState=ibSmaPortLinkDownDefaultState, ibSmaPKeyTable=ibSmaPKeyTable, ibSmaPortSubnetTimeout=ibSmaPortSubnetTimeout, ibSmaPortIsVendorClassSupported=ibSmaPortIsVendorClassSupported, ibSmaPortInitTypeLoad=ibSmaPortInitTypeLoad, ibSmaSwPartitionEnforceNum=ibSmaSwPartitionEnforceNum, ibSmaPortNumGuid=ibSmaPortNumGuid, ibSmaPortLinkSpeedActive=ibSmaPortLinkSpeedActive, ibSmaSwLinearFdbTableNum=ibSmaSwLinearFdbTableNum, ibSmaNodeDataValid=ibSmaNodeDataValid, ibSmaPortIsCommManageSupported=ibSmaPortIsCommManageSupported, ibSmaHiPriNIndex=ibSmaHiPriNIndex, ibSmaLinForwEgressPort=ibSmaLinForwEgressPort, ibSmaNodeLid=ibSmaNodeLid, ibSmaVendDiagGroup=ibSmaVendDiagGroup, ibSmaSwDefMcastPriPort=ibSmaSwDefMcastPriPort, ibSmaPortFilterRawPktInbound=ibSmaPortFilterRawPktInbound, ibSmaIBAOutPortIndex=ibSmaIBAOutPortIndex, ibSmaServiceLevelIndex=ibSmaServiceLevelIndex, ibSmaPortIsLedInfoSupported=ibSmaPortIsLedInfoSupported, ibSmaNodeCapMask=ibSmaNodeCapMask, ibSmaDataPortInfo=ibSmaDataPortInfo, ibSmaSmState=ibSmaSmState, ibSmaCompliances=ibSmaCompliances, ibSmaConformance=ibSmaConformance, ibSmaSwLidsPerPort=ibSmaSwLidsPerPort, ibSmaPortIsSysImgGuidSupported=ibSmaPortIsSysImgGuidSupported, ibSmaPortInfoEntry=ibSmaPortInfoEntry, ibSmaSwitchGroup=ibSmaSwitchGroup, ibSmaVLArbitGroup=ibSmaVLArbitGroup, ibSmaNodeQueuePair1=ibSmaNodeQueuePair1, ibSmaPortMKeyProtectBits=ibSmaPortMKeyProtectBits, ibSmaDataPortGroup=ibSmaDataPortGroup, ibSmaPortHeadOfQueueLife=ibSmaPortHeadOfQueueLife, ibSmaLinForTable=ibSmaLinForTable, ibSmaPortIsTrapSupported=ibSmaPortIsTrapSupported, ibSmaPortPartEnforceInbound=ibSmaPortPartEnforceInbound, ibSmaLinDestDLIDIndex=ibSmaLinDestDLIDIndex, ibSmaLedState=ibSmaLedState, ibSmaPortInitNoLoadReply=ibSmaPortInitNoLoadReply, ibSmaPortResponseTimeValue=ibSmaPortResponseTimeValue, ibSmaPortMtuCapacity=ibSmaPortMtuCapacity, ibSmaMulForwMask=ibSmaMulForwMask, ibSmaPortOverrunErrorThreshold=ibSmaPortOverrunErrorThreshold, ibSmaNodePortNum=ibSmaNodePortNum, ibSmaPortFilterRawPktOutbound=ibSmaPortFilterRawPktOutbound, ibSmaSmSmKey=ibSmaSmSmKey, ibSmaNodeLid2=ibSmaNodeLid2, ibSmaGuidGroup=ibSmaGuidGroup, ibSmaNodeServiceLevel=ibSmaNodeServiceLevel, ibSmaSwPortStateChange=ibSmaSwPortStateChange, ibSmaPortIsSmDisabled=ibSmaPortIsSmDisabled, ibSmaNodeQueuePair2=ibSmaNodeQueuePair2, ibSmaSmGuid=ibSmaSmGuid, ibSmaSwOutboundEnforceCap=ibSmaSwOutboundEnforceCap, ibSmaSmInfoEntry=ibSmaSmInfoEntry, ibSmaPortLinkWidthEnabled=ibSmaPortLinkWidthEnabled, ibSmaSwLifeTimeValue=ibSmaSwLifeTimeValue, ibSmaLedIndex=ibSmaLedIndex, ibSmaRFTGroup=ibSmaRFTGroup, ibSmaLowPriVirtLane=ibSmaLowPriVirtLane, ibSmaSMGroup=ibSmaSMGroup, ibSmaLedGroup=ibSmaLedGroup, ibSmaPortLinkWidthSupported=ibSmaPortLinkWidthSupported, ibSmaRandomForwardingEntry=ibSmaRandomForwardingEntry, ibSmaPortIsSlMappingSupported=ibSmaPortIsSlMappingSupported, ibSmaPKeyMembership=ibSmaPKeyMembership, ibSmaLedInfoTable=ibSmaLedInfoTable, ibSmaNotificationsGroup=ibSmaNotificationsGroup, ibSmaSubMgrInfo=ibSmaSubMgrInfo, ibSmaPortIsCapMaskNoticSupported=ibSmaPortIsCapMaskNoticSupported, ibSmaVendDiagInfo=ibSmaVendDiagInfo, ibSmaPortIndex=ibSmaPortIndex, ibGuidInfoEntry=ibGuidInfoEntry, ibSmaNodeDeviceId=ibSmaNodeDeviceId, ibSmaPortGenericDiagCode=ibSmaPortGenericDiagCode, ibSmaNotificationPrefix=ibSmaNotificationPrefix, ibSmaNodeGuid=ibSmaNodeGuid, ibSmaRandomDestLID=ibSmaRandomDestLID, ibSmaLinkIntegrityThresReached=ibSmaLinkIntegrityThresReached, ibSmaPortLidMaskCount=ibSmaPortLidMaskCount, ibSmaBadManagementKey=ibSmaBadManagementKey, ibSmaHiPriVlArbTable=ibSmaHiPriVlArbTable, ibSmaNodeRevision=ibSmaNodeRevision, ibSmaIBAInPortIndex=ibSmaIBAInPortIndex, ibSmaNodeString=ibSmaNodeString, ibSmaSmInfoTable=ibSmaSmInfoTable, ibSmaPortLinkSpeedSupported=ibSmaPortLinkSpeedSupported, ibSmaSlToVlMapGroup=ibSmaSlToVlMapGroup, ibSmaPortPKeyViolations=ibSmaPortPKeyViolations, ibSmaPKeyEntry=ibSmaPKeyEntry, ibSmaSlToVlMapInfo=ibSmaSlToVlMapInfo, ibSmaVirtualLane=ibSmaVirtualLane, ibSmaMulForEntry=ibSmaMulForEntry, ibSmaMFTGroup=ibSmaMFTGroup, ibSmaPortLocalPhysErrorThreshold=ibSmaPortLocalPhysErrorThreshold, ibSmaBadQueueKey=ibSmaBadQueueKey, ibSmaRandomIsValid=ibSmaRandomIsValid, ibSmaNodeMethod=ibSmaNodeMethod, ibSmaExcessBuffOverrunThres=ibSmaExcessBuffOverrunThres, ibSmaPortIsNoticeSupported=ibSmaPortIsNoticeSupported, ibSmaNodeGid1=ibSmaNodeGid1, ibSmaSwitchInfo=ibSmaSwitchInfo, ibSmaPortInitTypePresence=ibSmaPortInitTypePresence, ibSmaPortLinkStateChange=ibSmaPortLinkStateChange, ibSmaNodeBaseVersion=ibSmaNodeBaseVersion, ibSmaGuidInfo=ibSmaGuidInfo, ibSmaPortInitTypeResuscitate=ibSmaPortInitTypeResuscitate, ibSmaPortVendorDiagIndexFwd=ibSmaPortVendorDiagIndexFwd, ibSmaLowPriWeight=ibSmaLowPriWeight, ibSmaPortInfoTable=ibSmaPortInfoTable, ibSmaPortOperationalVls=ibSmaPortOperationalVls, ibSmaRFTInfo=ibSmaRFTInfo, ibSmaObjects=ibSmaObjects, ibSmaLowPriIBAPortIndex=ibSmaLowPriIBAPortIndex, ibSmaBasicNodeCompliance=ibSmaBasicNodeCompliance, ibSmaPortLinkSpeedEnabled=ibSmaPortLinkSpeedEnabled, ibSmaNodeLocalPortNumOrZero=ibSmaNodeLocalPortNumOrZero, ibSmaLinForEntry=ibSmaLinForEntry, ibSmaPortIsSnmpTunnelSupported=ibSmaPortIsSnmpTunnelSupported, ibSmaSL2VLMapTable=ibSmaSL2VLMapTable, ibSmaSwMulticastFdbTableNum=ibSmaSwMulticastFdbTableNum, ibSmaGuidPortIndex=ibSmaGuidPortIndex, ibSmaBadPartitionKey=ibSmaBadPartitionKey, ibSmaPKeyIndex=ibSmaPKeyIndex, ibSmaNodeGroup=ibSmaNodeGroup, ibSmaPKeyBase=ibSmaPKeyBase, ibSmaNodeAttributeId=ibSmaNodeAttributeId, ibSmaNodeSwitchLid=ibSmaNodeSwitchLid, ibSmaPortIsDevManageSupported=ibSmaPortIsDevManageSupported, ibSmaSwEnhancedPort0=ibSmaSwEnhancedPort0, ibSmaSmPriority=ibSmaSmPriority, ibSmaBadPKeyAtSwitchPort=ibSmaBadPKeyAtSwitchPort, ibSmaPortVirtLaneSupport=ibSmaPortVirtLaneSupport, ibSmaSwFilterRawPktOutputCap=ibSmaSwFilterRawPktOutputCap, ibSmaMulForTable=ibSmaMulForTable, ibSmaSmSmpCount=ibSmaSmSmpCount, ibSmaRandomForwardingPortIndex=ibSmaRandomForwardingPortIndex, ibSmaSwInboundEnforceCap=ibSmaSwInboundEnforceCap, ibSmaNodeGid2=ibSmaNodeGid2, ibSmaVLArbitInfo=ibSmaVLArbitInfo, ibSmaPortVendorDiagData=ibSmaPortVendorDiagData, ibSmaPortLinkWidthActive=ibSmaPortLinkWidthActive, ibSmaNodeNumPorts=ibSmaNodeNumPorts, ibSmaFullSwitchCompliance=ibSmaFullSwitchCompliance, ibSmaLFTGroup=ibSmaLFTGroup, ibSmaVendDiagPortIndex=ibSmaVendDiagPortIndex, ibSmaPortMasterSmSl=ibSmaPortMasterSmSl, ibSmaPortLid=ibSmaPortLid, ibSmaHiPriWeight=ibSmaHiPriWeight, ibSmaHiPriVirtLane=ibSmaHiPriVirtLane, ibSmaMgmtPortInfo=ibSmaMgmtPortInfo, ibSmaPortInitPreservePresReply=ibSmaPortInitPreservePresReply, ibSmaPortIsBootMgmtSupported=ibSmaPortIsBootMgmtSupported, ibSmaPortPartEnforceOutbound=ibSmaPortPartEnforceOutbound, ibSmaNotifications=ibSmaNotifications, ibSmaPortMKey=ibSmaPortMKey, ibSmaPortVendorDiagCode=ibSmaPortVendorDiagCode, ibSmaPortIsSubnetManager=ibSmaPortIsSubnetManager, ibSmaPortVlStallCount=ibSmaPortVlStallCount, ibSmaHiPriIBAPortIndex=ibSmaHiPriIBAPortIndex, ibSmaPortIsReinitSupported=ibSmaPortIsReinitSupported, ibSmaFullRouterCACompliance=ibSmaFullRouterCACompliance, ibSmaPortVlHighPriorityLimit=ibSmaPortVlHighPriorityLimit, ibSmaRandomForwEgressPort=ibSmaRandomForwEgressPort, ibSmaPortQKeyViolations=ibSmaPortQKeyViolations, ibSmaNodeType=ibSmaNodeType, ibSmaPortInitPreserveContReply=ibSmaPortInitPreserveContReply, ibSmaSwDefMcastNotPriPort=ibSmaSwDefMcastNotPriPort, ibSmaPortVlArbLowCapacity=ibSmaPortVlArbLowCapacity, ibSmaMIB=ibSmaMIB, ibSmaPortInitTypeContent=ibSmaPortInitTypeContent, ibSmaMgmtPortGroup=ibSmaMgmtPortGroup, ibSmaPKeyGroup=ibSmaPKeyGroup, ibSmaGroups=ibSmaGroups, ibSmaCapabilityMaskModified=ibSmaCapabilityMaskModified, ibSmaNodeVendorId=ibSmaNodeVendorId, ibSmaMulDestDLIDIndex=ibSmaMulDestDLIDIndex, ibSmaPortPhysState=ibSmaPortPhysState)

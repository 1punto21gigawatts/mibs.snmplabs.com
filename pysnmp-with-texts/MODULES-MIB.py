#
# PySNMP MIB module MODULES-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/MODULES-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:13:40 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, SingleValueConstraint, ValueSizeConstraint, ConstraintsIntersection, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsIntersection", "ConstraintsUnion")
lannet, = mibBuilder.importSymbols("GEN-MIB", "lannet")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
MibScalar, MibTable, MibTableRow, MibTableColumn, IpAddress, Integer32, Bits, ModuleIdentity, Unsigned32, Counter32, ObjectIdentity, Counter64, NotificationType, Gauge32, iso, MibIdentifier, TimeTicks = mibBuilder.importSymbols("SNMPv2-SMI", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "IpAddress", "Integer32", "Bits", "ModuleIdentity", "Unsigned32", "Counter32", "ObjectIdentity", "Counter64", "NotificationType", "Gauge32", "iso", "MibIdentifier", "TimeTicks")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
eth = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 12))
tok = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 13))
ts = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 14))
ltalk = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 15))
cl = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 16))
bRouter = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 21))
lntFddiGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 25))
ethAg = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 12, 1))
ethAgTable = MibTable((1, 3, 6, 1, 4, 1, 81, 12, 1, 1), )
if mibBuilder.loadTexts: ethAgTable.setStatus('mandatory')
if mibBuilder.loadTexts: ethAgTable.setDescription('Table of attributes which define configuration characteristics for chassis SNMP agents which use Ethernet as in-band management protocol.')
ethAgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 12, 1, 1, 1), ).setIndexNames((0, "MODULES-MIB", "ethAgId"))
if mibBuilder.loadTexts: ethAgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ethAgEntry.setDescription('An entry in the table, containing data about a single Ethernet agent.')
ethAgId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethAgId.setStatus('mandatory')
if mibBuilder.loadTexts: ethAgId.setDescription('Index which identifies the Ethernet agent for which the current entry provides information.')
ethAgPerfBusSelection = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 1, 1, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethAgPerfBusSelection.setStatus('mandatory')
if mibBuilder.loadTexts: ethAgPerfBusSelection.setDescription('Attribute describing the bus attached to the performance data collection hardware on those agent hardware implementations which support configuration management on multi-Ethernet bus enclosures, but performan- ce data collection on a single bus.')
ethGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 12, 2))
ethGroupTable = MibTable((1, 3, 6, 1, 4, 1, 81, 12, 2, 1), )
if mibBuilder.loadTexts: ethGroupTable.setStatus('mandatory')
if mibBuilder.loadTexts: ethGroupTable.setDescription('Table of attributes which define configuration characteristics for Ethernet modules.')
ethGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 12, 2, 1, 1), ).setIndexNames((0, "MODULES-MIB", "ethGroupId"))
if mibBuilder.loadTexts: ethGroupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ethGroupEntry.setDescription('An entry in the table, containing data about a single Ethernet module (group).')
ethGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: ethGroupId.setDescription('Index which identifies the group inside the chassis for which this entry contains information. Equals the number of the slot by which the group is accessed. This value is never greater than chNumberOfSlots.')
ethGroupFIFO = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethGroupFIFO.setStatus('mandatory')
if mibBuilder.loadTexts: ethGroupFIFO.setDescription('Value ON of this attribute describes an internal FIFO error sensed by the internal hardware mechanism of a repeater.')
ethGroup10BTPlus = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethGroup10BTPlus.setStatus('mandatory')
if mibBuilder.loadTexts: ethGroup10BTPlus.setDescription('Value ON of this attribute defines activation of the 10BaseTPlus mode - a proprietary extension of the 10BaseT standard.')
ethGroupIntPortsRedundancy = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethGroupIntPortsRedundancy.setStatus('mandatory')
if mibBuilder.loadTexts: ethGroupIntPortsRedundancy.setDescription('Value ON of this attribute defines a redundancy (backup) relationship between internal ports 1 and 2 on a module.')
ethGroupBackboneMode = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethGroupBackboneMode.setStatus('mandatory')
if mibBuilder.loadTexts: ethGroupBackboneMode.setDescription('Value On of this attribute defines Backbone Mode of a sensor. Internal ports are enabled and the information path goes straightly from external port to internal bus, via corresponding internal port.')
ethGroupFOIRLPlusMode = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethGroupFOIRLPlusMode.setStatus('mandatory')
if mibBuilder.loadTexts: ethGroupFOIRLPlusMode.setDescription('Value On of this attribute defines FOIRL of a sensor. When this attribute has value ON, FOIRL Plus mode is enabled, while value OFF indicates stan- dard FOIRL mode.')
ethGroupWrongPortSelection = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethGroupWrongPortSelection.setStatus('mandatory')
if mibBuilder.loadTexts: ethGroupWrongPortSelection.setDescription('A value ON of this attribute warns of incorrect selection of enabled ports on sensors which impose restrictions on this configura- tion (e.g. integrated local bridges.)')
ethGroupBackupBus = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethGroupBackupBus.setStatus('mandatory')
if mibBuilder.loadTexts: ethGroupBackupBus.setDescription('Defines the common secondary bus for Ethernet modules with bus redundancy defined at port level.')
ethGroupSingleBusMode = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 2, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethGroupSingleBusMode.setStatus('mandatory')
if mibBuilder.loadTexts: ethGroupSingleBusMode.setDescription("Value 'on of this attribute defines bus-star mode for cards supporting this type of configuration.")
ethGroupSpecificOID = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 2, 1, 1, 10), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethGroupSpecificOID.setStatus('mandatory')
if mibBuilder.loadTexts: ethGroupSpecificOID.setDescription('This attribute provides the OID of another group containing additional more specific information regarding this instance.')
ethGroup10FBPlus = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 2, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethGroup10FBPlus.setStatus('mandatory')
if mibBuilder.loadTexts: ethGroup10FBPlus.setDescription('This variable enables/disables 10BaseFB plus mode.')
ethGroupMasterClock = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 2, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethGroupMasterClock.setStatus('mandatory')
if mibBuilder.loadTexts: ethGroupMasterClock.setDescription('This attribute pertains to the SH-E16 chassis and defines the hub in the stack that generates the clock.')
ethGroupIdleTrx = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 2, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethGroupIdleTrx.setStatus('mandatory')
if mibBuilder.loadTexts: ethGroupIdleTrx.setDescription("This attribute is relevant to the LE-120Q/SQ modules and when set to 'off' after port disable terminates also light propagation (for redundancy tests).")
ethGroupTotalFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 2, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethGroupTotalFrames.setStatus('mandatory')
if mibBuilder.loadTexts: ethGroupTotalFrames.setDescription('The total number of frames of valid frame length that have been received on the ports in this group and for which the FCSError and CollisionEvent signals were not asserted. This statistic provides one of the parameters necessary for obtaining the packet error rate. The approximate minimum time for rollover of this counter is 80 hours. This item is a Repeater MIB counter.')
ethGroupTotalOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 2, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethGroupTotalOctets.setStatus('mandatory')
if mibBuilder.loadTexts: ethGroupTotalOctets.setDescription('The total number of octets contained in the valid frames that have been received on the ports in this group. This counter is the summation of the values of the ethPortReadableOctets counters for all of the ports in the group. This statistic provides an indicator of the total data transferred. The approximate minimum time for rollover of this counter is 58 minutes. This item is a Repeater MIB counter.')
ethGroupTotalErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 2, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethGroupTotalErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ethGroupTotalErrors.setDescription('The total number of errors which have occurred on all of the ports in this group. This counter is the summation of the values of the ethPortTotalErrors counters for all of the ports in the group. This item is a Repeater MIB counter.')
ethGroupBridgeMode = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 2, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 5, 6, 9, 10, 12))).clone(namedValues=NamedValues(("bus1Tobus2", 3), ("bus1ToAUIPort", 5), ("bus2ToAUIPort", 6), ("bus1To10BTPort", 9), ("bus2To10BTPort", 10), ("portAUITo10BTPort", 12)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethGroupBridgeMode.setStatus('mandatory')
if mibBuilder.loadTexts: ethGroupBridgeMode.setDescription('This attribute defines between which buses/ports the IELB bridge is bridging.')
ethGroupBroadcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 2, 1, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethGroupBroadcastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: ethGroupBroadcastPkts.setDescription('The total number of good packets received that were directed to the broadcast address, through this ports group.')
ethGroupMulticastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 2, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethGroupMulticastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: ethGroupMulticastPkts.setDescription('The total number of good packets received that were directed to a multicast address, through this ports group. Note that this number does not include packets directed to the broadcast address.')
ethPort = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 12, 3))
ethPortTable = MibTable((1, 3, 6, 1, 4, 1, 81, 12, 3, 1), )
if mibBuilder.loadTexts: ethPortTable.setStatus('mandatory')
ethPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 12, 3, 1, 1), ).setIndexNames((0, "MODULES-MIB", "ethPortGroupId"), (0, "MODULES-MIB", "ethPortId"))
if mibBuilder.loadTexts: ethPortEntry.setStatus('mandatory')
ethPortGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethPortGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: ethPortGroupId.setDescription('Id of the group to which the port belongs.')
ethPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 3, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethPortId.setStatus('mandatory')
if mibBuilder.loadTexts: ethPortId.setDescription('Unique Id of the port in the ethPortTable.')
ethPortFunctionalStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 255))).clone(namedValues=NamedValues(("ok", 1), ("rld", 2), ("localJabber", 3), ("tld", 4), ("remoteJabber", 5), ("illSeq", 6), ("shortCirc", 7), ("partitionOrLocalJabber", 8), ("remoteFaultOrLockLost", 9), ("remoteFault", 10), ("lockLost", 11), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethPortFunctionalStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ethPortFunctionalStatus.setDescription('The value of this attribute reflects the functional status of synchronous ports. Note that it is not mandatory that all ports support all the enumerated states. ok(1) - fully functional port, transmitting and receiving packets. rld(2) - receive link down condition on the port - Indicates a cable or connector failure detected by the port H/W. localJabber(3) - fault condition indicating that the port emitted jabber (excessive long transmission) tld(4) - transmit link down condition on the port - Indicates a cable or connector failure detected by the H/W of a port connected to the monitored port. remoteJabber(5) - fault condition indicating that remote jabber was sensed at the port. illSeq(6) - fault condition indicating an illegal synchronization sequence at the port. shortCircuit(7) - short-circuit fault condition detected at the port. partitionOrLocalJabber(8) - one of the partition or local jabber (excessive long transmission) was detected at the port of an optical repeater ) - remoteFaultOrLockLoss(9) - one of optical repeater fault conditions, detected by the port H/W. remoteFault(10) - fault condition, detected by an optical port connected to the monitored port. lockLost(11) - optical port H/W fault. ')
ethPortManPart = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethPortManPart.setStatus('mandatory')
if mibBuilder.loadTexts: ethPortManPart.setDescription('Setting the value of this attribute to ON activates the manual partition mechanism at the port level. Setting the value of this attribute to OFF cancels the partition mechanism. The segment may reconnect after the reception of 32 packets. Attribute vaild for repeater modules from the LE-10 family.')
ethPortJabber = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethPortJabber.setStatus('mandatory')
if mibBuilder.loadTexts: ethPortJabber.setDescription('Value ON of this attribute reflects jabber transmitted to the port by the hardware of a repeater or transceiver, as a result of collisions detected on the port. Valid for all modules in the LE-10 and LE-15 families.')
ethPortNoAUILoop = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethPortNoAUILoop.setStatus('mandatory')
if mibBuilder.loadTexts: ethPortNoAUILoop.setDescription('Value ON of this attribute indicates that a No AUI Loop fault condition was detected on an AUI repeater port. Valid for LE-10C family of modu- les.')
ethPortMJLP = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethPortMJLP.setStatus('mandatory')
if mibBuilder.loadTexts: ethPortMJLP.setDescription('Value ON of this attribute describes an internal MJLP (MAU Jabber Lockup Protection) error sensed by the internal hardware mechanism of a repeater. This mechanism is activated to protect the repeater ports from a jabber condition (excessive long transmission) detected on one of the port. Valid for LE140XTF.')
ethPortFIFO = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 3, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethPortFIFO.setStatus('mandatory')
if mibBuilder.loadTexts: ethPortFIFO.setDescription('Value ON of this attribute describes an internal FIFO error sensed by the internal hardware mechanism of a repeater. Valid for LE140XTF.')
ethPortAutoPartitionState = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 3, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("autoPartition", 1), ("notAutoPartition", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethPortAutoPartitionState.setStatus('mandatory')
if mibBuilder.loadTexts: ethPortAutoPartitionState.setDescription('The AutoPart condition indicates that the port is currently partitioned by the auto-partition protection mechanism.')
ethPortSQETest = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethPortSQETest.setStatus('mandatory')
if mibBuilder.loadTexts: ethPortSQETest.setDescription('Settable attribute which allows activation of SQE test for integrated transceivers.')
ethPortLastSourceAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 3, 1, 1, 11), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethPortLastSourceAddr.setStatus('mandatory')
if mibBuilder.loadTexts: ethPortLastSourceAddr.setDescription('Ethernet source address of the last readable frame received by this port. The value of this item may be set to 000000 (a string of 6 zeros) by a management console, but not to any other value. ')
ethPortUserStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 3, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("singleUser", 1), ("multiUser", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethPortUserStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ethPortUserStatus.setDescription('Attribute defining the connection of a port to a single Ethernet source or to a multi-source (segment or star).')
ethPortMainBusSelection = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 3, 1, 1, 13), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethPortMainBusSelection.setStatus('mandatory')
if mibBuilder.loadTexts: ethPortMainBusSelection.setDescription('On cards with port-level redundancy, defines the main bus for each port instance as selected by user.')
ethPortTraffic = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 3, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethPortTraffic.setStatus('mandatory')
if mibBuilder.loadTexts: ethPortTraffic.setDescription('Counter for the number of bits received on this port in frames with legal length information.')
ethPortFramesReceivedOK = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 3, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethPortFramesReceivedOK.setStatus('mandatory')
if mibBuilder.loadTexts: ethPortFramesReceivedOK.setDescription('A representation of the total number of frames of legal length that have not been corrupted in transmission. These frames can be encoded and decoded by the commonly available MACs and provide a measure of the network bandwidth being used. The number does not include frames received with frame-too-long, FCS, alignment errors, frames lost due to internal MAC sublayer errors, runts or pygmys.')
ethPortRunts = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 3, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethPortRunts.setStatus('mandatory')
if mibBuilder.loadTexts: ethPortRunts.setDescription('This counter is incremented by one for each CarrierEvent on this port that meets one of the following two conditions. Only one test need be made. a) The ActivityDuration is greater than ShortEventMaxTime and less than ValidPacketMinTime and the CollisionEvent signal is deasserted. b) The OctetCount is less than 64, the ActivityDuration is greater than ShortEventMaxTime and the CollisionEvent signal is deasserted. ValidPacketMinTime is greater than or equal to 552 bit times and less than 565 bit times. An event whose length is greater than 74 bit times but less than 82 bit times shall increment either the shortEvents counter or the runts counter but not both. A CarrierEvent greater than or equal to 552 bit times but less than 565 bit times may or may not be counted as a runt. ValidPacketMinTime has tolerances included to provide for circuit losses between a conformance test point at the AUI and the measurement point within the state machine. Runts usually indicate collision fragments, a normal network event. In certain situations associated with large diameter networks a percentage of collision fragments may exceed ValidPacketMinTime. The approximate minimum time for rollover of this counter is 16 hours. REFERENCE Reference IEEE 802.3 Rptr Mgt, 19.2.6.2, aRunts.')
ethPortPacketErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 3, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethPortPacketErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ethPortPacketErrors.setDescription('Counter for the number of frames with errors detected on the port by the agent hardware. This generic port error comprises too long packets, CRC and alignment errors.')
ethPortSpecificOID = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 3, 1, 1, 18), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethPortSpecificOID.setStatus('mandatory')
if mibBuilder.loadTexts: ethPortSpecificOID.setDescription('This attribute provides the OID of another group containing additional more specific information regarding this instance.')
ethPortCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 3, 1, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethPortCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: ethPortCollisions.setDescription('This counter is incremented by one for any CarrierEvent signal on any port for which the CollisionEvent signal on this port is also asserted. The approximate minimum time for rollover of this counter is 16 hours. Relevant for MPR and HIMIB modules. REFERENCE Reference IEEE 802.3 Rptr Mgt, 19.2.6.2, aCollisions.')
ethPortPartitions = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 3, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethPortPartitions.setStatus('mandatory')
if mibBuilder.loadTexts: ethPortPartitions.setDescription('This counter is incremented by one for each time the repeater has automatically partitioned this port. The conditions that cause port partitioning are specified in the partition state machine in Section 9 [IEEE 802.3 Std]. They are not differentiated here. Relevant for MPR and HIMIB modules. REFERENCE Reference IEEE 802.3 Rptr Mgt, 19.2.6.2, aAutoPartitions.')
ethPortPygmys = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 3, 1, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethPortPygmys.setStatus('mandatory')
if mibBuilder.loadTexts: ethPortPygmys.setDescription('The number of pygmys observed on a specified port. The pygmy is a short event. This counter is incremented by one for each CarrierEvent on this port with ActivityDuration less than ShortEventMaxTime. ShortEventMaxTime is greater than 74 bit times and less than 82 bit times. ShortEventMaxTime has tolerances included to provide for circuit losses between a conformance test point at the AUI and the measurement point within the state machine. Note: shortEvents may indicate externally generated noise hits which will cause the repeater to transmit Runts to its other ports, or propagate a collision (which may be late) back to the transmitting DTE and damaged frames to the rest of the network. Implementors may wish to consider selecting the ShortEventMaxTime towards the lower end of the allowed tolerance range to accommodate bit losses suffered through physical channel devices not budgeted for within this standard. The approximate minimum time for rollover of this counter is 16 hours. REFERENCE Reference IEEE 802.3 Rptr Mgt, 19.2.6.2, aShortEvents.')
ethPortJabberCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 3, 1, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethPortJabberCounter.setStatus('mandatory')
if mibBuilder.loadTexts: ethPortJabberCounter.setDescription('Counter for the number of local jabbers detected on a specific port (LE-115Q).')
ethPortCoupling = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 3, 1, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("dc", 1), ("ac", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethPortCoupling.setStatus('mandatory')
if mibBuilder.loadTexts: ethPortCoupling.setDescription("Indication of port's coupling method in Ethernet transceiver modules (LE-115Q). The coupling methode can be set on board, using specific jumpers.")
ethPortPolarity = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 3, 1, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("ok", 1), ("crossed", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethPortPolarity.setStatus('mandatory')
if mibBuilder.loadTexts: ethPortPolarity.setDescription('This item defines the polarity state of the connection to LE-240XTC and LE-280XT ports. If the wires are crossed, the value is crossed(2), otherwise ok(1).')
ethPortReadableFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 3, 1, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethPortReadableFrames.setStatus('mandatory')
if mibBuilder.loadTexts: ethPortReadableFrames.setDescription('This object is the number of frames of valid frame length that have been received on this port. This counter is incremented by one for each frame received on this port whose OctetCount is greater than or equal to minFrameSize and less than or equal to maxFrameSize (Ref: IEEE 802.3 Std, 4.4.2.1) and for which the FCSError and CollisionEvent signals are not asserted. This statistic provides one of the parameters necessary for obtaining the packet error rate. The approximate minimum time for rollover of this counter is 80 hours. REFERENCE Reference IEEE 802.3 Rptr Mgt, 19.2.6.2, aReadableFrames.')
ethPortReadableOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 3, 1, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethPortReadableOctets.setStatus('mandatory')
if mibBuilder.loadTexts: ethPortReadableOctets.setDescription('This counter is the number of octets contained in valid frames that have been received on this port.It is incremented for each frame received on this port which has been determined to be a readable frame (including FCS octets but excluding framing bits and dribble bits). This statistic provides an indicator of the total data transferred. The approximate minimum time for rollover of this counter is 58 minutes. This object is a Repeater MIB counter.')
ethPortFCSErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 3, 1, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethPortFCSErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ethPortFCSErrors.setDescription('This counter is incremented by one for each frame received on this port with the FCSError signal asserted and the FramingError and CollisionEvent signals deasserted and whose OctetCount is greater than or equal to minFrameSize and less than or equal to maxFrameSize (Ref: 4.4.2.1, IEEE 802.3 Std). The approximate minimum time for rollover of this counter is 80 hours. This object is a Repeater MIB counter.')
ethPortAlignmentErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 3, 1, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethPortAlignmentErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ethPortAlignmentErrors.setDescription('This counter is incremented by one for each frame received on this port with the FCSError and FramingError signals asserted and CollisionEvent signal deasserted and whose OctetCount is greater than or equal to minFrameSize and less than or equal to maxFrameSize (Ref: IEEE 802.3 Std, 4.4.2.1). The approximate minimum time for rollover of this counter is 80 hours. This object is a Repeater MIB counter.')
ethPortFramesTooLong = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 3, 1, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethPortFramesTooLong.setStatus('mandatory')
if mibBuilder.loadTexts: ethPortFramesTooLong.setDescription('This counter is incremented by one for each frame received on this port whose OctetCount is greater than maxFrameSize (Ref: 4.4.2.1, IEEE 802.3 Std). The approximate minimum time for rollover of this counter is 61 days. This object is a Repeater MIB counter.')
ethPortLateEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 3, 1, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethPortLateEvents.setStatus('mandatory')
if mibBuilder.loadTexts: ethPortLateEvents.setDescription('This counter is incremented by one for each CarrierEvent on this port in which the CollIn(X) variable transitions to the value SQE (Ref:9.6.6.2, IEEE 802.3 Std) while the ActivityDuration is greater than the LateEventThreshold. Such a CarrierEvent is counted twice, as both a collision and as a lateEvent. The approximate minimum time for rollover of this counter is 81 hours. This object is a Repeater MIB counter.')
ethPortVeryLongEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 3, 1, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethPortVeryLongEvents.setStatus('mandatory')
if mibBuilder.loadTexts: ethPortVeryLongEvents.setDescription('This counter is incremented by one for each CarrierEvent on this port whose ActivityDuration is greater than the MAU Jabber Lockup Protection timer TW3 (Ref: 9.6.1 & 9.6.5, IEEE 802.3 Std). Other counters may be incremented as appropriate. This object is a Repeater MIB counter.')
ethPortDataRateMismatches = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 3, 1, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethPortDataRateMismatches.setStatus('mandatory')
if mibBuilder.loadTexts: ethPortDataRateMismatches.setDescription('This counter is incremented by one for each frame received on this port that meets all of the following conditions: a) The CollisionEvent signal is not asserted. b) The ActivityDuration is greater than ValidPacketMinTime. c) The frequency (data rate) is detectably mismatched from the local transmit frequency. This object is a Repeater MIB counter.')
ethPortTotalErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 3, 1, 1, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethPortTotalErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ethPortTotalErrors.setDescription('The total number of errors which have occurred on this port. This counter is the summation of the values of other error counters (for the same port), namely: ethPortFCSErrors, ethPortAlignmentErrors, ethPortFrameTooLongs, ethPortShortEvents, ethPortLateEvents, ethPortVeryLongEvents, and ethPortDataRateMismatches. This object is a Repeater MIB counter.')
ethPortSourceAddrChanges = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 3, 1, 1, 34), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethPortSourceAddrChanges.setStatus('mandatory')
if mibBuilder.loadTexts: ethPortSourceAddrChanges.setDescription('This counter is incremented by one for each time that the last source address of frames entering this port has changed. This may indicate whether a link is connected to a single DTE or another multi-user segment. The approximate minimum time for rollover of this counter is 81 hours. This object is a Repeater MIB counter.')
ethPortOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 3, 1, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("operational", 1), ("notOperational", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethPortOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ethPortOperStatus.setDescription("This object indicates the port's operational status. The operational(1) status indicates that the port is enabled and working, even though it might be auto-partitioned.")
ethPortBroadcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 3, 1, 1, 36), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethPortBroadcastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: ethPortBroadcastPkts.setDescription('The total number of good packets received that were directed to the broadcast address.')
ethPortMulticastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 3, 1, 1, 37), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethPortMulticastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: ethPortMulticastPkts.setDescription('The total number of good packets received that were directed to a multicast address. Note that this number does not include packets directed to the broadcast address.')
ethIntPort = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 12, 4))
ethIntPortTable = MibTable((1, 3, 6, 1, 4, 1, 81, 12, 4, 1), )
if mibBuilder.loadTexts: ethIntPortTable.setStatus('mandatory')
ethIntPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 12, 4, 1, 1), ).setIndexNames((0, "MODULES-MIB", "ethIntPortGroupId"), (0, "MODULES-MIB", "ethIntPortId"))
if mibBuilder.loadTexts: ethIntPortEntry.setStatus('mandatory')
ethIntPortGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIntPortGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: ethIntPortGroupId.setDescription('ID of the group to which the internal port belongs.')
ethIntPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIntPortId.setStatus('mandatory')
if mibBuilder.loadTexts: ethIntPortId.setDescription('ID of the internal port in the ethIntPortTable.')
ethIntPortPartition = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIntPortPartition.setStatus('mandatory')
if mibBuilder.loadTexts: ethIntPortPartition.setDescription('This condition indicates that the internal port is currently partitioned from the bus by the auto-partition protection mechanism.')
ethIntPortJabber = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIntPortJabber.setStatus('deprecated')
if mibBuilder.loadTexts: ethIntPortJabber.setDescription('Value ON of this attribute reflects jabber being transmitted to the bus by the hardware of a repeater, as a result of collisions detected on the internal bus of the enclosure. This situation is similar to MJLP as defined by the Repeater Management standard.')
ethIntPortBackedUp = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 4, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethIntPortBackedUp.setStatus('mandatory')
if mibBuilder.loadTexts: ethIntPortBackedUp.setDescription('Indicates that internal port is part of a redundancy scheme.')
ethBus = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 12, 5))
ethBusPerfTable = MibTable((1, 3, 6, 1, 4, 1, 81, 12, 5, 1), )
if mibBuilder.loadTexts: ethBusPerfTable.setStatus('mandatory')
ethBusPerfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 12, 5, 1, 1), ).setIndexNames((0, "MODULES-MIB", "ethBusPerfAgId"), (0, "MODULES-MIB", "ethBusPerfId"))
if mibBuilder.loadTexts: ethBusPerfEntry.setStatus('mandatory')
ethBusPerfAgId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 5, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethBusPerfAgId.setStatus('mandatory')
if mibBuilder.loadTexts: ethBusPerfAgId.setDescription('ID of the agent in the ethBusPerfTable.')
ethBusPerfId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethBusPerfId.setStatus('mandatory')
if mibBuilder.loadTexts: ethBusPerfId.setDescription('ID of the bus in the ethBusPerfTable.')
ethBusTrafficBuffer = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 5, 1, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethBusTrafficBuffer.setStatus('deprecated')
if mibBuilder.loadTexts: ethBusTrafficBuffer.setDescription('Record of traffic for the last second with a resolution of 100 msec. The traffic is expressed in percents of the maximum Ethernet traffic and each record contains 10 readings, in the range 1..20, expressed on a log(10) scale ( value = 10*log10(percent) ).')
ethBusTrafficThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 5, 1, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethBusTrafficThresh.setStatus('mandatory')
if mibBuilder.loadTexts: ethBusTrafficThresh.setDescription('Traffic threshold value. When exceeded, a trap is send to the management console. Expressed in percents of the maximum Ethernet traffic, in the range 1..20, expressed on a log(10) scale.')
ethBusPeakTraffic = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 5, 1, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethBusPeakTraffic.setStatus('mandatory')
if mibBuilder.loadTexts: ethBusPeakTraffic.setDescription('Maximal traffic value since last reset of hub or relay. Expressed in per- cents of the maximum Ethernet traffic, in the range 1..20, expressed on log(10) scale. The write access is reserved for resetting the value of the peak.')
ethBusTotalCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 5, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethBusTotalCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: ethBusTotalCollisions.setDescription('Counter incremented every time the hub enters a condition caused by simultaneous transmission and detection of external activity on one or more of its ports.')
ethBusTotalPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 5, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethBusTotalPackets.setStatus('mandatory')
if mibBuilder.loadTexts: ethBusTotalPackets.setDescription('Counter for number of packets (good and errors) detected on the Ethernet bus.')
ethBusTotalErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 5, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethBusTotalErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ethBusTotalErrors.setDescription('Counter for number of errors detected on the Ethernet bus. Does not take into account the collisions.')
ethBusTraffic = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 5, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethBusTraffic.setStatus('mandatory')
if mibBuilder.loadTexts: ethBusTraffic.setDescription('Last traffic reading (sampling time = 100 msec). The traffic is expressed in percents of the maximum Ethernet traffic in the range 1..20, expressed on a log(10) scale ( value = 10*log10(percent) ).')
ethBusUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 5, 1, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethBusUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: ethBusUtilization.setDescription('Last traffic reading (sampling time = 100 msec). The traffic is expressed in percents of the maximum Ethernet traffic.')
ethBusPeakUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 5, 1, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethBusPeakUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: ethBusPeakUtilization.setDescription('Maximal traffic value since last reset of agent. Expressed in percents of the maximum effective Ethernet traffic.')
ethBusThresholdStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 5, 1, 1, 12), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethBusThresholdStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ethBusThresholdStatus.setDescription("This item is a bitmap that defines the threshold status of the bus, in relation to the alarmPolicyTable. If the bus is monitored by the agent according to policy number x in the alarmPolicyTable, and the threshold condition has occured, then the bit #x in this item will have the value '1'. Otherwise it will be '0'. For x-186 based agents all bits of this item are '0'.")
ethBusClockTable = MibTable((1, 3, 6, 1, 4, 1, 81, 12, 5, 2), )
if mibBuilder.loadTexts: ethBusClockTable.setStatus('mandatory')
ethBusClockEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 12, 5, 2, 1), ).setIndexNames((0, "MODULES-MIB", "ethBusClockBusId"), (0, "MODULES-MIB", "ethBusClockId"))
if mibBuilder.loadTexts: ethBusClockEntry.setStatus('mandatory')
ethBusClockBusId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 5, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethBusClockBusId.setStatus('mandatory')
if mibBuilder.loadTexts: ethBusClockBusId.setDescription('ID of the bus in the ethBusClockTable.')
ethBusClockId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 5, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethBusClockId.setStatus('mandatory')
if mibBuilder.loadTexts: ethBusClockId.setDescription('ID of the clock in the ethBusClockTable.')
ethBusClockTestResult = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 5, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 255))).clone(namedValues=NamedValues(("ok", 1), ("clockFailure", 2), ("busFailure", 3), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethBusClockTestResult.setStatus('mandatory')
if mibBuilder.loadTexts: ethBusClockTestResult.setDescription('Values clockFailure(2) and busFailure(3) define the faulty status for clock tests. The test is performed by LCL100 module.')
feth = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 12, 6))
fethPort = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 12, 6, 1))
fethPortTable = MibTable((1, 3, 6, 1, 4, 1, 81, 12, 6, 1, 1), )
if mibBuilder.loadTexts: fethPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: fethPortTable.setDescription('Table of descriptive, status, performance and error information about the ports.')
fethPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 12, 6, 1, 1, 1), ).setIndexNames((0, "MODULES-MIB", "fethPortGroupId"), (0, "MODULES-MIB", "fethPortId"))
if mibBuilder.loadTexts: fethPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fethPortEntry.setDescription('An entry in the table, containing information, performance and error statistics about a single port.')
fethPortGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 6, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fethPortGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: fethPortGroupId.setDescription('Id of the group to which the port belongs.')
fethPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 6, 1, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fethPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fethPortId.setDescription('Unique Id of the port in the ethPortTable.')
fethPortFunctionalStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 6, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 8, 10, 12, 255))).clone(namedValues=NamedValues(("ok", 1), ("rld", 2), ("rxJabber", 3), ("partition", 8), ("remoteFault", 10), ("wrongSpeed", 12), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fethPortFunctionalStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fethPortFunctionalStatus.setDescription('The value of this attribute reflects the functional status of LANNET 100BaseTX port. Here is the set possible states: ok(1)- fully functional port, transmitting and receiving packets. rld(2) - receive link down (Link Test Failure) condition on the port - indicates a broken connection (cable, connector) detected by the port. rxJabber(3) - fault condition indicating that the port received long packet (jabber) from the line. partition(8) - the port is in partition state. remoteFault(10) - fault condition sensed by the remote port. wrong speed(12) - 10Mbit transmission sensed by the port.')
fethPortFIFO = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 6, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fethPortFIFO.setStatus('mandatory')
if mibBuilder.loadTexts: fethPortFIFO.setDescription('Value ON of this attribute describes an internal FIFO error sensed by the internal hardware mechanism of a the port.')
fethPortOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 6, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("operational", 1), ("notOperational", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fethPortOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fethPortOperStatus.setDescription("This object indicates the port's operational status. The operational(1) status indicates that the port is enabled and working, even though it might be auto-partitioned.")
fethPortAutoPartitionState = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 6, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("autoPartition", 1), ("notAutoPartition", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fethPortAutoPartitionState.setStatus('mandatory')
if mibBuilder.loadTexts: fethPortAutoPartitionState.setDescription('The AutoPart condition indicates that the port is currently partitioned by the auto-partition protection mechanism.')
fethPortFramesReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 6, 1, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fethPortFramesReceived.setStatus('mandatory')
if mibBuilder.loadTexts: fethPortFramesReceived.setDescription('A representation of the total number of frames received by the port from the line. The number includes all frames received even those with RxError or alignment errors or those that had been corrupred in transmission.')
fethPortFramesTransmitted = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 6, 1, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fethPortFramesTransmitted.setStatus('mandatory')
if mibBuilder.loadTexts: fethPortFramesTransmitted.setDescription('A representation of the total number of frames transmitted by the port to the line. The number includes all frames transmitted.')
fethPortTotalErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 6, 1, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fethPortTotalErrors.setStatus('mandatory')
if mibBuilder.loadTexts: fethPortTotalErrors.setDescription('The total number of errors which have occurred on this port. This counter is the summation of the values of other error counters (for the same port), namely: fethPortFCSErrors, fethPortAlignmentErrors, fethPortFrameTooLongs, fethPortShortEvents, fethPortLateEvents, fethPortVeryLongEvents, fethPortDataRateMismatches, For LFE-100 only : fethPortAlignmentErrors, fethPortRxErrors. This counter is redundant in the sense that it is the summation of information already available through other objects. However, it is included specifically because the regular retrieval of this object as a means of tracking the health of a port provides a considerable optimization of network management traffic over the otherwise necessary retrieval of the summed counters. REFERENCE Reference IETF 100Base-T Repeater MIB, rptr100MonitorPortTotalErrors.')
fethPortFramesTransmittedOK = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 6, 1, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fethPortFramesTransmittedOK.setStatus('mandatory')
if mibBuilder.loadTexts: fethPortFramesTransmittedOK.setDescription('A representation of the total number of frames of legal length that have not been corrupted in transmission that transmitted by the port to the line. These frames can be encoded and decoded by the commonly available MACs. Not supported by LFE1008.')
fethPortCollisionFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 6, 1, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fethPortCollisionFrames.setStatus('mandatory')
if mibBuilder.loadTexts: fethPortCollisionFrames.setDescription('This counter is incremented by one for any CarrierEvent signal on any port for which the CollisionEvent signal on this port is also asserted.')
fethPortAlignmentErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 6, 1, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fethPortAlignmentErrors.setStatus('mandatory')
if mibBuilder.loadTexts: fethPortAlignmentErrors.setDescription('This counter is incremented by one for each frame received on this port with the FCSError and FramingError signals asserted and CollisionEvent signal deasserted and whose OctetCount is greater than or equal to minFrameSize and less than or equal to maxFrameSize.')
fethPortRxErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 6, 1, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fethPortRxErrors.setStatus('mandatory')
if mibBuilder.loadTexts: fethPortRxErrors.setDescription('The total number of received frames with error code violation or dose not terminate correctlly.')
fethPortReadableFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 6, 1, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fethPortReadableFrames.setStatus('mandatory')
if mibBuilder.loadTexts: fethPortReadableFrames.setDescription('This object is the number of frames of valid frame length that have been received on this port. This counter is incremented by one for each frame received on this port whose OctetCount is greater than or equal to minFrameSize and less than or equal to maxFrameSize (Ref: IEEE 802.3 Std, 4.4.2.1) and for which the FCSError and CollisionEvent signals are not asserted. This statistic provides one of the parameters necessary for obtaining the packet error rate. REFERENCE Reference IEEE Draft Std 802.3u/D4 Rptr Mgt, 30.4.3.1.4, aReadableFrames. Reference IETF 100Base-T Repeater MIB, rptr100MonitorPortReadableFrames.')
fethPortUpper32ReadableOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 6, 1, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fethPortUpper32ReadableOctets.setStatus('mandatory')
if mibBuilder.loadTexts: fethPortUpper32ReadableOctets.setDescription('This object is the number of octets contained in valid frames that have been received on this port. This counter is incremented by OctetCount for each frame received on this port which has been determined to be a readable frame (i.e., including FCS octets but excluding framing bits and dribble bits). This statistic provides an indicator of the total data transferred. Note that this counter and fethPortLower32ReadableOctets forms a 64 bits counter. It is provided for those network management protocols that do not support 64 bit counters (e.g. SNMP V1) and the repeater type is 100Mbs. REFERENCE Reference IETF 100Base-T Repeater MIB, rptr100MonitorPortUpper32ReadableOctets.')
fethPortLower32ReadableOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 6, 1, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fethPortLower32ReadableOctets.setStatus('mandatory')
if mibBuilder.loadTexts: fethPortLower32ReadableOctets.setDescription('This object is the number of octets contained in valid frames that have been received on this port. This counter is incremented by OctetCount for each frame received on this port which has been determined to be a readable frame (i.e., including FCS octets but excluding framing bits and dribble bits). This statistic provides an indicator of the total data transferred. Note that this counter and fethPortUpper32ReadableOctets forms a 64 bits counter. It is provided for those network management protocols that do not support 64 bit counters (e.g. SNMP V1) and the repeater type is 100Mbs. REFERENCE Reference IEEE Draft Std 802.3u/D4 Rptr Mgt, 30.4.3.1.5, aReadableOctets. Reference IETF 100Base-T Repeater MIB, rptr100MonitorPortLower32ReadableOctets.')
fethPortFCSErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 6, 1, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fethPortFCSErrors.setStatus('mandatory')
if mibBuilder.loadTexts: fethPortFCSErrors.setDescription('This counter is incremented by one for each frame received on this port with the FCSError signal asserted and the FramingError and CollisionEvent signals deasserted and whose OctetCount is greater than or equal to minFrameSize and less than or equal to maxFrameSize (Ref: 4.4.2.1, IEEE 802.3 Std). REFERENCE Reference IEEE Draft Std 802.3u/D4 Rptr Mgt, 30.4.3.1.6, aFrameCheckSequenceErrors. Reference IETF 100Base-T Repeater MIB, rptr100MonitorPortFCSErrors.')
fethPortFrameTooLongs = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 6, 1, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fethPortFrameTooLongs.setStatus('mandatory')
if mibBuilder.loadTexts: fethPortFrameTooLongs.setDescription('This counter is incremented by one for each frame received on this port whose OctetCount is greater than maxFrameSize (Ref: 4.4.2.1, IEEE 802.3 Std). If fethPortFrameTooLongs is incremented then neither the fethPortAlignmentErrors nor the fethPortFCSErrors counter shall be incremented for the frame. REFERENCE Reference IEEE Draft Std 802.3u/D4 Rptr Mgt, 30.4.3.1.8, aFramesTooLong. Reference IETF 100Base-T Repeater MIB, rptr100MonitorPortFrameTooLongs.')
fethPortShortEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 6, 1, 1, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fethPortShortEvents.setStatus('mandatory')
if mibBuilder.loadTexts: fethPortShortEvents.setDescription('This counter is incremented by one for each CarrierEvent on this port with ActivityDuration less than ShortEventMaxTime. ShortEventMaxTime is 84 bits (21 nibbles). Note: shortEvents may indicate externally generated noise hits which will cause the repeater to transmit Runts to its other ports, or propagate a collision (which may be late) back to the transmitting DTE and damaged frames to the rest of the network. Implementors may wish to consider selecting the ShortEventMaxTime towards the lower end of the allowed tolerance range to accommodate bit losses suffered through physical channel devices not budgeted for within this standard. Note also that clause 27 repeaters do not perform fragment extension as clause 9 repeater does. REFERENCE Reference IEEE Draft Std 802.3u/D4 Rptr Mgt, 30.4.3.1.9, aShortEvents. Reference IETF 100Base-T Repeater MIB, rptr100MonitorPortShortEvents.')
fethPortRunts = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 6, 1, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fethPortRunts.setStatus('mandatory')
if mibBuilder.loadTexts: fethPortRunts.setDescription('This counter is incremented by one for each CarrierEvent on this port that meets one of the following two conditions. Only one test need be made. a) The ActivityDuration is greater than ShortEventMaxTime and less than validPacketMinTime and the CollisionEvent signal is deasserted. b) The OctetCount is less than 64, the ActivityDuration is greater than ShortEventMaxTime and the CollisionEvent signal is deasserted. ValidPacketMinTime is greater than or equal to 552 bit times and less than 565 bit times. ValidPacketMinTime has tolerances included to provide for circuit losses between a conformance test point at the AUI and the measurement point within the state machine. Runts usually indicate collision fragments, a normal network event. In certain situations associated with large diameter networks a percentage of collision fragments may exceed ValidPacketMinTime. REFERENCE Reference IEEE Draft Std 802.3u/D4 Rptr Mgt, 30.4.1.3.10, aRunts. Reference IETF 100Base-T Repeater MIB, rptr100MonitorPortRunts.')
fethPortLateEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 6, 1, 1, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fethPortLateEvents.setStatus('mandatory')
if mibBuilder.loadTexts: fethPortLateEvents.setDescription('This counter is incremented by one on entering the Collision Count Increment state of the partition state diagram (fig 27-8) while the ActivityDuration is greater than the LateEvent- Threshold. Such a CarrierEvent is counted twice, as both collision and a late event. The LateEventThreshold is greater than 480 bit times and less than 565 bit times. LateEventThreshold has tolerances included to permit an implementation to build a single threshold to serve as both the LateEventThreshold and ValidPacketMinTime threshold. REFERENCE Reference IEEE Draft Std 802.3u/D4 Rptr Mgt, 30.4.3.1.12, aLateEvents. Reference IETF 100Base-T Repeater MIB, rptr100MonitorPortLateEvents.')
fethPortVeryLongEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 6, 1, 1, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fethPortVeryLongEvents.setStatus('mandatory')
if mibBuilder.loadTexts: fethPortVeryLongEvents.setDescription('This counter is incremented by one on entry to the Rx Jabber state of the receiver timer state diagram (fig 27-7). Other counters may be incremented as appropriate. REFERENCE Reference IEEE Draft Std 802.3u/D4 Rptr Mgt, 30.4.3.1.13, aVeryLongEvents. Reference IETF 100Base-T Repeater MIB, rptr100MonitorPortVeryLongEvents.')
fethPortDataRateMismatches = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 6, 1, 1, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fethPortDataRateMismatches.setStatus('mandatory')
if mibBuilder.loadTexts: fethPortDataRateMismatches.setDescription("This counter is incremented by one for each frame received on this port that meets all of the following conditions: a) the Collision Count Increment state of the partition state diagram (fig 27-8) has not been entered. b) The ActivityDuration is greater than ValidPacketMinTime. c) The frequency (data rate) is detectably mismatched from the local transmit frequency. The exact degree of mismatch is vendor specific and is to be defined by the vendor for conformance testing. When this event occurs, other counters whose increment conditions were satisfied may or may not also be incremented, at the implementor's discretion. Whether or not the repeater was able to maintain data integrity is beyond the scope of this standard. REFERENCE Reference IEEE Draft Std 802.3u/D4 Rptr Mgt, 30.4.3.1.14, aDataRateMismatches. Reference IETF 100Base-T Repeater MIB, rptr100MonitorPortDataRateMismatches.")
fethPortAutoPartitions = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 6, 1, 1, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fethPortAutoPartitions.setStatus('mandatory')
if mibBuilder.loadTexts: fethPortAutoPartitions.setDescription('This counter is incremented by one on entry to the Partition Wait state of the partition state diagram (fig 27-8). REFERENCE Reference IEEE Draft Std 802.3u/D4 Rptr Mgt, 30.4.3.1.14, aAutoPartitions. Reference IETF 100Base-T Repeater MIB, rptr100MonitorPortAutoPartitions.')
fethPortSymbolErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 6, 1, 1, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fethPortSymbolErrors.setStatus('mandatory')
if mibBuilder.loadTexts: fethPortSymbolErrors.setDescription('This counter is incremented by one each time when valid length packet was received at the port and there was at least one occurrence of an invalid data symbol. This can increment only once per valid carrier event. A collision presence at any port of the repeater containing port N, will not cause this attribute to increment. This Counter has a maximum increment rate of 160,000 counts per second for 100Mb/s implementation. REFERENCE Reference IEEE Draft Std 802.3u/D4 Rptr Mgt, 30.4.3.1.17, aSymbolErrorDuringPacket. Reference IETF 100Base-T Repeater MIB, rptr100MonitorPortSymbolErrors.')
fethPortLastSourceAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 6, 1, 1, 1, 26), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 6))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fethPortLastSourceAddress.setStatus('deprecated')
if mibBuilder.loadTexts: fethPortLastSourceAddress.setDescription('This object is the SourceAddress of the last readable frame (i.e., counted by fethPortReadableFrames) received by this port. If no frames have been received by this port since the agent began monitoring the port activity, the agent shall return a string of length zero. REFERENCE Reference IEEE Draft Std 802.3u/D4 Rptr Mgt, 30.4.3.1.18, aLastSourceAddress. Reference IETF 100Base-T Repeater MIB, rptr100AddrTrackLastSourceAddress.')
fethPortSourceAddrChanges = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 6, 1, 1, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fethPortSourceAddrChanges.setStatus('mandatory')
if mibBuilder.loadTexts: fethPortSourceAddrChanges.setDescription('This counter is incremented by one for each time that the fethPortLastSourceAddress attribute for this port has changed. This may indicate whether a link is connected to a single DTE or another multi-user segment. The approximate minimum time for rollover of this counter is 8 hours. REFERENCE Reference IEEE Draft Std 802.3u/D4 Rptr Mgt, 30.4.3.1.19, aSourceAddressChanges. Reference IETF 100Base-T Repeater MIB, rptr100AddrTrackSourceAddrChanges.')
fethPortMode = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 6, 1, 1, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 255))).clone(namedValues=NamedValues(("halfDuplex", 1), ("fullDuplex", 2), ("fullDuplexAndFlowControl", 3), ("fullDuplexAndISL", 4), ("fullDuplexAndFlowControlAndISL", 5), ("notSupported", 255))).clone('halfDuplex')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fethPortMode.setStatus('mandatory')
if mibBuilder.loadTexts: fethPortMode.setDescription("The mode of the port. halfDuplex(1)- standard mode, usually for segments. fullDuplex(2)- standard mode, usually for servers. fullDuplexAndFlowControl(3)- the module transmits Flow Control symbols to the line between two HUBs in order to control the flow of data. fullDuplexAndISL(4)- the module transmits to the line a control-word from the HSB, in order to transfer VLANs and Priority to another HUB ( ISL=Inter Switch Link). fullDuplexAndFlowControlAndISL(5)- FDX with both Flow Control and ISL modes. It is the user's responsibility to set both modules connected to the line, to the same mode.")
fethPortLinkRedundancyMode = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 6, 1, 1, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("notSupported", 255))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fethPortLinkRedundancyMode.setStatus('mandatory')
if mibBuilder.loadTexts: fethPortLinkRedundancyMode.setDescription('This item is relevant for modules which include redundant links. This item enables/disables the Redundancy mechanism. When enabled, the Sensor will alternately switch between the main and secondary ports/links, upon a predefined failure indication. See also the fethPortEnablePHY item.')
fethPortLinkRedundancyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 6, 1, 1, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("firstLinkActive", 1), ("secondLinkActive", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fethPortLinkRedundancyStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fethPortLinkRedundancyStatus.setDescription('This item is relevant for ports which includes redundant links. This item indicates which of the links is active. Default value=firstLinkActive(1). ')
fethPortDormantLinkFunctionalStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 6, 1, 1, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 10, 255))).clone(namedValues=NamedValues(("ok", 1), ("rld", 2), ("remoteFault", 10), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fethPortDormantLinkFunctionalStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fethPortDormantLinkFunctionalStatus.setDescription('The value of this attribute reflects the functionality status of the dormant link, in modules such as LEB-200, which have link redundancy capability. Note that the Main Link functionality status is still reflected by the fethPortFunctionalStatus item as usual.. Default value=ok(1). ')
fethPortUpper32TransmittedOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 6, 1, 1, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fethPortUpper32TransmittedOctets.setStatus('mandatory')
if mibBuilder.loadTexts: fethPortUpper32TransmittedOctets.setDescription('This object is the number of octets contained in valid frames that have been transmitted on this port. This counter is incremented by OctetCount for each frame transmitted on this port which has not been encountered with a collision event. This statistic provides an indicator of the total data transferred. Note that this counter and fethPortLower32TransmittedOctets forms a 64 bits counter. It is provided for those network management protocols that do not support 64 bit counters (e.g. SNMP V1) and the repeater type is 100Mbs.')
fethPortLower32TransmittedOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 6, 1, 1, 1, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fethPortLower32TransmittedOctets.setStatus('mandatory')
if mibBuilder.loadTexts: fethPortLower32TransmittedOctets.setDescription('This object is the number of octets contained in valid frames that have been transmitted on this port.This counter is incremented by OctetCount for each frame transmitted on this port which has not been encountered with a collision event. This statistic provides an indicator of the total data transferred. Note that this counter and fethPortUpper32TransmittedOctets forms a 64 bits counter. It is provided for those network management protocols that do not support 64 bit counters (e.g. SNMP V1) and the repeater type is 100Mbs.')
fethPortBroadcastReceivedFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 6, 1, 1, 1, 34), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fethPortBroadcastReceivedFrames.setStatus('mandatory')
if mibBuilder.loadTexts: fethPortBroadcastReceivedFrames.setDescription('This object is the number of Broadcast readable frames that have been Received on this port.')
fethPortMulticastReceivedFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 6, 1, 1, 1, 35), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fethPortMulticastReceivedFrames.setStatus('mandatory')
if mibBuilder.loadTexts: fethPortMulticastReceivedFrames.setDescription('This object is the number of Multicast readable (good) frames that have been Received on this port.')
fethPortEnablePHY = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 6, 1, 1, 1, 36), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("enPHY1", 1), ("enPHY2", 2), ("notSupported", 255))).clone('enPHY1')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fethPortEnablePHY.setStatus('mandatory')
if mibBuilder.loadTexts: fethPortEnablePHY.setDescription('This item is relevant for ports which include redundant links (such as LEB200). This item is not valid and has no effect when the fethPortLinkRedundancyMode=enable(1). This item determines and indicates the active PHY in case that fethPortLinkRedundancyMode is set to disable(2).')
fethGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 12, 6, 2))
fethGroupTable = MibTable((1, 3, 6, 1, 4, 1, 81, 12, 6, 2, 1), )
if mibBuilder.loadTexts: fethGroupTable.setStatus('mandatory')
if mibBuilder.loadTexts: fethGroupTable.setDescription('Table of descriptive, status, performance and error information about the groups of fast ethernet ports.')
fethGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 12, 6, 2, 1, 1), ).setIndexNames((0, "MODULES-MIB", "fethGroupId"))
if mibBuilder.loadTexts: fethGroupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fethGroupEntry.setDescription("An entry in the table, containing information, total performance and error statistics for a single group of ports. Regular retrieval of the information in this table provides a means of tracking the performance and health of the networked devices attached to this group's ports. The counters in this table are redundant in the sense that they are the summations of information already available through other objects. However, these sums provide a considerable optimization of network management traffic over the otherwise necessary retrieval of the individual counters included in each sum.")
fethGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 6, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fethGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: fethGroupId.setDescription('This object identifies the group within the repeater for which this entry contains information. This value is never greater than fethRepeaterGroupCapacity. REFERENCE Reference IEEE Draft Std 802.3u/D4 Rptr Mgt, 30.4.2.1.1, aGroupID. Reference IETF 100Base-T Repeater MIB, rptr100GroupIndex.')
fethGroupOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 6, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("operational", 2), ("malfunctioning", 3), ("notPresent", 4), ("underTest", 5), ("resetInProgress", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fethGroupOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fethGroupOperStatus.setDescription('An object that indicates the operational status of the group. A status of notPresent(4) indicates that the group is temporarily or permanently physically and/or logically not a part of the repeater (Stand Alone). A status of operational(2) indicates that the group is functioning, and a status of malfunctioning(3) indicates that the group is malfunctioning in some way (see fethRepeaterOperStatus). REFERENCE Reference IETF 100Base-T Repeater MIB, rptr100GroupOperStatus.')
fethGroupUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 6, 2, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fethGroupUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: fethGroupUtilization.setDescription('Utilization of the network, expressed in percentage of the maximum traffic possible ( 100Mbps)')
fethGroupTotalFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 6, 2, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fethGroupTotalFrames.setStatus('mandatory')
if mibBuilder.loadTexts: fethGroupTotalFrames.setDescription('The total number of frames of valid frame length that have been received on the ports in this group and for which the FCSError and CollisionEvent signals were not asserted. This counter is the summation of the values of the fethPortReadableFrames counters for all of the ports in the group. This statistic provides one of the parameters necessary for obtaining the packet error rate. REFERENCE Reference IETF 100Base-T Repeater MIB, rptr100MonitorGroupTotalFrames.')
fethGroupUpper32TotalOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 6, 2, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fethGroupUpper32TotalOctets.setStatus('mandatory')
if mibBuilder.loadTexts: fethGroupUpper32TotalOctets.setDescription('The total number of octets contained in the valid frames that have been received on the ports in this group. This counter is the summation of the values of the fethPortReadableOctets counters for all of the ports in the group. This statistic provides an indicator of the total data transferred. Note that this counter and fethGroupLower32TotalOctets forms a 64 bits counter. It is provided for those network management protocols that do not support 64 bit counters (e.g. SNMP V1) and the repeater type is 100Mbs. REFERENCE Reference IETF 100Base-T Repeater MIB, rptr100MonitorGroupUpper32TotalOctets.')
fethGroupLower32TotalOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 6, 2, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fethGroupLower32TotalOctets.setStatus('mandatory')
if mibBuilder.loadTexts: fethGroupLower32TotalOctets.setDescription('The total number of octets contained in the valid frames that have been received on the ports in this group. This counter is the summation of the values of the fethPortReadableOctets counters for all of the ports in the group. This statistic provides an indicator of the total data transferred. Note that this counter and fethGroupUpper32TotalOctets forms a 64 bits counter. It is provided for those network management protocols that do not support 64 bit counters (e.g. SNMP V1) and the repeater type is 100Mbs. REFERENCE Reference IETF 100Base-T Repeater MIB, rptr100MonitorGroupLower32TotalOctets.')
fethGroupTotalErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 6, 2, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fethGroupTotalErrors.setStatus('mandatory')
if mibBuilder.loadTexts: fethGroupTotalErrors.setDescription('The total number of errors which have occurred on all of the ports in this group. This counter is the summation of the values of the fethPortTotalErrors counters for all of the ports in the group. REFERENCE Reference IETF 100Base-T Repeater MIB, rptr100MonitorGroupTotalErrors.')
fethGroupFefiEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 6, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fethGroupFefiEnable.setStatus('mandatory')
if mibBuilder.loadTexts: fethGroupFefiEnable.setDescription('This item enables\\disables the FEFI mechanism of the PHY on the module. It enables\\disables both the transmission and the recognition of FEFI signals . This item is used only in modules that support 100BaseFx.')
tokRing = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 13, 1))
tokRingTable = MibTable((1, 3, 6, 1, 4, 1, 81, 13, 1, 1), )
if mibBuilder.loadTexts: tokRingTable.setStatus('mandatory')
tokRingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 13, 1, 1, 1), ).setIndexNames((0, "MODULES-MIB", "tokRingAgId"), (0, "MODULES-MIB", "tokRingId"))
if mibBuilder.loadTexts: tokRingEntry.setStatus('mandatory')
tokRingAgId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokRingAgId.setStatus('mandatory')
if mibBuilder.loadTexts: tokRingAgId.setDescription('ID of the agent to which the ring belongs in the tokRingTable.')
tokRingId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokRingId.setStatus('mandatory')
if mibBuilder.loadTexts: tokRingId.setDescription('ID of the ring in the tokRingTable.')
tokRingLeftSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokRingLeftSlot.setStatus('mandatory')
if mibBuilder.loadTexts: tokRingLeftSlot.setDescription("Slot number of the left-most slot of the ring. In the token ring stackable hub, 'Left' should be read as 'Up'. ")
tokRingRightSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tokRingRightSlot.setStatus('mandatory')
if mibBuilder.loadTexts: tokRingRightSlot.setDescription("Slot number of the right-most slot of the ring that has a lobe port. In the token ring stackable hub, 'Right' should be read as 'Down'. ")
tokRingTrafficBuffer = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 1, 1, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokRingTrafficBuffer.setStatus('deprecated')
if mibBuilder.loadTexts: tokRingTrafficBuffer.setDescription('Record of traffic for the last second with a resolution of 100 msec. The traffic is expressed in percents of the maximum effective TR traffic (token messages are excluded) and each record contains 10 readings, in range 1..20 on log(10) scale.')
tokRingTrafficThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 1, 1, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tokRingTrafficThresh.setStatus('mandatory')
if mibBuilder.loadTexts: tokRingTrafficThresh.setDescription('Traffic threshold value. When exceeded, a trap is send to the management console. Expressed in percents of the maximum effective TR traffic (token messages are excluded) in the range 1..20 on log(10) scale.')
tokRingPeakTraffic = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 1, 1, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tokRingPeakTraffic.setStatus('mandatory')
if mibBuilder.loadTexts: tokRingPeakTraffic.setDescription('Maximal traffic value since last reset of agent. Expressed in percents of the maximum effective TR traffic (token messages are excluded), in the range 1..20 on log(10) scale. The write access is reserved for resetting the value of the peak.')
tokRingNumberOfStations = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 1, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokRingNumberOfStations.setStatus('mandatory')
if mibBuilder.loadTexts: tokRingNumberOfStations.setDescription('Number of Token Ring stations (controllers) detected on the ring. The TR controller of the agent card is included in this count.')
tokRingConfiguration = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 1, 1, 1, 9), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokRingConfiguration.setStatus('mandatory')
if mibBuilder.loadTexts: tokRingConfiguration.setDescription('Configuration attribute describing the list of physical addresses detected on the Token Ring. Coded in internal application format. ')
tokRingBeaconing = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokRingBeaconing.setStatus('mandatory')
if mibBuilder.loadTexts: tokRingBeaconing.setDescription('This attribute indicates if a beaconing condition is currently detected on the ring.')
tokRingBeaconingStation = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 1, 1, 1, 11), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokRingBeaconingStation.setStatus('mandatory')
if mibBuilder.loadTexts: tokRingBeaconingStation.setDescription('The MAC address of the last station which was detected as sending Beaconing MAC frames on the ring.')
tokRingStationsMatch = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 1, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("partial", 3), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokRingStationsMatch.setStatus('mandatory')
if mibBuilder.loadTexts: tokRingStationsMatch.setDescription('This attribute indicates matching between the number of stations detected on the ring between the current agent and the next agent on Up Stream sense and the number of connected lobe ports.Used by the port address correlation mechanism.')
tokRingTraffic = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 1, 1, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokRingTraffic.setStatus('mandatory')
if mibBuilder.loadTexts: tokRingTraffic.setDescription('Last traffic reading (sampling time = 100 msec). The traffic is expressed in percents of the maximum Ethernet traffic in the range 1..20, expressed on a log(10) scale ( value = 10*log10(percent) ).')
tokRingSecurityMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 1, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 255))).clone(namedValues=NamedValues(("perPort", 1), ("perRing", 2), ("disabled", 3), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tokRingSecurityMethod.setStatus('mandatory')
if mibBuilder.loadTexts: tokRingSecurityMethod.setDescription('Security scheme selected by the user. perPort(1) indicates that secure addresses are defined for each secured token ring port. perRing(2) indicates that a common set of secure addresses will be allowed for the whole ring. disabled(3) - no security method is applied on this ring.')
tokRingSecurityPolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 1, 1, 1, 15), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tokRingSecurityPolicy.setStatus('mandatory')
if mibBuilder.loadTexts: tokRingSecurityPolicy.setDescription('Security policy (trap only or trap and disconnect) selected for the ring. Coded in internal format.')
tokRingSecureAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 1, 1, 1, 16), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tokRingSecureAddr.setStatus('mandatory')
if mibBuilder.loadTexts: tokRingSecureAddr.setDescription('Secure addresses assigned to the ring. Coded in internal format.')
tokRingLastViolation = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 1, 1, 1, 17), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokRingLastViolation.setStatus('mandatory')
if mibBuilder.loadTexts: tokRingLastViolation.setDescription('MAC address of a last detected intruder.')
tokRingUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 1, 1, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokRingUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: tokRingUtilization.setDescription('Last traffic reading (sampling time = 100 msec). The traffic is expressed in percents of the maximum Token Ring traffic.')
tokRingPeakUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 1, 1, 1, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokRingPeakUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: tokRingPeakUtilization.setDescription('Maximal traffic value since last reset of agent. Expressed in percents of the maximum effective TR traffic (token messages are excluded).')
tokRingBeaconingResolution = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 1, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("notSupported", 255))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tokRingBeaconingResolution.setStatus('mandatory')
if mibBuilder.loadTexts: tokRingBeaconingResolution.setDescription('This parameter enables or disables the beaconing resolution.')
tokRingThresholdStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 1, 1, 1, 21), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokRingThresholdStatus.setStatus('mandatory')
if mibBuilder.loadTexts: tokRingThresholdStatus.setDescription("This item is a bitmap that defines the threshold status of the ring, in relation to the alarmPolicyTable. If the ring is monitored by the agent according to policy number x in the alarmPolicyTable, and the threshold condition has occured, then the bit #x in this item will have the value '1'. Otherwise it will be '0'. For x-186 based agents all bits of this item are '0'.")
tokRingActiveMonitor = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 1, 1, 1, 22), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokRingActiveMonitor.setStatus('mandatory')
if mibBuilder.loadTexts: tokRingActiveMonitor.setDescription(' The MAC Address of the station functioning as Active Monitor.')
tokGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 13, 2))
tokGroupTable = MibTable((1, 3, 6, 1, 4, 1, 81, 13, 2, 1), )
if mibBuilder.loadTexts: tokGroupTable.setStatus('mandatory')
tokGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 13, 2, 1, 1), ).setIndexNames((0, "MODULES-MIB", "tokGroupId"))
if mibBuilder.loadTexts: tokGroupEntry.setStatus('mandatory')
tokGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: tokGroupId.setDescription('Number of the slot in which the group is installed.')
tokGroupAutoRightLoop = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokGroupAutoRightLoop.setStatus('mandatory')
if mibBuilder.loadTexts: tokGroupAutoRightLoop.setDescription("Value ON of this attribute signifies that a hardware loop was automatically created on a Token Ring module which does not sense the existence of another token ring group on the right hand side. In the token ring stackable hub, 'Right' should be read as 'Down'. ")
tokGroupAutoLeftLoop = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokGroupAutoLeftLoop.setStatus('mandatory')
if mibBuilder.loadTexts: tokGroupAutoLeftLoop.setDescription("Value ON of this attribute signifies that a hardware loop was automatically created on a Token Ring module which does not sense the existence of another token ring group on the left hand side. In the token ring stackable hub, 'Left' should be read as 'Up'. ")
tokGroupManRightLoop = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tokGroupManRightLoop.setStatus('mandatory')
if mibBuilder.loadTexts: tokGroupManRightLoop.setDescription("Setting this attribute to ON signifies a command to the hardware to create a loop on the Token Ring module which isolates the ring from the right hand side. In the token ring stackable hub, 'Right' should be read as 'Down'. ")
tokGroupManLeftLoop = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tokGroupManLeftLoop.setStatus('mandatory')
if mibBuilder.loadTexts: tokGroupManLeftLoop.setDescription("Setting this attribute to ON signifies a command to the hardware to create a loop on the Token Ring module which isolates the ring from the left hand side. In the token ring stackable hub, 'Left' should be read as 'Up'. ")
tokGroupRightNeighbor = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("exist", 1), ("notExist", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokGroupRightNeighbor.setStatus('mandatory')
if mibBuilder.loadTexts: tokGroupRightNeighbor.setDescription("Attribute defining the existence of a neighbor another token ring group on the right hand side of the module. In the token ring stackable hub, 'Right' should be read as 'Down'. ")
tokGroupLeftNeighbor = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("exist", 1), ("notExist", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokGroupLeftNeighbor.setStatus('mandatory')
if mibBuilder.loadTexts: tokGroupLeftNeighbor.setDescription("Attribute defining the existence of a neighbor another token ring group on the left hand side of the module. In the token ring stackable hub, 'Left' should be read as 'Up'. ")
tokGroupIOMode = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 12, 255))).clone(namedValues=NamedValues(("single", 1), ("dualRingIn", 2), ("dualRingOut", 3), ("illegalMode", 4), ("lobe", 5), ("intRepeater", 6), ("star", 7), ("starAndRingOut", 8), ("starAndRI", 10), ("starAndSingle", 11), ("starAndIntRepeater", 12), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tokGroupIOMode.setStatus('mandatory')
if mibBuilder.loadTexts: tokGroupIOMode.setDescription('Attribute defining the I/O mode (single, dual-ring-in, dual-ring-out) Lobe, Internal Repeater or Star) of a module from the the LTR-IO family.')
tokGroupBridgeMode = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 2, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 255))).clone(namedValues=NamedValues(("modeA", 1), ("modeB", 2), ("modeC", 3), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tokGroupBridgeMode.setStatus('mandatory')
if mibBuilder.loadTexts: tokGroupBridgeMode.setDescription('Attribute describing the operational mode of the bridge. For ITLB the following modes are defined: - Mode A: First channel connected to an external ring (RI,RO connectors) and second channel connected to an internal ring; - Mode B: First channel connected to an external ring by a DTE connector and second channel connected to an internal ring; - Mode C: First channel connected to an internal left ring and second channel connected to an internal right ring.')
tokGroupManLinkLoop = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tokGroupManLinkLoop.setStatus('mandatory')
if mibBuilder.loadTexts: tokGroupManLinkLoop.setDescription('Setting the value of this attribute to ON instructs the hardware of a Token Ring repeater module to close the loop in the direction of the external connection.')
tokGroupManBusLoop = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 2, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tokGroupManBusLoop.setStatus('mandatory')
if mibBuilder.loadTexts: tokGroupManBusLoop.setDescription('Setting the value of this attribute to ON instructs the hardware of a Token Ring repeater module to close the loop in the direction of the internal bus.')
tokGroupAutoLinkLoop = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 2, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokGroupAutoLinkLoop.setStatus('mandatory')
if mibBuilder.loadTexts: tokGroupAutoLinkLoop.setDescription('Value ON of this attribute signifies that a hardware loop has been auto- matically closed by the hardwar of the Token Ring repeater as a result of problems on the external link.')
tokGroupAutoBusLoop = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 2, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokGroupAutoBusLoop.setStatus('mandatory')
if mibBuilder.loadTexts: tokGroupAutoBusLoop.setDescription('Value ON of this attribute signifies that a hardware loop has been auto- matically closed by the hardware of the Token Ring repeater as a result of problems on the internal bus.')
tokGroupSpecificOID = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 2, 1, 1, 14), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokGroupSpecificOID.setStatus('mandatory')
if mibBuilder.loadTexts: tokGroupSpecificOID.setDescription('This attribute provides the OID of another group containing additional more specific information regarding this instance.')
tokGroupStarSpeedDetect = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 2, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tokGroupStarSpeedDetect.setStatus('mandatory')
if mibBuilder.loadTexts: tokGroupStarSpeedDetect.setDescription('This attribute enables the speed detection mechanism for the ports which are in star mode')
tokGroupLobeSpeedDetect = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 2, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tokGroupLobeSpeedDetect.setStatus('mandatory')
if mibBuilder.loadTexts: tokGroupLobeSpeedDetect.setDescription('This attribute enables the speed detection mechanism for all ports which are in Lobe mode, at module level.')
tokGroupLSTBeaconing = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 2, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokGroupLSTBeaconing.setStatus('mandatory')
if mibBuilder.loadTexts: tokGroupLSTBeaconing.setDescription("This item is for LST168 only. The ring is in beaconning state. Value 'on' informs on beacon fault when the number of consecutive beacon frames is above BeaconThreshold.")
tokGroupLSTBeaconThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 2, 1, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tokGroupLSTBeaconThresh.setStatus('mandatory')
if mibBuilder.loadTexts: tokGroupLSTBeaconThresh.setDescription('This item is for LST168 only.Threshold for the number of consecutive beacon frames in the ring, above which a beaconning fault is alerted.')
tokGroupRingTable = MibTable((1, 3, 6, 1, 4, 1, 81, 13, 2, 2), )
if mibBuilder.loadTexts: tokGroupRingTable.setStatus('mandatory')
tokGroupRingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 13, 2, 2, 1), ).setIndexNames((0, "MODULES-MIB", "tokGroupRingGroupId"), (0, "MODULES-MIB", "tokGroupRingId"))
if mibBuilder.loadTexts: tokGroupRingEntry.setStatus('mandatory')
tokGroupRingGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokGroupRingGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: tokGroupRingGroupId.setDescription('ID of the group to which the ring belongs.')
tokGroupRingId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokGroupRingId.setStatus('mandatory')
if mibBuilder.loadTexts: tokGroupRingId.setDescription('ID of the ring.')
tokGroupRingSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unknown", 1), ("oneMegabit", 2), ("fourMegabit", 3), ("sixteenMegabit", 4), ("sixteenMgbEarly", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tokGroupRingSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: tokGroupRingSpeed.setDescription('Attribute describing the bandwidth of the ring.')
tokGroupRingInserted = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("notInserted", 1), ("inserted", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokGroupRingInserted.setStatus('mandatory')
if mibBuilder.loadTexts: tokGroupRingInserted.setDescription('Indicates that the bridge interface has inserted itself into the ring.')
tokGroupRingStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 2, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tokGroupRingStatus.setStatus('mandatory')
if mibBuilder.loadTexts: tokGroupRingStatus.setDescription('This item sets the connection of a TR controller to one of its possible connections, identified by the index of this row, for modules with a multiple interface controller (for example ITRP).')
tokPort = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 13, 3))
tokPortTable = MibTable((1, 3, 6, 1, 4, 1, 81, 13, 3, 1), )
if mibBuilder.loadTexts: tokPortTable.setStatus('mandatory')
tokPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 13, 3, 1, 1), ).setIndexNames((0, "MODULES-MIB", "tokPortGroupId"), (0, "MODULES-MIB", "tokPortId"))
if mibBuilder.loadTexts: tokPortEntry.setStatus('mandatory')
tokPortGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokPortGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: tokPortGroupId.setDescription('ID of the group to which the token ring port belongs.')
tokPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokPortId.setStatus('mandatory')
if mibBuilder.loadTexts: tokPortId.setDescription('ID of the port in the tokPortTable.')
tokPortBypass = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tokPortBypass.setStatus('mandatory')
if mibBuilder.loadTexts: tokPortBypass.setDescription('Setting the value of this attribute to ON causes the by- passing of the TokenRing port.')
tokPortConnected = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("connected", 1), ("notConnected", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokPortConnected.setStatus('mandatory')
if mibBuilder.loadTexts: tokPortConnected.setDescription('Attribute which describes the connection status of a Token Ring port (inclusion of the Token Ring controller in the ring).')
tokPortTCP = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tokPortTCP.setStatus('mandatory')
if mibBuilder.loadTexts: tokPortTCP.setDescription('Setting the value of this attribute to ON causes the activation of the cable-fault detection mechanism.')
tokPortCableFault = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokPortCableFault.setStatus('mandatory')
if mibBuilder.loadTexts: tokPortCableFault.setDescription('Value ON of this attribute signifies the detection of a cable-fault on this specific Token Ring port.')
tokPortFunctionalStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 255))).clone(namedValues=NamedValues(("ok", 1), ("rld", 2), ("tld", 4), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokPortFunctionalStatus.setStatus('mandatory')
if mibBuilder.loadTexts: tokPortFunctionalStatus.setDescription('The value of this attribute reflects the functional status of Token Ring ports. Note that it is not mandatory that a certain port support all the enumerated states. Here is the lest of the possible states: ok(1) - fully functional port, transmitting and receiving packets. rld(2) - receive link down condition on the port. tld(4) - transmit link down condition on the port.')
tokPortLastSourceAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 3, 1, 1, 8), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokPortLastSourceAddr.setStatus('mandatory')
if mibBuilder.loadTexts: tokPortLastSourceAddr.setDescription('MAC source address of the last readable frame received by this port.')
tokPortSpecificOID = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 3, 1, 1, 9), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokPortSpecificOID.setStatus('mandatory')
if mibBuilder.loadTexts: tokPortSpecificOID.setDescription('This attribute provides the OID of another group containing additional more specific information regarding this instance.')
tokPortRingSpeedError = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokPortRingSpeedError.setStatus('mandatory')
if mibBuilder.loadTexts: tokPortRingSpeedError.setDescription(" This attribute is set to 'on' when the station tries to enter the ring with a speed different from the speed of the ring.")
tokPortSpeedDetect = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 3, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tokPortSpeedDetect.setStatus('mandatory')
if mibBuilder.loadTexts: tokPortSpeedDetect.setDescription('This attribute enables the speed detection mechanism on a port level.')
tokPortRingId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 3, 1, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokPortRingId.setStatus('mandatory')
if mibBuilder.loadTexts: tokPortRingId.setDescription('Unique identifier of the ring/ring segment to which a specific port is connected.')
tokPortMapping = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 3, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tokPortMapping.setStatus('mandatory')
if mibBuilder.loadTexts: tokPortMapping.setDescription('This attribute enables/disables participation of the selected port in port-to-address correlation algorithm. Default value is on(1).')
tokRingStation = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 13, 4))
tokRingStationTable = MibTable((1, 3, 6, 1, 4, 1, 81, 13, 4, 1), )
if mibBuilder.loadTexts: tokRingStationTable.setStatus('mandatory')
tokRingStationEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 13, 4, 1, 1), ).setIndexNames((0, "MODULES-MIB", "tokRingId"), (0, "MODULES-MIB", "tokRingStationMAC"))
if mibBuilder.loadTexts: tokRingStationEntry.setStatus('mandatory')
tokRingStationRingId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokRingStationRingId.setStatus('mandatory')
if mibBuilder.loadTexts: tokRingStationRingId.setDescription('ID of the ring in the in which the station is inserted.')
tokRingStationMAC = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 4, 1, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokRingStationMAC.setStatus('mandatory')
if mibBuilder.loadTexts: tokRingStationMAC.setDescription('This item defines the MAC address (in token ring format) of the station connected to the ring.')
tokRingStationLineErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 4, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokRingStationLineErrors.setStatus('mandatory')
if mibBuilder.loadTexts: tokRingStationLineErrors.setDescription('This counter is incremented when a frame or token is copied or repeated by a station, the E bit is zero in the frame or token and one of the following conditions exists: 1) there is a non-data bit (J or K bit) between the SD and the ED of the frame or token, or 2) there is an FCS error in the frame.')
tokRingStationInternalErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 4, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokRingStationInternalErrors.setStatus('mandatory')
if mibBuilder.loadTexts: tokRingStationInternalErrors.setDescription("This counter is incremented when a station recognizes an internal error. Internal errors are detected by the adapter's hardware and/or firmware. They usually cause the detecting adapter to remove itself from the ring.")
tokRingStationBurstErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 4, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokRingStationBurstErrors.setStatus('mandatory')
if mibBuilder.loadTexts: tokRingStationBurstErrors.setDescription('This counter is incremented when a station detects the absence of transitions for five half-bit timers (burst-five error).')
tokRingStationACErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 4, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokRingStationACErrors.setStatus('mandatory')
if mibBuilder.loadTexts: tokRingStationACErrors.setDescription('This counter is incremented when a station receives an AMP or SMP frame in which A is equal to C is equal to 0, and then receives another SMP frame with A is equal to C is equal to 0 without first receiving an AMP frame. It denotes a station that cannot set the AC bits properly.')
tokRingStationAbortsTrans = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 4, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokRingStationAbortsTrans.setStatus('mandatory')
if mibBuilder.loadTexts: tokRingStationAbortsTrans.setDescription('This counter is incremented when a station transmits an abort delimiter while transmitting.')
tokRingStationLostFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 4, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokRingStationLostFrames.setStatus('mandatory')
if mibBuilder.loadTexts: tokRingStationLostFrames.setDescription('This counter is incremented when a station is transmitting and its TRR timer expires. This condition denotes a condition where a transmitting station in strip mode does not receive the trailer of the frame before the TRR timer goes off.')
tokRingStationReceiveCongErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 4, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokRingStationReceiveCongErrors.setStatus('mandatory')
if mibBuilder.loadTexts: tokRingStationReceiveCongErrors.setDescription('This counter is incremented when a station recognizes a frame addressed to its specific address, but has no available buffer space indicating that the station is congested.')
tokRingStationFramesCopied = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 4, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokRingStationFramesCopied.setStatus('mandatory')
if mibBuilder.loadTexts: tokRingStationFramesCopied.setDescription('This counter is incremented when a station recognizes a frame addressed to its specific address and detects that the FS field A bits are set to 1 indicating a possible line hit or duplicate address.')
tokRingStationFrequencyErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 4, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokRingStationFrequencyErrors.setStatus('mandatory')
if mibBuilder.loadTexts: tokRingStationFrequencyErrors.setDescription('The number of times the interface has detected that the frequency of the incoming signal differs from the expected frequency by more than that specified by the IEEE 802.5 standard.')
tokRingStationTokenErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 4, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokRingStationTokenErrors.setStatus('mandatory')
if mibBuilder.loadTexts: tokRingStationTokenErrors.setDescription('This counter is incremented when a station acting as the active monitor recognizes an error condition that needs a token transmitted.')
tokRingStationTotalErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 4, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokRingStationTotalErrors.setStatus('mandatory')
if mibBuilder.loadTexts: tokRingStationTotalErrors.setDescription('This counter is the sum of all REM counters for this station, i.e.: LineErrors, InternalErrors, BurstErrors, ACErrors, AbortsTrans, LostFrames, FrameCopiedErrors, ReceiveCongestionsErrors, FrequencyErrors, TokenErrors.')
tokRingStationFunctionalType = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 4, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("ringStation", 1), ("agent", 2), ("bridge", 3), ("netbios", 4), ("ringParameterServer", 5), ("ringErrorMonitor", 6), ("lanManager", 7), ("activeMonitor", 8), ("other", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokRingStationFunctionalType.setStatus('mandatory')
if mibBuilder.loadTexts: tokRingStationFunctionalType.setDescription('The function of the concerned station in the ring.')
tokIntPort = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 13, 5))
tokIntPortTable = MibTable((1, 3, 6, 1, 4, 1, 81, 13, 5, 1), )
if mibBuilder.loadTexts: tokIntPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: tokIntPortTable.setDescription('Table of configuration attributes for items specific to token ring internal ports, which can not be addressed via the genIntPort group.')
tokIntPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 13, 5, 1, 1), ).setIndexNames((0, "MODULES-MIB", "tokIntPortGroupId"), (0, "MODULES-MIB", "tokIntPortId"))
if mibBuilder.loadTexts: tokIntPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: tokIntPortEntry.setDescription('An entry in the table, containing data about a single port.')
tokIntPortGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 5, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokIntPortGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: tokIntPortGroupId.setDescription('Index which identifies the group inside the hub for which this entry contains information. Equals the number of the slot by which the group containing the internal port is accessed. This value is never greater than chNumberOfSlots.')
tokIntPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokIntPortId.setStatus('mandatory')
if mibBuilder.loadTexts: tokIntPortId.setDescription('Index which identifies the internal port inside the group for which this entry contains information. This value is never greater than genGroupNumberOfIntPorts of the group to which the port belongs.')
tokIntPortLeftNeighbor = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 5, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("exist", 1), ("notExist", 2), ("bypass", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokIntPortLeftNeighbor.setStatus('mandatory')
if mibBuilder.loadTexts: tokIntPortLeftNeighbor.setDescription('Attribute defining the existence of another token ring group to the left hand side of the module, on the TR bus to which this intrnal port is connected. The value bypass is reported when the controller is not connected to the bus.')
tokIntPortRightNeighbor = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 5, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("exist", 1), ("notExist", 2), ("bypass", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokIntPortRightNeighbor.setStatus('mandatory')
if mibBuilder.loadTexts: tokIntPortRightNeighbor.setDescription('Attribute defining the existence of another token ring group to the left hand side of the module, on the TR bus to which this intrnal port is connected. The value bypass is reported when the controller is not connected to the bus.')
tokIntPortManLeftLoop = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 5, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tokIntPortManLeftLoop.setStatus('mandatory')
if mibBuilder.loadTexts: tokIntPortManLeftLoop.setDescription('Setting this attribute to on signifies a command to the hardware to create a loop to the left of the module, on the bus to which this internal port is connected.')
tokIntPortManRightLoop = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 5, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tokIntPortManRightLoop.setStatus('mandatory')
if mibBuilder.loadTexts: tokIntPortManRightLoop.setDescription('Setting this attribute to on signifies a command to the hardware to create a loop to the left of the module, on the bus to which this internal port is connected.')
tokIntPortAutoLeftLoop = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 5, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokIntPortAutoLeftLoop.setStatus('mandatory')
if mibBuilder.loadTexts: tokIntPortAutoLeftLoop.setDescription("Value 'on' of this attribute signifies that a left hardware loop was created on the Token Ring bus to which this internal port is connected.")
tokIntPortAutoRightLoop = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 5, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokIntPortAutoRightLoop.setStatus('mandatory')
if mibBuilder.loadTexts: tokIntPortAutoRightLoop.setDescription("Value 'on' of this attribute signifies that a right hardware loop was created on the Token Ring bus to which this internal port is connected.")
tsGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 14, 1))
tsGroupTable = MibTable((1, 3, 6, 1, 4, 1, 81, 14, 1, 1), )
if mibBuilder.loadTexts: tsGroupTable.setStatus('mandatory')
tsGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 14, 1, 1, 1), ).setIndexNames((0, "MODULES-MIB", "tsGroupId"))
if mibBuilder.loadTexts: tsGroupEntry.setStatus('mandatory')
tsGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 14, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: tsGroupId.setDescription('Number of the slot in which the group is installed.')
tsGroupLATStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 14, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsGroupLATStatus.setStatus('mandatory')
if mibBuilder.loadTexts: tsGroupLATStatus.setDescription('Value ON of this attribute means that LAT protocol is Enabled on the Ethernet module.')
tsGroupOperationMode = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 14, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("diagnostics", 1), ("diagnosticsFailure", 2), ("loading", 3), ("loadingFailure", 4), ("operational", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsGroupOperationMode.setStatus('mandatory')
if mibBuilder.loadTexts: tsGroupOperationMode.setDescription('This attribute describes the operation mode of the module in a multiprocessor configuration sensor, as reported by interprocessors communication.')
ltalkPort = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 15, 1))
ltalkPortTable = MibTable((1, 3, 6, 1, 4, 1, 81, 15, 1, 1), )
if mibBuilder.loadTexts: ltalkPortTable.setStatus('mandatory')
ltalkPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 15, 1, 1, 1), ).setIndexNames((0, "MODULES-MIB", "ltalkPortGroupId"), (0, "MODULES-MIB", "ltalkPortId"))
if mibBuilder.loadTexts: ltalkPortEntry.setStatus('mandatory')
ltalkPortGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 15, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ltalkPortGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: ltalkPortGroupId.setDescription('Number of the group to which the port belongs.')
ltalkPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 15, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ltalkPortId.setStatus('mandatory')
if mibBuilder.loadTexts: ltalkPortId.setDescription('ID of the port in the ltalkPortTable.')
ltalkPortTest = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 15, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ltalkPortTest.setStatus('mandatory')
if mibBuilder.loadTexts: ltalkPortTest.setDescription('A value ON of this attribute indicates that a port test should be performed upon the port defined by the attribute instance.')
ltalkPortTestResult = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 15, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("faulty", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ltalkPortTestResult.setStatus('mandatory')
if mibBuilder.loadTexts: ltalkPortTestResult.setDescription('Indicates the result of a port test performed on this port.')
ltalkPortJam = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 15, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ltalkPortJam.setStatus('mandatory')
if mibBuilder.loadTexts: ltalkPortJam.setDescription('An ON value of this attribute indicates a Jam error on the specific port.')
clGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 16, 1))
clGroupTable = MibTable((1, 3, 6, 1, 4, 1, 81, 16, 1, 1), )
if mibBuilder.loadTexts: clGroupTable.setStatus('mandatory')
clGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 16, 1, 1, 1), ).setIndexNames((0, "MODULES-MIB", "clGroupId"))
if mibBuilder.loadTexts: clGroupEntry.setStatus('mandatory')
clGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 16, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: clGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: clGroupId.setDescription('Number of the slot in which the group is installed.')
clGroupClockRedundancy = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 16, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: clGroupClockRedundancy.setStatus('mandatory')
if mibBuilder.loadTexts: clGroupClockRedundancy.setDescription('Value ON of this attribute defines a redundancy (backup) relationship between the internal and external clocks on the LCL100 module.')
clGroupMainClock = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 16, 1, 1, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: clGroupMainClock.setStatus('mandatory')
if mibBuilder.loadTexts: clGroupMainClock.setDescription("Value of this attribute is an index into clPortTable, and defines the clock that should operate or a main clock in redundancy scheme. Serves as 'Clock selection' switch on the card.")
clGroupTestClocks = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 16, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: clGroupTestClocks.setStatus('mandatory')
if mibBuilder.loadTexts: clGroupTestClocks.setDescription('A value ON of this attribute indicates that a test should be performed on all clock ports.')
clPort = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 16, 2))
clPortTable = MibTable((1, 3, 6, 1, 4, 1, 81, 16, 2, 1), )
if mibBuilder.loadTexts: clPortTable.setStatus('mandatory')
clPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 16, 2, 1, 1), ).setIndexNames((0, "MODULES-MIB", "clPortGroupId"), (0, "MODULES-MIB", "clPortId"))
if mibBuilder.loadTexts: clPortEntry.setStatus('mandatory')
clPortGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 16, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: clPortGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: clPortGroupId.setDescription('Number of the group to which the port belongs.')
clPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 16, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: clPortId.setStatus('mandatory')
if mibBuilder.loadTexts: clPortId.setDescription('ID of the port in the clPortTable.')
clPortFunctionalStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 16, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("faulty", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: clPortFunctionalStatus.setStatus('mandatory')
if mibBuilder.loadTexts: clPortFunctionalStatus.setDescription('Indicates whether the clock is faulty or not.')
iwb = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 21, 1))
iwr = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 21, 2))
itr = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 21, 3))
iwrGroupTable = MibTable((1, 3, 6, 1, 4, 1, 81, 21, 2, 1), )
if mibBuilder.loadTexts: iwrGroupTable.setStatus('mandatory')
if mibBuilder.loadTexts: iwrGroupTable.setDescription('Attributes pertaining to the integrated router module.')
iwrGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 21, 2, 1, 1), ).setIndexNames((0, "MODULES-MIB", "iwrGroupId"))
if mibBuilder.loadTexts: iwrGroupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: iwrGroupEntry.setDescription('An entry in the table.')
iwrGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 21, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: iwrGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: iwrGroupId.setDescription('Slot number in which the module is located.')
iwrOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 21, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("run", 1), ("boot", 2), ("fail", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: iwrOperState.setStatus('mandatory')
if mibBuilder.loadTexts: iwrOperState.setDescription('One of the possible states of the module. run(1) - indicates a successful completion of the boot and self test procedure. boot(2) - indicates that the module is performing the boot and self-test procedure. fail(3) - indicates an unsuccessful completion of the boot and self-test procedure.')
iwrPMState = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 21, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("fail", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: iwrPMState.setStatus('mandatory')
if mibBuilder.loadTexts: iwrPMState.setDescription('The state of the Processor Module.')
iwrIOMState = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 21, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("fail", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: iwrIOMState.setStatus('mandatory')
if mibBuilder.loadTexts: iwrIOMState.setDescription('The state of the Input/Output Module.')
iwrEthernetMode = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 21, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("bus4", 1), ("ex10bt", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: iwrEthernetMode.setStatus('mandatory')
if mibBuilder.loadTexts: iwrEthernetMode.setDescription('Determines whether the ex10bt(2) LAN controller is connected to the front panel 10BaseT or to backplane bus4(1).')
iwrPrimaryFDDIInsert = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 21, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("inserted", 1), ("bypassed", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: iwrPrimaryFDDIInsert.setStatus('mandatory')
if mibBuilder.loadTexts: iwrPrimaryFDDIInsert.setDescription("This variable is specific to the IEFR router and reflect the status of the Primary - P FDDI interfaces of the router. There is a corresponding LED for each one on the front pannel and this information may be used to build a 'real-life' representation of the module's pannel on a management application.")
iwrSecondaryFDDIInsert = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 21, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("inserted", 1), ("bypassed", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: iwrSecondaryFDDIInsert.setStatus('mandatory')
if mibBuilder.loadTexts: iwrSecondaryFDDIInsert.setDescription("This variable is specific to the IEFR router and reflect the status of the Secondary - S FDDI interfaces of the router. There is a corresponding LED for each one on the front pannel and this information may be used to build a 'real-life' representation of the module's pannel on a management application.")
iwrWANTable = MibTable((1, 3, 6, 1, 4, 1, 81, 21, 2, 2), )
if mibBuilder.loadTexts: iwrWANTable.setStatus('mandatory')
if mibBuilder.loadTexts: iwrWANTable.setDescription('WAN data table.')
iwrWANEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 21, 2, 2, 1), ).setIndexNames((0, "MODULES-MIB", "iwrWANGroupId"), (0, "MODULES-MIB", "iwrWANPortId"))
if mibBuilder.loadTexts: iwrWANEntry.setStatus('mandatory')
if mibBuilder.loadTexts: iwrWANEntry.setDescription('Entry in the table.')
iwrWANGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 21, 2, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: iwrWANGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: iwrWANGroupId.setDescription('Slot number in which the module is located.')
iwrWANPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 21, 2, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: iwrWANPortId.setStatus('mandatory')
if mibBuilder.loadTexts: iwrWANPortId.setDescription('WAN port index.')
iwrWANConnection = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 21, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("connected", 1), ("disconnected", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: iwrWANConnection.setStatus('mandatory')
if mibBuilder.loadTexts: iwrWANConnection.setDescription('WAN connection status.')
iwrWANPortCableType = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 21, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("x21", 1), ("rs232", 2), ("v35", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: iwrWANPortCableType.setStatus('mandatory')
if mibBuilder.loadTexts: iwrWANPortCableType.setDescription('Cable type connected to the specified WAN port.')
iwrInterfaceAddrTable = MibTable((1, 3, 6, 1, 4, 1, 81, 21, 2, 3), )
if mibBuilder.loadTexts: iwrInterfaceAddrTable.setStatus('mandatory')
if mibBuilder.loadTexts: iwrInterfaceAddrTable.setDescription('The table contain for each interface: 1. The IP address that was configured to the interface. 2. The IP netmask that was configured to the interface. All the network bits are set to 1 and all the hosts bits are set to 0. 3. The Mac Address assigned to the interface.')
iwrInterfaceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 21, 2, 3, 1), ).setIndexNames((0, "MODULES-MIB", "iwrInterfaceGroupId"), (0, "MODULES-MIB", "iwrInterfaceId"))
if mibBuilder.loadTexts: iwrInterfaceEntry.setStatus('mandatory')
if mibBuilder.loadTexts: iwrInterfaceEntry.setDescription('Entry in the table.')
iwrInterfaceGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 21, 2, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: iwrInterfaceGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: iwrInterfaceGroupId.setDescription('Slot number in which the module is located.')
iwrInterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 21, 2, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: iwrInterfaceId.setStatus('mandatory')
if mibBuilder.loadTexts: iwrInterfaceId.setDescription('IP Interface port index.')
iwrInterfaceAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 21, 2, 3, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: iwrInterfaceAddr.setStatus('mandatory')
if mibBuilder.loadTexts: iwrInterfaceAddr.setDescription('The IP Address of this indexed port.')
iwrInterfaceMask = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 21, 2, 3, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: iwrInterfaceMask.setStatus('mandatory')
if mibBuilder.loadTexts: iwrInterfaceMask.setDescription('The IP Address Mask of this indexed port.')
iwrInterfaceMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 21, 2, 3, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: iwrInterfaceMacAddress.setStatus('mandatory')
if mibBuilder.loadTexts: iwrInterfaceMacAddress.setDescription('The Mac Address of this indexed interface.')
itrGroupTable = MibTable((1, 3, 6, 1, 4, 1, 81, 21, 3, 1), )
if mibBuilder.loadTexts: itrGroupTable.setStatus('mandatory')
if mibBuilder.loadTexts: itrGroupTable.setDescription('Table of attributes pertaining to the ITRE module.')
itrGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 21, 3, 1, 1), ).setIndexNames((0, "MODULES-MIB", "itrGroupId"))
if mibBuilder.loadTexts: itrGroupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: itrGroupEntry.setDescription('An entry in the table.')
itrGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 21, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: itrGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: itrGroupId.setDescription('Slot number in which the module is located.')
itrMainSWVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 21, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: itrMainSWVersion.setStatus('mandatory')
if mibBuilder.loadTexts: itrMainSWVersion.setDescription('Software version of the main CPU.')
itrConfigState = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 21, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("local", 1), ("remote", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: itrConfigState.setStatus('mandatory')
if mibBuilder.loadTexts: itrConfigState.setDescription('Configuration state of the module.')
itrModuleState = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 21, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 255))).clone(namedValues=NamedValues(("oper", 1), ("load", 2), ("setup", 3), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: itrModuleState.setStatus('mandatory')
if mibBuilder.loadTexts: itrModuleState.setDescription('State of the ISTC/IFTC modules.')
itrLinkTable = MibTable((1, 3, 6, 1, 4, 1, 81, 21, 3, 2), )
if mibBuilder.loadTexts: itrLinkTable.setStatus('mandatory')
if mibBuilder.loadTexts: itrLinkTable.setDescription('ITRE links table.')
itrLinkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 21, 3, 2, 1), ).setIndexNames((0, "MODULES-MIB", "itrLinkGroupId"), (0, "MODULES-MIB", "itrLinkPortId"))
if mibBuilder.loadTexts: itrLinkEntry.setStatus('mandatory')
if mibBuilder.loadTexts: itrLinkEntry.setDescription('Entry in the table.')
itrLinkGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 21, 3, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: itrLinkGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: itrLinkGroupId.setDescription('Slot number in which the module is located.')
itrLinkPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 21, 3, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: itrLinkPortId.setStatus('mandatory')
if mibBuilder.loadTexts: itrLinkPortId.setDescription('Link identifier.')
itrLinkIf = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 21, 3, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("v11", 1), ("v24", 2), ("v35", 3), ("dte-dce", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: itrLinkIf.setStatus('mandatory')
if mibBuilder.loadTexts: itrLinkIf.setDescription('Interface type.')
itrLinkMode = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 21, 3, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("sync", 1), ("async", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: itrLinkMode.setStatus('mandatory')
if mibBuilder.loadTexts: itrLinkMode.setDescription('Synchronous or asynchronous modes on the link.')
itrLinkAsyncRate = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 21, 3, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 255))).clone(namedValues=NamedValues(("r2400", 1), ("r4800", 2), ("r9600", 3), ("r14400", 4), ("r19200", 5), ("r38400", 6), ("r56000", 7), ("r57600", 8), ("r64000", 9), ("r115200", 10), ("unknown", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: itrLinkAsyncRate.setStatus('mandatory')
if mibBuilder.loadTexts: itrLinkAsyncRate.setDescription('Possible link speeds that can be set in asynchronous mode.')
itrLinkSyncRate = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 21, 3, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 255))).clone(namedValues=NamedValues(("r1200", 1), ("r2400", 2), ("r4800", 3), ("r9600", 4), ("r14400", 5), ("r19200", 6), ("r38400", 7), ("r48000", 8), ("r56000", 9), ("r57600", 10), ("r64000", 11), ("r112000", 12), ("r128000", 13), ("r256000", 14), ("r384000", 15), ("r512000", 16), ("r786000", 17), ("r1024000", 18), ("r1544000", 19), ("r2048000", 20), ("unknown", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: itrLinkSyncRate.setStatus('mandatory')
if mibBuilder.loadTexts: itrLinkSyncRate.setDescription('Link speeds in synchronous mode.')
itrLinkParity = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 21, 3, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: itrLinkParity.setStatus('deprecated')
if mibBuilder.loadTexts: itrLinkParity.setDescription('This attribute enables/disables parity checking.')
itrLinkParityEvenOdd = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 21, 3, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("even", 1), ("odd", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: itrLinkParityEvenOdd.setStatus('deprecated')
if mibBuilder.loadTexts: itrLinkParityEvenOdd.setDescription('Even or odd parity.')
itrLinkStopBit = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 21, 3, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 255))).clone(namedValues=NamedValues(("one", 1), ("two", 2), ("none", 3), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: itrLinkStopBit.setStatus('mandatory')
if mibBuilder.loadTexts: itrLinkStopBit.setDescription("Number of stop bits (1 or 2 ) in asynchronous mode. The value 'none' is returned in synchronous mode.")
itrLinkRemoteLANConn = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 21, 3, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("connected", 1), ("disconnected", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: itrLinkRemoteLANConn.setStatus('mandatory')
if mibBuilder.loadTexts: itrLinkRemoteLANConn.setDescription('This attribute shows whether the remote ITRE is connected to the LAN.')
itrLinkFunctionalStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 21, 3, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("ok", 1), ("fail", 2), ("noRxClk", 3), ("disable", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: itrLinkFunctionalStatus.setStatus('mandatory')
if mibBuilder.loadTexts: itrLinkFunctionalStatus.setDescription('The attribute represents the status of the WAN link.')
itrLinkAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 21, 3, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 255))).clone(namedValues=NamedValues(("enabled", 1), ("enabledOnDemand", 2), ("disabled", 3), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: itrLinkAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: itrLinkAdminStatus.setDescription("The administrative status of the WAN port of the ITRE/IERE family. enabled(1) enables the WAN link, disabled(3) disables it, and enableddOnDemand(2) allows the ITRE/IERE to decide whether to open the port or close it. In this case, it's RO value and the state of the module is reflected in the genPortAdminStatus object.")
itrLinkReset = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 21, 3, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: itrLinkReset.setStatus('mandatory')
if mibBuilder.loadTexts: itrLinkReset.setDescription('Reset the WAN link')
itrLinkConnectionStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 21, 3, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("trying", 3), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: itrLinkConnectionStatus.setStatus('mandatory')
if mibBuilder.loadTexts: itrLinkConnectionStatus.setDescription("This attribute represents the end-to-end connection status of the WAN link. When the connection is ok, the link is 'on(1)'. When the connection is lost the link is 'trying(3)'constantly to re-establish the connection until it becomes 'on(1)' or 'off(2)' .")
itrLinkDataBits = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 21, 3, 2, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 255))).clone(namedValues=NamedValues(("seven", 1), ("eight", 2), ("none", 3), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: itrLinkDataBits.setStatus('mandatory')
if mibBuilder.loadTexts: itrLinkDataBits.setDescription("Number of data bits (7 or 8) in asynchronous mode. The value 'notSupported' is returned in synchronous mode.")
itrLinkControlSignalsMode = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 21, 3, 2, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: itrLinkControlSignalsMode.setStatus('mandatory')
if mibBuilder.loadTexts: itrLinkControlSignalsMode.setDescription('The value of this attribute determines the control signals (RTS,CTS, CD) mode while working with a MODEM, either in synchronous or asynchronous mode. When the Control Signals Mode is disabled, there is no flow control with the MODEM.')
itrLinkParityType = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 21, 3, 2, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 255))).clone(namedValues=NamedValues(("noParity", 1), ("even", 2), ("odd", 3), ("none", 4), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: itrLinkParityType.setStatus('mandatory')
if mibBuilder.loadTexts: itrLinkParityType.setDescription("This attribute represents the parity type in asynchronous mode. The value 'none' is returned in synchronous mode.")
lntFddiPort = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 25, 1))
lntFddiPortTable = MibTable((1, 3, 6, 1, 4, 1, 81, 25, 1, 1), )
if mibBuilder.loadTexts: lntFddiPortTable.setStatus('mandatory')
lntFddiPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 25, 1, 1, 1), ).setIndexNames((0, "MODULES-MIB", "lntFddiPortGroupId"), (0, "MODULES-MIB", "lntFddiPortId"))
if mibBuilder.loadTexts: lntFddiPortEntry.setStatus('mandatory')
lntFddiPortGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 25, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lntFddiPortGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: lntFddiPortGroupId.setDescription('Id of the slot to which the fddi port belongs.')
lntFddiPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 25, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lntFddiPortId.setStatus('mandatory')
if mibBuilder.loadTexts: lntFddiPortId.setDescription('Id of the port.')
lntFddiPortMACCurrentPath = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 25, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("primary", 1), ("secondary", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lntFddiPortMACCurrentPath.setStatus('mandatory')
if mibBuilder.loadTexts: lntFddiPortMACCurrentPath.setDescription('Indicates the association of the MAC with the link path.')
lntFddiPortOpticalSwitchExist = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 25, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("exist", 1), ("not-exist", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lntFddiPortOpticalSwitchExist.setStatus('mandatory')
if mibBuilder.loadTexts: lntFddiPortOpticalSwitchExist.setDescription('This attribute describes the presence of the optical switch and for existing optical switches describes the possibility of the auto-reconfiguration of path resources in the case of power fault.')
lntFddiPortRingConfiguration = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 25, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("thru", 1), ("wrap-a", 2), ("wrap-b", 3), ("wrap-s", 4), ("isolate", 5), ("dualHomingA", 6), ("dualHomingB", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lntFddiPortRingConfiguration.setStatus('mandatory')
if mibBuilder.loadTexts: lntFddiPortRingConfiguration.setDescription('Attribute which summarizes the status of the fddi link. It is related to the light detection in the physical fiber.')
lntFddiPortLineStatusA = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 25, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("als", 1), ("ils", 2), ("mls", 3), ("hls", 4), ("qls", 5), ("nls", 6), ("sils", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lntFddiPortLineStatusA.setStatus('mandatory')
if mibBuilder.loadTexts: lntFddiPortLineStatusA.setDescription('Attribute that reflects the status of fddi line, interface a.')
lntFddiPortLineStatusB = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 25, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("als", 1), ("ils", 2), ("mls", 3), ("hls", 4), ("qls", 5), ("nls", 6), ("sils", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lntFddiPortLineStatusB.setStatus('mandatory')
if mibBuilder.loadTexts: lntFddiPortLineStatusB.setDescription('Attribute that reflects the status of fddi line, interface b.')
lntFddiPortRxTotalPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 25, 1, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lntFddiPortRxTotalPackets.setStatus('mandatory')
if mibBuilder.loadTexts: lntFddiPortRxTotalPackets.setDescription('Number of total packets, including errors, received')
lntFddiPortRxTotalOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 25, 1, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lntFddiPortRxTotalOctets.setStatus('mandatory')
if mibBuilder.loadTexts: lntFddiPortRxTotalOctets.setDescription('Number of total octets, including errors, received')
lntFddiPortTxTotalPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 25, 1, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lntFddiPortTxTotalPackets.setStatus('mandatory')
if mibBuilder.loadTexts: lntFddiPortTxTotalPackets.setDescription('Number of total packets, including errors, transmitted')
lntFddiPortTxTotalOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 25, 1, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lntFddiPortTxTotalOctets.setStatus('mandatory')
if mibBuilder.loadTexts: lntFddiPortTxTotalOctets.setDescription('Number of total octets, including errors, transmitted')
lntFddiPortIPXtoFDDIMatching = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 25, 1, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 255))).clone(namedValues=NamedValues(("llc", 1), ("snap", 2), ("tunneled", 3), ("fddi-raw", 4), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lntFddiPortIPXtoFDDIMatching.setStatus('mandatory')
if mibBuilder.loadTexts: lntFddiPortIPXtoFDDIMatching.setDescription(' Conversion matching from IPX to FDDI in Novell environment')
lntFddiPortFDDItoIPXMatching = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 25, 1, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 255))).clone(namedValues=NamedValues(("llc", 1), ("snap", 2), ("eth-2", 3), ("eth-raw", 4), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lntFddiPortFDDItoIPXMatching.setStatus('mandatory')
if mibBuilder.loadTexts: lntFddiPortFDDItoIPXMatching.setDescription('Conversion matching from FDDI to IPX in Novell environment')
mibBuilder.exportSymbols("MODULES-MIB", tsGroupEntry=tsGroupEntry, ethPortPolarity=ethPortPolarity, fethPortBroadcastReceivedFrames=fethPortBroadcastReceivedFrames, itrGroupTable=itrGroupTable, tokRingStationEntry=tokRingStationEntry, tokGroupAutoLinkLoop=tokGroupAutoLinkLoop, fethPortFunctionalStatus=fethPortFunctionalStatus, fethPortFIFO=fethPortFIFO, ltalkPort=ltalkPort, ethGroup=ethGroup, itrLinkAdminStatus=itrLinkAdminStatus, ethBusUtilization=ethBusUtilization, tsGroupTable=tsGroupTable, ethBusPerfTable=ethBusPerfTable, fethPortUpper32ReadableOctets=fethPortUpper32ReadableOctets, tsGroupId=tsGroupId, tokGroupRingTable=tokGroupRingTable, fethPortFrameTooLongs=fethPortFrameTooLongs, ethAgTable=ethAgTable, tokRingStationReceiveCongErrors=tokRingStationReceiveCongErrors, iwrWANPortCableType=iwrWANPortCableType, itrLinkStopBit=itrLinkStopBit, iwrSecondaryFDDIInsert=iwrSecondaryFDDIInsert, tokPortId=tokPortId, ethPortFramesTooLong=ethPortFramesTooLong, tokRingStationAbortsTrans=tokRingStationAbortsTrans, ethGroupBroadcastPkts=ethGroupBroadcastPkts, clGroupId=clGroupId, tokPortFunctionalStatus=tokPortFunctionalStatus, fethPortAlignmentErrors=fethPortAlignmentErrors, tokPortGroupId=tokPortGroupId, itrLinkParityType=itrLinkParityType, itrLinkEntry=itrLinkEntry, ltalk=ltalk, ethAg=ethAg, ethGroup10BTPlus=ethGroup10BTPlus, tokRingStationRingId=tokRingStationRingId, fethPortGroupId=fethPortGroupId, fethPortLinkRedundancyMode=fethPortLinkRedundancyMode, ethGroupTotalOctets=ethGroupTotalOctets, fethPortRxErrors=fethPortRxErrors, cl=cl, tsGroupOperationMode=tsGroupOperationMode, tokGroupStarSpeedDetect=tokGroupStarSpeedDetect, ethBusPerfAgId=ethBusPerfAgId, itrLinkControlSignalsMode=itrLinkControlSignalsMode, fethPortFCSErrors=fethPortFCSErrors, iwrWANGroupId=iwrWANGroupId, iwrInterfaceMacAddress=iwrInterfaceMacAddress, tokRingStationFunctionalType=tokRingStationFunctionalType, tokGroupRingId=tokGroupRingId, tokGroupManLinkLoop=tokGroupManLinkLoop, tokRingStationFramesCopied=tokRingStationFramesCopied, ethGroupFIFO=ethGroupFIFO, clPortGroupId=clPortGroupId, itrLinkGroupId=itrLinkGroupId, ethPortVeryLongEvents=ethPortVeryLongEvents, tokGroupAutoRightLoop=tokGroupAutoRightLoop, tokPortMapping=tokPortMapping, ethAgPerfBusSelection=ethAgPerfBusSelection, lntFddiPortTable=lntFddiPortTable, ethGroupTotalFrames=ethGroupTotalFrames, tokRingStationLostFrames=tokRingStationLostFrames, lntFddiPortEntry=lntFddiPortEntry, ethPortTotalErrors=ethPortTotalErrors, tokRingTraffic=tokRingTraffic, ethPortGroupId=ethPortGroupId, fethPortVeryLongEvents=fethPortVeryLongEvents, ethPortLateEvents=ethPortLateEvents, eth=eth, fethPortSourceAddrChanges=fethPortSourceAddrChanges, ethBusClockTestResult=ethBusClockTestResult, lntFddiPort=lntFddiPort, fethGroupTable=fethGroupTable, ltalkPortJam=ltalkPortJam, lntFddiPortLineStatusA=lntFddiPortLineStatusA, ethGroupMulticastPkts=ethGroupMulticastPkts, bRouter=bRouter, ethPortUserStatus=ethPortUserStatus, fethGroupTotalFrames=fethGroupTotalFrames, ethPortId=ethPortId, tokRingBeaconing=tokRingBeaconing, tokGroupLeftNeighbor=tokGroupLeftNeighbor, ethPortReadableFrames=ethPortReadableFrames, ethBusTraffic=ethBusTraffic, clGroupTable=clGroupTable, ethIntPort=ethIntPort, tokGroupLSTBeaconing=tokGroupLSTBeaconing, iwrInterfaceEntry=iwrInterfaceEntry, tokGroup=tokGroup, iwrInterfaceAddrTable=iwrInterfaceAddrTable, tokGroupRingSpeed=tokGroupRingSpeed, fethPortTable=fethPortTable, tokGroupEntry=tokGroupEntry, ts=ts, lntFddiPortIPXtoFDDIMatching=lntFddiPortIPXtoFDDIMatching, clGroupClockRedundancy=clGroupClockRedundancy, ethIntPortId=ethIntPortId, iwrWANPortId=iwrWANPortId, ethPortMJLP=ethPortMJLP, ethIntPortJabber=ethIntPortJabber, itrLinkPortId=itrLinkPortId, fethGroupEntry=fethGroupEntry, ethBusTotalCollisions=ethBusTotalCollisions, ethGroupEntry=ethGroupEntry, tokPortEntry=tokPortEntry, ethGroupWrongPortSelection=ethGroupWrongPortSelection, iwrIOMState=iwrIOMState, ethPortFramesReceivedOK=ethPortFramesReceivedOK, fethPortFramesTransmittedOK=fethPortFramesTransmittedOK, tokRingRightSlot=tokRingRightSlot, tokGroupLobeSpeedDetect=tokGroupLobeSpeedDetect, tokPort=tokPort, itrGroupId=itrGroupId, ethPortManPart=ethPortManPart, tokRingStationTable=tokRingStationTable, tokRingStationTokenErrors=tokRingStationTokenErrors, fethPortLower32TransmittedOctets=fethPortLower32TransmittedOctets, clPortEntry=clPortEntry, tokGroupLSTBeaconThresh=tokGroupLSTBeaconThresh, ethGroupIntPortsRedundancy=ethGroupIntPortsRedundancy, iwrInterfaceAddr=iwrInterfaceAddr, tokRingBeaconingStation=tokRingBeaconingStation, tsGroupLATStatus=tsGroupLATStatus, ethBusPerfEntry=ethBusPerfEntry, itrLinkSyncRate=itrLinkSyncRate, tokPortBypass=tokPortBypass, tokGroupManLeftLoop=tokGroupManLeftLoop, ethPortJabberCounter=ethPortJabberCounter, iwrInterfaceGroupId=iwrInterfaceGroupId, clGroup=clGroup, itrLinkIf=itrLinkIf, tsGroup=tsGroup, ethPortMulticastPkts=ethPortMulticastPkts, ethBusClockEntry=ethBusClockEntry, itrLinkReset=itrLinkReset, tokPortRingId=tokPortRingId, tokRingThresholdStatus=tokRingThresholdStatus, iwrEthernetMode=iwrEthernetMode, tokRingAgId=tokRingAgId, tokRingStationMAC=tokRingStationMAC, fethPortLower32ReadableOctets=fethPortLower32ReadableOctets, iwrWANEntry=iwrWANEntry, tokPortRingSpeedError=tokPortRingSpeedError, tokGroupRingGroupId=tokGroupRingGroupId, fethGroupUpper32TotalOctets=fethGroupUpper32TotalOctets, fethPortAutoPartitions=fethPortAutoPartitions, tokGroupRightNeighbor=tokGroupRightNeighbor, ethPortPygmys=ethPortPygmys, itrLinkParityEvenOdd=itrLinkParityEvenOdd, tokRingPeakUtilization=tokRingPeakUtilization, ethAgEntry=ethAgEntry, ethPortNoAUILoop=ethPortNoAUILoop, fethGroupUtilization=fethGroupUtilization, itrLinkTable=itrLinkTable, itrConfigState=itrConfigState, ethIntPortTable=ethIntPortTable, ethIntPortEntry=ethIntPortEntry, ethPortEntry=ethPortEntry, fethPortMode=fethPortMode, tokPortSpeedDetect=tokPortSpeedDetect, ethBusTrafficBuffer=ethBusTrafficBuffer, lntFddiPortRxTotalPackets=lntFddiPortRxTotalPackets, ethPortPartitions=ethPortPartitions, ethBus=ethBus, tokGroupAutoLeftLoop=tokGroupAutoLeftLoop, tokGroupRingStatus=tokGroupRingStatus, ethPortOperStatus=ethPortOperStatus, tokPortSpecificOID=tokPortSpecificOID, ethGroupSpecificOID=ethGroupSpecificOID, tokRingStationLineErrors=tokRingStationLineErrors, itrLinkDataBits=itrLinkDataBits, ethPortFIFO=ethPortFIFO, ethBusTrafficThresh=ethBusTrafficThresh, iwrWANTable=iwrWANTable, ethBusPeakTraffic=ethBusPeakTraffic, fethPortEntry=fethPortEntry, ethPortSpecificOID=ethPortSpecificOID, tokRingConfiguration=tokRingConfiguration, tokPortCableFault=tokPortCableFault, iwrGroupId=iwrGroupId, tokRingPeakTraffic=tokRingPeakTraffic, ethBusClockId=ethBusClockId, tokIntPortManLeftLoop=tokIntPortManLeftLoop, fethPortLastSourceAddress=fethPortLastSourceAddress, ltalkPortId=ltalkPortId, iwrWANConnection=iwrWANConnection, tokRingTrafficThresh=tokRingTrafficThresh, fethPortUpper32TransmittedOctets=fethPortUpper32TransmittedOctets, iwrGroupTable=iwrGroupTable, fethPortDormantLinkFunctionalStatus=fethPortDormantLinkFunctionalStatus, tokRingSecureAddr=tokRingSecureAddr, tokRingStationFrequencyErrors=tokRingStationFrequencyErrors, ethBusPeakUtilization=ethBusPeakUtilization, itrLinkParity=itrLinkParity, lntFddiPortOpticalSwitchExist=lntFddiPortOpticalSwitchExist, fethPortCollisionFrames=fethPortCollisionFrames, feth=feth, tokRingId=tokRingId, tokRingActiveMonitor=tokRingActiveMonitor, tokIntPort=tokIntPort, itrLinkConnectionStatus=itrLinkConnectionStatus, tokRingTable=tokRingTable, fethPortOperStatus=fethPortOperStatus, ethPortAlignmentErrors=ethPortAlignmentErrors, itrMainSWVersion=itrMainSWVersion, lntFddiPortTxTotalOctets=lntFddiPortTxTotalOctets, ethGroupTotalErrors=ethGroupTotalErrors, ethPortTable=ethPortTable, tokIntPortAutoLeftLoop=tokIntPortAutoLeftLoop, fethPortLinkRedundancyStatus=fethPortLinkRedundancyStatus, iwrPrimaryFDDIInsert=iwrPrimaryFDDIInsert, iwrOperState=iwrOperState, tokRingLastViolation=tokRingLastViolation, ethPortRunts=ethPortRunts, lntFddiPortRxTotalOctets=lntFddiPortRxTotalOctets, ethGroupBridgeMode=ethGroupBridgeMode, iwrInterfaceId=iwrInterfaceId, tokRingSecurityPolicy=tokRingSecurityPolicy, ltalkPortTest=ltalkPortTest, ethBusPerfId=ethBusPerfId, itrModuleState=itrModuleState, lntFddiGroup=lntFddiGroup, ethPortCollisions=ethPortCollisions, iwrGroupEntry=iwrGroupEntry, clPort=clPort, ethGroupFOIRLPlusMode=ethGroupFOIRLPlusMode, tokPortTCP=tokPortTCP, ethPortMainBusSelection=ethPortMainBusSelection, tokRingStationInternalErrors=tokRingStationInternalErrors, ethIntPortPartition=ethIntPortPartition, tokIntPortTable=tokIntPortTable, tokRingUtilization=tokRingUtilization, ethPort=ethPort, ltalkPortTable=ltalkPortTable, tokRingBeaconingResolution=tokRingBeaconingResolution, lntFddiPortLineStatusB=lntFddiPortLineStatusB, fethGroupFefiEnable=fethGroupFefiEnable, tokGroupIOMode=tokGroupIOMode, tokGroupTable=tokGroupTable, clPortFunctionalStatus=clPortFunctionalStatus, ethPortFunctionalStatus=ethPortFunctionalStatus, ethPortSQETest=ethPortSQETest, ethPortDataRateMismatches=ethPortDataRateMismatches, tokGroupRingInserted=tokGroupRingInserted, tokIntPortLeftNeighbor=tokIntPortLeftNeighbor, tokIntPortAutoRightLoop=tokIntPortAutoRightLoop, lntFddiPortTxTotalPackets=lntFddiPortTxTotalPackets, ethBusThresholdStatus=ethBusThresholdStatus, itr=itr, ethPortJabber=ethPortJabber, itrGroupEntry=itrGroupEntry, fethPortFramesTransmitted=fethPortFramesTransmitted, tokGroupSpecificOID=tokGroupSpecificOID)
mibBuilder.exportSymbols("MODULES-MIB", tokRingEntry=tokRingEntry, ethBusClockBusId=ethBusClockBusId, fethGroupTotalErrors=fethGroupTotalErrors, tokGroupManBusLoop=tokGroupManBusLoop, ethPortBroadcastPkts=ethPortBroadcastPkts, fethPortId=fethPortId, ethGroupIdleTrx=ethGroupIdleTrx, itrLinkFunctionalStatus=itrLinkFunctionalStatus, tokIntPortId=tokIntPortId, ethBusTotalPackets=ethBusTotalPackets, tok=tok, tokIntPortEntry=tokIntPortEntry, lntFddiPortMACCurrentPath=lntFddiPortMACCurrentPath, iwrInterfaceMask=iwrInterfaceMask, ethBusClockTable=ethBusClockTable, ethGroupTable=ethGroupTable, tokGroupAutoBusLoop=tokGroupAutoBusLoop, tokPortLastSourceAddr=tokPortLastSourceAddr, clPortTable=clPortTable, tokRingStationBurstErrors=tokRingStationBurstErrors, fethPortShortEvents=fethPortShortEvents, ethPortLastSourceAddr=ethPortLastSourceAddr, lntFddiPortId=lntFddiPortId, clGroupTestClocks=clGroupTestClocks, tokIntPortRightNeighbor=tokIntPortRightNeighbor, fethGroup=fethGroup, tokRingStationTotalErrors=tokRingStationTotalErrors, iwb=iwb, fethPort=fethPort, tokRing=tokRing, tokGroupRingEntry=tokGroupRingEntry, ltalkPortTestResult=ltalkPortTestResult, ethPortReadableOctets=ethPortReadableOctets, itrLinkMode=itrLinkMode, fethPortSymbolErrors=fethPortSymbolErrors, fethPortDataRateMismatches=fethPortDataRateMismatches, ltalkPortGroupId=ltalkPortGroupId, fethPortLateEvents=fethPortLateEvents, clGroupMainClock=clGroupMainClock, tokGroupManRightLoop=tokGroupManRightLoop, tokRingTrafficBuffer=tokRingTrafficBuffer, clPortId=clPortId, ethGroupMasterClock=ethGroupMasterClock, iwrPMState=iwrPMState, itrLinkRemoteLANConn=itrLinkRemoteLANConn, fethGroupOperStatus=fethGroupOperStatus, ethBusTotalErrors=ethBusTotalErrors, lntFddiPortFDDItoIPXMatching=lntFddiPortFDDItoIPXMatching, ethGroupBackboneMode=ethGroupBackboneMode, ethPortAutoPartitionState=ethPortAutoPartitionState, tokIntPortManRightLoop=tokIntPortManRightLoop, tokGroupBridgeMode=tokGroupBridgeMode, ethIntPortGroupId=ethIntPortGroupId, fethPortFramesReceived=fethPortFramesReceived, fethPortEnablePHY=fethPortEnablePHY, fethPortRunts=fethPortRunts, clGroupEntry=clGroupEntry, fethPortMulticastReceivedFrames=fethPortMulticastReceivedFrames, ethPortPacketErrors=ethPortPacketErrors, tokRingNumberOfStations=tokRingNumberOfStations, tokRingStationACErrors=tokRingStationACErrors, ethGroupSingleBusMode=ethGroupSingleBusMode, tokPortConnected=tokPortConnected, ethGroupBackupBus=ethGroupBackupBus, fethPortAutoPartitionState=fethPortAutoPartitionState, tokGroupId=tokGroupId, ethAgId=ethAgId, iwr=iwr, ltalkPortEntry=ltalkPortEntry, tokPortTable=tokPortTable, ethPortCoupling=ethPortCoupling, fethGroupLower32TotalOctets=fethGroupLower32TotalOctets, itrLinkAsyncRate=itrLinkAsyncRate, fethGroupId=fethGroupId, ethIntPortBackedUp=ethIntPortBackedUp, tokIntPortGroupId=tokIntPortGroupId, tokRingSecurityMethod=tokRingSecurityMethod, ethPortSourceAddrChanges=ethPortSourceAddrChanges, fethPortTotalErrors=fethPortTotalErrors, ethGroupId=ethGroupId, ethGroup10FBPlus=ethGroup10FBPlus, ethPortTraffic=ethPortTraffic, tokRingLeftSlot=tokRingLeftSlot, ethPortFCSErrors=ethPortFCSErrors, tokRingStation=tokRingStation, tokRingStationsMatch=tokRingStationsMatch, lntFddiPortGroupId=lntFddiPortGroupId, lntFddiPortRingConfiguration=lntFddiPortRingConfiguration, fethPortReadableFrames=fethPortReadableFrames)

#
# PySNMP MIB module CPIWF-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CPIWF-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:27:08 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ValueSizeConstraint, SingleValueConstraint, ConstraintsIntersection, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ValueSizeConstraint", "SingleValueConstraint", "ConstraintsIntersection", "ConstraintsUnion")
ModuleCompliance, ObjectGroup, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "ObjectGroup", "NotificationGroup")
ObjectIdentity, enterprises, IpAddress, Gauge32, Counter32, iso, NotificationType, MibIdentifier, Counter64, Bits, ModuleIdentity, Integer32, TimeTicks, Unsigned32, MibScalar, MibTable, MibTableRow, MibTableColumn = mibBuilder.importSymbols("SNMPv2-SMI", "ObjectIdentity", "enterprises", "IpAddress", "Gauge32", "Counter32", "iso", "NotificationType", "MibIdentifier", "Counter64", "Bits", "ModuleIdentity", "Integer32", "TimeTicks", "Unsigned32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
atmForum = MibIdentifier((1, 3, 6, 1, 4, 1, 353))
atmForumNetworkManagement = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5))
atmfLoopEmulationService = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 10))
cpIwfMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 353, 5, 10, 1))
if mibBuilder.loadTexts: cpIwfMIB.setLastUpdated('200107260000Z')
if mibBuilder.loadTexts: cpIwfMIB.setOrganization('ATM Forum VMOA Working Group')
if mibBuilder.loadTexts: cpIwfMIB.setContactInfo('The ATM Forum 1000 Executive Parkway, Suite 200 St. Louis, MO 63141 United States of America Tel: +1 314 205 0200 E-mail: info@atmforum.com')
if mibBuilder.loadTexts: cpIwfMIB.setDescription('This module defines a portion of the management information base (MIB) for managing the LES CP-IWFs. It is meant to be used in connection with MIB-II System Group and RFC 2863 which defines the ifTable.')
cpIwfMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1))
cpIwfMIBNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 2))
cpIwf = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 1))
cpIwfVpi = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpIwfVpi.setStatus('current')
if mibBuilder.loadTexts: cpIwfVpi.setDescription('The VPI of the AAL2 VCC to which this CP-IWF is associated.')
cpIwfVci = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpIwfVci.setStatus('current')
if mibBuilder.loadTexts: cpIwfVci.setDescription('The VCI of the AAL2 VCC to which this CP-IWF is associated.')
cpIwfEchoCancellationSupport = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpIwfEchoCancellationSupport.setStatus('current')
if mibBuilder.loadTexts: cpIwfEchoCancellationSupport.setDescription('Specifies whether or not the echo cancellation facility is supported or not supported at the CP-IWF.')
cpIwfNumPotsPorts = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpIwfNumPotsPorts.setStatus('current')
if mibBuilder.loadTexts: cpIwfNumPotsPorts.setDescription('The total number of POTS user ports on the CP-IWF.')
cpIwfNumIsdnBriPorts = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpIwfNumIsdnBriPorts.setStatus('current')
if mibBuilder.loadTexts: cpIwfNumIsdnBriPorts.setDescription('The total number of ISDN-BRI user ports on the CP-IWF.')
cpIwfTimingReference = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ntr", 1), ("adaptiveVoice", 2), ("freeRun", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpIwfTimingReference.setStatus('current')
if mibBuilder.loadTexts: cpIwfTimingReference.setDescription('ntr - network timing reference, voice timing derived from the local network interface. adaptiveVoice - voice timing derived from incoming cell rate. freeRun - voice timing derived from an internal free-running timing source.')
cpIwfPotsPortEncodingSelectionMode = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("independent", 1), ("masterSlave", 2))).clone('masterSlave')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpIwfPotsPortEncodingSelectionMode.setStatus('current')
if mibBuilder.loadTexts: cpIwfPotsPortEncodingSelectionMode.setDescription('This object controls the encoding switching for POTS user ports. masterSlave - the profile entry used by the CP-IWF is the same as that selected by the CO-IWF. independent - the CP-IWF can select the profile entry used for transmission independently of the CO-IWF.')
cpIwfIsdnBriPortEncodingSelectionMode = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("independent", 1), ("masterSlave", 2))).clone('masterSlave')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpIwfIsdnBriPortEncodingSelectionMode.setStatus('current')
if mibBuilder.loadTexts: cpIwfIsdnBriPortEncodingSelectionMode.setDescription('This object controls the encoding switching for ISDN BRI user ports. masterSlave - the profile entry used by the CP-IWF is the same as that selected by the CO-IWF. independent - the CP-IWF can select the profile entry used for transmission independently of the CO-IWF.')
cpIwfElcpAndPstnChannelBandwidth = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 1, 9), Integer32().clone(64000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpIwfElcpAndPstnChannelBandwidth.setStatus('current')
if mibBuilder.loadTexts: cpIwfElcpAndPstnChannelBandwidth.setDescription('The approximate maximum bandwidth of the aal2 connection with CID=8 used to transport ELCP and PSTN signalling messages specified in bits per second at the physical layer.')
cpIwfAdminStatus = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("shuttingDown", 3), ("testing", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpIwfAdminStatus.setStatus('current')
if mibBuilder.loadTexts: cpIwfAdminStatus.setDescription("This object is used to reflect the desired state of the CP-IWF. The actual state of the CP-IWF is given by cpIwfOperStatus. When this object is set to 'down', all existing calls on the CP-IWF are cleared immediately. If this object is set to 'shuttingDown', no further calls shall be accepted either incoming or outgoing on any of the CP-IWF user ports. Once all the calls on the CP-IWF have cleared gracefully the value of this object moves to 'down'.")
cpIwfOperStatus = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpIwfOperStatus.setStatus('current')
if mibBuilder.loadTexts: cpIwfOperStatus.setDescription('Provides the current operational status of the CP-IWF function.')
cpIwfRestart = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("started", 1), ("warmStart", 2), ("coldStart", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpIwfRestart.setStatus('current')
if mibBuilder.loadTexts: cpIwfRestart.setDescription("May be used to initiate a re-start of the CP-IWF function. A Get operation performed on this object will always return 'started'. Re-start is initiated by performing a Set operation to either 'warmStart' or 'coldStart'. A warmStart means initialising all state variables within the CP-IWF to their starting values. A coldStart means rebooting the software process that implements the CP-IWF function. It is desirable that a coldStart should not affect the operation of other functions within the LES device, including other CP-IWF instances.")
cpIwfTestType = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("selfTest", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpIwfTestType.setStatus('current')
if mibBuilder.loadTexts: cpIwfTestType.setDescription("This object is used to specify the type of test to run. The result of the self test will be stored in cpIwfTestResult. In order to run this test, the CO-IWF must first set the value of this object to the test that needs to be carried out. The CO-IWF must then set the cpIwfAdminStatus to 'testing' which will activate the test. To de-activate a test that does not self-terminate such as a loopback test, the CO-IWF must set the cpIwfAdminStatus to a value other than 'testing'.")
cpIwfTestResult = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("null", 1), ("success", 2), ("failure", 3), ("inProgress", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpIwfTestResult.setStatus('current')
if mibBuilder.loadTexts: cpIwfTestResult.setDescription('Provides the result of the last self-test operation performed on the CP-IWF. If no self-test has been performed, this object should return null (1).')
cpIwfTestResultText = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 1, 15), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpIwfTestResultText.setStatus('current')
if mibBuilder.loadTexts: cpIwfTestResultText.setDescription('Provides textual information about the result of the last self-test operation performed on the CP-IWF, or a zero-length string if no tests have been performed since the last reset.')
cpIwfPlayoutBufferDepth = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 1, 16), Integer32().clone(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpIwfPlayoutBufferDepth.setStatus('current')
if mibBuilder.loadTexts: cpIwfPlayoutBufferDepth.setDescription('The amount of packet delay variation to be accommodated on all ports of the CP-IWF, in milliseconds.')
cpIwfImpairmentInterval = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 1, 17), Integer32().clone(15)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpIwfImpairmentInterval.setStatus('current')
if mibBuilder.loadTexts: cpIwfImpairmentInterval.setDescription('The period over which voice impairments should be counted to determine whether a threshold-crossing event has occurred, in minutes. It is recommended that this value be set to an integral multiple of 5 minutes.')
cpIwfImpairmentThreshold = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 1, 18), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpIwfImpairmentThreshold.setStatus('current')
if mibBuilder.loadTexts: cpIwfImpairmentThreshold.setDescription('If the number of impairment octets, calculated as the sum of fillerOctets and droppedOctets, that is observed on any individual POTS port or ISDN BRI port/channel during any interval of length cpIwfImpairmentInterval minutes is equal to or greater than the value of cpIwfImpairmentThreshold, then the trap cpIwfExcessImpairment will be sent to the CO-IWF. A value of zero will disable the reporting of excess impairments.')
cpIwfV5PSTNProtocolVariant = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 1, 19), Integer32().clone(44)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpIwfV5PSTNProtocolVariant.setStatus('current')
if mibBuilder.loadTexts: cpIwfV5PSTNProtocolVariant.setDescription('When the applicationIdentifier indicates the use of PSTN signalling for POTS the value of this object shall be set to the national PSTN protocol variant to be used, else this object is not applicable. The value of this object shall be the 2-digit country code, as defined in the E.164 numbering plan, followed by an optional carrier code. An SNMP Set operation to a value which is not supported shall result in an SNMP Response with error status of badValue(3).')
cpIwfMwdForRestart = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 1, 20), Integer32().clone(600)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpIwfMwdForRestart.setStatus('current')
if mibBuilder.loadTexts: cpIwfMwdForRestart.setDescription('This object defines the maximum waiting delay (MWD) in seconds used during restart. When this CP-IWF is powered on, it shall initiate a restart timer to a random value, uniformly distributed between 0 and the value of this object. Upon expiry of this timer or when activity is detected this CP-IWF shall send a coldStart Trap to its peer CO-IWF and initiate the restart procedure. The CP-IWF shall guarantee that the first message that the CO-IWF sees across the LES EOC after a restart of the CP-IWF is the coldStart Trap.')
cpIwfEocBandwidth = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(300, 640000)).clone(32000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpIwfEocBandwidth.setStatus('current')
if mibBuilder.loadTexts: cpIwfEocBandwidth.setDescription('Provides the approximate maximum bandwidth of the EOC in bits per second at the physical layer.')
cpIwfCurrentConfig = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 1, 22), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpIwfCurrentConfig.setStatus('current')
if mibBuilder.loadTexts: cpIwfCurrentConfig.setDescription('This object provides an efficient mechanism for a management entity to maintain synchronization with a CP-IWF current level of configuration. The value should be persistently stored on the CP-IWF and hence retain its previous value following a restart event. The CP-IWF EMS is expected to retain a local copy of this value. At any time (e.g., upon processing a cold start trap), if the CP-IWF EMS detects a mismatch between its copy and the value returned by CP-IWF, the CP-IWF EMS may initiate configuration synchronization operation with the CP-IWF and update this value. The CP-IWF shall reset this value to zero, if the configuration of the CP-IWF is changed by local management action or when it determines that the hardware/software configuration that affects the service capability of the CP-IWF has changed. This only applies to configuration changes and not other changeable objects such as statistics.')
cpIwfTrapGeneration = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled-all", 2), ("disabled-except-coldStart", 3))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpIwfTrapGeneration.setStatus('current')
if mibBuilder.loadTexts: cpIwfTrapGeneration.setDescription('Using this object, the CP-IWF EMS can globally disable all trap generation by the CP-IWF. By default, the CP-IWF shall be globally enabled to generate any/all traps that have not otherwise been selectively disabled. To globally suppress all trap generation by CP-IWF, CP-IWF EMS should set this object to value: disabled-all(2).')
cpIwfVendorName = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 1, 24), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpIwfVendorName.setStatus('current')
if mibBuilder.loadTexts: cpIwfVendorName.setDescription('The name of the vendor that produced the LES device in which this CP-IWF function resides.')
cpIwfDeviceType = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 1, 25), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpIwfDeviceType.setStatus('current')
if mibBuilder.loadTexts: cpIwfDeviceType.setDescription("The vendor's designated model number for the LES device in which this CP-IWF function resides.")
cpIwfHardwareVersion = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 1, 26), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpIwfHardwareVersion.setStatus('current')
if mibBuilder.loadTexts: cpIwfHardwareVersion.setDescription("The vendor's designated hardware revision for the LES device in which this CP-IWF function resides.")
cpIwfSoftwareVersion = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 1, 27), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpIwfSoftwareVersion.setStatus('current')
if mibBuilder.loadTexts: cpIwfSoftwareVersion.setDescription("The vendor's designated software revision for the software that implements the CP-IWF function.")
cpIwfAal2Profile = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 2))
aal2ApplicationIdentifier = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 2, 1), Integer32().clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aal2ApplicationIdentifier.setStatus('current')
if mibBuilder.loadTexts: aal2ApplicationIdentifier.setDescription('This attribute describes the application identifier, which describes the type of signaling used. The value of this object should be one of those values given in the administered list of AppIDs in section 5 of the ATM Forum document of well-known addresses and assigned codes which can be located at http://www.atmforum.com/pages/aboutatmtech/committees/ public-assigned-codes.txt')
aal2CpsMaxMultiplexedChannels = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 2, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(255)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aal2CpsMaxMultiplexedChannels.setStatus('current')
if mibBuilder.loadTexts: aal2CpsMaxMultiplexedChannels.setDescription('Maximum number of multiplexed channels.')
aal2CpsMaxSDULength = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(45, 45), ValueRangeConstraint(64, 64), )).clone(45)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aal2CpsMaxSDULength.setStatus('current')
if mibBuilder.loadTexts: aal2CpsMaxSDULength.setDescription('Maximum CPS-SDU size given in octets.')
aal2CpsCIDLowerLimit = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 2, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 223)).clone(16)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aal2CpsCIDLowerLimit.setStatus('current')
if mibBuilder.loadTexts: aal2CpsCIDLowerLimit.setDescription('The minimum value the CID can take for AAL2 bearer channels and ISDN D-channels.')
aal2CpsCIDUpperLimit = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 2, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 223)).clone(223)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aal2CpsCIDUpperLimit.setStatus('current')
if mibBuilder.loadTexts: aal2CpsCIDUpperLimit.setDescription('The maximum value the CID can take for AAL2 bearer channels and ISDN D-channels.')
aal2CpsOptimisation = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 2, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("singleCpsPacketPerCpsPduNoOverlap", 1), ("multipleCpsPacketsPerCpsPduWithOverlap", 2))).clone('singleCpsPacketPerCpsPduNoOverlap')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aal2CpsOptimisation.setStatus('current')
if mibBuilder.loadTexts: aal2CpsOptimisation.setDescription('This object refers to the mode of operation of the CPS on the CP-IWF. The value of this object imposes a restriction on the CPS SDU length and hence must override the value of aal2CpsMaxSDULength. singleCpsPacketPerCpsPduNoOverlap - A single CPS Packet is contained within a CPS PDU and no overlap can occur into the next CPS PDU. If this option is selected, then Timer-CU is not applicable. Also the AAL2 payload size must be less than or equal to 44 octets. multipleCpsPacketsPerCpsPduWithOverlap - Multiple CPS Packets are contained within a CPS PDU and overlap can occur into the next CPS PDU. If this option is selected, then Timer-CU is applicable. Also Max CPS SDU size must be less than or equal to 64.')
aal2CpsTimerCuValue = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 2, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aal2CpsTimerCuValue.setStatus('current')
if mibBuilder.loadTexts: aal2CpsTimerCuValue.setDescription('This parameter specifies value of the Timer-CU, in msec, for this VCC. This parameter has meaning only if the value of the parameter aal2CpsOptimisation is set to multipleCpsPacketperCpsPduWithOverlap. Although no default value is provided for this parameter, a value must be assigned to the parameter during the startup of the CP-IWF.')
aal2SscsFaxDemodulationTransport = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 2, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aal2SscsFaxDemodulationTransport.setStatus('current')
if mibBuilder.loadTexts: aal2SscsFaxDemodulationTransport.setDescription('This specifies whether fax demodulation is enabled or disabled. An SNMP Set to enable(2) when fax demodulation is not supported must result in an SNMP response with error status of badValue(3).')
aal2SscsDtmfDigitPacketTransport = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 2, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aal2SscsDtmfDigitPacketTransport.setStatus('current')
if mibBuilder.loadTexts: aal2SscsDtmfDigitPacketTransport.setDescription("This attribute describes whether DTMF digit packet transport is enabled or disabled. If the parameter value specifies 'enabled', then type 3 dialled digit packets are only passed if the encoding scheme being used cannot transparently pass DTMF tones. If the parameter value specifies 'disabled', then a higher rate encoding scheme should be used to transparently pass DTMF tones.")
aal2SscsPcmEncoding = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 2, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("aLaw", 1), ("uLaw", 2))).clone('aLaw')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aal2SscsPcmEncoding.setStatus('current')
if mibBuilder.loadTexts: aal2SscsPcmEncoding.setDescription('This attribute describes the type of PCM encoding used.')
aal2SscsMaxSssarSduLength = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 2, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(493, 65568)).clone(1500)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aal2SscsMaxSssarSduLength.setStatus('current')
if mibBuilder.loadTexts: aal2SscsMaxSssarSduLength.setDescription('This is the maximum size an SSSAR-SDU can take as defined in I.366.1. This parameter only applies to those AAL2 channels using I.366.1 SSSAR.')
aal2SscsProfileSource = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 2, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ituT", 1), ("other", 2))).clone('other')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aal2SscsProfileSource.setStatus('current')
if mibBuilder.loadTexts: aal2SscsProfileSource.setDescription('This attribute describes the source of the profile source. An SNMP Set on this object to an unsupported profile source must result in an SNMP Response with error status of badValue(3).')
aal2SscsPredefinedProfileIdentifier = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 2, 13), Integer32().clone(9)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aal2SscsPredefinedProfileIdentifier.setStatus('current')
if mibBuilder.loadTexts: aal2SscsPredefinedProfileIdentifier.setDescription('This attribute describes the predefined profile identifier. An SNMP Set on this object to an unsupported profile must result in an SNMP Response with error status of badValue(3).')
aal2SscsIeeeOui = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 2, 14), Integer32().clone(41022)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aal2SscsIeeeOui.setStatus('current')
if mibBuilder.loadTexts: aal2SscsIeeeOui.setDescription("This attribute contains the IEEE Organizationally Unique Identifier (OUI) of the entity that specified the profile being used, if other than ITU-T. For example, if the source is the ATM Forum, the value of this object is 00A03E. This attribute is only meaningful if aal2SccsProfileSource has the value 'other'. An SNMP Set on this object to an unsupported profile source must result in an SNMP Response with error status of badValue(3).")
aal2SscsSsSarAssemblyTimerValue = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 2, 15), Integer32().clone(2147483647)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aal2SscsSsSarAssemblyTimerValue.setStatus('current')
if mibBuilder.loadTexts: aal2SscsSsSarAssemblyTimerValue.setDescription('This object specifies the value of the segmentation reassembly timer, in msec, for I.366.1 SAR. The default value specified for this timer is effectively an infinite value per I.366.1.')
cpIwfPotsPortTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 3), )
if mibBuilder.loadTexts: cpIwfPotsPortTable.setStatus('current')
if mibBuilder.loadTexts: cpIwfPotsPortTable.setDescription('This table contains information on the configuration of the POTS ports on the CP-IWF in addition to the information contained in the ifTable about the physical interfaces to which the CP-IWF POTS ports are peering with currently.')
cpIwfPotsPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 3, 1), ).setIndexNames((0, "CPIWF-MIB", "potsPortNumber"))
if mibBuilder.loadTexts: cpIwfPotsPortEntry.setStatus('current')
if mibBuilder.loadTexts: cpIwfPotsPortEntry.setDescription('An entry in the cpIwfPotsPortTable that represents a single POTS port.')
potsPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 3, 1, 1), Integer32())
if mibBuilder.loadTexts: potsPortNumber.setStatus('current')
if mibBuilder.loadTexts: potsPortNumber.setDescription('The number identifying the POTS user port on the CP-IWF.')
potsPhysicalPort = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 3, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: potsPhysicalPort.setStatus('current')
if mibBuilder.loadTexts: potsPhysicalPort.setDescription('This has the value of the ifIndex of the ifEntry of the physical POTS port to which this CP-IWF POTS port is connected. The value of (0) has the special meaning that this POTS port is not connected to any physical port on the LES device.')
aal2ChannelId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aal2ChannelId.setStatus('current')
if mibBuilder.loadTexts: aal2ChannelId.setDescription("The CID of the AAL2 connection transporting this port's traffic over the AAL2 VCC. When the aal2ApplicationIdentifier indicates the presence of ELCP, this object should not be used for CID allocation and the value of this object is not applicable. In addition, if an SNMP operation is attempted on this object, an SNMP response with error status of badValue (3) should be returned.")
potsPortTestType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("codecLoopback", 2), ("aal2Loopback", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: potsPortTestType.setStatus('current')
if mibBuilder.loadTexts: potsPortTestType.setDescription("This object is used to specify the type of test to run for POTS ports. There are no results stored locally for a loopback test. The tests involve looping back the media stream at either the codec (PCM loopback) or the AAL2 layer (CPS loopback). In order to run these tests, the CO-IWF must first set the value of this object appropriate to the test that needs to be run. The CO-IWF should then set the value of ifAdminStatus in the corresponding ifEntry to 'testing'. The CO-IWF should verify that the test is in progress by checking that the value of ifOperStatus in the corresponding ifEntry is equal to 'testing'. Once testing is complete the CO-IWF must set the ifAdminStatus to a value other than 'testing'. Note that the LES device must not allow a CO-IWF to manipulate the ifAdminStatus of physical user ports that do not belong to its managed CP-IWF.")
signalingMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("loopStart", 1), ("loopReverseBattery", 2), ("groundStart", 3), ("ddiPbxStart", 4))).clone('loopStart')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: signalingMethod.setStatus('current')
if mibBuilder.loadTexts: signalingMethod.setDescription('The signalling method to use for this user port.')
potsPortLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 3, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: potsPortLabel.setStatus('current')
if mibBuilder.loadTexts: potsPortLabel.setDescription('Label assigned by service provider to identify this CP-IWF port. For example, may be used to hold Directory Number.')
cpIwfIsdnBriPortTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 4), )
if mibBuilder.loadTexts: cpIwfIsdnBriPortTable.setStatus('current')
if mibBuilder.loadTexts: cpIwfIsdnBriPortTable.setDescription('This table contains information on the configuration of the ISDN BRI ports on the CP-IWF in addition to the information contained in the ifTable about the physical interfaces to which the CP-IWF ports are peering with currently.')
cpIwfIsdnBriPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 4, 1), ).setIndexNames((0, "CPIWF-MIB", "isdnBriPortNumber"))
if mibBuilder.loadTexts: cpIwfIsdnBriPortEntry.setStatus('current')
if mibBuilder.loadTexts: cpIwfIsdnBriPortEntry.setDescription('An entry in the cpIwfIsdnBriPortTable that represents a single ISDN BRI port.')
isdnBriPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 4, 1, 1), Integer32())
if mibBuilder.loadTexts: isdnBriPortNumber.setStatus('current')
if mibBuilder.loadTexts: isdnBriPortNumber.setDescription(' The number identifying the ISDN BRI user port on the CP-IWF.')
isdnBriPhysicalPort = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 4, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnBriPhysicalPort.setStatus('current')
if mibBuilder.loadTexts: isdnBriPhysicalPort.setDescription('This has the value of the ifIndex of the ifEntry of the physical ISDN BRI port to which this CP-IWF ISDN BRI port is connected. The value of (0) has the special meaning that this ISDN BRI port is not connected to any physical port on the LES device.')
aal2ChannelIdD = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aal2ChannelIdD.setStatus('current')
if mibBuilder.loadTexts: aal2ChannelIdD.setDescription('The CID of the AAL2 connection transporting the D channel of this ISDN BRI port over the AAL2 VCC. The default value of this object is determined by the formula defined in af-vmoa-0145.000 section 4.4.2. When the aal2ApplicationIdentifier indicates the presence of ELCP, this object should not be used for CID allocation and the value of this object is not applicable. In addition, if an SNMP operation is attempted on this object, an SNMP response with error status of badValue (3) should be returned.')
aal2ChannelIdB1 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aal2ChannelIdB1.setStatus('current')
if mibBuilder.loadTexts: aal2ChannelIdB1.setDescription('The CID of the AAL2 connection transporting the B1 channel of this ISDN BRI port over the AAL2 VCC. The default value of this object is determined by the formula defined in af-vmoa-0145.000 section 4.4.2. When the aal2ApplicationIdentifier indicates the presence of ELCP, this object should not be used for CID allocation and the value of this object is not applicable. In addition, if an SNMP operation is attempted on this object, an SNMP response with error status of badValue (3) should be returned.')
aal2ChannelIdB2 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 4, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aal2ChannelIdB2.setStatus('current')
if mibBuilder.loadTexts: aal2ChannelIdB2.setDescription('The CID of the AAL2 connection transporting the B2 channel of this ISDN BRI port over the AAL2 VCC. The default value of this object is determined by the formula defined in af-vmoa-0145.000 section 4.4.2. When the aal2ApplicationIdentifier indicates the presence of ELCP, this object should not be used for CID allocation and the value this object is not applicable. In addition, if an SNMP operation is attempted on this object, an SNMP response with error status of badValue (3) should be returned.')
isdnBriPortLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 4, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnBriPortLabel.setStatus('current')
if mibBuilder.loadTexts: isdnBriPortLabel.setDescription('Label assigned by service provider to identify this CP-IWF port. For example, may be used to hold Directory Number.')
isdnBriPortTestType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 4, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("physicalPortLoopback", 1), ("dChannelPhysicalPortLoopback", 2), ("b1ChannelPhysicalPortLoopback", 3), ("b2ChannelPhysicalPortLoopback", 4), ("dChannelAal2Loopback", 5), ("b1ChannelAal2Loopback", 6), ("b2ChannelAal2Loopback", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnBriPortTestType.setStatus('current')
if mibBuilder.loadTexts: isdnBriPortTestType.setDescription("This object is used to specify the type of test to run for ISDN-BRI ports. There are no results stored locally for a loopback test. Loopback of the whole ISDN-BRI physical user port is supported where all the D, B1 and B2 channels are looped back simultaneously, along with individual loopback of the D, B1 and B2 channels. AAL2 Loopback is also supported on a per sub-channel basis. In order to run these tests, the CO-IWF must first set the value of this object appropriate to the test that needs to be run. The CO-IWF should then set the value of ifAdminStatus in the corresponding ifEntry to 'testing'. The CO-IWF should verify that the test is in progress by checking that the value of ifOperStatus in the corresponding ifEntry is equal to 'testing'. Once testing is complete the CO-IWF must set the ifAdminStatus to a value other than 'testing'. Note that the LES device must not allow a CO-IWF to manipulate the ifAdminStatus of physical user ports that do not belong to its managed CP-IWF.")
cpIwfAal2Stats = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 6))
aal2CpsInPkts = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 6, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aal2CpsInPkts.setStatus('current')
if mibBuilder.loadTexts: aal2CpsInPkts.setDescription('Number of CPS packets received')
aal2CpsOutPkts = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 6, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aal2CpsOutPkts.setStatus('current')
if mibBuilder.loadTexts: aal2CpsOutPkts.setDescription('Number of CPS packets transmitted')
aal2CpsParityErrors = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 6, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aal2CpsParityErrors.setStatus('current')
if mibBuilder.loadTexts: aal2CpsParityErrors.setDescription('Number of errors encountered as specified in Table 6/I.363.2 (errnum = 0)')
aal2CpsSeqNumErrors = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 6, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aal2CpsSeqNumErrors.setStatus('current')
if mibBuilder.loadTexts: aal2CpsSeqNumErrors.setDescription('Number of errors encountered as specified in Table 6/I.363.2 (errnum = 1)')
aal2CpsOsfMismatchErrors = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 6, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aal2CpsOsfMismatchErrors.setStatus('current')
if mibBuilder.loadTexts: aal2CpsOsfMismatchErrors.setDescription('Number of errors encountered as specified in Table 6/I.363.2 (errnum = 2)')
aal2CpsOsfErrors = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 6, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aal2CpsOsfErrors.setStatus('current')
if mibBuilder.loadTexts: aal2CpsOsfErrors.setDescription('Number of errors encountered as specified in Table 6/I.363.2 (errnum = 3)')
aal2CpsHecErrors = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 6, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aal2CpsHecErrors.setStatus('current')
if mibBuilder.loadTexts: aal2CpsHecErrors.setDescription('Number of errors encountered as specified in Table 6/I.363.2 (errnum = 4)')
aal2CpsOversizedSduErrors = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 6, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aal2CpsOversizedSduErrors.setStatus('current')
if mibBuilder.loadTexts: aal2CpsOversizedSduErrors.setDescription('Number of errors encountered as specified in Table 6/I.363.2 (errnum = 5)')
aal2CpsReassemblyErrors = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 6, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aal2CpsReassemblyErrors.setStatus('current')
if mibBuilder.loadTexts: aal2CpsReassemblyErrors.setDescription('Number of errors encountered as specified in Table 6/I.363.2 (errnum = 6)')
aal2CpsHecOverlapErrors = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 6, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aal2CpsHecOverlapErrors.setStatus('current')
if mibBuilder.loadTexts: aal2CpsHecOverlapErrors.setDescription('Number of errors encountered as specified in Table 6/I.363.2 (errnum = 7)')
aal2CpsUuiErrors = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 6, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aal2CpsUuiErrors.setStatus('current')
if mibBuilder.loadTexts: aal2CpsUuiErrors.setDescription('Number of errors encountered as specified in Table 6/I.363.2 (errnum = 8)')
aal2CpsCidErrors = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 6, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aal2CpsCidErrors.setStatus('current')
if mibBuilder.loadTexts: aal2CpsCidErrors.setDescription('Number of errors encountered as specified in Table 6/I.363.2 (errnum = 9)')
aal2SscsOversizedSssarSduErrors = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 6, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aal2SscsOversizedSssarSduErrors.setStatus('current')
if mibBuilder.loadTexts: aal2SscsOversizedSssarSduErrors.setDescription('Number of errors encountered as specified in Table 3/I.366.1 (errnum = 10)')
aal2SscsSssarRasTimerExpiryErrors = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 6, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aal2SscsSssarRasTimerExpiryErrors.setStatus('current')
if mibBuilder.loadTexts: aal2SscsSssarRasTimerExpiryErrors.setDescription('Number of errors encountered as specified in Table 3/I.366.1 (errnum = 11)')
aal2SscsUndersizedSstedPduErrors = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 6, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aal2SscsUndersizedSstedPduErrors.setStatus('current')
if mibBuilder.loadTexts: aal2SscsUndersizedSstedPduErrors.setDescription('Number of errors encountered as specified in Table 5/I.366.1 (errnum = 20)')
aal2SscsSstedPduLengthMismatchErrors = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 6, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aal2SscsSstedPduLengthMismatchErrors.setStatus('current')
if mibBuilder.loadTexts: aal2SscsSstedPduLengthMismatchErrors.setDescription('Number of errors encountered as specified in Table 5/I.366.1 (errnum = 21)')
aal2SscsSstedCrcMismatchErrors = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 6, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aal2SscsSstedCrcMismatchErrors.setStatus('current')
if mibBuilder.loadTexts: aal2SscsSstedCrcMismatchErrors.setDescription('Number of errors encountered as specified in Table 5/I.366.1 (errnum = 22)')
cpIwfPotsPortStatsTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 7), )
if mibBuilder.loadTexts: cpIwfPotsPortStatsTable.setStatus('current')
if mibBuilder.loadTexts: cpIwfPotsPortStatsTable.setDescription('This table contains performance statistics pertinent to POTS ports respectively in addition to the information contained in the ifTable about the physical interfaces to which the CP-IWF ports are peering with currently')
cpIwfPotsPortStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 7, 1), ).setIndexNames((0, "CPIWF-MIB", "potsPortNumber"))
if mibBuilder.loadTexts: cpIwfPotsPortStatsEntry.setStatus('current')
if mibBuilder.loadTexts: cpIwfPotsPortStatsEntry.setDescription('An entry in the cpIwfPotsPortStatsTable that represents statistics for a single POTS port.')
cpIwfPotsPortActiveSeconds = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 7, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpIwfPotsPortActiveSeconds.setStatus('current')
if mibBuilder.loadTexts: cpIwfPotsPortActiveSeconds.setDescription('Total length of time the AAL2 channel associated with this port has been active, in seconds.')
cpIwfPotsPortFillerOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 7, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpIwfPotsPortFillerOctets.setStatus('current')
if mibBuilder.loadTexts: cpIwfPotsPortFillerOctets.setDescription('Total number of PCM filler octets injected into active media stream on this port due to playout buffer underflow.')
cpIwfPotsPortDroppedOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 7, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpIwfPotsPortDroppedOctets.setStatus('current')
if mibBuilder.loadTexts: cpIwfPotsPortDroppedOctets.setDescription('Total number of PCM payload octets dropped due to buffer overflow at this port. Octets that are dropped because they arrived late, and which have already been substituted by filler PCM octets, shall not be counted.')
cpIwfIsdnBriPortStatsTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 8), )
if mibBuilder.loadTexts: cpIwfIsdnBriPortStatsTable.setStatus('current')
if mibBuilder.loadTexts: cpIwfIsdnBriPortStatsTable.setDescription('This table contains performance statistics pertinent to ISDN BRI ports respectively in addition to the information contained in the ifTable about the physical interfaces to which the CP-IWF ports are peering with currently')
cpIwfIsdnBriPortStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 8, 1), ).setIndexNames((0, "CPIWF-MIB", "isdnBriPortNumber"))
if mibBuilder.loadTexts: cpIwfIsdnBriPortStatsEntry.setStatus('current')
if mibBuilder.loadTexts: cpIwfIsdnBriPortStatsEntry.setDescription('An entry in the cpIwfIsdnBriPortStatsTable that represents statistics for a single ISDN BRI port.')
cpIwfIsdnBriPortB1ActiveSeconds = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 8, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpIwfIsdnBriPortB1ActiveSeconds.setStatus('current')
if mibBuilder.loadTexts: cpIwfIsdnBriPortB1ActiveSeconds.setDescription('Total length of time the AAL2 channel associated with this port/channel has been active, in seconds.')
cpIwfIsdnBriPortB1FillerOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 8, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpIwfIsdnBriPortB1FillerOctets.setStatus('current')
if mibBuilder.loadTexts: cpIwfIsdnBriPortB1FillerOctets.setDescription('Total number of PCM filler octets injected into active media stream on this port/channel due to playout buffer underflow.')
cpIwfIsdnBriPortB1DroppedOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 8, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpIwfIsdnBriPortB1DroppedOctets.setStatus('current')
if mibBuilder.loadTexts: cpIwfIsdnBriPortB1DroppedOctets.setDescription('Total number of PCM payload octets dropped due to buffer overflow on this port/channel. Octets that are dropped because they arrived late, and which have already been substituted by filler PCM octets, shall not be counted.')
cpIwfIsdnBriPortB2ActiveSeconds = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 8, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpIwfIsdnBriPortB2ActiveSeconds.setStatus('current')
if mibBuilder.loadTexts: cpIwfIsdnBriPortB2ActiveSeconds.setDescription('Total length of time the AAL2 channel associated with this port/channel has been active, in seconds.')
cpIwfIsdnBriPortB2FillerOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 8, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpIwfIsdnBriPortB2FillerOctets.setStatus('current')
if mibBuilder.loadTexts: cpIwfIsdnBriPortB2FillerOctets.setDescription('Total number of PCM filler octets injected into active media stream on this port/channel due to playout buffer underflow.')
cpIwfIsdnBriPortB2DroppedOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 8, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpIwfIsdnBriPortB2DroppedOctets.setStatus('current')
if mibBuilder.loadTexts: cpIwfIsdnBriPortB2DroppedOctets.setDescription('Total number of PCM payload octets dropped due to buffer overflow on this port/channel. Octets that are dropped because they arrived late, and which have already been substituted by filler PCM octets, shall not be counted.')
cpIwfMIBNotificationPrefix = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 2, 0))
cpIwfInsufficientPhysicalBandwidth = NotificationType((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 2, 0, 1)).setObjects(("CPIWF-MIB", "cpIwfUpstreamPhysicalBandwidth"), ("CPIWF-MIB", "cpIwfDownstreamPhysicalBandwidth"))
if mibBuilder.loadTexts: cpIwfInsufficientPhysicalBandwidth.setStatus('current')
if mibBuilder.loadTexts: cpIwfInsufficientPhysicalBandwidth.setDescription('This trap is generated when the physical layer bandwidth in either direction drops below the currently configured AAL2 VCC bandwidth.')
cpIwfUpstreamPhysicalBandwidth = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 9), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpIwfUpstreamPhysicalBandwidth.setStatus('current')
if mibBuilder.loadTexts: cpIwfUpstreamPhysicalBandwidth.setDescription('This object defines the new physical bandwidth in the upstream direction of the CP-IWF.')
cpIwfDownstreamPhysicalBandwidth = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 10), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpIwfDownstreamPhysicalBandwidth.setStatus('current')
if mibBuilder.loadTexts: cpIwfDownstreamPhysicalBandwidth.setDescription('This object defines the new physical bandwidth in the downstream direction of the CP-IWF.')
cpIwfExcessImpairment = NotificationType((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 2, 0, 2)).setObjects(("CPIWF-MIB", "cpIwfImpairmentPortType"), ("CPIWF-MIB", "cpIwfPortNumber"))
if mibBuilder.loadTexts: cpIwfExcessImpairment.setStatus('current')
if mibBuilder.loadTexts: cpIwfExcessImpairment.setDescription('This trap is generated when the number of impairments on any POTS port or ISDN BRI port/channel, measured as the sum of fillerOctets and droppedOctets on that port, in any given interval of cpIwfImpairmentInterval minutes, is equal to or greater than the value of cpIwfImpairmentThreshold. If the value of cpIwfImpairmentThreshold is zero, then this trap is never generated.')
cpIwfImpairmentPortType = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("pots", 1), ("isdnBriB1", 2), ("isdnBriB2", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpIwfImpairmentPortType.setStatus('current')
if mibBuilder.loadTexts: cpIwfImpairmentPortType.setDescription('This object is used within the cpIwfExcessImpairment Trap and identifies the type of the CP-IWF port on which the excess impairments event occurred.')
cpIwfPortNumber = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 240))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpIwfPortNumber.setStatus('current')
if mibBuilder.loadTexts: cpIwfPortNumber.setDescription('This object is used within traps to identify the port number to which the trap refers. The range of values this object can take is dependent on port type and is defined in af-vmoa-0145.000 section 4.4.2')
cpIwfMIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 3))
cpIwfMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 3, 1))
cpIwfMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 3, 2))
cpIwfMIBCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 3, 1, 1)).setObjects(("CPIWF-MIB", "cpIwfGeneralGroup"), ("CPIWF-MIB", "cpIwfNotificationsGroup"), ("CPIWF-MIB", "cpIwfAal2ConfigGroup"), ("CPIWF-MIB", "cpIwfAal2StatsGroup"), ("CPIWF-MIB", "cpIwfPotsPortConfigGroup"), ("CPIWF-MIB", "cpIwfPotsPortStatsGroup"), ("CPIWF-MIB", "cpIwfIsdnBriPortConfigGroup"), ("CPIWF-MIB", "cpIwfIsdnBriPortStatsGroup"), ("CPIWF-MIB", "cpIwfPotsPortCidConfigGroup"), ("CPIWF-MIB", "cpIwfIsdnBriPortCidConfigGroup"), ("CPIWF-MIB", "cpIwfElcpPstnGroup"), ("CPIWF-MIB", "cpIwfPlayoutBufferGroup"), ("CPIWF-MIB", "cpIwfImpairmentNotificationsGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cpIwfMIBCompliance = cpIwfMIBCompliance.setStatus('current')
if mibBuilder.loadTexts: cpIwfMIBCompliance.setDescription('The compliance statement for SNMP entities that support LES as specified in af-vmoa-0145.000 of the ATM Forum. Note the Trap types and associated MIB objects defined in this MIB are required implementations to claim conformance to this MIB. For a host to conform to this MIB it must also implement: - The System Group from RFC 1213 - ifTable and ifXTable from RFC 2863. See section 6 of this specification for interpretations of the ifTable and ifXTable objects as they apply to LES.')
cpIwfGeneralGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 3, 2, 1)).setObjects(("CPIWF-MIB", "cpIwfVpi"), ("CPIWF-MIB", "cpIwfVci"), ("CPIWF-MIB", "cpIwfTimingReference"), ("CPIWF-MIB", "cpIwfEchoCancellationSupport"), ("CPIWF-MIB", "cpIwfAdminStatus"), ("CPIWF-MIB", "cpIwfOperStatus"), ("CPIWF-MIB", "cpIwfRestart"), ("CPIWF-MIB", "cpIwfTestType"), ("CPIWF-MIB", "cpIwfTestResult"), ("CPIWF-MIB", "cpIwfTestResultText"), ("CPIWF-MIB", "cpIwfMwdForRestart"), ("CPIWF-MIB", "cpIwfEocBandwidth"), ("CPIWF-MIB", "cpIwfCurrentConfig"), ("CPIWF-MIB", "cpIwfTrapGeneration"), ("CPIWF-MIB", "cpIwfVendorName"), ("CPIWF-MIB", "cpIwfDeviceType"), ("CPIWF-MIB", "cpIwfHardwareVersion"), ("CPIWF-MIB", "cpIwfSoftwareVersion"), ("CPIWF-MIB", "cpIwfUpstreamPhysicalBandwidth"), ("CPIWF-MIB", "cpIwfDownstreamPhysicalBandwidth"), ("CPIWF-MIB", "cpIwfPortNumber"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cpIwfGeneralGroup = cpIwfGeneralGroup.setStatus('current')
if mibBuilder.loadTexts: cpIwfGeneralGroup.setDescription('A collection of objects required to manage the CP-IWF as a whole')
cpIwfAal2ConfigGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 3, 2, 2)).setObjects(("CPIWF-MIB", "aal2ApplicationIdentifier"), ("CPIWF-MIB", "aal2CpsMaxMultiplexedChannels"), ("CPIWF-MIB", "aal2CpsMaxSDULength"), ("CPIWF-MIB", "aal2CpsCIDLowerLimit"), ("CPIWF-MIB", "aal2CpsCIDUpperLimit"), ("CPIWF-MIB", "aal2CpsOptimisation"), ("CPIWF-MIB", "aal2CpsTimerCuValue"), ("CPIWF-MIB", "aal2SscsMaxSssarSduLength"), ("CPIWF-MIB", "aal2SscsFaxDemodulationTransport"), ("CPIWF-MIB", "aal2SscsDtmfDigitPacketTransport"), ("CPIWF-MIB", "aal2SscsPcmEncoding"), ("CPIWF-MIB", "aal2SscsProfileSource"), ("CPIWF-MIB", "aal2SscsPredefinedProfileIdentifier"), ("CPIWF-MIB", "aal2SscsIeeeOui"), ("CPIWF-MIB", "aal2SscsSsSarAssemblyTimerValue"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cpIwfAal2ConfigGroup = cpIwfAal2ConfigGroup.setStatus('current')
if mibBuilder.loadTexts: cpIwfAal2ConfigGroup.setDescription('A collection of objects describing the configuration of the AAL2 layer specific to LES')
cpIwfPotsPortConfigGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 3, 2, 3)).setObjects(("CPIWF-MIB", "cpIwfNumPotsPorts"), ("CPIWF-MIB", "cpIwfPotsPortEncodingSelectionMode"), ("CPIWF-MIB", "potsPhysicalPort"), ("CPIWF-MIB", "potsPortTestType"), ("CPIWF-MIB", "signalingMethod"), ("CPIWF-MIB", "potsPortLabel"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cpIwfPotsPortConfigGroup = cpIwfPotsPortConfigGroup.setStatus('current')
if mibBuilder.loadTexts: cpIwfPotsPortConfigGroup.setDescription('A collection of objects describing the configuration of the POTS ports on a CP-IWF.')
cpIwfIsdnBriPortConfigGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 3, 2, 4)).setObjects(("CPIWF-MIB", "cpIwfNumIsdnBriPorts"), ("CPIWF-MIB", "cpIwfIsdnBriPortEncodingSelectionMode"), ("CPIWF-MIB", "isdnBriPhysicalPort"), ("CPIWF-MIB", "isdnBriPortLabel"), ("CPIWF-MIB", "isdnBriPortTestType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cpIwfIsdnBriPortConfigGroup = cpIwfIsdnBriPortConfigGroup.setStatus('current')
if mibBuilder.loadTexts: cpIwfIsdnBriPortConfigGroup.setDescription('A collection of objects describing the configuration of the ISDN BRI ports on a CP-IWF.')
cpIwfPotsPortCidConfigGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 3, 2, 5)).setObjects(("CPIWF-MIB", "aal2ChannelId"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cpIwfPotsPortCidConfigGroup = cpIwfPotsPortCidConfigGroup.setStatus('current')
if mibBuilder.loadTexts: cpIwfPotsPortCidConfigGroup.setDescription('Object describing the static CID allocation to a user-side POTS termination. This object is required when ELCP is not used as a mechanism for CID allocation.')
cpIwfIsdnBriPortCidConfigGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 3, 2, 6)).setObjects(("CPIWF-MIB", "aal2ChannelIdD"), ("CPIWF-MIB", "aal2ChannelIdB1"), ("CPIWF-MIB", "aal2ChannelIdB2"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cpIwfIsdnBriPortCidConfigGroup = cpIwfIsdnBriPortCidConfigGroup.setStatus('current')
if mibBuilder.loadTexts: cpIwfIsdnBriPortCidConfigGroup.setDescription('A collection of objects describing the static CID allocations to the D, B1 and B2 channels of a user-side ISDN-BRI termination. These objects are required when ELCP is not used as a mechanism for CID allocation.')
cpIwfAal2StatsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 3, 2, 7)).setObjects(("CPIWF-MIB", "aal2CpsInPkts"), ("CPIWF-MIB", "aal2CpsOutPkts"), ("CPIWF-MIB", "aal2CpsParityErrors"), ("CPIWF-MIB", "aal2CpsSeqNumErrors"), ("CPIWF-MIB", "aal2CpsOsfMismatchErrors"), ("CPIWF-MIB", "aal2CpsOsfErrors"), ("CPIWF-MIB", "aal2CpsHecOverlapErrors"), ("CPIWF-MIB", "aal2CpsHecErrors"), ("CPIWF-MIB", "aal2CpsOversizedSduErrors"), ("CPIWF-MIB", "aal2CpsReassemblyErrors"), ("CPIWF-MIB", "aal2CpsUuiErrors"), ("CPIWF-MIB", "aal2CpsCidErrors"), ("CPIWF-MIB", "aal2SscsOversizedSssarSduErrors"), ("CPIWF-MIB", "aal2SscsSssarRasTimerExpiryErrors"), ("CPIWF-MIB", "aal2SscsUndersizedSstedPduErrors"), ("CPIWF-MIB", "aal2SscsSstedPduLengthMismatchErrors"), ("CPIWF-MIB", "aal2SscsSstedCrcMismatchErrors"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cpIwfAal2StatsGroup = cpIwfAal2StatsGroup.setStatus('current')
if mibBuilder.loadTexts: cpIwfAal2StatsGroup.setDescription('These objects provide statistics on the AAL2 layer')
cpIwfPotsPortStatsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 3, 2, 8)).setObjects(("CPIWF-MIB", "cpIwfPotsPortActiveSeconds"), ("CPIWF-MIB", "cpIwfPotsPortFillerOctets"), ("CPIWF-MIB", "cpIwfPotsPortDroppedOctets"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cpIwfPotsPortStatsGroup = cpIwfPotsPortStatsGroup.setStatus('current')
if mibBuilder.loadTexts: cpIwfPotsPortStatsGroup.setDescription('These objects provide statistics on the POTS ports')
cpIwfIsdnBriPortStatsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 3, 2, 9)).setObjects(("CPIWF-MIB", "cpIwfIsdnBriPortB1ActiveSeconds"), ("CPIWF-MIB", "cpIwfIsdnBriPortB1FillerOctets"), ("CPIWF-MIB", "cpIwfIsdnBriPortB1DroppedOctets"), ("CPIWF-MIB", "cpIwfIsdnBriPortB2ActiveSeconds"), ("CPIWF-MIB", "cpIwfIsdnBriPortB2FillerOctets"), ("CPIWF-MIB", "cpIwfIsdnBriPortB2DroppedOctets"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cpIwfIsdnBriPortStatsGroup = cpIwfIsdnBriPortStatsGroup.setStatus('current')
if mibBuilder.loadTexts: cpIwfIsdnBriPortStatsGroup.setDescription('These objects provide statistics on the ISDN BRI ports')
cpIwfElcpPstnGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 3, 2, 10)).setObjects(("CPIWF-MIB", "cpIwfV5PSTNProtocolVariant"), ("CPIWF-MIB", "cpIwfElcpAndPstnChannelBandwidth"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cpIwfElcpPstnGroup = cpIwfElcpPstnGroup.setStatus('current')
if mibBuilder.loadTexts: cpIwfElcpPstnGroup.setDescription('Objects for setting the V5 PSTN protocol variant and the maximum bandwidth to be used for transmission of PSTN or ELCP messages.')
cpIwfPlayoutBufferGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 3, 2, 11)).setObjects(("CPIWF-MIB", "cpIwfPlayoutBufferDepth"), ("CPIWF-MIB", "cpIwfImpairmentInterval"), ("CPIWF-MIB", "cpIwfImpairmentThreshold"), ("CPIWF-MIB", "cpIwfImpairmentPortType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cpIwfPlayoutBufferGroup = cpIwfPlayoutBufferGroup.setStatus('current')
if mibBuilder.loadTexts: cpIwfPlayoutBufferGroup.setDescription('A collection of objects used for configuring the playout buffer depth and to detect impairments to do incorrect setting of this buffer depth.')
cpIwfNotificationsGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 3, 2, 12)).setObjects(("CPIWF-MIB", "cpIwfInsufficientPhysicalBandwidth"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cpIwfNotificationsGroup = cpIwfNotificationsGroup.setStatus('current')
if mibBuilder.loadTexts: cpIwfNotificationsGroup.setDescription('The notification(s) which a CP-IWF is required to implement')
cpIwfImpairmentNotificationsGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 353, 5, 10, 1, 3, 2, 13)).setObjects(("CPIWF-MIB", "cpIwfExcessImpairment"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cpIwfImpairmentNotificationsGroup = cpIwfImpairmentNotificationsGroup.setStatus('current')
if mibBuilder.loadTexts: cpIwfImpairmentNotificationsGroup.setDescription('This group specifies the notification used to inform the CO-IWF of impairments due to incorrect playout buffer depth, or corruption or loss of AAL2 packets by the network.')
mibBuilder.exportSymbols("CPIWF-MIB", atmForum=atmForum, cpIwfVendorName=cpIwfVendorName, cpIwfPotsPortEntry=cpIwfPotsPortEntry, cpIwfMIBNotifications=cpIwfMIBNotifications, cpIwfV5PSTNProtocolVariant=cpIwfV5PSTNProtocolVariant, cpIwfImpairmentInterval=cpIwfImpairmentInterval, aal2CpsParityErrors=aal2CpsParityErrors, aal2CpsInPkts=aal2CpsInPkts, aal2SscsMaxSssarSduLength=aal2SscsMaxSssarSduLength, PYSNMP_MODULE_ID=cpIwfMIB, cpIwfMIBNotificationPrefix=cpIwfMIBNotificationPrefix, cpIwfIsdnBriPortB2FillerOctets=cpIwfIsdnBriPortB2FillerOctets, cpIwfIsdnBriPortStatsTable=cpIwfIsdnBriPortStatsTable, cpIwfPortNumber=cpIwfPortNumber, potsPortTestType=potsPortTestType, aal2SscsDtmfDigitPacketTransport=aal2SscsDtmfDigitPacketTransport, cpIwfAal2StatsGroup=cpIwfAal2StatsGroup, aal2SscsProfileSource=aal2SscsProfileSource, cpIwfPotsPortConfigGroup=cpIwfPotsPortConfigGroup, cpIwfTestResult=cpIwfTestResult, aal2SscsSsSarAssemblyTimerValue=aal2SscsSsSarAssemblyTimerValue, cpIwfIsdnBriPortB1FillerOctets=cpIwfIsdnBriPortB1FillerOctets, cpIwfIsdnBriPortCidConfigGroup=cpIwfIsdnBriPortCidConfigGroup, atmForumNetworkManagement=atmForumNetworkManagement, atmfLoopEmulationService=atmfLoopEmulationService, aal2SscsSssarRasTimerExpiryErrors=aal2SscsSssarRasTimerExpiryErrors, cpIwfIsdnBriPortB1ActiveSeconds=cpIwfIsdnBriPortB1ActiveSeconds, cpIwfIsdnBriPortStatsEntry=cpIwfIsdnBriPortStatsEntry, cpIwfUpstreamPhysicalBandwidth=cpIwfUpstreamPhysicalBandwidth, cpIwfElcpPstnGroup=cpIwfElcpPstnGroup, aal2CpsReassemblyErrors=aal2CpsReassemblyErrors, cpIwfPotsPortStatsGroup=cpIwfPotsPortStatsGroup, aal2CpsOversizedSduErrors=aal2CpsOversizedSduErrors, cpIwfNotificationsGroup=cpIwfNotificationsGroup, cpIwfNumPotsPorts=cpIwfNumPotsPorts, aal2SscsPcmEncoding=aal2SscsPcmEncoding, aal2ChannelId=aal2ChannelId, isdnBriPortTestType=isdnBriPortTestType, cpIwfIsdnBriPortTable=cpIwfIsdnBriPortTable, aal2CpsOsfMismatchErrors=aal2CpsOsfMismatchErrors, cpIwf=cpIwf, aal2CpsOutPkts=aal2CpsOutPkts, cpIwfMwdForRestart=cpIwfMwdForRestart, cpIwfPotsPortStatsTable=cpIwfPotsPortStatsTable, aal2SscsFaxDemodulationTransport=aal2SscsFaxDemodulationTransport, cpIwfNumIsdnBriPorts=cpIwfNumIsdnBriPorts, cpIwfEocBandwidth=cpIwfEocBandwidth, aal2CpsHecErrors=aal2CpsHecErrors, cpIwfAdminStatus=cpIwfAdminStatus, cpIwfMIBObjects=cpIwfMIBObjects, cpIwfIsdnBriPortConfigGroup=cpIwfIsdnBriPortConfigGroup, cpIwfRestart=cpIwfRestart, potsPhysicalPort=potsPhysicalPort, isdnBriPortLabel=isdnBriPortLabel, cpIwfVci=cpIwfVci, aal2CpsSeqNumErrors=aal2CpsSeqNumErrors, aal2SscsIeeeOui=aal2SscsIeeeOui, cpIwfIsdnBriPortB2ActiveSeconds=cpIwfIsdnBriPortB2ActiveSeconds, cpIwfPotsPortCidConfigGroup=cpIwfPotsPortCidConfigGroup, cpIwfMIBCompliances=cpIwfMIBCompliances, potsPortLabel=potsPortLabel, cpIwfIsdnBriPortEntry=cpIwfIsdnBriPortEntry, cpIwfPotsPortTable=cpIwfPotsPortTable, cpIwfVpi=cpIwfVpi, cpIwfPotsPortEncodingSelectionMode=cpIwfPotsPortEncodingSelectionMode, aal2CpsCIDLowerLimit=aal2CpsCIDLowerLimit, aal2ChannelIdB2=aal2ChannelIdB2, cpIwfAal2Stats=cpIwfAal2Stats, potsPortNumber=potsPortNumber, isdnBriPhysicalPort=isdnBriPhysicalPort, cpIwfHardwareVersion=cpIwfHardwareVersion, cpIwfImpairmentPortType=cpIwfImpairmentPortType, aal2CpsCidErrors=aal2CpsCidErrors, aal2ChannelIdD=aal2ChannelIdD, cpIwfAal2ConfigGroup=cpIwfAal2ConfigGroup, cpIwfEchoCancellationSupport=cpIwfEchoCancellationSupport, aal2SscsSstedPduLengthMismatchErrors=aal2SscsSstedPduLengthMismatchErrors, cpIwfMIBConformance=cpIwfMIBConformance, cpIwfMIBCompliance=cpIwfMIBCompliance, aal2CpsMaxMultiplexedChannels=aal2CpsMaxMultiplexedChannels, cpIwfDownstreamPhysicalBandwidth=cpIwfDownstreamPhysicalBandwidth, cpIwfExcessImpairment=cpIwfExcessImpairment, aal2CpsOptimisation=aal2CpsOptimisation, cpIwfDeviceType=cpIwfDeviceType, cpIwfMIBGroups=cpIwfMIBGroups, cpIwfOperStatus=cpIwfOperStatus, aal2ChannelIdB1=aal2ChannelIdB1, cpIwfTimingReference=cpIwfTimingReference, cpIwfInsufficientPhysicalBandwidth=cpIwfInsufficientPhysicalBandwidth, aal2SscsUndersizedSstedPduErrors=aal2SscsUndersizedSstedPduErrors, cpIwfPotsPortFillerOctets=cpIwfPotsPortFillerOctets, aal2ApplicationIdentifier=aal2ApplicationIdentifier, signalingMethod=signalingMethod, cpIwfPotsPortStatsEntry=cpIwfPotsPortStatsEntry, cpIwfIsdnBriPortEncodingSelectionMode=cpIwfIsdnBriPortEncodingSelectionMode, aal2CpsUuiErrors=aal2CpsUuiErrors, aal2SscsOversizedSssarSduErrors=aal2SscsOversizedSssarSduErrors, cpIwfElcpAndPstnChannelBandwidth=cpIwfElcpAndPstnChannelBandwidth, aal2CpsTimerCuValue=aal2CpsTimerCuValue, aal2CpsCIDUpperLimit=aal2CpsCIDUpperLimit, aal2CpsHecOverlapErrors=aal2CpsHecOverlapErrors, cpIwfTestResultText=cpIwfTestResultText, cpIwfPotsPortActiveSeconds=cpIwfPotsPortActiveSeconds, cpIwfPotsPortDroppedOctets=cpIwfPotsPortDroppedOctets, cpIwfTrapGeneration=cpIwfTrapGeneration, cpIwfPlayoutBufferDepth=cpIwfPlayoutBufferDepth, cpIwfImpairmentThreshold=cpIwfImpairmentThreshold, cpIwfGeneralGroup=cpIwfGeneralGroup, cpIwfCurrentConfig=cpIwfCurrentConfig, cpIwfSoftwareVersion=cpIwfSoftwareVersion, cpIwfImpairmentNotificationsGroup=cpIwfImpairmentNotificationsGroup, cpIwfAal2Profile=cpIwfAal2Profile, cpIwfPlayoutBufferGroup=cpIwfPlayoutBufferGroup, cpIwfIsdnBriPortB2DroppedOctets=cpIwfIsdnBriPortB2DroppedOctets, aal2SscsSstedCrcMismatchErrors=aal2SscsSstedCrcMismatchErrors, cpIwfIsdnBriPortStatsGroup=cpIwfIsdnBriPortStatsGroup, cpIwfMIB=cpIwfMIB, aal2SscsPredefinedProfileIdentifier=aal2SscsPredefinedProfileIdentifier, cpIwfTestType=cpIwfTestType, aal2CpsOsfErrors=aal2CpsOsfErrors, aal2CpsMaxSDULength=aal2CpsMaxSDULength, cpIwfIsdnBriPortB1DroppedOctets=cpIwfIsdnBriPortB1DroppedOctets, isdnBriPortNumber=isdnBriPortNumber)

#
# PySNMP MIB module CISCO-LICENSE-MGMT-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCO-LICENSE-MGMT-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:04:30 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ConstraintsIntersection, ValueSizeConstraint, ConstraintsUnion, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ConstraintsIntersection", "ValueSizeConstraint", "ConstraintsUnion", "SingleValueConstraint")
ciscoMgmt, = mibBuilder.importSymbols("CISCO-SMI", "ciscoMgmt")
entPhysicalIndex, PhysicalIndexOrZero = mibBuilder.importSymbols("ENTITY-MIB", "entPhysicalIndex", "PhysicalIndexOrZero")
InetAddress, InetAddressType = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddress", "InetAddressType")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
ModuleCompliance, NotificationGroup, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup", "ObjectGroup")
Gauge32, TimeTicks, IpAddress, NotificationType, MibIdentifier, iso, Counter32, Unsigned32, Integer32, Counter64, MibScalar, MibTable, MibTableRow, MibTableColumn, ModuleIdentity, Bits, ObjectIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "Gauge32", "TimeTicks", "IpAddress", "NotificationType", "MibIdentifier", "iso", "Counter32", "Unsigned32", "Integer32", "Counter64", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ModuleIdentity", "Bits", "ObjectIdentity")
DisplayString, DateAndTime, RowStatus, TextualConvention, TruthValue, StorageType = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "DateAndTime", "RowStatus", "TextualConvention", "TruthValue", "StorageType")
ciscoLicenseMgmtMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 9, 9, 543))
ciscoLicenseMgmtMIB.setRevisions(('2012-04-19 00:00', '2011-04-19 00:00', '2008-11-21 00:00', '2006-10-03 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ciscoLicenseMgmtMIB.setRevisionsDescriptions(('This version of the MIB adds support for Permanent Right to use (RTU) licensing. The revisions are: o Updated clmgmtLicenseType object to support the following new types of license: permanentRightToUse The new module compliance is ciscoLicenseMgmtComplianceRev1.', 'This version of the MIB adds support for Right to use (RTU) licensing. The revisions are: o Added RTU license definition to MIB description above. o Updated clmgmtLicenseType object to support the following new types of license: evalRightToUse rightToUse o Added following objects to clmgmtLicenseInfoTable clmgmtLicensePeriodUsed o Added following objects to clmgmtLicensableFeatureTable clmgmtFeaturePeriodUsed o Added the following notifications clmgmtLicenseEvalRTUTransitionWarning clmgmtLicenseEvalRTUTransition o Added the following conformance groups clmgmtLicenseRTUGroup clmgmtLicenseRTUUsageNotifGroup The new module compliance is ciscoLicenseMgmtComplianceRev1.', 'This version of the MIB adds support for subscription licensing. Subscription licenses provide software enforcement for a licensed feature for a fixed calendar period. The revisions are: o Updated clmgmtLicenseType object to support the following three new types of licenses: paidSubscription evaluationSubscription extensionSubscription o Added following objects to clmgmtLicenseInfoTable clmgmtLicenseStartDate clmgmtLicenseEndDate o Added following objects to clmgmtLicensableFeatureTable clmgmtFeatureStartDate clmgmtFeatureEndDate o Added the following notifications clmgmtLicenseSubscriptionExpiryWarning clmgmtLicenseSubscriptionExtExpiryWarning clmgmtLicenseSubscriptionExpired o Added the following conformance groups clmgmtLicenseSubscriptionGroup clmgmtLicenseSubscriptionUsageNotifGroup The new module compliance is ciscoLicenseMgmtComplianceRev1.', 'Initial version of this MIB module.',))
if mibBuilder.loadTexts: ciscoLicenseMgmtMIB.setLastUpdated('201204190000Z')
if mibBuilder.loadTexts: ciscoLicenseMgmtMIB.setOrganization('Cisco Systems Inc.')
if mibBuilder.loadTexts: ciscoLicenseMgmtMIB.setContactInfo('Cisco Systems Customer Service Postal: 170 W Tasman Drive San Jose, CA 95134 USA Tel: +1 800 553 -NETS E-mail: cs-snmp@cisco.com')
if mibBuilder.loadTexts: ciscoLicenseMgmtMIB.setDescription("The MIB module for managing licenses on the system. The licensing mechanism provides flexibility to enforce licensing for various features in the system. The following text introduces different concepts and terms those are necessary to understand the MIB definition and to perform license management. UDI Universal Device Identifier that uniquely identifies a device. It comprises of product ID, version ID and serial number of the device. NODE LOCKED LICENSE: Node locked licenses are locked to one of the device identifiers in the system. For example, the license can be locked to the UDI value of one of the devices in the system. Locking a license to an UDI guarantees that the license will not be moved to a device with a different UDI. NON-NODE LOCKED LICENSE: Non-node locked licenses are not locked to any device identifier. They can be used on other similar devices. METERED LICENSE: Metered licenses are valid for limited period of time and they expire after that. This period is the usage period of a license and it is not based on real time clock, but system clock. EULA: End User License Agreement. EVALUATION LICENSE: Evaluation licenses are non-node locked metered licenses which are valid only for a limited period. They are used only when there are no permanent, extension or grace period licenses for a feature. User will have to accept EULA (End User License Agreement) before using an evaluation license. Even though they are not node locked, their usage is recorded on the device. RIGHT TO USE (RTU) LICENSE: Right to use license is a non-node locked metered license which is in evaluation mode for a limited time after which it is converted to Right To Use (RTU) license and is valid for the lifetime of the product. User will have to accept EULA (End User License Agreement) before using this license. Even though it is not node locked, usage information is recorded on the device. EXTENSION LICENSE: Extension licenses are node locked metered licenses. These licenses are issued by Cisco's licensing portal. These licenses need to be installed using management interfaces on the device. User will have to accept an EULA as part of installation of extension license. GRACE PERIOD LICENSE: Grace period licenses are node locked metered licenses. These licenses are issued by Cisco's licensing portal as part of the permission ticket to rehost a license. These licenses are installed on the device as part of the rehost operation. User will have to accept an EULA as part of the rehost operation for this type of license. Details on permission ticket, rehost operations are provided further down in this description clause. PERMANENT LICENSE: Permanent licenses are node locked licenses that have no usage period associated with them. These licenses are issued by Cisco's licensing portal. These licenses need to be installed using management interfaces on the device. Once these licenses are installed, they will provide needed permission for the feature/image across different versions. COUNTED LICENSE: Counted licenses limit the number of similar entities that can use the license. For example, a counted license when used by a feature can limit the number of IP phones that can connect or the number of tunnels that can be created. UNCOUNTED LICENSE: Uncounted licenses do not limit the number of similar entities that can use the licenses. License can be enforced at the image level or at the feature level and this MIB module supports both. IMAGE LEVEL LICENSING: A universal image that contains all levels of software packages is loaded on to the device. At boot time, the device determines the highest level of license and brings up the appropriate software features or subsystems. FEATURE LEVEL LICENSING: Feature level licensing will support enforcement of license at individual feature. Features have to check for their licenses before enabling themselves. If it does not have a license, the feature should disable itself. There is a one-to-one relationship between a feature and a license. That is, a feature can use only one license at a time and a license can be used by only one feature at a time. LICENSE LINE: A License line is an atomic set of ASCII characters arranged in a particular format that holds the license for a single feature within it. A line has all the necessary fields and attributes that make it a valid, non-tamper able and complete license. LICENSE FILE: File generated by Cisco licensing portal. It is used to install license on product. It has a user readable part and it contains one or more license lines. DEVICE CREDENTIALS: Device credentials file is a document that is generated by a licensed device. This document establishes the identity of the device and proves that the sender/user has/had authorized access to the device. REHOST: Rehost operation allows a node locked license that is installed on a device to be installed on other similar device. As part of rehost operation, a device processes the permission ticket, revokes the license(s) on the device and generates a rehost ticket as the proof of revocation. This rehost ticket needs to be presented to the Cisco's licensing portal to get the license transferred on to a new similar device. PERMISSION TICKET: Permission ticket is a document generated by Cisco licensing portal that allows a device to rehost its licenses. REHOST TICKET: Rehost ticket is document generated by a device after it has applied a permission ticket. The rehost ticket is a proof of revocation. LICENSING PORTAL: Generates licenses, permission tickets and verifies device credentials and rehost tickets. This MIB module provides MIB objects to install, clear, revoke licenses. It also provides objects to regenerate last rehost ticket, backup all the licenses installed on a device, generate & export EULA for licenses. STEPS TO INSTALL A LICENSE: To install a license, the management application 1. Retrieves device credentials of the device. 2. Communicates with Cisco's licensing portal to get the license file, uses device credentials to identify the device 3. Executes the license install action. STEPS TO CLEAR A LICENSE: To clear a license, the management application 1. Identifies the license to be cleared using license index. 2. Executes the license clear action. STEPS TO REHOST A LICENSE: To rehost a license, the management application 1. Retrieves device credentials of the device. 2. Communicates with Cisco's licensing portal to get the permission ticket, uses device credentials to identify the device. 3. Executes the processPermissionTicket action. Device revokes the license and generates rehost ticket to be submitted as proof of revocation. 4. Retrieves device credentials of the device where the license needs to be transferred to. 5. Submits rehost ticket as proof of revocation to Cisco's licensing portal, uses device credentials of the new device to identify the device, gets license file. 6. Executes the license install action on the new device. STEPS TO REGENERATE LAST REHOST TICKET: To regenerate last rehost ticket, the management application 1. Retrieves device credentials of the device. 2. Uses already obtained permission ticket or communicates with Cisco's licensing portal to get the permission ticket, uses device credentials to identify the device. 3. Executes the regenerateLastRehostTicket action. Device generates rehost ticket to be submitted as proof of revocation. STEPS TO BACKUP ALL LICENSES: To backup all licenses installed in the device, the management application 1. Specifies the backup file path. 2. Executes the license backup action. STEPS TO GENERATE & EXPORT EULA: To install certain kind of licenses, the management application must accept EULA first. The management application can generate and export EULA for one or more licenses with out installing licenses as follows. 1. Specifies the license file path that has licenses to be installed 2. Specifies the EULA file path where EULA need to be exported to 3. Executes the generate EULA action. To support the various license actions, this MIB module also defines MIB objects to know if a device supports licensing, retrieve device credentials, retrieve information on license stores in the device. It also defines MIB objects to expose management information associated with the licenses installed on the device, with the licensable features in the software image. This MIB module also defines various notifications that will be triggered to asynchronously notify the management application of any critical events. This MIB module is defined generically so it can be implemented on stand alone devices or stack of devices. In stack of devices, one device in the stack acts as master agent and rest are slave agents. Each device in the stack has its own UDI. The master agent receives requests on behalf of all the devices in the stack including itself and delegates it to other devices as needed. It also collects responses from other devices and sends them to the management application. Examples of such devices include stackable switches, devices with route processor and line cards. On the other hand, stand alone device is a single device and has only one UDI associated with it. entPhysicalIndex imported from ENTITY-MIB is used to identify the device uniquely. It is specified as the index or one of the index for tables in this MIB as needed.")
ciscoLicenseMgmtMIBNotifs = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 543, 0))
ciscoLicenseMgmtMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 543, 1))
ciscoLicenseMgmtMIBConform = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 543, 2))
clmgmtLicenseConfiguration = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 1))
clmgmtLicenseInformation = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 2))
clmgmtLicenseDeviceInformation = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 3))
clmgmtLicenseNotifObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 4))
class ClmgmtLicenseIndex(TextualConvention, Unsigned32):
    description = "A unique value, for each license in the managed system. It is not necessary to have values assigned contiguously. The value for each license must remain constant at least from one re-initialization of the entity's network management system to the next re-initialization"
    status = 'current'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(1, 4294967295)

class ClmgmtLicenseIndexOrZero(TextualConvention, Unsigned32):
    description = 'This textual convention is an extension of the ClmgmtLicenseIndex convention. The latter defines a greater than zero value used to identify a license in the managed system. This extension permits the additional value of zero. The value zero is object-specific and must therefore be defined as part of the description of any object which uses this syntax. Examples of the usage of zero might include situations where license was not present or unknown.'
    status = 'current'

class ClmgmtLicenseTransferProtocol(TextualConvention, Integer32):
    description = 'The transfer protocol that should be used for copying files when performing license management. When the protocol is set to local(2), local file system (flash or disk) is used. Different agents may support different transfer protocols and the management application is expected to some how determine which protocol is supported and use.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))
    namedValues = NamedValues(("none", 1), ("local", 2), ("tftp", 3), ("ftp", 4), ("rcp", 5), ("http", 6), ("scp", 7), ("sftp", 8))

class ClmgmtLicenseActionState(TextualConvention, Integer32):
    description = 'The state of license action execution. none(1) - action is not yet scheduled to be executed. pending(2) - All the required parameters for the action are set and the action is scheduled to be executed. inProgress(3) - action execution has started and is in progress. successful(4) - action has completed successfully. partiallySuccessful(5) - action has completed, but was partially successful. Management application can query additional MIB objects to know what is successful and what has failed. These addtional objects are listed in the description of the corresponding action tables. failed(6) - action has failed.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))
    namedValues = NamedValues(("none", 1), ("pending", 2), ("inProgress", 3), ("successful", 4), ("partiallySuccessful", 5), ("failed", 6))

class ClmgmtLicenseActionFailCause(TextualConvention, Integer32):
    description = 'Reason for license action failure. Defines error codes for all the license actions. none(1) - action execution has not started yet. If the action is completed and the action is successful, then also none(1) is returned to indicate that there are no errors. generalFailure(2) - General licensing failure. This will be used for resource unavailability failures. Ex: Lack of memory. transferProtocolNotSupported(3) - protocol selected is not supported. fileServerNotReachable(4) - file server is not reachable. unrecognizedEntPhysicalIndex(5) - entPhysicalIndex is not valid invalidLicenseFilePath(6) - The license file path is not accessible. invalidLicenseFile(7) - Contents of license file are not valid. invalidLicenseLine(8) - License string in the license file is not valid. licenseAlreadyExists(9) - Management application is trying to install a license that already exists. licenseNotValidForDevice(10) - This license is not valid for the device/entPhysicalIndex specified. invalidLicenseCount(11) - Invalid count for this counted license. invalidLicensePeriod(12) - Validity period is invalid for this expiring license. licenseInUse(13) - License file is in use by a feature/image. invalidLicenseStore(14) - License store is not valid. licenseStorageFull(15) - There is no more space in the license storage. invalidPermissionTicketFile(16) - The permission ticket file path is not accecssible. invalidPermissionTicket(17) - The permission ticket file contents are not valid. invalidRehostTicketFile(18) - The rehost ticket file path is not accessible. invalidRehostTicket(19) - The rehost ticket file contents are not valid. invalidLicenseBackupFile(20) - License backup store path is not accessible. licenseClearInProgress(21) - When license clear action is in progress, license backup action is not permitted to avoid race conditions. This error code is sent back in response to a license backup action when a license clear action is in progress or in pending state. Try again in few seconds. invalidLicenseEULAFile(22) - EULA file path is not accessible.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22))
    namedValues = NamedValues(("none", 1), ("generalFailure", 2), ("transferProtocolNotSupported", 3), ("fileServerNotReachable", 4), ("unrecognizedEntPhysicalIndex", 5), ("invalidLicenseFilePath", 6), ("invalidLicenseFile", 7), ("invalidLicenseLine", 8), ("licenseAlreadyExists", 9), ("licenseNotValidForDevice", 10), ("invalidLicenseCount", 11), ("invalidLicensePeriod", 12), ("licenseInUse", 13), ("invalidLicenseStore", 14), ("licenseStorageFull", 15), ("invalidPermissionTicketFile", 16), ("invalidPermissionTicket", 17), ("invalidRehostTicketFile", 18), ("invalidRehostTicket", 19), ("invalidLicenseBackupFile", 20), ("licenseClearInProgress", 21), ("invalidLicenseEULAFile", 22))

clmgmtNextFreeLicenseActionIndex = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: clmgmtNextFreeLicenseActionIndex.setStatus('current')
if mibBuilder.loadTexts: clmgmtNextFreeLicenseActionIndex.setDescription('This object contains appropriate value for clmgmtLicenseActionIndex that can be used to create an entry in clmgmtLicenseActionTable. The management application should read this object first and then use this as the value for clmgmtLicenseActionIndex to avoid collisions when creating entries in clmgmtLicenseActionTable. Following this approach does not guarantee collision free row creation, but will reduce the probability. The collision will happen if two management applications read this object at the same time and attempt to create an entry with this value at the same time. In this case, the management application whose request is processed after the first request will get an error and the process of reading this object and entry creation needs to be repeated.')
clmgmtLicenseActionTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 1, 2), )
if mibBuilder.loadTexts: clmgmtLicenseActionTable.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseActionTable.setDescription('A table for invoking license management actions. Management application must create a row in this table to trigger any of the license management actions. The following are different actions that can be executed using this table. 1. install 2. clear 3. processPermissionTicket 4. regenerateLastRehostTicket 5. backup 6. generateEULA Refer to the description of clmgmtLicenseAction for more information on what these actions do on the device. Once the request completes, the management application should retrieve the values of the objects of interest, and then delete the entry. In order to prevent old entries from clogging the table, entries will be aged out, but an entry will never be deleted within 5 minutes of completion.')
clmgmtLicenseActionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 1, 2, 1), ).setIndexNames((0, "CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseActionIndex"))
if mibBuilder.loadTexts: clmgmtLicenseActionEntry.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseActionEntry.setDescription('An entry for each action that is being executed or was executed recently. The management application executes an action by creating this entry. This can be done in the following 2 methods 1. CREATE-AND-GO method Management application sets clmgmtLicenseActionRowStatus to createAndGo(4) and all other required objects to valid values in a single SNMP SET request. If all the values are valid, the device creates the entry and executes the action. If the SET request fails, the entry will not be created. 2. CREATE-AND-WAIT method Management application sets clmgmtLicenseActionRowStatus to createAndWait(5) to create an entry. Management application can set all other required objects to valid values in more than one SNMP SET request. If SET request for any of the objects fails, management application can set just only that object. Once all the required objects are set to valid values, management application triggers action execution by setting clmgmtLicenseActionRowStatus to active(1). To stop the action from being executed, the management application can delete the entry by setting clmgmtLicenseActionRowStatus to destroy(6) when clmgmtLicenseActionState is pending(2). The status of action execution can be known by querying clmgmtLicenseActionState. If the action is still in pending(2) or in inProgress(3) state, the management application need to check back again after few seconds. Once the action completes and status of the action is failed(6), the reason for failure can be retrieved from clmgmtLicenseActionFailCause. If the status of the action is partiallySuccessful(5), results of individual licenses can be queried from clmgmtLicenseActionResultTable. Not all objects in the entry are needed to execute every action. Below is the list of actions and the required objects that are needed to be set for executing that action. 1. Installing a license The following MIB objects need to be set for installing a license a. clmgmtLicenseActionTransferProtocol b. clmgmtLicenseServerAddressType c. clmgmtLicenseServerAddress d. clmgmtLicenseServerUsername e. clmgmtLicenseServerPassword f. clmgmtLicenseFile g. clmgmtLicenseStore h. clmgmtLicenseStopOnFailure i. clmgmtLicenseAcceptEULA j. clmgmtLicenseAction clmgmtLicenseActionEntPhysicalIndex need not be set explicitly for license installs. License itself identifes the device where the license needs to be installed. clmgmtLicenseStore need to be set to store the licenses in a non-default license store. But, if a license file has more than one license and licenses need to be installed on multiple devices (for example to multiple members with in a stack), then value of clmgmtLicenseStore is ignored and the licenses will be installed in default license stores of the respective devices. 2. Clearing a license The following MIB objects need to be set for clearing a license a. clmgmtLicenseActionEntPhysicalIndex b. clmgmtLicenseActionLicenseIndex c. clmgmtLicenseStore d. clmgmtLicenseAction 3. Revoking a license The following MIB objects need to be set for revoking a license a. clmgmtLicenseActionTransferProtocol b. clmgmtLicenseServerAddressType c. clmgmtLicenseServerAddress d. clmgmtLicenseServerUsername e. clmgmtLicenseServerPassword f. clmgmtLicensePermissionTicketFile g. clmgmtLicenseRehostTicketFile h. clmgmtLicenseStopOnFailure i. clmgmtLicenseAction 4. Regenerate last rehost ticket The following MIB objects need to be set for regenerating last rehost ticket a. clmgmtLicenseActionTransferProtocol b. clmgmtLicenseServerAddressType c. clmgmtLicenseServerAddress d. clmgmtLicenseServerUsername e. clmgmtLicenseServerPassword f. clmgmtLicensePermissionTicketFile g. clmgmtLicenseRehostTicketFile h. clmgmtLicenseStopOnFailure i. clmgmtLicenseAction 5. Save all licenses to a backup storage The following MIB objects need to be set for storing all licenses to a backup store a. clmgmtLicenseActionEntPhysicalIndex b. clmgmtLicenseActionTransferProtocol c. clmgmtLicenseServerAddressType d. clmgmtLicenseServerAddress e. clmgmtLicenseServerUsername f. clmgmtLicenseServerPassword g. clmgmtLicenseBackupFile h. clmgmtLicenseAction 6. Generate and export EULA if the licenses need EULA to be accepted for installing. The following MIB objects need to be set exporting required EULAs a. clmgmtLicenseActionTransferProtocol b. clmgmtLicenseServerAddressType c. clmgmtLicenseServerAddress d. clmgmtLicenseServerUsername e. clmgmtLicenseServerPassword f. clmgmtLicenseFile g. clmgmtLicenseEULAFile h. clmgmtLicenseAction For any action, if clmgmtLicenseActionTransferProtocol is set to local(2), the following objects need not be set. a. clmgmtLicenseServerAddressType b. clmgmtLicenseServerAddress c. clmgmtLicenseServerUsername d. clmgmtLicenseServerPassword Entry can be deleted except when clmgmtLicenseAction is set to pending(2). All entries are volatile and are cleared on agent reset.')
clmgmtLicenseActionIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 1, 2, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: clmgmtLicenseActionIndex.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseActionIndex.setDescription('This object uniquely identifies a row in clmgmtLicenseActionTable. The management application should choose this value by reading clmgmtNextFreeLicenseActionIndex while creating an entry in this table. If an entry already exists with this index, the creation of the entry will not continue and error will be returned. The management application should read the value of clmgmtNextFreeLicenseActionIndex again and retry with the new value for this object.')
clmgmtLicenseActionEntPhysicalIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 1, 2, 1, 2), PhysicalIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: clmgmtLicenseActionEntPhysicalIndex.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseActionEntPhysicalIndex.setDescription('This object represents the entPhysicalIndex of the device where the action is being executed. This object is mainly used in devices where one device is acting as a master and rest of the devices as slaves. The master device is responsible for SNMP communication with the management application. Examples include stackable switches, devices with route processor and line card configuration. If this object is not set, the license action will be executed on the master device. Note: This object need not be set if there is a stand alone device')
clmgmtLicenseActionTransferProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 1, 2, 1, 3), ClmgmtLicenseTransferProtocol().clone('none')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: clmgmtLicenseActionTransferProtocol.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseActionTransferProtocol.setDescription("This object represents the transfer protocol to be used when copying files as specified in the following objects. 1. clmgmtLicenseFile 2. clmgmtLicensePermissionTicketFile 3. clmgmtLicenseRehostTicketFile 4. clmgmtLicenseBackupFile Note: This object need not be set if the all the files required for the action are in device's local file system.")
clmgmtLicenseServerAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 1, 2, 1, 4), InetAddressType().clone('unknown')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: clmgmtLicenseServerAddressType.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseServerAddressType.setDescription('This object indicates the transport type of the address contained in clmgmtLicenseServerAddress object. This must be set when clmgmtLicenseActionTransferProtocol is not none(1) or local(2).')
clmgmtLicenseServerAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 1, 2, 1, 5), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: clmgmtLicenseServerAddress.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseServerAddress.setDescription('This object indicates the ip address of the server from which the files must be read or written to if clmgmtLicenseActionTransferProtocol is not none(1) or local(2). All bits as 0s or 1s for clmgmtLicenseServerAddress are not allowed. The format of this address depends on the value of the clmgmtLicenseServerAddressType object')
clmgmtLicenseServerUsername = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 1, 2, 1, 6), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 96))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: clmgmtLicenseServerUsername.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseServerUsername.setDescription('This object indicates the remote user name for accessing files via ftp, rcp, sftp or scp protocols. This object must be set when the clmgmtLicenseActionTransferProtocol is ftp(4), rcp(5), scp(7) or sftp(8). If clmgmtLicenseActionTransferProtocol is rcp(5), the remote username is sent as the server username in an rcp command request sent by the system to a remote rcp server.')
clmgmtLicenseServerPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 1, 2, 1, 7), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 96))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: clmgmtLicenseServerPassword.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseServerPassword.setDescription('This object indicates the password used by ftp, sftp or scp for copying a file to/from an ftp/sftp/scp server. This object must be set when the clmgmtLicenseActionTransferProtocol is ftp(4) or scp(7) or sftp(8). Reading it returns a zero-length string for security reasons.')
clmgmtLicenseFile = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 1, 2, 1, 8), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: clmgmtLicenseFile.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseFile.setDescription('This object represents the location of the license file on the server identified by clmgmtLicenseServerAddress. This object MUST be set to a valid value before or concurrently with setting the value of the clmgmtLicenseAction object to install(2). For other operations, the value of this object is not considered, it is irrelevant.')
clmgmtLicenseStore = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 1, 2, 1, 9), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: clmgmtLicenseStore.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseStore.setDescription('This object represents the clmgmtLicenseStoreIndex of the license store to use within the device. The license store can be a local disk or flash. A device can have more than one license stores. If this object is not set, the license will be stored in the default license store as exposed by clmgmtDefaultLicenseStore object.')
clmgmtLicenseActionLicenseIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 1, 2, 1, 10), ClmgmtLicenseIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: clmgmtLicenseActionLicenseIndex.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseActionLicenseIndex.setDescription('This object indicates the the license index of the license that is the subject of this action. This is used for identifying a license for performing actions specific to that license. This object need to be set only if clmgmtLicenseAction is set to clear(4). The value of this object is same as the clmgmtLicenseIndex object in clmgmtLicenseInfoEntry for license that is subject of this action.')
clmgmtLicensePermissionTicketFile = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 1, 2, 1, 11), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: clmgmtLicensePermissionTicketFile.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicensePermissionTicketFile.setDescription('This object indicates the file name of the permission ticket. This object need to be set only if clmgmtLicenseAction is set to processPermissionTicket(4) or regenerateLastRehostTicket(5) actions. The permission ticket is obtained from Cisco licensing portal to revoke a license. The management application must set this object to valid value before invoking the action.')
clmgmtLicenseRehostTicketFile = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 1, 2, 1, 12), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: clmgmtLicenseRehostTicketFile.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseRehostTicketFile.setDescription('This object indicates the file where the rehost ticket generated by the device need to be exported to. The rehost ticket is generated as a result of processPermissionTicket and regenerateLastRehostTicket actions. After generating the rehost ticket, the device exports the rehost ticket contents to this file. This object need to be set only if clmgmtLicenseAction is set to processPermissionTicket(4) or regenerateLastRehostTicket(5) actions.')
clmgmtLicenseBackupFile = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 1, 2, 1, 13), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: clmgmtLicenseBackupFile.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseBackupFile.setDescription('This object indicates the file where all the licenses in the device need to be backed up. This object need to be set only if clmgmtLicenseAction is set to backup(6) and the management application must set the value of this object to valid value before invoking action.')
clmgmtLicenseStopOnFailure = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 1, 2, 1, 14), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: clmgmtLicenseStopOnFailure.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseStopOnFailure.setDescription('This object indicates whether the license action should stop if the action on a license fails. This object is applicable only if there are more than one licenses involved in an action.')
clmgmtLicenseAction = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 1, 2, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("noOp", 1), ("install", 2), ("clear", 3), ("processPermissionTicket", 4), ("regenerateLastRehostTicket", 5), ("backup", 6), ("generateEULA", 7))).clone('noOp')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: clmgmtLicenseAction.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseAction.setDescription('This object indicates the the command/action to be executed. Command Remarks ------- ------- noOp(1) No operation will be performed. install(2) Installs the license. clear(3) Clears the license. processPermissionTicket(4) Processes thee permission ticket and generates and exports rehost ticket. regenerateLastRehostTicket(5) Generates and exports the last generated rehost ticket. backup(6) Backs up all the licenses installed currently onto a backup store. generateEULA(7) Checks whether the licenses in the license file need EULA acceptance and uploads the needed EULA contents to a file.')
clmgmtLicenseActionState = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 1, 2, 1, 16), ClmgmtLicenseActionState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: clmgmtLicenseActionState.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseActionState.setDescription('This object indicates the state of this license action.')
clmgmtLicenseJobQPosition = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 1, 2, 1, 17), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: clmgmtLicenseJobQPosition.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseJobQPosition.setDescription('This object represents the position of the action in the license action job queue that is maintained internally. Only actions in pending(2) state will be put in the queue until they are executed. By reading this object, the management application can make intelligent decision on whether to execute another action that it is planning on. For example, if there is already a license clear action in the queue in pending(2) state, management application can choose to defer its license back up action to a later time. This object will return a value of 0 if the action is not in pending(2) state.')
clmgmtLicenseActionFailCause = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 1, 2, 1, 18), ClmgmtLicenseActionFailCause()).setMaxAccess("readonly")
if mibBuilder.loadTexts: clmgmtLicenseActionFailCause.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseActionFailCause.setDescription('This object indicates the reason for this license action failure. The value of this object is valid only when clmgmtLicenseActionState is failed(6).')
clmgmtLicenseActionStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 1, 2, 1, 19), StorageType().clone('volatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: clmgmtLicenseActionStorageType.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseActionStorageType.setDescription("This object indicates the storage type for this conceptual row. Conceptual rows having the value 'permanent' need not allow write-access to any columnar objects in the row.")
clmgmtLicenseActionRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 1, 2, 1, 20), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: clmgmtLicenseActionRowStatus.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseActionRowStatus.setDescription('This object indicates the the status of this table entry. Once the entry status is set to active(1), the associated entry cannot be modified until the action completes (clmgmtLicenseConfigCommandStatus is set to a value other than inProgress(3)). Once the action completes the only operation possible after this is to delete the row. It is recommended that the management application should delete entries in this table after reading the result. In order to prevent old entries from clogging the table, entries will be aged out, but an entry will never be deleted within 5 minutes of completion')
clmgmtLicenseAcceptEULA = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 1, 2, 1, 21), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: clmgmtLicenseAcceptEULA.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseAcceptEULA.setDescription('This object indicates whether the End User License Agreement needed for installing the licenses is accepted. true(1) - EULA is read and accepted false(2) - EULA is not accepted Management application should set this object to true(1) when installing licenses that need EULA acceptance.')
clmgmtLicenseEULAFile = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 1, 2, 1, 22), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: clmgmtLicenseEULAFile.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseEULAFile.setDescription('This object indicates the file where all the End User License Agreements (EULAs) need to be exported to. This object need to be set only if clmgmtLicenseAction is set to generateEULA(7) and the management application must set the value of this object to valid value before invoking action.')
clmgmtLicenseActionResultTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 1, 3), )
if mibBuilder.loadTexts: clmgmtLicenseActionResultTable.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseActionResultTable.setDescription('This table contains results of license action if the license action involves multiple licenses. Entries in this table are not created for actions where there is only license that is subject of the action. For example, if there are 3 licenses in a license file when executing license install action, 3 entries will be created in this table, one for each license.')
clmgmtLicenseActionResultEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 1, 3, 1), ).setIndexNames((0, "CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseActionIndex"), (0, "CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseNumber"))
if mibBuilder.loadTexts: clmgmtLicenseActionResultEntry.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseActionResultEntry.setDescription('An entry in clmgmtLicenseActionResultTable. Each entry contains result of the action for a single license. These entries are created immediately after action execution when the action involves multiple licenses. These entries get automatically deleted when the corresponding entry in clmgmtLicenseActionTable is deleted.')
clmgmtLicenseNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 1, 3, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: clmgmtLicenseNumber.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseNumber.setDescription('This object indicates the sequence number of this license in the list of licenses on which the action is executed. For example, if there are 3 licenses in a license file when executing license install action, this object will have values 1, 2 and 3 respectively as ordered in the license file.')
clmgmtLicenseIndivActionState = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 1, 3, 1, 2), ClmgmtLicenseActionState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: clmgmtLicenseIndivActionState.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseIndivActionState.setDescription('This object indicates the state of action on this individual license.')
clmgmtLicenseIndivActionFailCause = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 1, 3, 1, 3), ClmgmtLicenseActionFailCause()).setMaxAccess("readonly")
if mibBuilder.loadTexts: clmgmtLicenseIndivActionFailCause.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseIndivActionFailCause.setDescription('This object indicates the reason for action failure on this individual license')
clmgmtLicenseStoreInfoTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 2, 1), )
if mibBuilder.loadTexts: clmgmtLicenseStoreInfoTable.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseStoreInfoTable.setDescription('This table contains information about all the license stores allocated on the device.')
clmgmtLicenseStoreInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 2, 1, 1), ).setIndexNames((0, "ENTITY-MIB", "entPhysicalIndex"), (0, "CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseStoreIndex"))
if mibBuilder.loadTexts: clmgmtLicenseStoreInfoEntry.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseStoreInfoEntry.setDescription('An entry in clmgmtLicenseStoreInfoTable. Each entry contains information about a license store allocated on the device')
clmgmtLicenseStoreIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 2, 1, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: clmgmtLicenseStoreIndex.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseStoreIndex.setDescription('This object uniquely identifies a license store within the device.')
clmgmtLicenseStoreName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 2, 1, 1, 2), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: clmgmtLicenseStoreName.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseStoreName.setDescription("This object indicates the name of the license store within the device. It is a file in device's local file system i.e., either on a local disk or flash or some other storage media. For example, the value of this object can be 'disk1:lic_store_1.txt' or 'flash:lic_store_2.txt")
clmgmtLicenseStoreTotalSize = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 2, 1, 1, 3), Unsigned32()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: clmgmtLicenseStoreTotalSize.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseStoreTotalSize.setDescription('This object indicates the total number of bytes that are allocated to the license store.')
clmgmtLicenseStoreSizeRemaining = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 2, 1, 1, 4), Unsigned32()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: clmgmtLicenseStoreSizeRemaining.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseStoreSizeRemaining.setDescription('This object indicates the number of bytes still remaining to be used for new license installations in the license store.')
clmgmtLicenseDeviceInfoTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 2, 2), )
if mibBuilder.loadTexts: clmgmtLicenseDeviceInfoTable.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseDeviceInfoTable.setDescription('This table contains objects that provide licensing related information at the device level. Entries will exist only for entities that support licensing. For example, if it is a stand alone device and supports licensing, then there will be only one entry in this table. If it is stackable switch then there will be multiple entries with one entry for each device in the stack.')
clmgmtLicenseDeviceInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 2, 2, 1), ).setIndexNames((0, "ENTITY-MIB", "entPhysicalIndex"))
if mibBuilder.loadTexts: clmgmtLicenseDeviceInfoEntry.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseDeviceInfoEntry.setDescription('An entry in clmgmtLicenseDeviceInfoTable. Each entry contains device level licensing information for a device.')
clmgmtDefaultLicenseStore = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 2, 2, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: clmgmtDefaultLicenseStore.setStatus('current')
if mibBuilder.loadTexts: clmgmtDefaultLicenseStore.setDescription('This object indicates the clmgmtLicenseStoreIndex of default store in the device. There will be only one default license store per device. If no license store is specified during license install, this default license store will be used.')
clmgmtLicenseInfoTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 2, 3), )
if mibBuilder.loadTexts: clmgmtLicenseInfoTable.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseInfoTable.setDescription('This table contains information about all the licenses installed on the device.')
clmgmtLicenseInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 2, 3, 1), ).setIndexNames((0, "ENTITY-MIB", "entPhysicalIndex"), (0, "CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseStoreUsed"), (0, "CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseIndex"))
if mibBuilder.loadTexts: clmgmtLicenseInfoEntry.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseInfoEntry.setDescription('An entry in clmgmtLicenseInfoTable. Each entry contains information about a license installed on the device. This entry gets created when a license is installed successfully. Management application can not create these entries directly, but will do so indirectly by executing license install action. Some of these entries may already exist that correspond to demo licenses even before management application installs any licenses.')
clmgmtLicenseStoreUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 2, 3, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: clmgmtLicenseStoreUsed.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseStoreUsed.setDescription('This object represents the license store that is used for storing this license. This object will have the same value as clmgmtLicenseStoreIndex in clmgmtLicenseStoreInfoEntry of the license store used.')
clmgmtLicenseIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 2, 3, 1, 2), ClmgmtLicenseIndex())
if mibBuilder.loadTexts: clmgmtLicenseIndex.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseIndex.setDescription('This object uniquely identifies a license within the device.')
clmgmtLicenseFeatureName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 2, 3, 1, 3), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: clmgmtLicenseFeatureName.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseFeatureName.setDescription("This object indicates the name of the feature that is using or can use this license. A license can be used by only one feature. Examples of feature name are: 'IPBASE', 'ADVIPSERVICE'.")
clmgmtLicenseFeatureVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 2, 3, 1, 4), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: clmgmtLicenseFeatureVersion.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseFeatureVersion.setDescription("This object indicates the version of the feature that is using or can use this license. Examples of feature version are: '1.0', '2.0'")
clmgmtLicenseType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 2, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("demo", 1), ("extension", 2), ("gracePeriod", 3), ("permanent", 4), ("paidSubscription", 5), ("evaluationSubscription", 6), ("extensionSubscription", 7), ("evalRightToUse", 8), ("rightToUse", 9), ("permanentRightToUse", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: clmgmtLicenseType.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseType.setDescription('This object identifies type of license. Licenses may have validity period defined in terms of time duration that the license is valid for or it may be defined in terms of actual calendar dates. Subscription licenses are licenses that have validity period defined in terms of calendar dates. demo(1) - demo(evaluation license) license. extension(2) - Extension(expiring) license. gracePeriod(3) - Grace period license. permanent(4) - permanent license, the license has no expiry date. paidSubscription(5) - Paid subscription licenses are the licenses which are purchased by customers. These licenses have a start date and end date associated with them. evaluationSubscription(6)-Evaluation subscription licenses are the trial licenses. These licenses are node locked and it can be obtained only once for an UDI. They are valid based on calendar days. These licenses have a start date and an end date associated with them and are issued once per UDI. extensionSubscription(7)- Extension subscription licenses are similar to evaluation subscription licenses but these licenses are issued based on customer request. There are no restrictions on the number of licenses available for a UDI. evalRightToUse(8) - Evaluation Right to use (RTU) license. rightToUse(9) - Right to use (RTU) license. permanentRightToUse(10) ? Right To Use license right after it is configured and is valid for the lifetime of the product. This is a Right To Use license which is not in evaluation mode for a limited time.')
clmgmtLicenseCounted = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 2, 3, 1, 6), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: clmgmtLicenseCounted.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseCounted.setDescription('This object indicates whether the license is counted license. true(1) - counted license false(2) - uncounted license')
clmgmtLicenseValidityPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 2, 3, 1, 7), Unsigned32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: clmgmtLicenseValidityPeriod.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseValidityPeriod.setDescription('This object indicates the time period the license is valid for. This object is applicable only if clmgmtLicenseType is demo(1), or extension(2) or gracePeriod(3) or evalRightToUse(8). The object will return 0 for other license types.')
clmgmtLicenseValidityPeriodRemaining = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 2, 3, 1, 8), Unsigned32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: clmgmtLicenseValidityPeriodRemaining.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseValidityPeriodRemaining.setDescription('This object indicates the time period remaining before the license expires or transitions to rightToUse(9) license. This object is applicable only if clmgmtLicenseType is demo(1), or extension(2) or gracePeriod(3) or evalRightToUse(8). The object will contain 0 for other license types.')
clmgmtLicenseExpiredPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 2, 3, 1, 9), Unsigned32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: clmgmtLicenseExpiredPeriod.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseExpiredPeriod.setDescription('This object indicates the elapsed time period since the license expired. This object is applicable only if clmgmtLicenseType is demo(1), or extension(2) or gracePeriod(3). Also, this value of this object will be valid only after the license expires. The object will return 0 for other license types or before the license expiry.')
clmgmtLicenseMaxUsageCount = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 2, 3, 1, 10), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: clmgmtLicenseMaxUsageCount.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseMaxUsageCount.setDescription('This object indicates the maximum number of entities that can use this license. This object is applicable only if clmgmtLicenseCounted is true(1). The entity that is being counted can be anything and it depends on the licensable feature.')
clmgmtLicenseUsageCountRemaining = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 2, 3, 1, 11), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: clmgmtLicenseUsageCountRemaining.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseUsageCountRemaining.setDescription('This object indicates the number of entities that can still use this license. This object is applicable only if clmgmtLicenseCounted is true(1).')
clmgmtLicenseEULAStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 2, 3, 1, 12), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: clmgmtLicenseEULAStatus.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseEULAStatus.setDescription('This object indicates whether the user accepted End User License Agreement for this license. true(1) - EULA accpeted false(2) - EULA not accepted')
clmgmtLicenseComments = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 2, 3, 1, 13), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: clmgmtLicenseComments.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseComments.setDescription('This object represents the user modifiable comments about the license. This object is initially populated with comments from the license file.')
clmgmtLicenseStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 2, 3, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("inactive", 1), ("notInUse", 2), ("inUse", 3), ("expiredInUse", 4), ("expiredNotInUse", 5), ("usageCountConsumed", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: clmgmtLicenseStatus.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseStatus.setDescription('This object represents status of the license. inactive(1) - license is installed, but not active. notInUse(2) - license is installed and available for use. inUse(3) - the license is being used (by a feature). expiredInUse(4) - license is expired but still being held by the feature. expiredNotInUse(5) - license is expired and not being held by any feature. usageCountConsumed(6) - number of entities using this licenses has reached the allowed limit, no new entities are allowed to use this license.')
clmgmtLicenseStartDate = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 2, 3, 1, 15), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: clmgmtLicenseStartDate.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseStartDate.setDescription('This object indicates the start date for a subscription license. It is optional for subscription linceses to have a start date associated with them, they may only have an end date associated with them. This object may be applicable only when clmgmtLicenseType is paidSubscription(5), evaluationSubscription(6) or extensionSubscription (7). The object will contain an octet string of length 0 when it is not applicable.')
clmgmtLicenseEndDate = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 2, 3, 1, 16), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: clmgmtLicenseEndDate.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseEndDate.setDescription('This object indicates the end date for a subscription license. This object is applicable only when clmgmtLicenseType is paidSubscription(5), evaluationSubscription(6) or extensionSubscription (7). The object will contain an octet string of length 0 when it is not applicable.')
clmgmtLicensePeriodUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 2, 3, 1, 17), Unsigned32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: clmgmtLicensePeriodUsed.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicensePeriodUsed.setDescription('This object indicates the time period used for the Right to use (RTU) licenses. This object is applicable for all RTU licenses.')
clmgmtLicensableFeatureTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 2, 4), )
if mibBuilder.loadTexts: clmgmtLicensableFeatureTable.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicensableFeatureTable.setDescription('This table contains list of licensable features in the image. All the licensable features will have an entry each in this table irrespective of whether they are using any licenses currently. Entries in this table are created by the agent one for each licensable feature in the image. These entries remain in the table permanently and can not be deleted. Management application can not create or delete entries from this table.')
clmgmtLicensableFeatureEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 2, 4, 1), ).setIndexNames((0, "ENTITY-MIB", "entPhysicalIndex"), (0, "CISCO-LICENSE-MGMT-MIB", "clmgmtFeatureIndex"))
if mibBuilder.loadTexts: clmgmtLicensableFeatureEntry.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicensableFeatureEntry.setDescription('An entry in clmgmtLicensableFeatureTable. Each entry represents a licensable feature.')
clmgmtFeatureIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 2, 4, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: clmgmtFeatureIndex.setStatus('current')
if mibBuilder.loadTexts: clmgmtFeatureIndex.setDescription('This object uniquely identifies a licensable feature in the device.')
clmgmtFeatureName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 2, 4, 1, 2), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: clmgmtFeatureName.setStatus('current')
if mibBuilder.loadTexts: clmgmtFeatureName.setDescription("This object indicates the name of the licensable feature in the device. Examples of feature names are: 'IPBASE', 'ADVIPSERVICE'")
clmgmtFeatureVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 2, 4, 1, 3), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: clmgmtFeatureVersion.setStatus('current')
if mibBuilder.loadTexts: clmgmtFeatureVersion.setDescription("This object indicates the version of the licensable feature in the device. Examples of feature versions are: '1.0' or '2.0'")
clmgmtFeatureValidityPeriodRemaining = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 2, 4, 1, 4), Unsigned32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: clmgmtFeatureValidityPeriodRemaining.setStatus('current')
if mibBuilder.loadTexts: clmgmtFeatureValidityPeriodRemaining.setDescription("This object indicates the time period remaining before the feature's license expires or transitions. This object is applicable only if clmgmtLicenseType of the license used by this feature is demo(1), or extension(2) or gracePeriod(3) or evalRightToUse(8). The object will contain 0 if other types of license is used or if the feature does not use any license. If the feature is using multiple licenses, this period will represent the cumulative period remaining from all the licenses used by this feature.")
clmgmtFeatureWhatIsCounted = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 2, 4, 1, 5), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: clmgmtFeatureWhatIsCounted.setStatus('current')
if mibBuilder.loadTexts: clmgmtFeatureWhatIsCounted.setDescription('This object represents the entity that is being counted by this feature. Examples of entities are IP Phones, number of sessions etc. This object is only applicable for features that use counting licenses. For other features, this object will return empty string.')
clmgmtFeatureStartDate = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 2, 4, 1, 6), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: clmgmtFeatureStartDate.setStatus('current')
if mibBuilder.loadTexts: clmgmtFeatureStartDate.setDescription('This object indicates the license start date of the feature. This object is applicable if at least one of the licenses used for this feature has a valid start date. The start date will be the earliest of the valid start dates of all the licenses used for this feature. If none of the licenses used for this feature have a valid start date then this object will contain an octet string of length 0.')
clmgmtFeatureEndDate = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 2, 4, 1, 7), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: clmgmtFeatureEndDate.setStatus('current')
if mibBuilder.loadTexts: clmgmtFeatureEndDate.setDescription('This object indicates the license end date of the feature. This object is applicable if at least one of the licenses used for this feature has a valid end date. The end date will be the latest of the valid end dates of all the licenses used for this feature. If none of the licenses used for this feature have a valid end date then this object will contain an octet string of length 0.')
clmgmtFeaturePeriodUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 2, 4, 1, 8), Unsigned32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: clmgmtFeaturePeriodUsed.setStatus('current')
if mibBuilder.loadTexts: clmgmtFeaturePeriodUsed.setDescription('This object indicates the license period used for the feature.')
clmgmtNextFreeDevCredExportActionIndex = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 3, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: clmgmtNextFreeDevCredExportActionIndex.setStatus('current')
if mibBuilder.loadTexts: clmgmtNextFreeDevCredExportActionIndex.setDescription('This object contains appropriate value for clmgmtDevCredExportActionIndex that can be used to create an entry in clmgmtDevCredExportActionTable. The management application should read this object first and then use this as the value for clmgmtDevCredExportActionIndex to avoid collisions when creating entries in clmgmtDevCredExportActionTable. Following this approach does not guarantee collision free row creation, but will reduce the probability. The collision will happen if two management applications read this object at the same time and attempt to create an entry with this value at the same time. In this case, the management application whose request is processed after the first request will get an error and the process of reading this object and entry creation needs to be repeated.')
clmgmtDevCredExportActionTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 3, 2), )
if mibBuilder.loadTexts: clmgmtDevCredExportActionTable.setStatus('current')
if mibBuilder.loadTexts: clmgmtDevCredExportActionTable.setDescription('A table for triggering device credentials export action. Management application must create this entry to trigger the export of device credentials from the device to a file. Once the request completes, the management application should retrieve the values of the objects of interest, and then delete the entry. In order to prevent old entries from clogging the table, entries will be aged out, but an entry will never be deleted within 5 minutes of completion.')
clmgmtDevCredExportActionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 3, 2, 1), ).setIndexNames((0, "CISCO-LICENSE-MGMT-MIB", "clmgmtDevCredExportActionIndex"))
if mibBuilder.loadTexts: clmgmtDevCredExportActionEntry.setStatus('current')
if mibBuilder.loadTexts: clmgmtDevCredExportActionEntry.setDescription('An entry for each device credential export action that is being executed or was executed recently. The management application triggers the export by creating an entry in this table. This can be done in the following 2 methods 1. CREATE-AND-GO method Management application sets clmgmtDevCredExportActionStatus to createAndGo(4) and all other required objects to valid values in a single SNMP SET request. If all the values are valid, the device creates the entry and executes the action. If the SET request fails, the entry will not be created. 2. CREATE-AND-WAIT method Management application sets clmgmtDevCredExportActionStatus to createAndWait(5) to create an entry. Management application can set all other required objects to valid values in more than one SNMP SET request. If SET request for any of the objects fails, management application can set just only that object. Once all the required objects are set to valid values, management application triggers action execution by setting clmgmtDevCredExportActionStatus to active(1). To stop the action from being executed, the management application can delete the entry by setting clmgmtDevCredExportActionStatus to destroy(6) when clmgmtDevCredCommandState is pending(2). The status of action execution can be known by querying clmgmtDevCredCommandState. If the action is still in pending(2) or inProgress(3), the management application need to check back again after few seconds. Once the action completes and if status of the action is failed(6), the reason for failure can be retrieved from clmgmtDevCredCommandFailCause. Entry can be deleted except when clmgmtLicenseAction is set to inProgress(3). All entries in this table are volatile and are cleared on agent reset.')
clmgmtDevCredExportActionIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 3, 2, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: clmgmtDevCredExportActionIndex.setStatus('current')
if mibBuilder.loadTexts: clmgmtDevCredExportActionIndex.setDescription('This object uniquely identifies a row in clmgmtDevCredExportActionTable. The management application chooses this value by reading clmgmtNextFreeDevCredExportActionIndex while creating an entry in this table. If an entry already exists with this index, the creation of the entry will not continue and error will be returned. The management application should read the value of clmgmtNextFreeDevCredExportActionIndex again and retry with the new value for this object.')
clmgmtDevCredEntPhysicalIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 3, 2, 1, 2), PhysicalIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: clmgmtDevCredEntPhysicalIndex.setStatus('current')
if mibBuilder.loadTexts: clmgmtDevCredEntPhysicalIndex.setDescription('This object represents the entPhysicalIndex of the device for which the device credentials are being retrieved. This object is mainly used in devices where one device is acting as a master and rest of the devices as slaves. The master device is responsible for SNMP communication with the manager. Examples include stackable switches, devices with router processor and line cards. Note: This object need not be set if it is a stand alone device')
clmgmtDevCredTransferProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 3, 2, 1, 3), ClmgmtLicenseTransferProtocol().clone('none')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: clmgmtDevCredTransferProtocol.setStatus('current')
if mibBuilder.loadTexts: clmgmtDevCredTransferProtocol.setDescription('This object indicates the transfer protocol to be used when copying files as specified in the following objects. 1. clmgmtDevCredExportFile .')
clmgmtDevCredServerAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 3, 2, 1, 4), InetAddressType().clone('unknown')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: clmgmtDevCredServerAddressType.setStatus('current')
if mibBuilder.loadTexts: clmgmtDevCredServerAddressType.setDescription('This object indicates the transport type of the address contained in clmgmtDevCredServerAddress object. This must be set when clmgmtDevCredTransferProtocol is not none(1) or local(2).')
clmgmtDevCredServerAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 3, 2, 1, 5), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: clmgmtDevCredServerAddress.setStatus('current')
if mibBuilder.loadTexts: clmgmtDevCredServerAddress.setDescription('This object indicates the the ip address of the server from which the files must be read or written to if clmgmtDevCredTransferProtocol is not none(1) or local(2). All bits as 0s or 1s for clmgmtDevCredServerAddress are not allowed. The format of this address depends on the value of the clmgmtDevCredServerAddressType object')
clmgmtDevCredServerUsername = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 3, 2, 1, 6), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 96))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: clmgmtDevCredServerUsername.setStatus('current')
if mibBuilder.loadTexts: clmgmtDevCredServerUsername.setDescription('This object indicates the remote user name for accessing files via ftp, rcp, sftp or scp protocols. This object must be set when the clmgmtDevCredTransferProtocol is ftp(4), rcp(5), scp(7) or sftp(8). If clmgmtDevCredTransferProtocol is rcp(5), the remote username is sent as the server username in an rcp command request sent by the system to a remote rcp server.')
clmgmtDevCredServerPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 3, 2, 1, 7), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 96))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: clmgmtDevCredServerPassword.setStatus('current')
if mibBuilder.loadTexts: clmgmtDevCredServerPassword.setDescription('This object indicates the password used by ftp, sftp or scp for copying a file to/from an ftp/sftp/scp server. This object must be set when the clmgmtDevCredTransferProtocol is ftp(4) or scp(7) or sftp(8). Reading it returns a zero-length string for security reasons.')
clmgmtDevCredExportFile = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 3, 2, 1, 8), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: clmgmtDevCredExportFile.setStatus('current')
if mibBuilder.loadTexts: clmgmtDevCredExportFile.setDescription('This object represents file where device credentials needs to be exported to.')
clmgmtDevCredCommand = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 3, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noOp", 1), ("getDeviceCredentials", 2))).clone('noOp')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: clmgmtDevCredCommand.setStatus('current')
if mibBuilder.loadTexts: clmgmtDevCredCommand.setDescription('This object indicates the the command to be executed. Command Remarks ------- ------- noOp(1) No operation will be performed. getDeviceCredentials(2) Exports device credentials')
clmgmtDevCredCommandState = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 3, 2, 1, 10), ClmgmtLicenseActionState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: clmgmtDevCredCommandState.setStatus('current')
if mibBuilder.loadTexts: clmgmtDevCredCommandState.setDescription('This object indicates the state of the action that is executed as a result of setting clmgmtDevCredRowStatus to active(1).')
clmgmtDevCredCommandFailCause = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 3, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("none", 1), ("unknownError", 2), ("transferProtocolNotSupported", 3), ("fileServerNotReachable", 4), ("unrecognizedEntPhysicalIndex", 5), ("invalidFile", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: clmgmtDevCredCommandFailCause.setStatus('current')
if mibBuilder.loadTexts: clmgmtDevCredCommandFailCause.setDescription('This object indicates the the reason for device credentials export operation failure. The value of this object is valid only when clmgmtDevCredCommandState is failed(6). none(1) - action execution has not started yet. If the action is completed and the action is successful, then also none(1) is returned to indicate that there are no errors. unknownError(2) - reason for failure is unknown, operation failed, no operation is performed transferProtocolNotSupported(3) - clmgmtDevCredTransferProtocol given is not supported. fileServerNotReachable(4) - file server is not reachable. unrecognizedEntPhysicalIndex(5) - entPhysicalIndex is not valid invalidFile(6) - The target file specified is not valid.')
clmgmtDevCredStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 3, 2, 1, 12), StorageType().clone('volatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: clmgmtDevCredStorageType.setStatus('current')
if mibBuilder.loadTexts: clmgmtDevCredStorageType.setDescription("This object indicates the storage type for this conceptual row. Conceptual rows having the value 'permanent' need not allow write-access to any columnar objects in the row.")
clmgmtDevCredRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 3, 2, 1, 13), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: clmgmtDevCredRowStatus.setStatus('current')
if mibBuilder.loadTexts: clmgmtDevCredRowStatus.setDescription('This object indicates the the status of this table entry. Once the entry status is set to active(1), the associated entry cannot be modified until the action completes (clmgmtDevCredCommandStatus is set to a value other than inProgress(3)). Once the action completes the only operation possible after this is to delete the row. clmgmtDevCredExportFile is a mandatory object to be set when creating this entry.')
clmgmtLicenseUsageNotifEnable = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 4, 1), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: clmgmtLicenseUsageNotifEnable.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseUsageNotifEnable.setDescription('This object indicates whether the device should generate the notifications related to usage of licenses. This object enables/disables sending following notifications: clmgmtLicenseExpired clmgmtLicenseExpiryWarning clmgmtLicenseUsageCountExceeded clmgmtLicenseUsageCountAboutToExceed clmgmtLicenseSubscriptionExpiryWarning clmgmtLicenseSubscriptionExtExpiryWarning clmgmtLicenseSubscriptionExpired clmgmtLicenseEvalRTUTransitionWarning clmgmtLicenseEvalRTUTransition')
clmgmtLicenseDeploymentNotifEnable = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 4, 2), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: clmgmtLicenseDeploymentNotifEnable.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseDeploymentNotifEnable.setDescription('This object indicates whether the device should generate notifications related to license deployment. This object enables/disables sending following notifications: clmgmtLicenseInstalled clmgmtLicenseCleared clmgmtLicenseRevoked clmgmtLicenseEULAAccepted')
clmgmtLicenseErrorNotifEnable = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 543, 1, 4, 3), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: clmgmtLicenseErrorNotifEnable.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseErrorNotifEnable.setDescription('This object indicates whether the device should generate notifications related to error conditions in enforcing licensing. This object enables/disables sending following notifications: clmgmtLicenseNotEnforced')
clmgmtLicenseExpired = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 543, 0, 1)).setObjects(("CISCO-LICENSE-MGMT-MIB", "clmgmtFeatureName"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtFeatureVersion"))
if mibBuilder.loadTexts: clmgmtLicenseExpired.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseExpired.setDescription('This notification is sent, when a feature license expires. This notification will be sent continuously every week even after the expiry to alert the management application.')
clmgmtLicenseExpiryWarning = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 543, 0, 2)).setObjects(("CISCO-LICENSE-MGMT-MIB", "clmgmtFeatureName"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtFeatureVersion"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtFeatureValidityPeriodRemaining"))
if mibBuilder.loadTexts: clmgmtLicenseExpiryWarning.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseExpiryWarning.setDescription('This notification is sent when a license is about to expire. This notification will go out multiple times. First notification goes out when expiry day is 4 weeks ahead, second notification when expiry day is 3 weeks ahead, third notification when expiry day is 2 weeks ahead. This notification will go out daily in the last week of license expiry.')
clmgmtLicenseUsageCountExceeded = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 543, 0, 3)).setObjects(("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseFeatureName"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseFeatureVersion"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseMaxUsageCount"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtFeatureWhatIsCounted"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseComments"))
if mibBuilder.loadTexts: clmgmtLicenseUsageCountExceeded.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseUsageCountExceeded.setDescription('This notification is sent when clmgmtLicenseUsageCountRemaining has reached clmgmtLicenseMaxUsageCount for a counting license.')
clmgmtLicenseUsageCountAboutToExceed = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 543, 0, 4)).setObjects(("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseFeatureName"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseFeatureVersion"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseMaxUsageCount"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseUsageCountRemaining"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtFeatureWhatIsCounted"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseComments"))
if mibBuilder.loadTexts: clmgmtLicenseUsageCountAboutToExceed.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseUsageCountAboutToExceed.setDescription('This notification is sent when clmgmtLicenseUsageCountRemaining has reached 80% of clmgmtLicenseMaxUsageCount for a counting license. This is a warning notification to the management application that very soon the maximum count will be reached and after that the device will not allow new entities to make use of this license.')
clmgmtLicenseInstalled = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 543, 0, 5)).setObjects(("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseFeatureName"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseFeatureVersion"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseType"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseComments"))
if mibBuilder.loadTexts: clmgmtLicenseInstalled.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseInstalled.setDescription('This notification is sent when a license is installed successfully.')
clmgmtLicenseCleared = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 543, 0, 6)).setObjects(("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseFeatureName"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseFeatureVersion"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseType"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseComments"))
if mibBuilder.loadTexts: clmgmtLicenseCleared.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseCleared.setDescription('This notification is sent when a license is cleared successfully.')
clmgmtLicenseRevoked = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 543, 0, 7)).setObjects(("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseFeatureName"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseFeatureVersion"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseType"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseComments"))
if mibBuilder.loadTexts: clmgmtLicenseRevoked.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseRevoked.setDescription('This notification is sent when a license is revoked successfully.')
clmgmtLicenseEULAAccepted = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 543, 0, 8)).setObjects(("CISCO-LICENSE-MGMT-MIB", "clmgmtFeatureName"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtFeatureVersion"))
if mibBuilder.loadTexts: clmgmtLicenseEULAAccepted.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseEULAAccepted.setDescription('This notification is sent when a user accepts End User License Agreement (EULA) for a license.')
clmgmtLicenseNotEnforced = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 543, 0, 9)).setObjects(("CISCO-LICENSE-MGMT-MIB", "clmgmtFeatureName"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtFeatureVersion"))
if mibBuilder.loadTexts: clmgmtLicenseNotEnforced.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseNotEnforced.setDescription('This notification is sent when a license does not exist for a feature, but the feature is a mandatory feature and it should run. This notification will be sent out periodically to indicate that there is no license installed for this feature and it needs to be done as soon as possible.')
clmgmtLicenseSubscriptionExpiryWarning = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 543, 0, 10)).setObjects(("CISCO-LICENSE-MGMT-MIB", "clmgmtFeatureName"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtFeatureVersion"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtFeatureEndDate"))
if mibBuilder.loadTexts: clmgmtLicenseSubscriptionExpiryWarning.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseSubscriptionExpiryWarning.setDescription('This notification is sent when a subscription license of a feature is about to expire. This notification will be sent as per the following schedule: Once a week for the last eight weeks Once a day for the last week Once a hour for the last day')
clmgmtLicenseSubscriptionExtExpiryWarning = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 543, 0, 11)).setObjects(("CISCO-LICENSE-MGMT-MIB", "clmgmtFeatureName"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtFeatureVersion"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtFeatureEndDate"))
if mibBuilder.loadTexts: clmgmtLicenseSubscriptionExtExpiryWarning.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseSubscriptionExtExpiryWarning.setDescription('This notification is sent when the subscription license end date of a feature is reached but extension period is left. This notification will be sent once a day after the license end date is reached.')
clmgmtLicenseSubscriptionExpired = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 543, 0, 12)).setObjects(("CISCO-LICENSE-MGMT-MIB", "clmgmtFeatureName"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtFeatureVersion"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtFeatureEndDate"))
if mibBuilder.loadTexts: clmgmtLicenseSubscriptionExpired.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseSubscriptionExpired.setDescription('This notification will be sent after a subscription license of a feature completely expires. It will be sent once a day after the license has completely expired')
clmgmtLicenseEvalRTUTransitionWarning = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 543, 0, 13)).setObjects(("CISCO-LICENSE-MGMT-MIB", "clmgmtFeatureName"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtFeatureVersion"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtFeatureValidityPeriodRemaining"))
if mibBuilder.loadTexts: clmgmtLicenseEvalRTUTransitionWarning.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseEvalRTUTransitionWarning.setDescription('This notification is sent when Evaluation to Right to use (RTU) license transition is about to happen. The first notification will be sent 10 days before the transition and second notification will be sent 5 days before the transition.')
clmgmtLicenseEvalRTUTransition = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 543, 0, 14)).setObjects(("CISCO-LICENSE-MGMT-MIB", "clmgmtFeatureName"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtFeatureVersion"))
if mibBuilder.loadTexts: clmgmtLicenseEvalRTUTransition.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseEvalRTUTransition.setDescription('This notification is sent, when a feature license transitions from a evaluation to a Right to use (RTU) license.')
ciscoLicenseMgmtCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 543, 2, 1))
ciscoLicenseMgmtGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 543, 2, 2))
ciscoLicenseMgmtCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 543, 2, 1, 1)).setObjects(("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseDeploymentGroup"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseDeviceInformationGroup"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseInformationGroup"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicensableFeatureInformationGroup"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseDevCredGroup"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseNotificationEnableGroup"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseUsageNotifGroup"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseDeploymentNotifGroup"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseErrorNotifGroup"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseStoreInformationGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoLicenseMgmtCompliance = ciscoLicenseMgmtCompliance.setStatus('deprecated')
if mibBuilder.loadTexts: ciscoLicenseMgmtCompliance.setDescription('Compliance statement for Cisco license mgmt MIB.')
ciscoLicenseMgmtComplianceRev1 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 543, 2, 1, 2)).setObjects(("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseDeploymentGroup"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseDeviceInformationGroup"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseInformationGroup"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicensableFeatureInformationGroup"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseDevCredGroup"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseNotificationEnableGroup"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseUsageNotifGroup"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseDeploymentNotifGroup"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseErrorNotifGroup"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseStoreInformationGroup"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseSubscriptionGroup"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseSubscriptionUsageNotifGroup"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseRTUGroup"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseRTUUsageNotifGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoLicenseMgmtComplianceRev1 = ciscoLicenseMgmtComplianceRev1.setStatus('current')
if mibBuilder.loadTexts: ciscoLicenseMgmtComplianceRev1.setDescription('Compliance statement for Cisco license mgmt MIB.')
clmgmtLicenseDeploymentGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 543, 2, 2, 1)).setObjects(("CISCO-LICENSE-MGMT-MIB", "clmgmtNextFreeLicenseActionIndex"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseActionEntPhysicalIndex"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseActionTransferProtocol"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseServerAddressType"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseServerAddress"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseServerUsername"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseServerPassword"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseFile"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseStore"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseActionLicenseIndex"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicensePermissionTicketFile"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseRehostTicketFile"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseBackupFile"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseStopOnFailure"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseAction"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseActionState"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseJobQPosition"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseActionFailCause"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseActionStorageType"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseActionRowStatus"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseIndivActionState"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseIndivActionFailCause"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseAcceptEULA"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseEULAFile"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    clmgmtLicenseDeploymentGroup = clmgmtLicenseDeploymentGroup.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseDeploymentGroup.setDescription('A collection of objects for performing license deployment i.e., license installation, clear and revoke')
clmgmtLicenseStoreInformationGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 543, 2, 2, 2)).setObjects(("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseStoreName"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseStoreTotalSize"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseStoreSizeRemaining"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    clmgmtLicenseStoreInformationGroup = clmgmtLicenseStoreInformationGroup.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseStoreInformationGroup.setDescription('A collection of objects that provide information about license storages in the device.')
clmgmtLicenseDeviceInformationGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 543, 2, 2, 3)).setObjects(("CISCO-LICENSE-MGMT-MIB", "clmgmtDefaultLicenseStore"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    clmgmtLicenseDeviceInformationGroup = clmgmtLicenseDeviceInformationGroup.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseDeviceInformationGroup.setDescription('A collection of objects that provide information about device level licensing support information in the device.')
clmgmtLicenseInformationGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 543, 2, 2, 4)).setObjects(("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseFeatureName"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseFeatureVersion"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseType"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseCounted"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseValidityPeriod"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseValidityPeriodRemaining"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseExpiredPeriod"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseMaxUsageCount"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseUsageCountRemaining"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseEULAStatus"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseComments"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    clmgmtLicenseInformationGroup = clmgmtLicenseInformationGroup.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseInformationGroup.setDescription('A collection of objects that provide information about licenses and its state.')
clmgmtLicensableFeatureInformationGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 543, 2, 2, 5)).setObjects(("CISCO-LICENSE-MGMT-MIB", "clmgmtFeatureName"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtFeatureVersion"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtFeatureValidityPeriodRemaining"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtFeatureWhatIsCounted"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    clmgmtLicensableFeatureInformationGroup = clmgmtLicensableFeatureInformationGroup.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicensableFeatureInformationGroup.setDescription('A collection of objects that provide information about licensable features in the software image.')
clmgmtLicenseDevCredGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 543, 2, 2, 6)).setObjects(("CISCO-LICENSE-MGMT-MIB", "clmgmtNextFreeDevCredExportActionIndex"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtDevCredEntPhysicalIndex"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtDevCredTransferProtocol"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtDevCredServerAddressType"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtDevCredServerAddress"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtDevCredServerUsername"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtDevCredServerPassword"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtDevCredExportFile"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtDevCredCommand"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtDevCredCommandState"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtDevCredCommandFailCause"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtDevCredStorageType"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtDevCredRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    clmgmtLicenseDevCredGroup = clmgmtLicenseDevCredGroup.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseDevCredGroup.setDescription('A collection of objects for exporting device credentials from the device.')
clmgmtLicenseNotificationEnableGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 543, 2, 2, 7)).setObjects(("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseUsageNotifEnable"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseDeploymentNotifEnable"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseErrorNotifEnable"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    clmgmtLicenseNotificationEnableGroup = clmgmtLicenseNotificationEnableGroup.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseNotificationEnableGroup.setDescription('A collection of objects for controlling (enabling/disabling) license notifications to a management application.')
clmgmtLicenseUsageNotifGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 9, 9, 543, 2, 2, 8)).setObjects(("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseExpired"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseExpiryWarning"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseUsageCountExceeded"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseUsageCountAboutToExceed"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    clmgmtLicenseUsageNotifGroup = clmgmtLicenseUsageNotifGroup.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseUsageNotifGroup.setDescription('A collection of notifications related to license usage.')
clmgmtLicenseDeploymentNotifGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 9, 9, 543, 2, 2, 9)).setObjects(("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseInstalled"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseCleared"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseRevoked"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseEULAAccepted"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    clmgmtLicenseDeploymentNotifGroup = clmgmtLicenseDeploymentNotifGroup.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseDeploymentNotifGroup.setDescription('A collection of notifications related to license deployment.')
clmgmtLicenseErrorNotifGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 9, 9, 543, 2, 2, 10)).setObjects(("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseNotEnforced"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    clmgmtLicenseErrorNotifGroup = clmgmtLicenseErrorNotifGroup.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseErrorNotifGroup.setDescription('A collection of notifications related to license errors.')
clmgmtLicenseSubscriptionGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 543, 2, 2, 11)).setObjects(("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseStartDate"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseEndDate"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtFeatureStartDate"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtFeatureEndDate"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    clmgmtLicenseSubscriptionGroup = clmgmtLicenseSubscriptionGroup.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseSubscriptionGroup.setDescription('A collection of objects that provide information specific to subscription licenses.')
clmgmtLicenseSubscriptionUsageNotifGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 9, 9, 543, 2, 2, 12)).setObjects(("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseSubscriptionExpiryWarning"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseSubscriptionExtExpiryWarning"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseSubscriptionExpired"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    clmgmtLicenseSubscriptionUsageNotifGroup = clmgmtLicenseSubscriptionUsageNotifGroup.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseSubscriptionUsageNotifGroup.setDescription('A collection of notifications related to usage of subscription licenses.')
clmgmtLicenseRTUGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 543, 2, 2, 13)).setObjects(("CISCO-LICENSE-MGMT-MIB", "clmgmtLicensePeriodUsed"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtFeaturePeriodUsed"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    clmgmtLicenseRTUGroup = clmgmtLicenseRTUGroup.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseRTUGroup.setDescription('A collection of objects that provide information specific to Right to use (RTU) licenses.')
clmgmtLicenseRTUUsageNotifGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 9, 9, 543, 2, 2, 14)).setObjects(("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseEvalRTUTransitionWarning"), ("CISCO-LICENSE-MGMT-MIB", "clmgmtLicenseEvalRTUTransition"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    clmgmtLicenseRTUUsageNotifGroup = clmgmtLicenseRTUUsageNotifGroup.setStatus('current')
if mibBuilder.loadTexts: clmgmtLicenseRTUUsageNotifGroup.setDescription('A collection of notifications related to Right to use (RTU) licenses.')
mibBuilder.exportSymbols("CISCO-LICENSE-MGMT-MIB", clmgmtLicenseExpiredPeriod=clmgmtLicenseExpiredPeriod, clmgmtLicenseInformationGroup=clmgmtLicenseInformationGroup, ciscoLicenseMgmtCompliances=ciscoLicenseMgmtCompliances, clmgmtLicenseActionState=clmgmtLicenseActionState, clmgmtLicenseDevCredGroup=clmgmtLicenseDevCredGroup, clmgmtLicenseIndivActionFailCause=clmgmtLicenseIndivActionFailCause, clmgmtLicenseValidityPeriod=clmgmtLicenseValidityPeriod, ciscoLicenseMgmtGroups=ciscoLicenseMgmtGroups, clmgmtLicenseActionEntPhysicalIndex=clmgmtLicenseActionEntPhysicalIndex, clmgmtLicenseRTUUsageNotifGroup=clmgmtLicenseRTUUsageNotifGroup, clmgmtLicenseActionResultEntry=clmgmtLicenseActionResultEntry, clmgmtLicenseStore=clmgmtLicenseStore, clmgmtLicensableFeatureTable=clmgmtLicensableFeatureTable, clmgmtLicenseIndivActionState=clmgmtLicenseIndivActionState, clmgmtFeatureEndDate=clmgmtFeatureEndDate, clmgmtLicenseServerUsername=clmgmtLicenseServerUsername, clmgmtLicenseDeploymentGroup=clmgmtLicenseDeploymentGroup, clmgmtLicenseStoreUsed=clmgmtLicenseStoreUsed, clmgmtDevCredCommandFailCause=clmgmtDevCredCommandFailCause, clmgmtLicenseStartDate=clmgmtLicenseStartDate, clmgmtLicenseErrorNotifGroup=clmgmtLicenseErrorNotifGroup, clmgmtLicenseInstalled=clmgmtLicenseInstalled, clmgmtLicenseSubscriptionExpiryWarning=clmgmtLicenseSubscriptionExpiryWarning, clmgmtLicenseAcceptEULA=clmgmtLicenseAcceptEULA, clmgmtLicenseCleared=clmgmtLicenseCleared, ClmgmtLicenseTransferProtocol=ClmgmtLicenseTransferProtocol, clmgmtLicenseActionTransferProtocol=clmgmtLicenseActionTransferProtocol, clmgmtLicenseDeviceInfoEntry=clmgmtLicenseDeviceInfoEntry, clmgmtFeatureName=clmgmtFeatureName, clmgmtLicenseCounted=clmgmtLicenseCounted, clmgmtLicenseSubscriptionUsageNotifGroup=clmgmtLicenseSubscriptionUsageNotifGroup, clmgmtLicenseNumber=clmgmtLicenseNumber, ciscoLicenseMgmtMIBObjects=ciscoLicenseMgmtMIBObjects, clmgmtLicenseEULAFile=clmgmtLicenseEULAFile, clmgmtLicenseStoreIndex=clmgmtLicenseStoreIndex, clmgmtLicenseActionLicenseIndex=clmgmtLicenseActionLicenseIndex, clmgmtLicenseStoreSizeRemaining=clmgmtLicenseStoreSizeRemaining, clmgmtLicenseUsageNotifGroup=clmgmtLicenseUsageNotifGroup, ClmgmtLicenseIndexOrZero=ClmgmtLicenseIndexOrZero, clmgmtFeatureWhatIsCounted=clmgmtFeatureWhatIsCounted, clmgmtLicenseMaxUsageCount=clmgmtLicenseMaxUsageCount, clmgmtLicenseServerPassword=clmgmtLicenseServerPassword, clmgmtLicenseInfoEntry=clmgmtLicenseInfoEntry, clmgmtFeatureIndex=clmgmtFeatureIndex, clmgmtLicenseStatus=clmgmtLicenseStatus, clmgmtLicenseNotEnforced=clmgmtLicenseNotEnforced, clmgmtLicenseSubscriptionGroup=clmgmtLicenseSubscriptionGroup, clmgmtLicenseUsageCountAboutToExceed=clmgmtLicenseUsageCountAboutToExceed, clmgmtLicenseActionStorageType=clmgmtLicenseActionStorageType, clmgmtLicenseConfiguration=clmgmtLicenseConfiguration, clmgmtFeaturePeriodUsed=clmgmtFeaturePeriodUsed, clmgmtLicenseActionIndex=clmgmtLicenseActionIndex, clmgmtLicenseStopOnFailure=clmgmtLicenseStopOnFailure, clmgmtLicenseSubscriptionExpired=clmgmtLicenseSubscriptionExpired, ClmgmtLicenseActionState=ClmgmtLicenseActionState, ClmgmtLicenseActionFailCause=ClmgmtLicenseActionFailCause, clmgmtLicenseServerAddressType=clmgmtLicenseServerAddressType, clmgmtLicenseType=clmgmtLicenseType, clmgmtLicenseServerAddress=clmgmtLicenseServerAddress, clmgmtDevCredServerAddressType=clmgmtDevCredServerAddressType, clmgmtLicenseRTUGroup=clmgmtLicenseRTUGroup, clmgmtLicenseBackupFile=clmgmtLicenseBackupFile, clmgmtLicenseUsageNotifEnable=clmgmtLicenseUsageNotifEnable, clmgmtLicenseEvalRTUTransitionWarning=clmgmtLicenseEvalRTUTransitionWarning, clmgmtLicenseRehostTicketFile=clmgmtLicenseRehostTicketFile, ClmgmtLicenseIndex=ClmgmtLicenseIndex, clmgmtLicenseDeviceInfoTable=clmgmtLicenseDeviceInfoTable, clmgmtDevCredCommand=clmgmtDevCredCommand, ciscoLicenseMgmtCompliance=ciscoLicenseMgmtCompliance, clmgmtLicenseValidityPeriodRemaining=clmgmtLicenseValidityPeriodRemaining, clmgmtLicenseEndDate=clmgmtLicenseEndDate, clmgmtDevCredRowStatus=clmgmtDevCredRowStatus, clmgmtLicenseRevoked=clmgmtLicenseRevoked, clmgmtDevCredServerUsername=clmgmtDevCredServerUsername, ciscoLicenseMgmtMIBNotifs=ciscoLicenseMgmtMIBNotifs, clmgmtLicenseUsageCountExceeded=clmgmtLicenseUsageCountExceeded, clmgmtLicenseActionResultTable=clmgmtLicenseActionResultTable, clmgmtLicenseActionEntry=clmgmtLicenseActionEntry, clmgmtDevCredServerPassword=clmgmtDevCredServerPassword, clmgmtDevCredStorageType=clmgmtDevCredStorageType, ciscoLicenseMgmtMIBConform=ciscoLicenseMgmtMIBConform, clmgmtFeatureStartDate=clmgmtFeatureStartDate, clmgmtLicensableFeatureInformationGroup=clmgmtLicensableFeatureInformationGroup, clmgmtLicenseAction=clmgmtLicenseAction, ciscoLicenseMgmtComplianceRev1=ciscoLicenseMgmtComplianceRev1, clmgmtLicenseExpired=clmgmtLicenseExpired, clmgmtDevCredTransferProtocol=clmgmtDevCredTransferProtocol, clmgmtLicenseDeviceInformationGroup=clmgmtLicenseDeviceInformationGroup, clmgmtLicenseInformation=clmgmtLicenseInformation, clmgmtDevCredExportActionEntry=clmgmtDevCredExportActionEntry, clmgmtLicensableFeatureEntry=clmgmtLicensableFeatureEntry, clmgmtLicenseJobQPosition=clmgmtLicenseJobQPosition, clmgmtFeatureVersion=clmgmtFeatureVersion, clmgmtFeatureValidityPeriodRemaining=clmgmtFeatureValidityPeriodRemaining, clmgmtDevCredCommandState=clmgmtDevCredCommandState, ciscoLicenseMgmtMIB=ciscoLicenseMgmtMIB, clmgmtLicenseFeatureVersion=clmgmtLicenseFeatureVersion, clmgmtDevCredExportActionTable=clmgmtDevCredExportActionTable, clmgmtLicenseActionRowStatus=clmgmtLicenseActionRowStatus, clmgmtLicenseStoreInfoEntry=clmgmtLicenseStoreInfoEntry, clmgmtDevCredServerAddress=clmgmtDevCredServerAddress, clmgmtLicensePermissionTicketFile=clmgmtLicensePermissionTicketFile, clmgmtLicenseExpiryWarning=clmgmtLicenseExpiryWarning, clmgmtLicenseNotificationEnableGroup=clmgmtLicenseNotificationEnableGroup, clmgmtLicenseDeviceInformation=clmgmtLicenseDeviceInformation, clmgmtLicenseInfoTable=clmgmtLicenseInfoTable, clmgmtDevCredExportFile=clmgmtDevCredExportFile, PYSNMP_MODULE_ID=ciscoLicenseMgmtMIB, clmgmtLicenseComments=clmgmtLicenseComments, clmgmtLicensePeriodUsed=clmgmtLicensePeriodUsed, clmgmtNextFreeDevCredExportActionIndex=clmgmtNextFreeDevCredExportActionIndex, clmgmtLicenseDeploymentNotifGroup=clmgmtLicenseDeploymentNotifGroup, clmgmtLicenseActionFailCause=clmgmtLicenseActionFailCause, clmgmtNextFreeLicenseActionIndex=clmgmtNextFreeLicenseActionIndex, clmgmtLicenseActionTable=clmgmtLicenseActionTable, clmgmtLicenseFile=clmgmtLicenseFile, clmgmtLicenseEvalRTUTransition=clmgmtLicenseEvalRTUTransition, clmgmtLicenseUsageCountRemaining=clmgmtLicenseUsageCountRemaining, clmgmtLicenseErrorNotifEnable=clmgmtLicenseErrorNotifEnable, clmgmtLicenseDeploymentNotifEnable=clmgmtLicenseDeploymentNotifEnable, clmgmtLicenseIndex=clmgmtLicenseIndex, clmgmtDefaultLicenseStore=clmgmtDefaultLicenseStore, clmgmtLicenseStoreInformationGroup=clmgmtLicenseStoreInformationGroup, clmgmtDevCredExportActionIndex=clmgmtDevCredExportActionIndex, clmgmtDevCredEntPhysicalIndex=clmgmtDevCredEntPhysicalIndex, clmgmtLicenseStoreName=clmgmtLicenseStoreName, clmgmtLicenseEULAStatus=clmgmtLicenseEULAStatus, clmgmtLicenseEULAAccepted=clmgmtLicenseEULAAccepted, clmgmtLicenseSubscriptionExtExpiryWarning=clmgmtLicenseSubscriptionExtExpiryWarning, clmgmtLicenseStoreInfoTable=clmgmtLicenseStoreInfoTable, clmgmtLicenseStoreTotalSize=clmgmtLicenseStoreTotalSize, clmgmtLicenseNotifObjects=clmgmtLicenseNotifObjects, clmgmtLicenseFeatureName=clmgmtLicenseFeatureName)

#
# PySNMP MIB module XYLAN-VSM-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/XYLAN-VSM-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:45:31 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, SingleValueConstraint, ConstraintsIntersection, ConstraintsUnion, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsIntersection", "ConstraintsUnion", "ValueSizeConstraint")
XylanModuleSubunit, = mibBuilder.importSymbols("CHASSIS-MIB", "XylanModuleSubunit")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
TimeTicks, ModuleIdentity, IpAddress, Integer32, Bits, ObjectIdentity, NotificationType, Unsigned32, iso, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter64, Gauge32, Counter32 = mibBuilder.importSymbols("SNMPv2-SMI", "TimeTicks", "ModuleIdentity", "IpAddress", "Integer32", "Bits", "ObjectIdentity", "NotificationType", "Unsigned32", "iso", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter64", "Gauge32", "Counter32")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
xylanVsmArch, = mibBuilder.importSymbols("XYLAN-BASE-MIB", "xylanVsmArch")
class RowStatus(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))
    namedValues = NamedValues(("active", 1), ("notInService", 2), ("notReady", 3), ("createAndGo", 4), ("createAndWait", 5), ("destroy", 6))

class VsmEnableDisabled(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("disabled", 1), ("enabled", 2))

class VsmOnOff(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("off", 1), ("on", 2))

class VsmVoiceCodingType(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))
    namedValues = NamedValues(("aLawPcm", 1), ("muLawPcm", 2), ("ituG723-53", 3), ("ituG723-63", 4), ("ituG729AB", 5), ("t38-fax", 6))

vsmNetworkGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 26, 1))
vsmSignalingGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 26, 2))
vsmCodingProfileGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 26, 3))
vsmDialSchemeGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 26, 4))
vsmPhysicalGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 26, 5))
vsmConfigControlGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 26, 6))
vsmStatsGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 26, 7))
vsmVNTemplateTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 26, 1, 1), )
if mibBuilder.loadTexts: vsmVNTemplateTable.setStatus('mandatory')
if mibBuilder.loadTexts: vsmVNTemplateTable.setDescription('This table is not supported')
vsmVNTemplateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 26, 1, 1, 1), ).setIndexNames((0, "XYLAN-VSM-MIB", "vsmVNTmplIndex"))
if mibBuilder.loadTexts: vsmVNTemplateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vsmVNTemplateEntry.setDescription('This is an entry in the vsmVNTemplateTable. This table is not supported')
vsmVNTmplIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 1, 1, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmVNTmplIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vsmVNTmplIndex.setDescription('Integer index into this table. For more information, please see the following CLI command: [Note: There is NO equivalent command in the CLI.] ')
vsmVNTmplName = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 1, 1, 1, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmVNTmplName.setStatus('deprecated')
if mibBuilder.loadTexts: vsmVNTmplName.setDescription("This is not supported. For more information, please see the following CLI command: voice network template 'vsmNetworkTemplateName' ")
vsmVNTmplRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 1, 1, 1, 3), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmVNTmplRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vsmVNTmplRowStatus.setDescription('This object is the RowStatus (locking flag) for creating the vsmVNTemplateTable conceptual row. This table is not supported.')
vsmVNTmplH323GateKeeperPhoneGroupTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 26, 1, 2), )
if mibBuilder.loadTexts: vsmVNTmplH323GateKeeperPhoneGroupTable.setStatus('mandatory')
if mibBuilder.loadTexts: vsmVNTmplH323GateKeeperPhoneGroupTable.setDescription('This table is not supported.')
vsmVNTmplH323GateKeeperPhoneGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 26, 1, 2, 1), ).setIndexNames((0, "XYLAN-VSM-MIB", "vsmVNTmplName"), (0, "XYLAN-VSM-MIB", "vsmPhoneGroupName"))
if mibBuilder.loadTexts: vsmVNTmplH323GateKeeperPhoneGroupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vsmVNTmplH323GateKeeperPhoneGroupEntry.setDescription('This is an entry in the vsmVNTemplateTable. This table is not supported. ')
vsmVNTmplH323GateKeeperPhoneGroupRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 1, 2, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmVNTmplH323GateKeeperPhoneGroupRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vsmVNTmplH323GateKeeperPhoneGroupRowStatus.setDescription('Note: destroy(6) is not supported in this release. This table is not supported ')
vsmVNCardTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 26, 1, 3), )
if mibBuilder.loadTexts: vsmVNCardTable.setStatus('mandatory')
if mibBuilder.loadTexts: vsmVNCardTable.setDescription('This table contains information for each network interface.')
vsmVNCardEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 26, 1, 3, 1), ).setIndexNames((0, "XYLAN-VSM-MIB", "vsmCardSlotIndex"), (0, "XYLAN-VSM-MIB", "vsmCardSubunitIndex"))
if mibBuilder.loadTexts: vsmVNCardEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vsmVNCardEntry.setDescription('This is an entry in the vsmVNCardTable. For more information, please see the following CLI command: [Note: There is NO equivalent command in the CLI.] ')
vsmVNCardH323DisplayName = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 1, 3, 1, 1), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmVNCardH323DisplayName.setStatus('mandatory')
if mibBuilder.loadTexts: vsmVNCardH323DisplayName.setDescription("Specifies the display name information that is carried in the H.323 setup messages. The display-name string is inserted into the Q.931 display information field and in the sourceAddress field of the H.323 setup-UUIE. The string can be up to 64 bytes. For more information, please see the following CLI command: voice network card slot/card h.323 display name 'string' ")
vsmVNCardRTPPortMode = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 1, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dynamic", 1), ("sequential", 2))).clone('dynamic')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmVNCardRTPPortMode.setStatus('mandatory')
if mibBuilder.loadTexts: vsmVNCardRTPPortMode.setDescription('Selects the method of port number assignment for RTP and RTCP ports. For more information, please see the following CLI command: voice network card slot/card h.323 rtp port mode dynamic voice network card slot/card h.323 rtp port mode sequential ')
vsmVNCardRTPPortBase = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 1, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65534)).clone(30000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmVNCardRTPPortBase.setStatus('mandatory')
if mibBuilder.loadTexts: vsmVNCardRTPPortBase.setDescription('Selects the starting port number for assignment of RTP and RTCP ports. When H.323 calls are made an RTP or RTCP port is opened for each call. The H.323 specification states that the RTP port number should be even in value and the RTCP port number should be one greater than the RTP port value. In order to accomplish this sort of controlled allocation, the ports are assigned starting at the rtp-port-base value. CCB 0 will use ports numbered rtp-port-base and rtp-port-base + 1. CCB 1 will used the next two successive ports, etc. For more information, please see the following CLI command: voice network card slot/card h.323 rtp port base value ')
vsmVNCardH323OutFastStart = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 1, 3, 1, 4), VsmEnableDisabled().clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmVNCardH323OutFastStart.setStatus('deprecated')
if mibBuilder.loadTexts: vsmVNCardH323OutFastStart.setDescription('This command is used to select the H.323 Fast Start mode on the outgoing side of the link. For more information, please see the following CLI command: voice daughter card slot/daughter_card_number h.323 out[going] fast start on voice daughter card slot/daughter_card_number h.323 out[going] fast start off ')
vsmVNCardH323InFastStart = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 1, 3, 1, 5), VsmEnableDisabled().clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmVNCardH323InFastStart.setStatus('mandatory')
if mibBuilder.loadTexts: vsmVNCardH323InFastStart.setDescription('This command is used to select the H.323 Fast Start mode on the incoming side of the link. For more information, please see the following CLI command: voice daughter card slot/daughter_card_number h.323 in[coming] fast start on voice daughter card slot/daughter_card_number h.323 in[coming] fast start off ')
vsmVNCardH323GatekeeperCtrl = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 1, 3, 1, 6), VsmEnableDisabled().clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmVNCardH323GatekeeperCtrl.setStatus('mandatory')
if mibBuilder.loadTexts: vsmVNCardH323GatekeeperCtrl.setDescription('Specifies whether GateKeeper control is on or off. If enabled, then the vsmVNTmplH323GatekeeperMode also needs to be specified. For more information, please see the following CLI command: voice network card slot/card h.323 gatekeeper control on voice network card slot/card h.323 gatekeeper control off ')
vsmVNCardH323GatekeeperMode = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 1, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("manual", 2), ("auto", 3))).clone('manual')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmVNCardH323GatekeeperMode.setStatus('mandatory')
if mibBuilder.loadTexts: vsmVNCardH323GatekeeperMode.setDescription("Controls gatekeeper operation. Internally, the setting affects two different variables in the HSMU configuration: The HSMU configuration field use_GK controls gatekeeper operation being enabled or disabled. When enabled, the configuration field auto_GK_discovery determines automatic or manual discovery. These are collapsed into one command for convenience. Note: 'auto (3)' is not suppoted in this release. For more information, please see the following CLI command: voice network card slot/card h.323 gatekeeper control off voice network card slot/card h.323 gatekeeper mode manual Note: The following are not supported in this Release voice network card slot/card h.323 gatekeeper mode auto ")
vsmVNCardH323GatekeeperAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 1, 3, 1, 8), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmVNCardH323GatekeeperAddr.setStatus('mandatory')
if mibBuilder.loadTexts: vsmVNCardH323GatekeeperAddr.setDescription('Specifies the address of the gatekeeper when configured for manual mode. Only the IP address needs to be specified, as port 1719 is used. For more information, please see the following CLI command: voice network card slot/card h.323 gatekeeper address xxx.xxx.xxx.xxx ')
vsmVNCardH323AllowCallsWithoutGatekeeper = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 1, 3, 1, 9), VsmEnableDisabled().clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmVNCardH323AllowCallsWithoutGatekeeper.setStatus('mandatory')
if mibBuilder.loadTexts: vsmVNCardH323AllowCallsWithoutGatekeeper.setDescription('This command is used to inform the H.323 stack to allow calls when the endpoint is not registered with a gatekeeper. The endpoint can remain unregistered for two reasons: 1. The gatekeeper could not be found. (Auto discovery failed, an incorrect address was specified for manual mode, or the gatekeeper simply is not responding.) 2. The gatekeeper was discovered but the registration was rejected. This could occur because of a policy implemented in the gatekeeper that is limiting registration of a particular endpoint. Enabled is true and disabled is false. For more information, please see the following CLI command: voice network card slot/card h.323 allow calls without gatekeeper true voice network card slot/card h.323 allow calls without gatekeeper false ')
vsmVNCardH323GatekeeperMaxRetries = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 1, 3, 1, 10), Integer32().clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmVNCardH323GatekeeperMaxRetries.setStatus('mandatory')
if mibBuilder.loadTexts: vsmVNCardH323GatekeeperMaxRetries.setDescription('Specifies how many registration attempts will be made before the endpoint considers itself to have failed registration. Once this number of unsuccessful attempts have been made, the endpoint will only be able to place calls if allow-calls-without-gatekeeper is true. For more information, please see the following CLI command: voice network card slot/card h.323 gatekeeper maximum tries number ')
vsmVNCardH323EndpointRegType = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 1, 3, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("gateway", 1), ("terminal", 2))).clone('gateway')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmVNCardH323EndpointRegType.setStatus('mandatory')
if mibBuilder.loadTexts: vsmVNCardH323EndpointRegType.setDescription('Specifies the endpoint registration type. This should not be confused with the H.245 terminal type, although the two parameters should be programmed consistently. This parameter specifies how the endpoint will register itself with the gatekeeper, and has nothing to do with master/slave determination. For more information, please see the following CLI command: voice network card slot/card h.323 endpoint registration type gateway voice network card slot/card h.323 endpoint registration type terminal ')
vsmVNCardH323Notification = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 1, 3, 1, 12), VsmEnableDisabled().clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmVNCardH323Notification.setStatus('deprecated')
if mibBuilder.loadTexts: vsmVNCardH323Notification.setDescription('This object is no longer supported.')
vsmVNCardH323GateKeeperPhoneGroupTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 26, 1, 4), )
if mibBuilder.loadTexts: vsmVNCardH323GateKeeperPhoneGroupTable.setStatus('mandatory')
if mibBuilder.loadTexts: vsmVNCardH323GateKeeperPhoneGroupTable.setDescription('This table contains arrays of Phone Group that are associated with the gatekeeper. ')
vsmVNCardH323GateKeeperPhoneGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 26, 1, 4, 1), ).setIndexNames((0, "XYLAN-VSM-MIB", "vsmCardSlotIndex"), (0, "XYLAN-VSM-MIB", "vsmCardSubunitIndex"), (0, "XYLAN-VSM-MIB", "vsmPhoneGroupName"))
if mibBuilder.loadTexts: vsmVNCardH323GateKeeperPhoneGroupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vsmVNCardH323GateKeeperPhoneGroupEntry.setDescription("This is an entry in the vsmVNCardTable. For more information, please see the following CLI command: voice network card slot/card h.323 gatekeeper associate phone group 'phoneGrpName' voice network card slot/card h.323 gatekeeper disassociate phone group 'phoneGrpName' ")
vsmVNCardH323GateKeeperPhoneGroupRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 1, 4, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmVNCardH323GateKeeperPhoneGroupRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vsmVNCardH323GateKeeperPhoneGroupRowStatus.setDescription("Note: destroy(6) is not supported in this release. For more information, please see the following CLI command: voice network card slot/card h.323 gatekeeper associate phone group 'phoneGrpName' voice network card slot/card h.323 gatekeeper disassociate phone group 'phoneGrpName' ")
vsmSignalingTemplateTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 1), )
if mibBuilder.loadTexts: vsmSignalingTemplateTable.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSignalingTemplateTable.setDescription('This table contains information for each telephony signaling interface template. This table is not supported ')
vsmSignalingTemplateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 1, 1), ).setIndexNames((0, "XYLAN-VSM-MIB", "vsmSigTmplIndex"))
if mibBuilder.loadTexts: vsmSignalingTemplateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSignalingTemplateEntry.setDescription('This is an entry in the vsmSignalingTemplateTable. This table is not supported For more information, please see the following CLI command: [Note: There is NO equivalent command in the CLI.] ')
vsmSigTmplIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 1, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigTmplIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigTmplIndex.setDescription('Integer index into this table. This table is not supported -- For more information, please see the following CLI command: -- [Note: There is NO equivalent command in the CLI.] ')
vsmSigTmplName = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 1, 1, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigTmplName.setStatus('deprecated')
if mibBuilder.loadTexts: vsmSigTmplName.setDescription("This is not supported. For more information, please see the following CLI command: voice signaling template 'signalingTemplateName' ")
vsmSigTmplRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 1, 1, 3), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigTmplRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigTmplRowStatus.setDescription("This object is the RowStatus (locking flag) for creating the vsm Signaling Template Table conceptual row. This table is not supported. -- CreateAndWait is -- not supported with this table. In order to do a createAndGo, -- the required fields to create a row must be passed in the PDU. -- For more information, please see the following CLI command: -- voice no signaling template 'signalingTemplateName' ")
vsmSigTmplEmCommonTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 2), )
if mibBuilder.loadTexts: vsmSigTmplEmCommonTable.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigTmplEmCommonTable.setDescription('This table contains information that is used for all E&M type signaling protocols. This table is not supported. ')
vsmSigTmplEmCommonEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 2, 1), ).setIndexNames((0, "XYLAN-VSM-MIB", "vsmSigTmplIndex"))
if mibBuilder.loadTexts: vsmSigTmplEmCommonEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigTmplEmCommonEntry.setDescription('This is an entry in the E&M Common Signaling Table. This is not supported. For more information, please see the following CLI command: [Note: There is NO equivalent command in the CLI.] ')
vsmSigTmplEmCommonOffHookDebounce = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 1000)).clone(50)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigTmplEmCommonOffHookDebounce.setStatus('deprecated')
if mibBuilder.loadTexts: vsmSigTmplEmCommonOffHookDebounce.setDescription("The time, in milliseconds, to allow to de-bounce a transition to an offhook state. This is not supported -- For more information, please see the following CLI command: -- voice signaling template 'signalingTemplateName' em off hook debounce (5..1000) ")
vsmSigTmplEmDelayTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 3), )
if mibBuilder.loadTexts: vsmSigTmplEmDelayTable.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigTmplEmDelayTable.setDescription('This table contains entries that specify how to perform E&M Delay signaling on the port indicated. This is not supported')
vsmSigTmplEmDelayEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 3, 1), ).setIndexNames((0, "XYLAN-VSM-MIB", "vsmSigTmplIndex"))
if mibBuilder.loadTexts: vsmSigTmplEmDelayEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigTmplEmDelayEntry.setDescription('This is an entry in the E&M Delay Signaling Table. This is not supported. -- For more information, please see the following CLI command: -- [Note: There is NO equivalent command in the CLI.] ')
vsmSigTmplEmDelayInDelayDurMin = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 60000)).clone(200)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigTmplEmDelayInDelayDurMin.setStatus('deprecated')
if mibBuilder.loadTexts: vsmSigTmplEmDelayInDelayDurMin.setDescription("The minimum duration, in milliseconds, of the delay signal response to the seize detect (of incoming calls) on the M-lead. This is not supported. -- For more information, please see the following CLI command: -- voice signaling template 'signalingTemplateName' emd in delay minimum (5..60000) ")
vsmSigTmplEmImmedTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 4), )
if mibBuilder.loadTexts: vsmSigTmplEmImmedTable.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigTmplEmImmedTable.setDescription('This table contains entries that specify how to perform E&M Immediate signaling on the telephone channel. This is not supported. ')
vsmSigTmplEmImmedEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 4, 1), ).setIndexNames((0, "XYLAN-VSM-MIB", "vsmSigTmplIndex"))
if mibBuilder.loadTexts: vsmSigTmplEmImmedEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigTmplEmImmedEntry.setDescription('This is an entry in the E&M Immediate Signaling Table. This table is not supported. -- For more information, please see the following CLI command: -- [Note: There is NO equivalent command in the CLI.] ')
vsmSigTmplEmImmedGlareReport = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000)).clone(5000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigTmplEmImmedGlareReport.setStatus('deprecated')
if mibBuilder.loadTexts: vsmSigTmplEmImmedGlareReport.setDescription("Specifies, how long, in milliseconds, the interface should remain off hook after detecting a glare condition to indicate congestion. This is not supported. -- For more information, please see the following CLI command: -- voice signaling template 'signalingTemplateName' emi glare report (0..60000) ")
vsmSigTmplEmWinkTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 5), )
if mibBuilder.loadTexts: vsmSigTmplEmWinkTable.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigTmplEmWinkTable.setDescription('This table contains entries that specify how to perform E&M Wink signaling on the channel indicated. This is not supported.')
vsmSigTmplEmWinkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 5, 1), ).setIndexNames((0, "XYLAN-VSM-MIB", "vsmSigTmplIndex"))
if mibBuilder.loadTexts: vsmSigTmplEmWinkEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigTmplEmWinkEntry.setDescription('This is an entry in the E&M Wink Signaling Table. This is not supported. -- For more information, please see the following CLI command: -- [Note: There is NO equivalent command in the CLI.] ')
vsmSigTmplEmWinkInWinkWaitMin = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 60000)).clone(150)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigTmplEmWinkInWinkWaitMin.setStatus('deprecated')
if mibBuilder.loadTexts: vsmSigTmplEmWinkInWinkWaitMin.setDescription("Specifies the minimum delay, in milliseconds, before beginning the wink on the E-lead after detecting a line seizure on the M-lead during an incoming call. This is not supported. -- For more information, please see the following CLI command: -- voice signaling template 'signalingTemplateName' emw in wink wait minimum (5..60000) ")
vsmSigTmplFxoGSTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 6), )
if mibBuilder.loadTexts: vsmSigTmplFxoGSTable.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigTmplFxoGSTable.setDescription('This table contains entries that specify how to perform Foreign Exchange Office (FXO) ground start signaling on the port indicated. This is not supported. ')
vsmSigTmplFxoGSEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 6, 1), ).setIndexNames((0, "XYLAN-VSM-MIB", "vsmSigTmplIndex"))
if mibBuilder.loadTexts: vsmSigTmplFxoGSEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigTmplFxoGSEntry.setDescription('This is an entry in the FXO ground start Signaling Table. This is not supported. -- For more information, please see the following CLI command: -- [Note: There is NO equivalent command in the CLI.] ')
vsmSigTmplFxoGSConnectionLoopOpenDebounce = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 6000)).clone(150)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigTmplFxoGSConnectionLoopOpenDebounce.setStatus('deprecated')
if mibBuilder.loadTexts: vsmSigTmplFxoGSConnectionLoopOpenDebounce.setDescription("Debounce interval for loop open detection for an existing conection. This is not supported. -- For more information, please see the following CLI command: -- voice signaling template 'signalingTemplateName' fxo gs connection loop open debounce (1..60000) ")
vsmSigTmplFxoLSTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 7), )
if mibBuilder.loadTexts: vsmSigTmplFxoLSTable.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigTmplFxoLSTable.setDescription('This table contains entries that specify how to perform FXO Loop start signaling on the port indicated. This is not supported. ')
vsmSigTmplFxoLSEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 7, 1), ).setIndexNames((0, "XYLAN-VSM-MIB", "vsmSigTmplIndex"))
if mibBuilder.loadTexts: vsmSigTmplFxoLSEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigTmplFxoLSEntry.setDescription('This is an entry in the FXO Loop start Signaling Table. This is not supported. For more information, please see the following CLI command: [Note: There is NO equivalent command in the CLI.] ')
vsmSigTmplFxoLSRingingDebounce = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 7, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000)).clone(50)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigTmplFxoLSRingingDebounce.setStatus('deprecated')
if mibBuilder.loadTexts: vsmSigTmplFxoLSRingingDebounce.setDescription("When a ring signal is modulated by the ringing frequency, the debouncer is used to debounce the incoming ring signal. This is not supported. -- For more information, please see the following CLI command: -- voice signaling template 'signalingTemplateName' fxo ls ringing debounce (1..1000) ")
vsmSigTmplFxsGSTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 8), )
if mibBuilder.loadTexts: vsmSigTmplFxsGSTable.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigTmplFxsGSTable.setDescription('This table contains entries that specify how to perform Foreign Exchange Station (FXS) ground start signaling on the port indicated. This is not supported. ')
vsmSigTmplFxsGSEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 8, 1), ).setIndexNames((0, "XYLAN-VSM-MIB", "vsmSigTmplIndex"))
if mibBuilder.loadTexts: vsmSigTmplFxsGSEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigTmplFxsGSEntry.setDescription('This is an entry in the FXS ground start signaling Table. This is not supported. -- For more information, please see the following CLI command: -- [Note: There is NO equivalent command in the CLI.] ')
vsmSigTmplFxsGSSeizeDetect = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 8, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5000)).clone(150)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigTmplFxsGSSeizeDetect.setStatus('deprecated')
if mibBuilder.loadTexts: vsmSigTmplFxsGSSeizeDetect.setDescription("The time to wait before an off-hook condition is declared. -- For more information, please see the following CLI command: -- voice signaling template 'signalingTemplateName' fxs gs seize detect (1..5000) ")
vsmSigTmplFxsLSTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 9), )
if mibBuilder.loadTexts: vsmSigTmplFxsLSTable.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigTmplFxsLSTable.setDescription('This table contains entries that specify how to perform Foreign Exchange Station (FXS) Loop signaling on the port indicated This is not supported. ')
vsmSigTmplFxsLSEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 9, 1), ).setIndexNames((0, "XYLAN-VSM-MIB", "vsmSigTmplIndex"))
if mibBuilder.loadTexts: vsmSigTmplFxsLSEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigTmplFxsLSEntry.setDescription('This is an entry in the FXS Loop Signaling Table. This is not supported. -- For more information, please see the following CLI command: -- [Note: There is NO equivalent command in the CLI.] ')
vsmSigTmplFxsLSOffHookDebounce = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 9, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000)).clone(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigTmplFxsLSOffHookDebounce.setStatus('deprecated')
if mibBuilder.loadTexts: vsmSigTmplFxsLSOffHookDebounce.setDescription("Debounce interval to offhook transition. This is not supported. -- For more information, please see the following CLI command: -- voice signaling template 'signalingTemplateName' fxs ls off hook debounce (1..1000) ")
vsmSignalingChannelTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 10), )
if mibBuilder.loadTexts: vsmSignalingChannelTable.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSignalingChannelTable.setDescription('This table contains information for each telephony signaling interface. ')
vsmSignalingChannelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 10, 1), ).setIndexNames((0, "XYLAN-VSM-MIB", "vsmChanSlotIndex"), (0, "XYLAN-VSM-MIB", "vsmChanPortIndex"), (0, "XYLAN-VSM-MIB", "vsmChanIndex"))
if mibBuilder.loadTexts: vsmSignalingChannelEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSignalingChannelEntry.setDescription('This is an entry in the vsmSignalingChannelTable. For more information, please see the following CLI command: [Note: There is NO equivalent command in the CLI.] ')
vsmSigChanProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("emDelayStart", 1), ("emImmedStart", 2), ("emWinkStart", 3), ("fxoGroundStart", 4), ("fxsGroundStart", 5), ("fxoLoopStart", 6), ("fxsLoopStart", 7), ("isdn", 8))).clone('emWinkStart')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanProtocol.setDescription('The signaling protocol this template has been set up to perform. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel protocol fxs ls voice signaling channel slot/port/startChannel-endChannel protocol fxo ls voice signaling channel slot/port/startChannel-endChannel protocol fxs gs voice signaling channel slot/port/startChannel-endChannel protocol fxo gs voice signaling channel slot/port/startChannel-endChannel protocol emi voice signaling channel slot/port/startChannel-endChannel protocol emd voice signaling channel slot/port/startChannel-endChannel protocol emw voice signaling channel slot/port/startChannel-endChannel protocol ISDN ')
vsmSigChanCallerIdName = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("private", 1), ("unavailable", 2), ("available", 3))).clone('unavailable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanCallerIdName.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanCallerIdName.setDescription('The originating name to transmit may be private, unavailable or available. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel caller id name private voice signaling channel slot/port/startChannel-endChannel caller id name unavailable ')
vsmSigChanCallerIdNameStr = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 10, 1, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanCallerIdNameStr.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanCallerIdNameStr.setDescription("The caller Id name is meaningful if the vsmSigChanCallerIdType is set to available. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel caller id name 'callerIdName' ")
vsmSigChanCallerIdNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("private", 1), ("unavailable", 2), ("available", 3))).clone('unavailable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanCallerIdNumber.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanCallerIdNumber.setDescription('The originating phone number to transmit may be private, unavailable or available. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel caller id number private voice signaling channel slot/port/startChannel-endChannel caller id number unavailable ')
vsmSigChanCallerIdNumberStr = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 10, 1, 5), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanCallerIdNumberStr.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanCallerIdNumberStr.setDescription("The originating telephone number to transmit is only meaningful if vsmSigChanCallerIdNumberType is set to available. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel caller id number 'callerIdNumber' ")
vsmSigChanToneTable = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ringing", 1), ("silence", 2))).clone('ringing')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanToneTable.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanToneTable.setDescription(' This command is used to select the Tone Table for a TCID. Tone table to use. (In the future, this parameter will probably be changed to a VSx daughter card parameter.) Value Description ===== =========== ringing Default. Typically set for a normal ringback sound silence Typically set for a silent ringback. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel tone table ringing voice signaling channel slot/port/startChannel-endChannel tone table silence ')
vsmSigChanOutWait = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 10, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 20000)).clone(400)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanOutWait.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanOutWait.setDescription('The time to delay after going off-hook, before generating the first outbound dial digit(s). For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel out wait (0..20000) ')
vsmSigChanOutToneDigitDur = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 10, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(25, 2000)).clone(200)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanOutToneDigitDur.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanOutToneDigitDur.setDescription('This is the duration, in milliseconds, of a tone that is generated when tone dialing is used. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel out tone digit duration (25..2000) ')
vsmSigChanOutToneInterDigitDur = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 10, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(25, 2000)).clone(200)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanOutToneInterDigitDur.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanOutToneInterDigitDur.setDescription('This is the duration, in milliseconds, of the inter digit gap when tone dialing is used. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel out tone interdigit duration (25..2000) ')
vsmSigChanUnused = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 10, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 0))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanUnused.setStatus('deprecated')
if mibBuilder.loadTexts: vsmSigChanUnused.setDescription('This object is no longer supported. Was vsmSigTmplOutToneAmplitude.')
vsmSigChanCallLimitCtrl = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 10, 1, 11), VsmEnableDisabled().clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanCallLimitCtrl.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanCallLimitCtrl.setDescription('Enables or Disables call timing limit duration (vsmSigChanCallLimit). For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel no call duration limit ')
vsmSigChanCallLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 10, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65534)).clone(65534)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanCallLimit.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanCallLimit.setDescription('The call duration limit. If the call length is exceeded, the call is automatically terminated. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel call duration limit (0..65534) ')
vsmSigChanAnswerWaitLimitCtrl = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 10, 1, 13), VsmEnableDisabled().clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanAnswerWaitLimitCtrl.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanAnswerWaitLimitCtrl.setDescription('Enables or Disables call answer limit timing (vsmSigChanAnswerWaitLimit). For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel no answer wait limit ')
vsmSigChanAnswerWaitLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 10, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65534)).clone(65534)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanAnswerWaitLimit.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanAnswerWaitLimit.setDescription('The wait-for-answer time limit. If the call destination does not answer within this period, the call is automatically terminated. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel answer wait limit (0..65534) ')
vsmSigChanHangupWaitLimitCtrl = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 10, 1, 15), VsmEnableDisabled().clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanHangupWaitLimitCtrl.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanHangupWaitLimitCtrl.setDescription('Enables or Disables call hangup limit timing (vsmSigChanHangupWaitLimit). For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel no hang up wait limit ')
vsmSigChanHangupWaitLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 10, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65534)).clone(65534)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanHangupWaitLimit.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanHangupWaitLimit.setDescription('The wait-for-hang-up time limit. If the call originator does not hang up within this time period after the destination has hung up, the call is automatically terminated. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel hang up wait limit (0..65534) ')
vsmSigChanFaxHoldoverDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 10, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65534)).clone(2000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanFaxHoldoverDelay.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanFaxHoldoverDelay.setDescription('The Fax holdover delay. This is the time the system will delay after detecting on-hook during fax mode operation, before generating a call clear. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel fax holdover (0..65534) ')
vsmSigChanCompanding = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 10, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("alaw", 1), ("mulaw", 2))).clone('mulaw')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanCompanding.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanCompanding.setDescription("Select the companding used at the DSP's PCM interface. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel companding alaw voice signaling channel slot/port/startChannel-endChannel companding mulaw ")
vsmSigChanReceiveGain = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 10, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-14, 14))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanReceiveGain.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanReceiveGain.setDescription('The Receive (Rx) Gain, in dB. The reference to Rx gain is from the perspective of the Micro software. The Micro interprets receive (Rx) gain as PCM interface-to-packet network. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel receive gain 0 voice signaling channel slot/port/startChannel-endChannel receive gain -14 voice signaling channel slot/port/startChannel-endChannel receive gain -13 voice signaling channel slot/port/startChannel-endChannel receive gain -12 voice signaling channel slot/port/startChannel-endChannel receive gain -11 voice signaling channel slot/port/startChannel-endChannel receive gain -10 voice signaling channel slot/port/startChannel-endChannel receive gain -9 voice signaling channel slot/port/startChannel-endChannel receive gain -8 voice signaling channel slot/port/startChannel-endChannel receive gain -7 voice signaling channel slot/port/startChannel-endChannel receive gain -6 voice signaling channel slot/port/startChannel-endChannel receive gain -5 voice signaling channel slot/port/startChannel-endChannel receive gain -4 voice signaling channel slot/port/startChannel-endChannel receive gain -3 voice signaling channel slot/port/startChannel-endChannel receive gain -2 voice signaling channel slot/port/startChannel-endChannel receive gain -1 voice signaling channel slot/port/startChannel-endChannel receive gain 14 voice signaling channel slot/port/startChannel-endChannel receive gain 13 voice signaling channel slot/port/startChannel-endChannel receive gain 12 voice signaling channel slot/port/startChannel-endChannel receive gain 11 voice signaling channel slot/port/startChannel-endChannel receive gain 10 voice signaling channel slot/port/startChannel-endChannel receive gain 9 voice signaling channel slot/port/startChannel-endChannel receive gain 8 voice signaling channel slot/port/startChannel-endChannel receive gain 7 voice signaling channel slot/port/startChannel-endChannel receive gain 6 voice signaling channel slot/port/startChannel-endChannel receive gain 5 voice signaling channel slot/port/startChannel-endChannel receive gain 4 voice signaling channel slot/port/startChannel-endChannel receive gain 3 voice signaling channel slot/port/startChannel-endChannel receive gain 2 voice signaling channel slot/port/startChannel-endChannel receive gain 1 ')
vsmSigChanTransmitGain = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 10, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-14, 14))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanTransmitGain.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanTransmitGain.setDescription('The Transmit (Tx) Gain, in dB. The reference to Tx gain is from the perspective of the Micro software. The Micro interprets transmit (Tx) gain as packet network-to-PCM interface. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel transmit gain 0 voice signaling channel slot/port/startChannel-endChannel transmit gain -14 voice signaling channel slot/port/startChannel-endChannel transmit gain -13 voice signaling channel slot/port/startChannel-endChannel transmit gain -12 voice signaling channel slot/port/startChannel-endChannel transmit gain -11 voice signaling channel slot/port/startChannel-endChannel transmit gain -10 voice signaling channel slot/port/startChannel-endChannel transmit gain -9 voice signaling channel slot/port/startChannel-endChannel transmit gain -8 voice signaling channel slot/port/startChannel-endChannel transmit gain -7 voice signaling channel slot/port/startChannel-endChannel transmit gain -6 voice signaling channel slot/port/startChannel-endChannel transmit gain -5 voice signaling channel slot/port/startChannel-endChannel transmit gain -4 voice signaling channel slot/port/startChannel-endChannel transmit gain -3 voice signaling channel slot/port/startChannel-endChannel transmit gain -2 voice signaling channel slot/port/startChannel-endChannel transmit gain -1 voice signaling channel slot/port/startChannel-endChannel transmit gain 14 voice signaling channel slot/port/startChannel-endChannel transmit gain 13 voice signaling channel slot/port/startChannel-endChannel transmit gain 12 voice signaling channel slot/port/startChannel-endChannel transmit gain 11 voice signaling channel slot/port/startChannel-endChannel transmit gain 10 voice signaling channel slot/port/startChannel-endChannel transmit gain 9 voice signaling channel slot/port/startChannel-endChannel transmit gain 8 voice signaling channel slot/port/startChannel-endChannel transmit gain 7 voice signaling channel slot/port/startChannel-endChannel transmit gain 6 voice signaling channel slot/port/startChannel-endChannel transmit gain 5 voice signaling channel slot/port/startChannel-endChannel transmit gain 4 voice signaling channel slot/port/startChannel-endChannel transmit gain 3 voice signaling channel slot/port/startChannel-endChannel transmit gain 2 voice signaling channel slot/port/startChannel-endChannel transmit gain 1 ')
vsmSigChanIdleNoise = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 10, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-7000, 7000)).clone(7000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanIdleNoise.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanIdleNoise.setDescription('The Idle Noise level (also known as comfort noise), in 0.01dBm. a value of -5000 means -50 dbm. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel idle noise (-7000..7000) ')
vsmSigChanOverrideInBandCallProgressTones = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 10, 1, 22), VsmEnableDisabled().clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanOverrideInBandCallProgressTones.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanOverrideInBandCallProgressTones.setDescription('Enables or Disables support for passing call progress tones in band (ie, call progress tones are carried as voice) This object should only be used under the supervision of trained personnel. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel no override in band call progress tones voice signaling channel slot/port/startChannel-endChannel override in band call progress tones on voice signaling channel slot/port/startChannel-endChannel override in band call progress tones off ')
vsmSigChanOverrideInBandCodecSwitching = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 10, 1, 23), VsmEnableDisabled().clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanOverrideInBandCodecSwitching.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanOverrideInBandCodecSwitching.setDescription('Enables or Disables capability of the call to switch from one codec to another in band (in voice mode) by detecting change in payload type of the packets This object should only be used under the supervision of trained personnel. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel no override in band codec switching ')
vsmSigChanOverridePSUCodecSwitching = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 10, 1, 24), VsmEnableDisabled().clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanOverridePSUCodecSwitching.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanOverridePSUCodecSwitching.setDescription('Enables or Disables Coding switchover in the Signaling band. In the PSU this is accomplished by using the Set-Coding API. This happens after the Net-Connect stage. This object should only be used under the supervision of trained personnel. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel override PSU codec switching on voice signaling channel slot/port/startChannel-endChannel override PSU codec switching off voice signaling channel slot/port/startChannel-endChannel no override PSU codec switching ')
vsmSigChanOverrideNetworkOverlapDialing = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 10, 1, 25), VsmEnableDisabled().clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanOverrideNetworkOverlapDialing.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanOverrideNetworkOverlapDialing.setDescription('Enables or Disables support for Network overlap dialing. The Net connect happens even if all the digits have not been collected. The call moves to Call progress when the dialing is completed. This object should only be used under the supervision of trained personnel. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel override network overlap dialing on voice signaling channel slot/port/startChannel-endChannel override network overlap dialing off voice signaling channel slot/port/startChannel-endChannel no override network overlap dialing ')
vsmSigChanOverrideFullCallProgressTones = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 10, 1, 26), VsmEnableDisabled().clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanOverrideFullCallProgressTones.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanOverrideFullCallProgressTones.setDescription('Enables or Disables support for full call progress tones in signaling band. Call progress indications are sent as information type packets. The call progress tones include Ringback, Busy etc. This object should only be used under the supervision of trained personnel. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel no override full call progress tones ')
vsmSigChanOverrideRingBack = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 10, 1, 27), VsmEnableDisabled().clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanOverrideRingBack.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanOverrideRingBack.setDescription('Enables or Disables ring back detection. This object should only be used under the supervision of trained personnel. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel no override ring back ')
vsmSigChanOverrideInfoElementTransport = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 10, 1, 28), VsmEnableDisabled().clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanOverrideInfoElementTransport.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanOverrideInfoElementTransport.setDescription('Enables or Disables general user to user Information Element (IE) packet passing support. This means that the call is capable of transporting IEs from user to user. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel no override information element transport ')
vsmSigChanOverrideQSIGInfoElementTransport = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 10, 1, 29), VsmEnableDisabled().clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanOverrideQSIGInfoElementTransport.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanOverrideQSIGInfoElementTransport.setDescription('Enables or Disables QSIG Information Element (IE) packet passing support. This object should only be used under the supervision of trained personnel. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel no override QSIG information element transport ')
vsmSigChanOverrideDataSetup = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 10, 1, 30), VsmOnOff().clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanOverrideDataSetup.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanOverrideDataSetup.setDescription('Enables or Disables identification that this is a data call. Only one of the following objects should be enabled: vsmSigChanHangupWaitLimit, vsmSigChanVoiceSetup, vsmSigChanFAXSetup, or vsmSigChanModemSetup This object should only be used under the supervision of trained personnel. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel no override data setup ')
vsmSigChanOverrideVoiceSetup = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 10, 1, 31), VsmOnOff().clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanOverrideVoiceSetup.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanOverrideVoiceSetup.setDescription('Enables or Disables identification that this is a voice call. Only one of the following objects should be enabled: vsmSigChanHangupWaitLimit, vsmSigChanVoiceSetup, vsmSigChanFAXSetup, or vsmSigChanModemSetup This object should only be used under the supervision of trained personnel. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel no override voice setup voice signaling channel slot/port/startChannel-endChannel override voice setup on voice signaling channel slot/port/startChannel-endChannel override voice setup off ')
vsmSigChanOverrideFAXSetup = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 10, 1, 32), VsmOnOff().clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanOverrideFAXSetup.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanOverrideFAXSetup.setDescription('Enables or Disables identification that this is a FAX call. Only one of the following objects should be enabled: vsmSigChanHangupWaitLimit, vsmSigChanVoiceSetup, vsmSigChanFAXSetup, or vsmSigChanModemSetup This object should only be used under the supervision of trained personnel. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel no override fax setup ')
vsmSigChanOverrideModemSetup = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 10, 1, 33), VsmOnOff().clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanOverrideModemSetup.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanOverrideModemSetup.setDescription('Enables or Disables identification that this is a modem call. Only one of the following objects should be enabled: vsmSigChanHangupWaitLimit, vsmSigChanVoiceSetup, vsmSigChanFAXSetup, or vsmSigChanModemSetup This object should only be used under the supervision of trained personnel. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel no override modem setup ')
vsmSigChanCallProgressToneDetControl = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 10, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("on", 2), ("relative", 3))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanCallProgressToneDetControl.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanCallProgressToneDetControl.setDescription('This command is used to control the detection of call progress tones. Value Description ===== =========== off Disable call progress detection. on Enable call progress detection. relative Enable/disable call progress detection according to the Call progress tone detection parameter in the coding profile that is currently loaded. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel call progress tone detection control off voice signaling channel slot/port/startChannel-endChannel call progress tone detection control on voice signaling channel slot/port/startChannel-endChannel call progress tone detection control relative ')
vsmSigChanCallProgressToneDetCfg = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 10, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("default", 1), ("alternate", 2))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanCallProgressToneDetCfg.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanCallProgressToneDetCfg.setDescription('Specifies which configuration will be used for call progress tone detection. A configuration includes filter configuration information (threshold and filter coefficients), and a table containing cadence information of all the call progress tones that are to be detected. Two sample configurations are provided - default and alternate. Both of the configurations currently use the default filter configuration - dial tone, ring back, (3 different cadences are supported), bust, and congestion. The alternate configuration allows for the detection of the busy tone only. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel call progress tone detection configuration default voice signaling channel slot/port/startChannel-endChannel call progress tone detection configuration alternate ')
vsmSigChanAssignTmplName = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 10, 1, 36), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanAssignTmplName.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanAssignTmplName.setDescription("This object specifies the ID of the Signaling template to assign to this channel. For more information, please see the following CLI command: voice channel slot/port/startChannel-endChannel assign signaling template 'signalingTemplateName' ")
vsmSigChanAssignTmplStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 10, 1, 37), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("assign", 1))).clone('assign')).setMaxAccess("writeonly")
if mibBuilder.loadTexts: vsmSigChanAssignTmplStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanAssignTmplStatus.setDescription("Causes the vsmSigChanAssignTmplName to be assigned. For more information, please see the following CLI command: voice channel slot/port/startChannel-endChannel assign signaling template 'signalingTemplateName' ")
vsmSigChanOutDialType = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 10, 1, 38), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("tone", 1), ("pulse", 2))).clone('tone')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanOutDialType.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanOutDialType.setDescription(' This command is used to select the out dialing characteristic of the channels on the specified port. Value Description ===== =========== Tone Default. Indicates use of tone (Dual Tone Multi-frequency) dialing. Pulse Indicates use of pulse dialing. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel out dialing type tone voice signaling channel slot/port/startChannel-endChannel out dialing type pulse ')
vsmSigChanV18ToneDetThHangTime = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 10, 1, 39), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 32767)).clone(50)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanV18ToneDetThHangTime.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanV18ToneDetThHangTime.setDescription(' This command sets the signal duration threshold for V18 tone detection. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel v.18 tone detection threshold hang time (5 ... 32767) ')
vsmSigChanV18ToneDetThLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 10, 1, 40), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-50, -15)).clone(-40)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanV18ToneDetThLevel.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanV18ToneDetThLevel.setDescription(' This command sets the signal strength threshold for V18 tone detection. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel v.18 tone detection threshold Level (-50 ... -15) ')
vsmSigChanV18ToneDetThFraction = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 10, 1, 41), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32767)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanV18ToneDetThFraction.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanV18ToneDetThFraction.setDescription(' This command sets the signal fraction threshold for V18 tone detection. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel v.18 tone detection threshold fraction (1 ... 32767) ')
vsmSigChanSinFreqToneDetThLev = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 10, 1, 42), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-50, -15)).clone(-40)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanSinFreqToneDetThLev.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanSinFreqToneDetThLev.setDescription(' This command sets the signal strength threshold for SF {single frequency } tone detection. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel single frequency tone detection threshold level (-50 ... -15) ')
vsmSigChanSinFreqToneDetThTime = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 10, 1, 43), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(50)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanSinFreqToneDetThTime.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanSinFreqToneDetThTime.setDescription(' This command sets the time threshold level for SF {single frequency } tone detection. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel single frequency tone detection threshold time (0 ... 65535) ')
vsmSigChanEchoCancelNonSens = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 10, 1, 44), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32767)).clone(327)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanEchoCancelNonSens.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanEchoCancelNonSens.setDescription(' This command sets the sensitivity of the echo canceller non-linear processor. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel echo canceller non-linear sensitivity (0 ... 32767) ')
vsmSigChanAcousticEchoCancellerMode = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 10, 1, 45), VsmEnableDisabled().clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanAcousticEchoCancellerMode.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanAcousticEchoCancellerMode.setDescription(' This command selects whether the line of the Acoustic Echo Canceller (EC) is started on channel startup. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel acoustic echo canceller mode on voice signaling channel slot/port/startChannel-endChannel acoustic echo canceller mode off ')
vsmSigChanAcouEchoCanNonProc = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 10, 1, 46), VsmEnableDisabled().clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanAcouEchoCanNonProc.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanAcouEchoCanNonProc.setDescription(' This command enables or disables the (TBD: acoustic echo canceller non-linear processor or comfort noise level generator) For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel acoustic echo canceller non-linear processor on voice signaling channel slot/port/startChannel-endChannel acoustic echo canceller non-linear processor off ')
vsmSigChanAcEchoCanSetSpGain = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 10, 1, 47), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 31)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanAcEchoCanSetSpGain.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanAcEchoCanSetSpGain.setDescription(' This command sets the Handset (HS) specker gain. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel acoustic echo canceller handset speaker gain (0 ... 31) ')
vsmSigChanAcEchoCanFreeSpGain = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 10, 1, 48), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanAcEchoCanFreeSpGain.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanAcEchoCanFreeSpGain.setDescription(' This command sets the Hands Free (HF) specker gain. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel acoustic echo canceller hands free speaker gain (0 ... 31) ')
vsmSigChanAcousticEchoCanOper = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 10, 1, 49), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("handset", 1), ("handsfree", 2))).clone('handsfree')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanAcousticEchoCanOper.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanAcousticEchoCanOper.setDescription('new leaf for 2.2f parser For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel acoustic echo canceller operation handset voice signaling channel slot/port/startChannel-endChannel acoustic echo canceller operation hands free ')
vsmSigChanFxsLSCadenceCoefficient = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 10, 1, 50), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("northAmerica", 1), ("europe", 2))).clone('northAmerica')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanFxsLSCadenceCoefficient.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanFxsLSCadenceCoefficient.setDescription('This command selects the fxs cadence coefficient on this channel. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel fxs ls cadence coefficient North America voice signaling channel slot/port/startChannel-endChannel fxs ls cadence coefficient Europe ')
vsmSigChanFxsLSRingId = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 10, 1, 51), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("default", 1), ("zero", 2), ("one", 3), ("two", 4), ("three", 5), ("four", 6), ("five", 7), ("six", 8), ("seven", 9))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanFxsLSRingId.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanFxsLSRingId.setDescription('This command selects the ring id for the specific fxs cadence coefficient on this channel. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel fxs ls ring id default voice signaling channel slot/port/startChannel-endChannel fxs ls ring id zero voice signaling channel slot/port/startChannel-endChannel fxs ls ring id one voice signaling channel slot/port/startChannel-endChannel fxs ls ring id two voice signaling channel slot/port/startChannel-endChannel fxs ls ring id three voice signaling channel slot/port/startChannel-endChannel fxs ls ring id four voice signaling channel slot/port/startChannel-endChannel fxs ls ring id five voice signaling channel slot/port/startChannel-endChannel fxs ls ring id six voice signaling channel slot/port/startChannel-endChannel fxs ls ring id seven ')
vsmSigChanFxsGSCadenceCoefficient = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 10, 1, 52), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("northAmerica", 1), ("europe", 2))).clone('northAmerica')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanFxsGSCadenceCoefficient.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanFxsGSCadenceCoefficient.setDescription('This command selects the fxs cadence coefficient on this channel. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel fxs gs cadence coefficient North America voice signaling channel slot/port/startChannel-endChannel fxs gs cadence coefficient Europe ')
vsmSigChanFxsGSRingId = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 10, 1, 53), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("default", 1), ("zero", 2), ("one", 3), ("two", 4), ("three", 5), ("four", 6), ("five", 7), ("six", 8), ("seven", 9))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanFxsGSRingId.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanFxsGSRingId.setDescription('This command selects the ring id for the specific fxs cadence coefficient on this channel. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel fxs gs ring id default voice signaling channel slot/port/startChannel-endChannel fxs gs ring id zero voice signaling channel slot/port/startChannel-endChannel fxs gs ring id one voice signaling channel slot/port/startChannel-endChannel fxs gs ring id two voice signaling channel slot/port/startChannel-endChannel fxs gs ring id three voice signaling channel slot/port/startChannel-endChannel fxs gs ring id four voice signaling channel slot/port/startChannel-endChannel fxs gs ring id five voice signaling channel slot/port/startChannel-endChannel fxs gs ring id six voice signaling channel slot/port/startChannel-endChannel fxs gs ring id seven ')
vsmSigChanEmCommonTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 11), )
if mibBuilder.loadTexts: vsmSigChanEmCommonTable.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanEmCommonTable.setDescription('This table contains information that is used for all E&M type signaling protocols. ')
vsmSigChanEmCommonEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 11, 1), ).setIndexNames((0, "XYLAN-VSM-MIB", "vsmChanSlotIndex"), (0, "XYLAN-VSM-MIB", "vsmChanPortIndex"), (0, "XYLAN-VSM-MIB", "vsmChanIndex"))
if mibBuilder.loadTexts: vsmSigChanEmCommonEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanEmCommonEntry.setDescription('This is an entry in the E&M Common Signaling Table. For more information, please see the following CLI command: [Note: There is NO equivalent command in the CLI.] ')
vsmSigChanEmCommonOffHookDebounce = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 11, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 1000)).clone(50)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanEmCommonOffHookDebounce.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanEmCommonOffHookDebounce.setDescription('The time, in milliseconds, to allow to de-bounce a transition to an offhook state. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel em off hook debounce (5..1000) ')
vsmSigChanEmCommonOnHookDebounce = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 11, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 1000)).clone(50)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanEmCommonOnHookDebounce.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanEmCommonOnHookDebounce.setDescription('The time, in milliseconds, to allow to de-bounce a transition to an onhook state. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel em on hook debounce (5..1000) ')
vsmSigChanEmCommonSeizeDetect = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 11, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 5000)).clone(150)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanEmCommonSeizeDetect.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanEmCommonSeizeDetect.setDescription('The time to wait, in milliseconds, before declaring an off-hook condition after the M-lead has transitioned to the active state. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel em seize detect (5..5000) ')
vsmSigChanEmCommonClearDetect = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 11, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 5000)).clone(400)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanEmCommonClearDetect.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanEmCommonClearDetect.setDescription('The minimum time to wait, in milliseconds, before declaring an on-hook condition after the M-lead transitions to the inactive state and the interface was off-hook. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel em clear detect (5..5000) ')
vsmSigChanEmCommonClearConfDetect = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 11, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 5000)).clone(5000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanEmCommonClearConfDetect.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanEmCommonClearConfDetect.setDescription('The amount of time, in milliseconds, that an on-hook must be detected on the M-lead after going on-hook on the E-lead. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel em clear confirm detect (5..5000) ')
vsmSigChanEmCommonClearConfWaitMax = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 11, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 60000)).clone(60000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanEmCommonClearConfWaitMax.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanEmCommonClearConfWaitMax.setDescription('Defines the maximum time, in seconds, to wait for an on-hook indication following a clearing indication. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel em clear confirm wait maximum (1..60000) ')
vsmSigChanEmCommonGuardAll = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 11, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000)).clone(400)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanEmCommonGuardAll.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanEmCommonGuardAll.setDescription('The period, in milliseconds, after an aborted call when neither no incoming calls will be accepted nor outgoing calls initiated. In other words, this is the duration of time that the channel is out of service after a call is aborted. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel em guard all (0..60000) ')
vsmSigChanEmCommonGuardOut = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 11, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 60000)).clone(400)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanEmCommonGuardOut.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanEmCommonGuardOut.setDescription('This specifies an additional period of time, in milliseconds, after guard-all when incoming calls will be accepted but outgoing calls will not be initiated for aborted calls. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel em guard out (0..60000) ')
vsmSigChanEmCommonDialTone = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 11, 1, 9), VsmEnableDisabled().clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanEmCommonDialTone.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanEmCommonDialTone.setDescription('Specifies whether dial tone should be generated on incoming calls. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel em dial tone on voice signaling channel slot/port/startChannel-endChannel em dial tone off ')
vsmSigChanEmCommonMinConnectTime = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 11, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 20000)).clone(2000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanEmCommonMinConnectTime.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanEmCommonMinConnectTime.setDescription('The minimum period of time, in milliseconds, that a connection will be maintained. If the remote end disconnects during this interval, the disconnect will be acknowledged only at the end of this time interval. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel em minimum connect time (0..20000) ')
vsmSigChanEmCommonHangUpWait = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 11, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 60000)).clone(2000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanEmCommonHangUpWait.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanEmCommonHangUpWait.setDescription('The time period, in milliseconds, a port will wait after hanging up a call before signaling that it is in a disabled state. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel em hang up wait (5..60000) ')
vsmSigChanEmDelayTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 12), )
if mibBuilder.loadTexts: vsmSigChanEmDelayTable.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanEmDelayTable.setDescription('This table contains entries that specify how to perform E&M Delay signaling on the port indicated ')
vsmSigChanEmDelayEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 12, 1), ).setIndexNames((0, "XYLAN-VSM-MIB", "vsmChanSlotIndex"), (0, "XYLAN-VSM-MIB", "vsmChanPortIndex"), (0, "XYLAN-VSM-MIB", "vsmChanIndex"))
if mibBuilder.loadTexts: vsmSigChanEmDelayEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanEmDelayEntry.setDescription('This is an entry in the E&M Delay Signaling Table. For more information, please see the following CLI command: [Note: There is NO equivalent command in the CLI.] ')
vsmSigChanEmDelayInDelayDurMin = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 12, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 60000)).clone(200)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanEmDelayInDelayDurMin.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanEmDelayInDelayDurMin.setDescription('The minimum duration, in milliseconds, of the delay signal response to the seize detect (of incoming calls) on the M-lead. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel emd in delay minimum (5..60000) ')
vsmSigChanEmDelayInDelayDurMax = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 12, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 60000)).clone(2500)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanEmDelayInDelayDurMax.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanEmDelayInDelayDurMax.setDescription('The maximum duration, in milliseconds, of the delay signal response to the Seize Detect (of incoming calls) on the M-lead. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel emd in delay maximum (5..60000) ')
vsmSigChanEmDelayInDigitIgnore = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 12, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 60000)).clone(30)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanEmDelayInDigitIgnore.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanEmDelayInDigitIgnore.setDescription('The period of time in milliseconds, after completing the delay signal, before the digits will be accepted on incoming calls. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel emd in digit ignore (5..60000) ')
vsmSigChanEmDelayOutDelayDurMin = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 12, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 60000)).clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanEmDelayOutDelayDurMin.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanEmDelayOutDelayDurMin.setDescription('The minimum duration, in milliseconds, of the delay signal response on the M-lead for it to be detected on outgoing calls. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel emd out delay duration minimum (5..60000) ')
vsmSigChanEmDelayOutDelayDurMax = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 12, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 60000)).clone(8000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanEmDelayOutDelayDurMax.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanEmDelayOutDelayDurMax.setDescription('The maximum duration, in milliseconds, of the delay signal response on the M-lead for it to be declared as a glare condition by the TSG on outgoing calls. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel emd out delay duration maximum (5..60000) ')
vsmSigChanEmDelayOutIntegrityChk = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 12, 1, 6), VsmEnableDisabled().clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanEmDelayOutIntegrityChk.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanEmDelayOutIntegrityChk.setDescription('Enables or disables the Integrity Check mode. If on, the delay signal response is required from the PBX for outgoing calls. If off, no Integrity check is performed. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel emd out integrity check on voice signaling channel slot/port/startChannel-endChannel emd out integrity check off ')
vsmSigChanEmDelayOutDelayChk = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 12, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 60000)).clone(170)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanEmDelayOutDelayChk.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanEmDelayOutDelayChk.setDescription('The wait period for outgoing calls with the Integrity Check set to off; the period of time, in milliseconds, after going off-hook on the E-lead before checking the M-lead for the delay signal response. If the response is not seen at this time, the call setup process will continue immediately. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel emd out delay check (5..60000) ')
vsmSigChanEmImmedTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 13), )
if mibBuilder.loadTexts: vsmSigChanEmImmedTable.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanEmImmedTable.setDescription('This table contains entries that specify how to perform E&M Immediate signaling on the telephone channel. ')
vsmSigChanEmImmedEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 13, 1), ).setIndexNames((0, "XYLAN-VSM-MIB", "vsmChanSlotIndex"), (0, "XYLAN-VSM-MIB", "vsmChanPortIndex"), (0, "XYLAN-VSM-MIB", "vsmChanIndex"))
if mibBuilder.loadTexts: vsmSigChanEmImmedEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanEmImmedEntry.setDescription('This is an entry in the E&M Immediate Signaling Table. For more information, please see the following CLI command: [Note: There is NO equivalent command in the CLI.] ')
vsmSigChanEmImmedGlareReport = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 13, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000)).clone(5000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanEmImmedGlareReport.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanEmImmedGlareReport.setDescription('Specifies, how long, in milliseconds, the interface should remain off hook after detecting a glare condition to indicate congestion. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel emi glare report (0..60000) ')
vsmSigChanEmImmedDigitWait = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 13, 1, 2), Integer32().clone(200)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanEmImmedDigitWait.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanEmImmedDigitWait.setDescription('Specifies how long, in milliseconds, to wait before digit collection can be enabled. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel emi digit wait (0..60000) ')
vsmSigChanEmWinkTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 14), )
if mibBuilder.loadTexts: vsmSigChanEmWinkTable.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanEmWinkTable.setDescription('This table contains entries that specify how to perform E&M Wink signaling on the channel indicated. ')
vsmSigChanEmWinkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 14, 1), ).setIndexNames((0, "XYLAN-VSM-MIB", "vsmChanSlotIndex"), (0, "XYLAN-VSM-MIB", "vsmChanPortIndex"), (0, "XYLAN-VSM-MIB", "vsmChanIndex"))
if mibBuilder.loadTexts: vsmSigChanEmWinkEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanEmWinkEntry.setDescription('This is an entry in the E&M Wink Signaling Table. For more information, please see the following CLI command: [Note: There is NO equivalent command in the CLI.] ')
vsmSigChanEmWinkInWinkWaitMin = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 14, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 60000)).clone(150)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanEmWinkInWinkWaitMin.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanEmWinkInWinkWaitMin.setDescription('Specifies the minimum delay, in milliseconds, before beginning the wink on the E-lead after detecting a line seizure on the M-lead during an incoming call. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel emw in wink wait minimum (5..60000) ')
vsmSigChanEmWinkInWinkWaitMax = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 14, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 60000)).clone(290)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanEmWinkInWinkWaitMax.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanEmWinkInWinkWaitMax.setDescription('Specifies the maximum delay, in milliseconds, before beginning the wink on the E-lead after detecting a line seizure on the M-lead during an incoming call. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel emw in wink wait maximum (5..60000) ')
vsmSigChanEmWinkInWinkDur = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 14, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 60000)).clone(200)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanEmWinkInWinkDur.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanEmWinkInWinkDur.setDescription('Specifies the duration of the wink signal on the E-lead for incoming calls. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel emw in wink duration (5..60000) ')
vsmSigChanEmWinkInDigitIgnore = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 14, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 1000)).clone(30)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanEmWinkInDigitIgnore.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanEmWinkInDigitIgnore.setDescription('Specifies how long in milliseconds, after generating the wink signal on the E-lead, incoming digits will be ignored. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel emw in wink digit ignore (5..1000) ')
vsmSigChanEmWinkOutWinkWaitMax = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 14, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 60000)).clone(8000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanEmWinkOutWinkWaitMax.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanEmWinkOutWinkWaitMax.setDescription('Specifies the time, in milliseconds, to wait to detect a wink of the M-lead after seizure of the E-lead during an outgoing call. If the wink signal is not received within this time period, it is considered an error and the call will not connect. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel emw out wink wait maximum (5..60000) ')
vsmSigChanEmWinkOutWinkDurMin = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 14, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 60000)).clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanEmWinkOutWinkDurMin.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanEmWinkOutWinkDurMin.setDescription('Specifies the minimum duration, in milliseconds, of the wink on the M-lead during the processing of an outgoing call. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel emw out wink duration minimum (5..60000) ')
vsmSigChanEmWinkOutWinkDurMax = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 14, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 60000)).clone(800)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanEmWinkOutWinkDurMax.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanEmWinkOutWinkDurMax.setDescription('Specifies the maximum duration of the wink response on the M-lead before it is to be declared as a glare condition for outgoing calls. A glare condition occurs when both ends of a channel are seized at the same time. This command reduces the chance of deadlock. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel emw out wink duration maximum (5..60000) ')
vsmSigChanFxoGSTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 15), )
if mibBuilder.loadTexts: vsmSigChanFxoGSTable.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanFxoGSTable.setDescription('This table contains entries that specify how to perform Foreign Exchange Office (FXO) gorund start signaling on the port indicated. ')
vsmSigChanFxoGSEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 15, 1), ).setIndexNames((0, "XYLAN-VSM-MIB", "vsmChanSlotIndex"), (0, "XYLAN-VSM-MIB", "vsmChanPortIndex"), (0, "XYLAN-VSM-MIB", "vsmChanIndex"))
if mibBuilder.loadTexts: vsmSigChanFxoGSEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanFxoGSEntry.setDescription('This is an entry in the FXO ground start Signaling Table. For more information, please see the following CLI command: [Note: There is NO equivalent command in the CLI.] ')
vsmSigChanFxoGSConnectionLoopOpenDebounce = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 15, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 6000)).clone(150)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanFxoGSConnectionLoopOpenDebounce.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanFxoGSConnectionLoopOpenDebounce.setDescription('Debounce interval for loop open detection for an existing conection. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel fxo gs connection loop open debounce (1..60000) ')
vsmSigChanFxoGSMaxTipGroundWait = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 15, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 60000)).clone(30)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanFxoGSMaxTipGroundWait.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanFxoGSMaxTipGroundWait.setDescription('Maximum time the interface will wait after ring ground is asserted for a tip ground receive. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel fxo gs maximum tip ground wait (1..60000) ')
vsmSigChanFxoGSTipGroundDebounce = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 15, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000)).clone(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanFxoGSTipGroundDebounce.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanFxoGSTipGroundDebounce.setDescription('Time, in milliseconds, to be used as a de-bouncer interval for debouncing the tip ground detector. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel fxo gs tip ground debounce (1..1000) ')
vsmSigChanFxoGSRingingDebounce = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 15, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000)).clone(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanFxoGSRingingDebounce.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanFxoGSRingingDebounce.setDescription('When a ring signal is modulated by the ringing frequency, the debouncer is used to debounce the incoming ring signal. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel fxo gs ringing debounce (1..1000) ')
vsmSigChanFxoGSRingingInterCycle = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 15, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 60000)).clone(5000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanFxoGSRingingInterCycle.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanFxoGSRingingInterCycle.setDescription('Specifies the time between consecutive ring cycles, in milliseconds. It is used to detect ringing. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel fxo gs ringing inter cycle (1..60000) ')
vsmSigChanFxoGSRingingInterPulse = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 15, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 60000)).clone(550)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanFxoGSRingingInterPulse.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanFxoGSRingingInterPulse.setDescription('Specifies the time between consecutive ring pulses in the same ring cycle, in milliseconds. It is used to detect ringing. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel fxo gs ringing inter pulse (1..60000) ')
vsmSigChanFxoGSCallerIdDetect = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 15, 1, 7), VsmEnableDisabled().clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanFxoGSCallerIdDetect.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanFxoGSCallerIdDetect.setDescription('If enabled, Caller ID will be detected. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel fxo gs caller id detection on voice signaling channel slot/port/startChannel-endChannel fxo gs caller id detection off ')
vsmSigChanFxoGSAnswerAfterRings = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 15, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanFxoGSAnswerAfterRings.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanFxoGSAnswerAfterRings.setDescription('Specifies the number of rings to elapse before answering an incoming call. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel fxo gs answer after (1..65535) ')
vsmSigChanFxoGSLoopCurrentDebounce = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 15, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000)).clone(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanFxoGSLoopCurrentDebounce.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanFxoGSLoopCurrentDebounce.setDescription('Time, in milliseconds, to use as a de-bouncer interval for debouncing the loop current detector. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel fxo gs loop current debounce (0..1000) ')
vsmSigChanFxoGSBattReversalDebounce = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 15, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000)).clone(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanFxoGSBattReversalDebounce.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanFxoGSBattReversalDebounce.setDescription('Time, in milliseconds, to use as a de-bouncer interval for debouncing the battery reversal detector. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel fxo gs battery reversal debounce (1..1000) ')
vsmSigChanFxoLSTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 16), )
if mibBuilder.loadTexts: vsmSigChanFxoLSTable.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanFxoLSTable.setDescription('This table contains entries that specify how to perform Foreign Exchange Office (FXO) Loop start signaling on the port indicated. ')
vsmSigChanFxoLSEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 16, 1), ).setIndexNames((0, "XYLAN-VSM-MIB", "vsmChanSlotIndex"), (0, "XYLAN-VSM-MIB", "vsmChanPortIndex"), (0, "XYLAN-VSM-MIB", "vsmChanIndex"))
if mibBuilder.loadTexts: vsmSigChanFxoLSEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanFxoLSEntry.setDescription('This is an entry in the FXO Loop start Signaling Table. For more information, please see the following CLI command: [Note: There is NO equivalent command in the CLI.] ')
vsmSigChanFxoLSRingingDebounce = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 16, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000)).clone(50)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanFxoLSRingingDebounce.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanFxoLSRingingDebounce.setDescription('When a ring signal is modulated by the ringing frequency, the debouncer is used to debounce the incoming ring signal. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel fxo ls ringing debounce (1..1000) ')
vsmSigChanFxoLSCPCDetectCtrl = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 16, 1, 2), VsmEnableDisabled().clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanFxoLSCPCDetectCtrl.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanFxoLSCPCDetectCtrl.setDescription('This command is used to enable or disable detection of a CPC (supervisory disconnect) signal (vsmSigChanFxoLSCPCDetectDur).. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel fxo ls supervisory disconnect detection on voice signaling channel slot/port/startChannel-endChannel fxo ls supervisory disconnect detection off ')
vsmSigChanFxoLSCPCDetectDur = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 16, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 60000)).clone(600)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanFxoLSCPCDetectDur.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanFxoLSCPCDetectDur.setDescription('The expected duration of the CPC (supervisory disconnect) signal in milliseconds. If the loop current drops for a time period shorter than indicated, it is not regarded as a supervisory disconnect. This object is only valid if vsmSigChanFxoLSCPCDetectCtrl is enabled. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel fxo ls supervisory disconnect detect (1..60000 ) ')
vsmSigChanFxoLSGuardOut = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 16, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 60000)).clone(2000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanFxoLSGuardOut.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanFxoLSGuardOut.setDescription('After the call, the period of time where the channel does not originate a call, but will receive a call. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel fxo ls guard out (1..60000) ')
vsmSigChanFxoLSRingingInterCycle = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 16, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 60000)).clone(5000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanFxoLSRingingInterCycle.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanFxoLSRingingInterCycle.setDescription('The time between ring cycles (ringing pulse plus time between ring pulses) in milliseconds. It is used to detect ringing. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel fxo ls ringing inter cycle (1..60000) ')
vsmSigChanFxoLSRingingInterPulse = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 16, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 60000)).clone(550)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanFxoLSRingingInterPulse.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanFxoLSRingingInterPulse.setDescription('The time between ring pulses in milliseconds. It is used to detect ringing. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel fxo ls ringing inter pulse (1..60000) ')
vsmSigChanFxoLSCallerIdDetect = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 16, 1, 7), VsmEnableDisabled().clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanFxoLSCallerIdDetect.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanFxoLSCallerIdDetect.setDescription('If enabled, Caller ID will be detected. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel fxo ls caller id detection on voice signaling channel slot/port/startChannel-endChannel fxo ls caller id detection off ')
vsmSigChanFxoLSAnswerAfterRings = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 16, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanFxoLSAnswerAfterRings.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanFxoLSAnswerAfterRings.setDescription('Specifies the number of rings to elapse before answering an incoming call. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel fxo ls answer after (1..65535) ')
vsmSigChanFxoLSLoopCurrentDebounce = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 16, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 6000)).clone(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanFxoLSLoopCurrentDebounce.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanFxoLSLoopCurrentDebounce.setDescription('Time, in milliseconds, to use as a de-bouncer interval for debouncing the loop current detector. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel fxo ls loop current debounce (0..60000) ')
vsmSigChanFxoLSBattReversalDebounce = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 16, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000)).clone(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanFxoLSBattReversalDebounce.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanFxoLSBattReversalDebounce.setDescription('Time, in milliseconds, to use as a de-bouncer interval for debouncing the battery reversal detector. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel fxo ls battery reversal debounce (0..60000) ')
vsmSigChanFxsGSTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 17), )
if mibBuilder.loadTexts: vsmSigChanFxsGSTable.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanFxsGSTable.setDescription('This table contains entries that specify how to perform Foreign Exchange Station (FXS) ground start signaling on the port indicated ')
vsmSigChanFxsGSEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 17, 1), ).setIndexNames((0, "XYLAN-VSM-MIB", "vsmChanSlotIndex"), (0, "XYLAN-VSM-MIB", "vsmChanPortIndex"), (0, "XYLAN-VSM-MIB", "vsmChanIndex"))
if mibBuilder.loadTexts: vsmSigChanFxsGSEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanFxsGSEntry.setDescription('This is an entry in the FXS ground start signaling Table. For more information, please see the following CLI command: [Note: There is NO equivalent command in the CLI.] ')
vsmSigChanFxsGSSeizeDetect = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 17, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5000)).clone(150)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanFxsGSSeizeDetect.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanFxsGSSeizeDetect.setDescription('The time to wait before an off-hook condition is declared. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel fxs gs seize detect (1..5000) ')
vsmSigChanFxsGSOnHookDebounce = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 17, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000)).clone(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanFxsGSOnHookDebounce.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanFxsGSOnHookDebounce.setDescription('Debounce interval to onhook transition. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel fxs gs on hook debounce (1..1000) ')
vsmSigChanFxsGSOrigClearDetect = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 17, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 60000)).clone(200)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanFxsGSOrigClearDetect.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanFxsGSOrigClearDetect.setDescription('The minimum time to wait if the originator drops the line before declaring onhook. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel fxs gs originate clear detect (1..60000) ')
vsmSigChanFxsGSAnswClearDetect = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 17, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 60000)).clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanFxsGSAnswClearDetect.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanFxsGSAnswClearDetect.setDescription('Minimum time to wait when the answering party drops the line before declaring onhook. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel fxs gs answer clear detect (1..60000) ')
vsmSigChanFxsGSMinRingGround = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 17, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanFxsGSMinRingGround.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanFxsGSMinRingGround.setDescription('The minimum time for the ring lead to be grounded before it is considered a valid seizure For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel fxs gs minimum ring ground (0..65535) ')
vsmSigChanFxsGSMaxWaitLoop = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 17, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanFxsGSMaxWaitLoop.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanFxsGSMaxWaitLoop.setDescription('Specifies the maximum time to allow for the loop to close, after a ring ground is detected and the tip is grounded, before the interface will disconnect. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel fxs gs maximum wait loop (0..65535) ')
vsmSigChanFxsGSMinLoopOpen = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 17, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanFxsGSMinLoopOpen.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanFxsGSMinLoopOpen.setDescription('Specifies the minimum time the interface waits after detecting an open loop condition, before returning to an idle state. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel fxs gs minimum loop open (0..65535) ')
vsmSigChanFxsGSGenerateCallerId = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 17, 1, 8), VsmEnableDisabled().clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanFxsGSGenerateCallerId.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanFxsGSGenerateCallerId.setDescription('If enabled, Caller ID will be generated. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel fxs gs generate caller id on voice signaling channel slot/port/startChannel-endChannel fxs gs generate caller id off ')
vsmSigChanFxsGSOffHookDebounce = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 17, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000)).clone(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanFxsGSOffHookDebounce.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanFxsGSOffHookDebounce.setDescription('Specifies the time, in milliseconds, to be used as de-bouncer interval for off-hook transition. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel fxs gs off hook debounce (1..1000) ')
vsmSigChanFxsGSRingGroundDebounce = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 17, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000)).clone(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanFxsGSRingGroundDebounce.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanFxsGSRingGroundDebounce.setDescription('Time, in milliseconds, to be used as de-bouncer interval for debouncing the ring ground detector. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel fxs gs ring ground debounce (1..1000) ')
vsmSigChanFxsLSTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 18), )
if mibBuilder.loadTexts: vsmSigChanFxsLSTable.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanFxsLSTable.setDescription('This table contains entries that specify how to perform FXS Loop signaling on the port indicated ')
vsmSigChanFxsLSEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 18, 1), ).setIndexNames((0, "XYLAN-VSM-MIB", "vsmChanSlotIndex"), (0, "XYLAN-VSM-MIB", "vsmChanPortIndex"), (0, "XYLAN-VSM-MIB", "vsmChanIndex"))
if mibBuilder.loadTexts: vsmSigChanFxsLSEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanFxsLSEntry.setDescription('This is an entry in the FXS Loop Signaling Table. For more information, please see the following CLI command: [Note: There is NO equivalent command in the CLI.] ')
vsmSigChanFxsLSOffHookDebounce = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 18, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000)).clone(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanFxsLSOffHookDebounce.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanFxsLSOffHookDebounce.setDescription('Debounce interval to offhook transition. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel fxs ls off hook debounce (1..1000) ')
vsmSigChanFxsLSOnHookDebounce = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 18, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000)).clone(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanFxsLSOnHookDebounce.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanFxsLSOnHookDebounce.setDescription('Debounce interval to onhook transition. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel fxs ls on hook debounce (1..1000) ')
vsmSigChanFxsLSSeizeDetect = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 18, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5000)).clone(150)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanFxsLSSeizeDetect.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanFxsLSSeizeDetect.setDescription('The time to wait before an off-hook condition is declared. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel fxs ls seize detect (1..5000) ')
vsmSigChanFxsLSOrigClearDetect = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 18, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000)).clone(300)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanFxsLSOrigClearDetect.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanFxsLSOrigClearDetect.setDescription('The minimum time to wait if the originator drops the line before declaring onhook. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel fxs ls originate clear detect (1..1000) ')
vsmSigChanFxsLSAnswClearDetect = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 18, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 60000)).clone(300)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanFxsLSAnswClearDetect.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanFxsLSAnswClearDetect.setDescription('Minimum time to wait when the answering party drops the line before declaring onhook. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel fxs ls answer clear detect (1..60000) ')
vsmSigChanFxsLSCPCWait = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 18, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 60000)).clone(200)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanFxsLSCPCWait.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanFxsLSCPCWait.setDescription('Time to wait after a Supervisory Disconnect (CPC) signal is received before declaring on hook. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel fxs ls supervisory disconnect wait (1..60000) ')
vsmSigChanFxsLSCPCDur = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 18, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000)).clone(850)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanFxsLSCPCDur.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanFxsLSCPCDur.setDescription('If zero, then do not generate Supervisory Disconnect (CPC). For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel fxs ls supervisory disconnect duration (1..60000) ')
vsmSigChanFxsLSGenerateCallerId = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 2, 18, 1, 8), VsmEnableDisabled().clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmSigChanFxsLSGenerateCallerId.setStatus('mandatory')
if mibBuilder.loadTexts: vsmSigChanFxsLSGenerateCallerId.setDescription('If enabled, Caller ID will be generated. For more information, please see the following CLI command: voice signaling channel slot/port/startChannel-endChannel fxs ls generate caller id on voice signaling channel slot/port/startChannel-endChannel fxs ls generate caller id off ')
vsmCodingProfileTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 26, 3, 1), )
if mibBuilder.loadTexts: vsmCodingProfileTable.setStatus('mandatory')
if mibBuilder.loadTexts: vsmCodingProfileTable.setDescription('This table contains information for each coding profile. ')
vsmCodingProfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 26, 3, 1, 1), ).setIndexNames((0, "XYLAN-VSM-MIB", "vsmCodingProfName"))
if mibBuilder.loadTexts: vsmCodingProfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vsmCodingProfEntry.setDescription('This is an entry in the vsmCodingProfileTable. For more information, please see the following CLI command: [Note: There is NO equivalent command in the CLI.] ')
vsmCodingProfId = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmCodingProfId.setStatus('mandatory')
if mibBuilder.loadTexts: vsmCodingProfId.setDescription('The coding profile ID uniquely distinguishes the coding profile. For more information, please see the following CLI command: [Note: There is NO equivalent command in the CLI.] ')
vsmCodingProfName = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 3, 1, 1, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmCodingProfName.setStatus('mandatory')
if mibBuilder.loadTexts: vsmCodingProfName.setDescription("The coding profile name provides a text label for the coding profile. For more information, please see the following CLI command: voice coding profile 'codingProfName' ")
vsmCodingProfCallerId = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 3, 1, 1, 3), VsmEnableDisabled().clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmCodingProfCallerId.setStatus('mandatory')
if mibBuilder.loadTexts: vsmCodingProfCallerId.setDescription("Enables or Disables Caller Id for the specified Coding Profile. For more information, please see the following CLI command: voice coding profile 'codingProfName' caller id on voice coding profile 'codingProfName' caller id off ")
vsmCodingProfCodingType = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 3, 1, 1, 4), VsmVoiceCodingType().clone('ituG723-63')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmCodingProfCodingType.setStatus('mandatory')
if mibBuilder.loadTexts: vsmCodingProfCodingType.setDescription("Used to define the codec type. For more information, please see the following CLI command: voice coding profile 'codingProfName' codec type g.711 mulaw voice coding profile 'codingProfName' codec type g.711 alaw voice coding profile 'codingProfName' codec type g.723.1 53 voice coding profile 'codingProfName' codec type g.723.1 63 voice coding profile 'codingProfName' codec type g.729ab voice coding profile 'codingProfName' codec type fax t.38 Note: The following are not supported in this Release voice coding profile 'codingProfName' codec type fax voice coding profile 'codingProfName' codec type g.726 16 voice coding profile 'codingProfName' codec type g.726 24 voice coding profile 'codingProfName' codec type g.726 32 voice coding profile 'codingProfName' codec type g.726 40 voice coding profile 'codingProfName' codec type g.727 16 voice coding profile 'codingProfName' codec type g.727 24 voice coding profile 'codingProfName' codec type g.727 32 voice coding profile 'codingProfName' codec type g.727 40 ")
vsmCodingProfPktInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(10, 20, 30, 40, 50, 60, 70, 80))).clone(namedValues=NamedValues(("interval1", 10), ("interval2", 20), ("interval3", 30), ("interval4", 40), ("interval5", 50), ("interval6", 60), ("interval7", 70), ("interval8", 80))).clone('interval3')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmCodingProfPktInterval.setStatus('mandatory')
if mibBuilder.loadTexts: vsmCodingProfPktInterval.setDescription("Specifies the Voice Packet Interval in milliseconds. The size of the Voice Information Field (vsmCodingProfVIF) is determined by using the current setting of: vsmCodingProfCodingType and vsmCodingProfPktInterval. The following table shows the relationship between the three parameters: CODEC TYPE: Voice Packet Voice Information Intervals Allowed: Field Size(in bits): Pcm mulaw TBD TBD Pcm alaw TBD TBD g.723 53 30 ms 192 g.723 63 30 ms 192 g.723 53 60 ms 384 g.723 63 60 ms 384 g.729ab 10 ms 80 g.729ab 20 ms 160 g.729ab 30 ms 240 g.729ab 40 ms 320 g.729ab 50 ms 400 g.729ab 60 ms 480 g.729ab 70 ms 560 g.729ab 80 ms 640 Fax TBD TBD fax t.38 TBD TBD g.726 16 10 ms 160 g.726 16 20 ms 320 g.726 16 30 ms 480 g.727 16 10 ms 160 g.727 16 20 ms 320 g.727 16 30 ms 480 g.726 24 10 ms 240 g.726 24 20 ms 480 g.726 24 30 ms 720 g.727 24 10 ms 240 g.727 24 20 ms 480 g.727 24 30 ms 720 g.726 32 10 ms 320 g.726 32 20 ms 640 g.726 32 30 ms 960 g.727 32 10 ms 320 g.727 32 20 ms 640 g.727 32 30 ms 960 g.726 40 10 ms 400 g.726 40 20 ms 800 g.726 40 30 ms 1200 g.727 40 10 ms 400 g.727 40 20 ms 800 g.727 40 30 ms 1200 end of table. For more information, please see the following CLI command: voice coding profile 'codingProfName' voice packet interval 10 voice coding profile 'codingProfName' voice packet interval 20 voice coding profile 'codingProfName' voice packet interval 30 voice coding profile 'codingProfName' voice packet interval 40 voice coding profile 'codingProfName' voice packet interval 50 voice coding profile 'codingProfName' voice packet interval 60 voice coding profile 'codingProfName' voice packet interval 70 voice coding profile 'codingProfName' voice packet interval 80 ")
vsmCodingProfVIF = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 3, 1, 1, 6), Integer32().clone(384)).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmCodingProfVIF.setStatus('deprecated')
if mibBuilder.loadTexts: vsmCodingProfVIF.setDescription('deprecated')
vsmCodingProfNetBufMode = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("adaptive", 1), ("static", 2))).clone('static')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmCodingProfNetBufMode.setStatus('mandatory')
if mibBuilder.loadTexts: vsmCodingProfNetBufMode.setDescription("Configures the mode of the adaptive playback function for a coding profile. With the voice network delay buffer mode set to static (adaptive playout disabled), the nominal and maximum playout values are valid. If this object is set to adaptive (adaptive playout enabled), the nominal and maximum values hold, but the DSP will adjust the nominal delay (playout point) to reflect any observed jitter. For more information, please see the following CLI command: voice coding profile 'codingProfName' voice network delay buffer mode adaptive voice coding profile 'codingProfName' voice network delay buffer mode static ")
vsmCodingProfNetBufNomDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 3, 1, 1, 8), Integer32().clone(120)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmCodingProfNetBufNomDelay.setStatus('mandatory')
if mibBuilder.loadTexts: vsmCodingProfNetBufNomDelay.setDescription("The average delay (in msec) maintained in the path from the packet network to the PCM interface to compensate for the network jitter effects. For more information, please see the following CLI command: voice coding profile 'codingProfName' voice network delay buffer nominal delay (1..1000) ")
vsmCodingProfNetBufMaxDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 3, 1, 1, 9), Integer32().clone(240)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmCodingProfNetBufMaxDelay.setStatus('mandatory')
if mibBuilder.loadTexts: vsmCodingProfNetBufMaxDelay.setDescription("The maximum instantaneous delay (in msec) beyond which the playout buffer is being recentered. For more information, please see the following CLI command: voice coding profile 'codingProfName' voice network delay buffer maximum delay (1..1000 ) ")
vsmCodingProfDtmfRelay = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 3, 1, 1, 10), VsmEnableDisabled().clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmCodingProfDtmfRelay.setStatus('mandatory')
if mibBuilder.loadTexts: vsmCodingProfDtmfRelay.setDescription("Enables or disables the DTMF Relay mode for a Coding Profile, in which DTMF tones are detected during voice processing and separately packetized for transmission. For more information, please see the following CLI command: voice coding profile 'codingProfName' voice dtmf relay on voice coding profile 'codingProfName' voice dtmf relay off ")
vsmCodingProfVAD = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 3, 1, 1, 11), VsmEnableDisabled().clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmCodingProfVAD.setStatus('mandatory')
if mibBuilder.loadTexts: vsmCodingProfVAD.setDescription("Enables or disables Voice Activity Detection (VAD). For more information, please see the following CLI command: voice coding profile 'codingProfName' voice activity detector on voice coding profile 'codingProfName' voice activity detector off ")
vsmCodingProfEC = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 3, 1, 1, 12), VsmEnableDisabled().clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmCodingProfEC.setStatus('mandatory')
if mibBuilder.loadTexts: vsmCodingProfEC.setDescription("Enables or disables the Echo Canceller (EC). For more information, please see the following CLI command: voice coding profile 'codingProfName' voice echo canceller on voice coding profile 'codingProfName' voice echo canceller off ")
vsmCodingProfSwitchover = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 3, 1, 1, 13), VsmEnableDisabled().clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmCodingProfSwitchover.setStatus('mandatory')
if mibBuilder.loadTexts: vsmCodingProfSwitchover.setDescription("Enables or Disables switchover to FAX when configured as a voice line. If enabled, switchover will occur when the appropriate FAX tones have been detected. For more information, please see the following CLI command: voice coding profile 'codingProfName' switchover on voice coding profile 'codingProfName' switchover off ")
vsmCodingProfCallProgToneDet = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 3, 1, 1, 15), VsmEnableDisabled().clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmCodingProfCallProgToneDet.setStatus('mandatory')
if mibBuilder.loadTexts: vsmCodingProfCallProgToneDet.setDescription(" This command is used to specify a secondary level of control of call progress detection. If the call progress detection control for a channel is set to relative (See Set Call progress tone detection (off/on/relative) command in section 10.7.1 above) in the signaling, then this parameter determines if detection is to be enabled or not. For more information, please see the following CLI command: voice coding profile 'codingProfName' call progress tone detection on voice coding profile 'codingProfName' call progress tone detection off ")
vsmCodingProfV18ToneDet = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 3, 1, 1, 16), VsmEnableDisabled().clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmCodingProfV18ToneDet.setStatus('mandatory')
if mibBuilder.loadTexts: vsmCodingProfV18ToneDet.setDescription("Enables or disables V.18 Annex A tone detection. The V.18 Annex A tone is a 1400 HZ tone is detected for 100ms. It is used for channel configuration purposes. For more information, please see the following CLI command: voice coding profile 'codingProfName' v.18 tone detection on voice coding profile 'codingProfName' v.18 tone detection off ")
vsmCodingProfVADThreshMode = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 3, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("adaptive", 1), ("relative", 2))).clone('adaptive')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmCodingProfVADThreshMode.setStatus('mandatory')
if mibBuilder.loadTexts: vsmCodingProfVADThreshMode.setDescription("The mode of the audio threshold level for the Voice Activity Detector (VAD) in a Coding Profile to be adaptive or relative to a reference level of -30 dBm. For more information, please see the following CLI command: voice coding profile 'codingProfName' voice activity detection threshold mode adaptive voice coding profile 'codingProfName' voice activity detection threshold mode relative ")
vsmCodingProfVADThreshLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 3, 1, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-20, 20)).clone(-13)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmCodingProfVADThreshLevel.setStatus('mandatory')
if mibBuilder.loadTexts: vsmCodingProfVADThreshLevel.setDescription("If the Voice Activity Detector (VAD) is set to relative using vsmCodingProfVADThreshMode, then this object is used to set the audio threshold level (in dBm) releative to a reference level of -30 dBm. For more information, please see the following CLI command: voice coding profile 'codingProfName' voice activity detection threshold level -20 voice coding profile 'codingProfName' voice activity detection threshold level -19 voice coding profile 'codingProfName' voice activity detection threshold level -18 voice coding profile 'codingProfName' voice activity detection threshold level -17 voice coding profile 'codingProfName' voice activity detection threshold level -16 voice coding profile 'codingProfName' voice activity detection threshold level -15 voice coding profile 'codingProfName' voice activity detection threshold level -14 voice coding profile 'codingProfName' voice activity detection threshold level -13 voice coding profile 'codingProfName' voice activity detection threshold level -12 voice coding profile 'codingProfName' voice activity detection threshold level -11 voice coding profile 'codingProfName' voice activity detection threshold level -10 voice coding profile 'codingProfName' voice activity detection threshold level -9 voice coding profile 'codingProfName' voice activity detection threshold level -8 voice coding profile 'codingProfName' voice activity detection threshold level -7 voice coding profile 'codingProfName' voice activity detection threshold level -6 voice coding profile 'codingProfName' voice activity detection threshold level -5 voice coding profile 'codingProfName' voice activity detection threshold level -4 voice coding profile 'codingProfName' voice activity detection threshold level -3 voice coding profile 'codingProfName' voice activity detection threshold level -2 voice coding profile 'codingProfName' voice activity detection threshold level -1 voice coding profile 'codingProfName' voice activity detection threshold level 0 voice coding profile 'codingProfName' voice activity detection threshold level 20 voice coding profile 'codingProfName' voice activity detection threshold level 19 voice coding profile 'codingProfName' voice activity detection threshold level 18 voice coding profile 'codingProfName' voice activity detection threshold level 17 voice coding profile 'codingProfName' voice activity detection threshold level 16 voice coding profile 'codingProfName' voice activity detection threshold level 15 voice coding profile 'codingProfName' voice activity detection threshold level 14 voice coding profile 'codingProfName' voice activity detection threshold level 13 voice coding profile 'codingProfName' voice activity detection threshold level 12 voice coding profile 'codingProfName' voice activity detection threshold level 11 voice coding profile 'codingProfName' voice activity detection threshold level 10 voice coding profile 'codingProfName' voice activity detection threshold level 9 voice coding profile 'codingProfName' voice activity detection threshold level 8 voice coding profile 'codingProfName' voice activity detection threshold level 7 voice coding profile 'codingProfName' voice activity detection threshold level 6 voice coding profile 'codingProfName' voice activity detection threshold level 5 voice coding profile 'codingProfName' voice activity detection threshold level 4 voice coding profile 'codingProfName' voice activity detection threshold level 3 voice coding profile 'codingProfName' voice activity detection threshold level 2 voice coding profile 'codingProfName' voice activity detection threshold level 1 ")
vsmCodingProfVEchoCanComfNoiseMode = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 3, 1, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("static", 1), ("adaptive", 2))).clone('static')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmCodingProfVEchoCanComfNoiseMode.setStatus('mandatory')
if mibBuilder.loadTexts: vsmCodingProfVEchoCanComfNoiseMode.setDescription("New leaf for 2.2f parser. For more information, please see the following CLI command: voice coding profile 'codingProfName' voice echo canceller comfort noise mode static voice coding profile 'codingProfName' voice echo canceller comfort noise mode adaptive ")
vsmCodingProfEchoCanRefreshCfg = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 3, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("frozen", 1), ("refresh", 2))).clone('frozen')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmCodingProfEchoCanRefreshCfg.setStatus('mandatory')
if mibBuilder.loadTexts: vsmCodingProfEchoCanRefreshCfg.setDescription("New leaf for 2.2f parser. For more information, please see the following CLI command: voice coding profile 'codingProfName' echo canceller refresh configuration frozen voice coding profile 'codingProfName' echo canceller refresh configuration refresh ")
vsmCodingProfEchoCanRefreshState = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 3, 1, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone('on')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmCodingProfEchoCanRefreshState.setStatus('mandatory')
if mibBuilder.loadTexts: vsmCodingProfEchoCanRefreshState.setDescription("New leaf for 2.2f parser. For more information, please see the following CLI command: voice coding profile 'codingProfName' echo canceller refresh state on voice coding profile 'codingProfName' echo canceller refresh state off ")
vsmCodingProfECTailDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 3, 1, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4, 8, 16, 32))).clone(namedValues=NamedValues(("delay1", 4), ("delay2", 8), ("delay3", 16), ("delay4", 32))).clone('delay3')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmCodingProfECTailDelay.setStatus('mandatory')
if mibBuilder.loadTexts: vsmCodingProfECTailDelay.setDescription("Echo canceller (EC) tail delay in msec. For more information, please see the following CLI command: voice coding profile 'codingProfName' voice echo canceller tail (0 .. 128 ) ")
vsmCodingProfECNonLinear = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 3, 1, 1, 23), VsmEnableDisabled().clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmCodingProfECNonLinear.setStatus('mandatory')
if mibBuilder.loadTexts: vsmCodingProfECNonLinear.setDescription("Enables or disables non-linear echo canceller (EC). object only has effect if the vsmCodingProfEC object is enabled. For more information, please see the following CLI command: voice coding profile 'codingProfName' voice echo canceller non linear on voice coding profile 'codingProfName' voice echo canceller non linear off ")
vsmCodingProfFaxRate = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 3, 1, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2400, 4800, 7200, 9600, 12000, 14400))).clone(namedValues=NamedValues(("rate1", 2400), ("rate2", 4800), ("rate3", 7200), ("rate4", 9600), ("rate5", 12000), ("rate6", 14400))).clone('rate6')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmCodingProfFaxRate.setStatus('mandatory')
if mibBuilder.loadTexts: vsmCodingProfFaxRate.setDescription("Specifies the FAX maximum rate. For more information, please see the following CLI command: voice coding profile 'codingProfName' fax rate 2400 voice coding profile 'codingProfName' fax rate 4800 voice coding profile 'codingProfName' fax rate 7200 voice coding profile 'codingProfName' fax rate 9600 voice coding profile 'codingProfName' fax rate 12000 voice coding profile 'codingProfName' fax rate 14400 ")
vsmCodingProfFaxTxLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 3, 1, 1, 36), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-13, 0)).clone(-13)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmCodingProfFaxTxLevel.setStatus('mandatory')
if mibBuilder.loadTexts: vsmCodingProfFaxTxLevel.setDescription("Specifies the fax modem transmit (tx) gain. For more information, please see the following CLI command: voice coding profile 'codingProfName' fax transmit level -13 voice coding profile 'codingProfName' fax transmit level -12 voice coding profile 'codingProfName' fax transmit level -11 voice coding profile 'codingProfName' fax transmit level -10 voice coding profile 'codingProfName' fax transmit level -9 voice coding profile 'codingProfName' fax transmit level -8 voice coding profile 'codingProfName' fax transmit level -7 voice coding profile 'codingProfName' fax transmit level -6 voice coding profile 'codingProfName' fax transmit level -5 voice coding profile 'codingProfName' fax transmit level -4 voice coding profile 'codingProfName' fax transmit level -3 voice coding profile 'codingProfName' fax transmit level -2 voice coding profile 'codingProfName' fax transmit level -1 voice coding profile 'codingProfName' fax transmit level 0 ")
vsmCodingProfFaxCdThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 3, 1, 1, 37), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("n26dBm", 1), ("n33dBm", 2), ("n43dBm", 3))).clone('n43dBm')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmCodingProfFaxCdThresh.setStatus('mandatory')
if mibBuilder.loadTexts: vsmCodingProfFaxCdThresh.setDescription("Specifies the fax modem carrier-detection threshold. For more information, please see the following CLI command: voice coding profile 'codingProfName' fax carrier detect threshold low voice coding profile 'codingProfName' fax carrier detect threshold medium voice coding profile 'codingProfName' fax carrier detect threshold high ")
vsmCodingProfFaxTimeOut = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 3, 1, 1, 38), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 3200)).clone(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmCodingProfFaxTimeOut.setStatus('mandatory')
if mibBuilder.loadTexts: vsmCodingProfFaxTimeOut.setDescription("Specifies the amount of time of no activity on a fax modem connection before the call will be cleared. For more information, please see the following CLI command: voice coding profile 'codingProfName' fax timeout (10..32000) ")
vsmCodingProfFaxHsPktRate = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 3, 1, 1, 39), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(10, 20, 30, 40))).clone(namedValues=NamedValues(("rate1", 10), ("rate2", 20), ("rate3", 30), ("rate4", 40))).clone('rate2')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmCodingProfFaxHsPktRate.setStatus('mandatory')
if mibBuilder.loadTexts: vsmCodingProfFaxHsPktRate.setDescription("Specifies the rate at which high speed data will be sent across the network, for fax coding. For more information, please see the following CLI command: voice coding profile 'codingProfName' fax t.38 high speed packet rate 10 voice coding profile 'codingProfName' fax t.38 high speed packet rate 20 voice coding profile 'codingProfName' fax t.38 high speed packet rate 30 voice coding profile 'codingProfName' fax t.38 high speed packet rate 40 ")
vsmCodingProfFaxLsRedun = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 3, 1, 1, 40), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 6)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmCodingProfFaxLsRedun.setStatus('mandatory')
if mibBuilder.loadTexts: vsmCodingProfFaxLsRedun.setDescription("Specifies the packet-level redundancy for low speed data transmission, for fax coding. For more information, please see the following CLI command: voice coding profile 'codingProfName' fax t.38 low speed redundancy 0 voice coding profile 'codingProfName' fax t.38 low speed redundancy 1 voice coding profile 'codingProfName' fax t.38 low speed redundancy 2 voice coding profile 'codingProfName' fax t.38 low speed redundancy 3 voice coding profile 'codingProfName' fax t.38 low speed redundancy 4 voice coding profile 'codingProfName' fax t.38 low speed redundancy 5 ")
vsmCodingProfFaxHsRedun = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 3, 1, 1, 41), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmCodingProfFaxHsRedun.setStatus('mandatory')
if mibBuilder.loadTexts: vsmCodingProfFaxHsRedun.setDescription("Specifies the packet-level redundancy for high speed data transmission, for fax coding. For more information, please see the following CLI command: voice coding profile 'codingProfName' fax t.38 high speed redundancy 0 voice coding profile 'codingProfName' fax t.38 high speed redundancy 1 voice coding profile 'codingProfName' fax t.38 high speed redundancy 2 ")
vsmCodingProfFaxTcfMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 3, 1, 1, 42), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("local", 1), ("network", 2))).clone('network')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmCodingProfFaxTcfMethod.setStatus('mandatory')
if mibBuilder.loadTexts: vsmCodingProfFaxTcfMethod.setDescription("Specifies the method with which data is handled over the network, for fax coding. For more information, please see the following CLI command: voice coding profile 'codingProfName' fax t.38 training check field method local voice coding profile 'codingProfName' fax t.38 training check field method network ")
vsmCodingProfSilenceDetect = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 3, 1, 1, 43), VsmEnableDisabled().clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmCodingProfSilenceDetect.setStatus('mandatory')
if mibBuilder.loadTexts: vsmCodingProfSilenceDetect.setDescription("Enables or disables silence detection. For more information, please see the following CLI command: voice coding profile 'codingProfName' no silence detect time ")
vsmCodingProfSilenceDetectTime = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 3, 1, 1, 44), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 32000)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmCodingProfSilenceDetectTime.setStatus('mandatory')
if mibBuilder.loadTexts: vsmCodingProfSilenceDetectTime.setDescription("Specifies the silent time for declaring silence detection. To disable silence detection use the object vsmCodingProfSilenceDetect. For more information, please see the following CLI command: voice coding profile 'codingProfName' silence detect time (5..32000) ")
vsmCodingProfSilenceLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 3, 1, 1, 45), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-50, -40)).clone(-50)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmCodingProfSilenceLevel.setStatus('mandatory')
if mibBuilder.loadTexts: vsmCodingProfSilenceLevel.setDescription("Specifies the silence signal level for declaring silence detection. For more information, please see the following CLI command: voice coding profile 'codingProfName' silence detect level -50 voice coding profile 'codingProfName' silence detect level -49 voice coding profile 'codingProfName' silence detect level -48 voice coding profile 'codingProfName' silence detect level -47 voice coding profile 'codingProfName' silence detect level -46 voice coding profile 'codingProfName' silence detect level -45 voice coding profile 'codingProfName' silence detect level -44 voice coding profile 'codingProfName' silence detect level -43 voice coding profile 'codingProfName' silence detect level -42 voice coding profile 'codingProfName' silence detect level -41 voice coding profile 'codingProfName' silence detect level -40 ")
vsmCodingProfVoiceComfortNoiseLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 3, 1, 1, 46), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-70, -40)).clone(-40)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmCodingProfVoiceComfortNoiseLevel.setStatus('mandatory')
if mibBuilder.loadTexts: vsmCodingProfVoiceComfortNoiseLevel.setDescription(" This command is used to set the comfort noise level. For more information, please see the following CLI command: voice coding profile 'codingProfName' voice comfort noise level (-70 ... -40) ")
vsmCodingProfG711ModemResampMode = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 3, 1, 1, 47), VsmEnableDisabled().clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmCodingProfG711ModemResampMode.setStatus('mandatory')
if mibBuilder.loadTexts: vsmCodingProfG711ModemResampMode.setDescription(" This command toggles resampling on or off for a Coding Profile. For more information, please see the following CLI command: voice coding profile 'codingProfName' g.711 modem resampling mode on voice coding profile 'codingProfName' g.711 modem resampling mode off ")
vsmCodingProfSinFreqToneDet = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 3, 1, 1, 48), VsmEnableDisabled().clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmCodingProfSinFreqToneDet.setStatus('mandatory')
if mibBuilder.loadTexts: vsmCodingProfSinFreqToneDet.setDescription(" This command is used to enable or disable SF Single Frequency signaling tone detection. The SF Signaling characteristocs are defined in the Bellcore document TP-NPL-000275. The DSPs on the VSx card supports detection of 2600 Hz tone. For more information, please see the following CLI command: voice coding profile 'codingProfName' single frequency tone detection on voice coding profile 'codingProfName' single frequency tone detection off ")
vsmCodingProfRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 3, 1, 1, 49), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmCodingProfRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vsmCodingProfRowStatus.setDescription("This object is the RowStatus (locking flag) for creating the vsmCodingProfileTable conceptual row. For more information, please see the following CLI command: voice no coding profile 'codingProfName' ")
vsmDestinationsTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 26, 4, 1), )
if mibBuilder.loadTexts: vsmDestinationsTable.setStatus('mandatory')
if mibBuilder.loadTexts: vsmDestinationsTable.setDescription('This table defines all the possible network destinations on this switch. This table includes definitions for both destinations and local destinations. Not all elements of the table are used for both types od destinations. Each element description should be checked to see if local or non-local or both types are supported. Local destinations are defined to be destinations that reside on the same Vsd board. Thus they do not ahve to travel over IP. ')
vsmDestinationsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 26, 4, 1, 1), ).setIndexNames((0, "XYLAN-VSM-MIB", "vsmDestinationsName"))
if mibBuilder.loadTexts: vsmDestinationsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vsmDestinationsEntry.setDescription('This is an entry in the vsmDialDestinationsTable. For more information, please see the following CLI command: [Note: There is NO equivalent command in the CLI.] ')
vsmDestinationsName = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 4, 1, 1, 1), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmDestinationsName.setStatus('mandatory')
if mibBuilder.loadTexts: vsmDestinationsName.setDescription("A name describing the network destination. This object is valid for both local and non-local destinations. For more information, please see the following CLI command: voice destination 'endPointNameStr' h.323 xxx.xxx.xxx.xxx h323port voice destination 'destinationNameStr' local channel 'endpointNameStr'/port/startChannel-endChannel ")
vsmDestinationsIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 4, 1, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmDestinationsIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: vsmDestinationsIpAddr.setDescription("IP Address of a network endpoint The default value is 127.0.0.1 For more information, please see the following CLI command: voice destination 'endPointNameStr' h.323 xxx.xxx.xxx.xxx [h323port] ")
vsmDestinationsNetworkPort = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 4, 1, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmDestinationsNetworkPort.setStatus('mandatory')
if mibBuilder.loadTexts: vsmDestinationsNetworkPort.setDescription("Network H.323 port for destination, For now this parameter is always 1720. This is valid for only non-local destinations. For more information, please see the following CLI command: voice destination 'endPointNameStr' h.323 xxx.xxx.xxx.xxx [h323port] ")
vsmDestinationsH323Name = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 4, 1, 1, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmDestinationsH323Name.setStatus('mandatory')
if mibBuilder.loadTexts: vsmDestinationsH323Name.setDescription("The end point name describing the network destination that is associated with an IP address. All local ports will have this name associated with them. This object is valid for local ports only. For more information, please see the following CLI command: voice destination 'destinationNameStr' local channel 'endpointNameStr'/port/startChannel-endChannel ")
vsmDestinationsLocalPort = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 4, 1, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmDestinationsLocalPort.setStatus('mandatory')
if mibBuilder.loadTexts: vsmDestinationsLocalPort.setDescription("The Physical port number on which this local destination exists. This is valid for only local destinations. For more information, please see the following CLI command: voice destination 'destinationNameStr' local channel 'endpointNameStr'/port/startChannel-endChannel ")
vsmDestinationsStartChan = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 4, 1, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmDestinationsStartChan.setStatus('mandatory')
if mibBuilder.loadTexts: vsmDestinationsStartChan.setDescription("a group of channels is associated with a local destination, this specifies the first channel number in that group. This object is for local destinations only. For more information, please see the following CLI command: voice destination 'destinationNameStr' local channel 'endpointNameStr'/port/startChannel-endChannel ")
vsmDestinationsEndChan = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 4, 1, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmDestinationsEndChan.setStatus('mandatory')
if mibBuilder.loadTexts: vsmDestinationsEndChan.setDescription("a group of channels is associated with a local destination, this specifies the last channel number in that group. This object is for local destinations only. For more information, please see the following CLI command: voice destination 'destinationNameStr' local channel 'endpointNameStr'/port/startChannel-endChannel ")
vsmDestinationsType = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 4, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("h323", 1))).clone('h323')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmDestinationsType.setStatus('mandatory')
if mibBuilder.loadTexts: vsmDestinationsType.setDescription("The type of destination, hsmu (H.323), tsgm, or qsmu. Currently we only support hsmu. This is valid for all destinations as a local destination will be set to tsgm. For more information, please see the following CLI command: voice destination 'endPointNameStr' h.323 xxx.xxx.xxx.xxx h323port ")
vsmDestinationsRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 4, 1, 1, 9), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmDestinationsRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vsmDestinationsRowStatus.setDescription("The status of a row in this table using CreateAndGo and DeleteRow. Objects in this table cannot be set individually. There are two basic operations supported. 1. endpoints can be created, 2. destinations can be created. When endpoints are created, In the PDU supplied with the RowStatus there must also be a vsmDestinationsName object, and a vsmDestinationsIpAddr object and optionally a vsmDestinationsNetworkPort object. When destinations are created, inside the Pdu with the RowStatus create request, the packet must also contain the vsmDestinationsName object, vsmDestinationsH323Name object, vsmDestinationsLocalPort object, vsmDestinationsStartChan object and vsmDestinationsEndChan object. The vsmDestinationsType object is currently not used since there is only one type supported. For more information, please see the following CLI command: voice no destination 'NameStr' ")
vsmPhoneGroupTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 26, 4, 2), )
if mibBuilder.loadTexts: vsmPhoneGroupTable.setStatus('mandatory')
if mibBuilder.loadTexts: vsmPhoneGroupTable.setDescription('This table contains information on the extensions and the usage of those extensions for each defined phone group. ')
vsmPhoneGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 26, 4, 2, 1), ).setIndexNames((0, "XYLAN-VSM-MIB", "vsmPhoneGroupName"))
if mibBuilder.loadTexts: vsmPhoneGroupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vsmPhoneGroupEntry.setDescription('This is an entry in the vsmPhoneGroupTable. For more information, please see the following CLI command: [Note: There is NO equivalent command in the CLI.] ')
vsmPhoneGroupName = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 4, 2, 1, 1), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmPhoneGroupName.setStatus('mandatory')
if mibBuilder.loadTexts: vsmPhoneGroupName.setDescription("A name describing a row in the phone group table. For more information, please see the following CLI command: voice phone group 'PhoneGroupName' ")
vsmPhoneGroupType = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 4, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("localExt", 1), ("nanpExt", 2), ("internationalExt", 3), ("nanpPstn", 4), ("internationalPstn", 5))).clone('localExt')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmPhoneGroupType.setStatus('mandatory')
if mibBuilder.loadTexts: vsmPhoneGroupType.setDescription("Specifies the type of phone group type. For more information, please see the following CLI command: voice phone group 'PhoneGroupName' type local extensions voice phone group 'PhoneGroupName' type NANP extensions voice phone group 'PhoneGroupName' type international extensions voice phone group 'PhoneGroupName' type NANP PSTN voice phone group 'PhoneGroupName' type international PSTN ")
vsmPhoneGroupFormat = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 4, 2, 1, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmPhoneGroupFormat.setStatus('mandatory')
if mibBuilder.loadTexts: vsmPhoneGroupFormat.setDescription("This command is used to set the preferred user viewing format specification for this phone group. This field is used to calculated the # of digits allowed. For more information, please see the following CLI command: voice phone group 'PhoneGroupName' format 'formatString' ")
vsmPhoneGroupUsageVoice = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 4, 2, 1, 4), VsmEnableDisabled().clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmPhoneGroupUsageVoice.setStatus('mandatory')
if mibBuilder.loadTexts: vsmPhoneGroupUsageVoice.setDescription("This command is used to set the allowed usages of these phone lines This parameter allows for better type checking upon binding later on. For more information, please see the following CLI command: voice phone group 'PhoneGroupName' usage voice on voice phone group 'PhoneGroupName' usage voice off ")
vsmPhoneGroupUsageFax = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 4, 2, 1, 5), VsmEnableDisabled().clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmPhoneGroupUsageFax.setStatus('mandatory')
if mibBuilder.loadTexts: vsmPhoneGroupUsageFax.setDescription("This command is used to set the allowed usages of these phone lines This parameter allows for better type checking upon binding later on. For more information, please see the following CLI command: voice phone group 'PhoneGroupName' usage fax on voice phone group 'PhoneGroupName' usage fax off ")
vsmPhoneGroupUsageModem = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 4, 2, 1, 6), VsmEnableDisabled().clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmPhoneGroupUsageModem.setStatus('mandatory')
if mibBuilder.loadTexts: vsmPhoneGroupUsageModem.setDescription("This command is used to set the allowed usages of these phone lines This parameter allows for better type checking upon binding later on. For more information, please see the following CLI command: voice phone group 'PhoneGroupName' usage modem on voice phone group 'PhoneGroupName' usage modem off ")
vsmPhoneGroupUsageData = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 4, 2, 1, 7), VsmEnableDisabled().clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmPhoneGroupUsageData.setStatus('mandatory')
if mibBuilder.loadTexts: vsmPhoneGroupUsageData.setDescription("This command is used to set the allowed usages of these phone lines This parameter allows for better type checking upon binding later on. For more information, please see the following CLI command: voice phone group 'PhoneGroupName' usage data on voice phone group 'PhoneGroupName' usage data off ")
vsmPhoneGroupSitePrefixEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 4, 2, 1, 8), VsmEnableDisabled().clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmPhoneGroupSitePrefixEnable.setStatus('mandatory')
if mibBuilder.loadTexts: vsmPhoneGroupSitePrefixEnable.setDescription("This command selects if a site prefix will be used. A caller uses this prefix to route members of this phone group. For more information, please see the following CLI command: voice phone group 'PhoneGroupName' site prefix on voice phone group 'PhoneGroupName' site prefix off ")
vsmPhoneGroupSitePrefixString = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 4, 2, 1, 9), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmPhoneGroupSitePrefixString.setStatus('mandatory')
if mibBuilder.loadTexts: vsmPhoneGroupSitePrefixString.setDescription("This command sets the site prefix digits to be used. For example **9 would mean that from any channel on the network, if the digits **9 are pressed, we expect # of digits to follow. So if the user sets up a site prefix of **9, and the format is XXXX then to get to extension 4601, the user would dial **94601 to get to that extension from anywhere on the VoIP network. In this case, a 3 digit dialing prefix is used, so the VoIP network can support 1728 sites, with 1000 extensions per site For more information, please see the following CLI command: voice phone group 'PhoneGroupName' site prefix digits 'String' ")
vsmPhoneGroupStripDigitLength = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 4, 2, 1, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmPhoneGroupStripDigitLength.setStatus('mandatory')
if mibBuilder.loadTexts: vsmPhoneGroupStripDigitLength.setDescription("Number of digits to strip from the beginning of the digits collected before forwarding on the destination side. For more information, please see the following CLI command: voice phone group 'PhoneGroupName' strip digit length vsmPreStripLength ")
vsmPhoneGroupForwardingPrefixEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 4, 2, 1, 11), VsmEnableDisabled().clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmPhoneGroupForwardingPrefixEnable.setStatus('mandatory')
if mibBuilder.loadTexts: vsmPhoneGroupForwardingPrefixEnable.setDescription("This command is used to enable/disable the forwarding prefix. The forwarding prefix is a digit that must be typed before the phone group is entered. For more information, please see the following CLI command: voice phone group 'PhoneGroupName' forwarding prefix on voice phone group 'PhoneGroupName' forwarding prefix off ")
vsmPhoneGroupForwardingPrefix = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 4, 2, 1, 12), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmPhoneGroupForwardingPrefix.setStatus('mandatory')
if mibBuilder.loadTexts: vsmPhoneGroupForwardingPrefix.setDescription("String of digits to prefix before forwarding on the destination side. Digits to be attached at the beginning of the address being forwarded. For example, when dialing out to a PBX, dial 9 before outward dialing. This is an optional parameter. For more information, please see the following CLI command: voice phone group 'PhoneGroupName' forwarding prefix digits 'String' ")
vsmPhoneGroupRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 4, 2, 1, 13), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmPhoneGroupRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vsmPhoneGroupRowStatus.setDescription("The status of a row in this table using SNMPv2 Standard for row status; CreateAndWait, CreateAndGo, ActivateRow, InactivateRow and DeleteRow. For more information, please see the following CLI command: voice no phone group 'PhoneGroupName' ")
vsmPGNumbersTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 26, 4, 3), )
if mibBuilder.loadTexts: vsmPGNumbersTable.setStatus('mandatory')
if mibBuilder.loadTexts: vsmPGNumbersTable.setDescription('This table contains arrays of phone ranges for the above phone groups. This table has two indexes, because there is an array of phone ranges for each phone group. ')
vsmPGNumbersEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 26, 4, 3, 1), ).setIndexNames((0, "XYLAN-VSM-MIB", "vsmPhoneGroupName"), (0, "XYLAN-VSM-MIB", "vsmPGNumber"))
if mibBuilder.loadTexts: vsmPGNumbersEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vsmPGNumbersEntry.setDescription('This is an entry in the vsmPhoneGroupTable. For more information, please see the following CLI command: [Note: There is NO equivalent command in the CLI.] ')
vsmPGNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 4, 3, 1, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmPGNumber.setStatus('mandatory')
if mibBuilder.loadTexts: vsmPGNumber.setDescription("The site number being added to the phone group entry. For more information, please see the following CLI command: voice phone group 'PhoneGroupName' add numbers 'StartRange' voice phone group 'PhoneGroupName' add numbers 'StartRange' thru 'EndRange' ")
vsmPGNumbersRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 4, 3, 1, 2), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmPGNumbersRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vsmPGNumbersRowStatus.setDescription("The status of a row in this table using SNMPv2 Standard for row status; CreateAndWait, CreateAndGo, ActivateRow, InactivateRow and DeleteRow. For more information, please see the following CLI command: voice phone group 'PhoneGroupName' delete numbers 'StartRange' voice phone group 'PhoneGroupName' delete numbers 'StartRange' thru 'EndRange' ")
vsmNumPlanTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 26, 4, 4), )
if mibBuilder.loadTexts: vsmNumPlanTable.setStatus('mandatory')
if mibBuilder.loadTexts: vsmNumPlanTable.setDescription('This table contains information on the extensions and the usage of those extensions for each defined phone group. ')
vsmNumPlanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 26, 4, 4, 1), ).setIndexNames((0, "XYLAN-VSM-MIB", "vsmNumPlanName"))
if mibBuilder.loadTexts: vsmNumPlanEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vsmNumPlanEntry.setDescription('This is an entry in the vsmNumPlanTable. For more information, please see the following CLI command: [Note: There is NO equivalent command in the CLI.] ')
vsmNumPlanName = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 4, 4, 1, 1), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmNumPlanName.setStatus('mandatory')
if mibBuilder.loadTexts: vsmNumPlanName.setDescription("A name describing a row in the numbering plan table. For more information, please see the following CLI command: voice numbering plan 'NumberingPlanName' ")
vsmNumPlanHuntMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 4, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("roundRobin", 1), ("topDown", 2))).clone('roundRobin')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmNumPlanHuntMethod.setStatus('mandatory')
if mibBuilder.loadTexts: vsmNumPlanHuntMethod.setDescription("This command is used to set the method of outgoing hunting. It also serves to group related destinations together. For more information, please see the following CLI command: voice numbering plan 'NumberingPlanName' hunt method round robin voice numbering plan 'NumberingPlanName' hunt method top down ")
vsmNumPlanDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 4, 4, 1, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmNumPlanDescription.setStatus('mandatory')
if mibBuilder.loadTexts: vsmNumPlanDescription.setDescription("This parameter is used to store a description of this phone group It is for the users convenience only. This command is optional and has no effect on any hardware. This can be used to hold the circuit identifier is so desired. For more information, please see the following CLI command: voice numbering plan 'NumberingPlanName' description 'String' ")
vsmNumPlanAllActivate = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 4, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("activate", 1), ("active", 2), ("inactive", 3), ("invalid", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmNumPlanAllActivate.setStatus('mandatory')
if mibBuilder.loadTexts: vsmNumPlanAllActivate.setDescription('This object has one writable state called activate, This will force the configured row to become the active configuration for the specified card. This object can be read to determine the current state of the row. If the row has not been activated, by default, the state is inactive. If the row has been activated and the configuration is good, then this object transitions to active. If the row has been activated and the configuration is not good then this object transitions to invalid. For more information, please see the following CLI command: voice numbering plan all activate ')
vsmNumPlanRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 4, 4, 1, 5), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmNumPlanRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vsmNumPlanRowStatus.setDescription("The status of a row in this table using SNMPv2 Standard for row status; CreateAndWait, CreateAndGo, ActivateRow, InactivateRow and DeleteRow. For more information, please see the following CLI command: voice no numbering plan 'NumberingPlanName' ")
vsmNPPhoneGroupTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 26, 4, 5), )
if mibBuilder.loadTexts: vsmNPPhoneGroupTable.setStatus('mandatory')
if mibBuilder.loadTexts: vsmNPPhoneGroupTable.setDescription('This table contains arrays of phone groups that are associated with numbering plans. ')
vsmNPPhoneGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 26, 4, 5, 1), ).setIndexNames((0, "XYLAN-VSM-MIB", "vsmNumPlanName"), (0, "XYLAN-VSM-MIB", "vsmPhoneGroupName"))
if mibBuilder.loadTexts: vsmNPPhoneGroupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vsmNPPhoneGroupEntry.setDescription('This is an entry in the vsmNumPlanTable. For more information, please see the following CLI command: [Note: There is NO equivalent command in the CLI.] ')
vsmNPPhoneGroupRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 4, 5, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmNPPhoneGroupRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vsmNPPhoneGroupRowStatus.setDescription("The status of a row in this table using SNMPv2 Standard for row status; CreateAndWait, CreateAndGo, ActivateRow, InactivateRow and DeleteRow. For more information, please see the following CLI command: voice numbering plan 'NumberingPlanName' associate phone group member 'PhoneGroupName' voice numbering plan 'NumberingPlanName' disassociate phone group member 'PhoneGroupName' ")
vsmNPDestinationsTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 26, 4, 6), )
if mibBuilder.loadTexts: vsmNPDestinationsTable.setStatus('mandatory')
if mibBuilder.loadTexts: vsmNPDestinationsTable.setDescription('This table contains arrays of destinations that are associated with Numbering Plans. ')
vsmNPDestinationsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 26, 4, 6, 1), ).setIndexNames((0, "XYLAN-VSM-MIB", "vsmNumPlanName"), (0, "XYLAN-VSM-MIB", "vsmDestinationsName"))
if mibBuilder.loadTexts: vsmNPDestinationsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vsmNPDestinationsEntry.setDescription('This is an entry in the vsmNumPlanTable. For more information, please see the following CLI command: [Note: There is NO equivalent command in the CLI.] ')
vsmNPDestinationsRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 4, 6, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmNPDestinationsRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vsmNPDestinationsRowStatus.setDescription("The status of a row in this table using SNMPv2 Standard for row status; CreateAndWait, CreateAndGo, ActivateRow, InactivateRow and DeleteRow. For more information, please see the following CLI command: voice numbering plan 'NumberingPlanName' associate destination member 'NameStr' voice numbering plan 'NumberingPlanName' disassociate destination member 'NameStr' ")
vsmCardConfTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 26, 5, 1), )
if mibBuilder.loadTexts: vsmCardConfTable.setStatus('mandatory')
if mibBuilder.loadTexts: vsmCardConfTable.setDescription('This table contains VSM local interface configuration parameters, one entry per VSM daughter card. ')
vsmCardConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 26, 5, 1, 1), ).setIndexNames((0, "XYLAN-VSM-MIB", "vsmCardSlotIndex"), (0, "XYLAN-VSM-MIB", "vsmCardSubunitIndex"))
if mibBuilder.loadTexts: vsmCardConfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vsmCardConfEntry.setDescription('This list contains VSM interface configuration parameters and state variables. For more information, please see the following CLI command: [Note: There is NO equivalent command in the CLI.] ')
vsmCardSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 5, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 9))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmCardSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vsmCardSlotIndex.setDescription('The slot number for the card For more information, please see the following CLI command: [Note: There is NO equivalent command in the CLI.] ')
vsmCardSubunitIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 5, 1, 1, 2), XylanModuleSubunit()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmCardSubunitIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vsmCardSubunitIndex.setDescription("The sub-unit number within module in slot 'n'. For each non-empty slot there will exist a module entry with a chasModuleSubUnit value of base. If the chasModuleType of that chasModuleEntry is hsm, then there may be additional chasModuleEntrys with the same chasModuleSlot value but with chasModuleSubUnit values of hsm1 or hsm2. These are HSM sub-modules. An HSM module can have up to 2 daughter cards on it. The first position would be denoted by hsm1(2) and the second position is hsm2(3). The general implication of this field is: each occupied slot will have an entry field will be base(1), and may if the module supports daughter cards have entries for which if this field is hsm1(2) or hsm2(3), corresponding to an installed daughter card on the HSM in the specified chasModuleSlot. (and the card type will be listed in chasModuleType). For more information, please see the following CLI command: [Note: There is NO equivalent command in the CLI.] ")
vsmCardIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 5, 1, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmCardIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: vsmCardIpAddr.setDescription('The IP address of the daughter card For more information, please see the following CLI command: voice daughter card slot/daughter_card_number ip address xxx.xxx.xxx.xxx ')
vsmCardIpMask = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 5, 1, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmCardIpMask.setStatus('mandatory')
if mibBuilder.loadTexts: vsmCardIpMask.setDescription('The IP mask of the daughter card For more information, please see the following CLI command: voice daughter card slot/daughter_card_number ip mask xxx.xxx.xxx.xxx ')
vsmCardIpDefGateway = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 5, 1, 1, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmCardIpDefGateway.setStatus('mandatory')
if mibBuilder.loadTexts: vsmCardIpDefGateway.setDescription('The IP Default Gateway of the daughter card For more information, please see the following CLI command: voice daughter card slot/daughter_card_number ip default gateway xxx.xxx.xxx.xxx ')
vsmCardFirstDigitWaitDur = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 5, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)).clone(10000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmCardFirstDigitWaitDur.setStatus('mandatory')
if mibBuilder.loadTexts: vsmCardFirstDigitWaitDur.setDescription('Time between off-hook and when the first dial digit is entered. At expiration, causes a no digits received error condition to occur, this in turn, causes the numbering plan lookup to fail. This object has a range of 100 to 65500 milliseconds, in increments of 100 ms. For more information, please see the following CLI command: voice daughter card slot/daughter_card_number first digit wait duration (1..4294967295) ')
vsmCardInterDigitWaitDur = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 5, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)).clone(5000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmCardInterDigitWaitDur.setStatus('mandatory')
if mibBuilder.loadTexts: vsmCardInterDigitWaitDur.setDescription('The maximum time allowed between entry of each digit after the first digit. At expiration, assumes that the user is done entering digits, and causes the numbering plan to attempt a match. This object has a range of 100 to 65500 milliseconds, in increments of 100 ms. For more information, please see the following CLI command: voice daughter card slot/daughter_card_number inter digit wait duration (1..4294967295)')
vsmCardDialTimeDur = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 5, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)).clone(30000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmCardDialTimeDur.setStatus('mandatory')
if mibBuilder.loadTexts: vsmCardDialTimeDur.setDescription('The maximum time allowed for entry of the entire string of dialed digits if no other dial string terminating condition is declared. At expiration, assumes that the user is done entering digits, and causes the numbering plan to attempt a match. This object has a range of 100 to 65500 milliseconds, in increments of 100 ms. For more information, please see the following CLI command: voice daughter card slot/daughter_card_number dial time duration (1..4294967295) ')
vsmCardTermDigitStr = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 5, 1, 1, 9), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmCardTermDigitStr.setStatus('mandatory')
if mibBuilder.loadTexts: vsmCardTermDigitStr.setDescription('A NULL for the string disables dial termination string detection. This object is only a 1 digit string. Any valid digit: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, a, b, c, d, * or #. The Dial Terminating Digit is used for the purpose of determining when the dial process is complete. When this digit is received, ignore all digits entered after it. Upon receiving this digit, causes the numbering plan to attempt a match with the digits received before this terminating digit. The Dial Terminating Digit can not be part of a valid number. All the digits dialed until the Dial Terminating Digit are considered valid and the Dial Terminating Digit is discarded. For more information, please see the following CLI command: voice daughter card slot/daughter_card_number no termination digit voice daughter card slot/daughter_card_number termination digit 0 voice daughter card slot/daughter_card_number termination digit 1 voice daughter card slot/daughter_card_number termination digit 2 voice daughter card slot/daughter_card_number termination digit 3 voice daughter card slot/daughter_card_number termination digit 4 voice daughter card slot/daughter_card_number termination digit 5 voice daughter card slot/daughter_card_number termination digit 6 voice daughter card slot/daughter_card_number termination digit 7 voice daughter card slot/daughter_card_number termination digit 8 voice daughter card slot/daughter_card_number termination digit 9 voice daughter card slot/daughter_card_number termination digit # voice daughter card slot/daughter_card_number termination digit * Note: The following are not supported in this Release. voice daughter card slot/daughter_card_number termination digit A voice daughter card slot/daughter_card_number termination digit B voice daughter card slot/daughter_card_number termination digit C voice daughter card slot/daughter_card_number termination digit D ')
vsmCardH323InFastStart = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 5, 1, 1, 10), VsmEnableDisabled().clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmCardH323InFastStart.setStatus('mandatory')
if mibBuilder.loadTexts: vsmCardH323InFastStart.setDescription('This command is used to select the H.323 Fast Start mode on the incoming side of the link. For more information, please see the following CLI command: voice daughter card slot/daughter_card_number h.323 in[coming] fast start on voice daughter card slot/daughter_card_number h.323 in[coming] fast start off ')
vsmCardH323OutFastStart = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 5, 1, 1, 11), VsmEnableDisabled().clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmCardH323OutFastStart.setStatus('mandatory')
if mibBuilder.loadTexts: vsmCardH323OutFastStart.setDescription('This command is used to select the H.323 Fast Start mode on the outgoing side of the link. For more information, please see the following CLI command: voice daughter card slot/daughter_card_number h.323 out[going] fast start on voice daughter card slot/daughter_card_number h.323 out[going] fast start off ')
vsmCardH323AutomaticAnswer = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 5, 1, 1, 12), VsmEnableDisabled().clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmCardH323AutomaticAnswer.setStatus('mandatory')
if mibBuilder.loadTexts: vsmCardH323AutomaticAnswer.setDescription(' This command is used to select the H.323 automatic call answering mode on the incoming side of the link. If on then the call is connected automatically for instant voice. For more information, please see the following CLI command: voice daughter card slot/daughter_card_number h.323 auto[matic] answer on voice daughter card slot/daughter_card_number h.323 auto[matic] answer off ')
vsmCardConfigStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 5, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("activate", 1), ("active", 2), ("inactive", 3), ("invalid", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmCardConfigStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vsmCardConfigStatus.setDescription('This object has one writable state called activate, This will force the configured row to become the active configuration for the specified card. This object can be read to determine the current state of the row. If the row has not been activated, by default, the state is inactive. If the row has been activated and the configuration is good, then this object transitions to active. If the row has been activated and the configuration is not good then this object transitions to invalid. For more information, please see the following CLI command: voice daughter card slot/daughter_card_number activate ')
vsmPortConfTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 26, 5, 2), )
if mibBuilder.loadTexts: vsmPortConfTable.setStatus('mandatory')
if mibBuilder.loadTexts: vsmPortConfTable.setDescription('This table contains VSM local interface configuration parameters, one entry per VSM physical port. ')
vsmPortConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 26, 5, 2, 1), ).setIndexNames((0, "XYLAN-VSM-MIB", "vsmPortSlotNum"), (0, "XYLAN-VSM-MIB", "vsmPortNum"))
if mibBuilder.loadTexts: vsmPortConfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vsmPortConfEntry.setDescription('This list contains VSM interface configuration parameters and state variables. For more information, please see the following CLI command: [Note: There is NO equivalent command in the CLI.] ')
vsmPortSlotNum = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 5, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmPortSlotNum.setStatus('mandatory')
if mibBuilder.loadTexts: vsmPortSlotNum.setDescription('The ifIndex for this Port in the interfaces table. For more information, please see the following CLI command: [Note: There is NO equivalent command in the CLI.] ')
vsmPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 5, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmPortNum.setStatus('mandatory')
if mibBuilder.loadTexts: vsmPortNum.setDescription('The ifIndex for this Port in the interfaces table. For more information, please see the following CLI command: [Note: There is NO equivalent command in the CLI.] ')
vsmPortInterfaceType = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 5, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("t1", 1), ("e1", 2), ("prie1", 3), ("e1IsdnPri", 4), ("briEuro", 5))).clone('t1')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmPortInterfaceType.setStatus('mandatory')
if mibBuilder.loadTexts: vsmPortInterfaceType.setDescription('The interface type of this port. This is used to determine the # of channels per port. For more information, please see the following CLI command: voice port slot/port interface type T1 voice port slot/port interface type E1 voice port slot/port interface type E1 ISDN PRI voice port slot/port interface type BRI EURO ')
vsmPortDialType = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 5, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("tone", 1), ("pulse", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmPortDialType.setStatus('deprecated')
if mibBuilder.loadTexts: vsmPortDialType.setDescription('Obsolete')
vsmPortDsx1LineType = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 5, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("other", 1), ("vsmPortDsx1ESF", 2), ("vsmPortDsx1D4", 3), ("vsmPortDsx1E1", 4), ("vsmPortDsx1E1-CRC", 5), ("vsmPortDsx1E1-MF", 6), ("vsmPortDsx1E1-CRC-MF", 7), ("vsmPortDsx1E1Unframed", 8))).clone('other')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmPortDsx1LineType.setStatus('mandatory')
if mibBuilder.loadTexts: vsmPortDsx1LineType.setDescription('This variable indicates the variety of DS1 Line implementing this circuit. The type of circuit affects the number of bits per second that the circuit can reasonably carry, as well as the interpretation of the usage and error statistics. The values, in sequence, describe: TITLE: SPECIFICATION: vsmPortDsx1ESF Extended SuperFrame DS1 vsmPortDsx1E1 CCITT Recommendation G.704 (Table 5a) vsmPortDsx1E1-CRC CCITT Recommendation G.704 (Table 5b) vsmPortDsxE1-MF G.704 (Table 4a) with TS16 multiframing enabled vsmPortDsx1E1-CRC-MF G.704 (Table 4b) with TS16 multiframing enabled vsmPortDsx1Unframed No Framing performed vsmPortDsx1E1Unframed E1 with No Framing For clarification, the capacity for each E1 type is as listed below: vsmPortDsx1E1Unframed - E1, no framing = 32 x 64k = 2048k vsmPortDsx1E1 or vsmPortDsx1E1CRC - E1, with framing, no signalling = 31 x 64k = 1984k vsmPortDsx1E1MF or vsmPortDsx1E1CRCMF - E1, with framing, signalling = 30 x 64k = 1920k For further information See CCITT Recomm G.704 For more information, please see the following CLI command: voice port slot/port frame format none voice port slot/port frame format superframe voice port slot/port frame format extended superframe voice port slot/port frame format E1 voice port slot/port frame format E1 CRC Note: The following are not supported in this Release voice port slot/port frame format E1 MF voice port slot/port frame format E1 CRC MF ')
vsmPortDsx1LineCoding = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 5, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("vsmPortDsx1JBZS", 1), ("vsmPortDsx1B8ZS", 2), ("vsmPortDsx1HDB3", 3), ("vsmPortDsx1AMI", 4), ("other", 5))).clone('vsmPortDsx1JBZS')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmPortDsx1LineCoding.setStatus('mandatory')
if mibBuilder.loadTexts: vsmPortDsx1LineCoding.setDescription('This variable describes the variety of Zero Code Suppression used on the link, which in turn affects a number of its characteristics. vsmPortDsx1JBZS refers the Jammed Bit Zero Suppres- sion, in which the AT&T specification of at least one pulse every 8 bit periods is literal- ly implemented by forcing a pulse in bit 8 of each channel. Thus, only seven bits per chan- nel, or 1.344 Mbps, is available for data. vsmPortDsx1B8ZS refers to the use of a specified pat- tern of normal bits and bipolar violations which are used to replace a sequence of eight zero bits. ANSI Clear Channels may use vsmPortDsx1ZBTSI, or Zero Byte Time Slot Interchange. E1 links, with or without CRC, use vsmPortDsx1HDB3 or vsmPortDsx1AMI. vsmPortDsx1AMI refers to a mode wherein no zero code suppression is present and the line encoding does not solve the problem directly. In this application, the higher layer must provide data which meets or exceeds the pulse density re- quirements, such as inverting HDLC data. For more information, please see the following CLI command: voice port slot/port line coding AMI voice port slot/port line coding B8ZS voice port slot/port line coding HDB3 ')
vsmPortDsx1SendCode = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 5, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("vsmPortDsx1SendNoCode", 1), ("vsmPortDsx1SendLineCode", 2), ("vsmPortDsx1SendPayloadCode", 3), ("vsmPortDsx1SendResetCode", 4), ("vsmPortDsx1SendQRS", 5), ("vsmPortDsx1Send511Pattern", 6), ("vsmPortDsx1Send3in24Pattern", 7), ("vsmPortDsx1SendOtherTestPattern", 8))).clone('vsmPortDsx1SendNoCode')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmPortDsx1SendCode.setStatus('mandatory')
if mibBuilder.loadTexts: vsmPortDsx1SendCode.setDescription('This variable indicates what type of code is being sent across the DS1 interface by the dev- ice. The values mean: vsmPortDsx1SendNoCode sending looped or normal data vsmPortDsx1SendLineCode sending a request for a line loopback vsmPortDsx1SendPayloadCode sending a request for a payload loopback vsmPortDsx1SendResetCode sending a loopback termination request vsmPortDsx1SendQRS sending a Quasi-Random Signal (QRS) test pattern vsmPortDsx1Send511Pattern sending a 511 bit fixed test pattern vsmPortDsx1Send3in24Pattern sending a fixed test pattern of 3 bits set in 24 vsmPortDsx1SendOtherTestPattern sending a test pattern other than those described by this object For more information, please see the following CLI command: voice port slot/port send code none voice port slot/port send code line voice port slot/port send code pay load voice port slot/port send code reset voice port slot/port send code quasi voice port slot/port send code quasi random signal voice port slot/port send code 511 voice port slot/port send code 511 pattern voice port slot/port send code 3 in 24 voice port slot/port send code 3 in 24 pattern voice port slot/port send code other ')
vsmPortDsx1CircuitIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 5, 2, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmPortDsx1CircuitIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: vsmPortDsx1CircuitIdentifier.setDescription("This variable contains the transmission vendor's circuit identifier, for the purpose of facilitating troubleshooting. For more information, please see the following CLI command: voice port slot/port circuit identifier 'String' ")
vsmPortDsx1LoopbackConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 5, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("vsmPortDsx1NoLoop", 1), ("vsmPortDsx1PayloadLoop", 2), ("vsmPortDsx1LineLoop", 3), ("vsmDSx1Inward", 4), ("vsmPortDsx1OtherLoop", 5))).clone('vsmPortDsx1NoLoop')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmPortDsx1LoopbackConfig.setStatus('mandatory')
if mibBuilder.loadTexts: vsmPortDsx1LoopbackConfig.setDescription("This variable represents the loopback confi- guration of the DS1 interface. Agents support- ing read/write access should return badValue in response to a requested loopback state that the interface does not support. The values mean: vsmPortDsx1NoLoop Not in the loopback state. A device that is not capable of performing a loopback on the interface shall always return this as it's value. vsmPortDsx1PayloadLoop The received signal at this interface is looped through the device. Typically the received signal is looped back for re- transmission after it has passed through the device's framing function. vsmPortDsx1LineLoop The received signal at this interface does not go through the device (minimum pene- tration) but is looped back out. vsmPortDsx1OtherLoop Loopbacks that are not defined here. For more information, please see the following CLI command: voice port slot/port loop back mode none voice port slot/port loop back mode payload voice port slot/port loop back mode line voice port slot/port loop back mode inward ")
vsmPortDsx1LineStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 5, 2, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8191))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmPortDsx1LineStatus.setStatus('deprecated')
if mibBuilder.loadTexts: vsmPortDsx1LineStatus.setDescription("This variable indicates the Line Status of the interface. It contains loopback, failure, re- ceived 'alarm' and transmitted 'alarm' infor- mation. The vsmPortDsx1LineStatus is a bit map represented as a sum, therefore, it can represent multiple failures (alarms) and a LoopbackState simultaneously. vsmPortDsx1NoAlarm should be set if and only if no other flag is set. If the vsmPortDsx1LoopbackState bit is set, the loopback in ef- fect can be determined from the vsmPortDsx1LoopbackConfig object. The various bit positions are: 1 vsmPortDsx1NoAlarm No Alarm Present 2 vsmPortDsx1RcvFarEndLOF Far end LOF (a.k.a., Yellow Alarm) 4 vsmPortDsx1XmtFarEndLOF Near end sending LOF Indication 8 vsmPortDsx1RcvAIS Far end sending AIS 16 vsmPortDsx1XmtAIS Near end sending AIS 32 vsmPortDsx1LossOfFrame Near end LOF (a.k.a., Red Alarm) 64 vsmPortDsx1LossOfSignal Near end Loss Of Signal 128 vsmPortDsx1LoopbackState Near end is looped 256 vsmPortDsx1T16AIS E1 TS16 AIS 512 vsmPortDsx1RcvFarEndLOMF Far End Sending TS16 LOMF 1024 vsmPortDsx1XmtFarEndLOMF Near End Sending TS16 LOMF 2048 vsmPortDsx1RcvTestCode Near End detects a test code 4096 vsmPortDsx1OtherFailure any line status not defined here For more information, please see the following CLI command: {this command is not supported by the CLI} ")
vsmPortDsx1SignalMode = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 5, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("cas", 2), ("ccs", 3), ("messageOriented", 4))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmPortDsx1SignalMode.setStatus('mandatory')
if mibBuilder.loadTexts: vsmPortDsx1SignalMode.setDescription("'none' indicates that no bits are reserved for signaling on this channel. 'robbedBit' indicates that T1 Robbed Bit Sig- naling is in use. 'bitOriented' indicates that E1 Channel Asso- ciated Signaling is in use. 'messageOriented' indicates that Common Chan- nel Signaling is in use either on channel 16 of an E1 link or channel 24 of a T1. For more information, please see the following CLI command: voice port slot/port signaling mode none voice port slot/port signaling mode CAS voice port slot/port signaling mode CCS ")
vsmPortDsx1TransmitClockSource = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 5, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("loopTiming", 1), ("localTiming", 2), ("throughTiming", 3))).clone('loopTiming')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmPortDsx1TransmitClockSource.setStatus('mandatory')
if mibBuilder.loadTexts: vsmPortDsx1TransmitClockSource.setDescription("The source of Tranmit Clock. 'loopTiming' indicates that the recovered re- ceive clock is used as the transmit clock. 'localTiming' indicates that a local clock source is used. 'throughTiming' indicates that recovered re- ceive clock from another interface is used as the transmit clock. For more information, please see the following CLI command: voice port slot/port transmit clock source loop timing voice port slot/port transmit clock source local timing ")
vsmPortDsx1Fdl = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 5, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("vsmPortDsx1Fdl-none", 1), ("vsmPortDsx1Att-54016", 2), ("vsmPortDsx1Ansi-T1-403", 3), ("vsmPortDsx1T1-403-ATT", 4), ("other", 5))).clone('vsmPortDsx1Fdl-none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmPortDsx1Fdl.setStatus('mandatory')
if mibBuilder.loadTexts: vsmPortDsx1Fdl.setDescription("This bitmap describes the use of the facili- ties data link, and is the sum of the capabili- ties: 'other' indicates that a protocol other than one following is used. 'vsmPortDsx1Ansi-T1-403' refers to the FDL exchange recommended by ANSI. 'vsmPortDsx1Att-54016' refers to ESF FDL exchanges. 'vsmPortDsx1Fdl-none' indicates that the device does not use the FDL. For more information, please see the following CLI command: voice port slot/port facilities data link protocol none voice port slot/port facilities data link protocol AT&T 54016 voice port slot/port facilities data link protocol ANSI T1.403 voice port slot/port facilities data link protocol T1.403 AT&T ")
vsmPortDsx1LineBuildOut = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 5, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("shortHaul", 1), ("longHaul", 2))).clone('shortHaul')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmPortDsx1LineBuildOut.setStatus('mandatory')
if mibBuilder.loadTexts: vsmPortDsx1LineBuildOut.setDescription("Indicates line build out of this port. It's worth noting that only T1/E1 port with LIU (Line Interface Unit) equipped can support Long Haul (LH); otherwise, only Short Haul (SH) is supported. For more information, please see the following CLI command: voice port slot/port line build out short voice port slot/port line build out short haul voice port slot/port line build out long voice port slot/port line build out long haul ")
vsmPortDsx1CableType = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 5, 2, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("cable75ohm", 1), ("cable120ohm", 2))).clone('cable120ohm')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmPortDsx1CableType.setStatus('mandatory')
if mibBuilder.loadTexts: vsmPortDsx1CableType.setDescription('The cable type for this port. For more information, please see the following CLI command: voice port slot/port cable type 75 voice port slot/port line build out cable type 75 voice port slot/port cable type 120 voice port slot/port line build out cable type 120 ')
vsmPortDsx1LineLength = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 5, 2, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 200)).clone(30)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmPortDsx1LineLength.setStatus('mandatory')
if mibBuilder.loadTexts: vsmPortDsx1LineLength.setDescription('The length of the ds1 line in meters. This objects provides information for line build out circuitry if it exists and can use this object to adjust the line build out. For more information, please see the following CLI command: voice port slot/port line length (0..200) voice port slot/port line build out line length (0..200) ')
vsmPortDsx1LineStatusChangeTrapEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 5, 2, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmPortDsx1LineStatusChangeTrapEnable.setStatus('mandatory')
if mibBuilder.loadTexts: vsmPortDsx1LineStatusChangeTrapEnable.setDescription('Indicates whether vsmPortDsx1LineStatusChange traps should be generated for this interface. For more information, please see the following CLI command: voice port slot/port trap generation enable voice port slot/port trap generation disable ')
vsmPortDsx1LoopbackStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 5, 2, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmPortDsx1LoopbackStatus.setStatus('deprecated')
if mibBuilder.loadTexts: vsmPortDsx1LoopbackStatus.setDescription('This variable represents the current state of the loopback on the DS1 interface. It contains information about loopbacks established by a manager and remotely from the far end. The vsmPortDsx1LoopbackStatus is a bit map represented as a sum, therefore is can represent multiple loopbacks simultaneously. The various bit positions are: 1 vsmPortDsx1NoLoopback 2 vsmPortDsx1NearEndPayloadLoopback 4 vsmPortDsx1NearEndLineLoopback 8 vsmPortDsx1NearEndOtherLoopback 16 vsmPortDsx1NearEndInwardLoopback 32 vsmPortDsx1FarEndPayloadLoopback 64 vsmPortDsx1FarEndLineLoopback For more information, please see the following CLI command: {This command is not supported by the CLI} ')
vsmPortDsx1PortFdlRole = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 5, 2, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("network", 1), ("user", 2))).clone('network')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmPortDsx1PortFdlRole.setStatus('mandatory')
if mibBuilder.loadTexts: vsmPortDsx1PortFdlRole.setDescription('Indicates Facility Data Link port role of this port. If the port role is network and fdlMode is set to AT&T 54016, then this port periodically sends AT&T performance requests to CI. For more information, please see the following CLI command: voice port slot/port facilities data link port role network voice port slot/port facilities data link port role user ')
vsmPortDsx1PortNfasAlign = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 5, 2, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmPortDsx1PortNfasAlign.setStatus('mandatory')
if mibBuilder.loadTexts: vsmPortDsx1PortNfasAlign.setDescription('This object indicates if framing criterion is based on bit 2 of Time Slot 0 NOT-FAS. This object only applies to E1. For more information, please see the following CLI command: voice port slot/port NFAS framing enable voice port slot/port NFAS framing disable ')
vsmPortDsx1PortAttenuation = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 5, 2, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("att1", 1), ("att2", 2), ("att3", 3), ("att4", 4))).clone('att1')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmPortDsx1PortAttenuation.setStatus('mandatory')
if mibBuilder.loadTexts: vsmPortDsx1PortAttenuation.setDescription('attenuation to set for vsmPortDsx1 port. For more information, please see the following CLI command: voice port slot/port attenuation 0 voice port slot/port line build out attenuation 0 voice port slot/port attenuation -7.5 voice port slot/port line build out attenuation -7.5 voice port slot/port attenuation -15.0 voice port slot/port line build out attenuation -15.0 voice port slot/port attenuation -22.5 voice port slot/port line build out attenuation -22.5 ')
vsmPortIsdnProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 5, 2, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("net", 1), ("user", 2), ("qmaster", 3), ("qslave", 4))).clone('qmaster')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmPortIsdnProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: vsmPortIsdnProtocol.setDescription('Configures the isdn mode on the specified Slot/Port combination. For more information, please see the following CLI command: voice port slot/port isdn protocol net voice port slot/port isdn protocol user voice port slot/port isdn protocol qmaster voice port slot/port isdn protocol qslave ')
vsmPortIsdnSwitchType = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 5, 2, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("net3", 1), ("net5", 2))).clone('net5')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmPortIsdnSwitchType.setStatus('mandatory')
if mibBuilder.loadTexts: vsmPortIsdnSwitchType.setDescription('If the object vsmIsdnProtocol is set to user, then this object specifies the switch the ISDN link is connected to. If the object vsmIsdnProtocol is set to net, then this pbject specifies the switch to be emulated. At present only net5 is supported for this command. For more information, please see the following CLI command: voice port slot/port isdn switch type net5 ')
vsmChanConfTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 26, 5, 3), )
if mibBuilder.loadTexts: vsmChanConfTable.setStatus('mandatory')
if mibBuilder.loadTexts: vsmChanConfTable.setDescription('This table contains VSM local interface configuration parameters, one entry per VSM channel. A physical port may have multiple channels associated with it, depending on port type. ')
vsmChanConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 26, 5, 3, 1), ).setIndexNames((0, "XYLAN-VSM-MIB", "vsmChanSlotIndex"), (0, "XYLAN-VSM-MIB", "vsmChanPortIndex"), (0, "XYLAN-VSM-MIB", "vsmChanIndex"))
if mibBuilder.loadTexts: vsmChanConfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vsmChanConfEntry.setDescription('This list contains VSM channel configuration parameters and state variables. For more information, please see the following CLI command: [Note: There is NO equivalent command in the CLI.] ')
vsmChanSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 5, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmChanSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vsmChanSlotIndex.setDescription('The slot number associated with this row. For more information, please see the following CLI command: [Note: There is NO equivalent command in the CLI.] ')
vsmChanPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 5, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmChanPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vsmChanPortIndex.setDescription('The port number associated with this row. For more information, please see the following CLI command: [Note: There is NO equivalent command in the CLI.] ')
vsmChanIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 5, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmChanIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vsmChanIndex.setDescription('The channel number associated with this row. For more information, please see the following CLI command: [Note: There is NO equivalent command in the CLI.] ')
vsmChanMode = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 5, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("telephony", 1), ("passThrough", 2), ("plar", 3), ("wan", 4))).clone('telephony')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmChanMode.setStatus('mandatory')
if mibBuilder.loadTexts: vsmChanMode.setDescription('This object Indicates in which mode of operation the channel operates. telephony - The channel processing will be handled by the gateway and normal call processing. passThrough - The channel will be direct connected to the corresponding channel on the other port on the same daughter card. No processing will be done by the gateway or call processor. plar - The channel will automatically initiate dialing when it goes off-hook. The number to be dialed is specified in vsmChannelPlarNumber. If no number has been specified, operation will behave as if in telephony mode. wan - The channel will operate in WAN mode. For more information, please see the following CLI command: voice channel slot/port/startChannel-endChannel mode telephony voice channel slot/port/startChannel-endChannel mode plar Note: The following are not supported in this Release. voice channel slot/port/startChannel-endChannel mode pass through ')
vsmChanPlarNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 5, 3, 1, 5), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmChanPlarNumber.setStatus('mandatory')
if mibBuilder.loadTexts: vsmChanPlarNumber.setDescription("The number to be dialed when the channel goes off-hook, if vsmChannelType has been set to 'plar'. For more information, please see the following CLI command: voice channel slot/port/startChannel-endChannel dial in private line automatic ringdown 'plar_phone_number' ")
vsmChanPerferredVoiceProfile = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 5, 3, 1, 6), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmChanPerferredVoiceProfile.setStatus('mandatory')
if mibBuilder.loadTexts: vsmChanPerferredVoiceProfile.setDescription("Sets the preferred coding profile to use for voice calls on the specified channel. For more information, please see the following CLI command: voice channel slot/port/startChannel-endChannel assign preferred voice coding profile 'codingProfName' ")
vsmChanPerferredFaxProfile = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 5, 3, 1, 7), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmChanPerferredFaxProfile.setStatus('mandatory')
if mibBuilder.loadTexts: vsmChanPerferredFaxProfile.setDescription("Sets the preferred coding profile to use for fax calls on the specified channel. For more information, please see the following CLI command: voice channel slot/port/startChannel-endChannel assign preferred fax coding profile 'codingProfName' ")
vsmChanPerferredModemProfile = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 5, 3, 1, 8), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmChanPerferredModemProfile.setStatus('mandatory')
if mibBuilder.loadTexts: vsmChanPerferredModemProfile.setDescription("Sets the preferred coding profile to use for modem calls on the specified channel. For more information, please see the following CLI command: voice channel slot/port/startChannel-endChannel assign preferred modem coding profile 'codingProfName' ")
vsmChanISDNChanType = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 5, 3, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("dchannel", 1), ("bchannel", 2), ("none", 3))).clone('bchannel')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmChanISDNChanType.setStatus('mandatory')
if mibBuilder.loadTexts: vsmChanISDNChanType.setDescription('This object sets the channel specified by the slot/port/channel indices as either a dchannel or bchannel or none if the channel is not yet configured. This object is only valid is the signaling protocol for this channel is set to ISDN. If this object is set to bchannel, then the objects vsmChanDChannelPort and vsmChanDChannel must also be specifeid For more information, please see the following CLI command: voice channel slot/port/channel isdn b channel port/dchannel dsl_id ')
vsmChanDslId = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 5, 3, 1, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmChanDslId.setStatus('deprecated')
if mibBuilder.loadTexts: vsmChanDslId.setDescription('deprecated')
vsmChanDChannelPort = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 5, 3, 1, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmChanDChannelPort.setStatus('deprecated')
if mibBuilder.loadTexts: vsmChanDChannelPort.setDescription('deprecated')
vsmChanDChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 5, 3, 1, 12), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmChanDChannel.setStatus('deprecated')
if mibBuilder.loadTexts: vsmChanDChannel.setDescription('deprecated ')
vsmChanStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 5, 3, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("activate", 1), ("deactivate", 2), ("in-service", 3), ("out-of-service", 4), ("invalid", 5))).clone('out-of-service')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmChanStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vsmChanStatus.setDescription('This object controls the state of the channel configuration when writing to this object. The channel can be put into service by setting this object to activate. The channel can be taken out of service by setting this object to deactivate. The actual status of the channel can be read from this object. The channel is in out-of-service by default. If the channel is activated and all configuration is good, then the channel is in-service. If the channel is activated and something is wrong with the configuration, then the channel state is invalid. For more information, please see the following CLI command: voice channel slot/port/startChannel-endChannel state in service voice channel slot/port/startChannel-endChannel state out of service ')
vsmAllowedCodingProfileTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 26, 5, 4), )
if mibBuilder.loadTexts: vsmAllowedCodingProfileTable.setStatus('mandatory')
if mibBuilder.loadTexts: vsmAllowedCodingProfileTable.setDescription('This table makes available defined coding profiles to channels. ')
vsmAllowedCodingProfileEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 26, 5, 4, 1), ).setIndexNames((0, "XYLAN-VSM-MIB", "vsmChanSlotIndex"), (0, "XYLAN-VSM-MIB", "vsmChanPortIndex"), (0, "XYLAN-VSM-MIB", "vsmChanIndex"), (0, "XYLAN-VSM-MIB", "vsmCodingProfName"))
if mibBuilder.loadTexts: vsmAllowedCodingProfileEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vsmAllowedCodingProfileEntry.setDescription('This list contains VSM channel configuration parameters and state variables. For more information, please see the following CLI command: [Note: There is NO equivalent command in the CLI.] ')
vsmAllowedCodingProfileRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 5, 4, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmAllowedCodingProfileRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vsmAllowedCodingProfileRowStatus.setDescription("This object is the RowStatus (locking flag) for creating the vsmAllowedCodingProfileTable conceptual row. Note: destroy(6) is not supported in this release. For more information, please see the following CLI command: voice channel slot/port/startChannel-endChannel available coding profile 'codingProfName' voice channel slot/port/startChannel-endChannel unavailable coding profile 'codingProfName' ")
vsmConfigDumpFlag = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 26, 6, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmConfigDumpFlag.setStatus('mandatory')
if mibBuilder.loadTexts: vsmConfigDumpFlag.setDescription('Set to 1 makes vsm ascii configuration to dump')
vsmConfigRebootFlag = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 26, 6, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmConfigRebootFlag.setStatus('mandatory')
if mibBuilder.loadTexts: vsmConfigRebootFlag.setDescription('Set to 1 makes switch to reboot')
vsmConfigDumpFileName = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 26, 6, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 12))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmConfigDumpFileName.setStatus('mandatory')
if mibBuilder.loadTexts: vsmConfigDumpFileName.setDescription('Name of vsm ascii configuration dump file')
vsmTeleLevelTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 26, 7, 1), )
if mibBuilder.loadTexts: vsmTeleLevelTable.setStatus('mandatory')
if mibBuilder.loadTexts: vsmTeleLevelTable.setDescription('Telephone channel transmit and receive levels by slot/port/channel. Displays the current and mean transmit and receive levels at the PCM interface of the DSP. Rx means received from the telephony interface; Tx means transmitted to that interface. Current levels are given in 0.1 dBm0 unis. Mean values are given in 0.1 linear PCM units. For more information, please see the following CLI command: voice channel slot/port/channel telephony level stat[istic]s view ')
vsmTeleLevelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 26, 7, 1, 1), ).setIndexNames((0, "XYLAN-VSM-MIB", "vsmChanSlotIndex"), (0, "XYLAN-VSM-MIB", "vsmChanPortIndex"), (0, "XYLAN-VSM-MIB", "vsmChanIndex"))
if mibBuilder.loadTexts: vsmTeleLevelEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vsmTeleLevelEntry.setDescription('Individual Telephone Channel Level Entry. For more information, please see the following CLI command: [Note: There is NO equivalent command in the CLI.] ')
vsmTeleLevelRx = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 7, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmTeleLevelRx.setStatus('mandatory')
if mibBuilder.loadTexts: vsmTeleLevelRx.setDescription('The receive level at the PCM inteface of the DSP. Current Levels are given in 0.1 dBm. ')
vsmTeleLevelTx = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 7, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmTeleLevelTx.setStatus('mandatory')
if mibBuilder.loadTexts: vsmTeleLevelTx.setDescription('The transmit level at the PCM interface of the DSP. Current Levels are given in 0.1 dBm.')
vsmTeleLevelRxMean = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 7, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmTeleLevelRxMean.setStatus('mandatory')
if mibBuilder.loadTexts: vsmTeleLevelRxMean.setDescription('The receive level at the PCM interface givben in 0.1 linear PCM units. Mean values are in 0.1 linear PCM units. For more information, please see the following CLI command: [Note: This object is not supported in this Release] ')
vsmTeleLevelTxMean = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 7, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmTeleLevelTxMean.setStatus('mandatory')
if mibBuilder.loadTexts: vsmTeleLevelTxMean.setDescription('The transmit level at the PCM interface in 0.1 linear PCM units. Mean values are in 0.1 linear PCM units.')
vsmTeleStatsTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 26, 7, 2), )
if mibBuilder.loadTexts: vsmTeleStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: vsmTeleStatsTable.setDescription('Telephone channel statistics by slot/port/channel. For more information, please see the following CLI command: voice channel slot/port/channel telephony channel stat[istic]s view ')
vsmTeleStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 26, 7, 2, 1), ).setIndexNames((0, "XYLAN-VSM-MIB", "vsmChanSlotIndex"), (0, "XYLAN-VSM-MIB", "vsmChanPortIndex"), (0, "XYLAN-VSM-MIB", "vsmChanIndex"))
if mibBuilder.loadTexts: vsmTeleStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vsmTeleStatsEntry.setDescription('Individual Telephone Channel Statistics Entry. For more information, please see the following CLI command: [Note: There is NO equivalent command in the CLI.] ')
vsmNumOffHooks = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 7, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmNumOffHooks.setStatus('mandatory')
if mibBuilder.loadTexts: vsmNumOffHooks.setDescription('The number of times an off-hook indication was detected.')
vsmNumOnHooks = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 7, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmNumOnHooks.setStatus('mandatory')
if mibBuilder.loadTexts: vsmNumOnHooks.setDescription('The number of times an on-hook indication was detected.')
vsmNumSeizures = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 7, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmNumSeizures.setStatus('mandatory')
if mibBuilder.loadTexts: vsmNumSeizures.setDescription('The number of seizures detected on a channel.')
vsmNumToneDigits = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 7, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmNumToneDigits.setStatus('mandatory')
if mibBuilder.loadTexts: vsmNumToneDigits.setDescription('The number of tone digits detected')
vsmNumPulseDigits = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 7, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmNumPulseDigits.setStatus('mandatory')
if mibBuilder.loadTexts: vsmNumPulseDigits.setDescription('The number of good pulse digits detected.')
vsmResetTeleStats = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 7, 2, 1, 6), Integer32()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: vsmResetTeleStats.setStatus('mandatory')
if mibBuilder.loadTexts: vsmResetTeleStats.setDescription('Any write operation on this field will reset the telephony statistics for the specified slot/port/channel')
vsmDspVPStatsTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 26, 7, 3), )
if mibBuilder.loadTexts: vsmDspVPStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: vsmDspVPStatsTable.setDescription('DSP voice playout statistics by slot/port/channel. For more information, please see the following CLI command: voice channel slot/port/channel voice play out stat[istic]s view ')
vsmDspVPStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 26, 7, 3, 1), ).setIndexNames((0, "XYLAN-VSM-MIB", "vsmChanSlotIndex"), (0, "XYLAN-VSM-MIB", "vsmChanPortIndex"), (0, "XYLAN-VSM-MIB", "vsmChanIndex"))
if mibBuilder.loadTexts: vsmDspVPStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vsmDspVPStatsEntry.setDescription('Individual DSP voice playout statistics entry. For more information, please see the following CLI command: [Note: There is NO equivalent command in the CLI.] ')
vsmDspAvgPlayoutDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 7, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmDspAvgPlayoutDelay.setStatus('mandatory')
if mibBuilder.loadTexts: vsmDspAvgPlayoutDelay.setDescription('The average delay of the voice playout FIFOin the DSP, in milliseconds.')
vsmDspLostPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 7, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmDspLostPackets.setStatus('mandatory')
if mibBuilder.loadTexts: vsmDspLostPackets.setDescription('The number of lost packets in teh DSP based on missing sequence number.')
vsmDspReplayPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 7, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmDspReplayPackets.setStatus('mandatory')
if mibBuilder.loadTexts: vsmDspReplayPackets.setDescription('The number of packets replayed by the DSP due to lost packets.')
vsmDspIdlePackets = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 7, 3, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmDspIdlePackets.setStatus('mandatory')
if mibBuilder.loadTexts: vsmDspIdlePackets.setDescription('The number of idle packets being played out by the DSP due to either lost packets or voice playout FIFO buffer underrun.')
vsmDspDroppedPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 7, 3, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmDspDroppedPackets.setStatus('mandatory')
if mibBuilder.loadTexts: vsmDspDroppedPackets.setDescription('The number of voice packets dropped by the DSP due to the voice playout FIFO buffer overrun.')
vsmDspReceivedPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 7, 3, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmDspReceivedPackets.setStatus('mandatory')
if mibBuilder.loadTexts: vsmDspReceivedPackets.setDescription('The number of packets being submitted by packetization unit in the DSP for playout.')
vsmDspRxAvgFrameJitter = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 7, 3, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmDspRxAvgFrameJitter.setStatus('mandatory')
if mibBuilder.loadTexts: vsmDspRxAvgFrameJitter.setDescription('The average recieve jitter on a frame in the DSP in milliseconds.')
vsmResetDspPlayOutStats = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 7, 3, 1, 8), Integer32()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: vsmResetDspPlayOutStats.setStatus('mandatory')
if mibBuilder.loadTexts: vsmResetDspPlayOutStats.setDescription('Any write operation on this field will reset DSP play out statistics for the specified slot/port/channel')
vsmDspRxTxStatsTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 26, 7, 4), )
if mibBuilder.loadTexts: vsmDspRxTxStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: vsmDspRxTxStatsTable.setDescription('DSP receive and transmit statistics by slot/port/channel. For more information, please see the following CLI command: voice channel slot/port/channel dsp stat[istic]s view ')
vsmDspRxTxStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 26, 7, 4, 1), ).setIndexNames((0, "XYLAN-VSM-MIB", "vsmChanSlotIndex"), (0, "XYLAN-VSM-MIB", "vsmChanPortIndex"), (0, "XYLAN-VSM-MIB", "vsmChanIndex"))
if mibBuilder.loadTexts: vsmDspRxTxStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vsmDspRxTxStatsEntry.setDescription('Individual DSP receive and transmit statistics entry. For more information, please see the following CLI command: [Note: There is NO equivalent command in the CLI.] ')
vsmDspRxPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 7, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmDspRxPackets.setStatus('mandatory')
if mibBuilder.loadTexts: vsmDspRxPackets.setDescription('The number of voice packets received that are sent for playout.')
vsmDspTxPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 7, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmDspTxPackets.setStatus('mandatory')
if mibBuilder.loadTexts: vsmDspTxPackets.setDescription('The number of voice packets that are written into the data buffer to be transmitted.')
vsmDspSilencePackets = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 7, 4, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmDspSilencePackets.setStatus('mandatory')
if mibBuilder.loadTexts: vsmDspSilencePackets.setDescription('The number of voice packets on the transmit side that were classified as silence.')
vsmDspRxMinJitter = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 7, 4, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmDspRxMinJitter.setStatus('mandatory')
if mibBuilder.loadTexts: vsmDspRxMinJitter.setDescription('Minimum packet interarrival time specified in milliseconds.')
vsmDspRxMaxJitter = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 7, 4, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmDspRxMaxJitter.setStatus('mandatory')
if mibBuilder.loadTexts: vsmDspRxMaxJitter.setDescription('Maximum packet interarrival time specified in milliseconds.')
vsmDspRxAvgJitter = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 7, 4, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmDspRxAvgJitter.setStatus('mandatory')
if mibBuilder.loadTexts: vsmDspRxAvgJitter.setDescription('RTP average packet interarrival time in timetimestamp units.')
vsmTxDroppedFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 7, 4, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmTxDroppedFrames.setStatus('mandatory')
if mibBuilder.loadTexts: vsmTxDroppedFrames.setDescription('The number of basic frames lost due to resync requests.')
vsmTxOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 7, 4, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmTxOctets.setStatus('mandatory')
if mibBuilder.loadTexts: vsmTxOctets.setDescription('The number of octets transmitted by the DSP.')
vsmRxOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 7, 4, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmRxOctets.setStatus('mandatory')
if mibBuilder.loadTexts: vsmRxOctets.setDescription('The number of octets received by the DSP.')
vsmAal2CodPrfChgs = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 7, 4, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmAal2CodPrfChgs.setStatus('mandatory')
if mibBuilder.loadTexts: vsmAal2CodPrfChgs.setDescription('The number of AAL2 coding profile chnages')
vsmDtmfTxOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 7, 4, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmDtmfTxOctets.setStatus('mandatory')
if mibBuilder.loadTexts: vsmDtmfTxOctets.setDescription('The number of DTMF trasmitted octets')
vsmDtmfRxOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 7, 4, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmDtmfRxOctets.setStatus('mandatory')
if mibBuilder.loadTexts: vsmDtmfRxOctets.setDescription('The number of DTMF received octets')
vsmResetDspRxTxStats = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 7, 4, 1, 13), Integer32()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: vsmResetDspRxTxStats.setStatus('mandatory')
if mibBuilder.loadTexts: vsmResetDspRxTxStats.setDescription('Any write operation on this field will reset DSP Rx Tx statistics for the specified slot/port/channel')
vsmDspVoiceErrorStatsTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 26, 7, 5), )
if mibBuilder.loadTexts: vsmDspVoiceErrorStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: vsmDspVoiceErrorStatsTable.setDescription('DSP voice error statistics by slot/port/channel. For more information, please see the following CLI command: voice channel slot/port/channel error stat[istic]s view ')
vsmDspVoiceErrorStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 26, 7, 5, 1), ).setIndexNames((0, "XYLAN-VSM-MIB", "vsmChanSlotIndex"), (0, "XYLAN-VSM-MIB", "vsmChanPortIndex"), (0, "XYLAN-VSM-MIB", "vsmChanIndex"))
if mibBuilder.loadTexts: vsmDspVoiceErrorStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vsmDspVoiceErrorStatsEntry.setDescription('Individual DSP voice error statistics entry. For more information, please see the following CLI command: [Note: There is NO equivalent command in the CLI.] ')
vsmDspInvalidHeaderCount = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 7, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmDspInvalidHeaderCount.setStatus('mandatory')
if mibBuilder.loadTexts: vsmDspInvalidHeaderCount.setDescription('The number of incomming voice packets dropped by the DSP due to invalid generic voice header syntax.')
vsmDspMicroOverflowCount = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 7, 5, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmDspMicroOverflowCount.setStatus('mandatory')
if mibBuilder.loadTexts: vsmDspMicroOverflowCount.setDescription('The number of voice packets that could not be transmitted by the DSP because the DSP-to-MIC voice data buffer was busy.')
vsmDspLostEnhPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 7, 5, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmDspLostEnhPackets.setStatus('mandatory')
if mibBuilder.loadTexts: vsmDspLostEnhPackets.setDescription('The number of lost incomming enhancement packets detected when two core packets are received without enhancement in between, in the DSP (E-ADPCM only).')
vsmDspMissingCorePackets = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 7, 5, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmDspMissingCorePackets.setStatus('mandatory')
if mibBuilder.loadTexts: vsmDspMissingCorePackets.setDescription('The number of enhancement packets that are dropped since the core packet was not received (E-ADPCM only).')
vsmDspPktsLostByNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 7, 5, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmDspPktsLostByNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: vsmDspPktsLostByNetwork.setDescription('The number of packets lost by the network.')
vsmResetDspErrorStats = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 7, 5, 1, 6), Integer32()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: vsmResetDspErrorStats.setStatus('mandatory')
if mibBuilder.loadTexts: vsmResetDspErrorStats.setDescription('Any write operation on this field will reset DSP error statistics for the specified slot/port/channel')
vsmDspModemStatsTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 26, 7, 6), )
if mibBuilder.loadTexts: vsmDspModemStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: vsmDspModemStatsTable.setDescription('DSP modem statistics by slot/port/channel. For more information, please see the following CLI command: voice channel slot/port/channel modem stat[istic]s view ')
vsmDspModemStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 26, 7, 6, 1), ).setIndexNames((0, "XYLAN-VSM-MIB", "vsmChanSlotIndex"), (0, "XYLAN-VSM-MIB", "vsmChanPortIndex"), (0, "XYLAN-VSM-MIB", "vsmChanIndex"))
if mibBuilder.loadTexts: vsmDspModemStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vsmDspModemStatsEntry.setDescription('Individual DSP modem statistics entry. For more information, please see the following CLI command: [Note: There is NO equivalent command in the CLI.] ')
vsmDspModemStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 7, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmDspModemStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vsmDspModemStatus.setDescription('The DSP modem status. ')
vsmDspModemRxLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 7, 6, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmDspModemRxLevel.setStatus('mandatory')
if mibBuilder.loadTexts: vsmDspModemRxLevel.setDescription('The DSP modem receive level in dB.')
vsmDspModemRxRate = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 7, 6, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmDspModemRxRate.setStatus('mandatory')
if mibBuilder.loadTexts: vsmDspModemRxRate.setDescription('The DSP modem receive rate in bps.')
vsmDspModemTxLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 7, 6, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmDspModemTxLevel.setStatus('mandatory')
if mibBuilder.loadTexts: vsmDspModemTxLevel.setDescription('The DSP modem transmit level in dB.')
vsmDspModemTxRate = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 7, 6, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmDspModemTxRate.setStatus('mandatory')
if mibBuilder.loadTexts: vsmDspModemTxRate.setDescription('The DSP modem transmit rate in bps.')
vsmDspModemCarrFreqOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 7, 6, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmDspModemCarrFreqOffset.setStatus('mandatory')
if mibBuilder.loadTexts: vsmDspModemCarrFreqOffset.setDescription('The DSP modem carrier freq offset (1/10 Hz).')
vsmDspModemTimeFreqOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 7, 6, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmDspModemTimeFreqOffset.setStatus('mandatory')
if mibBuilder.loadTexts: vsmDspModemTimeFreqOffset.setDescription('The DSP modem timing freq offset (1/10000 of clock rate).')
vsmResetDspModemStats = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 7, 6, 1, 8), Integer32()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: vsmResetDspModemStats.setStatus('mandatory')
if mibBuilder.loadTexts: vsmResetDspModemStats.setDescription('Any write operation on this field will reset DSP modem statistics for the specified slot/port/channel')
vsmDspFaxStatsTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 26, 7, 7), )
if mibBuilder.loadTexts: vsmDspFaxStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: vsmDspFaxStatsTable.setDescription('DSP fax statistics for channel by slot/port/channel. For more information, please see the following CLI command: voice channel slot/port/channel fax stat[istic]s view ')
vsmDspFaxStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 26, 7, 7, 1), ).setIndexNames((0, "XYLAN-VSM-MIB", "vsmChanSlotIndex"), (0, "XYLAN-VSM-MIB", "vsmChanPortIndex"), (0, "XYLAN-VSM-MIB", "vsmChanIndex"))
if mibBuilder.loadTexts: vsmDspFaxStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vsmDspFaxStatsEntry.setDescription('Individual DSP fax statistics entry. For more information, please see the following CLI command: [Note: There is NO equivalent command in the CLI.] ')
vsmDspFaxTxPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 7, 7, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmDspFaxTxPackets.setStatus('mandatory')
if mibBuilder.loadTexts: vsmDspFaxTxPackets.setDescription('The number of DSP fax transmitted packets.')
vsmDspFaxRxPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 7, 7, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmDspFaxRxPackets.setStatus('mandatory')
if mibBuilder.loadTexts: vsmDspFaxRxPackets.setDescription('The number of DSP fax received packets.')
vsmDspFaxLostPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 7, 7, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmDspFaxLostPackets.setStatus('mandatory')
if mibBuilder.loadTexts: vsmDspFaxLostPackets.setDescription('The number of DSP fax lost packets.')
vsmDspFaxDroppedPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 7, 7, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmDspFaxDroppedPackets.setStatus('mandatory')
if mibBuilder.loadTexts: vsmDspFaxDroppedPackets.setDescription('The number of DSP fax dropped packets.')
vsmDspFaxRxOutOfSeqPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 7, 7, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmDspFaxRxOutOfSeqPkts.setStatus('mandatory')
if mibBuilder.loadTexts: vsmDspFaxRxOutOfSeqPkts.setDescription('The number of DSP fax received packets out of sequence.')
vsmResetDspFaxStats = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 7, 7, 1, 6), Integer32()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: vsmResetDspFaxStats.setStatus('mandatory')
if mibBuilder.loadTexts: vsmResetDspFaxStats.setDescription('Any write operation on this field will reset DSP fax statistics for the specified slot/port/channel')
vsmISDNTeleStatsTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 26, 7, 9), )
if mibBuilder.loadTexts: vsmISDNTeleStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: vsmISDNTeleStatsTable.setDescription('channel statistics for ISDN channel by slot/port/channel.')
vsmISDNTeleStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 26, 7, 9, 1), ).setIndexNames((0, "XYLAN-VSM-MIB", "vsmChanSlotIndex"), (0, "XYLAN-VSM-MIB", "vsmChanPortIndex"), (0, "XYLAN-VSM-MIB", "vsmChanIndex"))
if mibBuilder.loadTexts: vsmISDNTeleStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vsmISDNTeleStatsEntry.setDescription('Channel statistics for ISDN channel')
vsmNbCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 7, 9, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmNbCalls.setStatus('mandatory')
if mibBuilder.loadTexts: vsmNbCalls.setDescription('Number of calls.')
vsmNbLocalSetup = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 7, 9, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmNbLocalSetup.setStatus('mandatory')
if mibBuilder.loadTexts: vsmNbLocalSetup.setDescription('Number of local setups')
vsmNbRemoteSetup = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 7, 9, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmNbRemoteSetup.setStatus('mandatory')
if mibBuilder.loadTexts: vsmNbRemoteSetup.setDescription('Number of remote setups')
vsmNbDropCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 7, 9, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmNbDropCalls.setStatus('mandatory')
if mibBuilder.loadTexts: vsmNbDropCalls.setDescription('Number of dropped calls')
vsmNbFaxSwitch = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 7, 9, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmNbFaxSwitch.setStatus('mandatory')
if mibBuilder.loadTexts: vsmNbFaxSwitch.setDescription('Number of fax switch')
vsmNbModemSwitch = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 7, 9, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmNbModemSwitch.setStatus('mandatory')
if mibBuilder.loadTexts: vsmNbModemSwitch.setDescription('Number of modem switch')
vsmResetISDNTeleStats = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 26, 7, 9, 1, 7), Integer32()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: vsmResetISDNTeleStats.setStatus('mandatory')
if mibBuilder.loadTexts: vsmResetISDNTeleStats.setDescription('Any write operation on this field will Reset DSP fax statistics for the specified slot/port/channel')
mibBuilder.exportSymbols("XYLAN-VSM-MIB", vsmPortConfTable=vsmPortConfTable, vsmPortIsdnSwitchType=vsmPortIsdnSwitchType, vsmPGNumbersEntry=vsmPGNumbersEntry, vsmCardInterDigitWaitDur=vsmCardInterDigitWaitDur, vsmSigChanOverrideVoiceSetup=vsmSigChanOverrideVoiceSetup, vsmCodingProfSilenceDetectTime=vsmCodingProfSilenceDetectTime, vsmSigChanOverrideQSIGInfoElementTransport=vsmSigChanOverrideQSIGInfoElementTransport, vsmSigChanEmWinkInWinkWaitMin=vsmSigChanEmWinkInWinkWaitMin, vsmNbDropCalls=vsmNbDropCalls, vsmNumPlanHuntMethod=vsmNumPlanHuntMethod, vsmSigChanFxoLSCallerIdDetect=vsmSigChanFxoLSCallerIdDetect, vsmNumToneDigits=vsmNumToneDigits, vsmSigChanEmCommonHangUpWait=vsmSigChanEmCommonHangUpWait, vsmSigTmplEmWinkInWinkWaitMin=vsmSigTmplEmWinkInWinkWaitMin, vsmNumSeizures=vsmNumSeizures, vsmDspModemTimeFreqOffset=vsmDspModemTimeFreqOffset, vsmNumPlanDescription=vsmNumPlanDescription, vsmSigChanOverrideNetworkOverlapDialing=vsmSigChanOverrideNetworkOverlapDialing, vsmCodingProfFaxHsPktRate=vsmCodingProfFaxHsPktRate, vsmDestinationsH323Name=vsmDestinationsH323Name, vsmCardSubunitIndex=vsmCardSubunitIndex, vsmSigChanOverrideInfoElementTransport=vsmSigChanOverrideInfoElementTransport, vsmPGNumbersTable=vsmPGNumbersTable, vsmCodingProfFaxHsRedun=vsmCodingProfFaxHsRedun, vsmSignalingGroup=vsmSignalingGroup, vsmSigChanFxoGSRingingInterCycle=vsmSigChanFxoGSRingingInterCycle, vsmSigChanFxsLSEntry=vsmSigChanFxsLSEntry, vsmSigChanFxoGSTipGroundDebounce=vsmSigChanFxoGSTipGroundDebounce, vsmSigChanFxoLSCPCDetectDur=vsmSigChanFxoLSCPCDetectDur, vsmSigChanEmCommonOffHookDebounce=vsmSigChanEmCommonOffHookDebounce, vsmChanPerferredModemProfile=vsmChanPerferredModemProfile, vsmResetDspRxTxStats=vsmResetDspRxTxStats, vsmVNCardH323InFastStart=vsmVNCardH323InFastStart, vsmDspMissingCorePackets=vsmDspMissingCorePackets, vsmSigChanFxsGSCadenceCoefficient=vsmSigChanFxsGSCadenceCoefficient, vsmSigChanEmCommonClearDetect=vsmSigChanEmCommonClearDetect, vsmPhoneGroupForwardingPrefix=vsmPhoneGroupForwardingPrefix, vsmDspReceivedPackets=vsmDspReceivedPackets, vsmPhoneGroupUsageData=vsmPhoneGroupUsageData, vsmSigChanEmDelayEntry=vsmSigChanEmDelayEntry, vsmVNCardH323GatekeeperAddr=vsmVNCardH323GatekeeperAddr, vsmTeleStatsEntry=vsmTeleStatsEntry, vsmCodingProfVIF=vsmCodingProfVIF, vsmSigChanHangupWaitLimit=vsmSigChanHangupWaitLimit, vsmCodingProfG711ModemResampMode=vsmCodingProfG711ModemResampMode, vsmPortSlotNum=vsmPortSlotNum, vsmPortDsx1PortAttenuation=vsmPortDsx1PortAttenuation, vsmCodingProfNetBufNomDelay=vsmCodingProfNetBufNomDelay, vsmResetTeleStats=vsmResetTeleStats, vsmVNCardRTPPortMode=vsmVNCardRTPPortMode, vsmVNCardH323GateKeeperPhoneGroupRowStatus=vsmVNCardH323GateKeeperPhoneGroupRowStatus, vsmPhoneGroupForwardingPrefixEnable=vsmPhoneGroupForwardingPrefixEnable, vsmSigChanFxsLSGenerateCallerId=vsmSigChanFxsLSGenerateCallerId, vsmCodingProfCodingType=vsmCodingProfCodingType, vsmPhoneGroupUsageVoice=vsmPhoneGroupUsageVoice, vsmSigChanEmWinkInWinkWaitMax=vsmSigChanEmWinkInWinkWaitMax, vsmNbFaxSwitch=vsmNbFaxSwitch, vsmNbLocalSetup=vsmNbLocalSetup, vsmSigChanFxoGSConnectionLoopOpenDebounce=vsmSigChanFxoGSConnectionLoopOpenDebounce, vsmSigChanAnswerWaitLimit=vsmSigChanAnswerWaitLimit, vsmSigTmplEmDelayInDelayDurMin=vsmSigTmplEmDelayInDelayDurMin, vsmDestinationsRowStatus=vsmDestinationsRowStatus, vsmNbCalls=vsmNbCalls, vsmPortDsx1LineStatus=vsmPortDsx1LineStatus, vsmTeleLevelRxMean=vsmTeleLevelRxMean, vsmDspLostEnhPackets=vsmDspLostEnhPackets, vsmSigChanFxsGSMinRingGround=vsmSigChanFxsGSMinRingGround, vsmPortDsx1PortNfasAlign=vsmPortDsx1PortNfasAlign, vsmSigTmplEmImmedEntry=vsmSigTmplEmImmedEntry, vsmPortDsx1CircuitIdentifier=vsmPortDsx1CircuitIdentifier, vsmSigChanEmCommonGuardAll=vsmSigChanEmCommonGuardAll, vsmPortDsx1TransmitClockSource=vsmPortDsx1TransmitClockSource, vsmStatsGroup=vsmStatsGroup, vsmSigChanEchoCancelNonSens=vsmSigChanEchoCancelNonSens, vsmAal2CodPrfChgs=vsmAal2CodPrfChgs, vsmSigTmplEmWinkEntry=vsmSigTmplEmWinkEntry, vsmDspModemCarrFreqOffset=vsmDspModemCarrFreqOffset, vsmSigTmplEmDelayTable=vsmSigTmplEmDelayTable, vsmSigChanFxoGSRingingDebounce=vsmSigChanFxoGSRingingDebounce, vsmDspModemTxLevel=vsmDspModemTxLevel, vsmCardH323AutomaticAnswer=vsmCardH323AutomaticAnswer, vsmSigTmplName=vsmSigTmplName, vsmSignalingChannelEntry=vsmSignalingChannelEntry, vsmSigChanOverrideModemSetup=vsmSigChanOverrideModemSetup, vsmNPPhoneGroupTable=vsmNPPhoneGroupTable, vsmSigChanEmWinkInDigitIgnore=vsmSigChanEmWinkInDigitIgnore, vsmDspModemRxRate=vsmDspModemRxRate, vsmSigTmplIndex=vsmSigTmplIndex, vsmConfigControlGroup=vsmConfigControlGroup, vsmVNTemplateEntry=vsmVNTemplateEntry, vsmSigChanEmCommonOnHookDebounce=vsmSigChanEmCommonOnHookDebounce, vsmSigTmplEmDelayEntry=vsmSigTmplEmDelayEntry, vsmNumPlanTable=vsmNumPlanTable, vsmDspFaxStatsTable=vsmDspFaxStatsTable, vsmSigChanFxsLSCPCWait=vsmSigChanFxsLSCPCWait, vsmPhoneGroupType=vsmPhoneGroupType, vsmSigChanOverridePSUCodecSwitching=vsmSigChanOverridePSUCodecSwitching, vsmVNTmplIndex=vsmVNTmplIndex, vsmDestinationsStartChan=vsmDestinationsStartChan, vsmCodingProfVADThreshLevel=vsmCodingProfVADThreshLevel, vsmSigTmplFxsLSOffHookDebounce=vsmSigTmplFxsLSOffHookDebounce, vsmAllowedCodingProfileTable=vsmAllowedCodingProfileTable, vsmSigChanCallerIdName=vsmSigChanCallerIdName, vsmSigChanFxoGSMaxTipGroundWait=vsmSigChanFxoGSMaxTipGroundWait, vsmNumPlanEntry=vsmNumPlanEntry, vsmSigTmplFxoLSRingingDebounce=vsmSigTmplFxoLSRingingDebounce, vsmPortDialType=vsmPortDialType, vsmChanPerferredVoiceProfile=vsmChanPerferredVoiceProfile, vsmPortNum=vsmPortNum, vsmSigChanFxsGSTable=vsmSigChanFxsGSTable, vsmCardH323InFastStart=vsmCardH323InFastStart, vsmDspAvgPlayoutDelay=vsmDspAvgPlayoutDelay, vsmCodingProfSinFreqToneDet=vsmCodingProfSinFreqToneDet, vsmSigChanEmWinkOutWinkDurMin=vsmSigChanEmWinkOutWinkDurMin, vsmDspFaxRxOutOfSeqPkts=vsmDspFaxRxOutOfSeqPkts, vsmChanConfEntry=vsmChanConfEntry, vsmPortDsx1LineLength=vsmPortDsx1LineLength, vsmSigChanFxsLSCPCDur=vsmSigChanFxsLSCPCDur, vsmPortInterfaceType=vsmPortInterfaceType, vsmPGNumber=vsmPGNumber, vsmSigTmplEmCommonTable=vsmSigTmplEmCommonTable, vsmCodingProfSilenceDetect=vsmCodingProfSilenceDetect, vsmCardSlotIndex=vsmCardSlotIndex, vsmPhoneGroupStripDigitLength=vsmPhoneGroupStripDigitLength, vsmDestinationsType=vsmDestinationsType, vsmSigTmplRowStatus=vsmSigTmplRowStatus, vsmVNCardH323Notification=vsmVNCardH323Notification, vsmCodingProfEntry=vsmCodingProfEntry, vsmSigChanHangupWaitLimitCtrl=vsmSigChanHangupWaitLimitCtrl, vsmChanDslId=vsmChanDslId, vsmDspVPStatsTable=vsmDspVPStatsTable, vsmVNCardH323GatekeeperMaxRetries=vsmVNCardH323GatekeeperMaxRetries, vsmCodingProfId=vsmCodingProfId, vsmDtmfTxOctets=vsmDtmfTxOctets, vsmCodingProfileTable=vsmCodingProfileTable, vsmNPDestinationsRowStatus=vsmNPDestinationsRowStatus, vsmSigTmplFxsLSEntry=vsmSigTmplFxsLSEntry, vsmSigChanCallProgressToneDetControl=vsmSigChanCallProgressToneDetControl, vsmSigChanOutDialType=vsmSigChanOutDialType, vsmSigChanFxoLSTable=vsmSigChanFxoLSTable, vsmVNCardH323EndpointRegType=vsmVNCardH323EndpointRegType, vsmPhoneGroupRowStatus=vsmPhoneGroupRowStatus, vsmSigChanCallLimit=vsmSigChanCallLimit, vsmDialSchemeGroup=vsmDialSchemeGroup, vsmPortDsx1SendCode=vsmPortDsx1SendCode, vsmCardConfEntry=vsmCardConfEntry, vsmVNTemplateTable=vsmVNTemplateTable, vsmCodingProfileGroup=vsmCodingProfileGroup, vsmChanDChannel=vsmChanDChannel, vsmRxOctets=vsmRxOctets, vsmCodingProfSilenceLevel=vsmCodingProfSilenceLevel, vsmPortIsdnProtocol=vsmPortIsdnProtocol, vsmCodingProfFaxTcfMethod=vsmCodingProfFaxTcfMethod, vsmSigTmplEmImmedTable=vsmSigTmplEmImmedTable, vsmChanPortIndex=vsmChanPortIndex, vsmSigChanFxoGSLoopCurrentDebounce=vsmSigChanFxoGSLoopCurrentDebounce, vsmChanSlotIndex=vsmChanSlotIndex, vsmISDNTeleStatsTable=vsmISDNTeleStatsTable, vsmSigChanEmImmedTable=vsmSigChanEmImmedTable, vsmDspRxTxStatsEntry=vsmDspRxTxStatsEntry, vsmVNCardH323AllowCallsWithoutGatekeeper=vsmVNCardH323AllowCallsWithoutGatekeeper, vsmNbModemSwitch=vsmNbModemSwitch, vsmConfigRebootFlag=vsmConfigRebootFlag, vsmSigTmplEmImmedGlareReport=vsmSigTmplEmImmedGlareReport, vsmCodingProfFaxTimeOut=vsmCodingProfFaxTimeOut, vsmCodingProfVEchoCanComfNoiseMode=vsmCodingProfVEchoCanComfNoiseMode, vsmSigChanFxsGSMaxWaitLoop=vsmSigChanFxsGSMaxWaitLoop, RowStatus=RowStatus, vsmDspPktsLostByNetwork=vsmDspPktsLostByNetwork, vsmSigChanEmDelayOutDelayDurMax=vsmSigChanEmDelayOutDelayDurMax, vsmPhoneGroupTable=vsmPhoneGroupTable, vsmChanPlarNumber=vsmChanPlarNumber, vsmResetDspModemStats=vsmResetDspModemStats, vsmSigChanEmWinkInWinkDur=vsmSigChanEmWinkInWinkDur, vsmNumOnHooks=vsmNumOnHooks, vsmSigChanReceiveGain=vsmSigChanReceiveGain, vsmSigChanFxoLSLoopCurrentDebounce=vsmSigChanFxoLSLoopCurrentDebounce, vsmSigChanAcEchoCanFreeSpGain=vsmSigChanAcEchoCanFreeSpGain, vsmSigTmplFxsGSSeizeDetect=vsmSigTmplFxsGSSeizeDetect, vsmSigChanFxsLSAnswClearDetect=vsmSigChanFxsLSAnswClearDetect, vsmSigChanFxoLSRingingInterPulse=vsmSigChanFxoLSRingingInterPulse, vsmCodingProfFaxLsRedun=vsmCodingProfFaxLsRedun, vsmDspRxMinJitter=vsmDspRxMinJitter, vsmSigChanEmDelayOutIntegrityChk=vsmSigChanEmDelayOutIntegrityChk, vsmSigChanEmDelayInDelayDurMax=vsmSigChanEmDelayInDelayDurMax, vsmPhoneGroupSitePrefixString=vsmPhoneGroupSitePrefixString, vsmSigChanOverrideRingBack=vsmSigChanOverrideRingBack, VsmEnableDisabled=VsmEnableDisabled, vsmSigChanFxoLSBattReversalDebounce=vsmSigChanFxoLSBattReversalDebounce, vsmDspModemStatsEntry=vsmDspModemStatsEntry, vsmSigChanFxsGSOnHookDebounce=vsmSigChanFxsGSOnHookDebounce, vsmCodingProfFaxTxLevel=vsmCodingProfFaxTxLevel, vsmCodingProfDtmfRelay=vsmCodingProfDtmfRelay, vsmSigChanTransmitGain=vsmSigChanTransmitGain, vsmCodingProfPktInterval=vsmCodingProfPktInterval, vsmPortConfEntry=vsmPortConfEntry, vsmCodingProfCallerId=vsmCodingProfCallerId, vsmSigChanFxoLSRingingDebounce=vsmSigChanFxoLSRingingDebounce, vsmDestinationsName=vsmDestinationsName, vsmSigChanFxoGSRingingInterPulse=vsmSigChanFxoGSRingingInterPulse, vsmCodingProfVADThreshMode=vsmCodingProfVADThreshMode, vsmDspFaxLostPackets=vsmDspFaxLostPackets, vsmVNTmplH323GateKeeperPhoneGroupEntry=vsmVNTmplH323GateKeeperPhoneGroupEntry, vsmSigChanEmDelayInDelayDurMin=vsmSigChanEmDelayInDelayDurMin, VsmVoiceCodingType=VsmVoiceCodingType, vsmSigChanEmCommonSeizeDetect=vsmSigChanEmCommonSeizeDetect, vsmVNCardH323GatekeeperCtrl=vsmVNCardH323GatekeeperCtrl, vsmSigTmplFxsLSTable=vsmSigTmplFxsLSTable, vsmTeleLevelTable=vsmTeleLevelTable, vsmSigChanFxsGSAnswClearDetect=vsmSigChanFxsGSAnswClearDetect, vsmSigChanEmCommonClearConfDetect=vsmSigChanEmCommonClearConfDetect, vsmCodingProfSwitchover=vsmCodingProfSwitchover, vsmCardIpDefGateway=vsmCardIpDefGateway, vsmSigChanFaxHoldoverDelay=vsmSigChanFaxHoldoverDelay, vsmCardFirstDigitWaitDur=vsmCardFirstDigitWaitDur, vsmPhoneGroupSitePrefixEnable=vsmPhoneGroupSitePrefixEnable, vsmCardIpMask=vsmCardIpMask, vsmSigChanFxsGSOrigClearDetect=vsmSigChanFxsGSOrigClearDetect, vsmDestinationsIpAddr=vsmDestinationsIpAddr, vsmSigChanCallerIdNameStr=vsmSigChanCallerIdNameStr, vsmCodingProfECTailDelay=vsmCodingProfECTailDelay, vsmDspLostPackets=vsmDspLostPackets, vsmSigChanEmCommonMinConnectTime=vsmSigChanEmCommonMinConnectTime, vsmSigChanAssignTmplName=vsmSigChanAssignTmplName, vsmNPPhoneGroupEntry=vsmNPPhoneGroupEntry, vsmCodingProfEchoCanRefreshState=vsmCodingProfEchoCanRefreshState, vsmSigChanOverrideInBandCallProgressTones=vsmSigChanOverrideInBandCallProgressTones, vsmSigChanEmImmedGlareReport=vsmSigChanEmImmedGlareReport, vsmCodingProfNetBufMaxDelay=vsmCodingProfNetBufMaxDelay, vsmSigChanProtocol=vsmSigChanProtocol, vsmSigChanEmCommonEntry=vsmSigChanEmCommonEntry, vsmCardTermDigitStr=vsmCardTermDigitStr, vsmConfigDumpFlag=vsmConfigDumpFlag, vsmAllowedCodingProfileRowStatus=vsmAllowedCodingProfileRowStatus, vsmPhysicalGroup=vsmPhysicalGroup, vsmChanPerferredFaxProfile=vsmChanPerferredFaxProfile, vsmSigTmplFxoLSEntry=vsmSigTmplFxoLSEntry, vsmSigChanOverrideDataSetup=vsmSigChanOverrideDataSetup, vsmSigChanSinFreqToneDetThLev=vsmSigChanSinFreqToneDetThLev, vsmChanDChannelPort=vsmChanDChannelPort, vsmSigChanEmImmedEntry=vsmSigChanEmImmedEntry, vsmSigChanEmWinkOutWinkWaitMax=vsmSigChanEmWinkOutWinkWaitMax, vsmChanMode=vsmChanMode, vsmSigChanAcousticEchoCancellerMode=vsmSigChanAcousticEchoCancellerMode, vsmCardDialTimeDur=vsmCardDialTimeDur, vsmChanStatus=vsmChanStatus, vsmSigChanEmDelayOutDelayDurMin=vsmSigChanEmDelayOutDelayDurMin, vsmDestinationsEndChan=vsmDestinationsEndChan, vsmSigChanToneTable=vsmSigChanToneTable, vsmSigChanFxsLSOrigClearDetect=vsmSigChanFxsLSOrigClearDetect, vsmSigChanAcEchoCanSetSpGain=vsmSigChanAcEchoCanSetSpGain, vsmSignalingChannelTable=vsmSignalingChannelTable, vsmTeleLevelEntry=vsmTeleLevelEntry, vsmDestinationsTable=vsmDestinationsTable)
mibBuilder.exportSymbols("XYLAN-VSM-MIB", vsmSigChanEmCommonTable=vsmSigChanEmCommonTable, vsmSigTmplFxoGSConnectionLoopOpenDebounce=vsmSigTmplFxoGSConnectionLoopOpenDebounce, vsmPhoneGroupName=vsmPhoneGroupName, vsmSigChanFxsLSRingId=vsmSigChanFxsLSRingId, vsmSigChanEmWinkOutWinkDurMax=vsmSigChanEmWinkOutWinkDurMax, vsmSigChanFxoGSBattReversalDebounce=vsmSigChanFxoGSBattReversalDebounce, vsmDspVPStatsEntry=vsmDspVPStatsEntry, vsmSigChanFxsLSCadenceCoefficient=vsmSigChanFxsLSCadenceCoefficient, vsmSigChanAnswerWaitLimitCtrl=vsmSigChanAnswerWaitLimitCtrl, vsmSigChanEmWinkTable=vsmSigChanEmWinkTable, vsmCodingProfEchoCanRefreshCfg=vsmCodingProfEchoCanRefreshCfg, vsmDspFaxRxPackets=vsmDspFaxRxPackets, vsmDestinationsLocalPort=vsmDestinationsLocalPort, vsmSigTmplEmCommonEntry=vsmSigTmplEmCommonEntry, vsmCodingProfEC=vsmCodingProfEC, vsmSigChanAssignTmplStatus=vsmSigChanAssignTmplStatus, vsmDspFaxTxPackets=vsmDspFaxTxPackets, vsmNPDestinationsEntry=vsmNPDestinationsEntry, vsmSigChanFxoLSGuardOut=vsmSigChanFxoLSGuardOut, vsmVNTmplH323GateKeeperPhoneGroupTable=vsmVNTmplH323GateKeeperPhoneGroupTable, vsmVNCardH323DisplayName=vsmVNCardH323DisplayName, vsmSigChanSinFreqToneDetThTime=vsmSigChanSinFreqToneDetThTime, vsmSigTmplFxoGSEntry=vsmSigTmplFxoGSEntry, vsmDspReplayPackets=vsmDspReplayPackets, vsmSigChanFxsLSTable=vsmSigChanFxsLSTable, vsmCardConfigStatus=vsmCardConfigStatus, vsmSigChanFxsLSSeizeDetect=vsmSigChanFxsLSSeizeDetect, vsmCodingProfECNonLinear=vsmCodingProfECNonLinear, vsmSigChanUnused=vsmSigChanUnused, vsmSigChanEmDelayTable=vsmSigChanEmDelayTable, vsmTeleLevelRx=vsmTeleLevelRx, vsmSigChanFxoGSCallerIdDetect=vsmSigChanFxoGSCallerIdDetect, vsmSigChanFxoGSAnswerAfterRings=vsmSigChanFxoGSAnswerAfterRings, vsmVNTmplName=vsmVNTmplName, vsmTxOctets=vsmTxOctets, vsmPortDsx1LineBuildOut=vsmPortDsx1LineBuildOut, vsmResetISDNTeleStats=vsmResetISDNTeleStats, vsmSigChanEmCommonClearConfWaitMax=vsmSigChanEmCommonClearConfWaitMax, vsmPortDsx1SignalMode=vsmPortDsx1SignalMode, vsmPGNumbersRowStatus=vsmPGNumbersRowStatus, vsmDspMicroOverflowCount=vsmDspMicroOverflowCount, vsmSigChanFxsLSOnHookDebounce=vsmSigChanFxsLSOnHookDebounce, vsmSigChanV18ToneDetThLevel=vsmSigChanV18ToneDetThLevel, vsmDspRxMaxJitter=vsmDspRxMaxJitter, vsmCardH323OutFastStart=vsmCardH323OutFastStart, vsmSigChanFxsGSSeizeDetect=vsmSigChanFxsGSSeizeDetect, vsmDspModemRxLevel=vsmDspModemRxLevel, vsmSigChanCallLimitCtrl=vsmSigChanCallLimitCtrl, vsmVNCardH323OutFastStart=vsmVNCardH323OutFastStart, vsmSigChanFxoGSEntry=vsmSigChanFxoGSEntry, vsmSigChanFxoGSTable=vsmSigChanFxoGSTable, vsmCodingProfV18ToneDet=vsmCodingProfV18ToneDet, vsmCodingProfFaxCdThresh=vsmCodingProfFaxCdThresh, vsmDspRxTxStatsTable=vsmDspRxTxStatsTable, vsmSigChanV18ToneDetThHangTime=vsmSigChanV18ToneDetThHangTime, vsmPhoneGroupUsageModem=vsmPhoneGroupUsageModem, vsmChanConfTable=vsmChanConfTable, vsmNPPhoneGroupRowStatus=vsmNPPhoneGroupRowStatus, vsmSigChanCallerIdNumberStr=vsmSigChanCallerIdNumberStr, vsmDspRxPackets=vsmDspRxPackets, vsmPortDsx1CableType=vsmPortDsx1CableType, vsmPortDsx1PortFdlRole=vsmPortDsx1PortFdlRole, vsmSigChanFxsGSGenerateCallerId=vsmSigChanFxsGSGenerateCallerId, vsmConfigDumpFileName=vsmConfigDumpFileName, vsmDspIdlePackets=vsmDspIdlePackets, vsmDestinationsEntry=vsmDestinationsEntry, vsmDspFaxDroppedPackets=vsmDspFaxDroppedPackets, vsmDspVoiceErrorStatsEntry=vsmDspVoiceErrorStatsEntry, vsmPortDsx1LoopbackConfig=vsmPortDsx1LoopbackConfig, vsmSigTmplFxoLSTable=vsmSigTmplFxoLSTable, vsmTeleLevelTxMean=vsmTeleLevelTxMean, vsmPortDsx1LoopbackStatus=vsmPortDsx1LoopbackStatus, vsmNPDestinationsTable=vsmNPDestinationsTable, vsmSigChanFxoLSAnswerAfterRings=vsmSigChanFxoLSAnswerAfterRings, vsmDspModemStatus=vsmDspModemStatus, vsmSigChanOutToneDigitDur=vsmSigChanOutToneDigitDur, vsmPhoneGroupFormat=vsmPhoneGroupFormat, vsmSignalingTemplateTable=vsmSignalingTemplateTable, vsmAllowedCodingProfileEntry=vsmAllowedCodingProfileEntry, vsmCardConfTable=vsmCardConfTable, vsmVNCardTable=vsmVNCardTable, vsmSigChanEmImmedDigitWait=vsmSigChanEmImmedDigitWait, vsmCodingProfVoiceComfortNoiseLevel=vsmCodingProfVoiceComfortNoiseLevel, vsmCodingProfVAD=vsmCodingProfVAD, vsmNumOffHooks=vsmNumOffHooks, vsmDspModemStatsTable=vsmDspModemStatsTable, vsmVNCardH323GateKeeperPhoneGroupEntry=vsmVNCardH323GateKeeperPhoneGroupEntry, vsmNbRemoteSetup=vsmNbRemoteSetup, vsmSigChanFxsGSRingGroundDebounce=vsmSigChanFxsGSRingGroundDebounce, vsmResetDspErrorStats=vsmResetDspErrorStats, vsmSigChanEmWinkEntry=vsmSigChanEmWinkEntry, vsmSigTmplFxsGSTable=vsmSigTmplFxsGSTable, vsmSigChanFxsGSEntry=vsmSigChanFxsGSEntry, vsmSigChanEmDelayOutDelayChk=vsmSigChanEmDelayOutDelayChk, vsmSigChanFxsGSMinLoopOpen=vsmSigChanFxsGSMinLoopOpen, vsmSigChanOutWait=vsmSigChanOutWait, vsmCardIpAddr=vsmCardIpAddr, vsmVNCardH323GateKeeperPhoneGroupTable=vsmVNCardH323GateKeeperPhoneGroupTable, vsmDspModemTxRate=vsmDspModemTxRate, vsmSigChanOutToneInterDigitDur=vsmSigChanOutToneInterDigitDur, vsmDspTxPackets=vsmDspTxPackets, vsmChanIndex=vsmChanIndex, vsmVNCardH323GatekeeperMode=vsmVNCardH323GatekeeperMode, vsmCodingProfName=vsmCodingProfName, vsmPhoneGroupUsageFax=vsmPhoneGroupUsageFax, vsmNumPlanName=vsmNumPlanName, vsmSigChanAcouEchoCanNonProc=vsmSigChanAcouEchoCanNonProc, vsmPortDsx1Fdl=vsmPortDsx1Fdl, vsmSigTmplEmCommonOffHookDebounce=vsmSigTmplEmCommonOffHookDebounce, vsmSigChanOverrideInBandCodecSwitching=vsmSigChanOverrideInBandCodecSwitching, vsmDspSilencePackets=vsmDspSilencePackets, vsmSigChanCallProgressToneDetCfg=vsmSigChanCallProgressToneDetCfg, vsmVNTmplRowStatus=vsmVNTmplRowStatus, vsmCodingProfCallProgToneDet=vsmCodingProfCallProgToneDet, vsmDspRxAvgJitter=vsmDspRxAvgJitter, vsmSigChanAcousticEchoCanOper=vsmSigChanAcousticEchoCanOper, VsmOnOff=VsmOnOff, vsmSigChanFxsLSOffHookDebounce=vsmSigChanFxsLSOffHookDebounce, vsmNumPulseDigits=vsmNumPulseDigits, vsmSigTmplEmWinkTable=vsmSigTmplEmWinkTable, vsmPhoneGroupEntry=vsmPhoneGroupEntry, vsmSigChanEmDelayInDigitIgnore=vsmSigChanEmDelayInDigitIgnore, vsmSigChanCallerIdNumber=vsmSigChanCallerIdNumber, vsmSigChanFxsGSOffHookDebounce=vsmSigChanFxsGSOffHookDebounce, vsmSignalingTemplateEntry=vsmSignalingTemplateEntry, vsmChanISDNChanType=vsmChanISDNChanType, vsmVNTmplH323GateKeeperPhoneGroupRowStatus=vsmVNTmplH323GateKeeperPhoneGroupRowStatus, vsmVNCardRTPPortBase=vsmVNCardRTPPortBase, vsmSigChanOverrideFAXSetup=vsmSigChanOverrideFAXSetup, vsmDspVoiceErrorStatsTable=vsmDspVoiceErrorStatsTable, vsmSigChanFxoLSCPCDetectCtrl=vsmSigChanFxoLSCPCDetectCtrl, vsmSigChanIdleNoise=vsmSigChanIdleNoise, vsmDspFaxStatsEntry=vsmDspFaxStatsEntry, vsmTeleLevelTx=vsmTeleLevelTx, vsmResetDspPlayOutStats=vsmResetDspPlayOutStats, vsmCodingProfFaxRate=vsmCodingProfFaxRate, vsmDtmfRxOctets=vsmDtmfRxOctets, vsmDestinationsNetworkPort=vsmDestinationsNetworkPort, vsmTeleStatsTable=vsmTeleStatsTable, vsmSigChanCompanding=vsmSigChanCompanding, vsmSigChanV18ToneDetThFraction=vsmSigChanV18ToneDetThFraction, vsmNumPlanAllActivate=vsmNumPlanAllActivate, vsmSigChanFxsGSRingId=vsmSigChanFxsGSRingId, vsmNetworkGroup=vsmNetworkGroup, vsmSigChanFxoLSEntry=vsmSigChanFxoLSEntry, vsmISDNTeleStatsEntry=vsmISDNTeleStatsEntry, vsmCodingProfNetBufMode=vsmCodingProfNetBufMode, vsmSigChanEmCommonGuardOut=vsmSigChanEmCommonGuardOut, vsmNumPlanRowStatus=vsmNumPlanRowStatus, vsmPortDsx1LineType=vsmPortDsx1LineType, vsmSigChanOverrideFullCallProgressTones=vsmSigChanOverrideFullCallProgressTones, vsmVNCardEntry=vsmVNCardEntry, vsmResetDspFaxStats=vsmResetDspFaxStats, vsmSigChanFxoLSRingingInterCycle=vsmSigChanFxoLSRingingInterCycle, vsmPortDsx1LineCoding=vsmPortDsx1LineCoding, vsmSigChanEmCommonDialTone=vsmSigChanEmCommonDialTone, vsmTxDroppedFrames=vsmTxDroppedFrames, vsmDspInvalidHeaderCount=vsmDspInvalidHeaderCount, vsmDspDroppedPackets=vsmDspDroppedPackets, vsmSigTmplFxoGSTable=vsmSigTmplFxoGSTable, vsmSigTmplFxsGSEntry=vsmSigTmplFxsGSEntry, vsmPortDsx1LineStatusChangeTrapEnable=vsmPortDsx1LineStatusChangeTrapEnable, vsmCodingProfRowStatus=vsmCodingProfRowStatus, vsmDspRxAvgFrameJitter=vsmDspRxAvgFrameJitter)

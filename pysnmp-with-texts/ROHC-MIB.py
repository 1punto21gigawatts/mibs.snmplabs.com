#
# PySNMP MIB module ROHC-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/ROHC-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:58:09 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsIntersection, ValueRangeConstraint, ConstraintsUnion, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsIntersection", "ValueRangeConstraint", "ConstraintsUnion", "ValueSizeConstraint")
ifIndex, = mibBuilder.importSymbols("IF-MIB", "ifIndex")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
ObjectGroup, ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "ModuleCompliance", "NotificationGroup")
Integer32, NotificationType, iso, IpAddress, ObjectIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, Unsigned32, TimeTicks, MibIdentifier, mib_2, Bits, Counter64, ModuleIdentity, Counter32, Gauge32 = mibBuilder.importSymbols("SNMPv2-SMI", "Integer32", "NotificationType", "iso", "IpAddress", "ObjectIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Unsigned32", "TimeTicks", "MibIdentifier", "mib-2", "Bits", "Counter64", "ModuleIdentity", "Counter32", "Gauge32")
TruthValue, DateAndTime, DisplayString, TimeInterval, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "TruthValue", "DateAndTime", "DisplayString", "TimeInterval", "TextualConvention")
rohcMIB = ModuleIdentity((1, 3, 6, 1, 2, 1, 112))
rohcMIB.setRevisions(('2004-06-03 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: rohcMIB.setRevisionsDescriptions(('Initial version, published as RFC 3816.',))
if mibBuilder.loadTexts: rohcMIB.setLastUpdated('200406030000Z')
if mibBuilder.loadTexts: rohcMIB.setOrganization('IETF Robust Header Compression Working Group')
if mibBuilder.loadTexts: rohcMIB.setContactInfo('WG charter: http://www.ietf.org/html.charters/rohc-charter.html Mailing Lists: General Discussion: rohc@ietf.org To Subscribe: rohc-request@ietf.org In Body: subscribe your_email_address Editor: Juergen Quittek NEC Europe Ltd. Network Laboratories Kurfuersten-Anlage 36 69221 Heidelberg Germany Tel: +49 6221 90511-15 EMail: quittek@netlab.nec.de')
if mibBuilder.loadTexts: rohcMIB.setDescription('This MIB module defines a set of basic objects for monitoring and configuring robust header compression. The module covers information about running instances of ROHC (compressors or decompressors) at IP interfaces. Information about compressor contexts and decompressor contexts has different structure for different profiles. Therefore it is not provided by this MIB module, but by individual modules for different profiles. Copyright (C) The Internet Society (2004). The initial version of this MIB module was published in RFC 3816. For full legal notices see the RFC itself or see: http://www.ietf.org/copyrights/ianamib.html')
class RohcChannelIdentifier(TextualConvention, Unsigned32):
    description = 'A number identifying a channel. The value of 0 must not be used as identifier of an existing channel.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(1, 4294967295)

class RohcChannelIdentifierOrZero(TextualConvention, Unsigned32):
    description = 'A number identifying a channel. The value of 0 is indicates that no channel is identified.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(0, 4294967295)

class RohcCompressionRatio(TextualConvention, Unsigned32):
    description = 'A number indicating a compression ratio over a set of bytes. The value is defined as 1000 * bytes(compressed) / bytes(original) rounded to the next integer value. Note that compressed sets of bytes can be larger than the corresponding uncompressed ones. Therefore, the number can be greater than 1000.'
    status = 'current'
    displayHint = 'd'

rohcObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 112, 1))
rohcConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 112, 2))
rohcInstanceObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 112, 1, 1))
rohcChannelTable = MibTable((1, 3, 6, 1, 2, 1, 112, 1, 1, 1), )
if mibBuilder.loadTexts: rohcChannelTable.setStatus('current')
if mibBuilder.loadTexts: rohcChannelTable.setDescription('This table lists and describes all ROHC channels per interface.')
rohcChannelEntry = MibTableRow((1, 3, 6, 1, 2, 1, 112, 1, 1, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "ROHC-MIB", "rohcChannelID"))
if mibBuilder.loadTexts: rohcChannelEntry.setStatus('current')
if mibBuilder.loadTexts: rohcChannelEntry.setDescription('An entry describing a particular script. Every script that is stored in non-volatile memory is required to appear in this script table. Note, that the rohcChannelID identifies the channel uniquely. The ifIndex is part of the index of this table just in order to allow addressing channels per interface.')
rohcChannelID = MibTableColumn((1, 3, 6, 1, 2, 1, 112, 1, 1, 1, 1, 2), RohcChannelIdentifier())
if mibBuilder.loadTexts: rohcChannelID.setReference('RFC 3095, Section 5.1.1')
if mibBuilder.loadTexts: rohcChannelID.setStatus('current')
if mibBuilder.loadTexts: rohcChannelID.setDescription("The locally arbitrary, but unique identifier associated with this channel. The value is REQUIRED to be unique per ROHC MIB implementation independent of the associated interface. The value is REQUIRED to remain constant at least from one re-initialization of the entity's network management system to the next re-initialization. It is RECOMMENDED that the value persist across such re-initializations.")
rohcChannelType = MibTableColumn((1, 3, 6, 1, 2, 1, 112, 1, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notInUse", 1), ("rohc", 2), ("dedicatedFeedback", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rohcChannelType.setStatus('current')
if mibBuilder.loadTexts: rohcChannelType.setDescription('Type of usage of the channel. A channel might be currently not in use for ROHC or feedback, it might be in use as a ROHC channel carrying packets and optional piggy-backed feedback, or it might be used as a dedicated feedback channel exclusively carrying feedback.')
rohcChannelFeedbackFor = MibTableColumn((1, 3, 6, 1, 2, 1, 112, 1, 1, 1, 1, 4), RohcChannelIdentifierOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rohcChannelFeedbackFor.setReference('RFC 3095, Section 5.1.1')
if mibBuilder.loadTexts: rohcChannelFeedbackFor.setStatus('current')
if mibBuilder.loadTexts: rohcChannelFeedbackFor.setDescription('The index of another channel of this interface for which the channel serves as feedback channel. If no feedback information is transferred on this channel, then the value of this ID is 0. If the channel type is set to notInUse(1), then the value of this object must be 0. If the channel type is rohc(2) and the value of this object is a valid channel ID, then feedback information is piggy-backed on the ROHC channel. If the channel type is dedicatedFeedback(3), then feedback is transferred on this channel and the value of this object MUST be different from 0 and MUST identify an existing ROHC channel.')
rohcChannelDescr = MibTableColumn((1, 3, 6, 1, 2, 1, 112, 1, 1, 1, 1, 5), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rohcChannelDescr.setStatus('current')
if mibBuilder.loadTexts: rohcChannelDescr.setDescription('A textual description of the channel.')
rohcChannelStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 112, 1, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rohcChannelStatus.setStatus('current')
if mibBuilder.loadTexts: rohcChannelStatus.setDescription('Status of the channel.')
rohcInstanceTable = MibTable((1, 3, 6, 1, 2, 1, 112, 1, 1, 2), )
if mibBuilder.loadTexts: rohcInstanceTable.setStatus('current')
if mibBuilder.loadTexts: rohcInstanceTable.setDescription('This table lists properties of running instances of robust header compressors and decompressors at IP interfaces. It is indexed by interface number, the type of instance (compressor or decompressor), and the ID of the channel used by the instance as ROHC channel. Note that the rohcChannelID uniquely identifies an instance. The ifIndex and rohcInstanceType are part of the index, because it simplifies accessing instances per interface and for addressing either compressors or decompressors only.')
rohcInstanceEntry = MibTableRow((1, 3, 6, 1, 2, 1, 112, 1, 1, 2, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "ROHC-MIB", "rohcInstanceType"), (0, "ROHC-MIB", "rohcChannelID"))
if mibBuilder.loadTexts: rohcInstanceEntry.setStatus('current')
if mibBuilder.loadTexts: rohcInstanceEntry.setDescription('An entry describing a particular instance of a robust header compressor or decompressor.')
rohcInstanceType = MibTableColumn((1, 3, 6, 1, 2, 1, 112, 1, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("compressor", 1), ("decompressor", 2))))
if mibBuilder.loadTexts: rohcInstanceType.setStatus('current')
if mibBuilder.loadTexts: rohcInstanceType.setDescription('Type of the instance of ROHC. It is either a compressor instance or a decompressor instance.')
rohcInstanceFBChannelID = MibTableColumn((1, 3, 6, 1, 2, 1, 112, 1, 1, 2, 1, 4), RohcChannelIdentifierOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rohcInstanceFBChannelID.setReference('RFC 3095, Section 5.1.1')
if mibBuilder.loadTexts: rohcInstanceFBChannelID.setStatus('current')
if mibBuilder.loadTexts: rohcInstanceFBChannelID.setDescription('Identifier of the channel used for feedback. If no feedback channel is used, the value of this object is 0 .')
rohcInstanceVendor = MibTableColumn((1, 3, 6, 1, 2, 1, 112, 1, 1, 2, 1, 5), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rohcInstanceVendor.setStatus('current')
if mibBuilder.loadTexts: rohcInstanceVendor.setDescription('An object identifier that identifies the vendor who provides the implementation of robust header description. This object identifier SHALL point to the object identifier directly below the enterprise object identifier {1 3 6 1 4 1} allocated for the vendor. The value must be the object identifier {0 0} if the vendor is not known.')
rohcInstanceVersion = MibTableColumn((1, 3, 6, 1, 2, 1, 112, 1, 1, 2, 1, 6), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rohcInstanceVersion.setStatus('current')
if mibBuilder.loadTexts: rohcInstanceVersion.setDescription('The version number of the implementation of robust header compression. The zero-length string shall be used if the implementation does not have a version number. It is suggested that the version number consist of one or more decimal numbers separated by dots, where the first number is called the major version number.')
rohcInstanceDescr = MibTableColumn((1, 3, 6, 1, 2, 1, 112, 1, 1, 2, 1, 7), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rohcInstanceDescr.setStatus('current')
if mibBuilder.loadTexts: rohcInstanceDescr.setDescription('A textual description of the implementation.')
rohcInstanceClockRes = MibTableColumn((1, 3, 6, 1, 2, 1, 112, 1, 1, 2, 1, 8), Unsigned32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rohcInstanceClockRes.setStatus('current')
if mibBuilder.loadTexts: rohcInstanceClockRes.setDescription('This object indicates the system clock resolution in units of milliseconds. A zero (0) value means that there is no clock available.')
rohcInstanceMaxCID = MibTableColumn((1, 3, 6, 1, 2, 1, 112, 1, 1, 2, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 16383))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rohcInstanceMaxCID.setReference('RFC 3095, Section 5.1.1')
if mibBuilder.loadTexts: rohcInstanceMaxCID.setStatus('current')
if mibBuilder.loadTexts: rohcInstanceMaxCID.setDescription('The highest context ID number to be used by the compressor. Note that this parameter is not coupled to, but in effect further constrained by, rohcChannelLargeCIDs.')
rohcInstanceLargeCIDs = MibTableColumn((1, 3, 6, 1, 2, 1, 112, 1, 1, 2, 1, 10), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rohcInstanceLargeCIDs.setReference('RFC 3095, Section 5.1.1')
if mibBuilder.loadTexts: rohcInstanceLargeCIDs.setStatus('current')
if mibBuilder.loadTexts: rohcInstanceLargeCIDs.setDescription('When retrieved, this boolean object returns false if the short CID representation (0 bytes or 1 prefix byte, covering CID 0 to 15) is used; it returns true, if the embedded CID representation (1 or 2 embedded CID bytes covering CID 0 to 16383) is used.')
rohcInstanceMRRU = MibTableColumn((1, 3, 6, 1, 2, 1, 112, 1, 1, 2, 1, 11), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rohcInstanceMRRU.setReference('RFC 3095, Section 5.1.1')
if mibBuilder.loadTexts: rohcInstanceMRRU.setStatus('current')
if mibBuilder.loadTexts: rohcInstanceMRRU.setDescription('Maximum reconstructed reception unit. This is the size of the largest reconstructed unit in octets that the decompressor is expected to reassemble from segments (see RFC 3095, Section 5.2.5). Note that this size includes the CRC. If MRRU is negotiated to be 0, no segment headers are allowed on the channel.')
rohcInstanceContextStorageTime = MibTableColumn((1, 3, 6, 1, 2, 1, 112, 1, 1, 2, 1, 12), TimeInterval().clone(360000)).setUnits('centi-seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: rohcInstanceContextStorageTime.setStatus('current')
if mibBuilder.loadTexts: rohcInstanceContextStorageTime.setDescription('This object indicates the default maximum amount of time information on a context belonging to this instance is kept as entry in the rohcContextTable after the context is expired or terminated. The value of this object is used to initialize rohcContexStorageTime object when a new context is created. Changing the value of an rohcInstanceContextStorageTime instance does not affect any entry of the rohcContextTable created previously. ROHC-MIB implementations SHOULD store the set value of this object persistently.')
rohcInstanceStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 112, 1, 1, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rohcInstanceStatus.setStatus('current')
if mibBuilder.loadTexts: rohcInstanceStatus.setDescription('Status of the instance of ROHC.')
rohcInstanceContextsTotal = MibTableColumn((1, 3, 6, 1, 2, 1, 112, 1, 1, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rohcInstanceContextsTotal.setStatus('current')
if mibBuilder.loadTexts: rohcInstanceContextsTotal.setDescription('Counter of all contexts created by this instance. Discontinuities in the value of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of ifCounterDiscontinuityTime.')
rohcInstanceContextsCurrent = MibTableColumn((1, 3, 6, 1, 2, 1, 112, 1, 1, 2, 1, 15), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rohcInstanceContextsCurrent.setStatus('current')
if mibBuilder.loadTexts: rohcInstanceContextsCurrent.setDescription('Number of currently active contexts created by this instance.')
rohcInstancePackets = MibTableColumn((1, 3, 6, 1, 2, 1, 112, 1, 1, 2, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rohcInstancePackets.setStatus('current')
if mibBuilder.loadTexts: rohcInstancePackets.setDescription('Counter of all packets passing this instance. Discontinuities in the value of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of ifCounterDiscontinuityTime.')
rohcInstanceIRs = MibTableColumn((1, 3, 6, 1, 2, 1, 112, 1, 1, 2, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rohcInstanceIRs.setReference('RFC 3095, Section 5.7.7.1')
if mibBuilder.loadTexts: rohcInstanceIRs.setStatus('current')
if mibBuilder.loadTexts: rohcInstanceIRs.setDescription('The number of all IR packets that are either sent or received by this instance. Discontinuities in the value of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of ifCounterDiscontinuityTime.')
rohcInstanceIRDYNs = MibTableColumn((1, 3, 6, 1, 2, 1, 112, 1, 1, 2, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rohcInstanceIRDYNs.setReference('RFC 3095, Section 5.7.7.2')
if mibBuilder.loadTexts: rohcInstanceIRDYNs.setStatus('current')
if mibBuilder.loadTexts: rohcInstanceIRDYNs.setDescription('The number of all IR-DYN packets that are either sent or received by this instance. Discontinuities in the value of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of ifCounterDiscontinuityTime.')
rohcInstanceFeedbacks = MibTableColumn((1, 3, 6, 1, 2, 1, 112, 1, 1, 2, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rohcInstanceFeedbacks.setStatus('current')
if mibBuilder.loadTexts: rohcInstanceFeedbacks.setDescription('The number of all feedbacks that are either sent or received by this instance. Discontinuities in the value of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of ifCounterDiscontinuityTime.')
rohcInstanceCompressionRatio = MibTableColumn((1, 3, 6, 1, 2, 1, 112, 1, 1, 2, 1, 20), RohcCompressionRatio()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rohcInstanceCompressionRatio.setStatus('current')
if mibBuilder.loadTexts: rohcInstanceCompressionRatio.setDescription('This object indicates the compression ratio so far over all packets on the channel served by this instance. The compression is computed over all bytes of the IP packets including the IP header but excluding all lower layer headers.')
rohcProfileTable = MibTable((1, 3, 6, 1, 2, 1, 112, 1, 1, 3), )
if mibBuilder.loadTexts: rohcProfileTable.setReference('RFC 3095, Section 5.1.1')
if mibBuilder.loadTexts: rohcProfileTable.setStatus('current')
if mibBuilder.loadTexts: rohcProfileTable.setDescription('This table lists a set of profiles supported by the instance.')
rohcProfileEntry = MibTableRow((1, 3, 6, 1, 2, 1, 112, 1, 1, 3, 1), ).setIndexNames((0, "ROHC-MIB", "rohcChannelID"), (0, "ROHC-MIB", "rohcProfile"))
if mibBuilder.loadTexts: rohcProfileEntry.setStatus('current')
if mibBuilder.loadTexts: rohcProfileEntry.setDescription('An entry describing a particular profile supported by the instance. It is indexed by the rohcChannelID identifying the instance and by the rohcProfile.')
rohcProfile = MibTableColumn((1, 3, 6, 1, 2, 1, 112, 1, 1, 3, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: rohcProfile.setStatus('current')
if mibBuilder.loadTexts: rohcProfile.setDescription("Identifier of a profile supported. For a listing of possible profile values, see the IANA registry for 'RObust Header Compression (ROHC) Profile Identifiers' at http://www.iana.org/assignments/rohc-pro-ids")
rohcProfileVendor = MibTableColumn((1, 3, 6, 1, 2, 1, 112, 1, 1, 3, 1, 3), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rohcProfileVendor.setStatus('current')
if mibBuilder.loadTexts: rohcProfileVendor.setDescription('An object identifier that identifies the vendor who provides the implementation of robust header description. This object identifier SHALL point to the object identifier directly below the enterprise object identifier {1 3 6 1 4 1} allocated for the vendor. The value must be the object identifier {0 0} if the vendor is not known.')
rohcProfileVersion = MibTableColumn((1, 3, 6, 1, 2, 1, 112, 1, 1, 3, 1, 4), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rohcProfileVersion.setStatus('current')
if mibBuilder.loadTexts: rohcProfileVersion.setDescription('The version number of the implementation of robust header compression. The zero-length string shall be used if the implementation does not have a version number. It is suggested that the version number consist of one or more decimal numbers separated by dots, where the first number is called the major version number.')
rohcProfileDescr = MibTableColumn((1, 3, 6, 1, 2, 1, 112, 1, 1, 3, 1, 5), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rohcProfileDescr.setStatus('current')
if mibBuilder.loadTexts: rohcProfileDescr.setDescription('A textual description of the implementation.')
rohcProfileNegotiated = MibTableColumn((1, 3, 6, 1, 2, 1, 112, 1, 1, 3, 1, 6), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rohcProfileNegotiated.setStatus('current')
if mibBuilder.loadTexts: rohcProfileNegotiated.setDescription('When retrieved, this boolean object returns true if the profile has been negotiated to be used at the instance, i.e., is supported also be the corresponding compressor/decompressor.')
rohcContextTable = MibTable((1, 3, 6, 1, 2, 1, 112, 1, 2), )
if mibBuilder.loadTexts: rohcContextTable.setStatus('current')
if mibBuilder.loadTexts: rohcContextTable.setDescription('This table lists and describes all compressor contexts per instance.')
rohcContextEntry = MibTableRow((1, 3, 6, 1, 2, 1, 112, 1, 2, 1), ).setIndexNames((0, "ROHC-MIB", "rohcChannelID"), (0, "ROHC-MIB", "rohcContextCID"))
if mibBuilder.loadTexts: rohcContextEntry.setStatus('current')
if mibBuilder.loadTexts: rohcContextEntry.setDescription('An entry describing a particular compressor context.')
rohcContextCID = MibTableColumn((1, 3, 6, 1, 2, 1, 112, 1, 2, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16383)))
if mibBuilder.loadTexts: rohcContextCID.setReference('RFC 3095, Sections 5.1.1 and 5.1.3')
if mibBuilder.loadTexts: rohcContextCID.setStatus('current')
if mibBuilder.loadTexts: rohcContextCID.setDescription('The context identifier (CID) of this context.')
rohcContextCIDState = MibTableColumn((1, 3, 6, 1, 2, 1, 112, 1, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unused", 1), ("active", 2), ("expired", 3), ("terminated", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rohcContextCIDState.setStatus('current')
if mibBuilder.loadTexts: rohcContextCIDState.setDescription("State of the CID. When a CID is assigned to a context, its state changes from `unused' to `active'. The active context may stop operation due to some explicit signalling or after observing no packet for some specified time. In the first case then the CID state changes to `terminated', in the latter case it changes to `expired'. If the CID is re-used again for another context, the state changes back to `active'.")
rohcContextProfile = MibTableColumn((1, 3, 6, 1, 2, 1, 112, 1, 2, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rohcContextProfile.setStatus('current')
if mibBuilder.loadTexts: rohcContextProfile.setDescription('Identifier of the profile for this context. The profile is identified by its index in the rohcProfileTable for this instance. There MUST exist a corresponding entry in the rohcProfileTable using the value of rohcContextProfile as second part of the index (and using the same rohcChannelID as first part of the index).')
rohcContextDecompressorDepth = MibTableColumn((1, 3, 6, 1, 2, 1, 112, 1, 2, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rohcContextDecompressorDepth.setStatus('current')
if mibBuilder.loadTexts: rohcContextDecompressorDepth.setDescription('This object indicates whether reverse decompression, for example as described in RFC 3095, Section 6.1, is used on this channel or not, and if used, to what extent. Its value is only valid for decompressor contexts, i.e., if rohcInstanceType has the value decompressor(2). For compressor contexts where rohcInstanceType has the value compressor(1), the value of this object is irrelevant and MUST be set to zero (0). The value of the reverse decompression depth indicates the maximum number of packets that are buffered, and thus possibly be reverse decompressed by the decompressor. A zero (0) value means that reverse decompression is not used.')
rohcContextStorageTime = MibTableColumn((1, 3, 6, 1, 2, 1, 112, 1, 2, 1, 6), TimeInterval()).setUnits('centi-seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: rohcContextStorageTime.setStatus('current')
if mibBuilder.loadTexts: rohcContextStorageTime.setDescription('The value of this object specifies how long this row can exist in the rohcContextTable after the rohcContextCIDState switched to expired(3) or terminated(4). This object returns the remaining time that the row may exist before it is aged out. The object is initialized with the value of the associated rohcContextStorageTime object. After expiration or termination of the context, the value of this object ticks backwards. The entry in the rohcContextTable is destroyed when the value reaches 0. The value of this object may be set in order to increase or reduce the remaining time that the row may exist. Setting the value to 0 will destroy this entry as soon as the rochContextCIDState has the value expired(3) or terminated(4). Note that there is no guarantee that the row is stored as long as this object indicates. In case of limited CID space, the instance may re-use a CID before the storage time of the corresponding row in rohcContextTable reaches the value of 0. In this case the information stored in this row is not anymore available.')
rohcContextActivationTime = MibTableColumn((1, 3, 6, 1, 2, 1, 112, 1, 2, 1, 7), DateAndTime().clone(hexValue="0000000000000000")).setMaxAccess("readonly")
if mibBuilder.loadTexts: rohcContextActivationTime.setStatus('current')
if mibBuilder.loadTexts: rohcContextActivationTime.setDescription("The date and time when the context started to be able to compress packets or decompress packets, respectively. The value '0000000000000000'H is returned if the context has not been activated yet.")
rohcContextDeactivationTime = MibTableColumn((1, 3, 6, 1, 2, 1, 112, 1, 2, 1, 8), DateAndTime().clone(hexValue="0000000000000000")).setMaxAccess("readonly")
if mibBuilder.loadTexts: rohcContextDeactivationTime.setStatus('current')
if mibBuilder.loadTexts: rohcContextDeactivationTime.setDescription("The date and time when the context stopped being able to compress packets or decompress packets, respectively, because it expired or was terminated for other reasons. The value '0000000000000000'H is returned if the context has not been deactivated yet.")
rohcContextPackets = MibTableColumn((1, 3, 6, 1, 2, 1, 112, 1, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rohcContextPackets.setStatus('current')
if mibBuilder.loadTexts: rohcContextPackets.setDescription('The number of all packets passing this context. Discontinuities in the value of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of ifCounterDiscontinuityTime. For checking ifCounterDiscontinuityTime, the interface index is required. It can be determined by reading the rohcChannelTable.')
rohcContextIRs = MibTableColumn((1, 3, 6, 1, 2, 1, 112, 1, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rohcContextIRs.setReference('RFC 3095, Section 5.7.7.1')
if mibBuilder.loadTexts: rohcContextIRs.setStatus('current')
if mibBuilder.loadTexts: rohcContextIRs.setDescription('The number of all IR packets sent or received, respectively, by this context. Discontinuities in the value of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of ifCounterDiscontinuityTime. For checking ifCounterDiscontinuityTime, the interface index is required. It can be determined by reading the rohcChannelTable.')
rohcContextIRDYNs = MibTableColumn((1, 3, 6, 1, 2, 1, 112, 1, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rohcContextIRDYNs.setReference('RFC 3095, Section 5.7.7.2')
if mibBuilder.loadTexts: rohcContextIRDYNs.setStatus('current')
if mibBuilder.loadTexts: rohcContextIRDYNs.setDescription('The number of all IR-DYN packets sent or received, respectively, by this context. Discontinuities in the value of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of ifCounterDiscontinuityTime. For checking ifCounterDiscontinuityTime, the interface index is required. It can be determined by reading the rohcChannelTable.')
rohcContextFeedbacks = MibTableColumn((1, 3, 6, 1, 2, 1, 112, 1, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rohcContextFeedbacks.setStatus('current')
if mibBuilder.loadTexts: rohcContextFeedbacks.setDescription('The number of all feedbacks sent or received, respectively, by this context. Discontinuities in the value of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of ifCounterDiscontinuityTime. For checking ifCounterDiscontinuityTime, the interface index is required. It can be determined by reading the rohcChannelTable.')
rohcContextDecompressorFailures = MibTableColumn((1, 3, 6, 1, 2, 1, 112, 1, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rohcContextDecompressorFailures.setStatus('current')
if mibBuilder.loadTexts: rohcContextDecompressorFailures.setDescription('The number of all decompressor failures so far in this context. The number is only valid for decompressor contexts, i.e., if rohcInstanceType has the value decompressor(2). Discontinuities in the value of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of ifCounterDiscontinuityTime. For checking ifCounterDiscontinuityTime, the interface index is required. It can be determined by reading the rohcChannelTable.')
rohcContextDecompressorRepairs = MibTableColumn((1, 3, 6, 1, 2, 1, 112, 1, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rohcContextDecompressorRepairs.setStatus('current')
if mibBuilder.loadTexts: rohcContextDecompressorRepairs.setDescription('The number of all context repairs so far in this context. The number is only valid for decompressor contexts, i.e., if rohcInstanceType has the value decompressor(2). Discontinuities in the value of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of ifCounterDiscontinuityTime. For checking ifCounterDiscontinuityTime, the interface index is required. It can be determined by reading the rohcChannelTable.')
rohcContextAllPacketsRatio = MibTableColumn((1, 3, 6, 1, 2, 1, 112, 1, 2, 1, 15), RohcCompressionRatio()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rohcContextAllPacketsRatio.setStatus('current')
if mibBuilder.loadTexts: rohcContextAllPacketsRatio.setDescription('This object indicates the compression ratio so far over all packets passing this context. The compression is computed over all bytes of the IP packets including the IP header but excluding all lower layer headers.')
rohcContextAllHeadersRatio = MibTableColumn((1, 3, 6, 1, 2, 1, 112, 1, 2, 1, 16), RohcCompressionRatio()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rohcContextAllHeadersRatio.setStatus('current')
if mibBuilder.loadTexts: rohcContextAllHeadersRatio.setDescription('This object indicates the compression ratio so far over all packet headers passing this context. The compression is computed over all bytes of all headers that are subject to compression for the used profile.')
rohcContextAllPacketsMeanSize = MibTableColumn((1, 3, 6, 1, 2, 1, 112, 1, 2, 1, 17), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rohcContextAllPacketsMeanSize.setStatus('current')
if mibBuilder.loadTexts: rohcContextAllPacketsMeanSize.setDescription('This object indicates the mean compressed packet size of all packets passing this context. The packet size includes the IP header and payload but excludes all lower layer headers. The mean value is given in byte rounded to the next integer value.')
rohcContextAllHeadersMeanSize = MibTableColumn((1, 3, 6, 1, 2, 1, 112, 1, 2, 1, 18), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rohcContextAllHeadersMeanSize.setStatus('current')
if mibBuilder.loadTexts: rohcContextAllHeadersMeanSize.setDescription('This object indicates the mean compressed packet header size of all packets passing this context. The packet header size is the sum of the size of all headers of a packet that are subject to compression for the used profile. The mean value is given in byte rounded to the next integer value.')
rohcContextLastPacketsRatio = MibTableColumn((1, 3, 6, 1, 2, 1, 112, 1, 2, 1, 19), RohcCompressionRatio()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rohcContextLastPacketsRatio.setStatus('current')
if mibBuilder.loadTexts: rohcContextLastPacketsRatio.setDescription('This object indicates the compression ratio concerning the last 16 packets passing this context or concerning all packets passing this context if they are less than 16, so far. The compression is computed over all bytes of the IP packets including the IP header but excluding all lower layer headers.')
rohcContextLastHeadersRatio = MibTableColumn((1, 3, 6, 1, 2, 1, 112, 1, 2, 1, 20), RohcCompressionRatio()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rohcContextLastHeadersRatio.setStatus('current')
if mibBuilder.loadTexts: rohcContextLastHeadersRatio.setDescription('This object indicates the compression ratio concerning the headers of the last 16 packets passing this context or concerning the headers of all packets passing this context if they are less than 16, so far. The compression is computed over all bytes of all headers that are subject to compression for the used profile.')
rohcContextLastPacketsMeanSize = MibTableColumn((1, 3, 6, 1, 2, 1, 112, 1, 2, 1, 21), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rohcContextLastPacketsMeanSize.setStatus('current')
if mibBuilder.loadTexts: rohcContextLastPacketsMeanSize.setDescription('This object indicates the mean compressed packet size concerning the last 16 packets passing this context or concerning all packets passing this context if they are less than 16, so far. The packet size includes the IP header and payload but excludes all lower layer headers. The mean value is given in byte rounded to the next integer value.')
rohcContextLastHeadersMeanSize = MibTableColumn((1, 3, 6, 1, 2, 1, 112, 1, 2, 1, 22), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rohcContextLastHeadersMeanSize.setStatus('current')
if mibBuilder.loadTexts: rohcContextLastHeadersMeanSize.setDescription('This object indicates the mean compressed packet header size concerning the last 16 packets passing this context or concerning all packets passing this context if they are less than 16, so far. The packet header size is the sum of the size of all headers of a packet that are subject to compression for the used profile. The mean value is given in byte rounded to the next integer value.')
rohcCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 112, 2, 1))
rohcGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 112, 2, 2))
rohcCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 112, 2, 1, 1)).setObjects(("ROHC-MIB", "rohcInstanceGroup"), ("ROHC-MIB", "rohcContextGroup"), ("ROHC-MIB", "rohcStatisticsGroup"), ("ROHC-MIB", "rohcTimerGroup"), ("ROHC-MIB", "rohcContextStatisticsGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rohcCompliance = rohcCompliance.setStatus('current')
if mibBuilder.loadTexts: rohcCompliance.setDescription('The compliance statement for SNMP entities that implement the ROHC-MIB. Note that compliance with this compliance statement requires compliance with the ifCompliance3 MODULE-COMPLIANCE statement of the IF-MIB (RFC2863).')
rohcInstanceGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 112, 2, 2, 2)).setObjects(("ROHC-MIB", "rohcChannelType"), ("ROHC-MIB", "rohcChannelFeedbackFor"), ("ROHC-MIB", "rohcChannelDescr"), ("ROHC-MIB", "rohcChannelStatus"), ("ROHC-MIB", "rohcInstanceFBChannelID"), ("ROHC-MIB", "rohcInstanceVendor"), ("ROHC-MIB", "rohcInstanceVersion"), ("ROHC-MIB", "rohcInstanceDescr"), ("ROHC-MIB", "rohcInstanceClockRes"), ("ROHC-MIB", "rohcInstanceMaxCID"), ("ROHC-MIB", "rohcInstanceLargeCIDs"), ("ROHC-MIB", "rohcInstanceMRRU"), ("ROHC-MIB", "rohcInstanceStatus"), ("ROHC-MIB", "rohcProfileVendor"), ("ROHC-MIB", "rohcProfileVersion"), ("ROHC-MIB", "rohcProfileDescr"), ("ROHC-MIB", "rohcProfileNegotiated"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rohcInstanceGroup = rohcInstanceGroup.setStatus('current')
if mibBuilder.loadTexts: rohcInstanceGroup.setDescription('A collection of objects providing information about ROHC instances, used channels and available profiles.')
rohcStatisticsGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 112, 2, 2, 4)).setObjects(("ROHC-MIB", "rohcInstanceContextsTotal"), ("ROHC-MIB", "rohcInstanceContextsCurrent"), ("ROHC-MIB", "rohcInstancePackets"), ("ROHC-MIB", "rohcInstanceIRs"), ("ROHC-MIB", "rohcInstanceIRDYNs"), ("ROHC-MIB", "rohcInstanceFeedbacks"), ("ROHC-MIB", "rohcInstanceCompressionRatio"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rohcStatisticsGroup = rohcStatisticsGroup.setStatus('current')
if mibBuilder.loadTexts: rohcStatisticsGroup.setDescription('A collection of objects providing ROHC statistics.')
rohcContextGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 112, 2, 2, 5)).setObjects(("ROHC-MIB", "rohcContextCIDState"), ("ROHC-MIB", "rohcContextProfile"), ("ROHC-MIB", "rohcContextDecompressorDepth"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rohcContextGroup = rohcContextGroup.setStatus('current')
if mibBuilder.loadTexts: rohcContextGroup.setDescription('A collection of objects providing information about ROHC compressor contexts and decompressor contexts.')
rohcTimerGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 112, 2, 2, 6)).setObjects(("ROHC-MIB", "rohcInstanceContextStorageTime"), ("ROHC-MIB", "rohcContextStorageTime"), ("ROHC-MIB", "rohcContextActivationTime"), ("ROHC-MIB", "rohcContextDeactivationTime"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rohcTimerGroup = rohcTimerGroup.setStatus('current')
if mibBuilder.loadTexts: rohcTimerGroup.setDescription('A collection of objects providing statistical information about ROHC compressor contexts and decompressor contexts.')
rohcContextStatisticsGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 112, 2, 2, 7)).setObjects(("ROHC-MIB", "rohcContextPackets"), ("ROHC-MIB", "rohcContextIRs"), ("ROHC-MIB", "rohcContextIRDYNs"), ("ROHC-MIB", "rohcContextFeedbacks"), ("ROHC-MIB", "rohcContextDecompressorFailures"), ("ROHC-MIB", "rohcContextDecompressorRepairs"), ("ROHC-MIB", "rohcContextAllPacketsRatio"), ("ROHC-MIB", "rohcContextAllHeadersRatio"), ("ROHC-MIB", "rohcContextAllPacketsMeanSize"), ("ROHC-MIB", "rohcContextAllHeadersMeanSize"), ("ROHC-MIB", "rohcContextLastPacketsRatio"), ("ROHC-MIB", "rohcContextLastHeadersRatio"), ("ROHC-MIB", "rohcContextLastPacketsMeanSize"), ("ROHC-MIB", "rohcContextLastHeadersMeanSize"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rohcContextStatisticsGroup = rohcContextStatisticsGroup.setStatus('current')
if mibBuilder.loadTexts: rohcContextStatisticsGroup.setDescription('A collection of objects providing statistical information about ROHC compressor contexts and decompressor contexts.')
mibBuilder.exportSymbols("ROHC-MIB", rohcInstanceIRs=rohcInstanceIRs, rohcContextStorageTime=rohcContextStorageTime, rohcChannelType=rohcChannelType, rohcChannelDescr=rohcChannelDescr, rohcMIB=rohcMIB, rohcChannelTable=rohcChannelTable, rohcInstanceFBChannelID=rohcInstanceFBChannelID, rohcInstanceDescr=rohcInstanceDescr, rohcConformance=rohcConformance, rohcInstanceContextStorageTime=rohcInstanceContextStorageTime, rohcGroups=rohcGroups, rohcProfileEntry=rohcProfileEntry, rohcInstanceVendor=rohcInstanceVendor, rohcProfileNegotiated=rohcProfileNegotiated, rohcContextDeactivationTime=rohcContextDeactivationTime, rohcContextIRDYNs=rohcContextIRDYNs, rohcStatisticsGroup=rohcStatisticsGroup, rohcContextDecompressorRepairs=rohcContextDecompressorRepairs, rohcContextLastPacketsMeanSize=rohcContextLastPacketsMeanSize, rohcInstanceContextsTotal=rohcInstanceContextsTotal, rohcInstanceEntry=rohcInstanceEntry, rohcContextProfile=rohcContextProfile, rohcContextLastHeadersRatio=rohcContextLastHeadersRatio, rohcChannelEntry=rohcChannelEntry, rohcContextPackets=rohcContextPackets, rohcObjects=rohcObjects, rohcProfileTable=rohcProfileTable, rohcContextGroup=rohcContextGroup, rohcProfile=rohcProfile, rohcProfileDescr=rohcProfileDescr, rohcContextDecompressorDepth=rohcContextDecompressorDepth, rohcCompliances=rohcCompliances, rohcCompliance=rohcCompliance, rohcContextAllPacketsRatio=rohcContextAllPacketsRatio, rohcContextCID=rohcContextCID, rohcInstanceGroup=rohcInstanceGroup, rohcInstanceContextsCurrent=rohcInstanceContextsCurrent, rohcProfileVendor=rohcProfileVendor, rohcInstanceType=rohcInstanceType, rohcInstancePackets=rohcInstancePackets, rohcChannelStatus=rohcChannelStatus, rohcContextLastHeadersMeanSize=rohcContextLastHeadersMeanSize, RohcChannelIdentifier=RohcChannelIdentifier, rohcInstanceStatus=rohcInstanceStatus, rohcContextCIDState=rohcContextCIDState, rohcInstanceFeedbacks=rohcInstanceFeedbacks, rohcContextAllPacketsMeanSize=rohcContextAllPacketsMeanSize, rohcInstanceLargeCIDs=rohcInstanceLargeCIDs, rohcInstanceTable=rohcInstanceTable, rohcContextEntry=rohcContextEntry, rohcContextAllHeadersMeanSize=rohcContextAllHeadersMeanSize, rohcInstanceVersion=rohcInstanceVersion, rohcContextActivationTime=rohcContextActivationTime, rohcInstanceMaxCID=rohcInstanceMaxCID, rohcTimerGroup=rohcTimerGroup, rohcContextAllHeadersRatio=rohcContextAllHeadersRatio, rohcContextStatisticsGroup=rohcContextStatisticsGroup, rohcInstanceClockRes=rohcInstanceClockRes, rohcContextLastPacketsRatio=rohcContextLastPacketsRatio, rohcContextTable=rohcContextTable, rohcChannelFeedbackFor=rohcChannelFeedbackFor, rohcInstanceCompressionRatio=rohcInstanceCompressionRatio, RohcChannelIdentifierOrZero=RohcChannelIdentifierOrZero, rohcInstanceMRRU=rohcInstanceMRRU, rohcProfileVersion=rohcProfileVersion, RohcCompressionRatio=RohcCompressionRatio, rohcInstanceObjects=rohcInstanceObjects, rohcContextDecompressorFailures=rohcContextDecompressorFailures, rohcContextIRs=rohcContextIRs, rohcInstanceIRDYNs=rohcInstanceIRDYNs, rohcContextFeedbacks=rohcContextFeedbacks, rohcChannelID=rohcChannelID, PYSNMP_MODULE_ID=rohcMIB)

#
# PySNMP MIB module Nortel-MsCarrier-MscPassport-AtmBearerServiceMIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/Nortel-MsCarrier-MscPassport-AtmBearerServiceMIB
# Produced by pysmi-0.3.4 at Wed May  1 14:29:02 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ValueRangeConstraint, ConstraintsIntersection, ValueSizeConstraint, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ValueRangeConstraint", "ConstraintsIntersection", "ValueSizeConstraint", "SingleValueConstraint")
mscAtmIfVpc, mscAtmIfVccIndex, mscAtmIfVcc, mscAtmIfIndex, mscAtmIfVpcIndex, mscAtmIfVptIndex, mscAtmIfVptVccIndex, mscAtmIfVptVcc = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpc", "mscAtmIfVccIndex", "mscAtmIfVcc", "mscAtmIfIndex", "mscAtmIfVpcIndex", "mscAtmIfVptIndex", "mscAtmIfVptVccIndex", "mscAtmIfVptVcc")
StorageType, RowStatus, DisplayString = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-StandardTextualConventionsMIB", "StorageType", "RowStatus", "DisplayString")
NonReplicated, Link = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-TextualConventionsMIB", "NonReplicated", "Link")
mscPassportMIBs, = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-UsefulDefinitionsMIB", "mscPassportMIBs")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Integer32, Counter32, Counter64, Gauge32, MibIdentifier, NotificationType, ObjectIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, ModuleIdentity, Unsigned32, TimeTicks, Bits, iso, IpAddress = mibBuilder.importSymbols("SNMPv2-SMI", "Integer32", "Counter32", "Counter64", "Gauge32", "MibIdentifier", "NotificationType", "ObjectIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ModuleIdentity", "Unsigned32", "TimeTicks", "Bits", "iso", "IpAddress")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
atmBearerServiceMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 64))
mscAtmIfVpcNrp = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 4))
mscAtmIfVpcNrpRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 4, 1), )
if mibBuilder.loadTexts: mscAtmIfVpcNrpRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcNrpRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfVpcNrp components.')
mscAtmIfVpcNrpRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 4, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBearerServiceMIB", "mscAtmIfVpcNrpIndex"))
if mibBuilder.loadTexts: mscAtmIfVpcNrpRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcNrpRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfVpcNrp component.')
mscAtmIfVpcNrpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 4, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcNrpRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcNrpRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfVpcNrp components. These components can be added and deleted.')
mscAtmIfVpcNrpComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcNrpComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcNrpComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfVpcNrpStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcNrpStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcNrpStorageType.setDescription('This variable represents the storage type value for the mscAtmIfVpcNrp tables.')
mscAtmIfVpcNrpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 4, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscAtmIfVpcNrpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcNrpIndex.setDescription('This variable represents the index for the mscAtmIfVpcNrp tables.')
mscAtmIfVpcNrpProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 4, 100), )
if mibBuilder.loadTexts: mscAtmIfVpcNrpProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcNrpProvTable.setDescription('This group contains the provisionable attributes for the Nrp component.')
mscAtmIfVpcNrpProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 4, 100, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBearerServiceMIB", "mscAtmIfVpcNrpIndex"))
if mibBuilder.loadTexts: mscAtmIfVpcNrpProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcNrpProvEntry.setDescription('An entry in the mscAtmIfVpcNrpProvTable.')
mscAtmIfVpcNrpNextHop = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 4, 100, 1, 10), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcNrpNextHop.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcNrpNextHop.setDescription('This attribute specifies the Nrp component with which this Nrp is associated. A sample value is AtmIf/31 Vcc/0.32 Nrp.')
mscAtmIfVpcNrpConnectionPointType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 4, 100, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4))).clone(namedValues=NamedValues(("segmentEndPoint", 1), ("connectingPoint", 2), ("autoConfigure", 4))).clone('autoConfigure')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcNrpConnectionPointType.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcNrpConnectionPointType.setDescription("This attribute specifies the connection point type desired for a Nrp component. The actual connection point type value is visible in the parent component's connectionPointType attribute. The desired connection point type can be specified directly as a segmentEndPoint or connectingPoint. If autoConfigure is specified, the switch will select the connection point type based on the type attribute of the associated AtmIf, choosing segmentEndPoint for a UNI-type ATM interface and connectingPoint for a PPI-type ATM interface. It is obsoleted. The value is mapped into oamSegmentBoundary attribute. segmentEndPoint is mapped into yes. connectingPoint is mapped into no. autoConfigure is mapped into sameAsInterface.")
mscAtmIfVpcNrpOamSegmentBoundary = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 4, 100, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("no", 0), ("yes", 1), ("sameAsInterface", 2))).clone('sameAsInterface')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcNrpOamSegmentBoundary.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcNrpOamSegmentBoundary.setDescription("This attribute specifies the OAM segment boundary desired for a Nrp component. It affects the connection point type value visible in the parent component's connectionPointType attribute. The desired OAM segment boundary can be specified directly as yes, no or sameAsInterface. If sameAsInterface is specified, the OAM segment boundary is same as the oamSegmentBoundary attribute of the associated AtmIf and the switch will set the connectionPointType, choosing segmentEndPoint for a segment- boundary ATM interface and connectingPoint for a non-segment- boundary ATM interface.")
mscAtmIfVpcNrpTxAal5PartialPacketDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 4, 100, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcNrpTxAal5PartialPacketDiscard.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcNrpTxAal5PartialPacketDiscard.setDescription("This attribute is obsolete in P4.2 and has been migrated under Vcd (Vpd) component. This attribute specifies whether the AAL5 Partial Packet Discard (PPD) feature has been enabled or disabled on the Nrp in the transmit direction. This feature allows the NRP to discard the remainder of a cell-forwarded AAL5 frame if a cell of this frame has been discarded due to congestion. This increases the 'goodput' of the link, since cells which are only going to be discarded by the AAL5 reassembly are not transmitted. When this attribute is set to enabled, the PPD feature is applied in the transmit direction. It should only be enabled for connections whose end points are performing AAL5 segmentation and reassembly. When this attribute is set to disabled, the PPD feature is not applied to traffic for this connection in the transmit direction. Note that specifying enabled for a non-AAL5 connection will cause all traffic to be discarded once congestion is encountered.")
mscAtmIfVpcNrpRxAal5PartialPacketDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 4, 100, 1, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("sameAsTx", 2))).clone('sameAsTx')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcNrpRxAal5PartialPacketDiscard.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcNrpRxAal5PartialPacketDiscard.setDescription("This attribute is obsolete in P4.2 and has been migrated under Vcd (Vpd) component. This attribute specifies whether the AAL5 Partial Packet Discard (PPD) feature has been enabled or disabled on the Nrp in the receive direction. This feature allows the NRP to discard the remainder of a cell-forwarded AAL5 frame if a cell of this frame has been discarded due to congestion or usage parameter control (UPC). This increases the 'goodput' of the link, since cells which are only going to be discarded by the AAL5 reassembly are not transmitted. When this attribute is set to enabled, the PPD feature is applied in the receive direction. It should only be enabled for connections whose end points are performing AAL5 segmentation and reassembly. When this attribute is set to disabled, the PPD feature is not applied to traffic for this connection in the receive direction. When this attribute is set to sameAsTx, the PPD feature for traffic in the receive direction will be configured the same way as it is in the transmit direction. Note that specifying enabled for a non-AAL5 connection will cause all traffic to be discarded once congestion is encountered.")
mscAtmIfVpcNrpBandwidthElastic = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 4, 100, 1, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcNrpBandwidthElastic.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcNrpBandwidthElastic.setDescription('This attribute is only of importance for connections which are carried on a link with a variable bandwidth. For example, the bandwidth may be reduced in the event that one or more physical links in the IMA group fail, such that the originally requested bandwidth cannot be maintained. This attribute shows whether the application running on this connection can continue to operate if the bandwidth is reduced. If the bandwidth is reduced, the amount by which it is reduced will be displayed in the bandwidthReduction attribute. A value of yes, indicates that this connection is elastic, and the bandwidth may be reduced but the connection will not be released. Currently, this attribute should only be set to yes for situations where this Nrp is functioning as a loopback on one side of an IMA link. There are no other situations where this setting is valid. A value of no indicates that the bandwidth for this connection will not be reduced in the event of link bandwidth reduction. However, this connection may be released based on its holdingPriority.')
mscAtmIfVpcNrpOverrideHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 4, 100, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 6))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("noOverride", 6))).clone('noOverride')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcNrpOverrideHoldingPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcNrpOverrideHoldingPriority.setDescription('This attribute specifies the holding priority of this connection. Holding priority is used when there is an IMA group where some physical links have failed. Holding priority determines the order in which connections are released. 4 is the lowest holding priority and is released first. 0 is a higher priority and is released last. The value specified in this attribute will override whatever holdingPriority that has been provisioned at the Vcd (or Vpd). If the value is left at the default of noOverride, the holdingPriority provisioned at the Vcd (or Vpd) will be used.')
mscAtmIfVpcMnrp = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 12))
mscAtmIfVpcMnrpRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 12, 1), )
if mibBuilder.loadTexts: mscAtmIfVpcMnrpRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcMnrpRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfVpcMnrp components.')
mscAtmIfVpcMnrpRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 12, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBearerServiceMIB", "mscAtmIfVpcMnrpIndex"))
if mibBuilder.loadTexts: mscAtmIfVpcMnrpRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcMnrpRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfVpcMnrp component.')
mscAtmIfVpcMnrpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 12, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcMnrpRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcMnrpRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfVpcMnrp components. These components can be added and deleted.')
mscAtmIfVpcMnrpComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 12, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcMnrpComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcMnrpComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfVpcMnrpStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 12, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcMnrpStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcMnrpStorageType.setDescription('This variable represents the storage type value for the mscAtmIfVpcMnrp tables.')
mscAtmIfVpcMnrpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 12, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscAtmIfVpcMnrpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcMnrpIndex.setDescription('This variable represents the index for the mscAtmIfVpcMnrp tables.')
mscAtmIfVpcMnrpProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 12, 101), )
if mibBuilder.loadTexts: mscAtmIfVpcMnrpProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcMnrpProvTable.setDescription('This group contains the provisionable attributes for the Mnrp component.')
mscAtmIfVpcMnrpProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 12, 101, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBearerServiceMIB", "mscAtmIfVpcMnrpIndex"))
if mibBuilder.loadTexts: mscAtmIfVpcMnrpProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcMnrpProvEntry.setDescription('An entry in the mscAtmIfVpcMnrpProvTable.')
mscAtmIfVpcMnrpOamSegmentBoundary = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 12, 101, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("no", 0), ("yes", 1), ("sameAsInterface", 2))).clone('sameAsInterface')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcMnrpOamSegmentBoundary.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcMnrpOamSegmentBoundary.setDescription("This attribute specifies the OAM segment boundary desired for a Mnrp component. It affects the connection point type value visible in the parent component's connectionPointType attribute. The desired OAM segment boundary can be specified directly as yes, no or sameAsInterface. If sameAsInterface is specified, the OAM segment boundary is same as the oamSegmentBoundary attribute of the associated AtmIf and the switch will set the connectionPointType, choosing segmentEndPoint for a segment- boundary ATM interface and connectingPoint for a non-segment- boundary ATM interface.")
mscAtmIfVpcMnrpBandwidthElastic = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 12, 101, 1, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcMnrpBandwidthElastic.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcMnrpBandwidthElastic.setDescription('This attribute is only of importance for connections which are carried on a link with a variable bandwidth. For example, the bandwidth may be reduced in the event that one or more physical links in the IMA group fail, such that the originally requested bandwidth cannot be maintained. This attribute shows whether the application running on this connection can continue to operate if the bandwidth is reduced. If the bandwidth is reduced, the amount by which it is reduced will be displayed in the bandwidthReduction attribute. A value of yes, indicates that this connection is elastic, and the bandwidth may be reduced but the connection will not be released. Currently, this attribute should only be set to yes for situations where this Mnrp is functioning as a loopback on one side of an IMA link. There are no other situations where this setting is valid. A value of no indicates that the bandwidth for this connection will not be reduced in the event of link bandwidth reduction. However, this connection may be released based on its holdingPriority.')
mscAtmIfVpcMnrpOverrideHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 12, 101, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 6))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("noOverride", 6))).clone('noOverride')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcMnrpOverrideHoldingPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcMnrpOverrideHoldingPriority.setDescription('This attribute specifies the holding priority of this connection. Holding priority is used when there is an IMA group where some physical links have failed. Holding priority determines the order in which connections are released. 4 is the lowest holding priority and is released first. 0 is a higher priority and is released last. The value specified in this attribute will override whatever holdingPriority that has been provisioned at the Vcd (or Vpd). If the value is left at the default of noOverride, the holdingPriority provisioned at the Vcd (or Vpd) will be used.')
mscAtmIfVpcMnrpNextHopsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 12, 658), )
if mibBuilder.loadTexts: mscAtmIfVpcMnrpNextHopsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcMnrpNextHopsTable.setDescription('This attribute specifies the list of Nrp components with which this Mnrp is associated. A sample value is AtmIf/31 Vcc/0.32 Nrp. This attribute must be provisioned with at least one Nrp component under a compatible connection type.')
mscAtmIfVpcMnrpNextHopsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 12, 658, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBearerServiceMIB", "mscAtmIfVpcMnrpIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBearerServiceMIB", "mscAtmIfVpcMnrpNextHopsValue"))
if mibBuilder.loadTexts: mscAtmIfVpcMnrpNextHopsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcMnrpNextHopsEntry.setDescription('An entry in the mscAtmIfVpcMnrpNextHopsTable.')
mscAtmIfVpcMnrpNextHopsValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 12, 658, 1, 1), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcMnrpNextHopsValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcMnrpNextHopsValue.setDescription('This variable represents both the value and the index for the mscAtmIfVpcMnrpNextHopsTable.')
mscAtmIfVpcMnrpNextHopsRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 12, 658, 1, 2), RowStatus()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mscAtmIfVpcMnrpNextHopsRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcMnrpNextHopsRowStatus.setDescription('This variable is used to control the addition and deletion of individual values of the mscAtmIfVpcMnrpNextHopsTable.')
mscAtmIfVccNrp = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 4))
mscAtmIfVccNrpRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 4, 1), )
if mibBuilder.loadTexts: mscAtmIfVccNrpRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccNrpRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfVccNrp components.')
mscAtmIfVccNrpRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 4, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBearerServiceMIB", "mscAtmIfVccNrpIndex"))
if mibBuilder.loadTexts: mscAtmIfVccNrpRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccNrpRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfVccNrp component.')
mscAtmIfVccNrpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 4, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccNrpRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccNrpRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfVccNrp components. These components can be added and deleted.')
mscAtmIfVccNrpComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccNrpComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccNrpComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfVccNrpStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccNrpStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccNrpStorageType.setDescription('This variable represents the storage type value for the mscAtmIfVccNrp tables.')
mscAtmIfVccNrpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 4, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscAtmIfVccNrpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccNrpIndex.setDescription('This variable represents the index for the mscAtmIfVccNrp tables.')
mscAtmIfVccNrpProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 4, 100), )
if mibBuilder.loadTexts: mscAtmIfVccNrpProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccNrpProvTable.setDescription('This group contains the provisionable attributes for the Nrp component.')
mscAtmIfVccNrpProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 4, 100, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBearerServiceMIB", "mscAtmIfVccNrpIndex"))
if mibBuilder.loadTexts: mscAtmIfVccNrpProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccNrpProvEntry.setDescription('An entry in the mscAtmIfVccNrpProvTable.')
mscAtmIfVccNrpNextHop = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 4, 100, 1, 10), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccNrpNextHop.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccNrpNextHop.setDescription('This attribute specifies the Nrp component with which this Nrp is associated. A sample value is AtmIf/31 Vcc/0.32 Nrp.')
mscAtmIfVccNrpConnectionPointType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 4, 100, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4))).clone(namedValues=NamedValues(("segmentEndPoint", 1), ("connectingPoint", 2), ("autoConfigure", 4))).clone('autoConfigure')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccNrpConnectionPointType.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccNrpConnectionPointType.setDescription("This attribute specifies the connection point type desired for a Nrp component. The actual connection point type value is visible in the parent component's connectionPointType attribute. The desired connection point type can be specified directly as a segmentEndPoint or connectingPoint. If autoConfigure is specified, the switch will select the connection point type based on the type attribute of the associated AtmIf, choosing segmentEndPoint for a UNI-type ATM interface and connectingPoint for a PPI-type ATM interface. It is obsoleted. The value is mapped into oamSegmentBoundary attribute. segmentEndPoint is mapped into yes. connectingPoint is mapped into no. autoConfigure is mapped into sameAsInterface.")
mscAtmIfVccNrpOamSegmentBoundary = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 4, 100, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("no", 0), ("yes", 1), ("sameAsInterface", 2))).clone('sameAsInterface')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccNrpOamSegmentBoundary.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccNrpOamSegmentBoundary.setDescription("This attribute specifies the OAM segment boundary desired for a Nrp component. It affects the connection point type value visible in the parent component's connectionPointType attribute. The desired OAM segment boundary can be specified directly as yes, no or sameAsInterface. If sameAsInterface is specified, the OAM segment boundary is same as the oamSegmentBoundary attribute of the associated AtmIf and the switch will set the connectionPointType, choosing segmentEndPoint for a segment- boundary ATM interface and connectingPoint for a non-segment- boundary ATM interface.")
mscAtmIfVccNrpTxAal5PartialPacketDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 4, 100, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccNrpTxAal5PartialPacketDiscard.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccNrpTxAal5PartialPacketDiscard.setDescription("This attribute is obsolete in P4.2 and has been migrated under Vcd (Vpd) component. This attribute specifies whether the AAL5 Partial Packet Discard (PPD) feature has been enabled or disabled on the Nrp in the transmit direction. This feature allows the NRP to discard the remainder of a cell-forwarded AAL5 frame if a cell of this frame has been discarded due to congestion. This increases the 'goodput' of the link, since cells which are only going to be discarded by the AAL5 reassembly are not transmitted. When this attribute is set to enabled, the PPD feature is applied in the transmit direction. It should only be enabled for connections whose end points are performing AAL5 segmentation and reassembly. When this attribute is set to disabled, the PPD feature is not applied to traffic for this connection in the transmit direction. Note that specifying enabled for a non-AAL5 connection will cause all traffic to be discarded once congestion is encountered.")
mscAtmIfVccNrpRxAal5PartialPacketDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 4, 100, 1, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("sameAsTx", 2))).clone('sameAsTx')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccNrpRxAal5PartialPacketDiscard.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccNrpRxAal5PartialPacketDiscard.setDescription("This attribute is obsolete in P4.2 and has been migrated under Vcd (Vpd) component. This attribute specifies whether the AAL5 Partial Packet Discard (PPD) feature has been enabled or disabled on the Nrp in the receive direction. This feature allows the NRP to discard the remainder of a cell-forwarded AAL5 frame if a cell of this frame has been discarded due to congestion or usage parameter control (UPC). This increases the 'goodput' of the link, since cells which are only going to be discarded by the AAL5 reassembly are not transmitted. When this attribute is set to enabled, the PPD feature is applied in the receive direction. It should only be enabled for connections whose end points are performing AAL5 segmentation and reassembly. When this attribute is set to disabled, the PPD feature is not applied to traffic for this connection in the receive direction. When this attribute is set to sameAsTx, the PPD feature for traffic in the receive direction will be configured the same way as it is in the transmit direction. Note that specifying enabled for a non-AAL5 connection will cause all traffic to be discarded once congestion is encountered.")
mscAtmIfVccNrpBandwidthElastic = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 4, 100, 1, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccNrpBandwidthElastic.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccNrpBandwidthElastic.setDescription('This attribute is only of importance for connections which are carried on a link with a variable bandwidth. For example, the bandwidth may be reduced in the event that one or more physical links in the IMA group fail, such that the originally requested bandwidth cannot be maintained. This attribute shows whether the application running on this connection can continue to operate if the bandwidth is reduced. If the bandwidth is reduced, the amount by which it is reduced will be displayed in the bandwidthReduction attribute. A value of yes, indicates that this connection is elastic, and the bandwidth may be reduced but the connection will not be released. Currently, this attribute should only be set to yes for situations where this Nrp is functioning as a loopback on one side of an IMA link. There are no other situations where this setting is valid. A value of no indicates that the bandwidth for this connection will not be reduced in the event of link bandwidth reduction. However, this connection may be released based on its holdingPriority.')
mscAtmIfVccNrpOverrideHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 4, 100, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 6))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("noOverride", 6))).clone('noOverride')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccNrpOverrideHoldingPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccNrpOverrideHoldingPriority.setDescription('This attribute specifies the holding priority of this connection. Holding priority is used when there is an IMA group where some physical links have failed. Holding priority determines the order in which connections are released. 4 is the lowest holding priority and is released first. 0 is a higher priority and is released last. The value specified in this attribute will override whatever holdingPriority that has been provisioned at the Vcd (or Vpd). If the value is left at the default of noOverride, the holdingPriority provisioned at the Vcd (or Vpd) will be used.')
mscAtmIfVccMnrp = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 13))
mscAtmIfVccMnrpRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 13, 1), )
if mibBuilder.loadTexts: mscAtmIfVccMnrpRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccMnrpRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfVccMnrp components.')
mscAtmIfVccMnrpRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 13, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBearerServiceMIB", "mscAtmIfVccMnrpIndex"))
if mibBuilder.loadTexts: mscAtmIfVccMnrpRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccMnrpRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfVccMnrp component.')
mscAtmIfVccMnrpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 13, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccMnrpRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccMnrpRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfVccMnrp components. These components can be added and deleted.')
mscAtmIfVccMnrpComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 13, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccMnrpComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccMnrpComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfVccMnrpStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 13, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccMnrpStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccMnrpStorageType.setDescription('This variable represents the storage type value for the mscAtmIfVccMnrp tables.')
mscAtmIfVccMnrpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 13, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscAtmIfVccMnrpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccMnrpIndex.setDescription('This variable represents the index for the mscAtmIfVccMnrp tables.')
mscAtmIfVccMnrpProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 13, 101), )
if mibBuilder.loadTexts: mscAtmIfVccMnrpProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccMnrpProvTable.setDescription('This group contains the provisionable attributes for the Mnrp component.')
mscAtmIfVccMnrpProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 13, 101, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBearerServiceMIB", "mscAtmIfVccMnrpIndex"))
if mibBuilder.loadTexts: mscAtmIfVccMnrpProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccMnrpProvEntry.setDescription('An entry in the mscAtmIfVccMnrpProvTable.')
mscAtmIfVccMnrpOamSegmentBoundary = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 13, 101, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("no", 0), ("yes", 1), ("sameAsInterface", 2))).clone('sameAsInterface')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccMnrpOamSegmentBoundary.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccMnrpOamSegmentBoundary.setDescription("This attribute specifies the OAM segment boundary desired for a Mnrp component. It affects the connection point type value visible in the parent component's connectionPointType attribute. The desired OAM segment boundary can be specified directly as yes, no or sameAsInterface. If sameAsInterface is specified, the OAM segment boundary is same as the oamSegmentBoundary attribute of the associated AtmIf and the switch will set the connectionPointType, choosing segmentEndPoint for a segment- boundary ATM interface and connectingPoint for a non-segment- boundary ATM interface.")
mscAtmIfVccMnrpBandwidthElastic = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 13, 101, 1, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccMnrpBandwidthElastic.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccMnrpBandwidthElastic.setDescription('This attribute is only of importance for connections which are carried on a link with a variable bandwidth. For example, the bandwidth may be reduced in the event that one or more physical links in the IMA group fail, such that the originally requested bandwidth cannot be maintained. This attribute shows whether the application running on this connection can continue to operate if the bandwidth is reduced. If the bandwidth is reduced, the amount by which it is reduced will be displayed in the bandwidthReduction attribute. A value of yes, indicates that this connection is elastic, and the bandwidth may be reduced but the connection will not be released. Currently, this attribute should only be set to yes for situations where this Mnrp is functioning as a loopback on one side of an IMA link. There are no other situations where this setting is valid. A value of no indicates that the bandwidth for this connection will not be reduced in the event of link bandwidth reduction. However, this connection may be released based on its holdingPriority.')
mscAtmIfVccMnrpOverrideHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 13, 101, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 6))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("noOverride", 6))).clone('noOverride')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccMnrpOverrideHoldingPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccMnrpOverrideHoldingPriority.setDescription('This attribute specifies the holding priority of this connection. Holding priority is used when there is an IMA group where some physical links have failed. Holding priority determines the order in which connections are released. 4 is the lowest holding priority and is released first. 0 is a higher priority and is released last. The value specified in this attribute will override whatever holdingPriority that has been provisioned at the Vcd (or Vpd). If the value is left at the default of noOverride, the holdingPriority provisioned at the Vcd (or Vpd) will be used.')
mscAtmIfVccMnrpNextHopsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 13, 658), )
if mibBuilder.loadTexts: mscAtmIfVccMnrpNextHopsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccMnrpNextHopsTable.setDescription('This attribute specifies the list of Nrp components with which this Mnrp is associated. A sample value is AtmIf/31 Vcc/0.32 Nrp. This attribute must be provisioned with at least one Nrp component under a compatible connection type.')
mscAtmIfVccMnrpNextHopsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 13, 658, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBearerServiceMIB", "mscAtmIfVccMnrpIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBearerServiceMIB", "mscAtmIfVccMnrpNextHopsValue"))
if mibBuilder.loadTexts: mscAtmIfVccMnrpNextHopsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccMnrpNextHopsEntry.setDescription('An entry in the mscAtmIfVccMnrpNextHopsTable.')
mscAtmIfVccMnrpNextHopsValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 13, 658, 1, 1), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccMnrpNextHopsValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccMnrpNextHopsValue.setDescription('This variable represents both the value and the index for the mscAtmIfVccMnrpNextHopsTable.')
mscAtmIfVccMnrpNextHopsRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 13, 658, 1, 2), RowStatus()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mscAtmIfVccMnrpNextHopsRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccMnrpNextHopsRowStatus.setDescription('This variable is used to control the addition and deletion of individual values of the mscAtmIfVccMnrpNextHopsTable.')
mscAtmIfVptVccNrp = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 4))
mscAtmIfVptVccNrpRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 4, 1), )
if mibBuilder.loadTexts: mscAtmIfVptVccNrpRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccNrpRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfVptVccNrp components.')
mscAtmIfVptVccNrpRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 4, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBearerServiceMIB", "mscAtmIfVptVccNrpIndex"))
if mibBuilder.loadTexts: mscAtmIfVptVccNrpRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccNrpRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfVptVccNrp component.')
mscAtmIfVptVccNrpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 4, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccNrpRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccNrpRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfVptVccNrp components. These components can be added and deleted.')
mscAtmIfVptVccNrpComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccNrpComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccNrpComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfVptVccNrpStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccNrpStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccNrpStorageType.setDescription('This variable represents the storage type value for the mscAtmIfVptVccNrp tables.')
mscAtmIfVptVccNrpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 4, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscAtmIfVptVccNrpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccNrpIndex.setDescription('This variable represents the index for the mscAtmIfVptVccNrp tables.')
mscAtmIfVptVccNrpProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 4, 100), )
if mibBuilder.loadTexts: mscAtmIfVptVccNrpProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccNrpProvTable.setDescription('This group contains the provisionable attributes for the Nrp component.')
mscAtmIfVptVccNrpProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 4, 100, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBearerServiceMIB", "mscAtmIfVptVccNrpIndex"))
if mibBuilder.loadTexts: mscAtmIfVptVccNrpProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccNrpProvEntry.setDescription('An entry in the mscAtmIfVptVccNrpProvTable.')
mscAtmIfVptVccNrpNextHop = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 4, 100, 1, 10), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccNrpNextHop.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccNrpNextHop.setDescription('This attribute specifies the Nrp component with which this Nrp is associated. A sample value is AtmIf/31 Vcc/0.32 Nrp.')
mscAtmIfVptVccNrpConnectionPointType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 4, 100, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4))).clone(namedValues=NamedValues(("segmentEndPoint", 1), ("connectingPoint", 2), ("autoConfigure", 4))).clone('autoConfigure')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccNrpConnectionPointType.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccNrpConnectionPointType.setDescription("This attribute specifies the connection point type desired for a Nrp component. The actual connection point type value is visible in the parent component's connectionPointType attribute. The desired connection point type can be specified directly as a segmentEndPoint or connectingPoint. If autoConfigure is specified, the switch will select the connection point type based on the type attribute of the associated AtmIf, choosing segmentEndPoint for a UNI-type ATM interface and connectingPoint for a PPI-type ATM interface. It is obsoleted. The value is mapped into oamSegmentBoundary attribute. segmentEndPoint is mapped into yes. connectingPoint is mapped into no. autoConfigure is mapped into sameAsInterface.")
mscAtmIfVptVccNrpOamSegmentBoundary = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 4, 100, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("no", 0), ("yes", 1), ("sameAsInterface", 2))).clone('sameAsInterface')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccNrpOamSegmentBoundary.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccNrpOamSegmentBoundary.setDescription("This attribute specifies the OAM segment boundary desired for a Nrp component. It affects the connection point type value visible in the parent component's connectionPointType attribute. The desired OAM segment boundary can be specified directly as yes, no or sameAsInterface. If sameAsInterface is specified, the OAM segment boundary is same as the oamSegmentBoundary attribute of the associated AtmIf and the switch will set the connectionPointType, choosing segmentEndPoint for a segment- boundary ATM interface and connectingPoint for a non-segment- boundary ATM interface.")
mscAtmIfVptVccNrpTxAal5PartialPacketDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 4, 100, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccNrpTxAal5PartialPacketDiscard.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccNrpTxAal5PartialPacketDiscard.setDescription("This attribute is obsolete in P4.2 and has been migrated under Vcd (Vpd) component. This attribute specifies whether the AAL5 Partial Packet Discard (PPD) feature has been enabled or disabled on the Nrp in the transmit direction. This feature allows the NRP to discard the remainder of a cell-forwarded AAL5 frame if a cell of this frame has been discarded due to congestion. This increases the 'goodput' of the link, since cells which are only going to be discarded by the AAL5 reassembly are not transmitted. When this attribute is set to enabled, the PPD feature is applied in the transmit direction. It should only be enabled for connections whose end points are performing AAL5 segmentation and reassembly. When this attribute is set to disabled, the PPD feature is not applied to traffic for this connection in the transmit direction. Note that specifying enabled for a non-AAL5 connection will cause all traffic to be discarded once congestion is encountered.")
mscAtmIfVptVccNrpRxAal5PartialPacketDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 4, 100, 1, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("sameAsTx", 2))).clone('sameAsTx')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccNrpRxAal5PartialPacketDiscard.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccNrpRxAal5PartialPacketDiscard.setDescription("This attribute is obsolete in P4.2 and has been migrated under Vcd (Vpd) component. This attribute specifies whether the AAL5 Partial Packet Discard (PPD) feature has been enabled or disabled on the Nrp in the receive direction. This feature allows the NRP to discard the remainder of a cell-forwarded AAL5 frame if a cell of this frame has been discarded due to congestion or usage parameter control (UPC). This increases the 'goodput' of the link, since cells which are only going to be discarded by the AAL5 reassembly are not transmitted. When this attribute is set to enabled, the PPD feature is applied in the receive direction. It should only be enabled for connections whose end points are performing AAL5 segmentation and reassembly. When this attribute is set to disabled, the PPD feature is not applied to traffic for this connection in the receive direction. When this attribute is set to sameAsTx, the PPD feature for traffic in the receive direction will be configured the same way as it is in the transmit direction. Note that specifying enabled for a non-AAL5 connection will cause all traffic to be discarded once congestion is encountered.")
mscAtmIfVptVccNrpBandwidthElastic = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 4, 100, 1, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccNrpBandwidthElastic.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccNrpBandwidthElastic.setDescription('This attribute is only of importance for connections which are carried on a link with a variable bandwidth. For example, the bandwidth may be reduced in the event that one or more physical links in the IMA group fail, such that the originally requested bandwidth cannot be maintained. This attribute shows whether the application running on this connection can continue to operate if the bandwidth is reduced. If the bandwidth is reduced, the amount by which it is reduced will be displayed in the bandwidthReduction attribute. A value of yes, indicates that this connection is elastic, and the bandwidth may be reduced but the connection will not be released. Currently, this attribute should only be set to yes for situations where this Nrp is functioning as a loopback on one side of an IMA link. There are no other situations where this setting is valid. A value of no indicates that the bandwidth for this connection will not be reduced in the event of link bandwidth reduction. However, this connection may be released based on its holdingPriority.')
mscAtmIfVptVccNrpOverrideHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 4, 100, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 6))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("noOverride", 6))).clone('noOverride')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccNrpOverrideHoldingPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccNrpOverrideHoldingPriority.setDescription('This attribute specifies the holding priority of this connection. Holding priority is used when there is an IMA group where some physical links have failed. Holding priority determines the order in which connections are released. 4 is the lowest holding priority and is released first. 0 is a higher priority and is released last. The value specified in this attribute will override whatever holdingPriority that has been provisioned at the Vcd (or Vpd). If the value is left at the default of noOverride, the holdingPriority provisioned at the Vcd (or Vpd) will be used.')
mscAtmIfVptVccMnrp = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 13))
mscAtmIfVptVccMnrpRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 13, 1), )
if mibBuilder.loadTexts: mscAtmIfVptVccMnrpRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccMnrpRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfVptVccMnrp components.')
mscAtmIfVptVccMnrpRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 13, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBearerServiceMIB", "mscAtmIfVptVccMnrpIndex"))
if mibBuilder.loadTexts: mscAtmIfVptVccMnrpRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccMnrpRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfVptVccMnrp component.')
mscAtmIfVptVccMnrpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 13, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccMnrpRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccMnrpRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfVptVccMnrp components. These components can be added and deleted.')
mscAtmIfVptVccMnrpComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 13, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccMnrpComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccMnrpComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfVptVccMnrpStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 13, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccMnrpStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccMnrpStorageType.setDescription('This variable represents the storage type value for the mscAtmIfVptVccMnrp tables.')
mscAtmIfVptVccMnrpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 13, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscAtmIfVptVccMnrpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccMnrpIndex.setDescription('This variable represents the index for the mscAtmIfVptVccMnrp tables.')
mscAtmIfVptVccMnrpProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 13, 101), )
if mibBuilder.loadTexts: mscAtmIfVptVccMnrpProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccMnrpProvTable.setDescription('This group contains the provisionable attributes for the Mnrp component.')
mscAtmIfVptVccMnrpProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 13, 101, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBearerServiceMIB", "mscAtmIfVptVccMnrpIndex"))
if mibBuilder.loadTexts: mscAtmIfVptVccMnrpProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccMnrpProvEntry.setDescription('An entry in the mscAtmIfVptVccMnrpProvTable.')
mscAtmIfVptVccMnrpOamSegmentBoundary = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 13, 101, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("no", 0), ("yes", 1), ("sameAsInterface", 2))).clone('sameAsInterface')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccMnrpOamSegmentBoundary.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccMnrpOamSegmentBoundary.setDescription("This attribute specifies the OAM segment boundary desired for a Mnrp component. It affects the connection point type value visible in the parent component's connectionPointType attribute. The desired OAM segment boundary can be specified directly as yes, no or sameAsInterface. If sameAsInterface is specified, the OAM segment boundary is same as the oamSegmentBoundary attribute of the associated AtmIf and the switch will set the connectionPointType, choosing segmentEndPoint for a segment- boundary ATM interface and connectingPoint for a non-segment- boundary ATM interface.")
mscAtmIfVptVccMnrpBandwidthElastic = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 13, 101, 1, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccMnrpBandwidthElastic.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccMnrpBandwidthElastic.setDescription('This attribute is only of importance for connections which are carried on a link with a variable bandwidth. For example, the bandwidth may be reduced in the event that one or more physical links in the IMA group fail, such that the originally requested bandwidth cannot be maintained. This attribute shows whether the application running on this connection can continue to operate if the bandwidth is reduced. If the bandwidth is reduced, the amount by which it is reduced will be displayed in the bandwidthReduction attribute. A value of yes, indicates that this connection is elastic, and the bandwidth may be reduced but the connection will not be released. Currently, this attribute should only be set to yes for situations where this Mnrp is functioning as a loopback on one side of an IMA link. There are no other situations where this setting is valid. A value of no indicates that the bandwidth for this connection will not be reduced in the event of link bandwidth reduction. However, this connection may be released based on its holdingPriority.')
mscAtmIfVptVccMnrpOverrideHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 13, 101, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 6))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("noOverride", 6))).clone('noOverride')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccMnrpOverrideHoldingPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccMnrpOverrideHoldingPriority.setDescription('This attribute specifies the holding priority of this connection. Holding priority is used when there is an IMA group where some physical links have failed. Holding priority determines the order in which connections are released. 4 is the lowest holding priority and is released first. 0 is a higher priority and is released last. The value specified in this attribute will override whatever holdingPriority that has been provisioned at the Vcd (or Vpd). If the value is left at the default of noOverride, the holdingPriority provisioned at the Vcd (or Vpd) will be used.')
mscAtmIfVptVccMnrpNextHopsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 13, 658), )
if mibBuilder.loadTexts: mscAtmIfVptVccMnrpNextHopsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccMnrpNextHopsTable.setDescription('This attribute specifies the list of Nrp components with which this Mnrp is associated. A sample value is AtmIf/31 Vcc/0.32 Nrp. This attribute must be provisioned with at least one Nrp component under a compatible connection type.')
mscAtmIfVptVccMnrpNextHopsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 13, 658, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBearerServiceMIB", "mscAtmIfVptVccMnrpIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmBearerServiceMIB", "mscAtmIfVptVccMnrpNextHopsValue"))
if mibBuilder.loadTexts: mscAtmIfVptVccMnrpNextHopsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccMnrpNextHopsEntry.setDescription('An entry in the mscAtmIfVptVccMnrpNextHopsTable.')
mscAtmIfVptVccMnrpNextHopsValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 13, 658, 1, 1), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccMnrpNextHopsValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccMnrpNextHopsValue.setDescription('This variable represents both the value and the index for the mscAtmIfVptVccMnrpNextHopsTable.')
mscAtmIfVptVccMnrpNextHopsRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 13, 658, 1, 2), RowStatus()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mscAtmIfVptVccMnrpNextHopsRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccMnrpNextHopsRowStatus.setDescription('This variable is used to control the addition and deletion of individual values of the mscAtmIfVptVccMnrpNextHopsTable.')
atmBearerServiceGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 64, 1))
atmBearerServiceGroupCA = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 64, 1, 1))
atmBearerServiceGroupCA02 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 64, 1, 1, 3))
atmBearerServiceGroupCA02A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 64, 1, 1, 3, 2))
atmBearerServiceCapabilities = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 64, 3))
atmBearerServiceCapabilitiesCA = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 64, 3, 1))
atmBearerServiceCapabilitiesCA02 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 64, 3, 1, 3))
atmBearerServiceCapabilitiesCA02A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 64, 3, 1, 3, 2))
mibBuilder.exportSymbols("Nortel-MsCarrier-MscPassport-AtmBearerServiceMIB", mscAtmIfVpcNrpNextHop=mscAtmIfVpcNrpNextHop, mscAtmIfVpcMnrpIndex=mscAtmIfVpcMnrpIndex, mscAtmIfVccNrpConnectionPointType=mscAtmIfVccNrpConnectionPointType, mscAtmIfVptVccMnrpNextHopsTable=mscAtmIfVptVccMnrpNextHopsTable, atmBearerServiceGroupCA02=atmBearerServiceGroupCA02, mscAtmIfVpcNrpRowStatus=mscAtmIfVpcNrpRowStatus, mscAtmIfVccNrpIndex=mscAtmIfVccNrpIndex, mscAtmIfVptVccNrpBandwidthElastic=mscAtmIfVptVccNrpBandwidthElastic, mscAtmIfVccNrpStorageType=mscAtmIfVccNrpStorageType, mscAtmIfVccMnrpNextHopsTable=mscAtmIfVccMnrpNextHopsTable, mscAtmIfVptVccMnrpRowStatusTable=mscAtmIfVptVccMnrpRowStatusTable, mscAtmIfVpcMnrpProvTable=mscAtmIfVpcMnrpProvTable, mscAtmIfVpcMnrpNextHopsEntry=mscAtmIfVpcMnrpNextHopsEntry, mscAtmIfVpcMnrpOverrideHoldingPriority=mscAtmIfVpcMnrpOverrideHoldingPriority, mscAtmIfVccNrpComponentName=mscAtmIfVccNrpComponentName, mscAtmIfVptVccNrpRxAal5PartialPacketDiscard=mscAtmIfVptVccNrpRxAal5PartialPacketDiscard, mscAtmIfVpcMnrpRowStatus=mscAtmIfVpcMnrpRowStatus, atmBearerServiceGroupCA=atmBearerServiceGroupCA, mscAtmIfVptVccMnrpProvTable=mscAtmIfVptVccMnrpProvTable, mscAtmIfVpcNrpComponentName=mscAtmIfVpcNrpComponentName, mscAtmIfVccNrpRowStatusTable=mscAtmIfVccNrpRowStatusTable, mscAtmIfVpcNrpOamSegmentBoundary=mscAtmIfVpcNrpOamSegmentBoundary, mscAtmIfVptVccMnrpOverrideHoldingPriority=mscAtmIfVptVccMnrpOverrideHoldingPriority, mscAtmIfVptVccNrpOverrideHoldingPriority=mscAtmIfVptVccNrpOverrideHoldingPriority, mscAtmIfVccNrpRowStatusEntry=mscAtmIfVccNrpRowStatusEntry, mscAtmIfVptVccMnrpRowStatusEntry=mscAtmIfVptVccMnrpRowStatusEntry, mscAtmIfVccMnrpOamSegmentBoundary=mscAtmIfVccMnrpOamSegmentBoundary, mscAtmIfVptVccNrpStorageType=mscAtmIfVptVccNrpStorageType, mscAtmIfVccNrpOamSegmentBoundary=mscAtmIfVccNrpOamSegmentBoundary, mscAtmIfVpcMnrpNextHopsValue=mscAtmIfVpcMnrpNextHopsValue, mscAtmIfVptVccNrp=mscAtmIfVptVccNrp, mscAtmIfVptVccMnrpOamSegmentBoundary=mscAtmIfVptVccMnrpOamSegmentBoundary, mscAtmIfVccMnrpIndex=mscAtmIfVccMnrpIndex, mscAtmIfVccMnrpProvEntry=mscAtmIfVccMnrpProvEntry, mscAtmIfVpcMnrpBandwidthElastic=mscAtmIfVpcMnrpBandwidthElastic, mscAtmIfVpcNrpProvEntry=mscAtmIfVpcNrpProvEntry, mscAtmIfVccNrpTxAal5PartialPacketDiscard=mscAtmIfVccNrpTxAal5PartialPacketDiscard, atmBearerServiceCapabilitiesCA02A=atmBearerServiceCapabilitiesCA02A, mscAtmIfVccNrp=mscAtmIfVccNrp, mscAtmIfVpcNrpRowStatusEntry=mscAtmIfVpcNrpRowStatusEntry, mscAtmIfVpcNrpConnectionPointType=mscAtmIfVpcNrpConnectionPointType, mscAtmIfVpcMnrpNextHopsRowStatus=mscAtmIfVpcMnrpNextHopsRowStatus, mscAtmIfVpcNrpTxAal5PartialPacketDiscard=mscAtmIfVpcNrpTxAal5PartialPacketDiscard, mscAtmIfVccNrpOverrideHoldingPriority=mscAtmIfVccNrpOverrideHoldingPriority, mscAtmIfVpcNrpIndex=mscAtmIfVpcNrpIndex, mscAtmIfVptVccMnrpProvEntry=mscAtmIfVptVccMnrpProvEntry, mscAtmIfVpcNrpStorageType=mscAtmIfVpcNrpStorageType, mscAtmIfVptVccNrpConnectionPointType=mscAtmIfVptVccNrpConnectionPointType, mscAtmIfVccMnrp=mscAtmIfVccMnrp, mscAtmIfVccMnrpStorageType=mscAtmIfVccMnrpStorageType, mscAtmIfVccMnrpOverrideHoldingPriority=mscAtmIfVccMnrpOverrideHoldingPriority, atmBearerServiceGroup=atmBearerServiceGroup, mscAtmIfVptVccMnrpNextHopsEntry=mscAtmIfVptVccMnrpNextHopsEntry, mscAtmIfVpcNrpRowStatusTable=mscAtmIfVpcNrpRowStatusTable, mscAtmIfVpcMnrpRowStatusTable=mscAtmIfVpcMnrpRowStatusTable, atmBearerServiceGroupCA02A=atmBearerServiceGroupCA02A, mscAtmIfVptVccMnrpComponentName=mscAtmIfVptVccMnrpComponentName, mscAtmIfVccNrpBandwidthElastic=mscAtmIfVccNrpBandwidthElastic, mscAtmIfVptVccNrpRowStatus=mscAtmIfVptVccNrpRowStatus, mscAtmIfVpcMnrp=mscAtmIfVpcMnrp, mscAtmIfVptVccNrpOamSegmentBoundary=mscAtmIfVptVccNrpOamSegmentBoundary, mscAtmIfVptVccNrpComponentName=mscAtmIfVptVccNrpComponentName, mscAtmIfVptVccMnrpIndex=mscAtmIfVptVccMnrpIndex, mscAtmIfVpcNrpBandwidthElastic=mscAtmIfVpcNrpBandwidthElastic, mscAtmIfVccMnrpRowStatus=mscAtmIfVccMnrpRowStatus, atmBearerServiceCapabilitiesCA=atmBearerServiceCapabilitiesCA, mscAtmIfVpcNrpRxAal5PartialPacketDiscard=mscAtmIfVpcNrpRxAal5PartialPacketDiscard, mscAtmIfVptVccNrpProvEntry=mscAtmIfVptVccNrpProvEntry, mscAtmIfVccNrpRowStatus=mscAtmIfVccNrpRowStatus, mscAtmIfVccMnrpProvTable=mscAtmIfVccMnrpProvTable, mscAtmIfVccMnrpRowStatusEntry=mscAtmIfVccMnrpRowStatusEntry, mscAtmIfVptVccMnrpRowStatus=mscAtmIfVptVccMnrpRowStatus, mscAtmIfVccMnrpRowStatusTable=mscAtmIfVccMnrpRowStatusTable, mscAtmIfVptVccNrpRowStatusEntry=mscAtmIfVptVccNrpRowStatusEntry, mscAtmIfVpcNrpOverrideHoldingPriority=mscAtmIfVpcNrpOverrideHoldingPriority, mscAtmIfVptVccMnrp=mscAtmIfVptVccMnrp, mscAtmIfVpcNrpProvTable=mscAtmIfVpcNrpProvTable, mscAtmIfVpcMnrpOamSegmentBoundary=mscAtmIfVpcMnrpOamSegmentBoundary, mscAtmIfVpcMnrpNextHopsTable=mscAtmIfVpcMnrpNextHopsTable, mscAtmIfVccMnrpNextHopsEntry=mscAtmIfVccMnrpNextHopsEntry, atmBearerServiceCapabilitiesCA02=atmBearerServiceCapabilitiesCA02, mscAtmIfVccNrpRxAal5PartialPacketDiscard=mscAtmIfVccNrpRxAal5PartialPacketDiscard, mscAtmIfVpcMnrpProvEntry=mscAtmIfVpcMnrpProvEntry, mscAtmIfVpcMnrpComponentName=mscAtmIfVpcMnrpComponentName, mscAtmIfVpcMnrpRowStatusEntry=mscAtmIfVpcMnrpRowStatusEntry, mscAtmIfVpcNrp=mscAtmIfVpcNrp, atmBearerServiceCapabilities=atmBearerServiceCapabilities, mscAtmIfVptVccNrpProvTable=mscAtmIfVptVccNrpProvTable, mscAtmIfVptVccNrpRowStatusTable=mscAtmIfVptVccNrpRowStatusTable, mscAtmIfVccNrpProvTable=mscAtmIfVccNrpProvTable, mscAtmIfVptVccNrpNextHop=mscAtmIfVptVccNrpNextHop, mscAtmIfVptVccMnrpStorageType=mscAtmIfVptVccMnrpStorageType, mscAtmIfVptVccMnrpNextHopsValue=mscAtmIfVptVccMnrpNextHopsValue, mscAtmIfVpcMnrpStorageType=mscAtmIfVpcMnrpStorageType, mscAtmIfVccMnrpNextHopsValue=mscAtmIfVccMnrpNextHopsValue, mscAtmIfVptVccNrpTxAal5PartialPacketDiscard=mscAtmIfVptVccNrpTxAal5PartialPacketDiscard, mscAtmIfVptVccMnrpBandwidthElastic=mscAtmIfVptVccMnrpBandwidthElastic, mscAtmIfVptVccNrpIndex=mscAtmIfVptVccNrpIndex, mscAtmIfVccMnrpNextHopsRowStatus=mscAtmIfVccMnrpNextHopsRowStatus, mscAtmIfVccMnrpBandwidthElastic=mscAtmIfVccMnrpBandwidthElastic, mscAtmIfVccMnrpComponentName=mscAtmIfVccMnrpComponentName, mscAtmIfVptVccMnrpNextHopsRowStatus=mscAtmIfVptVccMnrpNextHopsRowStatus, atmBearerServiceMIB=atmBearerServiceMIB, mscAtmIfVccNrpNextHop=mscAtmIfVccNrpNextHop, mscAtmIfVccNrpProvEntry=mscAtmIfVccNrpProvEntry)

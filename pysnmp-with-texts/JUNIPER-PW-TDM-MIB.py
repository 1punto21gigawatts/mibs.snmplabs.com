#
# PySNMP MIB module JUNIPER-PW-TDM-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/JUNIPER-PW-TDM-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:00:51 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueSizeConstraint, ValueRangeConstraint, ConstraintsUnion, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsUnion", "ConstraintsIntersection")
InterfaceIndexOrZero, = mibBuilder.importSymbols("IF-MIB", "InterfaceIndexOrZero")
jnxMibs, jnxPwTdmMibRoot = mibBuilder.importSymbols("JUNIPER-SMI", "jnxMibs", "jnxPwTdmMibRoot")
jnxVpnPwVpnType, jnxVpnPwVpnName, jnxVpnPwIndex = mibBuilder.importSymbols("JUNIPER-VPN-MIB", "jnxVpnPwVpnType", "jnxVpnPwVpnName", "jnxVpnPwIndex")
PerfCurrentCount, PerfIntervalCount = mibBuilder.importSymbols("PerfHist-TC-MIB", "PerfCurrentCount", "PerfIntervalCount")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
NotificationGroup, ModuleCompliance, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance", "ObjectGroup")
transmission, Gauge32, Unsigned32, ModuleIdentity, Counter64, MibScalar, MibTable, MibTableRow, MibTableColumn, Integer32, TimeTicks, IpAddress, MibIdentifier, iso, Bits, NotificationType, ObjectIdentity, Counter32 = mibBuilder.importSymbols("SNMPv2-SMI", "transmission", "Gauge32", "Unsigned32", "ModuleIdentity", "Counter64", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Integer32", "TimeTicks", "IpAddress", "MibIdentifier", "iso", "Bits", "NotificationType", "ObjectIdentity", "Counter32")
TimeStamp, StorageType, DisplayString, TruthValue, RowStatus, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "TimeStamp", "StorageType", "DisplayString", "TruthValue", "RowStatus", "TextualConvention")
jnxPWTdmMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1))
jnxPWTdmMIB.setRevisions(('2007-04-03 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: jnxPWTdmMIB.setRevisionsDescriptions(('Initial version published as part of RFC YYYY.',))
if mibBuilder.loadTexts: jnxPWTdmMIB.setLastUpdated('200704030000Z')
if mibBuilder.loadTexts: jnxPWTdmMIB.setOrganization('Pseudo-Wire Emulation Edge-to-Edge (PWE3) Working Group')
if mibBuilder.loadTexts: jnxPWTdmMIB.setContactInfo(' Orly Nicklass Postal: RAD Data Communications 24 Raoul Wallenberg St., Bldg C Tel Aviv 69719, Israel Email: orly_n@rad.com The PWE3 Working Group (email distribution pwe3@ietf.org, http://www.ietf.org/html.charters/pwe3-charter.html) ')
if mibBuilder.loadTexts: jnxPWTdmMIB.setDescription("This MIB contains managed object definitions for encapsulating TDM (T1,E1, T3, E3, NxDS0) as pseudo-wires over packet-switching networks (PSN). This MIB supplements the PW-STD-MIB as in: Zelig, D., Nadeau,T. 'Pseudo Wire (PW) Management Information Base'. The PW-STD-MIB contains structures and MIB associations generic to Pseudo-Wire (PW) emulation. PW-specific MIBs (such as this) contain config and stats for specific PW types. Copyright (C) The IETF Trust (2007). This version of this MIB module is part of RFC yyyy; see the RFC itself for full legal notices. -- RFC Ed.: replace yyyy with actual RFC number & remove this note")
class JnxPwTDMCfgIndex(TextualConvention, Unsigned32):
    description = 'Index into the relevant pwXXXCfgTable.'
    status = 'current'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(1, 4294967295)

class JnxPwCfgIndexOrzero(TextualConvention, Unsigned32):
    description = 'Index in any of the relevant configuration tables for supplement information regarding configuration of the specific technology. Value 0 implies no additional configuration information is applicable.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(0, 4294967295)

jnxpwTDMObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1))
jnxpwTDMNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 2))
jnxpwTDMConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 3))
jnxpwTDMTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 1), )
if mibBuilder.loadTexts: jnxpwTDMTable.setStatus('current')
if mibBuilder.loadTexts: jnxpwTDMTable.setDescription('This table contains basic information including ifIndex, and pointers to entries in the relevant TDM config tables for this TDM PW.')
jnxpwTDMEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 1, 1), ).setIndexNames((0, "JUNIPER-VPN-MIB", "jnxVpnPwVpnType"), (0, "JUNIPER-VPN-MIB", "jnxVpnPwVpnName"), (0, "JUNIPER-VPN-MIB", "jnxVpnPwIndex"))
if mibBuilder.loadTexts: jnxpwTDMEntry.setStatus('current')
if mibBuilder.loadTexts: jnxpwTDMEntry.setDescription('This table is indexed by the same index that was created for the associated entry in the PW Table (in the PW-STD-MIB). - The PwIndex. An entry is created in this table by the agent for every entry in the pwTable with a pwType equal to one of the following: e1Satop(17), t1Satop(18), e3Satop(19), t3Satop(20), basicCesPsn(21), basicTdmIp(22), tdmCasCesPsn(23), tdmCasTdmIp(24). Unless otherwise specified, all RW objects in this table MUST NOT be changed after row activation (see [PWMIB]) and should remain unchanged after reboot.')
jnxpwTDMRate = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 1, 1, 1), Integer32().clone(32)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMRate.setReference('TDMCP-EXT')
if mibBuilder.loadTexts: jnxpwTDMRate.setStatus('current')
if mibBuilder.loadTexts: jnxpwTDMRate.setDescription("The parameter represents the bit-rate of the TDM service in multiples of the 'basic' 64 Kbit/s rate [TDMCP-EXT]. It complements the definition of pwType used in PW-STD-MIB. For structure-agnostic the following should be used: a) Satop E1 - 32 b) Satop T1 emulation: i) MUST be set to 24 in the basic emulation mode ii) MUST be set to 25 for the 'Octet-aligned T1' emulation mode c) Satop E3 - 535 d) Satop T3 - 699 For all kinds of structure-aware emulation, this parameter MUST be set to N where N is the number of DS0 channels in the corresponding attachment circuit.")
jnxpwTDMIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 1, 1, 2), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMIfIndex.setStatus('current')
if mibBuilder.loadTexts: jnxpwTDMIfIndex.setDescription('This is a unique index within the ifTable. It represents the interface index of the full link or the interface index for the bundle holding the group of time slots to be transmitted via this PW connection. A value of zero indicates an interface index that has yet to be determined. Once set, if the TDM ifIndex is (for some reason) later removed, the agent SHOULD delete the associated PW rows (e.g., this pwTDMTable entry). If the agent does not delete the rows, the agent MUST set this object to zero.')
jnxpwGenTDMCfgIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 1, 1, 3), JnxPwCfgIndexOrzero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwGenTDMCfgIndex.setStatus('current')
if mibBuilder.loadTexts: jnxpwGenTDMCfgIndex.setDescription('Index to the generic parameters in the TDM configuration table that appears in this MIB module. It is likely that multiple TDM PWs of the same characteristic will share a single TDM Cfg entry.')
jnxpwRelTDMCfgIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 1, 1, 4), JnxPwCfgIndexOrzero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwRelTDMCfgIndex.setStatus('current')
if mibBuilder.loadTexts: jnxpwRelTDMCfgIndex.setDescription('Index to the relevant TDM configuration table entry that appears in one of the related MIB modules such as TDMoIP or CESoPSN. It is likely that multiple TDM PWs of the same characteristic will share a single configuration entry of the relevant type. The value 0 implies no entry in other related MIB')
jnxpwTDMConfigError = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 1, 1, 5), Bits().clone(namedValues=NamedValues(("notApplicable", 0), ("tdmTypeIncompatible", 1), ("peerRtpIncompatible", 2), ("peerPayloadSizeIncompatible", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMConfigError.setStatus('current')
if mibBuilder.loadTexts: jnxpwTDMConfigError.setDescription('Any of the bits are set if the local configuration is not compatible with the peer configuration as available from the various parameters options. Setting is done based on signaling, or else value (0) will be set. -tdmTypeIncompatible bit is set if the local configuration is not carrying the same TDM type as the peer configuration. -peerRtpIncompatible bit is set if the local configuration is configured to send RTP packets for this PW, and the remote is not capable of accepting RTP packets. -peerPayloadSizeIncompatible bit is set if the local configuration is not carrying the same Payload Size as the peer configuration. ')
jnxpwTDMTimeElapsed = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 900))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMTimeElapsed.setStatus('current')
if mibBuilder.loadTexts: jnxpwTDMTimeElapsed.setDescription("The number of seconds, including partial seconds, that have elapsed since the beginning of the current measurement period. If, for some reason, such as an adjustment in the system's time-of-day clock, the current interval exceeds the maximum value, the agent will return the maximum value.")
jnxpwTDMValidIntervals = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 96))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMValidIntervals.setStatus('current')
if mibBuilder.loadTexts: jnxpwTDMValidIntervals.setDescription('The number of previous 15-minute intervals for which data was collected. An agent with TDM capability must be capable of supporting at least n intervals. The minimum value of n is 4, The default of n is 32 and the maximum value of n is 96. The value will be n unless the measurement was (re-) started within the last (n*15) minutes, in which case the value will be the number of complete 15 minute intervals for which the agent has at least some data. In certain cases(e.g., in the case where the agent is a proxy) it is possible that some intervals are unavailable. In this case, this interval is the maximum interval number for which data is available. ')
jnxpwTDMValidDayIntervals = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 30))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMValidDayIntervals.setStatus('current')
if mibBuilder.loadTexts: jnxpwTDMValidDayIntervals.setDescription('The number of previous days for which data was collected. An agent with TDM capability must be capable of supporting at least n intervals. The minimum value of n is 1, The default of n is 1 and the maximum value of n is 30.')
jnxpwTDMLastEsTimeStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 1, 1, 11), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMLastEsTimeStamp.setStatus('current')
if mibBuilder.loadTexts: jnxpwTDMLastEsTimeStamp.setDescription('The value of sysUpTime at the most recent occasion at which the TDM PW entered the ES or SES state.')
jnxpwTDMCfgIndexNext = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMCfgIndexNext.setStatus('current')
if mibBuilder.loadTexts: jnxpwTDMCfgIndexNext.setDescription('This object contains the value to be used for pwTDMCfgIndex when creating entries in the pwTDMCfgTable. The value 0 indicates that no unassigned entries are available. To obtain the value of pwTDMCfgIndexNext for a new entry in the pwTDMCfgTable, the manager issues a management protocol retrieval operation. The agent will determine through its local policy when this index value will be made available for reuse.')
jnxpwTDMCfgTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 3), )
if mibBuilder.loadTexts: jnxpwTDMCfgTable.setStatus('current')
if mibBuilder.loadTexts: jnxpwTDMCfgTable.setDescription('This table contains a set of parameters that may be referenced by one or more TDM PWs in pwTDMTable.')
jnxpwTDMCfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 3, 1), ).setIndexNames((0, "JUNIPER-VPN-MIB", "jnxVpnPwVpnType"), (0, "JUNIPER-VPN-MIB", "jnxVpnPwVpnName"), (0, "JUNIPER-VPN-MIB", "jnxVpnPwIndex"))
if mibBuilder.loadTexts: jnxpwTDMCfgEntry.setStatus('current')
if mibBuilder.loadTexts: jnxpwTDMCfgEntry.setDescription('These parameters define the characteristics of a TDM PW. They are grouped here to ease NMS burden. Once an entry is created here it may be re-used by many PWs. Unless otherwise specified, all objects in this table MUST NOT be changed after row activation (see [PWMIB]) if the row index is in used by an entry in pwTDMTable. Rows should remain unchanged after reboot.')
jnxpwTDMCfgIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 3, 1, 1), JnxPwTDMCfgIndex())
if mibBuilder.loadTexts: jnxpwTDMCfgIndex.setStatus('current')
if mibBuilder.loadTexts: jnxpwTDMCfgIndex.setDescription('Index to an entry in this table. The value is a copy of the assigned pwTDMCfgIndexNext')
jnxpwTDMCfgRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 3, 1, 2), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMCfgRowStatus.setStatus('current')
if mibBuilder.loadTexts: jnxpwTDMCfgRowStatus.setDescription('Object used for creating, modifying, and deleting a row from this table. The following objects should not be modified if the entry is in used and the status is active: pwTDMCfgPayloadSize, pwTDMCfgRtpHdrUsed, pwTDMCfgJtrBfrDepth, and pwTDMCfgPayloadSuppression. The row should not be deleted if the entry is in used')
jnxpwTDMCfgPayloadSize = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 3, 1, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMCfgPayloadSize.setStatus('current')
if mibBuilder.loadTexts: jnxpwTDMCfgPayloadSize.setDescription('The value of this object indicates the PayLoad Size (in bytes) to be defined during the PW setUp. Upon TX, implementation must be capable of carrying that amount of bytes. Upon RX, when the LEN field is set to 0, the payload of packet MUST assume this size, and if the actual packet size is inconsistent with this length, the packet MUST be considered to be malformed. ')
jnxpwTDMCfgPktReorder = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 3, 1, 5), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMCfgPktReorder.setStatus('current')
if mibBuilder.loadTexts: jnxpwTDMCfgPktReorder.setDescription('If set True: as CE bound packets are queued in the jitter buffer, out of order packets are re-ordered. The maximum sequence number differential (i.e., the range in which re-sequencing can occur) is dependant on the depth of the jitter buffer. See pwTDMCfgJtrBfrDepth. NOTE: Some implementations may not support this feature. The agent is then required to set this to False.')
jnxpwTDMCfgRtpHdrUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 3, 1, 6), TruthValue().clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMCfgRtpHdrUsed.setReference('SATOP')
if mibBuilder.loadTexts: jnxpwTDMCfgRtpHdrUsed.setStatus('current')
if mibBuilder.loadTexts: jnxpwTDMCfgRtpHdrUsed.setDescription('If set to False: an RTP header is not pre-pended to the TDM packet.')
jnxpwTDMCfgJtrBfrDepth = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 3, 1, 7), Unsigned32().clone(3000)).setUnits('microsecond').setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMCfgJtrBfrDepth.setStatus('current')
if mibBuilder.loadTexts: jnxpwTDMCfgJtrBfrDepth.setDescription("The size of this buffer SHOULD be locally configured to allow accommodation to the PSN-specific packet delay variation. If configured to a value not supported by the implementation, the agent MUST return an error code 'jtrBfrDepth' in 'pwTDMConfigError ' NOTE: jitter buffers are a limited resource to be managed. The actual size should be at least twice as big as the value of pwTDMCfgJtrBfrDepth ")
jnxpwTDMCfgPayloadSuppression = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMCfgPayloadSuppression.setStatus('current')
if mibBuilder.loadTexts: jnxpwTDMCfgPayloadSuppression.setDescription("Selecting 'enable' means: Payload suppression is allowed. Payload MAY be omitted in order to conserve bandwidth. Selecting 'disable' means: no suppresion under any condition. Object MAY be changed at any time.")
jnxpwTDMCfgConsecPktsInSynch = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 3, 1, 9), Unsigned32().clone(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMCfgConsecPktsInSynch.setReference('SATOP')
if mibBuilder.loadTexts: jnxpwTDMCfgConsecPktsInSynch.setStatus('current')
if mibBuilder.loadTexts: jnxpwTDMCfgConsecPktsInSynch.setDescription('The number of consecutive packets with sequential sequence numbers that are required to exit the LOPS state. Object MAY be changed when the related PW is defined as not active.')
jnxpwTDMCfgConsecMissPktsOutSynch = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 3, 1, 10), Unsigned32().clone(10)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMCfgConsecMissPktsOutSynch.setReference('SATOP')
if mibBuilder.loadTexts: jnxpwTDMCfgConsecMissPktsOutSynch.setStatus('current')
if mibBuilder.loadTexts: jnxpwTDMCfgConsecMissPktsOutSynch.setDescription('The number of consecutive missing packets that are required to enter the LOPS state. Object MAY be changed when the related PW is defined as not active.')
jnxpwTDMCfgSetUp2SynchTimeOut = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 3, 1, 11), Unsigned32().clone(5000)).setUnits('millisecond').setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMCfgSetUp2SynchTimeOut.setStatus('current')
if mibBuilder.loadTexts: jnxpwTDMCfgSetUp2SynchTimeOut.setDescription("The amount of time the host should wait before declaring the pseudo wire in down state, if the number of consecutive TDM packets that have been received after changing the adminstrative status to up and after finalization of signaling (if supported) between the two PEs is smaller than pwTDMCfgConsecPktsInSynch. Once the the pw has OperStatus of 'up' this parameter is no longer valid. This parameter is defined to ensure that the host does not prematurely inform failure of the pw. In particular pw 'down' notifications should not be sent before expiration of this timer. This parameter is valid only after adminisrative changes of the status of the pw. If the pw fails due to network impairments a 'down' notification should be sent. Object MAY be changed when the related PW is defined as not active.")
jnxpwTDMCfgPktReplacePolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 3, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("allOnes", 1), ("implementationSpecific", 2), ("filler", 3))).clone('allOnes')).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMCfgPktReplacePolicy.setStatus('current')
if mibBuilder.loadTexts: jnxpwTDMCfgPktReplacePolicy.setDescription('This parameter determines the value to be played when CE bound packets have over/underflow the jitter buffer, or are missing for any reason. This byte pattern is sent(played)on the TDM line. Selecting implementationSpecific(2) implies agent specific algorithm. Selecting filler(3) requires setting of pwTDMCfgPktFiller. Object MAY be changed when the related PW is defined as not active.')
jnxpwTDMCfgAvePktLossTimeWindow = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 3, 1, 13), Integer32()).setUnits('millisecond').setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMCfgAvePktLossTimeWindow.setStatus('current')
if mibBuilder.loadTexts: jnxpwTDMCfgAvePktLossTimeWindow.setDescription('The length of time over which the average packet loss rate should be computed to detect Excessive packet loss rate. Object MAY be changed when the related PW is defined as not active.')
jnxpwTDMCfgExcessivePktLossThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 3, 1, 14), Unsigned32()).setUnits('Percent').setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMCfgExcessivePktLossThreshold.setStatus('current')
if mibBuilder.loadTexts: jnxpwTDMCfgExcessivePktLossThreshold.setDescription('Excessive packet loss rate is detected by computing the average packetloss rate over a pwTDMCfgAvePktLossTimeWindow amount of time and comparing it with this threshold value. The rate is expressed in precentage. Object MAY be changed when the related PW is defined as not active.')
jnxpwTDMCfgAlarmThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 3, 1, 15), Unsigned32().clone(2500)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMCfgAlarmThreshold.setStatus('current')
if mibBuilder.loadTexts: jnxpwTDMCfgAlarmThreshold.setDescription("Alarms are only reported when the defect state persists for the length of time specified by this object. The object's unit is millisec. Object MAY be changed when the related PW is defined as not active.")
jnxpwTDMCfgClearAlarmThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 3, 1, 16), Unsigned32().clone(10000)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMCfgClearAlarmThreshold.setStatus('current')
if mibBuilder.loadTexts: jnxpwTDMCfgClearAlarmThreshold.setDescription("Alarm MUST be cleared after the corresponding defect is undetected for the amount of time specified by this object. The object's unit is millisec. Object MAY be changed when the related PW is defined as not active.")
jnxpwTDMCfgMissingPktsToSes = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 3, 1, 17), Unsigned32().clone(30)).setUnits('Percent').setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMCfgMissingPktsToSes.setStatus('current')
if mibBuilder.loadTexts: jnxpwTDMCfgMissingPktsToSes.setDescription('Percent of missing packets detected (consecutive or not) within a 1 second window to cause a Severely Error Second (SES) to be counted. Object MAY be changed when the related PW is defined as not active.')
jnxpwTDMCfgTimestampMode = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 3, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("absolute", 2), ("differential", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMCfgTimestampMode.setStatus('current')
if mibBuilder.loadTexts: jnxpwTDMCfgTimestampMode.setDescription('Timestamp generation MAY be used in one of the following modes: 1. Absolute mode: the PSN-bound IWF sets timestamps using the clock recovered from the incoming TDM attachment circuit. As a consequence, the timestamps are closely correlated with the sequence numbers. All TDM implementations that support usage of the RTP header MUST support this mode. 2. Differential mode: Both IWFs have access to a common high- quality timing source, and this source is used for timestamp generation. Support of this mode is OPTIONAL. Object MAY be changed when the related PW is defined as not active.')
jnxpwTDMCfgStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 3, 1, 19), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMCfgStorageType.setStatus('current')
if mibBuilder.loadTexts: jnxpwTDMCfgStorageType.setDescription('This variable indicates the storage type for this row.')
jnxpwTDMCfgPktFiller = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 3, 1, 20), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(255)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMCfgPktFiller.setStatus('current')
if mibBuilder.loadTexts: jnxpwTDMCfgPktFiller.setDescription('Filler byte pattern played out on the TDM interface if pwTDMCfgPktReplacePolicy was set to filler(3). Object MAY be changed when the related PW is defined as not active.')
jnxpwTDMCfgName = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 3, 1, 21), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMCfgName.setStatus('current')
if mibBuilder.loadTexts: jnxpwTDMCfgName.setDescription('A descriptive string, prefereably unique name, to an entry in this table. Object MAY be changed at any time.')
jnxpwTDMPerfCurrentTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 5), )
if mibBuilder.loadTexts: jnxpwTDMPerfCurrentTable.setStatus('current')
if mibBuilder.loadTexts: jnxpwTDMPerfCurrentTable.setDescription('The current 15 minute interval counts are in this table. This table provides per TDM PW performance information.')
jnxpwTDMPerfCurrentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 5, 1), ).setIndexNames((0, "JUNIPER-VPN-MIB", "jnxVpnPwVpnType"), (0, "JUNIPER-VPN-MIB", "jnxVpnPwVpnName"), (0, "JUNIPER-VPN-MIB", "jnxVpnPwIndex"))
if mibBuilder.loadTexts: jnxpwTDMPerfCurrentEntry.setStatus('current')
if mibBuilder.loadTexts: jnxpwTDMPerfCurrentEntry.setDescription('An entry in this table is created by the agent for every pwTDMTable entry. After 15 minutes, the contents of this table entry are copied to a new entry in the pwTDMPerfInterval table and the counts in this entry are reset to zero.')
jnxpwTDMPerfCurrentMissingPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 5, 1, 1), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMPerfCurrentMissingPkts.setStatus('current')
if mibBuilder.loadTexts: jnxpwTDMPerfCurrentMissingPkts.setDescription('Number of missing packets (as detected via control word sequence number gaps).')
jnxpwTDMPerfCurrentPktsReOrder = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 5, 1, 2), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMPerfCurrentPktsReOrder.setStatus('current')
if mibBuilder.loadTexts: jnxpwTDMPerfCurrentPktsReOrder.setDescription('Number of packets detected out of sequence (via control word sequence number), but successfully re-ordered. Note: some implementations may not support this Feature.')
jnxpwTDMPerfCurrentJtrBfrUnderruns = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 5, 1, 3), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMPerfCurrentJtrBfrUnderruns.setStatus('current')
if mibBuilder.loadTexts: jnxpwTDMPerfCurrentJtrBfrUnderruns.setDescription('Number of times a packet needed to be played out and the jitter buffer was empty.')
jnxpwTDMPerfCurrentMisOrderDropped = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 5, 1, 4), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMPerfCurrentMisOrderDropped.setStatus('current')
if mibBuilder.loadTexts: jnxpwTDMPerfCurrentMisOrderDropped.setDescription('Number of packets detected out of order(via control word sequence numbers), and could not be re-ordered, or could not fit in the jitter buffer.')
jnxpwTDMPerfCurrentMalformedPkt = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 5, 1, 5), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMPerfCurrentMalformedPkt.setStatus('current')
if mibBuilder.loadTexts: jnxpwTDMPerfCurrentMalformedPkt.setDescription("Number of packets detected with unexpected size, or bad headers' stack")
jnxpwTDMPerfCurrentESs = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 5, 1, 6), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMPerfCurrentESs.setStatus('current')
if mibBuilder.loadTexts: jnxpwTDMPerfCurrentESs.setDescription('The counter associated with the number of Error Seconds encountered. Any malformed packet, seq. error, LOPS and similar are considered as error second')
jnxpwTDMPerfCurrentSESs = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 5, 1, 7), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMPerfCurrentSESs.setStatus('current')
if mibBuilder.loadTexts: jnxpwTDMPerfCurrentSESs.setDescription('The counter associated with the number of Severely Error Seconds encountered. ')
jnxpwTDMPerfCurrentUASs = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 5, 1, 8), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMPerfCurrentUASs.setStatus('current')
if mibBuilder.loadTexts: jnxpwTDMPerfCurrentUASs.setDescription('The counter associated with the number of Unavailable Seconds encountered. Any consequtive ten seconds of SES are counted as one UAS')
jnxpwTDMPerfCurrentFC = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 5, 1, 9), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMPerfCurrentFC.setStatus('current')
if mibBuilder.loadTexts: jnxpwTDMPerfCurrentFC.setDescription('TDM Failure Counts (FC-TDM). The number of TDM failure events. A failure event begins when the LOPS failure is declared, and ends when the failure is cleared. A failure event that begins in one period and ends in another period is counted only in the period in which it begins.')
jnxpwTDMPerfIntervalTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 6), )
if mibBuilder.loadTexts: jnxpwTDMPerfIntervalTable.setStatus('current')
if mibBuilder.loadTexts: jnxpwTDMPerfIntervalTable.setDescription('This table provides performance information per TDM PW similar to the pwTDMPerfCurrentTable above. However, these counts represent historical 15 minute intervals. Typically, this table will have a maximum of 96 entries for a 24 hour period, but is not limited to this. ')
jnxpwTDMPerfIntervalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 6, 1), ).setIndexNames((0, "JUNIPER-VPN-MIB", "jnxVpnPwVpnType"), (0, "JUNIPER-VPN-MIB", "jnxVpnPwVpnName"), (0, "JUNIPER-VPN-MIB", "jnxVpnPwIndex"), (0, "JUNIPER-PW-TDM-MIB", "jnxpwTDMPerfIntervalNumber"))
if mibBuilder.loadTexts: jnxpwTDMPerfIntervalEntry.setStatus('current')
if mibBuilder.loadTexts: jnxpwTDMPerfIntervalEntry.setDescription('An entry in this table is created by the agent for every pwTDMPerfCurrentEntry that is 15 minutes old. The contents of the Current entry are copied to the new entry here. The Current entry, then resets its counts to zero for the next current 15 minute interval. ')
jnxpwTDMPerfIntervalNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 6, 1, 1), Unsigned32())
if mibBuilder.loadTexts: jnxpwTDMPerfIntervalNumber.setStatus('current')
if mibBuilder.loadTexts: jnxpwTDMPerfIntervalNumber.setDescription('A number (normally between 1 and 96 to cover a 24 hour period) which identifies the interval for which the set of statistics is available. The interval identified by 1 is the most recently completed 15 minute interval, and the interval identified by N is the interval immediately preceding the one identified by N-1. The minimum range of N is 1 through 4. The default range is 1 through 32. The maximum value of N is 1 through 96.')
jnxpwTDMPerfIntervalValidData = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 6, 1, 2), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMPerfIntervalValidData.setStatus('current')
if mibBuilder.loadTexts: jnxpwTDMPerfIntervalValidData.setDescription('This variable indicates if the data for this interval is valid.')
jnxpwTDMPerfIntervalDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 6, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMPerfIntervalDuration.setStatus('current')
if mibBuilder.loadTexts: jnxpwTDMPerfIntervalDuration.setDescription("The duration of a particular interval in seconds, Adjustments in the system's time-of-day clock, may cause the interval to be greater or less than, the normal value. Therefore this actual interval value is provided.")
jnxpwTDMPerfIntervalMissingPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 6, 1, 4), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMPerfIntervalMissingPkts.setStatus('current')
if mibBuilder.loadTexts: jnxpwTDMPerfIntervalMissingPkts.setDescription('Number of missing packets (as detected via control word sequence number gaps).')
jnxpwTDMPerfIntervalPktsReOrder = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 6, 1, 5), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMPerfIntervalPktsReOrder.setStatus('current')
if mibBuilder.loadTexts: jnxpwTDMPerfIntervalPktsReOrder.setDescription('Number of packets detected out of sequence (via control word sequence number), but successfully re-ordered. Note: some implementations may not support this Feature.')
jnxpwTDMPerfIntervalJtrBfrUnderruns = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 6, 1, 6), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMPerfIntervalJtrBfrUnderruns.setStatus('current')
if mibBuilder.loadTexts: jnxpwTDMPerfIntervalJtrBfrUnderruns.setDescription('Number of times a packet needed to be played out and the jitter buffer was empty.')
jnxpwTDMPerfIntervalMisOrderDropped = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 6, 1, 7), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMPerfIntervalMisOrderDropped.setStatus('current')
if mibBuilder.loadTexts: jnxpwTDMPerfIntervalMisOrderDropped.setDescription('Number of packets detected out of order(via control word sequence numbers), and could not be re-ordered, or could not fit in the jitter buffer.')
jnxpwTDMPerfIntervalMalformedPkt = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 6, 1, 8), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMPerfIntervalMalformedPkt.setStatus('current')
if mibBuilder.loadTexts: jnxpwTDMPerfIntervalMalformedPkt.setDescription("Number of packets detected with unexpected size, or bad headers' stack")
jnxpwTDMPerfIntervalESs = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 6, 1, 9), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMPerfIntervalESs.setStatus('current')
if mibBuilder.loadTexts: jnxpwTDMPerfIntervalESs.setDescription('The counter associated with the number of Error Seconds encountered.')
jnxpwTDMPerfIntervalSESs = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 6, 1, 10), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMPerfIntervalSESs.setStatus('current')
if mibBuilder.loadTexts: jnxpwTDMPerfIntervalSESs.setDescription('The counter associated with the number of Severely Error Seconds encountered.')
jnxpwTDMPerfIntervalUASs = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 6, 1, 11), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMPerfIntervalUASs.setStatus('current')
if mibBuilder.loadTexts: jnxpwTDMPerfIntervalUASs.setDescription('The counter associated with the number of Unavailable Seconds encountered.')
jnxpwTDMPerfIntervalFC = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 6, 1, 12), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMPerfIntervalFC.setStatus('current')
if mibBuilder.loadTexts: jnxpwTDMPerfIntervalFC.setDescription('TDM Failure Counts (FC-TDM). The number of TDM failure events. A failure event begins when the LOPS failure is declared, and ends when the failure is cleared. A failure event that begins in one period and ends in another period is counted only in the period in which it begins.')
jnxpwTDMPerf1DayIntervalTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 7), )
if mibBuilder.loadTexts: jnxpwTDMPerf1DayIntervalTable.setStatus('current')
if mibBuilder.loadTexts: jnxpwTDMPerf1DayIntervalTable.setDescription('This table provides performance information per TDM PW similar to the pwTDMPerfIntervalTable above. However, these counters represent historical 1 day intervals up to one full month. The table consists of real time data, as such it is not persistence across re-boot.')
jnxpwTDMPerf1DayIntervalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 7, 1), ).setIndexNames((0, "JUNIPER-VPN-MIB", "jnxVpnPwVpnType"), (0, "JUNIPER-VPN-MIB", "jnxVpnPwVpnName"), (0, "JUNIPER-VPN-MIB", "jnxVpnPwIndex"), (0, "JUNIPER-PW-TDM-MIB", "jnxpwTDMPerf1DayIntervalNumber"))
if mibBuilder.loadTexts: jnxpwTDMPerf1DayIntervalEntry.setStatus('current')
if mibBuilder.loadTexts: jnxpwTDMPerf1DayIntervalEntry.setDescription('An entry is created in this table by the agent for every entry in the pwTDMTable table.')
jnxpwTDMPerf1DayIntervalNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 7, 1, 1), Unsigned32())
if mibBuilder.loadTexts: jnxpwTDMPerf1DayIntervalNumber.setStatus('current')
if mibBuilder.loadTexts: jnxpwTDMPerf1DayIntervalNumber.setDescription('The number of interval, where 1 indicates current day measured period and 2 and above indicate previous days respectively')
jnxpwTDMPerf1DayIntervalValidData = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 7, 1, 2), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMPerf1DayIntervalValidData.setStatus('current')
if mibBuilder.loadTexts: jnxpwTDMPerf1DayIntervalValidData.setDescription('This variable indicates if the data for this interval is valid.')
jnxpwTDMPerf1DayIntervalDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 7, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMPerf1DayIntervalDuration.setStatus('current')
if mibBuilder.loadTexts: jnxpwTDMPerf1DayIntervalDuration.setDescription("The duration of a particular interval in seconds, Adjustments in the system's time-of-day clock, may cause the interval to be greater or less than, the normal value. Therefore this actual interval value is provided.")
jnxpwTDMPerf1DayIntervalMissingPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 7, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMPerf1DayIntervalMissingPkts.setStatus('current')
if mibBuilder.loadTexts: jnxpwTDMPerf1DayIntervalMissingPkts.setDescription('Number of missing packets (as detected via control word sequence number gaps).')
jnxpwTDMPerf1DayIntervalPktsReOrder = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 7, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMPerf1DayIntervalPktsReOrder.setStatus('current')
if mibBuilder.loadTexts: jnxpwTDMPerf1DayIntervalPktsReOrder.setDescription('Number of packets detected out of sequence (via control word sequence number), but successfully re-ordered. Note: some implementations may not support this feature.')
jnxpwTDMPerf1DayIntervalJtrBfrUnderruns = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 7, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMPerf1DayIntervalJtrBfrUnderruns.setStatus('current')
if mibBuilder.loadTexts: jnxpwTDMPerf1DayIntervalJtrBfrUnderruns.setDescription('Number of times a packet needed to be played out and the jitter buffer was empty.')
jnxpwTDMPerf1DayIntervalMisOrderDropped = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 7, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMPerf1DayIntervalMisOrderDropped.setStatus('current')
if mibBuilder.loadTexts: jnxpwTDMPerf1DayIntervalMisOrderDropped.setDescription('Number of packets detected out of order(via control word sequence numbers), and could not be re-ordered, or could not fit in the jitter buffer.')
jnxpwTDMPerf1DayIntervalMalformedPkt = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 7, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMPerf1DayIntervalMalformedPkt.setStatus('current')
if mibBuilder.loadTexts: jnxpwTDMPerf1DayIntervalMalformedPkt.setDescription("Number of packets detected with unexpected size, or bad headers' stack.")
jnxpwTDMPerf1DayIntervalESs = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 7, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMPerf1DayIntervalESs.setStatus('current')
if mibBuilder.loadTexts: jnxpwTDMPerf1DayIntervalESs.setDescription('The counter associated with the number of Error Seconds encountered.')
jnxpwTDMPerf1DayIntervalSESs = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 7, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMPerf1DayIntervalSESs.setStatus('current')
if mibBuilder.loadTexts: jnxpwTDMPerf1DayIntervalSESs.setDescription('The counter associated with the number of Severely Error Seconds.')
jnxpwTDMPerf1DayIntervalUASs = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 7, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMPerf1DayIntervalUASs.setStatus('current')
if mibBuilder.loadTexts: jnxpwTDMPerf1DayIntervalUASs.setDescription('The counter associated with the number of UnAvailable Seconds. NOTE: When first entering the UAS state, the number of SES To UAS is added to this object, then as each additional UAS occurs, this object increments by one.')
jnxpwTDMPerf1DayIntervalFC = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 7, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMPerf1DayIntervalFC.setStatus('current')
if mibBuilder.loadTexts: jnxpwTDMPerf1DayIntervalFC.setDescription('TDM Failure Counts (FC-TDM). The number of TDM failure events. A failure event begins when the LOPS failure is declared, and ends when the failure is cleared.')
jnxpwTDMGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 3, 1))
jnxpwTDMCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 3, 2))
jnxpwTDMModuleCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 3, 2, 1)).setObjects(("JUNIPER-PW-TDM-MIB", "jnxpwTDMGroup"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMPerfCurrentGroup"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMPerfIntervalGroup"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMPerf1DayIntervalGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    jnxpwTDMModuleCompliance = jnxpwTDMModuleCompliance.setStatus('current')
if mibBuilder.loadTexts: jnxpwTDMModuleCompliance.setDescription('The compliance statement for agent that support TDM PW over PSN operation.')
jnxpwTDMGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 3, 1, 1)).setObjects(("JUNIPER-PW-TDM-MIB", "jnxpwTDMRate"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMIfIndex"), ("JUNIPER-PW-TDM-MIB", "jnxpwGenTDMCfgIndex"), ("JUNIPER-PW-TDM-MIB", "jnxpwRelTDMCfgIndex"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMConfigError"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMTimeElapsed"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMValidIntervals"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMValidDayIntervals"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMLastEsTimeStamp"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMCfgIndexNext"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMCfgRowStatus"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMCfgPayloadSize"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMCfgPktReorder"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMCfgRtpHdrUsed"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMCfgJtrBfrDepth"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMCfgPayloadSuppression"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMCfgConsecPktsInSynch"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMCfgConsecMissPktsOutSynch"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMCfgSetUp2SynchTimeOut"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMCfgPktReplacePolicy"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMCfgAvePktLossTimeWindow"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMCfgExcessivePktLossThreshold"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMCfgAlarmThreshold"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMCfgClearAlarmThreshold"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMCfgMissingPktsToSes"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMCfgTimestampMode"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMCfgStorageType"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMCfgPktFiller"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMCfgName"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    jnxpwTDMGroup = jnxpwTDMGroup.setStatus('current')
if mibBuilder.loadTexts: jnxpwTDMGroup.setDescription('Collection of objects for basic TDM PW config and status.')
jnxpwTDMPerfCurrentGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 3, 1, 2)).setObjects(("JUNIPER-PW-TDM-MIB", "jnxpwTDMPerfCurrentMissingPkts"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMPerfCurrentPktsReOrder"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMPerfCurrentJtrBfrUnderruns"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMPerfCurrentMisOrderDropped"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMPerfCurrentMalformedPkt"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMPerfCurrentESs"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMPerfCurrentSESs"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMPerfCurrentUASs"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMPerfCurrentFC"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    jnxpwTDMPerfCurrentGroup = jnxpwTDMPerfCurrentGroup.setStatus('current')
if mibBuilder.loadTexts: jnxpwTDMPerfCurrentGroup.setDescription('Collection of current statistics objects for TDM PWs.')
jnxpwTDMPerfIntervalGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 3, 1, 3)).setObjects(("JUNIPER-PW-TDM-MIB", "jnxpwTDMPerfIntervalValidData"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMPerfIntervalDuration"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMPerfIntervalMissingPkts"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMPerfIntervalPktsReOrder"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMPerfIntervalJtrBfrUnderruns"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMPerfIntervalMisOrderDropped"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMPerfIntervalMalformedPkt"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMPerfIntervalESs"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMPerfIntervalSESs"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMPerfIntervalUASs"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMPerfIntervalFC"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    jnxpwTDMPerfIntervalGroup = jnxpwTDMPerfIntervalGroup.setStatus('current')
if mibBuilder.loadTexts: jnxpwTDMPerfIntervalGroup.setDescription('Collection of Interval statistics objects for TDM PWs.')
jnxpwTDMPerf1DayIntervalGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 3, 1, 4)).setObjects(("JUNIPER-PW-TDM-MIB", "jnxpwTDMPerf1DayIntervalValidData"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMPerf1DayIntervalDuration"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMPerf1DayIntervalMissingPkts"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMPerf1DayIntervalPktsReOrder"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMPerf1DayIntervalJtrBfrUnderruns"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMPerf1DayIntervalMisOrderDropped"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMPerf1DayIntervalMalformedPkt"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMPerf1DayIntervalESs"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMPerf1DayIntervalSESs"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMPerf1DayIntervalUASs"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMPerf1DayIntervalFC"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    jnxpwTDMPerf1DayIntervalGroup = jnxpwTDMPerf1DayIntervalGroup.setStatus('current')
if mibBuilder.loadTexts: jnxpwTDMPerf1DayIntervalGroup.setDescription('Collection of Daily statistics objects for TDM PWs.')
mibBuilder.exportSymbols("JUNIPER-PW-TDM-MIB", jnxpwTDMPerf1DayIntervalMissingPkts=jnxpwTDMPerf1DayIntervalMissingPkts, jnxpwTDMLastEsTimeStamp=jnxpwTDMLastEsTimeStamp, jnxpwGenTDMCfgIndex=jnxpwGenTDMCfgIndex, jnxPWTdmMIB=jnxPWTdmMIB, jnxpwTDMCfgEntry=jnxpwTDMCfgEntry, jnxpwTDMPerfIntervalJtrBfrUnderruns=jnxpwTDMPerfIntervalJtrBfrUnderruns, jnxpwTDMPerfIntervalESs=jnxpwTDMPerfIntervalESs, jnxpwTDMGroup=jnxpwTDMGroup, jnxpwRelTDMCfgIndex=jnxpwRelTDMCfgIndex, jnxpwTDMCfgPktFiller=jnxpwTDMCfgPktFiller, jnxpwTDMCfgExcessivePktLossThreshold=jnxpwTDMCfgExcessivePktLossThreshold, jnxpwTDMCfgPktReorder=jnxpwTDMCfgPktReorder, jnxpwTDMPerf1DayIntervalNumber=jnxpwTDMPerf1DayIntervalNumber, jnxpwTDMCfgTimestampMode=jnxpwTDMCfgTimestampMode, jnxpwTDMCfgAvePktLossTimeWindow=jnxpwTDMCfgAvePktLossTimeWindow, jnxpwTDMCfgJtrBfrDepth=jnxpwTDMCfgJtrBfrDepth, jnxpwTDMCfgPayloadSize=jnxpwTDMCfgPayloadSize, jnxpwTDMValidIntervals=jnxpwTDMValidIntervals, jnxpwTDMModuleCompliance=jnxpwTDMModuleCompliance, jnxpwTDMPerf1DayIntervalGroup=jnxpwTDMPerf1DayIntervalGroup, jnxpwTDMPerfIntervalGroup=jnxpwTDMPerfIntervalGroup, jnxpwTDMPerf1DayIntervalEntry=jnxpwTDMPerf1DayIntervalEntry, jnxpwTDMNotifications=jnxpwTDMNotifications, jnxpwTDMPerfIntervalMalformedPkt=jnxpwTDMPerfIntervalMalformedPkt, jnxpwTDMCfgStorageType=jnxpwTDMCfgStorageType, jnxpwTDMPerf1DayIntervalJtrBfrUnderruns=jnxpwTDMPerf1DayIntervalJtrBfrUnderruns, jnxpwTDMPerfIntervalNumber=jnxpwTDMPerfIntervalNumber, jnxpwTDMPerfIntervalUASs=jnxpwTDMPerfIntervalUASs, jnxpwTDMPerf1DayIntervalTable=jnxpwTDMPerf1DayIntervalTable, jnxpwTDMPerfIntervalMissingPkts=jnxpwTDMPerfIntervalMissingPkts, jnxpwTDMCfgName=jnxpwTDMCfgName, jnxpwTDMPerf1DayIntervalDuration=jnxpwTDMPerf1DayIntervalDuration, jnxpwTDMPerfCurrentEntry=jnxpwTDMPerfCurrentEntry, jnxpwTDMCfgClearAlarmThreshold=jnxpwTDMCfgClearAlarmThreshold, jnxpwTDMPerf1DayIntervalPktsReOrder=jnxpwTDMPerf1DayIntervalPktsReOrder, jnxpwTDMPerfCurrentMisOrderDropped=jnxpwTDMPerfCurrentMisOrderDropped, jnxpwTDMRate=jnxpwTDMRate, jnxpwTDMPerf1DayIntervalUASs=jnxpwTDMPerf1DayIntervalUASs, jnxpwTDMCfgPktReplacePolicy=jnxpwTDMCfgPktReplacePolicy, jnxpwTDMCfgMissingPktsToSes=jnxpwTDMCfgMissingPktsToSes, jnxpwTDMPerf1DayIntervalESs=jnxpwTDMPerf1DayIntervalESs, jnxpwTDMPerf1DayIntervalValidData=jnxpwTDMPerf1DayIntervalValidData, jnxpwTDMTable=jnxpwTDMTable, jnxpwTDMPerf1DayIntervalFC=jnxpwTDMPerf1DayIntervalFC, jnxpwTDMPerfIntervalPktsReOrder=jnxpwTDMPerfIntervalPktsReOrder, jnxpwTDMPerfCurrentJtrBfrUnderruns=jnxpwTDMPerfCurrentJtrBfrUnderruns, jnxpwTDMPerf1DayIntervalMisOrderDropped=jnxpwTDMPerf1DayIntervalMisOrderDropped, jnxpwTDMPerfCurrentUASs=jnxpwTDMPerfCurrentUASs, jnxpwTDMPerfCurrentFC=jnxpwTDMPerfCurrentFC, jnxpwTDMCfgConsecPktsInSynch=jnxpwTDMCfgConsecPktsInSynch, jnxpwTDMValidDayIntervals=jnxpwTDMValidDayIntervals, jnxpwTDMPerfCurrentSESs=jnxpwTDMPerfCurrentSESs, jnxpwTDMPerfCurrentGroup=jnxpwTDMPerfCurrentGroup, jnxpwTDMCfgSetUp2SynchTimeOut=jnxpwTDMCfgSetUp2SynchTimeOut, jnxpwTDMIfIndex=jnxpwTDMIfIndex, JnxPwCfgIndexOrzero=JnxPwCfgIndexOrzero, jnxpwTDMPerfIntervalSESs=jnxpwTDMPerfIntervalSESs, jnxpwTDMPerfIntervalDuration=jnxpwTDMPerfIntervalDuration, jnxpwTDMCfgIndex=jnxpwTDMCfgIndex, jnxpwTDMPerfCurrentPktsReOrder=jnxpwTDMPerfCurrentPktsReOrder, jnxpwTDMPerf1DayIntervalSESs=jnxpwTDMPerf1DayIntervalSESs, jnxpwTDMPerfCurrentTable=jnxpwTDMPerfCurrentTable, JnxPwTDMCfgIndex=JnxPwTDMCfgIndex, jnxpwTDMConfigError=jnxpwTDMConfigError, jnxpwTDMCfgPayloadSuppression=jnxpwTDMCfgPayloadSuppression, jnxpwTDMCfgAlarmThreshold=jnxpwTDMCfgAlarmThreshold, jnxpwTDMPerfCurrentMissingPkts=jnxpwTDMPerfCurrentMissingPkts, jnxpwTDMObjects=jnxpwTDMObjects, jnxpwTDMCfgTable=jnxpwTDMCfgTable, jnxpwTDMPerfIntervalValidData=jnxpwTDMPerfIntervalValidData, jnxpwTDMPerfIntervalMisOrderDropped=jnxpwTDMPerfIntervalMisOrderDropped, jnxpwTDMCfgConsecMissPktsOutSynch=jnxpwTDMCfgConsecMissPktsOutSynch, jnxpwTDMPerfIntervalTable=jnxpwTDMPerfIntervalTable, jnxpwTDMCfgRowStatus=jnxpwTDMCfgRowStatus, jnxpwTDMPerfIntervalFC=jnxpwTDMPerfIntervalFC, jnxpwTDMPerfIntervalEntry=jnxpwTDMPerfIntervalEntry, PYSNMP_MODULE_ID=jnxPWTdmMIB, jnxpwTDMPerf1DayIntervalMalformedPkt=jnxpwTDMPerf1DayIntervalMalformedPkt, jnxpwTDMPerfCurrentESs=jnxpwTDMPerfCurrentESs, jnxpwTDMCfgIndexNext=jnxpwTDMCfgIndexNext, jnxpwTDMTimeElapsed=jnxpwTDMTimeElapsed, jnxpwTDMCfgRtpHdrUsed=jnxpwTDMCfgRtpHdrUsed, jnxpwTDMGroups=jnxpwTDMGroups, jnxpwTDMPerfCurrentMalformedPkt=jnxpwTDMPerfCurrentMalformedPkt, jnxpwTDMEntry=jnxpwTDMEntry, jnxpwTDMCompliances=jnxpwTDMCompliances, jnxpwTDMConformance=jnxpwTDMConformance)

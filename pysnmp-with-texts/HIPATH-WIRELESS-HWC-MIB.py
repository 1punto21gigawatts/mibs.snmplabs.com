#
# PySNMP MIB module HIPATH-WIRELESS-HWC-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/HIPATH-WIRELESS-HWC-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:30:43 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ConstraintsIntersection, ValueSizeConstraint, ValueRangeConstraint, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ConstraintsIntersection", "ValueSizeConstraint", "ValueRangeConstraint", "SingleValueConstraint")
hiPathWirelessModules, hiPathWirelessMgmt = mibBuilder.importSymbols("HIPATH-WIRELESS-SMI", "hiPathWirelessModules", "hiPathWirelessMgmt")
WEPKeytype, = mibBuilder.importSymbols("IEEE802dot11-MIB", "WEPKeytype")
ifIndex, InterfaceIndex = mibBuilder.importSymbols("IF-MIB", "ifIndex", "InterfaceIndex")
Ipv6Address, = mibBuilder.importSymbols("IPV6-TC", "Ipv6Address")
ObjectGroup, ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "ModuleCompliance", "NotificationGroup")
iso, MibIdentifier, NotificationType, ModuleIdentity, TimeTicks, MibScalar, MibTable, MibTableRow, MibTableColumn, Unsigned32, Bits, ObjectIdentity, Gauge32, Integer32, Counter64, IpAddress, Counter32 = mibBuilder.importSymbols("SNMPv2-SMI", "iso", "MibIdentifier", "NotificationType", "ModuleIdentity", "TimeTicks", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Unsigned32", "Bits", "ObjectIdentity", "Gauge32", "Integer32", "Counter64", "IpAddress", "Counter32")
TruthValue, DisplayString, MacAddress, RowStatus, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "TruthValue", "DisplayString", "MacAddress", "RowStatus", "TextualConvention")
hiPathWirelessControllerMib = ModuleIdentity((1, 3, 6, 1, 4, 1, 4329, 15, 5, 2))
hiPathWirelessControllerMib.setRevisions(('2016-04-13 13:55', '2016-03-09 16:41', '2015-10-06 17:31', '2015-06-12 12:05', '2015-03-17 10:31', '2014-11-28 17:31', '2014-06-17 15:29', '2014-04-16 14:29', '2014-01-27 14:29', '2013-11-18 10:29', '2013-08-28 11:17', '2013-08-01 15:55', '2013-07-12 16:50', '2013-04-18 15:55', '2012-10-18 11:50', '2012-09-27 11:10', '2012-09-10 14:10', '2012-02-13 19:33', '2011-08-17 14:18', '2011-06-13 13:10', '2011-04-29 16:06', '2011-01-13 13:25', '2010-04-29 17:44', '2010-04-08 16:45', '2010-02-23 15:17', '2009-08-18 12:00', '2009-07-23 12:47', '2009-04-23 17:14', '2009-01-19 13:49', '2008-08-13 14:31', '2007-11-26 16:15', '2007-08-11 16:15', '2007-01-15 13:38', '2005-10-28 13:12',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: hiPathWirelessControllerMib.setRevisionsDescriptions((' - Added wlanAppVisibility to wlanTable.', ' - Added stationIPv6Address1, stationIPv6Address2, and stationIPv6Address3 to stationEventAlarm. - Added apTotalStationsAInOctets, apTotalStationsAOutOctets, apTotalStationsBInOctets, apTotalStationsBOutOctets, apTotalStationsGInOctets, apTotalStationsGOutOctets, apTotalStationsN50InOctets, apTotalStationsN50OutOctets, apTotalStationsN24InOctets, apTotalStationsN24OutOctets, apTotalStationsACInOctets, and apTotalStationsACOutOctets to apStatsTable.', ' - Modified the description of stationEventTimeStamp. - Added more access points (APs) to apPlatforms. - Deprecated topoWireStatTable. - Added topoCompleteStatTable. - Added applyMacAddressFormat to authenticationAdvanced. - Added radiusMacAddressFormatOption to vnsGlobalSetting.', ' - Modified the description of topoStatTable. - Modified the description of apPerformanceReportByRadioTable.', ' - Added wlanRadioManagement11k, wlanBeaconReport, QuietIE, wlanMirrorN, and wlanNetFlow to wlanTable. - Added wlanPrivfastTransition, and wlanPrivManagementFrameProtection to wlanPrivTable. - Added topologyIsGroup, topologyGroupMembers, and topologyMemberId to topologyTable. - Added netflowAndMirrorN Object. It contains netflowDestinationIP, netflowInterval, mirrorFirstN, and mirrorL2Ports. - Added fastTransition(13) to muDot11ConnectionCapability. - Added clearAccessRejectMsg and accessRejectMsgTable. - Added vnsQoSWirelessUseAdmControlBestEffort, and vnsQoSWirelessUseAdmControlBackground to vnsQoSTable. - Added maxBestEffortBWforReassociation, maxBestEffortBWforAssociation, maxBackgroundBWforReassociation, and maxBackgroundBWforAssociation to wirelessQoS. - Added radacctStartOnIPAddr and clientServiceTypeLogin to authenticationAdvanced. - Added apPerformanceReportByRadioTable. - Added apPerformanceReportbyRadioAndWlanTable. - Added apChannelUtilizationTable. - Added apAccessibilityTable. - Added apNeighboursTable.', '- Added topoWireStatTable.', '- Added firewallFriendlyExCP(7) to wlanAuthType. - Added firewallFriendlyExCP(7) to wlanCPAuthType. - Added wlanCPIdentity, wlanCPCustomSpecificURL and wlanCPSelectionOption to wlanCPTable. - Added wlanAuthRadiusOperatorNameSpace, wlanAuthRadiusOperatorName and wlanAuthMACBasedAuthReAuthOnAreaRoam to wlanAuthTable. - Added radiusExtnsSettingTable. - Added authenticationAdvanced. - Added areaChange(12) to stationEventType.', '- Added apLogManagement Objects. - Added apMaintenanceCycle Objects. - Deprecated wlanCPExtTosValue from wlanCPTable. - Deprecated apSSHAccess from apTable. - Added apSSHConnection to apTable. - Added na(3) to apTelnetAccess.', '- Added apRadioAttenuation to apRadioAntennaTable. - Added apRadioStatusTable. - Added apRadioProtocol to apRadioTable. - Deprecated apRadioType from apRadioTable.', '- stationsByProtocol was modified to add stationsByProtocolUnavailable, stationsByProtocolError and stationsByProtocolAC. - Added muDot11ConnectionCapability to muTable. - deprecated muConnectionCapability from muTable. - Added ac(6) to muConnectionProtoco. - Added apInterfaceMTU, apEffectiveTunnelMTU and apTotalStationsAC to apStatsTable. - Added dot11ac(11) and dot11cStrict(12) to apRadioType. - Added wlanAuthRadiusAcctAfterMacBaseAuthorization and wlanAuthRadiusTimeoutRole to wlanAuthTable. - Added wlanPrivWPAversion to wlanPrivTable. - Added jumboFrames to physicalPortObjects. - Added apRegister to apEventId.', '- apTable was modified to add apIPMulticastAssembly.', ' - Added wlanCPUseHTTPSforConnection to wlanCPTable. - Added wlanRadiusServerTable. - Added inSrvScanGrpDetectRogueAP and inSrvScanGrpListeningPort to inServiceScanGroupTable. - Added dedicatedScanGrpDetectRogueAP and dedicatedScanGrpListeningPort to dedicatedScanGroupTable. - Added clientAutologinOption to vnsGlobalSetting. - Added licenseMode, licenseLocalAP, licenseForeignAP, licenseLocalRadarAP and licenseForeignRadarAP to licensingInformation. - Added sysCPUType to systemObjects. - Added adHocModeDevice(6) and rogueAP(7) to dedicatedScanGrpCounterMeasures and inServiceScanGroupTable .', '- Added AccessPoint reigisteration event notification.', '- Added radiusFastFailoverEventsTable. - Addes dhcpRelayListenersTable. - topologyTable was modified to add new topologyDynamicEgress value.. - Added apRadioAntennaTable. - Added stationSessionNotifications trap. - scanGroupAPAssignmentTable was modified to add scanGroupAPAssignControllerIPAddress and scanGroupAPAssignFordwardingService. - scanAPTable was modified to add scanAPProfileName and scanAPProfileType. - Added dedicatedScanGroupTable. - apStatsTable was modified to add apInvalidPolicyCount. - apTable was modified to add apSecureDataTunnelType - uncategorizedAPTable was modified to add uncategorizedAPSSID and deprecate uncategorizedAPDescption.', 'Description changes for object groups: uncategorizedAPGroup, authorizedAPGroup and prohibitedAPGroup.', '- Added radiusStrictMode - Enhance description field of a few variables', "Added support: - widsWips: Configuration and statistic infromation about intrusion detection and prevention. - Controller dashboard information was added under 'dashboard', that includes some controler statistics and lincensing information - wlanSecurityReportTable was created to report on the status of weak WLAN configuration - apAntennaTable was added to provide AP antenna information - MU access list: creating MU access list using set of MAC addresses. - muACLTable is deprecated and replaced by muAccessListTable. - apTable was modified with added new field: apMICErrorWarning", 'Added support: - siteTable: main table to create any site. - sitePolicyTable: The table for assigning policies to a site. - siteCosTable: The table for retrieving assigned CoS to a site. - siteAPTable: Table for assinging APs to a site. - siteWlanTable: Table for assinging WLANs to a site. All tables above can collectively be used to configure a site or retrieve its configuration values. apTable was modified with new value for show its site membership. - WlanAuthTable::wlanAuthReplaceCalledStationIDWithZone was added. - WlanCpTable::wlanCPGuestMaxConcurrentSession was added. - TopologyTable was modified with additional new elements. - apTable was modified with new AP attributes. - muTable::muBSSIDMac was added. - loadGroupTable: more elements were added to this table. - loadGroupTable::loadGroupLoadControl was deprecated and was replaced with two new fields each representing one radio.', 'muTable was modified to show its association to WLAN by including WLAN ID into muTable.', 'secureConnection: This object was added to support weak cipher configuration. VSN related fields were modified: -- vnsFilterRuleDirection, vnsFilterRuleProtocol, vnsFilterRuleEtherType. muTable was modified with added fields: -- muTopologyName, muPolicyName, muDefaultCoS, muConnectionProtocol, muConnectionCapability. More added for configuration of MU Access List: - muACLType, muACLTable. apStatsTable was modified with more new elements: - apTotalStationsA, apTotalStationsB, apTotalStationsG,apTotalStationsN50, apTotalStationsN24.', 'Added layer two physical tables: - layerTwoPortTable Following tables are deprecated due to changes in EWC: - physicalPortsTable - phyDHCPRangeTable HWC (HiPath Wireless Controller) has been replaced with EWC (Enterasys Wireless Controller).', 'Added more tables to reflect WLAN configuration. Detailed WLAN configuration are reflected in new tables: - wlanPrivTable (WLAN privacy configuration) - wlanAuthTable (WLAN authentication configuration) - wlanRadiusTable (RADIUS assignment for each WLAN) - wlanCPTable (WLAN captive portal configuration) - wlanServiceType field was modifed to support mesh. Acess point related changes are: - apStaticMTUSize to apTable - apRadioNumber to apRadioTable - apRadioType to apRadioTable Global advanced filtering mode were added: advancedFilteringMode Following item were not applicable to HWC captive portal anymore and are deprecated: - cpLoginLabel - cpPasswordLabel - cpHeaderURL - cpFooterURL - cpMessage Access point load balancing group are reflected in new tables: - loadGroupTable (load group configuration) - loadGrpRadiosTable (radio assignment to loadGroupTable) - loadGrpWlanTable (WLAN assignment to loadGroupTable) ', 'HWC release 7.31: Enhancement are in the area of: - availability: HWC availability support - vnManagerObjects: Mobility enhancement related to MU counters - tunnelStatsTable: Mobility tunnel stats enhancement such as MU counters - AP stats enhancement in apStatsTable - apRegistration: AP registration and administration configuration fields - topologyTable: Advanced topology configuration fields are added to this table. - topoStatTable: topoStatFrameChkSeqErrors and topoStatFrameTooLongErrors added - WLAN scalars added: wlanMaxEntries, wlanNumEntries, wlanTableNextAvailableIndex - wlanTable: Table of WLAN configuration - wlanStatsTable: WLAN statistics such as clients counts, RADIUS request counts, RAIDUS failed or rejected counters. ', 'Obsoleted following items: - vnsAssignmentMode - vnsParentIfIndex - vnsRateControlProfTable - vnsWDSStatTable - vnsStatTable. These stats are reflected under topology - vnsExceptionStatTable. These stats are reflected under topology.', 'New changes include: - Topology configuratioin - Statistics about topoloy - Exception stat about topology.', 'Added version of the image for sensors.', 'Added SLP status field to VNS configuration table (vnsConfigTable).', 'Added information about sensor management.', 'Added new fields for VNS such as vnsEabled. Added AP filter for ACL list for Access Points', 'Added DNS entries. Aded DAS values Added RADIUS server information', 'DHCP information related to the Controller was added to the MIB.', 'Modified apTable with additional fields.', 'Added WDS VNS.', 'Initial version.',))
if mibBuilder.loadTexts: hiPathWirelessControllerMib.setLastUpdated('201604131355Z')
if mibBuilder.loadTexts: hiPathWirelessControllerMib.setOrganization('Chantry Networks Inc.')
if mibBuilder.loadTexts: hiPathWirelessControllerMib.setContactInfo('Chantry Networks, Inc. 55 Commerce Valley Drive (W), Suite 400 Thornhill, Ontario L3T 7V9, Canada Phone: 1-289-695-3182 Fax: 1 289-695-3299')
if mibBuilder.loadTexts: hiPathWirelessControllerMib.setDescription('The access controller MIB')
class LogEventSeverity(TextualConvention, Integer32):
    description = 'The log event severities used in the access controller.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))
    namedValues = NamedValues(("critical", 1), ("major", 2), ("minor", 3), ("information", 4), ("trace", 5))

class HundredthOfGauge64(TextualConvention, Counter64):
    description = 'This textual convention represents a hundredth of a 64-bit gauge number.'
    status = 'current'
    displayHint = 'd-2'

class HundredthOfGauge32(TextualConvention, Gauge32):
    description = 'This textual convention represents a hundredth of a gauge number.'
    status = 'current'
    displayHint = 'd-2'

class HundredthOfInt32(TextualConvention, Integer32):
    description = 'This textual convention represents a hundredth of an integer number.'
    status = 'current'
    displayHint = 'd-2'

hiPathWirelessController = MibIdentifier((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2))
systemObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 1))
sysSoftwareVersion = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 1, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSoftwareVersion.setStatus('current')
if mibBuilder.loadTexts: sysSoftwareVersion.setDescription('System software version.')
sysLogLevel = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 1, 2), LogEventSeverity()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysLogLevel.setStatus('current')
if mibBuilder.loadTexts: sysLogLevel.setDescription('Sets the level of events which are written to the system log.')
sysSerialNo = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSerialNo.setStatus('current')
if mibBuilder.loadTexts: sysSerialNo.setDescription('System serial number.')
sysLogSupport = MibIdentifier((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 1, 4))
hiPathWirelessAppLogFacility = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 1, 4, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("local0", 0), ("local1", 1), ("local2", 2), ("local3", 3), ("local4", 4), ("local5", 5), ("local6", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hiPathWirelessAppLogFacility.setStatus('current')
if mibBuilder.loadTexts: hiPathWirelessAppLogFacility.setDescription('The application log facility level for syslog.')
serviceLogFacility = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 1, 4, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("local0", 0), ("local1", 1), ("local2", 2), ("local3", 3), ("local4", 4), ("local5", 5), ("local6", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: serviceLogFacility.setStatus('current')
if mibBuilder.loadTexts: serviceLogFacility.setDescription('The service log facility level for syslog.')
includeAllServiceMessages = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 1, 4, 3), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: includeAllServiceMessages.setStatus('current')
if mibBuilder.loadTexts: includeAllServiceMessages.setDescription('Indicates if DHCP messages should also be forwarded to syslog.')
sysLogServersTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 1, 4, 4), )
if mibBuilder.loadTexts: sysLogServersTable.setStatus('current')
if mibBuilder.loadTexts: sysLogServersTable.setDescription('Table of syslog servers to forward logging messages.')
sysLogServersEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 1, 4, 4, 1), ).setIndexNames((0, "HIPATH-WIRELESS-HWC-MIB", "sysLogServerIndex"))
if mibBuilder.loadTexts: sysLogServersEntry.setStatus('current')
if mibBuilder.loadTexts: sysLogServersEntry.setDescription('Configuration information for an external syslog server.')
sysLogServerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 1, 4, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysLogServerIndex.setStatus('current')
if mibBuilder.loadTexts: sysLogServerIndex.setDescription('Table index for the syslog server.')
sysLogServerEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 1, 4, 4, 1, 2), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysLogServerEnabled.setStatus('current')
if mibBuilder.loadTexts: sysLogServerEnabled.setDescription('Indicates if messages are to be sent to the syslog server.')
sysLogServerIP = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 1, 4, 4, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysLogServerIP.setStatus('current')
if mibBuilder.loadTexts: sysLogServerIP.setDescription('syslog server IP address.')
sysLogServerPort = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 1, 4, 4, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysLogServerPort.setStatus('current')
if mibBuilder.loadTexts: sysLogServerPort.setDescription('syslog server port number.')
sysLogServerRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 1, 4, 4, 1, 5), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysLogServerRowStatus.setStatus('current')
if mibBuilder.loadTexts: sysLogServerRowStatus.setDescription('RowStatus for operating on syslogServersTable.')
sysCPUType = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysCPUType.setStatus('current')
if mibBuilder.loadTexts: sysCPUType.setDescription("Wireless controller's CPU type")
apLogManagement = MibIdentifier((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 1, 6))
apLogCollectionEnable = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 1, 6, 1), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apLogCollectionEnable.setStatus('current')
if mibBuilder.loadTexts: apLogCollectionEnable.setDescription('If this field is set to true, then the AP log collection feature is enabled.')
apLogFrequency = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 1, 6, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apLogFrequency.setStatus('current')
if mibBuilder.loadTexts: apLogFrequency.setDescription('Number of log collections performed daily. The number must be one of the following 1, 2, 4, 6.')
apLogDestination = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 1, 6, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("local", 0), ("flash", 1), ("remote", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apLogDestination.setStatus('current')
if mibBuilder.loadTexts: apLogDestination.setDescription('Destination where the log file will be stored. If the local flash is not mounted, then you can not select 1. 0 : local memory. 1 : flash. 2 : remote location. ')
apLogFTProtocol = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 1, 6, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ftp", 0), ("scp", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apLogFTProtocol.setStatus('current')
if mibBuilder.loadTexts: apLogFTProtocol.setDescription('File transfer protocol. This field has meaning only when apLogDestination is set to remote(2). 0 : ftp. 1 : scp.')
apLogServerIP = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 1, 6, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apLogServerIP.setStatus('current')
if mibBuilder.loadTexts: apLogServerIP.setDescription('The IP address of the remote server. This field has meaning only when apLogDestination is set to remote(2).')
apLogUserId = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 1, 6, 6), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apLogUserId.setStatus('current')
if mibBuilder.loadTexts: apLogUserId.setDescription('The user ID that is used for access to the remote server. This field has meaning only when apLogDestination is set to remote(2).')
apLogPassword = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 1, 6, 7), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apLogPassword.setStatus('current')
if mibBuilder.loadTexts: apLogPassword.setDescription('The user password that is used for access to the remote server. This field has meaning only when apLogDestination is set to remote(2). This field can only be viewed in SNMPv3 mode with privacy.')
apLogDirectory = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 1, 6, 8), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apLogDirectory.setStatus('current')
if mibBuilder.loadTexts: apLogDirectory.setDescription('The directory of the remote server. This field has meaning only when apLogDestination is set to remote(2).')
apLogSelectedAPsTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 1, 6, 9), )
if mibBuilder.loadTexts: apLogSelectedAPsTable.setStatus('current')
if mibBuilder.loadTexts: apLogSelectedAPsTable.setDescription('Table containing a list of APs for which log collection is supported.')
apLogSelectedAPsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 1, 6, 9, 1), ).setIndexNames((0, "HIPATH-WIRELESS-HWC-MIB", "apSerialNo"))
if mibBuilder.loadTexts: apLogSelectedAPsEntry.setStatus('current')
if mibBuilder.loadTexts: apLogSelectedAPsEntry.setDescription('Configuration information of an AP which supports the AP log feature.')
apSerialNo = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 1, 6, 9, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16))
if mibBuilder.loadTexts: apSerialNo.setStatus('current')
if mibBuilder.loadTexts: apSerialNo.setDescription("Table index for the apLogSelectedAPs. The AP's serial number serves as the index.")
select = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 1, 6, 9, 1, 2), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: select.setStatus('current')
if mibBuilder.loadTexts: select.setDescription('Indicates whether logs are collected from the AP.')
apLogQuickSelectedOption = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 1, 6, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("unknown", 0), ("addAll", 1), ("addAllLocal", 2), ("addAllForeign", 3), ("removeAll", 4), ("removeAllLocal", 5), ("removeAllForeign", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apLogQuickSelectedOption.setStatus('current')
if mibBuilder.loadTexts: apLogQuickSelectedOption.setDescription("This is a quick select option for the user to perform the AP's bulk selection. This field is write-only and read access returns unknown(0) value. 0 : unknown. 1 : add all APs. 2 : add all local APs. 3 : add all foreign APs. 4 : remove all APs. 5 : remove all local APs. 6 : remove all foreign APs.")
apLogFileUtility = MibIdentifier((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 1, 7))
apLogFileUtilityLimit = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 1, 7, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apLogFileUtilityLimit.setStatus('current')
if mibBuilder.loadTexts: apLogFileUtilityLimit.setDescription('The maximum number of AP log file copy requests that can be held in the apLogFileCopyTable. A value of 0 indicates no configured limit.')
apLogFileUtilityCurrent = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 1, 7, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apLogFileUtilityCurrent.setStatus('current')
if mibBuilder.loadTexts: apLogFileUtilityCurrent.setDescription('The number of AP log file copy requests currently in the apLogFileCopyTable.')
apLogFileCopyTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 1, 7, 5), )
if mibBuilder.loadTexts: apLogFileCopyTable.setStatus('current')
if mibBuilder.loadTexts: apLogFileCopyTable.setDescription('List of AP log file copy requests.')
apLogFileCopyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 1, 7, 5, 1), ).setIndexNames((0, "HIPATH-WIRELESS-HWC-MIB", "apLogFileCopyIndex"))
if mibBuilder.loadTexts: apLogFileCopyEntry.setStatus('current')
if mibBuilder.loadTexts: apLogFileCopyEntry.setDescription('An entry describing the AP log file copy request.')
apLogFileCopyIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 1, 7, 5, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: apLogFileCopyIndex.setStatus('current')
if mibBuilder.loadTexts: apLogFileCopyIndex.setDescription('The index for this AP log file copy request.')
apLogFileCopyDestination = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 1, 7, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("flash", 1), ("remoteServer", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apLogFileCopyDestination.setStatus('current')
if mibBuilder.loadTexts: apLogFileCopyDestination.setDescription('Destination where the log file will be copied. If the local flash is not mounted, then you can not select 1. 1 : copy the local AP log file to flash. 2 : copy the local AP log file to remote server. ')
apLogFileCopyProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 1, 7, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ftp", 0), ("scp", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apLogFileCopyProtocol.setStatus('current')
if mibBuilder.loadTexts: apLogFileCopyProtocol.setDescription('File transfer protocol to be used to copy the log file. 0 : ftp. 1 : scp.')
apLogFileCopyServerIP = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 1, 7, 5, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apLogFileCopyServerIP.setStatus('current')
if mibBuilder.loadTexts: apLogFileCopyServerIP.setDescription('The IP address of the remote server.')
apLogFileCopyUserID = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 1, 7, 5, 1, 5), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apLogFileCopyUserID.setStatus('current')
if mibBuilder.loadTexts: apLogFileCopyUserID.setDescription('The user ID that is used for access to the remote server.')
apLogFileCopyPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 1, 7, 5, 1, 6), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apLogFileCopyPassword.setStatus('current')
if mibBuilder.loadTexts: apLogFileCopyPassword.setDescription('The user password that is used for access to the remote server. This field can only be viewed in SNMPv3 mode with privacy.')
apLogFileCopyServerDirectory = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 1, 7, 5, 1, 7), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apLogFileCopyServerDirectory.setStatus('current')
if mibBuilder.loadTexts: apLogFileCopyServerDirectory.setDescription('The directory on the remote server.')
apLogFileCopyOperation = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 1, 7, 5, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("start", 1)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: apLogFileCopyOperation.setStatus('current')
if mibBuilder.loadTexts: apLogFileCopyOperation.setDescription('If this field is set to 1, then the controller will start to perform the copy action.')
apLogFileCopyOperationStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 1, 7, 5, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("inactive", 1), ("pending", 2), ("running", 3), ("success", 4), ("failure", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apLogFileCopyOperationStatus.setStatus('current')
if mibBuilder.loadTexts: apLogFileCopyOperationStatus.setDescription('The operational state of the AP log file copy request. inactive - Indicates that the RowStatus of this conceptual row is not in the `active` state. pending - Indicates that the AP log file copy described by this row is ready to run and waiting in a queue. running - Indicates that the AP log file copy described by this row is running. success - Indicates that the AP log file copy described by this row has successfully run to completion. failure - Indicates that the AP log file copy described by this row has failed to run to completion.')
apLogFileCopyRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 1, 7, 5, 1, 10), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: apLogFileCopyRowStatus.setStatus('current')
if mibBuilder.loadTexts: apLogFileCopyRowStatus.setDescription('Row status variable for row operations on the apLogFileCopyTable.')
dnsObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 2))
primaryDNS = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 2, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: primaryDNS.setStatus('current')
if mibBuilder.loadTexts: primaryDNS.setDescription('Primary DNS address configured in the Controller.')
secondaryDNS = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 2, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: secondaryDNS.setStatus('current')
if mibBuilder.loadTexts: secondaryDNS.setDescription('Secondary DNS address configured in the Controller.')
tertiaryDNS = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 2, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tertiaryDNS.setStatus('current')
if mibBuilder.loadTexts: tertiaryDNS.setDescription('Third DNS address configured in the Controller.')
mgmtPortObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 3))
mgmtPortIfIndex = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 3, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mgmtPortIfIndex.setStatus('current')
if mibBuilder.loadTexts: mgmtPortIfIndex.setDescription('ifIndex of the management port.')
mgmtPortHostname = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 3, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mgmtPortHostname.setStatus('current')
if mibBuilder.loadTexts: mgmtPortHostname.setDescription('Hostname of the management port.')
mgmtPortDomain = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 3, 5), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mgmtPortDomain.setStatus('current')
if mibBuilder.loadTexts: mgmtPortDomain.setDescription('Domain of the management port.')
physicalPortObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 4))
physicalPortCount = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 4, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: physicalPortCount.setStatus('current')
if mibBuilder.loadTexts: physicalPortCount.setDescription('Number of rows in routerPortsTable.')
physicalPortsTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 4, 2), )
if mibBuilder.loadTexts: physicalPortsTable.setStatus('deprecated')
if mibBuilder.loadTexts: physicalPortsTable.setDescription('Table of router ports on the controller.')
physicalPortsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 4, 2, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: physicalPortsEntry.setStatus('deprecated')
if mibBuilder.loadTexts: physicalPortsEntry.setDescription('An entry in routerPortsTable.')
portMgmtTrafficEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 4, 2, 1, 1), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portMgmtTrafficEnable.setStatus('deprecated')
if mibBuilder.loadTexts: portMgmtTrafficEnable.setDescription('Determines whether controller management network traffic is allowed over this interface.')
portDuplexMode = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 4, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("full", 1), ("half", 2), ("auto", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portDuplexMode.setStatus('deprecated')
if mibBuilder.loadTexts: portDuplexMode.setDescription('Duplex mode for the esa ports.')
portFunction = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 4, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("router", 1), ("host", 2), ("thirdPartyAP", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portFunction.setStatus('deprecated')
if mibBuilder.loadTexts: portFunction.setDescription('Specifies the behavior of the EWC physical ports.')
portEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 4, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portEnabled.setStatus('deprecated')
if mibBuilder.loadTexts: portEnabled.setDescription('If enabled, the interface administratively is enabled.')
portName = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 4, 2, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portName.setStatus('deprecated')
if mibBuilder.loadTexts: portName.setDescription('A textual string containing information about the port.')
portIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 4, 2, 1, 6), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portIpAddress.setStatus('deprecated')
if mibBuilder.loadTexts: portIpAddress.setDescription('The IP address of this port.')
portMask = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 4, 2, 1, 7), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portMask.setStatus('deprecated')
if mibBuilder.loadTexts: portMask.setDescription('The subnet mask associated with the IP address of this port.')
portMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 4, 2, 1, 8), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portMacAddress.setStatus('deprecated')
if mibBuilder.loadTexts: portMacAddress.setDescription("Port's MAC address.")
portVlanID = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 4, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 4094)).clone(-1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portVlanID.setStatus('deprecated')
if mibBuilder.loadTexts: portVlanID.setDescription('External VLAN tag for the physical port for trasmitted and received packets. Value ranges: (-1) it is not tagged, zero(0) means reserved, 1-4094 tag value.')
portDHCPEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 4, 2, 1, 10), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portDHCPEnable.setStatus('deprecated')
if mibBuilder.loadTexts: portDHCPEnable.setDescription('If enabled, the controller is configured as default DHCP server for AP.')
portDHCPGateway = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 4, 2, 1, 11), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portDHCPGateway.setStatus('deprecated')
if mibBuilder.loadTexts: portDHCPGateway.setDescription('Gateway address to be supplied to the wireless clients if controller is configured as default DHCP server for AP.')
portDHCPDomain = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 4, 2, 1, 12), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portDHCPDomain.setStatus('deprecated')
if mibBuilder.loadTexts: portDHCPDomain.setDescription('Domain name to be supplied to the wireless clients if controller is configured as default DHCP server for AP.')
portDHCPDefaultLease = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 4, 2, 1, 13), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portDHCPDefaultLease.setStatus('deprecated')
if mibBuilder.loadTexts: portDHCPDefaultLease.setDescription('Default DHCP lease time in seconds to be supplied to the wireless clients if controller is configured as default DHCP server for AP.')
portDHCPMaxLease = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 4, 2, 1, 14), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portDHCPMaxLease.setStatus('deprecated')
if mibBuilder.loadTexts: portDHCPMaxLease.setDescription('Maximum DHCP lease time in seconds to be supplied to the wireless clients if controller is configured as default DHCP server for AP.')
portDHCPDnsServers = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 4, 2, 1, 15), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portDHCPDnsServers.setStatus('deprecated')
if mibBuilder.loadTexts: portDHCPDnsServers.setDescription('List of DNSs to be supplied to the wireless clients if controller is configured as default DHCP server for AP.')
portDHCPWins = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 4, 2, 1, 16), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portDHCPWins.setStatus('deprecated')
if mibBuilder.loadTexts: portDHCPWins.setDescription('List of WINSs to be supplied to the wireless clients if controller is configured as default DHCP server for AP.')
physicalPortsInternalVlanID = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 4, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 4094)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: physicalPortsInternalVlanID.setStatus('current')
if mibBuilder.loadTexts: physicalPortsInternalVlanID.setDescription('Internal VLAN tag to be used for physical ports for which the exernal VLAN tag have not been configured. Value ranges: (-1) it is not tagged, zero(0) means reserved, 1-4094 tag value.')
physicalFlash = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 4, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("mounted", 1), ("unmounted", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: physicalFlash.setStatus('current')
if mibBuilder.loadTexts: physicalFlash.setDescription('Flash drive status.')
phyDHCPRangeTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 4, 5), )
if mibBuilder.loadTexts: phyDHCPRangeTable.setStatus('deprecated')
if mibBuilder.loadTexts: phyDHCPRangeTable.setDescription('phyDHCPRangeTable contains the IP address ranges that DHCP will serve to clients associated with physical ports.')
phyDHCPRangeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 4, 5, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "HIPATH-WIRELESS-HWC-MIB", "phyDHCPRangeIndex"))
if mibBuilder.loadTexts: phyDHCPRangeEntry.setStatus('deprecated')
if mibBuilder.loadTexts: phyDHCPRangeEntry.setDescription('Configuration information for a DHCP range.')
phyDHCPRangeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 4, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: phyDHCPRangeIndex.setStatus('deprecated')
if mibBuilder.loadTexts: phyDHCPRangeIndex.setDescription('Index for the DHCP row element.')
phyDHCPRangeStart = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 4, 5, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: phyDHCPRangeStart.setStatus('deprecated')
if mibBuilder.loadTexts: phyDHCPRangeStart.setDescription('First IP address in the range.')
phyDHCPRangeEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 4, 5, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: phyDHCPRangeEnd.setStatus('deprecated')
if mibBuilder.loadTexts: phyDHCPRangeEnd.setDescription('Last IP address in the range.')
phyDHCPRangeType = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 4, 5, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("inclusion", 1), ("exclusion", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: phyDHCPRangeType.setStatus('deprecated')
if mibBuilder.loadTexts: phyDHCPRangeType.setDescription('Determines whether addresses in the specified range will be included, or excluded by the DHCP server.')
phyDHCPRangeStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 4, 5, 1, 5), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: phyDHCPRangeStatus.setStatus('deprecated')
if mibBuilder.loadTexts: phyDHCPRangeStatus.setDescription('Row status variable for row operations on the phyDHCPRangeTable')
layerTwoPortTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 4, 6), )
if mibBuilder.loadTexts: layerTwoPortTable.setStatus('current')
if mibBuilder.loadTexts: layerTwoPortTable.setDescription('This table contains all layer two ports.')
layerTwoPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 4, 6, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: layerTwoPortEntry.setStatus('current')
if mibBuilder.loadTexts: layerTwoPortEntry.setDescription('Entry for a layer two port.')
layerTwoPortName = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 4, 6, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: layerTwoPortName.setStatus('current')
if mibBuilder.loadTexts: layerTwoPortName.setDescription('Text string identifying the port within the controller.')
layerTwoPortMgmtState = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 4, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: layerTwoPortMgmtState.setStatus('current')
if mibBuilder.loadTexts: layerTwoPortMgmtState.setDescription('This value indicates administrator state of the port. ')
layerTwoPortMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 4, 6, 1, 3), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: layerTwoPortMacAddress.setStatus('current')
if mibBuilder.loadTexts: layerTwoPortMacAddress.setDescription("Port's MAC address.")
jumboFrames = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 4, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: jumboFrames.setStatus('current')
if mibBuilder.loadTexts: jumboFrames.setDescription('Enables support for frames up to 1800 bytes long. jumboFrames support only applies to the controller and compatible APs.')
vnManagerObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 5))
vnRole = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 5, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("vnMgr", 2), ("vnAgent", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnRole.setStatus('current')
if mibBuilder.loadTexts: vnRole.setDescription('Specifies the role of this EWC in inter-EWC mobility. None indicates that mobile units cannot roam to or from this EWC. In any EWC cluster, only one EWC should be specified as vnMgr, all others should be have vnRole = vnAgent.')
vnIfIndex = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 5, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnIfIndex.setStatus('current')
if mibBuilder.loadTexts: vnIfIndex.setDescription('ifIndex of the physical port where inter-EWC tunnels terminate. This field has meaning if vnRole is not none(1)')
vnHeartbeatInterval = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 5, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnHeartbeatInterval.setStatus('current')
if mibBuilder.loadTexts: vnHeartbeatInterval.setDescription('The time interval between inter-EWC polling messages. This field has meaning if vnRole is not none(1)')
vnLocalClients = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 5, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vnLocalClients.setStatus('current')
if mibBuilder.loadTexts: vnLocalClients.setDescription('Number of locally associated clients to this controller that is considered to be their home controller in the mobility zone, which this controller is part of.')
vnForeignClients = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 5, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vnForeignClients.setStatus('current')
if mibBuilder.loadTexts: vnForeignClients.setDescription('Number of clients that have registered with another controller in the mobility zone, which this controller is part of, and currently have roamed to this controller.')
vnTotalClients = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 5, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vnTotalClients.setStatus('current')
if mibBuilder.loadTexts: vnTotalClients.setDescription('Number of local and foreign clients on this controller in the Mobility zone.')
ntpObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 6))
ntpEnabled = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 6, 1), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntpEnabled.setStatus('current')
if mibBuilder.loadTexts: ntpEnabled.setDescription('Enable or disables support for the Network Time Protocol (NTP).')
ntpTimezone = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 6, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntpTimezone.setStatus('current')
if mibBuilder.loadTexts: ntpTimezone.setDescription('Specifies the time zone where this EWC resides.')
ntpTimeServer1 = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 6, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntpTimeServer1.setStatus('current')
if mibBuilder.loadTexts: ntpTimeServer1.setDescription('Primary NTP server.')
ntpTimeServer2 = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 6, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntpTimeServer2.setStatus('current')
if mibBuilder.loadTexts: ntpTimeServer2.setDescription('Secondary NTP server.')
ntpTimeServer3 = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 6, 5), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntpTimeServer3.setStatus('current')
if mibBuilder.loadTexts: ntpTimeServer3.setDescription('Tertiary NTP server.')
ntpServerEnabled = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 6, 6), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntpServerEnabled.setStatus('current')
if mibBuilder.loadTexts: ntpServerEnabled.setDescription('Enable or disables support for controller as NTP server.')
controllerStats = MibIdentifier((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 7))
tunnelsTxRxBytes = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 7, 1), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tunnelsTxRxBytes.setStatus('current')
if mibBuilder.loadTexts: tunnelsTxRxBytes.setDescription('Sum of transmitted and received bytes over all existing tunnels.')
tunnelCount = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 7, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tunnelCount.setStatus('current')
if mibBuilder.loadTexts: tunnelCount.setDescription('Number of connections to other WirelessController controllers.')
tunnelStatsTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 7, 7), )
if mibBuilder.loadTexts: tunnelStatsTable.setStatus('current')
if mibBuilder.loadTexts: tunnelStatsTable.setDescription('tunnelStatsTable contains a list of the IP tunnels connected to this EWC for use in inter-EWC mobility.')
tunnelStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 7, 7, 1), ).setIndexNames((0, "HIPATH-WIRELESS-HWC-MIB", "tunnelStartIP"), (0, "HIPATH-WIRELESS-HWC-MIB", "tunnelEndIP"))
if mibBuilder.loadTexts: tunnelStatsEntry.setStatus('current')
if mibBuilder.loadTexts: tunnelStatsEntry.setDescription('Statistics for a mobility tunnel.')
tunnelStartIP = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 7, 7, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tunnelStartIP.setStatus('current')
if mibBuilder.loadTexts: tunnelStartIP.setDescription('IP address for the start of the tunnel.')
tunnelStartHWC = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 7, 7, 1, 2), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tunnelStartHWC.setStatus('current')
if mibBuilder.loadTexts: tunnelStartHWC.setDescription('Name of the access controller for the start of the tunnel.')
tunnelEndIP = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 7, 7, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tunnelEndIP.setStatus('current')
if mibBuilder.loadTexts: tunnelEndIP.setDescription('IP address for the end of the tunnel.')
tunnelEndHWC = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 7, 7, 1, 4), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tunnelEndHWC.setStatus('current')
if mibBuilder.loadTexts: tunnelEndHWC.setDescription('Name of the access controller for the end of the tunnel.')
tunnelStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 7, 7, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disconnected", 1), ("connected", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tunnelStatus.setStatus('current')
if mibBuilder.loadTexts: tunnelStatus.setDescription('Indicates if the mobility tunnel is up or down.')
tunnelStatsTxBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 7, 7, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tunnelStatsTxBytes.setStatus('current')
if mibBuilder.loadTexts: tunnelStatsTxBytes.setDescription('Number of bytes have been transmitted from the controller at the start of the tunnel to the controller on the other end of the tunnel.')
tunnelStatsRxBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 7, 7, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tunnelStatsRxBytes.setStatus('current')
if mibBuilder.loadTexts: tunnelStatsRxBytes.setDescription('Number of bytes have been received by the controller at the end of the tunnel from the controller at the start of the tunnel.')
tunnelStatsTxRxBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 7, 7, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tunnelStatsTxRxBytes.setStatus('current')
if mibBuilder.loadTexts: tunnelStatsTxRxBytes.setDescription('Sum of transmitted and received bytes over this tunnel.')
clearAccessRejectMsg = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 7, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("clear", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: clearAccessRejectMsg.setStatus('current')
if mibBuilder.loadTexts: clearAccessRejectMsg.setDescription('Set this OID to one to erase the contents of the accessRejectMessage table. The OID always returns 0 when read.')
accessRejectMsgTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 7, 9), )
if mibBuilder.loadTexts: accessRejectMsgTable.setStatus('current')
if mibBuilder.loadTexts: accessRejectMsgTable.setDescription('This table lists each of the reply messages returned in RADIUS Access-Reject messages and for each reply message, a count of the number of times it has been received.')
accessRejectMsgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 7, 9, 1), ).setIndexNames((0, "HIPATH-WIRELESS-HWC-MIB", "armIndex"))
if mibBuilder.loadTexts: accessRejectMsgEntry.setStatus('current')
if mibBuilder.loadTexts: accessRejectMsgEntry.setDescription('One entry consisting of a unique Access-Reject Reply-Message (accessRejectReplyMessage) and count of this message.')
armIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 7, 9, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100)))
if mibBuilder.loadTexts: armIndex.setStatus('current')
if mibBuilder.loadTexts: armIndex.setDescription('A number uniquely identifying each conceptual row in the accessRejectMsgTable. ')
armCount = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 7, 9, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: armCount.setStatus('current')
if mibBuilder.loadTexts: armCount.setDescription('Count of the number of times the controller has received an Access-Reject response from a RADIUS server that contained the associated armReplyMessage.')
armReplyMessage = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 7, 9, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: armReplyMessage.setStatus('current')
if mibBuilder.loadTexts: armReplyMessage.setDescription('A reply message attribute received by the controller from a RADIUS server in an Access-Reject message.')
availability = MibIdentifier((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 8))
availabilityStatus = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 8, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("standalone", 0), ("paired", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: availabilityStatus.setStatus('current')
if mibBuilder.loadTexts: availabilityStatus.setDescription('This field can be used to enable or disable availability. If it is set to paired(1), then availability is enabled on this controller, otherwise it is considered that the controller operates in stand-alone mode. All other availability fields have no meaning if this field is set to standalone(0).')
pairIPAddress = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 8, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pairIPAddress.setStatus('current')
if mibBuilder.loadTexts: pairIPAddress.setDescription('IP address of paired controller in availability pairing mode.')
hwcAvailabilityRank = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 8, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("notConfigured", 0), ("secondary", 1), ("primary", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwcAvailabilityRank.setStatus('current')
if mibBuilder.loadTexts: hwcAvailabilityRank.setDescription('Rank of controller in Availability pairing mode. This is legacy field and applies to releases before 5.x and in current releases it is used for reporting only.')
fastFailover = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 8, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fastFailover.setStatus('current')
if mibBuilder.loadTexts: fastFailover.setDescription('Enables or disables fast failover when controller operates in Availability pairing mode.')
detectLinkFailure = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 8, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(2, 30)).clone(10)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: detectLinkFailure.setStatus('current')
if mibBuilder.loadTexts: detectLinkFailure.setDescription('Time to detect link failure between two controllers in availability pairing. The value can be set to values between 2-30 seconds')
synchronizeSystemConfig = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 8, 6), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: synchronizeSystemConfig.setStatus('current')
if mibBuilder.loadTexts: synchronizeSystemConfig.setDescription('If this flag is set to enabled then system configuration is synchronized between paired controllers operating in Availabilty pairing mode.')
synchronizeGuestPort = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 8, 7), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: synchronizeGuestPort.setStatus('current')
if mibBuilder.loadTexts: synchronizeGuestPort.setDescription('If this flag is set to enabled then Guest Portal user accounts are synchronized between paired controllers operating in Availabilty pairing mode.')
secureConnection = MibIdentifier((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 9))
weakCipherEnable = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 9, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: weakCipherEnable.setStatus('current')
if mibBuilder.loadTexts: weakCipherEnable.setDescription('By default usage of weak cipher is enabled on EWC. Weak cipher can be disabled using this field. ')
dashboard = MibIdentifier((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 10))
licensingInformation = MibIdentifier((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 10, 1))
licenseRegulatoryDomain = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 10, 1, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseRegulatoryDomain.setStatus('current')
if mibBuilder.loadTexts: licenseRegulatoryDomain.setDescription('Regulatory domain that this wireless controller system has been licensed for to operate.')
licenseType = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("permanent", 1), ("temporary", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseType.setStatus('current')
if mibBuilder.loadTexts: licenseType.setDescription('Type of license for the controller. Temporary lincese allows controller to operate within defined number of days after which a permanent license is required for the operation of the controller system.')
licenseDaysRemaining = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 10, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseDaysRemaining.setStatus('current')
if mibBuilder.loadTexts: licenseDaysRemaining.setDescription('Number of days is left for the temporary license to expire. This value has meaning if the license type is temporary(1).')
licenseAvailableAP = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 10, 1, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseAvailableAP.setStatus('current')
if mibBuilder.loadTexts: licenseAvailableAP.setDescription('If licenseMode is standAlone, this is the maximum number of APs that can be active on the controller without violating the licensing agreement. If licenseMode is availabilityPaired, this is the maximum number of APs that can be active on both members of the availability pair without violating the licensing agreement.')
licenseInServiceRadarAP = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 10, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseInServiceRadarAP.setStatus('current')
if mibBuilder.loadTexts: licenseInServiceRadarAP.setDescription('If licenseMode is standalone this is the maximum number of APs that can be active on this controller and can operate as Guardians or in-service Radar APs without violating the licensing agreement. If licenseMode is availabilityPaired, this is the maximum number of APs that can be active on both members of the availability pair and can operate as Guardians or in-service Radar APs without violating the licensing agreement.')
licenseMode = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("standAlone", 1), ("availabilityPaired", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseMode.setStatus('current')
if mibBuilder.loadTexts: licenseMode.setDescription('License mode determines how to interpret the license capacity OIDs. licenseMode is standalone if the controller is not part of an availability pair. licenseMode is availabilityPaired if the controller is part of an availability pair.')
licenseLocalAP = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 10, 1, 7), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseLocalAP.setStatus('current')
if mibBuilder.loadTexts: licenseLocalAP.setDescription('The total number of AP capacity licenses installed on this controller. ')
licenseForeignAP = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 10, 1, 8), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseForeignAP.setStatus('current')
if mibBuilder.loadTexts: licenseForeignAP.setDescription("The total number of AP capacity licenses installed on this controller's availability partner.")
licenseLocalRadarAP = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 10, 1, 9), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseLocalRadarAP.setStatus('current')
if mibBuilder.loadTexts: licenseLocalRadarAP.setDescription('The total number of AP Radar capacity licenses installed on this controller.')
licenseForeignRadarAP = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 10, 1, 10), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseForeignRadarAP.setStatus('current')
if mibBuilder.loadTexts: licenseForeignRadarAP.setDescription("The total number of AP Radar capacity licenses installed on this controller's availability partner. ")
stationsByProtocol = MibIdentifier((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 10, 2))
stationsByProtocolA = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 10, 2, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stationsByProtocolA.setStatus('current')
if mibBuilder.loadTexts: stationsByProtocolA.setDescription('Number of stations using 802.11a mode to access the network.')
stationsByProtocolB = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 10, 2, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stationsByProtocolB.setStatus('current')
if mibBuilder.loadTexts: stationsByProtocolB.setDescription('Number of stations using 802.11b mode to access the network.')
stationsByProtocolG = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 10, 2, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stationsByProtocolG.setStatus('current')
if mibBuilder.loadTexts: stationsByProtocolG.setDescription('Number of stations using 802.11b mode to access the network.')
stationsByProtocolN24 = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 10, 2, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stationsByProtocolN24.setStatus('current')
if mibBuilder.loadTexts: stationsByProtocolN24.setDescription('Number of stations using 802.11n mode with frequency of 2.4Gig to access the network.')
stationsByProtocolN5 = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 10, 2, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stationsByProtocolN5.setStatus('current')
if mibBuilder.loadTexts: stationsByProtocolN5.setDescription('Number of stations using 802.11n mode with frequency of 5Gig to access the network.')
stationsByProtocolUnavailable = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 10, 2, 6), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stationsByProtocolUnavailable.setStatus('current')
if mibBuilder.loadTexts: stationsByProtocolUnavailable.setDescription('The total number of stations with sessions on this controller for which the 802.11 protocol type (a, b, g, n, ac) for which the protocol could not be determined.')
stationsByProtocolError = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 10, 2, 7), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stationsByProtocolError.setStatus('current')
if mibBuilder.loadTexts: stationsByProtocolError.setDescription("The total number of stations with sessions on this controller for which an AP reported an invalid (out of range) value as the station's 802.11 protocol type.")
stationsByProtocolAC = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 10, 2, 8), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stationsByProtocolAC.setStatus('current')
if mibBuilder.loadTexts: stationsByProtocolAC.setDescription('Number of stations using 802.11ac mode to access the network.')
apByChannelTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 10, 3), )
if mibBuilder.loadTexts: apByChannelTable.setStatus('current')
if mibBuilder.loadTexts: apByChannelTable.setDescription('List of aggregated access points that are operating on a specific wireless channels.')
apByChannelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 10, 3, 1), ).setIndexNames((0, "HIPATH-WIRELESS-HWC-MIB", "apByChannelNumber"))
if mibBuilder.loadTexts: apByChannelEntry.setStatus('current')
if mibBuilder.loadTexts: apByChannelEntry.setDescription('An entry in this table for one wireless channel and aggregated access point on that channel.')
apByChannelNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 10, 3, 1, 1), Unsigned32())
if mibBuilder.loadTexts: apByChannelNumber.setStatus('current')
if mibBuilder.loadTexts: apByChannelNumber.setDescription("The channel on which a set of access points are presently operating. If this number is 0, this means the AP is in Guardian mode or the AP's radios are turned off.")
apByChannelAPs = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 2, 10, 3, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apByChannelAPs.setStatus('current')
if mibBuilder.loadTexts: apByChannelAPs.setDescription('Total number of the access point on the channel that this row is indexed on.')
virtualNetworks = MibIdentifier((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3))
vnsConfigObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1))
vnsCount = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vnsCount.setStatus('current')
if mibBuilder.loadTexts: vnsCount.setDescription('Number of VNSes defined in vnsConfigTable.')
vnsConfigTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 2), )
if mibBuilder.loadTexts: vnsConfigTable.setStatus('current')
if mibBuilder.loadTexts: vnsConfigTable.setDescription('Contains definitions of the Virtual Network Segments defined on this WirelessController.')
vnsConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 2, 1), ).setIndexNames((0, "HIPATH-WIRELESS-HWC-MIB", "vnsIfIndex"))
if mibBuilder.loadTexts: vnsConfigEntry.setStatus('current')
if mibBuilder.loadTexts: vnsConfigEntry.setDescription('Configuration elements for a specific Virtual Network Segment.')
vnsDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 2, 1, 1), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsDescription.setStatus('current')
if mibBuilder.loadTexts: vnsDescription.setDescription('Textual description of the VNS.')
vnsAssignmentMode = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ssid", 1), ("aaa", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsAssignmentMode.setStatus('obsolete')
if mibBuilder.loadTexts: vnsAssignmentMode.setDescription('Determines the method by which mobile units are assigned an address within this VNS. If vnsAssignmentMode = ssid, any client with an SSID matching the VNS will be assigned an address from this VNS. If vnsAssignmentMode == aaa, then address assignment is not completed until after the user is authenticated.')
vnsMUSessionTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 2, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsMUSessionTimeout.setStatus('current')
if mibBuilder.loadTexts: vnsMUSessionTimeout.setDescription('Client session idle time out, in seconds.')
vnsAllowMulticast = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 2, 1, 4), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsAllowMulticast.setStatus('current')
if mibBuilder.loadTexts: vnsAllowMulticast.setDescription('When true, allows IP multicast packets to be broadcast to the clients on this VNS.')
vnsSSID = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 2, 1, 5), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsSSID.setStatus('current')
if mibBuilder.loadTexts: vnsSSID.setDescription('Service Set Identifier (i.e. Network Name) that will be configured on the AccessPoints associated with this VNS.')
vnsDomain = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 2, 1, 6), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsDomain.setStatus('current')
if mibBuilder.loadTexts: vnsDomain.setDescription('Domain name to be supplied to the wireless clients if internal DHCP address assignment.')
vnsDNSServers = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 2, 1, 7), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsDNSServers.setStatus('current')
if mibBuilder.loadTexts: vnsDNSServers.setDescription('List of DNSs to be supplied to the wireless clients if internal DHCP address assignment.')
vnsWINSServers = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 2, 1, 8), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsWINSServers.setStatus('current')
if mibBuilder.loadTexts: vnsWINSServers.setDescription('List of WINSs to be supplied to the wireless clients if internal DHCP address assignment.')
vnsAuthModel = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("captivePortal", 2), ("dot1X", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsAuthModel.setStatus('current')
if mibBuilder.loadTexts: vnsAuthModel.setDescription('vnsAuthModel specifies the authentication method used for clients in the VNS. None indicates that the VNS is open, and no authentication is required. vnsAuthModel=captivePortal may only be specified for a VNS with vnsAssignmentMode=ssid. Likewise, vnsAuthModel=dot1X may only be specified for a VNS with vnsAssignmentMode=aaa.')
vnsParentIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 2, 1, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsParentIfIndex.setStatus('obsolete')
if mibBuilder.loadTexts: vnsParentIfIndex.setDescription('Specifies the ifIndex of the parent VNS, if this VNS is a child. If this is a top level VNS, vnsParentIfIndex will return null or 0.')
vnsMgmtTrafficEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 2, 1, 11), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsMgmtTrafficEnable.setStatus('current')
if mibBuilder.loadTexts: vnsMgmtTrafficEnable.setDescription('Specifies whether clients in the VNS have access to EWC management elements.')
vnsUseDHCPRelay = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("none", 0), ("dhcpRelay", 1), ("localDhcp", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsUseDHCPRelay.setStatus('current')
if mibBuilder.loadTexts: vnsUseDHCPRelay.setDescription('This variable indicates what type of DHCP is used for the VNS. none(0): No DHCP server on the VNS. dhcpRelay(1): Uses DHCP relay to reach the DHCP server. localDhcp(2): Uses local DHCP server on the controler.')
vns3rdPartyAP = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 2, 1, 13), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vns3rdPartyAP.setStatus('current')
if mibBuilder.loadTexts: vns3rdPartyAP.setDescription('When true, specifies that the VNS contains 3rd party access points. Only one such VNS may be defined for a WirelessController.')
vnsStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 2, 1, 14), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsStatus.setStatus('current')
if mibBuilder.loadTexts: vnsStatus.setDescription('RowStatus variable for performing row operations on vnsConfigTable.')
vnsMode = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 2, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("routed", 1), ("bridgeAtController", 2), ("bridgeAtAP", 3), ("wds", 4), ("thirdParty", 5))).clone('routed')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsMode.setStatus('current')
if mibBuilder.loadTexts: vnsMode.setDescription('Type of traffic for this VNS. routed(1): The traffic is routed at the controller. bridgeAtController(2): Traffic is bridged at controller. bridgeAtAP(3): Traffic is bridged at Access Points. wds(4): Wireless Distributed System (WDS) type of VNS. If VNS is type of wds(4), then only vnsSupressSSID, vnsDescription and vnsSSID has meaning.')
vnsVlanID = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 2, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 4094)).clone(-1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsVlanID.setStatus('current')
if mibBuilder.loadTexts: vnsVlanID.setDescription('VLAN tag for the packets trasmitted to/from of the VNS. This value has meaning if vnsMode is bridgeAtController(2) or bridgeAtAP(3). If vnsMode = bridgeAtController(2), tagging is done at controller. If vnsMode = bridgeAtAP(3), tagging is done at Access Point. Value ranges: (-1) it is not tagged, zero(0) means reserved, 1-4094 tag value.')
vnsInterfaceName = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 2, 1, 17), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsInterfaceName.setStatus('current')
if mibBuilder.loadTexts: vnsInterfaceName.setDescription('Physical interface to be used in the controller for trasmitting/receiving packets for the VNS. This value has meaning if vnsMode is bridgeAtController(2).')
vnsMgmIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 2, 1, 18), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsMgmIpAddress.setStatus('current')
if mibBuilder.loadTexts: vnsMgmIpAddress.setDescription('IP address of the management port associated to this VNS. This value has meaning if vnsMode is bridgeAtController(2).')
vnsSuppressSSID = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 2, 1, 19), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsSuppressSSID.setStatus('current')
if mibBuilder.loadTexts: vnsSuppressSSID.setDescription('If set to true, this prevents this SSID from appearing in the beacon message.')
vnsEnable11hSupport = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 2, 1, 20), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsEnable11hSupport.setStatus('current')
if mibBuilder.loadTexts: vnsEnable11hSupport.setDescription('If true, enables 802.11h support.')
vnsApplyPowerBackOff = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 2, 1, 21), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsApplyPowerBackOff.setStatus('current')
if mibBuilder.loadTexts: vnsApplyPowerBackOff.setDescription('Indicates whether the AP will direct 802.11h-enabled clients to apply the same power back-off setting that the AP is using')
vnsProcessClientIEReq = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 2, 1, 22), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsProcessClientIEReq.setStatus('current')
if mibBuilder.loadTexts: vnsProcessClientIEReq.setDescription('If true, enables support for 802.11d client information request.')
vnsDLSSupportEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 2, 1, 23), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsDLSSupportEnable.setStatus('current')
if mibBuilder.loadTexts: vnsDLSSupportEnable.setDescription('If true, enables support for DLS Support. This value has meaning only if vnsUseDHCPRelay is selected as localDhcp(2) and vnsMode is select as either routed(1) or bridgeAtController(2).')
vnsDLSAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 2, 1, 24), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsDLSAddress.setStatus('current')
if mibBuilder.loadTexts: vnsDLSAddress.setDescription('DNS IP Address for DLS associated to this VNS. It could be IP address or Name')
vnsDLSPort = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 2, 1, 25), Integer32().clone(18443)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsDLSPort.setStatus('current')
if mibBuilder.loadTexts: vnsDLSPort.setDescription('DNS Port for DLS associated to this VNS.')
vnsRateControlProfile = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 2, 1, 26), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsRateControlProfile.setStatus('current')
if mibBuilder.loadTexts: vnsRateControlProfile.setDescription('The Rate Control Profile that is referenced by this VNS.')
vnsSessionAvailabilityEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 2, 1, 27), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsSessionAvailabilityEnable.setStatus('current')
if mibBuilder.loadTexts: vnsSessionAvailabilityEnable.setDescription('To indicate if Session Availability feature is enabled.')
vnsEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 2, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsEnabled.setStatus('current')
if mibBuilder.loadTexts: vnsEnabled.setDescription('VNS status of being enabled or disabled.')
vnsStrictSubnetAdherence = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 2, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsStrictSubnetAdherence.setStatus('current')
if mibBuilder.loadTexts: vnsStrictSubnetAdherence.setDescription('Subnet adherence verification status for the VNS. Controller only learns devices whose address is within range of VNS segment definition. Disabling this field causes to not enforce validation. Doing so, may expose the controller to in-advertent Learning DoS attacks. ')
vnsSLPEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 2, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsSLPEnabled.setStatus('current')
if mibBuilder.loadTexts: vnsSLPEnabled.setDescription('Status of SLP flag on Bridge at Controller type VNS. This field does not have any meaning for other types of VNS.')
vnsConfigWLANID = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 2, 1, 31), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsConfigWLANID.setStatus('current')
if mibBuilder.loadTexts: vnsConfigWLANID.setDescription('Creation of VNS requires existing of a free WLAN. One WLAN can only be used in one VNS only. This ID identifies the WLAN that is used for creation of VNS that is identified by this row.')
vnsDHCPRangeTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 3), )
if mibBuilder.loadTexts: vnsDHCPRangeTable.setStatus('current')
if mibBuilder.loadTexts: vnsDHCPRangeTable.setDescription('vnsDHCPRangeTable contains the IP address ranges that DHCP will serve to clients associated with this VNS.')
vnsDHCPRangeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 3, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "HIPATH-WIRELESS-HWC-MIB", "vnsDHCPRangeIndex"))
if mibBuilder.loadTexts: vnsDHCPRangeEntry.setStatus('current')
if mibBuilder.loadTexts: vnsDHCPRangeEntry.setDescription('Configuration information for a DHCP range.')
vnsDHCPRangeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsDHCPRangeIndex.setStatus('current')
if mibBuilder.loadTexts: vnsDHCPRangeIndex.setDescription('Index for the DHCP row element.')
vnsDHCPRangeStart = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 3, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsDHCPRangeStart.setStatus('current')
if mibBuilder.loadTexts: vnsDHCPRangeStart.setDescription('First IP address in the range.')
vnsDHCPRangeEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 3, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsDHCPRangeEnd.setStatus('current')
if mibBuilder.loadTexts: vnsDHCPRangeEnd.setDescription('Last IP address in the range.')
vnsDHCPRangeType = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("inclusion", 1), ("exclusion", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsDHCPRangeType.setStatus('current')
if mibBuilder.loadTexts: vnsDHCPRangeType.setDescription('Determines whether addresses in the specified range will be included, or excluded by the DHCP server.')
vnsDHCPRangeStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 3, 1, 5), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsDHCPRangeStatus.setStatus('current')
if mibBuilder.loadTexts: vnsDHCPRangeStatus.setDescription('Row status variable for row operations on the vnsDHCPRangeTable')
vnsCaptivePortalTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 4), )
if mibBuilder.loadTexts: vnsCaptivePortalTable.setStatus('current')
if mibBuilder.loadTexts: vnsCaptivePortalTable.setDescription('Details of the Captive Portal login page for VNSes that have vnsAssignment=ssid and vnsAuthModel=captivePortal.')
vnsCaptivePortalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 4, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: vnsCaptivePortalEntry.setStatus('current')
if mibBuilder.loadTexts: vnsCaptivePortalEntry.setDescription('Captive Portal Information for the VNS.')
cpURL = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 4, 1, 1), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpURL.setStatus('current')
if mibBuilder.loadTexts: cpURL.setDescription('Redirect URL of the Captive Portal login page.')
cpLoginLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 4, 1, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpLoginLabel.setStatus('deprecated')
if mibBuilder.loadTexts: cpLoginLabel.setDescription('Label that appears in front of the login field on the Captive Portal login page.')
cpPasswordLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 4, 1, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpPasswordLabel.setStatus('deprecated')
if mibBuilder.loadTexts: cpPasswordLabel.setDescription('Label that appears in front of the password field on the Captive Portal login page.')
cpHeaderURL = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 4, 1, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpHeaderURL.setStatus('deprecated')
if mibBuilder.loadTexts: cpHeaderURL.setDescription('URL of the Captive Portal header.')
cpFooterURL = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 4, 1, 5), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpFooterURL.setStatus('deprecated')
if mibBuilder.loadTexts: cpFooterURL.setDescription('URL of the Captive Portal footer.')
cpMessage = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 4, 1, 6), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpMessage.setStatus('deprecated')
if mibBuilder.loadTexts: cpMessage.setDescription('A welcome message, or set of instructions that is to appear on the Captive Portal login page.')
cpReplaceGatewayWithFQDN = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 4, 1, 7), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpReplaceGatewayWithFQDN.setStatus('current')
if mibBuilder.loadTexts: cpReplaceGatewayWithFQDN.setDescription('Fully Qualified Domain Name (FQDN) to be used as the gateway IP address.')
cpDefaultRedirectionURL = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 4, 1, 8), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpDefaultRedirectionURL.setStatus('current')
if mibBuilder.loadTexts: cpDefaultRedirectionURL.setDescription('Default Redirect URL of the Captive Portal login page.')
cpConnectionIP = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 4, 1, 9), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpConnectionIP.setStatus('current')
if mibBuilder.loadTexts: cpConnectionIP.setDescription('IP address of the Controller interface for Captive Portal.')
cpConnectionPort = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 4, 1, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpConnectionPort.setStatus('current')
if mibBuilder.loadTexts: cpConnectionPort.setDescription('Port number on the cpConnectionIP interface.')
cpSharedSecret = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 4, 1, 11), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpSharedSecret.setStatus('current')
if mibBuilder.loadTexts: cpSharedSecret.setDescription('Secret Key to be used to encrypt the information passed between the Controller and the external web server. It is the password common to both Controller and the external web server.')
cpLogOff = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 4, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpLogOff.setStatus('current')
if mibBuilder.loadTexts: cpLogOff.setDescription('Toggles the display of logoff popup screen, allowing users to control their logoff.')
cpStatusCheck = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 4, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpStatusCheck.setStatus('current')
if mibBuilder.loadTexts: cpStatusCheck.setDescription('Toggles the display of popup window with session statistics for users to monitor their usage and time left in session.')
cpType = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 4, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 5))).clone(namedValues=NamedValues(("none", 1), ("internal", 2), ("external", 4), ("guestPortal", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpType.setStatus('current')
if mibBuilder.loadTexts: cpType.setDescription('Type of captive portal is enabled for the selected VNS. none(1) = no captive portal configured or type is unknown. internal(2) = internal captive portal. external(4) = external captive portal. guestPortal (5) = open host captive portal.')
vnsRadiusServerTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 5), )
if mibBuilder.loadTexts: vnsRadiusServerTable.setStatus('current')
if mibBuilder.loadTexts: vnsRadiusServerTable.setDescription('List of RADIUS servers to be utilized for authentication in the VNS.')
vnsRadiusServerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 5, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "HIPATH-WIRELESS-HWC-MIB", "vnsRadiusServerName"))
if mibBuilder.loadTexts: vnsRadiusServerEntry.setStatus('current')
if mibBuilder.loadTexts: vnsRadiusServerEntry.setDescription('Configuration information for a RADIUS server.')
vnsRadiusServerName = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 5, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsRadiusServerName.setStatus('current')
if mibBuilder.loadTexts: vnsRadiusServerName.setDescription('Name of the RADIUS server.')
vnsRadiusServerPort = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 5, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsRadiusServerPort.setStatus('current')
if mibBuilder.loadTexts: vnsRadiusServerPort.setDescription('Port number for the RADIUS server.')
vnsRadiusServerRetries = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 5, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsRadiusServerRetries.setStatus('current')
if mibBuilder.loadTexts: vnsRadiusServerRetries.setDescription('Number of retries for a RADIUS authentication request.')
vnsRadiusServerTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 5, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsRadiusServerTimeout.setStatus('current')
if mibBuilder.loadTexts: vnsRadiusServerTimeout.setDescription('Delay between requests.')
vnsRadiusServerSharedSecret = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 5, 1, 5), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsRadiusServerSharedSecret.setStatus('current')
if mibBuilder.loadTexts: vnsRadiusServerSharedSecret.setDescription('Shared secret to be used between the NAS and RADIUS server.')
vnsRadiusServerNASIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 5, 1, 6), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsRadiusServerNASIdentifier.setStatus('current')
if mibBuilder.loadTexts: vnsRadiusServerNASIdentifier.setDescription('NAS identifier to be included in RADIUS request.')
vnsRadiusServerAuthType = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 5, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("pap", 0), ("chap", 1), ("msChap", 2), ("msChapV2", 3), ("notApplicable", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsRadiusServerAuthType.setStatus('current')
if mibBuilder.loadTexts: vnsRadiusServerAuthType.setDescription('Challenge mechanism for the request.')
vnsRadiusServerRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 5, 1, 8), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsRadiusServerRowStatus.setStatus('current')
if mibBuilder.loadTexts: vnsRadiusServerRowStatus.setDescription('RowStatus value for manipulating vnsRADIUSServerTable.')
vnsRadiusServerNasAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 5, 1, 9), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsRadiusServerNasAddress.setStatus('current')
if mibBuilder.loadTexts: vnsRadiusServerNasAddress.setDescription('NAS address to be included in RADIUS request.')
vnsFilterIDTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 6), )
if mibBuilder.loadTexts: vnsFilterIDTable.setStatus('current')
if mibBuilder.loadTexts: vnsFilterIDTable.setDescription('Table of names filters for a VNS.')
vnsFilterIDEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 6, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "HIPATH-WIRELESS-HWC-MIB", "vnsFilterID"))
if mibBuilder.loadTexts: vnsFilterIDEntry.setStatus('current')
if mibBuilder.loadTexts: vnsFilterIDEntry.setDescription('Name of a specific filter in the VNS.')
vnsFilterID = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 6, 1, 1), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsFilterID.setStatus('current')
if mibBuilder.loadTexts: vnsFilterID.setDescription('Filter names.')
vnsFilterIDStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 6, 1, 2), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsFilterIDStatus.setStatus('current')
if mibBuilder.loadTexts: vnsFilterIDStatus.setDescription('RowStatus for operating on vnsFilterIDTable.')
vnsFilterRuleTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 7), )
if mibBuilder.loadTexts: vnsFilterRuleTable.setStatus('current')
if mibBuilder.loadTexts: vnsFilterRuleTable.setDescription('Table containing specific filters for a named filter.')
vnsFilterRuleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 7, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "HIPATH-WIRELESS-HWC-MIB", "vnsFilterID"), (0, "HIPATH-WIRELESS-HWC-MIB", "vnsFilterRuleOrder"))
if mibBuilder.loadTexts: vnsFilterRuleEntry.setStatus('current')
if mibBuilder.loadTexts: vnsFilterRuleEntry.setDescription('Filter elements for an individual VNS filter.')
vnsFilterRuleOrder = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 7, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65532))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsFilterRuleOrder.setStatus('current')
if mibBuilder.loadTexts: vnsFilterRuleOrder.setDescription('Position of the filter in the filter list.')
vnsFilterRuleDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 7, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("none", 0), ("in", 1), ("out", 2), ("both", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsFilterRuleDirection.setStatus('current')
if mibBuilder.loadTexts: vnsFilterRuleDirection.setDescription('Traffic direction defined by the rule.')
vnsFilterRuleAction = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 7, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("allow", 1), ("disallow", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsFilterRuleAction.setStatus('current')
if mibBuilder.loadTexts: vnsFilterRuleAction.setDescription('Allow or deny traffic for the filter.')
vnsFilterRuleIPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 7, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsFilterRuleIPAddress.setStatus('current')
if mibBuilder.loadTexts: vnsFilterRuleIPAddress.setDescription('IP address to apply the filter.')
vnsFilterRulePortLow = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 7, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsFilterRulePortLow.setStatus('current')
if mibBuilder.loadTexts: vnsFilterRulePortLow.setDescription('Low port number for the filter.')
vnsFilterRulePortHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 7, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsFilterRulePortHigh.setStatus('current')
if mibBuilder.loadTexts: vnsFilterRulePortHigh.setDescription('High port number for the filter.')
vnsFilterRuleProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 7, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("none", 0), ("notApplicable", 1), ("tcp", 2), ("udp", 3), ("icmp", 4), ("ipsecESP", 5), ("ipsecAH", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsFilterRuleProtocol.setStatus('current')
if mibBuilder.loadTexts: vnsFilterRuleProtocol.setDescription('Specific protocol to filter.')
vnsFilterRuleEtherType = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 7, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("none", 0), ("ip", 1), ("arp", 2), ("rarp", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsFilterRuleEtherType.setStatus('current')
if mibBuilder.loadTexts: vnsFilterRuleEtherType.setDescription('Specific ethertype to filter.')
vnsFilterRuleStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 7, 1, 9), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsFilterRuleStatus.setStatus('current')
if mibBuilder.loadTexts: vnsFilterRuleStatus.setDescription('RowStatus value for the vnsFilterRuleTable.')
vnsPrivacyTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 8), )
if mibBuilder.loadTexts: vnsPrivacyTable.setStatus('current')
if mibBuilder.loadTexts: vnsPrivacyTable.setDescription('Table of privacy settings for the VNS.')
vnsPrivacyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 8, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: vnsPrivacyEntry.setStatus('current')
if mibBuilder.loadTexts: vnsPrivacyEntry.setDescription('Configuration values for a specific privacy setting.')
vnsPrivWEPKeyType = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 8, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("none", 1), ("wepstatic", 2), ("wpapsk", 3), ("dynamic", 4), ("wpa", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsPrivWEPKeyType.setStatus('current')
if mibBuilder.loadTexts: vnsPrivWEPKeyType.setDescription('Type of key in use. none(1) = not cofigured, wepstatic(2) = static WEP, wpapsk(3) = WPA Pre-Shared Key, dynamic(4) = dynamically assigned, wpa(5) = WPA.')
vnsPrivDynamicRekeyFrequency = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 8, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsPrivDynamicRekeyFrequency.setStatus('current')
if mibBuilder.loadTexts: vnsPrivDynamicRekeyFrequency.setDescription('Dynamic WEP re-keying frequency, in seconds. Setting this value to 0 disables rekeying. This value is only meaningful if vnsPrivWEPKeyType = wpapsk(3). For any other values of vnsPrivWEPKeyType, reading or setting this value will return an unsuccessful status and will return a value of null or zero.')
vnsPrivWEPKeyLength = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 8, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsPrivWEPKeyLength.setStatus('current')
if mibBuilder.loadTexts: vnsPrivWEPKeyLength.setDescription('WEP key length, 64, 128, or 152 bits. If vnsPrivWEPKeyType is none, reading or setting this value will return an unsuccessful status and will return a value of null or zero.')
vnsPrivWPA1Enabled = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 8, 1, 4), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsPrivWPA1Enabled.setStatus('current')
if mibBuilder.loadTexts: vnsPrivWPA1Enabled.setDescription('Enables WPA.1 (Wi-Fi Protected Access).')
vnsPrivUseSharedKey = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 8, 1, 5), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsPrivUseSharedKey.setStatus('current')
if mibBuilder.loadTexts: vnsPrivUseSharedKey.setDescription('Enables the use of WPA shared key for this VNS.')
vnsPrivWPASharedKey = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 8, 1, 6), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsPrivWPASharedKey.setStatus('current')
if mibBuilder.loadTexts: vnsPrivWPASharedKey.setDescription('The value of the WPA shared key for this VNS. This value is logically WRITE ONLY. Attempts to read this value shall return unsuccessful status and values of null or zero.')
vnsPrivWPA2Enabled = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 8, 1, 7), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsPrivWPA2Enabled.setStatus('current')
if mibBuilder.loadTexts: vnsPrivWPA2Enabled.setDescription('When true, WPA v.2 support is enabled.')
vnsWEPKeyTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 9), )
if mibBuilder.loadTexts: vnsWEPKeyTable.setStatus('current')
if mibBuilder.loadTexts: vnsWEPKeyTable.setDescription('Table of WEP key entries for a static WEP definition.')
vnsWEPKeyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 9, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "HIPATH-WIRELESS-HWC-MIB", "vnsWEPKeyIndex"))
if mibBuilder.loadTexts: vnsWEPKeyEntry.setStatus('current')
if mibBuilder.loadTexts: vnsWEPKeyEntry.setDescription('WEP key for a single entry in the table.')
vnsWEPKeyIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 9, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsWEPKeyIndex.setStatus('current')
if mibBuilder.loadTexts: vnsWEPKeyIndex.setDescription('Table index for the WEP key.')
vnsWEPKeyValue = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 9, 1, 2), WEPKeytype()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsWEPKeyValue.setStatus('current')
if mibBuilder.loadTexts: vnsWEPKeyValue.setDescription('Value of a WEP key for this VNS. This value is logically WRITE ONLY. Attempts to read this value shall return unsuccessful status and values of null or zero.')
vns3rdPartyAPTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 10), )
if mibBuilder.loadTexts: vns3rdPartyAPTable.setStatus('current')
if mibBuilder.loadTexts: vns3rdPartyAPTable.setDescription('Contains a list of 3rd Party access points for the EWC.')
vns3rdPartyAPEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 10, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "HIPATH-WIRELESS-HWC-MIB", "apMacAddress"))
if mibBuilder.loadTexts: vns3rdPartyAPEntry.setStatus('current')
if mibBuilder.loadTexts: vns3rdPartyAPEntry.setDescription('Configuration information for a 3rd party access point.')
apMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 10, 1, 1), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apMacAddress.setStatus('current')
if mibBuilder.loadTexts: apMacAddress.setDescription('Ethernet MAC address of the 3rd party access point.')
apIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 10, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apIpAddress.setStatus('current')
if mibBuilder.loadTexts: apIpAddress.setDescription('IP address of the 3rd party access point.')
vnsQoSTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 11), )
if mibBuilder.loadTexts: vnsQoSTable.setStatus('current')
if mibBuilder.loadTexts: vnsQoSTable.setDescription('This table contains list of per-VNS QoS related configuration.')
vnsQoSEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 11, 1), ).setIndexNames((0, "HIPATH-WIRELESS-HWC-MIB", "vnsIfIndex"))
if mibBuilder.loadTexts: vnsQoSEntry.setStatus('current')
if mibBuilder.loadTexts: vnsQoSEntry.setDescription('An entry related to QoS configuration for the VNS indexed by vnsIfIndex.')
vnsQoSWirelessLegacyFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsQoSWirelessLegacyFlag.setStatus('current')
if mibBuilder.loadTexts: vnsQoSWirelessLegacyFlag.setDescription('This variable is used to enable/disable legacy QoS feature.')
vnsQoSWirelessWMMFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsQoSWirelessWMMFlag.setStatus('current')
if mibBuilder.loadTexts: vnsQoSWirelessWMMFlag.setDescription('This variable is used to enable/disable WMM feature.')
vnsQoSWireless80211eFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 11, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsQoSWireless80211eFlag.setStatus('current')
if mibBuilder.loadTexts: vnsQoSWireless80211eFlag.setDescription('This variable is used to enable/disable 802.11e feature.')
vnsQoSWirelessTurboVoiceFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 11, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsQoSWirelessTurboVoiceFlag.setStatus('current')
if mibBuilder.loadTexts: vnsQoSWirelessTurboVoiceFlag.setDescription('This variable is used to enable/disable turbo feature.')
vnsQoSPriorityOverrideFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 11, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsQoSPriorityOverrideFlag.setStatus('current')
if mibBuilder.loadTexts: vnsQoSPriorityOverrideFlag.setDescription('Enable/disable the use of DSCP to override Servic Class (SC) value.')
vnsQoSPriorityOverrideSC = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 11, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("background", 0), ("bestEffort", 1), ("bronze", 2), ("silver", 3), ("gold", 4), ("platinum", 5), ("premiumVoice", 6), ("networkControl", 7))).clone('background')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsQoSPriorityOverrideSC.setStatus('current')
if mibBuilder.loadTexts: vnsQoSPriorityOverrideSC.setDescription('Service class (SC) of the override value. This field has a meaning if vnsQoSPriorityOverrideFlag is enabled.')
vnsQoSPriorityOverrideDSCP = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 11, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 63))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsQoSPriorityOverrideDSCP.setStatus('current')
if mibBuilder.loadTexts: vnsQoSPriorityOverrideDSCP.setDescription('DSCP override value to be used for the service class. This field has a meaning if vnsQoSPriorityOverrideFlag is enabled.')
vnsQoSClassificationServiceClass = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 11, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsQoSClassificationServiceClass.setStatus('current')
if mibBuilder.loadTexts: vnsQoSClassificationServiceClass.setDescription('Service Class value for the DSCP code. This field is 64-bytes long. Each byte represents mapping between DSCP and Service Class. Position of each byte in the array represents DSCP code and the content of each byte represents the service class value for that DSCP code. For example, second byte represents DSCP code 1 and its value represents SC value. Value for each byte is equivalent to either of: background = 0, bestEffort = 1, bronze = 2, silver = 3, gold = 4, platinum = 5, premiumVoice = 6, networkControl = 7')
vnsQoSWirelessEnableUAPSD = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 11, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsQoSWirelessEnableUAPSD.setStatus('current')
if mibBuilder.loadTexts: vnsQoSWirelessEnableUAPSD.setDescription('This variable is used to enable/disable U-APSD feature.')
vnsQoSWirelessUseAdmControlVoice = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 11, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsQoSWirelessUseAdmControlVoice.setStatus('current')
if mibBuilder.loadTexts: vnsQoSWirelessUseAdmControlVoice.setDescription('If enabled, admission control for voice traffic is used.')
vnsQoSWirelessUseAdmControlVideo = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 11, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsQoSWirelessUseAdmControlVideo.setStatus('current')
if mibBuilder.loadTexts: vnsQoSWirelessUseAdmControlVideo.setDescription('If enabled, admission control for vedio traffic is used. This field has a meaning if vnsQoSUseGlobalAdmVoice is enabled.')
vnsQoSWirelessULPolicerAction = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 11, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("doNothing", 0), ("sendDELTStoClient", 1))).clone('doNothing')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsQoSWirelessULPolicerAction.setStatus('current')
if mibBuilder.loadTexts: vnsQoSWirelessULPolicerAction.setDescription('If doNothing is selected, no action is taken. This is default value. If sendDELTStoClient is selected, AP will send DELTS if a client is abusing in uplink. This field has a meaning only if admission control is enabled for VO or VI.')
vnsQoSWirelessDLPolicerAction = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 11, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("doNothing", 0), ("downgrade", 1), ("drop", 2))).clone('doNothing')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsQoSWirelessDLPolicerAction.setStatus('current')
if mibBuilder.loadTexts: vnsQoSWirelessDLPolicerAction.setDescription('If doNothing is selected, no action is taken. This is default value. If downgrade is selected, AP will downgrade all traffic to the highest AC that does not require CAC in downlink. If drop is selected, AP will drop client if it observes a client that is illegally using an AC that has CAC mandatory in downlink. This field has a meaning only if admission control is enabled for VO or VI.')
vnsQoSWirelessUseAdmControlBestEffort = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 11, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsQoSWirelessUseAdmControlBestEffort.setStatus('current')
if mibBuilder.loadTexts: vnsQoSWirelessUseAdmControlBestEffort.setDescription('If enabled, admission control for video traffic is set to Best Effort. This field has a meaning if vnsQoSUseGlobalAdmVoice is enabled.')
vnsQoSWirelessUseAdmControlBackground = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 11, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsQoSWirelessUseAdmControlBackground.setStatus('current')
if mibBuilder.loadTexts: vnsQoSWirelessUseAdmControlBackground.setDescription('If enabled, admission control for video traffic is set to Background. This field has a meaning if vnsQoSUseGlobalAdmVoice is enabled.')
vnsWDSRFTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 12), )
if mibBuilder.loadTexts: vnsWDSRFTable.setStatus('obsolete')
if mibBuilder.loadTexts: vnsWDSRFTable.setDescription('ontains definitions of the Wireless Distirbution System (WDS) VNS defined on this Controller.')
vnsWDSRFEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 12, 1), ).setIndexNames((0, "HIPATH-WIRELESS-HWC-MIB", "vnsIfIndex"), (0, "HIPATH-WIRELESS-HWC-MIB", "apIndex"))
if mibBuilder.loadTexts: vnsWDSRFEntry.setStatus('obsolete')
if mibBuilder.loadTexts: vnsWDSRFEntry.setDescription('Configuration elements for a specific WDS VNS.')
vnsWDSRFAPName = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 12, 1, 1), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsWDSRFAPName.setStatus('obsolete')
if mibBuilder.loadTexts: vnsWDSRFAPName.setDescription('AP name.')
vnsWDSRFbgService = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("notAvailable", 0), ("none", 1), ("child", 2), ("parent", 3), ("both", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsWDSRFbgService.setStatus('obsolete')
if mibBuilder.loadTexts: vnsWDSRFbgService.setDescription('Type of service offered by this radio.')
vnsWDSRFaService = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("notAvailable", 0), ("none", 1), ("child", 2), ("parent", 3), ("both", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsWDSRFaService.setStatus('obsolete')
if mibBuilder.loadTexts: vnsWDSRFaService.setDescription('Type of service offered by this radio.')
vnsWDSRFPreferredParent = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 12, 1, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsWDSRFPreferredParent.setStatus('obsolete')
if mibBuilder.loadTexts: vnsWDSRFPreferredParent.setDescription('Desired preferred parent.')
vnsWDSRFBackupParent = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 12, 1, 5), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsWDSRFBackupParent.setStatus('obsolete')
if mibBuilder.loadTexts: vnsWDSRFBackupParent.setDescription('Desired backup parent.')
vnsWDSRFBridge = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 12, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("bridged", 1), ("notBridged", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsWDSRFBridge.setStatus('obsolete')
if mibBuilder.loadTexts: vnsWDSRFBridge.setDescription('WDS bridge status.')
vnsRateControlProfTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 13), )
if mibBuilder.loadTexts: vnsRateControlProfTable.setStatus('obsolete')
if mibBuilder.loadTexts: vnsRateControlProfTable.setDescription('Table of Rate Control Profiles.')
vnsRateControlProfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 13, 1), ).setIndexNames((0, "HIPATH-WIRELESS-HWC-MIB", "vnsRateControlProfInd"))
if mibBuilder.loadTexts: vnsRateControlProfEntry.setStatus('obsolete')
if mibBuilder.loadTexts: vnsRateControlProfEntry.setDescription('Name of a specific Rate Control Profile.')
vnsRateControlProfInd = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 13, 1, 1), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsRateControlProfInd.setStatus('obsolete')
if mibBuilder.loadTexts: vnsRateControlProfInd.setDescription('A monotonically increasing integer which acts as index of entries within the named Rate Control Profiles.')
vnsRateControlProfName = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 13, 1, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsRateControlProfName.setStatus('obsolete')
if mibBuilder.loadTexts: vnsRateControlProfName.setDescription('Rate Control Profile Name.')
vnsRateControlCIR = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 13, 1, 3), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsRateControlCIR.setStatus('obsolete')
if mibBuilder.loadTexts: vnsRateControlCIR.setDescription('Rate Control Average Rate (CIR) in kbps.')
vnsRateControlCBS = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 13, 1, 4), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsRateControlCBS.setStatus('obsolete')
if mibBuilder.loadTexts: vnsRateControlCBS.setDescription('Rate Control Burst Size (CBS) in bytes.')
vnsAPFilterTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 14), )
if mibBuilder.loadTexts: vnsAPFilterTable.setStatus('current')
if mibBuilder.loadTexts: vnsAPFilterTable.setDescription('Filters applied to Access Points via VNS settings and assignments.')
vnsAPFilterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 14, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "HIPATH-WIRELESS-HWC-MIB", "vnsFilterID"), (0, "HIPATH-WIRELESS-HWC-MIB", "vnsAPFilterRuleOrder"))
if mibBuilder.loadTexts: vnsAPFilterEntry.setStatus('current')
if mibBuilder.loadTexts: vnsAPFilterEntry.setDescription('An entry containing filters definition for Access Points assigned to VNS that is identified by VNS index.')
vnsAPFilterRuleOrder = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 14, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vnsAPFilterRuleOrder.setStatus('current')
if mibBuilder.loadTexts: vnsAPFilterRuleOrder.setDescription('Position of the filter in the filter list.')
vnsAPFilterRuleDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 14, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("in", 1), ("out", 2), ("both", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vnsAPFilterRuleDirection.setStatus('current')
if mibBuilder.loadTexts: vnsAPFilterRuleDirection.setDescription('Traffic direction related to the filter rule.')
vnsAPFilterAction = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 14, 1, 3), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vnsAPFilterAction.setStatus('current')
if mibBuilder.loadTexts: vnsAPFilterAction.setDescription('Allow or deny traffic for the filter.')
vnsAPFilterIPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 14, 1, 4), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vnsAPFilterIPAddress.setStatus('current')
if mibBuilder.loadTexts: vnsAPFilterIPAddress.setDescription('IP address applied to the filter.')
vnsAPFilterMask = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 14, 1, 5), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vnsAPFilterMask.setStatus('current')
if mibBuilder.loadTexts: vnsAPFilterMask.setDescription('The mask, number of bits set to one in the mask, applied to filter IP address.')
vnsAPFilterPortLow = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 14, 1, 6), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vnsAPFilterPortLow.setStatus('current')
if mibBuilder.loadTexts: vnsAPFilterPortLow.setDescription('Low port number for the filter.')
vnsAPFilterPortHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 14, 1, 7), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vnsAPFilterPortHigh.setStatus('current')
if mibBuilder.loadTexts: vnsAPFilterPortHigh.setDescription('High port number for the filter.')
vnsAPFilterProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 14, 1, 8), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vnsAPFilterProtocol.setStatus('current')
if mibBuilder.loadTexts: vnsAPFilterProtocol.setDescription('Specific protocol for the filter.')
vnsAPFilterEtherType = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 14, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ip", 1), ("arp", 2), ("rarp", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vnsAPFilterEtherType.setStatus('current')
if mibBuilder.loadTexts: vnsAPFilterEtherType.setDescription('Specific ethertype to the filter.')
vnsAPFilterRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 1, 14, 1, 10), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vnsAPFilterRowStatus.setStatus('current')
if mibBuilder.loadTexts: vnsAPFilterRowStatus.setDescription('RowStatus value for this table entry.')
vnsStatsObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 2))
activeVNSSessionCount = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 2, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: activeVNSSessionCount.setStatus('current')
if mibBuilder.loadTexts: activeVNSSessionCount.setDescription('Number of active VNSs.')
vnsStatTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 2, 2), )
if mibBuilder.loadTexts: vnsStatTable.setStatus('obsolete')
if mibBuilder.loadTexts: vnsStatTable.setDescription('Description.')
vnsStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 2, 2, 1), ).setIndexNames((0, "HIPATH-WIRELESS-HWC-MIB", "vnsIfIndex"))
if mibBuilder.loadTexts: vnsStatEntry.setStatus('obsolete')
if mibBuilder.loadTexts: vnsStatEntry.setDescription('Description.')
vnsStatName = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 2, 2, 1, 1), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsStatName.setStatus('obsolete')
if mibBuilder.loadTexts: vnsStatName.setDescription('Name of the VNS.')
vnsStatTxPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 2, 2, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vnsStatTxPkts.setStatus('obsolete')
if mibBuilder.loadTexts: vnsStatTxPkts.setDescription('Trasmitted packets.')
vnsStatRxPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 2, 2, 1, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vnsStatRxPkts.setStatus('obsolete')
if mibBuilder.loadTexts: vnsStatRxPkts.setDescription('Received packtes.')
vnsStatTxOctects = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 2, 2, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vnsStatTxOctects.setStatus('obsolete')
if mibBuilder.loadTexts: vnsStatTxOctects.setDescription('Trasmitted octects.')
vnsStatRxOctects = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 2, 2, 1, 5), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vnsStatRxOctects.setStatus('obsolete')
if mibBuilder.loadTexts: vnsStatRxOctects.setDescription('Received octets.')
vnsStatMulticastTxPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 2, 2, 1, 6), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vnsStatMulticastTxPkts.setStatus('obsolete')
if mibBuilder.loadTexts: vnsStatMulticastTxPkts.setDescription('Multicast trasmitted packets.')
vnsStatMulticastRxPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 2, 2, 1, 7), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vnsStatMulticastRxPkts.setStatus('obsolete')
if mibBuilder.loadTexts: vnsStatMulticastRxPkts.setDescription('Multicast received packets.')
vnsStatBroadcastTxPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 2, 2, 1, 8), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vnsStatBroadcastTxPkts.setStatus('obsolete')
if mibBuilder.loadTexts: vnsStatBroadcastTxPkts.setDescription('Broadcast trasmitted packets.')
vnsStatBroadcastRxPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 2, 2, 1, 9), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vnsStatBroadcastRxPkts.setStatus('obsolete')
if mibBuilder.loadTexts: vnsStatBroadcastRxPkts.setDescription('Broadcast received packets.')
vnsStatRadiusTotRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 2, 2, 1, 10), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vnsStatRadiusTotRequests.setStatus('obsolete')
if mibBuilder.loadTexts: vnsStatRadiusTotRequests.setDescription('Total requests sent to radius server.')
vnsStatRadiusReqFailed = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 2, 2, 1, 11), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vnsStatRadiusReqFailed.setStatus('obsolete')
if mibBuilder.loadTexts: vnsStatRadiusReqFailed.setDescription('Requests that failed to be processed by radius server.')
vnsStatRadiusReqRejected = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 2, 2, 1, 12), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vnsStatRadiusReqRejected.setStatus('obsolete')
if mibBuilder.loadTexts: vnsStatRadiusReqRejected.setDescription('Requests that have been rejected by radius server.')
vnsExceptionStatTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 2, 3), )
if mibBuilder.loadTexts: vnsExceptionStatTable.setStatus('obsolete')
if mibBuilder.loadTexts: vnsExceptionStatTable.setDescription('Description.')
vnsExceptionStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 2, 3, 1), ).setIndexNames((0, "HIPATH-WIRELESS-HWC-MIB", "vnsIfIndex"), (0, "HIPATH-WIRELESS-HWC-MIB", "vnsExceptionFiterName"))
if mibBuilder.loadTexts: vnsExceptionStatEntry.setStatus('obsolete')
if mibBuilder.loadTexts: vnsExceptionStatEntry.setDescription('Description.')
vnsExceptionFiterName = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 2, 3, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsExceptionFiterName.setStatus('obsolete')
if mibBuilder.loadTexts: vnsExceptionFiterName.setDescription('Filter name.')
vnsExceptionStatPktsDenied = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 2, 3, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vnsExceptionStatPktsDenied.setStatus('obsolete')
if mibBuilder.loadTexts: vnsExceptionStatPktsDenied.setDescription('Total packets that are denied by defined filters.')
vnsExceptionStatPktsAllowed = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 2, 3, 1, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vnsExceptionStatPktsAllowed.setStatus('obsolete')
if mibBuilder.loadTexts: vnsExceptionStatPktsAllowed.setDescription('Total packets that are allowed by defined filters.')
vnsWDSStatTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 2, 4), )
if mibBuilder.loadTexts: vnsWDSStatTable.setStatus('obsolete')
if mibBuilder.loadTexts: vnsWDSStatTable.setDescription('Description.')
vnsWDSStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 2, 4, 1), ).setIndexNames((0, "HIPATH-WIRELESS-HWC-MIB", "vnsIfIndex"), (0, "HIPATH-WIRELESS-HWC-MIB", "apIndex"))
if mibBuilder.loadTexts: vnsWDSStatEntry.setStatus('obsolete')
if mibBuilder.loadTexts: vnsWDSStatEntry.setDescription('Description.')
vnsWDSStatAPName = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 2, 4, 1, 1), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsWDSStatAPName.setStatus('obsolete')
if mibBuilder.loadTexts: vnsWDSStatAPName.setDescription('AP name serving WDS VNS.')
vnsWDSStatAPRole = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 2, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(-1, 0, 1, 2, 3))).clone(namedValues=NamedValues(("unknown", -1), ("none", 0), ("satellite", 1), ("root", 2), ("repeater", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsWDSStatAPRole.setStatus('obsolete')
if mibBuilder.loadTexts: vnsWDSStatAPRole.setDescription('Role of the AP in WDS tree. All the statistics and configuration information in this table has no meaning if the role is unknown(-1).')
vnsWDSStatAPRadio = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 2, 4, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsWDSStatAPRadio.setStatus('obsolete')
if mibBuilder.loadTexts: vnsWDSStatAPRadio.setDescription("Radio and freq on which uplink WDS is established, N/A if connected over etherent (value are 'a:<freq>', 'b/g:<freq>', or 'N/A') ")
vnsWDSStatAPParent = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 2, 4, 1, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsWDSStatAPParent.setStatus('obsolete')
if mibBuilder.loadTexts: vnsWDSStatAPParent.setDescription('AP Name of the parent AP.')
vnsWDSStatSSID = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 2, 4, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsWDSStatSSID.setStatus('obsolete')
if mibBuilder.loadTexts: vnsWDSStatSSID.setDescription('SSID of the WDS VNS where parent WDS link is established.')
vnsWDSStatRxFrame = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 2, 4, 1, 6), Counter64()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsWDSStatRxFrame.setStatus('obsolete')
if mibBuilder.loadTexts: vnsWDSStatRxFrame.setDescription('Received frames from the parent AP.')
vnsWDSStatTxFrame = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 2, 4, 1, 7), Counter64()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsWDSStatTxFrame.setStatus('obsolete')
if mibBuilder.loadTexts: vnsWDSStatTxFrame.setDescription('Transmitted frames to the parent AP.')
vnsWDSStatRxError = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 2, 4, 1, 8), Counter64()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsWDSStatRxError.setStatus('obsolete')
if mibBuilder.loadTexts: vnsWDSStatRxError.setDescription('Received frames in error from the parent AP.')
vnsWDSStatTxError = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 2, 4, 1, 9), Counter64()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsWDSStatTxError.setStatus('obsolete')
if mibBuilder.loadTexts: vnsWDSStatTxError.setDescription('Transmitted frames in error to the parent AP.')
vnsWDSStatRxRSSI = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 2, 4, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsWDSStatRxRSSI.setStatus('obsolete')
if mibBuilder.loadTexts: vnsWDSStatRxRSSI.setDescription('Average Received Signal Strength Indicator (RSSI).')
vnsWDSStatRxRate = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 2, 4, 1, 11), Counter64()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsWDSStatRxRate.setStatus('obsolete')
if mibBuilder.loadTexts: vnsWDSStatRxRate.setDescription('Average receive rate.')
vnsWDSStatTxRate = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 2, 4, 1, 12), Counter64()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsWDSStatTxRate.setStatus('obsolete')
if mibBuilder.loadTexts: vnsWDSStatTxRate.setDescription('Average transmission rate.')
vnsGlobalSetting = MibIdentifier((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 3))
wirelessQoS = MibIdentifier((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 3, 1))
maxVoiceBWforReassociation = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100)).clone(80)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: maxVoiceBWforReassociation.setStatus('current')
if mibBuilder.loadTexts: maxVoiceBWforReassociation.setDescription('Maximum voice bandwidth to be used for re-association.')
maxVoiceBWforAssociation = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100)).clone(60)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: maxVoiceBWforAssociation.setStatus('current')
if mibBuilder.loadTexts: maxVoiceBWforAssociation.setDescription('Maximum voice bandwidth to be used for association.')
maxVideoBWforReassociation = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100)).clone(60)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: maxVideoBWforReassociation.setStatus('current')
if mibBuilder.loadTexts: maxVideoBWforReassociation.setDescription('Maximum video bandwidth to be used for re-association.')
maxVideoBWforAssociation = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100)).clone(40)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: maxVideoBWforAssociation.setStatus('current')
if mibBuilder.loadTexts: maxVideoBWforAssociation.setDescription('Maximum video bandwidth to be used for association.')
maxBestEffortBWforReassociation = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 3, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100)).clone(40)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: maxBestEffortBWforReassociation.setStatus('current')
if mibBuilder.loadTexts: maxBestEffortBWforReassociation.setDescription('Maximum best effort bandwidth to be used for reassociation.')
maxBestEffortBWforAssociation = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 3, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100)).clone(30)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: maxBestEffortBWforAssociation.setStatus('current')
if mibBuilder.loadTexts: maxBestEffortBWforAssociation.setDescription('Maximum best effort bandwidth to be used for association.')
maxBackgroundBWforReassociation = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 3, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100)).clone(30)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: maxBackgroundBWforReassociation.setStatus('current')
if mibBuilder.loadTexts: maxBackgroundBWforReassociation.setDescription('Maximum background bandwidth to be used for reassociation. ')
maxBackgroundBWforAssociation = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 3, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100)).clone(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: maxBackgroundBWforAssociation.setStatus('current')
if mibBuilder.loadTexts: maxBackgroundBWforAssociation.setDescription('Maximum background bandwidth to be used for association. ')
radiusInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 3, 2))
externalRadiusServerTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 3, 2, 2), )
if mibBuilder.loadTexts: externalRadiusServerTable.setStatus('obsolete')
if mibBuilder.loadTexts: externalRadiusServerTable.setDescription('Table of external RADIUS servers available for authentication services.')
externalRadiusServerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 3, 2, 2, 1), ).setIndexNames((0, "HIPATH-WIRELESS-HWC-MIB", "externalRadiusServerName"))
if mibBuilder.loadTexts: externalRadiusServerEntry.setStatus('obsolete')
if mibBuilder.loadTexts: externalRadiusServerEntry.setDescription('Configuration information about the RADIUS server entry.')
externalRadiusServerName = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 3, 2, 2, 1, 1), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: externalRadiusServerName.setStatus('obsolete')
if mibBuilder.loadTexts: externalRadiusServerName.setDescription('RADIUS server name.')
externalRadiusServerAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 3, 2, 2, 1, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: externalRadiusServerAddress.setStatus('obsolete')
if mibBuilder.loadTexts: externalRadiusServerAddress.setDescription('RADIUS server address, it can be either string or IP address.')
externalRadiusServerSharedSecret = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 3, 2, 2, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: externalRadiusServerSharedSecret.setStatus('obsolete')
if mibBuilder.loadTexts: externalRadiusServerSharedSecret.setDescription('Shared secret between Radius and the client.')
externalRadiusServerRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 3, 2, 2, 1, 4), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: externalRadiusServerRowStatus.setStatus('obsolete')
if mibBuilder.loadTexts: externalRadiusServerRowStatus.setDescription('Row Status for the entry.')
dasInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 3, 3))
dasPort = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 3, 3, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1024, 65535)).clone(3799)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dasPort.setStatus('current')
if mibBuilder.loadTexts: dasPort.setDescription('Dynamic Authorization Server (DAS) port. ')
dasReplayInterval = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 3, 3, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000)).clone(300)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: dasReplayInterval.setStatus('current')
if mibBuilder.loadTexts: dasReplayInterval.setDescription('The time window for message timeliness and replay protection for DAS packets. Packets should be dropped that their time generation is outside of this specified interval. Value zero indicates that the timeliness checking will be performed.')
advancedFilteringMode = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 3, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: advancedFilteringMode.setStatus('current')
if mibBuilder.loadTexts: advancedFilteringMode.setDescription("Value of 'enabled(1)' means EWC is operating in advanced filtering configuration mode. Value of 'disabled(0)' means EWC is operating in mode that is compatible with releases prior to 7.41. This field can only be set to 'enabled(1)' and after setting it to that value, the only way to undo that is by resetting the database.")
radiusStrictMode = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 3, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("strictModeDisabled", 0), ("strictModeEnabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radiusStrictMode.setStatus('current')
if mibBuilder.loadTexts: radiusStrictMode.setDescription('If this variable set to true, then assignment of RADIUS server(s) to WLAN are automatic during WLAN creation, otherwise, assignment of RADIUS server(s) to WLAN must be done manually. ')
radiusFastFailoverEvents = MibIdentifier((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 3, 6))
radiusFastFailoverEventsTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 3, 6, 1), )
if mibBuilder.loadTexts: radiusFastFailoverEventsTable.setStatus('current')
if mibBuilder.loadTexts: radiusFastFailoverEventsTable.setDescription('Table in which to configure which RADIUS servers will be sent interim accounting reports for stations when a fast failover incident occurs ')
radiusFastFailoverEventsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 3, 6, 1, 1), ).setIndexNames((0, "HIPATH-WIRELESS-HWC-MIB", "radiusFFOEid"))
if mibBuilder.loadTexts: radiusFastFailoverEventsEntry.setStatus('current')
if mibBuilder.loadTexts: radiusFastFailoverEventsEntry.setDescription('An entry for each radius server.')
radiusFFOEid = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 3, 6, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 64)))
if mibBuilder.loadTexts: radiusFFOEid.setStatus('current')
if mibBuilder.loadTexts: radiusFFOEid.setDescription('The IP address or hostname of configured radius server. If the hostname is created from GUI/CLI and the size is bigger than 64 characters, snmp will display the first 64 characters only. ')
fastFailoverEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 3, 6, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("fastFailoverEventsDisabled", 0), ("fastFailoverEventsEnabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fastFailoverEvents.setStatus('current')
if mibBuilder.loadTexts: fastFailoverEvents.setDescription('If true, send an interim accounting record to the RADIUS server for each affected station when a fast failover event occurs. This field can be modified when controller is operated in availablity paired mode and fast failover is enabled ')
dhcpRelayListeners = MibIdentifier((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 3, 7))
dhcpRelayListenersMaxEntries = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 3, 7, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpRelayListenersMaxEntries.setStatus('current')
if mibBuilder.loadTexts: dhcpRelayListenersMaxEntries.setDescription('Maximum number of servers to which DHCP messages are relayed .')
dhcpRelayListenersNumEntries = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 3, 7, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpRelayListenersNumEntries.setStatus('current')
if mibBuilder.loadTexts: dhcpRelayListenersNumEntries.setDescription('The current number of entries in the dhcpRelayListenersTable.')
dhcpRelayListenersNextIndex = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 3, 7, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpRelayListenersNextIndex.setStatus('current')
if mibBuilder.loadTexts: dhcpRelayListenersNextIndex.setDescription('This object indicates numerically lowest available index within this entity, which may be used for the value of index in the creation of new entry in dhcpRelayListenersTable. An index is considered available if the index falls within the range of 1 to dhcpRelayListenersMaxEntries and it is not being used to index an existing entry in the dhcpRelayListenersTable contained this entity. This value should only be used as guideline for the management application and there is no requirement on the management application to create entries based upon this index value. Value of zero indicates there is no more room for new dhcpRelayListenersTable creation.')
dhcpRelayListenersTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 3, 7, 4), )
if mibBuilder.loadTexts: dhcpRelayListenersTable.setStatus('current')
if mibBuilder.loadTexts: dhcpRelayListenersTable.setDescription('A list of servers to which DHCP messages are relayed but from which no responses are expected. ')
dhcpRelayListenersEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 3, 7, 4, 1), ).setIndexNames((0, "HIPATH-WIRELESS-HWC-MIB", "dhcpRelayListenersID"))
if mibBuilder.loadTexts: dhcpRelayListenersEntry.setStatus('current')
if mibBuilder.loadTexts: dhcpRelayListenersEntry.setDescription('An entry for each dhcpRelayListeners.')
dhcpRelayListenersID = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 3, 7, 4, 1, 1), Unsigned32())
if mibBuilder.loadTexts: dhcpRelayListenersID.setStatus('current')
if mibBuilder.loadTexts: dhcpRelayListenersID.setDescription("The id corresponds to the 'server number' in the controller GUI and CLI.")
dhcpRelayListenersRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 3, 7, 4, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dhcpRelayListenersRowStatus.setStatus('current')
if mibBuilder.loadTexts: dhcpRelayListenersRowStatus.setDescription('This object allows dynamic creation and deletion of entries within dhcpRelayListenersTable as well as activation and deactivation of these entries. For row creation, EWC only supports creatAndWait. ')
destinationName = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 3, 7, 4, 1, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: destinationName.setStatus('current')
if mibBuilder.loadTexts: destinationName.setDescription('Text string uniquely identifying NAC Server Name. Allowable characters for this field are from the set of A-Z, a-z, -_!#$, 0-9, and space. max len is 63 chars Howerver, it is recommended to avoid leading and trailing spaces.')
destinationIP = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 3, 7, 4, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: destinationIP.setStatus('current')
if mibBuilder.loadTexts: destinationIP.setDescription('IPv4 address to which DHCP messages are relayed.')
clientAutologinOption = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 3, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("hide", 0), ("redirect", 1), ("drop", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: clientAutologinOption.setStatus('current')
if mibBuilder.loadTexts: clientAutologinOption.setDescription('Many devices such as those made by Apple(R) implement an autologin feature that prompts the user to login as soon as the device detects the presence of a Captive Portal. This feature sometimes causes problems for users who actually interact with the captive portal. hide(0) - Hide the captive portal from Autologin detector. redirect(1) - Redirect detection messages to the Captive Portal. This option is to allow client autologin to detect the captive portal & prompt the user to login. This may cause post-authentication redirection to fail. drop(2) - Drop detection messages.')
authenticationAdvanced = MibIdentifier((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 3, 9))
includeServiceType = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 3, 9, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: includeServiceType.setStatus('current')
if mibBuilder.loadTexts: includeServiceType.setDescription(' Include the Service-Type attribute in client access request messages when this field is set to enable(1). ')
clientMessageDelayTime = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 3, 9, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: clientMessageDelayTime.setStatus('current')
if mibBuilder.loadTexts: clientMessageDelayTime.setDescription('This field specifies how long, in seconds, the notice Web page is displayed to the client when the topology changes as a result of a role change. The notice Web page indicates that authentication was successful and that the user must close all browser windows and then restart the browser for access to the network. Currently this is supported for Internal Captive Portal, Guest Portal, and Guest Splash. ')
radiusAccounting = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 3, 9, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radiusAccounting.setStatus('current')
if mibBuilder.loadTexts: radiusAccounting.setDescription('This field enables or disables RADIUS accounting. Disabling RADIUS accounting overrides the RADIUS accounting settings of individual WLAN Services. Enabling RADIUS accounting activates RADIUS accounting only in WLAN Services specifically configured to perform it.')
serverUsageModel = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 3, 9, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("roundRobin", 0), ("primaryBackup", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: serverUsageModel.setStatus('current')
if mibBuilder.loadTexts: serverUsageModel.setDescription('This field specifies RADIUS server failover behavior when the primary server goes down. When the primary server is down the controller moves on to the secondary or tertiary configured RADIUS Servers. If this field is set to primaryBackup(1), then the controller starts polling the primary RADIUS server to see if it is up. When the primary RADIUS server comes back, the controller automatically starts sending new access requests to the primary RADIUS server but pending requests continue with backup RADIUS server. The administrator can select between the two strategies, i.e. the existing roundRobin(0) or new primaryBackup(1). This only applies to Authentication, not to Accounting.')
radacctStartOnIPAddr = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 3, 9, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radacctStartOnIPAddr.setStatus('current')
if mibBuilder.loadTexts: radacctStartOnIPAddr.setDescription("When this OID is set to disabled (0) the controller sends a RADIUS accounting start message as soon as it receives an Access-Accept for the user from a RADIUS server. When this OID is set to enabled(1) the controller defers sending the RADIUS accounting start message until an Access-Accept for the client is received and the client's IP address is known.")
clientServiceTypeLogin = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 3, 9, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: clientServiceTypeLogin.setStatus('current')
if mibBuilder.loadTexts: clientServiceTypeLogin.setDescription("When this OID is set to enabled(1) the controller sets the Service-Type attribute of a station's Access-Request to 'Login'. When this OID is set to disabled(0) the controller sets the Service-Type attribute of a station's Access-Request to 'Framed'. By default this OID is set to 'disabled'. You cannot use RADIUS servers to authenticate administrators for local server access when this OID is set to 'enabled'.")
applyMacAddressFormat = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 3, 9, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: applyMacAddressFormat.setStatus('current')
if mibBuilder.loadTexts: applyMacAddressFormat.setDescription('When this OID is set to enabled(1), the controller uses MAC-Based Authentication MAC address format (refer to radiusMacAddressFormatOption) for user authentication and accounting via RADIUS.')
radiusExtnsSetting = MibIdentifier((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 3, 10))
radiusExtnsSettingTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 3, 10, 1), )
if mibBuilder.loadTexts: radiusExtnsSettingTable.setStatus('current')
if mibBuilder.loadTexts: radiusExtnsSettingTable.setDescription('List of RADIUS servers that will be used. ')
radiusExtnsSettingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 3, 10, 1, 1), ).setIndexNames((0, "HIPATH-WIRELESS-HWC-MIB", "radiusExtnsIndex"))
if mibBuilder.loadTexts: radiusExtnsSettingEntry.setStatus('current')
if mibBuilder.loadTexts: radiusExtnsSettingEntry.setDescription('An entry for each RADIUS server.')
radiusExtnsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 3, 10, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: radiusExtnsIndex.setStatus('current')
if mibBuilder.loadTexts: radiusExtnsIndex.setDescription('A number uniquely identifying each conceptual row in the radiusExtnsSettingTable. This value also equivalent to etsysRadiusAuthServerIndex of enterasys-radius-auth-client-mib.txt file.')
pollingMechanism = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 3, 10, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("authorizeAsActualUser", 0), ("useRFC5997StatusServerRequest", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pollingMechanism.setStatus('current')
if mibBuilder.loadTexts: pollingMechanism.setDescription("This field specifies the method to determine the health of the RADIUS server. If set to useRFC5997StatusServerRequest(1), RFC 5997 Status-Server packets will be sent to the primary server to determine it's health. If set to authorizeAsActualUser(0), access-request messages for a specified user account will be sent to the primary server to determine it's health.")
serverPollingInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 3, 10, 1, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: serverPollingInterval.setStatus('current')
if mibBuilder.loadTexts: serverPollingInterval.setDescription('Interval in seconds for the controller to poll the primary server.')
netflowAndMirrorN = MibIdentifier((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 3, 11))
netflowDestinationIP = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 3, 11, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: netflowDestinationIP.setStatus('current')
if mibBuilder.loadTexts: netflowDestinationIP.setDescription('The IP address for the Purview engine that will receive netflow records.')
netflowInterval = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 3, 11, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(30, 360)).clone(60)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: netflowInterval.setStatus('current')
if mibBuilder.loadTexts: netflowInterval.setDescription('The netflow record sending interval.')
mirrorFirstN = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 3, 11, 3), Integer32().clone(15)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mirrorFirstN.setStatus('current')
if mibBuilder.loadTexts: mirrorFirstN.setDescription('If non-zero, the first N packets of a particular flow will be mirrored. If 0, all packets will be mirrored.')
mirrorL2Ports = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 3, 11, 4), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mirrorL2Ports.setStatus('current')
if mibBuilder.loadTexts: mirrorL2Ports.setDescription('Configure the mirror port(s) on the controller. The default value is None. Only l2ports will be allowed to be selected and only when not referred to elsewhere (lag, topologies). The most significant bit of the most significant octet represents the first esa port (esa0). The second most significant bit of the most significant octet represents the second esa port (esa1) and so on.')
radiusMacAddressFormatOption = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 3, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 9, 10, 11, 12))).clone(namedValues=NamedValues(("option1", 1), ("option2", 2), ("option3", 3), ("option4", 4), ("option5", 5), ("option6", 6), ("option7", 7), ("option8", 9), ("option10", 10), ("option11", 11), ("option12", 12)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radiusMacAddressFormatOption.setStatus('current')
if mibBuilder.loadTexts: radiusMacAddressFormatOption.setDescription('The controller allows configuring different kinds of Mac address format in RADIUS messages. option1: mac address format as XXXXXXXXXXXX option2: mac address format as XX:XX:XX:XX:XX:XX option3: mac address format as XX-XX-XX-XX-XX-XX option4: mac address format as XXXX.XXXX.XXXX option5: mac address format as XXXXXX-XXXXXX option6: mac address format as XX XX XX XX XX XX option7: mac address format as xxxxxxxxxxxx option8: mac address format as xx:xx:xx:xx:xx:xx option9: mac address format as xx-xx-xx-xx-xx-xx option10: mac address format as xxxx.xxxx.xxxx option11: mac address format as xxxxxx-xxxxxx option12: mac address format as xx xx xx xx xx xx')
wlan = MibIdentifier((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4))
wlanMaxEntries = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wlanMaxEntries.setStatus('current')
if mibBuilder.loadTexts: wlanMaxEntries.setDescription('Maximum number of WLAN supported by the device.')
wlanNumEntries = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wlanNumEntries.setStatus('current')
if mibBuilder.loadTexts: wlanNumEntries.setDescription('The current number of entries in the wlanTable.')
wlanTableNextAvailableIndex = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wlanTableNextAvailableIndex.setStatus('current')
if mibBuilder.loadTexts: wlanTableNextAvailableIndex.setDescription('This object indicates numerically lowest available index within this entity, which may be used for the value of index in the creation of new entry in wlanTable. An index is considered available if the index falls within the range of 1 to wlanMaxEntries and it is not being used to index an existing entry in the wlanTable contained this entity. This value should only be used as guideline for the management application and there is no requirement on the management application to create entries based upon this index value. Value of zero indicates there is no more room for new wlanTable creation.')
wlanTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 4), )
if mibBuilder.loadTexts: wlanTable.setStatus('current')
if mibBuilder.loadTexts: wlanTable.setDescription('Table of configured WLAN. ')
wlanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 4, 1), ).setIndexNames((0, "HIPATH-WIRELESS-HWC-MIB", "wlanID"))
if mibBuilder.loadTexts: wlanEntry.setStatus('current')
if mibBuilder.loadTexts: wlanEntry.setDescription('An entry for each WLAN.')
wlanID = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 4, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wlanID.setStatus('current')
if mibBuilder.loadTexts: wlanID.setDescription('Unique internal ID associated with WLAN.')
wlanRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 4, 1, 2), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanRowStatus.setStatus('current')
if mibBuilder.loadTexts: wlanRowStatus.setDescription("This object allows dynamic creation and deletion of entries within wlanTable as well as activation and deactivation of these entries. For row creation, EWC only supports creatAndWait. WLAN name must be set before making the row active and persistent. Any WLAN that is associated to a VNS cannot be deleted unless it is first disassociated from VNS before being deleted. Any inactive entry will not be persistent and it will be lost during controller's restart.")
wlanServiceType = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 3, 4, 5, 6))).clone(namedValues=NamedValues(("standard", 0), ("wds", 3), ("thirdParty", 4), ("remote", 5), ("mesh", 6))).clone('standard')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanServiceType.setStatus('current')
if mibBuilder.loadTexts: wlanServiceType.setDescription('Service type of WLAN.')
wlanName = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 4, 1, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanName.setStatus('current')
if mibBuilder.loadTexts: wlanName.setDescription('Text string uniquely identifying WLAN within EWC. Allowable characters for this field are from the set of A-Z, a-z, -!#$:, 0-9, and space. Howerver, it is recommended to avoid leading and trailing spaces.')
wlanSSID = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 4, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanSSID.setStatus('current')
if mibBuilder.loadTexts: wlanSSID.setDescription('SSID (broadcast string) associated with WLAN. Allowable characters for this field are from the set of A-Z, a-z, _-.@, 0-9, and space. Howerver, it is recommendedto avoid leading and trailing spaces.')
wlanSynchronize = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 4, 1, 6), TruthValue().clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanSynchronize.setStatus('current')
if mibBuilder.loadTexts: wlanSynchronize.setDescription('If it is set to true, then WLAN will be replicated to peer controller if availability is configured and enabled.')
wlanEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 4, 1, 7), TruthValue().clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanEnabled.setStatus('current')
if mibBuilder.loadTexts: wlanEnabled.setDescription('This field is used to enable or disable this WLAN. If WLAN is disabled, then no traffic will be passed on behalf of this WLAN.')
wlanDefaultTopologyID = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 4, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(-1, -1), ValueRangeConstraint(0, 65535), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanDefaultTopologyID.setStatus('current')
if mibBuilder.loadTexts: wlanDefaultTopologyID.setDescription('The ID of topology from topologyTable associated to this WLAN. Topology ID of -1 means no default topology is associated to this WLAN. Physical topologies cannot be assigned to WLAN. The default topology indicates which topology to use for this WLAN if there is no topology associated with VNS via policy assignment.')
wlanSessionTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 4, 1, 9), Unsigned32()).setUnits('minute').setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanSessionTimeout.setStatus('current')
if mibBuilder.loadTexts: wlanSessionTimeout.setDescription('MU session that is associated to this WLAN will be terminated after elapse of this number of minutes from the start of its current session.')
wlanIdleTimeoutPreAuth = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 4, 1, 10), Unsigned32().clone(5)).setUnits('minute').setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanIdleTimeoutPreAuth.setStatus('current')
if mibBuilder.loadTexts: wlanIdleTimeoutPreAuth.setDescription('Elapse time between association and authentication after which MU session will be terminated if the user is idle this amount of time without being authenticated.')
wlanIdleSessionPostAuth = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 4, 1, 11), Unsigned32().clone(30)).setUnits('minute').setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanIdleSessionPostAuth.setStatus('current')
if mibBuilder.loadTexts: wlanIdleSessionPostAuth.setDescription('MU session that is associated to this WLAN will be terminated if the user is idle this amount of time after being authenticated.')
wlanSupressSSID = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 4, 1, 12), TruthValue().clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanSupressSSID.setStatus('current')
if mibBuilder.loadTexts: wlanSupressSSID.setDescription('If it is set to true then broadcast string (SSID) for this WLAN will not be broadcasted over the air.')
wlanDot11hSupport = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 4, 1, 13), TruthValue().clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanDot11hSupport.setStatus('current')
if mibBuilder.loadTexts: wlanDot11hSupport.setDescription('If it is set to true then dot11h support is enabled for clients associated to this WLAN.')
wlanDot11hClientPowerReduction = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 4, 1, 14), TruthValue().clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanDot11hClientPowerReduction.setStatus('current')
if mibBuilder.loadTexts: wlanDot11hClientPowerReduction.setDescription('If it is set to true then apply power reduction to dot11h clients associated to this WLAN. This field has meaning if wlanDot11hSupport is enabled (set to true).')
wlanProcessClientIE = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 4, 1, 15), TruthValue().clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanProcessClientIE.setStatus('current')
if mibBuilder.loadTexts: wlanProcessClientIE.setDescription('If it is set to true then clients that are associated to this WLAN their IE requests will be processed.')
wlanEngerySaveMode = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 4, 1, 16), TruthValue().clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanEngerySaveMode.setStatus('current')
if mibBuilder.loadTexts: wlanEngerySaveMode.setDescription('If it is set to true then engergy saving mode is enabled.')
wlanBlockMuToMuTraffic = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 4, 1, 17), TruthValue().clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanBlockMuToMuTraffic.setStatus('current')
if mibBuilder.loadTexts: wlanBlockMuToMuTraffic.setDescription('If it is set to true then two MU associated to this WLAN cannot communicate with each other.')
wlanRemoteable = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 4, 1, 18), TruthValue().clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanRemoteable.setStatus('current')
if mibBuilder.loadTexts: wlanRemoteable.setDescription('If it is set to true then this WLAN can be used as remote WLAN within mobility zone that this controller is partaking.')
wlanVNSID = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 4, 1, 19), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wlanVNSID.setStatus('current')
if mibBuilder.loadTexts: wlanVNSID.setDescription('The ID of the VNS that uses this WLAN. WLAN can be created but not used in any VNS, in that case alue of zero indicates WLAN has not been used in any VNS. The value of this field set during VNS creation no during the WLAN creation. ')
wlanRadioManagement11k = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 4, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanRadioManagement11k.setStatus('current')
if mibBuilder.loadTexts: wlanRadioManagement11k.setDescription('When this bit is set to enable, the Radio Management (802.11k) feature is enabled on those APs who have this wlan configuration and 802.11k capability. ')
wlanBeaconReport = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 4, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanBeaconReport.setStatus('current')
if mibBuilder.loadTexts: wlanBeaconReport.setDescription('Enable/disable AP to send out beacon report. This field is configurable only if wlanRadioManagement11k is set to enable(1).')
wlanQuietIE = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 4, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanQuietIE.setStatus('current')
if mibBuilder.loadTexts: wlanQuietIE.setDescription('Enable/disable AP to advertise a Quiet Element. This field is configurable only if wlanRadioManagement11k is set to enable(1).')
wlanMirrorN = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 4, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("prohibited", 0), ("bothDirection", 1), ("rxDirectionOnly", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanMirrorN.setStatus('current')
if mibBuilder.loadTexts: wlanMirrorN.setDescription("prohibited(0): Mirroring is prohibited. bothDirection(1) : Both direction packets will be mirrored. rxDirectionOnly(2): Only receive direction packets will be mirrored. Note: This will only take effect when the user's runtime current Roles's MirrorN action is None. ")
wlanNetFlow = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 4, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanNetFlow.setStatus('current')
if mibBuilder.loadTexts: wlanNetFlow.setDescription('Enable/disable netflow on this WLAN service.')
wlanAppVisibility = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 4, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanAppVisibility.setStatus('current')
if mibBuilder.loadTexts: wlanAppVisibility.setDescription('Enable/disable both application visibility and control for this WLAN service.')
wlanStatsTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 5), )
if mibBuilder.loadTexts: wlanStatsTable.setStatus('current')
if mibBuilder.loadTexts: wlanStatsTable.setDescription('Stats related to WLAN (RFS) created on EWC.')
wlanStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 5, 1), ).setIndexNames((0, "HIPATH-WIRELESS-HWC-MIB", "wlanStatsID"))
if mibBuilder.loadTexts: wlanStatsEntry.setStatus('current')
if mibBuilder.loadTexts: wlanStatsEntry.setDescription('An entery for each existing WLAN on EWC.')
wlanStatsID = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 5, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wlanStatsID.setStatus('current')
if mibBuilder.loadTexts: wlanStatsID.setDescription('Unique internal ID associated with WLAN.')
wlanStatsAssociatedClients = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 5, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wlanStatsAssociatedClients.setStatus('current')
if mibBuilder.loadTexts: wlanStatsAssociatedClients.setDescription('Number of clients that are currently associated to this WLAN. ')
wlanStatsRadiusTotRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 5, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wlanStatsRadiusTotRequests.setStatus('current')
if mibBuilder.loadTexts: wlanStatsRadiusTotRequests.setDescription("Number of requests that were sent to RADIUS servers associated to this WLAN on behalf of MUs' requests using SSID associated to the WLAN for association, authentication or authorization to this WLAN.")
wlanStatsRadiusReqFailed = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 5, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wlanStatsRadiusReqFailed.setStatus('current')
if mibBuilder.loadTexts: wlanStatsRadiusReqFailed.setDescription("Number of requests that were sent to RADIUS servers associated to this WLAN on behalf of MUs' requests for association, authentication or authorization to this WLAN but failed to be processed by RADIUS servers.")
wlanStatsRadiusReqRejected = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 5, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wlanStatsRadiusReqRejected.setStatus('current')
if mibBuilder.loadTexts: wlanStatsRadiusReqRejected.setDescription("Number of requests that were sent to RADIUS servers associated to this WLAN on behalf of MUs' requests for association, authentication or authorization to this WLAN but rejected to be processed by RADIUS servers.")
wlanPrivTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 6), )
if mibBuilder.loadTexts: wlanPrivTable.setStatus('current')
if mibBuilder.loadTexts: wlanPrivTable.setDescription('This table contains configuration of privacy settings for all configured WLAN on EWC. For each of the configured WLAN on the controller one entry is added to this table. Addition/deletion of entries in this table are automatic depending on the addition or deletion of entries in wlanTable table.')
wlanPrivEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 6, 1), ).setIndexNames((0, "HIPATH-WIRELESS-HWC-MIB", "wlanID"))
if mibBuilder.loadTexts: wlanPrivEntry.setStatus('current')
if mibBuilder.loadTexts: wlanPrivEntry.setDescription('An entry in wlanPrivTable for each configured WLAN on EWC. Each entry is indexed with corresponding wlan ID of wlanTable. The writable fields in this table can be modified depending on the corresponding wlanTable.')
wlanPrivPrivacyType = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 6, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 0), ("staticWEP", 1), ("dynamicWEP", 2), ("wpa", 3), ("wpaPSK", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanPrivPrivacyType.setStatus('current')
if mibBuilder.loadTexts: wlanPrivPrivacyType.setDescription('Type of privacy applied to the corresponding configured WLAN. Configuration of the other fields in this table depends on the value of this field, e.g. if this field is set to none(0), then no other field in this table are settable. ')
wlanPrivWEPKeyIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 6, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanPrivWEPKeyIndex.setStatus('current')
if mibBuilder.loadTexts: wlanPrivWEPKeyIndex.setDescription('Index of configured WEP. This field is required if and only if privacy type is staticWEP(1).')
wlanPrivWEPKeyLength = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 6, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("sixtyFourBits", 1), ("oneHundred28Bits", 2), ("oneHundred52Bits", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanPrivWEPKeyLength.setStatus('current')
if mibBuilder.loadTexts: wlanPrivWEPKeyLength.setDescription('Key legnth for the configured WEP key. This field is required if and only if privacy type is staticWEP(1).')
wlanPrivWEPKey = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 6, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(8, 19))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanPrivWEPKey.setStatus('current')
if mibBuilder.loadTexts: wlanPrivWEPKey.setDescription('The configured WEP key length must match the wlanPrivWEPKeyLength field. Any key with length longer or shorter than that length will be rejected. This field is required if and only if privacy type is staticWEP(1). This key can only be viewed in SNMPv3 mode with privacy.')
wlanPrivWPAv1EncryptionType = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 6, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("undefined", 0), ("tkipOnly", 1), ("auto", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanPrivWPAv1EncryptionType.setStatus('current')
if mibBuilder.loadTexts: wlanPrivWPAv1EncryptionType.setDescription('The type of encryption used for WPA version 1 associations. This OID is undefined unless wlanPrivPrivacyType is wpa (3) or wpaPSK (4) and wlanPrivWPAversion is set to wpaV1 (1) or wpaV1andV2 (3).')
wlanPrivWPAv2EncryptionType = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 6, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2, 3))).clone(namedValues=NamedValues(("undefined", 0), ("auto", 2), ("aesOnly", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanPrivWPAv2EncryptionType.setStatus('current')
if mibBuilder.loadTexts: wlanPrivWPAv2EncryptionType.setDescription('The type of encryption used for WPA version 2 associations. This OID is undefined unless wlanPrivPrivacyType is wpa (3) or wpaPSK (4) and wlanPrivWPAversion is set to wpaV2 (2) or wpaV1 and V2 (3).')
wlanPrivKeyManagement = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 6, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("none", 0), ("opportunisticKey", 1), ("preAuthentication", 2), ("both", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanPrivKeyManagement.setStatus('current')
if mibBuilder.loadTexts: wlanPrivKeyManagement.setDescription('Key management option available for the WPA2. This field has meaning if privacy type is WPA with WPA2 option enabled. This field can be modified only if wlanPrivPrivacyType is set to wpa(3) and wlanPrivWPAversion set to wpaV2(2) or wpaV1andV2(3). .')
wlanPrivBroadcastRekeying = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 6, 1, 8), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanPrivBroadcastRekeying.setStatus('current')
if mibBuilder.loadTexts: wlanPrivBroadcastRekeying.setDescription('Broadcast rekeying if this value is set to true. This field can be modified only if wlanPrivPrivacyType is set to wpa(3) or wpaPSK(4).')
wlanPrivRekeyInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 6, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(30, 86400)).clone(3600)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanPrivRekeyInterval.setStatus('current')
if mibBuilder.loadTexts: wlanPrivRekeyInterval.setDescription('Interval in seconds for requesting rekeying. This field has meaning if privacy type is WPA and broadcast rekeying is enabled (wlanPrivBroadcastRekeying is set to true). This field can be modified only if wlanPrivBroadcastRekeying is set to true.')
wlanPrivGroupKPSR = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 6, 1, 10), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanPrivGroupKPSR.setStatus('current')
if mibBuilder.loadTexts: wlanPrivGroupKPSR.setDescription('Group Key Power Save Retry (GKPSR) value for the WPA type of privacy. This field can be modified only if wlanPrivPrivacyType is set to wpa(3) or wpaPSK(4).')
wlanPrivWPAPSK = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 6, 1, 11), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 63))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanPrivWPAPSK.setStatus('current')
if mibBuilder.loadTexts: wlanPrivWPAPSK.setDescription('WPA-PSK shared key. This field has meaning if and only if WLAN privacy type is set to WPA-PSK. Input type can be either HEX formatted string or ASCII string. In case of HEX string, it must be 64 octets from set of hex characters. In case of ASCII string, the length is limited between 8 to 63 octets. This key can only be viewed in SNMPv3 mode with privacy. This field can be modified only if wlanPrivPrivacyType is set to wpaPSK(4).')
wlanPrivWPAversion = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 6, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("wpaNone", 0), ("wpaV1", 1), ("wpaV2", 2), ("wpaV1andV2", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanPrivWPAversion.setStatus('current')
if mibBuilder.loadTexts: wlanPrivWPAversion.setDescription('Type of wpa version selected. This field can be modified only if wlanPrivPrivacyType is set to wpa(3) or wpaPSK(4). Note: wpa version v1 only is not allowed. 0 - no wpa version selected. 1 - wpa version v1 selected. 2 - wpa version v2 selected. 3 - both wpa version v1 and v2 selected.')
wlanPrivfastTransition = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 6, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanPrivfastTransition.setStatus('current')
if mibBuilder.loadTexts: wlanPrivfastTransition.setDescription('When this field is set to enable(1), the 802.11r (fast transition) is enabled. This field can be modified only if wlanPrivPrivacyType is set to wpa(2).')
wlanPrivManagementFrameProtection = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 6, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1), ("require", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanPrivManagementFrameProtection.setStatus('current')
if mibBuilder.loadTexts: wlanPrivManagementFrameProtection.setDescription('Disable(0) : The AP will not encrypt any management frames. Enable(1): The AP will encrypt management frames for clients who also support this feature. If the clients do not support this feature, they are still able to connect to the AP but with no management frames encryption. Require(2): The AP will only allow clients who have the PMF feature to connect. Supported management frames will be encrypted to 802.11w standards. Clients who do not support this feature will not be able to associate. ')
wlanAuthTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 7), )
if mibBuilder.loadTexts: wlanAuthTable.setStatus('current')
if mibBuilder.loadTexts: wlanAuthTable.setDescription('This table contains configuration of authentication settings for all configured WLAN on EWC. For each of the configured WLAN on the controller one entry is added to this table. Addition/deletion of entries in this table are automatic depending on the addition/deletion of entries in wlanTable table.')
wlanAuthEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 7, 1), ).setIndexNames((0, "HIPATH-WIRELESS-HWC-MIB", "wlanID"))
if mibBuilder.loadTexts: wlanAuthEntry.setStatus('current')
if mibBuilder.loadTexts: wlanAuthEntry.setDescription('An entry in wlanAuthTable for each configured WLAN on EWC. Each entry is indexed with corresponding wlan ID of wlanTable. The writable fields in this table can be modified depending on the corresponding wlanTable. Note: All the fields in this table except wlanAuthType and wlanAuthCollectAcctInformation have meaning if MAC-based authentication filed (wlanAuthMacBasedAuth) is set to true. ')
wlanAuthType = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 7, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("disabled", 1), ("internalCP", 2), ("dot1x", 3), ("externalCP", 4), ("easyGuestCP", 5), ("guestSplash", 6), ("firewallFriendlyExCP", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanAuthType.setStatus('current')
if mibBuilder.loadTexts: wlanAuthType.setDescription('The type of authentication applied to stations attempting to associate to a BSSID belonging to this WLAN Service. If the dot1x type is selected, then this WLAN must have privacy. When the dot1x or internalCP is selected, the controller must have a RADIUS server, and SNMP will auto assign one RADIUS server to this WLAN if the user did not assign one.')
wlanAuthMacBasedAuth = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 7, 1, 2), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanAuthMacBasedAuth.setStatus('current')
if mibBuilder.loadTexts: wlanAuthMacBasedAuth.setDescription('MAC based authorization is enabled if this field is set to true. When this field set to true, SNMP will auto configure one RADIUS server to enable MAC authorization. ')
wlanAuthMACBasedAuthOnRoam = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 7, 1, 3), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanAuthMACBasedAuthOnRoam.setStatus('current')
if mibBuilder.loadTexts: wlanAuthMACBasedAuthOnRoam.setDescription('If it is set to true, the client will be forced to go through MAC based authorization when the client roamed. This field has meaning only when wlanAuthMacBasedAuth is set to true. This field can be modified only when wlanAuthMacBasedAuth is set to true. ')
wlanAuthAutoAuthAuthorizedUser = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 7, 1, 4), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanAuthAutoAuthAuthorizedUser.setStatus('current')
if mibBuilder.loadTexts: wlanAuthAutoAuthAuthorizedUser.setDescription('All authorized users will be considered authenticated automatically. This field has meaning only when wlanAuthMacBasedAuth is set to true. This field can be modified only when wlanAuthMacBasedAuth is set to true.')
wlanAuthAllowUnauthorizedUser = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 7, 1, 5), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanAuthAllowUnauthorizedUser.setStatus('current')
if mibBuilder.loadTexts: wlanAuthAllowUnauthorizedUser.setDescription('Unauthorized users will be allowed if this field is set to true.This field has meaning only when wlanAuthMacBasedAuth is set to true. This field can be modified only when wlanAuthMacBasedAuth is set to true.')
wlanAuthRadiusIncludeAP = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 7, 1, 6), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanAuthRadiusIncludeAP.setStatus('current')
if mibBuilder.loadTexts: wlanAuthRadiusIncludeAP.setDescription('AP serial number will be included in RADIUS request packet as VSA if this field is set to true.')
wlanAuthRadiusIncludeVNS = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 7, 1, 7), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanAuthRadiusIncludeVNS.setStatus('current')
if mibBuilder.loadTexts: wlanAuthRadiusIncludeVNS.setDescription('VNS name will be included in RADIUS request packet as VSA if this field is set to true.')
wlanAuthRadiusIncludeSSID = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 7, 1, 8), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanAuthRadiusIncludeSSID.setStatus('current')
if mibBuilder.loadTexts: wlanAuthRadiusIncludeSSID.setDescription('WLAN SSID will be included in RADIUS request packet as VSA if this field is set to true.')
wlanAuthRadiusIncludePolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 7, 1, 9), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanAuthRadiusIncludePolicy.setStatus('current')
if mibBuilder.loadTexts: wlanAuthRadiusIncludePolicy.setDescription('Policy name will be included in RADIUS request packet as VSA if this field is set to true.')
wlanAuthRadiusIncludeTopology = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 7, 1, 10), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanAuthRadiusIncludeTopology.setStatus('current')
if mibBuilder.loadTexts: wlanAuthRadiusIncludeTopology.setDescription('Topology name will be included in RADIUS request packet as VSA if this field is set to true.')
wlanAuthRadiusIncludeIngressRC = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 7, 1, 11), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanAuthRadiusIncludeIngressRC.setStatus('current')
if mibBuilder.loadTexts: wlanAuthRadiusIncludeIngressRC.setDescription('Ingress rate control name will be included in RADIUS request packet as VSA if this field is set to true.')
wlanAuthRadiusIncludeEgressRC = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 7, 1, 12), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanAuthRadiusIncludeEgressRC.setStatus('current')
if mibBuilder.loadTexts: wlanAuthRadiusIncludeEgressRC.setDescription('Egress rate control name will be included in RADIUS request packet as VSA if this field is set to true.')
wlanAuthCollectAcctInformation = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 7, 1, 13), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanAuthCollectAcctInformation.setStatus('current')
if mibBuilder.loadTexts: wlanAuthCollectAcctInformation.setDescription('Accounting information is collected for clients if this field is set to true.')
wlanAuthReplaceCalledStationIDWithZone = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 7, 1, 14), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanAuthReplaceCalledStationIDWithZone.setStatus('current')
if mibBuilder.loadTexts: wlanAuthReplaceCalledStationIDWithZone.setDescription('Replace called station ID with Zone if this field is set to true.')
wlanAuthRadiusAcctAfterMacBaseAuthorization = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 7, 1, 15), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanAuthRadiusAcctAfterMacBaseAuthorization.setStatus('current')
if mibBuilder.loadTexts: wlanAuthRadiusAcctAfterMacBaseAuthorization.setDescription('RADIUS accounting begins after MAC-based authorization completes if this field is set to true. This field has meaning only when wlanAuthMacBasedAuth is set to true. This field can be modified only when wlanAuthMacBasedAuth is set to true.')
wlanAuthRadiusTimeoutRole = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 7, 1, 16), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanAuthRadiusTimeoutRole.setStatus('current')
if mibBuilder.loadTexts: wlanAuthRadiusTimeoutRole.setDescription("Apply this role to clients when the RADIUS server timed out. '-1' is treat like access reject. Any other number is the Role ID. This field has meaning only when wlanAuthMacBasedAuth is set to true. This field can be modified only when wlanAuthMacBasedAuth is set to true.")
wlanAuthRadiusOperatorNameSpace = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 7, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(-1, 48, 49, 50, 51))).clone(namedValues=NamedValues(("disabled", -1), ("tadig", 48), ("realm", 49), ("e212", 50), ("icc", 51)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanAuthRadiusOperatorNameSpace.setStatus('current')
if mibBuilder.loadTexts: wlanAuthRadiusOperatorNameSpace.setDescription('wlanAuthRadiusOperatorNameSpace is the Namespace ID as defined in RFC 5580. The value within this field contains the operator namespace identifier. The Namespace ID value is encoded in ASCII and has the following values. -1 : disabled. 48 : TADIG. 49 : REALM. 50 : E212. 51 : ICC. ')
wlanAuthRadiusOperatorName = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 7, 1, 18), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanAuthRadiusOperatorName.setStatus('current')
if mibBuilder.loadTexts: wlanAuthRadiusOperatorName.setDescription('RADIUS accounting message will include this string when the wlanAuthRadiusOperatorNameSpace is not set to -1.')
wlanAuthMACBasedAuthReAuthOnAreaRoam = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 7, 1, 19), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanAuthMACBasedAuthReAuthOnAreaRoam.setStatus('current')
if mibBuilder.loadTexts: wlanAuthMACBasedAuthReAuthOnAreaRoam.setDescription('If this field is set to true, the client will be forced to go through MAC based authorization when the client roams to another area. This field has meaning and can be modified only when wlanAuthMacBasedAuth is set to true. ')
wlanRadiusTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 8), )
if mibBuilder.loadTexts: wlanRadiusTable.setStatus('current')
if mibBuilder.loadTexts: wlanRadiusTable.setDescription('This table contains configuration of RADIUS settings for all configured WLAN on EWC. For each of the configured WLAN on the controller there may exist one or more entries of RADIUS server(s) serving the WLAN. Addition/deletion of entries in this table are automatic depending on the addition/deletion of entries in wlanTable table.')
wlanRadiusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 8, 1), ).setIndexNames((0, "HIPATH-WIRELESS-HWC-MIB", "wlanID"), (0, "HIPATH-WIRELESS-HWC-MIB", "wlanRadiusIndex"))
if mibBuilder.loadTexts: wlanRadiusEntry.setStatus('current')
if mibBuilder.loadTexts: wlanRadiusEntry.setDescription('An entry in wlanRadiusTable for each RADIUS server used by the WLAN indexed by wlanID.')
wlanRadiusIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 8, 1, 1), Unsigned32())
if mibBuilder.loadTexts: wlanRadiusIndex.setStatus('current')
if mibBuilder.loadTexts: wlanRadiusIndex.setDescription('Internally generated index and it has no external meaning.')
wlanRadiusName = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 8, 1, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanRadiusName.setStatus('current')
if mibBuilder.loadTexts: wlanRadiusName.setDescription('Name of the RADIUS server associated to this entry.')
wlanRadiusUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 8, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("auth", 1), ("mac", 2), ("acc", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanRadiusUsage.setStatus('current')
if mibBuilder.loadTexts: wlanRadiusUsage.setDescription('Usage type associated to this entry for authentication.')
wlanRadiusPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 8, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanRadiusPriority.setStatus('current')
if mibBuilder.loadTexts: wlanRadiusPriority.setDescription('Priority associated to this entry for authentication. RADIUS servers are contacted for authentication requests in the order of their priority defined in this field. The highest priority servers (priorities with lower numerical values have higher priority order) are consulted first for any authentication request.')
wlanRadiusPort = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 8, 1, 5), Unsigned32().clone(1812)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanRadiusPort.setStatus('current')
if mibBuilder.loadTexts: wlanRadiusPort.setDescription('The RADIUS authentication requests should be sent to this authentication port.')
wlanRadiusRetries = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 8, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 32)).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanRadiusRetries.setStatus('current')
if mibBuilder.loadTexts: wlanRadiusRetries.setDescription('Maximum number of retries attempted for an specific authentication request.')
wlanRadiusTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 8, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 360)).clone(5)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanRadiusTimeout.setStatus('current')
if mibBuilder.loadTexts: wlanRadiusTimeout.setDescription('Number of seconds to wait for a response from authentication server for each request sent to the server before considering the request as failure.')
wlanRadiusNASUseVnsIP = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 8, 1, 8), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanRadiusNASUseVnsIP.setStatus('current')
if mibBuilder.loadTexts: wlanRadiusNASUseVnsIP.setDescription('If this value is set to true, then VNS IP address associated to the WLAN indexed by wlanID to this entry is used as NAS IP address. Otherwise NAS IP address should be configured manually.')
wlanRadiusNASIP = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 8, 1, 9), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanRadiusNASIP.setStatus('current')
if mibBuilder.loadTexts: wlanRadiusNASIP.setDescription('NAS IP associated to this RADIUS server. Configuration of this field is directly affected by the value of wlanRadiusNASUseVnsIP.')
wlanRadiusNASIDUseVNSName = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 8, 1, 10), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanRadiusNASIDUseVNSName.setStatus('current')
if mibBuilder.loadTexts: wlanRadiusNASIDUseVNSName.setDescription('If this value is set to true, then use VNS name associated to the WLAN indexed by wlanID for this entry as NAS ID. Otherwise NAS ID should be configured manually.')
wlanRadiusNASID = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 8, 1, 11), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanRadiusNASID.setStatus('current')
if mibBuilder.loadTexts: wlanRadiusNASID.setDescription('NAS ID associated to this RADIUS server. Configuration of this field is directly affected by the value of wlanRadiusNASIDUseVNSName.')
wlanRadiusAuthType = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 8, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("pap", 0), ("chap", 1), ("mschap", 2), ("mschap2", 3))).clone('pap')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanRadiusAuthType.setStatus('current')
if mibBuilder.loadTexts: wlanRadiusAuthType.setDescription('Authentication type used for this WLAN when using this RADIUS server to authenticate users.')
wlanCPTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 9), )
if mibBuilder.loadTexts: wlanCPTable.setStatus('current')
if mibBuilder.loadTexts: wlanCPTable.setDescription('This table contains configuration of Captive Portal settings for all configured WLAN on EWC. For each of the configured WLAN on the controller one entry is added to this table. Addition/deletion of entries in this table are automatic depending on the addition/deletion of entries in wlanTable table. This table can be accessed using SNMPv3 on behalf of users with privacy.')
wlanCPEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 9, 1), ).setIndexNames((0, "HIPATH-WIRELESS-HWC-MIB", "wlanID"))
if mibBuilder.loadTexts: wlanCPEntry.setStatus('current')
if mibBuilder.loadTexts: wlanCPEntry.setDescription("An entry in wlanCPTable for each configured WLAN on EWC. Each entry is indexed with corresponding wlan ID of wlanTable. The writable fields in this table can be modified depending on the corresponding wlanTable and type of CP assigned to the WLAN. If the authentication type is 'disabled(0)' for the WLAN, then all other entries in this table have no meaning.")
wlanCPAuthType = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 9, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("disabled", 1), ("internalCP", 2), ("dot1x", 3), ("externalCP", 4), ("easyGuestCP", 5), ("guestSplash", 6), ("firewallFriendlyExCP", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanCPAuthType.setStatus('current')
if mibBuilder.loadTexts: wlanCPAuthType.setDescription('Type of authentication applied to MU requesting association using SSID associated to this WLAN.')
wlanCP802HttpRedirect = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 9, 1, 2), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanCP802HttpRedirect.setStatus('current')
if mibBuilder.loadTexts: wlanCP802HttpRedirect.setDescription("If it is set to true, then CP will be redirected to configured CP. This value has meaning only for CP of the type 'dot1x(3)'.")
wlanCPExtConnection = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 9, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanCPExtConnection.setStatus('current')
if mibBuilder.loadTexts: wlanCPExtConnection.setDescription('IP address of the interface for this CP.')
wlanCPExtPort = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 9, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(32768, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanCPExtPort.setStatus('current')
if mibBuilder.loadTexts: wlanCPExtPort.setDescription('The port associated to the CP IP address.')
wlanCPExtEnableHttps = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 9, 1, 5), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanCPExtEnableHttps.setStatus('current')
if mibBuilder.loadTexts: wlanCPExtEnableHttps.setDescription('HTTPS support is enabled if this field is set to true.')
wlanCPExtEncryption = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 9, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("none", 0), ("legacy", 1), ("aes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanCPExtEncryption.setStatus('current')
if mibBuilder.loadTexts: wlanCPExtEncryption.setDescription('Type of encryption for the CP.')
wlanCPExtSharedSecret = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 9, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(16, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanCPExtSharedSecret.setStatus('current')
if mibBuilder.loadTexts: wlanCPExtSharedSecret.setDescription('Shared secret used for this captive portal.')
wlanCPExtTosOverride = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 9, 1, 8), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanCPExtTosOverride.setStatus('current')
if mibBuilder.loadTexts: wlanCPExtTosOverride.setDescription('Override ToS of NAC server usage only.')
wlanCPExtTosValue = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 9, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanCPExtTosValue.setStatus('deprecated')
if mibBuilder.loadTexts: wlanCPExtTosValue.setDescription('ToS value for NAC server only.')
wlanCPExtAddIPtoURL = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 9, 1, 10), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanCPExtAddIPtoURL.setStatus('current')
if mibBuilder.loadTexts: wlanCPExtAddIPtoURL.setDescription('If this value is set to true, then add EWC IP address and port number to the redirection URL.')
wlanCPIntLogoffButton = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 9, 1, 11), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanCPIntLogoffButton.setStatus('current')
if mibBuilder.loadTexts: wlanCPIntLogoffButton.setDescription("If set to true provide 'Logoff' button to the user in CP page.")
wlanCPIntStatusCheckButton = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 9, 1, 12), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanCPIntStatusCheckButton.setStatus('current')
if mibBuilder.loadTexts: wlanCPIntStatusCheckButton.setDescription("If set to true provide 'Status Check' button to the user in CP page.")
wlanCPReplaceIPwithFQDN = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 9, 1, 13), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanCPReplaceIPwithFQDN.setStatus('current')
if mibBuilder.loadTexts: wlanCPReplaceIPwithFQDN.setDescription('Replace CP gateway IP address with FQDN.')
wlanCPSendLoginTo = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 9, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("originalDestination", 0), ("cpSessionPage", 1), ("customURL", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanCPSendLoginTo.setStatus('current')
if mibBuilder.loadTexts: wlanCPSendLoginTo.setDescription('This field indicates to what URL the successful login session must be redirected. This field qualifies wlanCPRedirectURL.')
wlanCPRedirectURL = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 9, 1, 15), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanCPRedirectURL.setStatus('current')
if mibBuilder.loadTexts: wlanCPRedirectURL.setDescription('Text string identifying default redirection URL.')
wlanCPGuestAccLifetime = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 9, 1, 16), Unsigned32()).setUnits('days').setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanCPGuestAccLifetime.setStatus('current')
if mibBuilder.loadTexts: wlanCPGuestAccLifetime.setDescription('This value indicates for how many days the guest account is valid. Value of zero indicates that there is no limit for the guest account.')
wlanCPGuestAllowedLifetimeAcct = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 9, 1, 17), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanCPGuestAllowedLifetimeAcct.setStatus('current')
if mibBuilder.loadTexts: wlanCPGuestAllowedLifetimeAcct.setDescription('If this value is set to true, then guest admin can obtain lifetime account.')
wlanCPGuestSessionLifetime = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 9, 1, 18), Unsigned32()).setUnits('hours').setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanCPGuestSessionLifetime.setStatus('current')
if mibBuilder.loadTexts: wlanCPGuestSessionLifetime.setDescription('The guess account session using this CP cannot last longer than this number of hours. Value of zero means there is no limit for the session.')
wlanCPGuestIDPrefix = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 9, 1, 19), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanCPGuestIDPrefix.setStatus('current')
if mibBuilder.loadTexts: wlanCPGuestIDPrefix.setDescription('The prefix used for guest portal user ID label.')
wlanCPGuestMinPassLength = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 9, 1, 20), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 32)).clone(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanCPGuestMinPassLength.setStatus('current')
if mibBuilder.loadTexts: wlanCPGuestMinPassLength.setDescription('Minimum password length for the guest user account associated to this WLAN.')
wlanCPGuestMaxConcurrentSession = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 9, 1, 21), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 10)).clone(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanCPGuestMaxConcurrentSession.setStatus('current')
if mibBuilder.loadTexts: wlanCPGuestMaxConcurrentSession.setDescription('Maximum number of the guest users can use this set of credentials to access this concurrent session.')
wlanCPUseHTTPSforConnection = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 9, 1, 22), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanCPUseHTTPSforConnection.setStatus('current')
if mibBuilder.loadTexts: wlanCPUseHTTPSforConnection.setDescription('When this value set to true, use HTTPS for user connection. It has meaning only when wlanCPAuthType is set to internalCP(2) or easyGuestCP(5) or guestSplash(6) ')
wlanCPIdentity = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 9, 1, 23), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanCPIdentity.setStatus('current')
if mibBuilder.loadTexts: wlanCPIdentity.setDescription('wlanCPIdentity is used to identify the EWC to the external captive portal server (ECP) and the ECP to the EWC.')
wlanCPCustomSpecificURL = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 9, 1, 24), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanCPCustomSpecificURL.setStatus('current')
if mibBuilder.loadTexts: wlanCPCustomSpecificURL.setDescription('After a user successfully logs in, the user will be redirected to the URL as defined in the wlanCPCustomSpecificURL.')
wlanCPSelectionOption = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 9, 1, 25), Bits().clone(namedValues=NamedValues(("addEWCPortAndIP", 0), ("apNameAndSerial", 1), ("associatedBSSID", 2), ("vnsName", 3), ("userMacAddress", 4), ("currentlyAssignedRole", 5), ("containmentVLAN", 6), ("timeStamp", 7), ("signature", 8), ("ssid", 9)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanCPSelectionOption.setStatus('current')
if mibBuilder.loadTexts: wlanCPSelectionOption.setDescription('Append the above parameter(s) to the EWC captive portal redirection URL if one or more of the bits are set. ')
wlanUnsecuredWlanCounts = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wlanUnsecuredWlanCounts.setStatus('current')
if mibBuilder.loadTexts: wlanUnsecuredWlanCounts.setDescription('Total number of WLAN with security issues. The details of security issues can be found in wlanSecurityReportTable.')
wlanSecurityReportTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 11), )
if mibBuilder.loadTexts: wlanSecurityReportTable.setStatus('current')
if mibBuilder.loadTexts: wlanSecurityReportTable.setDescription('This table contains the weak configuration settings for all configured WLAN on EWC. For each of the configured WLAN on the controller there exist one entry in this table. Addition/deletion of entries in this table are automatic depending on the addition or deletion of entries in wlanTable table. This table can be accessed using SNMPv3 on behalf of users with privacy.')
wlanSecurityReportEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 11, 1), ).setIndexNames((0, "HIPATH-WIRELESS-HWC-MIB", "wlanID"))
if mibBuilder.loadTexts: wlanSecurityReportEntry.setStatus('current')
if mibBuilder.loadTexts: wlanSecurityReportEntry.setDescription('An entry in wlanSecurityReportTable for each configured WLAN on EWC. Each entry is indexed with corresponding wlan ID of wlanTable.')
wlanSecurityReportFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("unsecureSetting", 1), ("secureSetting", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wlanSecurityReportFlag.setStatus('current')
if mibBuilder.loadTexts: wlanSecurityReportFlag.setDescription('Value of secureSetting(2) indicates that WLAN has secure configuration.')
wlanSecurityReportUnsecureType = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 11, 1, 2), Bits().clone(namedValues=NamedValues(("open", 0), ("wep", 1), ("tkip", 2), ("defaultSsid", 3), ("hotspotSsid", 4), ("rainbowSsid", 5), ("dictionaryWordKey", 6), ("dictionaryWordSubstring", 7), ("passwordTooShort", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wlanSecurityReportUnsecureType.setStatus('current')
if mibBuilder.loadTexts: wlanSecurityReportUnsecureType.setDescription('bit 0: by setting this bit means this WLAN does not use any kind of encryption bit 1: by setting this bit means this WLAN uses weak WEP encryption bit 2: by setting this bit means this WLAN uses weak tkip encryption bit 3: by setting this bit means this WLAN uses default SSID bit 4: by setting this bit means this WLAN uses HotSpot SSID bit 5: by setting this bit means this WLAN uses Rainbow SSID bit 6: by setting this bit means this WLAN uses dictionary word as an encryption key bit 7: by setting this bit means this WLAN uses dictionary word in an encryption key string bit 8: by setting this bit means this WLAN uses a short password key')
wlanSecurityReportNotes = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 11, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wlanSecurityReportNotes.setStatus('current')
if mibBuilder.loadTexts: wlanSecurityReportNotes.setDescription('Textual description of any security issues related to the WLAN is reflected in this field.')
wlanRadiusServerTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 12), )
if mibBuilder.loadTexts: wlanRadiusServerTable.setStatus('current')
if mibBuilder.loadTexts: wlanRadiusServerTable.setDescription('This table contains configuration of RADIUS Servers settings for all configured WLANs on the Wireless Controller. For each of the configured WLANs on the controller there may exist one or more entries of RADIUS server(s) serving the WLAN. Addition/deletion of entries in this table are automatic depending on the addition/deletion of entries in wlanTable table.')
wlanRadiusServerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 12, 1), ).setIndexNames((0, "HIPATH-WIRELESS-HWC-MIB", "wlanID"), (0, "HIPATH-WIRELESS-HWC-MIB", "radiusId"))
if mibBuilder.loadTexts: wlanRadiusServerEntry.setStatus('current')
if mibBuilder.loadTexts: wlanRadiusServerEntry.setDescription("An entry in wlanRadiusServerTable for each RADIUS server used by the WLAN indexed by wlanID and radiusId. The radiusId is the controller's internal radius server index.")
radiusId = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 12, 1, 1), Unsigned32())
if mibBuilder.loadTexts: radiusId.setStatus('current')
if mibBuilder.loadTexts: radiusId.setDescription("Controller's internal RADIUS index.")
wlanRadiusServerName = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 12, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wlanRadiusServerName.setStatus('current')
if mibBuilder.loadTexts: wlanRadiusServerName.setDescription('Name of the RADIUS server.')
wlanRadiusServerUse = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("notUse", 0), ("use", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanRadiusServerUse.setStatus('current')
if mibBuilder.loadTexts: wlanRadiusServerUse.setDescription('use : This means that this WLAN service indexed by wlanID uses this RADIUS server which it is indexed by the radiusId. ')
wlanRadiusServerUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 12, 1, 4), Bits().clone(namedValues=NamedValues(("auth", 0), ("mac", 1), ("acct", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanRadiusServerUsage.setStatus('current')
if mibBuilder.loadTexts: wlanRadiusServerUsage.setDescription('bit 0: By setting this bit, this RADIUS server is used for authentication. This bit has meaning only when wlanAuthType is set to internalCP(2), dot1x(3), or externalCP(4). bit 1: By setting this bit, this RADIUS server is used for MAC-based authentication. This bit has meaning only when wlanAuthMacBasedAuth is set to true. bit 2: By setting this bit, this RADIUS server is used for accounting. This bit has meaning only when wlanAuthType is set to internalCP(2), dot1x(3), or externalCP(4).')
wlanRadiusServerAuthUseVNSIPAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 12, 1, 5), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanRadiusServerAuthUseVNSIPAddr.setStatus('current')
if mibBuilder.loadTexts: wlanRadiusServerAuthUseVNSIPAddr.setDescription("When this value set to true, use the VNS's IP address as NAS IP address during the authentication.")
wlanRadiusServerAuthNASIP = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 12, 1, 6), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanRadiusServerAuthNASIP.setStatus('current')
if mibBuilder.loadTexts: wlanRadiusServerAuthNASIP.setDescription("Use this IP address as the NAS IP addresss during the authentication. The default IP address is the VNS IP address. This field has meaning only when the wlanRadiusServerUsage's bit 0 is set. ")
wlanRadiusServerAuthUseVNSName = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 12, 1, 7), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanRadiusServerAuthUseVNSName.setStatus('current')
if mibBuilder.loadTexts: wlanRadiusServerAuthUseVNSName.setDescription("When this value set to true, use the VNS's name as the NAS identifier during the authentication.")
wlanRadiusServerAuthNASId = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 12, 1, 8), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanRadiusServerAuthNASId.setStatus('current')
if mibBuilder.loadTexts: wlanRadiusServerAuthNASId.setDescription("Use this name as the NAS identifier during the authentication. The default name is the VNS name. This field has meaning only when the wlanRadiusServerUsage's bit 0 is set.")
wlanRadiusServerAuthAuthType = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 12, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("pap", 0), ("chap", 1), ("mschap", 2), ("mschap2", 3), ("eap", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanRadiusServerAuthAuthType.setStatus('current')
if mibBuilder.loadTexts: wlanRadiusServerAuthAuthType.setDescription("Authentication type. This field has meaning only when the wlanRadiusServerUsage's bit 0 is set.")
wlanRadiusServerAcctUseVNSIPAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 12, 1, 10), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanRadiusServerAcctUseVNSIPAddr.setStatus('current')
if mibBuilder.loadTexts: wlanRadiusServerAcctUseVNSIPAddr.setDescription("When this value set to true, use the VNS's IP address as NAS IP address during the accounting.")
wlanRadiusServerAcctNASIP = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 12, 1, 11), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanRadiusServerAcctNASIP.setStatus('current')
if mibBuilder.loadTexts: wlanRadiusServerAcctNASIP.setDescription("Use this IP address as the NAS IP addresss during the accounting. The default IP address is the VNS IP address. This field has meaning only when the wlanRadiusServerUsage's bit 2 is set.")
wlanRadiusServerAcctUseVNSName = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 12, 1, 12), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanRadiusServerAcctUseVNSName.setStatus('current')
if mibBuilder.loadTexts: wlanRadiusServerAcctUseVNSName.setDescription("When this value set to true, use the VNS's name as the NAS identifier during the accounting.")
wlanRadiusServerAcctNASId = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 12, 1, 13), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanRadiusServerAcctNASId.setStatus('current')
if mibBuilder.loadTexts: wlanRadiusServerAcctNASId.setDescription("Use this name as the NAS identifier during the accounting. The default name is the VNS name. This field has meaning only when the wlanRadiusServerUsage's bit 2 is set.")
wlanRadiusServerAcctSIAR = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 12, 1, 14), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanRadiusServerAcctSIAR.setStatus('current')
if mibBuilder.loadTexts: wlanRadiusServerAcctSIAR.setDescription("If this value is set to true, then the controller sends interrim accounting records for fast failover events. This field has meaning only when the wlanRadiusServerUsage's bit 2 is set.")
wlanRadiusServerMacUseVNSIPAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 12, 1, 15), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanRadiusServerMacUseVNSIPAddr.setStatus('current')
if mibBuilder.loadTexts: wlanRadiusServerMacUseVNSIPAddr.setDescription("When this value set to true, use the VNS's IP address as NAS IP address during the MAC based authentication.")
wlanRadiusServerMacNASIP = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 12, 1, 16), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanRadiusServerMacNASIP.setStatus('current')
if mibBuilder.loadTexts: wlanRadiusServerMacNASIP.setDescription("Use this IP address as the NAS IP addresss during the MAC based authentication. The default IP address is the VNS IP address. This field has meaning only when the wlanRadiusServerUsage's bit 1 is set.")
wlanRadiusServerMacUseVNSName = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 12, 1, 17), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanRadiusServerMacUseVNSName.setStatus('current')
if mibBuilder.loadTexts: wlanRadiusServerMacUseVNSName.setDescription("When this value set to true, use the VNS's name as the NAS identifier during the MAC based authentication.")
wlanRadiusServerMacNASId = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 12, 1, 18), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanRadiusServerMacNASId.setStatus('current')
if mibBuilder.loadTexts: wlanRadiusServerMacNASId.setDescription("Use this name as the NAS identifier during the MAC based authentication. The default name is the VNS name. This field has meaning only when the wlanRadiusServerUsage's bit 1 is set.")
wlanRadiusServerMacAuthType = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 12, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("pap", 0), ("chap", 1), ("mschap", 2), ("mschap2", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanRadiusServerMacAuthType.setStatus('current')
if mibBuilder.loadTexts: wlanRadiusServerMacAuthType.setDescription("Authentication type. This field has meaning only when the wlanRadiusServerUsage's bit 1 is set.")
wlanRadiusServerMacPW = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 3, 4, 12, 1, 20), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanRadiusServerMacPW.setStatus('current')
if mibBuilder.loadTexts: wlanRadiusServerMacPW.setDescription("The password is used for MAC based authentication. This field has meaning only when the wlanRadiusServerUsage's bit 1 is set.")
topology = MibIdentifier((1, 3, 6, 1, 4, 1, 4329, 15, 3, 4))
topologyConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 4329, 15, 3, 4, 1))
topologyTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 4, 1, 1), )
if mibBuilder.loadTexts: topologyTable.setStatus('current')
if mibBuilder.loadTexts: topologyTable.setDescription('List of topologies configured on EWC.')
topologyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 4, 1, 1, 1), ).setIndexNames((0, "HIPATH-WIRELESS-HWC-MIB", "topologyID"))
if mibBuilder.loadTexts: topologyEntry.setStatus('current')
if mibBuilder.loadTexts: topologyEntry.setDescription('Configuration information about a topology in topology table. EWC supports different types of topologies, therefore, for complete configuration of a topology not all fields are necessary to be defined or have meaning. Definition of each field in this table specifies topolog-specific characteristics of the field and its relevance.')
topologyID = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 4, 1, 1, 1, 1), Unsigned32())
if mibBuilder.loadTexts: topologyID.setStatus('current')
if mibBuilder.loadTexts: topologyID.setDescription('Unique internal identifier of the topology. This item is generated internally by EWC and has no external meaning.')
topologyName = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 4, 1, 1, 1, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: topologyName.setStatus('current')
if mibBuilder.loadTexts: topologyName.setDescription('Name associated with topology. This name must be unique within EWC. Allowable characters for this field are from the set of A-Z, a-z, -!#$:, 0-9, and space. Howerver, it is recommended to avoid leading and trailing spaces.')
topologyMode = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 4, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(-1, 0, 1, 2, 4, 5, 6))).clone(namedValues=NamedValues(("undefined", -1), ("routed", 0), ("bridgedAtAP", 1), ("bridgedAtAC", 2), ("thirdPartyAP", 4), ("physical", 5), ("management", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: topologyMode.setStatus('current')
if mibBuilder.loadTexts: topologyMode.setDescription('Type of this topology. This field implies the meaning and necessity of other attributes associated to the topology.')
topologyTagged = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 4, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("tagged", 1), ("untagged", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: topologyTagged.setStatus('current')
if mibBuilder.loadTexts: topologyTagged.setDescription('If topology is tagged, then a VLAN ID must be assigned to the topology. Meaning associated to this field is topology specific: - For Admin topology (management port) is always untagged - Ror routed topology has no meaning and always untagged - For all other topologies this field is configurable.')
topologyVlanID = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 4, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(-1, -1), ValueRangeConstraint(1, 4095), )).clone(-1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: topologyVlanID.setStatus('current')
if mibBuilder.loadTexts: topologyVlanID.setDescription('VLAN ID assigned to a tagged topology. For untagged topology this field has no meaning and it is set to -1.')
topologyEgressPort = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 4, 1, 1, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 12))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: topologyEgressPort.setStatus('current')
if mibBuilder.loadTexts: topologyEgressPort.setDescription('Egress port associated to this topology if it is tagged and VLANID defined for the topology. This field is represented as octect string: The most significant bit of most significant octet represent first physical port (lowest number port) and second most significant bit of most significant octet represent second physical port and so on. Meaning associated to this field is topology specific: - For Admin topology (management port) this field has no meaning. - Ror routed topology this field has no meaning - For all other topologies: physical, bridge at controller, and bridge at AP topologies this field is configurable.')
topologyLayer3 = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 4, 1, 1, 1, 7), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: topologyLayer3.setStatus('current')
if mibBuilder.loadTexts: topologyLayer3.setDescription('If set to true, then topology has layer three persence. Any topology with layer three presence must have IP address and gateway assigned to it. Meaning associated to this field is topology specific: - For Admin topology (management port) it is always set to true. - Ror bridge at AP this field has no meaning and it is set to false. - For routed and physical topologies it is always set to true. - For bridge at controller type of topology this field is configurable.')
topologyIPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 4, 1, 1, 1, 8), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: topologyIPAddress.setStatus('current')
if mibBuilder.loadTexts: topologyIPAddress.setDescription('IP address assigned to the topology as its interface. Meaning associated to this field is topology specific: - This field has meaning if topology has layer three presence. - Ror bridge at AP this field has no meaning and set 0.0.0.0.')
topologyIPMask = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 4, 1, 1, 1, 9), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: topologyIPMask.setStatus('current')
if mibBuilder.loadTexts: topologyIPMask.setDescription("Mask for topology's IP address. This field is only applicable to those topologies that have IP address assigned to them, otherwise it is set either to 255.255.255.255 or 0.0.0.0.")
topologyMTUsize = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 4, 1, 1, 1, 10), Unsigned32().clone(1436)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: topologyMTUsize.setStatus('current')
if mibBuilder.loadTexts: topologyMTUsize.setDescription('Default MTU size for the topology. This field is only configurable for a topologies that has layer three presence.')
topologyGateway = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 4, 1, 1, 1, 11), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: topologyGateway.setStatus('current')
if mibBuilder.loadTexts: topologyGateway.setDescription('Gateway associated to this topology. This field has meaning for a topology that has layer three presence.')
topologyDHCPUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 4, 1, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("none", 0), ("useRelay", 1), ("localServer", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: topologyDHCPUsage.setStatus('current')
if mibBuilder.loadTexts: topologyDHCPUsage.setDescription('The type of DHCP to be used for IP address assignment to associated MU. This field has meaning only if the topology has layer three persense. Meaning associated to this field is topology specific: - For Admin topology (management port) has no meaning. - Ror bridge at AP this field has no meaning. - For all other topologies that their layer three presence is enabled this field is configurable.')
topologyAPRegistration = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 4, 1, 1, 1, 13), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: topologyAPRegistration.setStatus('current')
if mibBuilder.loadTexts: topologyAPRegistration.setDescription('If set to true, then AP registration can be achieved using via this topology. Meaning associated to this field is topology specific: - Always false for Admin (management port) and routed topologies - Always false and has no meaning for bridge at AP topology. - For physical and bridge at controller type topologies that have layer three presence this field can be set to either true or false.')
topologyManagementTraffic = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 4, 1, 1, 1, 14), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: topologyManagementTraffic.setStatus('current')
if mibBuilder.loadTexts: topologyManagementTraffic.setDescription('If set to true, then management data traffic is allowed on this topology. Meaning associated to this field is topology specific: - Always true for Admin topology (management port) - Has no meaning for bridge at AP type topologies - For all other topologies that have layer three presence this field can be set to either true or false.')
topologySynchronize = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 4, 1, 1, 1, 15), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: topologySynchronize.setStatus('current')
if mibBuilder.loadTexts: topologySynchronize.setDescription('If set to true, then topology must be synchronized with peer controller in availability mode operation. Meaning associated to this field is topology specific: - Always false for Admin topology (management port) - Has no meaning for topologies associated to physical ports. - For all other topologies: bridge at controller, routed and bridge at AP type topologies this field can be set to either true or false.')
topologySyncGateway = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 4, 1, 1, 1, 16), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: topologySyncGateway.setStatus('current')
if mibBuilder.loadTexts: topologySyncGateway.setDescription('Gateway associated to synchronized topology. This field has meaning for those topologies that their topologySynchornize field is set to true.')
topologySyncMask = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 4, 1, 1, 1, 17), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: topologySyncMask.setStatus('current')
if mibBuilder.loadTexts: topologySyncMask.setDescription('Mask of synchronized gateway IP address. This field has meaning for those topologies that their topologySynchornize field is set to true.')
topologySyncIPStart = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 4, 1, 1, 1, 18), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: topologySyncIPStart.setStatus('current')
if mibBuilder.loadTexts: topologySyncIPStart.setDescription('Range of IP addresses assigned to remote synchronized topology. This IP address represents starting IP address. This field has meaning for those topologies that their topologySynchornize field is set to true.')
topologySyncIPEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 4, 1, 1, 1, 19), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: topologySyncIPEnd.setStatus('current')
if mibBuilder.loadTexts: topologySyncIPEnd.setDescription('Range of IP addresses assigned to remote synchronized topology. This IP address represents ending IP address. This field has meaning for those topologies that their topologySynchornize field is set to true.')
topologyStaticIPv6Address = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 4, 1, 1, 1, 20), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: topologyStaticIPv6Address.setStatus('current')
if mibBuilder.loadTexts: topologyStaticIPv6Address.setDescription('Statically configured IPv6 address assigned to the admin port.')
topologyLinkLocalIPv6Address = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 4, 1, 1, 1, 21), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: topologyLinkLocalIPv6Address.setStatus('current')
if mibBuilder.loadTexts: topologyLinkLocalIPv6Address.setDescription('Automatically generated link-local IPv6 address assigned to the admin port.')
topologyPreFixLength = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 4, 1, 1, 1, 22), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: topologyPreFixLength.setStatus('current')
if mibBuilder.loadTexts: topologyPreFixLength.setDescription('The prfix length of the statically configured IPv6 address of the topology.')
topologyIPv6Gateway = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 4, 1, 1, 1, 23), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: topologyIPv6Gateway.setStatus('current')
if mibBuilder.loadTexts: topologyIPv6Gateway.setDescription('The gateway of IPv6 address that is associated to the admin topology.')
topologyDynamicEgress = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 4, 1, 1, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: topologyDynamicEgress.setStatus('current')
if mibBuilder.loadTexts: topologyDynamicEgress.setDescription('Enable/disable dynamic egress for this topology. Dynamic egress allows a station to receive from this VLAN if it can send to this VLAN.')
topologyIsGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 4, 1, 1, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: topologyIsGroup.setStatus('current')
if mibBuilder.loadTexts: topologyIsGroup.setDescription('When this flag is yes, this means the topology is created as a group topology.')
topologyGroupMembers = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 4, 1, 1, 1, 26), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 12))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: topologyGroupMembers.setStatus('current')
if mibBuilder.loadTexts: topologyGroupMembers.setDescription('This field specifies the topologies for this group. This field has meaning only when topologyIsGroup is set to 1. This field is represented as octect string. The most significant bit of the most significant octet of the octet string represents the first topology with topologyID = 0 and second most significant bit of the most significant octet represents the second topology with topologyID = 1 and so on.')
topologyMemberId = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 4, 1, 1, 1, 27), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: topologyMemberId.setStatus('current')
if mibBuilder.loadTexts: topologyMemberId.setDescription(' -1 : Means this topology is not a member of a group topology. valid topology ID : Means this topology is a member of a configured group topology that has this group topology ID.')
topologyStat = MibIdentifier((1, 3, 6, 1, 4, 1, 4329, 15, 3, 4, 2))
topoStatTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 4, 2, 1), )
if mibBuilder.loadTexts: topoStatTable.setStatus('current')
if mibBuilder.loadTexts: topoStatTable.setDescription('Statistics describing traffic transmitted or received for a single topology. This is the traffic on the topology that is coming from or going to destinations on the wired network.')
topoStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 4, 2, 1, 1), ).setIndexNames((0, "HIPATH-WIRELESS-HWC-MIB", "topologyID"))
if mibBuilder.loadTexts: topoStatEntry.setStatus('current')
if mibBuilder.loadTexts: topoStatEntry.setDescription('Statistic related an entry in topology table.')
topoStatName = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 4, 2, 1, 1, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: topoStatName.setStatus('current')
if mibBuilder.loadTexts: topoStatName.setDescription('Topology name.')
topoStatTxPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 4, 2, 1, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: topoStatTxPkts.setStatus('current')
if mibBuilder.loadTexts: topoStatTxPkts.setDescription('Number of packets transmitted to the wired network on the topology/vlan.')
topoStatRxPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 4, 2, 1, 1, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: topoStatRxPkts.setStatus('current')
if mibBuilder.loadTexts: topoStatRxPkts.setDescription('Number of packets received from the wired network on the topology/vlan.')
topoStatTxOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 4, 2, 1, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: topoStatTxOctets.setStatus('current')
if mibBuilder.loadTexts: topoStatTxOctets.setDescription('Number of octets transmitted in frames to the wired network on the topology/vlan.')
topoStatRxOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 4, 2, 1, 1, 5), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: topoStatRxOctets.setStatus('current')
if mibBuilder.loadTexts: topoStatRxOctets.setDescription('Number of octets received in frames from the wired network on the topology/vlan.')
topoStatMulticastTxPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 4, 2, 1, 1, 6), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: topoStatMulticastTxPkts.setStatus('current')
if mibBuilder.loadTexts: topoStatMulticastTxPkts.setDescription('Number of multicast frames transmitted to the wired network on the topology/vlan.')
topoStatMulticastRxPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 4, 2, 1, 1, 7), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: topoStatMulticastRxPkts.setStatus('current')
if mibBuilder.loadTexts: topoStatMulticastRxPkts.setDescription('Number of multicast frames received from the wired network on the topology/vlan.')
topoStatBroadcastTxPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 4, 2, 1, 1, 8), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: topoStatBroadcastTxPkts.setStatus('current')
if mibBuilder.loadTexts: topoStatBroadcastTxPkts.setDescription('Number of broadcast frames transmitted to the wired network on the topology/vlan.')
topoStatBroadcastRxPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 4, 2, 1, 1, 9), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: topoStatBroadcastRxPkts.setStatus('current')
if mibBuilder.loadTexts: topoStatBroadcastRxPkts.setDescription('Number of broadcast frames received from the wired network on the topology/vlan.')
topoStatFrameChkSeqErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 4, 2, 1, 1, 10), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: topoStatFrameChkSeqErrors.setStatus('current')
if mibBuilder.loadTexts: topoStatFrameChkSeqErrors.setDescription('Number of frames with checksum errors received from the wired network on the topology/vlan.')
topoStatFrameTooLongErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 4, 2, 1, 1, 11), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: topoStatFrameTooLongErrors.setStatus('current')
if mibBuilder.loadTexts: topoStatFrameTooLongErrors.setDescription('Number of oversized frames received from the wired network on the topology/vlan.')
topoExceptionStatTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 4, 2, 2), )
if mibBuilder.loadTexts: topoExceptionStatTable.setStatus('current')
if mibBuilder.loadTexts: topoExceptionStatTable.setDescription('The table contains list of exception-specific filters statistics for configured topologies in EWC.')
topoExceptionStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 4, 2, 2, 1), ).setIndexNames((0, "HIPATH-WIRELESS-HWC-MIB", "topologyID"))
if mibBuilder.loadTexts: topoExceptionStatEntry.setStatus('current')
if mibBuilder.loadTexts: topoExceptionStatEntry.setDescription('An entry in topology exception statistic table.')
topoExceptionFiterName = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 4, 2, 2, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: topoExceptionFiterName.setStatus('current')
if mibBuilder.loadTexts: topoExceptionFiterName.setDescription('Exception filter name.')
topoExceptionStatPktsDenied = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 4, 2, 2, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: topoExceptionStatPktsDenied.setStatus('current')
if mibBuilder.loadTexts: topoExceptionStatPktsDenied.setDescription("Number of packets that were denied by defined filters since device's last restart.")
topoExceptionStatPktsAllowed = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 4, 2, 2, 1, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: topoExceptionStatPktsAllowed.setStatus('current')
if mibBuilder.loadTexts: topoExceptionStatPktsAllowed.setDescription("Number packets that were allowed by defined filters since device's last restart.")
topoWireStatTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 4, 2, 3), )
if mibBuilder.loadTexts: topoWireStatTable.setStatus('deprecated')
if mibBuilder.loadTexts: topoWireStatTable.setDescription('The table contains statistics describing traffic transmitted or received unencapsulated (i.e. not wrapped in WASSP) for each topology')
topoWireStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 4, 2, 3, 1), ).setIndexNames((0, "HIPATH-WIRELESS-HWC-MIB", "topologyID"))
if mibBuilder.loadTexts: topoWireStatEntry.setStatus('deprecated')
if mibBuilder.loadTexts: topoWireStatEntry.setDescription("Statistics describing traffic transmitted or received unencapsulated (i.e. not wrapped in WASSP) for a single topology. This is the traffic on the topology that is coming from or going to destinations on the wired network other than to the controller's APs.")
topoWireStatName = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 4, 2, 3, 1, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: topoWireStatName.setStatus('deprecated')
if mibBuilder.loadTexts: topoWireStatName.setDescription('Topology name.')
topoWireStatTxPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 4, 2, 3, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: topoWireStatTxPkts.setStatus('deprecated')
if mibBuilder.loadTexts: topoWireStatTxPkts.setDescription('Number of packets transmitted unencapsulated to the wired network on the topology/vlan.')
topoWireStatRxPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 4, 2, 3, 1, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: topoWireStatRxPkts.setStatus('deprecated')
if mibBuilder.loadTexts: topoWireStatRxPkts.setDescription('Number of packets received unencapsulated from the wired network on the topology/vlan.')
topoWireStatTxOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 4, 2, 3, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: topoWireStatTxOctets.setStatus('deprecated')
if mibBuilder.loadTexts: topoWireStatTxOctets.setDescription('Number of octets transmitted in unencapsulated frames to the wired network on the topology/vlan.')
topoWireStatRxOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 4, 2, 3, 1, 5), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: topoWireStatRxOctets.setStatus('deprecated')
if mibBuilder.loadTexts: topoWireStatRxOctets.setDescription('Number of octets received in unencapsulated frames to the wired network on the topology/vlan.')
topoWireStatMulticastTxPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 4, 2, 3, 1, 6), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: topoWireStatMulticastTxPkts.setStatus('deprecated')
if mibBuilder.loadTexts: topoWireStatMulticastTxPkts.setDescription('Number of multicast frames transmitted unencapsulated to the wired network on the topology/vlan.')
topoWireStatMulticastRxPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 4, 2, 3, 1, 7), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: topoWireStatMulticastRxPkts.setStatus('deprecated')
if mibBuilder.loadTexts: topoWireStatMulticastRxPkts.setDescription('Number of multicast frames received unencapsulated from the wired network on the topology/vlan.')
topoWireStatBroadcastTxPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 4, 2, 3, 1, 8), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: topoWireStatBroadcastTxPkts.setStatus('deprecated')
if mibBuilder.loadTexts: topoWireStatBroadcastTxPkts.setDescription('Number of broadcast frames transmitted unencapsulated to the wired network on the topology/vlan.')
topoWireStatBroadcastRxPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 4, 2, 3, 1, 9), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: topoWireStatBroadcastRxPkts.setStatus('deprecated')
if mibBuilder.loadTexts: topoWireStatBroadcastRxPkts.setDescription('Number of broadcast frames received unencapsulated from the wired network on the topology/vlan.')
topoWireStatFrameChkSeqErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 4, 2, 3, 1, 10), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: topoWireStatFrameChkSeqErrors.setStatus('deprecated')
if mibBuilder.loadTexts: topoWireStatFrameChkSeqErrors.setDescription('Number of unencapsulated frames with checksum errors received from the wired network on the topology/vlan.')
topoWireStatFrameTooLongErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 4, 2, 3, 1, 11), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: topoWireStatFrameTooLongErrors.setStatus('deprecated')
if mibBuilder.loadTexts: topoWireStatFrameTooLongErrors.setDescription('Number of unencapsulated frames with length longer than permitted received from the wired network on the topology/vlan.')
topoCompleteStatTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 4, 2, 4), )
if mibBuilder.loadTexts: topoCompleteStatTable.setStatus('current')
if mibBuilder.loadTexts: topoCompleteStatTable.setDescription('The table contains statistics describing traffic transmitted and received for each topology on both the wired side and the wireless side.')
topoCompleteStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 4, 2, 4, 1), ).setIndexNames((0, "HIPATH-WIRELESS-HWC-MIB", "topologyID"))
if mibBuilder.loadTexts: topoCompleteStatEntry.setStatus('current')
if mibBuilder.loadTexts: topoCompleteStatEntry.setDescription('Statistics describing traffic transmitted and received on a single topology on both the wired side and the wireless side.')
topoCompleteStatName = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 4, 2, 4, 1, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: topoCompleteStatName.setStatus('current')
if mibBuilder.loadTexts: topoCompleteStatName.setDescription('Topology name.')
topoCompleteStatTxPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 4, 2, 4, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: topoCompleteStatTxPkts.setStatus('current')
if mibBuilder.loadTexts: topoCompleteStatTxPkts.setDescription('Number of packets transmitted to the wired and wireless networks on the topology/vlan.')
topoCompleteStatRxPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 4, 2, 4, 1, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: topoCompleteStatRxPkts.setStatus('current')
if mibBuilder.loadTexts: topoCompleteStatRxPkts.setDescription('Number of packets received from the wired and wireless networks on the topology/vlan.')
topoCompleteStatTxOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 4, 2, 4, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: topoCompleteStatTxOctets.setStatus('current')
if mibBuilder.loadTexts: topoCompleteStatTxOctets.setDescription('Number of octets transmitted in frames to the wired and wireless networks on the topology/vlan.')
topoCompleteStatRxOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 4, 2, 4, 1, 5), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: topoCompleteStatRxOctets.setStatus('current')
if mibBuilder.loadTexts: topoCompleteStatRxOctets.setDescription('Number of octets received in frames from the wired and wireless networks on the topology/vlan.')
topoCompleteStatMulticastTxPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 4, 2, 4, 1, 6), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: topoCompleteStatMulticastTxPkts.setStatus('current')
if mibBuilder.loadTexts: topoCompleteStatMulticastTxPkts.setDescription('Number of multicast frames transmitted to the wired and wireless networks on the topology/vlan.')
topoCompleteStatMulticastRxPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 4, 2, 4, 1, 7), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: topoCompleteStatMulticastRxPkts.setStatus('current')
if mibBuilder.loadTexts: topoCompleteStatMulticastRxPkts.setDescription('Number of multicast frames received from the wired and wireless networks on the topology/vlan.')
topoCompleteStatBroadcastTxPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 4, 2, 4, 1, 8), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: topoCompleteStatBroadcastTxPkts.setStatus('current')
if mibBuilder.loadTexts: topoCompleteStatBroadcastTxPkts.setDescription('Number of broadcast frames transmitted to the wired and wireless networks on the topology/vlan.')
topoCompleteStatBroadcastRxPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 4, 2, 4, 1, 9), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: topoCompleteStatBroadcastRxPkts.setStatus('current')
if mibBuilder.loadTexts: topoCompleteStatBroadcastRxPkts.setDescription('Number of broadcast frames received from the wired and wireless networks on the topology/vlan.')
topoCompleteStatFrameChkSeqErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 4, 2, 4, 1, 10), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: topoCompleteStatFrameChkSeqErrors.setStatus('current')
if mibBuilder.loadTexts: topoCompleteStatFrameChkSeqErrors.setDescription('Number of frames with checksum errors received from the wired and wireless networks on the topology/vlan.')
topoCompleteStatFrameTooLongErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 4, 2, 4, 1, 11), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: topoCompleteStatFrameTooLongErrors.setStatus('current')
if mibBuilder.loadTexts: topoCompleteStatFrameTooLongErrors.setDescription('Number of oversized frames received from the wired and wireless networks on the topology/vlan.')
accessPoints = MibIdentifier((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5))
apConfigObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 1))
apCount = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apCount.setStatus('current')
if mibBuilder.loadTexts: apCount.setDescription('The count of currently configured AccessPoints associated with this WirelessController.')
apTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 1, 2), )
if mibBuilder.loadTexts: apTable.setStatus('current')
if mibBuilder.loadTexts: apTable.setDescription('Contains a list of all configured APs associated with the Wireless Controller.')
apEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 1, 2, 1), ).setIndexNames((0, "HIPATH-WIRELESS-HWC-MIB", "apIndex"))
if mibBuilder.loadTexts: apEntry.setStatus('current')
if mibBuilder.loadTexts: apEntry.setDescription('Configuration information for an access point.')
apIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apIndex.setStatus('current')
if mibBuilder.loadTexts: apIndex.setDescription('Table index for the access point.')
apName = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 1, 2, 1, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apName.setStatus('current')
if mibBuilder.loadTexts: apName.setDescription("Access Point's name.")
apDesc = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 1, 2, 1, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apDesc.setStatus('current')
if mibBuilder.loadTexts: apDesc.setDescription('Text description of the AP.')
apSerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 1, 2, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readonly")
if mibBuilder.loadTexts: apSerialNumber.setStatus('current')
if mibBuilder.loadTexts: apSerialNumber.setDescription('16-character serial number of the AccessPoint.')
apPortifIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 1, 2, 1, 5), InterfaceIndex()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apPortifIndex.setStatus('current')
if mibBuilder.loadTexts: apPortifIndex.setDescription('ifIndex of the physical port to which this AP is assigned.')
apWiredIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 1, 2, 1, 6), InterfaceIndex()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apWiredIfIndex.setStatus('current')
if mibBuilder.loadTexts: apWiredIfIndex.setDescription('ifIndex of the wired interface on the AP.')
apSoftwareVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 1, 2, 1, 7), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apSoftwareVersion.setStatus('current')
if mibBuilder.loadTexts: apSoftwareVersion.setDescription('Software version currently installed on the AP.')
apSpecific = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 1, 2, 1, 8), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apSpecific.setStatus('current')
if mibBuilder.loadTexts: apSpecific.setDescription('A link back to the OID under the hiPathWirelessProducts branch that identifies the specific version of this AP.')
apBroadcastDisassociate = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 1, 2, 1, 9), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apBroadcastDisassociate.setStatus('current')
if mibBuilder.loadTexts: apBroadcastDisassociate.setDescription('True indicates that the AP should broadcast disassociation requests, False indicates unicast.')
apRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 1, 2, 1, 10), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apRowStatus.setStatus('current')
if mibBuilder.loadTexts: apRowStatus.setDescription('RowStatus for the apTable.')
apVlanID = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 1, 2, 1, 11), Integer32().clone(-1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apVlanID.setStatus('current')
if mibBuilder.loadTexts: apVlanID.setDescription('VLAN tag for the packets trasmitted to/from Access Point. Value ranges: (-1) it is not tagged, zero(0) means reserved, 1-4094 tag value.')
apIpAssignmentType = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 1, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dhcp", 1), ("static", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apIpAssignmentType.setStatus('current')
if mibBuilder.loadTexts: apIpAssignmentType.setDescription('IP address assignment type, dhcp(1) = uses DHCP to obtain IP address, static(2) = static IP address is assigned to the access point.')
apIfMAC = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 1, 2, 1, 13), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apIfMAC.setStatus('current')
if mibBuilder.loadTexts: apIfMAC.setDescription("Acess Point's wired interface MAC address.")
apIPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 1, 2, 1, 14), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apIPAddress.setStatus('current')
if mibBuilder.loadTexts: apIPAddress.setDescription("Access Point's wired interface IP address.")
apHwVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 1, 2, 1, 17), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apHwVersion.setStatus('current')
if mibBuilder.loadTexts: apHwVersion.setDescription("Text description of Access Point's hardware version.")
apSwVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 1, 2, 1, 18), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apSwVersion.setStatus('current')
if mibBuilder.loadTexts: apSwVersion.setDescription("Text description of Access Point's major software version.")
apEnvironment = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 1, 2, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("indoor", 1), ("outdoor", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apEnvironment.setStatus('current')
if mibBuilder.loadTexts: apEnvironment.setDescription("Access Point's environment.")
apHome = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 1, 2, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("local", 1), ("foreign", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apHome.setStatus('current')
if mibBuilder.loadTexts: apHome.setDescription('Local session is created when access point registers directly with the controller. Foreign session is mirrored session created via availability feature.')
apRole = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 1, 2, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("accessPoint", 1), ("sensor", 2), ("guardian", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apRole.setStatus('current')
if mibBuilder.loadTexts: apRole.setDescription('Indicates whether Access Point is a traffic fordwarder, sensor or guardian')
apState = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 1, 2, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apState.setStatus('current')
if mibBuilder.loadTexts: apState.setDescription('Active means that access point has registered with this controller at some point of time and still has active connection with this controller. This variable has meaning in the context of the controller that query is done. Inactive mean access point has lost the connection with this controller.')
apStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 1, 2, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("approved", 1), ("pending", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apStatus.setStatus('current')
if mibBuilder.loadTexts: apStatus.setDescription('Registration state for the access point at the time of query, approved(1) means the registration was completed, pending(2) means access point has registered but waiting manual approval from admin.')
apPollTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 1, 2, 1, 24), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(3, 3600))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apPollTimeout.setStatus('current')
if mibBuilder.loadTexts: apPollTimeout.setDescription("Duration after which the access point's connection to controller is considered has been lost if polling fails. ")
apPollInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 1, 2, 1, 25), Gauge32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apPollInterval.setStatus('current')
if mibBuilder.loadTexts: apPollInterval.setDescription('Interval between each poll sent to the controller.')
apTelnetAccess = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 1, 2, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("na", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apTelnetAccess.setStatus('current')
if mibBuilder.loadTexts: apTelnetAccess.setDescription('Indicates whether telnet access is enabled/disabled. This value only applys to AP26xx, W788, W786 and AP4102x APs. 1 : Enabled. 2 : Disabled. 3 : Telnet is not supported.')
apMaintainClientSession = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 1, 2, 1, 27), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apMaintainClientSession.setStatus('current')
if mibBuilder.loadTexts: apMaintainClientSession.setDescription("If true, Access Point maintains client's session in the event of poll failure.")
apRestartServiceContAbsent = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 1, 2, 1, 28), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apRestartServiceContAbsent.setStatus('current')
if mibBuilder.loadTexts: apRestartServiceContAbsent.setDescription('If true, Access Point restarts the service in the absence of controller.')
apHostname = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 1, 2, 1, 29), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apHostname.setStatus('current')
if mibBuilder.loadTexts: apHostname.setDescription('Hostname assigned to Access Point.')
apLocation = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 1, 2, 1, 30), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apLocation.setStatus('current')
if mibBuilder.loadTexts: apLocation.setDescription('Text identifying location of the access point.')
apStaticMTUsize = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 1, 2, 1, 31), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(600, 1500)).clone(1500)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apStaticMTUsize.setStatus('current')
if mibBuilder.loadTexts: apStaticMTUsize.setDescription('Configured MTU size for the access point. Access point will use the lower value of MTU size between statically configured MTU size and dynamically learned MTU size.')
apSiteID = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 1, 2, 1, 32), Integer32().clone(-1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apSiteID.setStatus('current')
if mibBuilder.loadTexts: apSiteID.setDescription('The site ID, as defined in siteTable, that this AP is member of. The value of -1 indicates that AP is not member of any site.')
apZone = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 1, 2, 1, 33), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apZone.setStatus('current')
if mibBuilder.loadTexts: apZone.setDescription('The Zone to which the Access Point belongs. ')
apLLDP = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 1, 2, 1, 34), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apLLDP.setStatus('current')
if mibBuilder.loadTexts: apLLDP.setDescription('Enable or disable broadcasting of LLDP information by the wireless AP.')
apSSHAccess = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 1, 2, 1, 35), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apSSHAccess.setStatus('deprecated')
if mibBuilder.loadTexts: apSSHAccess.setDescription('Enable or Disable SSH access to the Wireless AP. This value only applys to AP36xx, AP37xx, W788C and W786C APs.')
apLEDMode = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 1, 2, 1, 36), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("off", 0), ("wdsSignalStrength", 1), ("identify", 2), ("normal", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apLEDMode.setStatus('current')
if mibBuilder.loadTexts: apLEDMode.setDescription("LED status field for the Access Point. off(0): LED is set to off for the AP. wdsSignalStrength(1): LED conveys the strength of the singal, for the details please refer to user manual. indentify(2): Can be used to lacate the AP by making AP to flashing LED repeatedly. normal(3): This indicates AP's normal operational mode.")
apLocationbasedService = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 1, 2, 1, 37), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apLocationbasedService.setStatus('current')
if mibBuilder.loadTexts: apLocationbasedService.setDescription('Enable or disable the AeroScout or Ekahau location-based service for the Wireless AP.')
apSecureTunnel = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 1, 2, 1, 38), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apSecureTunnel.setStatus('current')
if mibBuilder.loadTexts: apSecureTunnel.setDescription('Enable or disable Secure Tunnel between Ap and Controller')
apEncryptCntTraffic = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 1, 2, 1, 39), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apEncryptCntTraffic.setStatus('current')
if mibBuilder.loadTexts: apEncryptCntTraffic.setDescription('Enable or disable encrypt of control traffic between AP & Controller. This value has meaning only if apSecureTunnel is enabled.')
apMICErrorWarning = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 1, 2, 1, 40), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apMICErrorWarning.setStatus('current')
if mibBuilder.loadTexts: apMICErrorWarning.setDescription('Enable or disable MIC error warning generation.')
apSecureDataTunnelType = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 1, 2, 1, 41), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("disable", 0), ("encryptControlTraffic", 1), ("encryptControlDataTraffic", 2), ("debugMode", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apSecureDataTunnelType.setStatus('current')
if mibBuilder.loadTexts: apSecureDataTunnelType.setDescription('secure data tunnel status between controller and acesss point. disable(0): disable encryption of control and data traffic between AP & Controller. encryptControlTraffic(1): encrypt control traffic between AP & Controller. encryptControlDataTraffic(2): encrypt control and data traffic between AP & Controller. debugMode(3): preserve keys without encryption.')
apIPMulticastAssembly = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 1, 2, 1, 42), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apIPMulticastAssembly.setStatus('current')
if mibBuilder.loadTexts: apIPMulticastAssembly.setDescription('Enable or disable fragmentation/reassembly of the IP Multicast frames transmitted over the tunnel between AP and Controller. When set to true, an IP Multicast frame larger than the tunnel MTU will be fragmented when it is placed into the WASSP tunnel and reassembled on the receiving end of the tunnel before being forwarded to the clients.')
apSSHConnection = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 1, 2, 1, 43), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("na", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apSSHConnection.setStatus('current')
if mibBuilder.loadTexts: apSSHConnection.setDescription('Enable or Disable SSH access to the Wireless AP. This value only applys to AP36xx, AP37xx, W788C and W786C APs. 1 : Enabled. 2 : Disabled. 3 : SSH is not supported.')
apRadioTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 1, 3), )
if mibBuilder.loadTexts: apRadioTable.setStatus('current')
if mibBuilder.loadTexts: apRadioTable.setDescription('Table access point radio configuration information.')
apRadioEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 1, 3, 1), ).setIndexNames((0, "HIPATH-WIRELESS-HWC-MIB", "apIndex"), (0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: apRadioEntry.setStatus('current')
if mibBuilder.loadTexts: apRadioEntry.setDescription('Configuration information for a radio on the access point.')
apRadioFrequency = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("freq50GHz", 1), ("freq24GHz", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apRadioFrequency.setStatus('current')
if mibBuilder.loadTexts: apRadioFrequency.setDescription('The frequency of the radio as supported by the hardware. Supported frequencies are either of 2.5Ghz or 5.0Ghz.')
apRadioNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 1, 3, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apRadioNumber.setStatus('current')
if mibBuilder.loadTexts: apRadioNumber.setDescription('Access point radios are numbered from 1 in increasing order. This numbering is limited in the context of AP. This field returns the radio number of the AP indexed by apIndex.')
apRadioType = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 1, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("off", 0), ("dot11a", 1), ("dot11an", 2), ("dot11anStrict", 3), ("dot11b", 4), ("dot11g", 5), ("dot11bg", 6), ("dot11gn", 7), ("dot11bgn", 8), ("dot11gnStrict", 9), ("dot11j", 10), ("dot11anc", 11), ("dot11cStrict", 12)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apRadioType.setStatus('deprecated')
if mibBuilder.loadTexts: apRadioType.setDescription('Indicates the type of radio (a, a/n, a/c, n-strict, c-strict, b, g, b/g, or b/g/n) as it is configured.')
apRadioProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 1, 3, 1, 4), Bits().clone(namedValues=NamedValues(("dot1124b", 0), ("dot1124g", 1), ("dot1124n", 2), ("dot1150a", 3), ("dot1150ac", 4), ("dot1150j", 5), ("dot1150n", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apRadioProtocol.setStatus('current')
if mibBuilder.loadTexts: apRadioProtocol.setDescription('Enumerates the possible types of 802.11 radio protocols.')
radioVNSTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 1, 4), )
if mibBuilder.loadTexts: radioVNSTable.setStatus('current')
if mibBuilder.loadTexts: radioVNSTable.setDescription('Table of VNSs the radio is participating in.')
radioVNSEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 1, 4, 1), ).setIndexNames((0, "HIPATH-WIRELESS-HWC-MIB", "radioIfIndex"), (0, "HIPATH-WIRELESS-HWC-MIB", "vnsIfIndex"))
if mibBuilder.loadTexts: radioVNSEntry.setStatus('current')
if mibBuilder.loadTexts: radioVNSEntry.setDescription('Information for a single VNS entry.')
radioIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 1, 4, 1, 1), InterfaceIndex()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radioIfIndex.setStatus('current')
if mibBuilder.loadTexts: radioIfIndex.setDescription('Radio participating in the VNS.')
vnsIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 1, 4, 1, 2), InterfaceIndex()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vnsIfIndex.setStatus('current')
if mibBuilder.loadTexts: vnsIfIndex.setDescription('ifIndex for the VNS the radio is participating.')
radioVNSRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 1, 4, 1, 3), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radioVNSRowStatus.setStatus('current')
if mibBuilder.loadTexts: radioVNSRowStatus.setDescription('RowStatus for the radioVNSTable.')
apFastFailoverEnable = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 1, 5), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apFastFailoverEnable.setStatus('current')
if mibBuilder.loadTexts: apFastFailoverEnable.setDescription('True indicates that Fast Failover feature is enabled at AP.')
apLinkTimeout = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apLinkTimeout.setStatus('current')
if mibBuilder.loadTexts: apLinkTimeout.setDescription('Time to deteck link failure. The value is in 1-30 seconds.')
apAntennaTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 1, 7), )
if mibBuilder.loadTexts: apAntennaTable.setStatus('current')
if mibBuilder.loadTexts: apAntennaTable.setDescription('Contains a list of antennas configured for each AP associated with the Wireless Controller. All elements in this table are predefined and read-only.')
apAntennaEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 1, 7, 1), ).setIndexNames((0, "HIPATH-WIRELESS-HWC-MIB", "apIndex"), (0, "HIPATH-WIRELESS-HWC-MIB", "apAntennaIndex"))
if mibBuilder.loadTexts: apAntennaEntry.setStatus('current')
if mibBuilder.loadTexts: apAntennaEntry.setDescription('An entry in this table identifying attributes of one antenna for an AP.')
apAntennaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 1, 7, 1, 1), Unsigned32())
if mibBuilder.loadTexts: apAntennaIndex.setStatus('current')
if mibBuilder.loadTexts: apAntennaIndex.setDescription('Index of an antenna inside an AP.')
apAntennanName = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 1, 7, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apAntennanName.setStatus('current')
if mibBuilder.loadTexts: apAntennanName.setDescription('Textual description identifying the antenna.')
apAntennaType = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 1, 7, 1, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apAntennaType.setStatus('current')
if mibBuilder.loadTexts: apAntennaType.setDescription('Textual description of antenna type selected for that antenna.')
apRadioAntennaTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 1, 8), )
if mibBuilder.loadTexts: apRadioAntennaTable.setStatus('current')
if mibBuilder.loadTexts: apRadioAntennaTable.setDescription('Contains a list of Radio configured for each AP associated with the Wireless Controller. All elements in this table are predefined and read-only.')
apRadioAntennaEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 1, 8, 1), ).setIndexNames((0, "HIPATH-WIRELESS-HWC-MIB", "apIndex"), (0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: apRadioAntennaEntry.setStatus('current')
if mibBuilder.loadTexts: apRadioAntennaEntry.setDescription('An entry in this table identifying attributes of one radio for an AP.')
apRadioAntennaType = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 1, 8, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apRadioAntennaType.setStatus('current')
if mibBuilder.loadTexts: apRadioAntennaType.setDescription('Textual description of antenna type selected for that radio.')
apRadioAntennaModel = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 1, 8, 1, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apRadioAntennaModel.setStatus('current')
if mibBuilder.loadTexts: apRadioAntennaModel.setDescription('Antenna type. 0 indicates internal antenna. 1 indicates no antenna. Other value indicates specific external antenna type. ')
apRadioAttenuation = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 1, 8, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apRadioAttenuation.setStatus('current')
if mibBuilder.loadTexts: apRadioAttenuation.setDescription('Cumulative attenuation (in dB) of all components (cables, attenuators) between the radio port and the antenna. A professional installer must configure this value so it does not violate country regulations and must verify that it reflects the actual installed components. If this field value is set to -1, then this radio does not support the attenuation configuration.')
apStatsObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2))
apActiveCount = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apActiveCount.setStatus('current')
if mibBuilder.loadTexts: apActiveCount.setDescription('The count of active AccessPoints associated with this WirelessController.')
apStatsTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 2), )
if mibBuilder.loadTexts: apStatsTable.setStatus('current')
if mibBuilder.loadTexts: apStatsTable.setDescription('Table of statistics for the access points.')
apStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 2, 1), ).setIndexNames((0, "HIPATH-WIRELESS-HWC-MIB", "apIndex"))
if mibBuilder.loadTexts: apStatsEntry.setStatus('current')
if mibBuilder.loadTexts: apStatsEntry.setDescription('Statistics for an access point.')
apInUcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 2, 1, 1), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apInUcastPkts.setStatus('current')
if mibBuilder.loadTexts: apInUcastPkts.setDescription('Number of unicast packets from wireless-to-wired network.')
apInNUcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 2, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apInNUcastPkts.setStatus('current')
if mibBuilder.loadTexts: apInNUcastPkts.setDescription('Number of non-unicast packets from wireless-to-wired network.')
apInOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 2, 1, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apInOctets.setStatus('current')
if mibBuilder.loadTexts: apInOctets.setDescription('Number of octets from wireless-to-wired network.')
apInErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 2, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apInErrors.setStatus('current')
if mibBuilder.loadTexts: apInErrors.setDescription('Number of error packets from wireless-to-wired network.')
apInDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 2, 1, 5), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apInDiscards.setStatus('current')
if mibBuilder.loadTexts: apInDiscards.setDescription('Number of discarded packets from wireless-to-wired network.')
apOutUcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 2, 1, 6), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apOutUcastPkts.setStatus('current')
if mibBuilder.loadTexts: apOutUcastPkts.setDescription('Number of unicast packets from wired-to-wireless network.')
apOutNUcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 2, 1, 7), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apOutNUcastPkts.setStatus('current')
if mibBuilder.loadTexts: apOutNUcastPkts.setDescription('Number of non-unicast packets from wired-to-wireless network.')
apOutOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 2, 1, 8), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apOutOctets.setStatus('current')
if mibBuilder.loadTexts: apOutOctets.setDescription('Number of octets from wired-to-wireless network.')
apOutErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 2, 1, 9), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apOutErrors.setStatus('current')
if mibBuilder.loadTexts: apOutErrors.setDescription('Number of error packets from wired-to-wireless network.')
apOutDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 2, 1, 10), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apOutDiscards.setStatus('current')
if mibBuilder.loadTexts: apOutDiscards.setDescription('Number of discarded packets from wired-to-wireless network.')
apUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 2, 1, 11), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apUpTime.setStatus('current')
if mibBuilder.loadTexts: apUpTime.setDescription('The time (in hundredths of a second) since the management portion of the access point was last re-initialized.')
apCredentialType = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("none", 0), ("tls", 1), ("peap", 2), ("all", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apCredentialType.setStatus('current')
if mibBuilder.loadTexts: apCredentialType.setDescription('Supported certificate type used by AP for commnuication. none(0) = not supported, TLS(1) = Trasport Layer Security (TLS), PEAP(2) = Protected Extensible Authentication Protocol, all(2) = supports all supported EAP.')
apCertificateExpiry = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 2, 1, 13), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apCertificateExpiry.setStatus('current')
if mibBuilder.loadTexts: apCertificateExpiry.setDescription('The number of timeticks from January, 1st, 1970 to the date when the certificate expires (issued certificate no longer is valid).')
apStatsMuCounts = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 2, 1, 14), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apStatsMuCounts.setStatus('current')
if mibBuilder.loadTexts: apStatsMuCounts.setDescription('Number of MUs currently associated with this AP.')
apStatsSessionDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 2, 1, 15), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apStatsSessionDuration.setStatus('current')
if mibBuilder.loadTexts: apStatsSessionDuration.setDescription("Elapse time since the access point's session has started.")
apTotalStationsA = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 2, 1, 16), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apTotalStationsA.setStatus('current')
if mibBuilder.loadTexts: apTotalStationsA.setDescription("Number of MUs that are currently associated to this AP using dot11 connection mode 'a'.")
apTotalStationsB = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 2, 1, 17), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apTotalStationsB.setStatus('current')
if mibBuilder.loadTexts: apTotalStationsB.setDescription("Number of MUs that are currently associated to this AP using dot11 connection mode 'b'.")
apTotalStationsG = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 2, 1, 18), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apTotalStationsG.setStatus('current')
if mibBuilder.loadTexts: apTotalStationsG.setDescription("Number of MUs that are currently associated to this AP using dot11 connection mode 'g'.")
apTotalStationsN50 = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 2, 1, 19), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apTotalStationsN50.setStatus('current')
if mibBuilder.loadTexts: apTotalStationsN50.setDescription("Number of MUs that are currently associated to this AP using dot11 connection mode 'n 5.0 Ghz'.")
apTotalStationsN24 = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 2, 1, 20), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apTotalStationsN24.setStatus('current')
if mibBuilder.loadTexts: apTotalStationsN24.setDescription("Number of MUs that are currently associated to this AP using dot11 connection mode 'n 2.4 Ghz'.")
apInvalidPolicyCount = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 2, 1, 21), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apInvalidPolicyCount.setStatus('current')
if mibBuilder.loadTexts: apInvalidPolicyCount.setDescription('Number of invalid role has been assigned to the AP')
apInterfaceMTU = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 2, 1, 22), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apInterfaceMTU.setStatus('current')
if mibBuilder.loadTexts: apInterfaceMTU.setDescription("The AP's configured ethernet interface MTU size in bytes. ")
apEffectiveTunnelMTU = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 2, 1, 23), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apEffectiveTunnelMTU.setStatus('current')
if mibBuilder.loadTexts: apEffectiveTunnelMTU.setDescription('The AP Effective Tunnel MTU determines the maximum length of the frames that can be tunnelled without fragmentation, after subtracting the tunnel headers (WASSP and IPSEC). The AP Effective Tunnel MTU is determined for each AP tunnel as minimum between the Static MTU (configurable) and Dynamic MTU (learned from the ICMP path discovery).')
apTotalStationsAC = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 2, 1, 24), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apTotalStationsAC.setStatus('current')
if mibBuilder.loadTexts: apTotalStationsAC.setDescription('Number of MUs that are currently associated to this AP using dot11ac connection mode.')
apTotalStationsAInOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 2, 1, 25), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apTotalStationsAInOctets.setStatus('current')
if mibBuilder.loadTexts: apTotalStationsAInOctets.setDescription('Number of octets from client to AP for clients using protocol 802.11a.')
apTotalStationsAOutOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 2, 1, 26), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apTotalStationsAOutOctets.setStatus('current')
if mibBuilder.loadTexts: apTotalStationsAOutOctets.setDescription('Number of octets from AP to client for clients using protocol 802.11a.')
apTotalStationsBInOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 2, 1, 27), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apTotalStationsBInOctets.setStatus('current')
if mibBuilder.loadTexts: apTotalStationsBInOctets.setDescription('Number of octets from client to AP for clients using protocol 802.11b.')
apTotalStationsBOutOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 2, 1, 28), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apTotalStationsBOutOctets.setStatus('current')
if mibBuilder.loadTexts: apTotalStationsBOutOctets.setDescription('Number of octets from AP to client for clients using protocol 802.11b.')
apTotalStationsGInOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 2, 1, 29), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apTotalStationsGInOctets.setStatus('current')
if mibBuilder.loadTexts: apTotalStationsGInOctets.setDescription('Number of octets from client to AP for clients using protocol 802.11g.')
apTotalStationsGOutOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 2, 1, 30), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apTotalStationsGOutOctets.setStatus('current')
if mibBuilder.loadTexts: apTotalStationsGOutOctets.setDescription('Number of octets from AP to client for clients using protocol 802.11g.')
apTotalStationsN50InOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 2, 1, 31), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apTotalStationsN50InOctets.setStatus('current')
if mibBuilder.loadTexts: apTotalStationsN50InOctets.setDescription('Number of octets from client to AP for clients using protocol 802.11n (5Ghz).')
apTotalStationsN50OutOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 2, 1, 32), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apTotalStationsN50OutOctets.setStatus('current')
if mibBuilder.loadTexts: apTotalStationsN50OutOctets.setDescription('Number of octets from AP to client for clients using protocol 802.11n (5Ghz).')
apTotalStationsN24InOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 2, 1, 33), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apTotalStationsN24InOctets.setStatus('current')
if mibBuilder.loadTexts: apTotalStationsN24InOctets.setDescription('Number of octets from client to AP for clients using protocol 802.11n (2.4Ghz).')
apTotalStationsN24OutOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 2, 1, 34), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apTotalStationsN24OutOctets.setStatus('current')
if mibBuilder.loadTexts: apTotalStationsN24OutOctets.setDescription('Number of octets from AP to client for clients using protocol 802.11n (2.4Ghz).')
apTotalStationsACInOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 2, 1, 35), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apTotalStationsACInOctets.setStatus('current')
if mibBuilder.loadTexts: apTotalStationsACInOctets.setDescription('Number of octets from client to AP for clients using protocol 802.11ac.')
apTotalStationsACOutOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 2, 1, 36), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apTotalStationsACOutOctets.setStatus('current')
if mibBuilder.loadTexts: apTotalStationsACOutOctets.setDescription('Number of octets from AP to client for clients using protocol 802.11ac.')
apRegistrationRequests = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apRegistrationRequests.setStatus('current')
if mibBuilder.loadTexts: apRegistrationRequests.setDescription('Total registration request have been received by all access points since last reboot.')
apRadioStatusTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 4), )
if mibBuilder.loadTexts: apRadioStatusTable.setStatus('current')
if mibBuilder.loadTexts: apRadioStatusTable.setDescription('Table of radio configuration attributes that the AP can change dynamically. It contains one entry for each radio of each active AP.')
apRadioStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 4, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: apRadioStatusEntry.setStatus('current')
if mibBuilder.loadTexts: apRadioStatusEntry.setDescription('The configuration attributes of one AP radio that the AP can change dynamically.')
apRadioStatusChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 4, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apRadioStatusChannel.setStatus('current')
if mibBuilder.loadTexts: apRadioStatusChannel.setDescription('The lowest 20 MHz channel of the 20/40/80 MHz wide channel on which the radio is operating. This can be different from the administratively configured channel as a result of the AP complying with regulatory requirements like DFS or adapting to the RF environment (e.g. DCS). If this field value is set to 0, then this means this radio is off or this AP is in Guardian mode.')
apRadioStatusChannelWidth = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4))).clone(namedValues=NamedValues(("width20Mhz", 1), ("width40Mhz", 2), ("width80Mhz", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apRadioStatusChannelWidth.setStatus('current')
if mibBuilder.loadTexts: apRadioStatusChannelWidth.setDescription("Maximum width of the channel being served by the AP's radio. The AP may select a different channel width from the administratively configured width in order to comply with regulatory requirements and the current RF environment.")
apRadioStatusChannelOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 4, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apRadioStatusChannelOffset.setStatus('current')
if mibBuilder.loadTexts: apRadioStatusChannelOffset.setDescription('This is the offset (in 20 MHz channels) of the primary channel from the lowest 20 MHz channel within an aggregated channel. The offset can be 0 if the primary channel is the same as the lowest channel or it can be 1,2 or 3 depending on the aggregate channel width. The AP may select a different channel width from the administratively configured width in order to comply with regulatory requirements and the current RF environment.')
apPerformanceReportByRadioTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 5), )
if mibBuilder.loadTexts: apPerformanceReportByRadioTable.setStatus('current')
if mibBuilder.loadTexts: apPerformanceReportByRadioTable.setDescription('Table of AP performance statistics by radio that the AP can change dynamically. It contains one entry for each radio of each active AP.')
apPerformanceReportByRadioEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 5, 1), ).setIndexNames((0, "HIPATH-WIRELESS-HWC-MIB", "apIndex"), (0, "HIPATH-WIRELESS-HWC-MIB", "apRadioIndex"))
if mibBuilder.loadTexts: apPerformanceReportByRadioEntry.setStatus('current')
if mibBuilder.loadTexts: apPerformanceReportByRadioEntry.setDescription('The AP radio performance statistics of one AP radio.')
apRadioIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2)))
if mibBuilder.loadTexts: apRadioIndex.setStatus('current')
if mibBuilder.loadTexts: apRadioIndex.setDescription('Index of an radio inside an AP.')
apPerfRadioPrevPeakChannelUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 5, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apPerfRadioPrevPeakChannelUtilization.setStatus('current')
if mibBuilder.loadTexts: apPerfRadioPrevPeakChannelUtilization.setDescription('Peak channel utilization in % from last 15 minute interval.')
apPerfRadioCurPeakChannelUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 5, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apPerfRadioCurPeakChannelUtilization.setStatus('current')
if mibBuilder.loadTexts: apPerfRadioCurPeakChannelUtilization.setDescription('Peak channel utilization in % of current 15 minute interval.')
apPerfRadioAverageChannelUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 5, 1, 4), HundredthOfGauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apPerfRadioAverageChannelUtilization.setStatus('current')
if mibBuilder.loadTexts: apPerfRadioAverageChannelUtilization.setDescription('Running average of channel utilization in hundredth of a %.')
apPerfRadioCurrentChannelUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 5, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apPerfRadioCurrentChannelUtilization.setStatus('current')
if mibBuilder.loadTexts: apPerfRadioCurrentChannelUtilization.setDescription('Channel utilization in % from latest statistics from AP.')
apPerfRadioPrevPeakRSS = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 5, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apPerfRadioPrevPeakRSS.setStatus('current')
if mibBuilder.loadTexts: apPerfRadioPrevPeakRSS.setDescription('Peak RSS in dBm from last 15 minute interval. Value of -100 means this field is not available.')
apPerfRadioCurPeakRSS = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 5, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apPerfRadioCurPeakRSS.setStatus('current')
if mibBuilder.loadTexts: apPerfRadioCurPeakRSS.setDescription('Peak RSS in dBm of current 15 minute interval. Value of -100 means this field is not available.')
apPerfRadioAverageRSS = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 5, 1, 8), HundredthOfInt32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apPerfRadioAverageRSS.setStatus('current')
if mibBuilder.loadTexts: apPerfRadioAverageRSS.setDescription('Running average of RSS in hundredth of a dBm. Value of -10000 means this field is not available.')
apPerfRadioCurrentRSS = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 5, 1, 9), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apPerfRadioCurrentRSS.setStatus('current')
if mibBuilder.loadTexts: apPerfRadioCurrentRSS.setDescription('RSS in dBm from latest statistics from AP. Value of -100 means this field is not available.')
apPerfRadioPrevPeakSNR = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 5, 1, 10), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apPerfRadioPrevPeakSNR.setStatus('current')
if mibBuilder.loadTexts: apPerfRadioPrevPeakSNR.setDescription('Peak SNR in dB from last 15 minute interval. Value of -100 means this field is not available.')
apPerfRadioCurPeakSNR = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 5, 1, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apPerfRadioCurPeakSNR.setStatus('current')
if mibBuilder.loadTexts: apPerfRadioCurPeakSNR.setDescription('Peak SNR in dB of current 15 minute interval. Value of -100 means this field is not available.')
apPerfRadioAverageSNR = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 5, 1, 12), HundredthOfInt32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apPerfRadioAverageSNR.setStatus('current')
if mibBuilder.loadTexts: apPerfRadioAverageSNR.setDescription('Running average of SNR in hundredth of a dB. Value of -10000 means this field is not available.')
apPerfRadioCurrentSNR = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 5, 1, 13), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apPerfRadioCurrentSNR.setStatus('current')
if mibBuilder.loadTexts: apPerfRadioCurrentSNR.setDescription('SNR in dB from latest statistics from AP. Value of -100 means this field is not available.')
apPerfRadioPrevPeakPktRetx = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 5, 1, 14), HundredthOfGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apPerfRadioPrevPeakPktRetx.setStatus('current')
if mibBuilder.loadTexts: apPerfRadioPrevPeakPktRetx.setDescription('Peak packet retransmissions in hundredth of pps from last 15 minute interval.')
apPerfRadioCurPeakPktRetx = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 5, 1, 15), HundredthOfGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apPerfRadioCurPeakPktRetx.setStatus('current')
if mibBuilder.loadTexts: apPerfRadioCurPeakPktRetx.setDescription('Peak packet retransmissions in hundredth of pps of current 15 minute interval.')
apPerfRadioAveragePktRetx = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 5, 1, 16), HundredthOfGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apPerfRadioAveragePktRetx.setStatus('current')
if mibBuilder.loadTexts: apPerfRadioAveragePktRetx.setDescription('Running average of packet retransmissions in hundredth of pps.')
apPerfRadioCurrentPktRetx = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 5, 1, 17), HundredthOfGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apPerfRadioCurrentPktRetx.setStatus('current')
if mibBuilder.loadTexts: apPerfRadioCurrentPktRetx.setDescription('Packet retransmissions in hundredth of pps from latest statistics from AP.')
apPerfRadioPktRetx = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 5, 1, 18), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apPerfRadioPktRetx.setStatus('current')
if mibBuilder.loadTexts: apPerfRadioPktRetx.setDescription('Running counter of number of packet retransmissions.')
apAccessibilityTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 6), )
if mibBuilder.loadTexts: apAccessibilityTable.setStatus('current')
if mibBuilder.loadTexts: apAccessibilityTable.setDescription('A table showing the rate of associations, reassociations and deauthentications/dissassociations from each AP radio. The table contains one row per radio per active AP.')
apAccessibilityEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 6, 1), ).setIndexNames((0, "HIPATH-WIRELESS-HWC-MIB", "apIndex"), (0, "HIPATH-WIRELESS-HWC-MIB", "apRadioIndex"))
if mibBuilder.loadTexts: apAccessibilityEntry.setStatus('current')
if mibBuilder.loadTexts: apAccessibilityEntry.setDescription('The accessibility statistics of one AP radio.')
apAccPrevPeakAssocReqRx = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 6, 1, 1), HundredthOfGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apAccPrevPeakAssocReqRx.setStatus('current')
if mibBuilder.loadTexts: apAccPrevPeakAssocReqRx.setDescription('Peak number of association requests in hundredth of requests per second received by AP from last 15 minute interval.')
apAccCurPeakAssocReqRx = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 6, 1, 2), HundredthOfGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apAccCurPeakAssocReqRx.setStatus('current')
if mibBuilder.loadTexts: apAccCurPeakAssocReqRx.setDescription('Peak number of association requests in hundredth of requests per second received by AP of current 15 minute interval.')
apAccAverageAssocReqRx = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 6, 1, 3), HundredthOfGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apAccAverageAssocReqRx.setStatus('current')
if mibBuilder.loadTexts: apAccAverageAssocReqRx.setDescription('Running average of association requests in hundredth of requests per second received by an AP radio.')
apAccCurrentAssocReqRx = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 6, 1, 4), HundredthOfGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apAccCurrentAssocReqRx.setStatus('current')
if mibBuilder.loadTexts: apAccCurrentAssocReqRx.setDescription('Association requests in hundredth of requests per second from latest statistics from AP.')
apAccAssocReqRx = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 6, 1, 5), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apAccAssocReqRx.setStatus('current')
if mibBuilder.loadTexts: apAccAssocReqRx.setDescription('Running counter of association requests.')
apAccPrevPeakReassocReqRx = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 6, 1, 6), HundredthOfGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apAccPrevPeakReassocReqRx.setStatus('current')
if mibBuilder.loadTexts: apAccPrevPeakReassocReqRx.setDescription('Peak number of re-association requests in hundredth of requests per second received by an AP radio from last 15 minute interval.')
apAccCurPeakReassocReqRx = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 6, 1, 7), HundredthOfGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apAccCurPeakReassocReqRx.setStatus('current')
if mibBuilder.loadTexts: apAccCurPeakReassocReqRx.setDescription('Peak number of re-association requests in hundredth of requests per second received by an AP radio of current 15 minute interval.')
apAccAverageReassocReqRx = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 6, 1, 8), HundredthOfGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apAccAverageReassocReqRx.setStatus('current')
if mibBuilder.loadTexts: apAccAverageReassocReqRx.setDescription('Running average of re-association requests in hundredth of requests per second received by an AP radio.')
apAccCurrentReassocReqRx = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 6, 1, 9), HundredthOfGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apAccCurrentReassocReqRx.setStatus('current')
if mibBuilder.loadTexts: apAccCurrentReassocReqRx.setDescription('Re-association requests in hundredth of requests per second received by an AP radio from latest statistics from AP.')
apAccReassocReqRx = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 6, 1, 10), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apAccReassocReqRx.setStatus('current')
if mibBuilder.loadTexts: apAccReassocReqRx.setDescription('Running counter of re-association requests received by an AP radio.')
apAccPrevPeakDisassocDeauthReqTx = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 6, 1, 11), HundredthOfGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apAccPrevPeakDisassocDeauthReqTx.setStatus('current')
if mibBuilder.loadTexts: apAccPrevPeakDisassocDeauthReqTx.setDescription('Peak number of disassociation/deauthentication requests in hundredth of requests per second transmitted by an AP radio from last 15 minute interval.')
apAccCurPeakDisassocDeauthReqTx = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 6, 1, 12), HundredthOfGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apAccCurPeakDisassocDeauthReqTx.setStatus('current')
if mibBuilder.loadTexts: apAccCurPeakDisassocDeauthReqTx.setDescription('Peak number of disassociation/deauthentication requests in hundredth of requests per second transmitted by an AP radio of current 15 minute interval.')
apAccAverageDisassocDeauthReqTx = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 6, 1, 13), HundredthOfGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apAccAverageDisassocDeauthReqTx.setStatus('current')
if mibBuilder.loadTexts: apAccAverageDisassocDeauthReqTx.setDescription('Running average of disassociation/deauthentication requests in hundredth of requests per second transmitted by an AP radio.')
apAccCurrentDisassocDeauthReqTx = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 6, 1, 14), HundredthOfGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apAccCurrentDisassocDeauthReqTx.setStatus('current')
if mibBuilder.loadTexts: apAccCurrentDisassocDeauthReqTx.setDescription('Disassociation/deauthentication requests in hundredth of requests per second transmitted by an AP radio from latest statistics from AP.')
apAccDisassocDeauthReqTx = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 6, 1, 15), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apAccDisassocDeauthReqTx.setStatus('current')
if mibBuilder.loadTexts: apAccDisassocDeauthReqTx.setDescription('Running counter of disassociation/deauthentication requests transmitted by an AP radio.')
apAccPrevPeakDisassocDeauthReqRx = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 6, 1, 16), HundredthOfGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apAccPrevPeakDisassocDeauthReqRx.setStatus('current')
if mibBuilder.loadTexts: apAccPrevPeakDisassocDeauthReqRx.setDescription('Peak number of disassociation/deauthentication requests in hundredth of requests per second received by an AP radio from last 15 minute interval.')
apAccCurPeakDisassocDeauthReqRx = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 6, 1, 17), HundredthOfGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apAccCurPeakDisassocDeauthReqRx.setStatus('current')
if mibBuilder.loadTexts: apAccCurPeakDisassocDeauthReqRx.setDescription('Peak number of disassociation/deauthentication requests in hundredth of requests per second received by an AP radio of current 15 minute interval.')
apAccAverageDisassocDeauthReqRx = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 6, 1, 18), HundredthOfGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apAccAverageDisassocDeauthReqRx.setStatus('current')
if mibBuilder.loadTexts: apAccAverageDisassocDeauthReqRx.setDescription('Running average of disassociation/deauthentication requests in hundredth of requests per second received by an AP radio.')
apAccCurrentDisassocDeauthReqRx = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 6, 1, 19), HundredthOfGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apAccCurrentDisassocDeauthReqRx.setStatus('current')
if mibBuilder.loadTexts: apAccCurrentDisassocDeauthReqRx.setDescription('Disassociation/deauthentication requests in hundredth of requests per second received by an AP radio from latest statistics from AP.')
apAccDisassocDeauthReqRx = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 6, 1, 20), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apAccDisassocDeauthReqRx.setStatus('current')
if mibBuilder.loadTexts: apAccDisassocDeauthReqRx.setDescription('Running counter of disassociation/deauthentication requests received by an AP radio.')
apPerformanceReportbyRadioAndWlanTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 7), )
if mibBuilder.loadTexts: apPerformanceReportbyRadioAndWlanTable.setStatus('current')
if mibBuilder.loadTexts: apPerformanceReportbyRadioAndWlanTable.setDescription('Table of AP performance statistics by AP, AP radio and WLAN. ')
apPerformanceReportbyRadioAndWlanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 7, 1), ).setIndexNames((0, "HIPATH-WIRELESS-HWC-MIB", "apIndex"), (0, "HIPATH-WIRELESS-HWC-MIB", "apRadioIndex"), (0, "HIPATH-WIRELESS-HWC-MIB", "wlanID"))
if mibBuilder.loadTexts: apPerformanceReportbyRadioAndWlanEntry.setStatus('current')
if mibBuilder.loadTexts: apPerformanceReportbyRadioAndWlanEntry.setDescription('The AP performance statistics of one AP radio and WLAN.')
apPerfWlanPrevPeakClientsPerSec = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 7, 1, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apPerfWlanPrevPeakClientsPerSec.setStatus('current')
if mibBuilder.loadTexts: apPerfWlanPrevPeakClientsPerSec.setDescription('Peak clients per second from last 15 minute interval.')
apPerfWlanCurPeakClientsPerSec = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 7, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apPerfWlanCurPeakClientsPerSec.setStatus('current')
if mibBuilder.loadTexts: apPerfWlanCurPeakClientsPerSec.setDescription('Peak clients per second of current 15 minute interval.')
apPerfWlanAverageClientsPerSec = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 7, 1, 3), HundredthOfGauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apPerfWlanAverageClientsPerSec.setStatus('current')
if mibBuilder.loadTexts: apPerfWlanAverageClientsPerSec.setDescription('Running average of clients in hundredth of clients per second.')
apPerfWlanCurrentClientsPerSec = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 7, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apPerfWlanCurrentClientsPerSec.setStatus('current')
if mibBuilder.loadTexts: apPerfWlanCurrentClientsPerSec.setDescription('Clients per second from latest statistics from AP.')
apPerfWlanPrevPeakULOctetsPerSec = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 7, 1, 5), HundredthOfGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apPerfWlanPrevPeakULOctetsPerSec.setStatus('current')
if mibBuilder.loadTexts: apPerfWlanPrevPeakULOctetsPerSec.setDescription('Peak uplink octets in hundredth of octets per second from last 15 minute interval.')
apPerfWlanCurPeakULOctetsPerSec = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 7, 1, 6), HundredthOfGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apPerfWlanCurPeakULOctetsPerSec.setStatus('current')
if mibBuilder.loadTexts: apPerfWlanCurPeakULOctetsPerSec.setDescription('Peak uplink octets in hundredth of octets per second of current 15 minute interval.')
apPerfWlanAverageULOctetsPerSec = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 7, 1, 7), HundredthOfGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apPerfWlanAverageULOctetsPerSec.setStatus('current')
if mibBuilder.loadTexts: apPerfWlanAverageULOctetsPerSec.setDescription('Running average of uplink hundredth of octets per second.')
apPerfWlanCurrentULOctetsPerSec = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 7, 1, 8), HundredthOfGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apPerfWlanCurrentULOctetsPerSec.setStatus('current')
if mibBuilder.loadTexts: apPerfWlanCurrentULOctetsPerSec.setDescription('Uplink octets in hundredth of octets per second from latest statistics from AP.')
apPerfWlanULOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 7, 1, 9), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apPerfWlanULOctets.setStatus('current')
if mibBuilder.loadTexts: apPerfWlanULOctets.setDescription('Running counter of uplink octets per second.')
apPerfWlanPrevPeakULPktsPerSec = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 7, 1, 10), HundredthOfGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apPerfWlanPrevPeakULPktsPerSec.setStatus('current')
if mibBuilder.loadTexts: apPerfWlanPrevPeakULPktsPerSec.setDescription('Peak uplink packets in hundredth of packets per second from last 15 minute interval.')
apPerfWlanCurPeakULPktsPerSec = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 7, 1, 11), HundredthOfGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apPerfWlanCurPeakULPktsPerSec.setStatus('current')
if mibBuilder.loadTexts: apPerfWlanCurPeakULPktsPerSec.setDescription('Peak uplink packets in hundredth of packets per second of current 15 minute interval.')
apPerfWlanAverageULPktsPerSec = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 7, 1, 12), HundredthOfGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apPerfWlanAverageULPktsPerSec.setStatus('current')
if mibBuilder.loadTexts: apPerfWlanAverageULPktsPerSec.setDescription('Running average of uplink packets in hundredth of packets per second.')
apPerfWlanCurrentULPktsPerSec = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 7, 1, 13), HundredthOfGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apPerfWlanCurrentULPktsPerSec.setStatus('current')
if mibBuilder.loadTexts: apPerfWlanCurrentULPktsPerSec.setDescription('Uplink packets in hundredth of packets per second from latest statistics from AP.')
apPerfWlanULPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 7, 1, 14), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apPerfWlanULPkts.setStatus('current')
if mibBuilder.loadTexts: apPerfWlanULPkts.setDescription('Running counter of uplink packets per second.')
apPerfWlanPrevPeakDLOctetsPerSec = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 7, 1, 15), HundredthOfGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apPerfWlanPrevPeakDLOctetsPerSec.setStatus('current')
if mibBuilder.loadTexts: apPerfWlanPrevPeakDLOctetsPerSec.setDescription('Peak downlink octets in hundredth of octets per second from last 15 minute interval.')
apPerfWlanCurPeakDLOctetsPerSec = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 7, 1, 16), HundredthOfGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apPerfWlanCurPeakDLOctetsPerSec.setStatus('current')
if mibBuilder.loadTexts: apPerfWlanCurPeakDLOctetsPerSec.setDescription('Peak downlink octets in hundredth of octets per second of current 15 minute interval.')
apPerfWlanAverageDLOctetsPerSec = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 7, 1, 17), HundredthOfGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apPerfWlanAverageDLOctetsPerSec.setStatus('current')
if mibBuilder.loadTexts: apPerfWlanAverageDLOctetsPerSec.setDescription('Running average of downlink octets in hundredth of octets per second.')
apPerfWlanCurrentDLOctetsPerSec = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 7, 1, 18), HundredthOfGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apPerfWlanCurrentDLOctetsPerSec.setStatus('current')
if mibBuilder.loadTexts: apPerfWlanCurrentDLOctetsPerSec.setDescription('Downlink octets in hundredth octets per second from latest statistics from AP.')
apPerfWlanDLOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 7, 1, 19), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apPerfWlanDLOctets.setStatus('current')
if mibBuilder.loadTexts: apPerfWlanDLOctets.setDescription('Running counter of downlink octets per second.')
apPerfWlanPrevPeakDLPktsPerSec = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 7, 1, 20), HundredthOfGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apPerfWlanPrevPeakDLPktsPerSec.setStatus('current')
if mibBuilder.loadTexts: apPerfWlanPrevPeakDLPktsPerSec.setDescription('Peak downlink packets in hundredth of packets per second from last 15 minute interval.')
apPerfWlanCurPeakDLPktsPerSec = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 7, 1, 21), HundredthOfGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apPerfWlanCurPeakDLPktsPerSec.setStatus('current')
if mibBuilder.loadTexts: apPerfWlanCurPeakDLPktsPerSec.setDescription('Peak downlink packets in hundredth of packets per second of current 15 minute interval.')
apPerfWlanAverageDLPktsPerSec = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 7, 1, 22), HundredthOfGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apPerfWlanAverageDLPktsPerSec.setStatus('current')
if mibBuilder.loadTexts: apPerfWlanAverageDLPktsPerSec.setDescription('Running average of downlink packets in hundredth of packets per second.')
apPerfWlanCurrentDLPktsPerSec = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 7, 1, 23), HundredthOfGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apPerfWlanCurrentDLPktsPerSec.setStatus('current')
if mibBuilder.loadTexts: apPerfWlanCurrentDLPktsPerSec.setDescription('Downlink packets in hundredth of packets per second from latest statistics from AP.')
apPerfWlanDLPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 7, 1, 24), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apPerfWlanDLPkts.setStatus('current')
if mibBuilder.loadTexts: apPerfWlanDLPkts.setDescription('Running counter of downlink packets per second.')
apChannelUtilizationTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 8), )
if mibBuilder.loadTexts: apChannelUtilizationTable.setStatus('current')
if mibBuilder.loadTexts: apChannelUtilizationTable.setDescription('Table of AP utilization by channel that the AP can change dynamically. It contains one entry for each radio and channel of each active AP.')
apChannelUtilizationEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 8, 1), ).setIndexNames((0, "HIPATH-WIRELESS-HWC-MIB", "apIndex"), (0, "HIPATH-WIRELESS-HWC-MIB", "apRadioIndex"), (0, "HIPATH-WIRELESS-HWC-MIB", "channel"))
if mibBuilder.loadTexts: apChannelUtilizationEntry.setStatus('current')
if mibBuilder.loadTexts: apChannelUtilizationEntry.setDescription('The AP performance statistics of one AP radio and channel.')
channel = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 8, 1, 1), Unsigned32())
if mibBuilder.loadTexts: channel.setStatus('current')
if mibBuilder.loadTexts: channel.setDescription('Channel on which utilization is measured.')
apChnlUtilPrevPeakUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 8, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apChnlUtilPrevPeakUtilization.setStatus('current')
if mibBuilder.loadTexts: apChnlUtilPrevPeakUtilization.setDescription('Peak channel utilization in % from last 15 minute interval.')
apChnlUtilCurPeakUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 8, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apChnlUtilCurPeakUtilization.setStatus('current')
if mibBuilder.loadTexts: apChnlUtilCurPeakUtilization.setDescription('Peak channel utilization in % of current 15 minute interval.')
apChnlUtilAverageUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 8, 1, 4), HundredthOfGauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apChnlUtilAverageUtilization.setStatus('current')
if mibBuilder.loadTexts: apChnlUtilAverageUtilization.setDescription('Running average of channel utilization in hundredth of %.')
apChnlUtilCurrentUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 8, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apChnlUtilCurrentUtilization.setStatus('current')
if mibBuilder.loadTexts: apChnlUtilCurrentUtilization.setDescription('Channel utilization in % from latest statistics from AP.')
apNeighboursTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 9), )
if mibBuilder.loadTexts: apNeighboursTable.setStatus('current')
if mibBuilder.loadTexts: apNeighboursTable.setDescription('A table showing the BSSID, RSS, operating radio channel and detailed information of a nearby AP. The table contains one row per nearby AP per radio per active AP.')
apNeighboursEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 9, 1), ).setIndexNames((0, "HIPATH-WIRELESS-HWC-MIB", "apIndex"), (0, "IF-MIB", "ifIndex"), (0, "HIPATH-WIRELESS-HWC-MIB", "nearbyApIndex"))
if mibBuilder.loadTexts: apNeighboursEntry.setStatus('current')
if mibBuilder.loadTexts: apNeighboursEntry.setDescription('The configuration attributes of one nearby AP.')
nearbyApIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 9, 1, 1), Unsigned32())
if mibBuilder.loadTexts: nearbyApIndex.setStatus('current')
if mibBuilder.loadTexts: nearbyApIndex.setDescription('Nearby AP index.')
nearbyApInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 9, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nearbyApInfo.setStatus('current')
if mibBuilder.loadTexts: nearbyApInfo.setDescription('Detailed information of a nearby AP. ')
nearbyApBSSID = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 9, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(17, 17)).setFixedLength(17)).setMaxAccess("readonly")
if mibBuilder.loadTexts: nearbyApBSSID.setStatus('current')
if mibBuilder.loadTexts: nearbyApBSSID.setDescription('The BSSID of a nearby AP. ')
nearbyApChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 9, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nearbyApChannel.setStatus('current')
if mibBuilder.loadTexts: nearbyApChannel.setDescription('The operating radio channel of a nearby AP. ')
nearbyApRSS = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 2, 9, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nearbyApRSS.setStatus('current')
if mibBuilder.loadTexts: nearbyApRSS.setDescription('The Received Signal Strength of a nearby AP. ')
sensorManagement = MibIdentifier((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 3))
tftpSever = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 3, 1), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tftpSever.setStatus('current')
if mibBuilder.loadTexts: tftpSever.setDescription('TFTP server that sensor image resides.')
imagePath26xx = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 3, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: imagePath26xx.setStatus('current')
if mibBuilder.loadTexts: imagePath26xx.setDescription('Path of sensor image on TFTP server.')
imagePath36xx = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 3, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: imagePath36xx.setStatus('current')
if mibBuilder.loadTexts: imagePath36xx.setDescription('Path of sensor image on TFTP server.')
imageVersionOfap26xx = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 3, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: imageVersionOfap26xx.setStatus('current')
if mibBuilder.loadTexts: imageVersionOfap26xx.setDescription("Sensor's software version.")
imageVersionOfngap36xx = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 3, 5), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: imageVersionOfngap36xx.setStatus('current')
if mibBuilder.loadTexts: imageVersionOfngap36xx.setDescription("Sensor's softerware version for Next Generation Access Point.")
apRegistration = MibIdentifier((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 4))
apRegSecurityMode = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 4, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("allowAll", 1), ("allowApprovedOnes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apRegSecurityMode.setStatus('current')
if mibBuilder.loadTexts: apRegSecurityMode.setDescription("Indicates registration mode for an AP. If allowAll(1), then all wireless APs are allowed to register to the controlloer, otherwise only approved APs in 'Approved AP' list are allowed to register to the controller.")
apRegDiscoveryRetries = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 4, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apRegDiscoveryRetries.setStatus('current')
if mibBuilder.loadTexts: apRegDiscoveryRetries.setDescription('Number of retries for discovery requests from an access point to controller. After these number of retries, the access point will start over again after some arbitrary delays.')
apRegDiscoveryInterval = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 4, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 10)).clone(3)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: apRegDiscoveryInterval.setStatus('current')
if mibBuilder.loadTexts: apRegDiscoveryInterval.setDescription('Interval between two consecutive discovery requests from the same access point.')
apRegTelnetPassword = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 4, 4), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apRegTelnetPassword.setStatus('current')
if mibBuilder.loadTexts: apRegTelnetPassword.setDescription('Password used to access an AP via telnet. This field is write-only and read access returns empty string.')
apRegSSHPassword = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 4, 5), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apRegSSHPassword.setStatus('current')
if mibBuilder.loadTexts: apRegSSHPassword.setDescription('SSH password used to access an access point. This field is write-only and read access returns empty string.')
apRegUseClusterEncryption = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 4, 6), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apRegUseClusterEncryption.setStatus('current')
if mibBuilder.loadTexts: apRegUseClusterEncryption.setDescription('If this field set to true, then all APs in the cluster use cluster encryption.')
apRegClusterSharedSecret = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 4, 7), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apRegClusterSharedSecret.setStatus('current')
if mibBuilder.loadTexts: apRegClusterSharedSecret.setDescription('Password for cluster encryption. This field is write-only and read access returns empty string.')
loadBalancing = MibIdentifier((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 5))
loadGroupTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 5, 1), )
if mibBuilder.loadTexts: loadGroupTable.setStatus('current')
if mibBuilder.loadTexts: loadGroupTable.setDescription('Table of configured load groups for access points. A set of access points can be grouped together and they are identified by unique name. An access point can only be assigned to one group.')
loadGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 5, 1, 1), ).setIndexNames((0, "HIPATH-WIRELESS-HWC-MIB", "loadGroupID"))
if mibBuilder.loadTexts: loadGroupEntry.setStatus('current')
if mibBuilder.loadTexts: loadGroupEntry.setDescription('An entry containing definition of a load group. There exists two types of load group: client-balancing-group and radio-balancing-group.')
loadGroupID = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 5, 1, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: loadGroupID.setStatus('current')
if mibBuilder.loadTexts: loadGroupID.setDescription('Internally generated ID for a group and cannot be changed externally.')
loadGroupName = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 5, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: loadGroupName.setStatus('current')
if mibBuilder.loadTexts: loadGroupName.setDescription('Unique name assigned to the group.')
loadGroupType = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 5, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("clientBalancing", 0), ("radioBalancing", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: loadGroupType.setStatus('current')
if mibBuilder.loadTexts: loadGroupType.setDescription('Type of load balancing this group supports.')
loadGroupBandPreference = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 5, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: loadGroupBandPreference.setStatus('current')
if mibBuilder.loadTexts: loadGroupBandPreference.setDescription('Band preference is enabled for this group if this field is set to true and group type is set to radioBalancing(1).')
loadGroupLoadControl = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 5, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: loadGroupLoadControl.setStatus('deprecated')
if mibBuilder.loadTexts: loadGroupLoadControl.setDescription('Load balancing is enabled for this group if this field is set to true and group type is set to radioBalancing(1).')
loadGroupClientCountRadio1 = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 5, 1, 1, 6), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(5, 60), ValueRangeConstraint(121, 121), )).clone(121)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: loadGroupClientCountRadio1.setStatus('current')
if mibBuilder.loadTexts: loadGroupClientCountRadio1.setDescription('Maximum number of client on this radio. This field is only applicable to a group with radioBalancing(1) type.')
loadGroupClientCountRadio2 = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 5, 1, 1, 7), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(5, 60), ValueRangeConstraint(121, 121), )).clone(121)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: loadGroupClientCountRadio2.setStatus('current')
if mibBuilder.loadTexts: loadGroupClientCountRadio2.setDescription('Maximum number of client on this radio. This field is only applicable to a group with radioBalancing(1) type.')
loadGroupLoadControlEnableR1 = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 5, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: loadGroupLoadControlEnableR1.setStatus('current')
if mibBuilder.loadTexts: loadGroupLoadControlEnableR1.setDescription('If it is enabled then load control is applicable to radio #1 of all access points that are assigned to this load group. This field has meaning only for the load group that is of radioBalancing(1) type. ')
loadGroupLoadControlEnableR2 = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 5, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: loadGroupLoadControlEnableR2.setStatus('current')
if mibBuilder.loadTexts: loadGroupLoadControlEnableR2.setDescription('If it is enabled then load control is applicable to radio #2 of all access points that are assigned to this load group. This field has meaning only for the load group that is of radioBalancing(1) type.')
loadGroupLoadControlStrictLimitR1 = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 5, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: loadGroupLoadControlStrictLimitR1.setStatus('current')
if mibBuilder.loadTexts: loadGroupLoadControlStrictLimitR1.setDescription('If it is enabled then strict limit for load control is applicable to radio #1 of all access points that are assigned to this load group. This field has meaning only for the load group that is of radioBalancing(1) type.')
loadGroupLoadControlStrictLimitR2 = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 5, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: loadGroupLoadControlStrictLimitR2.setStatus('current')
if mibBuilder.loadTexts: loadGroupLoadControlStrictLimitR2.setDescription('If it is enabled then strict limit for load control is applicable to radio #2 of all access points that are assigned to this load group. This field has meaning only for the load group that is of radioBalancing(1) type.')
loadGrpRadiosTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 5, 2), )
if mibBuilder.loadTexts: loadGrpRadiosTable.setStatus('current')
if mibBuilder.loadTexts: loadGrpRadiosTable.setDescription('Table of radio assignment to defined load groups. ')
loadGrpRadiosEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 5, 2, 1), ).setIndexNames((0, "HIPATH-WIRELESS-HWC-MIB", "loadGroupID"), (0, "HIPATH-WIRELESS-HWC-MIB", "apIndex"))
if mibBuilder.loadTexts: loadGrpRadiosEntry.setStatus('current')
if mibBuilder.loadTexts: loadGrpRadiosEntry.setDescription('Any entry defining radio assignment of AP, identified by apIndex, to a load group identified by loadGroupID.')
loadGrpRadiosRadio1 = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 5, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("notApplicable", 0), ("assigned", 1), ("unassigned", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: loadGrpRadiosRadio1.setStatus('current')
if mibBuilder.loadTexts: loadGrpRadiosRadio1.setDescription("If this field is set to 'assigned(1)', then the radio of the AP identified by the apIndex is a member of the load balancing group identified by the loadBlanaceID. For radio blanacing group, either all or none of the radios of a specific AP (indentified by apIndex) are assigned to the load balancing group.")
loadGrpRadiosRadio2 = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 5, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("notApplicable", 0), ("assigned", 1), ("unassigned", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: loadGrpRadiosRadio2.setStatus('current')
if mibBuilder.loadTexts: loadGrpRadiosRadio2.setDescription("If this field is set to 'assigned(2)', then the radio of the AP identified by the apIndex is a member of the load balancing group identified by the loadBlanaceID. For radio blanacing group, either all or none of the radios of a specific AP (indentified by apIndex) are assigned to the load balancing group.")
loadGrpWlanTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 5, 3), )
if mibBuilder.loadTexts: loadGrpWlanTable.setStatus('current')
if mibBuilder.loadTexts: loadGrpWlanTable.setDescription('Table of WLAN assignment to defined load groups. ')
loadGrpWlanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 5, 3, 1), ).setIndexNames((0, "HIPATH-WIRELESS-HWC-MIB", "loadGroupID"), (0, "HIPATH-WIRELESS-HWC-MIB", "wlanID"))
if mibBuilder.loadTexts: loadGrpWlanEntry.setStatus('current')
if mibBuilder.loadTexts: loadGrpWlanEntry.setDescription('An entry defining WLAN, identified by wlanID, assignment to a load group identified by loadGroupID.')
loadGrpWlanAssigned = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 5, 3, 1, 1), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: loadGrpWlanAssigned.setStatus('current')
if mibBuilder.loadTexts: loadGrpWlanAssigned.setDescription('Assignement of WLAN, identified with wlanID, to the load balancing group identified bye loadGroupID.')
apMaintenanceCycle = MibIdentifier((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 6))
schedule = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 6, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("never", 0), ("daily", 1), ("weekly", 2), ("monthly", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: schedule.setStatus('current')
if mibBuilder.loadTexts: schedule.setDescription('AP maintenance schedule options. 0 : never perform the maintenance action. 1 : perform the maintenance action every day. 2 : perform the maintenance action every week. 3 : perform the maintenance action every month.')
startHour = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 6, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 23))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: startHour.setStatus('current')
if mibBuilder.loadTexts: startHour.setDescription('Maintenance action starts at this hour of the day. ')
startMinute = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 6, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 59))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: startMinute.setStatus('current')
if mibBuilder.loadTexts: startMinute.setDescription('Maintenance action starts at this minute of the hour. ')
duration = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 6, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 23))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: duration.setStatus('current')
if mibBuilder.loadTexts: duration.setDescription('Duration of the AP maintenance cycle (how often maintenance is done) in hours. ')
recurrenceDaily = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 6, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("everyDay", 0), ("everyWeekday", 1), ("everyWeekend", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: recurrenceDaily.setStatus('current')
if mibBuilder.loadTexts: recurrenceDaily.setDescription('This field has meaning only when the maintenance schedule option is set to daily(1). Below is the recurrence option. 0 : every day. 1 : every weekday. 2 : every weekend.')
recurrenceWeekly = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 6, 6), Bits().clone(namedValues=NamedValues(("sunday", 0), ("monday", 1), ("tuesday", 2), ("wednesday", 3), ("thursday", 4), ("friday", 5), ("saturday", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: recurrenceWeekly.setStatus('current')
if mibBuilder.loadTexts: recurrenceWeekly.setDescription('This field has meaning only when the maintenance schedule option is set to weekly(2). Below are the recurrence options. BIT 0 : Sunday. BIT 1 : Monday. BIT 2 : Tuesday. BIT 3 : Wednesday. BIT 4 : Thursday. BIT 5 : Friday. BIT 6 : Saturday.')
recurrenceMonthly = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 6, 7), Bits().clone(namedValues=NamedValues(("first", 0), ("second", 1), ("third", 2), ("fourth", 3), ("fifth", 4), ("sunday", 5), ("monday", 6), ("tuesday", 7), ("wednesday", 8), ("thursday", 9), ("friday", 10), ("saturday", 11)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: recurrenceMonthly.setStatus('current')
if mibBuilder.loadTexts: recurrenceMonthly.setDescription('This field has meaning only when the maintenance schedule option is set to monthly(3). Below are the recurrence options. BIT 0 : the first week of the month. BIT 1 : the second week of the month. BIT 2 : the third week of the month. BIT 3 : the fourth week of the month. BIT 4 : the fifth week of the month. BIT 5 : sunday of the week. BIT 6 : monday of the week. BIT 7 : tuesday of the week. BIT 8 : wednesday of the week. BIT 9 : thursday of the week. BIT 10 : friday of the week. BIT 11 : saturday of the week.')
apPlatforms = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 5, 6, 8), Bits().clone(namedValues=NamedValues(("ap2600", 0), ("ap2605", 1), ("ap2650", 2), ("ap4102", 3), ("w786", 4), ("ap3705", 5), ("ap3710", 6), ("ap3715", 7), ("ap3765", 8), ("ap3767", 9), ("ap3801", 10), ("ap3805", 11), ("ap3825", 12), ("ap3865", 13), ("ap3935", 14), ("ap3965", 15), ("w78xc", 16), ("w78xcsfp", 17)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apPlatforms.setStatus('current')
if mibBuilder.loadTexts: apPlatforms.setDescription('Select which models of the AP platforms to perform the maintenance. BIT 0 : AP2600 platform. BIT 1 : AP2605 platform. BIT 2 : AP2650 platform. BIT 3 : AP4102 platform. BIT 4 : W786 platform. BIT 5 : AP3705 platform. BIT 6 : AP3710 platform. BIT 7 : AP3715 platform. BIT 8 : AP3765 platform. BIT 9 : AP3767 platform. BIT 10 : AP3801 platform. BIT 11 : AP3805 platform. BIT 12 : AP3825 platform. BIT 13 : AP3865 platform. BIT 14 : AP3935 platform. BIT 15 : AP3965 platform. BIT 16 : W78XC platform. BIT 17 : W78XCSFP platform.')
mobileUnits = MibIdentifier((1, 3, 6, 1, 4, 1, 4329, 15, 3, 6))
mobileUnitCount = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 6, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mobileUnitCount.setStatus('current')
if mibBuilder.loadTexts: mobileUnitCount.setDescription('Number of clients associated with the controller.')
muTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 6, 2), )
if mibBuilder.loadTexts: muTable.setStatus('current')
if mibBuilder.loadTexts: muTable.setDescription('Table of information for clients associated with the EWC.')
muEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 6, 2, 1), ).setIndexNames((0, "HIPATH-WIRELESS-HWC-MIB", "muMACAddress"))
if mibBuilder.loadTexts: muEntry.setStatus('current')
if mibBuilder.loadTexts: muEntry.setDescription('Information for a client associated with the EWC.')
muMACAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 6, 2, 1, 1), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: muMACAddress.setStatus('current')
if mibBuilder.loadTexts: muMACAddress.setDescription('Client MAC address.')
muIPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 6, 2, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: muIPAddress.setStatus('current')
if mibBuilder.loadTexts: muIPAddress.setDescription('Client IP Address.')
muUser = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 6, 2, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: muUser.setStatus('current')
if mibBuilder.loadTexts: muUser.setDescription('Client login name.')
muState = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 6, 2, 1, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: muState.setStatus('current')
if mibBuilder.loadTexts: muState.setDescription('True if the client is authenticated.')
muAPSerialNo = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 6, 2, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: muAPSerialNo.setStatus('current')
if mibBuilder.loadTexts: muAPSerialNo.setDescription('Serial Number of the Access Point the client is associated with.')
muVnsSSID = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 6, 2, 1, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: muVnsSSID.setStatus('current')
if mibBuilder.loadTexts: muVnsSSID.setDescription('SSID of the VNS the client is associated with.')
muTxPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 6, 2, 1, 7), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: muTxPackets.setStatus('current')
if mibBuilder.loadTexts: muTxPackets.setDescription('Number of packets trasmitted to the client.')
muRxPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 6, 2, 1, 8), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: muRxPackets.setStatus('current')
if mibBuilder.loadTexts: muRxPackets.setDescription('Number of packets received from the client.')
muTxOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 6, 2, 1, 9), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: muTxOctets.setStatus('current')
if mibBuilder.loadTexts: muTxOctets.setDescription('Number of octets transmitted to the client.')
muRxOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 6, 2, 1, 10), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: muRxOctets.setStatus('current')
if mibBuilder.loadTexts: muRxOctets.setDescription('Number of octets received from the client.')
muDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 6, 2, 1, 11), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: muDuration.setStatus('current')
if mibBuilder.loadTexts: muDuration.setDescription('Time client has been associated with the EWC.')
muAPName = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 6, 2, 1, 12), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: muAPName.setStatus('current')
if mibBuilder.loadTexts: muAPName.setDescription('Name of the Access Point the client is associated with.')
muTopologyName = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 6, 2, 1, 13), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: muTopologyName.setStatus('current')
if mibBuilder.loadTexts: muTopologyName.setDescription('Topology name that the MU is associated with.')
muPolicyName = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 6, 2, 1, 14), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: muPolicyName.setStatus('current')
if mibBuilder.loadTexts: muPolicyName.setDescription('The name of the policy that provides filter for this MU.')
muDefaultCoS = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 6, 2, 1, 15), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: muDefaultCoS.setStatus('current')
if mibBuilder.loadTexts: muDefaultCoS.setDescription('The CoS that is applied to the current traffic if the defined rule for the current traffic has not specifically defined any CoS.')
muConnectionProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 6, 2, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("unknown", 0), ("a", 1), ("g", 2), ("b", 3), ("n50", 4), ("n24", 5), ("ac", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: muConnectionProtocol.setStatus('current')
if mibBuilder.loadTexts: muConnectionProtocol.setDescription('The MU is using this connection protocol for current connection. Symbols notation: n50 = an = n5.0Ghz, n24 = bgn = n2.4Ghz')
muConnectionCapability = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 6, 2, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unknown", 0), ("a", 1), ("bg", 2), ("abg", 3), ("an", 4), ("bgn", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: muConnectionCapability.setStatus('deprecated')
if mibBuilder.loadTexts: muConnectionCapability.setDescription('This field indicates what are the MU connection capability.')
muWLANID = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 6, 2, 1, 18), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: muWLANID.setStatus('current')
if mibBuilder.loadTexts: muWLANID.setDescription('ID of the WLAN that the MU is associated with.')
muBSSIDMac = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 6, 2, 1, 19), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: muBSSIDMac.setStatus('current')
if mibBuilder.loadTexts: muBSSIDMac.setDescription('Client BSSID MAC address.')
muDot11ConnectionCapability = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 6, 2, 1, 20), Bits().clone(namedValues=NamedValues(("dot1150", 0), ("dot1124", 1), ("wpaV1", 2), ("wpaV2", 3), ("oneStream", 4), ("twoStream", 5), ("threeSteam", 6), ("uapsdVoice", 7), ("uapsdVideo", 8), ("uapsdBackground", 9), ("uapsdBesteffort", 10), ("wmm", 11), ("greenfield", 12), ("fastTransition", 13)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: muDot11ConnectionCapability.setStatus('current')
if mibBuilder.loadTexts: muDot11ConnectionCapability.setDescription('This field indicates what are the MU connection capabilities. bit 0 : If this bit is set, the client is capable to tx/rx on A radio. bit 1 : If this bit is set, the client is capable to tx/rx on BG radio. bit 2 : If this bit is set, the client is capable of wpaV1 privacy. bit 3 : If this bit is set, the client is capable of wpaV2 privacy. bit 4 : If this bit is set, the client is capable to comunicate with 1 data stream. bit 5 : If this bit is set, the client is capable to comunicate with 2 data streams. bit 6 : If this bit is set, the client is capable to comunicate with 3 data streams. bit 7 : If this bit is set, the client is capable of Unscheduled automatic power-save delivery (U-APSD) benefits. The voice client can synchronize the transmission and reception of voice frames with the AP. bit 8 : If this bit is set, the client is capable of Unscheduled automatic power-save delivery (U-APSD) benefits. The video client can synchronize the transmission and reception of video frames with the AP. bit 9 : If this bit is set, the client is capable of Unscheduled automatic power-save delivery (U-APSD) benefits. The client can synchronize the transmission and reception in background queue. bit 10 : If this bit is set, the client is capable of Unscheduled automatic power-save delivery (U-APSD) benefits. The client can synchronize the transmission and reception in best effort queue. bit 11 : If this bit is set, the client is capable of Wi-Fi Multimedia(WMM) power save. bit 12 : If this bit is set, the client is capable of 802.11n Greenfield mode. bit 13 : If this bit is set, the client is on fast-transition mode.')
muTSPECTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 6, 3), )
if mibBuilder.loadTexts: muTSPECTable.setStatus('current')
if mibBuilder.loadTexts: muTSPECTable.setDescription('Table of information for Admission Control Statistics by active client.')
muTSPECEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 6, 3, 1), ).setIndexNames((0, "HIPATH-WIRELESS-HWC-MIB", "apIndex"), (0, "HIPATH-WIRELESS-HWC-MIB", "muMACAddress"), (0, "HIPATH-WIRELESS-HWC-MIB", "tspecAC"), (0, "HIPATH-WIRELESS-HWC-MIB", "tspecDirection"))
if mibBuilder.loadTexts: muTSPECEntry.setStatus('current')
if mibBuilder.loadTexts: muTSPECEntry.setDescription('Information for Admission Control Statistics by active client.')
tspecMuMACAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 6, 3, 1, 1), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tspecMuMACAddress.setStatus('current')
if mibBuilder.loadTexts: tspecMuMACAddress.setDescription('Client MAC address.')
tspecAC = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 6, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("be", 0), ("bk", 1), ("vi", 2), ("vo", 3), ("tvo", 4), ("nwme", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tspecAC.setStatus('current')
if mibBuilder.loadTexts: tspecAC.setDescription('Access Category, such as Best Effort, Background, Voice, Video, and Reserved.')
tspecDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 6, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("uplink", 0), ("dnlink", 1), ("reserved", 2), ("bidir", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tspecDirection.setStatus('current')
if mibBuilder.loadTexts: tspecDirection.setDescription('Traffic direction, such as uplink direction, downlink direction.')
tspecApSerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 6, 3, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tspecApSerialNumber.setStatus('current')
if mibBuilder.loadTexts: tspecApSerialNumber.setDescription('16-character serial number of the AccessPoint.')
tspecMuIPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 6, 3, 1, 5), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tspecMuIPAddress.setStatus('current')
if mibBuilder.loadTexts: tspecMuIPAddress.setDescription('Client IP Address.')
tspecBssMac = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 6, 3, 1, 6), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tspecBssMac.setStatus('current')
if mibBuilder.loadTexts: tspecBssMac.setDescription('Access Point BSSID.')
tspecSsid = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 6, 3, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tspecSsid.setStatus('current')
if mibBuilder.loadTexts: tspecSsid.setDescription('VNS SSID.')
tspecMDR = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 6, 3, 1, 8), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tspecMDR.setStatus('current')
if mibBuilder.loadTexts: tspecMDR.setDescription('Mean Data Rate (bytes per second).')
tspecNMS = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 6, 3, 1, 9), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tspecNMS.setStatus('current')
if mibBuilder.loadTexts: tspecNMS.setDescription('Nominal MSDU size (bytes).')
tspecSBA = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 6, 3, 1, 10), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tspecSBA.setStatus('current')
if mibBuilder.loadTexts: tspecSBA.setDescription('Surplus Bandwidth Allowance.')
tspecDlRate = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 6, 3, 1, 11), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tspecDlRate.setStatus('current')
if mibBuilder.loadTexts: tspecDlRate.setDescription('Downlink Rate (bytes per second).')
tspecUlRate = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 6, 3, 1, 12), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tspecUlRate.setStatus('current')
if mibBuilder.loadTexts: tspecUlRate.setDescription('Uplink Rate (bytes per second).')
tspecDlViolations = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 6, 3, 1, 13), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tspecDlViolations.setStatus('current')
if mibBuilder.loadTexts: tspecDlViolations.setDescription('Downlink Violations (bytes per second).')
tspecUlViolations = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 6, 3, 1, 14), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tspecUlViolations.setStatus('current')
if mibBuilder.loadTexts: tspecUlViolations.setDescription('Uplink Violations (bytes per second).')
tspecProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 6, 3, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("proto80211a", 1), ("proto80211g", 2), ("proto80211b", 3), ("proto80211an", 4), ("proto80211bgn", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tspecProtocol.setStatus('current')
if mibBuilder.loadTexts: tspecProtocol.setDescription('802.11 radio protocol.')
muACLType = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 6, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("blacklist", 1), ("whitelist", 2))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: muACLType.setStatus('current')
if mibBuilder.loadTexts: muACLType.setDescription('MUs can access EWC by sending association request and providing proper credentials. However, EWC allows creation of a master list of a blacklist or a whitelist group to control such access. There can exist only a blacklist or a whitelist (mutually exclusive) at any time. The list of MUs belonging to such a list is populated in muACLTable. The muACLTable content can be interpreted in conjunction with this field as follows: - blacklist(1): MUs listed in muACLTable cannot access EWC resources. - whitelist(2): Only MUs listed in muACLTable can access EWC resources.')
muACLTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 6, 5), )
if mibBuilder.loadTexts: muACLTable.setStatus('current')
if mibBuilder.loadTexts: muACLTable.setDescription("Semantics of this list is directly related to muACLType. Access Control List(ACL) is list of MUs and their access rights. An MU can either belong to 'Blacklist', in that case its association request is denied, or it can belong to 'Whitelist', in that case it is allowed to associate to EWC provided having proper credentials.")
muACLEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 6, 5, 1), ).setIndexNames((0, "HIPATH-WIRELESS-HWC-MIB", "muACLMACAddress"))
if mibBuilder.loadTexts: muACLEntry.setStatus('current')
if mibBuilder.loadTexts: muACLEntry.setDescription('An entry about an MU and its ACL.')
muACLMACAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 6, 5, 1, 1), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: muACLMACAddress.setStatus('current')
if mibBuilder.loadTexts: muACLMACAddress.setDescription('MAC address of MU.')
muACLRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 6, 5, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: muACLRowStatus.setStatus('current')
if mibBuilder.loadTexts: muACLRowStatus.setDescription('An MU can either be added or removed to this list, therefore, allowed set values for this field are: createAndGo, destroy.')
muAccessListTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 6, 6), )
if mibBuilder.loadTexts: muAccessListTable.setStatus('current')
if mibBuilder.loadTexts: muAccessListTable.setDescription("Semantics of this list is directly related to muACLType. Access List Control(ACL) list of MUs and their access rights. An MU can either belong to 'Blacklist', in that case its association request is denied, or it can belong to 'Whitelist', in that case it is allowed to associate to EWC provided having proper credentials.")
muAccessListEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 6, 6, 1), ).setIndexNames((0, "HIPATH-WIRELESS-HWC-MIB", "muAccessListMACAddress"))
if mibBuilder.loadTexts: muAccessListEntry.setStatus('current')
if mibBuilder.loadTexts: muAccessListEntry.setDescription('An entry about about an MU and its ACL.')
muAccessListMACAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 6, 6, 1, 1), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: muAccessListMACAddress.setStatus('current')
if mibBuilder.loadTexts: muAccessListMACAddress.setDescription('MAC address of MU.')
muAccessListBitmaskLength = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 6, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(24, 36, 48))).clone(namedValues=NamedValues(("bits24", 24), ("bits36", 36), ("bits48", 48)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: muAccessListBitmaskLength.setStatus('current')
if mibBuilder.loadTexts: muAccessListBitmaskLength.setDescription('Length of bitmask associated to the MAC address in the entry.')
muAccessListRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 6, 6, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: muAccessListRowStatus.setStatus('current')
if mibBuilder.loadTexts: muAccessListRowStatus.setDescription('An MU can either be added or removed to this list, therefore, allowed set values for this field are: createAndGo, destroy.')
associations = MibIdentifier((1, 3, 6, 1, 4, 1, 4329, 15, 3, 7))
assocCount = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 7, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: assocCount.setStatus('current')
if mibBuilder.loadTexts: assocCount.setDescription('Total number of current client associations to the access point.')
assocTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 7, 2), )
if mibBuilder.loadTexts: assocTable.setStatus('current')
if mibBuilder.loadTexts: assocTable.setDescription('Table of information about clients associated with the access point.')
assocEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 7, 2, 1), ).setIndexNames((0, "HIPATH-WIRELESS-HWC-MIB", "assocMUMacAddress"), (0, "HIPATH-WIRELESS-HWC-MIB", "apIndex"), (0, "HIPATH-WIRELESS-HWC-MIB", "assocStartSysUpTime"))
if mibBuilder.loadTexts: assocEntry.setStatus('current')
if mibBuilder.loadTexts: assocEntry.setDescription('Information for a single client in the association table.')
assocMUMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 7, 2, 1, 1), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: assocMUMacAddress.setStatus('current')
if mibBuilder.loadTexts: assocMUMacAddress.setDescription('MAC address of the client.')
assocStartSysUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 7, 2, 1, 2), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: assocStartSysUpTime.setStatus('current')
if mibBuilder.loadTexts: assocStartSysUpTime.setDescription('The system uptime that client became associated with the access point.')
assocTxPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 7, 2, 1, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: assocTxPackets.setStatus('current')
if mibBuilder.loadTexts: assocTxPackets.setDescription('Nubmer of tx packets to the client.')
assocRxPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 7, 2, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: assocRxPackets.setStatus('current')
if mibBuilder.loadTexts: assocRxPackets.setDescription('Number of received packets from the client.')
assocTxOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 7, 2, 1, 5), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: assocTxOctets.setStatus('current')
if mibBuilder.loadTexts: assocTxOctets.setDescription('Number of octets sent to the client.')
assocRxOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 7, 2, 1, 6), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: assocRxOctets.setStatus('current')
if mibBuilder.loadTexts: assocRxOctets.setDescription('Number of octets received from the client.')
assocDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 7, 2, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: assocDuration.setStatus('current')
if mibBuilder.loadTexts: assocDuration.setDescription('Length of time since last association.')
assocVnsIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 7, 2, 1, 8), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: assocVnsIfIndex.setStatus('current')
if mibBuilder.loadTexts: assocVnsIfIndex.setDescription('Index of VNS to which the MU is associated with.')
protocols = MibIdentifier((1, 3, 6, 1, 4, 1, 4329, 15, 3, 8))
wassp = MibIdentifier((1, 3, 6, 1, 4, 1, 4329, 15, 3, 8, 1))
logNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 4329, 15, 3, 9))
logEventSeverityThreshold = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 9, 1), LogEventSeverity()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: logEventSeverityThreshold.setStatus('current')
if mibBuilder.loadTexts: logEventSeverityThreshold.setDescription("Specifies the minimum level at which the SNMP agent will send notifications for log events. I.e., setting this value to 'major' will send notifcations for critical and major log events. Setting the threshold to minor will trap critical, major, and minor events.")
logEventSeverity = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 9, 3), LogEventSeverity()).setMaxAccess("readonly")
if mibBuilder.loadTexts: logEventSeverity.setStatus('current')
if mibBuilder.loadTexts: logEventSeverity.setDescription('Contains the severity of the most recently trapped hiPathWirelessLogAlarm notification.')
logEventComponent = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 9, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: logEventComponent.setStatus('current')
if mibBuilder.loadTexts: logEventComponent.setDescription('Contains the component which sent the most recently trapped hiPathWirelessLogAlarm notification.')
logEventDescription = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 9, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: logEventDescription.setStatus('current')
if mibBuilder.loadTexts: logEventDescription.setDescription('Contains the description of the most recently trapped hiPathWirelessLogAlarm.')
hiPathWirelessLogAlarm = NotificationType((1, 3, 6, 1, 4, 1, 4329, 15, 3, 9, 6)).setObjects(("HIPATH-WIRELESS-HWC-MIB", "logEventSeverity"), ("HIPATH-WIRELESS-HWC-MIB", "logEventComponent"), ("HIPATH-WIRELESS-HWC-MIB", "logEventDescription"))
if mibBuilder.loadTexts: hiPathWirelessLogAlarm.setStatus('current')
if mibBuilder.loadTexts: hiPathWirelessLogAlarm.setDescription('Components of an alarm.')
sites = MibIdentifier((1, 3, 6, 1, 4, 1, 4329, 15, 3, 10))
siteMaxEntries = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 10, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: siteMaxEntries.setStatus('current')
if mibBuilder.loadTexts: siteMaxEntries.setDescription('The maximum number of entries allowed in the siteTable. This value is platform dependent.')
siteNumEntries = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 10, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: siteNumEntries.setStatus('current')
if mibBuilder.loadTexts: siteNumEntries.setDescription('The current number of entries in the siteTable.')
siteTableNextAvailableIndex = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 10, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: siteTableNextAvailableIndex.setStatus('current')
if mibBuilder.loadTexts: siteTableNextAvailableIndex.setDescription('This object indicates the numerically lowest available index within this entity, which may be used for the value of siteID in the creation of a new entry in the siteTable. An index is considered available if the index value falls within the range of 1 to siteMaxEntries value and is not being used to index an existing entry in the siteTable contained within this entity. This value should only be considered a guideline for management creation of siteEntries, there is no requirement on management to create entries based upon this index value.')
siteTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 10, 4), )
if mibBuilder.loadTexts: siteTable.setStatus('current')
if mibBuilder.loadTexts: siteTable.setDescription('A site is a logical entity that is constituted by collection of APs, CoS rules, policies, Radius server, WLAN, etc. A site is identified by a unique name. ')
siteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 10, 4, 1), ).setIndexNames((0, "HIPATH-WIRELESS-HWC-MIB", "siteID"))
if mibBuilder.loadTexts: siteEntry.setStatus('current')
if mibBuilder.loadTexts: siteEntry.setDescription('Definition of a site.')
siteID = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 10, 4, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: siteID.setStatus('current')
if mibBuilder.loadTexts: siteID.setDescription('An unique ID, identifying the site in the context of the controller. The site ID can be an integer value from 1 to the maximum number of APs supported by the EWC.')
siteRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 10, 4, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: siteRowStatus.setStatus('current')
if mibBuilder.loadTexts: siteRowStatus.setDescription('Row status for the entry.')
siteName = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 10, 4, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 64))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: siteName.setStatus('current')
if mibBuilder.loadTexts: siteName.setDescription('Textual description to identify the site in the context of the controller.')
siteLocalRadiusAuthentication = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 10, 4, 1, 4), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: siteLocalRadiusAuthentication.setStatus('current')
if mibBuilder.loadTexts: siteLocalRadiusAuthentication.setDescription('If this value is set to true, then the RADIUS client is on APs, otherwise the RADIUS client is on controller.')
siteDefaultDNSServer = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 10, 4, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: siteDefaultDNSServer.setStatus('current')
if mibBuilder.loadTexts: siteDefaultDNSServer.setDescription('If the APs associated to the site uses DHCP, and DHCP server does not assign DNS server, then this entry will be used for that purpose. Otherwise, if AP is configured with static IP address, then this entry will be used for that purpose.')
siteEnableSecureTunnel = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 10, 4, 1, 6), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: siteEnableSecureTunnel.setStatus('current')
if mibBuilder.loadTexts: siteEnableSecureTunnel.setDescription('If set to true secure communication key sent to APs to be used to encrypt the traffic between APs within the site and the traffic between controller and APs. However, the encryption itself does not take place unless siteEncryptCommAPtoController and/or siteEncryptCommBetweenAPs set to true.')
siteEncryptCommAPtoController = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 10, 4, 1, 7), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: siteEncryptCommAPtoController.setStatus('current')
if mibBuilder.loadTexts: siteEncryptCommAPtoController.setDescription('If set to true, communication between APs within the site and the controller are encrypted using defined encyption. For details about encryption type, please refer to user manual.')
siteEncryptCommBetweenAPs = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 10, 4, 1, 8), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: siteEncryptCommBetweenAPs.setStatus('current')
if mibBuilder.loadTexts: siteEncryptCommBetweenAPs.setDescription('If set to true, communication between APs within the site are encrypted using defined encyption. For details about encryption type, please refer to user manual.')
siteBandPreferenceEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 10, 4, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: siteBandPreferenceEnable.setStatus('current')
if mibBuilder.loadTexts: siteBandPreferenceEnable.setDescription('Enabling/disabling band preference for the site and associated APs. By enabling band preference 11a-capable clients can be moved to 11a radio and relieve the congestion on the 11g radio. Band preference provides radio load balancing between 11g and 11a radios.')
siteLoadControlEnableR1 = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 10, 4, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: siteLoadControlEnableR1.setStatus('current')
if mibBuilder.loadTexts: siteLoadControlEnableR1.setDescription('Enabling/disabling load control for the site for this radio. Load control manages the number of clients on the Radio #1 by disallowing additional clients on the radio above the configured radio limit.')
siteLoadControlEnableR2 = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 10, 4, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: siteLoadControlEnableR2.setStatus('current')
if mibBuilder.loadTexts: siteLoadControlEnableR2.setDescription('Enabling/disabling load control for the site for this radio. Load control manages the number of clients on the Radio #2 by disallowing additional clients on the radio above the configured radio limit.')
siteMaxClientR1 = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 10, 4, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 99))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: siteMaxClientR1.setStatus('current')
if mibBuilder.loadTexts: siteMaxClientR1.setDescription('Maximum number of clients that are allowed to be associated to this radio (radio #1). If the Load Control is not enabled then the maximum for this radio uses default value.')
siteMaxClientR2 = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 10, 4, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 99))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: siteMaxClientR2.setStatus('current')
if mibBuilder.loadTexts: siteMaxClientR2.setDescription('Maximum number of clients that are allowed to be associated to this radio (radio #2). If the Load Control is not enabled then the maximum for this radio uses default value.')
siteStrictLimitEnableR1 = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 10, 4, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: siteStrictLimitEnableR1.setStatus('current')
if mibBuilder.loadTexts: siteStrictLimitEnableR1.setDescription('Enabling/disabling strict limit of load control for this radio that is assigned to the site. Eanbleing strict limit enforces configured client limit for the radio (radio #1) in any circumstances. Otherwise if this field is disabled then the restriction may not be enforced in all circumstances.')
siteStrictLimitEnableR2 = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 10, 4, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: siteStrictLimitEnableR2.setStatus('current')
if mibBuilder.loadTexts: siteStrictLimitEnableR2.setDescription('Enabling/disabling strict limit of load control for this radio that is assigned to the site. Eanbleing strict limit enforces configured client limit for the radio (radio #2) in any circumstances. Otherwise if this field is disabled then the restriction may not be enforced in all circumstances.')
siteReplaceStnIDwithSiteName = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 10, 4, 1, 16), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: siteReplaceStnIDwithSiteName.setStatus('current')
if mibBuilder.loadTexts: siteReplaceStnIDwithSiteName.setDescription('If this value is set to true, then the called station ID will be replaced with the site name.')
sitePolicyTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 10, 5), )
if mibBuilder.loadTexts: sitePolicyTable.setStatus('current')
if mibBuilder.loadTexts: sitePolicyTable.setDescription('Each site can have zero or more policies assigned to it. All policies associated to a site are pushed to the all APs belonging to the site. This table defines the assignment of various policies to various sites.')
sitePolicyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 10, 5, 1), ).setIndexNames((0, "HIPATH-WIRELESS-HWC-MIB", "siteID"), (0, "HIPATH-WIRELESS-HWC-MIB", "sitePolicyID"))
if mibBuilder.loadTexts: sitePolicyEntry.setStatus('current')
if mibBuilder.loadTexts: sitePolicyEntry.setDescription('An entry defining assignment of a policy, identified by sitePolicyID, to a site, identified by siteID.')
sitePolicyID = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 10, 5, 1, 1), Unsigned32())
if mibBuilder.loadTexts: sitePolicyID.setStatus('current')
if mibBuilder.loadTexts: sitePolicyID.setDescription('The policy index, as defined ENTERASYS-POLICY-PROFILE-MIB::etsysPolicyProfileIndex.')
sitePolicyMember = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 10, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("notMember", 0), ("isMember", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sitePolicyMember.setStatus('current')
if mibBuilder.loadTexts: sitePolicyMember.setDescription('Indicates whether the policy associated with this row is a member of the zone identified by zoneID.')
siteCosTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 10, 6), )
if mibBuilder.loadTexts: siteCosTable.setStatus('current')
if mibBuilder.loadTexts: siteCosTable.setDescription('Each site can have zero or more CoS assigned to it. All CoS associated to a site are pushed to the all APs belonging to the site. This table defines the assignment of various CoS to various sites.')
siteCosEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 10, 6, 1), ).setIndexNames((0, "HIPATH-WIRELESS-HWC-MIB", "siteID"), (0, "HIPATH-WIRELESS-HWC-MIB", "siteCoSID"))
if mibBuilder.loadTexts: siteCosEntry.setStatus('current')
if mibBuilder.loadTexts: siteCosEntry.setDescription('An entry defining assignment of a CoS, identified by siteCoSID, to a site, identified by siteID.')
siteCoSID = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 10, 6, 1, 1), Unsigned32())
if mibBuilder.loadTexts: siteCoSID.setStatus('current')
if mibBuilder.loadTexts: siteCoSID.setDescription('The CoS index, as defined in ENTERASYS-POLICY-PROFILE-MIB::etsysCosIndex.')
siteCoSMember = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 10, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("notMember", 0), ("isMember", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: siteCoSMember.setStatus('current')
if mibBuilder.loadTexts: siteCoSMember.setDescription('Indicates whether the CoS associated with this row is a member of the site identified by siteID.')
siteAPTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 10, 7), )
if mibBuilder.loadTexts: siteAPTable.setStatus('current')
if mibBuilder.loadTexts: siteAPTable.setDescription('A site can have zero or more Access Points(AP) assigned to it. This table defines the assignment of various APs to various sites.')
siteAPEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 10, 7, 1), ).setIndexNames((0, "HIPATH-WIRELESS-HWC-MIB", "siteID"), (0, "HIPATH-WIRELESS-HWC-MIB", "apIndex"))
if mibBuilder.loadTexts: siteAPEntry.setStatus('current')
if mibBuilder.loadTexts: siteAPEntry.setDescription('An entry defining assignment of an AP, identified by apIndex, to a site, identified by siteID.')
siteAPMember = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 10, 7, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("notMember", 0), ("isMember", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: siteAPMember.setStatus('current')
if mibBuilder.loadTexts: siteAPMember.setDescription('Indicates whether the AP associated with this row is a member of the site identified by siteID.')
siteWlanTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 10, 8), )
if mibBuilder.loadTexts: siteWlanTable.setStatus('current')
if mibBuilder.loadTexts: siteWlanTable.setDescription('A site can have zero or more WLAN assigned to it. All WLANs that are associated with a site are pushed to the all APs belonging to the site. This table defines the assignment of various WLANs to various sites.')
siteWlanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 10, 8, 1), ).setIndexNames((0, "HIPATH-WIRELESS-HWC-MIB", "siteID"), (0, "HIPATH-WIRELESS-HWC-MIB", "wlanID"), (0, "HIPATH-WIRELESS-HWC-MIB", "siteWlanApRadioIndex"))
if mibBuilder.loadTexts: siteWlanEntry.setStatus('current')
if mibBuilder.loadTexts: siteWlanEntry.setDescription('An entry defining assignment of a WLAN identified by siteWlanID, to a site, identified by siteID.')
siteWlanApRadioIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 10, 8, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2)))
if mibBuilder.loadTexts: siteWlanApRadioIndex.setStatus('current')
if mibBuilder.loadTexts: siteWlanApRadioIndex.setDescription('Description.')
siteWlanApRadioAssigned = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 10, 8, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("notAssigned", 0), ("assigned", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: siteWlanApRadioAssigned.setStatus('current')
if mibBuilder.loadTexts: siteWlanApRadioAssigned.setDescription('Description.')
widsWips = MibIdentifier((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11))
mitigatorAnalysisEngine = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mitigatorAnalysisEngine.setStatus('current')
if mibBuilder.loadTexts: mitigatorAnalysisEngine.setDescription('Mitigator analysis engine can be enabled/disabled using this variable. All mitigator related objects, objects defined in widsWips subtree, can only be accessed using SNMPv3 provided this variable is set to enable(1) on behalf of users with privacy.')
scanGroupMaxEntries = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: scanGroupMaxEntries.setStatus('current')
if mibBuilder.loadTexts: scanGroupMaxEntries.setDescription('Maximum number of scan groups that can be created on the device.')
scanGroupsCurrentEntries = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: scanGroupsCurrentEntries.setStatus('current')
if mibBuilder.loadTexts: scanGroupsCurrentEntries.setDescription('Number of scan groups currently have been created on the device.')
activeThreatsCounts = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: activeThreatsCounts.setStatus('current')
if mibBuilder.loadTexts: activeThreatsCounts.setDescription('Number of currently active threats that have been detected.')
friendlyAPCounts = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: friendlyAPCounts.setStatus('current')
if mibBuilder.loadTexts: friendlyAPCounts.setDescription('Number of friendly access points that have been discovered at this point.')
uncategorizedAPCounts = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 6), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: uncategorizedAPCounts.setStatus('current')
if mibBuilder.loadTexts: uncategorizedAPCounts.setDescription('Number of uncategorized access points that have been discovered. This value refers to current number not the historical value.')
widsWipsEngineTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 11), )
if mibBuilder.loadTexts: widsWipsEngineTable.setStatus('current')
if mibBuilder.loadTexts: widsWipsEngineTable.setDescription('Table of Mitigators defined on set of controllers each identified by widsWipsEngineControllerIPAddress. ')
widsWipsEngineEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 11, 1), ).setIndexNames((0, "HIPATH-WIRELESS-HWC-MIB", "widsWipsEngineControllerIPAddress"))
if mibBuilder.loadTexts: widsWipsEngineEntry.setStatus('current')
if mibBuilder.loadTexts: widsWipsEngineEntry.setDescription('One entry in this table identifying a mitigator engine in a defined controller identified by IP address, widsWipsEngineControllerIPAddress.')
widsWipsEngineRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 11, 1, 1), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: widsWipsEngineRowStatus.setStatus('current')
if mibBuilder.loadTexts: widsWipsEngineRowStatus.setDescription('RowStatus for creation/deletion of mitigator engine row.')
widsWipsEngineControllerIPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 11, 1, 2), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: widsWipsEngineControllerIPAddress.setStatus('current')
if mibBuilder.loadTexts: widsWipsEngineControllerIPAddress.setDescription('Ip address of the controller that the defined mitigator in this row will run on.')
widsWipsEnginePollInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 11, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(3, 60))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: widsWipsEnginePollInterval.setStatus('current')
if mibBuilder.loadTexts: widsWipsEnginePollInterval.setDescription('Poll interval in seconds between successive keep alive messages between this controller and the mitigator engine to monitor status of mitigator engine. ')
widsWipsEnginePollRetry = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 11, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 20))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: widsWipsEnginePollRetry.setStatus('current')
if mibBuilder.loadTexts: widsWipsEnginePollRetry.setDescription('Number of consecutive retries of failed contact to a mitigator agent before declaring mitigator engine dead. ')
inServiceScanGroupTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 12), )
if mibBuilder.loadTexts: inServiceScanGroupTable.setStatus('current')
if mibBuilder.loadTexts: inServiceScanGroupTable.setDescription('In service scan group enables the subsystem simultaneously scan for threats and performs wireless bridging based on 37xx-based APs. The threats are discovered and identified in the deployment environment and then classified for further actions. ')
inServiceScanGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 12, 1), ).setIndexNames((0, "HIPATH-WIRELESS-HWC-MIB", "scanGroupProfileID"))
if mibBuilder.loadTexts: inServiceScanGroupEntry.setStatus('current')
if mibBuilder.loadTexts: inServiceScanGroupEntry.setDescription('An entry in this table that defines attributes of a in-service scan group.')
scanGroupProfileID = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 12, 1, 1), Unsigned32())
if mibBuilder.loadTexts: scanGroupProfileID.setStatus('current')
if mibBuilder.loadTexts: scanGroupProfileID.setDescription('A internally unique identifier for a scan group. Each scan group is indexed by this value.')
inSrvScanGrpName = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 12, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: inSrvScanGrpName.setStatus('current')
if mibBuilder.loadTexts: inSrvScanGrpName.setDescription('Textual description identifying the scan group.')
inSrvScanGrpSecurityThreats = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: inSrvScanGrpSecurityThreats.setStatus('current')
if mibBuilder.loadTexts: inSrvScanGrpSecurityThreats.setDescription('Enable/disable security engine to scan for threats.')
inSrvScanGrpMaxConcurrentAttacksPerAP = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 12, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 6))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: inSrvScanGrpMaxConcurrentAttacksPerAP.setStatus('current')
if mibBuilder.loadTexts: inSrvScanGrpMaxConcurrentAttacksPerAP.setDescription('Max number of concurrent attacks per AP')
inSrvScanGrpCounterMeasuresType = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 12, 1, 5), Bits().clone(namedValues=NamedValues(("externalHoneypotAPs", 0), ("roamingToFriendlyAPs", 1), ("internalHoneypotAPs", 2), ("spoofedAPs", 3), ("dropFloodAttack", 4), ("removeDosAttack", 5), ("adHocModeDevice", 6), ("rogueAP", 7)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: inSrvScanGrpCounterMeasuresType.setStatus('current')
if mibBuilder.loadTexts: inSrvScanGrpCounterMeasuresType.setDescription('bit 0: Setting this bit prevents authorized stations from roaming to external honeypot APs. bit 1: Setting this bit prevents authorized stations from roaming to friendly APs. bit 2: Setting this bit prevents any station from using an internal honeypot AP. bit 3: Setting this bit prevents any station from using a spoofed AP. bit 4: Setting this bit drops frames in a controlled fashion during a flood attack. bit 5: Setting this bit removes network access from clients originating DoS attacks. bit 6: Setting this bit prevents any station from using an ad hoc mode device. bit 7: Setting this bit prevents any station from using a rogue AP.')
inSrvScanGrpScan2400MHzSelection = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 12, 1, 6), Bits().clone(namedValues=NamedValues(("frequency2412MHz", 0), ("frequency2417MHz", 1), ("frequency2422MHz", 2), ("frequency2427MHz", 3), ("frequency2432MHz", 4), ("frequency2437MHz", 5), ("frequency2442MHz", 6), ("frequency2447MHz", 7), ("frequency2452MHz", 8), ("frequency2457MHz", 9), ("frequency2462MHz", 10), ("frequency2467MHz", 11), ("frequency2472MHz", 12), ("frequency2484MHz", 13)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: inSrvScanGrpScan2400MHzSelection.setStatus('current')
if mibBuilder.loadTexts: inSrvScanGrpScan2400MHzSelection.setDescription('bit 0: by setting this bit scanning is performed on 2412 MHz frequency channel bit 1: by setting this bit scanning is performed on 2417 MHz frequency channel bit 2: by setting this bit scanning is performed on 2422 MHz frequency channel bit 3: by setting this bit scanning is performed on 2427 MHz frequency channel bit 4: by setting this bit scanning is performed on 2432 MHz frequency channel bit 5: by setting this bit scanning is performed on 2437 MHz frequency channel bit 6: by setting this bit scanning is performed on 2442 MHz frequency channel bit 7: by setting this bit scanning is performed on 2447 MHz frequency channel bit 8: by setting this bit scanning is performed on 2452 MHz frequency channel bit 9: by setting this bit scanning is performed on 2457 MHz frequency channel bit 10: by setting this bit scanning is performed on 2462 MHz frequency channel bit 11: by setting this bit scanning is performed on 2467 MHz frequency channel bit 12: by setting this bit scanning is performed on 2472 MHz frequency channel bit 13: by setting this bit scanning is performed on 2484 MHz frequency channel')
inSrvScanGrpScan5GHzSelection = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 12, 1, 7), Bits().clone(namedValues=NamedValues(("frequency5040MHz", 0), ("frequency5060MHz", 1), ("frequency5080MHz", 2), ("frequency5180MHz", 3), ("frequency5200MHz", 4), ("frequency5220MHz", 5), ("frequency5240MHz", 6), ("frequency5260MHz", 7), ("frequency5280MHz", 8), ("frequency5300MHz", 9), ("frequency5320MHz", 10), ("frequency5500MHz", 11), ("frequency5520MHz", 12), ("frequency5540MHz", 13), ("frequency5560MHz", 14), ("frequency5580MHz", 15), ("frequency5600MHz", 16), ("frequency5620MHz", 17), ("frequency5640MHz", 18), ("frequency5660MHz", 19), ("frequency5680MHz", 20), ("frequency5700MHz", 21), ("frequency5745MHz", 22), ("frequency5765MHz", 23), ("frequency5785MHz", 24), ("frequency5805MHz", 25), ("frequency5825MHz", 26), ("frequency4920MHz", 27), ("frequency4940MHz", 28), ("frequency4960MHz", 29), ("frequency4980MHz", 30)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: inSrvScanGrpScan5GHzSelection.setStatus('current')
if mibBuilder.loadTexts: inSrvScanGrpScan5GHzSelection.setDescription('bit 0: by setting this bit scanning is performed on 5040 MHz frequency channel bit 1: by setting this bit scanning is performed on 5060 MHz frequency channel bit 2: by setting this bit scanning is performed on 5080 MHz frequency channel bit 3: by setting this bit scanning is performed on 5180 MHz frequency channel bit 4: by setting this bit scanning is performed on 5200 MHz frequency channel bit 5: by setting this bit scanning is performed on 5220 MHz frequency channel bit 6: by setting this bit scanning is performed on 5240 MHz frequency channel bit 7: by setting this bit scanning is performed on 5260 MHz frequency channel bit 8: by setting this bit scanning is performed on 5280 MHz frequency channel bit 9: by setting this bit scanning is performed on 5300 MHz frequency channel bit 10: by setting this bit scanning is performed on 5320 MHz frequency channel bit 11: by setting this bit scanning is performed on 5500 MHz frequency channel bit 12: by setting this bit scanning is performed on 5520 MHz frequency channel bit 13: by setting this bit scanning is performed on 5540 MHz frequency channel bit 14: by setting this bit scanning is performed on 5560 MHz frequency channel bit 15: by setting this bit scanning is performed on 5580 MHz frequency channel bit 16: by setting this bit scanning is performed on 5600 MHz frequency channel bit 17: by setting this bit scanning is performed on 5620 MHz frequency channel bit 18: by setting this bit scanning is performed on 5640 MHz frequency channel bit 19: by setting this bit scanning is performed on 5660 MHz frequency channel bit 20: by setting this bit scanning is performed on 5680 MHz frequency channel bit 21: by setting this bit scanning is performed on 5700 MHz frequency channel bit 22: by setting this bit scanning is performed on 5745 MHz frequency channel bit 23: by setting this bit scanning is performed on 5765 MHz frequency channel bit 24: by setting this bit scanning is performed on 5785 MHz frequency channel bit 25: by setting this bit scanning is performed on 5805 MHz frequency channel bit 26: by setting this bit scanning is performed on 5825 MHz frequency channel bit 27: by setting this bit scanning is performed on 4920 MHz frequency channel bit 28: by setting this bit scanning is performed on 4940 MHz frequency channel bit 29: by setting this bit scanning is performed on 4960 MHz frequency channel bit 30: by setting this bit scanning is performed on 4980 MHz frequency channel')
inSrvScanGrpblockAdHocClientsPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 12, 1, 8), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: inSrvScanGrpblockAdHocClientsPeriod.setStatus('current')
if mibBuilder.loadTexts: inSrvScanGrpblockAdHocClientsPeriod.setDescription('Number of seconds removing network access to the clients that are in ad hoc mode.')
inSrvScanGrpClassifySourceIF = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 12, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: inSrvScanGrpClassifySourceIF.setStatus('current')
if mibBuilder.loadTexts: inSrvScanGrpClassifySourceIF.setDescription('This variable allows to enable/disable classify sources of interference')
inSrvScanGrpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 12, 1, 10), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: inSrvScanGrpRowStatus.setStatus('current')
if mibBuilder.loadTexts: inSrvScanGrpRowStatus.setDescription('RowStatus field for creation/deletion or changing row status.')
inSrvScanGrpDetectRogueAP = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 12, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: inSrvScanGrpDetectRogueAP.setStatus('current')
if mibBuilder.loadTexts: inSrvScanGrpDetectRogueAP.setDescription('This enables/disables rogue AP detection.')
inSrvScanGrpListeningPort = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 12, 1, 12), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: inSrvScanGrpListeningPort.setStatus('current')
if mibBuilder.loadTexts: inSrvScanGrpListeningPort.setDescription('This OID represents the UDP port number that APs are to listen on while performing rogue AP detection. It has meaning only when inSrvScanGrpDetectRogueAP is enabled.')
outOfServiceScanGroupTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 13), )
if mibBuilder.loadTexts: outOfServiceScanGroupTable.setStatus('current')
if mibBuilder.loadTexts: outOfServiceScanGroupTable.setDescription('Out of service scan group is used to collect and classify various wireless identifiers that are discovered in the deployment environment. Legacy APs (26xx-based, 36xx-based) can participate in this subsystem if they are configured for out-of-service scanning. The new APs, based on 37xx architecture, can also participate in this subsystem.')
outOfServiceScanGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 13, 1), ).setIndexNames((0, "HIPATH-WIRELESS-HWC-MIB", "scanGroupProfileID"))
if mibBuilder.loadTexts: outOfServiceScanGroupEntry.setStatus('current')
if mibBuilder.loadTexts: outOfServiceScanGroupEntry.setDescription('An entry in this table that defines attributes of a out-of-service scan group.')
outOfSrvScanGrpName = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 13, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: outOfSrvScanGrpName.setStatus('current')
if mibBuilder.loadTexts: outOfSrvScanGrpName.setDescription('Human readable textual description identifying scan group.')
outOfSrvScanGrpRadio = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 13, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("radio1", 1), ("radio2", 2), ("both", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: outOfSrvScanGrpRadio.setStatus('current')
if mibBuilder.loadTexts: outOfSrvScanGrpRadio.setDescription('Radio selection for the scan group. Selected radio will be used in sacn group.')
outOfSrvScanGrpChannelList = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 13, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 999))).clone(namedValues=NamedValues(("allChannel", 0), ("currentChannel", 999)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: outOfSrvScanGrpChannelList.setStatus('current')
if mibBuilder.loadTexts: outOfSrvScanGrpChannelList.setDescription('Identifying the channel(s) which will be used for the defined scan group.')
outOfSrvScanGrpScanType = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 13, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("active", 0), ("passive", 1)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: outOfSrvScanGrpScanType.setStatus('current')
if mibBuilder.loadTexts: outOfSrvScanGrpScanType.setDescription('This field allows to select the type of scanning, active/passive, this scan group will be executing.')
outOfSrvScanGrpChannelDwellTime = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 13, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(200, 500))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: outOfSrvScanGrpChannelDwellTime.setStatus('current')
if mibBuilder.loadTexts: outOfSrvScanGrpChannelDwellTime.setDescription('Dwell time in mili-second for performing scanning.')
outOfSrvScanGrpScanTimeInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 13, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 120))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: outOfSrvScanGrpScanTimeInterval.setStatus('current')
if mibBuilder.loadTexts: outOfSrvScanGrpScanTimeInterval.setDescription('Time interval between two sucssive scanning performed for this scan group.')
outOfSrvScanGrpSecurityScan = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 13, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: outOfSrvScanGrpSecurityScan.setStatus('current')
if mibBuilder.loadTexts: outOfSrvScanGrpSecurityScan.setDescription('This field allows to enable/disable security Scan.')
outOfSrvScanGrpScanActivity = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 13, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("stop", 0), ("start", 1)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: outOfSrvScanGrpScanActivity.setStatus('current')
if mibBuilder.loadTexts: outOfSrvScanGrpScanActivity.setDescription('Scaning can be started or stopped using this field.')
outOfSrvScanGrpScanRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 13, 1, 9), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: outOfSrvScanGrpScanRowStatus.setStatus('current')
if mibBuilder.loadTexts: outOfSrvScanGrpScanRowStatus.setDescription('RowStatus field for the entry.')
scanGroupAPAssignmentTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 14), )
if mibBuilder.loadTexts: scanGroupAPAssignmentTable.setStatus('current')
if mibBuilder.loadTexts: scanGroupAPAssignmentTable.setDescription('The list of APs that have been assigned to a particular scan group, which could include in-service and out-of-service scanning groups.')
scanGroupAPAssignmentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 14, 1), ).setIndexNames((0, "HIPATH-WIRELESS-HWC-MIB", "scanGroupProfileID"), (0, "HIPATH-WIRELESS-HWC-MIB", "scanGroupAPAssignApSerial"), (0, "HIPATH-WIRELESS-HWC-MIB", "widsWipsEngineControllerIPAddress"))
if mibBuilder.loadTexts: scanGroupAPAssignmentEntry.setStatus('current')
if mibBuilder.loadTexts: scanGroupAPAssignmentEntry.setDescription('An entry in this table defining an AP assignment to a group, identified by scanGroupProfileID.')
scanGroupAPAssignApSerial = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 14, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readonly")
if mibBuilder.loadTexts: scanGroupAPAssignApSerial.setStatus('current')
if mibBuilder.loadTexts: scanGroupAPAssignApSerial.setDescription('Unique string of characters, a 16-character long, serial number of an access point.')
scanGroupAPAssignGroupName = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 14, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: scanGroupAPAssignGroupName.setStatus('current')
if mibBuilder.loadTexts: scanGroupAPAssignGroupName.setDescription('Human readable textual description identifying scan group.')
scanGroupAPAssignName = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 14, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: scanGroupAPAssignName.setStatus('current')
if mibBuilder.loadTexts: scanGroupAPAssignName.setDescription('Access Point (AP) name associated to this scan group.')
scanGroupAPAssignRadio1 = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 14, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 8, 16, 18, 19, 20, 32, 34, 35, 36))).clone(namedValues=NamedValues(("off", 0), ("b", 1), ("g", 2), ("bg", 3), ("a", 4), ("j", 8), ("n", 16), ("gn", 18), ("bgn", 19), ("an", 20), ("nStrict", 32), ("gnStrict", 34), ("bgnStrict", 35), ("anStrict", 36)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: scanGroupAPAssignRadio1.setStatus('current')
if mibBuilder.loadTexts: scanGroupAPAssignRadio1.setDescription('This field allows the radio #1 of the AP to be turned on/off. this field has meaning only the AP assigned to legacy (outOfScan) scan profile')
scanGroupAPAssignRadio2 = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 14, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 8, 16, 18, 19, 20, 32, 34, 35, 36))).clone(namedValues=NamedValues(("off", 0), ("b", 1), ("g", 2), ("bg", 3), ("a", 4), ("j", 8), ("n", 16), ("gn", 18), ("bgn", 19), ("an", 20), ("nStrict", 32), ("gnStrict", 34), ("bgnStrict", 35), ("anStrict", 36)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: scanGroupAPAssignRadio2.setStatus('current')
if mibBuilder.loadTexts: scanGroupAPAssignRadio2.setDescription('This field allows the radio #2 of the AP to be turned on/off. this field has meaning only the AP assigned to legacy (outOfScan) scan profile')
scanGroupAPAssignInactiveAP = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 14, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("inactive", 0), ("active", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: scanGroupAPAssignInactiveAP.setStatus('current')
if mibBuilder.loadTexts: scanGroupAPAssignInactiveAP.setDescription('This field allows to set the AP as active/inactive in scanning activities.')
scanGroupAPAssignAllowScanning = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 14, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("notAllow", 0), ("allow", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: scanGroupAPAssignAllowScanning.setStatus('current')
if mibBuilder.loadTexts: scanGroupAPAssignAllowScanning.setDescription('Setting scanning to active/inactive using this AP.')
scanGroupAPAssignAllowSpectrumAnalysis = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 14, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("notAllow", 0), ("allow", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: scanGroupAPAssignAllowSpectrumAnalysis.setStatus('current')
if mibBuilder.loadTexts: scanGroupAPAssignAllowSpectrumAnalysis.setDescription('Setting spectrum analysis to active/inactive using this AP.')
scanGroupAPAssignControllerIPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 14, 1, 9), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: scanGroupAPAssignControllerIPAddress.setStatus('current')
if mibBuilder.loadTexts: scanGroupAPAssignControllerIPAddress.setDescription('The IP address of the controller to which the AP is connected currently.')
scanGroupAPAssignFordwardingService = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 14, 1, 10), Bits().clone(namedValues=NamedValues(("assignedToSite", 0), ("assignedToLoadGroup", 1), ("assignedToWlanService", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: scanGroupAPAssignFordwardingService.setStatus('current')
if mibBuilder.loadTexts: scanGroupAPAssignFordwardingService.setDescription('This OID lists the types of forwarding services that each Guardian is assigned to. A Guardian will revert to providing these services when it is removed from the Guardian role. The meanings of the individual flags are: bit 0: Set if this AP is a member of a site. bit 1: Set if this AP is assigned to a load group. bit 2: Set if this AP is assigned to at least one WLAN service. This OID is only relevant to APs in the Guardian role.')
scanAPTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 15), )
if mibBuilder.loadTexts: scanAPTable.setStatus('current')
if mibBuilder.loadTexts: scanAPTable.setDescription('Table of sacn APs on each collector. This table can be viewed only in v3 mode when the mitigator analys engine is enabled.')
scanAPEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 15, 1), ).setIndexNames((0, "HIPATH-WIRELESS-HWC-MIB", "scanAPControllerIPAddress"), (0, "HIPATH-WIRELESS-HWC-MIB", "scanAPSerialNumber"))
if mibBuilder.loadTexts: scanAPEntry.setStatus('current')
if mibBuilder.loadTexts: scanAPEntry.setDescription('An entry in this table identifying one access point.')
scanAPControllerIPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 15, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: scanAPControllerIPAddress.setStatus('current')
if mibBuilder.loadTexts: scanAPControllerIPAddress.setDescription('IP address of the controller on which the scanning executed.')
scanAPSerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 15, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readonly")
if mibBuilder.loadTexts: scanAPSerialNumber.setStatus('current')
if mibBuilder.loadTexts: scanAPSerialNumber.setDescription('Serial number of the access point, 16-character human readable text, that is assigned to this group.')
scanAPAcessPointName = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 15, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: scanAPAcessPointName.setStatus('current')
if mibBuilder.loadTexts: scanAPAcessPointName.setDescription('Name of the access point belonging to this group.')
scanAPRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 15, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: scanAPRowStatus.setStatus('current')
if mibBuilder.loadTexts: scanAPRowStatus.setDescription('Row status for the entry.')
scanAPProfileName = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 15, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: scanAPProfileName.setStatus('current')
if mibBuilder.loadTexts: scanAPProfileName.setDescription('Name of the scan profile to which this access point is assigned.')
scanAPProfileType = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 15, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("inServiceScan", 1), ("guardianScan", 2), ("outOfServiceScan", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: scanAPProfileType.setStatus('current')
if mibBuilder.loadTexts: scanAPProfileType.setDescription('inServiceScan(1): access point is performed In service Scan. guardianScan(2): access point is performed Guardian Scan. outOfServiceScan(3): access point is performed out of service Scan(Legacy Scan).')
friendlyAPTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 16), )
if mibBuilder.loadTexts: friendlyAPTable.setStatus('current')
if mibBuilder.loadTexts: friendlyAPTable.setDescription('List of Access Points that have been categorized as not being any threat to the wireless network that is managed by EWC. This table can be viewed only in v3 mode when the mitigator analys engine is enabled.')
friendlyAPEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 16, 1), ).setIndexNames((0, "HIPATH-WIRELESS-HWC-MIB", "friendlyAPMacAddress"))
if mibBuilder.loadTexts: friendlyAPEntry.setStatus('current')
if mibBuilder.loadTexts: friendlyAPEntry.setDescription('An entry in this table identifying an access points and some of its attributes.')
friendlyAPMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 16, 1, 1), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: friendlyAPMacAddress.setStatus('current')
if mibBuilder.loadTexts: friendlyAPMacAddress.setDescription('Ethernet MAC address of the access point.')
friendlyAPSSID = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 16, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: friendlyAPSSID.setStatus('current')
if mibBuilder.loadTexts: friendlyAPSSID.setDescription('SSID broadcasted by the access point.')
friendlyAPDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 16, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: friendlyAPDescription.setStatus('current')
if mibBuilder.loadTexts: friendlyAPDescription.setDescription('Textual description that is used to identify the access point.')
friendlyAPManufacturer = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 16, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: friendlyAPManufacturer.setStatus('current')
if mibBuilder.loadTexts: friendlyAPManufacturer.setDescription('Textual description identifying the access point manufacturer.')
uncategorizedAPTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 17), )
if mibBuilder.loadTexts: uncategorizedAPTable.setStatus('current')
if mibBuilder.loadTexts: uncategorizedAPTable.setDescription('List of APs that have not been categorized either as friendly, threat or authorized.')
uncategorizedAPEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 17, 1), ).setIndexNames((0, "HIPATH-WIRELESS-HWC-MIB", "uncategorizedAPMAC"))
if mibBuilder.loadTexts: uncategorizedAPEntry.setStatus('current')
if mibBuilder.loadTexts: uncategorizedAPEntry.setDescription('An entry about an AP in this table.')
uncategorizedAPMAC = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 17, 1, 1), MacAddress())
if mibBuilder.loadTexts: uncategorizedAPMAC.setStatus('current')
if mibBuilder.loadTexts: uncategorizedAPMAC.setDescription('MAC address of access point.')
uncategorizedAPDescption = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 17, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: uncategorizedAPDescption.setStatus('current')
if mibBuilder.loadTexts: uncategorizedAPDescption.setDescription('Textual description of access point.')
uncategorizedAPManufacturer = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 17, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: uncategorizedAPManufacturer.setStatus('current')
if mibBuilder.loadTexts: uncategorizedAPManufacturer.setDescription('Access point manufacturer.')
uncategorizedAPClassify = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 17, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("noAction", 0), ("clasifyAsAuthorized", 1), ("classifyAsFriendlyAP", 2), ("clasifyAsThreatForReport", 3), ("clasifyAsInternalHoneypotThreat", 4), ("clasifyAsExternalHoneypotThreat", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uncategorizedAPClassify.setStatus('current')
if mibBuilder.loadTexts: uncategorizedAPClassify.setDescription('By setting this field, access point can be reclassified and moved to different group.')
uncategorizedAPSSID = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 17, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: uncategorizedAPSSID.setStatus('current')
if mibBuilder.loadTexts: uncategorizedAPSSID.setDescription('SSID broadcasted by the access point.')
authorizedAPTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 18), )
if mibBuilder.loadTexts: authorizedAPTable.setStatus('current')
if mibBuilder.loadTexts: authorizedAPTable.setDescription('List of authorized access point.')
authorizedAPEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 18, 1), ).setIndexNames((0, "HIPATH-WIRELESS-HWC-MIB", "authorizedAPMAC"))
if mibBuilder.loadTexts: authorizedAPEntry.setStatus('current')
if mibBuilder.loadTexts: authorizedAPEntry.setDescription('An entry in this table describing an authorized AP.')
authorizedAPMAC = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 18, 1, 1), MacAddress())
if mibBuilder.loadTexts: authorizedAPMAC.setStatus('current')
if mibBuilder.loadTexts: authorizedAPMAC.setDescription('MAC address of access point.')
authorizedAPDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 18, 1, 2), DisplayString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: authorizedAPDescription.setStatus('current')
if mibBuilder.loadTexts: authorizedAPDescription.setDescription('Discription of the access point.')
authorizedAPManufacturer = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 18, 1, 3), DisplayString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: authorizedAPManufacturer.setStatus('current')
if mibBuilder.loadTexts: authorizedAPManufacturer.setDescription("Access point's manufacturer. This field is cannot be set and it is deduced by MAC addressed.")
authorizedAPClassify = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 18, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("noAction", 0), ("classifyAsFriendlyAP", 1)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: authorizedAPClassify.setStatus('current')
if mibBuilder.loadTexts: authorizedAPClassify.setDescription('By setting this field, access point can be reclassified and moved to different group.')
authorizedAPRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 18, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: authorizedAPRowStatus.setStatus('current')
if mibBuilder.loadTexts: authorizedAPRowStatus.setDescription("Action permitted are 'delete/add' row.")
prohibitedAPTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 19), )
if mibBuilder.loadTexts: prohibitedAPTable.setStatus('current')
if mibBuilder.loadTexts: prohibitedAPTable.setDescription('List of prohibited access points.')
prohibitedAPEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 19, 1), ).setIndexNames((0, "HIPATH-WIRELESS-HWC-MIB", "prohibitedAPMAC"))
if mibBuilder.loadTexts: prohibitedAPEntry.setStatus('current')
if mibBuilder.loadTexts: prohibitedAPEntry.setDescription('An entry in this table describing an access point.')
prohibitedAPMAC = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 19, 1, 1), MacAddress())
if mibBuilder.loadTexts: prohibitedAPMAC.setStatus('current')
if mibBuilder.loadTexts: prohibitedAPMAC.setDescription('MAC address of access point.')
prohibitedAPCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 19, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 65529, 65530, 65531, 65532, 65533, 65534))).clone(namedValues=NamedValues(("notAvailable", 0), ("reportPresenceOnly", 65529), ("externalHoneyPot", 65530), ("internalHoneyPot", 65531), ("friendly", 65532), ("perauthorized", 65533), ("authorized", 65534)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prohibitedAPCategory.setStatus('current')
if mibBuilder.loadTexts: prohibitedAPCategory.setDescription('The category the access point in this row belongs to.')
prohibitedAPDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 19, 1, 3), DisplayString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prohibitedAPDescription.setStatus('current')
if mibBuilder.loadTexts: prohibitedAPDescription.setDescription('Description of the access point.')
prohibitedAPManufacturer = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 19, 1, 4), DisplayString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prohibitedAPManufacturer.setStatus('current')
if mibBuilder.loadTexts: prohibitedAPManufacturer.setDescription("Access point's manufacturer. This field is cannot be set and it is deduced by MAC addressed.")
prohibitedAPClassify = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 19, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("classifyAsFriendlyAP", 1), ("noAction", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prohibitedAPClassify.setStatus('current')
if mibBuilder.loadTexts: prohibitedAPClassify.setDescription('By setting this field, access point can be reclassified and moved to different group.')
prohibitedAPRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 19, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: prohibitedAPRowStatus.setStatus('current')
if mibBuilder.loadTexts: prohibitedAPRowStatus.setDescription("Action permitted are 'delete/add' row.")
dedicatedScanGroupTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 20), )
if mibBuilder.loadTexts: dedicatedScanGroupTable.setStatus('current')
if mibBuilder.loadTexts: dedicatedScanGroupTable.setDescription('dedicated scan group enables the subsystem full time scan for threats based on 37xx-based APs. The threats are discovered and identified in the deployment environment and then classified for further actions. ')
dedicatedScanGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 20, 1), ).setIndexNames((0, "HIPATH-WIRELESS-HWC-MIB", "scanGroupProfileID"))
if mibBuilder.loadTexts: dedicatedScanGroupEntry.setStatus('current')
if mibBuilder.loadTexts: dedicatedScanGroupEntry.setDescription('An entry in this table that defines attributes of a dedicated scan group.')
dedicatedScanGrpName = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 20, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dedicatedScanGrpName.setStatus('current')
if mibBuilder.loadTexts: dedicatedScanGrpName.setDescription('Textual description identifying the scan group.')
dedicatedScanGrpSecurityThreats = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 20, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dedicatedScanGrpSecurityThreats.setStatus('current')
if mibBuilder.loadTexts: dedicatedScanGrpSecurityThreats.setDescription('Enable/disable security engine to scan for threats.')
dedicatedScanGrpMaxConcurrentAttacksPerAP = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 20, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 6))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dedicatedScanGrpMaxConcurrentAttacksPerAP.setStatus('current')
if mibBuilder.loadTexts: dedicatedScanGrpMaxConcurrentAttacksPerAP.setDescription('Max number of concurrent attacks per AP')
dedicatedScanGrpCounterMeasures = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 20, 1, 4), Bits().clone(namedValues=NamedValues(("externalHoneypotAPs", 0), ("roamingToFriendlyAPs", 1), ("internalHoneypotAPs", 2), ("spoofedAPs", 3), ("dropFloodAttack", 4), ("removeDosAttack", 5), ("adHocModeDevice", 6), ("rogueAP", 7)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dedicatedScanGrpCounterMeasures.setStatus('current')
if mibBuilder.loadTexts: dedicatedScanGrpCounterMeasures.setDescription('bit 0: Setting this bit prevents authorized stations from roaming to external honeypot APs. bit 1: Setting this bit prevents authorized stations from roaming to friendly APs. bit 2: Setting this bit prevents any station from using an internal honeypot AP. bit 3: Setting this bit prevents any station from using a spoofed AP. bit 4: Setting this bit drops frames in a controlled fashion during a flood attack. bit 5: Setting this bit removes network access from clients originating DoS attacks. bit 6: Setting this bit prevents any station from using an ad hoc mode device. bit 7: Setting this bit prevents any station from using a rogue AP.')
dedicatedScanGrpScan2400MHzFreq = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 20, 1, 5), Bits().clone(namedValues=NamedValues(("frequency2412MHz", 0), ("frequency2417MHz", 1), ("frequency2422MHz", 2), ("frequency2427MHz", 3), ("frequency2432MHz", 4), ("frequency2437MHz", 5), ("frequency2442MHz", 6), ("frequency2447MHz", 7), ("frequency2452MHz", 8), ("frequency2457MHz", 9), ("frequency2462MHz", 10), ("frequency2467MHz", 11), ("frequency2472MHz", 12), ("frequency2484MHz", 13)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dedicatedScanGrpScan2400MHzFreq.setStatus('current')
if mibBuilder.loadTexts: dedicatedScanGrpScan2400MHzFreq.setDescription('bit 0: by setting this bit scanning is performed on 2412 MHz frequency channel bit 1: by setting this bit scanning is performed on 2417 MHz frequency channel bit 2: by setting this bit scanning is performed on 2422 MHz frequency channel bit 3: by setting this bit scanning is performed on 2427 MHz frequency channel bit 4: by setting this bit scanning is performed on 2432 MHz frequency channel bit 5: by setting this bit scanning is performed on 2437 MHz frequency channel bit 6: by setting this bit scanning is performed on 2442 MHz frequency channel bit 7: by setting this bit scanning is performed on 2447 MHz frequency channel bit 8: by setting this bit scanning is performed on 2452 MHz frequency channel bit 9: by setting this bit scanning is performed on 2457 MHz frequency channel bit 10: by setting this bit scanning is performed on 2462 MHz frequency channel bit 11: by setting this bit scanning is performed on 2467 MHz frequency channel bit 12: by setting this bit scanning is performed on 2472 MHz frequency channel bit 13: by setting this bit scanning is performed on 2484 MHz frequency channel')
dedicatedScanGrpScan5GHzFreq = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 20, 1, 6), Bits().clone(namedValues=NamedValues(("frequency5040MHz", 0), ("frequency5060MHz", 1), ("frequency5080MHz", 2), ("frequency5180MHz", 3), ("frequency5200MHz", 4), ("frequency5220MHz", 5), ("frequency5240MHz", 6), ("frequency5260MHz", 7), ("frequency5280MHz", 8), ("frequency5300MHz", 9), ("frequency5320MHz", 10), ("frequency5500MHz", 11), ("frequency5520MHz", 12), ("frequency5540MHz", 13), ("frequency5560MHz", 14), ("frequency5580MHz", 15), ("frequency5600MHz", 16), ("frequency5620MHz", 17), ("frequency5640MHz", 18), ("frequency5660MHz", 19), ("frequency5680MHz", 20), ("frequency5700MHz", 21), ("frequency5745MHz", 22), ("frequency5765MHz", 23), ("frequency5785MHz", 24), ("frequency5805MHz", 25), ("frequency5825MHz", 26), ("frequency4920MHz", 27), ("frequency4940MHz", 28), ("frequency4960MHz", 29), ("frequency4980MHz", 30)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dedicatedScanGrpScan5GHzFreq.setStatus('current')
if mibBuilder.loadTexts: dedicatedScanGrpScan5GHzFreq.setDescription('bit 0: by setting this bit scanning is performed on 5040 MHz frequency channel bit 1: by setting this bit scanning is performed on 5060 MHz frequency channel bit 2: by setting this bit scanning is performed on 5080 MHz frequency channel bit 3: by setting this bit scanning is performed on 5180 MHz frequency channel bit 4: by setting this bit scanning is performed on 5200 MHz frequency channel bit 5: by setting this bit scanning is performed on 5220 MHz frequency channel bit 6: by setting this bit scanning is performed on 5240 MHz frequency channel bit 7: by setting this bit scanning is performed on 5260 MHz frequency channel bit 8: by setting this bit scanning is performed on 5280 MHz frequency channel bit 9: by setting this bit scanning is performed on 5300 MHz frequency channel bit 10: by setting this bit scanning is performed on 5320 MHz frequency channel bit 11: by setting this bit scanning is performed on 5500 MHz frequency channel bit 12: by setting this bit scanning is performed on 5520 MHz frequency channel bit 13: by setting this bit scanning is performed on 5540 MHz frequency channel bit 14: by setting this bit scanning is performed on 5560 MHz frequency channel bit 15: by setting this bit scanning is performed on 5580 MHz frequency channel bit 16: by setting this bit scanning is performed on 5600 MHz frequency channel bit 17: by setting this bit scanning is performed on 5620 MHz frequency channel bit 18: by setting this bit scanning is performed on 5640 MHz frequency channel bit 19: by setting this bit scanning is performed on 5660 MHz frequency channel bit 20: by setting this bit scanning is performed on 5680 MHz frequency channel bit 21: by setting this bit scanning is performed on 5700 MHz frequency channel bit 22: by setting this bit scanning is performed on 5745 MHz frequency channel bit 23: by setting this bit scanning is performed on 5765 MHz frequency channel bit 24: by setting this bit scanning is performed on 5785 MHz frequency channel bit 25: by setting this bit scanning is performed on 5805 MHz frequency channel bit 26: by setting this bit scanning is performed on 5825 MHz frequency channel bit 27: by setting this bit scanning is performed on 4920 MHz frequency channel bit 28: by setting this bit scanning is performed on 4940 MHz frequency channel bit 29: by setting this bit scanning is performed on 4960 MHz frequency channel bit 30: by setting this bit scanning is performed on 4980 MHz frequency channel')
dedicatedScanGrpBlockAdHocPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 20, 1, 7), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dedicatedScanGrpBlockAdHocPeriod.setStatus('current')
if mibBuilder.loadTexts: dedicatedScanGrpBlockAdHocPeriod.setDescription('Number of seconds removing network access to the clients that are in ad hoc mode.')
dedicatedScanGrpClassifySourceIF = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 20, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dedicatedScanGrpClassifySourceIF.setStatus('current')
if mibBuilder.loadTexts: dedicatedScanGrpClassifySourceIF.setDescription('This variable allows to enable/disable classify sources of interference')
dedicatedScanGrpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 20, 1, 9), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dedicatedScanGrpRowStatus.setStatus('current')
if mibBuilder.loadTexts: dedicatedScanGrpRowStatus.setDescription('RowStatus field for creation/deletion or changing row status.')
dedicatedScanGrpDetectRogueAP = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 20, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dedicatedScanGrpDetectRogueAP.setStatus('current')
if mibBuilder.loadTexts: dedicatedScanGrpDetectRogueAP.setDescription('This enables/disables rogue AP detection.')
dedicatedScanGrpListeningPort = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 20, 1, 11), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dedicatedScanGrpListeningPort.setStatus('current')
if mibBuilder.loadTexts: dedicatedScanGrpListeningPort.setDescription('This variable has meaning only when dedicatedScanGrpDetectRogueAP is enabled. The port number is the port for listening for rogue AP detection.')
widsWipsReport = MibIdentifier((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 30))
activeThreatTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 30, 1), )
if mibBuilder.loadTexts: activeThreatTable.setStatus('current')
if mibBuilder.loadTexts: activeThreatTable.setDescription('List of active threats that have been discovered to this point of time.')
activeThreatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 30, 1, 1), ).setIndexNames((0, "HIPATH-WIRELESS-HWC-MIB", "activeThreatIndex"))
if mibBuilder.loadTexts: activeThreatEntry.setStatus('current')
if mibBuilder.loadTexts: activeThreatEntry.setDescription('An entry in this table describing an idividual threat charactersitics and attributes.')
activeThreatIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 30, 1, 1, 1), Unsigned32())
if mibBuilder.loadTexts: activeThreatIndex.setStatus('current')
if mibBuilder.loadTexts: activeThreatIndex.setDescription('Internally generated number without any significat meaning except used as indexing in this table.')
activeThreatCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 30, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: activeThreatCategory.setStatus('current')
if mibBuilder.loadTexts: activeThreatCategory.setDescription('Textual description describing the type of the threat.')
activeThreatDeviceMAC = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 30, 1, 1, 3), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: activeThreatDeviceMAC.setStatus('current')
if mibBuilder.loadTexts: activeThreatDeviceMAC.setDescription('MAC address of the device that the threat appears to be originated.')
activeThreatDateTime = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 30, 1, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: activeThreatDateTime.setStatus('current')
if mibBuilder.loadTexts: activeThreatDateTime.setDescription('Date and time the threat was discovered. ')
activeThreatCounterMeasure = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 30, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 4, 8))).clone(namedValues=NamedValues(("noCounterMeasure", 0), ("rateLimit", 1), ("preventUse", 2), ("preventRoaming", 4), ("blacklisted", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: activeThreatCounterMeasure.setStatus('current')
if mibBuilder.loadTexts: activeThreatCounterMeasure.setDescription('Counter measure has been taken to tackle the threat.')
activeThreatAPName = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 30, 1, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: activeThreatAPName.setStatus('current')
if mibBuilder.loadTexts: activeThreatAPName.setDescription('Name of the access point.')
activeThreatRSS = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 30, 1, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: activeThreatRSS.setStatus('current')
if mibBuilder.loadTexts: activeThreatRSS.setDescription('Signal strength of the device considered to be a threat.')
activeThreatExtraDetails = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 30, 1, 1, 8), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: activeThreatExtraDetails.setStatus('current')
if mibBuilder.loadTexts: activeThreatExtraDetails.setDescription('Extra comments related to the threat.')
activeThreatThreat = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 30, 1, 1, 9), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: activeThreatThreat.setStatus('current')
if mibBuilder.loadTexts: activeThreatThreat.setDescription('Textual description of the threat.')
countermeasureAPTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 30, 2), )
if mibBuilder.loadTexts: countermeasureAPTable.setStatus('current')
if mibBuilder.loadTexts: countermeasureAPTable.setDescription('List of APs engaged in countermeasure activities to thwart coming threats.')
countermeasureAPEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 30, 2, 1), ).setIndexNames((0, "HIPATH-WIRELESS-HWC-MIB", "countermeasureAPSerial"), (0, "HIPATH-WIRELESS-HWC-MIB", "countermeasureAPThreatIndex"))
if mibBuilder.loadTexts: countermeasureAPEntry.setStatus('current')
if mibBuilder.loadTexts: countermeasureAPEntry.setDescription('An entry in this table identifying an AP engaged in countermeasure activities.')
countermeasureAPThreatIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 30, 2, 1, 1), Unsigned32())
if mibBuilder.loadTexts: countermeasureAPThreatIndex.setStatus('current')
if mibBuilder.loadTexts: countermeasureAPThreatIndex.setDescription('Internally generated index of the access point taking part in countermeasure.')
countermeasureAPSerial = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 30, 2, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: countermeasureAPSerial.setStatus('current')
if mibBuilder.loadTexts: countermeasureAPSerial.setDescription('Serial number of the access point taking part in countermeasure.')
countermeasureAPName = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 30, 2, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: countermeasureAPName.setStatus('current')
if mibBuilder.loadTexts: countermeasureAPName.setDescription('Name of the access point taking part in countermeasure.')
countermeasureAPThreatCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 30, 2, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: countermeasureAPThreatCategory.setStatus('current')
if mibBuilder.loadTexts: countermeasureAPThreatCategory.setDescription('Textual description of the threat category that countermeasure action is aimed at.')
countermeasureAPCountermeasure = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 30, 2, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: countermeasureAPCountermeasure.setStatus('current')
if mibBuilder.loadTexts: countermeasureAPCountermeasure.setDescription('Countermeasure has been taken to thwart the threat.')
countermeasureAPTime = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 30, 2, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: countermeasureAPTime.setStatus('current')
if mibBuilder.loadTexts: countermeasureAPTime.setDescription('The time that the countermeasure has started.')
blacklistedClientTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 30, 3), )
if mibBuilder.loadTexts: blacklistedClientTable.setStatus('current')
if mibBuilder.loadTexts: blacklistedClientTable.setDescription('List of clients that have been blacklisted due to preceived threats they may pose to the safe functioning of the operating network.')
blacklistedClientEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 30, 3, 1), ).setIndexNames((0, "HIPATH-WIRELESS-HWC-MIB", "blacklistedClientMAC"))
if mibBuilder.loadTexts: blacklistedClientEntry.setStatus('current')
if mibBuilder.loadTexts: blacklistedClientEntry.setDescription('An entry in this table pertaining information about the MU that has been blacklisted.')
blacklistedClientMAC = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 30, 3, 1, 1), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: blacklistedClientMAC.setStatus('current')
if mibBuilder.loadTexts: blacklistedClientMAC.setDescription('MAC address of the client.')
blacklistedClientStatTime = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 30, 3, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: blacklistedClientStatTime.setStatus('current')
if mibBuilder.loadTexts: blacklistedClientStatTime.setDescription('The time blacklisting started.')
blacklistedClientEndTime = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 30, 3, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: blacklistedClientEndTime.setStatus('current')
if mibBuilder.loadTexts: blacklistedClientEndTime.setDescription('The time blacklisting ends.')
blacklistedClientReason = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 30, 3, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: blacklistedClientReason.setStatus('current')
if mibBuilder.loadTexts: blacklistedClientReason.setDescription('Reason for blacklisting the client.')
threatSummaryTable = MibTable((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 30, 4), )
if mibBuilder.loadTexts: threatSummaryTable.setStatus('current')
if mibBuilder.loadTexts: threatSummaryTable.setDescription('Summary of all threats that have been detected in the network by wireless controller system.')
threatSummaryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 30, 4, 1), ).setIndexNames((0, "HIPATH-WIRELESS-HWC-MIB", "threatSummaryIndex"))
if mibBuilder.loadTexts: threatSummaryEntry.setStatus('current')
if mibBuilder.loadTexts: threatSummaryEntry.setDescription('An entry summarizing statistics about a category of a threat.')
threatSummaryIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 30, 4, 1, 1), Unsigned32())
if mibBuilder.loadTexts: threatSummaryIndex.setStatus('current')
if mibBuilder.loadTexts: threatSummaryIndex.setDescription('Internally generated index.')
threatSummaryCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 30, 4, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: threatSummaryCategory.setStatus('current')
if mibBuilder.loadTexts: threatSummaryCategory.setDescription('Textul description identifying the category of a threat.')
threatSummaryActiveThreat = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 30, 4, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: threatSummaryActiveThreat.setStatus('current')
if mibBuilder.loadTexts: threatSummaryActiveThreat.setDescription('Counts of threats that are currently active.')
threatSummaryHistoricalCounts = MibTableColumn((1, 3, 6, 1, 4, 1, 4329, 15, 3, 11, 30, 4, 1, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: threatSummaryHistoricalCounts.setStatus('current')
if mibBuilder.loadTexts: threatSummaryHistoricalCounts.setDescription('Historical counts of such threat that were detected in the past by the wireless controller system.')
apNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 4329, 15, 3, 19))
apEventId = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 19, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("apPollTimeout", 1), ("apRegister", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apEventId.setStatus('current')
if mibBuilder.loadTexts: apEventId.setDescription('Identifies event associated with AP or AP tunnel: apPollTimeout - an event triggered when the AP disconnects from the controller. apRegister - an event triggered when the AP connects to the controller.')
apEventDescription = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 19, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apEventDescription.setStatus('current')
if mibBuilder.loadTexts: apEventDescription.setDescription('Contains the description of the most recently triggered event.')
apEventAPSerialNumber = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 19, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readonly")
if mibBuilder.loadTexts: apEventAPSerialNumber.setStatus('current')
if mibBuilder.loadTexts: apEventAPSerialNumber.setDescription('16-character serial number of the AP.')
apTunnelAlarm = NotificationType((1, 3, 6, 1, 4, 1, 4329, 15, 3, 19, 4)).setObjects(("HIPATH-WIRELESS-HWC-MIB", "apEventId"), ("HIPATH-WIRELESS-HWC-MIB", "apEventDescription"), ("HIPATH-WIRELESS-HWC-MIB", "apEventAPSerialNumber"))
if mibBuilder.loadTexts: apTunnelAlarm.setStatus('current')
if mibBuilder.loadTexts: apTunnelAlarm.setDescription('alarm associated with AP and AP interface.')
stationSessionNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 4329, 15, 3, 20))
stationEventType = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 20, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("registration", 0), ("deRegistration", 1), ("stateChange", 2), ("registrationFailed", 3), ("roam", 4), ("mbaTimeout", 5), ("mbaAccepted", 6), ("mbaRejected", 7), ("authorizationChanged", 8), ("authentication", 9), ("authenticationFailed", 10), ("locationUpdate", 11), ("areaChange", 12)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stationEventType.setStatus('current')
if mibBuilder.loadTexts: stationEventType.setDescription('station event type include: registration(0): MU registration. deRegistration(1): MU de-registration. stateChange(2): MU state changed. registrationFailed(3): MU registration failure. roam(4): MU roam. mbaTimeout(5): MU MAC-Based-Authentication time out. mbaAccepted(6): MU MAC-Based-Authentication accepted. mbaRejected(7): MU MAC-Based-Authentication rejected. authorizationChanged(8): MU authorization changed. authentication(9): MU authentication. authenticationFailed(10): MU authentication failure. locationUpdate(11): MU location updated. areaChange(12): MU roamed to other area.')
stationMacAddress = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 20, 2), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stationMacAddress.setStatus('current')
if mibBuilder.loadTexts: stationMacAddress.setDescription('MAC address of the station that is the subject of this event report.')
stationIPAddress = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 20, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stationIPAddress.setStatus('current')
if mibBuilder.loadTexts: stationIPAddress.setDescription('IP address of the station that is the subject of this event report.')
stationAPName = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 20, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stationAPName.setStatus('current')
if mibBuilder.loadTexts: stationAPName.setDescription('name of the AP which station associated with')
stationAPSSID = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 20, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stationAPSSID.setStatus('current')
if mibBuilder.loadTexts: stationAPSSID.setDescription('SSID broadcasted by the access point which station connected to')
stationDetailEvent = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 20, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stationDetailEvent.setStatus('current')
if mibBuilder.loadTexts: stationDetailEvent.setDescription('detail description of the station event')
stationRoamedAPName = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 20, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stationRoamedAPName.setStatus('current')
if mibBuilder.loadTexts: stationRoamedAPName.setDescription('name of the access point which station roamed from')
stationName = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 20, 8), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stationName.setStatus('current')
if mibBuilder.loadTexts: stationName.setDescription('name of station')
stationBSSID = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 20, 9), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stationBSSID.setStatus('current')
if mibBuilder.loadTexts: stationBSSID.setDescription('the Mac address of the radio which station connect to')
stationEventTimeStamp = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 20, 10), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stationEventTimeStamp.setStatus('current')
if mibBuilder.loadTexts: stationEventTimeStamp.setDescription('The duration in hundredths of a second from the network agent start time to the time of generation of the station event.')
stationEventAlarm = NotificationType((1, 3, 6, 1, 4, 1, 4329, 15, 3, 20, 11)).setObjects(("HIPATH-WIRELESS-HWC-MIB", "stationEventType"), ("HIPATH-WIRELESS-HWC-MIB", "stationMacAddress"), ("HIPATH-WIRELESS-HWC-MIB", "stationIPAddress"), ("HIPATH-WIRELESS-HWC-MIB", "stationAPName"), ("HIPATH-WIRELESS-HWC-MIB", "stationAPSSID"), ("HIPATH-WIRELESS-HWC-MIB", "stationDetailEvent"), ("HIPATH-WIRELESS-HWC-MIB", "stationRoamedAPName"), ("HIPATH-WIRELESS-HWC-MIB", "stationName"), ("HIPATH-WIRELESS-HWC-MIB", "stationBSSID"), ("HIPATH-WIRELESS-HWC-MIB", "stationEventTimeStamp"), ("HIPATH-WIRELESS-HWC-MIB", "stationIPv6Address1"), ("HIPATH-WIRELESS-HWC-MIB", "stationIPv6Address2"), ("HIPATH-WIRELESS-HWC-MIB", "stationIPv6Address3"))
if mibBuilder.loadTexts: stationEventAlarm.setStatus('current')
if mibBuilder.loadTexts: stationEventAlarm.setDescription('A trap describing a significant event that happened to a station during a session on the network. A controller can sees hundreds or even thousands of these events every second.')
stationIPv6Address1 = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 20, 12), Ipv6Address()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stationIPv6Address1.setStatus('current')
if mibBuilder.loadTexts: stationIPv6Address1.setDescription('One of the IPv6 addresses of the station that is the subject of this event report.')
stationIPv6Address2 = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 20, 13), Ipv6Address()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stationIPv6Address2.setStatus('current')
if mibBuilder.loadTexts: stationIPv6Address2.setDescription('One of the IPv6 addresses of the station that is the subject of this event report.')
stationIPv6Address3 = MibScalar((1, 3, 6, 1, 4, 1, 4329, 15, 3, 20, 14), Ipv6Address()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stationIPv6Address3.setStatus('current')
if mibBuilder.loadTexts: stationIPv6Address3.setDescription('One of the IPv6 addresses of the station that is the subject of this event report.')
hiPathWirelessHWCConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 4329, 15, 3, 30))
hiPathWirelessHWCModule = ModuleCompliance((1, 3, 6, 1, 4, 1, 4329, 15, 3, 30, 1)).setObjects(("HIPATH-WIRELESS-HWC-MIB", "hiPathWirelessHWCGroup"), ("HIPATH-WIRELESS-HWC-MIB", "layerTwoPortGroup"), ("HIPATH-WIRELESS-HWC-MIB", "muGroup"), ("HIPATH-WIRELESS-HWC-MIB", "apStatsGroup"), ("HIPATH-WIRELESS-HWC-MIB", "muACLGroup"), ("HIPATH-WIRELESS-HWC-MIB", "siteGroup"), ("HIPATH-WIRELESS-HWC-MIB", "sitePolicyGroup"), ("HIPATH-WIRELESS-HWC-MIB", "siteCosGroup"), ("HIPATH-WIRELESS-HWC-MIB", "siteAPGroup"), ("HIPATH-WIRELESS-HWC-MIB", "siteWlanGroup"), ("HIPATH-WIRELESS-HWC-MIB", "apGroup"), ("HIPATH-WIRELESS-HWC-MIB", "wlanGroup"), ("HIPATH-WIRELESS-HWC-MIB", "wlanStatsGroup"), ("HIPATH-WIRELESS-HWC-MIB", "topologyGroup"), ("HIPATH-WIRELESS-HWC-MIB", "topologyStatGroup"), ("HIPATH-WIRELESS-HWC-MIB", "loadGroup"), ("HIPATH-WIRELESS-HWC-MIB", "outOfServiceScanGroup"), ("HIPATH-WIRELESS-HWC-MIB", "widsWipsEngineGroup"), ("HIPATH-WIRELESS-HWC-MIB", "widsWipsObjectsGroup"), ("HIPATH-WIRELESS-HWC-MIB", "scanGroupAPAssignmentGroup"), ("HIPATH-WIRELESS-HWC-MIB", "inServiceScanGroup"), ("HIPATH-WIRELESS-HWC-MIB", "wlanSecurityReportGroup"), ("HIPATH-WIRELESS-HWC-MIB", "friendlyAPGroup"), ("HIPATH-WIRELESS-HWC-MIB", "scanAPGroup"), ("HIPATH-WIRELESS-HWC-MIB", "activeThreatGroup"), ("HIPATH-WIRELESS-HWC-MIB", "muAccessListGroup"), ("HIPATH-WIRELESS-HWC-MIB", "apAntennaGroup"), ("HIPATH-WIRELESS-HWC-MIB", "threatSummaryGroup"), ("HIPATH-WIRELESS-HWC-MIB", "blaclistedClientGroup"), ("HIPATH-WIRELESS-HWC-MIB", "countermeasureAPGroup"), ("HIPATH-WIRELESS-HWC-MIB", "apByChannelGroup"), ("HIPATH-WIRELESS-HWC-MIB", "stationsByProtocolGroup"), ("HIPATH-WIRELESS-HWC-MIB", "licensingInformationGroup"), ("HIPATH-WIRELESS-HWC-MIB", "dedicatedScanGroup"), ("HIPATH-WIRELESS-HWC-MIB", "prohibitedAPGroup"), ("HIPATH-WIRELESS-HWC-MIB", "authorizedAPGroup"), ("HIPATH-WIRELESS-HWC-MIB", "uncategorizedAPGroup"), ("HIPATH-WIRELESS-HWC-MIB", "radiusFastFailoverEventsGroup"), ("HIPATH-WIRELESS-HWC-MIB", "dhcpRelayListenersGroup"), ("HIPATH-WIRELESS-HWC-MIB", "apRadioAntennaGroup"), ("HIPATH-WIRELESS-HWC-MIB", "authenticationAdvancedGroup"), ("HIPATH-WIRELESS-HWC-MIB", "radiusExtnsSettingGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hiPathWirelessHWCModule = hiPathWirelessHWCModule.setStatus('current')
if mibBuilder.loadTexts: hiPathWirelessHWCModule.setDescription('Conformance definition for the EWC MIB.')
hiPathWirelessHWCGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 4329, 15, 3, 30, 2))
for _hiPathWirelessHWCGroup_obj in [[("HIPATH-WIRELESS-HWC-MIB", "sysSoftwareVersion"), ("HIPATH-WIRELESS-HWC-MIB", "sysCPUType"), ("HIPATH-WIRELESS-HWC-MIB", "sysLogLevel"), ("HIPATH-WIRELESS-HWC-MIB", "logEventSeverityThreshold"), ("HIPATH-WIRELESS-HWC-MIB", "logEventSeverity"), ("HIPATH-WIRELESS-HWC-MIB", "logEventComponent"), ("HIPATH-WIRELESS-HWC-MIB", "apLogCollectionEnable"), ("HIPATH-WIRELESS-HWC-MIB", "apLogFrequency"), ("HIPATH-WIRELESS-HWC-MIB", "apLogDestination"), ("HIPATH-WIRELESS-HWC-MIB", "apLogUserId"), ("HIPATH-WIRELESS-HWC-MIB", "apLogServerIP"), ("HIPATH-WIRELESS-HWC-MIB", "apLogDirectory"), ("HIPATH-WIRELESS-HWC-MIB", "apLogPassword"), ("HIPATH-WIRELESS-HWC-MIB", "apLogFTProtocol"), ("HIPATH-WIRELESS-HWC-MIB", "select"), ("HIPATH-WIRELESS-HWC-MIB", "apLogQuickSelectedOption"), ("HIPATH-WIRELESS-HWC-MIB", "apLogFileCopyDestination"), ("HIPATH-WIRELESS-HWC-MIB", "apLogFileCopyProtocol"), ("HIPATH-WIRELESS-HWC-MIB", "apLogFileCopyServerIP"), ("HIPATH-WIRELESS-HWC-MIB", "apLogFileCopyUserID"), ("HIPATH-WIRELESS-HWC-MIB", "apLogFileCopyPassword"), ("HIPATH-WIRELESS-HWC-MIB", "apLogFileCopyServerDirectory"), ("HIPATH-WIRELESS-HWC-MIB", "apLogFileCopyOperation"), ("HIPATH-WIRELESS-HWC-MIB", "apLogFileCopyOperationStatus"), ("HIPATH-WIRELESS-HWC-MIB", "apLogFileCopyRowStatus"), ("HIPATH-WIRELESS-HWC-MIB", "apLogFileUtilityLimit"), ("HIPATH-WIRELESS-HWC-MIB", "apLogFileUtilityCurrent"), ("HIPATH-WIRELESS-HWC-MIB", "logEventDescription"), ("HIPATH-WIRELESS-HWC-MIB", "apEventId"), ("HIPATH-WIRELESS-HWC-MIB", "apEventDescription"), ("HIPATH-WIRELESS-HWC-MIB", "apEventAPSerialNumber"), ("HIPATH-WIRELESS-HWC-MIB", "assocTxPackets"), ("HIPATH-WIRELESS-HWC-MIB", "assocRxPackets"), ("HIPATH-WIRELESS-HWC-MIB", "assocTxOctets"), ("HIPATH-WIRELESS-HWC-MIB", "assocRxOctets"), ("HIPATH-WIRELESS-HWC-MIB", "assocDuration"), ("HIPATH-WIRELESS-HWC-MIB", "assocCount"), ("HIPATH-WIRELESS-HWC-MIB", "assocMUMacAddress"), ("HIPATH-WIRELESS-HWC-MIB", "assocStartSysUpTime"), ("HIPATH-WIRELESS-HWC-MIB", "mobileUnitCount"), ("HIPATH-WIRELESS-HWC-MIB", "vnsIfIndex"), ("HIPATH-WIRELESS-HWC-MIB", "radioVNSRowStatus"), ("HIPATH-WIRELESS-HWC-MIB", "radioIfIndex"), ("HIPATH-WIRELESS-HWC-MIB", "vnsFilterRulePortLow"), ("HIPATH-WIRELESS-HWC-MIB", "vnsFilterRulePortHigh"), ("HIPATH-WIRELESS-HWC-MIB", "cpURL"), ("HIPATH-WIRELESS-HWC-MIB", "vnsDHCPRangeIndex"), ("HIPATH-WIRELESS-HWC-MIB", "vns3rdPartyAP"), ("HIPATH-WIRELESS-HWC-MIB", "vnsUseDHCPRelay"), ("HIPATH-WIRELESS-HWC-MIB", "vnsMgmtTrafficEnable"), ("HIPATH-WIRELESS-HWC-MIB", "vnsAuthModel"), ("HIPATH-WIRELESS-HWC-MIB", "physicalPortCount"), ("HIPATH-WIRELESS-HWC-MIB", "mgmtPortIfIndex"), ("HIPATH-WIRELESS-HWC-MIB", "mgmtPortHostname"), ("HIPATH-WIRELESS-HWC-MIB", "mgmtPortDomain"), ("HIPATH-WIRELESS-HWC-MIB", "vnRole"), ("HIPATH-WIRELESS-HWC-MIB", "vnIfIndex"), ("HIPATH-WIRELESS-HWC-MIB", "vnHeartbeatInterval"), ("HIPATH-WIRELESS-HWC-MIB", "ntpEnabled"), ("HIPATH-WIRELESS-HWC-MIB", "ntpTimezone"), ("HIPATH-WIRELESS-HWC-MIB", "ntpTimeServer1"), ("HIPATH-WIRELESS-HWC-MIB", "ntpTimeServer2"), ("HIPATH-WIRELESS-HWC-MIB", "ntpTimeServer3"), ("HIPATH-WIRELESS-HWC-MIB", "tunnelCount"), ("HIPATH-WIRELESS-HWC-MIB", "vnsCount"), ("HIPATH-WIRELESS-HWC-MIB", "vnsDescription"), ("HIPATH-WIRELESS-HWC-MIB", "vnsMUSessionTimeout"), ("HIPATH-WIRELESS-HWC-MIB", "vnsAllowMulticast"), ("HIPATH-WIRELESS-HWC-MIB", "vnsSSID"), ("HIPATH-WIRELESS-HWC-MIB", "vnsDomain"), ("HIPATH-WIRELESS-HWC-MIB", "vnsDNSServers"), ("HIPATH-WIRELESS-HWC-MIB", "vnsWINSServers"), ("HIPATH-WIRELESS-HWC-MIB", "vnsStatus"), ("HIPATH-WIRELESS-HWC-MIB", "vnsDHCPRangeStart"), ("HIPATH-WIRELESS-HWC-MIB", "vnsDHCPRangeEnd"), ("HIPATH-WIRELESS-HWC-MIB", "vnsDHCPRangeType"), ("HIPATH-WIRELESS-HWC-MIB", "vnsDHCPRangeStatus"), ("HIPATH-WIRELESS-HWC-MIB", "vnsRadiusServerPort"), ("HIPATH-WIRELESS-HWC-MIB", "vnsRadiusServerRetries"), ("HIPATH-WIRELESS-HWC-MIB", "vnsRadiusServerTimeout"), ("HIPATH-WIRELESS-HWC-MIB", "vnsRadiusServerSharedSecret"), ("HIPATH-WIRELESS-HWC-MIB", "vnsRadiusServerNASIdentifier"), ("HIPATH-WIRELESS-HWC-MIB", "vnsRadiusServerAuthType"), ("HIPATH-WIRELESS-HWC-MIB", "vnsRadiusServerRowStatus"), ("HIPATH-WIRELESS-HWC-MIB", "vnsFilterID"), ("HIPATH-WIRELESS-HWC-MIB", "vnsFilterIDStatus"), ("HIPATH-WIRELESS-HWC-MIB", "vnsFilterRuleOrder"), ("HIPATH-WIRELESS-HWC-MIB", "vnsFilterRuleDirection"), ("HIPATH-WIRELESS-HWC-MIB", "vnsFilterRuleAction"), ("HIPATH-WIRELESS-HWC-MIB", "vnsFilterRuleIPAddress"), ("HIPATH-WIRELESS-HWC-MIB", "vnsFilterRuleProtocol"), ("HIPATH-WIRELESS-HWC-MIB", "vnsFilterRuleEtherType"), ("HIPATH-WIRELESS-HWC-MIB", "vnsFilterRuleStatus"), ("HIPATH-WIRELESS-HWC-MIB", "vnsPrivWEPKeyType"), ("HIPATH-WIRELESS-HWC-MIB", "vnsPrivDynamicRekeyFrequency"), ("HIPATH-WIRELESS-HWC-MIB", "vnsPrivWEPKeyLength"), ("HIPATH-WIRELESS-HWC-MIB", "vnsPrivWPA1Enabled"), ("HIPATH-WIRELESS-HWC-MIB", "vnsPrivUseSharedKey"), ("HIPATH-WIRELESS-HWC-MIB", "vnsPrivWPASharedKey"), ("HIPATH-WIRELESS-HWC-MIB", "vnsWEPKeyIndex"), ("HIPATH-WIRELESS-HWC-MIB", "vnsWEPKeyValue"), ("HIPATH-WIRELESS-HWC-MIB", "activeVNSSessionCount"), ("HIPATH-WIRELESS-HWC-MIB", "apCount"), ("HIPATH-WIRELESS-HWC-MIB", "cpReplaceGatewayWithFQDN"), ("HIPATH-WIRELESS-HWC-MIB", "cpDefaultRedirectionURL"), ("HIPATH-WIRELESS-HWC-MIB", "cpConnectionIP"), ("HIPATH-WIRELESS-HWC-MIB", "cpConnectionPort"), ("HIPATH-WIRELESS-HWC-MIB", "cpSharedSecret"), ("HIPATH-WIRELESS-HWC-MIB", "cpLogOff"), ("HIPATH-WIRELESS-HWC-MIB", "cpStatusCheck"), ("HIPATH-WIRELESS-HWC-MIB", "cpType"), ("HIPATH-WIRELESS-HWC-MIB", "apMacAddress"), ("HIPATH-WIRELESS-HWC-MIB", "serviceLogFacility"), ("HIPATH-WIRELESS-HWC-MIB", "sysLogServerIP"), ("HIPATH-WIRELESS-HWC-MIB", "sysLogServerPort"), ("HIPATH-WIRELESS-HWC-MIB", "sysLogServerRowStatus"), ("HIPATH-WIRELESS-HWC-MIB", "sysLogServerIndex"), ("HIPATH-WIRELESS-HWC-MIB", "apActiveCount"), ("HIPATH-WIRELESS-HWC-MIB", "sysLogServerEnabled"), ("HIPATH-WIRELESS-HWC-MIB", "assocVnsIfIndex"), ("HIPATH-WIRELESS-HWC-MIB", "apRadioFrequency"), ("HIPATH-WIRELESS-HWC-MIB", "includeAllServiceMessages"), ("HIPATH-WIRELESS-HWC-MIB", "tunnelStartIP"), ("HIPATH-WIRELESS-HWC-MIB", "tunnelStartHWC"), ("HIPATH-WIRELESS-HWC-MIB", "tunnelEndIP"), ("HIPATH-WIRELESS-HWC-MIB", "tunnelEndHWC"), ("HIPATH-WIRELESS-HWC-MIB", "apBroadcastDisassociate"), ("HIPATH-WIRELESS-HWC-MIB", "sysSerialNo"), ("HIPATH-WIRELESS-HWC-MIB", "vnsPrivWPA2Enabled"), ("HIPATH-WIRELESS-HWC-MIB", "tunnelStatus"), ("HIPATH-WIRELESS-HWC-MIB", "hiPathWirelessAppLogFacility"), ("HIPATH-WIRELESS-HWC-MIB", "vnsVlanID"), ("HIPATH-WIRELESS-HWC-MIB", "vnsMgmIpAddress"), ("HIPATH-WIRELESS-HWC-MIB", "maxVoiceBWforReassociation"), ("HIPATH-WIRELESS-HWC-MIB", "maxVoiceBWforAssociation"), ("HIPATH-WIRELESS-HWC-MIB", "maxVideoBWforReassociation"), ("HIPATH-WIRELESS-HWC-MIB", "maxVideoBWforAssociation"), ("HIPATH-WIRELESS-HWC-MIB", "maxBestEffortBWforReassociation"), ("HIPATH-WIRELESS-HWC-MIB", "maxBestEffortBWforAssociation"), ("HIPATH-WIRELESS-HWC-MIB", "maxBackgroundBWforReassociation"), ("HIPATH-WIRELESS-HWC-MIB", "maxBackgroundBWforAssociation"), ("HIPATH-WIRELESS-HWC-MIB", "physicalPortsInternalVlanID"), ("HIPATH-WIRELESS-HWC-MIB", "vnsMode"), ("HIPATH-WIRELESS-HWC-MIB", "vnsQoSPriorityOverrideFlag"), ("HIPATH-WIRELESS-HWC-MIB", "vnsQoSPriorityOverrideSC"), ("HIPATH-WIRELESS-HWC-MIB", "vnsQoSPriorityOverrideDSCP"), ("HIPATH-WIRELESS-HWC-MIB", "netflowDestinationIP"), ("HIPATH-WIRELESS-HWC-MIB", "netflowInterval"), ("HIPATH-WIRELESS-HWC-MIB", "mirrorFirstN"), ("HIPATH-WIRELESS-HWC-MIB", "mirrorL2Ports"), ("HIPATH-WIRELESS-HWC-MIB", "vnsQoSClassificationServiceClass"), ("HIPATH-WIRELESS-HWC-MIB", "vnsQoSWirelessLegacyFlag"), ("HIPATH-WIRELESS-HWC-MIB", "vnsQoSWirelessWMMFlag"), ("HIPATH-WIRELESS-HWC-MIB", "vnsQoSWireless80211eFlag"), ("HIPATH-WIRELESS-HWC-MIB", "vnsQoSWirelessTurboVoiceFlag"), ("HIPATH-WIRELESS-HWC-MIB", "vnsQoSWirelessEnableUAPSD"), ("HIPATH-WIRELESS-HWC-MIB", "vnsQoSWirelessUseAdmControlVoice"), ("HIPATH-WIRELESS-HWC-MIB", "vnsSuppressSSID"), ("HIPATH-WIRELESS-HWC-MIB", "vnsEnable11hSupport"), ("HIPATH-WIRELESS-HWC-MIB", "vnsApplyPowerBackOff"), ("HIPATH-WIRELESS-HWC-MIB", "vnsProcessClientIEReq"), ("HIPATH-WIRELESS-HWC-MIB", "vnsQoSWirelessUseAdmControlVideo"), ("HIPATH-WIRELESS-HWC-MIB", "vnsInterfaceName"), ("HIPATH-WIRELESS-HWC-MIB", "vnsQoSWirelessULPolicerAction"), ("HIPATH-WIRELESS-HWC-MIB", "vnsQoSWirelessDLPolicerAction"), ("HIPATH-WIRELESS-HWC-MIB", "vnsQoSWirelessUseAdmControlBestEffort"), ("HIPATH-WIRELESS-HWC-MIB", "vnsQoSWirelessUseAdmControlBackground"), ("HIPATH-WIRELESS-HWC-MIB", "tspecMuMACAddress"), ("HIPATH-WIRELESS-HWC-MIB", "tspecAC"), ("HIPATH-WIRELESS-HWC-MIB", "tspecDirection"), ("HIPATH-WIRELESS-HWC-MIB", "tspecApSerialNumber"), ("HIPATH-WIRELESS-HWC-MIB", "tspecMuIPAddress"), ("HIPATH-WIRELESS-HWC-MIB", "tspecBssMac"), ("HIPATH-WIRELESS-HWC-MIB", "tspecSsid"), ("HIPATH-WIRELESS-HWC-MIB", "tspecMDR"), ("HIPATH-WIRELESS-HWC-MIB", "tspecNMS"), ("HIPATH-WIRELESS-HWC-MIB", "tspecSBA"), ("HIPATH-WIRELESS-HWC-MIB", "tspecDlRate"), ("HIPATH-WIRELESS-HWC-MIB", "tspecUlRate"), ("HIPATH-WIRELESS-HWC-MIB", "tspecDlViolations"), ("HIPATH-WIRELESS-HWC-MIB", "tspecUlViolations"), ("HIPATH-WIRELESS-HWC-MIB", "tspecProtocol"), ("HIPATH-WIRELESS-HWC-MIB", "vnsDLSSupportEnable"), ("HIPATH-WIRELESS-HWC-MIB", "vnsDLSAddress"), ("HIPATH-WIRELESS-HWC-MIB", "vnsDLSPort"), ("HIPATH-WIRELESS-HWC-MIB", "vnsSessionAvailabilityEnable"), ("HIPATH-WIRELESS-HWC-MIB", "ntpServerEnabled"), ("HIPATH-WIRELESS-HWC-MIB", "primaryDNS"), ("HIPATH-WIRELESS-HWC-MIB", "secondaryDNS"), ("HIPATH-WIRELESS-HWC-MIB", "tertiaryDNS"), ("HIPATH-WIRELESS-HWC-MIB", "physicalFlash"), ("HIPATH-WIRELESS-HWC-MIB", "jumboFrames"), ("HIPATH-WIRELESS-HWC-MIB", "vnsRadiusServerName"), ("HIPATH-WIRELESS-HWC-MIB", "vnsRadiusServerNasAddress"), ("HIPATH-WIRELESS-HWC-MIB", "dasReplayInterval"), ("HIPATH-WIRELESS-HWC-MIB", "dasPort"), ("HIPATH-WIRELESS-HWC-MIB", "vnsEnabled"), ("HIPATH-WIRELESS-HWC-MIB", "vnsAPFilterRuleOrder"), ("HIPATH-WIRELESS-HWC-MIB", "vnsAPFilterRuleDirection"), ("HIPATH-WIRELESS-HWC-MIB", "vnsAPFilterAction"), ("HIPATH-WIRELESS-HWC-MIB", "vnsAPFilterIPAddress"), ("HIPATH-WIRELESS-HWC-MIB", "vnsAPFilterMask"), ("HIPATH-WIRELESS-HWC-MIB", "vnsAPFilterPortLow"), ("HIPATH-WIRELESS-HWC-MIB", "vnsAPFilterPortHigh"), ("HIPATH-WIRELESS-HWC-MIB", "vnsAPFilterProtocol"), ("HIPATH-WIRELESS-HWC-MIB", "vnsAPFilterEtherType"), ("HIPATH-WIRELESS-HWC-MIB", "vnsAPFilterRowStatus"), ("HIPATH-WIRELESS-HWC-MIB", "vnsStrictSubnetAdherence"), ("HIPATH-WIRELESS-HWC-MIB", "vnsSLPEnabled"), ("HIPATH-WIRELESS-HWC-MIB", "imagePath36xx"), ("HIPATH-WIRELESS-HWC-MIB", "imagePath26xx"), ("HIPATH-WIRELESS-HWC-MIB", "tftpSever"), ("HIPATH-WIRELESS-HWC-MIB", "imageVersionOfap26xx"), ("HIPATH-WIRELESS-HWC-MIB", "imageVersionOfngap36xx"), ("HIPATH-WIRELESS-HWC-MIB", "topoExceptionFiterName"), ("HIPATH-WIRELESS-HWC-MIB", "topoExceptionStatPktsDenied"), ("HIPATH-WIRELESS-HWC-MIB", "topoExceptionStatPktsAllowed"), ("HIPATH-WIRELESS-HWC-MIB", "synchronizeSystemConfig"), ("HIPATH-WIRELESS-HWC-MIB", "availabilityStatus"), ("HIPATH-WIRELESS-HWC-MIB", "pairIPAddress"), ("HIPATH-WIRELESS-HWC-MIB", "hwcAvailabilityRank"), ("HIPATH-WIRELESS-HWC-MIB", "fastFailover"), ("HIPATH-WIRELESS-HWC-MIB", "synchronizeGuestPort"), ("HIPATH-WIRELESS-HWC-MIB", "tunnelStatsTxBytes"), ("HIPATH-WIRELESS-HWC-MIB", "apRegistrationRequests"), ("HIPATH-WIRELESS-HWC-MIB", "vnForeignClients"), ("HIPATH-WIRELESS-HWC-MIB", "vnLocalClients"), ("HIPATH-WIRELESS-HWC-MIB", "apStatsSessionDuration"), ("HIPATH-WIRELESS-HWC-MIB", "detectLinkFailure"), ("HIPATH-WIRELESS-HWC-MIB", "apRegUseClusterEncryption"), ("HIPATH-WIRELESS-HWC-MIB", "apRegClusterSharedSecret"), ("HIPATH-WIRELESS-HWC-MIB", "apRegDiscoveryRetries"), ("HIPATH-WIRELESS-HWC-MIB", "apRegDiscoveryInterval"), ("HIPATH-WIRELESS-HWC-MIB", "apRegTelnetPassword"), ("HIPATH-WIRELESS-HWC-MIB", "apRegSSHPassword"), ("HIPATH-WIRELESS-HWC-MIB", "apRegSecurityMode"), ("HIPATH-WIRELESS-HWC-MIB", "vnTotalClients"), ("HIPATH-WIRELESS-HWC-MIB", "tunnelStatsRxBytes"), ("HIPATH-WIRELESS-HWC-MIB", "tunnelStatsTxRxBytes"), ("HIPATH-WIRELESS-HWC-MIB", "tunnelsTxRxBytes"), ("HIPATH-WIRELESS-HWC-MIB", "clearAccessRejectMsg"), ("HIPATH-WIRELESS-HWC-MIB", "armCount"), ("HIPATH-WIRELESS-HWC-MIB", "armReplyMessage"), ("HIPATH-WIRELESS-HWC-MIB", "apLinkTimeout"), ("HIPATH-WIRELESS-HWC-MIB", "apFastFailoverEnable"), ("HIPATH-WIRELESS-HWC-MIB", "topoStatFrameTooLongErrors"), ("HIPATH-WIRELESS-HWC-MIB", "topoStatFrameChkSeqErrors"), ("HIPATH-WIRELESS-HWC-MIB", "vnsConfigWLANID"), ("HIPATH-WIRELESS-HWC-MIB", "wlanVNSID"), ("HIPATH-WIRELESS-HWC-MIB", "wlanPrivPrivacyType"), ("HIPATH-WIRELESS-HWC-MIB", "wlanPrivWEPKeyIndex"), ("HIPATH-WIRELESS-HWC-MIB", "wlanPrivWEPKeyLength"), ("HIPATH-WIRELESS-HWC-MIB", "wlanPrivWEPKey"), ("HIPATH-WIRELESS-HWC-MIB", "wlanPrivWPAv1EncryptionType"), ("HIPATH-WIRELESS-HWC-MIB", "wlanPrivWPAv2EncryptionType")], [("HIPATH-WIRELESS-HWC-MIB", "wlanPrivKeyManagement"), ("HIPATH-WIRELESS-HWC-MIB", "wlanPrivBroadcastRekeying"), ("HIPATH-WIRELESS-HWC-MIB", "wlanPrivRekeyInterval"), ("HIPATH-WIRELESS-HWC-MIB", "wlanPrivGroupKPSR"), ("HIPATH-WIRELESS-HWC-MIB", "wlanPrivWPAPSK"), ("HIPATH-WIRELESS-HWC-MIB", "wlanPrivWPAversion"), ("HIPATH-WIRELESS-HWC-MIB", "wlanPrivfastTransition"), ("HIPATH-WIRELESS-HWC-MIB", "wlanPrivManagementFrameProtection"), ("HIPATH-WIRELESS-HWC-MIB", "wlanAuthType"), ("HIPATH-WIRELESS-HWC-MIB", "wlanAuthMacBasedAuth"), ("HIPATH-WIRELESS-HWC-MIB", "wlanAuthMACBasedAuthOnRoam"), ("HIPATH-WIRELESS-HWC-MIB", "wlanAuthAutoAuthAuthorizedUser"), ("HIPATH-WIRELESS-HWC-MIB", "wlanAuthAllowUnauthorizedUser"), ("HIPATH-WIRELESS-HWC-MIB", "wlanAuthRadiusIncludeAP"), ("HIPATH-WIRELESS-HWC-MIB", "wlanAuthRadiusIncludeVNS"), ("HIPATH-WIRELESS-HWC-MIB", "wlanAuthRadiusIncludeSSID"), ("HIPATH-WIRELESS-HWC-MIB", "wlanAuthRadiusIncludePolicy"), ("HIPATH-WIRELESS-HWC-MIB", "wlanAuthRadiusIncludeTopology"), ("HIPATH-WIRELESS-HWC-MIB", "wlanAuthRadiusIncludeIngressRC"), ("HIPATH-WIRELESS-HWC-MIB", "wlanAuthRadiusIncludeEgressRC"), ("HIPATH-WIRELESS-HWC-MIB", "wlanAuthCollectAcctInformation"), ("HIPATH-WIRELESS-HWC-MIB", "wlanAuthReplaceCalledStationIDWithZone"), ("HIPATH-WIRELESS-HWC-MIB", "wlanAuthRadiusAcctAfterMacBaseAuthorization"), ("HIPATH-WIRELESS-HWC-MIB", "wlanAuthRadiusTimeoutRole"), ("HIPATH-WIRELESS-HWC-MIB", "wlanAuthRadiusOperatorNameSpace"), ("HIPATH-WIRELESS-HWC-MIB", "wlanAuthRadiusOperatorName"), ("HIPATH-WIRELESS-HWC-MIB", "wlanAuthMACBasedAuthReAuthOnAreaRoam"), ("HIPATH-WIRELESS-HWC-MIB", "wlanRadiusName"), ("HIPATH-WIRELESS-HWC-MIB", "wlanRadiusUsage"), ("HIPATH-WIRELESS-HWC-MIB", "wlanRadiusPriority"), ("HIPATH-WIRELESS-HWC-MIB", "wlanRadiusPort"), ("HIPATH-WIRELESS-HWC-MIB", "wlanRadiusRetries"), ("HIPATH-WIRELESS-HWC-MIB", "wlanRadiusTimeout"), ("HIPATH-WIRELESS-HWC-MIB", "wlanRadiusNASUseVnsIP"), ("HIPATH-WIRELESS-HWC-MIB", "wlanRadiusNASIP"), ("HIPATH-WIRELESS-HWC-MIB", "wlanRadiusNASIDUseVNSName"), ("HIPATH-WIRELESS-HWC-MIB", "wlanRadiusNASID"), ("HIPATH-WIRELESS-HWC-MIB", "wlanRadiusAuthType"), ("HIPATH-WIRELESS-HWC-MIB", "wlanCPAuthType"), ("HIPATH-WIRELESS-HWC-MIB", "wlanCP802HttpRedirect"), ("HIPATH-WIRELESS-HWC-MIB", "wlanCPExtConnection"), ("HIPATH-WIRELESS-HWC-MIB", "wlanCPExtPort"), ("HIPATH-WIRELESS-HWC-MIB", "wlanCPExtEnableHttps"), ("HIPATH-WIRELESS-HWC-MIB", "wlanCPExtSharedSecret"), ("HIPATH-WIRELESS-HWC-MIB", "wlanCPExtTosOverride"), ("HIPATH-WIRELESS-HWC-MIB", "wlanCPExtTosValue"), ("HIPATH-WIRELESS-HWC-MIB", "wlanCPGuestAccLifetime"), ("HIPATH-WIRELESS-HWC-MIB", "wlanCPGuestSessionLifetime"), ("HIPATH-WIRELESS-HWC-MIB", "loadGrpRadiosRadio1"), ("HIPATH-WIRELESS-HWC-MIB", "loadGrpRadiosRadio2"), ("HIPATH-WIRELESS-HWC-MIB", "loadGrpWlanAssigned"), ("HIPATH-WIRELESS-HWC-MIB", "schedule"), ("HIPATH-WIRELESS-HWC-MIB", "startHour"), ("HIPATH-WIRELESS-HWC-MIB", "startMinute"), ("HIPATH-WIRELESS-HWC-MIB", "duration"), ("HIPATH-WIRELESS-HWC-MIB", "recurrenceDaily"), ("HIPATH-WIRELESS-HWC-MIB", "recurrenceWeekly"), ("HIPATH-WIRELESS-HWC-MIB", "recurrenceMonthly"), ("HIPATH-WIRELESS-HWC-MIB", "apPlatforms"), ("HIPATH-WIRELESS-HWC-MIB", "wlanCPIntLogoffButton"), ("HIPATH-WIRELESS-HWC-MIB", "wlanCPIntStatusCheckButton"), ("HIPATH-WIRELESS-HWC-MIB", "wlanCPRedirectURL"), ("HIPATH-WIRELESS-HWC-MIB", "apRadioProtocol"), ("HIPATH-WIRELESS-HWC-MIB", "apRadioNumber"), ("HIPATH-WIRELESS-HWC-MIB", "wlanCPReplaceIPwithFQDN"), ("HIPATH-WIRELESS-HWC-MIB", "wlanCPSendLoginTo"), ("HIPATH-WIRELESS-HWC-MIB", "wlanCPGuestAllowedLifetimeAcct"), ("HIPATH-WIRELESS-HWC-MIB", "wlanCPGuestIDPrefix"), ("HIPATH-WIRELESS-HWC-MIB", "wlanCPGuestMinPassLength"), ("HIPATH-WIRELESS-HWC-MIB", "wlanCPGuestMaxConcurrentSession"), ("HIPATH-WIRELESS-HWC-MIB", "wlanCPExtAddIPtoURL"), ("HIPATH-WIRELESS-HWC-MIB", "wlanCPUseHTTPSforConnection"), ("HIPATH-WIRELESS-HWC-MIB", "wlanCPIdentity"), ("HIPATH-WIRELESS-HWC-MIB", "wlanCPCustomSpecificURL"), ("HIPATH-WIRELESS-HWC-MIB", "wlanCPSelectionOption"), ("HIPATH-WIRELESS-HWC-MIB", "wlanCPExtEncryption"), ("HIPATH-WIRELESS-HWC-MIB", "radiusStrictMode"), ("HIPATH-WIRELESS-HWC-MIB", "advancedFilteringMode"), ("HIPATH-WIRELESS-HWC-MIB", "weakCipherEnable"), ("HIPATH-WIRELESS-HWC-MIB", "stationEventType"), ("HIPATH-WIRELESS-HWC-MIB", "stationMacAddress"), ("HIPATH-WIRELESS-HWC-MIB", "stationIPAddress"), ("HIPATH-WIRELESS-HWC-MIB", "stationAPName"), ("HIPATH-WIRELESS-HWC-MIB", "stationAPSSID"), ("HIPATH-WIRELESS-HWC-MIB", "stationDetailEvent"), ("HIPATH-WIRELESS-HWC-MIB", "stationRoamedAPName"), ("HIPATH-WIRELESS-HWC-MIB", "stationName"), ("HIPATH-WIRELESS-HWC-MIB", "stationBSSID"), ("HIPATH-WIRELESS-HWC-MIB", "stationEventTimeStamp"), ("HIPATH-WIRELESS-HWC-MIB", "stationIPv6Address1"), ("HIPATH-WIRELESS-HWC-MIB", "stationIPv6Address2"), ("HIPATH-WIRELESS-HWC-MIB", "stationIPv6Address3"), ("HIPATH-WIRELESS-HWC-MIB", "clientAutologinOption"), ("HIPATH-WIRELESS-HWC-MIB", "radiusMacAddressFormatOption"), ("HIPATH-WIRELESS-HWC-MIB", "wlanRadiusServerName"), ("HIPATH-WIRELESS-HWC-MIB", "wlanRadiusServerUse"), ("HIPATH-WIRELESS-HWC-MIB", "wlanRadiusServerUsage"), ("HIPATH-WIRELESS-HWC-MIB", "wlanRadiusServerAuthNASIP"), ("HIPATH-WIRELESS-HWC-MIB", "wlanRadiusServerAuthNASId"), ("HIPATH-WIRELESS-HWC-MIB", "wlanRadiusServerAuthAuthType"), ("HIPATH-WIRELESS-HWC-MIB", "wlanRadiusServerAcctNASIP"), ("HIPATH-WIRELESS-HWC-MIB", "wlanRadiusServerAcctNASId"), ("HIPATH-WIRELESS-HWC-MIB", "wlanRadiusServerAcctSIAR"), ("HIPATH-WIRELESS-HWC-MIB", "wlanRadiusServerMacNASIP"), ("HIPATH-WIRELESS-HWC-MIB", "wlanRadiusServerMacNASId"), ("HIPATH-WIRELESS-HWC-MIB", "wlanRadiusServerMacAuthType"), ("HIPATH-WIRELESS-HWC-MIB", "wlanRadiusServerMacPW"), ("HIPATH-WIRELESS-HWC-MIB", "wlanRadiusServerAuthUseVNSIPAddr"), ("HIPATH-WIRELESS-HWC-MIB", "wlanRadiusServerAuthUseVNSName"), ("HIPATH-WIRELESS-HWC-MIB", "wlanRadiusServerAcctUseVNSIPAddr"), ("HIPATH-WIRELESS-HWC-MIB", "wlanRadiusServerAcctUseVNSName"), ("HIPATH-WIRELESS-HWC-MIB", "wlanRadiusServerMacUseVNSIPAddr"), ("HIPATH-WIRELESS-HWC-MIB", "wlanRadiusServerMacUseVNSName")]]:
    if getattr(mibBuilder, 'version', 0) < (4, 4, 2):
        # WARNING: leading objects get lost here!
        hiPathWirelessHWCGroup = hiPathWirelessHWCGroup.setObjects(*_hiPathWirelessHWCGroup_obj)
    else:
        hiPathWirelessHWCGroup = hiPathWirelessHWCGroup.setObjects(*_hiPathWirelessHWCGroup_obj, **dict(append=True))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hiPathWirelessHWCGroup = hiPathWirelessHWCGroup.setStatus('current')
if mibBuilder.loadTexts: hiPathWirelessHWCGroup.setDescription('Conformance groups.')
hiPathWirelessHWCAlarms = NotificationGroup((1, 3, 6, 1, 4, 1, 4329, 15, 3, 30, 3)).setObjects(("HIPATH-WIRELESS-HWC-MIB", "hiPathWirelessLogAlarm"), ("HIPATH-WIRELESS-HWC-MIB", "stationEventAlarm"), ("HIPATH-WIRELESS-HWC-MIB", "apTunnelAlarm"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hiPathWirelessHWCAlarms = hiPathWirelessHWCAlarms.setStatus('current')
if mibBuilder.loadTexts: hiPathWirelessHWCAlarms.setDescription('Conformance information for the alarm groups.')
hiPathWirelessHWCObsolete = ObjectGroup((1, 3, 6, 1, 4, 1, 4329, 15, 3, 30, 4)).setObjects(("HIPATH-WIRELESS-HWC-MIB", "vnsWDSRFAPName"), ("HIPATH-WIRELESS-HWC-MIB", "vnsWDSRFbgService"), ("HIPATH-WIRELESS-HWC-MIB", "vnsWDSRFaService"), ("HIPATH-WIRELESS-HWC-MIB", "vnsWDSRFPreferredParent"), ("HIPATH-WIRELESS-HWC-MIB", "vnsWDSRFBackupParent"), ("HIPATH-WIRELESS-HWC-MIB", "vnsWDSRFBridge"), ("HIPATH-WIRELESS-HWC-MIB", "vnsRateControlProfInd"), ("HIPATH-WIRELESS-HWC-MIB", "vnsRateControlProfName"), ("HIPATH-WIRELESS-HWC-MIB", "vnsRateControlCIR"), ("HIPATH-WIRELESS-HWC-MIB", "vnsRateControlCBS"), ("HIPATH-WIRELESS-HWC-MIB", "vnsExceptionFiterName"), ("HIPATH-WIRELESS-HWC-MIB", "vnsExceptionStatPktsDenied"), ("HIPATH-WIRELESS-HWC-MIB", "vnsExceptionStatPktsAllowed"), ("HIPATH-WIRELESS-HWC-MIB", "vnsWDSStatAPName"), ("HIPATH-WIRELESS-HWC-MIB", "vnsWDSStatAPRole"), ("HIPATH-WIRELESS-HWC-MIB", "vnsWDSStatAPRadio"), ("HIPATH-WIRELESS-HWC-MIB", "vnsWDSStatAPParent"), ("HIPATH-WIRELESS-HWC-MIB", "vnsWDSStatSSID"), ("HIPATH-WIRELESS-HWC-MIB", "vnsWDSStatRxFrame"), ("HIPATH-WIRELESS-HWC-MIB", "vnsWDSStatTxFrame"), ("HIPATH-WIRELESS-HWC-MIB", "vnsWDSStatRxError"), ("HIPATH-WIRELESS-HWC-MIB", "vnsWDSStatTxError"), ("HIPATH-WIRELESS-HWC-MIB", "vnsWDSStatRxRSSI"), ("HIPATH-WIRELESS-HWC-MIB", "vnsWDSStatRxRate"), ("HIPATH-WIRELESS-HWC-MIB", "vnsAssignmentMode"), ("HIPATH-WIRELESS-HWC-MIB", "vnsParentIfIndex"), ("HIPATH-WIRELESS-HWC-MIB", "externalRadiusServerName"), ("HIPATH-WIRELESS-HWC-MIB", "externalRadiusServerAddress"), ("HIPATH-WIRELESS-HWC-MIB", "externalRadiusServerSharedSecret"), ("HIPATH-WIRELESS-HWC-MIB", "externalRadiusServerRowStatus"), ("HIPATH-WIRELESS-HWC-MIB", "cpLoginLabel"), ("HIPATH-WIRELESS-HWC-MIB", "cpPasswordLabel"), ("HIPATH-WIRELESS-HWC-MIB", "cpHeaderURL"), ("HIPATH-WIRELESS-HWC-MIB", "cpFooterURL"), ("HIPATH-WIRELESS-HWC-MIB", "cpMessage"), ("HIPATH-WIRELESS-HWC-MIB", "cpURL"), ("HIPATH-WIRELESS-HWC-MIB", "loadGroupLoadControl"), ("HIPATH-WIRELESS-HWC-MIB", "vnsWDSStatTxRate"), ("HIPATH-WIRELESS-HWC-MIB", "vnsRateControlProfile"), ("HIPATH-WIRELESS-HWC-MIB", "vnsStatName"), ("HIPATH-WIRELESS-HWC-MIB", "vnsStatTxPkts"), ("HIPATH-WIRELESS-HWC-MIB", "vnsStatRxPkts"), ("HIPATH-WIRELESS-HWC-MIB", "vnsStatTxOctects"), ("HIPATH-WIRELESS-HWC-MIB", "vnsStatRxOctects"), ("HIPATH-WIRELESS-HWC-MIB", "vnsStatMulticastTxPkts"), ("HIPATH-WIRELESS-HWC-MIB", "vnsStatMulticastRxPkts"), ("HIPATH-WIRELESS-HWC-MIB", "vnsStatBroadcastTxPkts"), ("HIPATH-WIRELESS-HWC-MIB", "vnsStatBroadcastRxPkts"), ("HIPATH-WIRELESS-HWC-MIB", "vnsStatRadiusTotRequests"), ("HIPATH-WIRELESS-HWC-MIB", "vnsStatRadiusReqFailed"), ("HIPATH-WIRELESS-HWC-MIB", "vnsStatRadiusReqRejected"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hiPathWirelessHWCObsolete = hiPathWirelessHWCObsolete.setStatus('obsolete')
if mibBuilder.loadTexts: hiPathWirelessHWCObsolete.setDescription('List of object that EWC does not anymore support.')
wirelessEWCGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 4329, 15, 3, 30, 5))
physicalPortsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 4329, 15, 3, 30, 5, 1)).setObjects(("HIPATH-WIRELESS-HWC-MIB", "portMgmtTrafficEnable"), ("HIPATH-WIRELESS-HWC-MIB", "portDuplexMode"), ("HIPATH-WIRELESS-HWC-MIB", "portFunction"), ("HIPATH-WIRELESS-HWC-MIB", "portName"), ("HIPATH-WIRELESS-HWC-MIB", "portIpAddress"), ("HIPATH-WIRELESS-HWC-MIB", "portMask"), ("HIPATH-WIRELESS-HWC-MIB", "portVlanID"), ("HIPATH-WIRELESS-HWC-MIB", "portDHCPEnable"), ("HIPATH-WIRELESS-HWC-MIB", "portDHCPGateway"), ("HIPATH-WIRELESS-HWC-MIB", "portDHCPDomain"), ("HIPATH-WIRELESS-HWC-MIB", "portDHCPDefaultLease"), ("HIPATH-WIRELESS-HWC-MIB", "portDHCPMaxLease"), ("HIPATH-WIRELESS-HWC-MIB", "portDHCPDnsServers"), ("HIPATH-WIRELESS-HWC-MIB", "portDHCPWins"), ("HIPATH-WIRELESS-HWC-MIB", "portEnabled"), ("HIPATH-WIRELESS-HWC-MIB", "portMacAddress"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    physicalPortsGroup = physicalPortsGroup.setStatus('deprecated')
if mibBuilder.loadTexts: physicalPortsGroup.setDescription('Physical ports and their attributes. ')
phyDHCPRangeGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 4329, 15, 3, 30, 5, 2)).setObjects(("HIPATH-WIRELESS-HWC-MIB", "phyDHCPRangeIndex"), ("HIPATH-WIRELESS-HWC-MIB", "phyDHCPRangeStart"), ("HIPATH-WIRELESS-HWC-MIB", "phyDHCPRangeEnd"), ("HIPATH-WIRELESS-HWC-MIB", "phyDHCPRangeType"), ("HIPATH-WIRELESS-HWC-MIB", "phyDHCPRangeStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    phyDHCPRangeGroup = phyDHCPRangeGroup.setStatus('deprecated')
if mibBuilder.loadTexts: phyDHCPRangeGroup.setDescription('DHCP objects and attributes associated to physical ports. ')
layerTwoPortGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 4329, 15, 3, 30, 5, 3)).setObjects(("HIPATH-WIRELESS-HWC-MIB", "layerTwoPortName"), ("HIPATH-WIRELESS-HWC-MIB", "layerTwoPortMacAddress"), ("HIPATH-WIRELESS-HWC-MIB", "layerTwoPortMgmtState"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    layerTwoPortGroup = layerTwoPortGroup.setStatus('current')
if mibBuilder.loadTexts: layerTwoPortGroup.setDescription('Collection of layer two ports objects.')
muGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 4329, 15, 3, 30, 5, 4)).setObjects(("HIPATH-WIRELESS-HWC-MIB", "muMACAddress"), ("HIPATH-WIRELESS-HWC-MIB", "muIPAddress"), ("HIPATH-WIRELESS-HWC-MIB", "muUser"), ("HIPATH-WIRELESS-HWC-MIB", "muState"), ("HIPATH-WIRELESS-HWC-MIB", "muAPSerialNo"), ("HIPATH-WIRELESS-HWC-MIB", "muVnsSSID"), ("HIPATH-WIRELESS-HWC-MIB", "muTxPackets"), ("HIPATH-WIRELESS-HWC-MIB", "muRxPackets"), ("HIPATH-WIRELESS-HWC-MIB", "muTxOctets"), ("HIPATH-WIRELESS-HWC-MIB", "muRxOctets"), ("HIPATH-WIRELESS-HWC-MIB", "muDuration"), ("HIPATH-WIRELESS-HWC-MIB", "muAPName"), ("HIPATH-WIRELESS-HWC-MIB", "muWLANID"), ("HIPATH-WIRELESS-HWC-MIB", "muConnectionProtocol"), ("HIPATH-WIRELESS-HWC-MIB", "muTopologyName"), ("HIPATH-WIRELESS-HWC-MIB", "muPolicyName"), ("HIPATH-WIRELESS-HWC-MIB", "muDefaultCoS"), ("HIPATH-WIRELESS-HWC-MIB", "muConnectionCapability"), ("HIPATH-WIRELESS-HWC-MIB", "muBSSIDMac"), ("HIPATH-WIRELESS-HWC-MIB", "muDot11ConnectionCapability"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    muGroup = muGroup.setStatus('current')
if mibBuilder.loadTexts: muGroup.setDescription('MU attributes associated to EWC.')
apStatsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 4329, 15, 3, 30, 5, 5)).setObjects(("HIPATH-WIRELESS-HWC-MIB", "apInUcastPkts"), ("HIPATH-WIRELESS-HWC-MIB", "apInNUcastPkts"), ("HIPATH-WIRELESS-HWC-MIB", "apInOctets"), ("HIPATH-WIRELESS-HWC-MIB", "apInErrors"), ("HIPATH-WIRELESS-HWC-MIB", "apInDiscards"), ("HIPATH-WIRELESS-HWC-MIB", "apOutUcastPkts"), ("HIPATH-WIRELESS-HWC-MIB", "apOutNUcastPkts"), ("HIPATH-WIRELESS-HWC-MIB", "apOutOctets"), ("HIPATH-WIRELESS-HWC-MIB", "apOutErrors"), ("HIPATH-WIRELESS-HWC-MIB", "apOutDiscards"), ("HIPATH-WIRELESS-HWC-MIB", "apUpTime"), ("HIPATH-WIRELESS-HWC-MIB", "apCredentialType"), ("HIPATH-WIRELESS-HWC-MIB", "apCertificateExpiry"), ("HIPATH-WIRELESS-HWC-MIB", "apStatsMuCounts"), ("HIPATH-WIRELESS-HWC-MIB", "apStatsSessionDuration"), ("HIPATH-WIRELESS-HWC-MIB", "apTotalStationsA"), ("HIPATH-WIRELESS-HWC-MIB", "apTotalStationsB"), ("HIPATH-WIRELESS-HWC-MIB", "apTotalStationsG"), ("HIPATH-WIRELESS-HWC-MIB", "apTotalStationsN50"), ("HIPATH-WIRELESS-HWC-MIB", "apTotalStationsN24"), ("HIPATH-WIRELESS-HWC-MIB", "apInvalidPolicyCount"), ("HIPATH-WIRELESS-HWC-MIB", "apInterfaceMTU"), ("HIPATH-WIRELESS-HWC-MIB", "apEffectiveTunnelMTU"), ("HIPATH-WIRELESS-HWC-MIB", "apTotalStationsAC"), ("HIPATH-WIRELESS-HWC-MIB", "apTotalStationsAInOctets"), ("HIPATH-WIRELESS-HWC-MIB", "apTotalStationsAOutOctets"), ("HIPATH-WIRELESS-HWC-MIB", "apTotalStationsBInOctets"), ("HIPATH-WIRELESS-HWC-MIB", "apTotalStationsBOutOctets"), ("HIPATH-WIRELESS-HWC-MIB", "apTotalStationsGInOctets"), ("HIPATH-WIRELESS-HWC-MIB", "apTotalStationsGOutOctets"), ("HIPATH-WIRELESS-HWC-MIB", "apTotalStationsN50InOctets"), ("HIPATH-WIRELESS-HWC-MIB", "apTotalStationsN50OutOctets"), ("HIPATH-WIRELESS-HWC-MIB", "apTotalStationsN24InOctets"), ("HIPATH-WIRELESS-HWC-MIB", "apTotalStationsN24OutOctets"), ("HIPATH-WIRELESS-HWC-MIB", "apTotalStationsACInOctets"), ("HIPATH-WIRELESS-HWC-MIB", "apTotalStationsACOutOctets"), ("HIPATH-WIRELESS-HWC-MIB", "apRadioStatusChannel"), ("HIPATH-WIRELESS-HWC-MIB", "apRadioStatusChannelWidth"), ("HIPATH-WIRELESS-HWC-MIB", "apRadioStatusChannelOffset"), ("HIPATH-WIRELESS-HWC-MIB", "apPerfRadioPrevPeakChannelUtilization"), ("HIPATH-WIRELESS-HWC-MIB", "apPerfRadioCurPeakChannelUtilization"), ("HIPATH-WIRELESS-HWC-MIB", "apPerfRadioAverageChannelUtilization"), ("HIPATH-WIRELESS-HWC-MIB", "apPerfRadioCurrentChannelUtilization"), ("HIPATH-WIRELESS-HWC-MIB", "apPerfRadioPrevPeakRSS"), ("HIPATH-WIRELESS-HWC-MIB", "apPerfRadioCurPeakRSS"), ("HIPATH-WIRELESS-HWC-MIB", "apPerfRadioAverageRSS"), ("HIPATH-WIRELESS-HWC-MIB", "apPerfRadioCurrentRSS"), ("HIPATH-WIRELESS-HWC-MIB", "apPerfRadioPrevPeakSNR"), ("HIPATH-WIRELESS-HWC-MIB", "apPerfRadioCurPeakSNR"), ("HIPATH-WIRELESS-HWC-MIB", "apPerfRadioAverageSNR"), ("HIPATH-WIRELESS-HWC-MIB", "apPerfRadioCurrentSNR"), ("HIPATH-WIRELESS-HWC-MIB", "apPerfRadioPrevPeakPktRetx"), ("HIPATH-WIRELESS-HWC-MIB", "apPerfRadioCurPeakPktRetx"), ("HIPATH-WIRELESS-HWC-MIB", "apPerfRadioAveragePktRetx"), ("HIPATH-WIRELESS-HWC-MIB", "apPerfRadioCurrentPktRetx"), ("HIPATH-WIRELESS-HWC-MIB", "apPerfRadioPktRetx"), ("HIPATH-WIRELESS-HWC-MIB", "apAccPrevPeakAssocReqRx"), ("HIPATH-WIRELESS-HWC-MIB", "apAccCurPeakAssocReqRx"), ("HIPATH-WIRELESS-HWC-MIB", "apAccAverageAssocReqRx"), ("HIPATH-WIRELESS-HWC-MIB", "apAccCurrentAssocReqRx"), ("HIPATH-WIRELESS-HWC-MIB", "apAccAssocReqRx"), ("HIPATH-WIRELESS-HWC-MIB", "apAccPrevPeakReassocReqRx"), ("HIPATH-WIRELESS-HWC-MIB", "apAccCurPeakReassocReqRx"), ("HIPATH-WIRELESS-HWC-MIB", "apAccAverageReassocReqRx"), ("HIPATH-WIRELESS-HWC-MIB", "apAccCurrentReassocReqRx"), ("HIPATH-WIRELESS-HWC-MIB", "apAccReassocReqRx"), ("HIPATH-WIRELESS-HWC-MIB", "apAccPrevPeakDisassocDeauthReqTx"), ("HIPATH-WIRELESS-HWC-MIB", "apAccCurPeakDisassocDeauthReqTx"), ("HIPATH-WIRELESS-HWC-MIB", "apAccAverageDisassocDeauthReqTx"), ("HIPATH-WIRELESS-HWC-MIB", "apAccCurrentDisassocDeauthReqTx"), ("HIPATH-WIRELESS-HWC-MIB", "apAccDisassocDeauthReqTx"), ("HIPATH-WIRELESS-HWC-MIB", "apAccPrevPeakDisassocDeauthReqRx"), ("HIPATH-WIRELESS-HWC-MIB", "apAccCurPeakDisassocDeauthReqRx"), ("HIPATH-WIRELESS-HWC-MIB", "apAccAverageDisassocDeauthReqRx"), ("HIPATH-WIRELESS-HWC-MIB", "apAccCurrentDisassocDeauthReqRx"), ("HIPATH-WIRELESS-HWC-MIB", "apAccDisassocDeauthReqRx"), ("HIPATH-WIRELESS-HWC-MIB", "apPerfWlanPrevPeakClientsPerSec"), ("HIPATH-WIRELESS-HWC-MIB", "apPerfWlanCurPeakClientsPerSec"), ("HIPATH-WIRELESS-HWC-MIB", "apPerfWlanAverageClientsPerSec"), ("HIPATH-WIRELESS-HWC-MIB", "apPerfWlanCurrentClientsPerSec"), ("HIPATH-WIRELESS-HWC-MIB", "apPerfWlanPrevPeakULOctetsPerSec"), ("HIPATH-WIRELESS-HWC-MIB", "apPerfWlanCurPeakULOctetsPerSec"), ("HIPATH-WIRELESS-HWC-MIB", "apPerfWlanAverageULOctetsPerSec"), ("HIPATH-WIRELESS-HWC-MIB", "apPerfWlanCurrentULOctetsPerSec"), ("HIPATH-WIRELESS-HWC-MIB", "apPerfWlanULOctets"), ("HIPATH-WIRELESS-HWC-MIB", "apPerfWlanPrevPeakULPktsPerSec"), ("HIPATH-WIRELESS-HWC-MIB", "apPerfWlanCurPeakULPktsPerSec"), ("HIPATH-WIRELESS-HWC-MIB", "apPerfWlanAverageULPktsPerSec"), ("HIPATH-WIRELESS-HWC-MIB", "apPerfWlanCurrentULPktsPerSec"), ("HIPATH-WIRELESS-HWC-MIB", "apPerfWlanULPkts"), ("HIPATH-WIRELESS-HWC-MIB", "apPerfWlanPrevPeakDLOctetsPerSec"), ("HIPATH-WIRELESS-HWC-MIB", "apPerfWlanCurPeakDLOctetsPerSec"), ("HIPATH-WIRELESS-HWC-MIB", "apPerfWlanAverageDLOctetsPerSec"), ("HIPATH-WIRELESS-HWC-MIB", "apPerfWlanCurrentDLOctetsPerSec"), ("HIPATH-WIRELESS-HWC-MIB", "apPerfWlanDLOctets"), ("HIPATH-WIRELESS-HWC-MIB", "apPerfWlanPrevPeakDLPktsPerSec"), ("HIPATH-WIRELESS-HWC-MIB", "apPerfWlanCurPeakDLPktsPerSec"), ("HIPATH-WIRELESS-HWC-MIB", "apPerfWlanAverageDLPktsPerSec"), ("HIPATH-WIRELESS-HWC-MIB", "apPerfWlanCurrentDLPktsPerSec"), ("HIPATH-WIRELESS-HWC-MIB", "apPerfWlanDLPkts"), ("HIPATH-WIRELESS-HWC-MIB", "apChnlUtilPrevPeakUtilization"), ("HIPATH-WIRELESS-HWC-MIB", "apChnlUtilCurPeakUtilization"), ("HIPATH-WIRELESS-HWC-MIB", "apChnlUtilAverageUtilization"), ("HIPATH-WIRELESS-HWC-MIB", "apChnlUtilCurrentUtilization"), ("HIPATH-WIRELESS-HWC-MIB", "nearbyApInfo"), ("HIPATH-WIRELESS-HWC-MIB", "nearbyApBSSID"), ("HIPATH-WIRELESS-HWC-MIB", "nearbyApChannel"), ("HIPATH-WIRELESS-HWC-MIB", "nearbyApRSS"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    apStatsGroup = apStatsGroup.setStatus('current')
if mibBuilder.loadTexts: apStatsGroup.setDescription('Collection of objects and attributes related to AP statistics.')
muACLGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 4329, 15, 3, 30, 5, 6)).setObjects(("HIPATH-WIRELESS-HWC-MIB", "muACLRowStatus"), ("HIPATH-WIRELESS-HWC-MIB", "muACLMACAddress"), ("HIPATH-WIRELESS-HWC-MIB", "muACLType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    muACLGroup = muACLGroup.setStatus('current')
if mibBuilder.loadTexts: muACLGroup.setDescription('List of objects for creation of blacklist/whitelist.')
siteGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 4329, 15, 3, 30, 5, 7)).setObjects(("HIPATH-WIRELESS-HWC-MIB", "siteID"), ("HIPATH-WIRELESS-HWC-MIB", "siteName"), ("HIPATH-WIRELESS-HWC-MIB", "siteLocalRadiusAuthentication"), ("HIPATH-WIRELESS-HWC-MIB", "siteDefaultDNSServer"), ("HIPATH-WIRELESS-HWC-MIB", "siteMaxEntries"), ("HIPATH-WIRELESS-HWC-MIB", "siteNumEntries"), ("HIPATH-WIRELESS-HWC-MIB", "siteTableNextAvailableIndex"), ("HIPATH-WIRELESS-HWC-MIB", "siteEnableSecureTunnel"), ("HIPATH-WIRELESS-HWC-MIB", "siteReplaceStnIDwithSiteName"), ("HIPATH-WIRELESS-HWC-MIB", "siteRowStatus"), ("HIPATH-WIRELESS-HWC-MIB", "siteEncryptCommAPtoController"), ("HIPATH-WIRELESS-HWC-MIB", "siteEncryptCommBetweenAPs"), ("HIPATH-WIRELESS-HWC-MIB", "siteBandPreferenceEnable"), ("HIPATH-WIRELESS-HWC-MIB", "siteLoadControlEnableR1"), ("HIPATH-WIRELESS-HWC-MIB", "siteLoadControlEnableR2"), ("HIPATH-WIRELESS-HWC-MIB", "siteMaxClientR1"), ("HIPATH-WIRELESS-HWC-MIB", "siteMaxClientR2"), ("HIPATH-WIRELESS-HWC-MIB", "siteStrictLimitEnableR1"), ("HIPATH-WIRELESS-HWC-MIB", "siteStrictLimitEnableR2"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    siteGroup = siteGroup.setStatus('current')
if mibBuilder.loadTexts: siteGroup.setDescription('A collection of objects providing Site creation and its attributes.')
sitePolicyGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 4329, 15, 3, 30, 5, 8)).setObjects(("HIPATH-WIRELESS-HWC-MIB", "sitePolicyMember"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    sitePolicyGroup = sitePolicyGroup.setStatus('current')
if mibBuilder.loadTexts: sitePolicyGroup.setDescription('Objects defining the association of policies to sites.')
siteCosGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 4329, 15, 3, 30, 5, 9)).setObjects(("HIPATH-WIRELESS-HWC-MIB", "siteCoSMember"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    siteCosGroup = siteCosGroup.setStatus('current')
if mibBuilder.loadTexts: siteCosGroup.setDescription('Objects defining the association of policies to sites.')
siteAPGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 4329, 15, 3, 30, 5, 10)).setObjects(("HIPATH-WIRELESS-HWC-MIB", "siteAPMember"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    siteAPGroup = siteAPGroup.setStatus('current')
if mibBuilder.loadTexts: siteAPGroup.setDescription('Objects defining the association of policies to sites.')
siteWlanGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 4329, 15, 3, 30, 5, 11)).setObjects(("HIPATH-WIRELESS-HWC-MIB", "siteWlanApRadioAssigned"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    siteWlanGroup = siteWlanGroup.setStatus('current')
if mibBuilder.loadTexts: siteWlanGroup.setDescription('Objects defining the association of policies to sites.')
apGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 4329, 15, 3, 30, 5, 12)).setObjects(("HIPATH-WIRELESS-HWC-MIB", "apIndex"), ("HIPATH-WIRELESS-HWC-MIB", "apName"), ("HIPATH-WIRELESS-HWC-MIB", "apDesc"), ("HIPATH-WIRELESS-HWC-MIB", "apSerialNumber"), ("HIPATH-WIRELESS-HWC-MIB", "apPortifIndex"), ("HIPATH-WIRELESS-HWC-MIB", "apWiredIfIndex"), ("HIPATH-WIRELESS-HWC-MIB", "apSoftwareVersion"), ("HIPATH-WIRELESS-HWC-MIB", "apSpecific"), ("HIPATH-WIRELESS-HWC-MIB", "apBroadcastDisassociate"), ("HIPATH-WIRELESS-HWC-MIB", "apRowStatus"), ("HIPATH-WIRELESS-HWC-MIB", "apVlanID"), ("HIPATH-WIRELESS-HWC-MIB", "apIpAssignmentType"), ("HIPATH-WIRELESS-HWC-MIB", "apIfMAC"), ("HIPATH-WIRELESS-HWC-MIB", "apHwVersion"), ("HIPATH-WIRELESS-HWC-MIB", "apSwVersion"), ("HIPATH-WIRELESS-HWC-MIB", "apEnvironment"), ("HIPATH-WIRELESS-HWC-MIB", "apHome"), ("HIPATH-WIRELESS-HWC-MIB", "apRole"), ("HIPATH-WIRELESS-HWC-MIB", "apState"), ("HIPATH-WIRELESS-HWC-MIB", "apStatus"), ("HIPATH-WIRELESS-HWC-MIB", "apPollTimeout"), ("HIPATH-WIRELESS-HWC-MIB", "apPollInterval"), ("HIPATH-WIRELESS-HWC-MIB", "apTelnetAccess"), ("HIPATH-WIRELESS-HWC-MIB", "apMaintainClientSession"), ("HIPATH-WIRELESS-HWC-MIB", "apRestartServiceContAbsent"), ("HIPATH-WIRELESS-HWC-MIB", "apHostname"), ("HIPATH-WIRELESS-HWC-MIB", "apLocation"), ("HIPATH-WIRELESS-HWC-MIB", "apStaticMTUsize"), ("HIPATH-WIRELESS-HWC-MIB", "apSiteID"), ("HIPATH-WIRELESS-HWC-MIB", "apZone"), ("HIPATH-WIRELESS-HWC-MIB", "apLLDP"), ("HIPATH-WIRELESS-HWC-MIB", "apLEDMode"), ("HIPATH-WIRELESS-HWC-MIB", "apLocationbasedService"), ("HIPATH-WIRELESS-HWC-MIB", "apSecureTunnel"), ("HIPATH-WIRELESS-HWC-MIB", "apEncryptCntTraffic"), ("HIPATH-WIRELESS-HWC-MIB", "apIpAddress"), ("HIPATH-WIRELESS-HWC-MIB", "apMICErrorWarning"), ("HIPATH-WIRELESS-HWC-MIB", "apIPAddress"), ("HIPATH-WIRELESS-HWC-MIB", "apSecureDataTunnelType"), ("HIPATH-WIRELESS-HWC-MIB", "apIPMulticastAssembly"), ("HIPATH-WIRELESS-HWC-MIB", "apSSHConnection"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    apGroup = apGroup.setStatus('current')
if mibBuilder.loadTexts: apGroup.setDescription('List of objects defining configuration attributes of an AP.')
wlanGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 4329, 15, 3, 30, 5, 13)).setObjects(("HIPATH-WIRELESS-HWC-MIB", "wlanID"), ("HIPATH-WIRELESS-HWC-MIB", "wlanRowStatus"), ("HIPATH-WIRELESS-HWC-MIB", "wlanServiceType"), ("HIPATH-WIRELESS-HWC-MIB", "wlanName"), ("HIPATH-WIRELESS-HWC-MIB", "wlanSSID"), ("HIPATH-WIRELESS-HWC-MIB", "wlanSynchronize"), ("HIPATH-WIRELESS-HWC-MIB", "wlanEnabled"), ("HIPATH-WIRELESS-HWC-MIB", "wlanDefaultTopologyID"), ("HIPATH-WIRELESS-HWC-MIB", "wlanSessionTimeout"), ("HIPATH-WIRELESS-HWC-MIB", "wlanIdleTimeoutPreAuth"), ("HIPATH-WIRELESS-HWC-MIB", "wlanIdleSessionPostAuth"), ("HIPATH-WIRELESS-HWC-MIB", "wlanSupressSSID"), ("HIPATH-WIRELESS-HWC-MIB", "wlanDot11hSupport"), ("HIPATH-WIRELESS-HWC-MIB", "wlanDot11hClientPowerReduction"), ("HIPATH-WIRELESS-HWC-MIB", "wlanProcessClientIE"), ("HIPATH-WIRELESS-HWC-MIB", "wlanEngerySaveMode"), ("HIPATH-WIRELESS-HWC-MIB", "wlanBlockMuToMuTraffic"), ("HIPATH-WIRELESS-HWC-MIB", "wlanRemoteable"), ("HIPATH-WIRELESS-HWC-MIB", "wlanVNSID"), ("HIPATH-WIRELESS-HWC-MIB", "wlanMaxEntries"), ("HIPATH-WIRELESS-HWC-MIB", "wlanRadioManagement11k"), ("HIPATH-WIRELESS-HWC-MIB", "wlanBeaconReport"), ("HIPATH-WIRELESS-HWC-MIB", "wlanQuietIE"), ("HIPATH-WIRELESS-HWC-MIB", "wlanMirrorN"), ("HIPATH-WIRELESS-HWC-MIB", "wlanNetFlow"), ("HIPATH-WIRELESS-HWC-MIB", "wlanAppVisibility"), ("HIPATH-WIRELESS-HWC-MIB", "wlanNumEntries"), ("HIPATH-WIRELESS-HWC-MIB", "wlanTableNextAvailableIndex"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    wlanGroup = wlanGroup.setStatus('current')
if mibBuilder.loadTexts: wlanGroup.setDescription('List of objects defining configuration attributes of a WLAN.')
wlanStatsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 4329, 15, 3, 30, 5, 14)).setObjects(("HIPATH-WIRELESS-HWC-MIB", "wlanStatsAssociatedClients"), ("HIPATH-WIRELESS-HWC-MIB", "wlanStatsRadiusTotRequests"), ("HIPATH-WIRELESS-HWC-MIB", "wlanStatsRadiusReqFailed"), ("HIPATH-WIRELESS-HWC-MIB", "wlanStatsRadiusReqRejected"), ("HIPATH-WIRELESS-HWC-MIB", "wlanStatsID"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    wlanStatsGroup = wlanStatsGroup.setStatus('current')
if mibBuilder.loadTexts: wlanStatsGroup.setDescription('List of objects defining configuration attributes of a WLAN.')
topologyGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 4329, 15, 3, 30, 5, 15)).setObjects(("HIPATH-WIRELESS-HWC-MIB", "topologyName"), ("HIPATH-WIRELESS-HWC-MIB", "topologyMode"), ("HIPATH-WIRELESS-HWC-MIB", "topologyTagged"), ("HIPATH-WIRELESS-HWC-MIB", "topologyVlanID"), ("HIPATH-WIRELESS-HWC-MIB", "topologyEgressPort"), ("HIPATH-WIRELESS-HWC-MIB", "topologyLayer3"), ("HIPATH-WIRELESS-HWC-MIB", "topologyIPAddress"), ("HIPATH-WIRELESS-HWC-MIB", "topologyIPMask"), ("HIPATH-WIRELESS-HWC-MIB", "topologyMTUsize"), ("HIPATH-WIRELESS-HWC-MIB", "topologyGateway"), ("HIPATH-WIRELESS-HWC-MIB", "topologyDHCPUsage"), ("HIPATH-WIRELESS-HWC-MIB", "topologyAPRegistration"), ("HIPATH-WIRELESS-HWC-MIB", "topologyManagementTraffic"), ("HIPATH-WIRELESS-HWC-MIB", "topologySynchronize"), ("HIPATH-WIRELESS-HWC-MIB", "topologySyncGateway"), ("HIPATH-WIRELESS-HWC-MIB", "topologySyncMask"), ("HIPATH-WIRELESS-HWC-MIB", "topologySyncIPStart"), ("HIPATH-WIRELESS-HWC-MIB", "topologySyncIPEnd"), ("HIPATH-WIRELESS-HWC-MIB", "topologyStaticIPv6Address"), ("HIPATH-WIRELESS-HWC-MIB", "topologyLinkLocalIPv6Address"), ("HIPATH-WIRELESS-HWC-MIB", "topologyPreFixLength"), ("HIPATH-WIRELESS-HWC-MIB", "topologyIPv6Gateway"), ("HIPATH-WIRELESS-HWC-MIB", "topologyDynamicEgress"), ("HIPATH-WIRELESS-HWC-MIB", "topologyIsGroup"), ("HIPATH-WIRELESS-HWC-MIB", "topologyGroupMembers"), ("HIPATH-WIRELESS-HWC-MIB", "topologyMemberId"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    topologyGroup = topologyGroup.setStatus('current')
if mibBuilder.loadTexts: topologyGroup.setDescription('List of objects defining configuration attributes of a WLAN.')
topologyStatGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 4329, 15, 3, 30, 5, 16)).setObjects(("HIPATH-WIRELESS-HWC-MIB", "topologyName"), ("HIPATH-WIRELESS-HWC-MIB", "topoStatName"), ("HIPATH-WIRELESS-HWC-MIB", "topoStatTxPkts"), ("HIPATH-WIRELESS-HWC-MIB", "topoStatRxPkts"), ("HIPATH-WIRELESS-HWC-MIB", "topoStatTxOctets"), ("HIPATH-WIRELESS-HWC-MIB", "topoStatRxOctets"), ("HIPATH-WIRELESS-HWC-MIB", "topoStatMulticastTxPkts"), ("HIPATH-WIRELESS-HWC-MIB", "topoStatMulticastRxPkts"), ("HIPATH-WIRELESS-HWC-MIB", "topoStatBroadcastTxPkts"), ("HIPATH-WIRELESS-HWC-MIB", "topoStatBroadcastRxPkts"), ("HIPATH-WIRELESS-HWC-MIB", "topoStatFrameChkSeqErrors"), ("HIPATH-WIRELESS-HWC-MIB", "topoStatFrameTooLongErrors"), ("HIPATH-WIRELESS-HWC-MIB", "topoWireStatName"), ("HIPATH-WIRELESS-HWC-MIB", "topoWireStatTxPkts"), ("HIPATH-WIRELESS-HWC-MIB", "topoWireStatRxPkts"), ("HIPATH-WIRELESS-HWC-MIB", "topoWireStatTxOctets"), ("HIPATH-WIRELESS-HWC-MIB", "topoWireStatRxOctets"), ("HIPATH-WIRELESS-HWC-MIB", "topoWireStatMulticastTxPkts"), ("HIPATH-WIRELESS-HWC-MIB", "topoWireStatMulticastRxPkts"), ("HIPATH-WIRELESS-HWC-MIB", "topoWireStatBroadcastTxPkts"), ("HIPATH-WIRELESS-HWC-MIB", "topoWireStatBroadcastRxPkts"), ("HIPATH-WIRELESS-HWC-MIB", "topoWireStatFrameChkSeqErrors"), ("HIPATH-WIRELESS-HWC-MIB", "topoWireStatFrameTooLongErrors"), ("HIPATH-WIRELESS-HWC-MIB", "topoCompleteStatName"), ("HIPATH-WIRELESS-HWC-MIB", "topoCompleteStatTxPkts"), ("HIPATH-WIRELESS-HWC-MIB", "topoCompleteStatRxPkts"), ("HIPATH-WIRELESS-HWC-MIB", "topoCompleteStatTxOctets"), ("HIPATH-WIRELESS-HWC-MIB", "topoCompleteStatRxOctets"), ("HIPATH-WIRELESS-HWC-MIB", "topoCompleteStatMulticastTxPkts"), ("HIPATH-WIRELESS-HWC-MIB", "topoCompleteStatMulticastRxPkts"), ("HIPATH-WIRELESS-HWC-MIB", "topoCompleteStatBroadcastTxPkts"), ("HIPATH-WIRELESS-HWC-MIB", "topoCompleteStatBroadcastRxPkts"), ("HIPATH-WIRELESS-HWC-MIB", "topoCompleteStatFrameChkSeqErrors"), ("HIPATH-WIRELESS-HWC-MIB", "topoCompleteStatFrameTooLongErrors"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    topologyStatGroup = topologyStatGroup.setStatus('current')
if mibBuilder.loadTexts: topologyStatGroup.setDescription('List of objects for defining topology statics. ')
loadGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 4329, 15, 3, 30, 5, 17)).setObjects(("HIPATH-WIRELESS-HWC-MIB", "loadGroupID"), ("HIPATH-WIRELESS-HWC-MIB", "loadGroupName"), ("HIPATH-WIRELESS-HWC-MIB", "loadGroupType"), ("HIPATH-WIRELESS-HWC-MIB", "loadGroupBandPreference"), ("HIPATH-WIRELESS-HWC-MIB", "loadGroupClientCountRadio1"), ("HIPATH-WIRELESS-HWC-MIB", "loadGroupClientCountRadio2"), ("HIPATH-WIRELESS-HWC-MIB", "loadGroupLoadControlEnableR1"), ("HIPATH-WIRELESS-HWC-MIB", "loadGroupLoadControlEnableR2"), ("HIPATH-WIRELESS-HWC-MIB", "loadGroupLoadControlStrictLimitR1"), ("HIPATH-WIRELESS-HWC-MIB", "loadGroupLoadControlStrictLimitR2"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    loadGroup = loadGroup.setStatus('current')
if mibBuilder.loadTexts: loadGroup.setDescription('A collection of objects providing Load Group creation and its attributes.')
widsWipsObjectsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 4329, 15, 3, 30, 5, 18)).setObjects(("HIPATH-WIRELESS-HWC-MIB", "mitigatorAnalysisEngine"), ("HIPATH-WIRELESS-HWC-MIB", "activeThreatsCounts"), ("HIPATH-WIRELESS-HWC-MIB", "uncategorizedAPCounts"), ("HIPATH-WIRELESS-HWC-MIB", "friendlyAPCounts"), ("HIPATH-WIRELESS-HWC-MIB", "scanGroupMaxEntries"), ("HIPATH-WIRELESS-HWC-MIB", "scanGroupsCurrentEntries"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    widsWipsObjectsGroup = widsWipsObjectsGroup.setStatus('current')
if mibBuilder.loadTexts: widsWipsObjectsGroup.setDescription('Objects defining the state of WIDS-WIPS for the controller.')
widsWipsEngineGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 4329, 15, 3, 30, 5, 19)).setObjects(("HIPATH-WIRELESS-HWC-MIB", "widsWipsEngineRowStatus"), ("HIPATH-WIRELESS-HWC-MIB", "widsWipsEngineControllerIPAddress"), ("HIPATH-WIRELESS-HWC-MIB", "widsWipsEnginePollInterval"), ("HIPATH-WIRELESS-HWC-MIB", "widsWipsEnginePollRetry"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    widsWipsEngineGroup = widsWipsEngineGroup.setStatus('current')
if mibBuilder.loadTexts: widsWipsEngineGroup.setDescription('Set of objects defining attributes of a WIDS-WIPS engine.')
outOfServiceScanGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 4329, 15, 3, 30, 5, 20)).setObjects(("HIPATH-WIRELESS-HWC-MIB", "outOfSrvScanGrpName"), ("HIPATH-WIRELESS-HWC-MIB", "outOfSrvScanGrpRadio"), ("HIPATH-WIRELESS-HWC-MIB", "outOfSrvScanGrpChannelList"), ("HIPATH-WIRELESS-HWC-MIB", "outOfSrvScanGrpScanType"), ("HIPATH-WIRELESS-HWC-MIB", "outOfSrvScanGrpChannelDwellTime"), ("HIPATH-WIRELESS-HWC-MIB", "outOfSrvScanGrpScanTimeInterval"), ("HIPATH-WIRELESS-HWC-MIB", "outOfSrvScanGrpSecurityScan"), ("HIPATH-WIRELESS-HWC-MIB", "outOfSrvScanGrpScanActivity"), ("HIPATH-WIRELESS-HWC-MIB", "outOfSrvScanGrpScanRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    outOfServiceScanGroup = outOfServiceScanGroup.setStatus('current')
if mibBuilder.loadTexts: outOfServiceScanGroup.setDescription('List of objects for defining out-of-service scan group.')
inServiceScanGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 4329, 15, 3, 30, 5, 21)).setObjects(("HIPATH-WIRELESS-HWC-MIB", "inSrvScanGrpName"), ("HIPATH-WIRELESS-HWC-MIB", "inSrvScanGrpMaxConcurrentAttacksPerAP"), ("HIPATH-WIRELESS-HWC-MIB", "inSrvScanGrpCounterMeasuresType"), ("HIPATH-WIRELESS-HWC-MIB", "inSrvScanGrpScan2400MHzSelection"), ("HIPATH-WIRELESS-HWC-MIB", "inSrvScanGrpScan5GHzSelection"), ("HIPATH-WIRELESS-HWC-MIB", "inSrvScanGrpRowStatus"), ("HIPATH-WIRELESS-HWC-MIB", "inSrvScanGrpSecurityThreats"), ("HIPATH-WIRELESS-HWC-MIB", "inSrvScanGrpblockAdHocClientsPeriod"), ("HIPATH-WIRELESS-HWC-MIB", "inSrvScanGrpClassifySourceIF"), ("HIPATH-WIRELESS-HWC-MIB", "inSrvScanGrpDetectRogueAP"), ("HIPATH-WIRELESS-HWC-MIB", "inSrvScanGrpListeningPort"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    inServiceScanGroup = inServiceScanGroup.setStatus('current')
if mibBuilder.loadTexts: inServiceScanGroup.setDescription('List of objects for defining in-service scan group.')
scanGroupAPAssignmentGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 4329, 15, 3, 30, 5, 22)).setObjects(("HIPATH-WIRELESS-HWC-MIB", "scanGroupAPAssignApSerial"), ("HIPATH-WIRELESS-HWC-MIB", "scanGroupAPAssignName"), ("HIPATH-WIRELESS-HWC-MIB", "scanGroupAPAssignRadio1"), ("HIPATH-WIRELESS-HWC-MIB", "scanGroupAPAssignRadio2"), ("HIPATH-WIRELESS-HWC-MIB", "scanGroupAPAssignInactiveAP"), ("HIPATH-WIRELESS-HWC-MIB", "scanGroupAPAssignAllowScanning"), ("HIPATH-WIRELESS-HWC-MIB", "scanGroupAPAssignGroupName"), ("HIPATH-WIRELESS-HWC-MIB", "scanGroupAPAssignAllowSpectrumAnalysis"), ("HIPATH-WIRELESS-HWC-MIB", "scanGroupAPAssignControllerIPAddress"), ("HIPATH-WIRELESS-HWC-MIB", "scanGroupAPAssignFordwardingService"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    scanGroupAPAssignmentGroup = scanGroupAPAssignmentGroup.setStatus('current')
if mibBuilder.loadTexts: scanGroupAPAssignmentGroup.setDescription('List of objects for assignment of AP to scan group.')
scanAPGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 4329, 15, 3, 30, 5, 23)).setObjects(("HIPATH-WIRELESS-HWC-MIB", "scanAPSerialNumber"), ("HIPATH-WIRELESS-HWC-MIB", "scanAPControllerIPAddress"), ("HIPATH-WIRELESS-HWC-MIB", "scanAPRowStatus"), ("HIPATH-WIRELESS-HWC-MIB", "scanAPAcessPointName"), ("HIPATH-WIRELESS-HWC-MIB", "scanAPProfileName"), ("HIPATH-WIRELESS-HWC-MIB", "scanAPProfileType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    scanAPGroup = scanAPGroup.setStatus('current')
if mibBuilder.loadTexts: scanAPGroup.setDescription('List of objects for defining AP scan groups in EWC.')
friendlyAPGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 4329, 15, 3, 30, 5, 24)).setObjects(("HIPATH-WIRELESS-HWC-MIB", "friendlyAPMacAddress"), ("HIPATH-WIRELESS-HWC-MIB", "friendlyAPSSID"), ("HIPATH-WIRELESS-HWC-MIB", "friendlyAPDescription"), ("HIPATH-WIRELESS-HWC-MIB", "friendlyAPManufacturer"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    friendlyAPGroup = friendlyAPGroup.setStatus('current')
if mibBuilder.loadTexts: friendlyAPGroup.setDescription('List of objects defining friendly APs identified during scanning time.')
wlanSecurityReportGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 4329, 15, 3, 30, 5, 25)).setObjects(("HIPATH-WIRELESS-HWC-MIB", "wlanSecurityReportFlag"), ("HIPATH-WIRELESS-HWC-MIB", "wlanSecurityReportUnsecureType"), ("HIPATH-WIRELESS-HWC-MIB", "wlanSecurityReportNotes"), ("HIPATH-WIRELESS-HWC-MIB", "wlanUnsecuredWlanCounts"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    wlanSecurityReportGroup = wlanSecurityReportGroup.setStatus('current')
if mibBuilder.loadTexts: wlanSecurityReportGroup.setDescription('Set of objects defining attributes of security group report.')
apAntennaGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 4329, 15, 3, 30, 5, 26)).setObjects(("HIPATH-WIRELESS-HWC-MIB", "apAntennanName"), ("HIPATH-WIRELESS-HWC-MIB", "apAntennaType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    apAntennaGroup = apAntennaGroup.setStatus('current')
if mibBuilder.loadTexts: apAntennaGroup.setDescription('A collection of objects defining an antenna attributes for an AP.')
muAccessListGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 4329, 15, 3, 30, 5, 27)).setObjects(("HIPATH-WIRELESS-HWC-MIB", "muAccessListMACAddress"), ("HIPATH-WIRELESS-HWC-MIB", "muAccessListBitmaskLength"), ("HIPATH-WIRELESS-HWC-MIB", "muAccessListRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    muAccessListGroup = muAccessListGroup.setStatus('current')
if mibBuilder.loadTexts: muAccessListGroup.setDescription('List of objects for creation of MU access list to block MU access, case of black list, or allow access, case of white list to wireless controller resources.')
activeThreatGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 4329, 15, 3, 30, 5, 28)).setObjects(("HIPATH-WIRELESS-HWC-MIB", "activeThreatCategory"), ("HIPATH-WIRELESS-HWC-MIB", "activeThreatDeviceMAC"), ("HIPATH-WIRELESS-HWC-MIB", "activeThreatDateTime"), ("HIPATH-WIRELESS-HWC-MIB", "activeThreatCounterMeasure"), ("HIPATH-WIRELESS-HWC-MIB", "activeThreatAPName"), ("HIPATH-WIRELESS-HWC-MIB", "activeThreatRSS"), ("HIPATH-WIRELESS-HWC-MIB", "activeThreatExtraDetails"), ("HIPATH-WIRELESS-HWC-MIB", "activeThreatThreat"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    activeThreatGroup = activeThreatGroup.setStatus('current')
if mibBuilder.loadTexts: activeThreatGroup.setDescription('List of objects defining a discovered security threat.')
countermeasureAPGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 4329, 15, 3, 30, 5, 29)).setObjects(("HIPATH-WIRELESS-HWC-MIB", "countermeasureAPName"), ("HIPATH-WIRELESS-HWC-MIB", "countermeasureAPThreatCategory"), ("HIPATH-WIRELESS-HWC-MIB", "countermeasureAPCountermeasure"), ("HIPATH-WIRELESS-HWC-MIB", "countermeasureAPTime"), ("HIPATH-WIRELESS-HWC-MIB", "countermeasureAPSerial"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    countermeasureAPGroup = countermeasureAPGroup.setStatus('current')
if mibBuilder.loadTexts: countermeasureAPGroup.setDescription('List of objects defining APs taking part in countermeasure activities to thwart incoming threats.')
blaclistedClientGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 4329, 15, 3, 30, 5, 30)).setObjects(("HIPATH-WIRELESS-HWC-MIB", "blacklistedClientMAC"), ("HIPATH-WIRELESS-HWC-MIB", "blacklistedClientStatTime"), ("HIPATH-WIRELESS-HWC-MIB", "blacklistedClientEndTime"), ("HIPATH-WIRELESS-HWC-MIB", "blacklistedClientReason"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    blaclistedClientGroup = blaclistedClientGroup.setStatus('current')
if mibBuilder.loadTexts: blaclistedClientGroup.setDescription('List of objects identifying blacklisted clients.')
threatSummaryGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 4329, 15, 3, 30, 5, 31)).setObjects(("HIPATH-WIRELESS-HWC-MIB", "threatSummaryCategory"), ("HIPATH-WIRELESS-HWC-MIB", "threatSummaryActiveThreat"), ("HIPATH-WIRELESS-HWC-MIB", "threatSummaryHistoricalCounts"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    threatSummaryGroup = threatSummaryGroup.setStatus('current')
if mibBuilder.loadTexts: threatSummaryGroup.setDescription('List of objects defining attributes of known discovered threat.')
licensingInformationGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 4329, 15, 3, 30, 5, 32)).setObjects(("HIPATH-WIRELESS-HWC-MIB", "licenseRegulatoryDomain"), ("HIPATH-WIRELESS-HWC-MIB", "licenseType"), ("HIPATH-WIRELESS-HWC-MIB", "licenseDaysRemaining"), ("HIPATH-WIRELESS-HWC-MIB", "licenseAvailableAP"), ("HIPATH-WIRELESS-HWC-MIB", "licenseInServiceRadarAP"), ("HIPATH-WIRELESS-HWC-MIB", "licenseMode"), ("HIPATH-WIRELESS-HWC-MIB", "licenseLocalAP"), ("HIPATH-WIRELESS-HWC-MIB", "licenseForeignAP"), ("HIPATH-WIRELESS-HWC-MIB", "licenseLocalRadarAP"), ("HIPATH-WIRELESS-HWC-MIB", "licenseForeignRadarAP"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    licensingInformationGroup = licensingInformationGroup.setStatus('current')
if mibBuilder.loadTexts: licensingInformationGroup.setDescription('List of objects providing licensing information for the controller system.')
stationsByProtocolGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 4329, 15, 3, 30, 5, 33)).setObjects(("HIPATH-WIRELESS-HWC-MIB", "stationsByProtocolA"), ("HIPATH-WIRELESS-HWC-MIB", "stationsByProtocolB"), ("HIPATH-WIRELESS-HWC-MIB", "stationsByProtocolG"), ("HIPATH-WIRELESS-HWC-MIB", "stationsByProtocolN24"), ("HIPATH-WIRELESS-HWC-MIB", "stationsByProtocolN5"), ("HIPATH-WIRELESS-HWC-MIB", "stationsByProtocolUnavailable"), ("HIPATH-WIRELESS-HWC-MIB", "stationsByProtocolError"), ("HIPATH-WIRELESS-HWC-MIB", "stationsByProtocolAC"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    stationsByProtocolGroup = stationsByProtocolGroup.setStatus('current')
if mibBuilder.loadTexts: stationsByProtocolGroup.setDescription('List of objects for aggregated MUs on a specific wireless channel.')
apByChannelGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 4329, 15, 3, 30, 5, 34)).setObjects(("HIPATH-WIRELESS-HWC-MIB", "apByChannelAPs"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    apByChannelGroup = apByChannelGroup.setStatus('current')
if mibBuilder.loadTexts: apByChannelGroup.setDescription('List of objects for aggregated access points on a wireless channel.')
uncategorizedAPGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 4329, 15, 3, 30, 5, 35)).setObjects(("HIPATH-WIRELESS-HWC-MIB", "uncategorizedAPDescption"), ("HIPATH-WIRELESS-HWC-MIB", "uncategorizedAPManufacturer"), ("HIPATH-WIRELESS-HWC-MIB", "uncategorizedAPClassify"), ("HIPATH-WIRELESS-HWC-MIB", "uncategorizedAPSSID"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    uncategorizedAPGroup = uncategorizedAPGroup.setStatus('current')
if mibBuilder.loadTexts: uncategorizedAPGroup.setDescription('Objects defining uncategorized access points discovered by Radar application.')
authorizedAPGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 4329, 15, 3, 30, 5, 36)).setObjects(("HIPATH-WIRELESS-HWC-MIB", "authorizedAPDescription"), ("HIPATH-WIRELESS-HWC-MIB", "authorizedAPManufacturer"), ("HIPATH-WIRELESS-HWC-MIB", "authorizedAPClassify"), ("HIPATH-WIRELESS-HWC-MIB", "authorizedAPRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    authorizedAPGroup = authorizedAPGroup.setStatus('current')
if mibBuilder.loadTexts: authorizedAPGroup.setDescription('Objects defining authorized access points discovered by Radar application.')
prohibitedAPGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 4329, 15, 3, 30, 5, 37)).setObjects(("HIPATH-WIRELESS-HWC-MIB", "prohibitedAPCategory"), ("HIPATH-WIRELESS-HWC-MIB", "prohibitedAPDescription"), ("HIPATH-WIRELESS-HWC-MIB", "prohibitedAPManufacturer"), ("HIPATH-WIRELESS-HWC-MIB", "prohibitedAPClassify"), ("HIPATH-WIRELESS-HWC-MIB", "prohibitedAPRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    prohibitedAPGroup = prohibitedAPGroup.setStatus('current')
if mibBuilder.loadTexts: prohibitedAPGroup.setDescription('Objects defining prohibited access points discovered by Radar application.')
dedicatedScanGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 4329, 15, 3, 30, 5, 38)).setObjects(("HIPATH-WIRELESS-HWC-MIB", "dedicatedScanGrpName"), ("HIPATH-WIRELESS-HWC-MIB", "dedicatedScanGrpMaxConcurrentAttacksPerAP"), ("HIPATH-WIRELESS-HWC-MIB", "dedicatedScanGrpCounterMeasures"), ("HIPATH-WIRELESS-HWC-MIB", "dedicatedScanGrpScan2400MHzFreq"), ("HIPATH-WIRELESS-HWC-MIB", "dedicatedScanGrpScan5GHzFreq"), ("HIPATH-WIRELESS-HWC-MIB", "dedicatedScanGrpRowStatus"), ("HIPATH-WIRELESS-HWC-MIB", "dedicatedScanGrpSecurityThreats"), ("HIPATH-WIRELESS-HWC-MIB", "dedicatedScanGrpBlockAdHocPeriod"), ("HIPATH-WIRELESS-HWC-MIB", "dedicatedScanGrpClassifySourceIF"), ("HIPATH-WIRELESS-HWC-MIB", "dedicatedScanGrpDetectRogueAP"), ("HIPATH-WIRELESS-HWC-MIB", "dedicatedScanGrpListeningPort"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dedicatedScanGroup = dedicatedScanGroup.setStatus('current')
if mibBuilder.loadTexts: dedicatedScanGroup.setDescription('List of objects for defining dedicated scan group.')
apRadioAntennaGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 4329, 15, 3, 30, 5, 39)).setObjects(("HIPATH-WIRELESS-HWC-MIB", "apRadioAntennaType"), ("HIPATH-WIRELESS-HWC-MIB", "apRadioAntennaModel"), ("HIPATH-WIRELESS-HWC-MIB", "apRadioAttenuation"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    apRadioAntennaGroup = apRadioAntennaGroup.setStatus('current')
if mibBuilder.loadTexts: apRadioAntennaGroup.setDescription('A collection of objects defining an antenna attributes for an AP.')
radiusFastFailoverEventsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 4329, 15, 3, 30, 5, 40)).setObjects(("HIPATH-WIRELESS-HWC-MIB", "fastFailoverEvents"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    radiusFastFailoverEventsGroup = radiusFastFailoverEventsGroup.setStatus('current')
if mibBuilder.loadTexts: radiusFastFailoverEventsGroup.setDescription('List of objects for defining radius FastFailoverEvents.')
dhcpRelayListenersGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 4329, 15, 3, 30, 5, 41)).setObjects(("HIPATH-WIRELESS-HWC-MIB", "dhcpRelayListenersRowStatus"), ("HIPATH-WIRELESS-HWC-MIB", "destinationName"), ("HIPATH-WIRELESS-HWC-MIB", "destinationIP"), ("HIPATH-WIRELESS-HWC-MIB", "dhcpRelayListenersMaxEntries"), ("HIPATH-WIRELESS-HWC-MIB", "dhcpRelayListenersNextIndex"), ("HIPATH-WIRELESS-HWC-MIB", "dhcpRelayListenersNumEntries"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dhcpRelayListenersGroup = dhcpRelayListenersGroup.setStatus('current')
if mibBuilder.loadTexts: dhcpRelayListenersGroup.setDescription('List of objects for defining dhcpRelayListeners.')
authenticationAdvancedGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 4329, 15, 3, 30, 5, 42)).setObjects(("HIPATH-WIRELESS-HWC-MIB", "includeServiceType"), ("HIPATH-WIRELESS-HWC-MIB", "clientMessageDelayTime"), ("HIPATH-WIRELESS-HWC-MIB", "radiusAccounting"), ("HIPATH-WIRELESS-HWC-MIB", "serverUsageModel"), ("HIPATH-WIRELESS-HWC-MIB", "radacctStartOnIPAddr"), ("HIPATH-WIRELESS-HWC-MIB", "clientServiceTypeLogin"), ("HIPATH-WIRELESS-HWC-MIB", "applyMacAddressFormat"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    authenticationAdvancedGroup = authenticationAdvancedGroup.setStatus('current')
if mibBuilder.loadTexts: authenticationAdvancedGroup.setDescription('List of objects for defining authenticationAdvanced.')
radiusExtnsSettingGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 4329, 15, 3, 30, 5, 43)).setObjects(("HIPATH-WIRELESS-HWC-MIB", "pollingMechanism"), ("HIPATH-WIRELESS-HWC-MIB", "serverPollingInterval"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    radiusExtnsSettingGroup = radiusExtnsSettingGroup.setStatus('current')
if mibBuilder.loadTexts: radiusExtnsSettingGroup.setDescription('List of objects for defining radiusExtnsSetting.')
mibBuilder.exportSymbols("HIPATH-WIRELESS-HWC-MIB", loadGroupName=loadGroupName, stationMacAddress=stationMacAddress, licensingInformation=licensingInformation, dhcpRelayListenersTable=dhcpRelayListenersTable, apPerfWlanCurPeakClientsPerSec=apPerfWlanCurPeakClientsPerSec, apTotalStationsBInOctets=apTotalStationsBInOctets, vnsAPFilterRuleDirection=vnsAPFilterRuleDirection, wlanSSID=wlanSSID, topoExceptionStatPktsAllowed=topoExceptionStatPktsAllowed, apLogManagement=apLogManagement, apPerfRadioPrevPeakSNR=apPerfRadioPrevPeakSNR, apLogSelectedAPsEntry=apLogSelectedAPsEntry, siteStrictLimitEnableR1=siteStrictLimitEnableR1, topoStatName=topoStatName, licenseForeignRadarAP=licenseForeignRadarAP, topologyGroupMembers=topologyGroupMembers, wlanRadiusServerAcctSIAR=wlanRadiusServerAcctSIAR, apIPAddress=apIPAddress, phyDHCPRangeEnd=phyDHCPRangeEnd, apPollInterval=apPollInterval, vnsSLPEnabled=vnsSLPEnabled, scanGroupAPAssignAllowScanning=scanGroupAPAssignAllowScanning, apPerfWlanCurrentClientsPerSec=apPerfWlanCurrentClientsPerSec, vns3rdPartyAPTable=vns3rdPartyAPTable, apChannelUtilizationEntry=apChannelUtilizationEntry, wlanPrivWEPKeyLength=wlanPrivWEPKeyLength, wlanRadiusServerMacUseVNSName=wlanRadiusServerMacUseVNSName, loadGroupID=loadGroupID, cpConnectionIP=cpConnectionIP, dedicatedScanGrpSecurityThreats=dedicatedScanGrpSecurityThreats, tertiaryDNS=tertiaryDNS, topoCompleteStatName=topoCompleteStatName, vnsAPFilterPortLow=vnsAPFilterPortLow, loadGroupLoadControlEnableR1=loadGroupLoadControlEnableR1, siteLocalRadiusAuthentication=siteLocalRadiusAuthentication, wlanRadiusServerEntry=wlanRadiusServerEntry, dedicatedScanGroup=dedicatedScanGroup, vnsStatBroadcastTxPkts=vnsStatBroadcastTxPkts, topologyPreFixLength=topologyPreFixLength, mitigatorAnalysisEngine=mitigatorAnalysisEngine, wlanCPExtTosOverride=wlanCPExtTosOverride, vnsDLSPort=vnsDLSPort, stationIPAddress=stationIPAddress, vnsMgmtTrafficEnable=vnsMgmtTrafficEnable, tspecAC=tspecAC, apNotifications=apNotifications, vnsQoSWirelessULPolicerAction=vnsQoSWirelessULPolicerAction, apTotalStationsB=apTotalStationsB, wlanAuthRadiusAcctAfterMacBaseAuthorization=wlanAuthRadiusAcctAfterMacBaseAuthorization, apEventAPSerialNumber=apEventAPSerialNumber, vnsDHCPRangeEnd=vnsDHCPRangeEnd, vnsStatMulticastTxPkts=vnsStatMulticastTxPkts, loadGroupLoadControlEnableR2=loadGroupLoadControlEnableR2, muAPSerialNo=muAPSerialNo, topoStatTxOctets=topoStatTxOctets, activeThreatGroup=activeThreatGroup, wlanRadiusIndex=wlanRadiusIndex, apInNUcastPkts=apInNUcastPkts, phyDHCPRangeEntry=phyDHCPRangeEntry, cpType=cpType, netflowDestinationIP=netflowDestinationIP, apRadioAntennaTable=apRadioAntennaTable, wlanUnsecuredWlanCounts=wlanUnsecuredWlanCounts, muAccessListMACAddress=muAccessListMACAddress, topoStatBroadcastRxPkts=topoStatBroadcastRxPkts, activeThreatCategory=activeThreatCategory, wlanRadiusServerAcctUseVNSIPAddr=wlanRadiusServerAcctUseVNSIPAddr, loadGroupLoadControl=loadGroupLoadControl, dedicatedScanGrpScan5GHzFreq=dedicatedScanGrpScan5GHzFreq, loadGroupLoadControlStrictLimitR1=loadGroupLoadControlStrictLimitR1, muACLRowStatus=muACLRowStatus, dedicatedScanGrpClassifySourceIF=dedicatedScanGrpClassifySourceIF, tspecUlViolations=tspecUlViolations, dedicatedScanGroupEntry=dedicatedScanGroupEntry, stationsByProtocolN5=stationsByProtocolN5, PYSNMP_MODULE_ID=hiPathWirelessControllerMib, physicalPortsInternalVlanID=physicalPortsInternalVlanID, vnsRateControlCBS=vnsRateControlCBS, wlanStatsRadiusReqFailed=wlanStatsRadiusReqFailed, recurrenceDaily=recurrenceDaily, apAccPrevPeakReassocReqRx=apAccPrevPeakReassocReqRx, vnsStatsObjects=vnsStatsObjects, portDuplexMode=portDuplexMode, siteStrictLimitEnableR2=siteStrictLimitEnableR2, vnsWDSStatTxRate=vnsWDSStatTxRate, licenseDaysRemaining=licenseDaysRemaining, wlanPrivKeyManagement=wlanPrivKeyManagement, wlanAuthRadiusIncludeIngressRC=wlanAuthRadiusIncludeIngressRC, HundredthOfGauge64=HundredthOfGauge64, vnsStatTable=vnsStatTable, maxVideoBWforAssociation=maxVideoBWforAssociation, apPerfRadioAverageChannelUtilization=apPerfRadioAverageChannelUtilization, stationsByProtocolB=stationsByProtocolB, apMaintenanceCycle=apMaintenanceCycle, vnsFilterRuleIPAddress=vnsFilterRuleIPAddress, vnsWDSStatSSID=vnsWDSStatSSID, vnsWDSRFEntry=vnsWDSRFEntry, apPlatforms=apPlatforms, sysCPUType=sysCPUType, authorizedAPTable=authorizedAPTable, apRegSecurityMode=apRegSecurityMode, HundredthOfGauge32=HundredthOfGauge32, activeThreatIndex=activeThreatIndex, vnsQoSEntry=vnsQoSEntry, authenticationAdvanced=authenticationAdvanced, dhcpRelayListenersNextIndex=dhcpRelayListenersNextIndex, vnsAuthModel=vnsAuthModel, cpLoginLabel=cpLoginLabel, siteTable=siteTable, apCredentialType=apCredentialType, topologyMemberId=topologyMemberId, siteRowStatus=siteRowStatus, muGroup=muGroup, portDHCPDefaultLease=portDHCPDefaultLease, outOfSrvScanGrpChannelList=outOfSrvScanGrpChannelList, wlanCPReplaceIPwithFQDN=wlanCPReplaceIPwithFQDN, wlanRadiusName=wlanRadiusName, topologyVlanID=topologyVlanID, topoStatBroadcastTxPkts=topoStatBroadcastTxPkts, muPolicyName=muPolicyName, siteCoSMember=siteCoSMember, sysLogServerPort=sysLogServerPort, wlanRadiusPort=wlanRadiusPort, apWiredIfIndex=apWiredIfIndex, vnsFilterRuleStatus=vnsFilterRuleStatus, stationRoamedAPName=stationRoamedAPName, apGroup=apGroup, wlanCPIntLogoffButton=wlanCPIntLogoffButton, tspecNMS=tspecNMS, apRadioNumber=apRadioNumber, apPerfWlanDLPkts=apPerfWlanDLPkts, licenseForeignAP=licenseForeignAP, siteEnableSecureTunnel=siteEnableSecureTunnel, radiusExtnsSettingGroup=radiusExtnsSettingGroup, inSrvScanGrpDetectRogueAP=inSrvScanGrpDetectRogueAP, wlanNetFlow=wlanNetFlow, muACLType=muACLType, vnsFilterRuleEntry=vnsFilterRuleEntry, dasPort=dasPort, apAccDisassocDeauthReqRx=apAccDisassocDeauthReqRx, apAccAverageDisassocDeauthReqTx=apAccAverageDisassocDeauthReqTx, vnsExceptionStatTable=vnsExceptionStatTable, apStatsObjects=apStatsObjects, scanAPEntry=scanAPEntry, dhcpRelayListenersGroup=dhcpRelayListenersGroup, muDefaultCoS=muDefaultCoS, topologyTable=topologyTable, licenseLocalRadarAP=licenseLocalRadarAP, mobileUnitCount=mobileUnitCount, scanGroupAPAssignFordwardingService=scanGroupAPAssignFordwardingService, friendlyAPGroup=friendlyAPGroup, inSrvScanGrpSecurityThreats=inSrvScanGrpSecurityThreats, radiusInfo=radiusInfo, apTotalStationsN24=apTotalStationsN24, inServiceScanGroupTable=inServiceScanGroupTable, hiPathWirelessAppLogFacility=hiPathWirelessAppLogFacility, wlanSecurityReportTable=wlanSecurityReportTable, cpHeaderURL=cpHeaderURL, imagePath36xx=imagePath36xx, wlanCPExtEnableHttps=wlanCPExtEnableHttps, vnsFilterIDTable=vnsFilterIDTable, muConnectionCapability=muConnectionCapability, widsWipsEngineGroup=widsWipsEngineGroup, wlanAuthType=wlanAuthType, wlanRadiusNASUseVnsIP=wlanRadiusNASUseVnsIP, apAccPrevPeakAssocReqRx=apAccPrevPeakAssocReqRx, apLogFrequency=apLogFrequency, dhcpRelayListenersEntry=dhcpRelayListenersEntry, stationsByProtocolUnavailable=stationsByProtocolUnavailable, topoStatRxPkts=topoStatRxPkts, siteNumEntries=siteNumEntries, radioVNSTable=radioVNSTable, vnsWDSRFBackupParent=vnsWDSRFBackupParent, apInvalidPolicyCount=apInvalidPolicyCount, sysLogServerEnabled=sysLogServerEnabled, destinationName=destinationName, destinationIP=destinationIP, wlanProcessClientIE=wlanProcessClientIE, apTelnetAccess=apTelnetAccess, apUpTime=apUpTime, muConnectionProtocol=muConnectionProtocol, topoWireStatRxPkts=topoWireStatRxPkts, apLogFileCopyRowStatus=apLogFileCopyRowStatus, topoCompleteStatFrameChkSeqErrors=topoCompleteStatFrameChkSeqErrors, vnsWDSStatRxError=vnsWDSStatRxError, apLogUserId=apLogUserId, topologyIPMask=topologyIPMask, vnsRadiusServerNasAddress=vnsRadiusServerNasAddress, vnsFilterID=vnsFilterID, apPerfRadioCurPeakPktRetx=apPerfRadioCurPeakPktRetx, topologyIPAddress=topologyIPAddress, apLogFileCopyTable=apLogFileCopyTable, apAccCurPeakAssocReqRx=apAccCurPeakAssocReqRx, apStaticMTUsize=apStaticMTUsize, apPerformanceReportByRadioTable=apPerformanceReportByRadioTable, topoStatTable=topoStatTable, apLogFileCopyServerIP=apLogFileCopyServerIP, apHwVersion=apHwVersion, apRegTelnetPassword=apRegTelnetPassword, inSrvScanGrpblockAdHocClientsPeriod=inSrvScanGrpblockAdHocClientsPeriod, topoCompleteStatFrameTooLongErrors=topoCompleteStatFrameTooLongErrors, apPerfWlanULOctets=apPerfWlanULOctets, assocDuration=assocDuration, assocTxOctets=assocTxOctets, wlanCPSelectionOption=wlanCPSelectionOption, prohibitedAPMAC=prohibitedAPMAC, tspecBssMac=tspecBssMac, tspecMuIPAddress=tspecMuIPAddress, apRadioTable=apRadioTable, apByChannelTable=apByChannelTable, nearbyApIndex=nearbyApIndex, tunnelStatsTxBytes=tunnelStatsTxBytes, dedicatedScanGrpRowStatus=dedicatedScanGrpRowStatus, apOutDiscards=apOutDiscards, friendlyAPDescription=friendlyAPDescription, phyDHCPRangeStatus=phyDHCPRangeStatus, apFastFailoverEnable=apFastFailoverEnable, ntpObjects=ntpObjects, cpMessage=cpMessage, portIpAddress=portIpAddress, physicalPortsTable=physicalPortsTable, apTotalStationsACOutOctets=apTotalStationsACOutOctets, apAntennaGroup=apAntennaGroup, topoStatRxOctets=topoStatRxOctets, dasInfo=dasInfo, wlanCPIntStatusCheckButton=wlanCPIntStatusCheckButton, dedicatedScanGrpDetectRogueAP=dedicatedScanGrpDetectRogueAP, siteBandPreferenceEnable=siteBandPreferenceEnable, controllerStats=controllerStats, vnsQoSTable=vnsQoSTable, sitePolicyID=sitePolicyID, logEventComponent=logEventComponent, sysSoftwareVersion=sysSoftwareVersion, layerTwoPortEntry=layerTwoPortEntry, wlanSecurityReportFlag=wlanSecurityReportFlag, vnsCount=vnsCount, radiusId=radiusId, outOfSrvScanGrpSecurityScan=outOfSrvScanGrpSecurityScan, ntpTimeServer3=ntpTimeServer3, apAccPrevPeakDisassocDeauthReqRx=apAccPrevPeakDisassocDeauthReqRx, wlanAuthEntry=wlanAuthEntry, apLogFileCopyPassword=apLogFileCopyPassword, apRadioStatusEntry=apRadioStatusEntry, apPerfWlanCurPeakDLPktsPerSec=apPerfWlanCurPeakDLPktsPerSec, wlanAuthRadiusIncludeTopology=wlanAuthRadiusIncludeTopology, apRegUseClusterEncryption=apRegUseClusterEncryption, loadGroupType=loadGroupType, dhcpRelayListenersRowStatus=dhcpRelayListenersRowStatus, apInOctets=apInOctets, muTable=muTable, wlanPrivTable=wlanPrivTable, muTxOctets=muTxOctets, phyDHCPRangeType=phyDHCPRangeType, radiusFastFailoverEventsEntry=radiusFastFailoverEventsEntry)
mibBuilder.exportSymbols("HIPATH-WIRELESS-HWC-MIB", layerTwoPortTable=layerTwoPortTable, topologyLinkLocalIPv6Address=topologyLinkLocalIPv6Address, widsWipsEngineEntry=widsWipsEngineEntry, topologyEntry=topologyEntry, includeAllServiceMessages=includeAllServiceMessages, apByChannelNumber=apByChannelNumber, prohibitedAPCategory=prohibitedAPCategory, muAPName=muAPName, apRadioAntennaGroup=apRadioAntennaGroup, inSrvScanGrpScan5GHzSelection=inSrvScanGrpScan5GHzSelection, sites=sites, ntpTimezone=ntpTimezone, tspecSBA=tspecSBA, siteMaxEntries=siteMaxEntries, cpSharedSecret=cpSharedSecret, wlanAuthRadiusTimeoutRole=wlanAuthRadiusTimeoutRole, stationsByProtocolN24=stationsByProtocolN24, topoWireStatFrameTooLongErrors=topoWireStatFrameTooLongErrors, topologyStatGroup=topologyStatGroup, phyDHCPRangeStart=phyDHCPRangeStart, dasReplayInterval=dasReplayInterval, topoExceptionStatPktsDenied=topoExceptionStatPktsDenied, vnsDescription=vnsDescription, activeThreatsCounts=activeThreatsCounts, stationEventType=stationEventType, wlanPrivWPAversion=wlanPrivWPAversion, hwcAvailabilityRank=hwcAvailabilityRank, vnForeignClients=vnForeignClients, vnsRadiusServerTimeout=vnsRadiusServerTimeout, apSSHConnection=apSSHConnection, vnsPrivacyTable=vnsPrivacyTable, apByChannelGroup=apByChannelGroup, wlanAuthRadiusOperatorNameSpace=wlanAuthRadiusOperatorNameSpace, vnsPrivWEPKeyType=vnsPrivWEPKeyType, vnsRadiusServerEntry=vnsRadiusServerEntry, apMacAddress=apMacAddress, apIpAddress=apIpAddress, vnsPrivDynamicRekeyFrequency=vnsPrivDynamicRekeyFrequency, topoCompleteStatBroadcastRxPkts=topoCompleteStatBroadcastRxPkts, vnsDHCPRangeEntry=vnsDHCPRangeEntry, accessRejectMsgEntry=accessRejectMsgEntry, apRegistration=apRegistration, countermeasureAPThreatIndex=countermeasureAPThreatIndex, apInErrors=apInErrors, wlanVNSID=wlanVNSID, wlanRadiusServerAuthAuthType=wlanRadiusServerAuthAuthType, stationBSSID=stationBSSID, dedicatedScanGrpBlockAdHocPeriod=dedicatedScanGrpBlockAdHocPeriod, wlanIdleTimeoutPreAuth=wlanIdleTimeoutPreAuth, vnsQoSWirelessEnableUAPSD=vnsQoSWirelessEnableUAPSD, wlanStatsID=wlanStatsID, vnsStatus=vnsStatus, wlanRadiusServerAuthUseVNSName=wlanRadiusServerAuthUseVNSName, muACLTable=muACLTable, vnsAPFilterTable=vnsAPFilterTable, topoWireStatMulticastRxPkts=topoWireStatMulticastRxPkts, inServiceScanGroupEntry=inServiceScanGroupEntry, wlanSynchronize=wlanSynchronize, apRowStatus=apRowStatus, wlanAuthRadiusIncludeAP=wlanAuthRadiusIncludeAP, sensorManagement=sensorManagement, vnsExceptionFiterName=vnsExceptionFiterName, portMgmtTrafficEnable=portMgmtTrafficEnable, ntpTimeServer1=ntpTimeServer1, vnsPrivUseSharedKey=vnsPrivUseSharedKey, wlanIdleSessionPostAuth=wlanIdleSessionPostAuth, vnsQoSWirelessUseAdmControlVoice=vnsQoSWirelessUseAdmControlVoice, physicalFlash=physicalFlash, vnsProcessClientIEReq=vnsProcessClientIEReq, apRadioAttenuation=apRadioAttenuation, countermeasureAPThreatCategory=countermeasureAPThreatCategory, stationIPv6Address2=stationIPv6Address2, wlanAuthRadiusIncludePolicy=wlanAuthRadiusIncludePolicy, dedicatedScanGroupTable=dedicatedScanGroupTable, siteWlanGroup=siteWlanGroup, mgmtPortObjects=mgmtPortObjects, apState=apState, apAccAssocReqRx=apAccAssocReqRx, virtualNetworks=virtualNetworks, apAccDisassocDeauthReqTx=apAccDisassocDeauthReqTx, wlanPrivWEPKeyIndex=wlanPrivWEPKeyIndex, apAccCurPeakDisassocDeauthReqTx=apAccCurPeakDisassocDeauthReqTx, armCount=armCount, tspecMuMACAddress=tspecMuMACAddress, wlanPrivEntry=wlanPrivEntry, loadGroup=loadGroup, apCount=apCount, wlanSecurityReportNotes=wlanSecurityReportNotes, apRadioAntennaModel=apRadioAntennaModel, uncategorizedAPDescption=uncategorizedAPDescption, vnsStatRadiusTotRequests=vnsStatRadiusTotRequests, authorizedAPGroup=authorizedAPGroup, siteMaxClientR1=siteMaxClientR1, topoExceptionFiterName=topoExceptionFiterName, tspecDirection=tspecDirection, logEventSeverity=logEventSeverity, loadGrpWlanEntry=loadGrpWlanEntry, stationDetailEvent=stationDetailEvent, maxVoiceBWforAssociation=maxVoiceBWforAssociation, wlanTableNextAvailableIndex=wlanTableNextAvailableIndex, apOutErrors=apOutErrors, muACLGroup=muACLGroup, wlanRadiusServerAuthUseVNSIPAddr=wlanRadiusServerAuthUseVNSIPAddr, topoCompleteStatTxOctets=topoCompleteStatTxOctets, portDHCPEnable=portDHCPEnable, vnsAPFilterEntry=vnsAPFilterEntry, apIfMAC=apIfMAC, vnsAssignmentMode=vnsAssignmentMode, vnsDLSAddress=vnsDLSAddress, vnsRadiusServerSharedSecret=vnsRadiusServerSharedSecret, apCertificateExpiry=apCertificateExpiry, jumboFrames=jumboFrames, vnsFilterRuleDirection=vnsFilterRuleDirection, vnsAPFilterRowStatus=vnsAPFilterRowStatus, vnManagerObjects=vnManagerObjects, weakCipherEnable=weakCipherEnable, radiusStrictMode=radiusStrictMode, wlanCPRedirectURL=wlanCPRedirectURL, assocStartSysUpTime=assocStartSysUpTime, scanGroupAPAssignAllowSpectrumAnalysis=scanGroupAPAssignAllowSpectrumAnalysis, scanAPRowStatus=scanAPRowStatus, siteAPEntry=siteAPEntry, externalRadiusServerName=externalRadiusServerName, apChnlUtilCurrentUtilization=apChnlUtilCurrentUtilization, portVlanID=portVlanID, vnsDHCPRangeStatus=vnsDHCPRangeStatus, cpPasswordLabel=cpPasswordLabel, cpReplaceGatewayWithFQDN=cpReplaceGatewayWithFQDN, apAccCurPeakReassocReqRx=apAccCurPeakReassocReqRx, assocMUMacAddress=assocMUMacAddress, authorizedAPMAC=authorizedAPMAC, apLogPassword=apLogPassword, wlanEntry=wlanEntry, dedicatedScanGrpMaxConcurrentAttacksPerAP=dedicatedScanGrpMaxConcurrentAttacksPerAP, wlanAuthRadiusOperatorName=wlanAuthRadiusOperatorName, externalRadiusServerSharedSecret=externalRadiusServerSharedSecret, vnsSessionAvailabilityEnable=vnsSessionAvailabilityEnable, apAntennaEntry=apAntennaEntry, sysLogServerIP=sysLogServerIP, wlanSecurityReportUnsecureType=wlanSecurityReportUnsecureType, apName=apName, apPortifIndex=apPortifIndex, sitePolicyGroup=sitePolicyGroup, licenseInServiceRadarAP=licenseInServiceRadarAP, apBroadcastDisassociate=apBroadcastDisassociate, vnsWDSRFAPName=vnsWDSRFAPName, cpFooterURL=cpFooterURL, wlanStatsAssociatedClients=wlanStatsAssociatedClients, hiPathWirelessHWCModule=hiPathWirelessHWCModule, muWLANID=muWLANID, vnsConfigEntry=vnsConfigEntry, apAntennanName=apAntennanName, recurrenceWeekly=recurrenceWeekly, scanGroupAPAssignmentEntry=scanGroupAPAssignmentEntry, phyDHCPRangeIndex=phyDHCPRangeIndex, armReplyMessage=armReplyMessage, vnsStatRxPkts=vnsStatRxPkts, apAccPrevPeakDisassocDeauthReqTx=apAccPrevPeakDisassocDeauthReqTx, apPerfRadioAverageSNR=apPerfRadioAverageSNR, mirrorL2Ports=mirrorL2Ports, vnsFilterRuleOrder=vnsFilterRuleOrder, vnsPrivWPA1Enabled=vnsPrivWPA1Enabled, apPerfRadioPrevPeakRSS=apPerfRadioPrevPeakRSS, tunnelEndHWC=tunnelEndHWC, wlanRadiusEntry=wlanRadiusEntry, vnsWDSStatRxFrame=vnsWDSStatRxFrame, logNotifications=logNotifications, apSecureTunnel=apSecureTunnel, activeThreatAPName=activeThreatAPName, threatSummaryActiveThreat=threatSummaryActiveThreat, vnsInterfaceName=vnsInterfaceName, vnsWDSRFTable=vnsWDSRFTable, siteCoSID=siteCoSID, vnsWDSRFbgService=vnsWDSRFbgService, siteCosTable=siteCosTable, nearbyApRSS=nearbyApRSS, wlanPrivWEPKey=wlanPrivWEPKey, licenseMode=licenseMode, licenseRegulatoryDomain=licenseRegulatoryDomain, wlanPrivPrivacyType=wlanPrivPrivacyType, apEventDescription=apEventDescription, stationsByProtocolGroup=stationsByProtocolGroup, wlanPrivRekeyInterval=wlanPrivRekeyInterval, licenseLocalAP=licenseLocalAP, maxVideoBWforReassociation=maxVideoBWforReassociation, radiusExtnsSettingTable=radiusExtnsSettingTable, wlanCPSendLoginTo=wlanCPSendLoginTo, vnsRateControlProfEntry=vnsRateControlProfEntry, apChnlUtilCurPeakUtilization=apChnlUtilCurPeakUtilization, apPerfRadioAveragePktRetx=apPerfRadioAveragePktRetx, serviceLogFacility=serviceLogFacility, hiPathWirelessControllerMib=hiPathWirelessControllerMib, vnsWDSStatRxRate=vnsWDSStatRxRate, topologyGateway=topologyGateway, apSSHAccess=apSSHAccess, prohibitedAPClassify=prohibitedAPClassify, loadGrpRadiosEntry=loadGrpRadiosEntry, loadGroupLoadControlStrictLimitR2=loadGroupLoadControlStrictLimitR2, phyDHCPRangeGroup=phyDHCPRangeGroup, vnsGlobalSetting=vnsGlobalSetting, wlanAuthAutoAuthAuthorizedUser=wlanAuthAutoAuthAuthorizedUser, siteEncryptCommBetweenAPs=siteEncryptCommBetweenAPs, apPerfRadioCurPeakSNR=apPerfRadioCurPeakSNR, assocRxPackets=assocRxPackets, widsWipsEnginePollRetry=widsWipsEnginePollRetry, vnsRadiusServerPort=vnsRadiusServerPort, apNeighboursEntry=apNeighboursEntry, muMACAddress=muMACAddress, wlanPrivfastTransition=wlanPrivfastTransition, apDesc=apDesc, channel=channel, wlanRadiusTable=wlanRadiusTable, apOutOctets=apOutOctets, vnsPrivWEPKeyLength=vnsPrivWEPKeyLength, apPerfRadioAverageRSS=apPerfRadioAverageRSS, siteWlanApRadioAssigned=siteWlanApRadioAssigned, wlanRadiusServerUsage=wlanRadiusServerUsage, muTxPackets=muTxPackets, topoWireStatFrameChkSeqErrors=topoWireStatFrameChkSeqErrors, siteCosEntry=siteCosEntry, apTunnelAlarm=apTunnelAlarm, vnsParentIfIndex=vnsParentIfIndex, tspecSsid=tspecSsid, wlanRadiusServerAuthNASId=wlanRadiusServerAuthNASId, wlanRowStatus=wlanRowStatus, wlanRadiusServerMacNASIP=wlanRadiusServerMacNASIP, wlanRadiusNASIDUseVNSName=wlanRadiusNASIDUseVNSName, nearbyApChannel=nearbyApChannel, wlanAuthRadiusIncludeEgressRC=wlanAuthRadiusIncludeEgressRC, apByChannelEntry=apByChannelEntry, vnsMgmIpAddress=vnsMgmIpAddress, vnsDHCPRangeStart=vnsDHCPRangeStart, apChannelUtilizationTable=apChannelUtilizationTable, vnTotalClients=vnTotalClients, wlanDot11hSupport=wlanDot11hSupport, apInterfaceMTU=apInterfaceMTU, hiPathWirelessLogAlarm=hiPathWirelessLogAlarm, apRadioType=apRadioType, dedicatedScanGrpListeningPort=dedicatedScanGrpListeningPort, wlanStatsTable=wlanStatsTable, vnsFilterRulePortHigh=vnsFilterRulePortHigh, vnsQoSWirelessLegacyFlag=vnsQoSWirelessLegacyFlag, wlanRadiusRetries=wlanRadiusRetries, topologySyncMask=topologySyncMask, apStatsTable=apStatsTable, outOfSrvScanGrpScanType=outOfSrvScanGrpScanType, muACLEntry=muACLEntry, imageVersionOfngap36xx=imageVersionOfngap36xx, siteDefaultDNSServer=siteDefaultDNSServer, tftpSever=tftpSever, startHour=startHour, sitePolicyTable=sitePolicyTable, wlanSupressSSID=wlanSupressSSID, topologySyncIPStart=topologySyncIPStart)
mibBuilder.exportSymbols("HIPATH-WIRELESS-HWC-MIB", topologyIsGroup=topologyIsGroup, associations=associations, blacklistedClientMAC=blacklistedClientMAC, vnIfIndex=vnIfIndex, tunnelCount=tunnelCount, vnsUseDHCPRelay=vnsUseDHCPRelay, scanAPGroup=scanAPGroup, apMICErrorWarning=apMICErrorWarning, topologyStat=topologyStat, loadGroupTable=loadGroupTable, apTotalStationsA=apTotalStationsA, vnsRateControlProfInd=vnsRateControlProfInd, widsWipsEngineControllerIPAddress=widsWipsEngineControllerIPAddress, vnsQoSWirelessUseAdmControlBackground=vnsQoSWirelessUseAdmControlBackground, topoWireStatBroadcastRxPkts=topoWireStatBroadcastRxPkts, imageVersionOfap26xx=imageVersionOfap26xx, vnsWDSStatAPRadio=vnsWDSStatAPRadio, topoCompleteStatTxPkts=topoCompleteStatTxPkts, apRadioAntennaEntry=apRadioAntennaEntry, muAccessListBitmaskLength=muAccessListBitmaskLength, scanGroupsCurrentEntries=scanGroupsCurrentEntries, outOfSrvScanGrpScanRowStatus=outOfSrvScanGrpScanRowStatus, wlanAppVisibility=wlanAppVisibility, apTotalStationsBOutOctets=apTotalStationsBOutOctets, tspecProtocol=tspecProtocol, muACLMACAddress=muACLMACAddress, topoWireStatName=topoWireStatName, activeThreatDateTime=activeThreatDateTime, vnsWEPKeyValue=vnsWEPKeyValue, applyMacAddressFormat=applyMacAddressFormat, wlanCP802HttpRedirect=wlanCP802HttpRedirect, topoStatTxPkts=topoStatTxPkts, apRegDiscoveryInterval=apRegDiscoveryInterval, wlanStatsEntry=wlanStatsEntry, countermeasureAPTime=countermeasureAPTime, apRadioStatusChannel=apRadioStatusChannel, radiusMacAddressFormatOption=radiusMacAddressFormatOption, topoWireStatMulticastTxPkts=topoWireStatMulticastTxPkts, hiPathWirelessHWCObsolete=hiPathWirelessHWCObsolete, authorizedAPRowStatus=authorizedAPRowStatus, apPerfWlanPrevPeakULOctetsPerSec=apPerfWlanPrevPeakULOctetsPerSec, friendlyAPMacAddress=friendlyAPMacAddress, licenseAvailableAP=licenseAvailableAP, apPerfWlanPrevPeakDLOctetsPerSec=apPerfWlanPrevPeakDLOctetsPerSec, apLogFileCopyServerDirectory=apLogFileCopyServerDirectory, logEventSeverityThreshold=logEventSeverityThreshold, tunnelsTxRxBytes=tunnelsTxRxBytes, vnsAllowMulticast=vnsAllowMulticast, select=select, scanGroupAPAssignName=scanGroupAPAssignName, vnLocalClients=vnLocalClients, vnsSSID=vnsSSID, siteEncryptCommAPtoController=siteEncryptCommAPtoController, wlanTable=wlanTable, portMask=portMask, accessPoints=accessPoints, maxBackgroundBWforReassociation=maxBackgroundBWforReassociation, wlanEngerySaveMode=wlanEngerySaveMode, apRegistrationRequests=apRegistrationRequests, vnsRadiusServerAuthType=vnsRadiusServerAuthType, apSpecific=apSpecific, wlanRadiusServerMacNASId=wlanRadiusServerMacNASId, tunnelStatsTable=tunnelStatsTable, apPerfWlanDLOctets=apPerfWlanDLOctets, siteAPTable=siteAPTable, apEnvironment=apEnvironment, externalRadiusServerRowStatus=externalRadiusServerRowStatus, vnsWDSStatAPRole=vnsWDSStatAPRole, dhcpRelayListenersNumEntries=dhcpRelayListenersNumEntries, portDHCPWins=portDHCPWins, vnsCaptivePortalEntry=vnsCaptivePortalEntry, vnsRadiusServerTable=vnsRadiusServerTable, apLocationbasedService=apLocationbasedService, blacklistedClientStatTime=blacklistedClientStatTime, scanGroupAPAssignApSerial=scanGroupAPAssignApSerial, wlanDefaultTopologyID=wlanDefaultTopologyID, mobileUnits=mobileUnits, outOfSrvScanGrpScanActivity=outOfSrvScanGrpScanActivity, loadGrpRadiosRadio2=loadGrpRadiosRadio2, apSerialNo=apSerialNo, wlanSecurityReportEntry=wlanSecurityReportEntry, wlanCPGuestIDPrefix=wlanCPGuestIDPrefix, apPerfWlanCurPeakULOctetsPerSec=apPerfWlanCurPeakULOctetsPerSec, uncategorizedAPCounts=uncategorizedAPCounts, inServiceScanGroup=inServiceScanGroup, siteAPMember=siteAPMember, activeThreatExtraDetails=activeThreatExtraDetails, countermeasureAPName=countermeasureAPName, apAccAverageDisassocDeauthReqRx=apAccAverageDisassocDeauthReqRx, vnsStatRadiusReqFailed=vnsStatRadiusReqFailed, wlanGroup=wlanGroup, apEncryptCntTraffic=apEncryptCntTraffic, apLogDirectory=apLogDirectory, friendlyAPCounts=friendlyAPCounts, vnsWDSStatTxFrame=vnsWDSStatTxFrame, threatSummaryIndex=threatSummaryIndex, vnsDomain=vnsDomain, wlanRadiusServerAcctNASId=wlanRadiusServerAcctNASId, apPerfWlanCurPeakULPktsPerSec=apPerfWlanCurPeakULPktsPerSec, wlanID=wlanID, apPerfWlanAverageULPktsPerSec=apPerfWlanAverageULPktsPerSec, loadGrpRadiosRadio1=loadGrpRadiosRadio1, countermeasureAPSerial=countermeasureAPSerial, radiusFastFailoverEventsGroup=radiusFastFailoverEventsGroup, wlanPrivGroupKPSR=wlanPrivGroupKPSR, wlanCPGuestAccLifetime=wlanCPGuestAccLifetime, armIndex=armIndex, vnsStatMulticastRxPkts=vnsStatMulticastRxPkts, apLogFileCopyOperationStatus=apLogFileCopyOperationStatus, wlanStatsRadiusTotRequests=wlanStatsRadiusTotRequests, widsWipsEngineRowStatus=widsWipsEngineRowStatus, physicalPortCount=physicalPortCount, vnsDHCPRangeType=vnsDHCPRangeType, fastFailoverEvents=fastFailoverEvents, vnsFilterRuleAction=vnsFilterRuleAction, apTotalStationsN24OutOctets=apTotalStationsN24OutOctets, topoStatFrameChkSeqErrors=topoStatFrameChkSeqErrors, prohibitedAPEntry=prohibitedAPEntry, vnsMode=vnsMode, wlanDot11hClientPowerReduction=wlanDot11hClientPowerReduction, mgmtPortHostname=mgmtPortHostname, vnsAPFilterRuleOrder=vnsAPFilterRuleOrder, wlanAuthAllowUnauthorizedUser=wlanAuthAllowUnauthorizedUser, apPerformanceReportByRadioEntry=apPerformanceReportByRadioEntry, apLogDestination=apLogDestination, topoExceptionStatEntry=topoExceptionStatEntry, authorizedAPClassify=authorizedAPClassify, tunnelStartHWC=tunnelStartHWC, prohibitedAPRowStatus=prohibitedAPRowStatus, scanAPSerialNumber=scanAPSerialNumber, muAccessListRowStatus=muAccessListRowStatus, prohibitedAPManufacturer=prohibitedAPManufacturer, vnsIfIndex=vnsIfIndex, vnsStatRxOctects=vnsStatRxOctects, wlanRadiusServerMacUseVNSIPAddr=wlanRadiusServerMacUseVNSIPAddr, wlanRadiusServerAcctUseVNSName=wlanRadiusServerAcctUseVNSName, threatSummaryCategory=threatSummaryCategory, activeThreatDeviceMAC=activeThreatDeviceMAC, apByChannelAPs=apByChannelAPs, vns3rdPartyAP=vns3rdPartyAP, vns3rdPartyAPEntry=vns3rdPartyAPEntry, wlanAuthCollectAcctInformation=wlanAuthCollectAcctInformation, topoCompleteStatBroadcastTxPkts=topoCompleteStatBroadcastTxPkts, siteID=siteID, wlanCPExtTosValue=wlanCPExtTosValue, apPerfWlanAverageDLOctetsPerSec=apPerfWlanAverageDLOctetsPerSec, hiPathWirelessHWCGroup=hiPathWirelessHWCGroup, vnsQoSWirelessUseAdmControlBestEffort=vnsQoSWirelessUseAdmControlBestEffort, apRadioProtocol=apRadioProtocol, wlanRadiusPriority=wlanRadiusPriority, vnsExceptionStatPktsDenied=vnsExceptionStatPktsDenied, topoCompleteStatRxPkts=topoCompleteStatRxPkts, startMinute=startMinute, apPerfRadioPktRetx=apPerfRadioPktRetx, blaclistedClientGroup=blaclistedClientGroup, wlanCPTable=wlanCPTable, topologyIPv6Gateway=topologyIPv6Gateway, vnsPrivWPASharedKey=vnsPrivWPASharedKey, apPerfWlanAverageULOctetsPerSec=apPerfWlanAverageULOctetsPerSec, wlanRadiusServerAcctNASIP=wlanRadiusServerAcctNASIP, stationsByProtocolAC=stationsByProtocolAC, vnsWDSRFBridge=vnsWDSRFBridge, muUser=muUser, muDot11ConnectionCapability=muDot11ConnectionCapability, apLogFileUtility=apLogFileUtility, portDHCPDomain=portDHCPDomain, sysLogServersEntry=sysLogServersEntry, vnsQoSClassificationServiceClass=vnsQoSClassificationServiceClass, serverPollingInterval=serverPollingInterval, apSwVersion=apSwVersion, vnsStatName=vnsStatName, stationsByProtocolError=stationsByProtocolError, tunnelStatus=tunnelStatus, topoCompleteStatEntry=topoCompleteStatEntry, vnsStatTxOctects=vnsStatTxOctects, apAccCurrentDisassocDeauthReqRx=apAccCurrentDisassocDeauthReqRx, ntpEnabled=ntpEnabled, inSrvScanGrpListeningPort=inSrvScanGrpListeningPort, scanGroupAPAssignmentGroup=scanGroupAPAssignmentGroup, apIpAssignmentType=apIpAssignmentType, apTable=apTable, vnsQoSWirelessTurboVoiceFlag=vnsQoSWirelessTurboVoiceFlag, apRole=apRole, vnsApplyPowerBackOff=vnsApplyPowerBackOff, vnsWDSStatTxError=vnsWDSStatTxError, wlanCPUseHTTPSforConnection=wlanCPUseHTTPSforConnection, apRadioFrequency=apRadioFrequency, apInDiscards=apInDiscards, stationAPSSID=stationAPSSID, phyDHCPRangeTable=phyDHCPRangeTable, siteMaxClientR2=siteMaxClientR2, wlanAuthMacBasedAuth=wlanAuthMacBasedAuth, vnsPrivWPA2Enabled=vnsPrivWPA2Enabled, secureConnection=secureConnection, availability=availability, apAntennaIndex=apAntennaIndex, scanGroupAPAssignRadio1=scanGroupAPAssignRadio1, authorizedAPManufacturer=authorizedAPManufacturer, siteReplaceStnIDwithSiteName=siteReplaceStnIDwithSiteName, apStatsGroup=apStatsGroup, hiPathWirelessHWCAlarms=hiPathWirelessHWCAlarms, portDHCPMaxLease=portDHCPMaxLease, tunnelStatsRxBytes=tunnelStatsRxBytes, wlanRadiusUsage=wlanRadiusUsage, stationEventAlarm=stationEventAlarm, countermeasureAPGroup=countermeasureAPGroup, apActiveCount=apActiveCount, licensingInformationGroup=licensingInformationGroup, activeVNSSessionCount=activeVNSSessionCount, portDHCPGateway=portDHCPGateway, topoWireStatTxPkts=topoWireStatTxPkts, tspecApSerialNumber=tspecApSerialNumber, siteEntry=siteEntry, physicalPortsGroup=physicalPortsGroup, assocRxOctets=assocRxOctets, dhcpRelayListenersID=dhcpRelayListenersID, wlanCPEntry=wlanCPEntry, vnsQoSWirelessWMMFlag=vnsQoSWirelessWMMFlag, apRadioAntennaType=apRadioAntennaType, apRadioStatusTable=apRadioStatusTable, apPerfWlanAverageClientsPerSec=apPerfWlanAverageClientsPerSec, uncategorizedAPTable=uncategorizedAPTable, assocTable=assocTable, apStatsSessionDuration=apStatsSessionDuration, wlanName=wlanName, widsWipsReport=widsWipsReport, wlanAuthMACBasedAuthReAuthOnAreaRoam=wlanAuthMACBasedAuthReAuthOnAreaRoam, apPerfRadioCurrentPktRetx=apPerfRadioCurrentPktRetx, dashboard=dashboard, apAccReassocReqRx=apAccReassocReqRx, apTotalStationsN50InOctets=apTotalStationsN50InOctets, synchronizeGuestPort=synchronizeGuestPort, topologyGroup=topologyGroup, apPollTimeout=apPollTimeout, detectLinkFailure=detectLinkFailure, vnsWEPKeyIndex=vnsWEPKeyIndex, wlanAuthRadiusIncludeSSID=wlanAuthRadiusIncludeSSID, vnsQoSWirelessUseAdmControlVideo=vnsQoSWirelessUseAdmControlVideo, radioVNSRowStatus=radioVNSRowStatus, apTotalStationsN50=apTotalStationsN50, apAccessibilityTable=apAccessibilityTable, apAccessibilityEntry=apAccessibilityEntry, apPerfWlanULPkts=apPerfWlanULPkts, loadGroupClientCountRadio2=loadGroupClientCountRadio2, tunnelEndIP=tunnelEndIP, apInUcastPkts=apInUcastPkts, scanGroupAPAssignGroupName=scanGroupAPAssignGroupName, topologyLayer3=topologyLayer3, layerTwoPortMacAddress=layerTwoPortMacAddress, stationIPv6Address3=stationIPv6Address3, outOfServiceScanGroupTable=outOfServiceScanGroupTable, apTotalStationsGInOctets=apTotalStationsGInOctets, apChnlUtilAverageUtilization=apChnlUtilAverageUtilization, muRxOctets=muRxOctets)
mibBuilder.exportSymbols("HIPATH-WIRELESS-HWC-MIB", wlanRadiusServerUse=wlanRadiusServerUse, siteWlanApRadioIndex=siteWlanApRadioIndex, vnsWDSStatAPParent=vnsWDSStatAPParent, maxBestEffortBWforReassociation=maxBestEffortBWforReassociation, muTSPECEntry=muTSPECEntry, muDuration=muDuration, sitePolicyEntry=sitePolicyEntry, vnsQoSPriorityOverrideDSCP=vnsQoSPriorityOverrideDSCP, inSrvScanGrpScan2400MHzSelection=inSrvScanGrpScan2400MHzSelection, imagePath26xx=imagePath26xx, siteGroup=siteGroup, physicalPortObjects=physicalPortObjects, cpConnectionPort=cpConnectionPort, maxBackgroundBWforAssociation=maxBackgroundBWforAssociation, apLLDP=apLLDP, threatSummaryGroup=threatSummaryGroup, loadGrpRadiosTable=loadGrpRadiosTable, vnsWDSStatEntry=vnsWDSStatEntry, apLogFileCopyProtocol=apLogFileCopyProtocol, stationsByProtocolA=stationsByProtocolA, maxVoiceBWforReassociation=maxVoiceBWforReassociation, wlanCPGuestAllowedLifetimeAcct=wlanCPGuestAllowedLifetimeAcct, apNeighboursTable=apNeighboursTable, apRadioStatusChannelOffset=apRadioStatusChannelOffset, apPerfRadioCurrentSNR=apPerfRadioCurrentSNR, loadGrpWlanTable=loadGrpWlanTable, mgmtPortIfIndex=mgmtPortIfIndex, topoStatEntry=topoStatEntry, portName=portName, topologySynchronize=topologySynchronize, apLogCollectionEnable=apLogCollectionEnable, vnsRateControlCIR=vnsRateControlCIR, vnsAPFilterProtocol=vnsAPFilterProtocol, advancedFilteringMode=advancedFilteringMode, apAccCurrentDisassocDeauthReqTx=apAccCurrentDisassocDeauthReqTx, wirelessQoS=wirelessQoS, radiusFastFailoverEvents=radiusFastFailoverEvents, radiusFastFailoverEventsTable=radiusFastFailoverEventsTable, topologyDHCPUsage=topologyDHCPUsage, apRadioStatusChannelWidth=apRadioStatusChannelWidth, muIPAddress=muIPAddress, inSrvScanGrpMaxConcurrentAttacksPerAP=inSrvScanGrpMaxConcurrentAttacksPerAP, loadGroupBandPreference=loadGroupBandPreference, vnsPrivacyEntry=vnsPrivacyEntry, authorizedAPEntry=authorizedAPEntry, apLogFTProtocol=apLogFTProtocol, vnsFilterRuleProtocol=vnsFilterRuleProtocol, vnsConfigWLANID=vnsConfigWLANID, netflowInterval=netflowInterval, loadBalancing=loadBalancing, wlanServiceType=wlanServiceType, topology=topology, vnsExceptionStatPktsAllowed=vnsExceptionStatPktsAllowed, muEntry=muEntry, topoCompleteStatRxOctets=topoCompleteStatRxOctets, vnsDNSServers=vnsDNSServers, outOfSrvScanGrpChannelDwellTime=outOfSrvScanGrpChannelDwellTime, vnsRadiusServerName=vnsRadiusServerName, ntpTimeServer2=ntpTimeServer2, apAccAverageAssocReqRx=apAccAverageAssocReqRx, blacklistedClientTable=blacklistedClientTable, apSoftwareVersion=apSoftwareVersion, apAccCurPeakDisassocDeauthReqRx=apAccCurPeakDisassocDeauthReqRx, vnsFilterIDEntry=vnsFilterIDEntry, apPerfWlanCurrentDLPktsPerSec=apPerfWlanCurrentDLPktsPerSec, activeThreatTable=activeThreatTable, radiusAccounting=radiusAccounting, LogEventSeverity=LogEventSeverity, apLogFileCopyOperation=apLogFileCopyOperation, apSecureDataTunnelType=apSecureDataTunnelType, topologyTagged=topologyTagged, apEventId=apEventId, siteLoadControlEnableR2=siteLoadControlEnableR2, vnsWEPKeyTable=vnsWEPKeyTable, pairIPAddress=pairIPAddress, vnsConfigObjects=vnsConfigObjects, threatSummaryHistoricalCounts=threatSummaryHistoricalCounts, apLogFileCopyIndex=apLogFileCopyIndex, scanAPTable=scanAPTable, topoStatMulticastRxPkts=topoStatMulticastRxPkts, radioVNSEntry=radioVNSEntry, radioIfIndex=radioIfIndex, externalRadiusServerEntry=externalRadiusServerEntry, apAccAverageReassocReqRx=apAccAverageReassocReqRx, wlanPrivManagementFrameProtection=wlanPrivManagementFrameProtection, apPerfWlanCurPeakDLOctetsPerSec=apPerfWlanCurPeakDLOctetsPerSec, siteCosGroup=siteCosGroup, wlanRadiusServerMacPW=wlanRadiusServerMacPW, apEntry=apEntry, vnsQoSPriorityOverrideSC=vnsQoSPriorityOverrideSC, clearAccessRejectMsg=clearAccessRejectMsg, apHome=apHome, apTotalStationsGOutOctets=apTotalStationsGOutOctets, apTotalStationsACInOctets=apTotalStationsACInOctets, siteTableNextAvailableIndex=siteTableNextAvailableIndex, topologyMode=topologyMode, wlanAuthRadiusIncludeVNS=wlanAuthRadiusIncludeVNS, topoStatMulticastTxPkts=topoStatMulticastTxPkts, apHostname=apHostname, wassp=wassp, scanGroupAPAssignRadio2=scanGroupAPAssignRadio2, vnsWDSRFaService=vnsWDSRFaService, radiusExtnsSettingEntry=radiusExtnsSettingEntry, wlanRemoteable=wlanRemoteable, externalRadiusServerAddress=externalRadiusServerAddress, stationName=stationName, tspecUlRate=tspecUlRate, uncategorizedAPClassify=uncategorizedAPClassify, apIndex=apIndex, apPerformanceReportbyRadioAndWlanTable=apPerformanceReportbyRadioAndWlanTable, wlanBlockMuToMuTraffic=wlanBlockMuToMuTraffic, wlanAuthReplaceCalledStationIDWithZone=wlanAuthReplaceCalledStationIDWithZone, apPerfWlanCurrentULPktsPerSec=apPerfWlanCurrentULPktsPerSec, sysSerialNo=sysSerialNo, widsWipsEngineTable=widsWipsEngineTable, wlan=wlan, vnsDHCPRangeIndex=vnsDHCPRangeIndex, synchronizeSystemConfig=synchronizeSystemConfig, apZone=apZone, radiusExtnsIndex=radiusExtnsIndex, scanGroupProfileID=scanGroupProfileID, prohibitedAPTable=prohibitedAPTable, wlanStatsGroup=wlanStatsGroup, apTotalStationsN50OutOctets=apTotalStationsN50OutOctets, wlanAuthMACBasedAuthOnRoam=wlanAuthMACBasedAuthOnRoam, wlanCPExtAddIPtoURL=wlanCPExtAddIPtoURL, vnsStatTxPkts=vnsStatTxPkts, muTSPECTable=muTSPECTable, vnsAPFilterAction=vnsAPFilterAction, cpURL=cpURL, wlanCPExtConnection=wlanCPExtConnection, assocVnsIfIndex=assocVnsIfIndex, outOfSrvScanGrpRadio=outOfSrvScanGrpRadio, blacklistedClientReason=blacklistedClientReason, muAccessListGroup=muAccessListGroup, vnsMUSessionTimeout=vnsMUSessionTimeout, uncategorizedAPEntry=uncategorizedAPEntry, wlanRadiusAuthType=wlanRadiusAuthType, apTotalStationsAC=apTotalStationsAC, apLogSelectedAPsTable=apLogSelectedAPsTable, threatSummaryEntry=threatSummaryEntry, wlanStatsRadiusReqRejected=wlanStatsRadiusReqRejected, vnsEnabled=vnsEnabled, activeThreatEntry=activeThreatEntry, apRegDiscoveryRetries=apRegDiscoveryRetries, wlanCPExtSharedSecret=wlanCPExtSharedSecret, radiusFFOEid=radiusFFOEid, topoWireStatTxOctets=topoWireStatTxOctets, sysLogServersTable=sysLogServersTable, apAccCurrentAssocReqRx=apAccCurrentAssocReqRx, uncategorizedAPSSID=uncategorizedAPSSID, muAccessListEntry=muAccessListEntry, dedicatedScanGrpCounterMeasures=dedicatedScanGrpCounterMeasures, topoCompleteStatMulticastRxPkts=topoCompleteStatMulticastRxPkts, layerTwoPortGroup=layerTwoPortGroup, apLogFileUtilityCurrent=apLogFileUtilityCurrent, friendlyAPEntry=friendlyAPEntry, stationIPv6Address1=stationIPv6Address1, prohibitedAPDescription=prohibitedAPDescription, wlanCPExtEncryption=wlanCPExtEncryption, availabilityStatus=availabilityStatus, countermeasureAPEntry=countermeasureAPEntry, topoExceptionStatTable=topoExceptionStatTable, vnsVlanID=vnsVlanID, apPerfRadioCurPeakRSS=apPerfRadioCurPeakRSS, mgmtPortDomain=mgmtPortDomain, apRegSSHPassword=apRegSSHPassword, vnsRadiusServerRowStatus=vnsRadiusServerRowStatus, muState=muState, tunnelStartIP=tunnelStartIP, vnsQoSPriorityOverrideFlag=vnsQoSPriorityOverrideFlag, tspecMDR=tspecMDR, apOutUcastPkts=apOutUcastPkts, ntpServerEnabled=ntpServerEnabled, radiusExtnsSetting=radiusExtnsSetting, tspecDlRate=tspecDlRate, topologySyncGateway=topologySyncGateway, apIPMulticastAssembly=apIPMulticastAssembly, vnsWDSStatAPName=vnsWDSStatAPName, assocTxPackets=assocTxPackets, outOfSrvScanGrpScanTimeInterval=outOfSrvScanGrpScanTimeInterval, vnsAPFilterEtherType=vnsAPFilterEtherType, vnsRateControlProfile=vnsRateControlProfile, hiPathWirelessHWCConformance=hiPathWirelessHWCConformance, dedicatedScanGrpName=dedicatedScanGrpName, tspecDlViolations=tspecDlViolations, muBSSIDMac=muBSSIDMac, assocCount=assocCount, topologyManagementTraffic=topologyManagementTraffic, cpLogOff=cpLogOff, accessRejectMsgTable=accessRejectMsgTable, hiPathWirelessController=hiPathWirelessController, apPerfWlanPrevPeakClientsPerSec=apPerfWlanPrevPeakClientsPerSec, apLogFileCopyUserID=apLogFileCopyUserID, apVlanID=apVlanID, scanGroupMaxEntries=scanGroupMaxEntries, wlanCPGuestSessionLifetime=wlanCPGuestSessionLifetime, vnsQoSWireless80211eFlag=vnsQoSWireless80211eFlag, widsWipsObjectsGroup=widsWipsObjectsGroup, activeThreatThreat=activeThreatThreat, apPerfWlanPrevPeakDLPktsPerSec=apPerfWlanPrevPeakDLPktsPerSec, apAntennaTable=apAntennaTable, wlanCPIdentity=wlanCPIdentity, vnsCaptivePortalTable=vnsCaptivePortalTable, vnsFilterIDStatus=vnsFilterIDStatus, clientMessageDelayTime=clientMessageDelayTime, vnsWDSStatRxRSSI=vnsWDSStatRxRSSI, vnsRateControlProfName=vnsRateControlProfName, apTotalStationsG=apTotalStationsG, apTotalStationsN24InOctets=apTotalStationsN24InOctets, inSrvScanGrpCounterMeasuresType=inSrvScanGrpCounterMeasuresType, scanAPAcessPointName=scanAPAcessPointName, vnsWDSStatTable=vnsWDSStatTable, friendlyAPManufacturer=friendlyAPManufacturer, cpDefaultRedirectionURL=cpDefaultRedirectionURL, vnsRateControlProfTable=vnsRateControlProfTable, vnsDLSSupportEnable=vnsDLSSupportEnable, wlanRadiusServerMacAuthType=wlanRadiusServerMacAuthType, topologySyncIPEnd=topologySyncIPEnd, apPerfWlanPrevPeakULPktsPerSec=apPerfWlanPrevPeakULPktsPerSec, vnsAPFilterPortHigh=vnsAPFilterPortHigh, topologyMTUsize=topologyMTUsize, protocols=protocols, recurrenceMonthly=recurrenceMonthly, clientServiceTypeLogin=clientServiceTypeLogin, inSrvScanGrpName=inSrvScanGrpName, radacctStartOnIPAddr=radacctStartOnIPAddr, siteWlanEntry=siteWlanEntry, systemObjects=systemObjects, wlanCPExtPort=wlanCPExtPort, topologyAPRegistration=topologyAPRegistration, apPerfRadioCurPeakChannelUtilization=apPerfRadioCurPeakChannelUtilization, prohibitedAPGroup=prohibitedAPGroup, vnsAPFilterIPAddress=vnsAPFilterIPAddress, topologyStaticIPv6Address=topologyStaticIPv6Address, uncategorizedAPManufacturer=uncategorizedAPManufacturer, cpStatusCheck=cpStatusCheck, apLEDMode=apLEDMode, apTotalStationsAOutOctets=apTotalStationsAOutOctets, loadGrpWlanAssigned=loadGrpWlanAssigned, stationSessionNotifications=stationSessionNotifications, vnHeartbeatInterval=vnHeartbeatInterval, layerTwoPortName=layerTwoPortName, licenseType=licenseType, topoWireStatTable=topoWireStatTable, apLogServerIP=apLogServerIP, sysLogServerRowStatus=sysLogServerRowStatus, wlanCPGuestMinPassLength=wlanCPGuestMinPassLength, loadGroupEntry=loadGroupEntry, inSrvScanGrpRowStatus=inSrvScanGrpRowStatus, activeThreatCounterMeasure=activeThreatCounterMeasure, topoCompleteStatMulticastTxPkts=topoCompleteStatMulticastTxPkts, primaryDNS=primaryDNS, tunnelStatsEntry=tunnelStatsEntry)
mibBuilder.exportSymbols("HIPATH-WIRELESS-HWC-MIB", muVnsSSID=muVnsSSID, netflowAndMirrorN=netflowAndMirrorN, wlanRadiusTimeout=wlanRadiusTimeout, wlanEnabled=wlanEnabled, apLogFileCopyDestination=apLogFileCopyDestination, fastFailover=fastFailover, apPerfWlanCurrentDLOctetsPerSec=apPerfWlanCurrentDLOctetsPerSec, vnsWEPKeyEntry=vnsWEPKeyEntry, countermeasureAPTable=countermeasureAPTable, scanAPControllerIPAddress=scanAPControllerIPAddress, vnsStatBroadcastRxPkts=vnsStatBroadcastRxPkts, wlanCPAuthType=wlanCPAuthType, vnsWINSServers=vnsWINSServers, sitePolicyMember=sitePolicyMember, wlanSecurityReportGroup=wlanSecurityReportGroup, vnsRadiusServerRetries=vnsRadiusServerRetries, wlanCPCustomSpecificURL=wlanCPCustomSpecificURL, vnsFilterRuleTable=vnsFilterRuleTable, vnsConfigTable=vnsConfigTable, topologyName=topologyName, assocEntry=assocEntry, tunnelStatsTxRxBytes=tunnelStatsTxRxBytes, topologyID=topologyID, nearbyApInfo=nearbyApInfo, inSrvScanGrpClassifySourceIF=inSrvScanGrpClassifySourceIF, wlanAuthTable=wlanAuthTable, apRestartServiceContAbsent=apRestartServiceContAbsent, stationEventTimeStamp=stationEventTimeStamp, wlanRadiusServerName=wlanRadiusServerName, includeServiceType=includeServiceType, topoWireStatEntry=topoWireStatEntry, nearbyApBSSID=nearbyApBSSID, vnsStatRadiusReqRejected=vnsStatRadiusReqRejected, authenticationAdvancedGroup=authenticationAdvancedGroup, portMacAddress=portMacAddress, stationAPName=stationAPName, apPerfRadioCurrentChannelUtilization=apPerfRadioCurrentChannelUtilization, wlanMaxEntries=wlanMaxEntries, friendlyAPTable=friendlyAPTable, portEnabled=portEnabled, wlanPrivWPAv2EncryptionType=wlanPrivWPAv2EncryptionType, apLinkTimeout=apLinkTimeout, scanAPProfileType=scanAPProfileType, uncategorizedAPGroup=uncategorizedAPGroup, vnsWDSRFPreferredParent=vnsWDSRFPreferredParent, layerTwoPortMgmtState=layerTwoPortMgmtState, apLocation=apLocation, widsWips=widsWips, stationsByProtocol=stationsByProtocol, scanGroupAPAssignInactiveAP=scanGroupAPAssignInactiveAP, dhcpRelayListeners=dhcpRelayListeners, siteName=siteName, wlanQuietIE=wlanQuietIE, topoWireStatBroadcastTxPkts=topoWireStatBroadcastTxPkts, wlanRadioManagement11k=wlanRadioManagement11k, apRadioEntry=apRadioEntry, countermeasureAPCountermeasure=countermeasureAPCountermeasure, siteLoadControlEnableR1=siteLoadControlEnableR1, wirelessEWCGroups=wirelessEWCGroups, blacklistedClientEndTime=blacklistedClientEndTime, wlanRadiusServerAuthNASIP=wlanRadiusServerAuthNASIP, authorizedAPDescription=authorizedAPDescription, vnsSuppressSSID=vnsSuppressSSID, topoStatFrameTooLongErrors=topoStatFrameTooLongErrors, apPerfWlanCurrentULOctetsPerSec=apPerfWlanCurrentULOctetsPerSec, apChnlUtilPrevPeakUtilization=apChnlUtilPrevPeakUtilization, maxBestEffortBWforAssociation=maxBestEffortBWforAssociation, apSerialNumber=apSerialNumber, portDHCPDnsServers=portDHCPDnsServers, serverUsageModel=serverUsageModel, apStatus=apStatus, wlanPrivWPAPSK=wlanPrivWPAPSK, scanGroupAPAssignmentTable=scanGroupAPAssignmentTable, vnsQoSWirelessDLPolicerAction=vnsQoSWirelessDLPolicerAction, wlanMirrorN=wlanMirrorN, apStatsMuCounts=apStatsMuCounts, stationsByProtocolG=stationsByProtocolG, clientAutologinOption=clientAutologinOption, vnsStrictSubnetAdherence=vnsStrictSubnetAdherence, vnsExceptionStatEntry=vnsExceptionStatEntry, vnRole=vnRole, apPerformanceReportbyRadioAndWlanEntry=apPerformanceReportbyRadioAndWlanEntry, dedicatedScanGrpScan2400MHzFreq=dedicatedScanGrpScan2400MHzFreq, wlanPrivBroadcastRekeying=wlanPrivBroadcastRekeying, duration=duration, vnsStatEntry=vnsStatEntry, vnsDHCPRangeTable=vnsDHCPRangeTable, threatSummaryTable=threatSummaryTable, apAccCurrentReassocReqRx=apAccCurrentReassocReqRx, widsWipsEnginePollInterval=widsWipsEnginePollInterval, apMaintainClientSession=apMaintainClientSession, wlanRadiusNASID=wlanRadiusNASID, vnsFilterRulePortLow=vnsFilterRulePortLow, logEventDescription=logEventDescription, topoWireStatRxOctets=topoWireStatRxOctets, outOfServiceScanGroup=outOfServiceScanGroup, apLogFileUtilityLimit=apLogFileUtilityLimit, vnsAPFilterMask=vnsAPFilterMask, apLogFileCopyEntry=apLogFileCopyEntry, sysLogServerIndex=sysLogServerIndex, wlanCPGuestMaxConcurrentSession=wlanCPGuestMaxConcurrentSession, apEffectiveTunnelMTU=apEffectiveTunnelMTU, apLogQuickSelectedOption=apLogQuickSelectedOption, externalRadiusServerTable=externalRadiusServerTable, apOutNUcastPkts=apOutNUcastPkts, apRadioIndex=apRadioIndex, schedule=schedule, muAccessListTable=muAccessListTable, outOfServiceScanGroupEntry=outOfServiceScanGroupEntry, apSiteID=apSiteID, siteWlanTable=siteWlanTable, sysLogLevel=sysLogLevel, scanGroupAPAssignControllerIPAddress=scanGroupAPAssignControllerIPAddress, wlanNumEntries=wlanNumEntries, apAntennaType=apAntennaType, vnsFilterRuleEtherType=vnsFilterRuleEtherType, apStatsEntry=apStatsEntry, apPerfRadioCurrentRSS=apPerfRadioCurrentRSS, muRxPackets=muRxPackets, dnsObjects=dnsObjects, apRegClusterSharedSecret=apRegClusterSharedSecret, apPerfRadioPrevPeakChannelUtilization=apPerfRadioPrevPeakChannelUtilization, apPerfWlanAverageDLPktsPerSec=apPerfWlanAverageDLPktsPerSec, secondaryDNS=secondaryDNS, topologyEgressPort=topologyEgressPort, mirrorFirstN=mirrorFirstN, topoCompleteStatTable=topoCompleteStatTable, uncategorizedAPMAC=uncategorizedAPMAC, wlanRadiusNASIP=wlanRadiusNASIP, activeThreatRSS=activeThreatRSS, loadGroupClientCountRadio1=loadGroupClientCountRadio1, wlanPrivWPAv1EncryptionType=wlanPrivWPAv1EncryptionType, muTopologyName=muTopologyName, wlanBeaconReport=wlanBeaconReport, friendlyAPSSID=friendlyAPSSID, topologyConfig=topologyConfig, scanAPProfileName=scanAPProfileName, siteAPGroup=siteAPGroup, physicalPortsEntry=physicalPortsEntry, portFunction=portFunction, vnsRadiusServerNASIdentifier=vnsRadiusServerNASIdentifier, topologyDynamicEgress=topologyDynamicEgress, wlanSessionTimeout=wlanSessionTimeout, dhcpRelayListenersMaxEntries=dhcpRelayListenersMaxEntries, apConfigObjects=apConfigObjects, pollingMechanism=pollingMechanism, blacklistedClientEntry=blacklistedClientEntry, sysLogSupport=sysLogSupport, apTotalStationsAInOctets=apTotalStationsAInOctets, apPerfRadioPrevPeakPktRetx=apPerfRadioPrevPeakPktRetx, wlanRadiusServerTable=wlanRadiusServerTable, outOfSrvScanGrpName=outOfSrvScanGrpName, vnsEnable11hSupport=vnsEnable11hSupport, HundredthOfInt32=HundredthOfInt32)

#
# PySNMP MIB module CISCO-WAN-BBIF-ATM-CONN-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCO-WAN-BBIF-ATM-CONN-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:20:11 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ConstraintsUnion, ValueSizeConstraint, ValueRangeConstraint, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "ValueSizeConstraint", "ValueRangeConstraint", "SingleValueConstraint")
bbChanCnfGrp, bbChanStateGrp = mibBuilder.importSymbols("BASIS-MIB", "bbChanCnfGrp", "bbChanStateGrp")
ciscoWan, = mibBuilder.importSymbols("CISCOWAN-SMI", "ciscoWan")
ModuleCompliance, ObjectGroup, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "ObjectGroup", "NotificationGroup")
MibScalar, MibTable, MibTableRow, MibTableColumn, NotificationType, Gauge32, MibIdentifier, ObjectIdentity, Bits, TimeTicks, IpAddress, Counter64, Counter32, ModuleIdentity, Unsigned32, iso, Integer32 = mibBuilder.importSymbols("SNMPv2-SMI", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "NotificationType", "Gauge32", "MibIdentifier", "ObjectIdentity", "Bits", "TimeTicks", "IpAddress", "Counter64", "Counter32", "ModuleIdentity", "Unsigned32", "iso", "Integer32")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
ciscoWanBbifAtmConnMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 351, 150, 35))
ciscoWanBbifAtmConnMIB.setRevisions(('2002-09-09 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ciscoWanBbifAtmConnMIB.setRevisionsDescriptions(('Initial version of the MIB. The content of this MIB was originally available in CISCO-WAN-AXIPOP-MIB defined using SMIv1. The applicable objects from CISCO-WAN-AXIPOP-MIB are defined using SMIv2 in this MIB. Also the descriptions of some of the objects have been modified.',))
if mibBuilder.loadTexts: ciscoWanBbifAtmConnMIB.setLastUpdated('200209090000Z')
if mibBuilder.loadTexts: ciscoWanBbifAtmConnMIB.setOrganization('Cisco Systems, Inc.')
if mibBuilder.loadTexts: ciscoWanBbifAtmConnMIB.setContactInfo(' Cisco Systems Customer Service Postal: 170 W Tasman Drive San Jose, CA 95134 USA Tel: +1 800 553-NETS E-mail: cs-wanatm@cisco.com')
if mibBuilder.loadTexts: ciscoWanBbifAtmConnMIB.setDescription('The MIB module to configure the ATM Connections on a broad band interface in PXM1 Service module.')
class IfNsapAddress(TextualConvention, OctetString):
    description = 'ATM address used by the networking entity. The only address type presently supported is NSAP (20 octets)'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(20, 20)
    fixedLength = 20

bbChanCnfGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1), )
if mibBuilder.loadTexts: bbChanCnfGrpTable.setStatus('current')
if mibBuilder.loadTexts: bbChanCnfGrpTable.setDescription(' The Broadband Channel config table is for a channel on logical interface. There will an entry for each of the channel added on the logical partition of the physical line. Following parameters are needed if the connection is from a PXM user port and policing is enabled. These apply to connection on PXM lines confiured as user port only. PCR/CDVT is used for GCRA1 and SCR/MBS is used for GCRA2 UpcEnable UpcPCR UpcCDVT UpcSCRPolicing for CBR conns. UpcPCR0 UpcCDVT0 for non CBR conns. UpcSCR UpcMBS')
bbChanCnfGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1), ).setIndexNames((0, "CISCO-WAN-BBIF-ATM-CONN-MIB", "bbChanCnfNum"))
if mibBuilder.loadTexts: bbChanCnfGrpEntry.setStatus('current')
if mibBuilder.loadTexts: bbChanCnfGrpEntry.setDescription('The config table is for logical channel.')
bbChanCnfNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 4111))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bbChanCnfNum.setStatus('current')
if mibBuilder.loadTexts: bbChanCnfNum.setDescription(' This identifies a channel on the PXM logical interface, used as PXM port. ')
bbChanRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("add", 1), ("delete", 2), ("modify", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbChanRowStatus.setStatus('current')
if mibBuilder.loadTexts: bbChanRowStatus.setDescription('This object is used for adding/deleting/modifying entries in the table. add(1) : Adds the entry. delete(2) : Deletes the entry modify(3) : Set this before modifying any entries in the table. Following parameters need to be available before creating the entry: bbChanConnType, bbChanServiceType.')
bbChanConnType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("vpc", 1), ("vcc", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbChanConnType.setStatus('current')
if mibBuilder.loadTexts: bbChanConnType.setDescription('This specifies the connection type vpc(1) : Virtual Path Connection vcc(2) : Virtual Channel Connection This object can not be modified once the connection is created.')
bbChanServiceType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("cbr", 1), ("vbr", 2), ("abr", 3), ("ubr", 4), ("vbr-rt", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbChanServiceType.setStatus('current')
if mibBuilder.loadTexts: bbChanServiceType.setDescription(' This specifies the service type cbr(1) : Constant Bit Rate vbr(2) : Variable Bit Rate abr(3) : Available Bit Rate ubr(4) : Unspecified Bit Rate vbr-rt(5): Variable Bit Rate - Real Time This object can not be modified once the connection is created.')
bbChanConnDesc = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbChanConnDesc.setStatus('current')
if mibBuilder.loadTexts: bbChanConnDesc.setDescription('A string that has been defined to give a descriptive name to the connection.')
bbChanSvcFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("svc", 1), ("pvc", 2), ("spvc", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbChanSvcFlag.setStatus('current')
if mibBuilder.loadTexts: bbChanSvcFlag.setDescription('This specifies the connection type svc(1) : SVC connection pvc(2) : PVC connection, used by PAR(Portable Auto Route) spvc(3) : Soft PVC connection, used by PNNI')
bbChanSvcConnId = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbChanSvcConnId.setStatus('current')
if mibBuilder.loadTexts: bbChanSvcConnId.setDescription('This connection ID is for future use Currently not supported.')
bbChanIfNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbChanIfNum.setStatus('current')
if mibBuilder.loadTexts: bbChanIfNum.setDescription("Channel's logical Interface from which traffic of the connection will be received.")
bbChanVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbChanVpi.setStatus('current')
if mibBuilder.loadTexts: bbChanVpi.setDescription('VPI for the connection.')
bbChanVci = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbChanVci.setStatus('current')
if mibBuilder.loadTexts: bbChanVci.setDescription('VCI for the connection.')
bbChanUpcEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbChanUpcEnable.setStatus('current')
if mibBuilder.loadTexts: bbChanUpcEnable.setDescription('enables/disables UPC for Ingress cells.')
bbChanUpcPCR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(50, 1412832))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbChanUpcPCR.setStatus('current')
if mibBuilder.loadTexts: bbChanUpcPCR.setDescription('PCR(0+1), Peak Cell Rate, specifies an upper bound on rate at which traffic can be submitted on an ATM connection. This object applies to the First Leaky Bucket for leaving cells with Cell Loss Priority of 0 or 1. . Units: cells per second. . Applicable connection types: UBR, CBR, VBR, ABR . Default: 50 . Ranges: T3 : 50-96000 E3 : 50-80000 OC3 : 50-353208 OC12: 50-1412832 PCR is used for GCRA1.')
bbChanUpcCDVT = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbChanUpcCDVT.setStatus('current')
if mibBuilder.loadTexts: bbChanUpcCDVT.setDescription('Compliant Cell Delay Variation. Also known as CDVT(0+1), Cell Delay Variation Tolerance, which specifies the maximum time period for accumulated violations of cell-arrival time parameters. This object applies to the First Leaky bucket for cells with Cell Loss Priority of 0 or 1. . Units: microseconds. . Applicable connection types: UBR, CBR, VBR, ABR . Default: CBR: 10000 Others: 250000 ')
bbChanUpcSCR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1412832))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbChanUpcSCR.setStatus('current')
if mibBuilder.loadTexts: bbChanUpcSCR.setDescription(' SCR, Sustainable Cell Rate, is an upper bound on the conforming average rate of an ATM connection, over time scales which are long relative to those for which the PCR is defined. Enforcement of this bound by the UPC could allow the network to allocate sufficient resources, but less than thos based on the PCR, and still ensure that the performance objectives (e.g., Cell Loss Ratio) can be achieved. . Units: cell per second. . Applicable connection types: . VBR, ABR . Ranges: T3 : 50-96000 E3 : 50-80000 OC3 : 50-353208 OC12: 50-1412832 . Default: 50 ')
bbChanUpcMBS = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbChanUpcMBS.setStatus('current')
if mibBuilder.loadTexts: bbChanUpcMBS.setDescription('Maximum Burst Size (MBS). Also known as Compliant Burst Size (CBS). . Units: cells . Applicable connection types: . VBR, ABR . Default: 1000 . Range : 1-5000000 ')
bbChanGcra1Action = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("noAction", 1), ("tagCells", 2), ("tagAndDiscard", 3), ("discardAllNonComformCells", 4))).clone('discardAllNonComformCells')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbChanGcra1Action.setStatus('current')
if mibBuilder.loadTexts: bbChanGcra1Action.setDescription('GCRA1 Action. 1 = No Action 2 = Tag Untagged cells 3 = Tag untagged cells and discard tagged cells 4 = Discard all (0+1) non-comforming cells.')
bbChanGcra2Action = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("noAction", 1), ("tagCells", 2), ("tagAndDiscard", 3), ("discardAllNonComformCells", 4))).clone('discardAllNonComformCells')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbChanGcra2Action.setStatus('current')
if mibBuilder.loadTexts: bbChanGcra2Action.setDescription('GCRA2 Action. 1 = No Action 2 = Tag Untagged cells 3 = Tag untagged cells and discard tagged cells 4 = Discard all (0+1) non-comforming cells.')
bbChanUpcSCRPolicing = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("clp0", 1), ("clp0and1", 2), ("off", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbChanUpcSCRPolicing.setStatus('current')
if mibBuilder.loadTexts: bbChanUpcSCRPolicing.setDescription('Selects SCR policing for CLP = 0 or all cells.')
bbChanEfciThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 491520)).clone(196608)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbChanEfciThreshold.setStatus('current')
if mibBuilder.loadTexts: bbChanEfciThreshold.setDescription('Threshold above which EFCI bit is to be set. Default Value is 3/4 of max cell count.')
bbChanDiscardOption = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clpHysteresis", 1), ("frameDiscard", 2))).clone('clpHysteresis')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbChanDiscardOption.setStatus('current')
if mibBuilder.loadTexts: bbChanDiscardOption.setDescription('Enable Frame Discard or CLP Hysteresis.')
bbChanFrmDiscardThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 491520))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbChanFrmDiscardThreshold.setStatus('current')
if mibBuilder.loadTexts: bbChanFrmDiscardThreshold.setDescription('Ingress Frame Discard Threshold. Valid only when Ingress Frame Discard option is selected.')
bbChanClpHiThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 491520)).clone(196608)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbChanClpHiThreshold.setStatus('current')
if mibBuilder.loadTexts: bbChanClpHiThreshold.setDescription('Ingress CLP High Threshold. Default is 3/4 of max cell count.')
bbChanClpLoThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 491520)).clone(131072)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbChanClpLoThreshold.setStatus('current')
if mibBuilder.loadTexts: bbChanClpLoThreshold.setDescription('Ingress CLP Low Threshold. Valid only when Ingress CLP Hysteresis option is selected. Default Value is 1/2 of max cell count.')
bbChanCongstUpdateCode = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("dontUpdate", 1), ("setCiBit", 2), ("setEfciBit", 3), ("clearEfciBit", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbChanCongstUpdateCode.setStatus('current')
if mibBuilder.loadTexts: bbChanCongstUpdateCode.setDescription('Ingress Channel Congestion Update Code.')
bbChanMaxCellMemThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 512000)).clone(262144)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbChanMaxCellMemThreshold.setStatus('current')
if mibBuilder.loadTexts: bbChanMaxCellMemThreshold.setDescription('Maximum number of cells of that connection in the memory. Assuming Total Cell Memory is 512K cells, this is defaulted to half of total size.')
bbChanIngrPercentUtil = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbChanIngrPercentUtil.setStatus('current')
if mibBuilder.loadTexts: bbChanIngrPercentUtil.setDescription('Percentage Utilization of the IngrService Rate. This is used for connection admission control.')
bbChanEgrPercentUtil = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 27), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbChanEgrPercentUtil.setStatus('current')
if mibBuilder.loadTexts: bbChanEgrPercentUtil.setDescription('Percentage Utilization of the EgrService Rate. This is used for egress bandwidth calculation and connection admission control.')
bbChanEgrSrvRate = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 28), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1412832))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbChanEgrSrvRate.setStatus('current')
if mibBuilder.loadTexts: bbChanEgrSrvRate.setDescription('Egress service rate - This is used for egress bandwidth calculation and for connection admission control. The actual value depends on the speed of the logical interface.')
bbChanOvrSubOvrRide = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbChanOvrSubOvrRide.setStatus('current')
if mibBuilder.loadTexts: bbChanOvrSubOvrRide.setDescription('Channel Over Subscrive Override This MIB variable allows one to add a new connection on a port even if it is over subscribed. ')
bbChanLocalVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 30), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bbChanLocalVpi.setStatus('current')
if mibBuilder.loadTexts: bbChanLocalVpi.setDescription('The VPI value for this channel.')
bbChanLocalVci = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 31), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bbChanLocalVci.setStatus('current')
if mibBuilder.loadTexts: bbChanLocalVci.setDescription('The VCI value for this channel.')
bbChanLocalNsapAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 32), IfNsapAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbChanLocalNsapAddr.setStatus('current')
if mibBuilder.loadTexts: bbChanLocalNsapAddr.setDescription('The Near End NSAP Address value for this channel.')
bbChanRemoteVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 33), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbChanRemoteVpi.setStatus('current')
if mibBuilder.loadTexts: bbChanRemoteVpi.setDescription('The VPI value for this channel.')
bbChanRemoteVci = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 34), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbChanRemoteVci.setStatus('current')
if mibBuilder.loadTexts: bbChanRemoteVci.setDescription('The VCI value for this channel.')
bbChanRemoteNsapAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 35), IfNsapAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbChanRemoteNsapAddr.setStatus('current')
if mibBuilder.loadTexts: bbChanRemoteNsapAddr.setDescription('The Far End NSAP Address value for this channel.')
bbChanMaster = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 36), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("master", 1), ("slave", 2), ("unknown", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbChanMaster.setStatus('current')
if mibBuilder.loadTexts: bbChanMaster.setDescription('This is used by the PXM switch platform module, to determine if this endpoint ia master or slave.')
bbChanRtePriority = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 37), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbChanRtePriority.setStatus('current')
if mibBuilder.loadTexts: bbChanRtePriority.setDescription('This is also known as class of service, it is used by PXM to determine how important this connection is when selecting connections to route.')
bbChanMaxCost = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 38), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(255)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbChanMaxCost.setStatus('current')
if mibBuilder.loadTexts: bbChanMaxCost.setDescription("Maximum allowed cost. It is related to Cost Based Routing. This is used by PXM so that it won't choose a path with a cost greater than this configured level.")
bbChanRestrictTrkType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 39), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noRestriction", 1), ("terrestrialTrunk", 2), ("satelliteTrunk", 3))).clone('noRestriction')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbChanRestrictTrkType.setStatus('current')
if mibBuilder.loadTexts: bbChanRestrictTrkType.setDescription('Restricted trunk type for routind, used by PXM. It specifies that the connection either cannot be routed over satellite trunks or terrestrial trunks, or it can be on any type of trunk.')
bbChanTestType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("testcon", 1), ("testdelay", 2), ("notest", 3))).clone('notest')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbChanTestType.setStatus('current')
if mibBuilder.loadTexts: bbChanTestType.setDescription('The chanTestType starts testing the continuity or delay of a connection. It sends specific cell patterns toward the network and the terminating end of this connection has to be an AXIS or ASI of a BPX in order for this test to be working. The receiving node would loop back when it receives these cells. The test should be done in about couple of seconds. testcon(1) : The testcon tests the continuity of the connection and testdelay uses the same test except that it measures for delay through the network. To test the delay follow this procedure: a- set chanTestType to testdelay b- read chanTestState till it is Pass or Fail c- Read chanTestResult for the delay if it is Pass * Note that the chanTestType would go back to notest when the test is completed To test the continuity follow this procedure: a- set chanTestType to testcon b- read chanTestState till it is Pass or Fail * Note that the chanTestType would go back to notest when the test is completed You CAN NOT select 2 tests back to back, you have to select one and wait for the result and then start the other one.')
bbChanTestState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 41), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("passed", 1), ("failed", 2), ("inprogress", 3), ("notinprogress", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bbChanTestState.setStatus('current')
if mibBuilder.loadTexts: bbChanTestState.setDescription('This object provides the state of the test performed on a connection. When you add a connection then the chanTestState becomes notinprogress and when you select any test, it would go to inprogress state and after it completes the test, it will go to failed or passed state. 1 = Passed 2 = Failed 3 = In Progress 4 = Not In Progress ')
bbChanTestResult = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 42), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: bbChanTestResult.setStatus('current')
if mibBuilder.loadTexts: bbChanTestResult.setDescription('This is round trip delay in milliseconds. When you select testdelay option for the chanTestType, the result of the test that is measured in milliseconds can be read in chanTestResult.')
bbChanTestTypeCPESide = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 43), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("testconseg", 1), ("notest", 2))).clone('notest')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbChanTestTypeCPESide.setStatus('current')
if mibBuilder.loadTexts: bbChanTestTypeCPESide.setDescription('The chanTestType starts testing the segment continuity of a connection. It sends OAM Segment loopback cell towards port side (CPE) The CPE would loop back the cell To test the continuity follow this procedure: a- set chanTestTypeCPEside to testconseg b- read chanTestState till it is Pass or Fail *Note that the chanTestType would go back to notest when the test is completed.')
bbChanTestStateCPESide = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 44), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("passed", 1), ("failed", 2), ("inprogress", 3), ("notinprogress", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bbChanTestStateCPESide.setStatus('current')
if mibBuilder.loadTexts: bbChanTestStateCPESide.setDescription('This shows the state of the test When you add a connection then the chanTestState becomes notinprogress and when you select any test, it would go to inprogress state and after it completes the test, it will go to failed or passed state. 1 = Passed 2 = Failed 3 = In Progress 4 = Not In Progress')
bbConnVpcFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 45), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("vpc", 1), ("vcc", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbConnVpcFlag.setStatus('current')
if mibBuilder.loadTexts: bbConnVpcFlag.setDescription('This represents the connection type, used for PXM to identify VPC/VCC.')
bbConnServiceType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 46), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 6, 8))).clone(namedValues=NamedValues(("cbr", 1), ("vbr", 2), ("ubr", 4), ("abrstd", 6), ("vbrrt", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbConnServiceType.setStatus('current')
if mibBuilder.loadTexts: bbConnServiceType.setDescription(' This specifies the service type 1 ==> Constant Bit Rate 2 ==> Variable Bit Rate 4 ==> Unspecified Bit Rate 6 ==> Available Bit Rate ( standard ) 8 ==> Variable Bit Rate - Real-Time Note that this is used by PXM card, Also to make it compatible with existing AUSM MIB definition, value 3 is not used. foresight ABR is not supported in PXM , i.e Virtual Service Module ')
bbConnPCR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 47), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbConnPCR.setStatus('current')
if mibBuilder.loadTexts: bbConnPCR.setDescription(' Peak cell rate, could be derived from the end point parameter ')
bbConnSCR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 48), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbConnSCR.setStatus('current')
if mibBuilder.loadTexts: bbConnSCR.setDescription(' Sustained cell rate, could be derived from the end point parameter ')
bbConnPercentUtil = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 49), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100)).clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbConnPercentUtil.setStatus('current')
if mibBuilder.loadTexts: bbConnPercentUtil.setDescription(' This is the expected long-term utilization of the channel by this end-point. ')
bbRemoteConnPCR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 50), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbRemoteConnPCR.setStatus('current')
if mibBuilder.loadTexts: bbRemoteConnPCR.setDescription(' Peak cell rate of the other end, if not set, will be set to the same as local end PCR (bbChanUpcPCR). However, note that if the PCRs for both local and remote end are set to the different value (i.e., asymmetric conn), then this should be set differently from local end PCR. ')
bbRemoteConnSCR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 51), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbRemoteConnSCR.setStatus('current')
if mibBuilder.loadTexts: bbRemoteConnSCR.setDescription(' Sustained cell rate of the other end, if not set, will be set to the same as local end SCR (bbChanUpcSCR). However, note that if the PCRs for both local and remote end are set to the different value (i.e., asymmetric conn), then this should be set differently from local end SCR. ')
bbRemoteConnPercentUtil = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 52), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100)).clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbRemoteConnPercentUtil.setStatus('current')
if mibBuilder.loadTexts: bbRemoteConnPercentUtil.setDescription(" This is the expected long-term utilization of the channel by this end-point. If this is not specified in the connection setup request, it'll be defaulted to 100 percent ")
bbChanUpcMCR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 53), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1412832))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbChanUpcMCR.setStatus('current')
if mibBuilder.loadTexts: bbChanUpcMCR.setDescription(' SCR, Sustainable Cell Rate, is an upper bound on the conforming average rate of an ATM connection, over time scales which are long relative to those for which the PCR is defined. Enforcement of this bound by the UPC could allow the network to allocate sufficient resources, but less than thos based on the PCR, and still ensure that the performance objectives (e.g., Cell Loss Ratio) can be achieved. . Units: cell per second. . Applicable connection types: . ABR . Ranges: T3 : 50-96000 E3 : 50-80000 OC3 : 50-353208 OC12: 50-1412832 . Default: 50 ')
bbChanNumNextAvailable = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 4111))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bbChanNumNextAvailable.setStatus('current')
if mibBuilder.loadTexts: bbChanNumNextAvailable.setDescription(' This variable contains the next unused channel number of the possible 4096 . This number can be used in channel config table. ChanNumNextAvailable gets updated whenever this number is used to create a new logical channel. Value 0 for this variable indicates that no more channels are available. ')
bbChanVpIdNextAvailable = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bbChanVpIdNextAvailable.setStatus('current')
if mibBuilder.loadTexts: bbChanVpIdNextAvailable.setDescription(' This in only valid for a Service Module, will NOT be used in PXM. This variable contains the next unused local VPId of the possible 1 to 4095. This number can be used in channel config table. It gets updated if the number is used to create a new vp connection. The max. no. of VP conn.s is limited to the VPI range configured for this logical interface. Value of 0 for this variable indicates that no more vp connections are available ')
bbChanStateGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 2, 1), )
if mibBuilder.loadTexts: bbChanStateGrpTable.setStatus('current')
if mibBuilder.loadTexts: bbChanStateGrpTable.setDescription(' The Broadband Channel state table is for a channel on logical interface. There will an entry for each of the channel added on the logical partition of the physical line. ')
bbChanStateGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 2, 1, 1), ).setIndexNames((0, "CISCO-WAN-BBIF-ATM-CONN-MIB", "bbChanStateNum"))
if mibBuilder.loadTexts: bbChanStateGrpEntry.setStatus('current')
if mibBuilder.loadTexts: bbChanStateGrpEntry.setDescription(' The state table is for logical channel. The available number of channels on the broadband interface (user ports) on the PXM card is restricted to 4K. The PXM card has 2 Queue Engines ( QE0 and QE1). Current calculations allow 31954 GLCNs on QE0, and 31748 GLCNs on QE1. ')
bbChanStateNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 4111))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bbChanStateNum.setStatus('current')
if mibBuilder.loadTexts: bbChanStateNum.setDescription('Refers to the logical channel number.')
bbChanState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notconfigured", 1), ("normal", 2), ("alarm", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bbChanState.setStatus('current')
if mibBuilder.loadTexts: bbChanState.setDescription('This variable indicates the state of the VC (channel).')
bbChanEgrXmtState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("normal", 2), ("sendingAis", 3), ("sendingFerf", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bbChanEgrXmtState.setStatus('current')
if mibBuilder.loadTexts: bbChanEgrXmtState.setDescription('Indicates the status of port transmit(Egress).')
bbChanIngrRcvState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("normal", 2), ("receivingAis", 3), ("receivingFerf", 4), ("alarm", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bbChanIngrRcvState.setStatus('current')
if mibBuilder.loadTexts: bbChanIngrRcvState.setDescription('indicates the status of port receive(Ingress).')
cwbAtmConnMIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 150, 35, 2))
cwbAtmConnMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 150, 35, 2, 1))
cwbAtmConnMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 150, 35, 2, 2))
cwbAtmConnCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 351, 150, 35, 2, 2, 1)).setObjects(("CISCO-WAN-BBIF-ATM-CONN-MIB", "cwbAtmConnGroup"), ("CISCO-WAN-BBIF-ATM-CONN-MIB", "cwbAtmConnStateGroup"), ("CISCO-WAN-BBIF-ATM-CONN-MIB", "cwbAtmConnGeneralGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cwbAtmConnCompliance = cwbAtmConnCompliance.setStatus('current')
if mibBuilder.loadTexts: cwbAtmConnCompliance.setDescription('The compliance statement for SNMP entities which support Frame realy connection MIB.')
cwbAtmConnGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 351, 150, 35, 2, 1, 1)).setObjects(("CISCO-WAN-BBIF-ATM-CONN-MIB", "bbChanCnfNum"), ("CISCO-WAN-BBIF-ATM-CONN-MIB", "bbChanRowStatus"), ("CISCO-WAN-BBIF-ATM-CONN-MIB", "bbChanConnType"), ("CISCO-WAN-BBIF-ATM-CONN-MIB", "bbChanServiceType"), ("CISCO-WAN-BBIF-ATM-CONN-MIB", "bbChanConnDesc"), ("CISCO-WAN-BBIF-ATM-CONN-MIB", "bbChanSvcFlag"), ("CISCO-WAN-BBIF-ATM-CONN-MIB", "bbChanSvcConnId"), ("CISCO-WAN-BBIF-ATM-CONN-MIB", "bbChanIfNum"), ("CISCO-WAN-BBIF-ATM-CONN-MIB", "bbChanVpi"), ("CISCO-WAN-BBIF-ATM-CONN-MIB", "bbChanVci"), ("CISCO-WAN-BBIF-ATM-CONN-MIB", "bbChanUpcEnable"), ("CISCO-WAN-BBIF-ATM-CONN-MIB", "bbChanUpcPCR"), ("CISCO-WAN-BBIF-ATM-CONN-MIB", "bbChanUpcCDVT"), ("CISCO-WAN-BBIF-ATM-CONN-MIB", "bbChanUpcSCR"), ("CISCO-WAN-BBIF-ATM-CONN-MIB", "bbChanUpcMBS"), ("CISCO-WAN-BBIF-ATM-CONN-MIB", "bbChanGcra1Action"), ("CISCO-WAN-BBIF-ATM-CONN-MIB", "bbChanGcra2Action"), ("CISCO-WAN-BBIF-ATM-CONN-MIB", "bbChanUpcSCRPolicing"), ("CISCO-WAN-BBIF-ATM-CONN-MIB", "bbChanEfciThreshold"), ("CISCO-WAN-BBIF-ATM-CONN-MIB", "bbChanDiscardOption"), ("CISCO-WAN-BBIF-ATM-CONN-MIB", "bbChanFrmDiscardThreshold"), ("CISCO-WAN-BBIF-ATM-CONN-MIB", "bbChanClpHiThreshold"), ("CISCO-WAN-BBIF-ATM-CONN-MIB", "bbChanClpLoThreshold"), ("CISCO-WAN-BBIF-ATM-CONN-MIB", "bbChanCongstUpdateCode"), ("CISCO-WAN-BBIF-ATM-CONN-MIB", "bbChanMaxCellMemThreshold"), ("CISCO-WAN-BBIF-ATM-CONN-MIB", "bbChanIngrPercentUtil"), ("CISCO-WAN-BBIF-ATM-CONN-MIB", "bbChanEgrPercentUtil"), ("CISCO-WAN-BBIF-ATM-CONN-MIB", "bbChanEgrSrvRate"), ("CISCO-WAN-BBIF-ATM-CONN-MIB", "bbChanOvrSubOvrRide"), ("CISCO-WAN-BBIF-ATM-CONN-MIB", "bbChanLocalVpi"), ("CISCO-WAN-BBIF-ATM-CONN-MIB", "bbChanLocalVci"), ("CISCO-WAN-BBIF-ATM-CONN-MIB", "bbChanLocalNsapAddr"), ("CISCO-WAN-BBIF-ATM-CONN-MIB", "bbChanRemoteVpi"), ("CISCO-WAN-BBIF-ATM-CONN-MIB", "bbChanRemoteVci"), ("CISCO-WAN-BBIF-ATM-CONN-MIB", "bbChanRemoteNsapAddr"), ("CISCO-WAN-BBIF-ATM-CONN-MIB", "bbChanMaster"), ("CISCO-WAN-BBIF-ATM-CONN-MIB", "bbChanRtePriority"), ("CISCO-WAN-BBIF-ATM-CONN-MIB", "bbChanMaxCost"), ("CISCO-WAN-BBIF-ATM-CONN-MIB", "bbChanRestrictTrkType"), ("CISCO-WAN-BBIF-ATM-CONN-MIB", "bbChanTestType"), ("CISCO-WAN-BBIF-ATM-CONN-MIB", "bbChanTestState"), ("CISCO-WAN-BBIF-ATM-CONN-MIB", "bbChanTestResult"), ("CISCO-WAN-BBIF-ATM-CONN-MIB", "bbChanTestTypeCPESide"), ("CISCO-WAN-BBIF-ATM-CONN-MIB", "bbChanTestStateCPESide"), ("CISCO-WAN-BBIF-ATM-CONN-MIB", "bbConnVpcFlag"), ("CISCO-WAN-BBIF-ATM-CONN-MIB", "bbConnServiceType"), ("CISCO-WAN-BBIF-ATM-CONN-MIB", "bbConnPCR"), ("CISCO-WAN-BBIF-ATM-CONN-MIB", "bbConnSCR"), ("CISCO-WAN-BBIF-ATM-CONN-MIB", "bbConnPercentUtil"), ("CISCO-WAN-BBIF-ATM-CONN-MIB", "bbRemoteConnPCR"), ("CISCO-WAN-BBIF-ATM-CONN-MIB", "bbRemoteConnSCR"), ("CISCO-WAN-BBIF-ATM-CONN-MIB", "bbRemoteConnPercentUtil"), ("CISCO-WAN-BBIF-ATM-CONN-MIB", "bbChanUpcMCR"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cwbAtmConnGroup = cwbAtmConnGroup.setStatus('current')
if mibBuilder.loadTexts: cwbAtmConnGroup.setDescription('A collection of objects providing information applicable to an ATM Connection on broad band interfaces.')
cwbAtmConnStateGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 351, 150, 35, 2, 1, 2)).setObjects(("CISCO-WAN-BBIF-ATM-CONN-MIB", "bbChanStateNum"), ("CISCO-WAN-BBIF-ATM-CONN-MIB", "bbChanState"), ("CISCO-WAN-BBIF-ATM-CONN-MIB", "bbChanEgrXmtState"), ("CISCO-WAN-BBIF-ATM-CONN-MIB", "bbChanIngrRcvState"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cwbAtmConnStateGroup = cwbAtmConnStateGroup.setStatus('current')
if mibBuilder.loadTexts: cwbAtmConnStateGroup.setDescription('A collection of objects related to state of ATM Connections on Broad band interface.')
cwbAtmConnGeneralGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 351, 150, 35, 2, 1, 3)).setObjects(("CISCO-WAN-BBIF-ATM-CONN-MIB", "bbChanNumNextAvailable"), ("CISCO-WAN-BBIF-ATM-CONN-MIB", "bbChanVpIdNextAvailable"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cwbAtmConnGeneralGroup = cwbAtmConnGeneralGroup.setStatus('current')
if mibBuilder.loadTexts: cwbAtmConnGeneralGroup.setDescription('A collection of objects related to next available channeli number and next available VPI value of connections supported.')
mibBuilder.exportSymbols("CISCO-WAN-BBIF-ATM-CONN-MIB", bbChanLocalVci=bbChanLocalVci, bbChanUpcPCR=bbChanUpcPCR, bbChanClpHiThreshold=bbChanClpHiThreshold, IfNsapAddress=IfNsapAddress, bbChanUpcSCR=bbChanUpcSCR, bbChanRemoteVci=bbChanRemoteVci, bbChanMaster=bbChanMaster, bbChanMaxCost=bbChanMaxCost, bbChanRemoteVpi=bbChanRemoteVpi, bbChanTestTypeCPESide=bbChanTestTypeCPESide, bbConnPercentUtil=bbConnPercentUtil, bbRemoteConnPCR=bbRemoteConnPCR, bbChanVci=bbChanVci, bbChanStateGrpTable=bbChanStateGrpTable, bbChanLocalVpi=bbChanLocalVpi, cwbAtmConnCompliance=cwbAtmConnCompliance, bbChanUpcEnable=bbChanUpcEnable, cwbAtmConnMIBGroups=cwbAtmConnMIBGroups, cwbAtmConnStateGroup=cwbAtmConnStateGroup, bbChanIngrPercentUtil=bbChanIngrPercentUtil, bbChanTestState=bbChanTestState, bbChanCongstUpdateCode=bbChanCongstUpdateCode, bbChanIfNum=bbChanIfNum, bbChanClpLoThreshold=bbChanClpLoThreshold, bbChanNumNextAvailable=bbChanNumNextAvailable, bbChanVpIdNextAvailable=bbChanVpIdNextAvailable, bbChanStateNum=bbChanStateNum, bbChanRowStatus=bbChanRowStatus, bbChanRestrictTrkType=bbChanRestrictTrkType, bbChanGcra2Action=bbChanGcra2Action, bbChanUpcMCR=bbChanUpcMCR, ciscoWanBbifAtmConnMIB=ciscoWanBbifAtmConnMIB, bbChanEgrSrvRate=bbChanEgrSrvRate, bbChanCnfNum=bbChanCnfNum, bbChanEgrPercentUtil=bbChanEgrPercentUtil, bbChanTestResult=bbChanTestResult, bbChanUpcMBS=bbChanUpcMBS, bbRemoteConnPercentUtil=bbRemoteConnPercentUtil, bbChanOvrSubOvrRide=bbChanOvrSubOvrRide, bbChanStateGrpEntry=bbChanStateGrpEntry, bbConnPCR=bbConnPCR, bbChanSvcFlag=bbChanSvcFlag, bbChanMaxCellMemThreshold=bbChanMaxCellMemThreshold, bbChanRtePriority=bbChanRtePriority, cwbAtmConnGroup=cwbAtmConnGroup, bbChanUpcCDVT=bbChanUpcCDVT, bbConnSCR=bbConnSCR, bbChanGcra1Action=bbChanGcra1Action, bbChanEgrXmtState=bbChanEgrXmtState, bbChanCnfGrpEntry=bbChanCnfGrpEntry, bbRemoteConnSCR=bbRemoteConnSCR, bbChanCnfGrpTable=bbChanCnfGrpTable, bbChanIngrRcvState=bbChanIngrRcvState, bbConnVpcFlag=bbConnVpcFlag, bbChanTestStateCPESide=bbChanTestStateCPESide, bbChanRemoteNsapAddr=bbChanRemoteNsapAddr, bbChanSvcConnId=bbChanSvcConnId, cwbAtmConnMIBCompliances=cwbAtmConnMIBCompliances, bbChanDiscardOption=bbChanDiscardOption, bbChanConnType=bbChanConnType, bbChanFrmDiscardThreshold=bbChanFrmDiscardThreshold, bbChanLocalNsapAddr=bbChanLocalNsapAddr, PYSNMP_MODULE_ID=ciscoWanBbifAtmConnMIB, bbChanTestType=bbChanTestType, cwbAtmConnMIBConformance=cwbAtmConnMIBConformance, cwbAtmConnGeneralGroup=cwbAtmConnGeneralGroup, bbChanConnDesc=bbChanConnDesc, bbChanUpcSCRPolicing=bbChanUpcSCRPolicing, bbChanState=bbChanState, bbChanServiceType=bbChanServiceType, bbChanEfciThreshold=bbChanEfciThreshold, bbChanVpi=bbChanVpi, bbConnServiceType=bbConnServiceType)

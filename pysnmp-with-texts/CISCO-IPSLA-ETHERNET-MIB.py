#
# PySNMP MIB module CISCO-IPSLA-ETHERNET-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCO-IPSLA-ETHERNET-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:02:43 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ValueRangeConstraint, ConstraintsUnion, SingleValueConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsUnion", "SingleValueConstraint", "ConstraintsIntersection")
rttMonCtrlAdminIndex, = mibBuilder.importSymbols("CISCO-RTTMON-MIB", "rttMonCtrlAdminIndex")
RttMonIdLst, RttMonReactVar, RttMonCtrlIndex, RttMonRttType, RttResponseSense = mibBuilder.importSymbols("CISCO-RTTMON-TC-MIB", "RttMonIdLst", "RttMonReactVar", "RttMonCtrlIndex", "RttMonRttType", "RttResponseSense")
ciscoMgmt, = mibBuilder.importSymbols("CISCO-SMI", "ciscoMgmt")
Layer2Cos, = mibBuilder.importSymbols("CISCO-TC", "Layer2Cos")
Dot1agCfmMaintDomainNameType, Dot1agCfmMaintDomainName = mibBuilder.importSymbols("IEEE8021-CFM-MIB", "Dot1agCfmMaintDomainNameType", "Dot1agCfmMaintDomainName")
VlanId, = mibBuilder.importSymbols("Q-BRIDGE-MIB", "VlanId")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
ObjectGroup, ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "ModuleCompliance", "NotificationGroup")
TimeTicks, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter64, Integer32, IpAddress, Gauge32, ObjectIdentity, ModuleIdentity, Counter32, Unsigned32, Bits, NotificationType, MibIdentifier, iso = mibBuilder.importSymbols("SNMPv2-SMI", "TimeTicks", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter64", "Integer32", "IpAddress", "Gauge32", "ObjectIdentity", "ModuleIdentity", "Counter32", "Unsigned32", "Bits", "NotificationType", "MibIdentifier", "iso")
DisplayString, TimeStamp, TextualConvention, StorageType, RowStatus = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TimeStamp", "TextualConvention", "StorageType", "RowStatus")
ciscoIpSlaEthernetMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 9, 9, 585))
ciscoIpSlaEthernetMIB.setRevisions(('2012-05-15 00:00', '2008-01-02 00:00', '2006-02-08 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ciscoIpSlaEthernetMIB.setRevisionsDescriptions(('Added new object group ciscoIpSlaEthernetY1731Group. Added new compliance ciscoIpSlaEthernetComplianceRev3, which deprecates ciscoIpSlaEthenetComplianceRev2', 'Added object ipslaEthernetGrpCtrlEVC and ipslaEthernetGrpCtrlServiceInsType.', 'Initial version of this MIB module.',))
if mibBuilder.loadTexts: ciscoIpSlaEthernetMIB.setLastUpdated('201205150000Z')
if mibBuilder.loadTexts: ciscoIpSlaEthernetMIB.setOrganization('Cisco Systems, Inc.')
if mibBuilder.loadTexts: ciscoIpSlaEthernetMIB.setContactInfo('Cisco Systems, Inc. Customer Service Postal: 170 W Tasman Drive San Jose, CA 95134 Tel: +1 800 553 NETS Email: cs-ipsla@cisco.com')
if mibBuilder.loadTexts: ciscoIpSlaEthernetMIB.setDescription("This MIB module consists of two parts. 1) Auto-Ethernet-CFM Control: |-- ipslaEthernetGrpCtrlTable |-- ipslaEthernetGrpReactTable 2) ethernetJitter Stats: |-- ipslaEtherJitterLatestStatsTable |-- ipslaEtherJitterAggStatsTable The first part defines a mechanism to manage IP SLA Auto-Ethernet-CFM operation. IP SLA is a capability which utilizes active monitoring for network perfomance. It can be used for network troubleshooting, network assessment and health monitoring. IEEE 802.1ag defines Connection Fault Management (CFM) for Ethernet layer. CFM can be used to detect, isolate and report the connectivity faults, and allows discovery and verification of the path through briges and LANs. Auto-Ethernet-CFM operation integrates the capabilities of IP SLA and IEEE 802.1ag. It's capable of discovering all the existing MEPs in a specified VLAN or Ethernet Virtual Connection within a specified maintenance domain. After which, it creates, configures, and schedules an IP SLA operation for each MEP automatically. IP SLA currently supports two types of operations for end-to-end Ethernet connectivity - 'ethernetPing' and 'ethernetJitter'. 'ethernetPing' can be used to monitor the connectivity and measure RTT by sending the regular 802.1ag loopback frame to a particular MEP. 'ethernetJitter' can be used to measure metrics such as RTT, Jitter, frame loss, one-way latency by sending multiple enhanced CFM frames at specified interval to a particular MEP. Without Auto-Ethernet-CFM operation, the two types of operations can also be created, configured, and scheduled manually through CISCO-RTTMON-MIB by specifing the target MEP's identifier in addition to the VLAN or Ethernet Virtual Connection and Maintenance Domain. With Auto-Ethernet-CFM operation, the two types of operations will be created automatically. The Auto-Ethernet-CFM will pass all the values specified in this module to the corresponding objects in CISCO-RTTMON-MIB for each MEP discovered. CISCO-IPSLA-ETHERNET-MIB CISCO-RTTMON-MIB ipslaEthernetGrpCtrlTable -> rttMonCtrlAdminTable | -> rttMonEchoAdminTable ipslaEthernetGrpReactTable -> rttMonReactTable The second part defines a collection of statistics resulting from 'ethernetJitter' operation created either manually or automatically. Glossary: CFM - Connection Fault Management DSAP - Domain Service Access Point: A member of a set of SAPs at which a Maintenance Domain is capable of offering connectivity to systems outside the Maintenance Domain. IP SLA - Cisco IOS IP Service Level Agreements IP SLA operation - Refers to the 'ethernetPing' or 'ethernetJitter' operation supported by IP SLA. MEP - Maintenance association End Point: An actively managed CFM entity, associated with a specific DSAP of a service instance, which can generate and receive CFM PDUs and track any responses. maintenance domain - The network or the part of the network for which faults in connectivity are to be managed. The boundary of a Maintenance Domain is defined by a set of DSAPs, each of which can become a point of connectivity to a service instance. Maintenance Domain Name - The identifier, unique over the domain for which CFM is to protect against accidental concatenation of service instances, of a particular Maintenance Domain. RTT - Round Trip Time SAP - Service Access Point at which a service is offered. service instance - A service instance is a set of SAPs, selected from among the DSAPs defining a Maintenance Domain, such that a Data.Request primitive presented to one SAP can result in a Data.Indication primitive occurring at one or more of the other SAPs in the set. It corresponds to a VLAN or an Ethernet Virtual Connection. TLV - Stands for Type, Length, Value, and denotes a method of encoding variable-length and/or optional information in a PDU. TLVs are not aligned to any particular word or octet boundary. TLVs follow each other with no padding between TLVs. VLAN - Virtual Local Area Network: A subset of the active topology of a Bridged Local Area Network. Associated with each VLAN is a VLAN Identifier. REFERENCE: IEEE 802.1ag Draft 6.0 'Virtual Briged Local Area Networks - Amendments 5: Connectivity Fault Management' July 2006")
ciscoIpSlaEthernetMIBNotifs = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 585, 0))
ciscoIpSlaEthernetMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 585, 1))
ipslaEthernetGrpCtrl = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 1))
ipslaEthernetStats = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2))
ipslaEthernetLatestOper = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 3))
ipslaEthernetGrpCtrlTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 1, 1), )
if mibBuilder.loadTexts: ipslaEthernetGrpCtrlTable.setStatus('current')
if mibBuilder.loadTexts: ipslaEthernetGrpCtrlTable.setDescription("This table contains Auto-Ethernet-CFM control data. When a row transition to the 'active' state, the IP SLA agent will discover all the MEPs inside the specified VLAN and maintenance domain and create IP SLA ethernet operations based on the value of ipslaEthernetGrpCtrlRttType for each MEP. All the values in this table will be passed to the corresponding objects in the rttMonCtrlAdminTable and rttMonEchoAdminTable of CISCO-RTTMON-MIB so that each IP SLA Ethernet operation will have the same configuration as specified for Auto-Ethernet-CFM. - Objects in this table - Corresponding objects in rttMonCtrlAdminTable ipslaEthernetGrpCtrlStatus rttMonCtrlAdminStatus ipslaEthernetGrpCtrlRttType rttMonCtrlAdminRttType ipslaEthernetGrpCtrlOwner rttMonCtrlAdminOwner ipslaEthernetGrpCtrlTag rttMonCtrlAdminTag ipslaEthernetGrpCtrlThreshold rttMonCtrlAdminThreshold ipslaEthernetGrpCtrlTimeout rttMonCtrlAdminTimeout - Objects in this table - Corresponding objects in rttMonEchoAdminTable ipslaEthernetGrpCtrlVLAN rttMonEchoAdminTargetVLAN ipslaEthernetGrpCtrlDomainName rttMonEchoAdminTargetDomainName ipslaEthernetGrpCtrlReqDataSize rttMonEchoAdminPktDataRequestSize ipslaEthernetGrpCtrlCOS rttMonEchoAdminEthernetCOS ipslaEthernetGrpCtrlInterval rttMonEchoAdminInterval ipslaEthernetGrpCtrlNumFrames rttMonEchoAdminNumPackets ipslaEthernetGrpCtrlEVC rttMonEchoAdminTargetEVC")
ipslaEthernetGrpCtrlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 1, 1, 1), ).setIndexNames((0, "CISCO-IPSLA-ETHERNET-MIB", "ipslaEthernetGrpCtrlIndex"))
if mibBuilder.loadTexts: ipslaEthernetGrpCtrlEntry.setStatus('current')
if mibBuilder.loadTexts: ipslaEthernetGrpCtrlEntry.setDescription("A collection of objects that define a conceptual Auto-Ethernet-CFM control row. The following objects must be specified in order to create this conceptual row. - ipslaEthernetGrpCtrlStatus - ipslaEthernetGrpCtrlRttType The following objects must be specified in order to activate this conceptual row. - ipslaEthernetGrpCtrlVLAN OR - ipslaEthernetGrpCtrlEVC - ipslaEthernetGrpCtrlDomainName - ipslaEthernetGrpSchedulePeriod - ipslaEthernetGrpScheduleRttStartTime This conceptual row can be delete at any time by set the ipslaEthernetGrpCtrlStatus to 'destroy'. When this row is deleted, All the IP SLA operations created by this row will be destroyed.")
ipslaEthernetGrpCtrlIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 1, 1, 1, 1), RttMonCtrlIndex())
if mibBuilder.loadTexts: ipslaEthernetGrpCtrlIndex.setStatus('current')
if mibBuilder.loadTexts: ipslaEthernetGrpCtrlIndex.setDescription("This object indicates a row in the ipslaEthernetGrpCtrlTable. This value is a pseudo-random number selected by the management station when creating a row via the ipslaEthernetGrpCtrlStatus object. For easy management, user can select range of numbers for different maintenance domain. For instance, the ipslaEthernetGrpCtrlIndex 1-100 will be used for Domain_A, 101-200 will be used for Domain_B. If the pseudo-random number is already in use an 'inconsistentValue' return code will be returned when set operation is attempted.")
ipslaEthernetGrpCtrlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 1, 1, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipslaEthernetGrpCtrlStatus.setStatus('current')
if mibBuilder.loadTexts: ipslaEthernetGrpCtrlStatus.setDescription("This object specifies the status of Auto-Ethernet-CFM control row. Following objects must be specified in order for this object to become active. - ipslaEthernetGrpCtrlRttType - ipslaEthernetGrpCtrlVLAN OR - ipslaEthernetGrpCtrlEVC - ipslaEthernetGrpCtrlServiceInsType - ipslaEthernetGrpCtrlDomainName - ipslaEthernetGrpSchedulePeriod - ipslaEthernetGrpScheduleRttStartTime All other objects can assume default values. The following objects cannot be modified after creating the Auto-Ethernet-CFM conceptual row. - ipslaEthernetGrpCtrlRttType - ipslaEthernetGrpCtrlVLAN OR - ipslaEthernetGrpCtrlEVC - ipslaEthernetGrpCtrlDomainName - ipslaEthernetGrpCtrlServiceInsType The following objects can be modified even after creating the Auto-Ethernet-CFM conceptual row by setting this object to 'notInService' - All other writable objects in ipslaEthernetGrpCtrlTable except ipslaEthernetGrpCtrlRttType, ipslaEthernetGrpCtrlVLAN, ipslaEthernetGrpCtrlDomainName, ipslaEthernetGrpCtrlEVC and ipslaEthernetGrpCtrlServiceInsType - Objects in the ipslaEthernetGrpScheduleTable. The following objects can be modified as needed without setting this object to 'notInService' even after creating the Auto-Ethernet-CFM conceptual row. - Objects in ipslaEthernetGrpReactTable. This object can be set to 'destroy' from any value at any time. When this object is set to 'destroy' it will stop and destroy all the IP SLA operations created by this Auto-Ethernet-CFM before destroying Auto-Ethernet-CFM control row.")
ipslaEthernetGrpCtrlStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 1, 1, 1, 3), StorageType().clone('volatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipslaEthernetGrpCtrlStorageType.setStatus('current')
if mibBuilder.loadTexts: ipslaEthernetGrpCtrlStorageType.setDescription("This object specifies how the SNMP entity stores the data contained by the corresponding conceptual row. This object can be set to either 'volatile' or 'nonVolatile'. Other values are not applicable for this conceptual row and are not supported.")
ipslaEthernetGrpCtrlRttType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 1, 1, 1, 4), RttMonRttType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipslaEthernetGrpCtrlRttType.setStatus('current')
if mibBuilder.loadTexts: ipslaEthernetGrpCtrlRttType.setDescription("The type of IP SLA operation to be created by this Auto-Ethernet-CFM. This value can only be set to type 'ethernetPing' and 'ethernetJitter'. 'ethernetPing' operation sends the regular 802.1ag loopback frame to the target MEP to monitor the connectivity and perform delay analysis. 'ethernetJitter'sends multiple enhanced CFM frames at a specified interval to the target MEP to measure metrics such as RTT, jitter, frame loss, one-way latency and so on. This value must be set before setting any other parameter configuration of an Auto-Ethernet-CFM.")
ipslaEthernetGrpCtrlOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 1, 1, 1, 5), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipslaEthernetGrpCtrlOwner.setStatus('current')
if mibBuilder.loadTexts: ipslaEthernetGrpCtrlOwner.setDescription('A string which used by a managing application to identify the entity that created this Auto-Ethernet-CFM.')
ipslaEthernetGrpCtrlTag = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 1, 1, 1, 6), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipslaEthernetGrpCtrlTag.setStatus('current')
if mibBuilder.loadTexts: ipslaEthernetGrpCtrlTag.setDescription('A string which used by a managing application to identify the target VLAN and maintenance domain of this Auto-Ethernet-CFM.')
ipslaEthernetGrpCtrlThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 1, 1, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)).clone(5000)).setUnits('milliseconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipslaEthernetGrpCtrlThreshold.setStatus('current')
if mibBuilder.loadTexts: ipslaEthernetGrpCtrlThreshold.setDescription("This object specifies the threshold value of a particular object. This value will be examined for each IP SLA operations created by the Auto-Ethernet-CFM. For 'ethernetPing', if the value of rttMonLatestRttOperCompletionTime is greater than this value, the 'overThreshold' will be reported through rttMonLatestRttOperSense defined in CISCO-RTTMON-MIB. For 'ethernetJitter', if the value of ipslaEtherJitterLatestAvgJitter value is greater than this value, the 'overThreshold' will be reported through ipslaEtherJitterLatestSense defined this module.")
ipslaEthernetGrpCtrlTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 1, 1, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 604800000)).clone(5000)).setUnits('milliseconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipslaEthernetGrpCtrlTimeout.setStatus('current')
if mibBuilder.loadTexts: ipslaEthernetGrpCtrlTimeout.setDescription("Specifies the duration to wait for an IP SLA operation created by this Auto-Ethernet-CFM to complete. For 'ethernetPing', if the value of rttMonLatestRttOperCompletionTime is greater than this value, the 'timeout' will be reported through rttMonLatestRttOperSense defined in CISCO-RTTMON-MIB. For 'ethernetJitter', if all the frames sent to target MEP have not been recievied within this duration, the 'timeout' will be reported through ipslaEtherJitterLatestSense defined this module. The value of this object cannot be set to a value which would specify a duration exceeding ipslaEthernetGrpScheduleFrequency.")
ipslaEthernetGrpCtrlProbeList = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 1, 1, 1, 9), RttMonIdLst()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEthernetGrpCtrlProbeList.setStatus('current')
if mibBuilder.loadTexts: ipslaEthernetGrpCtrlProbeList.setDescription('This object indicates the identifiers of the IP SLA operations that are created by the Auto-Ethernet-CFM. The identifier will be stored in rttMonCtrlAdminIndex defined in CISCO-RTTMON-MIB for each IP SLA operation.')
ipslaEthernetGrpCtrlVLAN = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 1, 1, 1, 10), VlanId()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipslaEthernetGrpCtrlVLAN.setStatus('current')
if mibBuilder.loadTexts: ipslaEthernetGrpCtrlVLAN.setDescription("This object specifies the identifier of VLAN for which the Auto-Ethernet-CFM operation will be used. It is an unique identifier for a service instance within a Maintenance Domain specified by ipslaEthernetGrpCtrlDomainName. The Auto-Ethernet-CFM will find all the MEPs participating in this VLAN and create IP SLA operations for each MEP corresponding to value specified in ipslaEthernetGrpCtrlRttType. The value of this object is in effect only when the value of ipslaEthernetGrpCtrlServiceInsType is set to 'vlan'.")
ipslaEthernetGrpCtrlDomainNameType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 1, 1, 1, 11), Dot1agCfmMaintDomainNameType().clone('none')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipslaEthernetGrpCtrlDomainNameType.setStatus('current')
if mibBuilder.loadTexts: ipslaEthernetGrpCtrlDomainNameType.setDescription("This object specifies the type of maintenance domain name to be used by the Auto-Ethernet-CFM operation. This object can only be set to the following values: 'none'(1) 'charString'(4) Other values are not supported. Value 'none' means that the ipslaEthernetGrpCtrlDomainName has not been specified.")
ipslaEthernetGrpCtrlDomainName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 1, 1, 1, 12), Dot1agCfmMaintDomainName()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipslaEthernetGrpCtrlDomainName.setStatus('current')
if mibBuilder.loadTexts: ipslaEthernetGrpCtrlDomainName.setDescription("This object specifies the maintenance domain name to be used by the Auto-Ethernet-CFM operation. The Auto-Ethernet-CFM operation discovers all the MEPs participating in the VLAN specified by ipslaEthernetGrpCtrlVLAN within this maintenance domain and create IP SLA operations for each MEP corresponding to value specified in ipslaEthernetGrpCtrlRttType. As long as the value of this object is specified, the value of ipslaEthernetGrpCtrlDomainNameType must be set to 'charString'.")
ipslaEthernetGrpCtrlReqDataSize = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 1, 1, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1400))).setUnits('octets').setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipslaEthernetGrpCtrlReqDataSize.setStatus('current')
if mibBuilder.loadTexts: ipslaEthernetGrpCtrlReqDataSize.setDescription("This object specifies the padding that needs to be inserted into each ethernet frame of the IP SLA operation. The total ethernet frame size of the IP SLA operation is: CFM_header + TLVs + si_length + dm_length + padding size where dm_length = number of octets of the maintenance domain name si_length = number of octets of the service instance name CFM_header = 8 octets TLVs = 60 octets for 'ethernetPing' 45 octets for 'ethernetJitter' If the total frame size exceeds 1500, only 1500 will be sent to the target MEP.")
ipslaEthernetGrpCtrlMPIDExLst = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 1, 1, 1, 14), RttMonIdLst()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipslaEthernetGrpCtrlMPIDExLst.setStatus('current')
if mibBuilder.loadTexts: ipslaEthernetGrpCtrlMPIDExLst.setDescription('This object specifies the identifiers of the MEPs that will be excluded when create IP SLA operations by Auto-Ethernet-CFM operation.')
ipslaEthernetGrpCtrlCOS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 1, 1, 1, 15), Layer2Cos()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipslaEthernetGrpCtrlCOS.setStatus('current')
if mibBuilder.loadTexts: ipslaEthernetGrpCtrlCOS.setDescription('This object specifies the Class Of Service field in an Ethernet frame header.')
ipslaEthernetGrpCtrlInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 1, 1, 1, 16), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 60000)).clone(20)).setUnits('milliseconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipslaEthernetGrpCtrlInterval.setStatus('current')
if mibBuilder.loadTexts: ipslaEthernetGrpCtrlInterval.setDescription("This value specifies the inter-frame delay between Ethernet frames that need to be transmitted to the target MEPs. This object is applicable to 'ethernetJitter' operation only.")
ipslaEthernetGrpCtrlNumFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 1, 1, 1, 17), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 60000)).clone(10)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipslaEthernetGrpCtrlNumFrames.setStatus('current')
if mibBuilder.loadTexts: ipslaEthernetGrpCtrlNumFrames.setDescription("This value specifies the number of Ethernet frames that need to be transmitted to the target MEPs. This object is applicable to 'ethernetJitter' operation only.")
ipslaEthernetGrpScheduleRttStartTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 1, 1, 1, 18), TimeTicks()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipslaEthernetGrpScheduleRttStartTime.setStatus('current')
if mibBuilder.loadTexts: ipslaEthernetGrpScheduleRttStartTime.setDescription("This object specifies the time when this conceptual row will become 'active'. ipslaEthernetGrpSchedulePeriod object must be specified before setting this object. When sysUpTime equals this value, this object will cause the conceptual Auto-Ethernet-CFM row transmit to 'active'and start to discover the existing MEPs. Meanwhile the IP SLA operations will be created for each discovered MEP, and rttMonCtrlAdminStatus of each IP SLA operation will transmit to 'active'. If this object has value as 1, the conceptual Auto-Ethernet-CFM row will transmit to 'active' right now. Value of 0 puts this conceptual row in pending state.")
ipslaEthernetGrpSchedulePeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 1, 1, 1, 19), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 604800))).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipslaEthernetGrpSchedulePeriod.setStatus('current')
if mibBuilder.loadTexts: ipslaEthernetGrpSchedulePeriod.setDescription('Specifies the time duration over which all the IP SLA operations created by the current Auto-Ethernet-CFM have to be scheduled. For instance, if there are three MEPs discovered, there will be three IP SLA operations created. If this object is set to 30, ipslaEthernetGrpScheduleRttStartTime is set to T, the start time of three operations will be spreaded evenly within 30 seconds, i.e. start time: T+0 -------- T+9 ----------T+19 operation1 operation2 operation3 This object must be set first before setting ipslaEthernetGrpScheduleRttStartTime.')
ipslaEthernetGrpScheduleFrequency = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 1, 1, 1, 20), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 604800))).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipslaEthernetGrpScheduleFrequency.setStatus('current')
if mibBuilder.loadTexts: ipslaEthernetGrpScheduleFrequency.setDescription('Specifies the duration between initiating each IP SLA operation created by the Auto-Ethernet-CFM. Take above example, if the ipslaEthernetGrpScheduleFrequency is set to 60, then the start time of each IP SLA operation like: start time: T+0 -------- T+9 ----------T+19----- operation1 operation2 operation3 start again: --T+60-------- T+69 ----------T+79-- operation1 operation2 operation3 start 3rd time:--T+120-------- T+129 ----------T+139-- operation1 operation2 operation3 This object cannot be set to a value which would be a shorter duration than ipslaEthernetGrpCtrlTimeout. The default value of this object is the value set to ipslaEthernetGrpSchedulePeriod. This value will be passed to rttMonCtrlAdminFrequency for all the IP SLA operations created by the Auto-Ethernet-CFM.')
ipslaEthernetGrpCtrlEVC = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 1, 1, 1, 21), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 100))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipslaEthernetGrpCtrlEVC.setStatus('current')
if mibBuilder.loadTexts: ipslaEthernetGrpCtrlEVC.setDescription("This object specifies the Ethernet Virtual Connection for which the Auto-Ethernet-CFM operation will be used. It is an unique identifier for a service instance within a Maintenance Domain specified by ipslaEthernetGrpCtrlDomainName. The Auto-Ethernet-CFM will find all the MEPs participating in this Ethernet Virtual Connection and create IP SLA operations for each MEP corresponding to value specified in ipslaEthernetGrpCtrlRttType. The value of this object is in effect only when the value of ipslaEthernetGrpCtrlServiceInsType is set to 'evc'.")
ipslaEthernetGrpCtrlServiceInsType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 1, 1, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("vlan", 1), ("evc", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipslaEthernetGrpCtrlServiceInsType.setStatus('current')
if mibBuilder.loadTexts: ipslaEthernetGrpCtrlServiceInsType.setDescription("This object specifies the type of service instance to be used by the Auto-Ethernet-CFM operation. When this object is set to value 'vlan', ipslaEthernetGrpCtrlVLAN must be set, and the value of ipslaEthernetGrpCtrlVLAN will be used by the Auto-Ethernet-CFM to discover the participating MEPs. When this object is set to value 'evc', ipslaEthernetGrpCtrlEVC must be set, and the value of ipslaEthernetGrpCtrlEVC will be used by the Auto-Ethernet-CFM to discover the participating MEPs.")
ipslaEthernetGrpReactTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 1, 2), )
if mibBuilder.loadTexts: ipslaEthernetGrpReactTable.setStatus('current')
if mibBuilder.loadTexts: ipslaEthernetGrpReactTable.setDescription('A table that contains the reaction configurations for Auto-Ethernet-CFM operation. The reaction configuration specifies the network perfomance parameter needs to be monitored, the threshold for the parameter, the type of threshold violation that will trigger a reaction, and how to react upon a threshold being violated. This allows for proactive monitoring in an environment where user can be alerted to potential network problems, rather than having to manually examine data. Each conceptual row in ipslaEthernetGrpReactTable corresponds to a reaction configured for a corresponding Auto-Ethernet-CFM operation. Each Auto-Ethernet-CFM operation can have multiple parameters monitored and hence there can be multiple reaction configuration rows for a particular Auto-Ethernet-CFM operation. The reaction configurations in this table for a particular Auto-Ethernet-CFM operation will be passed to the corresponding objects in rttMonReactTable of CISCO-RTTMON-MIB for all the IP SLA operations created by this Auto-Ethernet-CFM. This makes the IP SLA operation capable of reacting to certain measured network condition such as long round trip delay, big jitter, etc., by generating a notification to a network management application based on defined thresholds. - Objects in this table - Corresponding objects in rttMonReactTable ipslaEthernetGrpReactConfigIndex rttMonReactConfigIndex ipslaEthernetGrpReactVar rttMonReactVar ipslaEthernetGrpReactThresholdType rttMonReactThresholdType ipslaEthernetGrpReactThresholdRising rttMonReactThresholdRising ipslaEthernetGrpReactThresholdFalling rttMonReactThresholdFalling ipslaEthernetGrpReactThresholdCountX rttMonReactThresholdCountX ipslaEthernetGrpReactThresholdCountY rttMonReactThresholdCountY ipslaEthernetGrpReactActionType rttMonReactActionType ipslaEthernetGrpReactStatus rttMonReactStatus This table is coupled with ipslaEthernetGrpCtrlTable. When an entry in the ipslaEthernetGrpCtrlTable is destroyed, the corresponding entries in this table will be destroyed too.')
ipslaEthernetGrpReactEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 1, 2, 1), ).setIndexNames((0, "CISCO-IPSLA-ETHERNET-MIB", "ipslaEthernetGrpCtrlIndex"), (0, "CISCO-IPSLA-ETHERNET-MIB", "ipslaEthernetGrpReactConfigIndex"))
if mibBuilder.loadTexts: ipslaEthernetGrpReactEntry.setStatus('current')
if mibBuilder.loadTexts: ipslaEthernetGrpReactEntry.setDescription("A collection of objects that define a conceptual Auto-Ethernet-CFM reaction configuration row. In order to create this conceptual row, ipslaEthernetGrpReactStatus must be set to 'createAndGo' and ipslaEthernetGrpReactVar must be specified. This conceptual row can be deleted at any time by set ipslaEthernetGrpReactStatus to 'destroy'. When this row is deleted, the corresponding reaction configuration of all the IP SLA operations are deleted.")
ipslaEthernetGrpReactConfigIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 1, 2, 1, 1), RttMonCtrlIndex())
if mibBuilder.loadTexts: ipslaEthernetGrpReactConfigIndex.setStatus('current')
if mibBuilder.loadTexts: ipslaEthernetGrpReactConfigIndex.setDescription("This object along with ipslaEthernetGrpCtrlEntry identifies a particular reaction-configuration for a particular Auto-Ethernet-CFM operation. This is a pseudo-random number selected by the management station when creating a row via the ipslaEthernetGrpReactStatus. If the pseudo-random number is already in use an 'inconsistentValue' return code will be returned when set operation is attempted.")
ipslaEthernetGrpReactStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 1, 2, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipslaEthernetGrpReactStatus.setStatus('current')
if mibBuilder.loadTexts: ipslaEthernetGrpReactStatus.setDescription("This objects specifies the status of the conceptual Auto-Ethernet-CFM reaction control row. Only 'createAndGo' and 'destroy' operations are permitted on the row. In order for this object to become 'active', ipslaEthernetGrpReactVar must be defined. All other objects assume the default value. When this object is in 'active' state, all the writable objects except ipslaEthernetGrpReactVar can be modified. When this object moves to 'active' state, the rttMonReactStatus of the individual IP SLA operations moves to 'active' state, thus the performance parameter specified in the reaction configuration is monitored for each IP SLA operation and the notifications are generated when the threshold violation takes place. This object can be set to 'destroy' from any value at any time. When this object is set to 'destroy', the reaction configuration of both Auto-Ethernet-CFM operation and IP SLA operations are removed.")
ipslaEthernetGrpReactStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 1, 2, 1, 3), StorageType().clone('volatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipslaEthernetGrpReactStorageType.setStatus('current')
if mibBuilder.loadTexts: ipslaEthernetGrpReactStorageType.setDescription("This object specifies how the SNMP entity stores the data contained by the corresponding conceptual row. This object can be set to either 'volatile' or 'nonVolatile'. Other values are not applicable for this conceptual row and are not supported.")
ipslaEthernetGrpReactVar = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 1, 2, 1, 4), RttMonReactVar()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipslaEthernetGrpReactVar.setStatus('current')
if mibBuilder.loadTexts: ipslaEthernetGrpReactVar.setDescription("This object specifies the performance parameter that will be monitored by the IP SLA operations which are created via Auto-Ethernet-CFM operation. The performance parameters that are valid to both 'ethernetJitter' and 'ethernetPing' include: - 'connectionLoss' - 'rtt' - 'timeout' The performance parameters that are only valid to 'ethernetJitter' include: - 'jitterSDAvg' - 'jitterDSAvg' - 'jitterAvg' - 'maxOfPositiveSD' - 'maxOfNegativeSD' - 'maxOfPositiveDS' - 'maxOfNegativeDS' - 'packetLateArrival' - 'packetLossDS' - 'packetLossSD' - 'packetOutOfSequence' - 'packetMIA'")
ipslaEthernetGrpReactThresholdType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 1, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("never", 1), ("immediate", 2), ("consecutive", 3), ("xOfy", 4), ("average", 5))).clone('never')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipslaEthernetGrpReactThresholdType.setStatus('current')
if mibBuilder.loadTexts: ipslaEthernetGrpReactThresholdType.setDescription("This object specifies the type of threshold violation that will trigger an notification. The notification will be sent accordingly only when the object rttMonReactOccurred which is defined in CISCO-RTTMON-MIB for IP SLA operation is set to 'true' or 'false'. 'never' - rttMonReactOccurred is never set 'immediate' - rttMonReactOccurred is set to 'true' when the value of parameter for which reaction is configured ( e.g. rtt, jitterAvg) violates the threshold. Conversely, rttMonReactOccurred is set to 'false' when the parameter ( e.g. rtt, jitterAvg) is below the threshold limits. 'consecutive'- rttMonReactOccurred is set to true when the value of parameter for which reaction is configured ( e.g. rtt, jitterAvg) violates the threshold for configured consecutive times. Conversely, rttMonReactOccurred is set to false when the value of parameter ( e.g. rtt, jitterAvg) is below the threshold limits for the same number of consecutive operations. 'xOfy' - rttMonReactOccurred is set to true when x ( as specified by ipslaEthernetGrpReactThresholdCountX ) out of the last y ( as specified by ipslaEthernetGrpReactThresholdCountY ) times the value of parameter for which the reaction is configured ( e.g. rtt, jitterAvg) violates the threshold. Conversely, it is set to false when x, out of the last y times the value of parameter ( e.g. rtt, jitterAvg) is below the threshold limits. 'average' - rttMonReactOccurred is set to true when the average (ipslaEthernetGrpReactThresholdCountX times ) value of parameter for which reaction is configured ( e.g. rtt, jitterAvg) violates the threshold condition. Conversely, it is set to false when the average value of parameter ( e.g. rtt, jitterAvg).")
ipslaEthernetGrpReactThresholdRising = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 1, 2, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipslaEthernetGrpReactThresholdRising.setStatus('current')
if mibBuilder.loadTexts: ipslaEthernetGrpReactThresholdRising.setDescription("This object specifies the higher threshold limit. If the value of monitored parameter ( e.g rtt, jitterAvg, packetLossSD etc ) rises above this limit and if the condition specified in ipslaEthernetGrpReactThresholdType are satisfied, a notification is generated. Default value of ipslaEthernetGrpReactThresholdRising for 'rtt' is 5000. 'jitterAvg' is 100. 'jitterSDAvg' is 100. 'jitterDSAvg' is 100. 'maxOfPositiveSD' is 10000. 'maxOfNegativeSD' is 10000. 'maxOfPositiveDS' is 10000. 'maxOfNegativeDS' is 10000. 'packetLossSD' is 10000. 'packetLossDS' is 10000. 'packetMIA' is 10000. 'packetLateArrival' is 10000. 'packetOutOfSequence' is 10000. This object is not applicable if the ipslaEthernetGrpReactVar is 'timeout' or 'connectionLoss'. For 'timeout' and 'connectionLoss', the default value will be 0.")
ipslaEthernetGrpReactThresholdFalling = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 1, 2, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipslaEthernetGrpReactThresholdFalling.setStatus('current')
if mibBuilder.loadTexts: ipslaEthernetGrpReactThresholdFalling.setDescription("This object specifies the lower threshold limit. If the value of monitored parameter ( e.g rtt, jitterAvg, packetLossSD etc ) falls below this limit and if the condition specified in ipslaEthernetGrpReactThresholdType are satisfied, a notification is generated. Default value of ipslaEthernetGrpReactThresholdFalling for 'rtt' is 3000. 'jitterAvg' is 100. 'jitterSDAvg' is 100. 'jitterDSAvg' is 100. 'maxOfPositiveSD' is 10000. 'maxOfNegativeSD' is 10000. 'maxOfPositiveDS' is 10000. 'maxOfNegativeDS' is 10000. 'packetLossSD' is 10000. 'packetLossDS' is 10000. 'packetMIA' is 10000. 'packetLateArrival' is 10000. 'packetOutOfSequence' is 10000. This object is not applicable if the ipslaEthernetGrpReactVar is 'timeout' or 'connectionLoss'. For 'timeout' and 'connectionLoss', the default value will be 0.")
ipslaEthernetGrpReactThresholdCountX = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 1, 2, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 16)).clone(5)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipslaEthernetGrpReactThresholdCountX.setStatus('current')
if mibBuilder.loadTexts: ipslaEthernetGrpReactThresholdCountX.setDescription("If ipslaEthernetGrpReactThresholdType value is 'xOfy', this object specifies the 'x' value. If ipslaEthernetGrpReactThresholdType value is 'consecutive', this object specifies the number of consecutive occurrences that needs threshold violation before setting rttMonReactOccurred as 'true'. If ipslaEthernetGrpReactThresholdType value is 'average', this object specifies the number of samples that needs be considered for calculating average. This object has no meaning if ipslaEthernetGrpReactThresholdType has value of 'never' and 'immediate'.")
ipslaEthernetGrpReactThresholdCountY = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 1, 2, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 16)).clone(5)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipslaEthernetGrpReactThresholdCountY.setStatus('current')
if mibBuilder.loadTexts: ipslaEthernetGrpReactThresholdCountY.setDescription("This object specifies the 'y' value of the xOfy condition if ipslaEthernetGrpReactThresholdType is 'xOfy'. For other values of ipslaEthernetGrpReactThresholdType, this object is not applicable.")
ipslaEthernetGrpReactActionType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 1, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("none", 1), ("notification", 2))).clone('none')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipslaEthernetGrpReactActionType.setStatus('current')
if mibBuilder.loadTexts: ipslaEthernetGrpReactActionType.setDescription("This object specifies what type of reaction to generate if an IP SLA operation violates one of the watched conditions (specified in ipslaEthernetGrpReactVar): 'none' - no reaction is generated. 'notification' - a notification is generated.")
ipslaEtherJitterLatestStatsTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 3, 1), )
if mibBuilder.loadTexts: ipslaEtherJitterLatestStatsTable.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJitterLatestStatsTable.setDescription("The 'ethernetJitter' operation sends out frames at the frequency specified by rttMonCtrlAdminFrequency. This table contains the statistics calculated for the latest sent frames. Each conceptual row in this table corresponds to an 'ethernetJitter' operation defined in rttMonCtrlAdminTable and has same index as rttMonCtrlAdminTable.")
ipslaEtherJitterLatestStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 3, 1, 1), ).setIndexNames((0, "CISCO-RTTMON-MIB", "rttMonCtrlAdminIndex"))
if mibBuilder.loadTexts: ipslaEtherJitterLatestStatsEntry.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJitterLatestStatsEntry.setDescription("A collection of objects that record the latest Ethernet jitter operation. An entry is created only when the following objects are valid. - rttMonCtrlAdminRttType - rttMonEchoAdminProtocol The entry will start to collect data when rttMonCtrlAdminStatus is in 'active' state. The entry will be removed when the rttMonCtrlAdminStatus is changed to 'destroy' state.")
ipslaEtherJitterLatestNumRTT = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 3, 1, 1, 1), Gauge32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJitterLatestNumRTT.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJitterLatestNumRTT.setDescription("The number of RTT's that were successfully measured.")
ipslaEtherJitterLatestRTTSum = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 3, 1, 1, 2), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJitterLatestRTTSum.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJitterLatestRTTSum.setDescription("The sum of RTT's that are successfully measured. The number of successfully measured RTT is stored in ipslaEtherJitterLatestNumRTT.")
ipslaEtherJitterLatestRTTSum2 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 3, 1, 1, 3), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJitterLatestRTTSum2.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJitterLatestRTTSum2.setDescription("The sum of squares of RTT's that are successfully measured.")
ipslaEtherJitterLatestRTTMin = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 3, 1, 1, 4), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJitterLatestRTTMin.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJitterLatestRTTMin.setDescription("The minimum of RTT's that were successfully measured.")
ipslaEtherJitterLatestRTTMax = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 3, 1, 1, 5), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJitterLatestRTTMax.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJitterLatestRTTMax.setDescription("The maximum of RTT's that were successfully measured.")
ipslaEtherJitterLatestMinPosSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 3, 1, 1, 6), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJitterLatestMinPosSD.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJitterLatestMinPosSD.setDescription('The minimum of all positive jitter values for frames sent from source to destination.')
ipslaEtherJitterLatestMaxPosSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 3, 1, 1, 7), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJitterLatestMaxPosSD.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJitterLatestMaxPosSD.setDescription('The maximum of all positive jitter values for frames sent from source to destination.')
ipslaEtherJitterLatestNumPosSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 3, 1, 1, 8), Gauge32()).setUnits('occurrences').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJitterLatestNumPosSD.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJitterLatestNumPosSD.setDescription('The number of all positive jitter values for frames sent from source to destination.')
ipslaEtherJitterLatestSumPosSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 3, 1, 1, 9), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJitterLatestSumPosSD.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJitterLatestSumPosSD.setDescription('The sum of all positive jitter values for frames sent source to destination. The number of such values is stored in ipslaEtherJitterLatestNumPosSD.')
ipslaEtherJitterLatestSum2PosSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 3, 1, 1, 10), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJitterLatestSum2PosSD.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJitterLatestSum2PosSD.setDescription('The sum of square of all positive jitter values for frames sent from source to destination.')
ipslaEtherJitterLatestMinNegSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 3, 1, 1, 11), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJitterLatestMinNegSD.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJitterLatestMinNegSD.setDescription('The minimum of absolute values of all negative jitter values for frames sent from source to destination.')
ipslaEtherJitterLatestMaxNegSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 3, 1, 1, 12), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJitterLatestMaxNegSD.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJitterLatestMaxNegSD.setDescription('The maximum of absolute values of all negative jitter values for frames sent from source to destination.')
ipslaEtherJitterLatestNumNegSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 3, 1, 1, 13), Gauge32()).setUnits('occurrences').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJitterLatestNumNegSD.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJitterLatestNumNegSD.setDescription('The number of all negative jitter values for frames sent from source to destination.')
ipslaEtherJitterLatestSumNegSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 3, 1, 1, 14), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJitterLatestSumNegSD.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJitterLatestSumNegSD.setDescription('The sum of all negative jitter values for frames sent from source to destination. The number of such values is stored in ipslaEtherJitterLatestNumNegSD.')
ipslaEtherJitterLatestSum2NegSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 3, 1, 1, 15), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJitterLatestSum2NegSD.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJitterLatestSum2NegSD.setDescription('The sum of square of all negative jitter values for frames sent from source to destination.')
ipslaEtherJitterLatestMinPosDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 3, 1, 1, 16), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJitterLatestMinPosDS.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJitterLatestMinPosDS.setDescription('The minimum of all positive jitter values for frames sent from destination to source.')
ipslaEtherJitterLatestMaxPosDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 3, 1, 1, 17), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJitterLatestMaxPosDS.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJitterLatestMaxPosDS.setDescription('The maximum of all positive jitter values for frames sent from destination to source.')
ipslaEtherJitterLatestNumPosDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 3, 1, 1, 18), Gauge32()).setUnits('occurrences').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJitterLatestNumPosDS.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJitterLatestNumPosDS.setDescription('The number of all positive jitter values for frames sent from destination to source.')
ipslaEtherJitterLatestSumPosDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 3, 1, 1, 19), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJitterLatestSumPosDS.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJitterLatestSumPosDS.setDescription('The sum of all positive jitter values for frames sent from destination to source. The number of such values is stored in ipslaEtherJitterLatestNumPosDS.')
ipslaEtherJitterLatestSum2PosDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 3, 1, 1, 20), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJitterLatestSum2PosDS.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJitterLatestSum2PosDS.setDescription('The sum of squares of all positive jitter values for frames sent from destination to source.')
ipslaEtherJitterLatestMinNegDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 3, 1, 1, 21), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJitterLatestMinNegDS.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJitterLatestMinNegDS.setDescription('The minimum of all negative jitter values for frames sent from destination to source.')
ipslaEtherJitterLatestMaxNegDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 3, 1, 1, 22), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJitterLatestMaxNegDS.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJitterLatestMaxNegDS.setDescription('The maximum of all negative jitter values for frames sent from destination to source.')
ipslaEtherJitterLatestNumNegDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 3, 1, 1, 23), Gauge32()).setUnits('occurrences').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJitterLatestNumNegDS.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJitterLatestNumNegDS.setDescription('The number of all negative jitter values for frames sent from destination to source.')
ipslaEtherJitterLatestSumNegDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 3, 1, 1, 24), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJitterLatestSumNegDS.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJitterLatestSumNegDS.setDescription('The sum of all negative jitter values for frames sent from destination to source. The number of such values is stored in ipslaEtherJitterLatestNumNegDS.')
ipslaEtherJitterLatestSum2NegDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 3, 1, 1, 25), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJitterLatestSum2NegDS.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJitterLatestSum2NegDS.setDescription('The sum of squares of all negative jitter values for frames sent from destination to source.')
ipslaEtherJitterLatestFrmLossSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 3, 1, 1, 26), Gauge32()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJitterLatestFrmLossSD.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJitterLatestFrmLossSD.setDescription('The number of frames lost when sent from source to destination.')
ipslaEtherJitterLatestFrmLossDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 3, 1, 1, 27), Gauge32()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJitterLatestFrmLossDS.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJitterLatestFrmLossDS.setDescription('The number of frames lost when sent from destination to source.')
ipslaEtherJitterLatestFrmOutSeq = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 3, 1, 1, 28), Gauge32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJitterLatestFrmOutSeq.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJitterLatestFrmOutSeq.setDescription('The number of frames arrived out of sequence.')
ipslaEtherJitterLatestFrmMIA = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 3, 1, 1, 29), Gauge32()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJitterLatestFrmMIA.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJitterLatestFrmMIA.setDescription('The number of frames that are lost for which we cannot determine the direction.')
ipslaEtherJitterLatestFrmSkipped = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 3, 1, 1, 30), Gauge32()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJitterLatestFrmSkipped.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJitterLatestFrmSkipped.setDescription('The number of frames in the operation that could not be initiated due to an internal error.')
ipslaEtherJitterLatestSense = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 3, 1, 1, 31), RttResponseSense()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJitterLatestSense.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJitterLatestSense.setDescription('An application specific sense code for the completion status.')
ipslaEtherJitterLatestFrmLateA = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 3, 1, 1, 32), Gauge32()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJitterLatestFrmLateA.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJitterLatestFrmLateA.setDescription('The number of frames that arrived after the timeout.')
ipslaEtherJitterLatestMinSucFrmL = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 3, 1, 1, 33), Gauge32()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJitterLatestMinSucFrmL.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJitterLatestMinSucFrmL.setDescription('The minimum number of frames that are dropped successively.')
ipslaEtherJitterLatestMaxSucFrmL = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 3, 1, 1, 34), Gauge32()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJitterLatestMaxSucFrmL.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJitterLatestMaxSucFrmL.setDescription('The maximum number of frames that are dropped successively.')
ipslaEtherJitterLatestOWSumSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 3, 1, 1, 35), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJitterLatestOWSumSD.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJitterLatestOWSumSD.setDescription('The sum of one way trip time from source to destination.')
ipslaEtherJitterLatestOWSum2SD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 3, 1, 1, 36), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJitterLatestOWSum2SD.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJitterLatestOWSum2SD.setDescription('The sum of squares of one way trip time from source to destination.')
ipslaEtherJitterLatestOWMinSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 3, 1, 1, 37), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJitterLatestOWMinSD.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJitterLatestOWMinSD.setDescription('The minimum of all one way trip time from source to destination.')
ipslaEtherJitterLatestOWMaxSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 3, 1, 1, 38), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJitterLatestOWMaxSD.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJitterLatestOWMaxSD.setDescription('The maximum of all one way trip time from source to destination.')
ipslaEtherJitterLatestOWSumDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 3, 1, 1, 39), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJitterLatestOWSumDS.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJitterLatestOWSumDS.setDescription('The sum of one way trip time from destination to source.')
ipslaEtherJitterLatestOWSum2DS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 3, 1, 1, 40), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJitterLatestOWSum2DS.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJitterLatestOWSum2DS.setDescription('The sum of squares of one way trip time from destination to source.')
ipslaEtherJitterLatestOWMinDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 3, 1, 1, 41), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJitterLatestOWMinDS.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJitterLatestOWMinDS.setDescription('The minimum of all one way trip time from destination to source.')
ipslaEtherJitterLatestOWMaxDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 3, 1, 1, 42), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJitterLatestOWMaxDS.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJitterLatestOWMaxDS.setDescription('The maximum of all one way trip time from destination to source.')
ipslaEtherJitterLatestNumOW = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 3, 1, 1, 43), Gauge32()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJitterLatestNumOW.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJitterLatestNumOW.setDescription('The number of successful one way trip time measurements.')
ipslaEtherJitterLatestAvgJitter = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 3, 1, 1, 44), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJitterLatestAvgJitter.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJitterLatestAvgJitter.setDescription('The average of positive and negative jitter values in Source-to-Destination and Destination-to-Source direction.')
ipslaEtherJitterLatestAvgSDJ = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 3, 1, 1, 45), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJitterLatestAvgSDJ.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJitterLatestAvgSDJ.setDescription('The average of positive and negative jitter values from source to destination.')
ipslaEtherJitterLatestAvgDSJ = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 3, 1, 1, 46), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJitterLatestAvgDSJ.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJitterLatestAvgDSJ.setDescription('The average of positive and negative jitter values from destination to source.')
ipslaEtherJitterLatestOWAvgSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 3, 1, 1, 47), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJitterLatestOWAvgSD.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJitterLatestOWAvgSD.setDescription('The average one way trip time from source to destination.')
ipslaEtherJitterLatestOWAvgDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 3, 1, 1, 48), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJitterLatestOWAvgDS.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJitterLatestOWAvgDS.setDescription('The average one way trip time from destination to source.')
ipslaEtherJitterLatestIAJOut = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 3, 1, 1, 49), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJitterLatestIAJOut.setReference('Refer to the following documents for the definition: RFC 1889, Section 6.3.1')
if mibBuilder.loadTexts: ipslaEtherJitterLatestIAJOut.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJitterLatestIAJOut.setDescription('Inter-arrival jitter (RFC 1889) at responder.')
ipslaEtherJitterLatestIAJIn = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 3, 1, 1, 50), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJitterLatestIAJIn.setReference('Refer to the following documents for the definition: RFC 1889, Section 6.3.1')
if mibBuilder.loadTexts: ipslaEtherJitterLatestIAJIn.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJitterLatestIAJIn.setDescription('Inter-arrival jitter (RFC 1889) at source.')
ipslaEtherJLatestFrmUnProcessed = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 3, 1, 1, 51), Gauge32()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJLatestFrmUnProcessed.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJLatestFrmUnProcessed.setDescription('The number of frames in the operation that could not be processed due to high CPU load.')
ipslaEtherJitterAggStatsTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1), )
if mibBuilder.loadTexts: ipslaEtherJitterAggStatsTable.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJitterAggStatsTable.setDescription("The 'ethernetJitter' statistics table contains summarized information of the results for a conceptual control row. A rolling accumulated history of this information is maintained in a series of hourly 'group(s)'. When ipslaEtherJAggStatsStartTimeId groups exceeds the rttMonStatisticsAdminNumHourGroups value, the oldest corresponding hourly group will be deleted and will be replaced with the new ipslaEtherJAggStatsStartTimeId hourly group.")
ipslaEtherJitterAggStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1), ).setIndexNames((0, "CISCO-RTTMON-MIB", "rttMonCtrlAdminIndex"), (0, "CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggStatsStartTimeId"))
if mibBuilder.loadTexts: ipslaEtherJitterAggStatsEntry.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJitterAggStatsEntry.setDescription("This entry contains the objects which accumulate the results of a series of 'ethernetJitter' operations over a 60 minute time period or a time period stored in rttMonScheduleAdminRttLife, whichever is smaller. An entry is created only if when the following objects are valid. - rttMonCtrlAdminRttType - rttMonEchoAdminProtocol The entry will start to collect data when rttMonCtrlAdminStatus is in 'active' state. The entry will be removed when the rttMonCtrlAdminStatus is changed to 'destroy' state.")
ipslaEtherJAggStatsStartTimeId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 1), TimeStamp())
if mibBuilder.loadTexts: ipslaEtherJAggStatsStartTimeId.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggStatsStartTimeId.setDescription('The value of sysUpTime at the time when this row was created.')
ipslaEtherJAggMeasuredCmpletions = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 2), Counter32()).setUnits('completions').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredCmpletions.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredCmpletions.setDescription('The number of Ethernet jitter operations that have completed successfully.')
ipslaEtherJAggMeasuredOvThrshlds = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 3), Counter32()).setUnits('operations').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredOvThrshlds.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredOvThrshlds.setDescription('The number of Ethernet jitter operations that violate jitterAvg threshold which is defined in RttMonReactVar.')
ipslaEtherJAggMeasuredNumRTTs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 4), Counter32()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredNumRTTs.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredNumRTTs.setDescription('The number of RTTs that are successfully measured.')
ipslaEtherJAggMeasuredRTTSums = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 5), Counter32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredRTTSums.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredRTTSums.setDescription('The sum of RTTs that are successfully measured for this ipslaEtherJAggMeasuredStartTimeId hourly group. The number of the successfully measured RTT is stored in the ipslaEtherJAggMeasuredNumRTTs.')
ipslaEtherJAggMeasuredRTTSum2Ls = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 6), Counter32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredRTTSum2Ls.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredRTTSum2Ls.setDescription('The sum of squares of RTTs that are successfully measured (low order 32 bits).')
ipslaEtherJAggMeasuredRTTSum2Hs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 7), Counter32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredRTTSum2Hs.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredRTTSum2Hs.setDescription('The sum of squares of RTTs that are successfully measured (high order 32 bits).')
ipslaEtherJAggMeasuredRTTMin = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 8), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredRTTMin.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredRTTMin.setDescription('The minimum of RTTs that were successfully measured.')
ipslaEtherJAggMeasuredRTTMax = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 9), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredRTTMax.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredRTTMax.setDescription('The maximum of RTTs that were successfully measured.')
ipslaEtherJAggMeasuredMinPosSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 10), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredMinPosSD.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredMinPosSD.setDescription('The minimum of absolute values of all positive jitter values for frames sent from source to destination.')
ipslaEtherJAggMeasuredMaxPosSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 11), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredMaxPosSD.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredMaxPosSD.setDescription('The maximum of absolute values of all positive jitter values for frames sent from source to destination.')
ipslaEtherJAggMeasuredNumPosSDs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 12), Counter32()).setUnits('occurrences').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredNumPosSDs.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredNumPosSDs.setDescription('The number of all positive jitter values for frames sent from source to destination.')
ipslaEtherJAggMeasuredSumPosSDs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 13), Counter32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredSumPosSDs.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredSumPosSDs.setDescription('The sum of all positive jitter values for frames sent from source to destination. The number of such values is stored in ipslaEtherJAggMeasuredNumPosSDs.')
ipslaEtherJAggMeasuredSum2PSDLs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 14), Counter32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredSum2PSDLs.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredSum2PSDLs.setDescription('The sum of square of all positive jitter values for frames sent from source to destination (low order 32 bits).')
ipslaEtherJAggMeasuredSum2PSDHs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 15), Counter32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredSum2PSDHs.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredSum2PSDHs.setDescription('The sum of square of all positive jitter values for frames sent from source to destination (high order 32 bits).')
ipslaEtherJAggMeasuredMinNegSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 16), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredMinNegSD.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredMinNegSD.setDescription('The minimum of all negative jitter values for frames sent from source to destination.')
ipslaEtherJAggMeasuredMaxNegSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 17), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredMaxNegSD.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredMaxNegSD.setDescription('The maximum of all negative jitter values for frames sent from source to destination.')
ipslaEtherJAggMeasuredNumNegSDs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 18), Counter32()).setUnits('occurrences').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredNumNegSDs.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredNumNegSDs.setDescription('The number of all negative jitter values for frames sent from source to destination.')
ipslaEtherJAggMeasuredSumNegSDs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 19), Counter32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredSumNegSDs.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredSumNegSDs.setDescription('The sum of all negative jitter values for frames sent from source to destination. The number of such values is stored in ipslaEtherJAggMeasuredNumNegSDs.')
ipslaEtherJAggMeasuredSum2NSDLs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 20), Counter32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredSum2NSDLs.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredSum2NSDLs.setDescription('The sum of square of all negative jitter values for frames sent from source to destination (low order 32 bits).')
ipslaEtherJAggMeasuredSum2NSDHs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 21), Counter32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredSum2NSDHs.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredSum2NSDHs.setDescription('The sum of square of all negative jitter values for frames sent from source to destination (high order 32 bits).')
ipslaEtherJAggMeasuredMinPosDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 22), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredMinPosDS.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredMinPosDS.setDescription('The minimum of all positive jitter values for frames sent from destination to source.')
ipslaEtherJAggMeasuredMaxPosDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 23), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredMaxPosDS.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredMaxPosDS.setDescription('The maximum of all positive jitter values for frames sent from destination to source.')
ipslaEtherJAggMeasuredNumPosDSes = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 24), Counter32()).setUnits('occurrences').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredNumPosDSes.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredNumPosDSes.setDescription('The number of all positive jitter values for frames sent from destination to source.')
ipslaEtherJAggMeasuredSumPosDSes = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 25), Counter32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredSumPosDSes.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredSumPosDSes.setDescription('The sum of all positive jitter values for frames sent from destination to source. The number of such values is stored in ipslaEtherJAggMeasuredNumPosDSes.')
ipslaEtherJAggMeasuredSum2PDSLs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 26), Counter32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredSum2PDSLs.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredSum2PDSLs.setDescription('The sum of squares of all positive jitter values for frames sent from destination to source (low order 32 bits).')
ipslaEtherJAggMeasuredSum2PDSHs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 27), Counter32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredSum2PDSHs.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredSum2PDSHs.setDescription('The sum of squares of all positive jitter values for frames sent from destination to source (high order 32 bits).')
ipslaEtherJAggMeasuredMinNegDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 28), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredMinNegDS.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredMinNegDS.setDescription('The minimum of all negative jitter values for frames sent from destination to source.')
ipslaEtherJAggMeasuredMaxNegDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 29), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredMaxNegDS.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredMaxNegDS.setDescription('The maximum of all negative jitter values for frames sent from destination to source.')
ipslaEtherJAggMeasuredNumNegDSes = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 30), Counter32()).setUnits('occurrences').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredNumNegDSes.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredNumNegDSes.setDescription('The number of all negative jitter values for frames sent from destination to source.')
ipslaEtherJAggMeasuredSumNegDSes = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 31), Counter32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredSumNegDSes.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredSumNegDSes.setDescription('The sum of all negative jitter values for frames sent from destination to source. The number of such values is stored in ipslaEtherJAggMeasuredNumNegDSes.')
ipslaEtherJAggMeasuredSum2NDSLs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 32), Counter32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredSum2NDSLs.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredSum2NDSLs.setDescription('The sum of squares of all negative jitter values for frames sent from destination to source (low order 32 bits).')
ipslaEtherJAggMeasuredSum2NDSHs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 33), Counter32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredSum2NDSHs.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredSum2NDSHs.setDescription('The sum of squares of all negative jitter values for frames sent from destination to source (high order 32 bits).')
ipslaEtherJAggMeasuredFrmLossSDs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 34), Counter32()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredFrmLossSDs.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredFrmLossSDs.setDescription('The number of lost frames when sent from source to destination.')
ipslaEtherJAggMeasuredFrmLssDSes = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 35), Counter32()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredFrmLssDSes.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredFrmLssDSes.setDescription('The number of lost frames when sent from destination to source.')
ipslaEtherJAggMeasuredFrmOutSeqs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 36), Counter32()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredFrmOutSeqs.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredFrmOutSeqs.setDescription('The number of frames arrived out of sequence.')
ipslaEtherJAggMeasuredFrmMIAes = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 37), Counter32()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredFrmMIAes.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredFrmMIAes.setDescription('The number of frames that are lost for which we cannot determine the direction.')
ipslaEtherJAggMeasuredFrmSkippds = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 38), Counter32()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredFrmSkippds.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredFrmSkippds.setDescription('The number of frames that are skipped per operation because the router could not send the packet out.')
ipslaEtherJAggMeasuredErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 39), Counter32()).setUnits('errors').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredErrors.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredErrors.setDescription('The number of occasions when an Ethernet jitter operation could not be initiated because of an internal error.')
ipslaEtherJAggMeasuredBusies = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 40), Counter32()).setUnits('busies').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredBusies.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredBusies.setDescription('The number of occasions when an Ethernet jitter operation could not be initiated because a previous Ethernet jitter operation has not been completed.')
ipslaEtherJAggMeasuredOWSumSDs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 41), Counter32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredOWSumSDs.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredOWSumSDs.setDescription('The sum of one way trip time from source to destination.')
ipslaEtherJAggMeasuredOWSum2SDLs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 42), Counter32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredOWSum2SDLs.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredOWSum2SDLs.setDescription('The sum of squares of one way trip time from source to destination (low order 32 bits).')
ipslaEtherJAggMeasuredOWSum2SDHs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 43), Counter32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredOWSum2SDHs.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredOWSum2SDHs.setDescription('The sum of squares of one way trip time from source to destination (high order 32 bits).')
ipslaEtherJAggMeasuredOWMinSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 44), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredOWMinSD.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredOWMinSD.setDescription('The minimum of all one way trip time from source to destination.')
ipslaEtherJAggMeasuredOWMaxSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 45), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredOWMaxSD.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredOWMaxSD.setDescription('The maximum of all one way trip time from source to destination.')
ipslaEtherJAggMeasuredOWSumDSes = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 46), Counter32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredOWSumDSes.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredOWSumDSes.setDescription('The sum of one way trip time from destination to source.')
ipslaEtherJAggMeasuredOWSum2DSLs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 47), Counter32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredOWSum2DSLs.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredOWSum2DSLs.setDescription('The sum of squares of one way trip time from destination to source (low order 32 bits).')
ipslaEtherJAggMeasuredOWSum2DSHs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 48), Counter32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredOWSum2DSHs.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredOWSum2DSHs.setDescription('The sum of squares of one way trip time from destination to source (high order 32 bits).')
ipslaEtherJAggMeasuredOWMinDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 49), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredOWMinDS.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredOWMinDS.setDescription('The minimum of all one way trip time from destination to source.')
ipslaEtherJAggMeasuredOWMaxDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 50), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredOWMaxDS.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredOWMaxDS.setDescription('The maximum of all one way trip time from destination to source.')
ipslaEtherJAggMeasuredNumOWs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 51), Counter32()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredNumOWs.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredNumOWs.setDescription('The number of one way trip time that are successfully measured.')
ipslaEtherJAggMeasuredAvgJ = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 52), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredAvgJ.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredAvgJ.setDescription('The average of positive and negative jitter values for source-to-destination and destination-to-source direction.')
ipslaEtherJAggMeasuredAvgJSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 53), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredAvgJSD.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredAvgJSD.setDescription('The average of positive and negative jitter values in source-to-destination direction.')
ipslaEtherJAggMeasuredAvgJDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 54), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredAvgJDS.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredAvgJDS.setDescription('The average of positive and negative jitter values in destination-to-source direction.')
ipslaEtherJAggMinSucFrmLoss = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 55), Gauge32()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMinSucFrmLoss.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMinSucFrmLoss.setDescription('The minimum number of frames that are dropped successively.')
ipslaEtherJAggMaxSucFrmLoss = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 56), Gauge32()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMaxSucFrmLoss.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMaxSucFrmLoss.setDescription('The maximum number of frames that are dropped successively.')
ipslaEtherJAggMeasuredIAJOut = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 57), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredIAJOut.setReference('Refer to the following documents for the definition: RFC 1889, Section 6.3.1')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredIAJOut.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredIAJOut.setDescription('Inter-arrival jitter (RFC 1889) at responder')
ipslaEtherJAggMeasuredIAJIn = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 58), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredIAJIn.setReference('Refer to the following documents for the definition: RFC 1889, Section 6.3.1')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredIAJIn.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredIAJIn.setDescription('Inter-arrival jitter (RFC 1889) at sender')
ipslaEtherJAggMeasuredFrmLateAs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 59), Counter32()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredFrmLateAs.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredFrmLateAs.setDescription('The number of frames that arrived after the timeout.')
ipslaEtherJAggMeasuredFrmUnPrcds = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 60), Counter32()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredFrmUnPrcds.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredFrmUnPrcds.setDescription('The number of frames that arrived but could not be processed due to the internal error.')
ipslaEtherJAggMeasuredMaxPosTW = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 61), Gauge32()).setUnits('microseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredMaxPosTW.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredMaxPosTW.setDescription('The two-way maximum of all positive jitter values for frames.')
ipslaEtherJAggMeasuredMaxNegTW = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 62), Gauge32()).setUnits('microseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredMaxNegTW.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredMaxNegTW.setDescription('The two-way maximum of all negative jitter values for frames.')
ipslaEtherJAggMeasuredMinPosTW = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 63), Gauge32()).setUnits('microseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredMinPosTW.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredMinPosTW.setDescription('The two-way minimum of all positive jitter values for frames.')
ipslaEtherJAggMeasuredMinNegTW = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 64), Gauge32()).setUnits('microseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredMinNegTW.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredMinNegTW.setDescription('The two-way minimum of all negative jitter values for frames.')
ipslaEtherJAggMeasuredTxFrmsSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 65), Counter64()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredTxFrmsSD.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredTxFrmsSD.setDescription('The number of data frames sent from source to destination.')
ipslaEtherJAggMeasuredTxFrmsDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 66), Counter64()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredTxFrmsDS.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredTxFrmsDS.setDescription('The number of data frames sent from destination to source.')
ipslaEtherJAggMeasuredRxFrmsSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 67), Counter64()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredRxFrmsSD.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredRxFrmsSD.setDescription('The number of data frames received from source to destination.')
ipslaEtherJAggMeasuredRxFrmsDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 68), Counter64()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredRxFrmsDS.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredRxFrmsDS.setDescription('The number of data frames received from destination to source.')
ipslaEtherJAggMeasuredMinLossNumeratorSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 69), Gauge32()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredMinLossNumeratorSD.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredMinLossNumeratorSD.setDescription('The numerator for the minimum loss ratio recorded in the source to destination direction.')
ipslaEtherJAggMeasuredMinLossDenominatorSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 70), Gauge32()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredMinLossDenominatorSD.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredMinLossDenominatorSD.setDescription('The denominator for the minimum loss ratio recorded in the source to destination direction.')
ipslaEtherJAggMeasuredMaxLossNumeratorSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 71), Gauge32()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredMaxLossNumeratorSD.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredMaxLossNumeratorSD.setDescription('The numerator for the maximum loss ratio recorded in the source to destination direction.')
ipslaEtherJAggMeasuredMaxLossDenominatorSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 72), Gauge32()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredMaxLossDenominatorSD.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredMaxLossDenominatorSD.setDescription('The denominator for the maximum loss ratio recorded in the source to destination direction.')
ipslaEtherJAggMeasuredAvgLossNumeratorSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 73), Gauge32()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredAvgLossNumeratorSD.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredAvgLossNumeratorSD.setDescription('The numerator for the average loss ratio recorded in the source to destination direction.')
ipslaEtherJAggMeasuredAvgLossDenominatorSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 74), Gauge32()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredAvgLossDenominatorSD.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredAvgLossDenominatorSD.setDescription('The denominator for the average loss ratio recorded in the source to destination direction.')
ipslaEtherJAggMeasuredMinLossNumeratorDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 75), Gauge32()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredMinLossNumeratorDS.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredMinLossNumeratorDS.setDescription('The numerator for the minimum loss ratio recorded in the destination to source direction.')
ipslaEtherJAggMeasuredMinLossDenominatorDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 76), Gauge32()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredMinLossDenominatorDS.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredMinLossDenominatorDS.setDescription('The denominator for the minimum loss ratio recorded in the destination to source direction.')
ipslaEtherJAggMeasuredMaxLossNumeratorDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 77), Gauge32()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredMaxLossNumeratorDS.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredMaxLossNumeratorDS.setDescription('The numerator for the maximum loss ratio recorded in the destination to source direction.')
ipslaEtherJAggMeasuredMaxLossDenominatorDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 78), Gauge32()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredMaxLossDenominatorDS.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredMaxLossDenominatorDS.setDescription('The denominator for the maximum loss ratio recorded in the destination to source direction.')
ipslaEtherJAggMeasuredAvgLossNumeratorDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 79), Gauge32()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredAvgLossNumeratorDS.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredAvgLossNumeratorDS.setDescription('The numerator for the average loss ratio recorded in the destination to source direction.')
ipslaEtherJAggMeasuredAvgLossDenominatorDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 80), Gauge32()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredAvgLossDenominatorDS.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredAvgLossDenominatorDS.setDescription('The denominator for the average loss ratio recorded in the destination to source direction.')
ipslaEtherJAggMeasuredCumulativeLossNumeratorSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 81), Gauge32()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredCumulativeLossNumeratorSD.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredCumulativeLossNumeratorSD.setDescription('The numerator for the loss ratio recorded in the source to destination direction. This value is cumulative over the period of this interval.')
ipslaEtherJAggMeasuredCumulativeLossDenominatorSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 82), Gauge32()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredCumulativeLossDenominatorSD.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredCumulativeLossDenominatorSD.setDescription('The denominator for the loss ratio recorded in the source to destination direction. This value is cumulative over the period of this interval.')
ipslaEtherJAggMeasuredCumulativeAvgLossNumeratorSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 83), Gauge32()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredCumulativeAvgLossNumeratorSD.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredCumulativeAvgLossNumeratorSD.setDescription('The numerator for the average loss ratio recorded in the source to destination direction. This value is cumulative over the perios of this interval.')
ipslaEtherJAggMeasuredCumulativeAvgLossDenominatorSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 84), Gauge32()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredCumulativeAvgLossDenominatorSD.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredCumulativeAvgLossDenominatorSD.setDescription('The denominator for the average loss ratio recorded in the source to destination direction. This value is cumulative over the period of this interval.')
ipslaEtherJAggMeasuredCumulativeLossNumeratorDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 85), Gauge32()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredCumulativeLossNumeratorDS.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredCumulativeLossNumeratorDS.setDescription('The numerator for the loss ratio recorded in the destination to source direction. This value is cumulative over the period of this interval.')
ipslaEtherJAggMeasuredCumulativeLossDenominatorDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 86), Gauge32()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredCumulativeLossDenominatorDS.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredCumulativeLossDenominatorDS.setDescription('The denominator for the loss ratio recorded in the destination to source direction. This valued is cumulative over the period of this interval.')
ipslaEtherJAggMeasuredCumulativeAvgLossNumeratorDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 87), Gauge32()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredCumulativeAvgLossNumeratorDS.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredCumulativeAvgLossNumeratorDS.setDescription('The numerator for the average loss ratio recorded in the destination to source direction. This value is cumulative over the period of this interval.')
ipslaEtherJAggMeasuredCumulativeAvgLossDenominatorDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 585, 1, 2, 1, 1, 88), Gauge32()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredCumulativeAvgLossDenominatorDS.setStatus('current')
if mibBuilder.loadTexts: ipslaEtherJAggMeasuredCumulativeAvgLossDenominatorDS.setDescription('The denominator for the average loss ratio recorded in the destination to source direction. This value is cumulative over the period of this interval.')
ciscoIpSlaEthernetMIBConform = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 585, 2))
ciscoIpSlaEthernetCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 585, 2, 1))
ciscoIpSlaEthernetMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 585, 2, 2))
ciscoIpSlaEthernetCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 585, 2, 1, 1)).setObjects(("CISCO-IPSLA-ETHERNET-MIB", "ciscoIpSlaEthernetAutoGroup"), ("CISCO-IPSLA-ETHERNET-MIB", "ciscoIpSlaEthernetStatsGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoIpSlaEthernetCompliance = ciscoIpSlaEthernetCompliance.setStatus('deprecated')
if mibBuilder.loadTexts: ciscoIpSlaEthernetCompliance.setDescription('The compliance statement for (1) Ethernet Jitter operation and statistics')
ciscoIpSlaEthernetComplianceRev2 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 585, 2, 1, 2)).setObjects(("CISCO-IPSLA-ETHERNET-MIB", "ciscoIpSlaEthernetAutoGroup"), ("CISCO-IPSLA-ETHERNET-MIB", "ciscoIpSlaEthernetStatsGroup"), ("CISCO-IPSLA-ETHERNET-MIB", "ciscoIpSlaEthernetAutoEVCGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoIpSlaEthernetComplianceRev2 = ciscoIpSlaEthernetComplianceRev2.setStatus('deprecated')
if mibBuilder.loadTexts: ciscoIpSlaEthernetComplianceRev2.setDescription('The compliance statement for (1) Ethernet Jitter operation and statistics (2) supporting IP SLA Auto-Ethernet-CFM')
ciscoIpSlaEthernetComplianceRev3 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 585, 2, 1, 3)).setObjects(("CISCO-IPSLA-ETHERNET-MIB", "ciscoIpSlaEthernetAutoGroup"), ("CISCO-IPSLA-ETHERNET-MIB", "ciscoIpSlaEthernetStatsGroup"), ("CISCO-IPSLA-ETHERNET-MIB", "ciscoIpSlaEthernetY1731Group"), ("CISCO-IPSLA-ETHERNET-MIB", "ciscoIpSlaEthernetAutoEVCGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoIpSlaEthernetComplianceRev3 = ciscoIpSlaEthernetComplianceRev3.setStatus('current')
if mibBuilder.loadTexts: ciscoIpSlaEthernetComplianceRev3.setDescription('The compliance statement for (1) Ethernet Jitter operation and statistics (2) supporting IP SLA Y1731')
ciscoIpSlaEthernetAutoGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 585, 2, 2, 1)).setObjects(("CISCO-IPSLA-ETHERNET-MIB", "ipslaEthernetGrpCtrlStatus"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEthernetGrpCtrlStorageType"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEthernetGrpCtrlRttType"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEthernetGrpCtrlOwner"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEthernetGrpCtrlTag"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEthernetGrpCtrlThreshold"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEthernetGrpCtrlTimeout"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEthernetGrpCtrlProbeList"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEthernetGrpCtrlVLAN"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEthernetGrpCtrlDomainNameType"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEthernetGrpCtrlDomainName"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEthernetGrpCtrlReqDataSize"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEthernetGrpCtrlMPIDExLst"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEthernetGrpCtrlCOS"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEthernetGrpCtrlInterval"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEthernetGrpCtrlNumFrames"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEthernetGrpReactStatus"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEthernetGrpReactStorageType"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEthernetGrpReactVar"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEthernetGrpReactThresholdType"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEthernetGrpReactThresholdRising"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEthernetGrpReactThresholdFalling"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEthernetGrpReactThresholdCountX"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEthernetGrpReactThresholdCountY"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEthernetGrpReactActionType"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEthernetGrpScheduleRttStartTime"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEthernetGrpSchedulePeriod"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEthernetGrpScheduleFrequency"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoIpSlaEthernetAutoGroup = ciscoIpSlaEthernetAutoGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoIpSlaEthernetAutoGroup.setDescription('A collection of objects that were added to support Auto-Ethernet-CFM.')
ciscoIpSlaEthernetStatsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 585, 2, 2, 2)).setObjects(("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJitterLatestNumRTT"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJitterLatestRTTSum"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJitterLatestRTTSum2"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJitterLatestRTTMin"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJitterLatestRTTMax"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJitterLatestMinPosSD"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJitterLatestMaxPosSD"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJitterLatestNumPosSD"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJitterLatestSumPosSD"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJitterLatestSum2PosSD"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJitterLatestMinNegSD"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJitterLatestMaxNegSD"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJitterLatestNumNegSD"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJitterLatestSumNegSD"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJitterLatestSum2NegSD"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJitterLatestMinPosDS"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJitterLatestMaxPosDS"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJitterLatestNumPosDS"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJitterLatestSumPosDS"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJitterLatestSum2PosDS"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJitterLatestMinNegDS"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJitterLatestMaxNegDS"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJitterLatestNumNegDS"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJitterLatestSumNegDS"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJitterLatestSum2NegDS"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJitterLatestFrmLossSD"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJitterLatestFrmLossDS"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJitterLatestFrmOutSeq"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJitterLatestFrmMIA"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJitterLatestFrmSkipped"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJitterLatestSense"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJitterLatestFrmLateA"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJitterLatestMinSucFrmL"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJitterLatestMaxSucFrmL"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJitterLatestOWSumSD"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJitterLatestOWSum2SD"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJitterLatestOWMinSD"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJitterLatestOWMaxSD"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJitterLatestOWSumDS"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJitterLatestOWSum2DS"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJitterLatestOWMinDS"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJitterLatestOWMaxDS"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJitterLatestNumOW"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJitterLatestAvgJitter"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJitterLatestAvgSDJ"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJitterLatestAvgDSJ"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJitterLatestOWAvgSD"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJitterLatestOWAvgDS"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJitterLatestIAJOut"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJitterLatestIAJIn"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJLatestFrmUnProcessed"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredCmpletions"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredOvThrshlds"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredNumRTTs"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredRTTSums"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredRTTSum2Ls"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredRTTSum2Hs"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredRTTMin"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredRTTMax"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredMinPosSD"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredMaxPosSD"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredNumPosSDs"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredSumPosSDs"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredSum2PSDLs"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredSum2PSDHs"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredMinNegSD"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredMaxNegSD"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredNumNegSDs"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredSumNegSDs"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredSum2NSDLs"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredSum2NSDHs"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredMinPosDS"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredMaxPosDS"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredNumPosDSes"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredSumPosDSes"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredSum2PDSLs"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredSum2PDSHs"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredMinNegDS"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredMaxNegDS"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredNumNegDSes"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredSumNegDSes"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredSum2NDSLs"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredSum2NDSHs"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredFrmLossSDs"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredFrmLssDSes"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredFrmOutSeqs"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredFrmMIAes"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredFrmSkippds"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredErrors"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredBusies"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredOWSumSDs"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredOWSum2SDLs"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredOWSum2SDHs"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredOWMinSD"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredOWMaxSD"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredOWSumDSes"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredOWSum2DSLs"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredOWSum2DSHs"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredOWMinDS"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredOWMaxDS"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredNumOWs"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredAvgJ"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredAvgJSD"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredAvgJDS"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMinSucFrmLoss"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMaxSucFrmLoss"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredIAJOut"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredIAJIn"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredFrmLateAs"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredFrmUnPrcds"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoIpSlaEthernetStatsGroup = ciscoIpSlaEthernetStatsGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoIpSlaEthernetStatsGroup.setDescription('A collection of statistics objects related to Ethernet Jitter Probe.')
ciscoIpSlaEthernetAutoEVCGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 585, 2, 2, 3)).setObjects(("CISCO-IPSLA-ETHERNET-MIB", "ipslaEthernetGrpCtrlEVC"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEthernetGrpCtrlServiceInsType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoIpSlaEthernetAutoEVCGroup = ciscoIpSlaEthernetAutoEVCGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoIpSlaEthernetAutoEVCGroup.setDescription('A collection of objects which provides the support for Auto-Ethernet-CFM ping/jitter operation with Ethernet Virtual Connection.')
ciscoIpSlaEthernetY1731Group = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 585, 2, 2, 4)).setObjects(("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredMaxPosTW"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredMaxNegTW"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredMinPosTW"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredMinNegTW"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredTxFrmsSD"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredTxFrmsDS"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredRxFrmsSD"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredRxFrmsDS"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredMinLossNumeratorSD"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredMinLossDenominatorSD"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredMaxLossNumeratorSD"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredMaxLossDenominatorSD"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredAvgLossNumeratorSD"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredAvgLossDenominatorSD"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredMinLossNumeratorDS"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredMinLossDenominatorDS"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredMaxLossNumeratorDS"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredMaxLossDenominatorDS"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredAvgLossNumeratorDS"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredAvgLossDenominatorDS"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredCumulativeLossNumeratorSD"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredCumulativeLossDenominatorSD"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredCumulativeAvgLossNumeratorSD"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredCumulativeAvgLossDenominatorSD"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredCumulativeLossNumeratorDS"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredCumulativeLossDenominatorDS"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredCumulativeAvgLossNumeratorDS"), ("CISCO-IPSLA-ETHERNET-MIB", "ipslaEtherJAggMeasuredCumulativeAvgLossDenominatorDS"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoIpSlaEthernetY1731Group = ciscoIpSlaEthernetY1731Group.setStatus('current')
if mibBuilder.loadTexts: ciscoIpSlaEthernetY1731Group.setDescription('A collection of objects which provides the support for Y1731 operation with Ethernet Virtual Connection.')
mibBuilder.exportSymbols("CISCO-IPSLA-ETHERNET-MIB", ipslaEtherJAggMeasuredSumNegSDs=ipslaEtherJAggMeasuredSumNegSDs, ipslaEthernetGrpReactThresholdCountY=ipslaEthernetGrpReactThresholdCountY, ipslaEtherJitterLatestMinNegSD=ipslaEtherJitterLatestMinNegSD, ipslaEtherJAggMeasuredSum2NSDHs=ipslaEtherJAggMeasuredSum2NSDHs, ipslaEtherJAggMeasuredSumPosDSes=ipslaEtherJAggMeasuredSumPosDSes, ipslaEthernetGrpCtrlIndex=ipslaEthernetGrpCtrlIndex, ipslaEthernetGrpCtrlDomainName=ipslaEthernetGrpCtrlDomainName, ipslaEthernetGrpCtrlEntry=ipslaEthernetGrpCtrlEntry, ipslaEtherJAggMeasuredSum2PDSLs=ipslaEtherJAggMeasuredSum2PDSLs, ipslaEtherJAggMeasuredErrors=ipslaEtherJAggMeasuredErrors, ipslaEtherJAggMeasuredMinLossNumeratorSD=ipslaEtherJAggMeasuredMinLossNumeratorSD, ipslaEtherJitterLatestRTTMin=ipslaEtherJitterLatestRTTMin, ipslaEthernetGrpCtrlReqDataSize=ipslaEthernetGrpCtrlReqDataSize, ipslaEtherJitterLatestFrmMIA=ipslaEtherJitterLatestFrmMIA, ipslaEtherJitterAggStatsTable=ipslaEtherJitterAggStatsTable, ipslaEtherJAggMeasuredOWSumDSes=ipslaEtherJAggMeasuredOWSumDSes, ipslaEtherJitterLatestOWSum2SD=ipslaEtherJitterLatestOWSum2SD, ipslaEtherJAggMeasuredRxFrmsSD=ipslaEtherJAggMeasuredRxFrmsSD, ipslaEtherJAggMeasuredRTTSums=ipslaEtherJAggMeasuredRTTSums, ipslaEtherJitterLatestSum2NegSD=ipslaEtherJitterLatestSum2NegSD, ipslaEtherJLatestFrmUnProcessed=ipslaEtherJLatestFrmUnProcessed, ipslaEtherJAggMeasuredSum2PSDHs=ipslaEtherJAggMeasuredSum2PSDHs, ipslaEtherJAggMeasuredRTTMax=ipslaEtherJAggMeasuredRTTMax, ipslaEtherJAggMeasuredFrmMIAes=ipslaEtherJAggMeasuredFrmMIAes, ipslaEthernetGrpReactThresholdRising=ipslaEthernetGrpReactThresholdRising, ipslaEtherJAggMeasuredMinPosSD=ipslaEtherJAggMeasuredMinPosSD, ipslaEtherJAggMaxSucFrmLoss=ipslaEtherJAggMaxSucFrmLoss, ipslaEtherJitterLatestMaxPosDS=ipslaEtherJitterLatestMaxPosDS, ipslaEtherJAggMeasuredCumulativeAvgLossDenominatorSD=ipslaEtherJAggMeasuredCumulativeAvgLossDenominatorSD, ipslaEtherJAggMeasuredSum2PDSHs=ipslaEtherJAggMeasuredSum2PDSHs, ipslaEtherJitterLatestStatsTable=ipslaEtherJitterLatestStatsTable, ipslaEtherJitterLatestAvgJitter=ipslaEtherJitterLatestAvgJitter, ipslaEtherJAggMeasuredAvgLossNumeratorSD=ipslaEtherJAggMeasuredAvgLossNumeratorSD, ipslaEtherJitterLatestOWMaxSD=ipslaEtherJitterLatestOWMaxSD, ciscoIpSlaEthernetCompliances=ciscoIpSlaEthernetCompliances, ipslaEtherJitterLatestIAJIn=ipslaEtherJitterLatestIAJIn, ipslaEtherJAggMeasuredCumulativeAvgLossNumeratorDS=ipslaEtherJAggMeasuredCumulativeAvgLossNumeratorDS, ipslaEthernetGrpScheduleRttStartTime=ipslaEthernetGrpScheduleRttStartTime, ipslaEthernetGrpSchedulePeriod=ipslaEthernetGrpSchedulePeriod, ipslaEtherJAggMeasuredAvgJSD=ipslaEtherJAggMeasuredAvgJSD, ipslaEtherJitterLatestFrmLateA=ipslaEtherJitterLatestFrmLateA, ipslaEthernetGrpReactStorageType=ipslaEthernetGrpReactStorageType, ipslaEtherJAggMeasuredMinNegSD=ipslaEtherJAggMeasuredMinNegSD, ipslaEthernetGrpReactVar=ipslaEthernetGrpReactVar, ipslaEthernetStats=ipslaEthernetStats, ipslaEthernetGrpReactTable=ipslaEthernetGrpReactTable, ipslaEtherJAggMeasuredMaxNegSD=ipslaEtherJAggMeasuredMaxNegSD, ipslaEtherJAggMeasuredMaxPosDS=ipslaEtherJAggMeasuredMaxPosDS, ipslaEtherJAggMeasuredFrmLssDSes=ipslaEtherJAggMeasuredFrmLssDSes, ipslaEtherJAggMeasuredIAJIn=ipslaEtherJAggMeasuredIAJIn, ipslaEtherJitterLatestNumNegDS=ipslaEtherJitterLatestNumNegDS, ciscoIpSlaEthernetCompliance=ciscoIpSlaEthernetCompliance, ciscoIpSlaEthernetMIBNotifs=ciscoIpSlaEthernetMIBNotifs, ipslaEthernetGrpCtrlNumFrames=ipslaEthernetGrpCtrlNumFrames, ipslaEtherJitterLatestFrmLossDS=ipslaEtherJitterLatestFrmLossDS, ipslaEtherJAggMeasuredNumNegSDs=ipslaEtherJAggMeasuredNumNegSDs, ipslaEtherJAggMeasuredCumulativeLossNumeratorDS=ipslaEtherJAggMeasuredCumulativeLossNumeratorDS, ipslaEthernetGrpScheduleFrequency=ipslaEthernetGrpScheduleFrequency, ipslaEthernetGrpCtrlRttType=ipslaEthernetGrpCtrlRttType, ipslaEtherJitterLatestRTTSum=ipslaEtherJitterLatestRTTSum, ipslaEtherJAggMeasuredAvgLossDenominatorSD=ipslaEtherJAggMeasuredAvgLossDenominatorSD, ipslaEthernetGrpCtrlVLAN=ipslaEthernetGrpCtrlVLAN, ipslaEtherJitterLatestOWAvgDS=ipslaEtherJitterLatestOWAvgDS, ipslaEtherJitterLatestOWSumSD=ipslaEtherJitterLatestOWSumSD, ciscoIpSlaEthernetComplianceRev3=ciscoIpSlaEthernetComplianceRev3, ciscoIpSlaEthernetMIBObjects=ciscoIpSlaEthernetMIBObjects, ipslaEtherJitterLatestOWMinSD=ipslaEtherJitterLatestOWMinSD, ipslaEthernetGrpReactThresholdFalling=ipslaEthernetGrpReactThresholdFalling, ipslaEtherJitterLatestIAJOut=ipslaEtherJitterLatestIAJOut, ipslaEtherJAggMeasuredAvgLossNumeratorDS=ipslaEtherJAggMeasuredAvgLossNumeratorDS, ipslaEtherJitterLatestSumPosDS=ipslaEtherJitterLatestSumPosDS, ciscoIpSlaEthernetY1731Group=ciscoIpSlaEthernetY1731Group, ipslaEtherJAggMeasuredCumulativeLossDenominatorDS=ipslaEtherJAggMeasuredCumulativeLossDenominatorDS, ipslaEtherJAggMeasuredFrmSkippds=ipslaEtherJAggMeasuredFrmSkippds, ipslaEtherJAggMeasuredMaxLossNumeratorSD=ipslaEtherJAggMeasuredMaxLossNumeratorSD, ipslaEtherJAggMeasuredOWSum2SDHs=ipslaEtherJAggMeasuredOWSum2SDHs, ipslaEtherJitterLatestNumOW=ipslaEtherJitterLatestNumOW, ipslaEtherJAggMeasuredSum2NDSLs=ipslaEtherJAggMeasuredSum2NDSLs, ipslaEtherJAggMeasuredCumulativeLossNumeratorSD=ipslaEtherJAggMeasuredCumulativeLossNumeratorSD, ipslaEtherJitterLatestSumNegSD=ipslaEtherJitterLatestSumNegSD, ipslaEtherJAggMeasuredSumPosSDs=ipslaEtherJAggMeasuredSumPosSDs, ipslaEtherJitterLatestNumPosDS=ipslaEtherJitterLatestNumPosDS, ipslaEtherJAggMeasuredOWMinSD=ipslaEtherJAggMeasuredOWMinSD, ipslaEtherJAggMeasuredNumRTTs=ipslaEtherJAggMeasuredNumRTTs, ipslaEtherJAggMeasuredOWSum2DSLs=ipslaEtherJAggMeasuredOWSum2DSLs, ipslaEtherJAggMeasuredSumNegDSes=ipslaEtherJAggMeasuredSumNegDSes, ipslaEthernetGrpReactStatus=ipslaEthernetGrpReactStatus, ipslaEtherJAggMeasuredRxFrmsDS=ipslaEtherJAggMeasuredRxFrmsDS, ipslaEthernetGrpReactThresholdType=ipslaEthernetGrpReactThresholdType, ipslaEthernetGrpCtrlProbeList=ipslaEthernetGrpCtrlProbeList, ipslaEtherJAggMeasuredMaxLossDenominatorDS=ipslaEtherJAggMeasuredMaxLossDenominatorDS, ipslaEtherJitterLatestOWMaxDS=ipslaEtherJitterLatestOWMaxDS, ipslaEthernetGrpReactActionType=ipslaEthernetGrpReactActionType, ipslaEtherJitterLatestFrmLossSD=ipslaEtherJitterLatestFrmLossSD, ipslaEtherJAggMeasuredAvgJ=ipslaEtherJAggMeasuredAvgJ, ipslaEtherJAggMeasuredMaxNegTW=ipslaEtherJAggMeasuredMaxNegTW, ipslaEthernetGrpCtrlInterval=ipslaEthernetGrpCtrlInterval, ipslaEtherJAggMeasuredCumulativeLossDenominatorSD=ipslaEtherJAggMeasuredCumulativeLossDenominatorSD, PYSNMP_MODULE_ID=ciscoIpSlaEthernetMIB, ipslaEtherJitterLatestMaxNegDS=ipslaEtherJitterLatestMaxNegDS, ipslaEtherJAggMeasuredIAJOut=ipslaEtherJAggMeasuredIAJOut, ipslaEthernetGrpCtrlTimeout=ipslaEthernetGrpCtrlTimeout, ipslaEthernetGrpCtrlMPIDExLst=ipslaEthernetGrpCtrlMPIDExLst, ipslaEtherJitterLatestSum2PosSD=ipslaEtherJitterLatestSum2PosSD, ipslaEtherJitterLatestSum2PosDS=ipslaEtherJitterLatestSum2PosDS, ipslaEtherJitterLatestFrmSkipped=ipslaEtherJitterLatestFrmSkipped, ipslaEtherJAggStatsStartTimeId=ipslaEtherJAggStatsStartTimeId, ipslaEtherJitterLatestMinNegDS=ipslaEtherJitterLatestMinNegDS, ipslaEtherJitterLatestStatsEntry=ipslaEtherJitterLatestStatsEntry, ipslaEtherJitterLatestSense=ipslaEtherJitterLatestSense, ipslaEtherJAggMeasuredRTTSum2Hs=ipslaEtherJAggMeasuredRTTSum2Hs, ipslaEtherJAggMeasuredOWSum2SDLs=ipslaEtherJAggMeasuredOWSum2SDLs, ipslaEtherJAggMeasuredTxFrmsDS=ipslaEtherJAggMeasuredTxFrmsDS, ciscoIpSlaEthernetAutoGroup=ciscoIpSlaEthernetAutoGroup, ipslaEtherJitterLatestOWSumDS=ipslaEtherJitterLatestOWSumDS, ipslaEthernetGrpReactThresholdCountX=ipslaEthernetGrpReactThresholdCountX, ipslaEtherJitterLatestAvgSDJ=ipslaEtherJitterLatestAvgSDJ, ciscoIpSlaEthernetMIB=ciscoIpSlaEthernetMIB, ipslaEtherJAggMeasuredNumOWs=ipslaEtherJAggMeasuredNumOWs, ciscoIpSlaEthernetComplianceRev2=ciscoIpSlaEthernetComplianceRev2, ipslaEtherJitterLatestMaxSucFrmL=ipslaEtherJitterLatestMaxSucFrmL, ipslaEtherJAggMeasuredFrmLateAs=ipslaEtherJAggMeasuredFrmLateAs, ipslaEtherJitterLatestSum2NegDS=ipslaEtherJitterLatestSum2NegDS, ipslaEtherJitterLatestNumPosSD=ipslaEtherJitterLatestNumPosSD, ipslaEthernetGrpCtrlThreshold=ipslaEthernetGrpCtrlThreshold, ciscoIpSlaEthernetAutoEVCGroup=ciscoIpSlaEthernetAutoEVCGroup, ipslaEtherJAggMeasuredOWMaxDS=ipslaEtherJAggMeasuredOWMaxDS, ipslaEtherJitterLatestMaxNegSD=ipslaEtherJitterLatestMaxNegSD, ipslaEtherJAggMeasuredMinLossDenominatorSD=ipslaEtherJAggMeasuredMinLossDenominatorSD, ipslaEthernetGrpCtrlStorageType=ipslaEthernetGrpCtrlStorageType, ipslaEtherJAggMeasuredCumulativeAvgLossNumeratorSD=ipslaEtherJAggMeasuredCumulativeAvgLossNumeratorSD, ipslaEthernetGrpReactEntry=ipslaEthernetGrpReactEntry, ipslaEtherJAggMeasuredOWMaxSD=ipslaEtherJAggMeasuredOWMaxSD, ipslaEtherJitterAggStatsEntry=ipslaEtherJitterAggStatsEntry, ipslaEtherJAggMeasuredMaxLossDenominatorSD=ipslaEtherJAggMeasuredMaxLossDenominatorSD, ipslaEthernetGrpCtrlEVC=ipslaEthernetGrpCtrlEVC, ciscoIpSlaEthernetStatsGroup=ciscoIpSlaEthernetStatsGroup, ipslaEtherJAggMeasuredSum2NDSHs=ipslaEtherJAggMeasuredSum2NDSHs, ipslaEtherJitterLatestNumRTT=ipslaEtherJitterLatestNumRTT, ipslaEtherJAggMeasuredOWSumSDs=ipslaEtherJAggMeasuredOWSumSDs, ipslaEtherJAggMeasuredCumulativeAvgLossDenominatorDS=ipslaEtherJAggMeasuredCumulativeAvgLossDenominatorDS, ipslaEtherJitterLatestMinPosSD=ipslaEtherJitterLatestMinPosSD, ipslaEtherJAggMeasuredRTTMin=ipslaEtherJAggMeasuredRTTMin, ipslaEtherJitterLatestNumNegSD=ipslaEtherJitterLatestNumNegSD, ipslaEtherJAggMeasuredOvThrshlds=ipslaEtherJAggMeasuredOvThrshlds, ipslaEtherJAggMeasuredMinLossDenominatorDS=ipslaEtherJAggMeasuredMinLossDenominatorDS, ipslaEtherJAggMeasuredSum2NSDLs=ipslaEtherJAggMeasuredSum2NSDLs, ipslaEtherJAggMeasuredMinNegDS=ipslaEtherJAggMeasuredMinNegDS, ipslaEtherJAggMeasuredFrmUnPrcds=ipslaEtherJAggMeasuredFrmUnPrcds, ipslaEtherJitterLatestMaxPosSD=ipslaEtherJitterLatestMaxPosSD, ipslaEtherJitterLatestMinPosDS=ipslaEtherJitterLatestMinPosDS, ipslaEthernetGrpCtrl=ipslaEthernetGrpCtrl, ipslaEthernetGrpCtrlStatus=ipslaEthernetGrpCtrlStatus, ipslaEtherJitterLatestRTTSum2=ipslaEtherJitterLatestRTTSum2, ipslaEtherJAggMeasuredOWSum2DSHs=ipslaEtherJAggMeasuredOWSum2DSHs, ipslaEtherJitterLatestMinSucFrmL=ipslaEtherJitterLatestMinSucFrmL, ipslaEtherJAggMeasuredAvgJDS=ipslaEtherJAggMeasuredAvgJDS, ipslaEtherJAggMeasuredMinPosDS=ipslaEtherJAggMeasuredMinPosDS, ipslaEtherJAggMeasuredMaxNegDS=ipslaEtherJAggMeasuredMaxNegDS, ipslaEtherJitterLatestSumNegDS=ipslaEtherJitterLatestSumNegDS, ipslaEtherJAggMeasuredMaxLossNumeratorDS=ipslaEtherJAggMeasuredMaxLossNumeratorDS, ciscoIpSlaEthernetMIBConform=ciscoIpSlaEthernetMIBConform, ipslaEtherJAggMeasuredMinNegTW=ipslaEtherJAggMeasuredMinNegTW, ipslaEtherJAggMeasuredCmpletions=ipslaEtherJAggMeasuredCmpletions, ipslaEtherJAggMeasuredMaxPosTW=ipslaEtherJAggMeasuredMaxPosTW, ciscoIpSlaEthernetMIBGroups=ciscoIpSlaEthernetMIBGroups, ipslaEtherJAggMeasuredAvgLossDenominatorDS=ipslaEtherJAggMeasuredAvgLossDenominatorDS, ipslaEtherJAggMeasuredNumPosDSes=ipslaEtherJAggMeasuredNumPosDSes, ipslaEtherJitterLatestRTTMax=ipslaEtherJitterLatestRTTMax, ipslaEtherJAggMeasuredMaxPosSD=ipslaEtherJAggMeasuredMaxPosSD, ipslaEtherJAggMeasuredMinPosTW=ipslaEtherJAggMeasuredMinPosTW, ipslaEtherJitterLatestSumPosSD=ipslaEtherJitterLatestSumPosSD, ipslaEtherJAggMeasuredBusies=ipslaEtherJAggMeasuredBusies, ipslaEthernetLatestOper=ipslaEthernetLatestOper, ipslaEtherJAggMinSucFrmLoss=ipslaEtherJAggMinSucFrmLoss, ipslaEtherJAggMeasuredTxFrmsSD=ipslaEtherJAggMeasuredTxFrmsSD, ipslaEtherJAggMeasuredOWMinDS=ipslaEtherJAggMeasuredOWMinDS, ipslaEtherJitterLatestOWSum2DS=ipslaEtherJitterLatestOWSum2DS, ipslaEthernetGrpCtrlTable=ipslaEthernetGrpCtrlTable, ipslaEthernetGrpCtrlCOS=ipslaEthernetGrpCtrlCOS, ipslaEtherJAggMeasuredNumPosSDs=ipslaEtherJAggMeasuredNumPosSDs, ipslaEthernetGrpCtrlTag=ipslaEthernetGrpCtrlTag, ipslaEtherJitterLatestAvgDSJ=ipslaEtherJitterLatestAvgDSJ, ipslaEtherJitterLatestOWAvgSD=ipslaEtherJitterLatestOWAvgSD, ipslaEtherJAggMeasuredSum2PSDLs=ipslaEtherJAggMeasuredSum2PSDLs, ipslaEtherJAggMeasuredMinLossNumeratorDS=ipslaEtherJAggMeasuredMinLossNumeratorDS, ipslaEtherJitterLatestOWMinDS=ipslaEtherJitterLatestOWMinDS, ipslaEtherJAggMeasuredNumNegDSes=ipslaEtherJAggMeasuredNumNegDSes, ipslaEthernetGrpCtrlServiceInsType=ipslaEthernetGrpCtrlServiceInsType, ipslaEtherJAggMeasuredFrmLossSDs=ipslaEtherJAggMeasuredFrmLossSDs, ipslaEthernetGrpReactConfigIndex=ipslaEthernetGrpReactConfigIndex, ipslaEtherJitterLatestFrmOutSeq=ipslaEtherJitterLatestFrmOutSeq, ipslaEthernetGrpCtrlDomainNameType=ipslaEthernetGrpCtrlDomainNameType, ipslaEtherJAggMeasuredRTTSum2Ls=ipslaEtherJAggMeasuredRTTSum2Ls, ipslaEthernetGrpCtrlOwner=ipslaEthernetGrpCtrlOwner, ipslaEtherJAggMeasuredFrmOutSeqs=ipslaEtherJAggMeasuredFrmOutSeqs)

#
# PySNMP MIB module HM2-NETCONFIG-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/HM2-NETCONFIG-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:31:46 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ValueSizeConstraint, ConstraintsIntersection, SingleValueConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ValueSizeConstraint", "ConstraintsIntersection", "SingleValueConstraint", "ConstraintsUnion")
HmEnabledStatus, hm2ConfigurationMibs = mibBuilder.importSymbols("HM2-TC-MIB", "HmEnabledStatus", "hm2ConfigurationMibs")
ifIndex, InterfaceIndex = mibBuilder.importSymbols("IF-MIB", "ifIndex", "InterfaceIndex")
InetAddress, InetAddressPrefixLength, InetAddressType = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddress", "InetAddressPrefixLength", "InetAddressType")
TimeFilter, = mibBuilder.importSymbols("RMON2-MIB", "TimeFilter")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
ModuleIdentity, Integer32, TimeTicks, NotificationType, Counter64, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, IpAddress, Counter32, Gauge32, iso, Unsigned32, ObjectIdentity, Bits = mibBuilder.importSymbols("SNMPv2-SMI", "ModuleIdentity", "Integer32", "TimeTicks", "NotificationType", "Counter64", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "IpAddress", "Counter32", "Gauge32", "iso", "Unsigned32", "ObjectIdentity", "Bits")
MacAddress, TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "MacAddress", "TextualConvention", "DisplayString")
hm2NetConfigMib = ModuleIdentity((1, 3, 6, 1, 4, 1, 248, 11, 20))
hm2NetConfigMib.setRevisions(('2011-03-16 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: hm2NetConfigMib.setRevisionsDescriptions(('Initial version.',))
if mibBuilder.loadTexts: hm2NetConfigMib.setLastUpdated('201103160000Z')
if mibBuilder.loadTexts: hm2NetConfigMib.setOrganization('Hirschmann Automation and Control GmbH')
if mibBuilder.loadTexts: hm2NetConfigMib.setContactInfo('Postal: Stuttgarter Str. 45-51 72654 Neckartenzlingen Germany Phone: +49 7127 140 E-mail: hac.support@belden.com')
if mibBuilder.loadTexts: hm2NetConfigMib.setDescription('Hirschmann Network Configuration MIB. Copyright (C) 2012. All Rights Reserved.')
hm2NetConfigMibNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 20, 0))
hm2NetConfigMibObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 20, 1))
hm2NetStaticGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 20, 1, 1))
hm2NetACDGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 20, 1, 2))
hm2NetMacGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 20, 1, 3))
hm2NetHiDiscoveryGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 20, 1, 4))
hm2NetMacACDGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 20, 1, 5))
hm2NetOobMgmtGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 20, 1, 6))
hm2NetConfigProtocol = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 20, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("bootp", 2), ("dhcp", 3))).clone('dhcp')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2NetConfigProtocol.setStatus('current')
if mibBuilder.loadTexts: hm2NetConfigProtocol.setDescription("The switch's network configuration protocol. The default value is dependent of the device type.")
hm2NetLocalIPAddrType = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 20, 1, 1, 2), InetAddressType().clone('ipv4')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2NetLocalIPAddrType.setStatus('current')
if mibBuilder.loadTexts: hm2NetLocalIPAddrType.setDescription('Local IP address type.')
hm2NetLocalIPAddr = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 20, 1, 1, 3), InetAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2NetLocalIPAddr.setStatus('current')
if mibBuilder.loadTexts: hm2NetLocalIPAddr.setDescription('IP address of the management agent board. Changing this value will take effect after activating with hm2NetAction.')
hm2NetPrefixLength = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 20, 1, 1, 4), InetAddressPrefixLength()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2NetPrefixLength.setStatus('current')
if mibBuilder.loadTexts: hm2NetPrefixLength.setDescription('The length of the IP netmask.')
hm2NetGatewayIPAddrType = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 20, 1, 1, 5), InetAddressType().clone('ipv4')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2NetGatewayIPAddrType.setStatus('current')
if mibBuilder.loadTexts: hm2NetGatewayIPAddrType.setDescription('Default gateway IP address type.')
hm2NetGatewayIPAddr = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 20, 1, 1, 6), InetAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2NetGatewayIPAddr.setStatus('current')
if mibBuilder.loadTexts: hm2NetGatewayIPAddr.setDescription('IP address of the default gateway. Changing this value will take effect after activating with hm2NetAction.')
hm2NetVlanID = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 20, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4042)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2NetVlanID.setStatus('current')
if mibBuilder.loadTexts: hm2NetVlanID.setDescription('VLAN-ID of the IP protocol stack. The VLAN-ID value means that only traffic of the appropriate VLAN is accepted and outgoing traffic uses this VLAN-ID.')
hm2NetVlanPriority = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 20, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2NetVlanPriority.setStatus('current')
if mibBuilder.loadTexts: hm2NetVlanPriority.setDescription('VLAN Priority which is used in management replies.')
hm2NetIpDscpPriority = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 20, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 63))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2NetIpDscpPriority.setStatus('current')
if mibBuilder.loadTexts: hm2NetIpDscpPriority.setDescription('IP DSCP value which is used in management replies.')
hm2NetMgmtPort = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 20, 1, 1, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2NetMgmtPort.setStatus('current')
if mibBuilder.loadTexts: hm2NetMgmtPort.setDescription('The port number of the Ethernet port, which gets the access to the switch management. If the value is set to 0, the access to the switch management is permitted from all ports of the switch. This object is only applicable for embedded switches which are integrated into customer devices.')
hm2NetDHCPClientId = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 20, 1, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2NetDHCPClientId.setStatus('current')
if mibBuilder.loadTexts: hm2NetDHCPClientId.setDescription('The identifier string that is currently used by the client in the request packets to the server for obtaining lease information.')
hm2NetAction = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 20, 1, 1, 50), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("activate", 2))).clone('other')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2NetAction.setStatus('current')
if mibBuilder.loadTexts: hm2NetAction.setDescription('This object, when read, always returns a value of other(1). Setting the object to activate(2) causes a reconfiguration of the IP protocol stack with the current values of hm2NetLocalIPAddr, hm2NetGatewayIPAddr and hm2NetMask.')
hm2NetACDStatus = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 20, 1, 2, 1), HmEnabledStatus().clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2NetACDStatus.setStatus('current')
if mibBuilder.loadTexts: hm2NetACDStatus.setDescription('Sets the status of the ip address conflict detection mechanism on this device. With activating the ACD status an internal check of duplicated IP-addresses is enabled.')
hm2NetACDDetectionMode = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 20, 1, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("activeAndPassive", 1), ("activeDetectionOnly", 2), ("passiveDetectionOnly", 3))).clone('activeAndPassive')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2NetACDDetectionMode.setStatus('current')
if mibBuilder.loadTexts: hm2NetACDDetectionMode.setDescription("Sets the mode of the ip address conflict detection mechanism on this device. activeAndPassive (1): Both active and passive detection are active. activeDetectionOnly (2): During configuration of a local ip address the device actively probes the network for this ip address. passiveDetectionOnly (3): The device listens passively on the network if another device with an already locally configured ip address appears. In this case the own ip address is actively defended by transmitting gratituous ARP's.")
hm2NetACDOngoingProbeStatus = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 20, 1, 2, 3), HmEnabledStatus().clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2NetACDOngoingProbeStatus.setStatus('current')
if mibBuilder.loadTexts: hm2NetACDOngoingProbeStatus.setDescription('If enabled, the device sends periodic ARP or NDP probes every 90-120 seconds.')
hm2NetACDDelay = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 20, 1, 2, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(20, 500)).clone(200)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2NetACDDelay.setStatus('current')
if mibBuilder.loadTexts: hm2NetACDDelay.setDescription('Time gap between ARP or NDP probes being sent.')
hm2NetACDReleaseDelay = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 20, 1, 2, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(3, 3600)).clone(15)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2NetACDReleaseDelay.setStatus('current')
if mibBuilder.loadTexts: hm2NetACDReleaseDelay.setDescription('Delay in seconds to the next ARP or NDP probe cycle after an ip address conflict was detected.')
hm2NetACDMaxProtection = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 20, 1, 2, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2NetACDMaxProtection.setStatus('current')
if mibBuilder.loadTexts: hm2NetACDMaxProtection.setDescription('The number of ARP announcement packets (gratuitous ARP packets) in passive(ongoing) mode to be received within hm2NetACDProtectInterval until the agent detects this as a conflict.')
hm2NetACDProtectInterval = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 20, 1, 2, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(20, 10000)).clone(10000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2NetACDProtectInterval.setStatus('current')
if mibBuilder.loadTexts: hm2NetACDProtectInterval.setDescription('Delay in milliseconds between two protections. See also hm2NetACDMaxProtection.')
hm2NetACDFaultState = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 20, 1, 2, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2NetACDFaultState.setStatus('current')
if mibBuilder.loadTexts: hm2NetACDFaultState.setDescription('true(1) if an active address conflict is detected. false(2) if no present address conflict.')
hm2NetACDTrapEnable = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 20, 1, 2, 15), HmEnabledStatus().clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2NetACDTrapEnable.setStatus('current')
if mibBuilder.loadTexts: hm2NetACDTrapEnable.setDescription('If enabled this trap reports an address conflict.')
hm2NetACDAddrTable = MibTable((1, 3, 6, 1, 4, 1, 248, 11, 20, 1, 2, 20), )
if mibBuilder.loadTexts: hm2NetACDAddrTable.setStatus('current')
if mibBuilder.loadTexts: hm2NetACDAddrTable.setDescription('This table contains address conflict detection information on the local system known to this agent.')
hm2NetACDAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 11, 20, 1, 2, 20, 1), ).setIndexNames((0, "HM2-NETCONFIG-MIB", "hm2NetACDTimeMark"))
if mibBuilder.loadTexts: hm2NetACDAddrEntry.setStatus('current')
if mibBuilder.loadTexts: hm2NetACDAddrEntry.setDescription('IP Address conflict detection information about a particular address on the local system known to this agent. There may be multiple addresses configured on the system. Entries may be created and deleted in this table by the agent.')
hm2NetACDTimeMark = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 20, 1, 2, 20, 1, 1), TimeFilter()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2NetACDTimeMark.setReference('IETF RFC 2021 section 6')
if mibBuilder.loadTexts: hm2NetACDTimeMark.setStatus('current')
if mibBuilder.loadTexts: hm2NetACDTimeMark.setDescription('A TimeFilter for this entry. See the TimeFilter textual convention in IETF RFC 2021 and http://www.ietf.org/IESG/Implementations/RFC2021-Implementation.txt to see how TimeFilter works.')
hm2NetACDAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 20, 1, 2, 20, 1, 3), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2NetACDAddrType.setStatus('current')
if mibBuilder.loadTexts: hm2NetACDAddrType.setDescription('Local IP Address Type')
hm2NetACDIPAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 20, 1, 2, 20, 1, 5), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2NetACDIPAddr.setStatus('current')
if mibBuilder.loadTexts: hm2NetACDIPAddr.setDescription('IP address used to identify the management address component associated with the local system.')
hm2NetACDMAC = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 20, 1, 2, 20, 1, 7), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2NetACDMAC.setStatus('current')
if mibBuilder.loadTexts: hm2NetACDMAC.setDescription('The physical address of the device that was detected causing the ip address conflict.')
hm2NetACDifIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 20, 1, 2, 20, 1, 9), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2NetACDifIndex.setStatus('current')
if mibBuilder.loadTexts: hm2NetACDifIndex.setDescription('The interface index on the local system where the ip address conflict was detected.')
hm2NetLocalBurnedInMacAddr = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 20, 1, 3, 1), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2NetLocalBurnedInMacAddr.setStatus('current')
if mibBuilder.loadTexts: hm2NetLocalBurnedInMacAddr.setDescription('Physical base address (MAC address) of the agent. This is the burned in MAC address from the production')
hm2NetLocalAdminMacAddress = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 20, 1, 3, 2), MacAddress().clone(hexValue="000000000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2NetLocalAdminMacAddress.setStatus('current')
if mibBuilder.loadTexts: hm2NetLocalAdminMacAddress.setDescription("The switch's network locally administered MAC address. This is the locally MAC address from the administrator. If the hm2NetLocalAdminMacAddress is nonzero, the device starts with this MAC address at the next boot. If the variable is changed, they must be stored by the configuration manager. A MAC address with a set multicast bit will not be accepted")
hm2NetMacAddressType = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 20, 1, 3, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("burned-in", 1), ("local", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2NetMacAddressType.setStatus('current')
if mibBuilder.loadTexts: hm2NetMacAddressType.setDescription('Shows the currently used MAC address at boot time. The device starts with the burned in MAC address when hm2NetLocalAdminMacAddress is zero, otherwise with the Local-Admin-MAC-Address.')
hm2NetHiDiscoveryOperation = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 20, 1, 4, 1), HmEnabledStatus().clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2NetHiDiscoveryOperation.setStatus('current')
if mibBuilder.loadTexts: hm2NetHiDiscoveryOperation.setDescription('Enables/disables the HiDiscovery protocol on this device. This protocol allows a remote host to detect devices without an IP configuration. It also allows the host to set IP parameters, like the ip address, the netmask and the gateway address.')
hm2NetHiDiscoveryMode = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 20, 1, 4, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("readWrite", 1), ("readOnly", 2))).clone('readWrite')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2NetHiDiscoveryMode.setStatus('current')
if mibBuilder.loadTexts: hm2NetHiDiscoveryMode.setDescription('In the read only mode only detecting and reading the IP parameters is permitted. The read write mode gives full access to the device.')
hm2NetHiDiscoveryBlinking = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 20, 1, 4, 3), HmEnabledStatus().clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2NetHiDiscoveryBlinking.setStatus('current')
if mibBuilder.loadTexts: hm2NetHiDiscoveryBlinking.setDescription('Enables/disables the HiDiscovery blinking sequence on this device. This object will not be saved.')
hm2NetHiDiscoveryProtocol = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 20, 1, 4, 4), Bits().clone(namedValues=NamedValues(("none", 0), ("v1", 1), ("v2", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2NetHiDiscoveryProtocol.setStatus('current')
if mibBuilder.loadTexts: hm2NetHiDiscoveryProtocol.setDescription('Shows the HiDiscovery protocols supported by the device.')
hm2NetHiDiscoveryRelay = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 20, 1, 4, 5), HmEnabledStatus().clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2NetHiDiscoveryRelay.setStatus('current')
if mibBuilder.loadTexts: hm2NetHiDiscoveryRelay.setDescription('Relay/bridge HiDiscovery frames.')
hm2NetMacACDStatus = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 20, 1, 5, 1), HmEnabledStatus().clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2NetMacACDStatus.setStatus('current')
if mibBuilder.loadTexts: hm2NetMacACDStatus.setDescription('Sets the status of the MAC address conflict detection mechanism on this device.')
hm2NetMacACDConflictAddress = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 20, 1, 5, 2), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2NetMacACDConflictAddress.setStatus('current')
if mibBuilder.loadTexts: hm2NetMacACDConflictAddress.setDescription('MAC address in case of a conflict.')
hm2NetACDNotification = NotificationType((1, 3, 6, 1, 4, 1, 248, 11, 20, 0, 1)).setObjects(("HM2-NETCONFIG-MIB", "hm2NetACDTimeMark"), ("HM2-NETCONFIG-MIB", "hm2NetACDAddrType"), ("HM2-NETCONFIG-MIB", "hm2NetACDIPAddr"), ("HM2-NETCONFIG-MIB", "hm2NetACDMAC"), ("HM2-NETCONFIG-MIB", "hm2NetACDifIndex"))
if mibBuilder.loadTexts: hm2NetACDNotification.setStatus('current')
if mibBuilder.loadTexts: hm2NetACDNotification.setDescription('This trap reports an address conflict.')
hm2NetMacACDNotification = NotificationType((1, 3, 6, 1, 4, 1, 248, 11, 20, 0, 2)).setObjects(("IF-MIB", "ifIndex"), ("HM2-NETCONFIG-MIB", "hm2NetMacACDConflictAddress"))
if mibBuilder.loadTexts: hm2NetMacACDNotification.setStatus('current')
if mibBuilder.loadTexts: hm2NetMacACDNotification.setDescription("This trap reports a MAC address conflict with it's own MAC address.")
hm2NetOobMgmtAdminState = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 20, 1, 6, 1), HmEnabledStatus().clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2NetOobMgmtAdminState.setStatus('current')
if mibBuilder.loadTexts: hm2NetOobMgmtAdminState.setDescription('The status of the Out-of-band management on this device.')
hm2NetOobMgmtProtocol = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 20, 1, 6, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("bootp", 2), ("dhcp", 3))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2NetOobMgmtProtocol.setStatus('current')
if mibBuilder.loadTexts: hm2NetOobMgmtProtocol.setDescription("The switch's out-of-band network configuration protocol. The default value is dependent of the device type.")
hm2NetOobMgmtIPAddrType = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 20, 1, 6, 3), InetAddressType().clone('ipv4')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2NetOobMgmtIPAddrType.setStatus('current')
if mibBuilder.loadTexts: hm2NetOobMgmtIPAddrType.setDescription('Out-of-band IP address type.')
hm2NetOobMgmtIPAddr = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 20, 1, 6, 4), InetAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2NetOobMgmtIPAddr.setStatus('current')
if mibBuilder.loadTexts: hm2NetOobMgmtIPAddr.setDescription('Out-of-band IP address of the management agent board. Changing this value will take effect after activating with hm2NetOobMgmtAction.')
hm2NetOobMgmtPrefixLength = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 20, 1, 6, 5), InetAddressPrefixLength()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2NetOobMgmtPrefixLength.setStatus('current')
if mibBuilder.loadTexts: hm2NetOobMgmtPrefixLength.setDescription('The length of the IP netmask.')
hm2NetOobMgmtGatewayIPAddrType = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 20, 1, 6, 6), InetAddressType().clone('ipv4')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2NetOobMgmtGatewayIPAddrType.setStatus('current')
if mibBuilder.loadTexts: hm2NetOobMgmtGatewayIPAddrType.setDescription('Out-of-band default gateway IP address type.')
hm2NetOobMgmtGatewayIPAddr = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 20, 1, 6, 7), InetAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2NetOobMgmtGatewayIPAddr.setStatus('current')
if mibBuilder.loadTexts: hm2NetOobMgmtGatewayIPAddr.setDescription('Out-of-band IP address of the default gateway. Changing this value will take effect after activating with hm2NetOobMgmtAction.')
hm2NetOobMgmtMacAddress = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 20, 1, 6, 8), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2NetOobMgmtMacAddress.setStatus('current')
if mibBuilder.loadTexts: hm2NetOobMgmtMacAddress.setDescription('Out-of-band MAC address of the interface.')
hm2NetOobMgmtOperState = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 20, 1, 6, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2NetOobMgmtOperState.setStatus('current')
if mibBuilder.loadTexts: hm2NetOobMgmtOperState.setDescription('Out-of-band interface current operational state.')
hm2NetOobMgmtAction = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 20, 1, 6, 50), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("activate", 2))).clone('other')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2NetOobMgmtAction.setStatus('current')
if mibBuilder.loadTexts: hm2NetOobMgmtAction.setDescription('This object, when read, always returns a value of other(1). Setting the object to activate(2) causes a reconfiguration of the out-of-band IP protocol stack with the current values of hm2NetOobMgmtLocalIPAddr, hm2NetOobMgmtPrefixLength and hm2NetOobMgmtGatewayIPAddr.')
mibBuilder.exportSymbols("HM2-NETCONFIG-MIB", hm2NetACDStatus=hm2NetACDStatus, hm2NetLocalAdminMacAddress=hm2NetLocalAdminMacAddress, hm2NetACDAddrTable=hm2NetACDAddrTable, hm2NetOobMgmtAction=hm2NetOobMgmtAction, hm2NetACDDelay=hm2NetACDDelay, hm2NetACDOngoingProbeStatus=hm2NetACDOngoingProbeStatus, hm2NetACDReleaseDelay=hm2NetACDReleaseDelay, hm2NetOobMgmtIPAddrType=hm2NetOobMgmtIPAddrType, hm2NetStaticGroup=hm2NetStaticGroup, hm2NetAction=hm2NetAction, hm2NetMgmtPort=hm2NetMgmtPort, hm2NetACDIPAddr=hm2NetACDIPAddr, hm2NetConfigProtocol=hm2NetConfigProtocol, hm2NetOobMgmtGatewayIPAddrType=hm2NetOobMgmtGatewayIPAddrType, hm2NetConfigMibNotifications=hm2NetConfigMibNotifications, hm2NetACDNotification=hm2NetACDNotification, hm2NetACDFaultState=hm2NetACDFaultState, hm2NetACDGroup=hm2NetACDGroup, hm2NetGatewayIPAddrType=hm2NetGatewayIPAddrType, hm2NetMacACDNotification=hm2NetMacACDNotification, hm2NetVlanPriority=hm2NetVlanPriority, hm2NetIpDscpPriority=hm2NetIpDscpPriority, hm2NetLocalIPAddrType=hm2NetLocalIPAddrType, hm2NetACDifIndex=hm2NetACDifIndex, hm2NetHiDiscoveryMode=hm2NetHiDiscoveryMode, hm2NetConfigMibObjects=hm2NetConfigMibObjects, hm2NetOobMgmtGatewayIPAddr=hm2NetOobMgmtGatewayIPAddr, hm2NetPrefixLength=hm2NetPrefixLength, hm2NetOobMgmtMacAddress=hm2NetOobMgmtMacAddress, hm2NetLocalIPAddr=hm2NetLocalIPAddr, hm2NetACDAddrType=hm2NetACDAddrType, hm2NetACDProtectInterval=hm2NetACDProtectInterval, hm2NetConfigMib=hm2NetConfigMib, hm2NetHiDiscoveryGroup=hm2NetHiDiscoveryGroup, hm2NetHiDiscoveryRelay=hm2NetHiDiscoveryRelay, hm2NetMacGroup=hm2NetMacGroup, hm2NetMacACDConflictAddress=hm2NetMacACDConflictAddress, hm2NetHiDiscoveryProtocol=hm2NetHiDiscoveryProtocol, hm2NetVlanID=hm2NetVlanID, hm2NetMacACDGroup=hm2NetMacACDGroup, hm2NetOobMgmtProtocol=hm2NetOobMgmtProtocol, hm2NetACDDetectionMode=hm2NetACDDetectionMode, hm2NetACDMaxProtection=hm2NetACDMaxProtection, hm2NetACDTimeMark=hm2NetACDTimeMark, hm2NetACDAddrEntry=hm2NetACDAddrEntry, hm2NetLocalBurnedInMacAddr=hm2NetLocalBurnedInMacAddr, hm2NetHiDiscoveryOperation=hm2NetHiDiscoveryOperation, hm2NetACDTrapEnable=hm2NetACDTrapEnable, hm2NetOobMgmtGroup=hm2NetOobMgmtGroup, hm2NetHiDiscoveryBlinking=hm2NetHiDiscoveryBlinking, hm2NetOobMgmtIPAddr=hm2NetOobMgmtIPAddr, hm2NetACDMAC=hm2NetACDMAC, hm2NetMacACDStatus=hm2NetMacACDStatus, hm2NetDHCPClientId=hm2NetDHCPClientId, hm2NetOobMgmtAdminState=hm2NetOobMgmtAdminState, hm2NetOobMgmtPrefixLength=hm2NetOobMgmtPrefixLength, hm2NetGatewayIPAddr=hm2NetGatewayIPAddr, PYSNMP_MODULE_ID=hm2NetConfigMib, hm2NetMacAddressType=hm2NetMacAddressType, hm2NetOobMgmtOperState=hm2NetOobMgmtOperState)

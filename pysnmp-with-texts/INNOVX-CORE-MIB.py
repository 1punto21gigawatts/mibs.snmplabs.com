#
# PySNMP MIB module INNOVX-CORE-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/INNOVX-CORE-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:22:57 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint, ConstraintsIntersection, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint", "ConstraintsIntersection", "ConstraintsUnion")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
sysName, = mibBuilder.importSymbols("SNMPv2-MIB", "sysName")
IpAddress, Unsigned32, MibScalar, MibTable, MibTableRow, MibTableColumn, NotificationType, MibIdentifier, Gauge32, Counter32, ObjectIdentity, Integer32, NotificationType, TimeTicks, Counter64, ModuleIdentity, iso, enterprises, Bits = mibBuilder.importSymbols("SNMPv2-SMI", "IpAddress", "Unsigned32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "NotificationType", "MibIdentifier", "Gauge32", "Counter32", "ObjectIdentity", "Integer32", "NotificationType", "TimeTicks", "Counter64", "ModuleIdentity", "iso", "enterprises", "Bits")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
gdc = MibIdentifier((1, 3, 6, 1, 4, 1, 498))
framerelay = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 22))
innovx = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 22, 1))
coreGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 22, 1, 1))
linkProbe = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 22, 1, 2))
liuGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 22, 1, 3))
casGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 22, 1, 4))
ddsGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 22, 1, 5))
dteGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 22, 1, 6))
coreAdmin = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 22, 1, 1, 1))
coreReset = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 22, 1, 1, 2))
coreDiags = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 22, 1, 1, 3))
coreStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 22, 1, 1, 4))
coreTrapArgs = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 22, 1, 1, 5))
coreAggRate = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 22, 1, 1, 6))
coreFeatures = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 22, 1, 1, 7))
innovxMIBversion = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(5, 5)).setFixedLength(5)).setMaxAccess("readonly")
if mibBuilder.loadTexts: innovxMIBversion.setStatus('mandatory')
if mibBuilder.loadTexts: innovxMIBversion.setDescription("Identifies the version of the MIB as `X.YZT' where: X: Major Revision (1-9) Y: Minor Revision (0-9) Z: Typographical Revision (0-9) T: Test Revision (A-Z) Upon formal release, the test revision will not be present.")
innovxFirmwareVersion = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: innovxFirmwareVersion.setStatus('mandatory')
if mibBuilder.loadTexts: innovxFirmwareVersion.setDescription("Identifies the version of the firmware as `MM.NN.BB' where: MM: Major Revision (0-99) NN: Minor Revision (0-99) BB: Bug Fix Revision (0-99) ")
innovxSerialNumber = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readonly")
if mibBuilder.loadTexts: innovxSerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: innovxSerialNumber.setDescription('Identifies the serial number of the unit.')
innovxHardwareVersion = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: innovxHardwareVersion.setStatus('mandatory')
if mibBuilder.loadTexts: innovxHardwareVersion.setDescription('Identifies the version of the base card hardware. The released version number is sequenced as follows: --, A-, ... AA, ... ZZ. ')
innovxHardwareDescription = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 1, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(255, 255)).setFixedLength(255)).setMaxAccess("readonly")
if mibBuilder.loadTexts: innovxHardwareDescription.setStatus('mandatory')
if mibBuilder.loadTexts: innovxHardwareDescription.setDescription('Identifies the model number, memory size and options. Example=> Model: 553, Flash: 2M, RAM: 16M, Options: Cascade')
innovxBootCodeVersion = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 1, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: innovxBootCodeVersion.setStatus('mandatory')
if mibBuilder.loadTexts: innovxBootCodeVersion.setDescription('Identifies the version of the bootstrap firmware. The released version number is sequenced as follows: --, A-, ... AA, ... ZZ. ')
innovxHardwareOptions = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 1, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: innovxHardwareOptions.setStatus('mandatory')
if mibBuilder.loadTexts: innovxHardwareOptions.setDescription('Identifies the hardware options installed on this innovx product. where 0 = not installed and 1 = installed, as follows: LED description Octet 1 bit 7 - n/u bit 6 - n/u bit 5 - n/u bit 4 - n/u bit 3 - n/u bit 2 - n/u bit 1 - n/u bit 0 - n/u Octet 2 bit 7 - n/u bit 6 - n/u bit 5 - n/u bit 4 - n/u bit 3 - n/u bit 2 - n/u bit 1 - n/u bit 0 - Cascade Adapter')
cmnTrapAddrTable = MibTable((1, 3, 6, 1, 4, 1, 498, 22, 1, 1, 1, 8), )
if mibBuilder.loadTexts: cmnTrapAddrTable.setStatus('mandatory')
if mibBuilder.loadTexts: cmnTrapAddrTable.setDescription('A table of management systems ready to accept traps generated by this node. To add an entry to the table, a set on the Community name for the instance (IP Address and UDP PORT) needs to be performed. To delete an entry, a set on the Status to invalid on the instance needs to be performed.')
cmnTrapAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 22, 1, 1, 1, 8, 1), ).setIndexNames((0, "INNOVX-CORE-MIB", "cmnTrapAddrIpDest"))
if mibBuilder.loadTexts: cmnTrapAddrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cmnTrapAddrEntry.setDescription('Information needed to deliver traps to a particular management station. This table holds a maximum of 4 entries.')
cmnTrapAddrIpDest = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 1, 1, 8, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmnTrapAddrIpDest.setStatus('mandatory')
if mibBuilder.loadTexts: cmnTrapAddrIpDest.setDescription('The IP address of the management agent receiving traps. The IP address of 0.0.0.0 will not be allowed.')
cmnTrapAddrCommunity = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 1, 1, 8, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmnTrapAddrCommunity.setStatus('mandatory')
if mibBuilder.loadTexts: cmnTrapAddrCommunity.setDescription('The community name expected by the management station receiving traps.')
cmnTrapAddrStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 1, 1, 8, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmnTrapAddrStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cmnTrapAddrStatus.setDescription('The status of the entry. If read and the entry exists, valid(1) will always be returned. Invalid entries will be removed from the table.')
innovxSoftReset = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 1, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normal", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: innovxSoftReset.setStatus('mandatory')
if mibBuilder.loadTexts: innovxSoftReset.setDescription("A set of `reset' on this object instructs the unit to perform a soft reset.")
innovxStatsReset = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 1, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normal", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: innovxStatsReset.setStatus('mandatory')
if mibBuilder.loadTexts: innovxStatsReset.setDescription("A set of `reset' on this object instructs the unit to set all statistics tracking objects to zero, including: current interval values, 24 hour total values, number of valid historical interval objects values, and all historical interval objects values (#1 - #96).")
innovxSelfTest = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 1, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normal", 1), ("start-test", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: innovxSelfTest.setStatus('mandatory')
if mibBuilder.loadTexts: innovxSelfTest.setDescription("A set of `start-test' on this object instructs the unit to perform a self test.")
innovxSelfTestStatus = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 1, 3, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("normal-complete-pass", 1), ("normal-complete-fail", 2), ("test-in-progress", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: innovxSelfTestStatus.setStatus('mandatory')
if mibBuilder.loadTexts: innovxSelfTestStatus.setDescription("Describes the result of a unit self test, during normal operation and after an innovxSoftReset or an innovxDefaultReset this object will read `normal-complete-pass'.")
innovxLedStatus = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 1, 4, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: innovxLedStatus.setStatus('mandatory')
if mibBuilder.loadTexts: innovxLedStatus.setDescription('A bitwise snapshot of the front panel LED states, where 0 = LED off and 1 = LED on, as follows: LED description Octet 1 bit 7 - n/u bit 6 - n/u bit 5 - n/u bit 4 - LAN LAN activity bit 3 - ALM Alarm Condition - any bit 2 - CN Congestion (FECNS & BECNS) bit 1 - TST Test Mode bit 0 - ERR Framing Errors')
innovxPortStatus = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 1, 4, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: innovxPortStatus.setStatus('mandatory')
if mibBuilder.loadTexts: innovxPortStatus.setDescription("A bitwise snapshot of interface port status conditions and EIA signals, where 0 = condition not present, and 1 = condition present, as follows: Octet 1 - ETHERNET Interface Port Status bit 7 - n/u bit 6 - n/u bit 5 - n/u bit 4 - Transmit Activity bit 3 - Receive Activity bit 2 - Runt packet (<64k bytes) bit 1 - CRC Error bit 0 - Transmit Collisions Octet 2 - PPP/CONSOLE Interface Port Status bit 7 - interface mode: 0 = PPP, 1 = Console, (invalid if 'handshake in progress') bit 6 - handshake in progress = 1/handshake complete = 0 bit 5 - n/u bit 4 - n/u bit 3 - n/u bit 2 - DTR Loss bit 1 - Transmit Activity bit 0 - Receive Activity")
innovxPortFrameCounts = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 1, 4, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: innovxPortFrameCounts.setStatus('mandatory')
if mibBuilder.loadTexts: innovxPortFrameCounts.setDescription('The total number of frames transmitted and received on each interface port. This object will be reset to zero after a read, and after power up, soft reset, or factory defaults reset. Octet 1 - ETHERNET Interface Transmit Frame Count Octet 2 bit 7 - 2^15 bit 7 - 2^7 bit 6 - 2^14 bit 6 - 2^6 bit 5 - 2^13 bit 5 - 2^5 bit 4 - 2^12 bit 4 - 2^4 bit 3 - 2^11 bit 3 - 2^3 bit 2 - 2^10 bit 2 - 2^2 bit 1 - 2^9 bit 1 - 2^1 bit 0 - 2^8 bit 0 - 2^0 Octet 3 - ETHERNET Interface Receive Frame Count Octet 4 bit 7 - 2^15 bit 7 - 2^7 bit 6 - 2^14 bit 6 - 2^6 bit 5 - 2^13 bit 5 - 2^5 bit 4 - 2^12 bit 4 - 2^4 bit 3 - 2^11 bit 3 - 2^3 bit 2 - 2^10 bit 2 - 2^2 bit 1 - 2^9 bit 1 - 2^1 bit 0 - 2^8 bit 0 - 2^0 Octet 5 - PPP/CONSOLE Intrf Tx Data Byte Count Octet 6 bit 7 - 2^15 bit 7 - 2^7 bit 6 - 2^14 bit 6 - 2^6 bit 5 - 2^13 bit 5 - 2^5 bit 4 - 2^12 bit 4 - 2^4 bit 3 - 2^11 bit 3 - 2^3 bit 2 - 2^10 bit 2 - 2^2 bit 1 - 2^9 bit 1 - 2^1 bit 0 - 2^8 bit 0 - 2^0 Octet 7 - PPP/CONSOLE Intrf Rx Data Byte Count Octet 8 bit 7 - 2^15 bit 7 - 2^7 bit 6 - 2^14 bit 6 - 2^6 bit 5 - 2^13 bit 5 - 2^5 bit 4 - 2^12 bit 4 - 2^4 bit 3 - 2^11 bit 3 - 2^3 bit 2 - 2^10 bit 2 - 2^2 bit 1 - 2^9 bit 1 - 2^1 bit 0 - 2^8 bit 0 - 2^0')
innovxTrapSeverity = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 1, 5, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("critical", 1), ("major", 2), ("minor", 3), ("warning", 4), ("info", 5))))
if mibBuilder.loadTexts: innovxTrapSeverity.setStatus('mandatory')
if mibBuilder.loadTexts: innovxTrapSeverity.setDescription('Trap argument describing severity of the trap being reported.')
innovxTrapState = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 1, 5, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16)))
if mibBuilder.loadTexts: innovxTrapState.setStatus('mandatory')
if mibBuilder.loadTexts: innovxTrapState.setDescription('Trap argument describing the state of the specific condition reported as: active, clear or exceeded.')
innovxTrapDescription = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 1, 5, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255)))
if mibBuilder.loadTexts: innovxTrapDescription.setStatus('mandatory')
if mibBuilder.loadTexts: innovxTrapDescription.setDescription('Trap argument describing the trap being reported.')
innovxTrapThreshold = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 1, 5, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255)))
if mibBuilder.loadTexts: innovxTrapThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: innovxTrapThreshold.setDescription('Trap argument describing the threshold value which was met in reporting the trap condition. This argument will be NULL (size 0) if not applicable to the trap condition being reported.')
innovxTrapActualValue = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 1, 5, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255)))
if mibBuilder.loadTexts: innovxTrapActualValue.setStatus('mandatory')
if mibBuilder.loadTexts: innovxTrapActualValue.setDescription('Trap argument identifying the current event value of this trap. This argument will be NULL (size 0) if not applicable to the trap condition being reported.')
innovxTrapDlci = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 1, 5, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 991)))
if mibBuilder.loadTexts: innovxTrapDlci.setStatus('mandatory')
if mibBuilder.loadTexts: innovxTrapDlci.setDescription('Trap argument identifying the DLCI number of the specific condition reported. This argument will be set to 0 if not applicable to the trap condition being reported.')
innovxpvcIdentifier = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 1, 5, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32)))
if mibBuilder.loadTexts: innovxpvcIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: innovxpvcIdentifier.setDescription('Comment field for PVC description, backfilled from the FRProbe mib.')
innovxAlarmTrap = NotificationType((1, 3, 6, 1, 4, 1, 498, 22, 1) + (0,1)).setObjects(("SNMPv2-MIB", "sysName"), ("INNOVX-CORE-MIB", "innovxTrapSeverity"), ("INNOVX-CORE-MIB", "innovxTrapState"), ("INNOVX-CORE-MIB", "innovxTrapDescription"), ("INNOVX-CORE-MIB", "innovxTrapThreshold"), ("INNOVX-CORE-MIB", "innovxTrapActualValue"), ("INNOVX-CORE-MIB", "innovxTrapDlci"), ("INNOVX-CORE-MIB", "innovxpvcIdentifier"))
if mibBuilder.loadTexts: innovxAlarmTrap.setDescription('Trap used to report all alarm conditions on the Innovx products. Some trap arguments may not apply for specific conditions reported, see above. Imported arguments: sysName - from rfc1213.mib, and pvcIdentifier - from FPProbe.mib, a comment field for DLCI description, pvcIdentifier will be NULL (size 0) if not applicable to the trap condition being reported.')
ap553DS0Format = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 1, 6, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("nx56k", 1), ("nx64k", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ap553DS0Format.setStatus('mandatory')
if mibBuilder.loadTexts: ap553DS0Format.setDescription("Defines the DS0 base rate as either 56K or 64K bits per second. This object value, in conjunction with the ap553NumDS0s object value determines the LIU aggregate bandwidth. `nx64k' defines a DS0 data format as clear channel in which all 8 bits of the DS0 are used for data. `nx56k defines a DS0 data format as 7 bits for data, and 1 bit used for signalling information or unused and forced to marks. The DSU will enforce an 8x(N+1) minimum ones density requirement when ap553NetLineCoding == `ami' and ap553DS0Format == `nx64k' and ap553DS0AllocationScheme == `consecutive'.")
ap553NumberOfDS0s = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 1, 6, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 24))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ap553NumberOfDS0s.setStatus('mandatory')
if mibBuilder.loadTexts: ap553NumberOfDS0s.setDescription('Defines the number of DS0 cells used for passing DSU data. When ap553DS0AllocationScheme is consecutive, valid values are 1 - N where N <= (25 - ap553StartingDS0). When ap553DS0AllocationScheme is alternate, valid values are 1 - N where N <= (25 - ap553StartingDS0)/2.')
innovxFeatureTable = MibTable((1, 3, 6, 1, 4, 1, 498, 22, 1, 1, 7, 1), )
if mibBuilder.loadTexts: innovxFeatureTable.setStatus('mandatory')
if mibBuilder.loadTexts: innovxFeatureTable.setDescription('A table of keyable software features contained in this this product. This table holds information about the software features that are available and can be Key enabled on this product. It also holds the status (On/Off) of the enabled features.')
innovxFeatureEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 22, 1, 1, 7, 1, 1), ).setIndexNames((0, "INNOVX-CORE-MIB", "innovxFeatureIndex"))
if mibBuilder.loadTexts: innovxFeatureEntry.setStatus('mandatory')
if mibBuilder.loadTexts: innovxFeatureEntry.setDescription('Software Features that have been Key enabled in this product. This table holds a maximum of 16 entries.')
innovxFeatureIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 1, 7, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: innovxFeatureIndex.setStatus('mandatory')
if mibBuilder.loadTexts: innovxFeatureIndex.setDescription(' Identifies an entry (row) in the feature table, 1-16 features. ')
innovxFeatureName = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 1, 7, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: innovxFeatureName.setStatus('mandatory')
if mibBuilder.loadTexts: innovxFeatureName.setDescription('The Name of the feature that is available in this software.')
innovxFeatureEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 1, 7, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: innovxFeatureEnable.setStatus('mandatory')
if mibBuilder.loadTexts: innovxFeatureEnable.setDescription('The state of the feature, whether it has been Key enabled or not. WEBFLAG Disabled Enabled WEBEND ')
innovxFeatureStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 1, 7, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: innovxFeatureStatus.setStatus('mandatory')
if mibBuilder.loadTexts: innovxFeatureStatus.setDescription('The operational status of the feature, on -- selected, off -- not selected. WEBFLAG Off On WEBEND ')
mibBuilder.exportSymbols("INNOVX-CORE-MIB", coreDiags=coreDiags, innovxFeatureIndex=innovxFeatureIndex, coreAdmin=coreAdmin, gdc=gdc, innovxLedStatus=innovxLedStatus, liuGroup=liuGroup, ap553DS0Format=ap553DS0Format, innovxFeatureName=innovxFeatureName, coreFeatures=coreFeatures, cmnTrapAddrStatus=cmnTrapAddrStatus, innovxTrapActualValue=innovxTrapActualValue, innovxFeatureEntry=innovxFeatureEntry, innovxTrapState=innovxTrapState, innovxTrapThreshold=innovxTrapThreshold, cmnTrapAddrCommunity=cmnTrapAddrCommunity, cmnTrapAddrTable=cmnTrapAddrTable, ddsGroup=ddsGroup, coreGroup=coreGroup, innovxHardwareDescription=innovxHardwareDescription, innovxTrapDescription=innovxTrapDescription, innovxStatsReset=innovxStatsReset, innovxPortStatus=innovxPortStatus, coreAggRate=coreAggRate, ap553NumberOfDS0s=ap553NumberOfDS0s, innovxSoftReset=innovxSoftReset, framerelay=framerelay, coreReset=coreReset, innovxBootCodeVersion=innovxBootCodeVersion, innovxHardwareOptions=innovxHardwareOptions, cmnTrapAddrIpDest=cmnTrapAddrIpDest, innovxAlarmTrap=innovxAlarmTrap, innovxSerialNumber=innovxSerialNumber, innovx=innovx, dteGroup=dteGroup, innovxHardwareVersion=innovxHardwareVersion, innovxFeatureStatus=innovxFeatureStatus, casGroup=casGroup, innovxFeatureEnable=innovxFeatureEnable, coreStatus=coreStatus, innovxSelfTest=innovxSelfTest, innovxSelfTestStatus=innovxSelfTestStatus, innovxTrapDlci=innovxTrapDlci, innovxMIBversion=innovxMIBversion, innovxPortFrameCounts=innovxPortFrameCounts, innovxFeatureTable=innovxFeatureTable, cmnTrapAddrEntry=cmnTrapAddrEntry, linkProbe=linkProbe, innovxTrapSeverity=innovxTrapSeverity, innovxpvcIdentifier=innovxpvcIdentifier, coreTrapArgs=coreTrapArgs, innovxFirmwareVersion=innovxFirmwareVersion)

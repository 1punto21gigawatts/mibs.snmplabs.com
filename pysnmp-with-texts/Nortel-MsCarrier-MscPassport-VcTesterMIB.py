#
# PySNMP MIB module Nortel-MsCarrier-MscPassport-VcTesterMIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/Nortel-MsCarrier-MscPassport-VcTesterMIB
# Produced by pysmi-0.3.4 at Wed May  1 14:31:35 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ConstraintsUnion, ValueRangeConstraint, SingleValueConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ConstraintsUnion", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsIntersection")
Unsigned32, Integer32, RowStatus, DisplayString, StorageType, RowPointer = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-StandardTextualConventionsMIB", "Unsigned32", "Integer32", "RowStatus", "DisplayString", "StorageType", "RowPointer")
HexString, EnterpriseDateAndTime, AsciiString, DigitString, Link, Hex, NonReplicated = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-TextualConventionsMIB", "HexString", "EnterpriseDateAndTime", "AsciiString", "DigitString", "Link", "Hex", "NonReplicated")
mscComponents, mscPassportMIBs = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-UsefulDefinitionsMIB", "mscComponents", "mscPassportMIBs")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Unsigned32, Integer32, Counter32, Gauge32, ModuleIdentity, Bits, NotificationType, Counter64, MibScalar, MibTable, MibTableRow, MibTableColumn, IpAddress, iso, ObjectIdentity, MibIdentifier, TimeTicks = mibBuilder.importSymbols("SNMPv2-SMI", "Unsigned32", "Integer32", "Counter32", "Gauge32", "ModuleIdentity", "Bits", "NotificationType", "Counter64", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "IpAddress", "iso", "ObjectIdentity", "MibIdentifier", "TimeTicks")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
vcTesterMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 34))
mscVct = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130))
mscVctRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 1), )
if mibBuilder.loadTexts: mscVctRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctRowStatusTable.setDescription('This entry controls the addition and deletion of mscVct components.')
mscVctRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VcTesterMIB", "mscVctIndex"))
if mibBuilder.loadTexts: mscVctRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctRowStatusEntry.setDescription('A single entry in the table represents a single mscVct component.')
mscVctRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVct components. These components can be added and deleted.')
mscVctComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVctStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctStorageType.setDescription('This variable represents the storage type value for the mscVct tables.')
mscVctIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16)))
if mibBuilder.loadTexts: mscVctIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctIndex.setDescription('This variable represents the index for the mscVct tables.')
mscVctProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 10), )
if mibBuilder.loadTexts: mscVctProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctProvTable.setDescription('This group provides the set of parameters for theVcTester component')
mscVctProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VcTesterMIB", "mscVctIndex"))
if mibBuilder.loadTexts: mscVctProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctProvEntry.setDescription('An entry in the mscVctProvTable.')
mscVctLogicalProcessor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 10, 1, 1), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctLogicalProcessor.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctLogicalProcessor.setDescription('This attribute specifies the logical processor on which the VcTester will run')
mscVctVcName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("gvc", 1), ("fvc", 2))).clone('gvc')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctVcName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcName.setDescription('This attribute specifies the type of vc (fvc or gvc) which will be used by VcTester.')
mscVctDna = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2))
mscVctDnaRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 1), )
if mibBuilder.loadTexts: mscVctDnaRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaRowStatusTable.setDescription('This entry controls the addition and deletion of mscVctDna components.')
mscVctDnaRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VcTesterMIB", "mscVctIndex"), (0, "Nortel-MsCarrier-MscPassport-VcTesterMIB", "mscVctDnaIndex"))
if mibBuilder.loadTexts: mscVctDnaRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaRowStatusEntry.setDescription('A single entry in the table represents a single mscVctDna component.')
mscVctDnaRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctDnaRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVctDna components. These components cannot be added nor deleted.')
mscVctDnaComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctDnaComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVctDnaStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctDnaStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaStorageType.setDescription('This variable represents the storage type value for the mscVctDna tables.')
mscVctDnaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscVctDnaIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaIndex.setDescription('This variable represents the index for the mscVctDna tables.')
mscVctDnaAddressTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 10), )
if mibBuilder.loadTexts: mscVctDnaAddressTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaAddressTable.setDescription("Address group contains attributes common to all Dna's. Every Dna used in the network is defined with this group of 2 attributes. String of address digits is complemented by type of address and Npi. These attributes are used to interpret format of the address digits.")
mscVctDnaAddressEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VcTesterMIB", "mscVctIndex"), (0, "Nortel-MsCarrier-MscPassport-VcTesterMIB", "mscVctDnaIndex"))
if mibBuilder.loadTexts: mscVctDnaAddressEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaAddressEntry.setDescription('An entry in the mscVctDnaAddressTable.')
mscVctDnaNumberingPlanIndicator = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("x121", 0), ("e164", 1))).clone('x121')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDnaNumberingPlanIndicator.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaNumberingPlanIndicator.setDescription('This attribute indicates the Numbering Plan Indicator (NPI) of the Dna that is entered. Address may belong to X.121 or E.164 plans. X.121 is used in packet svitched data networks.')
mscVctDnaDataNetworkAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 10, 1, 2), DigitString().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDnaDataNetworkAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaDataNetworkAddress.setDescription('Dna attribute contains digits which form unique identifier of the customer interface. It can be compared (approximation only) to telephone number where phone number identifies unique telephone set. Dna digits are selected and assigned by network operators.')
mscVctDnaOutgoingOptionsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 11), )
if mibBuilder.loadTexts: mscVctDnaOutgoingOptionsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaOutgoingOptionsTable.setDescription('OutgoingOptions group defines call options of a Dna for calls which are made out of the interface represented by Dna. All these options are not used for calls arriving to the interface represented by Dna.')
mscVctDnaOutgoingOptionsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VcTesterMIB", "mscVctIndex"), (0, "Nortel-MsCarrier-MscPassport-VcTesterMIB", "mscVctDnaIndex"))
if mibBuilder.loadTexts: mscVctDnaOutgoingOptionsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaOutgoingOptionsEntry.setDescription('An entry in the mscVctDnaOutgoingOptionsTable.')
mscVctDnaOutCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disallowed", 0), ("allowed", 1))).clone('allowed')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDnaOutCalls.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaOutCalls.setDescription("This attribute, if set to a value of allowed indicates that outgoing calls (from the DTE to the network) can be made using this particular Dna. If set to a value of disallowed, then outgoing calls cannot be made using this Dna - such calls will be cleared by the local DCE. This attribute corresponds to the ITU-T 'Outgoing Calls Barred' feature for Dnas in that outgoing calls are barred if this attribute is set to a value of disallowed. Either outCalls, or incCalls (or both) must be set to a value of allowed for this Dna to be useable.")
mscVctDnaOutNormalCharge = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disallowed", 0), ("allowed", 1))).clone('allowed')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDnaOutNormalCharge.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaOutNormalCharge.setDescription('This attribute, if set to a value of allowed indicates that outgoing normal charged calls (from the DTE to the network) can be made using this particular Dna. If set to a value of disallowed, then such calls cannot be made using this Dna - such calls will be cleared by the local DCE. This attribute is ignored if the corresponding attribute, outCalls is set to a value of disallowed.')
mscVctDnaOutReverseCharge = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 11, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disallowed", 0), ("allowed", 1))).clone('allowed')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDnaOutReverseCharge.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaOutReverseCharge.setDescription('This attribute, if set to a value of allowed indicates that outgoing reverse charged calls (from the DTE to the network) can be made using this particular Dna. If set to a value of disallowed, then such calls cannot be made using this Dna - such calls will be cleared by the local DCE. This attribute is ignored if the corresponding attribute, outCalls is set to a value of disallowed.')
mscVctDnaOutForceReverseCharge = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 11, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDnaOutForceReverseCharge.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaOutForceReverseCharge.setDescription('This attribute specifies whether to force outgoing reverse charged calls. This attribute, if set to a value of yes forces reverse charging on all outgoing calls (from the DTE to the network) using this particular Dna unless the caller specifies a NUI in which case the call is charged to the NUI. If set to a value of no then reverse charging is not forced for outgoing calls. This attribute is ignored if the corresponding attribute, outCalls is set to a value of disallowed.This attribute must be semantically consistent with the corresponding attribute, outReverseChargeCalls.')
mscVctDnaOutNormalPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 11, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disallowed", 0), ("allowed", 1))).clone('allowed')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDnaOutNormalPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaOutNormalPriority.setDescription('This attribute, if set to a value of allowed indicates that outgoing normal priority calls (from the DTE to the network) can be made using this particular Dna. If set to a value of disallowed, then such calls cannot be made using this Dna - such calls will be cleared by the local DCE. This attribute is ignored if the corresponding attribute, outCalls is set to a value of disallowed. This option can be also included in X.25 signalling, in such case it will be overruled.')
mscVctDnaOutHighPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 11, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disallowed", 0), ("allowed", 1))).clone('allowed')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDnaOutHighPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaOutHighPriority.setDescription('This attribute, if set to a value of allowed indicates that outgoing high priority calls (from the DTE to the network) can be made using this particular Dna. If set to a value of disallowed, then such calls cannot be made using this Dna - such calls will be cleared by the local DCE. This attribute is ignored if the corresponding attribute, outCalls is set to a value of disallowed. This option can be also included in X.25 signalling, in such case it will be overruled.')
mscVctDnaOutDefaultPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 11, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("normal", 0), ("high", 1))).clone('normal')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDnaOutDefaultPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaOutDefaultPriority.setDescription('This attribute, if set to normal indicates that the default priority for outgoing calls (from the DTE to the network) using this particular Dna is normal priority - if the priority is not specified by the DTE. If this attribute is set to high then the default priority for outgoing calls using this particular Dna is high priority. It can be overridden by the discardPriority under DLCI Direct Call subcomponent. This option can be also included in X.25 signalling, in such case it will be overruled.')
mscVctDnaOutIntl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 11, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disallowed", 0), ("allowed", 1))).clone('disallowed')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDnaOutIntl.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaOutIntl.setDescription('This attribute, if set to a value of allowed indicates that outgoing international calls (from the DTE to the network) can be made using this particular Dna. If set to a value of disallowed, then such calls cannot be made using this Dna - such calls will be cleared by the local DCE. This attribute also currently controls access to the E.164 numbering plan, and if set to a value of allowed, then cross-numbering plan calls are allowed. This attribute is ignored if the corresponding attribute, outCalls is set to a value of disallowed.')
mscVctDnaOutFsRestrictedResponse = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 11, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disallowed", 0), ("allowed", 1))).clone('disallowed')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDnaOutFsRestrictedResponse.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaOutFsRestrictedResponse.setDescription('This attribute, if set to a value of allowed indicates that outgoing fast select calls (from the DTE to the network) with a restricted response can be made using this particular Dna. If set to a value of disallowed, then such calls cannot be made using this Dna - such calls will be cleared by the local DCE. This attribute is ignored if the corresponding attribute, outCalls is set to a value of disallowed.')
mscVctDnaOutFsUnrestrictedResponse = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 11, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disallowed", 0), ("allowed", 1))).clone('disallowed')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDnaOutFsUnrestrictedResponse.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaOutFsUnrestrictedResponse.setDescription('This attribute, if set to a value of allowed indicates that outgoing fast select calls (from the DTE to the network) with an unrestricted response can be made using this particular Dna. If set to a value of disallowed, then such calls cannot be made using this Dna - such calls will be cleared by the local DCE. This attribute is ignored if the corresponding attribute, outCalls is set to a value of disallowed.')
mscVctDnaOutDefaultPathSensitivity = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 11, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("throughput", 0), ("delay", 1))).clone('throughput')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDnaOutDefaultPathSensitivity.setStatus('obsolete')
if mibBuilder.loadTexts: mscVctDnaOutDefaultPathSensitivity.setDescription('This attribute specifies the default class of path sensitivity to network for all outgoing calls using this particular Dna. The chosen default class of path sensitivity applies to all outgoing calls established using this Dna. This attribute, if set to a value of throughput, indicates that the default class is throughput sensitive. If set to a value of delay, then the default class is delay sensitive. The default of outDefaultPathSensitivity is throughput. This attribute is obsoleted. Please refer to defaultTransferPriority for the corresponding new attribute. The migration function here will provide')
mscVctDnaOutPathSensitivityOverRide = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 11, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDnaOutPathSensitivityOverRide.setStatus('obsolete')
if mibBuilder.loadTexts: mscVctDnaOutPathSensitivityOverRide.setDescription('If this attribute is set to in the call request, the called end will use the calling end provisioning data on path sensitivity to override its own provisioning data. The default of outPathSensitivityOverRide is no.')
mscVctDnaOutPathSensitivitySignal = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 11, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disallowed", 0), ("allowed", 1))).clone('disallowed')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDnaOutPathSensitivitySignal.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaOutPathSensitivitySignal.setDescription('This is the sensitivity signaling. If this attribute is set to allowed, the signalled value on sensitivity will be used.')
mscVctDnaOutDefaultPathReliability = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 11, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("high", 0), ("normal", 1))).clone('high')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDnaOutDefaultPathReliability.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaOutDefaultPathReliability.setDescription('This attribute specifies the default class of routing for reliability routing for all outgoing calls (from the DTE to the network) using this particular Dna. The chosen default class of routing applies to all outgoing calls established using this Dna, and applies to the packets travelling in both directions on all outgoing calls (local to remote, and remote to local). For incoming calls, the default class of routing is chosen by the calling party (as opposed to DPN, where either end of the call can choose the default routing class). This attribute, if set to a value of normal, indicates that the default class of routing is normal reliability routing. If set to a value of high, then the default class of routing is high reliability routing. High reliability is the standard choice for most DPN and Passport services. It usually indicates that packets are overflowed or retransmitted at various routing levels. Typically high reliability results in duplication and disordering of packets in the network when errors are detected or during link congestion. However, the Vc handles the duplication and disordering to ensure that packets are delivered to the DTE properly. For the Frame Relay service, duplication of packets is not desired, in which case, normal reliability may be chosen as the preferred class of routing.')
mscVctDnaOutPathReliabilityOverRide = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 11, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDnaOutPathReliabilityOverRide.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaOutPathReliabilityOverRide.setDescription('If outReliabilityOverRide set in the call request, the called end will use the calling end provisioning data on reliability to overide his provisioning data.')
mscVctDnaOutPathReliabilitySignal = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 11, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disallowed", 0), ("allowed", 1))).clone('disallowed')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDnaOutPathReliabilitySignal.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaOutPathReliabilitySignal.setDescription('outPathReliabilitySignal is reliability routing signaling. If this attribute is set to allowed, the signalled value on reliability will be used.')
mscVctDnaOutAccess = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 11, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disallowed", 0), ("allowed", 1))).clone('disallowed')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDnaOutAccess.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaOutAccess.setDescription("This attribute is an extension of the Closed User Group (CUG) facility, as follows: This attribute, if set to a value of allowed indicates that outgoing calls (from the DTE to the network) to the open (non-CUG) part of the network are permitted. It also permits outgoing calls to DTE's that have Incoming Access capabilities. If set to a value of disallowed, then such calls cannot be made using this Dna - such calls will be cleared by the local DCE. This attribute corresponds to the ITU-T 'Closed User Group with Outgoing Access' feature for Dna's in that outgoing access is granted if this attribute is set to a value of allowed.")
mscVctDnaDefaultTransferPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 11, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 9))).clone(namedValues=NamedValues(("normal", 0), ("high", 9))).clone('normal')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDnaDefaultTransferPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaDefaultTransferPriority.setDescription('This attribute specifies the default transfer priority to network for all outgoing calls using this particular Dna. It is overRidden by the transferPriority provisioned in the DLCI Direct Call sub- component. The transfer priority is a preference specified by an application according to its delay-sensitivity requirement. Frames with high transfer priority are served by the network before the frames with normal priority. Each transfer priority contains a predetermined setting for trunk queue (interrupting, delay or throughput), and routing metric (delay or throughput). When the transfer priority is set at high, the trunk queue is set to high, the routing metric is set to delay. When the transfer priority is set at normal, the trunk queue is set to normal, the routing metric is set to throughput. The default of defaultTransferPriority is normal.')
mscVctDnaTransferPriorityOverRide = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 11, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDnaTransferPriorityOverRide.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaTransferPriorityOverRide.setDescription('When this attribute is set to yes, the called end will use the calling end provisioning data on transfer priority to override its own provisioning data. If it is set no, the called end will use its own provisioning data on transfer priority. For more information about transfer priority, please refer to the previous attribute defaultTransferPriority. The default of transferPriorityOverRide is no.')
mscVctDnaIncomingOptionsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 12), )
if mibBuilder.loadTexts: mscVctDnaIncomingOptionsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaIncomingOptionsTable.setDescription('IncomingOptions defines set of options for incoming calls. These options are used for calls arriving to the interface represented by Dna. For calls originated from the interfasce, IncomingOptions attributes are not used.')
mscVctDnaIncomingOptionsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VcTesterMIB", "mscVctIndex"), (0, "Nortel-MsCarrier-MscPassport-VcTesterMIB", "mscVctDnaIndex"))
if mibBuilder.loadTexts: mscVctDnaIncomingOptionsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaIncomingOptionsEntry.setDescription('An entry in the mscVctDnaIncomingOptionsTable.')
mscVctDnaIncCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disallowed", 0), ("allowed", 1))).clone('allowed')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDnaIncCalls.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaIncCalls.setDescription("This attribute, if set to a value of allowed indicates that incoming calls (from the network to the DTE) can be made to this Dna. If set to a value of disallowed, then incoming calls cannot be made to this Dna - such calls will be cleared by the local DCE. This attribute corresponds to the ITU-T 'Incoming Calls Barred' feature for Dna's in that incoming calls are barred if this attribute is set to a value of disallowed. Either outCalls, or incCalls (or both) must be set to a value of allowed for this Dna to be useable.")
mscVctDnaIncHighPriorityReverseCharge = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disallowed", 0), ("allowed", 1))).clone('allowed')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDnaIncHighPriorityReverseCharge.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaIncHighPriorityReverseCharge.setDescription("This attribute, if set to a value of allowed indicates that incoming high priority, reverse charged calls (from the network to the DTE) can be made to this Dna. If set to a value of disallowed,then such calls cannot be made to this Dna - such calls will be cleared by the local DCE. This attribute, together with the incNormalPriorityReverseChargeCalls attribute corresponds to the ITU-T 'Reverse Charging Acceptance' feature for Dna's in that reverse charged calls are accepted if both attributes are set to a value of allowed. This attribute is ignored if the corresponding attribute, incCalls is set to a value of disallowed.")
mscVctDnaIncNormalPriorityReverseCharge = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disallowed", 0), ("allowed", 1))).clone('allowed')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDnaIncNormalPriorityReverseCharge.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaIncNormalPriorityReverseCharge.setDescription("This attribute, if set to a value of allowed indicates that incoming normal priority, reverse charged calls (from the network to the DTE) can be made to this Dna. If set to a value of disallowed, then such calls cannot be made to this Dna - such calls will be cleared by the local DCE. This attribute, together with the incHighPriorityReverseChargeCalls attribute corresponds to the ITU-T 'Reverse Charging Acceptance' feature for Dna's in that reverse charged calls are accepted if both attributes are set to a value of allowed. This attribute is ignored if the corresponding attribute, incCalls is set to a value of disallowed.")
mscVctDnaIncIntlNormalCharge = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 12, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disallowed", 0), ("allowed", 1))).clone('allowed')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDnaIncIntlNormalCharge.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaIncIntlNormalCharge.setDescription('This attribute, if set to a value of allowed indicates that incoming international normal charged calls (from the network to the DTE) can be made to this Dna. If set to a value of disallowed, then such calls cannot be made to this Dna - such calls will be cleared by the local DCE. This attribute also currently controls access to/from the E.164 numbering plan, and if set to a value of allowed, then cross- numbering plan calls (also normal charged) are allowed. This attribute is ignored if the corresponding attribute, incCalls is set to a value of disallowed.')
mscVctDnaIncIntlReverseCharge = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 12, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disallowed", 0), ("allowed", 1))).clone('allowed')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDnaIncIntlReverseCharge.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaIncIntlReverseCharge.setDescription('This attribute, if set to a value of allowed indicates that incoming international reverse charged calls (from the network to the DTE) can be made to this Dna. If set to a value of disallowed, then such calls cannot be made to this Dna - such calls will be cleared by the local DCE. This attribute also currently controls access to/from the E.164 numbering plan, and if set to a value of allowed, then cross- numbering plan calls (also normal charged) are allowed. This attribute is ignored if the corresponding attribute, incCalls is set to a value of disallowed.')
mscVctDnaIncFastSelect = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 12, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disallowed", 0), ("allowed", 1))).clone('disallowed')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDnaIncFastSelect.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaIncFastSelect.setDescription("This attribute specifies whether fast select calls may be received. This attribute, if set to a value of allowed indicates that incoming fast select calls (from the network to the DTE) can be made to this Dna. If set to a value of disallowed, then such calls cannot be made to this Dna - such calls will be cleared by the local DCE. This attribute corresponds to the ITU-T 'Fast Select Acceptance' feature for Dnas in that incoming fast select calls are accepted if this attribute is set to a value of allowed. This attribute is ignored if the corresponding attribute, incCalls is set to a value of disallowed.")
mscVctDnaIncSameService = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 12, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disallowed", 0), ("allowed", 1))).clone('allowed')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDnaIncSameService.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaIncSameService.setDescription('This attribute, if set to a value of allowed indicates that incoming calls from the same service type (eg: X.25, ITI, SNA) (from the network to the DTE) can be made to this Dna. If set to a value of disallowed, then such calls cannot be made to this Dna - such calls will be cleared by the local DCE. This attribute is ignored if the corresponding attribute, incCalls is set to a value of disallowed.')
mscVctDnaIncChargeTransfer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 12, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDnaIncChargeTransfer.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaIncChargeTransfer.setDescription('This attribute, if set to a value of yes indicates that the charges for incoming normal charged calls from a DTE with the same DNIC (calls from the network to the DTE) will be transferred to the called DTE. If set to a value of no, then charges will not be transferred. This attribute is ignored if the corresponding attribute, incCalls is set to a value of disallowed.')
mscVctDnaIncAccess = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 12, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disallowed", 0), ("allowed", 1))).clone('disallowed')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDnaIncAccess.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaIncAccess.setDescription("This attribute is an extension of the Closed User Group (CUG) facility, as follows: This attribute, if set to a value of allowed indicates that incoming calls (from the network to the DTE) from the open (non-CUG) part of the network are permitted. It also permits incoming calls from DTE's that have Outgoing Access capabilities. If set to a value of disallowed, then such calls cannot be made to this Dna - such calls will be cleared by the local DCE. This attribute corresponds to the ITU-T 'Closed User Group with Incoming Access' feature for Dnas in that incoming access is granted if this attribute is set to a value of allowed.")
mscVctDnaCallOptionsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 13), )
if mibBuilder.loadTexts: mscVctDnaCallOptionsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaCallOptionsTable.setDescription('CallOptions group defines additional options for calls not related directly to direction of a call.')
mscVctDnaCallOptionsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VcTesterMIB", "mscVctIndex"), (0, "Nortel-MsCarrier-MscPassport-VcTesterMIB", "mscVctDnaIndex"))
if mibBuilder.loadTexts: mscVctDnaCallOptionsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaCallOptionsEntry.setDescription('An entry in the mscVctDnaCallOptionsTable.')
mscVctDnaServiceCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 14, 15, 16, 20, 21, 22, 23, 24, 25, 26, 28, 29, 30, 31, 32))).clone(namedValues=NamedValues(("gsp", 0), ("x25", 1), ("enhancedIti", 2), ("ncs", 3), ("mlti", 4), ("sm", 5), ("ici", 6), ("dsp3270", 7), ("iam", 8), ("mlhi", 9), ("term3270", 10), ("iti", 11), ("bsi", 13), ("hostIti", 14), ("x75", 15), ("hdsp3270", 16), ("api3201", 20), ("sdlc", 21), ("snaMultiHost", 22), ("redirectionServ", 23), ("trSnaTpad", 24), ("offnetNui", 25), ("gasServer", 26), ("vapServer", 28), ("vapAgent", 29), ("frameRelay", 30), ("ipiVc", 31), ("gvcIf", 32))).clone('frameRelay')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDnaServiceCategory.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaServiceCategory.setDescription('This attribute is assigned for each different type of service within which this Dna is configured. It is placed into the Service Category attribute in the accounting record by both ends of the Vc.')
mscVctDnaPacketSizes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 13, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2).clone(hexValue="1c00")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDnaPacketSizes.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaPacketSizes.setDescription('This attribute indicates the allowable packet sizes supported for call setup using this Dna. ITU-T recommends that packet size 128 always be supported. Attributes defaultRecvFrmNetworkPacketSize and defaultSendToNetworkPacketSize are related to this attribute. Description of bits: n16(0) n32(1) n64(2) n128(3) n256(4) n512(5) n1024(6) n2048(7) n4096(8)')
mscVctDnaDefaultRecvFrmNetworkPacketSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 13, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("n16", 4), ("n32", 5), ("n64", 6), ("n128", 7), ("n256", 8), ("n512", 9), ("n1024", 10), ("n2048", 11), ("n4096", 12))).clone('n128')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDnaDefaultRecvFrmNetworkPacketSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaDefaultRecvFrmNetworkPacketSize.setDescription('This attribute indicates the default local receive packet size from network to DTE for all calls using this particular Dna. Attribute packetSizes has to be set with corresponding value.')
mscVctDnaDefaultSendToNetworkPacketSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 13, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("n16", 4), ("n32", 5), ("n64", 6), ("n128", 7), ("n256", 8), ("n512", 9), ("n1024", 10), ("n2048", 11), ("n4096", 12))).clone('n128')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDnaDefaultSendToNetworkPacketSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaDefaultSendToNetworkPacketSize.setDescription('This attribute indicates the default local send packet size from DTE to network for all calls using this particular Dna. Attribute packetSizes has to be set with corresponding value.')
mscVctDnaDefaultRecvFrmNetworkThruputClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 13, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(3, 15)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDnaDefaultRecvFrmNetworkThruputClass.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaDefaultRecvFrmNetworkThruputClass.setDescription('This attribute indicates the default receive throughput class for all calls using this particular Dna.')
mscVctDnaDefaultSendToNetworkThruputClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 13, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDnaDefaultSendToNetworkThruputClass.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaDefaultSendToNetworkThruputClass.setDescription('This attribute indicates the default send throughput class for all calls using this particular Dna.')
mscVctDnaDefaultRecvFrmNetworkWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 13, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 7)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDnaDefaultRecvFrmNetworkWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaDefaultRecvFrmNetworkWindowSize.setDescription('This attribute indicates the default number of data packets that can be received by the DTE from the DCE before more packets can be received. This view is oriented with respect to the DTE.')
mscVctDnaDefaultSendToNetworkWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 13, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 7)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDnaDefaultSendToNetworkWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaDefaultSendToNetworkWindowSize.setDescription('This attribute indicates the number of data packets that can be transmitted from the DTE to the DCE and must be acknowledged before more packets can be transmitted.')
mscVctDnaPacketSizeNegotiation = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 13, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("endToEnd", 0), ("local", 1))).clone('endToEnd')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDnaPacketSizeNegotiation.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaPacketSizeNegotiation.setDescription('This attribute, if set to local indicates that packet sizes can be negotiated locally at the interface irrespective of the remote interface. If set to endtoEnd, then local negotiation is not permitted and packet sizes are negotiated between 2 ends of Vc.')
mscVctDnaCugFormat = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 13, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("basic", 0), ("extended", 1))).clone('basic')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDnaCugFormat.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaCugFormat.setDescription('This attribute specifies which cug format is used when DTE signals CUG indices, basic or extended. This attribute, if set to extended indicates that the DTE signals and receives CUG indices in extended CUG format. If set to a value of basic, then the DTE signals and receives CUG indices in the basic CUG format.')
mscVctDnaCug0AsNonCugCall = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 13, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disallowed", 0), ("allowed", 1))).clone('disallowed')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDnaCug0AsNonCugCall.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaCug0AsNonCugCall.setDescription('This attribute, if set to allowed indicates that when a CUG index of 0 is signalled in a call request packet, the call is treated as a non- CUG call. If this attribute is set to disallowed, then a CUG index of 0 is treated as an index, and an attempt is made to find the particular CUG corresponding with the Dna.')
mscVctDnaSignalPreferentialCugToLink = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 13, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDnaSignalPreferentialCugToLink.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaSignalPreferentialCugToLink.setDescription("This attribute, if set to no, indicates that, at the destination (called) DTE, when a CUG call is received using the called DTE's preferential CUG, the preferential CUG's index is not signalled to the called DTE in the incoming call request packet. Otherwise, the preferential CUG's index is signalled to the link in the incoming call request packet.")
mscVctDnaSignalIntlAddressToLink = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 13, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDnaSignalIntlAddressToLink.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaSignalIntlAddressToLink.setDescription('This attribute, if set to yes, indicates that all addresses presented by the network (DCE) to the link (DTE) within incoming call request., call connected and clear packets are presented in international format with no prefix digit. International format includes DNIC in the address.')
mscVctDnaFastSelectCallsOnly = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 13, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDnaFastSelectCallsOnly.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaFastSelectCallsOnly.setDescription('This attribute, if set to yes, indicates that the service is permitted restricted fast select calls in both the incoming and the outgoing directions using this Dna. If set to no, then non fast select calls are permitted as well.')
mscVctDnaPreselectRpoa = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 13, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDnaPreselectRpoa.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaPreselectRpoa.setDescription('This attribute, if set to yes, indicates that this Dna subscribes to a pre-selected RPOA, in which case, the pre-selected RPOA is contained in the rpoa attribute described below. If set to no, then a pre-selected RPOA is not subscribed.')
mscVctDnaAccountClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 13, 1, 16), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDnaAccountClass.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaAccountClass.setDescription('This attribute specifies the accounting class which is reserved for network operations usage. Its value is returned in the accounting record in the local and remote service type attributes. Use of this attribute is decided by network operator and it is an arbitrary number.')
mscVctDnaAccountCollection = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 13, 1, 17), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1).clone(hexValue="80")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDnaAccountCollection.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaAccountCollection.setDescription('This attribute indicates that accounting records are to be collected by the network for the various reasons: billing, test, study, auditing. The last of the parameters, force, indicates that accounting records are to be collected irrespective of other collection reasons. If none of these reasons are set, then accounting will be suppressed. Description of bits: bill(0) test(1) study(2) audit(3) force(4)')
mscVctDnaServiceExchange = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 13, 1, 18), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDnaServiceExchange.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaServiceExchange.setDescription('This attribute is an arbitrary number, entered by the network operator. The value of serviceExchange is included in the accounting record generated by Vc.')
mscVctDnaEgressAccounting = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 13, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDnaEgressAccounting.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaEgressAccounting.setDescription('egressAccounting specifies if Egress accounting is enabled by Frame Relay service. Disabling of Egress accounting means that only segment counts are collected by VC and there are no frame relay counts in accounting records for Frame Relay service. Enabling of Egress accounting means that the accounting records for Frame Relay contain frame relay specific counts.')
mscVctDnaRpoa = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 13, 1, 20), DigitString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4).clone(hexValue="30303030")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDnaRpoa.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaRpoa.setDescription('rpoa - Recognized Private Operating Agency is a ITU-T specified facility which allows the user to specify--at call setup time--the next transit network the call should use. The rpoa can override all routing decisions. If Dna subscribes to preselectRpoa as indicated by the previously described attribute, (preselectRpoa set to yes) then this attribute contains preselected rpoa. If the preselectRpoa attribute is set to no, then this attribute can be left at its default. This preselected rpoa will be used for all outgoing call request packets using this Dna if an rpoa is not explicitly specified in the call request. The rpoa represents the dnic of the directly connected network through which the call will be routed in the presence of the rpoa.')
mscVctDnaDataPath = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 13, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("dprsOnly", 0), ("dprsMcsOnly", 1), ("dprsMcsFirst", 2))).clone('dprsOnly')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDnaDataPath.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaDataPath.setDescription('This attribute specifies the data path to be used by Virtual Circuits on this interface. If the connection has a DirectCall component then the value can be overridden by the dataPath attribute of the DirectCall component. This value applies to the connection after data transfer state is reached. All the data and control trafic will be sent using this data path. If the provisioned dataPath is not available the connection is not established. The value of the dataPath is signalled by both ends of the connection. If this value is not the same at both ends dprsOnly is used for the duration of the connection. A virtual circuit connection is always established using dprsOnly even if this attribute is provisioned as some other value. dprsOnly - dynamic packet routing system is used dprsMcsOnly - dprs Multi-Service Cut-Through Switching path is used. dprsMcsFirst - dprs Multi-Service Cut-Through Switching path is used if it is available. If it is not avaliable dprsOnly is used.')
mscVctDnaCug = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 2))
mscVctDnaCugRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 2, 1), )
if mibBuilder.loadTexts: mscVctDnaCugRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaCugRowStatusTable.setDescription('This entry controls the addition and deletion of mscVctDnaCug components.')
mscVctDnaCugRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VcTesterMIB", "mscVctIndex"), (0, "Nortel-MsCarrier-MscPassport-VcTesterMIB", "mscVctDnaIndex"), (0, "Nortel-MsCarrier-MscPassport-VcTesterMIB", "mscVctDnaCugIndex"))
if mibBuilder.loadTexts: mscVctDnaCugRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaCugRowStatusEntry.setDescription('A single entry in the table represents a single mscVctDnaCug component.')
mscVctDnaCugRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDnaCugRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaCugRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVctDnaCug components. These components can be added and deleted.')
mscVctDnaCugComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctDnaCugComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaCugComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVctDnaCugStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctDnaCugStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaCugStorageType.setDescription('This variable represents the storage type value for the mscVctDnaCug tables.')
mscVctDnaCugIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)))
if mibBuilder.loadTexts: mscVctDnaCugIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaCugIndex.setDescription('This variable represents the index for the mscVctDnaCug tables.')
mscVctDnaCugCugOptionsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 2, 10), )
if mibBuilder.loadTexts: mscVctDnaCugCugOptionsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaCugCugOptionsTable.setDescription("This group defines options for. Attributes in this group defines ClosedUserGroup options associated with interlockCode. Dna's with the same Cug (interlockCode) can make calls within this group. Various combinations which permit or prevent calls in the same Cug group are defined here.")
mscVctDnaCugCugOptionsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VcTesterMIB", "mscVctIndex"), (0, "Nortel-MsCarrier-MscPassport-VcTesterMIB", "mscVctDnaIndex"), (0, "Nortel-MsCarrier-MscPassport-VcTesterMIB", "mscVctDnaCugIndex"))
if mibBuilder.loadTexts: mscVctDnaCugCugOptionsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaCugCugOptionsEntry.setDescription('An entry in the mscVctDnaCugCugOptionsTable.')
mscVctDnaCugType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("national", 0), ("international", 1))).clone('national')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDnaCugType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaCugType.setDescription("This attribute specifies the Cug type - the Cug is either a national Cug, or an international Cug. International closed user groups are usually established between DTE's for which there is an X.75 Gateway between; whereas national closed user groups are usually established between DTE's for which there is no X.75 Gateway between. (National Cugs cannot normally traverse an X.75 Gateway). If this attribute is set to national, then the Cug is a national Cug, in which case, the dnic should be left at its default value since it is not part of a national Cug. If this attribute is set to international, then the Cug is an international Cug, in which case, the dnic should be set appropriately as part of the Cug interlockCode.")
mscVctDnaCugDnic = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 2, 10, 1, 2), DigitString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4).clone(hexValue="30303030")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDnaCugDnic.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaCugDnic.setDescription('This attribute specifies the dnic (Data Network ID Code) of the Cug by which packet networks are identified. This attribute is not applicable if the Cug is a national Cug, as specified by the Cug type attribute. There are usually 1 or 2 dnics assigned per country, for public networks. The U.S. is an exception where each BOC has a dnic. Also, a group of private networks can have its own dnic. dnic value is not an arbitrary number. It is assigned by international agreement and controlled by ITU-T.')
mscVctDnaCugInterlockCode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 2, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDnaCugInterlockCode.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaCugInterlockCode.setDescription("This attribute specifies the Cug identifier of a national or international Cug call. It is an arbitrary number and it also can be called Cug in some descriptions. Interfaces (Dna's) defined with this number can make calls to Dna's with the same interlockCode.")
mscVctDnaCugPreferential = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 2, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDnaCugPreferential.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaCugPreferential.setDescription('This attribute, if set to yes indicates that this Cug is the preferential Cug, in which case it will be used during the call establishment phase if the DTE has not explicitly specified a Cug index in the call request packet. If set to no, then this Cug is not the preferential Cug. Only one of the Cugs associated with a particular Dna can be the preferential Cug - only one Cug can have this attribute set to yes.')
mscVctDnaCugOutCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 2, 10, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disallowed", 0), ("allowed", 1))).clone('allowed')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDnaCugOutCalls.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaCugOutCalls.setDescription("This attribute, if set to allowed indicates that outgoing calls (from the DTE into the network) can be made using this particular Cug. If set to a value of disallowed, then outgoing calls cannot be made using this Cug - such calls will be cleared by the local DCE. This attribute corresponds to the ITU-T 'Outgoing Calls Barred' feature for cugs in that outgoing calls are barred if this attribute is set to a value of disallowed.")
mscVctDnaCugIncCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 2, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disallowed", 0), ("allowed", 1))).clone('allowed')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDnaCugIncCalls.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaCugIncCalls.setDescription("This attribute, if set to allowed indicates that incoming calls (from the network to the DTE) can be made using this particular Cug. If set to disallowed, then incoming calls cannot be made using this Cug - such calls will be cleared by the local DCE. This attribute corresponds to the ITU-T 'Incoming Calls Barred' feature for Cugs in that incoming calls are barred if this attribute is set to a value of disallowed.")
mscVctDnaCugPrivileged = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 2, 10, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('yes')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDnaCugPrivileged.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaCugPrivileged.setDescription("This attribute, if set to yes indicates that this Cug is a privileged Cug. In DPN, at least one side of a call setup within a Cug must have the Cug as a privileged Cug. If set to no, then the Cug is not privileged. If both the local DTE and the remote DTE subscribe to the Cug, but it is not privileged, then the call will be cleared. This attribute is typically used for a host DTE which must accept calls from many other DTE's in which case the other DTE's cannot call one another, but can call the host. In this example, the host would have the privileged Cug, and the other DTE's would belong to the same Cug, but it would not be privileged.")
mscVctDnaHgM = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 3))
mscVctDnaHgMRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 3, 1), )
if mibBuilder.loadTexts: mscVctDnaHgMRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaHgMRowStatusTable.setDescription('This entry controls the addition and deletion of mscVctDnaHgM components.')
mscVctDnaHgMRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 3, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VcTesterMIB", "mscVctIndex"), (0, "Nortel-MsCarrier-MscPassport-VcTesterMIB", "mscVctDnaIndex"), (0, "Nortel-MsCarrier-MscPassport-VcTesterMIB", "mscVctDnaHgMIndex"))
if mibBuilder.loadTexts: mscVctDnaHgMRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaHgMRowStatusEntry.setDescription('A single entry in the table represents a single mscVctDnaHgM component.')
mscVctDnaHgMRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 3, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDnaHgMRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaHgMRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVctDnaHgM components. These components can be added and deleted.')
mscVctDnaHgMComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctDnaHgMComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaHgMComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVctDnaHgMStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctDnaHgMStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaHgMStorageType.setDescription('This variable represents the storage type value for the mscVctDnaHgM tables.')
mscVctDnaHgMIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscVctDnaHgMIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaHgMIndex.setDescription('This variable represents the index for the mscVctDnaHgM tables.')
mscVctDnaHgMIfTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 3, 10), )
if mibBuilder.loadTexts: mscVctDnaHgMIfTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaHgMIfTable.setDescription('This group contains the interface parameters between the HuntGroupMember and the Hunt Group server.')
mscVctDnaHgMIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 3, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VcTesterMIB", "mscVctIndex"), (0, "Nortel-MsCarrier-MscPassport-VcTesterMIB", "mscVctDnaIndex"), (0, "Nortel-MsCarrier-MscPassport-VcTesterMIB", "mscVctDnaHgMIndex"))
if mibBuilder.loadTexts: mscVctDnaHgMIfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaHgMIfEntry.setDescription('An entry in the mscVctDnaHgMIfTable.')
mscVctDnaHgMAvailabilityUpdateThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 3, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDnaHgMAvailabilityUpdateThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaHgMAvailabilityUpdateThreshold.setDescription('This attribute indicates the number of channels that have to be freed or occupied before the Availability Message Packet (AMP) is sent to the Hunt Group Server informing it of the status of this interface.')
mscVctDnaHgMOpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 3, 11), )
if mibBuilder.loadTexts: mscVctDnaHgMOpTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaHgMOpTable.setDescription('This group contains the operational attributes of the HuntGroupMember component.')
mscVctDnaHgMOpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 3, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VcTesterMIB", "mscVctIndex"), (0, "Nortel-MsCarrier-MscPassport-VcTesterMIB", "mscVctDnaIndex"), (0, "Nortel-MsCarrier-MscPassport-VcTesterMIB", "mscVctDnaHgMIndex"))
if mibBuilder.loadTexts: mscVctDnaHgMOpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaHgMOpEntry.setDescription('An entry in the mscVctDnaHgMOpTable.')
mscVctDnaHgMMaxAvailableChannels = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 3, 11, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctDnaHgMMaxAvailableChannels.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaHgMMaxAvailableChannels.setDescription('This attribute indicates the maximum number of available channels for this HuntGroupMember.')
mscVctDnaHgMAvailableChannels = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 3, 11, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctDnaHgMAvailableChannels.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaHgMAvailableChannels.setDescription('This attribute indicates the number of available channels reported to the hunt group in the Availability Message Packet (AMP). It is modified by adding 1 by the application when a channel is freed and subtracting 1 when a channel is occupied.')
mscVctDnaHgMAvailabilityDelta = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 3, 11, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-4096, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctDnaHgMAvailabilityDelta.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaHgMAvailabilityDelta.setDescription('This attribute indicates the net change in the available channels since the last Availability Message Packet (AMP) was sent to the Hunt Group. Once the absolute value of this attribute reaches the availabilityUpdateThreshold an AMP is sent to the host and the availabilityDelta is reset to 0. If this attribute is positive it means an increase of the number of available channels. If it is negative it means a decrease in the number of available channels.')
mscVctDnaHgMHgAddr = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 3, 2))
mscVctDnaHgMHgAddrRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 3, 2, 1), )
if mibBuilder.loadTexts: mscVctDnaHgMHgAddrRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaHgMHgAddrRowStatusTable.setDescription('This entry controls the addition and deletion of mscVctDnaHgMHgAddr components.')
mscVctDnaHgMHgAddrRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 3, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VcTesterMIB", "mscVctIndex"), (0, "Nortel-MsCarrier-MscPassport-VcTesterMIB", "mscVctDnaIndex"), (0, "Nortel-MsCarrier-MscPassport-VcTesterMIB", "mscVctDnaHgMIndex"), (0, "Nortel-MsCarrier-MscPassport-VcTesterMIB", "mscVctDnaHgMHgAddrIndex"))
if mibBuilder.loadTexts: mscVctDnaHgMHgAddrRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaHgMHgAddrRowStatusEntry.setDescription('A single entry in the table represents a single mscVctDnaHgMHgAddr component.')
mscVctDnaHgMHgAddrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 3, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDnaHgMHgAddrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaHgMHgAddrRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVctDnaHgMHgAddr components. These components can be added and deleted.')
mscVctDnaHgMHgAddrComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 3, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctDnaHgMHgAddrComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaHgMHgAddrComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVctDnaHgMHgAddrStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 3, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctDnaHgMHgAddrStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaHgMHgAddrStorageType.setDescription('This variable represents the storage type value for the mscVctDnaHgMHgAddr tables.')
mscVctDnaHgMHgAddrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 3, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1)))
if mibBuilder.loadTexts: mscVctDnaHgMHgAddrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaHgMHgAddrIndex.setDescription('This variable represents the index for the mscVctDnaHgMHgAddr tables.')
mscVctDnaHgMHgAddrAddrTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 3, 2, 10), )
if mibBuilder.loadTexts: mscVctDnaHgMHgAddrAddrTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaHgMHgAddrAddrTable.setDescription('This group contains attributes common to all DNAs. Every DNA used in the network is defined with this group of 2 attributes. String of address digits complemented by the NPI.')
mscVctDnaHgMHgAddrAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 3, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VcTesterMIB", "mscVctIndex"), (0, "Nortel-MsCarrier-MscPassport-VcTesterMIB", "mscVctDnaIndex"), (0, "Nortel-MsCarrier-MscPassport-VcTesterMIB", "mscVctDnaHgMIndex"), (0, "Nortel-MsCarrier-MscPassport-VcTesterMIB", "mscVctDnaHgMHgAddrIndex"))
if mibBuilder.loadTexts: mscVctDnaHgMHgAddrAddrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaHgMHgAddrAddrEntry.setDescription('An entry in the mscVctDnaHgMHgAddrAddrTable.')
mscVctDnaHgMHgAddrNumberingPlanIndicator = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 3, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("x121", 0), ("e164", 1))).clone('x121')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDnaHgMHgAddrNumberingPlanIndicator.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaHgMHgAddrNumberingPlanIndicator.setDescription('This attribute indicates the Numbering Plan Indicator (NPI) the Dna that is entered. Address may belong to X.121 or E.164 plans.')
mscVctDnaHgMHgAddrDataNetworkAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 2, 3, 2, 10, 1, 2), DigitString().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDnaHgMHgAddrDataNetworkAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDnaHgMHgAddrDataNetworkAddress.setDescription('This attribute contains digits which form unique identifier of the customer interface. It can be compared (approximation only) telephone number where phone number identifies unique telephone set. Dna digits are selected and assigned by network operators.')
mscVctDc = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 3))
mscVctDcRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 3, 1), )
if mibBuilder.loadTexts: mscVctDcRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDcRowStatusTable.setDescription('This entry controls the addition and deletion of mscVctDc components.')
mscVctDcRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 3, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VcTesterMIB", "mscVctIndex"), (0, "Nortel-MsCarrier-MscPassport-VcTesterMIB", "mscVctDcIndex"))
if mibBuilder.loadTexts: mscVctDcRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDcRowStatusEntry.setDescription('A single entry in the table represents a single mscVctDc component.')
mscVctDcRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 3, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDcRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDcRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVctDc components. These components can be added and deleted.')
mscVctDcComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctDcComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDcComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVctDcStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctDcStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDcStorageType.setDescription('This variable represents the storage type value for the mscVctDc tables.')
mscVctDcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10)))
if mibBuilder.loadTexts: mscVctDcIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDcIndex.setDescription('This variable represents the index for the mscVctDc tables.')
mscVctDcOptionsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 3, 10), )
if mibBuilder.loadTexts: mscVctDcOptionsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDcOptionsTable.setDescription('Options group defines attributes associated with direct call. It defines complete connection in terms of path and call options. This connection can be permanent (pvc) or switched (svc). It can have facilities. The total number of bytes of facilities including the facility codes, and all of the facility data from all of the four classes of facilities: ITU-T_Facilities DTE_Facilities National_Facilities International_Facilities must not exceed maximum subnet packet size defined for the whole network in ModuleData Vcs component.')
mscVctDcOptionsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 3, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VcTesterMIB", "mscVctIndex"), (0, "Nortel-MsCarrier-MscPassport-VcTesterMIB", "mscVctDcIndex"))
if mibBuilder.loadTexts: mscVctDcOptionsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDcOptionsEntry.setDescription('An entry in the mscVctDcOptionsTable.')
mscVctDcLocalNpi = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 3, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("x121", 0), ("e164", 1))).clone('x121')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDcLocalNpi.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDcLocalNpi.setDescription('This attribute specifies the Numbering Plan Indicator (NPI) of the localDna.')
mscVctDcLocalDna = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 3, 10, 1, 2), DigitString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDcLocalDna.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDcLocalDna.setDescription('This attribute specifies the Data Network Address (Dna) of the local DTE. This address is used in formatting of call request to remoteDna.')
mscVctDcRemoteNpi = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 3, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("x121", 0), ("e164", 1))).clone('x121')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDcRemoteNpi.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDcRemoteNpi.setDescription('Remote numbering Plan Indicator (Npi) indicates the numbering plan used in the remoteDna.')
mscVctDcRemoteDna = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 3, 10, 1, 4), DigitString().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDcRemoteDna.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDcRemoteDna.setDescription('This attribute specifies the Data Network Address (Dna) of the remote. This is the called (destination) DTE address (Dna) to which this direct call will be sent. Initially, the called DTE address attribute must be present, that is, there must be a valid destination address. However, it may be possible in the future to configure the direct call with a mnemonic address, in which case, this attribute will contain a zero-length Dna, and the mnemonic address will be carried as one of the facilities.')
mscVctDcRemoteLcn = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 3, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDcRemoteLcn.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDcRemoteLcn.setDescription('This attribute provides the remote LCN (Logical Channel Number) - it is used only for PVCs, where attribute type is set to permanentMaster or permanentSlave or permanentBackupSlave. In switched case, value of remoteLcn is not known when call request is made.')
mscVctDcType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 3, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("switched", 0), ("permanentMaster", 1), ("permanentSlave", 2), ("permanentBackupSlave", 3), ("permanentSlaveWithBackup", 4), ("spvcMaster", 5), ("spvcSlave", 6), ("spvcBackupSlave", 7), ("spvcSlaveWithBackup", 8))).clone('switched')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDcType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDcType.setDescription('This attribute specifies the type of Vc call: switched, permanentMaster, permanentSlave, permanentSlaveWithBackup, permanentBackupSlave, spvcMaster, spvcSlave, spvcSlaveWithBackup, spvcBackupSlave. If the value of this attribute is set to switched then the remote end must also be provisioned as switched. No information at the remote end is defined about this switched interface. If the value is set to permanentMaster, then a permanent connection will be established between 2 ends. The remote end must be defined as a permanentSlave, permanentBackupSlave or permanentSlaveWithBackup. The connection cannot be established if the remote end is defined as anything else. The end defined as permanentMaster always initiates the calls. It will attempt to call once per minute. If the value is set to permanentSlave then a permanent connection will be established between 2 ends. The remote end must be defined as a permanentMaster. The connection cannot be established if the remote end is defined as anything else. The permanentSlave end will attempt to call once per minute. If the value is set to permanentSlaveWithBackup then a permanent connection will be established between the two ends. The remote end must be defined as a permanentMaster. The connection cannot be established if the remote interface end is defined as anything else. The permanentSlaveWithBackup end will attempt to call once per minute. When type is set to permanentSlaveWithBackup connection will be cleared if interface becomes unavailable. This enables a retry of the connection which can be redirected to permanentBackupSlave. If the value is set to permanentBackupSlave then a permanent connection will be established between the 2 ends only if the permanentMaster end is disconnected from the permanentSlaveWithBackup end and a backup call is established by the redirection system. If the permanentSlaveWithBackup interface becomes visible again, the permanentBackupSlave end is disconnected and the permanentSlaveWithBackup end is reconnected to the permanentMaster end. The permanentBackupSlave end does not try to establish pvc call. If the value is set to spvcMaster, then a permanent connection will be established between two ends, with resiliency at the NNI(s), if the connection transits across two or more networks. The remote end, which may be in the same network, or an external network that is reachable via Frame Relay NNIs, must be defined as either a spvcSlave, spvcBackupSlave or spvcSlaveWithBackup. The connection cannot be established if the remote end is defined as anything else. The end defined as spvcMaster always initiates the calls. It will attempt to call once per minute. The call is attempted by the spvcMaster, and accepted by the remote end, only if all three of the following conditions are satisfied at both ends: 1. The datalink layer must be operational 2. The LMI procedures must be in normal condition (i.e. no service affecting condition) 3. If the LMI side attribute is provisioned to both, the A-bit received from the interface must be Active. If the LMI side attribute is not provisioned to both, this condition does not apply. After a call is cleared, the end defined as spvcMaster attempts to retry the call according to the rule for the clear cause. If the call is cleared or rejected due to the failure of one of the three conditions indicated above, or due to unavailability of resources along any point in the connection path, the call will be retried after 60 seconds. For all other causes, such as loss of service at an NNI, the call will be retried immediately. If the value is set to spvcSlave then a SPVC connection will be established between two ends. The remote end must be defined as a spvcMaster. The connection cannot be established if the remote end is defined as anything else. The spvcSlave end never attempts to call. If the value is set to spvcSlaveWithBackup then a SPVC connection will be established between the two ends. The remote end must be defined as a spvcMaster. The connection cannot be established if the remote interface end is defined as anything else. Unlike a permanentSlaveWithBackup end, the spvcSlaveWithBackup end never attempts to call. If the value is set to spvcSlaveWithBackup, the connection will be cleared if the interface becomes unavailable. This enables a retry of the connection by the spvcMaster end, which may be redirected to an end that is set to spvcBackupSlave. If the value is set to spvcBackupSlave then a SPVC connection will be established between the two ends only if the spvcMaster end is disconnected from the spvcSlaveWithBackup, end and a backup call is redirected by the call redirection system. Unlike the permanent connection, if the spvcSlaveWithBackup interface becomes available again, the spvcBackupSlave end is not disconnected and the spvcSlaveWithBackup end is not reconnected to the spvcMaster end. Neither the spvcBackupSlave nor the spvcSlaveWithBackup end try to establish a SPVC call.')
mscVctDcSvcAutoCallRetry = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 3, 10, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDcSvcAutoCallRetry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDcSvcAutoCallRetry.setDescription('svcAutoCallRetry is used only for switched calls, in which case the attribute type is set to switched. Otherwise, this attribute is ignored by the Vcs. This attribute, if set to yes for Svc, indicates that the Vc will continually try to establish the SVC rather than clearing the Vc after the first unsuccessful call attempt. Further, if the call fails while in data transfer phase, then the Vc will automatically attempt to reconnect. The call attempts are made by the Vc once per time provisioned in InterfaceOptions as callRetryTimer, repeatedly. If set to no for SVCs, then the Vc behaves in the standard mode, making a single call attempt.')
mscVctDcUserData = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 3, 10, 1, 8), HexString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDcUserData.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDcUserData.setDescription("This attribute contains the user data, if present. userData is a 0 to 16 length string which is appended to the call request packet that is presented to the called (destination) DTE. User data can be a 0 to 128 byte string for fast select calls; otherwise it is 0 to 16 byte string. Fast select calls are indicated as such using the X.25 ITU-T facility for 'Reverse Charging'. The length of the user data attribute is not verified during service provisioning. If more than 16 bytes of user data is specified on a call without the fast select option, then the call is cleared with a clear cause of 'local procedure error', and a diagnostic code of 39 (as defined in the ITU-T X.25 Recommendation).")
mscVctDcDiscardPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 3, 10, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 3))).clone(namedValues=NamedValues(("normal", 0), ("high", 1), ("useDnaDefPriority", 3))).clone('useDnaDefPriority')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDcDiscardPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDcDiscardPriority.setDescription('This attribute specifies the discard priority for outgoing call using this DLCI. The discard priority has three provisioning values: normal, high, and useDnaDefPriority. Traffic with normal priority are discarded first than the traffic with high priority. The Dna default value (provisioned by outDefaultPriority) is taken if this attribute is set to the value useDnaDefPriority. The default of discardPriority is useDnaDefPriority.')
mscVctDcDataPath = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 3, 10, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("dprsOnly", 0), ("dprsMcsOnly", 1), ("dprsMcsFirst", 2), ("useDnaValue", 3))).clone('dprsOnly')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDcDataPath.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDcDataPath.setDescription('This attribute specifies the data path to be used by Virtual Circuits on this interface. The value of the dataPath attribute in the Dna component is overridden by this attribute if the value is not useDnaValue. This value applies to the connection after data transfer state is reached. All the data and control trafic will be sent using this data path. If the provisioned dataPath is not available the connection is not established. The value of the dataPath is signalled by both ends of the connection. If this value is not the same at both ends dprsOnly is used for the duration of the connection. A virtual circuit connection is always established using dprsOnly even if this attribute is provisioned as some other value. dprsOnly - dynamic packet routing system is used dprsMcsOnly - dprs Multi-Service Cut-Through Switching path is used. dprsMcsFirst - dprs Multi-Service Cut-Through Switching path is used if it is available. If it is not avaliable dprsOnly is used. useDnaValue - use the value provisioned in Dna component.')
mscVctDcCugIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 3, 10, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDcCugIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDcCugIndex.setDescription('This attribute specifies the CUG index which is to be signalled in PVC call requests to the remote end. The type of CUG signalling is defined in attribute cugType in this component.')
mscVctDcCugType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 3, 10, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 3, 9))).clone(namedValues=NamedValues(("doNotSignal", 0), ("cug", 3), ("cugOa", 9))).clone('doNotSignal')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDcCugType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDcCugType.setDescription('This attribute specifies the type of CUG signalling to be used in PVC call request. Index of CUG to be used is defined in attribute cugIndex in this component. Possible values are: cug - signal cug cugOa - signal cug with outgoing access doNotSignal - no CUG in call request')
mscVctDcCfaTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 3, 267), )
if mibBuilder.loadTexts: mscVctDcCfaTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDcCfaTable.setDescription("This is the i'th ITU-T facility required for this direct call. Within the provisioning system, the user specifies the facility code along with the facility parameters. The facility is represented internally as a hexadecimal string following the X.25 ITU-T representation for facility data. The user specifies the facility code when adding, changing or deleting a facility. The upper two bits of the facility code indicate the class of facility. From the class of the facility, one can derive the number of bytes of facility data, as follows: Class A - 1 byte of fax data Class B - 2 bytes of fax data Class C - 3 bytes of fax data Class D - variable length of fax data.")
mscVctDcCfaEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 3, 267, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VcTesterMIB", "mscVctIndex"), (0, "Nortel-MsCarrier-MscPassport-VcTesterMIB", "mscVctDcIndex"), (0, "Nortel-MsCarrier-MscPassport-VcTesterMIB", "mscVctDcCfaIndex"))
if mibBuilder.loadTexts: mscVctDcCfaEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDcCfaEntry.setDescription('An entry in the mscVctDcCfaTable.')
mscVctDcCfaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 3, 267, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(1, 1), ValueRangeConstraint(2, 2), ValueRangeConstraint(3, 3), ValueRangeConstraint(4, 4), ValueRangeConstraint(9, 9), ValueRangeConstraint(66, 66), ValueRangeConstraint(67, 67), ValueRangeConstraint(68, 68), ValueRangeConstraint(71, 71), ValueRangeConstraint(72, 72), ValueRangeConstraint(73, 73), ValueRangeConstraint(196, 196), ValueRangeConstraint(198, 198), )))
if mibBuilder.loadTexts: mscVctDcCfaIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDcCfaIndex.setDescription('This variable represents the index for the mscVctDcCfaTable.')
mscVctDcCfaValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 3, 267, 1, 2), HexString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDcCfaValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDcCfaValue.setDescription('This variable represents an individual value for the mscVctDcCfaTable.')
mscVctDcCfaRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 3, 267, 1, 3), RowStatus()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mscVctDcCfaRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDcCfaRowStatus.setDescription('This variable is used to control the addition and deletion of individual values of the mscVctDcCfaTable.')
mscVctDcDfaTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 3, 268), )
if mibBuilder.loadTexts: mscVctDcDfaTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDcDfaTable.setDescription("This is the i'th DTE facility required for this direct call. Within the provisioning system, the user specifies the facility code along with the facility parameters. The facility is represented internally as a hexadecimal string following the X.25 ITU-T representation for facility data.")
mscVctDcDfaEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 3, 268, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VcTesterMIB", "mscVctIndex"), (0, "Nortel-MsCarrier-MscPassport-VcTesterMIB", "mscVctDcIndex"), (0, "Nortel-MsCarrier-MscPassport-VcTesterMIB", "mscVctDcDfaIndex"))
if mibBuilder.loadTexts: mscVctDcDfaEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDcDfaEntry.setDescription('An entry in the mscVctDcDfaTable.')
mscVctDcDfaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 3, 268, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(10, 10), ValueRangeConstraint(11, 11), ValueRangeConstraint(201, 201), ValueRangeConstraint(202, 202), ValueRangeConstraint(203, 203), ValueRangeConstraint(210, 210), ValueRangeConstraint(211, 211), )))
if mibBuilder.loadTexts: mscVctDcDfaIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDcDfaIndex.setDescription('This variable represents the index for the mscVctDcDfaTable.')
mscVctDcDfaValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 3, 268, 1, 2), HexString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDcDfaValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDcDfaValue.setDescription('This variable represents an individual value for the mscVctDcDfaTable.')
mscVctDcDfaRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 3, 268, 1, 3), RowStatus()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mscVctDcDfaRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDcDfaRowStatus.setDescription('This variable is used to control the addition and deletion of individual values of the mscVctDcDfaTable.')
mscVctDcNfaTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 3, 269), )
if mibBuilder.loadTexts: mscVctDcNfaTable.setStatus('obsolete')
if mibBuilder.loadTexts: mscVctDcNfaTable.setDescription("This is the i'th National facility required for this direct call. Within the provisioning system, the user specifies the facility code along with the facility parameters. The facility is represented internally as a hexadecimal string following the X.25 ITU-T representation for facility data. Two explicit attributes discardPriority and transferPriority are created to replace H.01 and H.30 in the group VcsDirectCallOptionsProv of this file. The migrate escape here propagates the old provisioning data under H.01 and H.30 into discardPriority and transferPriority. The rule of the above propagation are: 0 in H.01 is equivalent to discardPriority 0; 1 in H.01 is equivalent to discardPriority 1. And 0 in H.30 is equivalent to transferPriority normal; 1 in H.30 is equivalent to transferPriority high. Please refer to discardPriority and transferPriority for more information on how to use them.")
mscVctDcNfaEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 3, 269, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VcTesterMIB", "mscVctIndex"), (0, "Nortel-MsCarrier-MscPassport-VcTesterMIB", "mscVctDcIndex"), (0, "Nortel-MsCarrier-MscPassport-VcTesterMIB", "mscVctDcNfaIndex"))
if mibBuilder.loadTexts: mscVctDcNfaEntry.setStatus('obsolete')
if mibBuilder.loadTexts: mscVctDcNfaEntry.setDescription('An entry in the mscVctDcNfaTable.')
mscVctDcNfaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 3, 269, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(1, 1), ValueRangeConstraint(48, 48), ValueRangeConstraint(127, 127), ValueRangeConstraint(212, 212), )))
if mibBuilder.loadTexts: mscVctDcNfaIndex.setStatus('obsolete')
if mibBuilder.loadTexts: mscVctDcNfaIndex.setDescription('This variable represents the index for the mscVctDcNfaTable.')
mscVctDcNfaValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 3, 269, 1, 2), HexString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDcNfaValue.setStatus('obsolete')
if mibBuilder.loadTexts: mscVctDcNfaValue.setDescription('This variable represents an individual value for the mscVctDcNfaTable.')
mscVctDcNfaRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 3, 269, 1, 3), RowStatus()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mscVctDcNfaRowStatus.setStatus('obsolete')
if mibBuilder.loadTexts: mscVctDcNfaRowStatus.setDescription('This variable is used to control the addition and deletion of individual values of the mscVctDcNfaTable.')
mscVctDcIfaTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 3, 270), )
if mibBuilder.loadTexts: mscVctDcIfaTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDcIfaTable.setDescription("This is the i'th International facility required for this direct call. Within the provisioning system, the user specifies the facility code along with the facility parameters. The facility is represented internally as a hexadecimal string following the X.25 ITU-T representation for facility data.")
mscVctDcIfaEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 3, 270, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VcTesterMIB", "mscVctIndex"), (0, "Nortel-MsCarrier-MscPassport-VcTesterMIB", "mscVctDcIndex"), (0, "Nortel-MsCarrier-MscPassport-VcTesterMIB", "mscVctDcIfaIndex"))
if mibBuilder.loadTexts: mscVctDcIfaEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDcIfaEntry.setDescription('An entry in the mscVctDcIfaTable.')
mscVctDcIfaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 3, 270, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)))
if mibBuilder.loadTexts: mscVctDcIfaIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDcIfaIndex.setDescription('This variable represents the index for the mscVctDcIfaTable.')
mscVctDcIfaValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 3, 270, 1, 2), HexString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVctDcIfaValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDcIfaValue.setDescription('This variable represents an individual value for the mscVctDcIfaTable.')
mscVctDcIfaRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 3, 270, 1, 3), RowStatus()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mscVctDcIfaRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctDcIfaRowStatus.setDescription('This variable is used to control the addition and deletion of individual values of the mscVctDcIfaTable.')
mscVctVc = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 4))
mscVctVcRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 4, 1), )
if mibBuilder.loadTexts: mscVctVcRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcRowStatusTable.setDescription('This entry controls the addition and deletion of mscVctVc components.')
mscVctVcRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 4, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VcTesterMIB", "mscVctIndex"), (0, "Nortel-MsCarrier-MscPassport-VcTesterMIB", "mscVctVcIndex"))
if mibBuilder.loadTexts: mscVctVcRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcRowStatusEntry.setDescription('A single entry in the table represents a single mscVctVc component.')
mscVctVcRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 4, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVctVc components. These components cannot be added nor deleted.')
mscVctVcComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVctVcStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcStorageType.setDescription('This variable represents the storage type value for the mscVctVc tables.')
mscVctVcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 4, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscVctVcIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcIndex.setDescription('This variable represents the index for the mscVctVc tables.')
mscVctVcCadTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 4, 10), )
if mibBuilder.loadTexts: mscVctVcCadTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcCadTable.setDescription('This group represents operational call data related to General Vc. It can be displayed only for General Vc which is created by application.')
mscVctVcCadEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 4, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VcTesterMIB", "mscVctIndex"), (0, "Nortel-MsCarrier-MscPassport-VcTesterMIB", "mscVctVcIndex"))
if mibBuilder.loadTexts: mscVctVcCadEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcCadEntry.setDescription('An entry in the mscVctVcCadTable.')
mscVctVcType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 4, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("svc", 0), ("pvc", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcType.setDescription('This attribute displays the type of call, pvc or svc. type is provided at provisioning time.')
mscVctVcState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 4, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("creating", 0), ("readyP1", 1), ("dteWaitingP2", 2), ("dceWaitingP3", 3), ("dataTransferP4", 4), ("unsupportedP5", 5), ("dteClearRequestP6", 6), ("dceClearIndicationP7", 7), ("termination", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcState.setDescription('This attribute displays the state of call control. P5 state is not supported but is listed for completness. Transitions from one state to another take very short time. state most often displayed is dataTransferP4.')
mscVctVcPreviousState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 4, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("creating", 0), ("readyP1", 1), ("dteWaitingP2", 2), ("dceWaitingP3", 3), ("dataTransferP4", 4), ("unsupportedP5", 5), ("dteClearRequestP6", 6), ("dceClearIndicationP7", 7), ("termination", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcPreviousState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcPreviousState.setDescription('This attribute displays the previous state of call control. This is a valuable field to determine how the processing is progressing.')
mscVctVcDiagnosticCode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 4, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcDiagnosticCode.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcDiagnosticCode.setDescription('This attribute displays the internal substate of call control. It is used to further refine state of call processing.')
mscVctVcPreviousDiagnosticCode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 4, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcPreviousDiagnosticCode.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcPreviousDiagnosticCode.setDescription('This attribute displays the internal substate of call control. It is used to further refine state of call processing.')
mscVctVcCalledNpi = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 4, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("x121", 0), ("e164", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcCalledNpi.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcCalledNpi.setDescription('This attribute displays the Numbering Plan Indicator (NPI) of the called end.')
mscVctVcCalledDna = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 4, 10, 1, 7), DigitString().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcCalledDna.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcCalledDna.setDescription('This attribute displays the Data Network Address (Dna) of the called (destination) DTE to which this call is sent. This address if defined at recieving end will complete Vc connection.')
mscVctVcCalledLcn = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 4, 10, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcCalledLcn.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcCalledLcn.setDescription('This attribute displays the Logical Channel Number of the called end. It is valid only after both ends of Vc exchanged relevant information.')
mscVctVcCallingNpi = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 4, 10, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("x121", 0), ("e164", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcCallingNpi.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcCallingNpi.setDescription('This attribute displays the Numbering Plan Indicator (NPI) of the calling end.')
mscVctVcCallingDna = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 4, 10, 1, 10), DigitString().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcCallingDna.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcCallingDna.setDescription('This attribute displays the Data Network Address (Dna) of the calling end.')
mscVctVcCallingLcn = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 4, 10, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcCallingLcn.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcCallingLcn.setDescription('This attribute displays the Logical Channel Number of the calling end.')
mscVctVcAccountingEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 4, 10, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("yes", 0), ("no", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcAccountingEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcAccountingEnabled.setDescription('This attribute indicates that this optional section of accounting record is suppressed or permitted. If accountingEnabled is yes, conditions for generation of accounting record were met. These conditions include billing options, vc recovery conditions and Module wide accounting data options.')
mscVctVcFastSelectCall = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 4, 10, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcFastSelectCall.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcFastSelectCall.setDescription('This attribute displays that this is a fast select call.')
mscVctVcLocalRxPktSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 4, 10, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("unknown", 0), ("n16", 4), ("n32", 5), ("n64", 6), ("n128", 7), ("n256", 8), ("n512", 9), ("n1024", 10), ("n2048", 11), ("n4096", 12)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcLocalRxPktSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcLocalRxPktSize.setDescription('This attribute displays the locally negotiated size of send packets.')
mscVctVcLocalTxPktSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 4, 10, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("unknown", 0), ("n16", 4), ("n32", 5), ("n64", 6), ("n128", 7), ("n256", 8), ("n512", 9), ("n1024", 10), ("n2048", 11), ("n4096", 12)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcLocalTxPktSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcLocalTxPktSize.setDescription('This attribute displays the locally negotiated size of send packets.')
mscVctVcLocalTxWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 4, 10, 1, 16), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcLocalTxWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcLocalTxWindowSize.setDescription('This attribute displays the send window size provided on incoming call packets or the default when a call request packet does not explicitly provide the window size.')
mscVctVcLocalRxWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 4, 10, 1, 17), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcLocalRxWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcLocalRxWindowSize.setDescription('This attribute displays the receive window size provided on incoming call packets or the default when a call request does not explicitly provide the window sizes.')
mscVctVcPathReliability = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 4, 10, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("high", 0), ("normal", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcPathReliability.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcPathReliability.setDescription('This attribute displays the path reliability.')
mscVctVcAccountingEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 4, 10, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("callingEnd", 0), ("calledEnd", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcAccountingEnd.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcAccountingEnd.setDescription('This attribute indicates if this end should generate an accounting record. Normally, callingEnd is the end to generate an accounting record.')
mscVctVcPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 4, 10, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("normal", 0), ("high", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcPriority.setDescription('This attribute displays whether the call is a normal or a high priority call.')
mscVctVcSegmentSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 4, 10, 1, 22), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcSegmentSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcSegmentSize.setDescription('This attribute displays the segment size (in bytes) used on the call. It is used to calculate the number of segments transmitted and received.')
mscVctVcSubnetTxPktSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 4, 10, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("unknown", 0), ("n16", 4), ("n32", 5), ("n64", 6), ("n128", 7), ("n256", 8), ("n512", 9), ("n1024", 10), ("n2048", 11), ("n4096", 12)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcSubnetTxPktSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcSubnetTxPktSize.setDescription('This attribute displays the locally negotiated size of the data packets on this Vc.')
mscVctVcSubnetTxWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 4, 10, 1, 24), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcSubnetTxWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcSubnetTxWindowSize.setDescription('This attribute displays the current send window size of Vc.')
mscVctVcSubnetRxPktSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 4, 10, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("unknown", 0), ("n16", 4), ("n32", 5), ("n64", 6), ("n128", 7), ("n256", 8), ("n512", 9), ("n1024", 10), ("n2048", 11), ("n4096", 12)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcSubnetRxPktSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcSubnetRxPktSize.setDescription('This attribute displays the locally negotiated size of receive packets.')
mscVctVcSubnetRxWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 4, 10, 1, 26), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcSubnetRxWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcSubnetRxWindowSize.setDescription('This attribute displays the receive window size provided on incoming call packets and to the default when a call request does not explicitly provide the window sizes.')
mscVctVcMaxSubnetPktSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 4, 10, 1, 27), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcMaxSubnetPktSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcMaxSubnetPktSize.setDescription('This attribute displays the maximum packet size allowed on Vc.')
mscVctVcTransferPriorityToNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 4, 10, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 9))).clone(namedValues=NamedValues(("normal", 0), ("high", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcTransferPriorityToNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcTransferPriorityToNetwork.setDescription('This attribute displays the priority in which data is transferred to the network. The transfer priority is a preference specified by an application according to its delay-sensitivity requirement. Frames with high transfer priority are served by the network before the frames with normal priority. Each transfer priority contains a predetermined setting for trunk queue (interrupting, delay or throughput), and routing metric (delay or throughput). When the transfer priority is set at high, the trunk queue is set to high, the routing metric is set to delay. When the transfer priority is set at normal, the trunk queue is set to normal, the routing metric is set to throughput.')
mscVctVcTransferPriorityFromNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 4, 10, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 9))).clone(namedValues=NamedValues(("normal", 0), ("high", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcTransferPriorityFromNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcTransferPriorityFromNetwork.setDescription('This attribute displays the priority in which data is transferred from the network. The transfer priority is a preference specified by an application according to its delay-sensitivity requirement. Frames with high transfer priority are served by the network before the frames with normal priority. Each transfer priority contains a predetermined setting for trunk queue (interrupting, delay or throughput), and routing metric (delay or throughput). When the transfer priority is set at high, and the trunk queue is set to high, the routing metric is set to delay. When the transfer priority is set at normal, the trunk queue is set to normal, and the routing metric is set to throughput.')
mscVctVcIntdTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 4, 11), )
if mibBuilder.loadTexts: mscVctVcIntdTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcIntdTable.setDescription('This group defines display of interval data collected by Vc. Data in this group is variable and may depend on time when this display command is issued.')
mscVctVcIntdEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 4, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VcTesterMIB", "mscVctIndex"), (0, "Nortel-MsCarrier-MscPassport-VcTesterMIB", "mscVctVcIndex"))
if mibBuilder.loadTexts: mscVctVcIntdEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcIntdEntry.setDescription('An entry in the mscVctVcIntdTable.')
mscVctVcCallReferenceNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 4, 11, 1, 1), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcCallReferenceNumber.setStatus('obsolete')
if mibBuilder.loadTexts: mscVctVcCallReferenceNumber.setDescription('This attribute is obsolete. It is replaced by the callReferenceNumber attribute to display the call reference number in decimal. The SNMP reference for the callReferenceNumber attribute is callReferenceNumberDecimal.')
mscVctVcElapsedTimeTillNow = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 4, 11, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcElapsedTimeTillNow.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcElapsedTimeTillNow.setDescription('This attribute displays the elapsed time representing the period of this interval data. It is elapsed time in 0.1 second increments since Vc started.')
mscVctVcSegmentsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 4, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcSegmentsRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcSegmentsRx.setDescription('This attribute displays the number of segments received at the time command was issued. This is the segment received count maintained by accounting at each end of the Vc. This counter is updated only when the packet cannot be successfully delivered out of the sink Vc and to the sink AP Conditions in which packets may be discarded by the sink Vc include: missing packets due to subnet discards, segmentation protocol violations due to subnet discard, duplicated and out-of-ranged packets and packets that arrive while Vc is in path recovery state.')
mscVctVcSegmentsSent = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 4, 11, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcSegmentsSent.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcSegmentsSent.setDescription('This attribute displays the number of segments sent at the time command was issued. This is the segment sent count maintained by accounting at the source Vc. Vc only counts packets that Vc thinks can be delivered successfully into the subnet. In reality, these packets may be dropped by trunking, for instance. This counter is not updated when splitting fails, when Vc is in a path recovery state, when packet forwarding fails to forward this packet and when subsequent packets have to be discarded as we want to minimize the chance of out-of-sequence and do not intentionally send out-of- sequenced packets into the subnet.')
mscVctVcStartTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 4, 11, 1, 5), EnterpriseDateAndTime().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(19, 19), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcStartTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcStartTime.setDescription('This attribute displays the start time of this interval period. If Vc spans 12 hour time or time of day change startTime reflects new time as recorded at 12 hour periods or time of day changes.')
mscVctVcCallReferenceNumberDecimal = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 4, 11, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcCallReferenceNumberDecimal.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcCallReferenceNumberDecimal.setDescription('This attribute displays the call reference number which is a unique number generated by the switch.The same Call Reference Number is stored in the interval data (accounting record) at both ends of the call. It can be used as one of the attributes in matching duplicate records generated at each end of the call.')
mscVctVcStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 4, 12), )
if mibBuilder.loadTexts: mscVctVcStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcStatsTable.setDescription('... Statistics(Stats) This group defines general attributes collected by general Vc. The purpose of Vc attributes is to aid end users and verification people to understand the Vc internal behavior. This is particularly useful when the network has experienced abnormality and we want to isolate problems and pinpoint trouble spots. Attributes are collected on a per Vc basis. Until a need is identified, statistics are not collected at a processor level. Each attribute is stored in a 32 bit field and is initialized to zero when a Vc enters into the data transfer state. When a PVC is disconnected and then connected again, the attributes will be reset. Attributes cannot be reset through other methods.')
mscVctVcStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 4, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VcTesterMIB", "mscVctIndex"), (0, "Nortel-MsCarrier-MscPassport-VcTesterMIB", "mscVctVcIndex"))
if mibBuilder.loadTexts: mscVctVcStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcStatsEntry.setDescription('An entry in the mscVctVcStatsTable.')
mscVctVcAckStackingTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 4, 12, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcAckStackingTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcAckStackingTimeouts.setDescription('This attribute counts the number of ack stacking timer expiries. It is used as an indicator of the acknowledgment behavior across the subnet when ack stacking is in effect. If it expires often, usually this means end users will experience longer delay. The ack stacking timer specifies how long the Vc will wait before finally sending the subnet acknowledgment. if this attribute is set to a value of 0, then the Vc will automatically return acknowledgment packets without delay. If this attribute is set to a value other than zero, then the Vc will wait for this amount of time in an attempt to piggyback the acknowledgment packet on another credit or data packet. If the Vc cannot piggyback the acknowledgment packet within this time, then the packet is returned without piggybacking.')
mscVctVcOutOfRangeFrmFromSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 4, 12, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcOutOfRangeFrmFromSubnet.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcOutOfRangeFrmFromSubnet.setDescription('This attribute counts the number of subnet frames discarded due to the sequence number being out of range. Two Categories apply for the General Vc 1) lost Acks (previous Range) 2) unexpected Packets (next Range) Vc internally maintains its own sequence number of packet order and sequencing. Due to packet retransmission, Vc may receive duplicate packets that have the same Vc internal sequence number. Only 1 copy is accepted by the Vc and other copies of the same packets are detected through this count. This attribute can be used to record the frequency of packet retransmission due to Vc and other part of the subnet.')
mscVctVcDuplicatesFromSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 4, 12, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcDuplicatesFromSubnet.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcDuplicatesFromSubnet.setDescription('This attribute counts the number of subnet packets discarded due to duplication. It is used to detect software error fault or duplication caused by retransmitting.')
mscVctVcFrmRetryTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 4, 12, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcFrmRetryTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcFrmRetryTimeouts.setDescription('This attribute counts the number of frames which have retransmission time-out. If packets from Vc into the subnet are discarded by the subnet, the source Vc will not receive any acknowledgment. The retransmission timer then expires and packets will be retransmitted again. Note that the Vc idle probe may be retransmitted and is included in this count. This statistics does not show the distribution of how many times packets are retransmitted (e.g. first retransmission results in successful packet forwarding).')
mscVctVcPeakRetryQueueSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 4, 12, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcPeakRetryQueueSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcPeakRetryQueueSize.setDescription('This attribute indicates the peak size of the retransmission queue. This attribute is used as an indicator of the acknowledgment behavior across the subnet. It records the largest body of unacknowledged packets.')
mscVctVcPeakOoSeqQueueSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 4, 12, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcPeakOoSeqQueueSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcPeakOoSeqQueueSize.setDescription('This attribute indicates the peak size of the out of sequence queue. This attribute is used as an indicator of the sequencing behavior across the subnet. It records the largest body of out of sequence packets.')
mscVctVcPeakOoSeqFrmForwarded = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 4, 12, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcPeakOoSeqFrmForwarded.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcPeakOoSeqFrmForwarded.setDescription('This attribute indicates the peak size of the sequence packet queue. This attribute is used as an indicator of the sequencing behavior across the subnet. It records the largest body of out of sequence packets, which by the receipt of an expected packet have been transformed to expected packets. The number of times this peak is reached is not recorded as it is traffic dependent.')
mscVctVcPeakStackedAcksRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 4, 12, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcPeakStackedAcksRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcPeakStackedAcksRx.setDescription('This attribute indicates the peak size of wait acks. This attribute is used as an indicator of the acknowledgment behavior across the subnet. It records the largest collective acknowledgment.')
mscVctVcSubnetRecoveries = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 4, 12, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcSubnetRecoveries.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcSubnetRecoveries.setDescription('This attribute counts the number of successful Vc recovery attempts. This attribute is used as an indicator of how many times the Vc path is broken but can be recovered. This attribute is useful to record the number of network path failures.')
mscVctVcWindowClosuresToSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 4, 12, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcWindowClosuresToSubnet.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcWindowClosuresToSubnet.setDescription('This attribute counts the number of window closures to subnet. A packet may have been sent into the subnet but its acknowledgment from the remote Vc has not yet been received. This is a 8 bit sequence number.This number is useful in detecting whether the Vc is sending any packet into the subnet.')
mscVctVcWindowClosuresFromSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 4, 12, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcWindowClosuresFromSubnet.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcWindowClosuresFromSubnet.setDescription('This attribute counts the number of window closures from subnet. This attribute is useful in detecting whether the Vc is receiving any packet from the subnet.')
mscVctVcWrTriggers = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 4, 12, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcWrTriggers.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcWrTriggers.setDescription('This attribute displays the number of times the Vc stays within the W-R region. The W-R region is a value used to determined the timing of credit transmission. Should the current window size be beneath this value, the credits will be transmitted immediately. Otherwise, they will be transmitted later with actual data. The wrTriggers statistic is therefore used to analyze the flow control and credit mechanism.')
mscVctVcfr = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 5))
mscVctVcfrRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 5, 1), )
if mibBuilder.loadTexts: mscVctVcfrRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcfrRowStatusTable.setDescription('This entry controls the addition and deletion of mscVctVcfr components.')
mscVctVcfrRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 5, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VcTesterMIB", "mscVctIndex"), (0, "Nortel-MsCarrier-MscPassport-VcTesterMIB", "mscVctVcfrIndex"))
if mibBuilder.loadTexts: mscVctVcfrRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcfrRowStatusEntry.setDescription('A single entry in the table represents a single mscVctVcfr component.')
mscVctVcfrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 5, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcfrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcfrRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVctVcfr components. These components cannot be added nor deleted.')
mscVctVcfrComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 5, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcfrComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcfrComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVctVcfrStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 5, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcfrStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcfrStorageType.setDescription('This variable represents the storage type value for the mscVctVcfr tables.')
mscVctVcfrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 5, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscVctVcfrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcfrIndex.setDescription('This variable represents the index for the mscVctVcfr tables.')
mscVctVcfrCadTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 5, 10), )
if mibBuilder.loadTexts: mscVctVcfrCadTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcfrCadTable.setDescription('This group represents operational call data related to Frame Relay Vc. It can be displayed only for Frame Relay Vc which is created by application.')
mscVctVcfrCadEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 5, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VcTesterMIB", "mscVctIndex"), (0, "Nortel-MsCarrier-MscPassport-VcTesterMIB", "mscVctVcfrIndex"))
if mibBuilder.loadTexts: mscVctVcfrCadEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcfrCadEntry.setDescription('An entry in the mscVctVcfrCadTable.')
mscVctVcfrType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 5, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("svc", 0), ("pvc", 1), ("spvc", 2), ("frf10spvc", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcfrType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcfrType.setDescription('This attribute displays the type of call, pvc,svc,spvc or frf10spvc.')
mscVctVcfrState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 5, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("creating", 0), ("readyP1", 1), ("dteWaitingP2", 2), ("dceWaitingP3", 3), ("dataTransferP4", 4), ("unsupportedP5", 5), ("dteClearRequestP6", 6), ("dceClearIndicationP7", 7), ("termination", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcfrState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcfrState.setDescription('This attribute displays the state of call control. P5 state is not supported but is listed for completness. Transitions from one state to another take very short time. state most often displayed is dataTransferP4.')
mscVctVcfrPreviousState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 5, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("creating", 0), ("readyP1", 1), ("dteWaitingP2", 2), ("dceWaitingP3", 3), ("dataTransferP4", 4), ("unsupportedP5", 5), ("dteClearRequestP6", 6), ("dceClearIndicationP7", 7), ("termination", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcfrPreviousState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcfrPreviousState.setDescription('This attribute displays the previous state of call control. This is a valuable field to determine how the processing is progressing.')
mscVctVcfrDiagnosticCode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 5, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcfrDiagnosticCode.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcfrDiagnosticCode.setDescription('This attribute displays the internal substate of call control. It is used to further refine state of call processing.')
mscVctVcfrPreviousDiagnosticCode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 5, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcfrPreviousDiagnosticCode.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcfrPreviousDiagnosticCode.setDescription('This attribute displays the internal substate of call control. It is used to further refine state of call processing.')
mscVctVcfrCalledNpi = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 5, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("x121", 0), ("e164", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcfrCalledNpi.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcfrCalledNpi.setDescription('This attribute displays the Numbering Plan Indicator (NPI) of the called end.')
mscVctVcfrCalledDna = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 5, 10, 1, 7), DigitString().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcfrCalledDna.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcfrCalledDna.setDescription('This attribute displays the Data Network Address (Dna) of the called (destination) DTE to which this call is sent. This address if defined at recieving end will complete Vc connection.')
mscVctVcfrCalledLcn = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 5, 10, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcfrCalledLcn.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcfrCalledLcn.setDescription('This attribute displays the Logical Channel Number of the called end. It is valid only after both ends of Vc exchanged relevant information.')
mscVctVcfrCallingNpi = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 5, 10, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("x121", 0), ("e164", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcfrCallingNpi.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcfrCallingNpi.setDescription('This attribute displays the Numbering Plan Indicator (NPI) of the calling end.')
mscVctVcfrCallingDna = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 5, 10, 1, 10), DigitString().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcfrCallingDna.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcfrCallingDna.setDescription('This attribute displays the Data Network Address (Dna) of the calling end.')
mscVctVcfrCallingLcn = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 5, 10, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcfrCallingLcn.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcfrCallingLcn.setDescription('This attribute displays the Logical Channel Number of the calling end.')
mscVctVcfrAccountingEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 5, 10, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("yes", 0), ("no", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcfrAccountingEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcfrAccountingEnabled.setDescription('This attribute indicates that this optional section of accounting record is suppressed or permitted. If accountingEnabled is yes, conditions for generation of accounting record were met. These conditions include billing options, vc recovery conditions and Module wide accounting data options.')
mscVctVcfrFastSelectCall = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 5, 10, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcfrFastSelectCall.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcfrFastSelectCall.setDescription('This attribute displays that this is a fast select call.')
mscVctVcfrPathReliability = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 5, 10, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("high", 0), ("normal", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcfrPathReliability.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcfrPathReliability.setDescription('This attribute displays the path reliability.')
mscVctVcfrAccountingEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 5, 10, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("callingEnd", 0), ("calledEnd", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcfrAccountingEnd.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcfrAccountingEnd.setDescription('This attribute indicates if this end should generate an accounting record. Normally, callingEnd is the end to generate an accounting record.')
mscVctVcfrPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 5, 10, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("normal", 0), ("high", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcfrPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcfrPriority.setDescription('This attribute displays whether the call is a normal or a high priority call.')
mscVctVcfrSegmentSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 5, 10, 1, 22), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcfrSegmentSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcfrSegmentSize.setDescription('This attribute displays the segment size (in bytes) used on the call. It is used to calculate the number of segments transmitted and received.')
mscVctVcfrMaxSubnetPktSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 5, 10, 1, 27), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcfrMaxSubnetPktSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcfrMaxSubnetPktSize.setDescription('This attribute indicates the maximum packet size allowed on the Vc.')
mscVctVcfrRcosToNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 5, 10, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("throughput", 0), ("delay", 1), ("multimedia", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcfrRcosToNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcfrRcosToNetwork.setDescription('This attribute indicates the routing metric routing class of service to the network.')
mscVctVcfrRcosFromNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 5, 10, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("throughput", 0), ("delay", 1), ("multimedia", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcfrRcosFromNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcfrRcosFromNetwork.setDescription('This attribute displays the routing metric Routing Class of Service from the Network.')
mscVctVcfrEmissionPriorityToNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 5, 10, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("normal", 0), ("high", 1), ("interrupting", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcfrEmissionPriorityToNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcfrEmissionPriorityToNetwork.setDescription('This attribute displays the network internal emission priotity to the network.')
mscVctVcfrEmissionPriorityFromNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 5, 10, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("normal", 0), ("high", 1), ("interrupting", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcfrEmissionPriorityFromNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcfrEmissionPriorityFromNetwork.setDescription('This attribute displays the network internal emission priotity from the network.')
mscVctVcfrDataPath = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 5, 10, 1, 32), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcfrDataPath.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcfrDataPath.setDescription('This attribute indicates the data path used by the connection. The data path is provisioned in Dna and DirectCall components. The displayed value of this attribute can be different from the provisioned value. If the connection is using dprsOnly data path, the string dprsOnly is displayed. (dynamic packet routing system) If the connection is using dprsMcsOnly data path, the string dprsMcsOnly is displayed. If the connection is using dprsMcsFirst data path, the string dprsMcsFirst is displayed.')
mscVctVcfrIntdTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 5, 11), )
if mibBuilder.loadTexts: mscVctVcfrIntdTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcfrIntdTable.setDescription('This group defines display of interval data collected by Vc. Data in this group is variable and may depend on time when this display command is issued.')
mscVctVcfrIntdEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 5, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VcTesterMIB", "mscVctIndex"), (0, "Nortel-MsCarrier-MscPassport-VcTesterMIB", "mscVctVcfrIndex"))
if mibBuilder.loadTexts: mscVctVcfrIntdEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcfrIntdEntry.setDescription('An entry in the mscVctVcfrIntdTable.')
mscVctVcfrCallReferenceNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 5, 11, 1, 1), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcfrCallReferenceNumber.setStatus('obsolete')
if mibBuilder.loadTexts: mscVctVcfrCallReferenceNumber.setDescription('This attribute is obsolete. It is replaced by the callReferenceNumber attribute to display the call reference number in decimal. The SNMP reference for the callReferenceNumber attribute is callReferenceNumberDecimal.')
mscVctVcfrElapsedTimeTillNow = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 5, 11, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcfrElapsedTimeTillNow.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcfrElapsedTimeTillNow.setDescription('This attribute displays the elapsed time representing the period of this interval data. It is elapsed time in 0.1 second increments since Vc started.')
mscVctVcfrSegmentsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 5, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcfrSegmentsRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcfrSegmentsRx.setDescription('This attribute displays the number of segments received at the time command was issued. This is the segment received count maintained by accounting at each end of the Vc. This counter is updated only when the packet cannot be successfully delivered out of the sink Vc and to the sink AP Conditions in which packets may be discarded by the sink Vc include: missing packets due to subnet discards, segmentation protocol violations due to subnet discard, duplicated and out-of-ranged packets and packets that arrive while Vc is in path recovery state.')
mscVctVcfrSegmentsSent = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 5, 11, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcfrSegmentsSent.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcfrSegmentsSent.setDescription('This attribute displays the number of segments sent at the time command was issued. This is the segment sent count maintained by accounting at the source Vc. Vc only counts packets that Vc thinks can be delivered successfully into the subnet. In reality, these packets may be dropped by trunking, for instance. This counter is not updated when splitting fails, when Vc is in a path recovery state, when packet forwarding fails to forward this packet and when subsequent packets have to be discarded as we want to minimize the chance of out-of-sequence and do not intentionally send out-of- sequenced packets into the subnet.')
mscVctVcfrStartTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 5, 11, 1, 5), EnterpriseDateAndTime().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(19, 19), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcfrStartTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcfrStartTime.setDescription('This attribute displays the start time of this interval period. If Vc spans 12 hour time or time of day change startTime reflects new time as recorded at 12 hour periods or time of day changes.')
mscVctVcfrCallReferenceNumberDecimal = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 5, 11, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcfrCallReferenceNumberDecimal.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcfrCallReferenceNumberDecimal.setDescription('This attribute displays the call reference number which is a unique number generated by the switch.The same Call Reference Number is stored in the interval data (accounting record) at both ends of the call. It can be used as one of the attributes in matching duplicate records generated at each end of the call.')
mscVctVcfrFrdTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 5, 12), )
if mibBuilder.loadTexts: mscVctVcfrFrdTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcfrFrdTable.setDescription('This group defines Frame Relay attributes collected by Frame Relay Vc. The purpose of Vc attributes is to aid end users and verification people to understand the Vc internal behavior. This is particularly useful when the network has experienced abnormality and we want to isolate problems and pinpoint trouble spots. Attributes are collected on a per Vc basis. Until a need is identified, statistics are not collected at a processor level. Each attribute is stored in a 32 bit field and is initialized to zero when a Vc enters into the data transfer state. When a PVC is disconnected and then connected again, the attributes will be reset. Attributes cannot be reset through other methods. Frame Relay Vc uses a best effort data packet delivery protocol and a different packet segmentation and combination methods from the General Vc. The Frame Relay Vc uses the same call setup and control mechanism (e.g. the support of non-flow control data packets) as in a General Vc. Most General Vc statistics and internal variables are used in a Frame Relay Vc and are displayed by software developers')
mscVctVcfrFrdEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 5, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VcTesterMIB", "mscVctIndex"), (0, "Nortel-MsCarrier-MscPassport-VcTesterMIB", "mscVctVcfrIndex"))
if mibBuilder.loadTexts: mscVctVcfrFrdEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcfrFrdEntry.setDescription('An entry in the mscVctVcfrFrdTable.')
mscVctVcfrFrmCongestedToSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 5, 12, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcfrFrmCongestedToSubnet.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcfrFrmCongestedToSubnet.setDescription('This attribute displays the number of frames from link discarded due to lack of resources. It keeps track of the number of frames from link that have to be discarded. The discard reasons include insufficient memory for splitting the frame into smaller subnet packet size.')
mscVctVcfrCannotForwardToSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 5, 12, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcfrCannotForwardToSubnet.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcfrCannotForwardToSubnet.setDescription('This attribute displays the number of discarded packets that can not be forwarded into the subnet because of subnet congestion. Number of frames from link discarded due to failure in forwarding a packet from Vc into the subnet.- This attribute is increased when packet forwarding fails to forward a packet into the subnet. If a frame is split into multiple subnet packets and a partial packet has to be discarded, all subsequent partial packets that have not yet been delivered to the subnet will be discarded as well.')
mscVctVcfrNotDataXferToSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 5, 12, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcfrNotDataXferToSubnet.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcfrNotDataXferToSubnet.setDescription('This attribute records the number of frames from link discarded when the Vc tries to recover from internal path failure.')
mscVctVcfrOutOfRangeFrmFromSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 5, 12, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcfrOutOfRangeFrmFromSubnet.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcfrOutOfRangeFrmFromSubnet.setDescription('This attribute displays the number of frames from subnet discarded due to out of sequence range for arriving too late.')
mscVctVcfrCombErrorsFromSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 5, 12, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcfrCombErrorsFromSubnet.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcfrCombErrorsFromSubnet.setDescription('This attribute records the number of subnet packets discarded at the sink Vc due to the Vc segmentation and combination protocol error. Usually, this occurs when the subnet discards packets and thus this statistics can be used to guest the number of subnet packets that are not delivered to the Vc. It cannot be used as an actual measure because some subnet packets may have been delivered to Vc but have to be discarded because these are partial packets to a frame in which some other partial packets have not been properly delivered to Vc')
mscVctVcfrDuplicatesFromSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 5, 12, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcfrDuplicatesFromSubnet.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcfrDuplicatesFromSubnet.setDescription('This attribute displays the number of subnet packets discarded due to duplication. Although packets are not retransmitted by the Frame Relay Vc, it is possible for the subnet to retransmit packets. When packets are out-of-sequenced and copies of the same packets arrive, then this attribute is increased.')
mscVctVcfrNotDataXferFromSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 5, 12, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcfrNotDataXferFromSubnet.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcfrNotDataXferFromSubnet.setDescription('This attribute displays the number of subnet packets discarded when data transfer is suspended in Vc recovery.')
mscVctVcfrFrmLossTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 5, 12, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcfrFrmLossTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcfrFrmLossTimeouts.setDescription('This attribute displays the number of lost frame timer expiries. When this count is excessive, the network is very congested and packets have been discarded in the subnet.')
mscVctVcfrOoSeqByteCntExceeded = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 5, 12, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcfrOoSeqByteCntExceeded.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcfrOoSeqByteCntExceeded.setDescription('This attribute displays the number times that the out of sequence byte threshold is exceeded. When the threshold is exceeded, this condition is treated as if the loss frame timer has expired and all frames queued at the sink Vc are delivered to the AP. We need to keep this count to examine if the threshold is engineered properly. This should be used in conjunction with the peak value of out-of- sequenced queue and the number of times the loss frame timer has expired. This count should be relatively small when compared with loss frame timer expiry count.')
mscVctVcfrPeakOoSeqPktCount = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 5, 12, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcfrPeakOoSeqPktCount.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcfrPeakOoSeqPktCount.setDescription('This attribute displays the frame relay peak packet count of the out of sequence queue. This attribute records the maximum queue length of the out-of-sequenced queue. The counter can be used to deduce the message buffer requirement on a Vc.')
mscVctVcfrPeakOoSeqFrmForwarded = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 5, 12, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcfrPeakOoSeqFrmForwarded.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcfrPeakOoSeqFrmForwarded.setDescription('This attribute displays the frame relay peak size of the sequence packet queue. The subnet may deliver packets out-of- sequenced. These packets are then queued in an out-of-sequenced queue, waiting for a packet with the expected sequence number to come. When that packet arrives, this attribute records the maximum number of packets that were out-of-sequenced, but now have become in-sequenced. The statistics is used to measure expected queue size due to normal subnet packet disorder (not due to subnet packet discard). Current implementation also uses this statistics to set a maximum size for the out-of-sequenced queue.')
mscVctVcfrSendSequenceNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 5, 12, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcfrSendSequenceNumber.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcfrSendSequenceNumber.setDescription("This attribute displays the Vc internal packet's send sequence number. Note that a 'packet' in this context, may be either a user data packet, or an OAM frame.")
mscVctVcfrPktRetryTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 5, 12, 1, 15), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcfrPktRetryTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcfrPktRetryTimeouts.setDescription('This attribute displays the number of packets which have retransmission time-outs. When this count is excessive, the network is very congested and packets have been discarded in the subnet.')
mscVctVcfrPeakRetryQueueSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 5, 12, 1, 16), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcfrPeakRetryQueueSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcfrPeakRetryQueueSize.setDescription('This attribute displays the peak size of retransmission queue. This attribute is used as an indicator of the acknowledgment behavior across the subnet. Records the largest body of unacknowledged packets.')
mscVctVcfrSubnetRecoveries = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 5, 12, 1, 17), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcfrSubnetRecoveries.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcfrSubnetRecoveries.setDescription('This attribute displays the number of successful Vc recovery attempts.')
mscVctVcfrOoSeqPktCntExceeded = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 5, 12, 1, 19), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcfrOoSeqPktCntExceeded.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcfrOoSeqPktCntExceeded.setDescription('This attribute displays the number times that the out of sequence packet threshold is exceeded. When the threshold is exceeded, this condition is treated as if the loss frame timer has expired and all frames queued at the sink Vc are delivered to the AP. We need to keep this count to examine if the threshold is engineered properly. This should be used in conjunction with the peak value of out-of- sequenced queue and the number of times the loss frame timer has expired. This count should be relatively small when compared with loss frame timer expiry count.')
mscVctVcfrPeakOoSeqByteCount = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 5, 12, 1, 20), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 50000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcfrPeakOoSeqByteCount.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcfrPeakOoSeqByteCount.setDescription('This attribute displays the frame relay peak byte count of the out of sequence queue. This attribute records the maximum queue length of the out-of-sequenced queue. The counter can be used to deduce the message buffer requirement on a Vc.')
mscVctVcfrDmepTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 5, 417), )
if mibBuilder.loadTexts: mscVctVcfrDmepTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcfrDmepTable.setDescription('This attribute displays the data path used by the connection. Data path is provisioned in Dna and DirectCall components. If the connection is using dprsOnly data path, this attribute is empty. If the connection is using dprsMcsOnly or dprsMcsFirst data path, this attribute displays component name of the dprsMcsEndPoint.')
mscVctVcfrDmepEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 5, 417, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VcTesterMIB", "mscVctIndex"), (0, "Nortel-MsCarrier-MscPassport-VcTesterMIB", "mscVctVcfrIndex"), (0, "Nortel-MsCarrier-MscPassport-VcTesterMIB", "mscVctVcfrDmepValue"))
if mibBuilder.loadTexts: mscVctVcfrDmepEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcfrDmepEntry.setDescription('An entry in the mscVctVcfrDmepTable.')
mscVctVcfrDmepValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 5130, 5, 417, 1, 1), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVctVcfrDmepValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscVctVcfrDmepValue.setDescription('This variable represents both the value and the index for the mscVctVcfrDmepTable.')
vcTesterGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 34, 1))
vcTesterGroupCA = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 34, 1, 1))
vcTesterGroupCA02 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 34, 1, 1, 3))
vcTesterGroupCA02A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 34, 1, 1, 3, 2))
vcTesterCapabilities = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 34, 3))
vcTesterCapabilitiesCA = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 34, 3, 1))
vcTesterCapabilitiesCA02 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 34, 3, 1, 3))
vcTesterCapabilitiesCA02A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 34, 3, 1, 3, 2))
mibBuilder.exportSymbols("Nortel-MsCarrier-MscPassport-VcTesterMIB", mscVctVcfr=mscVctVcfr, mscVctVcLocalRxPktSize=mscVctVcLocalRxPktSize, mscVctDnaOutNormalPriority=mscVctDnaOutNormalPriority, mscVctDnaAccountClass=mscVctDnaAccountClass, mscVctVcfrSegmentSize=mscVctVcfrSegmentSize, mscVctDcNfaValue=mscVctDcNfaValue, mscVctVcFastSelectCall=mscVctVcFastSelectCall, mscVctVcPeakStackedAcksRx=mscVctVcPeakStackedAcksRx, mscVctDnaIncHighPriorityReverseCharge=mscVctDnaIncHighPriorityReverseCharge, mscVctDnaIncomingOptionsTable=mscVctDnaIncomingOptionsTable, mscVctDnaOutDefaultPathReliability=mscVctDnaOutDefaultPathReliability, mscVctRowStatus=mscVctRowStatus, mscVctDnaServiceCategory=mscVctDnaServiceCategory, mscVctDnaHgMIndex=mscVctDnaHgMIndex, mscVctDcCugIndex=mscVctDcCugIndex, mscVctVcIntdEntry=mscVctVcIntdEntry, mscVctDnaIncIntlReverseCharge=mscVctDnaIncIntlReverseCharge, mscVctVcAckStackingTimeouts=mscVctVcAckStackingTimeouts, mscVctVcfrSubnetRecoveries=mscVctVcfrSubnetRecoveries, mscVctDcLocalNpi=mscVctDcLocalNpi, mscVctVcPeakRetryQueueSize=mscVctVcPeakRetryQueueSize, mscVctDcOptionsTable=mscVctDcOptionsTable, mscVctDcNfaTable=mscVctDcNfaTable, mscVctVcName=mscVctVcName, mscVctVcfrPeakOoSeqByteCount=mscVctVcfrPeakOoSeqByteCount, mscVctVcfrDmepTable=mscVctVcfrDmepTable, mscVctProvEntry=mscVctProvEntry, mscVctDna=mscVctDna, mscVctVcWindowClosuresFromSubnet=mscVctVcWindowClosuresFromSubnet, mscVctDcLocalDna=mscVctDcLocalDna, mscVctDnaDataPath=mscVctDnaDataPath, mscVctVcCalledNpi=mscVctVcCalledNpi, mscVctVcfrCallingNpi=mscVctVcfrCallingNpi, vcTesterCapabilitiesCA=vcTesterCapabilitiesCA, mscVctDnaIncomingOptionsEntry=mscVctDnaIncomingOptionsEntry, mscVctDnaCugRowStatusTable=mscVctDnaCugRowStatusTable, vcTesterGroupCA02A=vcTesterGroupCA02A, mscVctVcPeakOoSeqQueueSize=mscVctVcPeakOoSeqQueueSize, mscVctDnaPreselectRpoa=mscVctDnaPreselectRpoa, vcTesterCapabilitiesCA02A=vcTesterCapabilitiesCA02A, mscVctDcDataPath=mscVctDcDataPath, mscVctDnaCugOutCalls=mscVctDnaCugOutCalls, mscVctVcSubnetTxWindowSize=mscVctVcSubnetTxWindowSize, mscVctDcCfaIndex=mscVctDcCfaIndex, mscVctVcfrStorageType=mscVctVcfrStorageType, mscVctDcRemoteDna=mscVctDcRemoteDna, mscVctVcfrDmepValue=mscVctVcfrDmepValue, mscVctDnaHgMHgAddrDataNetworkAddress=mscVctDnaHgMHgAddrDataNetworkAddress, mscVctVcPreviousState=mscVctVcPreviousState, mscVctDnaCugComponentName=mscVctDnaCugComponentName, mscVctVcAccountingEnd=mscVctVcAccountingEnd, mscVctVcPathReliability=mscVctVcPathReliability, mscVctDnaHgMComponentName=mscVctDnaHgMComponentName, mscVctDnaOutAccess=mscVctDnaOutAccess, mscVctVcfrCallingLcn=mscVctVcfrCallingLcn, mscVctDnaHgMHgAddrNumberingPlanIndicator=mscVctDnaHgMHgAddrNumberingPlanIndicator, mscVctVcfrOoSeqPktCntExceeded=mscVctVcfrOoSeqPktCntExceeded, mscVctDcUserData=mscVctDcUserData, mscVctVcfrAccountingEnd=mscVctVcfrAccountingEnd, mscVctVcfrSendSequenceNumber=mscVctVcfrSendSequenceNumber, vcTesterGroup=vcTesterGroup, vcTesterCapabilities=vcTesterCapabilities, mscVctDcDfaEntry=mscVctDcDfaEntry, mscVctVcfrMaxSubnetPktSize=mscVctVcfrMaxSubnetPktSize, mscVctDnaCallOptionsEntry=mscVctDnaCallOptionsEntry, mscVctDnaHgMHgAddrStorageType=mscVctDnaHgMHgAddrStorageType, mscVctVcfrComponentName=mscVctVcfrComponentName, mscVctVcfrState=mscVctVcfrState, mscVctVcfrFrmCongestedToSubnet=mscVctVcfrFrmCongestedToSubnet, mscVctVcPriority=mscVctVcPriority, mscVctVcStartTime=mscVctVcStartTime, mscVctVcfrEmissionPriorityToNetwork=mscVctVcfrEmissionPriorityToNetwork, mscVctVcfrIntdTable=mscVctVcfrIntdTable, vcTesterCapabilitiesCA02=vcTesterCapabilitiesCA02, mscVctVcStatsTable=mscVctVcStatsTable, mscVctDcNfaRowStatus=mscVctDcNfaRowStatus, mscVctVcDiagnosticCode=mscVctVcDiagnosticCode, mscVctVcState=mscVctVcState, mscVctDcDfaIndex=mscVctDcDfaIndex, mscVctIndex=mscVctIndex, mscVctVcCallingLcn=mscVctVcCallingLcn, mscVctDnaCugDnic=mscVctDnaCugDnic, mscVctVcfrCadEntry=mscVctVcfrCadEntry, mscVctDcRemoteNpi=mscVctDcRemoteNpi, mscVctVcPreviousDiagnosticCode=mscVctVcPreviousDiagnosticCode, mscVctDnaHgMRowStatusTable=mscVctDnaHgMRowStatusTable, mscVctDnaHgMHgAddrIndex=mscVctDnaHgMHgAddrIndex, mscVctVcWrTriggers=mscVctVcWrTriggers, mscVctDnaHgMHgAddr=mscVctDnaHgMHgAddr, mscVctDnaPacketSizeNegotiation=mscVctDnaPacketSizeNegotiation, mscVctVcStatsEntry=mscVctVcStatsEntry, mscVctDcType=mscVctDcType, mscVctVcfrRcosFromNetwork=mscVctVcfrRcosFromNetwork, mscVctDnaCugPreferential=mscVctDnaCugPreferential, mscVctDnaIncNormalPriorityReverseCharge=mscVctDnaIncNormalPriorityReverseCharge, mscVctVcCallReferenceNumberDecimal=mscVctVcCallReferenceNumberDecimal, mscVctVcMaxSubnetPktSize=mscVctVcMaxSubnetPktSize, mscVctVcTransferPriorityFromNetwork=mscVctVcTransferPriorityFromNetwork, mscVctDnaOutDefaultPathSensitivity=mscVctDnaOutDefaultPathSensitivity, mscVctDnaHgMAvailableChannels=mscVctDnaHgMAvailableChannels, mscVctDnaPacketSizes=mscVctDnaPacketSizes, mscVctDnaDefaultRecvFrmNetworkThruputClass=mscVctDnaDefaultRecvFrmNetworkThruputClass, mscVctDnaHgMHgAddrAddrEntry=mscVctDnaHgMHgAddrAddrEntry, mscVctDcRowStatusTable=mscVctDcRowStatusTable, mscVctDcIndex=mscVctDcIndex, mscVctDcIfaEntry=mscVctDcIfaEntry, mscVctVcStorageType=mscVctVcStorageType, mscVctVcfrIndex=mscVctVcfrIndex, mscVctVcfrPeakOoSeqFrmForwarded=mscVctVcfrPeakOoSeqFrmForwarded, mscVctDnaHgMHgAddrComponentName=mscVctDnaHgMHgAddrComponentName, mscVctVcComponentName=mscVctVcComponentName, mscVctVcCallingNpi=mscVctVcCallingNpi, mscVctDnaEgressAccounting=mscVctDnaEgressAccounting, mscVctDnaRowStatus=mscVctDnaRowStatus, mscVctDnaSignalIntlAddressToLink=mscVctDnaSignalIntlAddressToLink, mscVctDnaOutReverseCharge=mscVctDnaOutReverseCharge, mscVctDnaAccountCollection=mscVctDnaAccountCollection, mscVctDnaCugCugOptionsTable=mscVctDnaCugCugOptionsTable, mscVctVcfrPeakOoSeqPktCount=mscVctVcfrPeakOoSeqPktCount, mscVctDnaCugInterlockCode=mscVctDnaCugInterlockCode, mscVctVcfrEmissionPriorityFromNetwork=mscVctVcfrEmissionPriorityFromNetwork, mscVctVcfrPathReliability=mscVctVcfrPathReliability, mscVctDcOptionsEntry=mscVctDcOptionsEntry, mscVctDcIfaRowStatus=mscVctDcIfaRowStatus, mscVctVcfrIntdEntry=mscVctVcfrIntdEntry, mscVctDnaCugFormat=mscVctDnaCugFormat, mscVctVcIntdTable=mscVctVcIntdTable, mscVctVcSegmentsSent=mscVctVcSegmentsSent, mscVctVcfrPreviousState=mscVctVcfrPreviousState, mscVctVcRowStatus=mscVctVcRowStatus, mscVctDnaIncCalls=mscVctDnaIncCalls, mscVctDnaCug0AsNonCugCall=mscVctDnaCug0AsNonCugCall, mscVctDnaCugRowStatus=mscVctDnaCugRowStatus, mscVctVcfrRowStatusTable=mscVctVcfrRowStatusTable, mscVctVcfrStartTime=mscVctVcfrStartTime, vcTesterMIB=vcTesterMIB, mscVctDnaCug=mscVctDnaCug, mscVctDcNfaEntry=mscVctDcNfaEntry, mscVctVcLocalTxPktSize=mscVctVcLocalTxPktSize, mscVctVcElapsedTimeTillNow=mscVctVcElapsedTimeTillNow, mscVctDnaHgMHgAddrRowStatusTable=mscVctDnaHgMHgAddrRowStatusTable, mscVctVcfrRowStatusEntry=mscVctVcfrRowStatusEntry, mscVctDnaRowStatusEntry=mscVctDnaRowStatusEntry, mscVctVcSubnetRecoveries=mscVctVcSubnetRecoveries, mscVctVc=mscVctVc, mscVctVcfrPeakRetryQueueSize=mscVctVcfrPeakRetryQueueSize, mscVctDcRowStatusEntry=mscVctDcRowStatusEntry, mscVctDnaServiceExchange=mscVctDnaServiceExchange, mscVctVcfrDuplicatesFromSubnet=mscVctVcfrDuplicatesFromSubnet, mscVctVcfrCalledDna=mscVctVcfrCalledDna, mscVctDnaOutHighPriority=mscVctDnaOutHighPriority, mscVctDcIfaIndex=mscVctDcIfaIndex, mscVctVcfrDiagnosticCode=mscVctVcfrDiagnosticCode, mscVctVcfrFrmLossTimeouts=mscVctVcfrFrmLossTimeouts, mscVctDcIfaTable=mscVctDcIfaTable, mscVctVcfrAccountingEnabled=mscVctVcfrAccountingEnabled, mscVctDnaIncIntlNormalCharge=mscVctDnaIncIntlNormalCharge, mscVctDnaNumberingPlanIndicator=mscVctDnaNumberingPlanIndicator, mscVctDnaDataNetworkAddress=mscVctDnaDataNetworkAddress, mscVctDnaHgM=mscVctDnaHgM, mscVctProvTable=mscVctProvTable, mscVctVcAccountingEnabled=mscVctVcAccountingEnabled, mscVctDnaFastSelectCallsOnly=mscVctDnaFastSelectCallsOnly, mscVctVcfrCallingDna=mscVctVcfrCallingDna, mscVctDnaHgMAvailabilityUpdateThreshold=mscVctDnaHgMAvailabilityUpdateThreshold, mscVctDnaDefaultSendToNetworkThruputClass=mscVctDnaDefaultSendToNetworkThruputClass, mscVctDnaOutgoingOptionsEntry=mscVctDnaOutgoingOptionsEntry, mscVctVcLocalTxWindowSize=mscVctVcLocalTxWindowSize, mscVctVcCallingDna=mscVctVcCallingDna, mscVctDnaOutCalls=mscVctDnaOutCalls, mscVctRowStatusEntry=mscVctRowStatusEntry, mscVctDcCfaValue=mscVctDcCfaValue, mscVctDnaHgMMaxAvailableChannels=mscVctDnaHgMMaxAvailableChannels, mscVctDnaAddressTable=mscVctDnaAddressTable, mscVctVcSubnetRxWindowSize=mscVctVcSubnetRxWindowSize, mscVctVcfrSegmentsSent=mscVctVcfrSegmentsSent, mscVctVcfrFrdTable=mscVctVcfrFrdTable, mscVctDnaRowStatusTable=mscVctDnaRowStatusTable, mscVctDnaOutFsUnrestrictedResponse=mscVctDnaOutFsUnrestrictedResponse, mscVctVcfrSegmentsRx=mscVctVcfrSegmentsRx, mscVctVcfrCalledNpi=mscVctVcfrCalledNpi, mscVctDnaHgMRowStatusEntry=mscVctDnaHgMRowStatusEntry, mscVctVcfrNotDataXferFromSubnet=mscVctVcfrNotDataXferFromSubnet, mscVctDnaRpoa=mscVctDnaRpoa, mscVctDnaCugRowStatusEntry=mscVctDnaCugRowStatusEntry, mscVctVcCadEntry=mscVctVcCadEntry, mscVctDnaCugIndex=mscVctDnaCugIndex, mscVctVcfrFastSelectCall=mscVctVcfrFastSelectCall, mscVctDnaComponentName=mscVctDnaComponentName, mscVctVcfrPktRetryTimeouts=mscVctVcfrPktRetryTimeouts, mscVctDnaCugStorageType=mscVctDnaCugStorageType, mscVctRowStatusTable=mscVctRowStatusTable, mscVctDcStorageType=mscVctDcStorageType, mscVctVcSegmentsRx=mscVctVcSegmentsRx, mscVctDcNfaIndex=mscVctDcNfaIndex, mscVctVcCalledDna=mscVctVcCalledDna, mscVctVcfrNotDataXferToSubnet=mscVctVcfrNotDataXferToSubnet, mscVctVcDuplicatesFromSubnet=mscVctVcDuplicatesFromSubnet, mscVctVcfrCalledLcn=mscVctVcfrCalledLcn, mscVctDnaHgMHgAddrAddrTable=mscVctDnaHgMHgAddrAddrTable, mscVctVcIndex=mscVctVcIndex, mscVctDnaCallOptionsTable=mscVctDnaCallOptionsTable, mscVctDnaOutForceReverseCharge=mscVctDnaOutForceReverseCharge, mscVctDnaSignalPreferentialCugToLink=mscVctDnaSignalPreferentialCugToLink, mscVctVcfrCallReferenceNumber=mscVctVcfrCallReferenceNumber, vcTesterGroupCA=vcTesterGroupCA, mscVctDnaOutPathSensitivityOverRide=mscVctDnaOutPathSensitivityOverRide, mscVctDnaCugIncCalls=mscVctDnaCugIncCalls, mscVctDnaHgMHgAddrRowStatusEntry=mscVctDnaHgMHgAddrRowStatusEntry, mscVctDcCfaTable=mscVctDcCfaTable, mscVctVcfrDmepEntry=mscVctVcfrDmepEntry, mscVctVcfrOoSeqByteCntExceeded=mscVctVcfrOoSeqByteCntExceeded, mscVctDnaTransferPriorityOverRide=mscVctDnaTransferPriorityOverRide, mscVctComponentName=mscVctComponentName, mscVctDcRowStatus=mscVctDcRowStatus, mscVctDcIfaValue=mscVctDcIfaValue, mscVctDnaCugPrivileged=mscVctDnaCugPrivileged, mscVctVcSubnetRxPktSize=mscVctVcSubnetRxPktSize, mscVctVcfrRowStatus=mscVctVcfrRowStatus, mscVctDcCfaRowStatus=mscVctDcCfaRowStatus, mscVctDnaOutPathReliabilityOverRide=mscVctDnaOutPathReliabilityOverRide, mscVctDnaOutIntl=mscVctDnaOutIntl, mscVctDnaHgMAvailabilityDelta=mscVctDnaHgMAvailabilityDelta, mscVctLogicalProcessor=mscVctLogicalProcessor, mscVctDnaOutPathSensitivitySignal=mscVctDnaOutPathSensitivitySignal, mscVctVcLocalRxWindowSize=mscVctVcLocalRxWindowSize, mscVctDnaOutNormalCharge=mscVctDnaOutNormalCharge, mscVctDnaOutDefaultPriority=mscVctDnaOutDefaultPriority, mscVctDnaHgMRowStatus=mscVctDnaHgMRowStatus, mscVctDnaAddressEntry=mscVctDnaAddressEntry, mscVctVcRowStatusTable=mscVctVcRowStatusTable, mscVctVcCadTable=mscVctVcCadTable, mscVctVcPeakOoSeqFrmForwarded=mscVctVcPeakOoSeqFrmForwarded, mscVctDnaIncChargeTransfer=mscVctDnaIncChargeTransfer, mscVctVcWindowClosuresToSubnet=mscVctVcWindowClosuresToSubnet, mscVctDnaCugCugOptionsEntry=mscVctDnaCugCugOptionsEntry, mscVctDnaHgMHgAddrRowStatus=mscVctDnaHgMHgAddrRowStatus, mscVctVcSubnetTxPktSize=mscVctVcSubnetTxPktSize, mscVctDcDfaTable=mscVctDcDfaTable, mscVctDnaHgMOpEntry=mscVctDnaHgMOpEntry, mscVctDnaHgMIfTable=mscVctDnaHgMIfTable, mscVctVcfrCombErrorsFromSubnet=mscVctVcfrCombErrorsFromSubnet, mscVctDnaDefaultSendToNetworkPacketSize=mscVctDnaDefaultSendToNetworkPacketSize, mscVctDnaDefaultRecvFrmNetworkWindowSize=mscVctDnaDefaultRecvFrmNetworkWindowSize, mscVct=mscVct, mscVctDcSvcAutoCallRetry=mscVctDcSvcAutoCallRetry, mscVctVcfrCadTable=mscVctVcfrCadTable, mscVctDnaIndex=mscVctDnaIndex, mscVctStorageType=mscVctStorageType, mscVctVcfrFrdEntry=mscVctVcfrFrdEntry, mscVctVcfrElapsedTimeTillNow=mscVctVcfrElapsedTimeTillNow, mscVctDnaDefaultRecvFrmNetworkPacketSize=mscVctDnaDefaultRecvFrmNetworkPacketSize, mscVctVcFrmRetryTimeouts=mscVctVcFrmRetryTimeouts, mscVctVcOutOfRangeFrmFromSubnet=mscVctVcOutOfRangeFrmFromSubnet)
mibBuilder.exportSymbols("Nortel-MsCarrier-MscPassport-VcTesterMIB", mscVctDnaOutFsRestrictedResponse=mscVctDnaOutFsRestrictedResponse, mscVctDnaIncFastSelect=mscVctDnaIncFastSelect, mscVctDcCugType=mscVctDcCugType, mscVctVcfrDataPath=mscVctVcfrDataPath, mscVctVcfrCannotForwardToSubnet=mscVctVcfrCannotForwardToSubnet, mscVctDnaHgMStorageType=mscVctDnaHgMStorageType, mscVctDnaStorageType=mscVctDnaStorageType, mscVctDnaIncSameService=mscVctDnaIncSameService, mscVctVcType=mscVctVcType, mscVctVcfrOutOfRangeFrmFromSubnet=mscVctVcfrOutOfRangeFrmFromSubnet, mscVctVcRowStatusEntry=mscVctVcRowStatusEntry, mscVctDcRemoteLcn=mscVctDcRemoteLcn, mscVctVcfrPreviousDiagnosticCode=mscVctVcfrPreviousDiagnosticCode, vcTesterGroupCA02=vcTesterGroupCA02, mscVctDnaHgMIfEntry=mscVctDnaHgMIfEntry, mscVctDnaDefaultSendToNetworkWindowSize=mscVctDnaDefaultSendToNetworkWindowSize, mscVctDnaCugType=mscVctDnaCugType, mscVctDc=mscVctDc, mscVctVcCallReferenceNumber=mscVctVcCallReferenceNumber, mscVctDnaOutgoingOptionsTable=mscVctDnaOutgoingOptionsTable, mscVctDnaIncAccess=mscVctDnaIncAccess, mscVctVcfrType=mscVctVcfrType, mscVctVcSegmentSize=mscVctVcSegmentSize, mscVctVcfrRcosToNetwork=mscVctVcfrRcosToNetwork, mscVctDcCfaEntry=mscVctDcCfaEntry, mscVctDcDfaValue=mscVctDcDfaValue, mscVctVcfrCallReferenceNumberDecimal=mscVctVcfrCallReferenceNumberDecimal, mscVctDcDfaRowStatus=mscVctDcDfaRowStatus, mscVctDnaDefaultTransferPriority=mscVctDnaDefaultTransferPriority, mscVctVcCalledLcn=mscVctVcCalledLcn, mscVctDcComponentName=mscVctDcComponentName, mscVctDnaOutPathReliabilitySignal=mscVctDnaOutPathReliabilitySignal, mscVctDnaHgMOpTable=mscVctDnaHgMOpTable, mscVctVcfrPriority=mscVctVcfrPriority, mscVctDcDiscardPriority=mscVctDcDiscardPriority, mscVctVcTransferPriorityToNetwork=mscVctVcTransferPriorityToNetwork)

#
# PySNMP MIB module Wellfleet-MCT1-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/Wellfleet-MCT1-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:40:52 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ConstraintsIntersection, SingleValueConstraint, ValueSizeConstraint, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ConstraintsIntersection", "SingleValueConstraint", "ValueSizeConstraint", "ValueRangeConstraint")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
TimeTicks, Unsigned32, iso, Gauge32, Counter64, Counter32, ModuleIdentity, ObjectIdentity, Bits, IpAddress, Integer32, MibIdentifier, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn = mibBuilder.importSymbols("SNMPv2-SMI", "TimeTicks", "Unsigned32", "iso", "Gauge32", "Counter64", "Counter32", "ModuleIdentity", "ObjectIdentity", "Bits", "IpAddress", "Integer32", "MibIdentifier", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
wfMcT1Group, = mibBuilder.importSymbols("Wellfleet-COMMON-MIB", "wfMcT1Group")
wfMcT1ModTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 1), )
if mibBuilder.loadTexts: wfMcT1ModTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1ModTable.setDescription('MCT1 MOD record - Contains MCT1 module Configuration parameters')
wfMcT1ModEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 1, 1), ).setIndexNames((0, "Wellfleet-MCT1-MIB", "wfMcT1ModSlot"))
if mibBuilder.loadTexts: wfMcT1ModEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1ModEntry.setDescription('An entry in the MCT1 Base table')
wfMcT1ModDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfMcT1ModDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1ModDelete.setDescription('Create/Delete parameter')
wfMcT1ModDisable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfMcT1ModDisable.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1ModDisable.setDescription('Enable/Disable parameter')
wfMcT1ModSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 14))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1ModSlot.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1ModSlot.setDescription('Instance ID slot, filled in by driver')
wfMcT1ModPrimaryClock = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("external", 1), ("loop0", 2), ("loop1", 3), ("int", 4))).clone('int')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfMcT1ModPrimaryClock.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1ModPrimaryClock.setDescription('Specifies the primary source for T1 transmit timing. Both T1 ports use the same T1 transmit timing source. The options for T1 timing source are internal timing source, loop timing from either T1 port and an external timing source.')
wfMcT1ModSecondaryClock = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("external", 1), ("loop0", 2), ("loop1", 3), ("int", 4))).clone('loop0')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfMcT1ModSecondaryClock.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1ModSecondaryClock.setDescription('Specifies the secondary source for T1 transmit timing. During normal operation T1 transmit timing is derived from the primary timing source. If the primary timing source fails, the software switches to secondary timing source.')
wfMcT1ModCurrentClock = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("primary", 1), ("secondary", 2), ("int", 3))).clone('primary')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1ModCurrentClock.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1ModCurrentClock.setDescription('Indicates the clock source currently in use')
wfMcT1ModExtClockOperational = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("oper", 1), ("unoper", 2))).clone('oper')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1ModExtClockOperational.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1ModExtClockOperational.setDescription('Indicates whether the External clock is operational')
wfMcT1ModLoop0ClockOperational = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("oper", 1), ("unoper", 2))).clone('oper')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1ModLoop0ClockOperational.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1ModLoop0ClockOperational.setDescription('Indicates whether the timing source from port 1 is operational')
wfMcT1ModLoop1ClockOperational = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("oper", 1), ("unoper", 2))).clone('oper')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1ModLoop1ClockOperational.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1ModLoop1ClockOperational.setDescription('Indicates whether the timing source from port 2 is operational')
wfMcT1ModRestart = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 1, 1, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfMcT1ModRestart.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1ModRestart.setDescription('Indicates Module gate should be restarted to read new configuration')
wfMcT1Table = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 2), )
if mibBuilder.loadTexts: wfMcT1Table.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1Table.setDescription('MCT1 line record - Contains MUNICH32 Configuration parameters ')
wfMcT1Entry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 2, 1), ).setIndexNames((0, "Wellfleet-MCT1-MIB", "wfMcT1Slot"), (0, "Wellfleet-MCT1-MIB", "wfMcT1Connector"))
if mibBuilder.loadTexts: wfMcT1Entry.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1Entry.setDescription('An entry in the MCT1 table')
wfMcT1Delete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfMcT1Delete.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1Delete.setDescription('Create/Delete parameter')
wfMcT1Disable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfMcT1Disable.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1Disable.setDescription('Enable/Disable parameter')
wfMcT1State = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("init", 1), ("up", 2), ("bert", 3), ("loopback", 4), ("redalarm", 5), ("yelalarm", 6), ("bluealarm", 7), ("notpresent", 8))).clone('notpresent')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1State.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1State.setDescription('Line Driver state variable')
wfMcT1Slot = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 14))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1Slot.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1Slot.setDescription('Instance ID Slot, filled in by driver')
wfMcT1Connector = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("one", 1), ("two", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1Connector.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1Connector.setDescription('Instance ID Connector, filled in by driver')
wfMcT1OperationMode = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("default", 1), ("bert", 2))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfMcT1OperationMode.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1OperationMode.setDescription('An option to generate and analyze specific test patterns is provided in BERT mode of operation. Only one T1 port can be in BERT mode at a time. This attribute selects normal or BERT mode of operation')
wfMcT1Mtu = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(3, 4608)).clone(4608)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfMcT1Mtu.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1Mtu.setDescription('MTU parameter. Specifies the largest frame size that can be received by the MCT1 link module. Any received frame which is larger than the MTU will be discarded.')
wfMcT1MunichVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("v1", 1), ("v2", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1MunichVersion.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1MunichVersion.setDescription('Specifies version number of the MUNICH chip used')
wfMcT1Dsx1LineType = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("esf", 2), ("d4", 3))).clone('d4')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfMcT1Dsx1LineType.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1Dsx1LineType.setDescription('Selects between the two framing formats supported - D4 and ESF. The sailent differences between the two formats are the number of frames per superframe and the use of F-bit position.')
wfMcT1Dsx1ZeroCoding = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 5))).clone(namedValues=NamedValues(("b8zs", 2), ("ami", 5))).clone('ami')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfMcT1Dsx1ZeroCoding.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1Dsx1ZeroCoding.setDescription('Selects between the two Zero Code Suppression formats used on the link. In B8ZS coding, any outgoing stream of eight consecutive zeroes is replaced with a B8ZS code word. Any received B8ZS code is replaced with all zeroes.')
wfMcT1Dsx1LoopbackConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("noloop", 1), ("mgrpayloadloop", 2), ("mgrlineloop", 3), ("netreqpayloadloop", 4), ("netreqlineloop", 5), ("otherloop", 6))).clone('noloop')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1Dsx1LoopbackConfig.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1Dsx1LoopbackConfig.setDescription('Indicates the loopback configuration of the T1 interface. The interface can be in the following loopback states: Payload loopback and Line loopback or no loopback. The loopbacks can be initiated by the manager of this device or by the far end. The loopbacks initiated by the far end are NETREQPAYLOADLOOP and NETREQLINELOOP.')
wfMcT1Dsx1LineStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 8, 16, 32))).clone(namedValues=NamedValues(("noalarm", 1), ("farendalarm", 2), ("alarmindicationsignal", 4), ("lossofframe", 8), ("lossofsignal", 16), ("loopbackstate", 32)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1Dsx1LineStatus.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1Dsx1LineStatus.setDescription('Indicates the line status of the T1 interface. It contains loopback state and alarm state information. The Dsx1LineStatus is a bit map therefore it can represent multiple loopback and alarm states simultaneously.')
wfMcT1Dsx1SetupAlarmThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 4, 6, 8, 10))).clone(namedValues=NamedValues(("threshold2", 2), ("threshold4", 4), ("threshold6", 6), ("threshold8", 8), ("threshold10", 10))).clone('threshold2')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfMcT1Dsx1SetupAlarmThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1Dsx1SetupAlarmThreshold.setDescription('Specifies setup time for performance failure conditions, in seconds. When a performance defect is present for greater than the time specified by this parameter a performance failure is registered and a message is logged.')
wfMcT1Dsx1ClearAlarmThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 4, 6, 8, 10))).clone(namedValues=NamedValues(("threshold2", 2), ("threshold4", 4), ("threshold6", 6), ("threshold8", 8), ("threshold10", 10))).clone('threshold2')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfMcT1Dsx1ClearAlarmThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1Dsx1ClearAlarmThreshold.setDescription('Specifies clear time for performance failure conditions, in seconds. When a performance failure condition has been cleared for greater than the time specified by this parameter then the failure cleared condition is registered and a message is logged.')
wfMcT1Dsx1SignalLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 2, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("minus15", 1), ("minus7point5", 2), ("minus0", 3), ("pluspoint5", 4), ("pluspoint8", 5), ("plus1point1", 6), ("plus1point5", 7))).clone('minus0')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfMcT1Dsx1SignalLevel.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1Dsx1SignalLevel.setDescription('Specifies T1 transmit power level, in terms of DB. They translate into cable length as follows: 0.0dB -> 0-133 ft 0.5dB -> 133-266 ft 0.8dB -> 266-399 ft 1.1dB -> 399-533 ft 1.5dB -> 533-655 ft')
wfMcT1LoopbackDisable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 2, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfMcT1LoopbackDisable.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1LoopbackDisable.setDescription('The MCT1 link module is capable of detecting loop up and loop down codes received from the far end. This parameter enables or disbales loop up/down code detection circuitry')
wfMcT1Dsx1FDLOperationMode = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 2, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("oper54016", 1), ("opert1403", 2))).clone('opert1403')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfMcT1Dsx1FDLOperationMode.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1Dsx1FDLOperationMode.setDescription('Select between the two FDL modes of operation. The AT&T mode, 54016 is based on AT&T publication 54015-1989. The ANSI mode, T1403 is based on ANSI publication T1.403-1989')
wfMcT1BertTxOutputLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 2, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("minus15", 1), ("minus7point5", 2), ("minus0", 3), ("pluspoint5", 4), ("pluspoint8", 5), ("plus1point1", 6), ("plus1point5", 7))).clone('minus0')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfMcT1BertTxOutputLevel.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1BertTxOutputLevel.setDescription('Specifies T1 transmit power level, in terms of DB while the T1 port is in BERT mode. The power levels translate into cable length as follows: 0.0dB -> 0-133 ft 0.5dB -> 133-266 ft 0.8dB -> 266-399 ft 1.1dB -> 399-533 ft 1.5dB -> 533-655 ft')
wfMcT1BertTestMode = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 2, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("t1", 1), ("sf", 2), ("esf", 3))).clone('sf')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfMcT1BertTestMode.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1BertTestMode.setDescription('Selects between the framing formats while in bert mode of operation.')
wfMcT1BertLineCode = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 2, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ami", 1), ("b8zs", 2))).clone('ami')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfMcT1BertLineCode.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1BertLineCode.setDescription('Selects between the two Zero Code Suppression formats used on the link while in BERT mode. In B8ZS coding, any outgoing stream of eight consecutive zeroes is replaced with a B8ZS code word. Any received B8ZS code is replaced with all zeroes.')
wfMcT1BertTestPattern = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 2, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("zeros", 1), ("ones", 2), ("qrss", 3), ("fifteen", 4), ("fifteeninv", 5), ("twenty", 6), ("twentythree", 7), ("twentythreeinv", 8))).clone('ones')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfMcT1BertTestPattern.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1BertTestPattern.setDescription('When a T1 port is in BERT mode, it is capable of generating a set of known patterns. This paramater selects between those patterns')
wfMcT1BertSendAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 2, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("blue", 1), ("yellow", 2), ("disabled", 3))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfMcT1BertSendAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1BertSendAlarm.setDescription('Specifies a blue or yellow alarm to be transmitted while in BERT mode.')
wfMcT1DS2282Version = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 2, 1, 23), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1DS2282Version.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1DS2282Version.setDescription('Specifies version number of DS2282 chip')
wfMcT1Restart = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 2, 1, 24), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfMcT1Restart.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1Restart.setDescription('Indicates Port gate should be restarted to read new configuration')
wfMcT1Loopback = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 2, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("linelb", 1), ("payldlb", 2), ("deactivate", 3))).clone('deactivate')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfMcT1Loopback.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1Loopback.setDescription('Selects line or payload loopback to be activated locally')
wfMcT1FDLTargetAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 2, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("az", 1), ("by", 2))).clone('by')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfMcT1FDLTargetAddress.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1FDLTargetAddress.setDescription('Selects between the two FDL target address modes')
wfMcT1ConfigTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 3), )
if mibBuilder.loadTexts: wfMcT1ConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1ConfigTable.setDescription('MCT1 configuration record - Contains MUNICH32 and Framer write only Configuration parameters')
wfMcT1ConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 3, 1), ).setIndexNames((0, "Wellfleet-MCT1-MIB", "wfMcT1ConfigSlot"), (0, "Wellfleet-MCT1-MIB", "wfMcT1ConfigConnector"))
if mibBuilder.loadTexts: wfMcT1ConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1ConfigEntry.setDescription('An entry in the MCT1 Config table')
wfMcT1ConfigSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 14))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1ConfigSlot.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1ConfigSlot.setDescription('Instance ID Slot, filled in by driver')
wfMcT1ConfigConnector = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("one", 1), ("two", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1ConfigConnector.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1ConfigConnector.setDescription('Instance ID Connector, filled in by driver')
wfMcT1BertRestart = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 10))).clone(namedValues=NamedValues(("restart", 1), ("noaction", 10))).clone('noaction')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfMcT1BertRestart.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1BertRestart.setDescription('Reset counters on BERT device')
wfMcT1BertPayldLb = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 10))).clone(namedValues=NamedValues(("act", 1), ("deact", 2), ("noaction", 10))).clone('noaction')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfMcT1BertPayldLb.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1BertPayldLb.setDescription('Selects a payload loopback code to be sent to the far end by the FDL while in BERT mode. It can be a payload loopback activate or deactivate code.')
wfMcT1BertLineLb = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 10))).clone(namedValues=NamedValues(("lpup", 1), ("lpdn", 2), ("fdlact", 3), ("fdldeact", 4), ("noaction", 10))).clone('noaction')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfMcT1BertLineLb.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1BertLineLb.setDescription('Selects a line loopback code to be sent to the far end while in BERT mode. It can be a line loopback activate or deactivate code using the hardware on the MCT1 board or it can be a code sent by the FDL.')
wfMcT1BertErrorInsert = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 10))).clone(namedValues=NamedValues(("config", 1), ("thousandconfig", 2), ("millionconfig", 3), ("disable", 4), ("noaction", 10))).clone('noaction')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfMcT1BertErrorInsert.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1BertErrorInsert.setDescription('Indicates that an error be injected into the transmitted data stream while in BERT mode.')
wfMcT1Dsx1SendLoopCode = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 10))).clone(namedValues=NamedValues(("loopup", 1), ("loopdn", 2), ("noaction", 10))).clone('noaction')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfMcT1Dsx1SendLoopCode.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1Dsx1SendLoopCode.setDescription('Selects a Loop Up/Down code to be sent to the remote end')
wfMcT1Dsx1SendFDLCode = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 10))).clone(namedValues=NamedValues(("ci", 1), ("univlbdeact", 2), ("ia", 3), ("linelbdeact", 4), ("pyldlbact", 5), ("pyldlbdeact", 6), ("ib", 7), ("noaction", 10))).clone('noaction')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfMcT1Dsx1SendFDLCode.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1Dsx1SendFDLCode.setDescription('Selects an FDL code to be sent to the remote end')
wfMcT1LineTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 4), )
if mibBuilder.loadTexts: wfMcT1LineTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1LineTable.setDescription('MCT1 Channel record - Contains configuration parameters and statistics for MUNICH32 which are channel specific.')
wfMcT1LineEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 4, 1), ).setIndexNames((0, "Wellfleet-MCT1-MIB", "wfMcT1LineSlot"), (0, "Wellfleet-MCT1-MIB", "wfMcT1LineConnector"), (0, "Wellfleet-MCT1-MIB", "wfMcT1LineLine"))
if mibBuilder.loadTexts: wfMcT1LineEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1LineEntry.setDescription('An entry in the MCT1CHANNEL table')
wfMcT1LineDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 4, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfMcT1LineDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1LineDelete.setDescription('Create/Delete parameter')
wfMcT1LineDisable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfMcT1LineDisable.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1LineDisable.setDescription('Enable/Disable parameter')
wfMcT1LineState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("init", 3), ("loopback", 4), ("wait", 5), ("channel", 6), ("stop", 7), ("notpresent", 8))).clone('notpresent')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1LineState.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1LineState.setDescription('Line Driver state variable')
wfMcT1LineSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 14))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1LineSlot.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1LineSlot.setDescription('Instance ID Slot, filled in by driver')
wfMcT1LineConnector = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("one", 1), ("two", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1LineConnector.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1LineConnector.setDescription('Instance ID Connector, filled in by driver')
wfMcT1LineLine = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 4, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 24))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1LineLine.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1LineLine.setDescription('Line number for this line instance, filled in by driver. The line number corresponds to the position of the circuit, from 1 to 24, on the port.')
wfMcT1LineCct = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 4, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1023))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfMcT1LineCct.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1LineCct.setDescription('Circuit number for this line instance')
wfMcT1LineBofl = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 4, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfMcT1LineBofl.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1LineBofl.setDescription('Selects Breath of Life (BOFL) parameter. If selected, a BOFL packet is sent out on the wire as often as specifies by the wfMcT1LineBoflTmo parameter')
wfMcT1LineBoflTmo = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 4, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 60)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfMcT1LineBoflTmo.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1LineBoflTmo.setDescription('Indicates the time-period between BOFL packets')
wfMcT1LineFractionalLpbk = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 4, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfMcT1LineFractionalLpbk.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1LineFractionalLpbk.setDescription('Any circuit on this T1 port is capable of being put into loopback, i.e. data coming into that circuit from the wire is mirrorred back onto the wire. This parameter enables or disables this loopback feature on any circuit.')
wfMcT1LineChannelAssignment = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 4, 1, 11), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfMcT1LineChannelAssignment.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1LineChannelAssignment.setDescription('Lists the time-slots which constitute this channel. User types in a list of time-slots from 1 to 24 separated by commas')
wfMcT1LineMadr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 4, 1, 12), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1LineMadr.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1LineMadr.setDescription('Line MAC address, fixed - line driver fills in from the 48 bit address stored in the serial number prom.')
wfMcT1LineWanProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 4, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("standard", 1), ("ppp", 2), ("smds", 3), ("framerelay", 4), ("switch", 5), ("sw", 6))).clone('standard')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfMcT1LineWanProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1LineWanProtocol.setDescription('WAN protocol selection is provided via this parameter. The supported protocols can be selected per circuit.')
wfMcT1LineService = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 4, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("hdlc", 1), ("llc1", 2))).clone('hdlc')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfMcT1LineService.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1LineService.setDescription('Service type for this circuit. Supports raw HDLC mode. Does not support LLC1 at this time. LLC1 mode will prefix the HDLC address and control fields to the frame. May support LLC1 mode in the future')
wfMcT1LineRateAdaption = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 4, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("adaption64k", 1), ("msb", 2), ("lsb", 3))).clone('lsb')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfMcT1LineRateAdaption.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1LineRateAdaption.setDescription('Determines the number of bits and their bit positions within the time-slot. 64k selection uses all 8 bits in the time-slot. The two 56k selections use 7 of the 8 bits in the time-slot. 56k_MSB does not use the most significant bit and 56k_LSB does not use the least significant bit in the time-slot.')
wfMcT1LineIFTF = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 4, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("flags", 1), ("idles", 2))).clone('flags')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfMcT1LineIFTF.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1LineIFTF.setDescription('Determines the Interframe time fill character to be transmitted by the MUNICH. In case of IFTF_FLAGS, 0x7E is sent and in case of IFTF_IDLES 0xff is sent as the interframe timefill characters.')
wfMcT1LineCRCSize = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 4, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("crc32", 1), ("crc16", 2))).clone('crc16')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfMcT1LineCRCSize.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1LineCRCSize.setDescription('Determines the CRC Size. When CRC32 is selected a 32 bit CRC is appended to the frame being transmitted and a 32 bit CRC check is performed on the received frame. When CRC16 is selected, a 16 bit CRC is appended to the transmitted frame and a 16 bit CRC is performed. on the received frame.')
wfMcT1LineRxOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 4, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1LineRxOctets.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1LineRxOctets.setDescription('Number of octets received without error')
wfMcT1LineRxFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 4, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1LineRxFrames.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1LineRxFrames.setDescription('Number of frames received without error')
wfMcT1LineTxOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 4, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1LineTxOctets.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1LineTxOctets.setDescription('Number of octets transmitted without error')
wfMcT1LineTxFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 4, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1LineTxFrames.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1LineTxFrames.setDescription('Number of frames transmitted without error')
wfMcT1LineRxErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 4, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1LineRxErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1LineRxErrors.setDescription('Number of receive errors')
wfMcT1LineTxErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 4, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1LineTxErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1LineTxErrors.setDescription('Number of transmission errors')
wfMcT1LineLackRxResources = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 4, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1LineLackRxResources.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1LineLackRxResources.setDescription('Number of Rx frames dropped due to lack of buffer resources')
wfMcT1LineLackTxResources = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 4, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1LineLackTxResources.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1LineLackTxResources.setDescription('Number of Tx frames dropped due to lack of buffer resources')
wfMcT1LineTxUnderflows = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 4, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1LineTxUnderflows.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1LineTxUnderflows.setDescription('Number of Tx frames dropped due to Transmit underflow')
wfMcT1LineRxOverflows = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 4, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1LineRxOverflows.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1LineRxOverflows.setDescription('Number of Rx frames dropped due to Receive overflow')
wfMcT1LineRxNullFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 4, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1LineRxNullFrames.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1LineRxNullFrames.setDescription('Number of short frames received (with no data bytes)')
wfMcT1LineRxShortFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 4, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1LineRxShortFrames.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1LineRxShortFrames.setDescription('Number of short frames received (less than or equal to two data bytes)')
wfMcT1LineRxLossSyncs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 4, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1LineRxLossSyncs.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1LineRxLossSyncs.setDescription('Loss of synchronization on receiver')
wfMcT1LineRxCRCErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 4, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1LineRxCRCErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1LineRxCRCErrors.setDescription('CRC error received')
wfMcT1LineRxNonOctetBits = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 4, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1LineRxNonOctetBits.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1LineRxNonOctetBits.setDescription('Non-Octet bits received in frame')
wfMcT1LineRxLongFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 4, 1, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1LineRxLongFrames.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1LineRxLongFrames.setDescription('Frame longer than MFL received')
wfMcT1LineRxAbortFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 4, 1, 34), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1LineRxAbortFrames.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1LineRxAbortFrames.setDescription('Aborted frame received')
wfMcT1LineRxDescOverflows = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 4, 1, 35), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1LineRxDescOverflows.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1LineRxDescOverflows.setDescription('Receive overflow on chip buffer')
wfMcT1LineTurboBofl = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 4, 1, 36), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfMcT1LineTurboBofl.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1LineTurboBofl.setDescription('DEBUG parameter - Turbo bofl enabled or disabled')
wfMcT1LineBoflNum = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 4, 1, 37), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfMcT1LineBoflNum.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1LineBoflNum.setDescription('DEBUG parameter - Number of breath of life packets per breath of life')
wfMcT1LineBoflLen = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 4, 1, 38), Integer32().subtype(subtypeSpec=ValueRangeConstraint(22, 4450)).clone(200)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfMcT1LineBoflLen.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1LineBoflLen.setDescription('DEBUG parameter - breath of life packet length')
wfMcT1LineRxIntProcs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 4, 1, 39), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1LineRxIntProcs.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1LineRxIntProcs.setDescription('Receive Interrupt processing count')
wfMcT1LineTxIntProcs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 4, 1, 40), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1LineTxIntProcs.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1LineTxIntProcs.setDescription('Tx interrupt processing count')
wfMcT1LineRxPktCorruptions = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 4, 1, 41), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1LineRxPktCorruptions.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1LineRxPktCorruptions.setDescription('Corruption check on receive')
wfMcT1LineRxReplenMisses = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 4, 1, 42), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1LineRxReplenMisses.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1LineRxReplenMisses.setDescription('Count of number of packet buffer misses while attempting to replenish driver receive ring')
wfMcT1LineRxIFCs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 4, 1, 43), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1LineRxIFCs.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1LineRxIFCs.setDescription('Number of times the device changes its interframe time-fill')
wfMcT1LineCfgTxQueueLength = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 4, 1, 44), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 336))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfMcT1LineCfgTxQueueLength.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1LineCfgTxQueueLength.setDescription('Configured transmit queue length')
wfMcT1LineCfgRxQueueLength = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 4, 1, 45), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 336))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfMcT1LineCfgRxQueueLength.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1LineCfgRxQueueLength.setDescription('Configured receive queue length')
wfMcT1LineTxQueueLength = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 4, 1, 46), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1LineTxQueueLength.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1LineTxQueueLength.setDescription('Current transmit queue length')
wfMcT1LineRxQueueLength = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 4, 1, 47), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1LineRxQueueLength.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1LineRxQueueLength.setDescription('Current Receive queue length')
wfMcT1LineTxQueueEmpty = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 4, 1, 48), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1LineTxQueueEmpty.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1LineTxQueueEmpty.setDescription('The number of times the transmit ring is found empty when transmitting packets')
wfMcT1LineMtu = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 4, 1, 49), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1LineMtu.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1LineMtu.setDescription('MTU read-only parameter. Specifies the largest frame size that can be received by the MCT1 link module. Any received frame which is larger than the MTU will be discarded. Can be set in MCT1Entry TABLE by the user')
wfMcT1LineRestart = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 4, 1, 50), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfMcT1LineRestart.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1LineRestart.setDescription('Indicates channel gate should be restarted to read new configuration')
wfMcT1LineLineNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 4, 1, 51), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfMcT1LineLineNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1LineLineNumber.setDescription('line number for this line instance')
wfMcT1Dsx1CurrentTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 5), )
if mibBuilder.loadTexts: wfMcT1Dsx1CurrentTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1Dsx1CurrentTable.setDescription('The MCT1_DSX1 Current table')
wfMcT1Dsx1CurrentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 5, 1), ).setIndexNames((0, "Wellfleet-MCT1-MIB", "wfMcT1Dsx1CurrentSlot"), (0, "Wellfleet-MCT1-MIB", "wfMcT1Dsx1CurrentConnector"))
if mibBuilder.loadTexts: wfMcT1Dsx1CurrentEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1Dsx1CurrentEntry.setDescription('per circuit MCT1_DSX1 current objects - wfMcT1Dsx1CurrentIndex corresponds to Wellfleet circuit number')
wfMcT1Dsx1CurrentSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 14))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1Dsx1CurrentSlot.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1Dsx1CurrentSlot.setDescription('this corresponds to the Wellfleet Slot number')
wfMcT1Dsx1CurrentConnector = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("one", 1), ("two", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1Dsx1CurrentConnector.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1Dsx1CurrentConnector.setDescription('this corresponds to the Wellfleet Connector number')
wfMcT1Dsx1CurrentIntervalTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 5, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1Dsx1CurrentIntervalTimer.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1Dsx1CurrentIntervalTimer.setDescription('the number of seconds in the current 15 minute interval')
wfMcT1Dsx1CurrentESs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 5, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1Dsx1CurrentESs.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1Dsx1CurrentESs.setDescription('the number of errored seconds encountered by a DS1 interface in the current 15 minute interval')
wfMcT1Dsx1CurrentSESs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 5, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1Dsx1CurrentSESs.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1Dsx1CurrentSESs.setDescription('the number of severely errored seconds in the current 15 minute interval')
wfMcT1Dsx1CurrentBESs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 5, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1Dsx1CurrentBESs.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1Dsx1CurrentBESs.setDescription('the number of bursty errored seconds in the current 15 minute interval')
wfMcT1Dsx1CurrentUASs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 5, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1Dsx1CurrentUASs.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1Dsx1CurrentUASs.setDescription('the number of unavailable seconds in the current 15 minute interval')
wfMcT1Dsx1CurrentCSSs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 5, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1Dsx1CurrentCSSs.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1Dsx1CurrentCSSs.setDescription('the number of Controlled Slip seconds in the current 15 minute interval')
wfMcT1Dsx1CurrentBPVs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 5, 1, 9), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1Dsx1CurrentBPVs.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1Dsx1CurrentBPVs.setDescription('the number of bipolar violations in the current 15 minute interval')
wfMcT1Dsx1IntervalTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 6), )
if mibBuilder.loadTexts: wfMcT1Dsx1IntervalTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1Dsx1IntervalTable.setDescription('The MCT1_DSX1 Interval table')
wfMcT1Dsx1IntervalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 6, 1), ).setIndexNames((0, "Wellfleet-MCT1-MIB", "wfMcT1Dsx1IntervalSlot"), (0, "Wellfleet-MCT1-MIB", "wfMcT1Dsx1IntervalConnector"), (0, "Wellfleet-MCT1-MIB", "wfMcT1Dsx1IntervalNumber"))
if mibBuilder.loadTexts: wfMcT1Dsx1IntervalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1Dsx1IntervalEntry.setDescription('per circuit MCT1_DSX1 interval objects - wfMcT1Dsx1IntervalIndex corresponds to Wellfleet circuit number, wfMcT1Dsx1IntervalNumber is the numbered previous 15-minute interval')
wfMcT1Dsx1IntervalSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 14))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1Dsx1IntervalSlot.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1Dsx1IntervalSlot.setDescription('this corresponds to the Wellfleet Slot number')
wfMcT1Dsx1IntervalConnector = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("one", 1), ("two", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1Dsx1IntervalConnector.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1Dsx1IntervalConnector.setDescription('this corresponds to the Wellfleet Connector number')
wfMcT1Dsx1IntervalNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 6, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 96))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1Dsx1IntervalNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1Dsx1IntervalNumber.setDescription('1..96 where 1 is the most recent 15-minute interval and 96 is the least')
wfMcT1Dsx1IntervalESs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 6, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1Dsx1IntervalESs.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1Dsx1IntervalESs.setDescription('the number of errored seconds in the specified interval')
wfMcT1Dsx1IntervalSESs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 6, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1Dsx1IntervalSESs.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1Dsx1IntervalSESs.setDescription('the number of severely errored seconds in the specified interval')
wfMcT1Dsx1IntervalBESs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 6, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1Dsx1IntervalBESs.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1Dsx1IntervalBESs.setDescription('the number of bursty errored seconds in the specified interval')
wfMcT1Dsx1IntervalUASs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 6, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1Dsx1IntervalUASs.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1Dsx1IntervalUASs.setDescription('the number of unavailable seconds in the specified interval')
wfMcT1Dsx1IntervalCSSs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 6, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1Dsx1IntervalCSSs.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1Dsx1IntervalCSSs.setDescription('the number of controlled slip seconds in the specified interval')
wfMcT1Dsx1IntervalBPVs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 6, 1, 9), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1Dsx1IntervalBPVs.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1Dsx1IntervalBPVs.setDescription('the number of bipolar violations in the specified interval')
wfMcT1Dsx1TotalTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 7), )
if mibBuilder.loadTexts: wfMcT1Dsx1TotalTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1Dsx1TotalTable.setDescription('The MCT1_DSX1 Total table')
wfMcT1Dsx1TotalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 7, 1), ).setIndexNames((0, "Wellfleet-MCT1-MIB", "wfMcT1Dsx1TotalSlot"), (0, "Wellfleet-MCT1-MIB", "wfMcT1Dsx1TotalConnector"))
if mibBuilder.loadTexts: wfMcT1Dsx1TotalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1Dsx1TotalEntry.setDescription('per circuit MCT1_DSX1 total objects - wfMcT1Dsx1TotalIndex corresponds to Wellfleet circuit number')
wfMcT1Dsx1TotalSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 7, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 14))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1Dsx1TotalSlot.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1Dsx1TotalSlot.setDescription('this corresponds to the Wellfleet Slot number')
wfMcT1Dsx1TotalConnector = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 7, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("one", 1), ("two", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1Dsx1TotalConnector.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1Dsx1TotalConnector.setDescription('this corresponds to the Wellfleet Connector number')
wfMcT1Dsx1TotalVITR = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 7, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1Dsx1TotalVITR.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1Dsx1TotalVITR.setDescription('Indicates the number of valid 15 minute intervals in the previous 24 hour period')
wfMcT1Dsx1TotalESs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 7, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1Dsx1TotalESs.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1Dsx1TotalESs.setDescription('The number of errored seconds encountered by the DS1 interface in the previous 24 hour interval')
wfMcT1Dsx1TotalSESs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 7, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1Dsx1TotalSESs.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1Dsx1TotalSESs.setDescription('The number of severely errored seconds encountered by a DS1 interface in the previous 24 hour interval')
wfMcT1Dsx1TotalBESs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 7, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1Dsx1TotalBESs.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1Dsx1TotalBESs.setDescription('The number of bursty errored seconds encountered by a DS1 interface in the previous 24 hour interval')
wfMcT1Dsx1TotalUASs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 7, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1Dsx1TotalUASs.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1Dsx1TotalUASs.setDescription('The number of unavailable seconds encountered by by a DS1 interface in the previous 24 hour interval')
wfMcT1Dsx1TotalCSSs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 7, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1Dsx1TotalCSSs.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1Dsx1TotalCSSs.setDescription('The number of controlled slip seconds encountered by a DS1 interface in the previous 24 hour interval')
wfMcT1Dsx1TotalBPVs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 7, 1, 9), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1Dsx1TotalBPVs.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1Dsx1TotalBPVs.setDescription('The number of bipolar violations encountered by a DS1 interface in the previous 24 hour interval')
wfMcT1AnsiTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 8), )
if mibBuilder.loadTexts: wfMcT1AnsiTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1AnsiTable.setDescription('ANSI Statistics line record - This table contains the performance parameters for the ANSI register set ')
wfMcT1AnsiEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 8, 1), ).setIndexNames((0, "Wellfleet-MCT1-MIB", "wfMcT1AnsiSlot"), (0, "Wellfleet-MCT1-MIB", "wfMcT1AnsiConnector"))
if mibBuilder.loadTexts: wfMcT1AnsiEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1AnsiEntry.setDescription('An entry in the MCT1 Ansi table')
wfMcT1AnsiSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 8, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 14))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1AnsiSlot.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1AnsiSlot.setDescription('Instance ID Slot, filled in by driver')
wfMcT1AnsiConnector = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 8, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("one", 1), ("two", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1AnsiConnector.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1AnsiConnector.setDescription('Instance ID Connector, filled in by driver')
wfMcT1AnsiCRCCounts = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 8, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1AnsiCRCCounts.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1AnsiCRCCounts.setDescription('Counts CRC-6 error events')
wfMcT1AnsiBPVCounts = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 8, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1AnsiBPVCounts.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1AnsiBPVCounts.setDescription('Counts bipolar violations')
wfMcT1AnsiOOFCounts = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 8, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1AnsiOOFCounts.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1AnsiOOFCounts.setDescription('Counts out-of-frame error events')
wfMcT1AnsiFECounts = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 8, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1AnsiFECounts.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1AnsiFECounts.setDescription('Counts errors in the FPS framing pattern')
wfMcT1AnsiESCounts = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 8, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1AnsiESCounts.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1AnsiESCounts.setDescription('Counts errorred seconds')
wfMcT1AnsiSESCounts = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 8, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1AnsiSESCounts.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1AnsiSESCounts.setDescription('Counts severly errorred seconds')
wfMcT1AnsiUASCounts = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 8, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1AnsiUASCounts.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1AnsiUASCounts.setDescription('counts unavailable seconds')
wfMcT1AnsiPRMR0Counts = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 8, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1AnsiPRMR0Counts.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1AnsiPRMR0Counts.setDescription('Counts PRMs that ewre received in the FDL in the last four seconds')
wfMcT1AnsiPRMR1Counts = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 8, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1AnsiPRMR1Counts.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1AnsiPRMR1Counts.setDescription('Counts PRMs that ewre received in the FDL in the last four seconds')
wfMcT1AnsiPRMR2Counts = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 8, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1AnsiPRMR2Counts.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1AnsiPRMR2Counts.setDescription('Counts PRMs that ewre received in the FDL in the last four seconds')
wfMcT1AnsiPRMR3Counts = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 8, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1AnsiPRMR3Counts.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1AnsiPRMR3Counts.setDescription('Counts PRMs that ewre received in the FDL in the last four seconds')
wfMcT1AnsiPRMESCounts = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 8, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1AnsiPRMESCounts.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1AnsiPRMESCounts.setDescription('Counts errorred seconds as reported in the Performance report messages')
wfMcT1AnsiPRMSESCounts = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 8, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1AnsiPRMSESCounts.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1AnsiPRMSESCounts.setDescription('Counts severely errorred seconds as reported in the Performance report messages')
wfMcT1AnsiPRMECounts = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 8, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1AnsiPRMECounts.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1AnsiPRMECounts.setDescription('Counts Performance report messages that are received in error')
wfMcT1BertStatsTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 9), )
if mibBuilder.loadTexts: wfMcT1BertStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1BertStatsTable.setDescription('BERT Counter line record - This table contains the statistics for the BERT tester.')
wfMcT1BertStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 9, 1), ).setIndexNames((0, "Wellfleet-MCT1-MIB", "wfMcT1BertStatsSlot"), (0, "Wellfleet-MCT1-MIB", "wfMcT1BertStatsConnector"))
if mibBuilder.loadTexts: wfMcT1BertStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1BertStatsEntry.setDescription('An entry in the MCT1 Bert Stats table')
wfMcT1BertStatsSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 9, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 14))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1BertStatsSlot.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1BertStatsSlot.setDescription('Instance ID Slot, filled in by driver')
wfMcT1BertStatsConnector = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 9, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("one", 1), ("two", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1BertStatsConnector.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1BertStatsConnector.setDescription('Instance ID Connector, filled in by driver')
wfMcT1BertStatsBitErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 9, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1BertStatsBitErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1BertStatsBitErrors.setDescription('Bit error counter')
wfMcT1BertStatsBits = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 8, 9, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfMcT1BertStatsBits.setStatus('mandatory')
if mibBuilder.loadTexts: wfMcT1BertStatsBits.setDescription('Bit counter')
mibBuilder.exportSymbols("Wellfleet-MCT1-MIB", wfMcT1BertStatsConnector=wfMcT1BertStatsConnector, wfMcT1LineRxAbortFrames=wfMcT1LineRxAbortFrames, wfMcT1ConfigEntry=wfMcT1ConfigEntry, wfMcT1Dsx1SendLoopCode=wfMcT1Dsx1SendLoopCode, wfMcT1LineMadr=wfMcT1LineMadr, wfMcT1LineTxQueueLength=wfMcT1LineTxQueueLength, wfMcT1LineTxIntProcs=wfMcT1LineTxIntProcs, wfMcT1Dsx1TotalUASs=wfMcT1Dsx1TotalUASs, wfMcT1LineTxUnderflows=wfMcT1LineTxUnderflows, wfMcT1OperationMode=wfMcT1OperationMode, wfMcT1Entry=wfMcT1Entry, wfMcT1LineTxQueueEmpty=wfMcT1LineTxQueueEmpty, wfMcT1LineSlot=wfMcT1LineSlot, wfMcT1Dsx1CurrentSESs=wfMcT1Dsx1CurrentSESs, wfMcT1LineCfgRxQueueLength=wfMcT1LineCfgRxQueueLength, wfMcT1BertStatsBitErrors=wfMcT1BertStatsBitErrors, wfMcT1AnsiConnector=wfMcT1AnsiConnector, wfMcT1AnsiPRMR1Counts=wfMcT1AnsiPRMR1Counts, wfMcT1BertRestart=wfMcT1BertRestart, wfMcT1Delete=wfMcT1Delete, wfMcT1Slot=wfMcT1Slot, wfMcT1Connector=wfMcT1Connector, wfMcT1Dsx1ClearAlarmThreshold=wfMcT1Dsx1ClearAlarmThreshold, wfMcT1BertPayldLb=wfMcT1BertPayldLb, wfMcT1LineBofl=wfMcT1LineBofl, wfMcT1LineBoflTmo=wfMcT1LineBoflTmo, wfMcT1LineIFTF=wfMcT1LineIFTF, wfMcT1Dsx1TotalBPVs=wfMcT1Dsx1TotalBPVs, wfMcT1LineRestart=wfMcT1LineRestart, wfMcT1Dsx1FDLOperationMode=wfMcT1Dsx1FDLOperationMode, wfMcT1BertStatsEntry=wfMcT1BertStatsEntry, wfMcT1AnsiTable=wfMcT1AnsiTable, wfMcT1Dsx1CurrentIntervalTimer=wfMcT1Dsx1CurrentIntervalTimer, wfMcT1Dsx1LineStatus=wfMcT1Dsx1LineStatus, wfMcT1LineLine=wfMcT1LineLine, wfMcT1Dsx1IntervalSESs=wfMcT1Dsx1IntervalSESs, wfMcT1Dsx1ZeroCoding=wfMcT1Dsx1ZeroCoding, wfMcT1LineDisable=wfMcT1LineDisable, wfMcT1ModDelete=wfMcT1ModDelete, wfMcT1LineCct=wfMcT1LineCct, wfMcT1AnsiPRMSESCounts=wfMcT1AnsiPRMSESCounts, wfMcT1Dsx1TotalVITR=wfMcT1Dsx1TotalVITR, wfMcT1AnsiOOFCounts=wfMcT1AnsiOOFCounts, wfMcT1ModDisable=wfMcT1ModDisable, wfMcT1Dsx1LineType=wfMcT1Dsx1LineType, wfMcT1AnsiPRMR3Counts=wfMcT1AnsiPRMR3Counts, wfMcT1DS2282Version=wfMcT1DS2282Version, wfMcT1ConfigSlot=wfMcT1ConfigSlot, wfMcT1Dsx1SetupAlarmThreshold=wfMcT1Dsx1SetupAlarmThreshold, wfMcT1Dsx1CurrentTable=wfMcT1Dsx1CurrentTable, wfMcT1State=wfMcT1State, wfMcT1LoopbackDisable=wfMcT1LoopbackDisable, wfMcT1BertTestMode=wfMcT1BertTestMode, wfMcT1LineRxPktCorruptions=wfMcT1LineRxPktCorruptions, wfMcT1AnsiPRMESCounts=wfMcT1AnsiPRMESCounts, wfMcT1AnsiSESCounts=wfMcT1AnsiSESCounts, wfMcT1Table=wfMcT1Table, wfMcT1Dsx1TotalSESs=wfMcT1Dsx1TotalSESs, wfMcT1LineRxErrors=wfMcT1LineRxErrors, wfMcT1Mtu=wfMcT1Mtu, wfMcT1LineRxLossSyncs=wfMcT1LineRxLossSyncs, wfMcT1LineRxDescOverflows=wfMcT1LineRxDescOverflows, wfMcT1AnsiFECounts=wfMcT1AnsiFECounts, wfMcT1LineChannelAssignment=wfMcT1LineChannelAssignment, wfMcT1ModTable=wfMcT1ModTable, wfMcT1LineRateAdaption=wfMcT1LineRateAdaption, wfMcT1LineRxQueueLength=wfMcT1LineRxQueueLength, wfMcT1BertStatsSlot=wfMcT1BertStatsSlot, wfMcT1LineWanProtocol=wfMcT1LineWanProtocol, wfMcT1Dsx1LoopbackConfig=wfMcT1Dsx1LoopbackConfig, wfMcT1Dsx1IntervalNumber=wfMcT1Dsx1IntervalNumber, wfMcT1Dsx1IntervalConnector=wfMcT1Dsx1IntervalConnector, wfMcT1ModExtClockOperational=wfMcT1ModExtClockOperational, wfMcT1AnsiPRMR0Counts=wfMcT1AnsiPRMR0Counts, wfMcT1ModEntry=wfMcT1ModEntry, wfMcT1LineBoflNum=wfMcT1LineBoflNum, wfMcT1LineDelete=wfMcT1LineDelete, wfMcT1LineRxNonOctetBits=wfMcT1LineRxNonOctetBits, wfMcT1ModLoop0ClockOperational=wfMcT1ModLoop0ClockOperational, wfMcT1Dsx1CurrentSlot=wfMcT1Dsx1CurrentSlot, wfMcT1Dsx1IntervalSlot=wfMcT1Dsx1IntervalSlot, wfMcT1BertStatsTable=wfMcT1BertStatsTable, wfMcT1LineRxIntProcs=wfMcT1LineRxIntProcs, wfMcT1AnsiESCounts=wfMcT1AnsiESCounts, wfMcT1LineLineNumber=wfMcT1LineLineNumber, wfMcT1Disable=wfMcT1Disable, wfMcT1BertTestPattern=wfMcT1BertTestPattern, wfMcT1Loopback=wfMcT1Loopback, wfMcT1ModSlot=wfMcT1ModSlot, wfMcT1BertLineLb=wfMcT1BertLineLb, wfMcT1LineRxNullFrames=wfMcT1LineRxNullFrames, wfMcT1LineBoflLen=wfMcT1LineBoflLen, wfMcT1LineRxOctets=wfMcT1LineRxOctets, wfMcT1ModPrimaryClock=wfMcT1ModPrimaryClock, wfMcT1LineTurboBofl=wfMcT1LineTurboBofl, wfMcT1Dsx1IntervalUASs=wfMcT1Dsx1IntervalUASs, wfMcT1BertErrorInsert=wfMcT1BertErrorInsert, wfMcT1Dsx1IntervalESs=wfMcT1Dsx1IntervalESs, wfMcT1LineRxIFCs=wfMcT1LineRxIFCs, wfMcT1Restart=wfMcT1Restart, wfMcT1AnsiPRMR2Counts=wfMcT1AnsiPRMR2Counts, wfMcT1LineCfgTxQueueLength=wfMcT1LineCfgTxQueueLength, wfMcT1Dsx1IntervalCSSs=wfMcT1Dsx1IntervalCSSs, wfMcT1Dsx1SendFDLCode=wfMcT1Dsx1SendFDLCode, wfMcT1Dsx1CurrentBESs=wfMcT1Dsx1CurrentBESs, wfMcT1LineRxFrames=wfMcT1LineRxFrames, wfMcT1Dsx1IntervalEntry=wfMcT1Dsx1IntervalEntry, wfMcT1LineFractionalLpbk=wfMcT1LineFractionalLpbk, wfMcT1Dsx1IntervalBPVs=wfMcT1Dsx1IntervalBPVs, wfMcT1BertTxOutputLevel=wfMcT1BertTxOutputLevel, wfMcT1ModLoop1ClockOperational=wfMcT1ModLoop1ClockOperational, wfMcT1Dsx1IntervalBESs=wfMcT1Dsx1IntervalBESs, wfMcT1Dsx1TotalEntry=wfMcT1Dsx1TotalEntry, wfMcT1Dsx1CurrentEntry=wfMcT1Dsx1CurrentEntry, wfMcT1LineTxOctets=wfMcT1LineTxOctets, wfMcT1BertLineCode=wfMcT1BertLineCode, wfMcT1AnsiEntry=wfMcT1AnsiEntry, wfMcT1AnsiCRCCounts=wfMcT1AnsiCRCCounts, wfMcT1LineConnector=wfMcT1LineConnector, wfMcT1LineRxOverflows=wfMcT1LineRxOverflows, wfMcT1LineEntry=wfMcT1LineEntry, wfMcT1LineTxFrames=wfMcT1LineTxFrames, wfMcT1Dsx1TotalConnector=wfMcT1Dsx1TotalConnector, wfMcT1AnsiBPVCounts=wfMcT1AnsiBPVCounts, wfMcT1AnsiUASCounts=wfMcT1AnsiUASCounts, wfMcT1LineLackTxResources=wfMcT1LineLackTxResources, wfMcT1ModSecondaryClock=wfMcT1ModSecondaryClock, wfMcT1LineRxCRCErrors=wfMcT1LineRxCRCErrors, wfMcT1ConfigTable=wfMcT1ConfigTable, wfMcT1LineLackRxResources=wfMcT1LineLackRxResources, wfMcT1AnsiPRMECounts=wfMcT1AnsiPRMECounts, wfMcT1MunichVersion=wfMcT1MunichVersion, wfMcT1Dsx1CurrentESs=wfMcT1Dsx1CurrentESs, wfMcT1LineRxLongFrames=wfMcT1LineRxLongFrames, wfMcT1Dsx1TotalSlot=wfMcT1Dsx1TotalSlot, wfMcT1FDLTargetAddress=wfMcT1FDLTargetAddress, wfMcT1Dsx1IntervalTable=wfMcT1Dsx1IntervalTable, wfMcT1Dsx1CurrentBPVs=wfMcT1Dsx1CurrentBPVs, wfMcT1Dsx1TotalESs=wfMcT1Dsx1TotalESs, wfMcT1Dsx1CurrentUASs=wfMcT1Dsx1CurrentUASs, wfMcT1Dsx1TotalCSSs=wfMcT1Dsx1TotalCSSs, wfMcT1Dsx1TotalTable=wfMcT1Dsx1TotalTable, wfMcT1Dsx1TotalBESs=wfMcT1Dsx1TotalBESs, wfMcT1AnsiSlot=wfMcT1AnsiSlot, wfMcT1LineTable=wfMcT1LineTable, wfMcT1BertSendAlarm=wfMcT1BertSendAlarm, wfMcT1LineRxShortFrames=wfMcT1LineRxShortFrames, wfMcT1LineState=wfMcT1LineState, wfMcT1LineService=wfMcT1LineService, wfMcT1Dsx1CurrentConnector=wfMcT1Dsx1CurrentConnector, wfMcT1LineCRCSize=wfMcT1LineCRCSize, wfMcT1Dsx1CurrentCSSs=wfMcT1Dsx1CurrentCSSs, wfMcT1ModCurrentClock=wfMcT1ModCurrentClock, wfMcT1BertStatsBits=wfMcT1BertStatsBits, wfMcT1LineRxReplenMisses=wfMcT1LineRxReplenMisses, wfMcT1LineMtu=wfMcT1LineMtu, wfMcT1ModRestart=wfMcT1ModRestart, wfMcT1Dsx1SignalLevel=wfMcT1Dsx1SignalLevel, wfMcT1ConfigConnector=wfMcT1ConfigConnector, wfMcT1LineTxErrors=wfMcT1LineTxErrors)

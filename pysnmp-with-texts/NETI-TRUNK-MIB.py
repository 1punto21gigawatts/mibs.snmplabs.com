#
# PySNMP MIB module NETI-TRUNK-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/NETI-TRUNK-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:19:52 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsIntersection, ConstraintsUnion, ValueRangeConstraint, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsIntersection", "ConstraintsUnion", "ValueRangeConstraint", "ValueSizeConstraint")
netiGeneric, = mibBuilder.importSymbols("NETI-COMMON-MIB", "netiGeneric")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
ObjectIdentity, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn, MibIdentifier, Integer32, Counter64, ModuleIdentity, Unsigned32, Gauge32, Counter32, TimeTicks, IpAddress, Bits, iso = mibBuilder.importSymbols("SNMPv2-SMI", "ObjectIdentity", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "MibIdentifier", "Integer32", "Counter64", "ModuleIdentity", "Unsigned32", "Gauge32", "Counter32", "TimeTicks", "IpAddress", "Bits", "iso")
RowPointer, TimeStamp, DisplayString, TruthValue, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "RowPointer", "TimeStamp", "DisplayString", "TruthValue", "TextualConvention")
netiTrunkMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 2928, 2, 3))
netiTrunkMIB.setRevisions(('2014-03-14 08:00', '2013-08-29 16:00', '2013-01-24 15:00', '2009-08-26 15:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: netiTrunkMIB.setRevisionsDescriptions(('Extended draft. This revision is preliminary. Read-write objects have been added to give full managablity to the interfaces in the DPP-IP group. Values that limits the configuration of the local DPP-IP interfaces have been introduced in the dppipLimitsTable. Similarly, limits of the peer DPP-IP interfaces have been added in the dppipPeerLimitsTable.', 'Extended draft. This revision is preliminary. The dppipDelayVar01 object has been added to dppipEntry. All objects in the MIB are read-only.', 'Extended draft. This revision is preliminary. More objects have been added to dppipEntry to make the configuration information and status more complete. All objects in the MIB are read-only.', 'Draft. This revision is preliminary. Future revisions are likely to be incompatible with this revision.',))
if mibBuilder.loadTexts: netiTrunkMIB.setLastUpdated('201403140800Z')
if mibBuilder.loadTexts: netiTrunkMIB.setOrganization('Net Insight AB')
if mibBuilder.loadTexts: netiTrunkMIB.setContactInfo('Net Insight AB Box 42093 SE-126 14 Stockholm Sweden Tel +46-8-685 0400 info@netinsight.se')
if mibBuilder.loadTexts: netiTrunkMIB.setDescription('MIB for DTM network links (trunks). DTM trunks provide transport of DTM data between two DTM networks nodes. The MIB currently includes the DPP-IP group (neti-dppip), providing management of DPP-IP encapsulated DTM over IP/Ethernet. It includes configuration information and status.')
trunkObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1))
dppipGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1))
class FecMode(TextualConvention, Integer32):
    description = 'The mode of operation of the Forward Error Correction function (FEC). The FEC function may be not used (fecNone), used for column correction (fec1D) or used for both row and column correction (fec2D).'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("fecNone", 1), ("fec1D", 2), ("fec2D", 3))

class DppipSupport(TextualConvention, OctetString):
    description = 'Represents the support of a specific DPP-IP function: octet contents 1 major version 2 minor version Any minor version N.x includes support for any minor version M.y with major version M<N. Minor version N.n includes support for any minor version N.m with the same major version N and m<n.'
    status = 'current'
    displayHint = '1d.1d'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(2, 2)
    fixedLength = 2

dppipNumber = MibScalar((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dppipNumber.setStatus('current')
if mibBuilder.loadTexts: dppipNumber.setDescription('The number of DPP-IP interfaces (regardless of their current state) present on this system.')
dppipLastChange = MibScalar((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 2), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dppipLastChange.setStatus('current')
if mibBuilder.loadTexts: dppipLastChange.setDescription('The value of sysUpTime when status or configuration of any the objects in the dppipTable was last changed.')
dppipTable = MibTable((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 3), )
if mibBuilder.loadTexts: dppipTable.setStatus('current')
if mibBuilder.loadTexts: dppipTable.setDescription("A list of DPP-IP interface entries. The number of entries is given by the value of dppipNumber. The following objects need to be written simultaneously, i.e. as a single write operation, while dppipAdminStatus is `up': dppipTxSlots, dppipMtu, dppipTxFecMode, dppipTxFecRows, dppipTxFecCols ")
dppipEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 3, 1), ).setIndexNames((0, "NETI-TRUNK-MIB", "dppipIndex"))
if mibBuilder.loadTexts: dppipEntry.setStatus('current')
if mibBuilder.loadTexts: dppipEntry.setDescription('A DPP-IP interface entry containing objects at the subnetwork layer and below for a particular interface.')
dppipIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 3, 1, 1), Unsigned32())
if mibBuilder.loadTexts: dppipIndex.setStatus('current')
if mibBuilder.loadTexts: dppipIndex.setDescription("A value greater than zero that is unique for each DPP-IP interface. The value for each DPP-IP interface must remain constant at least from one re-initialization of the entity's network management system to the next re-initialization.")
dppipName = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 3, 1, 2), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dppipName.setStatus('current')
if mibBuilder.loadTexts: dppipName.setDescription('The textual name of the interface. The value of this object should be the name of the DPP-IP interface as assigned by the local device.')
dppipAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 3, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dppipAddress.setStatus('current')
if mibBuilder.loadTexts: dppipAddress.setDescription('The IPv4 address of the DPP-IP interface.')
dppipNetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 3, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dppipNetMask.setStatus('current')
if mibBuilder.loadTexts: dppipNetMask.setDescription('The subnet mask associated with the IP address of DPP-IP interface. The value of the mask is an IP address with all the network bits set to 1 and all the hosts bits set to 0.')
dppipDefaultGateway = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 3, 1, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dppipDefaultGateway.setStatus('current')
if mibBuilder.loadTexts: dppipDefaultGateway.setDescription('The IPv4 address of the default gateway. Packets addressed to a destination outside the subnet of the DPP-IP interface are by default routed to this gateway. ')
dppipPeerAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 3, 1, 6), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dppipPeerAddress.setStatus('current')
if mibBuilder.loadTexts: dppipPeerAddress.setDescription('The IPv4 address of the peer DPP-IP interface at the remote end of the DTM trunk.')
dppipTxSlots = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 3, 1, 7), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dppipTxSlots.setStatus('current')
if mibBuilder.loadTexts: dppipTxSlots.setDescription("The DPP-IP interface's current transmit side capacity in slots per DTM frame.")
dppipTxUsedCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 3, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dppipTxUsedCapacity.setStatus('current')
if mibBuilder.loadTexts: dppipTxUsedCapacity.setDescription('An estimate of the transmit side physical layer capacity used by the DPP-IP interface in bits per second. It represents a minimum required capacity along the network path.')
dppipRxSlots = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 3, 1, 9), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dppipRxSlots.setStatus('current')
if mibBuilder.loadTexts: dppipRxSlots.setDescription("The DPP-IP interface's current receive side capacity in slots per DTM frame.")
dppipRxUsedCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 3, 1, 10), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dppipRxUsedCapacity.setStatus('current')
if mibBuilder.loadTexts: dppipRxUsedCapacity.setDescription('An estimate of the receive side physical layer capacity used by the DPP-IP interface in bits per second. It represents a minimum required capacity along the network path.')
dppipDelayVariation = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 3, 1, 11), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dppipDelayVariation.setStatus('current')
if mibBuilder.loadTexts: dppipDelayVariation.setDescription('The RMS (i.e. standard deviation) value of the DPP-IP path delay variation in ns. This value represents a momentary snapshot of the delay variation.')
dppipOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 3, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3), ("unknown", 4), ("dormant", 5), ("notPresent", 6), ("lowerLayerDown", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dppipOperStatus.setStatus('current')
if mibBuilder.loadTexts: dppipOperStatus.setDescription('The current operational state of the interface. The testing(3) state indicates that no operational frames can be passed.')
dppipFailure = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 3, 1, 13), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dppipFailure.setStatus('current')
if mibBuilder.loadTexts: dppipFailure.setDescription('A textual string describing a fault status on the DPP-IP interface. The object presents an empty string if there are no faults on the interface.')
dppipReceivedFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 3, 1, 14), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dppipReceivedFrames.setStatus('current')
if mibBuilder.loadTexts: dppipReceivedFrames.setDescription('The total number of DPP-IP frames that have been received.')
dppipMissingFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 3, 1, 15), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dppipMissingFrames.setStatus('current')
if mibBuilder.loadTexts: dppipMissingFrames.setDescription('The number of DPP-IP frames that were missing in the frame sequence, i.e. the expected sequence numbers were not found in the DPP-IP framing buffer.')
dppipDeliveredFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 3, 1, 16), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dppipDeliveredFrames.setStatus('current')
if mibBuilder.loadTexts: dppipDeliveredFrames.setDescription('The total number of DPP-IP data frames that have been delivered to the DTM interface.')
dppipDroppedFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 3, 1, 17), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dppipDroppedFrames.setStatus('current')
if mibBuilder.loadTexts: dppipDroppedFrames.setDescription('The number of DPP-IP frames that have been received and have not been processed since the interface was unable to align them to the DPP-IP frame sequence.')
dppipDuplicateFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 3, 1, 18), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dppipDuplicateFrames.setStatus('current')
if mibBuilder.loadTexts: dppipDuplicateFrames.setDescription('The number of DPP-IP frames that were received with a sequence number of an already processed DPP-IP frame.')
dppipReorderedFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 3, 1, 19), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dppipReorderedFrames.setStatus('current')
if mibBuilder.loadTexts: dppipReorderedFrames.setDescription('The number of DPP-IP frames that were received out of order, but could still be aligned to the DPP-IP frame sequence.')
dppipLostFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 3, 1, 20), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dppipLostFrames.setStatus('current')
if mibBuilder.loadTexts: dppipLostFrames.setDescription('The number of missing DPP-IP data frames that could not be delivered to the DTM interface.')
dppipRecoveredFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 3, 1, 21), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dppipRecoveredFrames.setStatus('current')
if mibBuilder.loadTexts: dppipRecoveredFrames.setDescription('The number of missing DPP-IP data frames that were recovered by the FEC procedure.')
dppipSentFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 3, 1, 22), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dppipSentFrames.setStatus('current')
if mibBuilder.loadTexts: dppipSentFrames.setDescription('The total number of DPP-IP frames that have been sent.')
dppipDelayVarPtp = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 3, 1, 23), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dppipDelayVarPtp.setStatus('current')
if mibBuilder.loadTexts: dppipDelayVarPtp.setDescription('The point-to-point value of the DPP-IP path delay variation in nanoseconds. The special value 0 means that the measurement is incomplete')
dppipDelayVar999 = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 3, 1, 24), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dppipDelayVar999.setStatus('current')
if mibBuilder.loadTexts: dppipDelayVar999.setDescription('The 99.9 percentile value of the DPP-IP path delay variation given in nanoseconds. The special value 0 means that the measurement is incomplete.')
dppipAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 3, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dppipAdminStatus.setStatus('current')
if mibBuilder.loadTexts: dppipAdminStatus.setDescription('The desired state of the interface.')
dppipVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 3, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dppipVlan.setStatus('current')
if mibBuilder.loadTexts: dppipVlan.setDescription('The VLAN identity associated to the DPP-IP interface. The value 0 indicates that the DPP-IP interface does not belong to a VLAN. The value -1 indicates that Ethernet frames from the DPP-IP interface are not tagged. ')
dppipDelayVar01 = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 3, 1, 27), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dppipDelayVar01.setStatus('current')
if mibBuilder.loadTexts: dppipDelayVar01.setDescription('The 0.1 percentile value of the DPP-IP path delay variation given in nanoseconds. The special value 0 means that the measurement is incomplete.')
dppipPrio = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 3, 1, 28), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dppipPrio.setStatus('current')
if mibBuilder.loadTexts: dppipPrio.setDescription('The Ethernet priority for frames sent from the DPP-IP interface. Ignored if frames are untagged (i.e. dppipVlan is -1).')
dppipPhysIf = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 3, 1, 29), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dppipPhysIf.setStatus('current')
if mibBuilder.loadTexts: dppipPhysIf.setDescription('A reference to an object representing the physical interface that supports the DPP-IP interface. The special value .0.0 is used, when no such reference is available.')
dppipMtu = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 3, 1, 30), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(64, 1500))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dppipMtu.setStatus('current')
if mibBuilder.loadTexts: dppipMtu.setDescription('The Maximum Transmission Unit of the DPP-IP interface, i.e. the maximum size of the DPP-IP payload, including IP header, UDP header and DPP-IP header.')
dppipTtl = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 3, 1, 31), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 127))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dppipTtl.setStatus('current')
if mibBuilder.loadTexts: dppipTtl.setDescription('The Time To Live of frames sent at the DPP-IP interface. This value is set in the IP header.')
dppipDscp = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 3, 1, 32), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 63))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dppipDscp.setStatus('current')
if mibBuilder.loadTexts: dppipDscp.setDescription('The Differential Services Coding Point of frames sent at the DPP-IP interface. This value is set in the IP header.')
dppipRxSlotsPerFrame = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 3, 1, 33), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dppipRxSlotsPerFrame.setStatus('current')
if mibBuilder.loadTexts: dppipRxSlotsPerFrame.setDescription('Number of DTM slots per received DPP-IP data frame.')
dppipAvailTxSlots = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 3, 1, 34), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dppipAvailTxSlots.setStatus('current')
if mibBuilder.loadTexts: dppipAvailTxSlots.setDescription('The maximum transmit slot rate (slots/frame) that can be allocated at the DTM switch.')
dppipAvailRxSlots = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 3, 1, 35), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dppipAvailRxSlots.setStatus('current')
if mibBuilder.loadTexts: dppipAvailRxSlots.setDescription('The maximum receive slot rate (slots/frame) that can be allocated at the DTM switch.')
dppipMinUsageRatio = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 3, 1, 36), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dppipMinUsageRatio.setStatus('current')
if mibBuilder.loadTexts: dppipMinUsageRatio.setDescription('The minimum allowed usage ratio (used slots/configured slots) in per-mille, when dynamic trunk functionality is used. 1000 is default and indicates that the Dynamic Trunk function is disabled. Requires Dynamic Trunk function support equal to 1.1 or higher.')
dppipTxTranspSlots = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 3, 1, 37), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dppipTxTranspSlots.setStatus('current')
if mibBuilder.loadTexts: dppipTxTranspSlots.setDescription("The DPP-IP interface's current transmit side capacity in slots per DTM frame that is actually transported over the. When Dynamic Trunk functionality is disabled this is equal to dppipTxSlots. When Dynamic Trunk functionality is enabled this is less or equal to dppipTxSlots, since slots that are not used by any channel need not be transported. Requires Dynamic Trunk function support equal to 1.1 or higher.")
dppipRxTranspSlots = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 3, 1, 38), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dppipRxTranspSlots.setStatus('current')
if mibBuilder.loadTexts: dppipRxTranspSlots.setDescription("The DPP-IP interface's current receive side capacity in slots per DTM frame that is actually transported. When Dynamic Trunk functionality is disabled this is equal to dppipRxSlots. When Dynamic Trunk functionality is enabled this is less or equal to dppipRxSlots, since slots that are not used by any channel need not be transported. Requires Dynamic Trunk function support equal to 1.1 or higher.")
dppipNomDTDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 3, 1, 39), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dppipNomDTDelay.setStatus('current')
if mibBuilder.loadTexts: dppipNomDTDelay.setDescription('The nominal extra delay in ns when the Dynamic Trunk function is enabled. Requires Dynamic Trunk function support equal to 1.1 or higher.')
dppipTxFecMode = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 3, 1, 40), FecMode()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dppipTxFecMode.setStatus('current')
if mibBuilder.loadTexts: dppipTxFecMode.setDescription("The DPP-IP interface's current mode of operation of the transmit side Forward Error Correction function (FEC). The FEC function may be not used (fecNone), used for column correction (fec1D) or used for both row and column correction (fec2D).")
dppipTxFecRows = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 3, 1, 41), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dppipTxFecRows.setStatus('current')
if mibBuilder.loadTexts: dppipTxFecRows.setDescription("The DPP-IP interface's current number of data rows in the transmit side Forward Error Correction (FEC) matrix. This object is not applicable when dppipTxFecMode is fecNone.")
dppipTxFecCols = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 3, 1, 42), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dppipTxFecCols.setStatus('current')
if mibBuilder.loadTexts: dppipTxFecCols.setDescription("The DPP-IP interface's current number of data columns in the transmit side Forward Error Correction (FEC) matrix. This object is not applicable when dppipTxFecMode is fecNone.")
dppipRxFecMode = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 3, 1, 43), FecMode()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dppipRxFecMode.setStatus('current')
if mibBuilder.loadTexts: dppipRxFecMode.setDescription("The DPP-IP interface's current mode of operation of the receive side Forward Error Correction function (FEC). The FEC function may be not used (fecNone), used for column correction (fec1D) or used for both row and column correction (fec2D).")
dppipRxFecRows = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 3, 1, 44), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dppipRxFecRows.setStatus('current')
if mibBuilder.loadTexts: dppipRxFecRows.setDescription("The DPP-IP interface's current number of data rows in the receive side Forward Error Correction (FEC) matrix. This object is not applicable when dppipRxFecMode is fecNone.")
dppipRxFecCols = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 3, 1, 45), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dppipRxFecCols.setStatus('current')
if mibBuilder.loadTexts: dppipRxFecCols.setDescription("The DPP-IP interface's current number of data columns in the receive side Forward Error Correction (FEC) matrix. This object is not applicable when dppipRxFecMode is fecNone.")
dppipCntControl = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 3, 1, 46), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("reset", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dppipCntControl.setStatus('current')
if mibBuilder.loadTexts: dppipCntControl.setDescription("Controls the statistics counter monitoring. The statistics monitoring is restarted and all counters set to 0, by writing `reset' to this object.")
dppipSuppressAlarms = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 3, 1, 47), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dppipSuppressAlarms.setStatus('current')
if mibBuilder.loadTexts: dppipSuppressAlarms.setDescription("Suppression control for alarms from the DPP-IP interface. When set to `true', all alarms are suppressed.")
dppipSigFailFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 3, 1, 48), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dppipSigFailFilter.setStatus('current')
if mibBuilder.loadTexts: dppipSigFailFilter.setDescription("Signal fail filter hold-off time in milliseconds. Trail Signal Fail conditions must be persistent during the hold-off time, before operStatus is changed from `up' to `down'.")
dppipDegThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 3, 1, 49), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 8000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dppipDegThreshold.setStatus('current')
if mibBuilder.loadTexts: dppipDegThreshold.setDescription('The detection threshold for DEG alarm. A bad second is declared when the number of errored blocks is equal to or greater than the threshold, otherwise a good second is declared. Default is 1200')
dppipDegPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 3, 1, 50), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(2, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dppipDegPeriod.setStatus('current')
if mibBuilder.loadTexts: dppipDegPeriod.setDescription('The persistence time for detection of DEG alarm as the number of consecutive seconds with changed status (bad or good) before the alarm is set or cleared.')
dppipTolJitter = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 3, 1, 51), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dppipTolJitter.setStatus('current')
if mibBuilder.loadTexts: dppipTolJitter.setDescription('The tolerated jitter and wander of the DPP-IP interface given in microseconds.')
dppipLimitsTable = MibTable((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 4), )
if mibBuilder.loadTexts: dppipLimitsTable.setStatus('current')
if mibBuilder.loadTexts: dppipLimitsTable.setDescription('A list of DPP-IP interface limits entries. The number of entries is given by the value of dppipNumber.')
dppipLimitsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 4, 1), ).setIndexNames((0, "NETI-TRUNK-MIB", "dppipIndex"))
if mibBuilder.loadTexts: dppipLimitsEntry.setStatus('current')
if mibBuilder.loadTexts: dppipLimitsEntry.setDescription('A DPP-IP interface limits entry containing limits for a particular interface.')
dppipMaxFecMode = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 4, 1, 1), FecMode()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dppipMaxFecMode.setStatus('current')
if mibBuilder.loadTexts: dppipMaxFecMode.setDescription("The DPP-IP interface's maximum mode of operation of the Forward Error Correction function (FEC). The FEC function may be not used (fecNone), used for column correction (fec1D) or used for both row and column correction (fec2D).")
dppipMaxFecRows = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 4, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dppipMaxFecRows.setStatus('current')
if mibBuilder.loadTexts: dppipMaxFecRows.setDescription("The DPP-IP interface's maximum number of data rows in the transmit side Forward Error Correction (FEC) matrix.")
dppipMinFecRows = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 4, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dppipMinFecRows.setStatus('current')
if mibBuilder.loadTexts: dppipMinFecRows.setDescription("The DPP-IP interface's minimum number of data rows in the transmit side Forward Error Correction (FEC) matrix.")
dppipMaxFecCols = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 4, 1, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dppipMaxFecCols.setStatus('current')
if mibBuilder.loadTexts: dppipMaxFecCols.setDescription("The DPP-IP interface's maximum number of data columns in the transmit side Forward Error Correction (FEC) matrix.")
dppipMinFecCols = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 4, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dppipMinFecCols.setStatus('current')
if mibBuilder.loadTexts: dppipMinFecCols.setDescription("The DPP-IP interface's minimum number of data columns in the transmit side Forward Error Correction (FEC) matrix.")
dppipMaxFecElems = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 4, 1, 6), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dppipMaxFecElems.setStatus('current')
if mibBuilder.loadTexts: dppipMaxFecElems.setDescription("The DPP-IP interface's maximum number of data elements in the transmit side Forward Error Correction (FEC) matrix.")
dppipMaxTxSlots = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 4, 1, 7), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dppipMaxTxSlots.setStatus('current')
if mibBuilder.loadTexts: dppipMaxTxSlots.setDescription('The maximum number of slots per DTM frame that can be allocated at the DPP-IP transmit interface.')
dppipMinTxSlots = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 4, 1, 8), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dppipMinTxSlots.setStatus('current')
if mibBuilder.loadTexts: dppipMinTxSlots.setDescription('The minimum number of slots per DTM frame that can be allocated at the DPP-IP transmit interface.')
dppipMaxTolJitter = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 4, 1, 9), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dppipMaxTolJitter.setStatus('current')
if mibBuilder.loadTexts: dppipMaxTolJitter.setDescription('The maximum tolerated jitter that can be configured expressed in units of DPP-IP inter-frame intervals. The DPP-IP inter-frame interval in microseconds is: dppipRxSlotsPerFrame * 125 / dppipRxSlots.')
dppipMinTolJitter = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 4, 1, 10), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dppipMinTolJitter.setStatus('current')
if mibBuilder.loadTexts: dppipMinTolJitter.setDescription('The minimum tolerated jitter that can be configured expressed in units of DPP-IP inter-frame intervals. The DPP-IP inter-frame interval in microseconds is: dppipRxSlotsPerFrame * 125 / dppipRxSlots.')
dppipDTSupport = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 4, 1, 11), DppipSupport()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dppipDTSupport.setStatus('current')
if mibBuilder.loadTexts: dppipDTSupport.setDescription("The local interface's maximum level of support for the Dynamic Trunk function.")
dppipTTSupport = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 4, 1, 12), DppipSupport()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dppipTTSupport.setStatus('current')
if mibBuilder.loadTexts: dppipTTSupport.setDescription("The local interface's maximum level of support for the Time Transfer function.")
dppipPeerLimitsTable = MibTable((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 5), )
if mibBuilder.loadTexts: dppipPeerLimitsTable.setStatus('current')
if mibBuilder.loadTexts: dppipPeerLimitsTable.setDescription('A list of DPP-IP interface limits entries. The number of entries is given by the value of dppipNumber.')
dppipPeerLimitsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 5, 1), ).setIndexNames((0, "NETI-TRUNK-MIB", "dppipIndex"))
if mibBuilder.loadTexts: dppipPeerLimitsEntry.setStatus('current')
if mibBuilder.loadTexts: dppipPeerLimitsEntry.setDescription('A DPP-IP interface peer limits entry containing limits for the peer of a particular interface.')
dppipPeerMaxFecMode = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 5, 1, 1), FecMode()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dppipPeerMaxFecMode.setStatus('current')
if mibBuilder.loadTexts: dppipPeerMaxFecMode.setDescription("The peer interface's maximum mode of operation of the Forward Error Correction function (FEC). The FEC function may be not used (fecNone), used for column correction (fec1D) or used for both row and column correction (fec2D).")
dppipPeerMaxFecRows = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 5, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dppipPeerMaxFecRows.setStatus('current')
if mibBuilder.loadTexts: dppipPeerMaxFecRows.setDescription("The peer interface's maximum number of data rows in the receive side Forward Error Correction (FEC) matrix.")
dppipPeerMinFecRows = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 5, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dppipPeerMinFecRows.setStatus('current')
if mibBuilder.loadTexts: dppipPeerMinFecRows.setDescription("The peer interface's minimum number of data rows in the receive side Forward Error Correction (FEC) matrix.")
dppipPeerMaxFecCols = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 5, 1, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dppipPeerMaxFecCols.setStatus('current')
if mibBuilder.loadTexts: dppipPeerMaxFecCols.setDescription("The peer interface's maximum number of data columns in the receive side Forward Error Correction (FEC) matrix.")
dppipPeerMinFecCols = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 5, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dppipPeerMinFecCols.setStatus('current')
if mibBuilder.loadTexts: dppipPeerMinFecCols.setDescription("The peer interface's minimum number of data columns in the receive side Forward Error Correction (FEC) matrix.")
dppipPeerMaxFecElems = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 5, 1, 6), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dppipPeerMaxFecElems.setStatus('current')
if mibBuilder.loadTexts: dppipPeerMaxFecElems.setDescription("The peer interface's maximum number of data elements in the receive side Forward Error Correction (FEC) matrix.")
dppipPeerMaxRxSlots = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 5, 1, 7), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dppipPeerMaxRxSlots.setStatus('current')
if mibBuilder.loadTexts: dppipPeerMaxRxSlots.setDescription('The maximum number of slots per DTM frame that can be allocated at the receive interface in the peer.')
dppipPeerMinRxSlots = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 5, 1, 8), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dppipPeerMinRxSlots.setStatus('current')
if mibBuilder.loadTexts: dppipPeerMinRxSlots.setDescription('The minimum number of slots per DTM frame that can be allocated at the DPP-IP receive interface of the peer.')
dppipPeerDTSupport = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 5, 1, 9), DppipSupport()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dppipPeerDTSupport.setStatus('current')
if mibBuilder.loadTexts: dppipPeerDTSupport.setDescription("The peer interface's maximum level of support for the Dynamic Trunk function.")
dppipPeerTTSupport = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 2, 3, 1, 1, 5, 1, 10), DppipSupport()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dppipPeerTTSupport.setStatus('current')
if mibBuilder.loadTexts: dppipPeerTTSupport.setDescription("The peer interface's maximum level of support for the Time Transfer function.")
mibBuilder.exportSymbols("NETI-TRUNK-MIB", dppipMaxFecMode=dppipMaxFecMode, dppipDelayVarPtp=dppipDelayVarPtp, dppipEntry=dppipEntry, dppipReorderedFrames=dppipReorderedFrames, dppipSuppressAlarms=dppipSuppressAlarms, dppipPeerMinFecRows=dppipPeerMinFecRows, dppipAvailTxSlots=dppipAvailTxSlots, dppipAvailRxSlots=dppipAvailRxSlots, dppipMinUsageRatio=dppipMinUsageRatio, dppipPeerMinFecCols=dppipPeerMinFecCols, dppipRxTranspSlots=dppipRxTranspSlots, dppipPeerAddress=dppipPeerAddress, dppipFailure=dppipFailure, dppipReceivedFrames=dppipReceivedFrames, dppipNomDTDelay=dppipNomDTDelay, dppipDelayVar999=dppipDelayVar999, dppipPeerLimitsTable=dppipPeerLimitsTable, dppipRxUsedCapacity=dppipRxUsedCapacity, dppipVlan=dppipVlan, dppipPeerLimitsEntry=dppipPeerLimitsEntry, dppipDegThreshold=dppipDegThreshold, dppipRxFecRows=dppipRxFecRows, dppipPeerDTSupport=dppipPeerDTSupport, dppipDefaultGateway=dppipDefaultGateway, DppipSupport=DppipSupport, dppipPeerMaxFecCols=dppipPeerMaxFecCols, dppipMinTolJitter=dppipMinTolJitter, dppipSentFrames=dppipSentFrames, dppipRxSlots=dppipRxSlots, dppipMinTxSlots=dppipMinTxSlots, dppipDelayVar01=dppipDelayVar01, dppipMaxFecElems=dppipMaxFecElems, dppipTolJitter=dppipTolJitter, dppipRxFecMode=dppipRxFecMode, dppipTxTranspSlots=dppipTxTranspSlots, dppipPeerMinRxSlots=dppipPeerMinRxSlots, dppipMtu=dppipMtu, dppipMinFecRows=dppipMinFecRows, dppipDscp=dppipDscp, dppipCntControl=dppipCntControl, dppipMinFecCols=dppipMinFecCols, dppipPeerMaxFecElems=dppipPeerMaxFecElems, dppipLimitsEntry=dppipLimitsEntry, dppipGroup=dppipGroup, dppipTable=dppipTable, dppipAdminStatus=dppipAdminStatus, dppipPeerMaxFecMode=dppipPeerMaxFecMode, trunkObjects=trunkObjects, dppipNumber=dppipNumber, dppipSigFailFilter=dppipSigFailFilter, dppipTtl=dppipTtl, dppipMissingFrames=dppipMissingFrames, dppipName=dppipName, dppipTxFecMode=dppipTxFecMode, dppipTxSlots=dppipTxSlots, dppipOperStatus=dppipOperStatus, dppipAddress=dppipAddress, dppipDegPeriod=dppipDegPeriod, dppipPeerMaxRxSlots=dppipPeerMaxRxSlots, dppipDelayVariation=dppipDelayVariation, dppipPeerTTSupport=dppipPeerTTSupport, dppipTxFecCols=dppipTxFecCols, netiTrunkMIB=netiTrunkMIB, dppipTTSupport=dppipTTSupport, dppipDTSupport=dppipDTSupport, dppipPrio=dppipPrio, dppipIndex=dppipIndex, dppipDuplicateFrames=dppipDuplicateFrames, dppipMaxTolJitter=dppipMaxTolJitter, dppipMaxFecRows=dppipMaxFecRows, dppipMaxFecCols=dppipMaxFecCols, dppipLimitsTable=dppipLimitsTable, dppipDeliveredFrames=dppipDeliveredFrames, dppipRecoveredFrames=dppipRecoveredFrames, PYSNMP_MODULE_ID=netiTrunkMIB, dppipPeerMaxFecRows=dppipPeerMaxFecRows, dppipRxSlotsPerFrame=dppipRxSlotsPerFrame, dppipRxFecCols=dppipRxFecCols, dppipLostFrames=dppipLostFrames, FecMode=FecMode, dppipLastChange=dppipLastChange, dppipTxFecRows=dppipTxFecRows, dppipMaxTxSlots=dppipMaxTxSlots, dppipTxUsedCapacity=dppipTxUsedCapacity, dppipDroppedFrames=dppipDroppedFrames, dppipNetMask=dppipNetMask, dppipPhysIf=dppipPhysIf)

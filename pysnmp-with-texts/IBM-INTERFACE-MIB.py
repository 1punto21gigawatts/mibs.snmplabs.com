#
# PySNMP MIB module IBM-INTERFACE-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/IBM-INTERFACE-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:51:02 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint, ConstraintsIntersection, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint", "ConstraintsIntersection", "ConstraintsUnion")
ifIndex, = mibBuilder.importSymbols("IF-MIB", "ifIndex")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
enterprises, ObjectIdentity, Gauge32, iso, MibIdentifier, Integer32, ModuleIdentity, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn, Unsigned32, TimeTicks, Bits, Counter32, Counter64, IpAddress = mibBuilder.importSymbols("SNMPv2-SMI", "enterprises", "ObjectIdentity", "Gauge32", "iso", "MibIdentifier", "Integer32", "ModuleIdentity", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Unsigned32", "TimeTicks", "Bits", "Counter32", "Counter64", "IpAddress")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
ibmIROCroutinginterface = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 17))
ibminterfaceClearTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 17, 1), )
if mibBuilder.loadTexts: ibminterfaceClearTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibminterfaceClearTable.setDescription('A table allowing interface counters to be cleared.')
ibminterfaceClearEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 17, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: ibminterfaceClearEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibminterfaceClearEntry.setDescription('Entry identifying a particular interface whose counters are to be cleared.')
ibminterfaceClearInOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 17, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("noaction", 0), ("clear", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibminterfaceClearInOctets.setStatus('mandatory')
if mibBuilder.loadTexts: ibminterfaceClearInOctets.setDescription('When SET to a value of clear(1), the counter of bytes received over this interface is reset. When READ, this object always returns a value of noaction(0), since this object is intended as a trigger, rather than providing information.')
ibminterfaceClearInUcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 17, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("noaction", 0), ("clear", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibminterfaceClearInUcastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: ibminterfaceClearInUcastPkts.setDescription('When SET to a value of clear(1), the counter of unicast packets received over this interface is reset. When READ, this object always returns a value of noaction(0), since this object is intended as a trigger, rather than providing information.')
ibminterfaceClearInMulticastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 17, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("noaction", 0), ("clear", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibminterfaceClearInMulticastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: ibminterfaceClearInMulticastPkts.setDescription('When SET to a value of clear(1), the counter of multicast packets received over this interface is reset. When READ, this object always returns a value of noaction(0), since this object is intended as a trigger, rather than providing information.')
ibminterfaceClearInErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 17, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("noaction", 0), ("clear", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibminterfaceClearInErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ibminterfaceClearInErrors.setDescription('When SET to a value of clear(1), the counters for all types of input errors are reset. When READ, this object always returns a value of noaction(0), since this object is intended as a trigger, rather than providing information.')
ibminterfaceClearInAll = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 17, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("noaction", 0), ("clear", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibminterfaceClearInAll.setStatus('mandatory')
if mibBuilder.loadTexts: ibminterfaceClearInAll.setDescription('When SET to a value of clear(1), the counters for all input counters (byte, packet, error) are reset. When READ, this object always returns a value of noaction(0), since this object is intended as a trigger, rather than providing information.')
ibminterfaceClearOutOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 17, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("noaction", 0), ("clear", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibminterfaceClearOutOctets.setStatus('mandatory')
if mibBuilder.loadTexts: ibminterfaceClearOutOctets.setDescription('When SET to a value of clear(1), the counter of bytes sent over this interface is reset. When READ, this object always returns a value of noaction(0), since this object is intended as a trigger, rather than providing information.')
ibminterfaceClearOutUcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 17, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("noaction", 0), ("clear", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibminterfaceClearOutUcastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: ibminterfaceClearOutUcastPkts.setDescription('When SET to a value of clear(1), the counter of unicast packets sent over this interface is reset. When READ, this object always returns a value of noaction(0), since this object is intended as a trigger, rather than providing information.')
ibminterfaceClearOutMulticastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 17, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("noaction", 0), ("clear", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibminterfaceClearOutMulticastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: ibminterfaceClearOutMulticastPkts.setDescription('When SET to a value of clear(1), the counter of multicast packets sent over this interface is reset. When READ, this object always returns a value of noaction(0), since this object is intended as a trigger, rather than providing information.')
ibminterfaceClearOutErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 17, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("noaction", 0), ("clear", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibminterfaceClearOutErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ibminterfaceClearOutErrors.setDescription('When SET to a value of clear(1), the counters for all types of output errors are reset. When READ, this object always returns a value of noaction(0), since this object is intended as a trigger, rather than providing information.')
ibminterfaceClearOutAll = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 17, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("noaction", 0), ("clear", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibminterfaceClearOutAll.setStatus('mandatory')
if mibBuilder.loadTexts: ibminterfaceClearOutAll.setDescription('When SET to a value of clear(1), the counters for all output counters (byte, packet, error) are reset. When READ, this object always returns a value of noaction(0), since this object is intended as a trigger, rather than providing information.')
ibminterfaceClearMaintTest = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 17, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("noaction", 0), ("clear", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibminterfaceClearMaintTest.setStatus('mandatory')
if mibBuilder.loadTexts: ibminterfaceClearMaintTest.setDescription('When SET to a value of clear(1), the counters for self test pass, self test fail and maintenance fail are reset. When READ, this object always returns a value of noaction(0), since this object is intended as a trigger, rather than providing information.')
ibminterfaceClearDeviceSpecific = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 17, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("noaction", 0), ("clear", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibminterfaceClearDeviceSpecific.setStatus('mandatory')
if mibBuilder.loadTexts: ibminterfaceClearDeviceSpecific.setDescription('When SET to a value of clear(1), all the device specific counters are reset. For example, for an Ethernet interface, all the counters provided in the dot3StatsTable are reset. When READ, this object always returns a value of noaction(0), since this object is intended as a trigger, rather than providing information.')
ibminterfaceClearAll = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 17, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("noaction", 0), ("clear", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibminterfaceClearAll.setStatus('mandatory')
if mibBuilder.loadTexts: ibminterfaceClearAll.setDescription('When SET to a value of clear(1), all the reset actions performed by the MIB objects defined above are executed at once. This action has the same behavior as executing the CLEAR command from the T5 console prompt (+). When READ, this object always returns a value of noaction(0), since this object is intended as a trigger, rather than providing information.')
mibBuilder.exportSymbols("IBM-INTERFACE-MIB", ibminterfaceClearInAll=ibminterfaceClearInAll, ibminterfaceClearTable=ibminterfaceClearTable, ibminterfaceClearEntry=ibminterfaceClearEntry, ibminterfaceClearInMulticastPkts=ibminterfaceClearInMulticastPkts, ibminterfaceClearInErrors=ibminterfaceClearInErrors, ibminterfaceClearOutOctets=ibminterfaceClearOutOctets, ibmIROCroutinginterface=ibmIROCroutinginterface, ibminterfaceClearInOctets=ibminterfaceClearInOctets, ibminterfaceClearOutMulticastPkts=ibminterfaceClearOutMulticastPkts, ibminterfaceClearMaintTest=ibminterfaceClearMaintTest, ibminterfaceClearOutUcastPkts=ibminterfaceClearOutUcastPkts, ibminterfaceClearOutErrors=ibminterfaceClearOutErrors, ibminterfaceClearOutAll=ibminterfaceClearOutAll, ibminterfaceClearInUcastPkts=ibminterfaceClearInUcastPkts, ibminterfaceClearAll=ibminterfaceClearAll, ibminterfaceClearDeviceSpecific=ibminterfaceClearDeviceSpecific)

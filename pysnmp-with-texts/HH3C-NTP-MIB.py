#
# PySNMP MIB module HH3C-NTP-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/HH3C-NTP-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:28:50 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueRangeConstraint, ConstraintsIntersection, ValueSizeConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueRangeConstraint", "ConstraintsIntersection", "ValueSizeConstraint", "ConstraintsUnion")
hh3cRhw, = mibBuilder.importSymbols("HH3C-OID-MIB", "hh3cRhw")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Unsigned32, ObjectIdentity, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, iso, TimeTicks, IpAddress, Counter32, Gauge32, ModuleIdentity, NotificationType, Integer32, Bits, Counter64 = mibBuilder.importSymbols("SNMPv2-SMI", "Unsigned32", "ObjectIdentity", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "iso", "TimeTicks", "IpAddress", "Counter32", "Gauge32", "ModuleIdentity", "NotificationType", "Integer32", "Bits", "Counter64")
TextualConvention, RowStatus, DisplayString, TruthValue = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "RowStatus", "DisplayString", "TruthValue")
hh3cNTP = ModuleIdentity((1, 3, 6, 1, 4, 1, 25506, 8, 22))
hh3cNTP.setRevisions(('2003-03-15 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: hh3cNTP.setRevisionsDescriptions(('The initial revision of this MIB module.',))
if mibBuilder.loadTexts: hh3cNTP.setLastUpdated('200303150000Z')
if mibBuilder.loadTexts: hh3cNTP.setOrganization('Hangzhou H3C Tech. Co., Ltd.')
if mibBuilder.loadTexts: hh3cNTP.setContactInfo('Platform Team Hangzhou H3C Tech. Co., Ltd. Hai-Dian District Beijing P.R. China http://www.h3c.com Zip:100085 ')
if mibBuilder.loadTexts: hh3cNTP.setDescription('This MIB provides mechanisms to monitor a NTP server.')
hh3cNTPSystemMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 8, 22, 1))
hh3cNTPSystemMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 8, 22, 1, 1))
hh3cNTPSysLeap = MibScalar((1, 3, 6, 1, 4, 1, 25506, 8, 22, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("noWarning", 0), ("addSecond", 1), ("subtractSecond", 2), ("alarm", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cNTPSysLeap.setStatus('current')
if mibBuilder.loadTexts: hh3cNTPSysLeap.setDescription('Leap Indicator (LI): This is a two-bit code warning of an impending leap second to be inserted/deleted in the last minute of the current day, with bit 0 and bit 1, respectively, coded as follows: 00, no warning 01, last minute has 61 seconds 10, last minute has 59 seconds) 11, alarm condition (clock not synchronized).')
hh3cNTPSysStratum = MibScalar((1, 3, 6, 1, 4, 1, 25506, 8, 22, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cNTPSysStratum.setStatus('current')
if mibBuilder.loadTexts: hh3cNTPSysStratum.setDescription('This is an eight-bit integer indicating the stratum level of the local clock, with values defined as follows: 0, unspecified 1, primary reference (e.g.,, radio clock) 2-255, secondary reference (via NTP)')
hh3cNTPSysPrecision = MibScalar((1, 3, 6, 1, 4, 1, 25506, 8, 22, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-20, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cNTPSysPrecision.setStatus('current')
if mibBuilder.loadTexts: hh3cNTPSysPrecision.setDescription('Precision : This is a signed integer indicating the precision of the various clocks, in seconds to the nearest power of two. The value must be rounded to the next larger power of two; for instance, a 50-Hz (20 ms) or 60-Hz (16.67ms) power-frequency clock would be assigned the value -5 (31.25 ms), while a 1000-Hz (1 ms) crystal-controlled clock would be assigned the value -9 (1.95 ms).')
hh3cNTPSysRootdelay = MibScalar((1, 3, 6, 1, 4, 1, 25506, 8, 22, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cNTPSysRootdelay.setStatus('current')
if mibBuilder.loadTexts: hh3cNTPSysRootdelay.setDescription('Root Delay : This is a signed fixed-point number indicating the total roundtrip delay to the primary reference source at the root of the synchronization subnet, in seconds. Note that this variable can take on both positive and negative values, depending on clock precision and skew.')
hh3cNTPSysRootdispersion = MibScalar((1, 3, 6, 1, 4, 1, 25506, 8, 22, 1, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cNTPSysRootdispersion.setStatus('current')
if mibBuilder.loadTexts: hh3cNTPSysRootdispersion.setDescription('Root Dispersion : This is a signed fixed-point number indicating the maximum error relative to the primary reference source at the root of the synchronization subnet, in seconds. Only positive values greater than zero are possible.')
hh3cNTPSysRefid = MibScalar((1, 3, 6, 1, 4, 1, 25506, 8, 22, 1, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cNTPSysRefid.setStatus('current')
if mibBuilder.loadTexts: hh3cNTPSysRefid.setDescription('Reference Clock Identifier : This is a 32-bit code identifying the particular reference clock. In the case of stratum 0 (unspecified) or stratum 1 (primary reference source), this is a four-octet, left-justified, zero-padded ASCII string. Stratum, Code, Meaning 0, DCN, DCN routing protocol 0, TSP, TSP time protocol 1, ATOM, Atomic clock (calibrated) 1, WWVB, WWVB LF (band 5) radio 1, GOES, GOES UHF (band 9) satellite 1, WWV, WWV HF (band 7) radio')
hh3cNTPSysReftime = MibScalar((1, 3, 6, 1, 4, 1, 25506, 8, 22, 1, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cNTPSysReftime.setStatus('current')
if mibBuilder.loadTexts: hh3cNTPSysReftime.setDescription('Reference Timestamp : This is the local time, in timestamp format, when the local clock was last updated. If the local clock has never been synchronized, the value is zero.')
hh3cNTPSysPoll = MibScalar((1, 3, 6, 1, 4, 1, 25506, 8, 22, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-20, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cNTPSysPoll.setStatus('current')
if mibBuilder.loadTexts: hh3cNTPSysPoll.setDescription('Poll Interval : This is a signed integer indicating the minimum interval between transmitted messages, in seconds as a power of two. For instance, a value of six indicates a minimum interval of 64 seconds.')
hh3cNTPSysPeer = MibScalar((1, 3, 6, 1, 4, 1, 25506, 8, 22, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cNTPSysPeer.setStatus('current')
if mibBuilder.loadTexts: hh3cNTPSysPeer.setDescription('This is a selector identifying the current synchronization source. Usually this will be a pointer to a structure containing the peer variables. The special value NULL indicates There is no currently valid synchronization source.')
hh3cNTPSysState = MibScalar((1, 3, 6, 1, 4, 1, 25506, 8, 22, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("noUpdateClock", 0), ("getfreqInfo", 1), ("clockBySet", 2), ("clockBySetAndNoFreq", 3), ("clockBySyns", 4), ("findError", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cNTPSysState.setStatus('current')
if mibBuilder.loadTexts: hh3cNTPSysState.setDescription('This is a integer indicating the state of local clock.')
hh3cNTPSysOffset = MibScalar((1, 3, 6, 1, 4, 1, 25506, 8, 22, 1, 1, 11), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cNTPSysOffset.setStatus('current')
if mibBuilder.loadTexts: hh3cNTPSysOffset.setDescription('The offset of two clocks is the time difference between them.')
hh3cNTPSysDrift = MibScalar((1, 3, 6, 1, 4, 1, 25506, 8, 22, 1, 1, 12), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cNTPSysDrift.setStatus('current')
if mibBuilder.loadTexts: hh3cNTPSysDrift.setDescription('Real clocks exhibit some variation in skew (second derivative of offset with time), which is called drift.')
hh3cNTPSysCompliance = MibScalar((1, 3, 6, 1, 4, 1, 25506, 8, 22, 1, 1, 13), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cNTPSysCompliance.setStatus('current')
if mibBuilder.loadTexts: hh3cNTPSysCompliance.setDescription('This is a string indicating the system error.')
hh3cNTPSysClock = MibScalar((1, 3, 6, 1, 4, 1, 25506, 8, 22, 1, 1, 14), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cNTPSysClock.setStatus('current')
if mibBuilder.loadTexts: hh3cNTPSysClock.setDescription('This is the current local time, in timestamp format. Local time is derived from the hardware clock of the particular machine and increments at intervals depending on the design used.')
hh3cNTPSysStabil = MibScalar((1, 3, 6, 1, 4, 1, 25506, 8, 22, 1, 1, 15), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cNTPSysStabil.setStatus('current')
if mibBuilder.loadTexts: hh3cNTPSysStabil.setDescription('This is a indicating that stability of a clock is how well it can maintain a constant frequency.')
hh3cNTPSysAuthenticate = MibScalar((1, 3, 6, 1, 4, 1, 25506, 8, 22, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("noAuthenticate", 0), ("authenticate", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cNTPSysAuthenticate.setStatus('current')
if mibBuilder.loadTexts: hh3cNTPSysAuthenticate.setDescription('This is a integer indicating that system support authentication.')
hh3cNTPSysPollSec = MibScalar((1, 3, 6, 1, 4, 1, 25506, 8, 22, 1, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 1048576))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cNTPSysPollSec.setStatus('current')
if mibBuilder.loadTexts: hh3cNTPSysPollSec.setDescription('PollSec Interval : This is a integer indicating the minimum interval between transmitted messages. For instance, a value of six indicates a minimum interval of 6 seconds.')
hh3cNTPSysClockSec = MibScalar((1, 3, 6, 1, 4, 1, 25506, 8, 22, 1, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cNTPSysClockSec.setStatus('current')
if mibBuilder.loadTexts: hh3cNTPSysClockSec.setDescription('This is the current local time, in integer format. Local time is derived from the hardware clock of the particular machine and increments at intervals depending on the design used.')
hh3cNTPServerIP = MibScalar((1, 3, 6, 1, 4, 1, 25506, 8, 22, 1, 1, 19), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cNTPServerIP.setStatus('current')
if mibBuilder.loadTexts: hh3cNTPServerIP.setDescription('The NTP server ip address. It must be a unicast address, rather than a broadcast address, a multicast address or the IP address of the local clock. To delete a configured NTP server ip address, please set hh3cNTPServerIP to 0.')
hh3cNTPPeerMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 8, 22, 2))
hh3cNTPPeerMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 8, 22, 2, 1))
hh3cNTPPeerTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 8, 22, 2, 1, 1), )
if mibBuilder.loadTexts: hh3cNTPPeerTable.setStatus('current')
if mibBuilder.loadTexts: hh3cNTPPeerTable.setDescription('This table provides information on the peers with which the local NTP server has associations. The peers are also NTP servers but running on different hosts.')
hh3cNTPPeerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 8, 22, 2, 1, 1, 1), ).setIndexNames((0, "HH3C-NTP-MIB", "hh3cNTPPeerRemAdr"), (0, "HH3C-NTP-MIB", "hh3cNTPPeerHMode"))
if mibBuilder.loadTexts: hh3cNTPPeerEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cNTPPeerEntry.setDescription("Each peers' entry provides NTP information retrieved from a particular peer NTP server. Each peer is identified by a unique association identifier. Entries are automatically created when the user configures the NTP server to be associated with remote peers. Similarly entries are deleted when the user removes the peer association from the NTP server. Entries can also be created by the management station by setting values for the following objects: hh3cNTPPeerRemAdr and making the hh3cNTPPeerRowStatus as 'active'. At the least, the management station has to set a value for hh3cNTPPeerRemAdr to make the row active.")
hh3cNTPPeerConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 22, 2, 1, 1, 1, 1), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cNTPPeerConfig.setStatus('current')
if mibBuilder.loadTexts: hh3cNTPPeerConfig.setDescription('This is a bit indicating that the association was created from configuration information and should not be demobilized if the peer becomes unreachable.')
hh3cNTPPeerAuthenable = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 22, 2, 1, 1, 1, 2), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cNTPPeerAuthenable.setStatus('current')
if mibBuilder.loadTexts: hh3cNTPPeerAuthenable.setDescription('This is a bit indicating that system support authentication.')
hh3cNTPPeerAuthentic = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 22, 2, 1, 1, 1, 3), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cNTPPeerAuthentic.setStatus('current')
if mibBuilder.loadTexts: hh3cNTPPeerAuthentic.setDescription('This is a bit indicating that massage pass authentication which is authentic.')
hh3cNTPPeerRemAdr = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 22, 2, 1, 1, 1, 4), IpAddress())
if mibBuilder.loadTexts: hh3cNTPPeerRemAdr.setStatus('current')
if mibBuilder.loadTexts: hh3cNTPPeerRemAdr.setDescription('The IP address of the peer. When creating a new association, a value for this object should be set before the row is made active.')
hh3cNTPPeerRemPort = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 22, 2, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cNTPPeerRemPort.setStatus('current')
if mibBuilder.loadTexts: hh3cNTPPeerRemPort.setDescription('The UDP port number on which the peer receives NTP messages.')
hh3cNTPPeerLocAdr = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 22, 2, 1, 1, 1, 6), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cNTPPeerLocAdr.setStatus('current')
if mibBuilder.loadTexts: hh3cNTPPeerLocAdr.setDescription('The IP address of the local host. Multi-homing can be supported using this object.')
hh3cNTPPeerLocPort = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 22, 2, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cNTPPeerLocPort.setStatus('current')
if mibBuilder.loadTexts: hh3cNTPPeerLocPort.setDescription('The UDP port number on which the local host receives NTP messages.')
hh3cNTPPeerLeap = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 22, 2, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("noWarning", 0), ("addSecond", 1), ("subtractSecond", 2), ("alarm", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cNTPPeerLeap.setStatus('current')
if mibBuilder.loadTexts: hh3cNTPPeerLeap.setDescription('This is a two-bit code warning of an impending leap second to be inserted in the NTP timescale. The bits are set before 23:59 on the day of insertion and reset after 00:00 on the following day. This causes the number of seconds (rollover interval) in the day of insertion to be increased or decreased by one. The two bits are coded as below, 00, no warning 01, last minute has 61 seconds 10, last minute has 59 seconds 11, alarm condition (clock not synchronized)')
hh3cNTPPeerHMode = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 22, 2, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("unspecified", 0), ("symmetricActive", 1), ("symmetricPassive", 2), ("client", 3), ("server", 4), ("broadcast", 5), ("reservedControl", 6), ("reservedPrivate", 7), ("broadcastclient", 8), ("multicastclient", 9))))
if mibBuilder.loadTexts: hh3cNTPPeerHMode.setStatus('current')
if mibBuilder.loadTexts: hh3cNTPPeerHMode.setDescription('This is an integer indicating the association mode, with values coded as follows, 0, unspecified 1, symmetric active - A host operating in this mode sends periodic messages regardless of the reach ability state or stratum of its peer. By operating in this mode the host announces its willingness to synchronize and be synchronized by the peer 2, symmetric passive - This type of association is ordinarily created upon arrival of a message from a peer operating in the symmetric active mode and persists only as long as the peer is reachable and operating at a stratum level less than or equal to the host; otherwise, the association is dissolved. However, the association will always persist until at least one message has been sent in reply. By operating in this mode the host announces its willingness to synchronize and be synchronized by the peer 3, client - A host operating in this mode sends periodic messages regardless of the reach ability state or stratum of its peer. By operating in this mode the host, usually a LAN workstation, announces its willingness to be synchronized by, but not to synchronize the peer 4, server - This type of association is ordinarily created upon arrival of a client request message and exists only in order to reply to that request, after which the association is dissolved. By operating in this mode the host, usually a LAN time server, announces its willingness to synchronize, but not to be synchronized by the peer 5, broadcast - A host operating in this mode sends periodic messages regardless of the reach ability state or stratum of the peers. By operating in this mode the host, usually a LAN time server operating on a high-speed broadcast medium, announces its willingness to synchronize all of the peers, but not to be synchronized by any of them 6, reserved for NTP control messages 7, reserved for private use 8, broadcastclient 9, multicastclient')
hh3cNTPPeerStratum = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 22, 2, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cNTPPeerStratum.setStatus('current')
if mibBuilder.loadTexts: hh3cNTPPeerStratum.setDescription('This is a integer indicating the stratum level of the local clock, with values defined as follows: 0, unspecified 1, primary reference (e.g.,, radio clock) 2-255, secondary reference (via NTP)')
hh3cNTPPeerPPoll = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 22, 2, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-20, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cNTPPeerPPoll.setStatus('current')
if mibBuilder.loadTexts: hh3cNTPPeerPPoll.setDescription('The interval at which the peer polls the local host.')
hh3cNTPPeerHPoll = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 22, 2, 1, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-20, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cNTPPeerHPoll.setStatus('current')
if mibBuilder.loadTexts: hh3cNTPPeerHPoll.setDescription('The interval at which the local host polls the peer.')
hh3cNTPPeerPrecision = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 22, 2, 1, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-20, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cNTPPeerPrecision.setStatus('current')
if mibBuilder.loadTexts: hh3cNTPPeerPrecision.setDescription('This is a signed integer indicating the precision of the peer clock, in seconds to the nearest power of two. The value must be rounded to the next larger power of two; for instance, a 50-Hz (20 ms) or 60-Hz (16.67 ms) power-frequency clock would be assigned the value -5 (31.25 ms), while a 1000-Hz (1 ms) crystal-controlled clock would be assigned the value -9 (1.95 ms).')
hh3cNTPPeerRootDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 22, 2, 1, 1, 1, 14), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cNTPPeerRootDelay.setStatus('current')
if mibBuilder.loadTexts: hh3cNTPPeerRootDelay.setDescription('This is a signed fixed-point number indicating the total roundtrip delay to the primary reference source at the root of the synchronization subnet, in seconds. Note that this variable can take on both positive and negative values, depending on clock precision and skew.')
hh3cNTPPeerRootDispersion = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 22, 2, 1, 1, 1, 15), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cNTPPeerRootDispersion.setStatus('current')
if mibBuilder.loadTexts: hh3cNTPPeerRootDispersion.setDescription('This is a signed fixed-point number indicating the maximum error of the peer clock relative to the primary reference source at the root of the synchronization subnet. Only positive values greater than zero are possible.')
hh3cNTPPeerRefId = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 22, 2, 1, 1, 1, 16), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cNTPPeerRefId.setStatus('current')
if mibBuilder.loadTexts: hh3cNTPPeerRefId.setDescription('The reference identifier of the peer. This is a 32-bit code identifying the particular reference clock. In the case of stratum 0 (unspecified) or stratum 1 (primary reference source), this is a four-octet, left-justified, zero-padded ASCII string. Stratum, Code, Meaning 0, DCN, DCN routing protocol 0, TSP, TSP time protocol 1, ATOM, Atomic clock (calibrated) 1, WWVB, WWVB LF (band 5) radio 1, GOES, GOES UHF (band 9) satellite 1, WWV, WWV HF (band 7) radio')
hh3cNTPPeerRefTime = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 22, 2, 1, 1, 1, 17), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cNTPPeerRefTime.setStatus('current')
if mibBuilder.loadTexts: hh3cNTPPeerRefTime.setDescription('This is the local time at the peer, in timestamp format, when the local clock was last updated. If the local clock has never been synchronized, the value is zero.')
hh3cNTPPeerOrg = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 22, 2, 1, 1, 1, 18), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cNTPPeerOrg.setStatus('current')
if mibBuilder.loadTexts: hh3cNTPPeerOrg.setDescription("This is the local time, in timestamp format, at the peer when it's latest NTP message was sent. If the peer becomes unreachable the value is set to zero")
hh3cNTPPeerRec = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 22, 2, 1, 1, 1, 19), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cNTPPeerRec.setStatus('current')
if mibBuilder.loadTexts: hh3cNTPPeerRec.setDescription('This is the local time, in timestamp format, when the latest NTP message from the peer arrived. If the peer becomes unreachable the value is set to zero.')
hh3cNTPPeerXmt = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 22, 2, 1, 1, 1, 20), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cNTPPeerXmt.setStatus('current')
if mibBuilder.loadTexts: hh3cNTPPeerXmt.setDescription('This is the local time, in timestamp format, at which the NTP message departed the sender.')
hh3cNTPPeerReach = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 22, 2, 1, 1, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cNTPPeerReach.setStatus('current')
if mibBuilder.loadTexts: hh3cNTPPeerReach.setDescription('This is a shift register of NTP.WINDOW bits used to determine the reach ability status of the peer, with bits entering from the least significant (rightmost) end. A peer is considered reachable if at least one bit in this register is set to one')
hh3cNTPPeerValid = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 22, 2, 1, 1, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cNTPPeerValid.setStatus('current')
if mibBuilder.loadTexts: hh3cNTPPeerValid.setDescription('This is an integer counter indicating the valid samples remaining in the filter register. It is used to determine the reach ability state and when the poll interval should be increased or decreased.')
hh3cNTPPeerTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 22, 2, 1, 1, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cNTPPeerTimer.setStatus('current')
if mibBuilder.loadTexts: hh3cNTPPeerTimer.setDescription('This is an integer counter used to control the interval of transmitted NTP messages from the local host to the peer.')
hh3cNTPPeerDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 22, 2, 1, 1, 1, 24), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cNTPPeerDelay.setStatus('current')
if mibBuilder.loadTexts: hh3cNTPPeerDelay.setDescription('This is a signed fixed-point number indicating the roundtrip delay of the peer clock relative to the local clock over the network path between them, in seconds. Note that this variable can take on both positive and negative values, depending on clock precision and skew-error accumulation.')
hh3cNTPPeerOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 22, 2, 1, 1, 1, 25), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cNTPPeerOffset.setStatus('current')
if mibBuilder.loadTexts: hh3cNTPPeerOffset.setDescription('This is a signed, fixed-point number indicating the offset of the peer clock relative to the local clock, in seconds.')
hh3cNTPPeerJitter = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 22, 2, 1, 1, 1, 26), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cNTPPeerJitter.setStatus('current')
if mibBuilder.loadTexts: hh3cNTPPeerJitter.setDescription('This is an indicating that peer of sample Variance')
hh3cNTPPeerDispersion = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 22, 2, 1, 1, 1, 27), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cNTPPeerDispersion.setStatus('current')
if mibBuilder.loadTexts: hh3cNTPPeerDispersion.setDescription('This is a signed fixed-point number indicating the maximum error of the peer clock relative to the local clock over the network path between them, in seconds. Only positive values greater than zero are possible.')
hh3cNTPPeerKeyId = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 22, 2, 1, 1, 1, 28), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cNTPPeerKeyId.setStatus('current')
if mibBuilder.loadTexts: hh3cNTPPeerKeyId.setDescription('This is an unsigned integer identifying the cryptographic key used to generate the message-authentication code.')
hh3cNTPPeerFiltDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 22, 2, 1, 1, 1, 29), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cNTPPeerFiltDelay.setStatus('current')
if mibBuilder.loadTexts: hh3cNTPPeerFiltDelay.setDescription('Round-trip delay of the peer clock relative to the local clock over the network path between them, in seconds. This variable can take on both positive and negative values, depending on clock precision and skew-error accumulation.')
hh3cNTPPeerFiltOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 22, 2, 1, 1, 1, 30), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cNTPPeerFiltOffset.setStatus('current')
if mibBuilder.loadTexts: hh3cNTPPeerFiltOffset.setDescription('The offset of the peer clock relative to the local clock in seconds.')
hh3cNTPPeerFiltError = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 22, 2, 1, 1, 1, 31), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cNTPPeerFiltError.setStatus('current')
if mibBuilder.loadTexts: hh3cNTPPeerFiltError.setDescription('The maximum error of the peer clock relative to the local clock over the network path between them, in seconds. Only positive values greater than zero are possible.')
hh3cNTPPeerPMode = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 22, 2, 1, 1, 1, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("unspecified", 0), ("symmetricActive", 1), ("symmetricPassive", 2), ("client", 3), ("server", 4), ("broadcast", 5), ("reservedControl", 6), ("reservedPrivate", 7), ("broadcastclient", 8), ("multicastclient", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cNTPPeerPMode.setStatus('current')
if mibBuilder.loadTexts: hh3cNTPPeerPMode.setDescription("This is an integer indicating the association mode, with values coded as follows, 0, unspecified 1, symmetric active - A host operating in this mode sends periodic messages regardless of the reach ability state or stratum of its peer. By operating in this mode the host announces its willingness to synchronize and be synchronized by the peer 2, symmetric passive - This type of association is ordinarily created upon arrival of a message from a peer operating in the symmetric active mode and persists only as long as the peer is reachable and operating at a stratum level less than or equal to the host; otherwise, the association is dissolved. However, the association will always persist until at least one message has been sent in reply. By operating in this mode the host announces its willingness to synchronize and be synchronized by the peer 3, client - A host operating in this mode sends periodic messages regardless of the reach ability state or stratum of its peer. By operating in this mode the host, usually a LAN workstation, announces its willingness to be synchronized by, but not to synchronize the peer 4, server - This type of association is ordinarily created upon arrival of a client request message and exists only in order to reply to that request, after which the association is dissolved. By operating in this mode the host, usually a LAN time server, announces its willingness to synchronize, but not to be synchronized by the peer 5, broadcast - A host operating in this mode sends periodic messages regardless of the reach ability state or stratum of the peers. By operating in this mode the host, usually a LAN time server operating on a high-speed broadcast medium, announces its willingness to synchronize all of the peers, but not to be synchronized by any of them 6, reserved for NTP control messages 7, reserved for private use 8, broadcastclient 9, multicastclient When creating a new peer association, if no value is specified for this object, it defaults to 'symmetricActive'.")
hh3cNTPPeerReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 22, 2, 1, 1, 1, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cNTPPeerReceived.setStatus('current')
if mibBuilder.loadTexts: hh3cNTPPeerReceived.setDescription('The number of received massages.')
hh3cNTPPeerSent = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 22, 2, 1, 1, 1, 34), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cNTPPeerSent.setStatus('current')
if mibBuilder.loadTexts: hh3cNTPPeerSent.setDescription('The number of send massages.')
hh3cNTPPeerFlash = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 22, 2, 1, 1, 1, 35), Bits().clone(namedValues=NamedValues(("recvRepeatMsg", 0), ("recvremanMsg", 1), ("unSynMsg", 2), ("dispBeyond", 3), ("unauthenticate", 4), ("unSynClock", 5), ("straBeyond", 6), ("rootDispBeyond", 7), ("noAuthen", 8), ("refuOperate", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cNTPPeerFlash.setStatus('current')
if mibBuilder.loadTexts: hh3cNTPPeerFlash.setDescription('The information about the massage. ')
hh3cNTPPeerRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 22, 2, 1, 1, 1, 36), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cNTPPeerRowStatus.setStatus('current')
if mibBuilder.loadTexts: hh3cNTPPeerRowStatus.setDescription("The status object for this row. When a management station is creating a new row, it should set the value for cntpPeersPeerAddress at least, before the row can be made 'active'.")
mibBuilder.exportSymbols("HH3C-NTP-MIB", hh3cNTPPeerLocPort=hh3cNTPPeerLocPort, hh3cNTPPeerDelay=hh3cNTPPeerDelay, hh3cNTPPeerXmt=hh3cNTPPeerXmt, hh3cNTPSysStratum=hh3cNTPSysStratum, hh3cNTPSysPollSec=hh3cNTPSysPollSec, hh3cNTPSysPoll=hh3cNTPSysPoll, hh3cNTPPeerReach=hh3cNTPPeerReach, hh3cNTPSystemMIB=hh3cNTPSystemMIB, hh3cNTPPeerSent=hh3cNTPPeerSent, hh3cNTPPeerValid=hh3cNTPPeerValid, hh3cNTPSystemMIBObjects=hh3cNTPSystemMIBObjects, hh3cNTPSysCompliance=hh3cNTPSysCompliance, hh3cNTPPeerPPoll=hh3cNTPPeerPPoll, hh3cNTPPeerTimer=hh3cNTPPeerTimer, hh3cNTPPeerRowStatus=hh3cNTPPeerRowStatus, hh3cNTPPeerStratum=hh3cNTPPeerStratum, hh3cNTPPeerRemPort=hh3cNTPPeerRemPort, hh3cNTPServerIP=hh3cNTPServerIP, hh3cNTPPeerMIB=hh3cNTPPeerMIB, hh3cNTPSysPrecision=hh3cNTPSysPrecision, hh3cNTPSysOffset=hh3cNTPSysOffset, hh3cNTPPeerLocAdr=hh3cNTPPeerLocAdr, hh3cNTPPeerHPoll=hh3cNTPPeerHPoll, hh3cNTPPeerAuthenable=hh3cNTPPeerAuthenable, hh3cNTPPeerDispersion=hh3cNTPPeerDispersion, hh3cNTPSysPeer=hh3cNTPSysPeer, hh3cNTPSysReftime=hh3cNTPSysReftime, hh3cNTPPeerRemAdr=hh3cNTPPeerRemAdr, hh3cNTPPeerJitter=hh3cNTPPeerJitter, hh3cNTPPeerReceived=hh3cNTPPeerReceived, hh3cNTPPeerFiltError=hh3cNTPPeerFiltError, hh3cNTPPeerTable=hh3cNTPPeerTable, hh3cNTPPeerFiltOffset=hh3cNTPPeerFiltOffset, hh3cNTPSysRootdispersion=hh3cNTPSysRootdispersion, hh3cNTPSysDrift=hh3cNTPSysDrift, hh3cNTPSysClock=hh3cNTPSysClock, hh3cNTPPeerEntry=hh3cNTPPeerEntry, hh3cNTPPeerHMode=hh3cNTPPeerHMode, hh3cNTPPeerFiltDelay=hh3cNTPPeerFiltDelay, hh3cNTPSysState=hh3cNTPSysState, hh3cNTPPeerFlash=hh3cNTPPeerFlash, hh3cNTPPeerConfig=hh3cNTPPeerConfig, hh3cNTPPeerMIBObjects=hh3cNTPPeerMIBObjects, hh3cNTPPeerPrecision=hh3cNTPPeerPrecision, hh3cNTPPeerRefTime=hh3cNTPPeerRefTime, hh3cNTPSysStabil=hh3cNTPSysStabil, hh3cNTPSysClockSec=hh3cNTPSysClockSec, hh3cNTPPeerRootDispersion=hh3cNTPPeerRootDispersion, hh3cNTPPeerRootDelay=hh3cNTPPeerRootDelay, PYSNMP_MODULE_ID=hh3cNTP, hh3cNTPPeerPMode=hh3cNTPPeerPMode, hh3cNTP=hh3cNTP, hh3cNTPPeerAuthentic=hh3cNTPPeerAuthentic, hh3cNTPSysLeap=hh3cNTPSysLeap, hh3cNTPPeerKeyId=hh3cNTPPeerKeyId, hh3cNTPSysAuthenticate=hh3cNTPSysAuthenticate, hh3cNTPPeerOrg=hh3cNTPPeerOrg, hh3cNTPSysRootdelay=hh3cNTPSysRootdelay, hh3cNTPSysRefid=hh3cNTPSysRefid, hh3cNTPPeerRec=hh3cNTPPeerRec, hh3cNTPPeerOffset=hh3cNTPPeerOffset, hh3cNTPPeerRefId=hh3cNTPPeerRefId, hh3cNTPPeerLeap=hh3cNTPPeerLeap)

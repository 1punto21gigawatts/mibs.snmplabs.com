#
# PySNMP MIB module Nortel-Magellan-Passport-PorsVcMIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/Nortel-Magellan-Passport-PorsVcMIB
# Produced by pysmi-0.3.4 at Wed May  1 14:28:09 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ConstraintsIntersection, ValueRangeConstraint, SingleValueConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ConstraintsIntersection", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsUnion")
rtgIndex, rtg = mibBuilder.importSymbols("Nortel-Magellan-Passport-BaseRoutingMIB", "rtgIndex", "rtg")
RowStatus, Integer32, DisplayString, StorageType, Unsigned32, RowPointer = mibBuilder.importSymbols("Nortel-Magellan-Passport-StandardTextualConventionsMIB", "RowStatus", "Integer32", "DisplayString", "StorageType", "Unsigned32", "RowPointer")
Link, EnterpriseDateAndTime, NonReplicated, AsciiString = mibBuilder.importSymbols("Nortel-Magellan-Passport-TextualConventionsMIB", "Link", "EnterpriseDateAndTime", "NonReplicated", "AsciiString")
passportMIBs, = mibBuilder.importSymbols("Nortel-Magellan-Passport-UsefulDefinitionsMIB", "passportMIBs")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Integer32, IpAddress, ModuleIdentity, Counter64, Unsigned32, ObjectIdentity, iso, Bits, TimeTicks, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter32, Gauge32, NotificationType, MibIdentifier = mibBuilder.importSymbols("SNMPv2-SMI", "Integer32", "IpAddress", "ModuleIdentity", "Counter64", "Unsigned32", "ObjectIdentity", "iso", "Bits", "TimeTicks", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter32", "Gauge32", "NotificationType", "MibIdentifier")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
porsVcMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 37))
rtgRs = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 2))
rtgRsRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 2, 1), )
if mibBuilder.loadTexts: rtgRsRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: rtgRsRowStatusTable.setDescription('This entry controls the addition and deletion of rtgRs components.')
rtgRsRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-BaseRoutingMIB", "rtgIndex"), (0, "Nortel-Magellan-Passport-PorsVcMIB", "rtgRsIndex"))
if mibBuilder.loadTexts: rtgRsRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rtgRsRowStatusEntry.setDescription('A single entry in the table represents a single rtgRs component.')
rtgRsRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgRsRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rtgRsRowStatus.setDescription('This variable is used as the basis for SNMP naming of rtgRs components. These components cannot be added nor deleted.')
rtgRsComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgRsComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: rtgRsComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
rtgRsStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgRsStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: rtgRsStorageType.setDescription('This variable represents the storage type value for the rtgRs tables.')
rtgRsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: rtgRsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rtgRsIndex.setDescription('This variable represents the index for the rtgRs tables.')
rtgRsSelectedRouteTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 2, 10), )
if mibBuilder.loadTexts: rtgRsSelectedRouteTable.setStatus('mandatory')
if mibBuilder.loadTexts: rtgRsSelectedRouteTable.setDescription('This group contains operational attributes describing the last selected or manual route returned by RouteSelector. These attributes form selected route description data.')
rtgRsSelectedRouteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-BaseRoutingMIB", "rtgIndex"), (0, "Nortel-Magellan-Passport-PorsVcMIB", "rtgRsIndex"))
if mibBuilder.loadTexts: rtgRsSelectedRouteEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rtgRsSelectedRouteEntry.setDescription('An entry in the rtgRsSelectedRouteTable.')
rtgRsRouteCostMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 2, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 999999)).clone(999999)).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgRsRouteCostMetric.setStatus('mandatory')
if mibBuilder.loadTexts: rtgRsRouteCostMetric.setDescription('This attribute indicates the sum of cost metrics of trunks that make up the selected route returned by RouteSelector. If the cost metrics at both ends of a trunk differ, the larger metric is used for that trunk. If a route could not be selected for whatever reason then the routeCostMetric is set to a value 999999 intended to symbolize unknown cost. For manual routes the value of routeCostMetric is also 999999. This is because RouteSelector does not verify manual routes thus routeCostMetric is unknown.')
rtgRsRouteDelayMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 2, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 999999)).clone(999999)).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgRsRouteDelayMetric.setStatus('mandatory')
if mibBuilder.loadTexts: rtgRsRouteDelayMetric.setDescription('This attribute indicates the sum of delay metrics of trunks that make up the selected route returned by RouteSelector. The delay metric of a trunk is equal to half the measuredRoundTripDelay operational attribute of the trunk. If the delay metrics at both ends of a trunk differ, the larger metric is used for that trunk. If a route could not be selected for whatever reason then the routeDelayMetric is set to a value 999999 intended to symbolize unknown delay. For manual routes the value of routeDelayMetric is also 999999. This is because RouteSelector does not verify manual routes, thus routeDelayMetric is unknown.')
rtgRsBumpingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 2, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgRsBumpingPriority.setStatus('mandatory')
if mibBuilder.loadTexts: rtgRsBumpingPriority.setDescription('This attribute indicates the priority at which a route has been selected, or a value of 4 for manual routes since no route selection was made. Since RouteSelector does not verify manual routes the value of 4 for routeBumpingPriority symbolizes an unknown value for manual routes. The remainder of the description is not applicable to manual routes. The bumping priority of a route specifies a priority at which a path along that route can be established. The lowest bumping priority is 4, the highest bumping priority is equal to a setup priority contained in the route request data. If a route is selected at bumping priority 4, then no paths will be bumped since there appears to be enough free bandwidth on selected trunks, and also since this bumping priority is not better than the lowest holding priority (4) of any path. If a route cannot be selected at bumping priority 4 and a setup priority is 3 or better, then a route may be selected at bumping priority 3. This means that paths at holding priority 4 may be bumped if currently there is not enough free bandwidth on selected trunks to establish the new path with setup priority 3. If a route cannot be selected at bumping priority 3 and a setup priority is 2 or better, then a route may be selected at bumping priority 2. In this case paths with holding priority 4 and 3 may be bumped if there is not enough free bandwidth on selected trunks to establish the new path with setup priority 2. If a route cannot be selected at bumping priority 2 and a setup priority is 1 or better, then a route may be selected at bumping priority 1. In this case paths with holding priority 4, 3, and 2 may be bumped if there is not enough free bandwidth on selected trunks to establish the new path with setup priority 1. If a route cannot be selected at bumping priority 1 and a setup priority is 0, then a route may be selected at bumping priority 0. In this case paths with holding priority 4, 3, 2, and 1 may be bumped if there is not enough free bandwidth on selected trunks to establish the new path with setup priority 0.')
rtgRsReasonForNoRoute = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 2, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14))).clone(namedValues=NamedValues(("none", 0), ("destinationNameTooLong", 1), ("destinationNotSpecified", 2), ("unknownDestinationName", 3), ("incorrectDestination", 4), ("incorrectDestinationEndPoint", 5), ("unknownSource", 6), ("unknownDestination", 7), ("sameNode", 8), ("routeCostTooMuch", 9), ("routeDelayTooLong", 10), ("attributesNotMet", 11), ("internalReason", 12), ("attributeProfileProblem", 13), ("manualPathIndexProblem", 14))).clone('none')).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgRsReasonForNoRoute.setStatus('mandatory')
if mibBuilder.loadTexts: rtgRsReasonForNoRoute.setDescription('This attribute indicates the reason for which a route was not selected by RouteSelector. If the route was selected then reasonForNoRoute has a value of none. If the destination in the form of ASCII name was specified (see destination) and the name of node is too long (more than 12 characters) then reasonForNoRoute has a value of destinationNameTooLong. Check and correct node name in the destination attribute. If the destination was not specified, that is destination is blank, then reasonForNoRoute has a value of destinationNotSpecified. Destination attribute should not be blank. If the destination in the form of ASCII name was specified (see destination) and the name of node cannot be found in topological database then reasonForNoRoute has a value of unknownDestinationName. Check and correct node name in the destination attribute. If it is correct then this node does not appear in local topological database as this node may lie across the topology region or cluster boundary. If the destination cannot be found in the topological database or cannot be reached through any gateway node then reasonForNoRoute has a value of unknownDestination. Ensure the destination specified in destination attribute resides in the topology region, or can be reached through a Routing Gateway. That is, at least one reachable address provisioned under a Trunk Address component representing a gateway link can reach the destination NSAP address. If the destination was specified using an incorrect format (see destination) then reasonForNoRoute has a value of incorrectDestination. Use the correct format for destination attribute. If there is no physical connectivity to the destination or gateway node, or number of hops to such node exceeds a limit of 20 hops, or a route to such node cannot satisfy all the parameters in the route request data then reasonForNoRoute has a value of attributeNotMet. Set operationMode to manual and issue d rtg rs command and inspect attributeNotMet to determine which attribute could not be satisfied. If the route to the destination could not be selected for some internal reason then reasonForNoRoute has a value of internalReason. A Software Alarm generated in association with this situation should be reported to Nortel Networks technical support. If the route to the destination could not be selected because of profile reference problem then reasonForNoRoute has a value of attributeProfileProblem. If the route to the destination could not be selected because of manual path reference problem then reasonForNoRoute has a value of manualPathIndexProblem. The following values of reasonForNoRoute are no longer generated: routeCostTooMuch, routeDelayTooMuch, incorrectDestinationEndPoint, and sameNode.')
rtgRsAttributeNotMet = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 2, 10, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("unknownAttributeNotMet", 0), ("allAttributesMet", 1), ("requiredRxBandwidth", 2), ("requiredTxBandwidth", 3), ("requiredTrunkModes", 4), ("maximumAcceptableCost", 5), ("maximumAcceptableDelay", 6), ("requiredTrafficType", 7), ("permittedTrunkTypes", 8), ("requiredSecurity", 9), ("requiredCustomerParm", 10), ("maximumTransmissionUnit", 11), ("maximumAcceptableGatewayCost", 12), ("maximumGatewayHops", 13))).clone('allAttributesMet')).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgRsAttributeNotMet.setStatus('mandatory')
if mibBuilder.loadTexts: rtgRsAttributeNotMet.setDescription('This attribute indicates the name of a possible route request data parameter which prevents RouteSelector from selecting the route. This attribute always has a value of allAttributesMet for manual routes since RouteSelector does not verify manual routes. This attribute has a meaningful value if reasonForNoRoute attribute has a value of attributesNotMet. The value of attributeNotMet is only computed when RouteSelector operates in manual mode. That is, when route selection has been initiated by the operator in which case operationMode has a value of manual. RouteSelector determines which of the attributes: requiredRxBandwidth, requiredTxBandwidth, requiredTrunkModes, maximumAcceptableCost, maximumAcceptableDelay, maximumAcceptableGatewaCost, requiredTrafficType, permittedTrunkTypes, requiredSecurity, requiredCustomerParameter, and maximumTransmissionUnit prevents successful route selection by dropping the constraints associated with that attribute and reselecting the route. If that route can be successfully selected then the attribute for which the constraints were dropped is the attribute preventing successful route selection. For example, RouteSelector drops bandwidth constraints by selecting a route with requiredRxBandwidth or requiredTxBandwidth of 0. If the route can be selected then bandwidth is preventing successful route selection. A value of unknownAttributeNotMet indicates that RouteSelector cannot determine why route cannot be selected. Constraints for all attributes are dropped yet successful route cannot be computed. This usually indicates a lack physical connectivity to the destination or gateway node. Alternatively, this may indicate that destination or gateway node is more than 20 hops away where 20 hops is the maximum number of hops in the route.')
rtgRsRouteGatewayCostMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 2, 10, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 999999))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgRsRouteGatewayCostMetric.setStatus('mandatory')
if mibBuilder.loadTexts: rtgRsRouteGatewayCostMetric.setDescription('This attribute indicates the cost metric associated with reaching the destination indirectly through a gateway node or gateway link that is part of the selected route If the selected route leads directly to the destination node then the routeGatewayCostMetric is set to a value 0. If a route could not be selected for whatever reason then the routeGatewayCostMetric is set to a value 999999 intended to symbolize unknown cost. For manual routes the value of routeGatewayCostMetric is also 999999. This is because RouteSelector does not verify manual routes thus routeGatewayCostMetric is unknown.')
rtgRsRouteType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 2, 10, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("noRoute", 3), ("sameNode", 4), ("destinationNode", 5), ("destinationNodeLegacy", 6), ("gatewayNode", 7), ("gatewayLink", 8), ("routingGateway", 9), ("manual", 10))).clone('noRoute')).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgRsRouteType.setStatus('mandatory')
if mibBuilder.loadTexts: rtgRsRouteType.setDescription('This attribute indicates the type of route that was selected by RouteSelector. If no route was selected then routeType has a value of noRoute. If the destination resides on the current node then routeType has a value of sameNode. If the destination resides on a different node and can be reached directly as opposed to indirectly through a gateway node then routeType has a value of destinationNode or destinationNodeLegacy with the latter only possible when legacy gateway selection algorithm was used (see gatewaySelectionAlgorithm). If the destination can be reached indirectly through a gateway node with the gateway node being different from the current node then routeType has a value of gatewayNode or gatewayLink depending on whether or not the route consists of a single gateway link. A route consists of a single gateway link only when the route requestor (see routeRequestor) is a Routing Gateway (in inbound or outbound direction) and the route leads immediately across topology region or cluster boundary. If the destination can be reached indirectly through a gateway node with the gateway node being the current node and the route requestor (see routeRequestor) is an application service as opposed to a Routing Gateway then routeType has a value of routingGateway. If selected route is a manual route then routeType has a value of manual. Note that the type of route, except for manual route, depends on who is the route requestor (application service, Routing Gateway serving as inbound or outbound gateway), where it resides (gateway or non-gateway node), how the destination can be reached (directly or indirectly through a gateway node), and what is the gateway selection algorithm (cost-based, random or legacy).')
rtgRsControlsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 2, 11), )
if mibBuilder.loadTexts: rtgRsControlsTable.setStatus('mandatory')
if mibBuilder.loadTexts: rtgRsControlsTable.setDescription('This group contains attributes used to control RouteSelector.')
rtgRsControlsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 2, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-BaseRoutingMIB", "rtgIndex"), (0, "Nortel-Magellan-Passport-PorsVcMIB", "rtgRsIndex"))
if mibBuilder.loadTexts: rtgRsControlsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rtgRsControlsEntry.setDescription('An entry in the rtgRsControlsTable.')
rtgRsRouteSelectionAttributes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 2, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("fromOperator", 0), ("fromLastRouteRequest", 1))).clone('fromLastRouteRequest')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rtgRsRouteSelectionAttributes.setStatus('obsolete')
if mibBuilder.loadTexts: rtgRsRouteSelectionAttributes.setDescription('This attribute acts as a 2-position switch, allowing an operator to specify whether the route selection attributes kept by the RouteSelector should be as he/she set them: routeSelectionAttributes = fromOperator, or the route selection attributes could be updated automatically to contain the route selection attributes of the last automatic route request: routeSelectionAttributes = fromLastRouteRequest.')
rtgRsOperationMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 2, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("automatic", 0), ("manual", 1))).clone('automatic')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rtgRsOperationMode.setStatus('mandatory')
if mibBuilder.loadTexts: rtgRsOperationMode.setDescription("This attribute indicates the mode in which the RouteSelector is currently operating. The two possible modes are automatic and manual. In the automatic mode, a route request message containing the route request data is originated by a PORS VC and sent to the RouteSelector. RouteSelector then selects a route or gets a manual route and returns its description in the selected route description data in the selected route message back to the PORS VC. In the manual mode, the RouteSelector allows the operator to modify the parameters in the route request data (except for the manual path profile reference), and to initiate route selection using that data. When RouteSelector selects the route it displays its description to the operator. Note that even when operationMode is set to manual, RouteSelector handles route request messages originated by services' VCs in the same way as it does when operationMode is set to automatic.")
rtgRsLastRouteSelectionTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 2, 11, 1, 3), EnterpriseDateAndTime().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(19, 19), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgRsLastRouteSelectionTime.setStatus('mandatory')
if mibBuilder.loadTexts: rtgRsLastRouteSelectionTime.setDescription('This attribute indicates the time when RouteSelector last handled a route request message.')
rtgRsPathAttributesTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 2, 12), )
if mibBuilder.loadTexts: rtgRsPathAttributesTable.setStatus('mandatory')
if mibBuilder.loadTexts: rtgRsPathAttributesTable.setDescription('This group contains parameters in route request data that govern the route selection. Values of these parameters are obtained either from an operator or from the last route request message from a PORS VC that contained such parameters or a reference to such parameters (parameter profile reference) as part of the route request data. Route request messages from a PORS VC that ask for a manual route do not contain such parameters or reference to such parameters. All other route request messages either explicitly contain route request data parameters or a reference to a profile containing such parameters. This group of attributes is therefore not applicable to manual routes.')
rtgRsPathAttributesEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 2, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-BaseRoutingMIB", "rtgIndex"), (0, "Nortel-Magellan-Passport-PorsVcMIB", "rtgRsIndex"))
if mibBuilder.loadTexts: rtgRsPathAttributesEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rtgRsPathAttributesEntry.setDescription('An entry in the rtgRsPathAttributesTable.')
rtgRsSourceId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 2, 12, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 16777215)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rtgRsSourceId.setStatus('mandatory')
if mibBuilder.loadTexts: rtgRsSourceId.setDescription("This attribute indicates the node ID of the source node from which a route to the destination is to be found. It is typically the current node. The term 'source' is used in relation to the route selection process and not the node where RouteSelector resides, that is the current node. That is, the source node need not be the current node although the selected route will be based on the topological database of the current node.")
rtgRsRemoteName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 2, 12, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(6, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rtgRsRemoteName.setStatus('obsolete')
if mibBuilder.loadTexts: rtgRsRemoteName.setDescription("This attribute is the remote end point's description. The term 'remote' means the other end point, usually distant from the source node. End points are identified using a node name and a service name. The syntax is 'EM/NodeName <service name>/<instance>'. As an example, the end point component name for the third voice service on node MoonBase is 'EM/MoonBase VS/3'.")
rtgRsSetupPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 2, 12, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rtgRsSetupPriority.setStatus('mandatory')
if mibBuilder.loadTexts: rtgRsSetupPriority.setDescription('This attribute indicates the required priority for path establishment along the selected. Zero is the highest priority and four is the lowest. This attribute is closely related to bumpingPriority attribute.')
rtgRsRequiredTxBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 2, 12, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(64000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rtgRsRequiredTxBandwidth.setStatus('mandatory')
if mibBuilder.loadTexts: rtgRsRequiredTxBandwidth.setDescription('This attribute indicates the required transmit bandwidth in bits per second to send data to the destination.')
rtgRsRequiredRxBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 2, 12, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(64000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rtgRsRequiredRxBandwidth.setStatus('mandatory')
if mibBuilder.loadTexts: rtgRsRequiredRxBandwidth.setDescription('This attribute indicates the required receive bandwidth in bits per second to receive data from the destination.')
rtgRsMaximumTransmissionUnit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 2, 12, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 8192))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rtgRsMaximumTransmissionUnit.setStatus('mandatory')
if mibBuilder.loadTexts: rtgRsMaximumTransmissionUnit.setDescription('This attribute indicates the size of the largest packet that can be transported along the selected route. It is used by RouteSelector to select a route which avoids trunks whose maximum transmission unit is less than maximumTransmissionUnit and as a result would be unable to transport packets of this size. The default value of 0 permits all trunks to be eligible with respect to this attribute.')
rtgRsSecurity = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 2, 12, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 7)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rtgRsSecurity.setStatus('mandatory')
if mibBuilder.loadTexts: rtgRsSecurity.setDescription("This attribute indicates the required minimum level of security of the trunks along the selected route. Zero represents the most secure and seven represents the least secure. The trunk's security is indicated by the trunkSecurity attribute of the Trunk PathAdministrator (Trk Pa) component. RouteSelector ensures that any route selected does not contain a trunk whose trunkSecurity attribute is numerically greater than the requiredSecurity.")
rtgRsTrafficType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 2, 12, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("voice", 0), ("data", 1), ("video", 2), ("trafficType1", 3), ("trafficType2", 4), ("trafficType3", 5), ("trafficType4", 6), ("trafficType5", 7))).clone('voice')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rtgRsTrafficType.setStatus('mandatory')
if mibBuilder.loadTexts: rtgRsTrafficType.setDescription('This attribute indicates the required type of traffic that can be transported along the selected route. There are eight possible traffic types, and only one type can be transported. The voice, data, and video traffic types are already defined, and five other traffic types can be defined by the network administrator. The supportedTrafficType attribute of the Trunk PathAdministrator (Trk Pa) component lists all the types of traffic allowed on the trunk. When selecting a route, RouteSelector only chooses trunks whose supportedTrafficType contains the requiredTrafficType.')
rtgRsPermittedTrunkTypes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 2, 12, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1).clone(hexValue="f8")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rtgRsPermittedTrunkTypes.setStatus('mandatory')
if mibBuilder.loadTexts: rtgRsPermittedTrunkTypes.setDescription('This attribute indicates a maximum of eight types of trunks that can be part of the selected route. The terrestrial and satellite trunk types have been defined already, leaving six remaining types that can be defined by the network administrator. The trunkType attribute of the Trunk PathAdministrator (Trk Pa) component specifies the type of the trunk. When selecting a route, RouteSelector only chooses trunks whose trunkType is one of the permittedTrunkTypes. Description of bits: terrestrial(0) satellite(1) trunkType1(2) trunkType2(3) trunkType3(4) trunkType4(5) trunkType5(6) trunkType6(7)')
rtgRsCustomerParameter = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 2, 12, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 7)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rtgRsCustomerParameter.setStatus('mandatory')
if mibBuilder.loadTexts: rtgRsCustomerParameter.setDescription('This attribute indicates the mechanism to customize the usage of trunks. Any trunk, whose customerParameter attribute under the Trunk PathAdministrator (Trk Pa) component is larger than the requiredCustomerParameter is not eligible to become part of the selected route.')
rtgRsPathAttributeToMinimize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 2, 12, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("cost", 0), ("delay", 1))).clone('cost')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rtgRsPathAttributeToMinimize.setStatus('mandatory')
if mibBuilder.loadTexts: rtgRsPathAttributeToMinimize.setDescription('This attribute indicates whether a route should be selected on the basis of minimizing the route cost or the route delay. Each trunk has a cost and a delay metric associated with it. The cost of a route is the sum of the trunk cost metrics for all trunks included in the route. The delay of a route is the sum of the trunk delay metrics for all trunks included in the route. The delay metric of a trunk is equal to half the measuredRoundTripDelay operational attribute of the trunk.')
rtgRsMaximumAcceptableCost = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 2, 12, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(1280)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rtgRsMaximumAcceptableCost.setStatus('mandatory')
if mibBuilder.loadTexts: rtgRsMaximumAcceptableCost.setDescription('This attribute indicates the upper bound on the cost metric of the selected route, which is the sum of the cost metrics of all trunks on the route. RouteSelector ensures the cost metric of the selected route does not exceed the maximumAcceptableCost.')
rtgRsMaximumAcceptableDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 2, 12, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 100000)).clone(100000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rtgRsMaximumAcceptableDelay.setStatus('mandatory')
if mibBuilder.loadTexts: rtgRsMaximumAcceptableDelay.setDescription('This attribute indicates the upper bound on the delay metric of the selected route, which is the sum of the delay metrics of all trunks on the route. RouteSelector ensures the delay metric of the selected route does not exceed the maximumAcceptableDelay. The delay metric of a trunk is equal to half the measuredRoundTripDelay operational attribute of the trunk.')
rtgRsBumpPreference = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 2, 12, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("bumpWhenNecessary", 0), ("bumpToObtainBestRoute", 1))).clone('bumpWhenNecessary')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rtgRsBumpPreference.setStatus('mandatory')
if mibBuilder.loadTexts: rtgRsBumpPreference.setDescription('This attribute indicates whether bumping may be considered when selecting a route. By default, bumping may be considered only when it is necessary. That is, only when no other route to the destination or gateway node can be found An indication to always bump in order to find the best route may be set. In this case an absolutely best route to the destination or gateway node is found even if other paths along that route would need bumping.')
rtgRsRequiredTrunkModes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 2, 12, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("any", 0), ("mapping", 1))).clone('any')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rtgRsRequiredTrunkModes.setStatus('mandatory')
if mibBuilder.loadTexts: rtgRsRequiredTrunkModes.setDescription('This attribute indicates which trunk modes to consider during route selection. The operational mode attribute of the Trunk PathAdministrator (Trk Pa) component specifies the mode of the trunk. When selecting a route, RouteSelector can either consider trunks with any mode, or only trunks with mode set to mapping. That is, the selected route may contain trunks with any mode, or all trunks with mode set to mapping.')
rtgRsMaximumAcceptableGatewayCost = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 2, 12, 1, 16), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(2048)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rtgRsMaximumAcceptableGatewayCost.setStatus('mandatory')
if mibBuilder.loadTexts: rtgRsMaximumAcceptableGatewayCost.setDescription('This attribute indicates the upper bound on the cost metric associated with reaching the destination along the selected route and through a gateway node. Such cost metrics are provisioned under Trunk Address component on a gateway node specifying costs of reaching an address through the gateway node and more accurately through the gateway link represented by the Trunk component.')
rtgRsRouteRequestor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 2, 12, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("applicationService", 0), ("inboundRGty", 1), ("outboundRGty", 2))).clone('applicationService')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rtgRsRouteRequestor.setStatus('mandatory')
if mibBuilder.loadTexts: rtgRsRouteRequestor.setDescription('This attribute indicates the type of entity that makes a request for a route (route requestor). Three types of entities can make route requests: application service, Routing Gateway serving as inbound gateway at a gateway node, or Routing Gateway serving as outbound gateway at a gateway node.')
rtgRsGatewaySelectionAlg = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 2, 12, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4))).clone(namedValues=NamedValues(("costBased", 1), ("random", 2), ("legacy", 4))).clone('costBased')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rtgRsGatewaySelectionAlg.setStatus('mandatory')
if mibBuilder.loadTexts: rtgRsGatewaySelectionAlg.setDescription('This attribute indicates the type of algorithm to use when a route to the destination has to be selected indirectly through a gateway node. The following types of algorithms are available: cost based, random, and legacy. For cost based algorithm, RouteSelector selects gateway node that advertised it can reach the destination at the smallest cost. For random algorithm, RouteSelector selects randomly any gateway node that advertised it can reach the destination. For legacy algorithm, RouteSelector selects a complete route to the destination without attempting to route through gateway nodes. This is only possible during single to multi topology region migration, or cluster migration but before such migration is complete. During such migrations routing to the destination is initially attempted through gateway nodes, but if such routing fails then legacy routing is attempted.')
rtgRsDestination = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 2, 12, 1, 20), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 45))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rtgRsDestination.setStatus('mandatory')
if mibBuilder.loadTexts: rtgRsDestination.setDescription("This attribute indicates either the ASCII name, node ID, or NSAP address of the destination node to which a route needs to be found. The format for destination is either 1. 'EM/nodeName serviceName/instance', for ASCII name, for example 'EM/MoonBase VS/3', or 2. 'NID/nodeId', for node ID, for example 'NID/1226', or 3. 'NSAP/nsapAddress', for NSAP address, for example 'NSAP/12234001'. For NSAP address formats a full ATM End System Address, node summary, or reachable address can be specified, as well as a node prefix.")
rtgRsSrdTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 2, 224), )
if mibBuilder.loadTexts: rtgRsSrdTable.setStatus('mandatory')
if mibBuilder.loadTexts: rtgRsSrdTable.setDescription("This attribute indicates a vector of strings describing the selected or manual route returned by RouteSelector. Each entry in the vector describes one hop of the route. The hops are identified using a node name and either - a TRM allocated trunk identification or exit number (TRM uses a component 'link', or 'Lk' in short form, to refer to trunks), or - a trunk name, which is local to that node. TRM allocated exit number is used for routes selected by RouteSelector. Trunk name is used for manual routes. For example, a hop out of node StarBase using exit number 99 is described as 'EM/STARBASE Trm Lk/99' for the selected route. A hop out of node StarBase using trunk name 123 is described as 'EM/STARBASE TRK/123' for the manual route. A command display Trm Lk/99 on node StarBase can be used to find out the trunk name corresponding to exit number 99.")
rtgRsSrdEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 2, 224, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-BaseRoutingMIB", "rtgIndex"), (0, "Nortel-Magellan-Passport-PorsVcMIB", "rtgRsIndex"), (0, "Nortel-Magellan-Passport-PorsVcMIB", "rtgRsSrdIndex"))
if mibBuilder.loadTexts: rtgRsSrdEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rtgRsSrdEntry.setDescription('An entry in the rtgRsSrdTable.')
rtgRsSrdIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 2, 224, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)))
if mibBuilder.loadTexts: rtgRsSrdIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rtgRsSrdIndex.setDescription('This variable represents the rtgRsSrdTable specific index for the rtgRsSrdTable.')
rtgRsSrdValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 2, 224, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgRsSrdValue.setStatus('mandatory')
if mibBuilder.loadTexts: rtgRsSrdValue.setDescription('This variable represents an individual value for the rtgRsSrdTable.')
rtgRsRouteStatisticsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 2, 225), )
if mibBuilder.loadTexts: rtgRsRouteStatisticsTable.setStatus('mandatory')
if mibBuilder.loadTexts: rtgRsRouteStatisticsTable.setDescription('This attribute indicates a table (or an array) of the number of route requests and the number of routes selected. There are six rows and five columns in the table. The first row contains a number of route requests in a column. Each column corresponds to a value of setupPriority (= 0,1,2,3,4). An element in the first row gives a number of route request per given setupPriority. The five subsequent rows provide numbers of routes selected at bumpingPriority 0,1,2,3,4. The second row provides numbers of route selections at bumpingPriority 0. Only route requests of setupPriority 0 could be given routes of the bumpingPriority 0. By virtue of the property of bumpingPriority that it cannot be better than the setupPriority the rows two to six form a lower triangular matrix. Route selections performed upon operator request (manual route requests) are not counted.')
rtgRsRouteStatisticsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 2, 225, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-BaseRoutingMIB", "rtgIndex"), (0, "Nortel-Magellan-Passport-PorsVcMIB", "rtgRsIndex"), (0, "Nortel-Magellan-Passport-PorsVcMIB", "rtgRsRouteStatisticsSetupPriorityIndex"), (0, "Nortel-Magellan-Passport-PorsVcMIB", "rtgRsRouteStatisticsStatisticsTableIndex"))
if mibBuilder.loadTexts: rtgRsRouteStatisticsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rtgRsRouteStatisticsEntry.setDescription('An entry in the rtgRsRouteStatisticsTable.')
rtgRsRouteStatisticsSetupPriorityIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 2, 225, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("routesRequested", 0), ("routesSelectedAtBp0", 1), ("routesSelectedAtBp1", 2), ("routesSelectedAtBp2", 3), ("routesSelectedAtBp3", 4), ("routesSelectedAtBp4", 5))))
if mibBuilder.loadTexts: rtgRsRouteStatisticsSetupPriorityIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rtgRsRouteStatisticsSetupPriorityIndex.setDescription('This variable represents the next to last index for the rtgRsRouteStatisticsTable.')
rtgRsRouteStatisticsStatisticsTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 2, 225, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4)))
if mibBuilder.loadTexts: rtgRsRouteStatisticsStatisticsTableIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rtgRsRouteStatisticsStatisticsTableIndex.setDescription('This variable represents the final index for the rtgRsRouteStatisticsTable.')
rtgRsRouteStatisticsValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 2, 225, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgRsRouteStatisticsValue.setStatus('mandatory')
if mibBuilder.loadTexts: rtgRsRouteStatisticsValue.setDescription('This variable represents an individual value for the rtgRsRouteStatisticsTable.')
rtgRsDgnTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 2, 650), )
if mibBuilder.loadTexts: rtgRsDgnTable.setStatus('mandatory')
if mibBuilder.loadTexts: rtgRsDgnTable.setDescription('This attribute indicates a set of node IDs of destination or gateway nodes which directly or indirectly support the destination and to which RouteSelector attempted to find a route. Node to which the RouteSelector selected the route is also included in destinationOrGatewayNodes.')
rtgRsDgnEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 2, 650, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-BaseRoutingMIB", "rtgIndex"), (0, "Nortel-Magellan-Passport-PorsVcMIB", "rtgRsIndex"), (0, "Nortel-Magellan-Passport-PorsVcMIB", "rtgRsDgnValue"))
if mibBuilder.loadTexts: rtgRsDgnEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rtgRsDgnEntry.setDescription('An entry in the rtgRsDgnTable.')
rtgRsDgnValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 2, 650, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgRsDgnValue.setStatus('mandatory')
if mibBuilder.loadTexts: rtgRsDgnValue.setDescription('This variable represents both the value and the index for the rtgRsDgnTable.')
rtgPors = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 6))
rtgPorsRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 6, 1), )
if mibBuilder.loadTexts: rtgPorsRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: rtgPorsRowStatusTable.setDescription('This entry controls the addition and deletion of rtgPors components.')
rtgPorsRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 6, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-BaseRoutingMIB", "rtgIndex"), (0, "Nortel-Magellan-Passport-PorsVcMIB", "rtgPorsIndex"))
if mibBuilder.loadTexts: rtgPorsRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rtgPorsRowStatusEntry.setDescription('A single entry in the table represents a single rtgPors component.')
rtgPorsRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 6, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rtgPorsRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rtgPorsRowStatus.setDescription('This variable is used as the basis for SNMP naming of rtgPors components. These components can be added and deleted.')
rtgPorsComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 6, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgPorsComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: rtgPorsComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
rtgPorsStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 6, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgPorsStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: rtgPorsStorageType.setDescription('This variable represents the storage type value for the rtgPors tables.')
rtgPorsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 6, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: rtgPorsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rtgPorsIndex.setDescription('This variable represents the index for the rtgPors tables.')
rtgPorsProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 6, 10), )
if mibBuilder.loadTexts: rtgPorsProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: rtgPorsProvTable.setDescription('This group contains all provisionable attributes for the Routing PathOrientedRoutingSystem component.')
rtgPorsProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 6, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-BaseRoutingMIB", "rtgIndex"), (0, "Nortel-Magellan-Passport-PorsVcMIB", "rtgPorsIndex"))
if mibBuilder.loadTexts: rtgPorsProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rtgPorsProvEntry.setDescription('An entry in the rtgPorsProvTable.')
rtgPorsOptimizationInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 6, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 1440), )).clone(30)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rtgPorsOptimizationInterval.setStatus('mandatory')
if mibBuilder.loadTexts: rtgPorsOptimizationInterval.setDescription('This attribute defines the interval at which the optimization process will be triggered. The time is defined from the end of one optimization pass until the start of another optimization pass. If an interval of zero is specified periodic optimization is disabled on this module.')
rtgPorsInfoTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 6, 11), )
if mibBuilder.loadTexts: rtgPorsInfoTable.setStatus('mandatory')
if mibBuilder.loadTexts: rtgPorsInfoTable.setDescription('This group contains operational information for the PathOrientedRoutingSystem component.')
rtgPorsInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 6, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-BaseRoutingMIB", "rtgIndex"), (0, "Nortel-Magellan-Passport-PorsVcMIB", "rtgPorsIndex"))
if mibBuilder.loadTexts: rtgPorsInfoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rtgPorsInfoEntry.setDescription('An entry in the rtgPorsInfoTable.')
rtgPorsActiveConnections = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 6, 11, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgPorsActiveConnections.setStatus('mandatory')
if mibBuilder.loadTexts: rtgPorsActiveConnections.setDescription('This attribute is the current number of active PORS connections on this module. Active connections are connections that are in the Logical Connection component pathUp state. This value is updated when requested and represents the current number of active PORS connections. During PORS optimization this number represents all the connections that receive optimization requests.')
rtgPorsOptimizationState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 6, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("disabled", 0), ("scheduled", 1), ("optimizing", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgPorsOptimizationState.setStatus('mandatory')
if mibBuilder.loadTexts: rtgPorsOptimizationState.setDescription('This attribute is the current state of the PORS optimization. The disabled state means that the optimizationInterval has been set to zero. The scheduled state means that the optimization will be started at the nextOptimizationTime. The optimizing state means that PORS is currently attempting to optimize all connections on the module.')
rtgPorsLastOptimizationTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 6, 11, 1, 3), EnterpriseDateAndTime().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(19, 19), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgPorsLastOptimizationTime.setStatus('mandatory')
if mibBuilder.loadTexts: rtgPorsLastOptimizationTime.setDescription('This attribute specifies the time that the last optimization started.')
rtgPorsNextOptimizationTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 6, 11, 1, 4), EnterpriseDateAndTime().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(19, 19), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgPorsNextOptimizationTime.setStatus('mandatory')
if mibBuilder.loadTexts: rtgPorsNextOptimizationTime.setDescription('This attribute specifies the time the next optimization process will begin. In the event that optimizationInterval is set to zero this value is also set to 0.')
rtgPorsOptimizationPasses = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 6, 11, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgPorsOptimizationPasses.setStatus('mandatory')
if mibBuilder.loadTexts: rtgPorsOptimizationPasses.setDescription('This is the number of optimization passes for the PORS connection manager. An optimization pass consists of a notification to each active PORS connection to attempt to optimize. All types of optimization passes are included in this statistic.')
rtgPorsOptimizationProgress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 6, 11, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgPorsOptimizationProgress.setStatus('mandatory')
if mibBuilder.loadTexts: rtgPorsOptimizationProgress.setDescription('This attribute is the percentage of active connections that have been sent an optimization request. A message is sent to each PORS component LC requesting it to optimize its route. This value is cleared at the beginning of each optimization pass.')
rtgPorsPathsOptimized = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 6, 11, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgPorsPathsOptimized.setStatus('mandatory')
if mibBuilder.loadTexts: rtgPorsPathsOptimized.setDescription('This attribute is the number of successfully optimized paths for the latest optimization pass. Successfully optimized paths are paths that switched to a better route. This value is cleared at the beginning of each optimization pass.')
rtgPorsTotalPathsOptimized = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 6, 11, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgPorsTotalPathsOptimized.setStatus('mandatory')
if mibBuilder.loadTexts: rtgPorsTotalPathsOptimized.setDescription('This attribute is the number of successfully optimized paths on this module since the CP became active.')
rtgPorsProf = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 6, 7))
rtgPorsProfRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 6, 7, 1), )
if mibBuilder.loadTexts: rtgPorsProfRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: rtgPorsProfRowStatusTable.setDescription('This entry controls the addition and deletion of rtgPorsProf components.')
rtgPorsProfRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 6, 7, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-BaseRoutingMIB", "rtgIndex"), (0, "Nortel-Magellan-Passport-PorsVcMIB", "rtgPorsIndex"), (0, "Nortel-Magellan-Passport-PorsVcMIB", "rtgPorsProfIndex"))
if mibBuilder.loadTexts: rtgPorsProfRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rtgPorsProfRowStatusEntry.setDescription('A single entry in the table represents a single rtgPorsProf component.')
rtgPorsProfRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 6, 7, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rtgPorsProfRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rtgPorsProfRowStatus.setDescription('This variable is used as the basis for SNMP naming of rtgPorsProf components. These components can be added and deleted.')
rtgPorsProfComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 6, 7, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgPorsProfComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: rtgPorsProfComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
rtgPorsProfStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 6, 7, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgPorsProfStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: rtgPorsProfStorageType.setDescription('This variable represents the storage type value for the rtgPorsProf tables.')
rtgPorsProfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 6, 7, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)))
if mibBuilder.loadTexts: rtgPorsProfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rtgPorsProfIndex.setDescription('This variable represents the index for the rtgPorsProf tables.')
rtgPorsProfProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 6, 7, 11), )
if mibBuilder.loadTexts: rtgPorsProfProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: rtgPorsProfProvTable.setDescription('This group contains all provisionable attributes for a PORS profile..')
rtgPorsProfProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 6, 7, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-BaseRoutingMIB", "rtgIndex"), (0, "Nortel-Magellan-Passport-PorsVcMIB", "rtgPorsIndex"), (0, "Nortel-Magellan-Passport-PorsVcMIB", "rtgPorsProfIndex"))
if mibBuilder.loadTexts: rtgPorsProfProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rtgPorsProfProvEntry.setDescription('An entry in the rtgPorsProfProvTable.')
rtgPorsProfSetupPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 6, 7, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rtgPorsProfSetupPriority.setStatus('mandatory')
if mibBuilder.loadTexts: rtgPorsProfSetupPriority.setDescription("This attribute specifies the priority at which a path is established. Zero is the highest priority and four is the lowest. When PORS establishes a path through the network, it uses the setupPriority attribute to determine its potential for bumping established paths to acquire their bandwidth. The holdingPriority, a complementary attribute of this attribute, specifies the priority a path maintains once it is established. A new path can bump an existing path if the new path's setupPriority is higher (numerically less) than the existing path's holdingPriority.")
rtgPorsProfHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 6, 7, 11, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rtgPorsProfHoldingPriority.setStatus('mandatory')
if mibBuilder.loadTexts: rtgPorsProfHoldingPriority.setDescription("This attribute specifies the priority that a path holds once it is established. Zero is the highest priority and four is the lowest. A path's holdingPriority determines this path's likelihood of being bumped by a new path to acquire its bandwidth. The setupPriority, a complementary attribute, indicates the priority of a path at establishment time. A new path can bump an existing path if the new path's setupPriority is higher (numerically less) than the existing path's holdingPriority.")
rtgPorsProfRequiredTxBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 6, 7, 11, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 155520000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rtgPorsProfRequiredTxBandwidth.setStatus('mandatory')
if mibBuilder.loadTexts: rtgPorsProfRequiredTxBandwidth.setDescription('This attribute specifies the bandwidth (in bits per second) reserved by a path on each of the trunks of its route.This attribute represents the bandwidth for traffic outgoing to the remote end point. This value should be chosen to achieve the amount of statistical bandwidth sharing that is desired by the network administration. This reservation is not enforced but is used to determine how many paths can be supported on a trunk. Both ends should be provisioned with the correct values allowing for the fact that transmit at this end represents receive at the remote end. Note that when the values do not correspond, the originating end of the connection determines the value. A value of 0 (the default) means that the bandwidth will be the Peak Cell Rate for CLP0+1 as chosen by the user. A non zero value overrides this reservation.')
rtgPorsProfRequiredRxBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 6, 7, 11, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 155520000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rtgPorsProfRequiredRxBandwidth.setStatus('mandatory')
if mibBuilder.loadTexts: rtgPorsProfRequiredRxBandwidth.setDescription('This attribute specifies the bandwidth (in bits per second) reserved by a path on each of trunks of its route. This attribute represents the bandwidth for traffic incoming from the remote end point. This value should be chosen to achieve the amount of statistical bandwidth sharing that is desired by the network administration. This reservation is not enforced but is used to determine how many paths can be supported on a trunk. Both ends should be provisioned with the correct values allowing for the fact that transmit at this end represents receive at the remote end. Note that when the values do not correspond, the originating end of the connection determines the value. A value of 0 (the default) means that the bandwidth will be the Peak Cell Rate for CLP0+1 as chosen by the user. A non zero value overrides this reservation.')
rtgPorsProfRequiredTrafficType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 6, 7, 11, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("voice", 0), ("data", 1), ("video", 2), ("trafficType1", 3), ("trafficType2", 4), ("trafficType3", 5), ("trafficType4", 6), ("trafficType5", 7))).clone('data')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rtgPorsProfRequiredTrafficType.setStatus('mandatory')
if mibBuilder.loadTexts: rtgPorsProfRequiredTrafficType.setDescription('This attribute specifies the type of traffic transmitted over the path. There are eight possible traffic types, and the path can transmit only one of them. The originating end of the connection determines the type. The voice, data and video traffic types are defined, and five other arbitrary traffic types can be defined by the network administration. This attribute is used in the route selection process to restrict the route to trunks that support this traffic type. The supportedTrafficType trunk attribute lists all the types of traffic allowed on the trunk. For example, if requiredTrafficType is specified as trafficType1, then only trunks that include trafficType1 in supportedTrafficType will be candidates for this connection.')
rtgPorsProfPermittedTrunkTypes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 6, 7, 11, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1).clone(hexValue="f8")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rtgPorsProfPermittedTrunkTypes.setStatus('mandatory')
if mibBuilder.loadTexts: rtgPorsProfPermittedTrunkTypes.setDescription("This attribute specifies up to eight types of trunk that can be used on the route. The terrestrial and satellite trunk types have been defined, leaving six remaining arbitrary types that can be defined by the network administration. The trunk's type is indicated in the trunkType attribute of the Trunk component. When selecting a route, PORS only chooses trunks whose trunkType are in the permittedTrunkTypes for the path. Description of bits: terrestrial(0) satellite(1) trunkType1(2) trunkType2(3) trunkType3(4) trunkType4(5) trunkType5(6) trunkType6(7)")
rtgPorsProfRequiredSecurity = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 6, 7, 11, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 7)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rtgPorsProfRequiredSecurity.setStatus('mandatory')
if mibBuilder.loadTexts: rtgPorsProfRequiredSecurity.setDescription("This attribute specifies the required minimum level of security of the trunks on the route. A value of zero represents the most secure while seven represents the least secure. The trunk's security is indicated by the trunkSecurity attribute of the Trunk component, and has values identical in range and meaning to the requiredSecurity attribute. PORS ensures that any route selected does not contain a trunk whose trunkSecurity attribute is numerically greater than the requiredSecurity.")
rtgPorsProfRequiredCustomerParm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 6, 7, 11, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 7)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rtgPorsProfRequiredCustomerParm.setStatus('mandatory')
if mibBuilder.loadTexts: rtgPorsProfRequiredCustomerParm.setDescription('This attribute specifies the allowed customer defined parameter of the trunks on the route. Its value, a number from zero to seven, is chosen by network administration to have a meaning specific to their network, thus allowing them to customize the use of their trunks. A complementary trunk attribute, customerParameter, also has a value from zero to seven. The route selection process does not consider trunks whose customerParameter is greater than the requiredCustomerParameter of the path.')
rtgPorsProfPathAttributeToMinimize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 6, 7, 11, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("cost", 0), ("delay", 1))).clone('cost')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rtgPorsProfPathAttributeToMinimize.setStatus('mandatory')
if mibBuilder.loadTexts: rtgPorsProfPathAttributeToMinimize.setDescription('This attribute specifies whether a route is selected on the basis of minimizing the cost or the delay. Each trunk has a cost and a delay metric associated with it. The cost of a selected route is the sum of the trunk cost metrics for all trunks included in the route. The delay of a selected route is the sum of the trunk delay metric for all trunks included in the route.')
rtgPorsProfMaximumAcceptableCost = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 6, 7, 11, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(1280)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rtgPorsProfMaximumAcceptableCost.setStatus('mandatory')
if mibBuilder.loadTexts: rtgPorsProfMaximumAcceptableCost.setDescription('This attribute specifies an upper bound on the cost metric of a route, which is the sum of the cost metrics of all trunks on the route. The cost metric is the trunkCost attribute of the Trunk component. If for any trunk the trunkCost is larger than the maximumAcceptableCost, then that trunk is not considered during the route selection. While a shortest route is being selected, the route cost is being compared with the maximumAcceptableCost attribute, and this is done regardless ofthe value of pathAttributeToMinimize. No route is selected if the cost metric of the shortest route is larger than the maximumAcceptableCost.')
rtgPorsProfMaximumAcceptableDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 6, 7, 11, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 100000)).clone(100000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rtgPorsProfMaximumAcceptableDelay.setStatus('mandatory')
if mibBuilder.loadTexts: rtgPorsProfMaximumAcceptableDelay.setDescription("This attribute specifies an upper bound on the delay of a route, which is the sum of the delay of all trunks on the route. It should be provisioned with a reasonable maximum acceptable delay for the end to end one way delay of a 512 byte packet. Remember, that during its staging, the trunk measures a measuredRoundTripDelay. This delay is divided by two and truncated to an integer number of milliseconds to provide a one way delay which is used to populate the delay in this trunk object in the topological database. The value includes emission, propagation, and queuing delays. A 512 byte data packet is used to perform the measurement. If for any trunk, half of the trunk's measuredRoundTripDelay is larger than the maximumAcceptableDelay, then that trunk is not considered during the route selection. While a shortest route is being selected, the route delay is being compared with the maximumAcceptableDelay attribute, and this is done for any minimization criterion. No route is selected if the delay metric of the shortest route is larger than the maximumAcceptableDelay.")
rtgPorsProfEmissionPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 6, 7, 11, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("ep0", 0), ("ep1", 1), ("ep2", 2), ("sameAsApplication", 3))).clone('sameAsApplication')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rtgPorsProfEmissionPriority.setStatus('mandatory')
if mibBuilder.loadTexts: rtgPorsProfEmissionPriority.setDescription("This attribute specifies the urgency with which packets on the path are emitted by the trunks on the route. An EmissionPriority of zero indicates the highest emission priority, while two indicates the lowest emission priority. Packets with a higher emissionPriority (or numerically less) are serviced and sent out before the packets of lower emissionPriority (or numerically higher). The default value for this attribute (sameAsApplication) will cause the connection's emissionPriority to be inherited from the user of the profile. In other words, setting this attribute to anything other than the default acts as an override to the priority normally used by the application linked to this profile.")
rtgPorsProfDiscardPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 6, 7, 11, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("sameAsApplication", 0), ("dp1", 1), ("dp2", 2), ("dp3", 3))).clone('sameAsApplication')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rtgPorsProfDiscardPriority.setStatus('mandatory')
if mibBuilder.loadTexts: rtgPorsProfDiscardPriority.setDescription("This attribute specifies the importance of the packets on the path. One is used for paths carrying the most important traffic, and three is used for paths carrying the least important traffic. Packets with lower discardPriority (numerically lower) are discarded after packets with a higher discardPriority (numerically higher). The default value for this attribute (sameAsApplication) will cause the connection's discardPriority to be inherited from the user of the profile. In other words, setting this attribute to anything other than the default acts as an override to the priority normally used by the application linked to this profile.")
rtgPorsProfPathFailureAction = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 6, 7, 11, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disconnectConnection", 0), ("reRoutePath", 1))).clone('reRoutePath')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rtgPorsProfPathFailureAction.setStatus('mandatory')
if mibBuilder.loadTexts: rtgPorsProfPathFailureAction.setDescription('This attribute specifies whether the application can tolerate momentary interruption of a path while a new path is selected. If disconnectConnection is chosen, the application is informed as soon as possible about a failure by disconnection. If the attribute is set to reRoutePath, the path may attempt an immediate reroute, provided the failure is a recoverable failure. If rerouting fails the application is informed of the failure. With this option set to reRoutePath the LCo may wait up to 30 seconds before informing the service of complete disconnection in order to allow both ends to attempt to reconnect. Note that if PLC components are different at both ends only the calling end is allowed to reconnect.')
rtgPorsProfBumpPreference = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 6, 7, 11, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("bumpWhenNecessary", 0), ("bumpToObtainBestRoute", 1))).clone('bumpWhenNecessary')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rtgPorsProfBumpPreference.setStatus('mandatory')
if mibBuilder.loadTexts: rtgPorsProfBumpPreference.setDescription('This attribute specifies when bumping may be triggered as a result of this call being routed/rerouted or optimized. There are two possibilities: bumpWhenNecessary: means that this call will only trigger the bumping of another call (subject to setup/holding priority restrictions) when there is no other way to establish a route for this call. bumpToObtainBestRoute: means that this call may trigger the bumping of other calls (subject to setup/holding priority restrictions) if doing so would result in this call obtaining a better (lower cost/delay) route. Since bumping to obtain the best route can be somewhat intrusive the default is only to bump when there is no other way to route the call.')
rtgPorsProfOptimization = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 6, 7, 11, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rtgPorsProfOptimization.setStatus('mandatory')
if mibBuilder.loadTexts: rtgPorsProfOptimization.setDescription('If this attribute is enabled, this connection will be optimized periodically as specified by the Rtg Pors attribute optimizationInterval. If this attribute is disabled, the connection will use the route it was given for the life of the connection or until a failure or lock results in the call being rerouted.')
rtgPorsProfUsrTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 6, 7, 400), )
if mibBuilder.loadTexts: rtgPorsProfUsrTable.setStatus('mandatory')
if mibBuilder.loadTexts: rtgPorsProfUsrTable.setDescription('This attribute specifies all of the components which are associated with this Profile. Users of this profile will select and instantiate routes based on the attributes of this profile when PORS is used to choose and instantiate the route. If IISP or PNNI are used to choose and instantiate the route these attributes are ignored since they have no counterparts in IISP or PNNI routing.')
rtgPorsProfUsrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 6, 7, 400, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-BaseRoutingMIB", "rtgIndex"), (0, "Nortel-Magellan-Passport-PorsVcMIB", "rtgPorsIndex"), (0, "Nortel-Magellan-Passport-PorsVcMIB", "rtgPorsProfIndex"), (0, "Nortel-Magellan-Passport-PorsVcMIB", "rtgPorsProfUsrValue"))
if mibBuilder.loadTexts: rtgPorsProfUsrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rtgPorsProfUsrEntry.setDescription('An entry in the rtgPorsProfUsrTable.')
rtgPorsProfUsrValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 6, 7, 400, 1, 1), Link()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgPorsProfUsrValue.setStatus('mandatory')
if mibBuilder.loadTexts: rtgPorsProfUsrValue.setDescription('This variable represents both the value and the index for the rtgPorsProfUsrTable.')
rtgPorsMpath = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 6, 8))
rtgPorsMpathRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 6, 8, 1), )
if mibBuilder.loadTexts: rtgPorsMpathRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: rtgPorsMpathRowStatusTable.setDescription('This entry controls the addition and deletion of rtgPorsMpath components.')
rtgPorsMpathRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 6, 8, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-BaseRoutingMIB", "rtgIndex"), (0, "Nortel-Magellan-Passport-PorsVcMIB", "rtgPorsIndex"), (0, "Nortel-Magellan-Passport-PorsVcMIB", "rtgPorsMpathIndex"))
if mibBuilder.loadTexts: rtgPorsMpathRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rtgPorsMpathRowStatusEntry.setDescription('A single entry in the table represents a single rtgPorsMpath component.')
rtgPorsMpathRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 6, 8, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rtgPorsMpathRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rtgPorsMpathRowStatus.setDescription('This variable is used as the basis for SNMP naming of rtgPorsMpath components. These components can be added and deleted.')
rtgPorsMpathComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 6, 8, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgPorsMpathComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: rtgPorsMpathComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
rtgPorsMpathStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 6, 8, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgPorsMpathStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: rtgPorsMpathStorageType.setDescription('This variable represents the storage type value for the rtgPorsMpath tables.')
rtgPorsMpathIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 6, 8, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)))
if mibBuilder.loadTexts: rtgPorsMpathIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rtgPorsMpathIndex.setDescription('This variable represents the index for the rtgPorsMpath tables.')
rtgPorsMpathOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 6, 8, 12), )
if mibBuilder.loadTexts: rtgPorsMpathOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: rtgPorsMpathOperTable.setDescription('This group contains operational information for the Rtg Pors ManualPath/n component.')
rtgPorsMpathOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 6, 8, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-BaseRoutingMIB", "rtgIndex"), (0, "Nortel-Magellan-Passport-PorsVcMIB", "rtgPorsIndex"), (0, "Nortel-Magellan-Passport-PorsVcMIB", "rtgPorsMpathIndex"))
if mibBuilder.loadTexts: rtgPorsMpathOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rtgPorsMpathOperEntry.setDescription('An entry in the rtgPorsMpathOperTable.')
rtgPorsMpathLastSetupFailureReason = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 6, 8, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 14, 15, 17, 19, 20, 23))).clone(namedValues=NamedValues(("none", 0), ("insufficientTxLcOrBandwidth", 2), ("insufficientRxLcOrBandwidth", 3), ("trunkFailure", 4), ("trunkCardFailure", 5), ("operatorForced", 6), ("lostLcnClash", 7), ("networkCongestion", 8), ("trunkNotFound", 9), ("farEndNotFound", 10), ("farEndBusy", 12), ("unknownReason", 14), ("farEndNotReady", 15), ("serviceTypeMismatch", 17), ("bumped", 19), ("accessCardFailure", 20), ("trunkOrFarEndDidNotSupportMode", 23))).clone('none')).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgPorsMpathLastSetupFailureReason.setStatus('mandatory')
if mibBuilder.loadTexts: rtgPorsMpathLastSetupFailureReason.setDescription("This attribute indicates the reason for the most recent failure for an attempted connection using this ManualPath's route. The following is a brief description of the reasons: none - This path has no information for the teardown. insufficientTxLcOrBandwidth - At present there is either no available bandwidth or logical channel numbers available on one or more of the Trunks for this path in the transmit direction. If a trunk in the route attribute was previously locked, or has a Trk PA subcomponent that is not in the up state , that Trunk is considered as having no available bandwidth. If the Trunk PA is in mapped mode, the inability to allocate an Atmif Vcc also results in this failure reason. insufficientRxLcOrBandwidth - At present there is either no available bandwidth or logical channel numbers available on one or more of the Trunks for this path in the receive direction. If a trunk in the route attribute was previously locked, or has a Trk PA subcomponent that is not in the up state , that Trunk is considered as having no available bandwidth. trunkFailure- A Trunk on the path has failed or has gone down, due to a provisioning change of a critical attribute, as the path was being established. trunkCardFailure- A Trunk FP card has failed along the path as the path was being established. accessCardFailure- The FP on which the peer access service was running has failed as the path was being established. operatorForced- The path has terminated due to the operator locking a Trunk along the path as the path was being established. lostLcnClash- The path has terminated because the Trk PA's at both ends of an intermediate trunk have allocated the same Trk LC to different calls. When this happens both calls must go down and then try to come up again a fraction of a second later (effectively ensuring that they will now be assigned different Trk LC's). It is normal to get the odd clash especially when the Trk PA usedLC is approaching the Trk PA maxLC. An LCN clash results in the path failing to instantiate only if the application disabled rerouting. By default rerouting is enabled for all applications. Applications can disable rerouting by using a Rtg Pors Prof/n component with pathFailureAction set to disconnectConnection. networkCongestion - The path has failed to establish due to control information being lost and not being recoverable. trunkNotFound - Check for Trunks not up or names provisioned incorrectly in route attribute . farEndNotFound - The far end is not provisioned or is not up. The called NSAP address cannot be reached through the last node in the Rtg Pors ManualPath path. farEndBusy - The far end has been reached but it is busy. Check remote end provisioning. unknownReason - The failure was not resolved. farEndNotReady - The remote end was reached but the connection was refused due to the remote end not being enabled. serviceTypeMismatch - The remote service type does not match this service type. Check provisioning. bumped - Another call bumped this path, as it was being established, from a trunk to get bandwidth (or an LC) which it required to come up. This other path had a higher setupPriority than this path's holdingPriority hence it was allowed to steal the bandwidth (or LC) from this path. A manual path that is bumped fails to instantiate if it cannot bump another path along the same route, or if it has pathFailureAction set to disconnectConnection. trunkOrFarEndDidNotSupportMode - This call was unable to complete because a mode required by the service was not supported by one of the Trunks the route went through or by the far end service it connected to. Currently the only mode that this applies to is the map/mux mode on Trk Pa Atm component.")
rtgPorsMpathLastSetupFailurePoint = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 6, 8, 12, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgPorsMpathLastSetupFailurePoint.setStatus('mandatory')
if mibBuilder.loadTexts: rtgPorsMpathLastSetupFailurePoint.setDescription('This attribute indicates the point in the route at which the path failed to establish. A failure at either end of a trunk will result in the display of the name of the trunk nearer the calling end.')
rtgPorsMpathLastSetupFailedUser = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 6, 8, 12, 1, 3), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgPorsMpathLastSetupFailedUser.setStatus('mandatory')
if mibBuilder.loadTexts: rtgPorsMpathLastSetupFailedUser.setDescription('This attribute indicates the component in the users attribute that last failed to instantiate a path based on the route.')
rtgPorsMpathRouteTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 6, 8, 408), )
if mibBuilder.loadTexts: rtgPorsMpathRouteTable.setStatus('mandatory')
if mibBuilder.loadTexts: rtgPorsMpathRouteTable.setDescription("This attribute specifies the sequence of trunks used as the route for a path. If any trunk in the sequence does not meet the requirements (bandwidth, permittedTrunkType, security, customerParm, etc.) for a component listed in users, path validation fails and no path is instantiated for that user. Changing this attribute will cause active connections of users of this ManualPath to move to the new route only if the users have optimization enabled and Rtg Pors optimizationInterval > 0. Otherwise, changing this attribute will cause the users' current connections to stay on the old route with all new calls instantiating their paths with the new route. Optimization can be disabled by having the application use a Rtg Pors Prof/n component with optimization disabled or by setting Rtg Pors optimizationInterval 0. As an example, the trunk component name for the trunk instance 10 on node MoonBase is EM/MoonBase Trk/10. These strings are case insensitive but the complete component name must be input. Note 1: the trunk designation must be in the 3-letter form 'trk'. Note 2: only the outbound trunk component names are used to provision the route.")
rtgPorsMpathRouteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 6, 8, 408, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-BaseRoutingMIB", "rtgIndex"), (0, "Nortel-Magellan-Passport-PorsVcMIB", "rtgPorsIndex"), (0, "Nortel-Magellan-Passport-PorsVcMIB", "rtgPorsMpathIndex"), (0, "Nortel-Magellan-Passport-PorsVcMIB", "rtgPorsMpathRouteIndex"))
if mibBuilder.loadTexts: rtgPorsMpathRouteEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rtgPorsMpathRouteEntry.setDescription('An entry in the rtgPorsMpathRouteTable.')
rtgPorsMpathRouteIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 6, 8, 408, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 19)))
if mibBuilder.loadTexts: rtgPorsMpathRouteIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rtgPorsMpathRouteIndex.setDescription('This variable represents the rtgPorsMpathRouteTable specific index for the rtgPorsMpathRouteTable.')
rtgPorsMpathRouteValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 6, 8, 408, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rtgPorsMpathRouteValue.setStatus('mandatory')
if mibBuilder.loadTexts: rtgPorsMpathRouteValue.setDescription('This variable represents an individual value for the rtgPorsMpathRouteTable.')
rtgPorsMpathUsrTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 6, 8, 409), )
if mibBuilder.loadTexts: rtgPorsMpathUsrTable.setStatus('mandatory')
if mibBuilder.loadTexts: rtgPorsMpathUsrTable.setDescription('This attribute specifies all of the components that will use this ManualPath to instantiate a path. Users of this component have paths that follow the sequence of Trunks specified in the route attribute of this component when PORS is used to choose and instantiate the route.')
rtgPorsMpathUsrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 6, 8, 409, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-BaseRoutingMIB", "rtgIndex"), (0, "Nortel-Magellan-Passport-PorsVcMIB", "rtgPorsIndex"), (0, "Nortel-Magellan-Passport-PorsVcMIB", "rtgPorsMpathIndex"), (0, "Nortel-Magellan-Passport-PorsVcMIB", "rtgPorsMpathUsrValue"))
if mibBuilder.loadTexts: rtgPorsMpathUsrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rtgPorsMpathUsrEntry.setDescription('An entry in the rtgPorsMpathUsrTable.')
rtgPorsMpathUsrValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 6, 8, 409, 1, 1), Link()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgPorsMpathUsrValue.setStatus('mandatory')
if mibBuilder.loadTexts: rtgPorsMpathUsrValue.setDescription('This variable represents both the value and the index for the rtgPorsMpathUsrTable.')
porsVcGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 37, 1))
porsVcGroupBE = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 37, 1, 5))
porsVcGroupBE00 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 37, 1, 5, 1))
porsVcGroupBE00A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 37, 1, 5, 1, 2))
porsVcCapabilities = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 37, 3))
porsVcCapabilitiesBE = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 37, 3, 5))
porsVcCapabilitiesBE00 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 37, 3, 5, 1))
porsVcCapabilitiesBE00A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 37, 3, 5, 1, 2))
mibBuilder.exportSymbols("Nortel-Magellan-Passport-PorsVcMIB", porsVcCapabilitiesBE00=porsVcCapabilitiesBE00, rtgRsRouteStatisticsStatisticsTableIndex=rtgRsRouteStatisticsStatisticsTableIndex, rtgPorsRowStatusTable=rtgPorsRowStatusTable, rtgRsDgnEntry=rtgRsDgnEntry, rtgPorsProfRowStatusTable=rtgPorsProfRowStatusTable, porsVcGroupBE=porsVcGroupBE, porsVcGroupBE00=porsVcGroupBE00, rtgPorsProfStorageType=rtgPorsProfStorageType, rtgRsTrafficType=rtgRsTrafficType, rtgRsRouteSelectionAttributes=rtgRsRouteSelectionAttributes, rtgPorsProfRequiredSecurity=rtgPorsProfRequiredSecurity, porsVcCapabilities=porsVcCapabilities, rtgPorsProfRequiredTrafficType=rtgPorsProfRequiredTrafficType, rtgPorsProvTable=rtgPorsProvTable, rtgRsRouteGatewayCostMetric=rtgRsRouteGatewayCostMetric, rtgPorsMpath=rtgPorsMpath, rtgPorsRowStatus=rtgPorsRowStatus, rtgPorsOptimizationState=rtgPorsOptimizationState, porsVcCapabilitiesBE00A=porsVcCapabilitiesBE00A, rtgPorsProfDiscardPriority=rtgPorsProfDiscardPriority, rtgRsSrdIndex=rtgRsSrdIndex, rtgPorsProfHoldingPriority=rtgPorsProfHoldingPriority, rtgRsMaximumAcceptableGatewayCost=rtgRsMaximumAcceptableGatewayCost, rtgRsSourceId=rtgRsSourceId, rtgRs=rtgRs, rtgPorsOptimizationProgress=rtgPorsOptimizationProgress, rtgPorsOptimizationPasses=rtgPorsOptimizationPasses, rtgRsBumpingPriority=rtgRsBumpingPriority, porsVcMIB=porsVcMIB, rtgRsRowStatusEntry=rtgRsRowStatusEntry, rtgPorsProfComponentName=rtgPorsProfComponentName, rtgRsRequiredTxBandwidth=rtgRsRequiredTxBandwidth, rtgRsPermittedTrunkTypes=rtgRsPermittedTrunkTypes, rtgPorsMpathRouteValue=rtgPorsMpathRouteValue, rtgRsOperationMode=rtgRsOperationMode, rtgRsDgnValue=rtgRsDgnValue, rtgRsLastRouteSelectionTime=rtgRsLastRouteSelectionTime, rtgPorsComponentName=rtgPorsComponentName, rtgRsRouteCostMetric=rtgRsRouteCostMetric, rtgPorsProfMaximumAcceptableCost=rtgPorsProfMaximumAcceptableCost, rtgPorsMpathUsrEntry=rtgPorsMpathUsrEntry, rtgPorsMpathComponentName=rtgPorsMpathComponentName, rtgRsPathAttributesTable=rtgRsPathAttributesTable, rtgPorsMpathRowStatusEntry=rtgPorsMpathRowStatusEntry, rtgPorsMpathRowStatusTable=rtgPorsMpathRowStatusTable, rtgRsDestination=rtgRsDestination, rtgRsSrdTable=rtgRsSrdTable, rtgPorsMpathUsrTable=rtgPorsMpathUsrTable, rtgPorsMpathOperTable=rtgPorsMpathOperTable, rtgPorsNextOptimizationTime=rtgPorsNextOptimizationTime, rtgPorsProfRequiredRxBandwidth=rtgPorsProfRequiredRxBandwidth, rtgRsMaximumTransmissionUnit=rtgRsMaximumTransmissionUnit, rtgRsRemoteName=rtgRsRemoteName, rtgRsRouteStatisticsSetupPriorityIndex=rtgRsRouteStatisticsSetupPriorityIndex, porsVcGroupBE00A=porsVcGroupBE00A, rtgRsRequiredTrunkModes=rtgRsRequiredTrunkModes, rtgRsGatewaySelectionAlg=rtgRsGatewaySelectionAlg, rtgPorsMpathRouteTable=rtgPorsMpathRouteTable, rtgPorsProfRequiredTxBandwidth=rtgPorsProfRequiredTxBandwidth, rtgPorsProfProvTable=rtgPorsProfProvTable, rtgPorsProfBumpPreference=rtgPorsProfBumpPreference, rtgPorsPathsOptimized=rtgPorsPathsOptimized, rtgPorsMpathLastSetupFailurePoint=rtgPorsMpathLastSetupFailurePoint, rtgRsControlsEntry=rtgRsControlsEntry, rtgRsDgnTable=rtgRsDgnTable, rtgPorsMpathOperEntry=rtgPorsMpathOperEntry, rtgRsRouteDelayMetric=rtgRsRouteDelayMetric, rtgRsReasonForNoRoute=rtgRsReasonForNoRoute, rtgRsSelectedRouteEntry=rtgRsSelectedRouteEntry, rtgPorsMpathRowStatus=rtgPorsMpathRowStatus, rtgPorsProfMaximumAcceptableDelay=rtgPorsProfMaximumAcceptableDelay, rtgRsAttributeNotMet=rtgRsAttributeNotMet, rtgPorsOptimizationInterval=rtgPorsOptimizationInterval, rtgRsMaximumAcceptableCost=rtgRsMaximumAcceptableCost, porsVcCapabilitiesBE=porsVcCapabilitiesBE, rtgRsMaximumAcceptableDelay=rtgRsMaximumAcceptableDelay, rtgRsControlsTable=rtgRsControlsTable, rtgRsPathAttributesEntry=rtgRsPathAttributesEntry, rtgPorsProfOptimization=rtgPorsProfOptimization, rtgRsSetupPriority=rtgRsSetupPriority, rtgRsComponentName=rtgRsComponentName, rtgRsRouteStatisticsEntry=rtgRsRouteStatisticsEntry, rtgPorsProfIndex=rtgPorsProfIndex, rtgRsRequiredRxBandwidth=rtgRsRequiredRxBandwidth, rtgPorsProvEntry=rtgPorsProvEntry, rtgPorsMpathLastSetupFailureReason=rtgPorsMpathLastSetupFailureReason, rtgRsRouteStatisticsValue=rtgRsRouteStatisticsValue, rtgPorsProfSetupPriority=rtgPorsProfSetupPriority, rtgRsRouteStatisticsTable=rtgRsRouteStatisticsTable, rtgPorsMpathLastSetupFailedUser=rtgPorsMpathLastSetupFailedUser, rtgPors=rtgPors, rtgPorsProfUsrEntry=rtgPorsProfUsrEntry, rtgPorsProfEmissionPriority=rtgPorsProfEmissionPriority, rtgPorsTotalPathsOptimized=rtgPorsTotalPathsOptimized, rtgPorsProfRowStatusEntry=rtgPorsProfRowStatusEntry, rtgRsSrdValue=rtgRsSrdValue, rtgPorsProfPathAttributeToMinimize=rtgPorsProfPathAttributeToMinimize, rtgPorsRowStatusEntry=rtgPorsRowStatusEntry, rtgRsSrdEntry=rtgRsSrdEntry, rtgPorsMpathUsrValue=rtgPorsMpathUsrValue, rtgPorsStorageType=rtgPorsStorageType, rtgPorsInfoTable=rtgPorsInfoTable, rtgPorsProfUsrTable=rtgPorsProfUsrTable, porsVcGroup=porsVcGroup, rtgPorsIndex=rtgPorsIndex, rtgRsSecurity=rtgRsSecurity, rtgRsRouteType=rtgRsRouteType, rtgPorsProfRowStatus=rtgPorsProfRowStatus, rtgRsSelectedRouteTable=rtgRsSelectedRouteTable, rtgRsRouteRequestor=rtgRsRouteRequestor, rtgRsBumpPreference=rtgRsBumpPreference, rtgRsStorageType=rtgRsStorageType, rtgRsCustomerParameter=rtgRsCustomerParameter, rtgRsPathAttributeToMinimize=rtgRsPathAttributeToMinimize, rtgRsRowStatusTable=rtgRsRowStatusTable, rtgPorsInfoEntry=rtgPorsInfoEntry, rtgPorsProfProvEntry=rtgPorsProfProvEntry, rtgPorsProfPathFailureAction=rtgPorsProfPathFailureAction, rtgPorsLastOptimizationTime=rtgPorsLastOptimizationTime, rtgPorsMpathRouteEntry=rtgPorsMpathRouteEntry, rtgPorsMpathStorageType=rtgPorsMpathStorageType, rtgPorsActiveConnections=rtgPorsActiveConnections, rtgRsRowStatus=rtgRsRowStatus, rtgPorsProf=rtgPorsProf, rtgPorsProfUsrValue=rtgPorsProfUsrValue, rtgPorsProfPermittedTrunkTypes=rtgPorsProfPermittedTrunkTypes, rtgPorsProfRequiredCustomerParm=rtgPorsProfRequiredCustomerParm, rtgPorsMpathIndex=rtgPorsMpathIndex, rtgPorsMpathRouteIndex=rtgPorsMpathRouteIndex, rtgRsIndex=rtgRsIndex)

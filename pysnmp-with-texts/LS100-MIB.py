#
# PySNMP MIB module LS100-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/LS100-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:08:54 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ConstraintsUnion, ConstraintsIntersection, ValueRangeConstraint, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ConstraintsUnion", "ConstraintsIntersection", "ValueRangeConstraint", "SingleValueConstraint")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
ModuleIdentity, TimeTicks, ObjectIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, NotificationType, IpAddress, enterprises, Unsigned32, MibIdentifier, iso, Counter64, Bits, Counter32, Integer32, Gauge32 = mibBuilder.importSymbols("SNMPv2-SMI", "ModuleIdentity", "TimeTicks", "ObjectIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "NotificationType", "IpAddress", "enterprises", "Unsigned32", "MibIdentifier", "iso", "Counter64", "Bits", "Counter32", "Integer32", "Gauge32")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
class DisplayString(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 255)

nec = MibIdentifier((1, 3, 6, 1, 4, 1, 119))
nec_mib = MibIdentifier((1, 3, 6, 1, 4, 1, 119, 2)).setLabel("nec-mib")
necProductDepend = MibIdentifier((1, 3, 6, 1, 4, 1, 119, 2, 3))
atomis_mib = MibIdentifier((1, 3, 6, 1, 4, 1, 119, 2, 3, 14)).setLabel("atomis-mib")
m5core_mib = MibIdentifier((1, 3, 6, 1, 4, 1, 119, 2, 3, 14, 3)).setLabel("m5core-mib")
node = MibIdentifier((1, 3, 6, 1, 4, 1, 119, 2, 3, 14, 3, 1))
linf = MibIdentifier((1, 3, 6, 1, 4, 1, 119, 2, 3, 14, 3, 2))
conn = MibIdentifier((1, 3, 6, 1, 4, 1, 119, 2, 3, 14, 3, 3))
perf = MibIdentifier((1, 3, 6, 1, 4, 1, 119, 2, 3, 14, 3, 4))
nodeOperStatus = MibScalar((1, 3, 6, 1, 4, 1, 119, 2, 3, 14, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("down", 1), ("active", 2), ("offLine", 3), ("testing", 4), ("initializing", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: nodeOperStatus.setDescription('Operational status of the LS100.')
nodeIfConfTable = MibTable((1, 3, 6, 1, 4, 1, 119, 2, 3, 14, 3, 1, 2), )
if mibBuilder.loadTexts: nodeIfConfTable.setStatus('mandatory')
if mibBuilder.loadTexts: nodeIfConfTable.setDescription('The configuration of the line cards.')
nodeIfConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 119, 2, 3, 14, 3, 1, 2, 1), ).setIndexNames((0, "LS100-MIB", "nodeIfConfIndex"))
if mibBuilder.loadTexts: nodeIfConfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nodeIfConfEntry.setDescription('The configuration of a line card.')
nodeIfConfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 119, 2, 3, 14, 3, 1, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeIfConfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: nodeIfConfIndex.setDescription('The index of the table. Same as ifIndex.')
nodeIfConfPhysType = MibTableColumn((1, 3, 6, 1, 4, 1, 119, 2, 3, 14, 3, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 99))).clone(namedValues=NamedValues(("other", 1), ("sar", 2), ("taxi100M", 3), ("oc3cSMF", 4), ("oc3cMMF", 5), ("ds3PlcpScramble", 6), ("ds3PlcpNoScramble", 7), ("relay6Mcell", 8), ("ds3Scramble", 9), ("ds3NoScramble", 10), ("e3PlcpScramble", 11), ("e3PlcpNoScramble", 12), ("e3Scramble", 13), ("e3NoScramble", 14), ("utp5", 15), ("leasedLine3M", 16), ("leasedLine4M", 17), ("leasedLine6M", 18), ("utp5classB", 19), ("oc3cSmfShaper", 20), ("taxi140M", 21), ("notInstalled", 99)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeIfConfPhysType.setStatus('mandatory')
if mibBuilder.loadTexts: nodeIfConfPhysType.setDescription('The PMD/physical layer format of the line card.')
nodeIfConfRev = MibTableColumn((1, 3, 6, 1, 4, 1, 119, 2, 3, 14, 3, 1, 2, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeIfConfRev.setStatus('mandatory')
if mibBuilder.loadTexts: nodeIfConfRev.setDescription('The revision of the line cards.')
nodeIfConfStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 119, 2, 3, 14, 3, 1, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 99))).clone(namedValues=NamedValues(("other", 1), ("inService", 2), ("outOfService", 3), ("testing", 4), ("localLoopBack", 5), ("remoteLoopBack", 6), ("notInstalled", 99)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeIfConfStatus.setStatus('mandatory')
if mibBuilder.loadTexts: nodeIfConfStatus.setDescription('Operational status of the line card.')
nodeFanStatus = MibScalar((1, 3, 6, 1, 4, 1, 119, 2, 3, 14, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeFanStatus.setStatus('mandatory')
if mibBuilder.loadTexts: nodeFanStatus.setDescription('Operational status of the Fan.')
nodeUpcWindowSize = MibScalar((1, 3, 6, 1, 4, 1, 119, 2, 3, 14, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 120))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nodeUpcWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: nodeUpcWindowSize.setDescription('UPC window size. Integer Wi represents Wi X 512 cell time. Wi=1 correspond to 1.4msec. Wi=120 correspond to 168msec. It is not allowed to change window size when any PVC exists.')
nodeBestEffortBufferSize = MibScalar((1, 3, 6, 1, 4, 1, 119, 2, 3, 14, 3, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nodeBestEffortBufferSize.setStatus('mandatory')
if mibBuilder.loadTexts: nodeBestEffortBufferSize.setDescription('Input buffer capacity for Best Effort traffic(Bb). The number of cells stored in the buffer is Bb X 128. The default value is 8. The sum of the buffer capacity is 2047 cells.')
nodeGuaranteedBufferSize = MibScalar((1, 3, 6, 1, 4, 1, 119, 2, 3, 14, 3, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nodeGuaranteedBufferSize.setStatus('mandatory')
if mibBuilder.loadTexts: nodeGuaranteedBufferSize.setDescription('Input buffer capacity for Guaranteed traffic(Bg). The number of cells stored in the buffer is Bg X 128. The default value is 0. The sum of the buffer capacity is 2047 cells.')
nodeBestEffortBufferThreshold = MibScalar((1, 3, 6, 1, 4, 1, 119, 2, 3, 14, 3, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nodeBestEffortBufferThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: nodeBestEffortBufferThreshold.setDescription('Threshold buffer capacity for Best Effort traffic. If the number of cells stored in the buffer exceeds this threshold, cells with CLP=1 and traffic defined as UBR will be discarded.')
nodeGuaranteedBufferThreshold = MibScalar((1, 3, 6, 1, 4, 1, 119, 2, 3, 14, 3, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nodeGuaranteedBufferThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: nodeGuaranteedBufferThreshold.setDescription('Threshold buffer capacity for Guaranteed traffic. If the number of cells stored in the buffer exceeds this threshold, cells with CLP=1 and traffic defined as VBR will be discarded.')
nodeSaveConf = MibScalar((1, 3, 6, 1, 4, 1, 119, 2, 3, 14, 3, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("save", 1), ("noOperation", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nodeSaveConf.setStatus('mandatory')
if mibBuilder.loadTexts: nodeSaveConf.setDescription('Save system configuration information including the PVC table to the non-volatile memory. Writing a value of save(1) saves the configiration data. Writing the value noOperation(2) has no effect. When read, this object always has the value noOperation(2).')
nodeSaveResult = MibScalar((1, 3, 6, 1, 4, 1, 119, 2, 3, 14, 3, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("temporaryFailure", 1), ("notReady", 2), ("ready", 3), ("success", 4), ("nearend", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeSaveResult.setStatus('mandatory')
if mibBuilder.loadTexts: nodeSaveResult.setDescription('Indicates the result of the save command issued from NMS. The result is either success/temporary failure/notReady.')
nodeReset = MibScalar((1, 3, 6, 1, 4, 1, 119, 2, 3, 14, 3, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("reset", 1), ("noOperation", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nodeReset.setStatus('mandatory')
if mibBuilder.loadTexts: nodeReset.setDescription('Writing the value reset(1) resets the system. Writing the value noOperation(2) has no effect. When read, this object always has the value noOperation(2).')
linfStatusTable = MibTable((1, 3, 6, 1, 4, 1, 119, 2, 3, 14, 3, 2, 1), )
if mibBuilder.loadTexts: linfStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: linfStatusTable.setDescription('Status of the line cards including ATM specific information.')
linfStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 119, 2, 3, 14, 3, 2, 1, 1), ).setIndexNames((0, "LS100-MIB", "linfIndex"))
if mibBuilder.loadTexts: linfStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: linfStatusEntry.setDescription('Status of a line card including ATM specific information.')
linfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 119, 2, 3, 14, 3, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: linfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: linfIndex.setDescription('Same as ifIndex')
linfStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 119, 2, 3, 14, 3, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 99))).clone(namedValues=NamedValues(("normal", 1), ("los", 2), ("lof", 3), ("loc", 4), ("ais", 5), ("yellowLine", 6), ("yellowPath", 7), ("lop", 8), ("idle", 9), ("yellowAlarm", 10), ("plcpLOF", 11), ("plcpYellow", 12), ("maFERF", 13), ("rai", 14), ("payloadAllOnes", 15), ("notInstalled", 99)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: linfStatus.setStatus('mandatory')
if mibBuilder.loadTexts: linfStatus.setDescription('Status of line interface')
linfConf = MibTableColumn((1, 3, 6, 1, 4, 1, 119, 2, 3, 14, 3, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 99))).clone(namedValues=NamedValues(("publicUNI", 1), ("privateUNI", 2), ("privateNNI", 3), ("others", 99)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: linfConf.setStatus('mandatory')
if mibBuilder.loadTexts: linfConf.setDescription('Line card type.')
linfFwdAvailableBandWidth = MibTableColumn((1, 3, 6, 1, 4, 1, 119, 2, 3, 14, 3, 2, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: linfFwdAvailableBandWidth.setStatus('mandatory')
if mibBuilder.loadTexts: linfFwdAvailableBandWidth.setDescription('The amount of bandwidth (Mbps) available/unallocated in the forward (incoming) direction.')
linfBkwdAvailableBandWidth = MibTableColumn((1, 3, 6, 1, 4, 1, 119, 2, 3, 14, 3, 2, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: linfBkwdAvailableBandWidth.setStatus('mandatory')
if mibBuilder.loadTexts: linfBkwdAvailableBandWidth.setDescription('The amount of bandwidth (Mbps) available/unallocated in the backward (outgoing) direction.')
connPvcIndexNext = MibScalar((1, 3, 6, 1, 4, 1, 119, 2, 3, 14, 3, 3, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8191))).setMaxAccess("readonly")
if mibBuilder.loadTexts: connPvcIndexNext.setStatus('mandatory')
if mibBuilder.loadTexts: connPvcIndexNext.setDescription('The next available index for a row of the connPvcTable.')
connPvcIndexEnable = MibScalar((1, 3, 6, 1, 4, 1, 119, 2, 3, 14, 3, 3, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8191))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: connPvcIndexEnable.setStatus('deprecated')
if mibBuilder.loadTexts: connPvcIndexEnable.setDescription('When read, this object is the current minimum value of an index in the connPvcTable. Writing this value has no effect.')
connPvcTable = MibTable((1, 3, 6, 1, 4, 1, 119, 2, 3, 14, 3, 3, 3), )
if mibBuilder.loadTexts: connPvcTable.setStatus('mandatory')
if mibBuilder.loadTexts: connPvcTable.setDescription("The table containing information on current PVC/SVCs. Currently, only PVCs are represented in this table. The table is also used to establish and delete PVCs. 1. PVC establishment procedure (1) Read connPvcIndexNext. This value is used as the value of connPvcIndex for the new connection. (2) Determine the value of connPvcHighIfIndex. When creating a new point-to-multipoint connection, connPvcHighIfIndex must identify the first leaf. When creating a new point-to-point connection, connPvcHighIfIndex normally identifies the interface with the higher value of ifIndex. (3) Set connPvcRowStatus to 'createAndWait' using the values of connPvcIndex and connPvcHighIfIndex as indexes. This causes the switch to create the new row with some objects being set to default values. The parameters for which there is no reasonable default are set to 0xffffffff. Object Default connPvcTopology bidirectionalVCC(2) connPvcTrafficType trafficUBR(4) connPvcLowIfIndex 0xffffffff connPvcLowVPI 0xffffffff connPvcLowVCI 0xffffffff connPvcLowUpcParam 512 connPvcLowUpc pass(1) connPvcLowThroughput 0 connPvcHighVPI 0xffffffff connPvcHighVCI 0xffffffff connPvcHighUpcParam 512 connPvcHighUpc pass(1) connPvcHighThroughput 0 The switch then sets the value of connPvcRowStatus to 'notReady'. The default values can be read by the NMS. (4) The values of the above objects which are set to 0xffffffff must be modified, and the values of any other objects can be changed. When establishing a VP connection, connPvcLowVCI and connPvcHighVCI should be set to 0. When connPvcTrafficType is set to trafficUBR, the values of connPvcLowThroughput and connPvcHighThroughput are ignored. When all parameters have acceptable values, the switch sets connPvcRowStatus to 'notInService'. (5) When the NMS sets connPvcRowStatus to 'active', the switch validates each parameter's value, and tries to establish the connection. If this operation fails, the the cause of the failure is indicated by the value of connPvcCause. At present, the switch allows connPvcRowStatus to have a value of notReady or notInService for only one row at a time. 2. Adding a new leaf to an existing pt-to-mpt connection (1) Determine the value of connPvcIndex for the existing point-to-multipoint connection to which a new leaf is to be added. (2) Determine the value of connPvcHighIfIndex as the ifIndex value of the interface to be used for the new leaf. (3) Set connPvcRowStatus to 'createAndWait' using the values of connPvcIndex and connPvcHighIfIndex as indexes. This causes the switch to create the new leaf with some objects being set to default values. The parameters for which there is no reasonable default are set to 0xffffffff. Object Default connPvcHighVPI 0xffffffff connPvcHighVCI 0xffffffff connPvcHighUpcParam 512 connPvcHighUpc pass(1) connPvcHighThroughput 0 The switch then sets the value of connPvcRowStatus to 'notReady'. The default values can be read by the NMS. (4) The NMS must modify the values of connPvcHighVPI and connPvcHighVCI, and can modify the values of connPvcHighUpc, connPvcHighUpcParam and connPvcHighThroughput. When establishing a VP connection, connPvcHighVCI should be set to 0. The NMS should not change the values of the following objects: connPvcTopology connPvcTrafficType connPvcLowIfIndex connPvcLowVPI connPvcLowVCI connPvcLowUpcParam connPvcLowUpc connPvcLowThroughput When all parameters have acceptable values, the switch sets connPvcRowStatus to 'notInService'. (5) When the NMS sets connPvcRowStatus to 'active', the switch validates each parameter's value, and tries to add the new leaf to the original connection. If this operation fails, the cause of the failure is indicated by the value of connPvcCause. 3. PVC deletion procedure (1) Set the connPvcRowStatus to 'destroy'. If the row exists but is impossible to delete, the cause of the failure is indicated by the value of connPvcCause. If the deletion is successful, the row is deleted (including the instance of connPvcCause for that row). Notes: - a row representing a terminating VP will not have instances of the following objects: connPvcLowUpc, connPvcLowUpcParam, connPvcLowThroughput, connPvcHighUpc, connPvcHighUpcParam, connPvcHighThroughput, connPvcLowOutCells, connPvcHighInCells, connPvcHighUpcViolatedCells, connPvcLowInCells, connPvcHighOutCells, and connPvcLowUpcViolatedCells. - a row representing a connection between the gateway-PAD (the switch's internal port) and a line interface will not have instances of the following objects: connPvcLowUpc, connPvcLowUpcParam, connPvcLowThroughput, connPvcHighUpc, connPvcHighUpcParam, connPvcHighThroughput, connPvcHighOutCells, connPvcHighInCells, and connPvcHighUpcViolatedCells.")
connPvcEntry = MibTableRow((1, 3, 6, 1, 4, 1, 119, 2, 3, 14, 3, 3, 3, 1), ).setIndexNames((0, "LS100-MIB", "connPvcIndex"), (0, "LS100-MIB", "connPvcHighIfIndex"))
if mibBuilder.loadTexts: connPvcEntry.setStatus('mandatory')
if mibBuilder.loadTexts: connPvcEntry.setDescription('A row in the table is used to show the current PVC/SVCs.')
connPvcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 119, 2, 3, 14, 3, 3, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8191))).setMaxAccess("readonly")
if mibBuilder.loadTexts: connPvcIndex.setStatus('mandatory')
if mibBuilder.loadTexts: connPvcIndex.setDescription('A unique value to identify this point-to-point or point-to-multipoint connection. A point-to-multipoint connection has multiple rows in this table, one for each leaf, each one having the same value of this object.')
connPvcTopology = MibTableColumn((1, 3, 6, 1, 4, 1, 119, 2, 3, 14, 3, 3, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("uniDirectionalVCC", 1), ("biDirectionalVCC", 2), ("uniDirectionalVPC", 3), ("biDirectionalVPC", 4), ("broadcastVPC", 5), ("broadcastVCC", 6), ("gateway", 7), ("vpterm", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: connPvcTopology.setStatus('mandatory')
if mibBuilder.loadTexts: connPvcTopology.setDescription('Topology of the connection.')
connPvcTrafficType = MibTableColumn((1, 3, 6, 1, 4, 1, 119, 2, 3, 14, 3, 3, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4))).clone(namedValues=NamedValues(("trafficCBR", 1), ("trafficVBR", 2), ("trafficUBR", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: connPvcTrafficType.setStatus('mandatory')
if mibBuilder.loadTexts: connPvcTrafficType.setDescription('Traffic Type.')
connPvcLowIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 119, 2, 3, 14, 3, 3, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: connPvcLowIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: connPvcLowIfIndex.setDescription('The line interface number (ifIndex) of the low port. Normally, the low port has a lower ifIndex value than the high port. However, for point-to-multipoint connections, the root is always the low port, regardless of whether it is greater or smaller than the port numbers of individual leaves.')
connPvcLowVPI = MibTableColumn((1, 3, 6, 1, 4, 1, 119, 2, 3, 14, 3, 3, 3, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: connPvcLowVPI.setStatus('mandatory')
if mibBuilder.loadTexts: connPvcLowVPI.setDescription('VPI value of the connection on the low port.')
connPvcLowVCI = MibTableColumn((1, 3, 6, 1, 4, 1, 119, 2, 3, 14, 3, 3, 3, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: connPvcLowVCI.setStatus('mandatory')
if mibBuilder.loadTexts: connPvcLowVCI.setDescription('VCI value of the connection on the low port.')
connPvcLowUpcParam = MibTableColumn((1, 3, 6, 1, 4, 1, 119, 2, 3, 14, 3, 3, 3, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 512))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: connPvcLowUpcParam.setStatus('mandatory')
if mibBuilder.loadTexts: connPvcLowUpcParam.setDescription('Number of cells allowed to be sent in the unit cell time (512 cell times).')
connPvcLowUpc = MibTableColumn((1, 3, 6, 1, 4, 1, 119, 2, 3, 14, 3, 3, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("pass", 1), ("discard", 2), ("tagging", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: connPvcLowUpc.setStatus('mandatory')
if mibBuilder.loadTexts: connPvcLowUpc.setDescription('The action to take on a UPC violation for this connection on the low port. The tagging action is not supported by current hardware.')
connPvcLowThroughput = MibTableColumn((1, 3, 6, 1, 4, 1, 119, 2, 3, 14, 3, 3, 3, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 622))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: connPvcLowThroughput.setStatus('mandatory')
if mibBuilder.loadTexts: connPvcLowThroughput.setDescription('Average rate of the connection (Mbps). Direction is from the low port to high port. This parameter is valid for the connection whose traffic type is CBR or VBR.')
connPvcHighIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 119, 2, 3, 14, 3, 3, 3, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: connPvcHighIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: connPvcHighIfIndex.setDescription("The line interface number (ifIndex) of the high port. Normally, the high port has a higher ifIndex value than the low port. However, for point-to-multipoint connections, the root is always the low port, regardless of whether it is greater or smaller than the port numbers of individual leaves. Line interface number 17 corresponds to gateway (the switch's internal port).")
connPvcHighVPI = MibTableColumn((1, 3, 6, 1, 4, 1, 119, 2, 3, 14, 3, 3, 3, 1, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: connPvcHighVPI.setStatus('mandatory')
if mibBuilder.loadTexts: connPvcHighVPI.setDescription('The VPI value of the connection on the high port.')
connPvcHighVCI = MibTableColumn((1, 3, 6, 1, 4, 1, 119, 2, 3, 14, 3, 3, 3, 1, 12), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: connPvcHighVCI.setStatus('mandatory')
if mibBuilder.loadTexts: connPvcHighVCI.setDescription('The VCI value of the connection on the high port.')
connPvcHighUpcParam = MibTableColumn((1, 3, 6, 1, 4, 1, 119, 2, 3, 14, 3, 3, 3, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 512))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: connPvcHighUpcParam.setStatus('mandatory')
if mibBuilder.loadTexts: connPvcHighUpcParam.setDescription('Number of cells allowed to be sent in the unit cell time (512 cell times).')
connPvcHighUpc = MibTableColumn((1, 3, 6, 1, 4, 1, 119, 2, 3, 14, 3, 3, 3, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("pass", 1), ("discard", 2), ("tagging", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: connPvcHighUpc.setStatus('mandatory')
if mibBuilder.loadTexts: connPvcHighUpc.setDescription('The action to take on a UPC violation for this connection on the high port. The tagging action is not supported by current hardware.')
connPvcHighThroughput = MibTableColumn((1, 3, 6, 1, 4, 1, 119, 2, 3, 14, 3, 3, 3, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 622))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: connPvcHighThroughput.setStatus('mandatory')
if mibBuilder.loadTexts: connPvcHighThroughput.setDescription('Average rate of the connection (Mbps). Direction is from the high port to low port. This parameter is valid for the connection whose traffic type is CBR or VBR.')
connPvcLowInCells = MibTableColumn((1, 3, 6, 1, 4, 1, 119, 2, 3, 14, 3, 3, 3, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connPvcLowInCells.setStatus('mandatory')
if mibBuilder.loadTexts: connPvcLowInCells.setDescription('Number of incoming cells on this connection on low port.')
connPvcHighOutCells = MibTableColumn((1, 3, 6, 1, 4, 1, 119, 2, 3, 14, 3, 3, 3, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connPvcHighOutCells.setStatus('mandatory')
if mibBuilder.loadTexts: connPvcHighOutCells.setDescription('Number of outgoing cells on this connection on the high port.')
connPvcHighInCells = MibTableColumn((1, 3, 6, 1, 4, 1, 119, 2, 3, 14, 3, 3, 3, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connPvcHighInCells.setStatus('mandatory')
if mibBuilder.loadTexts: connPvcHighInCells.setDescription('Number of incoming cells on this connection on high port. (Valid for bi-direction connections only).')
connPvcLowOutCells = MibTableColumn((1, 3, 6, 1, 4, 1, 119, 2, 3, 14, 3, 3, 3, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connPvcLowOutCells.setStatus('mandatory')
if mibBuilder.loadTexts: connPvcLowOutCells.setDescription('Number of outgoing cells on this connection on the low. port. (Valid for bi-direction connections only).')
connPvcLowUpcViolatedCells = MibTableColumn((1, 3, 6, 1, 4, 1, 119, 2, 3, 14, 3, 3, 3, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connPvcLowUpcViolatedCells.setStatus('mandatory')
if mibBuilder.loadTexts: connPvcLowUpcViolatedCells.setDescription('Number of UPC violation cells incoming from the low port.')
connPvcHighUpcViolatedCells = MibTableColumn((1, 3, 6, 1, 4, 1, 119, 2, 3, 14, 3, 3, 3, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connPvcHighUpcViolatedCells.setStatus('mandatory')
if mibBuilder.loadTexts: connPvcHighUpcViolatedCells.setDescription('Number of UPC violation cells incoming from the high port. (Valid for bi-direction connections only).')
connPvcRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 119, 2, 3, 14, 3, 3, 3, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 5, 6))).clone(namedValues=NamedValues(("active", 1), ("notInService", 2), ("notReady", 3), ("createAndWait", 5), ("destroy", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: connPvcRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: connPvcRowStatus.setDescription("The status of this row. 'active' indicates that the connection is in use. 'notInService' indicates that the row exists but the connection is not established. 'notReady' indicates that the row exists in the agent, but is missing information necessary in order to be established. 'createAndWait' supplied by a management station wishing to create a new row. 'destroy' supplied by a management station wishing to delete the row.")
connPvcCause = MibTableColumn((1, 3, 6, 1, 4, 1, 119, 2, 3, 14, 3, 3, 3, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("existing", 1), ("vpivciBusy", 2), ("vpivciOutOfRange", 3), ("rateOverFlow", 4), ("upvpOutOfRange", 5), ("broadcastTableFull", 6), ("inconsistentVPVC", 7), ("lineDiagnosis", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: connPvcCause.setStatus('mandatory')
if mibBuilder.loadTexts: connPvcCause.setDescription('The result of the PVC establishment/deletion.')
connPvcKind = MibTableColumn((1, 3, 6, 1, 4, 1, 119, 2, 3, 14, 3, 3, 3, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("pvc", 1), ("svc", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: connPvcKind.setStatus('mandatory')
if mibBuilder.loadTexts: connPvcKind.setDescription('This object identifies the connection is SVC or PVC.')
perfTrapEnable = MibScalar((1, 3, 6, 1, 4, 1, 119, 2, 3, 14, 3, 4, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: perfTrapEnable.setStatus('mandatory')
if mibBuilder.loadTexts: perfTrapEnable.setDescription('The status of performance monitoring traps. Its value does not affect other traps, such as coldStart.')
perfIfTable = MibTable((1, 3, 6, 1, 4, 1, 119, 2, 3, 14, 3, 4, 2), )
if mibBuilder.loadTexts: perfIfTable.setStatus('mandatory')
if mibBuilder.loadTexts: perfIfTable.setDescription('Table of performance monitoring information.')
perfIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 119, 2, 3, 14, 3, 4, 2, 1), ).setIndexNames((0, "LS100-MIB", "perfIfIndex"))
if mibBuilder.loadTexts: perfIfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: perfIfEntry.setDescription('Performance monitoring information for a specific line.')
perfIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 119, 2, 3, 14, 3, 4, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: perfIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: perfIfIndex.setDescription('Line interface number. Same as ifIndex.')
perfIfLcvs = MibTableColumn((1, 3, 6, 1, 4, 1, 119, 2, 3, 14, 3, 4, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: perfIfLcvs.setStatus('mandatory')
if mibBuilder.loadTexts: perfIfLcvs.setDescription('Line Code Violation. This object is valid only for DS3/E3.')
perfIfParitySections = MibTableColumn((1, 3, 6, 1, 4, 1, 119, 2, 3, 14, 3, 4, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: perfIfParitySections.setStatus('mandatory')
if mibBuilder.loadTexts: perfIfParitySections.setDescription('Number of B1 (BIP) errors(OC-3c, UTP-5), Number of C-bit parity violation(DS3), Number of CRC-6 violation(DS1).')
perfIfParityLines = MibTableColumn((1, 3, 6, 1, 4, 1, 119, 2, 3, 14, 3, 4, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: perfIfParityLines.setStatus('mandatory')
if mibBuilder.loadTexts: perfIfParityLines.setDescription('Number of B2 (BIP) errors(OC-3c, UTP-5), Number of P-bit parity violation(DS3).')
perfIfParityPaths = MibTableColumn((1, 3, 6, 1, 4, 1, 119, 2, 3, 14, 3, 4, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: perfIfParityPaths.setStatus('mandatory')
if mibBuilder.loadTexts: perfIfParityPaths.setDescription('Number of B3 (BIP) errors(OC-3c, UTP-5), Number of PLCP BIP violation(DS3).')
perfIfHecErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 119, 2, 3, 14, 3, 4, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: perfIfHecErrors.setStatus('mandatory')
if mibBuilder.loadTexts: perfIfHecErrors.setDescription('Number of HEC errors detected.')
perfIfMisDelivdCells = MibTableColumn((1, 3, 6, 1, 4, 1, 119, 2, 3, 14, 3, 4, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: perfIfMisDelivdCells.setStatus('mandatory')
if mibBuilder.loadTexts: perfIfMisDelivdCells.setDescription('Number of misdelivered cells.')
perfIfOverFlowCells = MibTableColumn((1, 3, 6, 1, 4, 1, 119, 2, 3, 14, 3, 4, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: perfIfOverFlowCells.setStatus('mandatory')
if mibBuilder.loadTexts: perfIfOverFlowCells.setDescription('Number of cells discarded due to buffer overflow.')
perfIfInCBRCells = MibTableColumn((1, 3, 6, 1, 4, 1, 119, 2, 3, 14, 3, 4, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: perfIfInCBRCells.setStatus('mandatory')
if mibBuilder.loadTexts: perfIfInCBRCells.setDescription('Number of received CBR cells.')
perfIfOutCBRCells = MibTableColumn((1, 3, 6, 1, 4, 1, 119, 2, 3, 14, 3, 4, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: perfIfOutCBRCells.setStatus('mandatory')
if mibBuilder.loadTexts: perfIfOutCBRCells.setDescription('Number of transmitted CBR cells.')
perfIfInVBRCells = MibTableColumn((1, 3, 6, 1, 4, 1, 119, 2, 3, 14, 3, 4, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: perfIfInVBRCells.setStatus('mandatory')
if mibBuilder.loadTexts: perfIfInVBRCells.setDescription('Number of received VBR cells.')
perfIfOutVBRCells = MibTableColumn((1, 3, 6, 1, 4, 1, 119, 2, 3, 14, 3, 4, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: perfIfOutVBRCells.setStatus('mandatory')
if mibBuilder.loadTexts: perfIfOutVBRCells.setDescription('Number of transmitted VBR cells.')
perfIfInUBRCells = MibTableColumn((1, 3, 6, 1, 4, 1, 119, 2, 3, 14, 3, 4, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: perfIfInUBRCells.setStatus('mandatory')
if mibBuilder.loadTexts: perfIfInUBRCells.setDescription('Number of received UBR cells.')
perfIfOutUBRCells = MibTableColumn((1, 3, 6, 1, 4, 1, 119, 2, 3, 14, 3, 4, 2, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: perfIfOutUBRCells.setStatus('mandatory')
if mibBuilder.loadTexts: perfIfOutUBRCells.setDescription('Number of transmitted UBR cells.')
mibBuilder.exportSymbols("LS100-MIB", connPvcTrafficType=connPvcTrafficType, nodeSaveResult=nodeSaveResult, nodeIfConfIndex=nodeIfConfIndex, connPvcHighUpc=connPvcHighUpc, perfIfInUBRCells=perfIfInUBRCells, connPvcHighVPI=connPvcHighVPI, perfIfParityLines=perfIfParityLines, nodeGuaranteedBufferThreshold=nodeGuaranteedBufferThreshold, connPvcEntry=connPvcEntry, nodeIfConfEntry=nodeIfConfEntry, nodeGuaranteedBufferSize=nodeGuaranteedBufferSize, connPvcIndex=connPvcIndex, perfIfLcvs=perfIfLcvs, atomis_mib=atomis_mib, nodeIfConfTable=nodeIfConfTable, DisplayString=DisplayString, connPvcIndexNext=connPvcIndexNext, connPvcLowOutCells=connPvcLowOutCells, perfIfParitySections=perfIfParitySections, connPvcHighVCI=connPvcHighVCI, perfIfInCBRCells=perfIfInCBRCells, connPvcLowThroughput=connPvcLowThroughput, node=node, connPvcHighOutCells=connPvcHighOutCells, connPvcHighInCells=connPvcHighInCells, conn=conn, linfStatusTable=linfStatusTable, necProductDepend=necProductDepend, linfBkwdAvailableBandWidth=linfBkwdAvailableBandWidth, perfTrapEnable=perfTrapEnable, connPvcLowUpc=connPvcLowUpc, perfIfEntry=perfIfEntry, connPvcLowUpcViolatedCells=connPvcLowUpcViolatedCells, linfIndex=linfIndex, nodeBestEffortBufferThreshold=nodeBestEffortBufferThreshold, perfIfOutCBRCells=perfIfOutCBRCells, nec_mib=nec_mib, nodeSaveConf=nodeSaveConf, connPvcCause=connPvcCause, perfIfOverFlowCells=perfIfOverFlowCells, linfStatus=linfStatus, nodeReset=nodeReset, perfIfParityPaths=perfIfParityPaths, connPvcHighThroughput=connPvcHighThroughput, connPvcTable=connPvcTable, nodeOperStatus=nodeOperStatus, perfIfInVBRCells=perfIfInVBRCells, perf=perf, connPvcHighUpcParam=connPvcHighUpcParam, linf=linf, perfIfTable=perfIfTable, nodeIfConfRev=nodeIfConfRev, linfConf=linfConf, connPvcLowVPI=connPvcLowVPI, nodeIfConfPhysType=nodeIfConfPhysType, perfIfOutUBRCells=perfIfOutUBRCells, linfFwdAvailableBandWidth=linfFwdAvailableBandWidth, connPvcLowIfIndex=connPvcLowIfIndex, connPvcLowInCells=connPvcLowInCells, connPvcHighIfIndex=connPvcHighIfIndex, connPvcLowUpcParam=connPvcLowUpcParam, connPvcRowStatus=connPvcRowStatus, perfIfIndex=perfIfIndex, nodeBestEffortBufferSize=nodeBestEffortBufferSize, perfIfMisDelivdCells=perfIfMisDelivdCells, m5core_mib=m5core_mib, perfIfHecErrors=perfIfHecErrors, connPvcKind=connPvcKind, connPvcIndexEnable=connPvcIndexEnable, connPvcLowVCI=connPvcLowVCI, perfIfOutVBRCells=perfIfOutVBRCells, nodeFanStatus=nodeFanStatus, connPvcTopology=connPvcTopology, nec=nec, connPvcHighUpcViolatedCells=connPvcHighUpcViolatedCells, nodeUpcWindowSize=nodeUpcWindowSize, linfStatusEntry=linfStatusEntry, nodeIfConfStatus=nodeIfConfStatus)

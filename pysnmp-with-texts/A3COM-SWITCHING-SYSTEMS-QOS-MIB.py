#
# PySNMP MIB module A3COM-SWITCHING-SYSTEMS-QOS-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/A3COM-SWITCHING-SYSTEMS-QOS-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:08:28 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueSizeConstraint, ValueRangeConstraint, ConstraintsUnion, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsUnion", "ConstraintsIntersection")
ifIndex, = mibBuilder.importSymbols("IF-MIB", "ifIndex")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
enterprises, TimeTicks, ObjectIdentity, MibIdentifier, Gauge32, IpAddress, Integer32, NotificationType, Unsigned32, ModuleIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter32, Counter64, Bits, NotificationType, iso = mibBuilder.importSymbols("SNMPv2-SMI", "enterprises", "TimeTicks", "ObjectIdentity", "MibIdentifier", "Gauge32", "IpAddress", "Integer32", "NotificationType", "Unsigned32", "ModuleIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter32", "Counter64", "Bits", "NotificationType", "iso")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
class RowStatus(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))
    namedValues = NamedValues(("active", 1), ("notInService", 2), ("notReady", 3), ("createAndGo", 4), ("createAndWait", 5), ("destroy", 6))

a3Com = MibIdentifier((1, 3, 6, 1, 4, 1, 43))
switchingSystemsMibs = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 29))
a3ComSwitchingSystemsMib = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 29, 4))
a3ComQos = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 29, 4, 21))
a3ComQosClass = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 1))
a3ComQosCtrl = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 2))
a3ComQosRsvp = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 3))
a3ComQosStats = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 4))
a3ComQosMisc = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 5))
a3ComQosGenClassTable = MibTable((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 1, 1), )
if mibBuilder.loadTexts: a3ComQosGenClassTable.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComQosGenClassTable.setDescription('This table lists all QoS classes (Flow and Non-Flow) configured in the system.')
a3ComQosGenClassEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 1, 1, 1), ).setIndexNames((0, "A3COM-SWITCHING-SYSTEMS-QOS-MIB", "a3ComQosGenClassIndex"))
if mibBuilder.loadTexts: a3ComQosGenClassEntry.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComQosGenClassEntry.setDescription('An entry describing a single class entity.')
a3ComQosGenClassIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65532))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ComQosGenClassIndex.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComQosGenClassIndex.setDescription('A unique value for each entry.')
a3ComQosGenClassName = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 1, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComQosGenClassName.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComQosGenClassName.setDescription('A textual name for the class.')
a3ComQosGenClassControlId = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 1, 1, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComQosGenClassControlId.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComQosGenClassControlId.setDescription('The control entry that this class is associated with. Note that the user must have created the control (via the a3ComQosCtrlTable) before making the association via this object. A value of zero indicates no control is attached.')
a3ComQosFlowClassTable = MibTable((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 1, 2), )
if mibBuilder.loadTexts: a3ComQosFlowClassTable.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComQosFlowClassTable.setDescription('This table lists the Flow classes defined in the system. A Flow class applies only to IP unicast and multicast packets. A Flow class is defined in terms of the IP packet header: IP protocol type, IP source and destination addresses, TCP/UDP source and destination ports. Note that a filter entry can only be modified if there is no control attached to it. Otherwise, the entry has to be deleted and recreated.')
a3ComQosFlowClassEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 1, 2, 1), ).setIndexNames((0, "A3COM-SWITCHING-SYSTEMS-QOS-MIB", "a3ComQosFlowClassIndex"), (0, "A3COM-SWITCHING-SYSTEMS-QOS-MIB", "a3ComQosFlowClassFilterIndex"))
if mibBuilder.loadTexts: a3ComQosFlowClassEntry.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComQosFlowClassEntry.setDescription('An entry describing a single flow class entity.')
a3ComQosFlowClassIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65532))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ComQosFlowClassIndex.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComQosFlowClassIndex.setDescription('A unique value for each entry. Flow classses use id values between 1-399.')
a3ComQosFlowClassFilterIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ComQosFlowClassFilterIndex.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComQosFlowClassFilterIndex.setDescription('The unique filter index associated with this class. Note that the maximum limit of 100 filters is the aggregate of all the filters defined in the system, not just the number of filters defined for this classifier.')
a3ComQosFlowClassCastType = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 1, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unicast", 1), ("multicast", 2), ("both", 3))).clone('both')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComQosFlowClassCastType.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComQosFlowClassCastType.setDescription('The network layer cast type for this class.')
a3ComQosFlowClassIpProtoType = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 1, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("udp", 1), ("tcp", 2), ("both", 3))).clone('both')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComQosFlowClassIpProtoType.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComQosFlowClassIpProtoType.setDescription('The IP protocol type for this class.')
a3ComQosFlowClassSrcAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 1, 2, 1, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComQosFlowClassSrcAddr.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComQosFlowClassSrcAddr.setDescription('The source IP address for this class.')
a3ComQosFlowClassSrcSubnetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 1, 2, 1, 6), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComQosFlowClassSrcSubnetMask.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComQosFlowClassSrcSubnetMask.setDescription('The source subnet mask for this class.')
a3ComQosFlowClassDestAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 1, 2, 1, 7), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComQosFlowClassDestAddr.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComQosFlowClassDestAddr.setDescription('The destination IP address for this class.')
a3ComQosFlowClassDestSubnetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 1, 2, 1, 8), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComQosFlowClassDestSubnetMask.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComQosFlowClassDestSubnetMask.setDescription('The destination subnet mask for this class.')
a3ComQosFlowClassPortStart = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 1, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComQosFlowClassPortStart.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComQosFlowClassPortStart.setDescription('The starting range of ports associated with this class.')
a3ComQosFlowClassPortEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 1, 2, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(65535)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComQosFlowClassPortEnd.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComQosFlowClassPortEnd.setDescription('The finishing range of ports associated with this class.')
a3ComQosFlowClassRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 1, 2, 1, 11), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComQosFlowClassRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComQosFlowClassRowStatus.setDescription('The status column for this entry. This object can be set to: createAndGo(4) destroy(6) The following value may be read: active(1) Setting this object to createAndGo(4) creates a row in in this table. The agent will allocate the next sequential filter index value for the newly created entry. Setting this object to destroy(6) will remove this entry. Note that only the entry with the highest a3ComQosFlowClassFilterIndex value can be deleted. Also, an entry can only be deleted if there is no control attached to it.')
a3ComQosNonFlowClassTable = MibTable((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 1, 3), )
if mibBuilder.loadTexts: a3ComQosNonFlowClassTable.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComQosNonFlowClassTable.setDescription('This table lists the Non-Flow classes defined in the system. A Non-Flow class defines a packet in terms of its data link level protocol: IEEE 802.1p tag value, cast type (broadcast, multicast, and unicast). Packets which match a Non-Flow class receive a service level specific to that class.')
a3ComQosNonFlowClassEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 1, 3, 1), ).setIndexNames((0, "A3COM-SWITCHING-SYSTEMS-QOS-MIB", "a3ComQosNonFlowClassIndex"))
if mibBuilder.loadTexts: a3ComQosNonFlowClassEntry.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComQosNonFlowClassEntry.setDescription('An entry describing a single non-flow class entity.')
a3ComQosNonFlowClassIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65532))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ComQosNonFlowClassIndex.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComQosNonFlowClassIndex.setDescription('A unique value for each entry. Non-flow classs use class ids values between 400-499.')
a3ComQosNonFlowClassCastType = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 1, 3, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1).clone(hexValue="07")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComQosNonFlowClassCastType.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComQosNonFlowClassCastType.setDescription("A bit mask of 'cast' types associated with this class. Each cast is represented by a single bit. If that bit is set then the corresponding cast is selected by this class. The following bits are currently defined: Unicast 0x01 Multicast 0x02 Broadcast 0x04")
a3ComQosNonFlowClassProtos = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 1, 3, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1).clone(hexValue="f")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComQosNonFlowClassProtos.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComQosNonFlowClassProtos.setDescription('A bit mask of network protocols associated with this class. Each protocol is represented by a single bit. If that bit is set then the corresponding protocol is a member of this class. Only one protocol can be assigned to any given classifier. This object CAN ONLY BE SET if a3ComQosNonFlowClassProtoDesciptor is set to name(1) for the associated class. Custom (0x10) will be returned if a3ComQosNonFlowClassProtoDesciptor is not set to name(1). However this object CANNOT be set to Custom. The following bits are currently defined: Any 0x00 IP 0x01 IPX 0x02 TCP 0x04 Appletalk 0x08 Custom 0x10')
a3ComQosNonFlowClass8021pTags = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 1, 3, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1).clone(hexValue="ff")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComQosNonFlowClass8021pTags.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComQosNonFlowClass8021pTags.setDescription('A bit mask of the 802.1p tags associated with this class. Each tag is represented by a single bit. If that bit is set then the corresponding tag is selected by this class. The following bits are currently defined: 8021pTag-0 0x01 8021pTag-1 0x02 8021pTag-2 0x04 8021pTag-3 0x08 8021pTag-4 0x10 8021pTag-5 0x20 8021pTag-6 0x40 8021pTag-7 0x80')
a3ComQosNonFlowClassRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 1, 3, 1, 5), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComQosNonFlowClassRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComQosNonFlowClassRowStatus.setDescription('The status column for this entry. This object can be set to: createAndGo(4) destroy(6) The following value may be read: active(1) Setting this object to createAndGo(4) creates a row in in this table. Setting this object to destroy(6) will remove this entry. Note that an entry can only be deleted if there is no control attached to it.')
a3ComQosNonFlowClassProtoDescriptor = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 1, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("name", 1), ("ethertype", 2), ("dsap-ssap", 3))).clone('name')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComQosNonFlowClassProtoDescriptor.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComQosNonFlowClassProtoDescriptor.setDescription('This object determines whether a3ComQosNonFlowClassProtos or a3ComQosNonFlowClassCustomProto is used to define the protocol for a classifier. If set to name(1), the pre-defined types Any, IP, IPX, TCP, AppleTalk from a3ComQosNonFlowClassProtos will be used. If set to ethertype(2) or dsap-ssap(3) then the a3ComQosNonFlowClassProtos will be custom and the value used will be determined by a3ComQosNonFlowClassCustomProto.')
a3ComQosNonFlowClassCustomProto = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 1, 3, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComQosNonFlowClassCustomProto.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComQosNonFlowClassCustomProto.setDescription('This object determines a 2-byte hex value for the Ethertype or DSAP/SSAP that will be used in conjunction with a3ComQosNonFlowClassProtoDescriptor. If a3ComQosNonFlowClassProtoDescriptor is set to name(1) then this object is not used and it CANNOT be set. If a3ComQosNonFlowClassProtoDescriptor is set to ethertype(2) then the value will be used as an ethertype mask. If a3ComQosNonFlowClassProtoDescriptor is set to dsap-ssap(3) then the most significant byte will be used for the DSAP value and the least significant will be used for the SSAP value. -- Example 1: a3ComQosNonFlowClassProto is set to ethertype (2) a3ComQosNonFlowClassCustomTypeMask is set to 0x1234 The value 0x1234 will be used in the ethertype field. -- Example 2: a3ComQosNonFlowClassCustomType is set to dsap-ssap (2) a3ComQosNonFlowClassCustomTypeMask is set to 0x1234 The value 0x12 would be used for the DSAP value. The value 0x34 would be used for the SSAP value.')
a3ComQosCtrlTable = MibTable((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 2, 1), )
if mibBuilder.loadTexts: a3ComQosCtrlTable.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComQosCtrlTable.setDescription('A list of controls defined on a given system.')
a3ComQosCtrlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 2, 1, 1), ).setIndexNames((0, "A3COM-SWITCHING-SYSTEMS-QOS-MIB", "a3ComQosCtrlIndex"))
if mibBuilder.loadTexts: a3ComQosCtrlEntry.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComQosCtrlEntry.setDescription('An entry describing a single QoS control.')
a3ComQosCtrlIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65532))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ComQosCtrlIndex.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComQosCtrlIndex.setDescription('A unique value for this entry.')
a3ComQosCtrlName = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 2, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32)).clone(hexValue="00")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComQosCtrlName.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComQosCtrlName.setDescription('A textual name for the control.')
a3ComQosCtrlServiceLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("highPriority", 1), ("bestEffort", 2), ("lowPriority", 3), ("drop", 4))).clone('bestEffort')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComQosCtrlServiceLevel.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComQosCtrlServiceLevel.setDescription('The service level for all conforming packets.')
a3ComQosCtrlConformPktsLossEligible = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eligible", 1), ("nonEligible", 2))).clone('eligible')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComQosCtrlConformPktsLossEligible.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComQosCtrlConformPktsLossEligible.setDescription('The variable indicates whether conforming packets are loss eligible.')
a3ComQosCtrlExcessPktsServiceLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("highPriority", 1), ("bestEffort", 2), ("lowPriority", 3), ("drop", 4))).clone('bestEffort')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComQosCtrlExcessPktsServiceLevel.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComQosCtrlExcessPktsServiceLevel.setDescription('The service level of excess packets for this control.')
a3ComQosCtrlExcessPktsLossEligible = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eligible", 1), ("nonEligible", 2))).clone('eligible')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComQosCtrlExcessPktsLossEligible.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComQosCtrlExcessPktsLossEligible.setDescription('The variable indicates whether excess packets are loss eligible.')
a3ComQosCtrl8021pTag = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("none", 1), ("ieee8021pTag0", 2), ("ieee8021pTag1", 3), ("ieee8021pTag2", 4), ("ieee8021pTag3", 5), ("ieee8021pTag4", 6), ("ieee8021pTag5", 7), ("ieee8021pTag6", 8), ("ieee8021pTag7", 9))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComQosCtrl8021pTag.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComQosCtrl8021pTag.setDescription('This indicates the tag to use on forwarded frames.')
a3ComQosCtrlRateLimitType = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("receivePort", 2), ("aggregate", 3))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComQosCtrlRateLimitType.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComQosCtrlRateLimitType.setDescription('The rate limit type to use with this control. A value of none(1) indicates that no rate limit is set for this control. A value of receivePort(2) indicates that the configured rate limit is applied on a per-port basis. A value of aggregate(3) indicates that the configured rate limit is aggregated across the set of ports that are configured for the rate limit. For values other than none(1), the rate limit entries are created via the a3ComQosCtrlRateLimitTable.')
a3ComQosCtrlRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 2, 1, 1, 9), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComQosCtrlRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComQosCtrlRowStatus.setDescription('The status column for this control entry. This object can be set to: createAndGo(4) destroy(6) The following value may be read: active(1) Setting this object to createAndGo(4) creates a row in this table. Setting this object to destroy(6) will remove this entry. Note that a control can only be deleted if it is not attached to a flow or a non-flow classifier. A side effect of deleting a control in this table is the deletion of the corresponding rate limit entries in the a3ComQosCtrlRateLimitTable.')
a3ComQosCtrlRateLimitTable = MibTable((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 2, 2), )
if mibBuilder.loadTexts: a3ComQosCtrlRateLimitTable.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComQosCtrlRateLimitTable.setDescription('A list of QoS control rate limits defined on a given system.')
a3ComQosCtrlRateLimitEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 2, 2, 1), ).setIndexNames((0, "A3COM-SWITCHING-SYSTEMS-QOS-MIB", "a3ComQosCtrlRateLimitCtrlIndex"), (0, "A3COM-SWITCHING-SYSTEMS-QOS-MIB", "a3ComQosCtrlRateLimitIndex"))
if mibBuilder.loadTexts: a3ComQosCtrlRateLimitEntry.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComQosCtrlRateLimitEntry.setDescription('An entry describing a single QoS control rate limit.')
a3ComQosCtrlRateLimitCtrlIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65532))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ComQosCtrlRateLimitCtrlIndex.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComQosCtrlRateLimitCtrlIndex.setDescription('The control index for which this entry is valid.')
a3ComQosCtrlRateLimitIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 24))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ComQosCtrlRateLimitIndex.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComQosCtrlRateLimitIndex.setDescription('The rate limit for which this entry is valid.')
a3ComQosCtrlRateLimitPercent = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 101))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComQosCtrlRateLimitPercent.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComQosCtrlRateLimitPercent.setDescription('The rate limit as a percentage of input port bandwidth. Packets received in excess of specified rate limit will receive the service defined by value of a3ComQosCtrlExcessPktsServiceLevel object. A value of 0 indicates no rate limit. A value of 101 indicates that this object is not being used and the value of the a3ComQosCtrlRateLimitKbps object will determine the rate limit (if any).')
a3ComQosCtrlRateLimitKbps = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 2, 2, 1, 4), Integer32().clone(-1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComQosCtrlRateLimitKbps.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComQosCtrlRateLimitKbps.setDescription('The rate limit in kilobits per second of input port bandwidth. Packets received in excess of specified rate limit will receive the service defined by value of a3ComQosCtrlExcessPktsServiceLevel object. Note that the requested rate may be rounded up to the next 1/16th chunk bandwidth. Note that the user can specify the rate limit either as a percentage (via the a3ComQosCtrlRateLimitPercent object) or as kilobits per second (via this object) but not both. If the value of the a3ComQosCtrlRateLimitPercent object is 101, then the setting of this object determines the rate limit. A value of -1 for this object indicates no rate limit. Any other value indicates the desired rate limit.')
a3ComQosCtrlRateLimitPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 2, 2, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 4)).clone(hexValue="00")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComQosCtrlRateLimitPorts.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComQosCtrlRateLimitPorts.setDescription('A bit mask of interfaces that support the defined rate limit. Each interface is represented by a single bit. If that bit is set then the corresponding interface is a member of this control. The bits are assigned with the least significant bit of the first byte corresponding to ifIndex 1, the next bit corresponding to ifIndex 2 and so on. Note that each port can only be associated with a single rate limit per control. An error will be returned if the user tries to assign a port that already has a rate limit associated with it.')
a3ComQosCtrlRateLimitRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 2, 2, 1, 6), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComQosCtrlRateLimitRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComQosCtrlRateLimitRowStatus.setDescription('The status column for this rate limit entry. This object can be set to: createAndGo(4) destroy(6) The following value may be read: active(1) Setting this object to createAndGo(4) creates a row in this table. Note that a request to create a new entry must use the next sequential available a3ComQosCtrlRateLimitIndex value. Setting this object to destroy(6) will remove this entry.')
a3ComQosRsvpStatus = MibScalar((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("rsvpEnabled", 1), ("rsvpDisabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComQosRsvpStatus.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComQosRsvpStatus.setDescription('The status of the RSVP protocol.')
a3ComQosRsvpMaxTotalResvdBandwidth = MibScalar((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 3, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 200))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComQosRsvpMaxTotalResvdBandwidth.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComQosRsvpMaxTotalResvdBandwidth.setDescription('The maximum total reservable bandwidth of the output link.')
a3ComQosRsvpMaxPerResvBandwidth = MibScalar((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 3, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComQosRsvpMaxPerResvBandwidth.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComQosRsvpMaxPerResvBandwidth.setDescription('The maximum per-reservation bandwidth of the output link.')
a3ComQosRsvpPolicy = MibScalar((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 3, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("edge", 1), ("always", 2), ("never", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComQosRsvpPolicy.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComQosRsvpPolicy.setDescription('The indication of a policing option that shows when excess packets are dropped.')
a3ComQosRsvpExcessTrafficPolicy = MibScalar((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 3, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("bestEffort", 1), ("lowPriority", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComQosRsvpExcessTrafficPolicy.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComQosRsvpExcessTrafficPolicy.setDescription('The indication of service for excess packets.')
a3ComQosRsvpExcessPktsLossEligible = MibScalar((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 3, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComQosRsvpExcessPktsLossEligible.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComQosRsvpExcessPktsLossEligible.setDescription('This object indicates if excess packets are loss eligible.')
a3ComQosRsvpAuthentication = MibScalar((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 3, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComQosRsvpAuthentication.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComQosRsvpAuthentication.setDescription('This object indicates the status of RSVP authentication.')
a3ComQosRsvpMd5Key = MibScalar((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 3, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComQosRsvpMd5Key.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComQosRsvpMd5Key.setDescription('The MD5 encryption key. This value is used if the a3ComQosRsvpAuthStatus object is set to enabled(1).')
a3ComQosStatsInterval = MibScalar((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 4, 1), Integer32().clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComQosStatsInterval.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComQosStatsInterval.setDescription('The time interval, in seconds, over which rate statistics are collected. A value of zero implies absolute (i.e. raw) statistics.')
a3ComQosXmtStatsTable = MibTable((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 4, 2), )
if mibBuilder.loadTexts: a3ComQosXmtStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComQosXmtStatsTable.setDescription('This table contains QoS transmit rate statistics. The interval over which the rate is calculated is determined by the value of a3ComQosStatsInterval object.')
a3ComQosXmtStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 4, 2, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "A3COM-SWITCHING-SYSTEMS-QOS-MIB", "a3ComQosXmtStatsQindex"))
if mibBuilder.loadTexts: a3ComQosXmtStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComQosXmtStatsEntry.setDescription('An entry containing transmit rate statistics.')
a3ComQosXmtStatsQindex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 4, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("reserved", 1), ("highPriority", 2), ("bestEffort", 3), ("lowPriority", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ComQosXmtStatsQindex.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComQosXmtStatsQindex.setDescription('The type of transmit queue for which this entry is valid.')
a3ComQosXmtStatsLowLossPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 4, 2, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ComQosXmtStatsLowLossPkts.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComQosXmtStatsLowLossPkts.setDescription('The rate of low loss packets. Low loss packets are packets that are not marked as loss eligible (a3ComQosCtrlConformPktLossEligible object) and are under the threshold. The rate is specified in packets per second.')
a3ComQosXmtStatsLowLossDelayedPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 4, 2, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ComQosXmtStatsLowLossDelayedPkts.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComQosXmtStatsLowLossDelayedPkts.setDescription('The rate of low loss delayed packets. Low loss delayed packets are packets that are not marked as loss eligible (a3ComQosCtrlConformPktLossEligible object) and are over the threshold. The rate is specified in packets per second.')
a3ComQosXmtStatsLowLossDiscardedPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 4, 2, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ComQosXmtStatsLowLossDiscardedPkts.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComQosXmtStatsLowLossDiscardedPkts.setDescription('The rate of low loss discarded packets. Low loss discarded packets are packets that are discarded due to the queue being full. The rate is specified in packets per second.')
a3ComQosXmtStatsHighLossPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 4, 2, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ComQosXmtStatsHighLossPkts.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComQosXmtStatsHighLossPkts.setDescription('The rate of high loss packets. High loss packets are packets that are marked as loss eligible (a3ComQosCtrlConformPktLossEligible object) and are under the threshold. The rate is specified in packets per second.')
a3ComQosXmtStatsHighLossDiscardedPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 4, 2, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ComQosXmtStatsHighLossDiscardedPkts.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComQosXmtStatsHighLossDiscardedPkts.setDescription('The rate of high loss discarded packets. High loss discarded packets are packets that are marked as loss eligible (a3ComQosCtrlConformPktLossEligible object) and are over the threshold. The rate is specified in packets per second.')
a3ComQosXmtHmStatsTable = MibTable((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 4, 3), )
if mibBuilder.loadTexts: a3ComQosXmtHmStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComQosXmtHmStatsTable.setDescription('This table contains QoS transmit high water mark rate statistics. The interval over which the rate is calculated is determined by the value of a3ComQosStatsInterval object.')
a3ComQosXmtHmStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 4, 3, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "A3COM-SWITCHING-SYSTEMS-QOS-MIB", "a3ComQosXmtHmStatsQindex"))
if mibBuilder.loadTexts: a3ComQosXmtHmStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComQosXmtHmStatsEntry.setDescription('An entry containing transmit high water mark rate statistics.')
a3ComQosXmtHmStatsQindex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 4, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("reserved", 1), ("highPriority", 2), ("bestEffort", 3), ("lowPriority", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ComQosXmtHmStatsQindex.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComQosXmtHmStatsQindex.setDescription('The type of queue for which this entry is valid.')
a3ComQosXmtHmStatsLowLossPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 4, 3, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ComQosXmtHmStatsLowLossPkts.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComQosXmtHmStatsLowLossPkts.setDescription('The high mark for low loss packets.')
a3ComQosXmtHmStatsLowLossDelayedPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 4, 3, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ComQosXmtHmStatsLowLossDelayedPkts.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComQosXmtHmStatsLowLossDelayedPkts.setDescription('The high mark for low loss delayed packets.')
a3ComQosXmtHmStatsLowLossDiscardedPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 4, 3, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ComQosXmtHmStatsLowLossDiscardedPkts.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComQosXmtHmStatsLowLossDiscardedPkts.setDescription('The high mark for low loss discarded packets.')
a3ComQosXmtHmStatsHighLossPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 4, 3, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ComQosXmtHmStatsHighLossPkts.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComQosXmtHmStatsHighLossPkts.setDescription('The high mark for high loss packets.')
a3ComQosXmtHmStatsHighLossDiscardedPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 4, 3, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ComQosXmtHmStatsHighLossDiscardedPkts.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComQosXmtHmStatsHighLossDiscardedPkts.setDescription('The high mark for high loss discarded packets.')
a3ComQosRcvStatsTable = MibTable((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 4, 4), )
if mibBuilder.loadTexts: a3ComQosRcvStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComQosRcvStatsTable.setDescription('A table containing QoS receive rate statistics. The interval over which the rate is calculated is determined by the value of a3ComQosStatsInterval object.')
a3ComQosRcvStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 4, 4, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: a3ComQosRcvStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComQosRcvStatsEntry.setDescription('An entry containing receive rate statistics for a particular port.')
a3ComQosRcvStatsConformBytesTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 4, 4, 1, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ComQosRcvStatsConformBytesTotal.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComQosRcvStatsConformBytesTotal.setDescription('The total conforming bytes receive rate. The rate is in bytes per second.')
a3ComQosRcvStatsNonConformBytesForFlows = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 4, 4, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ComQosRcvStatsNonConformBytesForFlows.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComQosRcvStatsNonConformBytesForFlows.setDescription('The non-conforming bytes receive rate for flows. The rate is in bytes per second.')
a3ComQosRcvStatsNonConformBytesForNonFlows = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 4, 4, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ComQosRcvStatsNonConformBytesForNonFlows.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComQosRcvStatsNonConformBytesForNonFlows.setDescription('The non-conforming bytes receive rate for non-flows. The rate is in bytes per second.')
a3ComQosRcvStatsDroppedPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 4, 4, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ComQosRcvStatsDroppedPkts.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComQosRcvStatsDroppedPkts.setDescription('The number of packets dropped. The rate is specified in packets per second.')
a3ComQosBandwidthRatio = MibScalar((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 5, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComQosBandwidthRatio.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComQosBandwidthRatio.setDescription('The bandwidth ratio of HighPriority/(HighPriority+BestEffort) that is allocated for each output port on a given system. The value is represented as a percentage.')
a3ComQosExcessTrafficClassTag = MibScalar((1, 3, 6, 1, 4, 1, 43, 29, 4, 21, 5, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("none", 1), ("ieee8021pTag0", 2), ("ieee8021pTag1", 3), ("ieee8021pTag2", 4), ("ieee8021pTag3", 5), ("ieee8021pTag4", 6), ("ieee8021pTag5", 7), ("ieee8021pTag6", 8), ("ieee8021pTag7", 9)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComQosExcessTrafficClassTag.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComQosExcessTrafficClassTag.setDescription('This object indicates the IEEE802.1p traffic class value to use to retag excess packets.')
a3ComQosFlowClassIntrudingEvent = NotificationType((1, 3, 6, 1, 4, 1, 43, 29, 4) + (0,88)).setObjects(("A3COM-SWITCHING-SYSTEMS-QOS-MIB", "a3ComQosFlowClassIndex"), ("A3COM-SWITCHING-SYSTEMS-QOS-MIB", "a3ComQosFlowClassIpProtoType"), ("A3COM-SWITCHING-SYSTEMS-QOS-MIB", "a3ComQosFlowClassSrcAddr"), ("A3COM-SWITCHING-SYSTEMS-QOS-MIB", "a3ComQosFlowClassDestAddr"))
if mibBuilder.loadTexts: a3ComQosFlowClassIntrudingEvent.setDescription('The trap that is generated when a intruder tries to enter a classified network')
mibBuilder.exportSymbols("A3COM-SWITCHING-SYSTEMS-QOS-MIB", a3ComQosFlowClassIndex=a3ComQosFlowClassIndex, a3ComQosXmtStatsHighLossDiscardedPkts=a3ComQosXmtStatsHighLossDiscardedPkts, a3ComQosNonFlowClassCustomProto=a3ComQosNonFlowClassCustomProto, a3ComQosRsvpExcessTrafficPolicy=a3ComQosRsvpExcessTrafficPolicy, a3ComQosXmtHmStatsLowLossDiscardedPkts=a3ComQosXmtHmStatsLowLossDiscardedPkts, a3ComQosCtrlName=a3ComQosCtrlName, switchingSystemsMibs=switchingSystemsMibs, a3ComSwitchingSystemsMib=a3ComSwitchingSystemsMib, a3ComQosNonFlowClass8021pTags=a3ComQosNonFlowClass8021pTags, a3ComQosCtrlRateLimitEntry=a3ComQosCtrlRateLimitEntry, a3ComQosCtrlEntry=a3ComQosCtrlEntry, a3ComQosFlowClassDestAddr=a3ComQosFlowClassDestAddr, a3ComQosCtrlIndex=a3ComQosCtrlIndex, a3Com=a3Com, a3ComQosXmtStatsLowLossPkts=a3ComQosXmtStatsLowLossPkts, a3ComQosNonFlowClassEntry=a3ComQosNonFlowClassEntry, a3ComQosFlowClassFilterIndex=a3ComQosFlowClassFilterIndex, a3ComQos=a3ComQos, a3ComQosRsvp=a3ComQosRsvp, a3ComQosNonFlowClassProtoDescriptor=a3ComQosNonFlowClassProtoDescriptor, a3ComQosXmtStatsEntry=a3ComQosXmtStatsEntry, a3ComQosRcvStatsEntry=a3ComQosRcvStatsEntry, a3ComQosRcvStatsDroppedPkts=a3ComQosRcvStatsDroppedPkts, a3ComQosFlowClassPortStart=a3ComQosFlowClassPortStart, a3ComQosFlowClassEntry=a3ComQosFlowClassEntry, a3ComQosCtrlConformPktsLossEligible=a3ComQosCtrlConformPktsLossEligible, a3ComQosCtrlRateLimitPercent=a3ComQosCtrlRateLimitPercent, a3ComQosXmtStatsHighLossPkts=a3ComQosXmtStatsHighLossPkts, a3ComQosCtrlServiceLevel=a3ComQosCtrlServiceLevel, a3ComQosGenClassControlId=a3ComQosGenClassControlId, a3ComQosXmtHmStatsHighLossPkts=a3ComQosXmtHmStatsHighLossPkts, a3ComQosCtrlRateLimitKbps=a3ComQosCtrlRateLimitKbps, a3ComQosFlowClassCastType=a3ComQosFlowClassCastType, a3ComQosCtrlRateLimitRowStatus=a3ComQosCtrlRateLimitRowStatus, a3ComQosXmtStatsTable=a3ComQosXmtStatsTable, a3ComQosNonFlowClassTable=a3ComQosNonFlowClassTable, a3ComQosMisc=a3ComQosMisc, a3ComQosGenClassName=a3ComQosGenClassName, a3ComQosExcessTrafficClassTag=a3ComQosExcessTrafficClassTag, a3ComQosNonFlowClassRowStatus=a3ComQosNonFlowClassRowStatus, a3ComQosCtrlExcessPktsServiceLevel=a3ComQosCtrlExcessPktsServiceLevel, a3ComQosCtrlRateLimitCtrlIndex=a3ComQosCtrlRateLimitCtrlIndex, a3ComQosXmtStatsQindex=a3ComQosXmtStatsQindex, a3ComQosNonFlowClassProtos=a3ComQosNonFlowClassProtos, a3ComQosCtrlRateLimitIndex=a3ComQosCtrlRateLimitIndex, a3ComQosRcvStatsNonConformBytesForFlows=a3ComQosRcvStatsNonConformBytesForFlows, a3ComQosXmtHmStatsHighLossDiscardedPkts=a3ComQosXmtHmStatsHighLossDiscardedPkts, a3ComQosFlowClassDestSubnetMask=a3ComQosFlowClassDestSubnetMask, a3ComQosGenClassTable=a3ComQosGenClassTable, a3ComQosFlowClassIpProtoType=a3ComQosFlowClassIpProtoType, a3ComQosGenClassIndex=a3ComQosGenClassIndex, a3ComQosCtrl8021pTag=a3ComQosCtrl8021pTag, a3ComQosRcvStatsConformBytesTotal=a3ComQosRcvStatsConformBytesTotal, a3ComQosRsvpExcessPktsLossEligible=a3ComQosRsvpExcessPktsLossEligible, a3ComQosXmtHmStatsLowLossDelayedPkts=a3ComQosXmtHmStatsLowLossDelayedPkts, a3ComQosRsvpStatus=a3ComQosRsvpStatus, a3ComQosFlowClassPortEnd=a3ComQosFlowClassPortEnd, a3ComQosXmtStatsLowLossDelayedPkts=a3ComQosXmtStatsLowLossDelayedPkts, a3ComQosGenClassEntry=a3ComQosGenClassEntry, a3ComQosRsvpMd5Key=a3ComQosRsvpMd5Key, a3ComQosXmtHmStatsTable=a3ComQosXmtHmStatsTable, a3ComQosBandwidthRatio=a3ComQosBandwidthRatio, a3ComQosXmtHmStatsQindex=a3ComQosXmtHmStatsQindex, a3ComQosClass=a3ComQosClass, a3ComQosCtrlRowStatus=a3ComQosCtrlRowStatus, a3ComQosXmtHmStatsEntry=a3ComQosXmtHmStatsEntry, a3ComQosFlowClassSrcSubnetMask=a3ComQosFlowClassSrcSubnetMask, a3ComQosFlowClassRowStatus=a3ComQosFlowClassRowStatus, a3ComQosRsvpMaxTotalResvdBandwidth=a3ComQosRsvpMaxTotalResvdBandwidth, a3ComQosNonFlowClassIndex=a3ComQosNonFlowClassIndex, a3ComQosStatsInterval=a3ComQosStatsInterval, a3ComQosRcvStatsNonConformBytesForNonFlows=a3ComQosRcvStatsNonConformBytesForNonFlows, a3ComQosFlowClassIntrudingEvent=a3ComQosFlowClassIntrudingEvent, RowStatus=RowStatus, a3ComQosStats=a3ComQosStats, a3ComQosRsvpPolicy=a3ComQosRsvpPolicy, a3ComQosRsvpAuthentication=a3ComQosRsvpAuthentication, a3ComQosNonFlowClassCastType=a3ComQosNonFlowClassCastType, a3ComQosXmtHmStatsLowLossPkts=a3ComQosXmtHmStatsLowLossPkts, a3ComQosCtrlExcessPktsLossEligible=a3ComQosCtrlExcessPktsLossEligible, a3ComQosRsvpMaxPerResvBandwidth=a3ComQosRsvpMaxPerResvBandwidth, a3ComQosCtrl=a3ComQosCtrl, a3ComQosCtrlRateLimitPorts=a3ComQosCtrlRateLimitPorts, a3ComQosFlowClassTable=a3ComQosFlowClassTable, a3ComQosXmtStatsLowLossDiscardedPkts=a3ComQosXmtStatsLowLossDiscardedPkts, a3ComQosCtrlTable=a3ComQosCtrlTable, a3ComQosFlowClassSrcAddr=a3ComQosFlowClassSrcAddr, a3ComQosRcvStatsTable=a3ComQosRcvStatsTable, a3ComQosCtrlRateLimitType=a3ComQosCtrlRateLimitType, a3ComQosCtrlRateLimitTable=a3ComQosCtrlRateLimitTable)

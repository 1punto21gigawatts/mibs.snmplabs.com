#
# PySNMP MIB module INTEL-VLAN-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/INTEL-VLAN-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:54:49 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ValueRangeConstraint, SingleValueConstraint, ConstraintsUnion, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsUnion", "ValueSizeConstraint")
mib2ext, = mibBuilder.importSymbols("INTEL-GEN-MIB", "mib2ext")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
sysName, = mibBuilder.importSymbols("SNMPv2-MIB", "sysName")
TimeTicks, Integer32, NotificationType, Bits, NotificationType, IpAddress, MibScalar, MibTable, MibTableRow, MibTableColumn, Unsigned32, Counter32, ObjectIdentity, ModuleIdentity, MibIdentifier, Counter64, iso, Gauge32 = mibBuilder.importSymbols("SNMPv2-SMI", "TimeTicks", "Integer32", "NotificationType", "Bits", "NotificationType", "IpAddress", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Unsigned32", "Counter32", "ObjectIdentity", "ModuleIdentity", "MibIdentifier", "Counter64", "iso", "Gauge32")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
vlan = MibIdentifier((1, 3, 6, 1, 4, 1, 343, 6, 11))
vlanPolicy = MibIdentifier((1, 3, 6, 1, 4, 1, 343, 6, 11, 1))
vlanLearned = MibIdentifier((1, 3, 6, 1, 4, 1, 343, 6, 11, 2))
vlanIsl = MibIdentifier((1, 3, 6, 1, 4, 1, 343, 6, 11, 3))
vlanEditToken = MibIdentifier((1, 3, 6, 1, 4, 1, 343, 6, 11, 4))
vlanTrapObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 343, 6, 11, 6))
class EthMacAddress(OctetString):
    pass

vlanPolicyDomainName = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 11, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlanPolicyDomainName.setStatus('mandatory')
if mibBuilder.loadTexts: vlanPolicyDomainName.setDescription('The VLAN Domain name. All VLAN configuration and connectivity is separated in domains.')
vlanPolicyServerSeqNo = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 11, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlanPolicyServerSeqNo.setStatus('mandatory')
if mibBuilder.loadTexts: vlanPolicyServerSeqNo.setDescription('The sequence number of the configuration policy of the VLAN sever.')
vlanPolicyClientSeqNo = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 11, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlanPolicyClientSeqNo.setStatus('mandatory')
if mibBuilder.loadTexts: vlanPolicyClientSeqNo.setDescription('The sequence number of the configuration policy of the client.')
vlanPolicyMode = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 11, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("fullVlan", 1), ("standalone", 2), ("fullVlanForStack", 3), ("standaloneForStack", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlanPolicyMode.setStatus('mandatory')
if mibBuilder.loadTexts: vlanPolicyMode.setDescription('The device is running VLAN in 1 of 2 possible modes. 1) Distributed VLAN - the configuration and VLAN memberships are shared with other devices in the same domain. 2) Stand-alone - the configuration has only local significance. When running the devices in a stack the values 3 or 4 will be returned according to the actual mode, but only the values 1 and 2 will be accepted for set-requests. For some devices this object can not be set to fullVlan. Refer to vlanPolicySupportedVlanModes object.')
vlanPolicyChangedStamp = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 11, 1, 5), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlanPolicyChangedStamp.setStatus('mandatory')
if mibBuilder.loadTexts: vlanPolicyChangedStamp.setDescription('Local timestamp of last policy configuration change')
vlanPolicyNextVlanId = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 11, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlanPolicyNextVlanId.setStatus('mandatory')
if mibBuilder.loadTexts: vlanPolicyNextVlanId.setDescription('Returns the next VLAN id to be used when creating a new VLAN')
vlanPolicyLastApiError = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 11, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 25, 26, 27, 30, 31, 32, 33, 34, 35, 37, 38, 40, 41, 42, 43, 44, 45, 46, 47, 48, 50, 51, 52, 53, 54, 55, 56))).clone(namedValues=NamedValues(("outOfMemory", 1), ("tokenTakenByOther", 2), ("editTokenNotAllocated", 3), ("illegalVlanId", 4), ("vlanAlreadyActive", 5), ("vlanAlreadyDeactive", 6), ("illegalIndex", 7), ("illegalName", 8), ("noDatabaseInFlash", 9), ("illegalEntryId", 10), ("optionUnknown", 11), ("commandUnknown", 12), ("entryAlreadyExist", 13), ("recursiveReferencing", 14), ("ipNetViolation", 15), ("noVlansDefined", 16), ("maximumNumberOfEntriesReached", 17), ("nameTooLong", 18), ("noIpNet", 19), ("illegalPortEntry", 20), ("moreEntriesExist", 21), ("entryNotFound", 22), ("saveError", 25), ("noEntriesDefined", 26), ("vlanNameAlreadyExist", 27), ("domainUnknown", 30), ("noLocalInfoPresent", 31), ("illegalNvpDbPointer", 32), ("illegalLocalPointer", 33), ("wrongDatabaseVersion", 34), ("errorInitializing", 35), ("errorClearingDb", 37), ("illegalPointer", 38), ("macVlanServerTimeOut", 40), ("editTokenLostToForcedRelease", 41), ("configurationChanged", 42), ("currentVersionTooOld", 43), ("wrongDomainName", 44), ("tokenClaimRequestAlreadyPending", 45), ("tokenIsAlreadyAllocated", 46), ("tokenAllocationTimeOut", 47), ("tokenAllocatedForDbUpdate", 48), ("serverIsLost", 50), ("tokenReclaimFromNewServerFailed", 51), ("vlanIdMismatch", 52), ("multiStpChangeGlobalExist", 53), ("multiStpChangeWrongVlanMode", 54), ("multiStpChangePortOverlapping", 55), ("notAllowedWhenRunningMultiStp", 56)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlanPolicyLastApiError.setStatus('mandatory')
if mibBuilder.loadTexts: vlanPolicyLastApiError.setDescription('Return code for the last occurred error when making changes to the VLAN database')
vlanPolicyChangeOperation = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 11, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("create", 1), ("rename", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlanPolicyChangeOperation.setStatus('mandatory')
if mibBuilder.loadTexts: vlanPolicyChangeOperation.setDescription('This object must be set when changing the name of a VLAN DOMAIN, to indicate whether the change is a rename- or a create-operation')
vlanPolicyVlanTable = MibTable((1, 3, 6, 1, 4, 1, 343, 6, 11, 1, 9), )
if mibBuilder.loadTexts: vlanPolicyVlanTable.setStatus('mandatory')
if mibBuilder.loadTexts: vlanPolicyVlanTable.setDescription('Table of configured VLANs')
policyVlanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 343, 6, 11, 1, 9, 1), ).setIndexNames((0, "INTEL-VLAN-MIB", "policyVlanId"))
if mibBuilder.loadTexts: policyVlanEntry.setStatus('mandatory')
if mibBuilder.loadTexts: policyVlanEntry.setDescription('Entry in VLAN table consists of id and name and contains two special binary objects for creating and deleting VLANs')
policyVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 11, 1, 9, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: policyVlanId.setStatus('mandatory')
if mibBuilder.loadTexts: policyVlanId.setDescription('The internal id number of a VLAN. Must be used as index for creating and deleting')
policyVlanName = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 11, 1, 9, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: policyVlanName.setStatus('mandatory')
if mibBuilder.loadTexts: policyVlanName.setDescription('Name of the VLAN (20 bytes ASCII-Z string)')
policyVlanCreateObj = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 11, 1, 9, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: policyVlanCreateObj.setStatus('mandatory')
if mibBuilder.loadTexts: policyVlanCreateObj.setDescription('This object is used to create a new VLAN. The object takes parameters as binary-coded octet strings. Index (policyVlanId) used must be value from vlanPolicyNextVlanId. Binary format: [name (20 bytes ASCII-Z string)]')
policyVlanDeleteObj = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 11, 1, 9, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("delete", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: policyVlanDeleteObj.setStatus('mandatory')
if mibBuilder.loadTexts: policyVlanDeleteObj.setDescription('This object is used to delete an existing VLAN. The id of the VLAN must be used as index')
vlanPolicyMacRuleTable = MibTable((1, 3, 6, 1, 4, 1, 343, 6, 11, 1, 10), )
if mibBuilder.loadTexts: vlanPolicyMacRuleTable.setStatus('mandatory')
if mibBuilder.loadTexts: vlanPolicyMacRuleTable.setDescription('Table of configured MAC rules in a VLAN')
policyMacRuleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 343, 6, 11, 1, 10, 1), ).setIndexNames((0, "INTEL-VLAN-MIB", "policyMacRuleVlanId"), (0, "INTEL-VLAN-MIB", "policyMacRuleAddress"))
if mibBuilder.loadTexts: policyMacRuleEntry.setStatus('mandatory')
if mibBuilder.loadTexts: policyMacRuleEntry.setDescription('Entry in MAC rule table consist of VLAN id and MAC address and contains two special binary objects for creating and deleting rules')
policyMacRuleVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 11, 1, 10, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: policyMacRuleVlanId.setStatus('mandatory')
if mibBuilder.loadTexts: policyMacRuleVlanId.setDescription('Id of VLAN. Used as index when creating and deleting a rule')
policyMacRuleAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 11, 1, 10, 1, 2), EthMacAddress().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: policyMacRuleAddress.setStatus('mandatory')
if mibBuilder.loadTexts: policyMacRuleAddress.setDescription('MAC address string rule (6 bytes) for VLAN learning')
policyMacRuleCreateObj = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 11, 1, 10, 1, 3), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: policyMacRuleCreateObj.setStatus('mandatory')
if mibBuilder.loadTexts: policyMacRuleCreateObj.setDescription('This object is used to create a new MAC rule. The object takes parameters as binary-coded octet strings. Index (policyMacRuleVlanId and policyMacRuleAddress) used must be an existing VLAN id and a valid 6 byte MAC address. Binary format: [] {= leave empty}')
policyMacRuleDeleteObj = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 11, 1, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("delete", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: policyMacRuleDeleteObj.setStatus('mandatory')
if mibBuilder.loadTexts: policyMacRuleDeleteObj.setDescription('This object is used to delete an existing MAC rule. The VLAN id and MAC address of the rule must be used as index')
vlanPolicyIslMacRuleTable = MibTable((1, 3, 6, 1, 4, 1, 343, 6, 11, 1, 11), )
if mibBuilder.loadTexts: vlanPolicyIslMacRuleTable.setStatus('mandatory')
if mibBuilder.loadTexts: vlanPolicyIslMacRuleTable.setDescription('THIS TABLE HAS BEEN OBSOLETED! Table of configured IslMAC rules in a VLAN')
policyIslMacRuleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 343, 6, 11, 1, 11, 1), ).setIndexNames((0, "INTEL-VLAN-MIB", "policyIslMacRuleVlanId"), (0, "INTEL-VLAN-MIB", "policyIslMacRuleAddress"))
if mibBuilder.loadTexts: policyIslMacRuleEntry.setStatus('mandatory')
if mibBuilder.loadTexts: policyIslMacRuleEntry.setDescription('THIS ENTRY HAS BEEN OBSOLETED! Entry in IslMAC rule table consists of VLAN id and IslMAC address and contains two special binary objects for creating and deleting rules')
policyIslMacRuleVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 11, 1, 11, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: policyIslMacRuleVlanId.setStatus('mandatory')
if mibBuilder.loadTexts: policyIslMacRuleVlanId.setDescription('OBJECT HAS BEEN OBSOLETED! Id of VLAN. Used as index when creating and deleting a rule')
policyIslMacRuleAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 11, 1, 11, 1, 2), EthMacAddress().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: policyIslMacRuleAddress.setStatus('mandatory')
if mibBuilder.loadTexts: policyIslMacRuleAddress.setDescription('OBJECT HAS BEEN OBSOLETED! MAC address string rule (6 bytes) for VLAN learning')
policyIslMacRuleCreateObj = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 11, 1, 11, 1, 3), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: policyIslMacRuleCreateObj.setStatus('mandatory')
if mibBuilder.loadTexts: policyIslMacRuleCreateObj.setDescription('OBJECT HAS BEEN OBSOLETED! This object is used to create a new IslMAC rule. The object takes parameters as binary-coded octet strings. Index (policyIslMacRuleVlanId and policyIslMacRuleAddress) used must be an existing VLAN id and a valid 6 byte MAC address. Binary format: [] {= leave empty}')
policyIslMacRuleDeleteObj = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 11, 1, 11, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("delete", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: policyIslMacRuleDeleteObj.setStatus('mandatory')
if mibBuilder.loadTexts: policyIslMacRuleDeleteObj.setDescription('OBJECT HAS BEEN OBSOLETED! This object is used to delete an existing IslMAC rule. The VLAN id and MAC address of the rule must be used as index')
vlanPolicyIpRuleTable = MibTable((1, 3, 6, 1, 4, 1, 343, 6, 11, 1, 12), )
if mibBuilder.loadTexts: vlanPolicyIpRuleTable.setStatus('mandatory')
if mibBuilder.loadTexts: vlanPolicyIpRuleTable.setDescription('Table of configured IP rules in a VLAN')
policyIpRuleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 343, 6, 11, 1, 12, 1), ).setIndexNames((0, "INTEL-VLAN-MIB", "policyIpRuleVlanId"), (0, "INTEL-VLAN-MIB", "policyIpRuleAddress"))
if mibBuilder.loadTexts: policyIpRuleEntry.setStatus('mandatory')
if mibBuilder.loadTexts: policyIpRuleEntry.setDescription('Entry in IP rule table consists of VLAN id and IP address and contains two special binary objects for creating and deleting rules')
policyIpRuleVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 11, 1, 12, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: policyIpRuleVlanId.setStatus('mandatory')
if mibBuilder.loadTexts: policyIpRuleVlanId.setDescription('Id of VLAN. Used as index when creating and deleting a rule')
policyIpRuleAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 11, 1, 12, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: policyIpRuleAddress.setStatus('mandatory')
if mibBuilder.loadTexts: policyIpRuleAddress.setDescription('IP address string rule (4 bytes) for VLAN learning')
policyIpRuleCreateObj = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 11, 1, 12, 1, 3), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: policyIpRuleCreateObj.setStatus('mandatory')
if mibBuilder.loadTexts: policyIpRuleCreateObj.setDescription('This object is used to create a new IP rule. The object takes parameters as binary-coded octet strings. Index (policyIpRuleVlanId and policyIpRuleAddress) used must be an existing VLAN id and a valid 4 byte IP address. Binary format: [] {= leave empty}')
policyIpRuleDeleteObj = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 11, 1, 12, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("delete", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: policyIpRuleDeleteObj.setStatus('mandatory')
if mibBuilder.loadTexts: policyIpRuleDeleteObj.setDescription('This object is used to delete an existing IP rule. The VLAN id and IP address of the rule must be used as index')
vlanPolicyIpNetRuleTable = MibTable((1, 3, 6, 1, 4, 1, 343, 6, 11, 1, 13), )
if mibBuilder.loadTexts: vlanPolicyIpNetRuleTable.setStatus('mandatory')
if mibBuilder.loadTexts: vlanPolicyIpNetRuleTable.setDescription('Table of configured IP Network rules in a VLAN')
policyIpNetRuleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 343, 6, 11, 1, 13, 1), ).setIndexNames((0, "INTEL-VLAN-MIB", "policyIpNetRuleVlanId"), (0, "INTEL-VLAN-MIB", "policyIpNetRuleAddress"))
if mibBuilder.loadTexts: policyIpNetRuleEntry.setStatus('mandatory')
if mibBuilder.loadTexts: policyIpNetRuleEntry.setDescription('Entry in IP Network rule table consists of VLAN id, IP Network address and IP Network mask and contains two special binary objects for creating and deleting rules')
policyIpNetRuleVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 11, 1, 13, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: policyIpNetRuleVlanId.setStatus('mandatory')
if mibBuilder.loadTexts: policyIpNetRuleVlanId.setDescription('Id of VLAN. Used as index when creating and deleting a rule')
policyIpNetRuleAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 11, 1, 13, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: policyIpNetRuleAddress.setStatus('mandatory')
if mibBuilder.loadTexts: policyIpNetRuleAddress.setDescription('IP Network address string rule (4 bytes) for VLAN learning')
policyIpNetRuleMask = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 11, 1, 13, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: policyIpNetRuleMask.setStatus('mandatory')
if mibBuilder.loadTexts: policyIpNetRuleMask.setDescription('IP Network subnet mask string (4 bytes). Rule will be the result of a bit-wise AND operation between address and mask')
policyIpNetRuleCreateObj = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 11, 1, 13, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: policyIpNetRuleCreateObj.setStatus('mandatory')
if mibBuilder.loadTexts: policyIpNetRuleCreateObj.setDescription('This object is used to create a new IP Network rule. The object takes parameters as binary-coded octet strings. Index (policyIpNetRuleVlanId and policyIpNetRuleAddress) used must be an existing VLAN id and a valid 4 byte IP address. Binary format: [mask (4bytes)]')
policyIpNetRuleDeleteObj = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 11, 1, 13, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("delete", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: policyIpNetRuleDeleteObj.setStatus('mandatory')
if mibBuilder.loadTexts: policyIpNetRuleDeleteObj.setDescription('This object is used to delete an existing IP Network rule. The VLAN id and IP Network address of the rule must be used as index')
vlanPolicyPortRuleTable = MibTable((1, 3, 6, 1, 4, 1, 343, 6, 11, 1, 14), )
if mibBuilder.loadTexts: vlanPolicyPortRuleTable.setStatus('mandatory')
if mibBuilder.loadTexts: vlanPolicyPortRuleTable.setDescription('Table of configured Port rules in a VLAN')
policyPortRuleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 343, 6, 11, 1, 14, 1), ).setIndexNames((0, "INTEL-VLAN-MIB", "policyPortRuleVlanId"), (0, "INTEL-VLAN-MIB", "policyPortRuleNumber"))
if mibBuilder.loadTexts: policyPortRuleEntry.setStatus('mandatory')
if mibBuilder.loadTexts: policyPortRuleEntry.setDescription('Entry in Port rule table consists of VLAN id and Port number and contains two special binary objects for creating and deleting rules')
policyPortRuleVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 11, 1, 14, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: policyPortRuleVlanId.setStatus('mandatory')
if mibBuilder.loadTexts: policyPortRuleVlanId.setDescription('Id of VLAN. Used as index when creating and deleting a rule')
policyPortRuleNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 11, 1, 14, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: policyPortRuleNumber.setStatus('mandatory')
if mibBuilder.loadTexts: policyPortRuleNumber.setDescription('Port number rule for VLAN learning')
policyPortRuleCreateObj = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 11, 1, 14, 1, 3), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: policyPortRuleCreateObj.setStatus('mandatory')
if mibBuilder.loadTexts: policyPortRuleCreateObj.setDescription('This object is used to create a new Port rule. The object takes parameters as binary-coded octet strings. Index (policyPortRuleVlanId and policyPortRuleAddress) used must be an existing VLAN id and a valid 4 byte IP address. Binary format: [] {= leave empty}')
policyPortRuleDeleteObj = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 11, 1, 14, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("delete", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: policyPortRuleDeleteObj.setStatus('mandatory')
if mibBuilder.loadTexts: policyPortRuleDeleteObj.setDescription('This object is used to delete an existing Port rule. The VLAN id and Port number of the rule must be used as index')
vlanPolicyPortSettingsTable = MibTable((1, 3, 6, 1, 4, 1, 343, 6, 11, 1, 15), )
if mibBuilder.loadTexts: vlanPolicyPortSettingsTable.setStatus('mandatory')
if mibBuilder.loadTexts: vlanPolicyPortSettingsTable.setDescription('List of ports and their VLAN relevant configuration')
policyPortSettingsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 343, 6, 11, 1, 15, 1), ).setIndexNames((0, "INTEL-VLAN-MIB", "policyPortSettingsPortNumber"))
if mibBuilder.loadTexts: policyPortSettingsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: policyPortSettingsEntry.setDescription('Entry consists of Port Number and state for IP learning on a port')
policyPortSettingsPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 11, 1, 15, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: policyPortSettingsPortNumber.setStatus('mandatory')
if mibBuilder.loadTexts: policyPortSettingsPortNumber.setDescription('This is the Port number. Used as index when changing settings')
policyPortSettingsIpLearning = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 11, 1, 15, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ipLearningDisabled", 1), ("ipLearningEnabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: policyPortSettingsIpLearning.setStatus('mandatory')
if mibBuilder.loadTexts: policyPortSettingsIpLearning.setDescription('This option enables or disables the IP rule learning on a per port basis. This option should be enabled for ports connected to IP traffic only networks')
vlanPolicyAllPortSettingsIpLearning = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 11, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ipLearningDisabled", 1), ("ipLearningEnabled", 2), ("ipLearningMixed", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlanPolicyAllPortSettingsIpLearning.setStatus('mandatory')
if mibBuilder.loadTexts: vlanPolicyAllPortSettingsIpLearning.setDescription('This object is used to synchronize IP learning settings for all ports (set to either enabled or disabled). When read this object will also indicate if the settings are the same for all ports (enabled or disabled) or mixed')
vlanPolicyAssignManagementVlan = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 11, 1, 17), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlanPolicyAssignManagementVlan.setStatus('mandatory')
if mibBuilder.loadTexts: vlanPolicyAssignManagementVlan.setDescription('Assign a VLAN to have access to the switch local management. NB: Only for desktop switches!')
vlanPolicyConfigConfState = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 11, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("notReady", 1), ("ready", 2), ("revertedToOldConf", 3), ("confirmedNewConf", 4), ("confirm", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlanPolicyConfigConfState.setStatus('mandatory')
if mibBuilder.loadTexts: vlanPolicyConfigConfState.setDescription('When a management center changes the VLAN configuration, there is a risk that it looses the access to the switch. Therefore, in case the switch is running VLAN in stand alone mode, a temporary backup of the old configuration is made. This copy is kept for 30 sec and if this object has not been set to confirm(5) within that time, the backup configuration is made active and the new modifications are lost (state will read revertedToOldConf(3)). When a Token is claimed the state is set to notReady(1) and the state cannot be set to confirm(5) until the state reads ready(2) (which means the configuration has been made active and the learning database updated). When setting state to confirm the backup is removed and the new configuration is made active, and the state reads confirmedNewConf(4).')
vlanPolicyConfigConfTimerValue = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 11, 1, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlanPolicyConfigConfTimerValue.setStatus('mandatory')
if mibBuilder.loadTexts: vlanPolicyConfigConfTimerValue.setDescription('This object returns the start value of the Configuration Confirm Timer')
vlanPolicySupportedVlanModes = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 11, 1, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlanPolicySupportedVlanModes.setStatus('mandatory')
if mibBuilder.loadTexts: vlanPolicySupportedVlanModes.setDescription('This object returns a bitmask containing the supported VLAN modes: 0x01 : Stand-alone VLAN 0x02 : Distributed VLAN')
vlanPolicyRevert2Default = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 11, 1, 21), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlanPolicyRevert2Default.setStatus('mandatory')
if mibBuilder.loadTexts: vlanPolicyRevert2Default.setDescription('Setting this object to 1 will restore the original VLAN setup (1 System VLAN with all ports in it). NB: vlanMode and name is not effected by this!')
vlanPolicyMacVlanServerPriority = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 11, 1, 22), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlanPolicyMacVlanServerPriority.setStatus('mandatory')
if mibBuilder.loadTexts: vlanPolicyMacVlanServerPriority.setDescription('This object sets the priority for this device to become MAC-VLAN server')
vlanPolicyAutoMoveMgtIpLink = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 11, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("autoMoveMgtEnabled", 1), ("autoMoveMgtDisabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlanPolicyAutoMoveMgtIpLink.setStatus('mandatory')
if mibBuilder.loadTexts: vlanPolicyAutoMoveMgtIpLink.setDescription('If this object is enabled, the switch will make use of the feature to let Main IP link follow the management VlanId. Otherwise Main IP link will not move with the management Vlan')
vlanPolicyStackPortRuleTable = MibTable((1, 3, 6, 1, 4, 1, 343, 6, 11, 1, 24), )
if mibBuilder.loadTexts: vlanPolicyStackPortRuleTable.setStatus('mandatory')
if mibBuilder.loadTexts: vlanPolicyStackPortRuleTable.setDescription('Table of configured Port rules in a VLAN for a stack')
policyStackPortRuleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 343, 6, 11, 1, 24, 1), ).setIndexNames((0, "INTEL-VLAN-MIB", "policyStackPortRuleVlanId"), (0, "INTEL-VLAN-MIB", "policyStackPortRuleSwitchMac"), (0, "INTEL-VLAN-MIB", "policyStackPortRuleNumber"))
if mibBuilder.loadTexts: policyStackPortRuleEntry.setStatus('mandatory')
if mibBuilder.loadTexts: policyStackPortRuleEntry.setDescription('Entry in Stack Port rule table consists of VLAN id, Switch MAC and Port number and contains two special binary objects for creating and deleting rules')
policyStackPortRuleVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 11, 1, 24, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: policyStackPortRuleVlanId.setStatus('mandatory')
if mibBuilder.loadTexts: policyStackPortRuleVlanId.setDescription('Id of VLAN. Used as index when creating and deleting a rule')
policyStackPortRuleSwitchMac = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 11, 1, 24, 1, 2), EthMacAddress().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: policyStackPortRuleSwitchMac.setStatus('mandatory')
if mibBuilder.loadTexts: policyStackPortRuleSwitchMac.setDescription('Mac address identifying the switch on which the port is physically located')
policyStackPortRuleNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 11, 1, 24, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: policyStackPortRuleNumber.setStatus('mandatory')
if mibBuilder.loadTexts: policyStackPortRuleNumber.setDescription('Port number rule for VLAN learning')
policyStackPortRuleCreateObj = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 11, 1, 24, 1, 4), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: policyStackPortRuleCreateObj.setStatus('mandatory')
if mibBuilder.loadTexts: policyStackPortRuleCreateObj.setDescription('This object is used to create a new Stack Port rule. The object takes parameters as binary-coded octet strings. Index (policyStackPortRuleVlanId, policyStackPortRuleSwitchMac and policyStackPortRuleAddress) used must be an existing VLAN id, a valid MAC address present in the stack and a valid 4 byte IP address. Binary format: [] {= leave empty}')
policyStackPortRuleDeleteObj = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 11, 1, 24, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("delete", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: policyStackPortRuleDeleteObj.setStatus('mandatory')
if mibBuilder.loadTexts: policyStackPortRuleDeleteObj.setDescription('This object is used to delete an existing Port rule. The VLAN id, Switch Mac and Port number of the rule must be used as index')
vlanPolicyUseMultiSTP = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 11, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlanPolicyUseMultiSTP.setStatus('mandatory')
if mibBuilder.loadTexts: vlanPolicyUseMultiSTP.setDescription('When enabled, the device will operate multiple spanning trees on top of VLANs. When disabled the device will operate with VLANs on top of a single spanning tree.')
vlanPolicyFwdLearnPckts = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 11, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlanPolicyFwdLearnPckts.setStatus('mandatory')
if mibBuilder.loadTexts: vlanPolicyFwdLearnPckts.setDescription('Enable or Disable forwarding of learn-packets. A learn-packet is the packet that was used to learn a station the first time the switch received traffic from the station. If enabled these packets will be forwarded after learning is complete. If disabled these packets will be discarded after learning, to prevent packet re-ordering in the network. NB: This setting is not protected by the edit-token lock.')
vlanLearnedVersion = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 11, 2, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlanLearnedVersion.setStatus('mandatory')
if mibBuilder.loadTexts: vlanLearnedVersion.setDescription('The version of the run-time database used for keeping actual VLAN information.')
vlanLearnedServerState = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 11, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("initActive", 1), ("initPassive", 2), ("passive", 3), ("active", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlanLearnedServerState.setStatus('mandatory')
if mibBuilder.loadTexts: vlanLearnedServerState.setDescription('State of the MAC-VLAN server: initActive - Initialising to become server initPassive - Initialising to become client passive - Station is client active - Station is server')
vlanLearnedServerPriority = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 11, 2, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlanLearnedServerPriority.setStatus('mandatory')
if mibBuilder.loadTexts: vlanLearnedServerPriority.setDescription('The priority of the server function. The lower the priority, the more likely that this device becomes the server. If there is a tie between the priorities the device with the lowest MAC will become server.')
vlanLearnedServerIPAddress = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 11, 2, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlanLearnedServerIPAddress.setStatus('mandatory')
if mibBuilder.loadTexts: vlanLearnedServerIPAddress.setDescription('The IP address of the current MAC-VLAN server')
vlanLearnedServerMACAddress = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 11, 2, 5), EthMacAddress().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlanLearnedServerMACAddress.setStatus('mandatory')
if mibBuilder.loadTexts: vlanLearnedServerMACAddress.setDescription('The MAC address of the current MAC-VLAN server')
vlanLearnedServerPortNo = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 11, 2, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlanLearnedServerPortNo.setStatus('mandatory')
if mibBuilder.loadTexts: vlanLearnedServerPortNo.setDescription('The port number through which the device is connected to the server. Only valid if device is client')
vlanLearnedServerNameChangeTimer = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 11, 2, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlanLearnedServerNameChangeTimer.setStatus('mandatory')
if mibBuilder.loadTexts: vlanLearnedServerNameChangeTimer.setDescription("Timer value used when renaming a VLAN DOMAIN. While timer is running, both the old and new Domain Name is accepted by all switches in the Domain. When renaming a Domain containing many switches, a high value of the timer may be needed to ensure that Domain is not 'broken'. Value is in seconds")
vlanLearnedServerExpiryTimer = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 11, 2, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlanLearnedServerExpiryTimer.setStatus('mandatory')
if mibBuilder.loadTexts: vlanLearnedServerExpiryTimer.setDescription('Time a device will wait before assuming the MAC-VLAN server is lost. If server is assumed lost, the device will search for a new server, or become the server itself. NOTE: The value used by all devices in a Domain, is the value configured on the device that currently is the MAC-VLAN server and NOT the individual settings on each device.')
vlanLearnedMacTable = MibTable((1, 3, 6, 1, 4, 1, 343, 6, 11, 2, 9), )
if mibBuilder.loadTexts: vlanLearnedMacTable.setStatus('mandatory')
if mibBuilder.loadTexts: vlanLearnedMacTable.setDescription('A list of all active stations in a VLAN in the domain for the device.')
learnedMacEntry = MibTableRow((1, 3, 6, 1, 4, 1, 343, 6, 11, 2, 9, 1), ).setIndexNames((0, "INTEL-VLAN-MIB", "learnedMacAddress"))
if mibBuilder.loadTexts: learnedMacEntry.setStatus('mandatory')
if mibBuilder.loadTexts: learnedMacEntry.setDescription('A VLAN active station. For each station there is information about its: MAC address. If possible additional information about on which access-port the station is placed, the protocol type used and IP-address is kept too.')
learnedMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 11, 2, 9, 1, 1), EthMacAddress().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: learnedMacAddress.setStatus('mandatory')
if mibBuilder.loadTexts: learnedMacAddress.setDescription('The MAC address for a station.')
learnedMacType = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 11, 2, 9, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: learnedMacType.setStatus('mandatory')
if mibBuilder.loadTexts: learnedMacType.setDescription('The 2 byte protocol/length identifier specified in a ethernet packet according to IEEE802.3 / ETHERNET II')
learnedMacPortNo = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 11, 2, 9, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: learnedMacPortNo.setStatus('mandatory')
if mibBuilder.loadTexts: learnedMacPortNo.setDescription('The access-port on the VLAN device for a learned station. If portNo = 0 it means that this MAC is not learned locally.')
learnedMacIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 11, 2, 9, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: learnedMacIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: learnedMacIpAddress.setDescription('The IP-address of a learned station.')
vlanLearnedMacVlanTable = MibTable((1, 3, 6, 1, 4, 1, 343, 6, 11, 2, 10), )
if mibBuilder.loadTexts: vlanLearnedMacVlanTable.setStatus('mandatory')
if mibBuilder.loadTexts: vlanLearnedMacVlanTable.setDescription('A membership list of which stations are included in which VLANs in the actual domain.')
learnedMacVlanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 343, 6, 11, 2, 10, 1), ).setIndexNames((0, "INTEL-VLAN-MIB", "learnedMacVlanMac"), (0, "INTEL-VLAN-MIB", "learnedMacVlanIndex"))
if mibBuilder.loadTexts: learnedMacVlanEntry.setStatus('mandatory')
if mibBuilder.loadTexts: learnedMacVlanEntry.setDescription('For every station (referred to by its MAC address) a list of VLANs that have the station as a member, can be retrieved.')
learnedMacVlanMac = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 11, 2, 10, 1, 1), EthMacAddress().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: learnedMacVlanMac.setStatus('mandatory')
if mibBuilder.loadTexts: learnedMacVlanMac.setDescription('The MAC address of a learned station')
learnedMacVlanIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 11, 2, 10, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: learnedMacVlanIndex.setStatus('mandatory')
if mibBuilder.loadTexts: learnedMacVlanIndex.setDescription('The index of this VLAN, to be used when retrieving the next VLAN.')
learnedMacVlanName = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 11, 2, 10, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: learnedMacVlanName.setStatus('mandatory')
if mibBuilder.loadTexts: learnedMacVlanName.setDescription('The name of the VLAN.')
vlanLearnedVlanPortTable = MibTable((1, 3, 6, 1, 4, 1, 343, 6, 11, 2, 11), )
if mibBuilder.loadTexts: vlanLearnedVlanPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: vlanLearnedVlanPortTable.setDescription('A table of which VLANs exist on the ports.')
learnedVlanPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 343, 6, 11, 2, 11, 1), ).setIndexNames((0, "INTEL-VLAN-MIB", "learnedVlanPortNo"), (0, "INTEL-VLAN-MIB", "learnedVlanPortVlanIndex"))
if mibBuilder.loadTexts: learnedVlanPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: learnedVlanPortEntry.setDescription('For each port a list of VLANs that are active on the port can be retrieved.')
learnedVlanPortNo = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 11, 2, 11, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: learnedVlanPortNo.setStatus('mandatory')
if mibBuilder.loadTexts: learnedVlanPortNo.setDescription('The if-index decribing the requested port.')
learnedVlanPortVlanIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 11, 2, 11, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: learnedVlanPortVlanIndex.setStatus('mandatory')
if mibBuilder.loadTexts: learnedVlanPortVlanIndex.setDescription('The index of this VLAN, to be used when retrieving the next VLAN.')
learnedVlanPortVlanName = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 11, 2, 11, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: learnedVlanPortVlanName.setStatus('mandatory')
if mibBuilder.loadTexts: learnedVlanPortVlanName.setDescription('The name of the VLAN.')
vlanLearnedVlanIdTable = MibTable((1, 3, 6, 1, 4, 1, 343, 6, 11, 2, 12), )
if mibBuilder.loadTexts: vlanLearnedVlanIdTable.setStatus('mandatory')
if mibBuilder.loadTexts: vlanLearnedVlanIdTable.setDescription("Table of active VLAN id's")
learnedVlanIdEntry = MibTableRow((1, 3, 6, 1, 4, 1, 343, 6, 11, 2, 12, 1), ).setIndexNames((0, "INTEL-VLAN-MIB", "learnedVlanId"))
if mibBuilder.loadTexts: learnedVlanIdEntry.setStatus('mandatory')
if mibBuilder.loadTexts: learnedVlanIdEntry.setDescription('A VLAN is active in a device, if a station connected to that device has become a member of the VLAN.')
learnedVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 11, 2, 12, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: learnedVlanId.setStatus('mandatory')
if mibBuilder.loadTexts: learnedVlanId.setDescription('The index of the VLAN.')
learnedVlanIdVlanName = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 11, 2, 12, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: learnedVlanIdVlanName.setStatus('mandatory')
if mibBuilder.loadTexts: learnedVlanIdVlanName.setDescription('The name of the VLAN.')
vlanLearnedSnmpMgtVlanIds = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 11, 2, 13), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlanLearnedSnmpMgtVlanIds.setStatus('mandatory')
if mibBuilder.loadTexts: vlanLearnedSnmpMgtVlanIds.setDescription("This object will return a list of VLAN id's for the incoming SNMP request, usable to determine which VLANs the Mgt station itself belongs to. The answer is an Octet-string consisting of 16-bit unsigned integers, up to a maximum of 127 id's. If more VLAN id's should exist, only the first 127 will be returned in the reply.")
vlanLearnedMacVlanFlush = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 11, 2, 14), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlanLearnedMacVlanFlush.setStatus('mandatory')
if mibBuilder.loadTexts: vlanLearnedMacVlanFlush.setDescription('Setting this object to 1 will flush the MAC-VLAN table of the entire distributed domain.')
islTable = MibTable((1, 3, 6, 1, 4, 1, 343, 6, 11, 3, 1), )
if mibBuilder.loadTexts: islTable.setStatus('mandatory')
if mibBuilder.loadTexts: islTable.setDescription('A list of interconnected VLAN aware devices sharing the same doamin on a port.')
islEntry = MibTableRow((1, 3, 6, 1, 4, 1, 343, 6, 11, 3, 1, 1), ).setIndexNames((0, "INTEL-VLAN-MIB", "islIfIndex"), (0, "INTEL-VLAN-MIB", "islMacAddress"))
if mibBuilder.loadTexts: islEntry.setStatus('mandatory')
if mibBuilder.loadTexts: islEntry.setDescription('On each switch vlan link a list of connected devices referred to by MAC- and IP-address.')
islIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 11, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: islIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: islIfIndex.setDescription('The if-index decribing the requested port.')
islMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 11, 3, 1, 1, 2), EthMacAddress().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: islMacAddress.setStatus('mandatory')
if mibBuilder.loadTexts: islMacAddress.setDescription('The MAC address of an SVL station.')
islIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 11, 3, 1, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: islIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: islIpAddress.setDescription('The IP-address of an SVL station')
editTokenOwnerMacAddress = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 11, 4, 1), EthMacAddress().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: editTokenOwnerMacAddress.setStatus('mandatory')
if mibBuilder.loadTexts: editTokenOwnerMacAddress.setDescription('The MAC address of the station that is currently locking the global VLAN configuration.')
editTokenOwnerIpAddress = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 11, 4, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: editTokenOwnerIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: editTokenOwnerIpAddress.setDescription('The IP-address of the station that is currently locking the global VLAN configuration.')
editTokenOwnerSysName = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 11, 4, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: editTokenOwnerSysName.setStatus('mandatory')
if mibBuilder.loadTexts: editTokenOwnerSysName.setDescription('The System Name of the station that is currently locking the global VLAN configuration.')
editTokenOwnerApplication = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 11, 4, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("localManagement", 1), ("snmp", 2), ("nvpdbTftp", 3), ("serverUpdate", 4), ("externalTftpGet", 5), ("externalTftpPut", 6), ("loadFromFlash", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: editTokenOwnerApplication.setStatus('mandatory')
if mibBuilder.loadTexts: editTokenOwnerApplication.setDescription('The Application that is currently locking the global VLAN configuration.')
editTokenOwnerSnmpIpAddress = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 11, 4, 5), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: editTokenOwnerSnmpIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: editTokenOwnerSnmpIpAddress.setDescription('The IP address of the IP host that has taken the edit token via SNMP')
editTokenClaimReq = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 11, 4, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: editTokenClaimReq.setStatus('mandatory')
if mibBuilder.loadTexts: editTokenClaimReq.setDescription('This object is used to claim the Token to make changes to the VLAN configuration. Parameters are supplied in a binary coded octet string. Request will fail if sequence number given is lower than or equal to active configuration sequence number. Binary format: [<seqNo(4)><suggestNewSeqNo(1)><allocForSNMP(1)>] seqNo = sequence number expected to be next suggestNewSeqNo = if 1 device will assign allocForSNMP = if editing from SNMP set to 1')
editTokenLastClaimRspRetVal = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 11, 4, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 99, 100, 101, 102, 103, 104, 105))).clone(namedValues=NamedValues(("success", 1), ("failTaken", 2), ("failVersionTooOld", 3), ("failWrongDomainName", 4), ("notReady", 99), ("failClaiming", 100), ("failTakenThisSwitch", 101), ("failReqTimeout", 102), ("failGetBuffer", 103), ("failUpdating", 104), ("failNotReady", 105)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: editTokenLastClaimRspRetVal.setStatus('mandatory')
if mibBuilder.loadTexts: editTokenLastClaimRspRetVal.setDescription('Returns the last error code for the Claim Edit Token call.')
editTokenReleaseReq = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 11, 4, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("noSave", 1), ("save", 2), ("saveWithConfirmOption", 3), ("modeChangeRestoreDefault", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: editTokenReleaseReq.setStatus('mandatory')
if mibBuilder.loadTexts: editTokenReleaseReq.setDescription('Object used to release the Token. When setting object an integer indicating 1) Abandon changes, 2) Save changes, 3) Save changes and wait for confirmation (if not confirmed the device returns to the previous configuration) must be given or 4) we are changing VLAN mode/name and want to have our System VLAN (id=24) back, to ensure correct connectivity after the change')
editTokenLastReleaseRspRetVal = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 11, 4, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 99, 100, 101, 102, 104, 105, 106, 107, 108))).clone(namedValues=NamedValues(("success", 1), ("failNotTaken", 2), ("failNotOwner", 3), ("failReplacing", 4), ("notReady", 99), ("failClaiming", 100), ("failReqTimeout", 101), ("failForceReleased", 102), ("failReleasing", 104), ("failSaving", 105), ("failNotTakenThisAppl", 106), ("failLocalError", 107), ("failNotReady", 108)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: editTokenLastReleaseRspRetVal.setStatus('mandatory')
if mibBuilder.loadTexts: editTokenLastReleaseRspRetVal.setDescription('Returns the last error code for the Release Edit Token call.')
editTokenForceReleaseReq = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 11, 4, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: editTokenForceReleaseReq.setStatus('mandatory')
if mibBuilder.loadTexts: editTokenForceReleaseReq.setDescription('A forced release of the edit token can be issued by an IP host via SNMP by setting this object on the MVS.')
editTokenClientState = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 11, 4, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("notTaken", 1), ("taken", 2), ("claiming", 3), ("releasing", 4), ("reclaiming", 5), ("expectingNewNvpdb", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: editTokenClientState.setStatus('mandatory')
if mibBuilder.loadTexts: editTokenClientState.setDescription('The edit token state of the client')
editTokenTakenTime = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 11, 4, 12), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: editTokenTakenTime.setStatus('mandatory')
if mibBuilder.loadTexts: editTokenTakenTime.setDescription('The time that the edit token has been allocated (in hundreds of a second)')
editTokenLastForceReleaseRspRetVal = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 11, 4, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 99))).clone(namedValues=NamedValues(("success", 1), ("timeout", 2), ("notTaken", 3), ("inProgress", 4), ("notReady", 99)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: editTokenLastForceReleaseRspRetVal.setStatus('mandatory')
if mibBuilder.loadTexts: editTokenLastForceReleaseRspRetVal.setDescription('Returns the last error code for the Release Edit Token call.')
editTokenServerState = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 11, 4, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notTaken", 1), ("releasing", 2), ("taken", 3), ("forceReleasing", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: editTokenServerState.setStatus('mandatory')
if mibBuilder.loadTexts: editTokenServerState.setDescription('The edit token state of the server.')
previousVlanDomainName = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 11, 6, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8)))
if mibBuilder.loadTexts: previousVlanDomainName.setStatus('mandatory')
if mibBuilder.loadTexts: previousVlanDomainName.setDescription('Internal value used when sending SNMP traps')
vlanParsingErrorNo = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 11, 6, 2), Integer32())
if mibBuilder.loadTexts: vlanParsingErrorNo.setStatus('mandatory')
if mibBuilder.loadTexts: vlanParsingErrorNo.setDescription('Internal value used when sending SNMP traps')
vlanParsingErrorText = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 11, 6, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255)))
if mibBuilder.loadTexts: vlanParsingErrorText.setStatus('mandatory')
if mibBuilder.loadTexts: vlanParsingErrorText.setDescription('Internal value used when sending SNMP traps')
originatorIpAddress = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 11, 6, 4), IpAddress())
if mibBuilder.loadTexts: originatorIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: originatorIpAddress.setDescription('Internal value used when sending SNMP traps')
originatorMacAddress = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 11, 6, 5), EthMacAddress().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6))
if mibBuilder.loadTexts: originatorMacAddress.setStatus('mandatory')
if mibBuilder.loadTexts: originatorMacAddress.setDescription('Internal value used when sending SNMP traps')
originatorSysName = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 11, 6, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255)))
if mibBuilder.loadTexts: originatorSysName.setStatus('mandatory')
if mibBuilder.loadTexts: originatorSysName.setDescription('Internal value used when sending SNMP traps')
originatorMgtStationIpAddress = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 11, 6, 7), IpAddress())
if mibBuilder.loadTexts: originatorMgtStationIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: originatorMgtStationIpAddress.setDescription('Internal value used when sending SNMP traps')
globalVlanConfigurationChange = NotificationType((1, 3, 6, 1, 4, 1, 343, 6, 11) + (0,1)).setObjects(("INTEL-VLAN-MIB", "vlanPolicyDomainName"))
if mibBuilder.loadTexts: globalVlanConfigurationChange.setDescription('A new VLAN configuration has been distributed.')
localConfigurationChange = NotificationType((1, 3, 6, 1, 4, 1, 343, 6, 11) + (0,2)).setObjects(("INTEL-VLAN-MIB", "vlanPolicyDomainName"), ("SNMPv2-MIB", "sysName"))
if mibBuilder.loadTexts: localConfigurationChange.setDescription('Changes made to local VLAN configuration.')
invalidVlanConfiguration = NotificationType((1, 3, 6, 1, 4, 1, 343, 6, 11) + (0,3)).setObjects(("INTEL-VLAN-MIB", "vlanPolicyDomainName"), ("INTEL-VLAN-MIB", "vlanParsingErrorNo"), ("INTEL-VLAN-MIB", "vlanParsingErrorText"))
if mibBuilder.loadTexts: invalidVlanConfiguration.setDescription('Error in uploaded configuration.')
domainNameChange = NotificationType((1, 3, 6, 1, 4, 1, 343, 6, 11) + (0,5)).setObjects(("INTEL-VLAN-MIB", "previousVlanDomainName"), ("INTEL-VLAN-MIB", "vlanPolicyDomainName"))
if mibBuilder.loadTexts: domainNameChange.setDescription('The VLAN domain name has been changed.')
newSwitchInDomain = NotificationType((1, 3, 6, 1, 4, 1, 343, 6, 11) + (0,6)).setObjects(("INTEL-VLAN-MIB", "vlanPolicyDomainName"), ("INTEL-VLAN-MIB", "islIfIndex"), ("INTEL-VLAN-MIB", "islMacAddress"), ("INTEL-VLAN-MIB", "islIpAddress"))
if mibBuilder.loadTexts: newSwitchInDomain.setDescription('This station is now participating in the domain.')
missingSwitchInDomain = NotificationType((1, 3, 6, 1, 4, 1, 343, 6, 11) + (0,7)).setObjects(("INTEL-VLAN-MIB", "vlanPolicyDomainName"), ("INTEL-VLAN-MIB", "islIfIndex"), ("INTEL-VLAN-MIB", "islMacAddress"), ("INTEL-VLAN-MIB", "islIpAddress"))
if mibBuilder.loadTexts: missingSwitchInDomain.setDescription('A switch is no longer in the domain.')
editTokenForceRelease = NotificationType((1, 3, 6, 1, 4, 1, 343, 6, 11) + (0,8)).setObjects(("INTEL-VLAN-MIB", "vlanPolicyDomainName"), ("INTEL-VLAN-MIB", "originatorIpAddress"), ("INTEL-VLAN-MIB", "originatorMacAddress"), ("INTEL-VLAN-MIB", "originatorSysName"), ("INTEL-VLAN-MIB", "originatorMgtStationIpAddress"))
if mibBuilder.loadTexts: editTokenForceRelease.setDescription('This station has made a forced release of the edit token for the VLAN configuration')
editTokenRequestFailed = NotificationType((1, 3, 6, 1, 4, 1, 343, 6, 11) + (0,9)).setObjects(("INTEL-VLAN-MIB", "vlanPolicyDomainName"), ("INTEL-VLAN-MIB", "originatorMgtStationIpAddress"))
if mibBuilder.loadTexts: editTokenRequestFailed.setDescription('A management station tried to allocate the token while it was not available.')
configConfirmFailed = NotificationType((1, 3, 6, 1, 4, 1, 343, 6, 11) + (0,10)).setObjects(("INTEL-VLAN-MIB", "vlanPolicyDomainName"), ("INTEL-VLAN-MIB", "originatorSysName"))
if mibBuilder.loadTexts: configConfirmFailed.setDescription('The new configuration rendered the device inaccessible to the management station, and the old configuration has been restored.')
vlanLearnedDatabaseFull = NotificationType((1, 3, 6, 1, 4, 1, 343, 6, 11) + (0,11)).setObjects(("INTEL-VLAN-MIB", "vlanPolicyDomainName"))
if mibBuilder.loadTexts: vlanLearnedDatabaseFull.setDescription('The VLAN learning process was unable to insert an entry in the VLAN database. This may result in a loss of connectivity between some stations. This is not an error; the setup is larger than the system has been designed to handle.')
mibBuilder.exportSymbols("INTEL-VLAN-MIB", policyIpRuleDeleteObj=policyIpRuleDeleteObj, vlanLearnedServerMACAddress=vlanLearnedServerMACAddress, learnedVlanPortNo=learnedVlanPortNo, configConfirmFailed=configConfirmFailed, vlanPolicyMode=vlanPolicyMode, learnedMacIpAddress=learnedMacIpAddress, policyPortRuleVlanId=policyPortRuleVlanId, policyIpNetRuleCreateObj=policyIpNetRuleCreateObj, vlanPolicyFwdLearnPckts=vlanPolicyFwdLearnPckts, policyVlanEntry=policyVlanEntry, vlanLearnedServerState=vlanLearnedServerState, learnedVlanId=learnedVlanId, vlanParsingErrorText=vlanParsingErrorText, islIpAddress=islIpAddress, editTokenLastReleaseRspRetVal=editTokenLastReleaseRspRetVal, learnedMacType=learnedMacType, editTokenServerState=editTokenServerState, policyIpRuleCreateObj=policyIpRuleCreateObj, policyPortRuleDeleteObj=policyPortRuleDeleteObj, previousVlanDomainName=previousVlanDomainName, policyStackPortRuleDeleteObj=policyStackPortRuleDeleteObj, vlanPolicyPortRuleTable=vlanPolicyPortRuleTable, editTokenReleaseReq=editTokenReleaseReq, policyPortSettingsIpLearning=policyPortSettingsIpLearning, vlanPolicyChangedStamp=vlanPolicyChangedStamp, vlanIsl=vlanIsl, originatorMacAddress=originatorMacAddress, learnedMacAddress=learnedMacAddress, vlanPolicySupportedVlanModes=vlanPolicySupportedVlanModes, policyPortRuleEntry=policyPortRuleEntry, vlanLearnedServerNameChangeTimer=vlanLearnedServerNameChangeTimer, policyIpRuleVlanId=policyIpRuleVlanId, editTokenTakenTime=editTokenTakenTime, vlanLearnedServerPriority=vlanLearnedServerPriority, editTokenClaimReq=editTokenClaimReq, vlanLearnedDatabaseFull=vlanLearnedDatabaseFull, learnedMacVlanName=learnedMacVlanName, invalidVlanConfiguration=invalidVlanConfiguration, vlanTrapObjects=vlanTrapObjects, vlanPolicyAssignManagementVlan=vlanPolicyAssignManagementVlan, policyIslMacRuleVlanId=policyIslMacRuleVlanId, vlanPolicyConfigConfTimerValue=vlanPolicyConfigConfTimerValue, EthMacAddress=EthMacAddress, policyPortSettingsPortNumber=policyPortSettingsPortNumber, vlanPolicyDomainName=vlanPolicyDomainName, policyPortRuleCreateObj=policyPortRuleCreateObj, vlanLearnedServerPortNo=vlanLearnedServerPortNo, vlanLearnedServerIPAddress=vlanLearnedServerIPAddress, islMacAddress=islMacAddress, vlanPolicyServerSeqNo=vlanPolicyServerSeqNo, learnedVlanPortVlanName=learnedVlanPortVlanName, policyIpNetRuleDeleteObj=policyIpNetRuleDeleteObj, editTokenOwnerMacAddress=editTokenOwnerMacAddress, policyIslMacRuleDeleteObj=policyIslMacRuleDeleteObj, learnedMacVlanIndex=learnedMacVlanIndex, policyMacRuleEntry=policyMacRuleEntry, policyMacRuleAddress=policyMacRuleAddress, originatorMgtStationIpAddress=originatorMgtStationIpAddress, localConfigurationChange=localConfigurationChange, policyStackPortRuleCreateObj=policyStackPortRuleCreateObj, learnedVlanPortVlanIndex=learnedVlanPortVlanIndex, policyPortRuleNumber=policyPortRuleNumber, editTokenLastClaimRspRetVal=editTokenLastClaimRspRetVal, vlanPolicyConfigConfState=vlanPolicyConfigConfState, vlanPolicyIpRuleTable=vlanPolicyIpRuleTable, editTokenOwnerApplication=editTokenOwnerApplication, vlanPolicyLastApiError=vlanPolicyLastApiError, policyIslMacRuleAddress=policyIslMacRuleAddress, islIfIndex=islIfIndex, vlanEditToken=vlanEditToken, vlanPolicyVlanTable=vlanPolicyVlanTable, policyVlanName=policyVlanName, originatorIpAddress=originatorIpAddress, vlan=vlan, vlanPolicyMacVlanServerPriority=vlanPolicyMacVlanServerPriority, editTokenOwnerIpAddress=editTokenOwnerIpAddress, editTokenLastForceReleaseRspRetVal=editTokenLastForceReleaseRspRetVal, learnedMacVlanEntry=learnedMacVlanEntry, vlanPolicyAllPortSettingsIpLearning=vlanPolicyAllPortSettingsIpLearning, policyStackPortRuleSwitchMac=policyStackPortRuleSwitchMac, policyPortSettingsEntry=policyPortSettingsEntry, vlanPolicyNextVlanId=vlanPolicyNextVlanId, missingSwitchInDomain=missingSwitchInDomain, vlanPolicyAutoMoveMgtIpLink=vlanPolicyAutoMoveMgtIpLink, policyIslMacRuleCreateObj=policyIslMacRuleCreateObj, vlanPolicyIslMacRuleTable=vlanPolicyIslMacRuleTable, learnedMacVlanMac=learnedMacVlanMac, policyMacRuleVlanId=policyMacRuleVlanId, policyVlanCreateObj=policyVlanCreateObj, globalVlanConfigurationChange=globalVlanConfigurationChange, vlanParsingErrorNo=vlanParsingErrorNo, vlanPolicyIpNetRuleTable=vlanPolicyIpNetRuleTable, policyStackPortRuleNumber=policyStackPortRuleNumber, policyStackPortRuleEntry=policyStackPortRuleEntry, policyMacRuleDeleteObj=policyMacRuleDeleteObj, vlanLearnedVersion=vlanLearnedVersion, policyIpRuleAddress=policyIpRuleAddress, domainNameChange=domainNameChange, policyStackPortRuleVlanId=policyStackPortRuleVlanId, originatorSysName=originatorSysName, vlanPolicyMacRuleTable=vlanPolicyMacRuleTable, policyIpNetRuleEntry=policyIpNetRuleEntry, learnedMacEntry=learnedMacEntry, policyIpNetRuleVlanId=policyIpNetRuleVlanId, vlanPolicy=vlanPolicy, vlanLearnedMacVlanTable=vlanLearnedMacVlanTable, editTokenClientState=editTokenClientState, vlanPolicyStackPortRuleTable=vlanPolicyStackPortRuleTable, policyVlanDeleteObj=policyVlanDeleteObj, policyIpRuleEntry=policyIpRuleEntry, learnedMacPortNo=learnedMacPortNo, vlanLearnedVlanIdTable=vlanLearnedVlanIdTable, learnedVlanPortEntry=learnedVlanPortEntry, editTokenOwnerSysName=editTokenOwnerSysName, editTokenForceReleaseReq=editTokenForceReleaseReq, editTokenOwnerSnmpIpAddress=editTokenOwnerSnmpIpAddress, policyVlanId=policyVlanId, vlanLearnedMacVlanFlush=vlanLearnedMacVlanFlush, newSwitchInDomain=newSwitchInDomain, islEntry=islEntry, vlanLearned=vlanLearned, vlanPolicyRevert2Default=vlanPolicyRevert2Default, vlanLearnedSnmpMgtVlanIds=vlanLearnedSnmpMgtVlanIds, vlanLearnedMacTable=vlanLearnedMacTable, editTokenRequestFailed=editTokenRequestFailed, policyIpNetRuleAddress=policyIpNetRuleAddress, vlanPolicyUseMultiSTP=vlanPolicyUseMultiSTP, vlanLearnedServerExpiryTimer=vlanLearnedServerExpiryTimer, learnedVlanIdEntry=learnedVlanIdEntry, policyIpNetRuleMask=policyIpNetRuleMask, vlanPolicyPortSettingsTable=vlanPolicyPortSettingsTable, vlanPolicyChangeOperation=vlanPolicyChangeOperation, policyMacRuleCreateObj=policyMacRuleCreateObj, policyIslMacRuleEntry=policyIslMacRuleEntry, vlanLearnedVlanPortTable=vlanLearnedVlanPortTable, learnedVlanIdVlanName=learnedVlanIdVlanName, islTable=islTable, editTokenForceRelease=editTokenForceRelease, vlanPolicyClientSeqNo=vlanPolicyClientSeqNo)

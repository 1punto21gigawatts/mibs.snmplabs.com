#
# PySNMP MIB module PRESTICOM7-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/PRESTICOM7-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:41:59 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ValueRangeConstraint, SingleValueConstraint, ValueSizeConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ValueRangeConstraint", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsUnion")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Gauge32, enterprises, MibScalar, MibTable, MibTableRow, MibTableColumn, NotificationType, MibIdentifier, Counter32, ModuleIdentity, NotificationType, ObjectIdentity, Unsigned32, iso, Integer32, Bits, IpAddress, Counter64, TimeTicks = mibBuilder.importSymbols("SNMPv2-SMI", "Gauge32", "enterprises", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "NotificationType", "MibIdentifier", "Counter32", "ModuleIdentity", "NotificationType", "ObjectIdentity", "Unsigned32", "iso", "Integer32", "Bits", "IpAddress", "Counter64", "TimeTicks")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
presticom = MibIdentifier((1, 3, 6, 1, 4, 1, 727))
netperformer7 = MibIdentifier((1, 3, 6, 1, 4, 1, 727, 7))
info = MibIdentifier((1, 3, 6, 1, 4, 1, 727, 7, 50))
mibVersionInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 727, 7, 50, 10))
mibVersion = MibIdentifier((1, 3, 6, 1, 4, 1, 727, 7, 50, 10, 7))
mibSubVersion = MibIdentifier((1, 3, 6, 1, 4, 1, 727, 7, 50, 10, 7, 0))
mibSpecialVersion = MibIdentifier((1, 3, 6, 1, 4, 1, 727, 7, 50, 10, 7, 0, 4))
mibEvolution = MibIdentifier((1, 3, 6, 1, 4, 1, 727, 7, 50, 10, 7, 0, 4, 1))
product = MibIdentifier((1, 3, 6, 1, 4, 1, 727, 7, 1))
mgmt = MibIdentifier((1, 3, 6, 1, 4, 1, 727, 7, 2))
noDevice = MibIdentifier((1, 3, 6, 1, 4, 1, 727, 7, 1, 1))
ver6X_Device = MibIdentifier((1, 3, 6, 1, 4, 1, 727, 7, 1, 2)).setLabel("ver6X-Device")
system = MibIdentifier((1, 3, 6, 1, 4, 1, 727, 7, 2, 1))
ifwan = MibIdentifier((1, 3, 6, 1, 4, 1, 727, 7, 2, 2))
iflan = MibIdentifier((1, 3, 6, 1, 4, 1, 727, 7, 2, 3))
ifvce = MibIdentifier((1, 3, 6, 1, 4, 1, 727, 7, 2, 18))
pu = MibIdentifier((1, 3, 6, 1, 4, 1, 727, 7, 2, 4))
schedule = MibIdentifier((1, 3, 6, 1, 4, 1, 727, 7, 2, 5))
bridge = MibIdentifier((1, 3, 6, 1, 4, 1, 727, 7, 2, 6))
phone = MibIdentifier((1, 3, 6, 1, 4, 1, 727, 7, 2, 7))
filter = MibIdentifier((1, 3, 6, 1, 4, 1, 727, 7, 2, 8))
pysmi_class = MibIdentifier((1, 3, 6, 1, 4, 1, 727, 7, 2, 9)).setLabel("class")
pvc = MibIdentifier((1, 3, 6, 1, 4, 1, 727, 7, 2, 10))
ipx = MibIdentifier((1, 3, 6, 1, 4, 1, 727, 7, 2, 11))
ipstatic = MibIdentifier((1, 3, 6, 1, 4, 1, 727, 7, 2, 13))
ip = MibIdentifier((1, 3, 6, 1, 4, 1, 727, 7, 2, 14))
ospf = MibIdentifier((1, 3, 6, 1, 4, 1, 727, 7, 2, 15))
ipxfilter = MibIdentifier((1, 3, 6, 1, 4, 1, 727, 7, 2, 16))
stat = MibIdentifier((1, 3, 6, 1, 4, 1, 727, 7, 2, 20))
intf = MibIdentifier((1, 3, 6, 1, 4, 1, 727, 7, 2, 30))
slot = MibIdentifier((1, 3, 6, 1, 4, 1, 727, 7, 2, 31))
ipaddr = MibIdentifier((1, 3, 6, 1, 4, 1, 727, 7, 2, 32))
bootp = MibIdentifier((1, 3, 6, 1, 4, 1, 727, 7, 2, 33))
proxy = MibIdentifier((1, 3, 6, 1, 4, 1, 727, 7, 2, 34))
timep = MibIdentifier((1, 3, 6, 1, 4, 1, 727, 7, 2, 35))
sysDesc = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 1, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysDesc.setStatus('mandatory')
if mibBuilder.loadTexts: sysDesc.setDescription('This variable contains a printable octet string which contains the full name and version of the product.')
sysContact = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysContact.setStatus('mandatory')
if mibBuilder.loadTexts: sysContact.setDescription('The textual identification of the contact person for this managed node, together with information on how to contact this person.')
sysName = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysName.setStatus('mandatory')
if mibBuilder.loadTexts: sysName.setDescription("An administratively-assigned name for this managed node. By convention, this is the node's fully-qualified domain name.")
sysUnitRoutingVersion = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysUnitRoutingVersion.setStatus('mandatory')
if mibBuilder.loadTexts: sysUnitRoutingVersion.setDescription('As of software release 6.7.0, the netperformer7 product line has an improved routing version for destinations reached via ports and PVCs configured with the PVCR protocol. This new routing version is called Version 2, and the previous routing version is referred to as Version 1. The most recent release of the netperformer7 (software release 6.7.0) can be configured to run either routing version. The routing version used for a particular unit is determined by the Unit Routing Version parameter. Unit Routing Version: The routing version to be used on this unit. Select 1 if any netperformer7 units in the network are running Unit Routing Version 1 (the version used in all software releases earlier than 6.7.0). Select 2 if all netperformer7 units in the network are running Unit Routing Version 2 (software release 6.7.0).')
sysLocation = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysLocation.setStatus('mandatory')
if mibBuilder.loadTexts: sysLocation.setDescription("The physical location of this node (e.g., `telephone closet, 3rd floor').")
sysDate = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 1, 5), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDate.setStatus('mandatory')
if mibBuilder.loadTexts: sysDate.setDescription('The current date.')
sysClock = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 1, 6), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysClock.setStatus('mandatory')
if mibBuilder.loadTexts: sysClock.setDescription('The current time.')
sysDay = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 254, 255))).clone(namedValues=NamedValues(("sunday", 1), ("monday", 2), ("tuesday", 3), ("wednesday", 4), ("thursday", 5), ("friday", 6), ("saturday", 7), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDay.setStatus('mandatory')
if mibBuilder.loadTexts: sysDay.setDescription('The current day.')
sysAcceptLoop = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("no", 1), ("yes", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysAcceptLoop.setStatus('mandatory')
if mibBuilder.loadTexts: sysAcceptLoop.setDescription('Control of loopback on the WAN links. This parameter determines whether loopback on any link is accepted (YES) or not accepted (NO). The unit software detects the presence of a loopback condition on any WAN link. Setting ACCEPT LOOP to NO prevents the unit from using a link that has been placed in loopback mode either temporarily or accidentally.')
sysLinkTimeout_s = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setLabel("sysLinkTimeout-s").setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysLinkTimeout_s.setStatus('mandatory')
if mibBuilder.loadTexts: sysLinkTimeout_s.setDescription('The delay, in seconds, before a WAN link is declared down during a link failure. This timeout can be used to prevent the accumulation of LINK DOWN alarms in the unit when brief link failures occur.')
sysTransitDelay_s = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20))).setLabel("sysTransitDelay-s").setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysTransitDelay_s.setStatus('mandatory')
if mibBuilder.loadTexts: sysTransitDelay_s.setDescription('The maximum delay, in seconds, allowed to elapse between the reception and transmission of a forwarded frame by a bridge. a timer is started if a link report that it is too busy to transmit a frame. Frame that are nor processed within the transit delay are discarded.')
sysDefaultIpAddr = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 1, 11), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDefaultIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: sysDefaultIpAddr.setDescription('Default IP address for the unit. This address is used for PVCR ports and PVCs that do not have a configures IP address (set with the IP LOCAL ADDR parameter for the port or PVC). It is a 4-byte value in dotted decimal representation with a maximum value of 255 for each byte. When set to 000.000.000.000, no default IP address is defined on the unit.')
sysDefaultIpMask = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 1, 12), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDefaultIpMask.setStatus('mandatory')
if mibBuilder.loadTexts: sysDefaultIpMask.setDescription('Default IP subnet mask associated with the default IP address. It is configured like the default IP address: a 4-byte value in dotted decimal representation, with a maximum value of 255 for each byte. The default IP mask identifies which bits of the IP address correspond to the physical network, and which bits correspond to host identifiers.')
sysDefaultGateway = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 1, 13), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDefaultGateway.setStatus('mandatory')
if mibBuilder.loadTexts: sysDefaultGateway.setDescription('This is the gateways IP address to use when a destination is unknown. At this time, well transmit all frame with unknown destination to this gateway.')
sysRackId = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 254, 255))).clone(namedValues=NamedValues(("cs-product-only", 0), ("rack-1", 1), ("rack-2", 2), ("rack-3", 3), ("rack-4", 4), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysRackId.setStatus('mandatory')
if mibBuilder.loadTexts: sysRackId.setDescription('ID of the CS-Rack this board is plugged in')
sysPsAndFansMonitoring = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 254, 255))).clone(namedValues=NamedValues(("cs-product-only", 0), ("none", 1), ("ps", 2), ("fans", 3), ("both", 4), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysPsAndFansMonitoring.setStatus('mandatory')
if mibBuilder.loadTexts: sysPsAndFansMonitoring.setDescription('The monitoring functionality of the Power Supplies and Fans.')
sysPsMonitoring = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 1, 47), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("no", 1), ("yes", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysPsMonitoring.setStatus('mandatory')
if mibBuilder.loadTexts: sysPsMonitoring.setDescription('The monitoring functionality of the Power Supplies and Fans.')
sysSnmpTrapIpAddr1 = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 1, 17), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSnmpTrapIpAddr1.setStatus('mandatory')
if mibBuilder.loadTexts: sysSnmpTrapIpAddr1.setDescription('Specific IP address to sent SNMP trap.')
sysSnmpTrapIpAddr2 = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 1, 18), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSnmpTrapIpAddr2.setStatus('mandatory')
if mibBuilder.loadTexts: sysSnmpTrapIpAddr2.setDescription('Specific IP address to sent SNMP trap.')
sysSnmpTrapIpAddr3 = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 1, 19), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSnmpTrapIpAddr3.setStatus('mandatory')
if mibBuilder.loadTexts: sysSnmpTrapIpAddr3.setDescription('Specific IP address to sent SNMP trap.')
sysSnmpTrapIpAddr4 = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 1, 20), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSnmpTrapIpAddr4.setStatus('mandatory')
if mibBuilder.loadTexts: sysSnmpTrapIpAddr4.setDescription('Specific IP address to sent SNMP trap.')
sysThisPosId = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 254, 255))).clone(namedValues=NamedValues(("cs-product-only", 0), ("pos-1", 1), ("pos-2", 2), ("pos-3", 3), ("pos-4", 4), ("pos-5", 5), ("pos-6", 6), ("pos-7", 7), ("pos-8", 8), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysThisPosId.setStatus('mandatory')
if mibBuilder.loadTexts: sysThisPosId.setDescription("ID of this board's position")
sysPosNr = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 1, 31), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysPosNr.setStatus('mandatory')
if mibBuilder.loadTexts: sysPosNr.setDescription('The number of positions in the Rack this board belongs to (Always 8, hardware characteristic)')
sysRacksNr = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 1, 33), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysRacksNr.setStatus('mandatory')
if mibBuilder.loadTexts: sysRacksNr.setDescription('The total number of populated Racks in the system (1 to 4 racks)')
sysPosTable = MibTable((1, 3, 6, 1, 4, 1, 727, 7, 2, 1, 32), )
if mibBuilder.loadTexts: sysPosTable.setStatus('mandatory')
if mibBuilder.loadTexts: sysPosTable.setDescription('This table represents the entire rack this board belongs to. The number of entries is sysPosNr')
sysPosEntry = MibTableRow((1, 3, 6, 1, 4, 1, 727, 7, 2, 1, 32, 1), ).setIndexNames((0, "PRESTICOM7-MIB", "sysPosRackId"), (0, "PRESTICOM7-MIB", "sysPosId"))
if mibBuilder.loadTexts: sysPosEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sysPosEntry.setDescription('This entry contains the principal configurable parameters related to CS racks and positions')
sysPosId = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 1, 32, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 254, 255))).clone(namedValues=NamedValues(("cs-product-only", 0), ("pos-1", 1), ("pos-2", 2), ("pos-3", 3), ("pos-4", 4), ("pos-5", 5), ("pos-6", 6), ("pos-7", 7), ("pos-8", 8), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysPosId.setStatus('mandatory')
if mibBuilder.loadTexts: sysPosId.setDescription("ID of the CS-Rack's position that the board at sysPosIndex is plugged in")
sysPosProduct = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 1, 32, 1, 3), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysPosProduct.setStatus('mandatory')
if mibBuilder.loadTexts: sysPosProduct.setDescription('The Product descriptor of the board at sysPosIndex in the OID form e.g.: {presticom netperformer7 product product-id} ')
sysPosRackId = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 1, 32, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 254, 255))).clone(namedValues=NamedValues(("single-rack", 0), ("rack-1", 1), ("rack-2", 2), ("rack-3", 3), ("rack-4", 4), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysPosRackId.setStatus('mandatory')
if mibBuilder.loadTexts: sysPosRackId.setDescription('ID of the CS-Rackds as it is configured in the board indexed by sysPosIndex. On a correctly configured installation, all positions in one rack must bear the same rackId')
sysPosIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 1, 32, 1, 5), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysPosIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: sysPosIpAddr.setDescription("the (Default) IP address for the unit. It means that, by managing this table in one position, we can see and alter the other position's IP addresses")
ipaddrNr = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 32, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipaddrNr.setStatus('mandatory')
if mibBuilder.loadTexts: ipaddrNr.setDescription('The number ip addresses identifying this unit')
ipaddrTable = MibTable((1, 3, 6, 1, 4, 1, 727, 7, 2, 32, 2), )
if mibBuilder.loadTexts: ipaddrTable.setStatus('mandatory')
if mibBuilder.loadTexts: ipaddrTable.setDescription('A list of ip addresses entries. The number of entries is given by the value of ipaddrNr.')
ipaddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 727, 7, 2, 32, 2, 1), ).setIndexNames((0, "PRESTICOM7-MIB", "ipaddrIndex"))
if mibBuilder.loadTexts: ipaddrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ipaddrEntry.setDescription('This table is an index list of all ip addresses of this unit.')
ipaddrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 32, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipaddrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ipaddrIndex.setDescription('')
ipaddrAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 32, 2, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipaddrAddr.setStatus('mandatory')
if mibBuilder.loadTexts: ipaddrAddr.setDescription('')
ipaddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 32, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("undef", 0), ("global", 1), ("wan", 2), ("lan", 3), ("proxy", 4), ("pvc", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipaddrType.setStatus('mandatory')
if mibBuilder.loadTexts: ipaddrType.setDescription('')
ipaddrIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 32, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipaddrIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ipaddrIfIndex.setDescription('')
sysDLCI = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 1, 34), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDLCI.setStatus('mandatory')
if mibBuilder.loadTexts: sysDLCI.setDescription('The local DLCI address used as Srce field in the connection request to an FP')
sysExtensionNumLength = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 1, 35), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysExtensionNumLength.setStatus('mandatory')
if mibBuilder.loadTexts: sysExtensionNumLength.setDescription('The number of digits that must be used to define a port Extension Number, or a Destination Extension Number in the Voice Mapping Table for this Netperformer.')
sysExtendedDigitsLength = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 1, 36), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysExtendedDigitsLength.setStatus('mandatory')
if mibBuilder.loadTexts: sysExtendedDigitsLength.setDescription('This parameter sets the number of digits that must be entered into the telephone set when the Extension Number Source of a Voice Mapping Table entry is set to User.')
sysDialTimer = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 1, 37), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDialTimer.setStatus('mandatory')
if mibBuilder.loadTexts: sysDialTimer.setDescription('This parameter specifies the amount of time the system should wait for a response to a Call Connect or Call Clear requests.')
sysCountry = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 1, 38), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 9999))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysCountry.setStatus('mandatory')
if mibBuilder.loadTexts: sysCountry.setDescription('This parameter determines the type of ring, dial tone, ringback tone and busy tone that will be generated by the NetVoice card. To ensure that these signals are generated according to local standards, set this parameter to the country where the NetVoice is located.')
sysJitterBuf = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 1, 39), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysJitterBuf.setStatus('mandatory')
if mibBuilder.loadTexts: sysJitterBuf.setDescription('The amount of jitter delay, in milliseconds, that the unit voice uses to compensate for the variable arrival time of packets.')
sysRingFreq = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 1, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 254, 255))).clone(namedValues=NamedValues(("voice-data-only", 0), ("hz-17", 1), ("hz-20", 2), ("hz-25", 3), ("hz-50", 4), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysRingFreq.setStatus('mandatory')
if mibBuilder.loadTexts: sysRingFreq.setDescription('the frequency in hertz, at which a ring is generated on locally attached equipment')
sysRingVolt = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 1, 41), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 254, 255))).clone(namedValues=NamedValues(("voice-data-only", 0), ("rms-Volts-60", 1), ("rms-Volts-80", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysRingVolt.setStatus('mandatory')
if mibBuilder.loadTexts: sysRingVolt.setDescription('the voltage, in volts rms, at which a ring is generated on locally attached equipment.')
sysVoiceEncoding = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 1, 42), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 254, 255))).clone(namedValues=NamedValues(("fp-product-only", 0), ("aCode", 1), ("bCode", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysVoiceEncoding.setStatus('mandatory')
if mibBuilder.loadTexts: sysVoiceEncoding.setDescription('SN-7800 and RX only...')
sysVoiceClocking = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 1, 43), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 254, 255))).clone(namedValues=NamedValues(("fp-product-only", 0), ("aClock", 1), ("bClock", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysVoiceClocking.setStatus('mandatory')
if mibBuilder.loadTexts: sysVoiceClocking.setDescription('SN-7800 and RX only...')
sysVoiceLog = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 1, 44), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("no", 1), ("yes", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysVoiceLog.setStatus('mandatory')
if mibBuilder.loadTexts: sysVoiceLog.setDescription('Enable logs (accounting) on voice/fax ports')
sysSpeedDialNumLength = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 1, 45), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSpeedDialNumLength.setStatus('mandatory')
if mibBuilder.loadTexts: sysSpeedDialNumLength.setDescription('Number of digit of the MAP numbers')
sysAutoSaveDelay = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 1, 46), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysAutoSaveDelay.setStatus('mandatory')
if mibBuilder.loadTexts: sysAutoSaveDelay.setDescription('Number of seconds left after a modification and before saving in flash (0 : no auto save)')
sysVoiceHighestPriority = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 1, 48), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("no", 1), ("yes", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysVoiceHighestPriority.setStatus('mandatory')
if mibBuilder.loadTexts: sysVoiceHighestPriority.setDescription('When set to yes, the voice traffic has unconditionnaly the highest possible priority. When set to no, the voice priority is specified by sysVoiceClass.')
sysVoiceClass = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 1, 49), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysVoiceClass.setStatus('mandatory')
if mibBuilder.loadTexts: sysVoiceClass.setDescription('Associate the voice traffic to a class priority. Effective only if sysVoiceHighestPriority is set to no')
sysHuntForwardingAUnit = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 1, 50), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysHuntForwardingAUnit.setStatus('mandatory')
if mibBuilder.loadTexts: sysHuntForwardingAUnit.setDescription('Hunt forwarding group A Unit name. Unit name where a busy call for hunt group A will be forwarded to')
sysHuntForwardingBUnit = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 1, 51), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysHuntForwardingBUnit.setStatus('mandatory')
if mibBuilder.loadTexts: sysHuntForwardingBUnit.setDescription('Hunt forwarding group B Unit name. Unit name where a busy call for hunt group B will be forwarded to')
sysHuntForwardingADLCI = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 1, 52), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysHuntForwardingADLCI.setStatus('mandatory')
if mibBuilder.loadTexts: sysHuntForwardingADLCI.setDescription('Hunt forwarding group A DLCI address. DLCI address where a busy call for hunt group A will be forwarded on an FP PVC')
sysHuntForwardingBDLCI = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 1, 53), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysHuntForwardingBDLCI.setStatus('mandatory')
if mibBuilder.loadTexts: sysHuntForwardingBDLCI.setDescription('Hunt forwarding group B DLCI address. DLCI address where a busy call for hunt group B will be forwarded on an FP PVC')
sysHuntForwardingASvcAddress = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 1, 54), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysHuntForwardingASvcAddress.setStatus('mandatory')
if mibBuilder.loadTexts: sysHuntForwardingASvcAddress.setDescription('Hunt forwarding group A SVC address. SVC address where a busy call for hunt group A will be forwarded on an FP SVC. NOTE: sysHuntForwardingAUnit must be empty otherwise this parameter is ignored')
sysHuntForwardingBSvcAddress = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 1, 55), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysHuntForwardingBSvcAddress.setStatus('mandatory')
if mibBuilder.loadTexts: sysHuntForwardingBSvcAddress.setDescription('Hunt forwarding group A SVC address. SVC address where a busy call for hunt group A will be forwarded on an FP SVC. NOTE: sysHuntForwardingBUnit must be empty otherwise this parameter is ignored')
sysBackplaneRipVersion = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 1, 56), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 254, 255))).clone(namedValues=NamedValues(("disable", 1), ("v1", 2), ("v2-broadcast", 3), ("v2-multicast", 4), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysBackplaneRipVersion.setStatus('mandatory')
if mibBuilder.loadTexts: sysBackplaneRipVersion.setDescription('When this parameter is set to V1, the RIP routing is done according to the RIP V1 standard. With RIP V2, broadcast or multicast can be used. With RIP V2 MULTICAST, only RIP V2 compliant devices will receive RIP frames.')
sysTrapRackandPos = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 1, 57), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysTrapRackandPos.setStatus('mandatory')
if mibBuilder.loadTexts: sysTrapRackandPos.setDescription('Rack ID X 10 + Position ID.')
proxyNumber = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 34, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: proxyNumber.setStatus('mandatory')
if mibBuilder.loadTexts: proxyNumber.setDescription('Number of proxies in this unit')
proxyTable = MibTable((1, 3, 6, 1, 4, 1, 727, 7, 2, 34, 2), )
if mibBuilder.loadTexts: proxyTable.setStatus('mandatory')
if mibBuilder.loadTexts: proxyTable.setDescription('List of proxies in this unit')
proxyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 727, 7, 2, 34, 2, 1), ).setIndexNames((0, "PRESTICOM7-MIB", "proxyIndex"))
if mibBuilder.loadTexts: proxyEntry.setStatus('mandatory')
if mibBuilder.loadTexts: proxyEntry.setDescription('This row presents the characteristics that uniquely identifies one proxy board.')
proxyIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 34, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: proxyIndex.setStatus('mandatory')
if mibBuilder.loadTexts: proxyIndex.setDescription('A unique value for each proxy board.')
proxyComm = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 34, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: proxyComm.setStatus('mandatory')
if mibBuilder.loadTexts: proxyComm.setDescription('The name of the community used to access the proxy agent')
proxyIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 34, 2, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: proxyIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: proxyIpAddr.setDescription('IP address of this proxy agent')
proxyIpMask = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 34, 2, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: proxyIpMask.setStatus('mandatory')
if mibBuilder.loadTexts: proxyIpMask.setDescription('IP subnet mask of this proxy agent')
proxyTrapIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 34, 2, 1, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: proxyTrapIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: proxyTrapIpAddr.setDescription('Specific IP address to send SNMP trap.')
proxyDefaultGateway = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 34, 2, 1, 6), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: proxyDefaultGateway.setStatus('mandatory')
if mibBuilder.loadTexts: proxyDefaultGateway.setDescription("This is the IP address of the gateway handling routing to all nodes based on ACT'S proprietary NMS")
intfNumber = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 30, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: intfNumber.setStatus('mandatory')
if mibBuilder.loadTexts: intfNumber.setDescription('The number of overall interfaces present on this system.')
intfTable = MibTable((1, 3, 6, 1, 4, 1, 727, 7, 2, 30, 2), )
if mibBuilder.loadTexts: intfTable.setStatus('mandatory')
if mibBuilder.loadTexts: intfTable.setDescription('A list of interface entries. The number of entries is given by the value of ifNumber.')
intfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 727, 7, 2, 30, 2, 1), ).setIndexNames((0, "PRESTICOM7-MIB", "intfIndex"))
if mibBuilder.loadTexts: intfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: intfEntry.setDescription('This table presents the characteristics that uniquely identifies one interface.')
intfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 30, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: intfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: intfIndex.setDescription('A unique value for each interface. Matches exaclty the ifIndex of the ifEntry in RFC-1213 ')
intfDesc = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 30, 2, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: intfDesc.setStatus('mandatory')
if mibBuilder.loadTexts: intfDesc.setDescription('A textual string containing information about a specific interface.')
intfType = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 30, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 99, 254, 255))).clone(namedValues=NamedValues(("wan-on-baseCard", 1), ("voice-on-baseCard", 2), ("wan-on-slot", 3), ("voice-on-slot", 4), ("lan-on-baseCard", 5), ("lan-on-slot", 6), ("proxy-on-slot", 7), ("voice-control-on-slot", 8), ("clock-extract-module", 9), ("other", 99), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: intfType.setStatus('mandatory')
if mibBuilder.loadTexts: intfType.setDescription('A unique type value for each interface. ')
intfNumInType = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 30, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: intfNumInType.setStatus('mandatory')
if mibBuilder.loadTexts: intfNumInType.setDescription('The logical number of this interface amongst those having the same type.')
intfSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 30, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 254, 255))).clone(namedValues=NamedValues(("baseCard", 0), ("slot-1", 1), ("slot-2", 2), ("slot-3", 3), ("slot-4", 4), ("slot-5", 5), ("slot-6", 6), ("slot-7", 7), ("slot-8", 8), ("slot-A", 9), ("slot-B", 10), ("slot-C", 11), ("slot-D", 12), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: intfSlot.setStatus('mandatory')
if mibBuilder.loadTexts: intfSlot.setDescription('The localization of this interface, whether on baseCard or in slot, and on what slot ')
intfSlotType = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 30, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 9, 16, 17, 18, 19, 21, 22, 23, 51, 36, 9999, 254, 255))).clone(namedValues=NamedValues(("baseCard", 0), ("ethernet", 1), ("vcf03", 2), ("g703-E1", 3), ("g703-T1", 4), ("g703-E1-ii", 5), ("g703-T1-ii", 6), ("tokenring", 7), ("voice", 9), ("tic", 16), ("tic-75", 17), ("dvc", 18), ("isdn-bri-voice", 19), ("eic", 21), ("eic-120", 22), ("cem", 23), ("vfc03r", 51), ("proxy", 36), ("unkown", 9999), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: intfSlotType.setStatus('mandatory')
if mibBuilder.loadTexts: intfSlotType.setDescription('A unique value for each interface. ')
intfNumInSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 30, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: intfNumInSlot.setStatus('mandatory')
if mibBuilder.loadTexts: intfNumInSlot.setDescription('The logical number of this interface within its slot.')
intfModuleType = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 30, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 17, 18, 19, 20, 21, 22, 23, 255, 254, 253, 252))).clone(namedValues=NamedValues(("module-rs232-dce", 0), ("module-rs232-dte", 1), ("module-v35-dce", 2), ("module-v35-dte", 3), ("module-x21-dce", 4), ("module-x21-dte", 5), ("module-rs530-dce", 6), ("module-rs530-dte", 7), ("module-rs366A-dce", 8), ("module-rs366A-dte", 9), ("module-rs449-dce", 10), ("module-rs449-dte", 11), ("module-univ-dce", 17), ("module-univ-dte", 18), ("module-i430s-dte", 19), ("module-i430u-dte", 20), ("module-i431-T1-dte", 21), ("module-i431-E1-dte", 22), ("module-dsucsu", 23), ("module-undef-dce", 255), ("module-undef-dte", 254), ("module-undef", 253), ("not-applicable", 252)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: intfModuleType.setStatus('mandatory')
if mibBuilder.loadTexts: intfModuleType.setDescription('A unique value for each interface. ')
intfSlotNumber = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 31, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: intfSlotNumber.setStatus('mandatory')
if mibBuilder.loadTexts: intfSlotNumber.setDescription('The number of overall slots actually presents on this system.')
slotPortInSlotTable = MibTable((1, 3, 6, 1, 4, 1, 727, 7, 2, 31, 2), )
if mibBuilder.loadTexts: slotPortInSlotTable.setStatus('mandatory')
if mibBuilder.loadTexts: slotPortInSlotTable.setDescription('This table maps a slot/PortInThisSlot coordinate to the corresponding ifIndex (in intfTable and ifTable)')
slotPortInSlotEntry = MibTableRow((1, 3, 6, 1, 4, 1, 727, 7, 2, 31, 2, 1), ).setIndexNames((0, "PRESTICOM7-MIB", "slotSlot"), (0, "PRESTICOM7-MIB", "slotPortInSlot"))
if mibBuilder.loadTexts: slotPortInSlotEntry.setStatus('mandatory')
if mibBuilder.loadTexts: slotPortInSlotEntry.setDescription('One element of the above table')
slotSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 31, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 254, 255))).clone(namedValues=NamedValues(("baseCard", 0), ("slot-1", 1), ("slot-2", 2), ("slot-3", 3), ("slot-4", 4), ("slot-5", 5), ("slot-6", 6), ("slot-7", 7), ("slot-8", 8), ("slot-A", 9), ("slot-B", 10), ("slot-C", 11), ("slot-D", 12), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slotSlot.setStatus('mandatory')
if mibBuilder.loadTexts: slotSlot.setDescription('The localization of this interface, whether on baseCard or in slot, and on what slot ')
slotPortInSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 31, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slotPortInSlot.setStatus('mandatory')
if mibBuilder.loadTexts: slotPortInSlot.setDescription('The logical number of this interface within its slot.')
slotIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 31, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slotIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: slotIfIndex.setDescription('A unique value for each interface. Matches exaclty the ifIndex of the ifEntry in RFC-1213 ')
ifwanNumber = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifwanNumber.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanNumber.setDescription('The number of wan interfaces present on this system.')
ifwanTable = MibTable((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2), )
if mibBuilder.loadTexts: ifwanTable.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanTable.setDescription('A list of interface entries. The number of entries is given by the value of ifwanNumber.')
ifwanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1), ).setIndexNames((0, "PRESTICOM7-MIB", "ifwanIndex"))
if mibBuilder.loadTexts: ifwanEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanEntry.setDescription('This table contains the principal configurable parameters which are used for a particular wan interface.')
ifwanIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifwanIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanIndex.setDescription('A unique value for each interface.')
ifwanDesc = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifwanDesc.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanDesc.setDescription('A textual string containing information about a specific interface.')
ifwanProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 17, 18, 19, 28, 29, 31, 254, 255))).clone(namedValues=NamedValues(("off", 1), ("p-sdlc", 2), ("s-sdlc", 3), ("hdlc", 4), ("ddcmp", 5), ("t-async", 6), ("r-async", 7), ("bsc", 8), ("cop", 9), ("pvcr", 10), ("passthru", 11), ("console", 12), ("fr-net", 17), ("fr-user", 18), ("ppp", 19), ("g703", 28), ("x25", 29), ("sf", 31), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanProtocol.setDescription('Operating protocol for the WAN/user port.')
ifwanSpeed_bps = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(110, 2000000))).setLabel("ifwanSpeed-bps").setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanSpeed_bps.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanSpeed_bps.setDescription('Port speed or PVC CIR and BIR. 1200 to 64000 for DDCMP, BSC and COP. 110 to 115200 for TASYNC and RASYNC. 1200 to 128000 for PASSTRHU. 1200 to 2000000 for PVCs, PSDLC, SSDLC, HDLC, X25, FR-USER, FR-NET, PVCR.')
ifwanFallBackSpeed_bps = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2000000))).setLabel("ifwanFallBackSpeed-bps").setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanFallBackSpeed_bps.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanFallBackSpeed_bps.setDescription('Fallback speed for the transmitter. Fallback is available only if the unit is set for DCE internal clocking. If in DTE, the fallback rate is ignored. Set this parameter to 0 to disable fallback. For all user protocols except ASYNC and PASSTHRU. Applicable to SDM-8200, SDM-8300 and SDM-9530 only. The maximum for DDCMP, BSC and COP is 64000.')
ifwanFallBackSpeedEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 91), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("no", 1), ("yes", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanFallBackSpeedEnable.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanFallBackSpeedEnable.setDescription('Enable the Fallback speed mechanism for the transmitter. Fallback is available only if the unit is set for DCE internal clocking. If in DTE, the fallback rate is ignored. Set this parameter to no to disable the fallback. The actual fallback speed is automatically computed and set by the unit. For all user protocols except ASYNC and PASSTHRU. Applicable to SDM-9300 and SDM-9400 only')
ifwanInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 16, 17, 18, 19, 20, 21, 22, 23, 255, 254, 253))).clone(namedValues=NamedValues(("dce-rs232", 0), ("dte-rs232", 1), ("dce-v35", 2), ("dte-v35", 3), ("dce-x21", 4), ("dte-x21", 5), ("dce-rs530", 6), ("dte-rs530", 7), ("dce-rs366a", 8), ("dte-rs366a", 9), ("dce-rs449", 10), ("dte-rs449", 11), ("dte-aui", 12), ("dte-tpe", 13), ("autom", 16), ("dce-univ", 17), ("dte-univ", 18), ("i430s", 19), ("i430u", 20), ("i431-t1", 21), ("i431-e1", 22), ("dsu-csu", 23), ("dce-undef", 255), ("dte-undef", 254), ("type-undef", 253)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanInterface.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanInterface.setDescription('Interface selection.')
ifwanClocking = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 11, 12, 13, 254, 255))).clone(namedValues=NamedValues(("internal", 1), ("external", 2), ("ipl", 3), ("itb", 4), ("async", 5), ("iso-int", 6), ("iso-ext", 7), ("t1-e1-B-Rcvd", 11), ("t1-e1-A-Rcvd", 12), ("t1-e1-Local", 13), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanClocking.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanClocking.setDescription('Clock source for the port. For ports on the processor/LAN interface board (ports 1 and 2) the clock source is automatically controlled by the unit, and cannot be changed. For all protocols.')
ifwanCoding = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 254, 255))).clone(namedValues=NamedValues(("nrz", 1), ("nrzi", 2), ("nrz-crc0", 3), ("nrzi-crc0", 4), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanCoding.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanCoding.setDescription('For SDLC and HDLC protocols only. Bit coding for CRC purposes. For NORMAL and NRZI coding the computed CRC is preset at 1. For normal coding with CRC0 (CRC0-NML) and NRZI coding with CRC0 (CRC0-NZI) the computed CRC is preset at 0. The values NRZ-CRC0 and NRZI-CRC0 are available for the HDLC protocol only.')
ifwanModem = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 254, 255))).clone(namedValues=NamedValues(("static", 1), ("dynamic", 2), ("statpass", 3), ("dynapass", 4), ("statfix", 5), ("dynafix", 6), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanModem.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanModem.setDescription('Modem control signal operating mode. If the port is DCE this parameter controls the operating mode of the DCD control signal. In STATIC mode the DCD signal is active at all times. In DYNAMIC mode it is active only when a frame is transmitted. If the port is DTE this parameter controls the operating mode of the RTS control signal. In STATIC mode the RTS signal is active at all times. In DYNAMIC mode it is active only when a frame is transmitted.')
ifwanTxStart = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 254, 255))).clone(namedValues=NamedValues(("auto", 0), ("max", 1), ("byte-48", 2), ("byte-96", 3), ("byte-144", 4), ("byte-192", 5), ("byte-256", 6), ("byte-512", 7), ("byte-1024", 8), ("byte-2048", 9), ("byte-8", 10), ("byte-16", 11), ("byte-24", 12), ("byte-32", 13), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanTxStart.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanTxStart.setDescription('For all user protocols except ASYNC, PASSTH and COP. Transmit start level. This is the number of characters that are accumulated before the transmitter is enabled when a frame is incomplete. When set to MAX, the transmitter is enabled only when a complete frame has been accumulated by the unit. This value prevents underruns but can introduce unnecessary delays. When the transmit start level is set to a numeric value, the transmitter is enabled at that level even if a frame coming from the remote unit has not been completely received. If the port is in DCE-INTRN mode and fallback is enabled, the transmitter falls back when the number of characters of an incomplete frame in the output queue goes below the transmit start level. Otherwise, no fallback occurs.')
ifwanTxStartCop = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 89), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 254, 255))).clone(namedValues=NamedValues(("auto", 0), ("max", 1), ("byte-8", 2), ("byte-16", 3), ("byte-24", 4), ("byte-32", 5), ("byte-40", 6), ("byte-48", 7), ("byte-96", 8), ("byte-144", 9), ("byte-192", 10), ("byte-256", 11), ("byte-512", 12), ("byte-1024", 13), ("byte-2048", 14), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanTxStartCop.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanTxStartCop.setDescription('For COP protocol only. Transmit start level. This is the number of characters that are accumulated before the transmitter is enabled when a frame is incomplete. When set to MAX, the transmitter is enabled only when a complete frame has been accumulated by the unit. This value prevents underruns but can introduce unnecessary delays. When the transmit start level is set to a numeric value, the transmitter is enabled at that level even if a frame coming from the remote unit has not been completely received. If the port is in DCE-INTRN mode and fallback is enabled, the transmitter falls back when the number of characters of an incomplete frame in the output queue goes below the transmit start level. Otherwise, no fallback occurs.')
ifwanTxStartPass = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 90), Integer32().subtype(subtypeSpec=ValueRangeConstraint(3, 12))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanTxStartPass.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanTxStartPass.setDescription('For PASSTRHU protocol only. Transmit start level. This is the number of transparent blocks that are accumulated before the transmitter is enabled when a frame is incomplete.')
ifwanIdle = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 254, 255))).clone(namedValues=NamedValues(("space", 1), ("mark", 2), ("flag", 3), ("markd", 4), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanIdle.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanIdle.setDescription('For HDLC, SDLC and COP protocols only. Transmitter idle state, which determines the characters to be sent when no data frame is transmitted. When configured as FLAG, the transmitter continuously sends 7E (flags). When configured as MARK, it continuously sends 1. When configured as MARKD, the MARK IDLE state is postponed 20 msec after the end of a frame. When configured as SPACE, it continuously sends 0.')
ifwanDuplex = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("half", 1), ("full", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanDuplex.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanDuplex.setDescription('Port duplex mode. When set to FULL (DUPLEX), the SDLC driver can transmit INFO frames to a secondary port while polling another secondary port.')
ifwanGroupPoll = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("no", 1), ("yes", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanGroupPoll.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanGroupPoll.setDescription('For P-SDLC and S-SDLC protocols only. Group poll enabled or disabled. When this parameter is set to YES, the group poll feature is enabled, using the address set with the group address parameter, described below. When this parameter is set to NO, the group poll feature is disabled.')
ifwanGroupAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 14), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanGroupAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanGroupAddress.setDescription('For P-SDLC and S-SDLC protocols only. Group address. This parameter is used when the group poll feature is enabled (see ifwanGroupPoll parameter, above).')
ifwanPollDelay_ms = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setLabel("ifwanPollDelay-ms").setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanPollDelay_ms.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanPollDelay_ms.setDescription('The wait time, in milliseconds, before transmitting a poll.')
ifwanFrameDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 254, 255))).clone(namedValues=NamedValues(("delay-0p0-ms", 1), ("delay-0p5-ms", 2), ("delay-1p0-ms", 3), ("delay-1p5-ms", 4), ("delay-2p0-ms", 5), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanFrameDelay.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanFrameDelay.setDescription('For HDLC protocol only. Delay, in milliseconds, added between each frame transmitted on the unit port. This delay is required by some DTE equipment operating at speeds higher than 56 Kbps.')
ifwanFormat = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 254, 255))).clone(namedValues=NamedValues(("fmt-8-none", 1), ("fmt-7-none", 2), ("fmt-7-odd", 3), ("fmt-7-even", 4), ("fmt-7-space", 5), ("fmt-7-mark", 6), ("fmt-7-ignore", 7), ("fmt-8-even", 8), ("fmt-8-odd", 9), ("fmt-8n-2stop", 10), ("fmt-8-bits", 11), ("fmt-6-bits", 12), ("sync", 13), ("async", 14), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanFormat.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanFormat.setDescription('For ASYNC and COP protocols only. Character format. The parameter values are different for the ASYNC and COP protocols. ASYNC Protocols: The parameter defines the number of data bits per character, the parity bit usage, number of stop bits and idle characters. When not specified in the parameter value, the number of stop bits is 1. 8N-2STOP configures the port for 8 bits, no parity and 2 stop bits. Values: 8-NONE, 8-ODD, 8-EVEN, 7-NONE, 7-ODD, 7-EVEN, 7 SPACE, 7-MARK, 7-IGNORE, 8N-2STOP COP Protocol: The parameter defines the number of bits per character only. Values: 8 bits, 6 bits')
ifwanSync = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 18), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanSync.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanSync.setDescription('For COP protocol only. The hexadecimal value of the synchronization character.')
ifwanDropSyncCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanDropSyncCounter.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanDropSyncCounter.setDescription('For COP protocol only. Drop synchronization counter. This parameter defines the number of contiguous desynchronization characters that must be received before the unit drops synchronization and closes the frame.')
ifwanDropSyncCharacter = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 20), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanDropSyncCharacter.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanDropSyncCharacter.setDescription('For COP protocol only. The hexadecimal value of the desynchronization character. This parameter defines the value of the desynchronization character in hexadecimal.')
ifwanMode = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 254, 255))).clone(namedValues=NamedValues(("inactive", 1), ("dedicated", 2), ("answer", 3), ("call-backup", 4), ("call-bod", 5), ("wait-user", 6), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanMode.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanMode.setDescription('For PVCR protocol only. Operating mode of the WAN link. This parameter defines the WAN link as a dedicated link, a backup link or a Bandwidth On Demand link. The ANSWER mode is used for the link that responds to calls. When you install a backup or Bandwidth On Demand (BOD) link between two units, one unit must be configured in call mode (CALL-BACKUP or CALL-BOD) and the other as ANSWER. The INACTIVE mode is used to turn off the link.')
ifwanBodCall_s = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000))).setLabel("ifwanBodCall-s").setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanBodCall_s.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanBodCall_s.setDescription('The call trigger period, in seconds, for the Bandwidth ON Demand function. This defines the period of time during which the combined WAN link usage must be a the BOD level (define with the BOD LEVEL parameter) or higher before another WAN link will be activated. It is, in effect, a means of validating the requirement for a new link')
ifwanBodHang_s = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000))).setLabel("ifwanBodHang-s").setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanBodHang_s.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanBodHang_s.setDescription('The hold time, in seconds, for minimum link activation under the Bandwidth On Demand function. This defines the minimum period of time during which a newly added WAN link will remain activated, even if the usage level drops rapidly. This parameter can prevent unnecessary link activation/deactivation procedures when the traffic flow fluctuates widely.')
ifwanBodLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 95))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanBodLevel.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanBodLevel.setDescription('The call trigger level for the Bandwidth On Demand function. It represents the combined WAN link usage level, given as a percentage of the total bandwidth, at which another link should be activated. This defines a threshold at which another wan link will be added to ease the traffic flow.')
ifwanBackupCall_s = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000))).setLabel("ifwanBackupCall-s").setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanBackupCall_s.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanBackupCall_s.setDescription('Delay, in seconds, before activating the backup link when a line failure has occurred on a dedicated link.')
ifwanDialTimeout_s = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 92), Integer32().subtype(subtypeSpec=ValueRangeConstraint(30, 1000))).setLabel("ifwanDialTimeout-s").setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanDialTimeout_s.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanDialTimeout_s.setDescription('Delay, in seconds, allowed to establish a dial-up backup link.')
ifwanBackupHang_s = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000))).setLabel("ifwanBackupHang-s").setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanBackupHang_s.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanBackupHang_s.setDescription('Delay, in seconds, before deactivating the backup WAN link after the dedicated link has been restored.')
ifwanPortToBack = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(15, 16, 1, 2, 3, 4, 5, 6, 7, 8, 254, 255))).clone(namedValues=NamedValues(("any", 15), ("all", 16), ("port-1", 1), ("port-2", 2), ("port-3", 3), ("port-4", 4), ("port-5", 5), ("port-6", 6), ("port-7", 7), ("port-8", 8), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanPortToBack.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanPortToBack.setDescription('The WAN link that this port backs up. Backup links can be configured to monitor and backup a specific link (1..8) any link that fails (ANY) or all other unit links (ALL). NOTE: The number of available links varies with each product.')
ifwanDialer = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 254, 255))).clone(namedValues=NamedValues(("dTR", 1), ("x21-L1", 2), ("x21-L2", 3), ("v25-H", 4), ("v25-B", 5), ("aT-9600", 6), ("aT-19200", 7), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanDialer.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanDialer.setDescription('Backup link dialer mode')
ifwanRemoteUnit = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 29), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanRemoteUnit.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanRemoteUnit.setDescription('Remote unit to which data from this port should be directed')
ifwanClassNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 30), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanClassNumber.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanClassNumber.setDescription('The priority class for data from this port. Classes are defined according to bandwidth weight.')
ifwanRingNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 31), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanRingNumber.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanRingNumber.setDescription('The ring number of the remote Token-ring LAN, required for source routing of Token-Ring data via the unit.')
ifwanIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 32), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanIpAddress.setDescription('IP address for the local port. This address is a 4-byte value in dotted decimal representation, with a maximum value of 255 for each byte. When set to 000.000.000.000, no IP address is defined for this port. In this case the unit will use the default IP address defined with the global DEFAULT IP ADDR parameter.')
ifwanSubnetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 33), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanSubnetMask.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanSubnetMask.setDescription('Subnet mask associated with the port IP address. It is configured like the IP address: a 4-byte value in dotted decimal representation, with a maximum value of 255 for each byte. The subnet mask identifies which bits of the IP address correspond to the physical network, and which bits correspond to host identifiers.')
ifwanMaxFrame = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 34), Integer32().subtype(subtypeSpec=ValueRangeConstraint(128, 8192))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanMaxFrame.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanMaxFrame.setDescription('Maximum frame size, in octets. This parameter determines the largest datagram that can be sent or received on the interface in one IP frame. Datagrams larger than the maximum frame size are divided into fragments before transmission, the reassembled at the remote end.')
ifwanCompression = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 36), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("no", 1), ("yes", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanCompression.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanCompression.setDescription('Use compression on the WAN link connection to the remote unit. With compression, the available bandwidth is used more efficiently. When compression is not used, higher speeds can be obtained on the link.')
ifwanPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 37), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifwanPriority.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanPriority.setDescription('Priority assigned to the WAN port for the Spanning Tree algorithm.')
ifwanTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 39), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1000, 30000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanTimeout.setDescription('The wait for ACK timeout before retransmitting a frame on the WAN link.')
ifwanRetry = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 40), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanRetry.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanRetry.setDescription('Maximum number of successive retries before the WAN link is declared down.')
ifwanRemotePort = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 41), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanRemotePort.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanRemotePort.setDescription('For all user protocols except SDLC and PVCR. The remote port to which data from the local port is sent. Specify the port number on the remote unit.')
ifwanFlowControl = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 42), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("off", 1), ("on", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanFlowControl.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanFlowControl.setDescription('Congestion flow control notification. If the FLOW CTRL parameter is ON, the unit will set the Forward and Backward Congestion Bits in the header of the active PVC frame when congestion occurs on the unit port. Forward data congestion affects data transmitted from Frame Relay equipment to the unit port. Backward data congestion affects data transmitted from the unit to the Frame Relay equipment. If the FLOW CTRL parameter is OFF, the unit does not set the congestion bits. In this cas, they are reset to zero')
ifwanMgmtInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 43), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 254, 255))).clone(namedValues=NamedValues(("lmi", 1), ("annex-d", 2), ("q-933", 3), ("none", 4), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanMgmtInterface.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanMgmtInterface.setDescription('Frame Relay Management Protocol. The LMI (Local Management Interface) uses the reserved DLCI address 1023. The ANNEX-D and the Q-933 protocols uses the reserved DLCI address 0. Set this parameter according to the Management Interface Protocol used on the network connected to the unit port.')
ifwanEnquiryTimer_s = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 44), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 30))).setLabel("ifwanEnquiryTimer-s").setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanEnquiryTimer_s.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanEnquiryTimer_s.setDescription('Frame Relay Enquiry Timer. The unit polls the network with STATUS ENQUIRY frames when this timer expires.')
ifwanReportCycle = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 45), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 256))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanReportCycle.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanReportCycle.setDescription('Full Status Enquiry Cycle. The value of this parameter determines the number of STATUS ENQUIRY frames that the unit will send before sending a full status enquiry to the network. In response to a full status enquiry the network will send a full status report. This report indicates the currently active PVC on the network. The unit uses this information to determine if a particular PVC is ready to receive data. It is also used in determining the number of restart errors for PVCs in PVCR mode.')
ifwanIpRip = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 46), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 254, 255))).clone(namedValues=NamedValues(("disable", 1), ("v1", 2), ("v2-broadcast", 3), ("v2-multicast", 4), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanIpRip.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanIpRip.setDescription('When this parameter is set to V1, the RIP routing is done according to the RIP V1 standard. With RIP V2, broadcast or multicast can be used. With RIP V2 MULTICAST, only RIP V2 compliant devices will receive RIP frames.')
ifwanCllm = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 47), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("off", 1), ("on", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanCllm.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanCllm.setDescription('Frame Relay CLLM control. The value of this parameter determines the behavior of the unit regarding the Consolidated Link Management Option. When set to OFF, CLLM messages received are discarded and none are generated. When set to ON, CLLM messages are generated on the FR-NET when PVC becomes congested or blocked and frames received are analyzed.')
ifwanIpxRip = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 48), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanIpxRip.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanIpxRip.setDescription('if this parameter is enable, the unit will generate IPX RIP frame on that interface every minute, otherwise the unit will discard all IPX RIP frame received and no one will be generated on that port.')
ifwanIpxSap = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 49), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanIpxSap.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanIpxSap.setDescription('if this parameter is enable, the unit will generate IPX SAP frame on that interface every minute, otherwise the unit will discard all IPX SAP frame received and no one will be generated on that port.')
ifwanIpxNetNum = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 50), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanIpxNetNum.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanIpxNetNum.setDescription('This value identify the IPX network number which the unit is connected to')
ifwanRxFlow = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 52), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 1, 2, 254, 255))).clone(namedValues=NamedValues(("none", 5), ("xon-Xoff", 1), ("hardware", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanRxFlow.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanRxFlow.setDescription('For R-ASYNC protocol only. Flow control on the receiver. This parameter describes the method used by the unit to control the flow of data received from the attached equipment. Flow control is applied when the number of characters on input exceeds a predefined threshold.')
ifwanTxFlow = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 53), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 1, 2, 254, 255))).clone(namedValues=NamedValues(("none", 5), ("xon-Xoff", 1), ("hardware", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanTxFlow.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanTxFlow.setDescription('For R-ASYNC protocol only. Flow control on the transmitter. This parameter describes the method used by the attached equipment to control the flow of data transmitted by the unit.')
ifwanTxHold_s = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 54), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setLabel("ifwanTxHold-s").setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanTxHold_s.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanTxHold_s.setDescription('For R-ASYNC protocol only. Transmitter hold time. This parameter defines the maximum hold time that the transmitter can be blocked due to flow control. There is no hold time limit if TX HOLD is configured as 0 seconds.')
ifwanDsOSpeed_bps = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 55), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("bps-64000", 1), ("bps-56000", 2), ("not-applicable", 254), ("not-available", 255)))).setLabel("ifwanDsOSpeed-bps").setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanDsOSpeed_bps.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanDsOSpeed_bps.setDescription('Speed of a DS0 channel: 64000 bps or 56000 bps.')
ifwanFraming = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 58), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 254, 255))).clone(namedValues=NamedValues(("esf", 2), ("d4", 3), ("other", 4), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanFraming.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanFraming.setDescription('Framing format (ESF or D4). ***** NOTE: This parameter applies only to TIC, not to EIC.')
ifwanTerminating = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 59), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("tE", 1), ("nT", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanTerminating.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanTerminating.setDescription('Terminating (NT indicate Network terminating and TE indicate terminal terminating).')
ifwanCrc4 = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 60), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanCrc4.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanCrc4.setDescription('CRC-4 procedure enable or disable.')
ifwanLineCoding = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 61), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 5, 4, 7, 254, 255))).clone(namedValues=NamedValues(("ami-e1", 0), ("hdb3-e1", 1), ("b8zs-t1", 2), ("ami-t1", 5), ("other", 4), ("b7sz-t1", 7), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanLineCoding.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanLineCoding.setDescription("1's density control or zero suppression over the line.")
ifwanBChannels = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 62), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 254, 255))).clone(namedValues=NamedValues(("disable", 1), ("b1", 2), ("b2", 3), ("b1-plus-b2", 4), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanBChannels.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanBChannels.setDescription('This parameter permits to enable two independent 64 kbits/s channel for use as B-channels.')
ifwanMultiframing = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 63), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanMultiframing.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanMultiframing.setDescription('The Multiframing provides a layer1 signalling capability between the TE and the NT.')
ifwanOspfEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 64), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanOspfEnable.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanOspfEnable.setDescription('Indicates whether or not OSPF is enabled on this interface.')
ifwanOspfAreaId = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 65), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanOspfAreaId.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanOspfAreaId.setDescription('Identifies the area to which this interface belongs.')
ifwanOspfTransitDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 66), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 360))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanOspfTransitDelay.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanOspfTransitDelay.setDescription('The estimated number of seconds it takes to transmit a Link State Update Packet over this interface.')
ifwanOspfRetransmitInt = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 67), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 360))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanOspfRetransmitInt.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanOspfRetransmitInt.setDescription('The number of seconds between like state advertisement retransmissions for adjacencies belonging to this interface. Also used when retransmitting Database Description and Link State Request Packets.')
ifwanOspfHelloInt = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 68), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 360))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanOspfHelloInt.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanOspfHelloInt.setDescription("The length of time, in seconds, between the Hello Packets that the router sends on the interface. This value is advertised in the router's Hello Packets. It must be the same for all routers attached to a common network. The smaller the HelloInterval, the faster topological changes will be detected, but more OSPF routing protocol traffic will ensue.")
ifwanOspfDeadInt = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 69), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanOspfDeadInt.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanOspfDeadInt.setDescription("After ceasing to hear a router's Hello Packets, the number of seconds before its neighbors declare the router down. This is also advertised in the router's Hello Packets in their RouterDeadInterval field. This value again bust be the same for all routers attached to a common network.")
ifwanOspfPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 70), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanOspfPassword.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanOspfPassword.setDescription('This configured data allows the authentication procedure to generate and/or verify the authentication field in the OSPF header. This value again must be the same for all routers attached to a common network.')
ifwanOspfMetricCost = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 71), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65534))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanOspfMetricCost.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanOspfMetricCost.setDescription("The cost of sending a packet on the interface, expressed in the link state metric. This is advertised as the link cost for this interface in the router's router links advertisement.")
ifwanChUse = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 72), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanChUse.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanChUse.setDescription("A 32 byte string describing the use of each DS0 of the span: - '-' or 'i' means off - 'P' means used in passthru mode - 'V' means used as a voice channel - 'R' means reserved ( cannot be set, valid only on EICs) for example: RV--------------R--------------P DS0 timeslot 1 is represent by the left most character. Timeslot 1 and 17 are always reserved when using an E1 span. When using a T1 span all DS0 timeslots are available. This would mean that the DS0 timeslot 1 is used as a reserved channel, the DS0 timeslot 2 is used as a voice channel and the DS0 timeslot 17 is used as a reserved channel and DS0 timeslot 32 is used as a passthru channel ")
ifwanGainLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 77), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("db-30", 1), ("db-36", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanGainLimit.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanGainLimit.setDescription('this object specifies the gain to be applied on received DS1 signal. ***** NOTE: This parameter applies only to TIC, not to EIC.')
ifwanSignaling = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 78), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 254, 255))).clone(namedValues=NamedValues(("none", 1), ("t1-rob-bit", 2), ("e1-cas", 3), ("e1-ccs", 4), ("trsp-orig", 5), ("trsp-answ", 6), ("qsig", 7), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanSignaling.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanSignaling.setDescription('Specifies what type of signalling is in effect on this port. NOTE: 1) none and t1-rob-bit are valid only for a TIC card. 2) e1-cas, trsp-orig, trsp-answ and qsig are valid only for a EIC card. 3) e1-ccs is no longer used.')
ifwanIdleCode = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 79), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanIdleCode.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanIdleCode.setDescription('this object specifies the byte to be transmitted when no real data to transmit')
ifwanLineBuild = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 80), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 254, 255))).clone(namedValues=NamedValues(("ft0-to-133", 0), ("ft133-to-266", 1), ("ft266-to-399", 2), ("ft399-to-533", 3), ("ft533-to-655", 4), ("dbMinus7point5", 5), ("dbMinus15", 6), ("dbMinus22point5", 7), ("ohm-75", 8), ("ohm-120", 9), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanLineBuild.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanLineBuild.setDescription('this object specifies the build out to be applied on transmitted DS1 signal. ***** NOTE: This parameter applies only to TIC, not to EIC.')
ifwanT1E1Status = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 84), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanT1E1Status.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanT1E1Status.setDescription('This parameter sets the activation status of the T1 port, that is, the preferred T1 port state (enabled or disabled).')
ifwanT1E1LoopBack = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 85), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 254, 255))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2), ("lev1-local", 3), ("lev2-local", 4), ("echo", 5), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanT1E1LoopBack.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanT1E1LoopBack.setDescription('This object is used to enable/disable loopback on T1/E1 interfaces. The types of loopback depend on the type of T1/E1 interface used.')
ifwanChExp = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 86), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanChExp.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanChExp.setDescription("A 32 byte string describing the cross connection of every DS0 of this interface: - DS0 timeslot 1 is represent by the left most character. - every byte of the field correspond to a DS0 channel assign to a specific DVC slot number, i.e. DS0 number 8 is represented by the second byte of the string and represent timeslot 2 crossconnect to a DVC in slot 8, and so on up to DS0 number 32. - a digit k ( k in the range '1' to '8') placed at the nth position in the string means that the nth DS0 is crossconnected to the expansion slot number k for example: R8--------------R-------------76 Timeslot 1 and 17 are always reserved when using an E1 span. When using a T1 span all DS0 timeslots are available. This would mean that the DS0 nr 2 is crossconnected to slot 8, DS0 nr 31 is crossconnected to a DVC in slot 7, DS0 nr 32 is crossconnected to a DVC in slot 6. The - or I characters means that there is no cross connection. ")
ifwanT1E1InterBit = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 87), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanT1E1InterBit.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanT1E1InterBit.setDescription('Use this parameter to enable or disable setting of the International Bit (I-bit).')
ifwanEncodingLaw = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 88), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 254, 255))).clone(namedValues=NamedValues(("aLaw", 0), ("muLaw", 1), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanEncodingLaw.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanEncodingLaw.setDescription('The PCM coding law in effect on this interface. Configuration CFG-WPORT-ENCODING-LAW')
ifwanCellPacketization = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 93), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanCellPacketization.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanCellPacketization.setDescription('Indicates whether or not cell packetization is enabled on this interface.')
ifwanMaxChannels = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 94), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanMaxChannels.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanMaxChannels.setDescription('Indicates the maximum number of voice channels permitted on this port.')
ifwanCondLMIPort = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 95), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 254, 255))).clone(namedValues=NamedValues(("none", 0), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanCondLMIPort.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanCondLMIPort.setDescription("Indicates which FR-USER port will be used as a reference port to respond to LMI request. If 'none' is specified, the FR-NET port will always answer to LMI request. If a port is specified, the FR-NET port will answer to LMI request only if the indicated port receives answers to its LMI request.")
ifwanExtNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 96), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanExtNumber.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanExtNumber.setDescription('Port extension number')
ifwanDestExtNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 97), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanDestExtNumber.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanDestExtNumber.setDescription('Destination extension number')
ifwanConnTimeout_s = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 98), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 30))).setLabel("ifwanConnTimeout-s").setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanConnTimeout_s.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanConnTimeout_s.setDescription('This parameter determines the maximum amount of time, in seconds, that the voice port who initiates the call will wait for a call connect confirmed ')
ifwanSvcAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 99), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("e-164", 2), ("x-121", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanSvcAddressType.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanSvcAddressType.setDescription('This parameter determines the SVC address type supported by this frame relay port (NONE, E.164 or X.121) ')
ifwanSvcNetworkAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 100), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanSvcNetworkAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanSvcNetworkAddress.setDescription('Local SVC Network address.')
ifwanSvcMaxTxTimeoutT200 = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 101), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanSvcMaxTxTimeoutT200.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanSvcMaxTxTimeoutT200.setDescription('Maximum Tx Acknowledge timeout (T200).')
ifwanSvcInactiveTimeoutT203 = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 102), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanSvcInactiveTimeoutT203.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanSvcInactiveTimeoutT203.setDescription('Maximum number of seconds without activity (T203).')
ifwanSvcIframeRetransmissionsN200 = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 103), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanSvcIframeRetransmissionsN200.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanSvcIframeRetransmissionsN200.setDescription("Maximum number of I frame retransmission's (N200).")
ifwanSvcSetupTimeoutT303 = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 104), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanSvcSetupTimeoutT303.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanSvcSetupTimeoutT303.setDescription('Response time-out for Q933 setup message (T303).')
ifwanSvcDisconnectTimeoutT305 = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 105), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanSvcDisconnectTimeoutT305.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanSvcDisconnectTimeoutT305.setDescription('Response time-out for Q933 disconnect message (T305).')
ifwanSvcReleaseTimeoutT308 = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 106), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanSvcReleaseTimeoutT308.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanSvcReleaseTimeoutT308.setDescription('Response time-out for Q933 release message (T308).')
ifwanSvcCallProceedingTimeoutT310 = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 107), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanSvcCallProceedingTimeoutT310.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanSvcCallProceedingTimeoutT310.setDescription('Response time-out for Q933 call proceeding message (T310).')
ifwanSvcStatusTimeoutT322 = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 108), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanSvcStatusTimeoutT322.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanSvcStatusTimeoutT322.setDescription('Response time-out for Q933 status enquiry message (T322).')
ifwanTeiMode = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 109), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("dynamic", 1), ("fixed", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanTeiMode.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanTeiMode.setDescription('Object specific to the ISDN BRI Voice card. Indicates the TEI mode used for the interface. When Dynamic is selected, the TEI is negotiated between the NT and the TE devices. Whenever Fixed is selected, the TEI value 0 is used to establish the session.')
ifwanDigitNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 110), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanDigitNumber.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanDigitNumber.setDescription('Object specific to the ISDN BRI Voice card. It contains the number of digits to wait for before the setup request is forwarded on the port. This object is usefull only when the ifwanTerminating is set to NT.')
ifwanMsn1 = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 111), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanMsn1.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanMsn1.setDescription('Object specific to the ISDN BRI Voice card. Contains the First ISDN number on which the port will accept an incoming connection request. This object is usefull only when ifwanTerminating is set to TE.')
ifwanMsn2 = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 112), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanMsn2.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanMsn2.setDescription('Object specific to the ISDN BRI Voice card. Second ISDN number on which the port will accept an incoming connection request. This object is usefull only when ifwanTerminating is set to TE while ifwanTeiMode is set to Dynamic.')
ifwanMsn3 = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 113), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanMsn3.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanMsn3.setDescription('Object specific to the ISDN BRI Voice card. Third ISDN number on which the port will accept an incoming connection request. This object is usefull only when ifwanTerminating is set to TE while ifwanTeiMode is set to Dynamic.')
ifwanX25Encapsulation = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 114), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("annex-f", 1), ("annex-g", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanX25Encapsulation.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanX25Encapsulation.setDescription('Defines the encapsulation method used to transport X25 over frame relay.')
ifwanPvcNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 115), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanPvcNumber.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanPvcNumber.setDescription('PVC this port will use to carry X25 traffic over frame relay.')
ifwanQsigPbxAb = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 116), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("a", 1), ("b", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanQsigPbxAb.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanQsigPbxAb.setDescription('Object specific to the E1 card, when QSIG signaling is used. Specifies the DTE/DCE operation mode of the QSIG port.')
ifwanQsigPbxXy = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 117), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("x", 1), ("y", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanQsigPbxXy.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanQsigPbxXy.setDescription('Object specific to the E1 card, when QSIG signaling is used. Object used as an arbitrator in case of collisions between the E1 card and the connected device (i.e. the local PBX). One side of the connection has to be set to X while the other side of the connection has to be set to Y.')
ifwanIpRipTxRx = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 118), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 254, 255))).clone(namedValues=NamedValues(("duplex", 1), ("tx-only", 2), ("rx-only", 3), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanIpRipTxRx.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanIpRipTxRx.setDescription('This parameter allows RIP frames transmission only, RIP frames reception only or both transmission and reception of RIP frames.')
ifwanIpRipAuthType = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 119), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("none", 1), ("simple", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanIpRipAuthType.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanIpRipAuthType.setDescription('Enable or disable password authentication for the interface. If you select Simple Password, the password will be included in the sent RIP frames. The received frames containing authentication will be accepted only if the password is valid.')
ifwanIpRipPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 120), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanIpRipPassword.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanIpRipPassword.setDescription('This configured data allows the authentication procedure to generate and/or verify the authentication field in the RIP header. This value again must be the same for each interface on each side of the link.')
ifwanPppSilent = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 121), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("send-request", 1), ("wait-for-request", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanPppSilent.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanPppSilent.setDescription('This parameter defines how this port participates in the configuration negotiation process. When a PPP port is Silent, it waits for a Configure-Request packet from the remote peer. Use WAIT FOR REQUEST to configure the port in this way. The port must receive a request before it can negotiate a connection. When a port is not Silent, it is actively trying to initialize the connection with the remote peer. Use the SEND REQUEST setting. The port will send Configure-Request packets in a timeout/retry sequence until the remote peer replies, at which point the two peers can negotiate the connection.')
ifwanPppConfigRestartTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 122), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanPppConfigRestartTimer.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanPppConfigRestartTimer.setDescription('This parameter defines the duration, in seconds, of the Restart timer, which is started when a Configure-Request or Terminate-Request packet is transmitted. If the timer expires a timeout occurs, followed by retransmission of the packet. Configure the Configuration Restart Timer parameter based on the speed of the link. The default value, 3 seconds, is designed for low-speed lines (from 2400 to 9600 bps) and links having a high switching latency, such as telephone lines. For higher speed links or links with low switching latency the retransmission time is reduced, so the Retry Period should be reduced also. For example, round trip transmission times for modems at 14,400 bps are in the range of 160 to 600 milliseconds. A value of 1 second for the Configuration Restart Timer would be appropriate.')
ifwanPppConfigRetries = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 123), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanPppConfigRetries.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanPppConfigRetries.setDescription('This parameter is a restart counter for Configure-Requests. It defines the maximum number of successive retry periods that can elapse when the port attempts to send a Configure-Request packet to the remote peer. The port counts the number of retry periods that elapse before receiving a Configure-Ack, Configure-Nak or Configure-Reject from the peer, until it assumes that the peer is unable to respond. The values 0 to 254 set a finite number of retry periods. Use the value 255 to allow the port to send a Configure-Request packet an unlimited number of times.')
ifwanPppNegociateLocalMru = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 124), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("no", 1), ("yes", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanPppNegociateLocalMru.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanPppNegociateLocalMru.setDescription('This parameter enables the negotiation of another MRU than the default MRU value (1500 bytes). The MRU is used when sending parameter values between peers to negotiate the connection. In particular, it specifies the maximum number of bytes in the Information and Padding fields of the PPP encapsulation frame. If you set this parameter to YES, you must also configure the Negotiated Local MRU parameter.')
ifwanPppLocalMru = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 125), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanPppLocalMru.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanPppLocalMru.setDescription('This parameter determines the size of the MRU that the local port offers (if greater than the default value) or requests (if less than the default value) for use by the peer. The MRU specifies the maximum number of bytes allowed in the Information and Padding fields of the PPP encapsulation frame.')
ifwanPppNegociatePeerMru = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 126), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("no", 1), ("yes", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanPppNegociatePeerMru.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanPppNegociatePeerMru.setDescription("This parameter determines whether the port will consider either an offer for a larger MRU value or a request for a smaller one. Set this parameter to YES to allow the port to consider an MRU offer or request from the peer. Set it to NO (the default value) to reject it. If you set this parameter to YES, you must also configure the Peer's MRU parameter.")
ifwanPppPeerMruUpTo = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 127), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanPppPeerMruUpTo.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanPppPeerMruUpTo.setDescription('This parameter determines up to what limit above the default MRU value the local port will set its MRU in response to an offer or request from the peer.')
ifwanPppNegociateAccm = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 128), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("no", 1), ("yes", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanPppNegociateAccm.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanPppNegociateAccm.setDescription('This parameter determines whether the port will inform the remote peer that it can enter into Asynchronous Control Character Map (ACCM) negotiation. This option provides a way to negotiate the use of control character mapping on asynchronous links. By default, PPP maps all control characters into an appropriate two-character sequence. This is usually not necessary. The NetPerformer uses the ACCM negotiation option to inform the remote end which control characters must remain mapped, and which ones do not need to remain mapped when the remote end sends them. Set this parameter to YES to permit ACCM negotiation. Set it to NO (the default value) to disallow this negotiation process. If you set this parameter to YES, you must also configure the Requested ACCM Characters parameter.')
ifwanPppRequestedAccmChar = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 129), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanPppRequestedAccmChar.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanPppRequestedAccmChar.setDescription('This parameter determines the exact characters of the Asynchronous Control Character Map that are requested from the remote peer. The Async-Control-Character-Map field is 4 bytes long. It encoded such that each numbered bit corresponds to the ASCII control character of the same value. If a bit is cleared to zero, then the corresponding ASCII control character must remain mapped. For example, if bit 19 is set to zero, then ASCII control character 19 (CTRL-S) will not be changed during transmission.')
ifwanPppAcceptAccmPeer = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 130), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("no", 1), ("yes", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanPppAcceptAccmPeer.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanPppAcceptAccmPeer.setDescription("This parameter determines whether the port will accept a request from the remote peer to enter into Asynchronous Control Character Map (ACCM) negotiation. Set this parameter to YES to accept the peer's request. Set it to NO (the default value) to reject the request for ACCM negotiation. If you set this parameter to YES, you must also configure the Acceptable ACCM Characters parameter.")
ifwanPppAcceptableAccmChar = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 131), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanPppAcceptableAccmChar.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanPppAcceptableAccmChar.setDescription('This parameter determines the exact characters of the Asynchronous Control Character Map that will be sent to the remote peer. The Async-Control-Character-Map field is 4 bytes, encoded such that each numbered bit corresponds to the ASCII control character of the same value. If a bit is cleared to zero, then the corresponding ASCII control character must remain mapped. For example, if bit 19 is set to zero, then ASCII control character 19 (CTRL-S) may be sent without change.')
ifwanPppRequestMagicNum = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 132), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("no", 1), ("yes", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanPppRequestMagicNum.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanPppRequestMagicNum.setDescription("This parameter determines whether the port will request the Magic Number from the remote peer. The Magic Number is a 4-byte field that aids in the detection of link loopback conditions and other data link layer anomalies. Set this parameter to YES (the default value) to request the peer's Magic Number. Set it to NO to disallow a Magic Number request.")
ifwanPppAcceptMagicNum = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 133), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("no", 1), ("yes", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanPppAcceptMagicNum.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanPppAcceptMagicNum.setDescription("This parameter determines whether the port will accept a request from the remote peer to send the local Magic Number. Set this parameter to YES (the default value) to accept the peer's Magic Number request. Set it to NO to reject the request.")
ifwanPppAcceptOldIpAddNeg = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 134), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("no", 1), ("yes", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanPppAcceptOldIpAddNeg.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanPppAcceptOldIpAddNeg.setDescription("This parameter determines whether the port will accept a request from the remote peer to negotiate old IP-Addresses. Set this parameter to YES to accept the peer's IP-Addresses Negotiation request. The port will enter into an obsolete IP address negotiation with the peer. Set it to NO (the default value) to reject this configuration option.")
ifwanPppNegociateIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 135), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("no", 1), ("yes", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanPppNegociateIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanPppNegociateIpAddress.setDescription('This parameter enables the negotiation of an IP Address with the remote peer. Set this parameter to YES (the default value) to allow the port to request and accept an IP Address. Set it to NO to disallow IP address negotiation.')
ifwanPppAcceptIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 136), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("no", 1), ("yes", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanPppAcceptIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanPppAcceptIpAddress.setDescription("This parameter determines whether the port will accept a request from the remote peer to send an IP Address. Set this parameter to YES ( the default value) to accept the peer's request for the local IP Address. Set it to NO to reject the request.")
ifwanPppRemoteIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 137), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanPppRemoteIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanPppRemoteIpAddress.setDescription('This parameter defines the IP-Address to be sent to the remote peer during negotiation of the connection. The IP-Address is specific to a particular PPP session. It is a 4-byte value in dotted decimal representation, with a maximum value of 255 for each byte, for example 128.128.128.122. When this parameter is set to 000.000.000.000, no IP-Address is defined.')
ifwanPppRemoteSubnetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 138), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanPppRemoteSubnetMask.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanPppRemoteSubnetMask.setDescription('Subnet mask associated with the Remote IP address. It is configured like the IP address: a 4-byte value in dotted decimal representation, with a maximum value of 255 for each byte. The subnet mask identifies which bits of the IP address correspond to the physical network, and which bits correspond to host identifiers.')
ifwanHighPriorityTransparentClass = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 139), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("no", 1), ("yes", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanHighPriorityTransparentClass.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanHighPriorityTransparentClass.setDescription('High priority transparent class.')
ifwanTransparentClassNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 140), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanTransparentClassNumber.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanTransparentClassNumber.setDescription('The transparent priority class for voice. Classes are defined according to bandwidth weight.')
ifwanChannelCompressed = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 141), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("no", 1), ("yes", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanChannelCompressed.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanChannelCompressed.setDescription('Channel compressed.')
ifwanSfType = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 142), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 254, 255))).clone(namedValues=NamedValues(("demodulator", 1), ("modulator", 2), ("expansion", 3), ("agregate", 4), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanSfType.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanSfType.setDescription('Specify the type of Skyframe port configured. It can be a Modulator, Demodulator, Expansion or Aggregate.')
ifwanSfMode = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 143), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("inactive", 1), ("active", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanSfMode.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanSfMode.setDescription('Enable/disable the data transmission/reception on the port.')
ifwanSfCarrierId = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 2, 2, 1, 144), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifwanSfCarrierId.setStatus('mandatory')
if mibBuilder.loadTexts: ifwanSfCarrierId.setDescription('Identifier of a physical port in a Skyframe system.')
ifvceNumber = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 18, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifvceNumber.setStatus('mandatory')
if mibBuilder.loadTexts: ifvceNumber.setDescription('The number of voice interfaces present on this system.')
ifvceTable = MibTable((1, 3, 6, 1, 4, 1, 727, 7, 2, 18, 2), )
if mibBuilder.loadTexts: ifvceTable.setStatus('mandatory')
if mibBuilder.loadTexts: ifvceTable.setDescription('A list of interface entries. The number of entries is given by the value of ifvceNumber.')
ifvceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 727, 7, 2, 18, 2, 1), ).setIndexNames((0, "PRESTICOM7-MIB", "ifvceIndex"))
if mibBuilder.loadTexts: ifvceEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ifvceEntry.setDescription('This table contains the principal configurable parameters which are used for a particular voice interface.')
ifvceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 18, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifvceIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ifvceIndex.setDescription('A unique value for each voice interface.')
ifvceDesc = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 18, 2, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifvceDesc.setStatus('mandatory')
if mibBuilder.loadTexts: ifvceDesc.setDescription('A textual string containing information about a specific interface.')
ifvceProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 18, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 21, 22, 23, 24, 26, 30, 254, 255))).clone(namedValues=NamedValues(("off", 1), ("acelp-8-kbs", 21), ("acelp-4-8-kbs", 22), ("pcm64k", 23), ("adpcm32k", 24), ("atc16k", 26), ("acelp-cn", 30), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifvceProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: ifvceProtocol.setDescription('Operating protocol for the NetVoice port. Enter ACELP 8 kbs, ACELP 4.8 kbs when you want to use the port for voice/fax transmissions. Select the OFF value when the port is not used.')
ifvceInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 18, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 254, 255))).clone(namedValues=NamedValues(("fxs", 1), ("fx0", 2), ("e-and-m", 3), ("ac15", 4), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifvceInterface.setStatus('mandatory')
if mibBuilder.loadTexts: ifvceInterface.setDescription('fxs: Used when connecting to a POTS line or fx0 unit. e-and-m: Used when connecting to the trunk side of a PBX. fx0: Used when connecting to a CO or the station side of a PBX.')
ifvceRemotePort = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 18, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 899))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifvceRemotePort.setStatus('mandatory')
if mibBuilder.loadTexts: ifvceRemotePort.setDescription('Specifies the port number on the remote unit for setting up predefined line activation. Select the number of the port connected to the device you want to reach.')
ifvceActivationType = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 18, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 254, 255))).clone(namedValues=NamedValues(("predefined", 1), ("switched", 2), ("autodial", 3), ("broadcast", 4), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifvceActivationType.setStatus('mandatory')
if mibBuilder.loadTexts: ifvceActivationType.setDescription('For each NetPerformer voice port, voice/fax line activation can be configured according to one of the following activation types.')
ifvceRemoteUnit = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 18, 2, 1, 7), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifvceRemoteUnit.setStatus('mandatory')
if mibBuilder.loadTexts: ifvceRemoteUnit.setDescription('Specifies the unit name of the NetVoice card at the remote site, for setting up predefined line activation.')
ifvceHuntGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 18, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 254, 255))).clone(namedValues=NamedValues(("no", 1), ("a", 2), ("b", 3), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifvceHuntGroup.setStatus('mandatory')
if mibBuilder.loadTexts: ifvceHuntGroup.setDescription('When line activation is defined as switched, this parameter permits hunting more than one port to place an incoming call.')
ifvceToneDetectRegen_s = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 18, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 256))).setLabel("ifvceToneDetectRegen-s").setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifvceToneDetectRegen_s.setStatus('mandatory')
if mibBuilder.loadTexts: ifvceToneDetectRegen_s.setDescription('This parameter specifies the number of seconds during which Tone tones will be detected and regenerated.')
ifvcePulseMakeBreak_ms = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 18, 2, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(20, 80))).setLabel("ifvcePulseMakeBreak-ms").setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifvcePulseMakeBreak_ms.setStatus('mandatory')
if mibBuilder.loadTexts: ifvcePulseMakeBreak_ms.setDescription('This parameter specifies the duration, in milliseconds, of the contact(or make) for each digit that is dialed using rotary type dialing.')
ifvceToneOn_ms = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 18, 2, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(30, 1000))).setLabel("ifvceToneOn-ms").setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifvceToneOn_ms.setStatus('mandatory')
if mibBuilder.loadTexts: ifvceToneOn_ms.setDescription('This parameter specifies the duration, in milliseconds, of the tone used to produce a single Tone digit.')
ifvceToneOff_ms = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 18, 2, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(30, 1000))).setLabel("ifvceToneOff-ms").setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifvceToneOff_ms.setStatus('mandatory')
if mibBuilder.loadTexts: ifvceToneOff_ms.setDescription('This parameter specifies the duration, in milliseconds, of the silence between Tone tones in a dial digit string.')
ifvceSilenceSuppress = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 18, 2, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(4, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifvceSilenceSuppress.setStatus('mandatory')
if mibBuilder.loadTexts: ifvceSilenceSuppress.setDescription('This parameter specifies the degree to which periods of silence will be suppressed and reduced during transmission. A higher Silence Suppression level increases the attenuation of the line, lowers background noise and reduces overall bandwidth use. ONLY FOR ACT/NETWORKS CARDS OTHER THAN DVC')
ifvceDVCSilenceSuppress = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 18, 2, 1, 33), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifvceDVCSilenceSuppress.setStatus('mandatory')
if mibBuilder.loadTexts: ifvceDVCSilenceSuppress.setDescription('This parameter specifies the degree to which periods of silence will be suppressed and reduced during transmission. A higher Silence Suppression level increases the attenuation of the line, lowers background noise and reduces overall bandwidth use. ONLY FOR ACT/NETWORKS DVC CARDS')
ifvceSignaling = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 18, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 6, 10, 11, 12, 13, 14, 15, 17, 18, 21, 22, 23, 24, 25, 26, 27, 28, 32, 30, 254, 255))).clone(namedValues=NamedValues(("e-and-m-4w-imm-start", 1), ("e-and-m-2W-imm-start", 2), ("loop-start", 3), ("ac15-a", 4), ("ac15-c", 6), ("e-and-m-4w-timed-e", 10), ("e-and-m-2W-timed-e", 11), ("e-and-m-4W-wink-start", 12), ("e-and-m-2W-wink-start", 13), ("e-and-m-4W-delay-dial", 14), ("e-and-m-2W-delay-dial", 15), ("e-and-m-4W-colisee", 17), ("e-and-m-2W-colisee", 18), ("imm-start", 21), ("r2", 22), ("fxo", 23), ("fxs", 24), ("gnd-fxo", 25), ("gnd-fxs", 26), ("plar", 27), ("poi", 28), ("wink-start", 32), ("ab00", 30), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifvceSignaling.setStatus('mandatory')
if mibBuilder.loadTexts: ifvceSignaling.setDescription('The signaling protocol of this port.')
ifvceLocalInbound = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 18, 2, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 254, 255))).clone(namedValues=NamedValues(("db-22", 1), ("db-21", 2), ("db-20", 3), ("db-19", 4), ("db-18", 5), ("db-17", 6), ("db-16", 7), ("db-15", 8), ("db-14", 9), ("db-13", 10), ("db-12", 11), ("db-11", 12), ("db-10", 13), ("db-9", 14), ("db-8", 15), ("db-7", 16), ("db-6", 17), ("db-5", 18), ("db-4", 19), ("db-3", 20), ("db-2", 21), ("db-1", 22), ("db0", 23), ("db1", 24), ("db2", 25), ("db3", 26), ("db4", 27), ("db5", 28), ("db6", 29), ("db7", 30), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifvceLocalInbound.setStatus('mandatory')
if mibBuilder.loadTexts: ifvceLocalInbound.setDescription('This parameter specifies the local voice level into the port, measured in 1 db increments. ONLY FOR ACT/NETWORKS CARDS OTHER THAN DVC')
ifvceLocalOutbound = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 18, 2, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 254, 255))).clone(namedValues=NamedValues(("db-22", 1), ("db-21", 2), ("db-20", 3), ("db-19", 4), ("db-18", 5), ("db-17", 6), ("db-16", 7), ("db-15", 8), ("db-14", 9), ("db-13", 10), ("db-12", 11), ("db-11", 12), ("db-10", 13), ("db-9", 14), ("db-8", 15), ("db-7", 16), ("db-6", 17), ("db-5", 18), ("db-4", 19), ("db-3", 20), ("db-2", 21), ("db-1", 22), ("db0", 23), ("db1", 24), ("db2", 25), ("db3", 26), ("db4", 27), ("db5", 28), ("db6", 29), ("db7", 30), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifvceLocalOutbound.setStatus('mandatory')
if mibBuilder.loadTexts: ifvceLocalOutbound.setDescription('This parameter specifies the local voice level out of the port, measured in 1 db increments. ONLY FOR ACT/NETWORKS CARDS OTHER THAN DVC')
ifvceDVCLocalInbound = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 18, 2, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 254, 255))).clone(namedValues=NamedValues(("db-12", 9), ("db-11", 10), ("db-10", 11), ("db-9", 12), ("db-8", 13), ("db-7", 14), ("db-6", 15), ("db-5", 16), ("db-4", 17), ("db-3", 18), ("db-2", 19), ("db-1", 20), ("db0", 21), ("db1", 22), ("db2", 23), ("db3", 24), ("db4", 25), ("db5", 26), ("db6", 27), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifvceDVCLocalInbound.setStatus('mandatory')
if mibBuilder.loadTexts: ifvceDVCLocalInbound.setDescription('This parameter specifies the local voice level into the port, measured in 1 db increments. ONLY FOR ACT/NETWORKS DVC CARDS')
ifvceDVCLocalOutbound = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 18, 2, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 254, 255))).clone(namedValues=NamedValues(("db-12", 9), ("db-11", 10), ("db-10", 11), ("db-9", 12), ("db-8", 13), ("db-7", 14), ("db-6", 15), ("db-5", 16), ("db-4", 17), ("db-3", 18), ("db-2", 19), ("db-1", 20), ("db0", 21), ("db1", 22), ("db2", 23), ("db3", 24), ("db4", 25), ("db5", 26), ("db6", 27), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifvceDVCLocalOutbound.setStatus('mandatory')
if mibBuilder.loadTexts: ifvceDVCLocalOutbound.setDescription('This parameter specifies the local voice level out of the port, measured in 1 db increments. ONLY FOR ACT/NETWORKS DVC CARDS')
ifvceFaxModemRelay = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 18, 2, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 254, 255))).clone(namedValues=NamedValues(("none", 1), ("fax", 2), ("both", 3), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifvceFaxModemRelay.setStatus('mandatory')
if mibBuilder.loadTexts: ifvceFaxModemRelay.setDescription("This parameter enables or disables handling of fax or modem calls on this unit's voice channel.")
ifvceMaxFaxModemRate = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 18, 2, 1, 44), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 254, 255))).clone(namedValues=NamedValues(("rate-14400", 1), ("rate-12000", 2), ("rate-9600", 3), ("rate-7200", 4), ("rate-4800", 5), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifvceMaxFaxModemRate.setStatus('mandatory')
if mibBuilder.loadTexts: ifvceMaxFaxModemRate.setDescription("This parameter enables or disables handling of fax or modem calls on this unit's voice channel.")
ifvceFxoTimeout_s = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 18, 2, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 99))).setLabel("ifvceFxoTimeout-s").setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifvceFxoTimeout_s.setStatus('mandatory')
if mibBuilder.loadTexts: ifvceFxoTimeout_s.setDescription('This parameter determines the maximum amount of time, in seconds, that the local port will wait for a fax transmission to begin.')
ifvceTeTimer_s = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 18, 2, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setLabel("ifvceTeTimer-s").setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifvceTeTimer_s.setStatus('mandatory')
if mibBuilder.loadTexts: ifvceTeTimer_s.setDescription('This parameter determines the delay, in seconds, between M-lead and E-lead activation when the starting method is timed e-and-m.')
ifvceFwdDigits = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 18, 2, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 254, 255))).clone(namedValues=NamedValues(("none", 1), ("all", 2), ("ext", 3), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifvceFwdDigits.setStatus('mandatory')
if mibBuilder.loadTexts: ifvceFwdDigits.setDescription('This parameter specifies which dial digits (if any) should be forwarded to the remote unit. When set to 0, no dial digits are forwarded to the destination device when a call is initiated on this channel. When set to a non-zero value, the specified number of dial digits are forwarded.')
ifvceFwdType = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 18, 2, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("tone", 1), ("pulse", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifvceFwdType.setStatus('mandatory')
if mibBuilder.loadTexts: ifvceFwdType.setDescription('This parameter specifies how the dial digits are sent to the remote unit for forwarding to the attached device such as a PBX. It can do it using pulse dial or Tone.')
ifvceFwdDelay_ms = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 18, 2, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10000))).setLabel("ifvceFwdDelay-ms").setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifvceFwdDelay_ms.setStatus('mandatory')
if mibBuilder.loadTexts: ifvceFwdDelay_ms.setDescription('This parameter specifies the length, in milliseconds, of a pause that precedes the forwarded dial digit string. The value entered with a SET is rounded down to the nearest multiple of 250 ms')
ifvceDelDigits = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 18, 2, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifvceDelDigits.setStatus('mandatory')
if mibBuilder.loadTexts: ifvceDelDigits.setDescription('This parameter specifies the number of leading dial digits (if any) that will be deleted from a dial string before it is forwarded to the attached voice equipment. When set to 0, no dial digits are deleted.')
ifvceExtNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 18, 2, 1, 25), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifvceExtNumber.setStatus('mandatory')
if mibBuilder.loadTexts: ifvceExtNumber.setDescription('This parameter specifies the extension number for the end device attached to this voice port.')
ifvceLinkDwnBusy = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 18, 2, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 254, 255))).clone(namedValues=NamedValues(("no", 1), ("yes", 2), ("broadcast", 3), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifvceLinkDwnBusy.setStatus('mandatory')
if mibBuilder.loadTexts: ifvceLinkDwnBusy.setDescription('Used by SDM-9400 VFC03, the SDM-9400 VFC03R cards and by the SDM-9300 voice ports for versions 7.1.0 and higher. Used only for DVC cards for versions 7.0.3 and lower. See also ifvceAnalogLinkDwnBusy for versions 7.0.3 and lower.')
ifvceToneType = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 18, 2, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 254, 255))).clone(namedValues=NamedValues(("dtmf", 0), ("mf", 1), ("r2", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifvceToneType.setStatus('mandatory')
if mibBuilder.loadTexts: ifvceToneType.setDescription('This parameter specifies the kind of multi-frequency tone that will be detected on this port.')
ifvceRate8kx1 = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 18, 2, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("no", 1), ("yes", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifvceRate8kx1.setStatus('mandatory')
if mibBuilder.loadTexts: ifvceRate8kx1.setDescription('This parameter enables fallback to 8 Kbps with single buffering.')
ifvceRate8kx2 = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 18, 2, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("no", 1), ("yes", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifvceRate8kx2.setStatus('mandatory')
if mibBuilder.loadTexts: ifvceRate8kx2.setDescription('This parameter enables fallback to 8 Kbps with double buffering.')
ifvceRate5k8x1 = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 18, 2, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("no", 1), ("yes", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifvceRate5k8x1.setStatus('mandatory')
if mibBuilder.loadTexts: ifvceRate5k8x1.setDescription('This parameter enables fallback to 5.8 Kbps with single buffering.')
ifvceRate5k8x2 = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 18, 2, 1, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("no", 1), ("yes", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifvceRate5k8x2.setStatus('mandatory')
if mibBuilder.loadTexts: ifvceRate5k8x2.setDescription('This parameter enables fallback to 5.8 Kbps with double buffering.')
ifvceBroadcastDir = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 18, 2, 1, 36), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("tX", 1), ("rX", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifvceBroadcastDir.setStatus('mandatory')
if mibBuilder.loadTexts: ifvceBroadcastDir.setDescription('When line activation is broadcast (Activation Type parameter set to BROADCAST), this parameter is used to specify whether the voice port will transmit(TX) or receive (RX) broadcast messages.')
ifvceBroadcastPvc = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 18, 2, 1, 37), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 300))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifvceBroadcastPvc.setStatus('mandatory')
if mibBuilder.loadTexts: ifvceBroadcastPvc.setDescription('This parameter specifies which PVC will be used for transmitting (on the root) or receiving (on leaves) the broadcast frames.')
ifvceAnalogLinkDwnBusy = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 18, 2, 1, 38), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 254, 255))).clone(namedValues=NamedValues(("no", 1), ("yes", 2), ("broadcast", 3), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifvceAnalogLinkDwnBusy.setStatus('mandatory')
if mibBuilder.loadTexts: ifvceAnalogLinkDwnBusy.setDescription('Used by SDM-9400 VFC03, the SDM-9400 VFC03R cards and by the SDM-9300 voice ports for versions 7.0.3 and lower. See ifvceLinkDwnBusy for version 7.1.0 and higher and for DVC cards.')
ifvceSpeedDialNum = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 18, 2, 1, 39), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifvceSpeedDialNum.setStatus('mandatory')
if mibBuilder.loadTexts: ifvceSpeedDialNum.setDescription('Specifies the Speed Dial Number to be dialed when a off-hook occurs on a port configured with Autodial activation type.')
ifvceR2ExtendedDigitSrc = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 18, 2, 1, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("map", 1), ("user", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifvceR2ExtendedDigitSrc.setStatus('mandatory')
if mibBuilder.loadTexts: ifvceR2ExtendedDigitSrc.setDescription('No longer supported by the NP Agent 7.1.0 and higher')
ifvceR2Group2Digit = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 18, 2, 1, 41), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifvceR2Group2Digit.setStatus('mandatory')
if mibBuilder.loadTexts: ifvceR2Group2Digit.setDescription('This parameter defines a Group 2 Digit that is output when dialing out.')
ifvceR2CompleteDigit = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 18, 2, 1, 42), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifvceR2CompleteDigit.setStatus('mandatory')
if mibBuilder.loadTexts: ifvceR2CompleteDigit.setDescription('This parameter defines the digit that is output when dialing is complete.')
ifvceR2BusyDigit = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 18, 2, 1, 43), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifvceR2BusyDigit.setStatus('mandatory')
if mibBuilder.loadTexts: ifvceR2BusyDigit.setDescription('This parameter defines the digit that is output to indicate that the destination is busy.')
ifvceRate8kx3 = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 18, 2, 1, 45), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("no", 1), ("yes", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifvceRate8kx3.setStatus('mandatory')
if mibBuilder.loadTexts: ifvceRate8kx3.setDescription('This parameter enables fallback to 8 Kbps with triple buffering.')
ifvceRate6kx1 = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 18, 2, 1, 46), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("no", 1), ("yes", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifvceRate6kx1.setStatus('mandatory')
if mibBuilder.loadTexts: ifvceRate6kx1.setDescription('This parameter enables fallback to 6 Kbps with single buffering.')
ifvceRate6kx2 = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 18, 2, 1, 47), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("no", 1), ("yes", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifvceRate6kx2.setStatus('mandatory')
if mibBuilder.loadTexts: ifvceRate6kx2.setDescription('This parameter enables fallback to 6 Kbps with double buffering.')
ifvceRate6kx3 = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 18, 2, 1, 48), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("no", 1), ("yes", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifvceRate6kx3.setStatus('mandatory')
if mibBuilder.loadTexts: ifvceRate6kx3.setDescription('This parameter enables fallback to 6 Kbps with triple buffering.')
ifvceRate4k8x1 = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 18, 2, 1, 49), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("no", 1), ("yes", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifvceRate4k8x1.setStatus('mandatory')
if mibBuilder.loadTexts: ifvceRate4k8x1.setDescription('This parameter enables fallback to 4.8 Kbps with single buffering.')
ifvceRate4k8x2 = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 18, 2, 1, 50), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("no", 1), ("yes", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifvceRate4k8x2.setStatus('mandatory')
if mibBuilder.loadTexts: ifvceRate4k8x2.setDescription('This parameter enables fallback to 4.8 Kbps with double buffering.')
ifvceDTalkThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 18, 2, 1, 51), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 1, 2, 3, 4, 5, 6, 7, 26, 254, 255))).clone(namedValues=NamedValues(("db-12", 8), ("db-11", 9), ("db-10", 10), ("db-9", 11), ("db-8", 12), ("db-7", 13), ("db-6", 14), ("db-5", 15), ("db-4", 16), ("db-3", 17), ("db-2", 18), ("db-1", 19), ("db0", 20), ("db1", 21), ("db2", 22), ("db3", 23), ("db4", 24), ("db5", 25), ("db6", 1), ("db7", 2), ("db8", 3), ("db9", 4), ("db10", 5), ("db11", 6), ("db12", 7), ("disabled", 26), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifvceDTalkThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: ifvceDTalkThreshold.setDescription('This parameter specifies the echo cancellation threshold, measured in 1 db increments.')
ifvceToneEnergyDetec = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 18, 2, 1, 52), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("yes", 1), ("no", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifvceToneEnergyDetec.setStatus('mandatory')
if mibBuilder.loadTexts: ifvceToneEnergyDetec.setDescription('This parameter controls whether DTMF detection will include the detection of energy as well as tones. In some cases, DTMF detection will work only if the energy is not detected.')
ifvceExtendedDigitSrc = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 18, 2, 1, 53), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("map", 1), ("user", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifvceExtendedDigitSrc.setStatus('mandatory')
if mibBuilder.loadTexts: ifvceExtendedDigitSrc.setDescription('Specifies the origin of the extended digits that will be forwarded to the remote unit. Available on a port configured with Autodial activation type.')
ifvceDtmfOnTime = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 18, 2, 1, 54), Integer32().subtype(subtypeSpec=ValueRangeConstraint(20, 50))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifvceDtmfOnTime.setStatus('mandatory')
if mibBuilder.loadTexts: ifvceDtmfOnTime.setDescription('This parameter specifies the DTMF ON duration, in milliseconds, for filtering unwanted DTMF tones during call progress.')
ifvceEnableDtmfOnTime = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 18, 2, 1, 55), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("no", 1), ("yes", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifvceEnableDtmfOnTime.setStatus('mandatory')
if mibBuilder.loadTexts: ifvceEnableDtmfOnTime.setDescription('This parameter specifies whether the duration of DTMF ON can be used to filter unwanted DTMF tones during call progress. If DTMF ON-TIME configuration is enabled, the next parameter is also listed.')
iflanNumber = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 3, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: iflanNumber.setStatus('mandatory')
if mibBuilder.loadTexts: iflanNumber.setDescription('The number of network interfaces present on this system.')
iflanTable = MibTable((1, 3, 6, 1, 4, 1, 727, 7, 2, 3, 2), )
if mibBuilder.loadTexts: iflanTable.setStatus('mandatory')
if mibBuilder.loadTexts: iflanTable.setDescription('A list of interface entries. The number of entries is given by the value of iflanNumber.')
iflanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 727, 7, 2, 3, 2, 1), ).setIndexNames((0, "PRESTICOM7-MIB", "iflanIndex"))
if mibBuilder.loadTexts: iflanEntry.setStatus('mandatory')
if mibBuilder.loadTexts: iflanEntry.setDescription('This table contains the principal configurable parameters which are used for a particular lan interface.')
iflanIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 3, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: iflanIndex.setStatus('mandatory')
if mibBuilder.loadTexts: iflanIndex.setDescription('A unique value for each interface.')
iflanDesc = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 3, 2, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: iflanDesc.setStatus('mandatory')
if mibBuilder.loadTexts: iflanDesc.setDescription('A textual string containing information about a specific interface.')
iflanProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 3, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 13, 14, 15, 16, 254, 255))).clone(namedValues=NamedValues(("off", 1), ("token-ring", 13), ("ethernet-auto", 14), ("ethernet-802p3", 15), ("ethernet-v2", 16), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: iflanProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: iflanProtocol.setDescription('Operating protocol for the LAN port.')
iflanSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 3, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 254, 255))).clone(namedValues=NamedValues(("tr-4-Mbps", 1), ("tr-16-Mbps", 2), ("eth-10-Mbps", 3), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: iflanSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: iflanSpeed.setDescription('The port speed.')
iflanPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 3, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: iflanPriority.setStatus('mandatory')
if mibBuilder.loadTexts: iflanPriority.setDescription('Priority assigned to the LAN port on the unit for the Spanning Tree algorithm.')
iflanCost = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 3, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: iflanCost.setStatus('mandatory')
if mibBuilder.loadTexts: iflanCost.setDescription('The path cost assigned to the LAN port on the unit for the Spanning Tree algorithm. This indicates to the automatic single-route bridge function the relative length of the path between the local unit port and the attached LAN. The higher the value, the less preferred the route.')
iflanPhysAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 3, 2, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: iflanPhysAddr.setStatus('mandatory')
if mibBuilder.loadTexts: iflanPhysAddr.setDescription('Network (or MAC) address of the unit. This address can be set to any value using 12 hexadecimal digits (6 bytes). However, the unit automatically sets the first byte to 40 for a Token-Ring LAN, or 02 for an Ethernet LAN, which forces the use of a locally administered address. When this parameter is set to 000000000000, the unit uses its burned-in address.')
iflanIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 3, 2, 1, 8), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: iflanIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: iflanIpAddress.setDescription('IP address for the local port. This address is a 4-byte value in dotted decimal representation, with a maximum value of 255 for each byte. When set to 000.000.000.000, no IP address is defined on the unit.')
iflanSubnetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 3, 2, 1, 9), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: iflanSubnetMask.setStatus('mandatory')
if mibBuilder.loadTexts: iflanSubnetMask.setDescription("Subnet mask associated with the port's IP address. It is configured like the IP address: a 4-byte value in dotted decimal representation, with a maximum value of 255 for each byte. The subnet mask identifies which bits of the IP address correspond to the physical network, and which bits correspond to host identifiers.")
iflanMaxFrame = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 3, 2, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(128, 8192))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: iflanMaxFrame.setStatus('mandatory')
if mibBuilder.loadTexts: iflanMaxFrame.setDescription('Maximum frame size, in octets. This parameter determines the largest datagram that can be sent or received on the interface in one IP frame. Datagrams larger than the maximum frame size are divided into fragments before transmission, the reassembled at the remote end.')
iflanEth_LinkIntegrity = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 3, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("no", 1), ("yes", 2), ("not-applicable", 254), ("not-available", 255)))).setLabel("iflanEth-LinkIntegrity").setMaxAccess("readwrite")
if mibBuilder.loadTexts: iflanEth_LinkIntegrity.setStatus('mandatory')
if mibBuilder.loadTexts: iflanEth_LinkIntegrity.setDescription('Heartbeat feature enabled or disabled, which determines whether the unit supports Link Integrity. When heartbeat is enabled (YES), the unit supports the Link Integrity mode. This is required when the Ethernet 10BASE-T port is connected to a hub. When the HEARTBEAT parameter is set to NO, the unit does not support Link Integrity. Valid only for Ethernet.')
iflanTr_Monitor = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 3, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("no", 1), ("yes", 2), ("not-applicable", 254), ("not-available", 255)))).setLabel("iflanTr-Monitor").setMaxAccess("readwrite")
if mibBuilder.loadTexts: iflanTr_Monitor.setStatus('mandatory')
if mibBuilder.loadTexts: iflanTr_Monitor.setDescription('Contender or non-contender as an active monitor. When this parameter is set to YES, the unit is a contender as the ring monitor. That is, if no ring monitors are active, the unit will automatically negotiate with other devices in the network to select a new monitor, and may become the new ring monitor. When this parameter is set to NO, the unit is a non-contender. That is, it will not negotiate with other devices and cannot become an active monitor. Valid only for Token-Ring.')
iflanTr_Etr = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 3, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("no", 1), ("yes", 2), ("not-applicable", 254), ("not-available", 255)))).setLabel("iflanTr-Etr").setMaxAccess("readwrite")
if mibBuilder.loadTexts: iflanTr_Etr.setStatus('mandatory')
if mibBuilder.loadTexts: iflanTr_Etr.setDescription("Early Token Release feature enabled or disabled. When this feature is enabled and the TR port speed is set to 16 Mbps, the unit will send an 'early token' as soon as the transmission of a frame is completed on the ring. When ETR is disabled, the unit waits until the reception of a frame is completed on the ring before sending a token. Valid only for Token-Ring.")
iflanTr_RingNumber = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 3, 2, 1, 15), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setLabel("iflanTr-RingNumber").setMaxAccess("readwrite")
if mibBuilder.loadTexts: iflanTr_RingNumber.setStatus('mandatory')
if mibBuilder.loadTexts: iflanTr_RingNumber.setDescription('The local LAN number, used for a source routing bridge. Valid only for Token-Ring.')
iflanIpRip = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 3, 2, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 254, 255))).clone(namedValues=NamedValues(("disable", 1), ("v1", 2), ("v2-broadcast", 3), ("v2-multicast", 4), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: iflanIpRip.setStatus('mandatory')
if mibBuilder.loadTexts: iflanIpRip.setDescription('When this parameter is set to V1, the RIP routing is done according to the RIP V1 standard. With RIP V2, broadcast or multicast can be used. With RIP V2 MULTICAST, only RIP V2 compliant devices will receive RIP frames.')
iflanIpxRip = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 3, 2, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: iflanIpxRip.setStatus('mandatory')
if mibBuilder.loadTexts: iflanIpxRip.setDescription('if this parameter is enable, the unit will generate IPX RIP frame on that interface every minute, otherwise the unit will discard all IPX RIP frame received and no one will be generated on that port.')
iflanIpxSap = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 3, 2, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: iflanIpxSap.setStatus('mandatory')
if mibBuilder.loadTexts: iflanIpxSap.setDescription('if this parameter is enable, the unit will generate IPX SAP frame on that interface every minute, otherwise the unit will discard all IPX SAP frame received and no one will be generated on that port.')
iflanIpxNetNum = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 3, 2, 1, 19), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: iflanIpxNetNum.setStatus('mandatory')
if mibBuilder.loadTexts: iflanIpxNetNum.setDescription('This value identify the IPX network number which the lan port of the unit is connected to')
iflanIpxLanType = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 3, 2, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 254, 255))).clone(namedValues=NamedValues(("ethernet-802p2", 1), ("ethernet-snap", 2), ("ethernet-802p3", 3), ("ethernet-ii", 4), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: iflanIpxLanType.setStatus('mandatory')
if mibBuilder.loadTexts: iflanIpxLanType.setDescription(' This parameter define the IPX frame type that the unit will recognize, Other frame type will be discarded')
iflanOspfEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 3, 2, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: iflanOspfEnable.setStatus('mandatory')
if mibBuilder.loadTexts: iflanOspfEnable.setDescription('Indicates whether or not OSPF is enabled on this interface.')
iflanOspfAreaId = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 3, 2, 1, 22), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: iflanOspfAreaId.setStatus('mandatory')
if mibBuilder.loadTexts: iflanOspfAreaId.setDescription('Identifies the area to which this interface belongs.')
iflanOspfPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 3, 2, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: iflanOspfPriority.setStatus('mandatory')
if mibBuilder.loadTexts: iflanOspfPriority.setDescription('When two routers attached to a network both attempt to become Designated Router, the one with the highest Router Priority takes precedence. A router whose Router Priority is set to 0 is ineligible to become Designated Router on the attached network. Router Priority is only configured for interfaces to multi-access networks.')
iflanOspfTransitDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 3, 2, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 360))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: iflanOspfTransitDelay.setStatus('mandatory')
if mibBuilder.loadTexts: iflanOspfTransitDelay.setDescription('The estimated number of seconds it takes to transmit a Link State Update Packet over this interface.')
iflanOspfRetransmitInt = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 3, 2, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 360))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: iflanOspfRetransmitInt.setStatus('mandatory')
if mibBuilder.loadTexts: iflanOspfRetransmitInt.setDescription('The number of seconds between like state advertisement retransmissions for adjacencies belonging to this interface. Also used when retransmitting Database Description and Link State Request Packets.')
iflanOspfHelloInt = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 3, 2, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 360))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: iflanOspfHelloInt.setStatus('mandatory')
if mibBuilder.loadTexts: iflanOspfHelloInt.setDescription("The length of time, in seconds, between the Hello Packets that the router sends on the interface. This value is advertised in the router's Hello Packets. It must be the same for all routers attached to a common network. The smaller the HelloInterval, the faster topological changes will be detected, but more OSPF routing protocol traffic will ensue.")
iflanOspfDeadInt = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 3, 2, 1, 27), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: iflanOspfDeadInt.setStatus('mandatory')
if mibBuilder.loadTexts: iflanOspfDeadInt.setDescription("After ceasing to hear a router's Hello Packets, the number of seconds before its neighbors declare the router down. This is also advertised in the router's Hello Packets in their RouterDeadInterval field. This value again bust be the same for all routers attached to a common network.")
iflanOspfPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 3, 2, 1, 28), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: iflanOspfPassword.setStatus('mandatory')
if mibBuilder.loadTexts: iflanOspfPassword.setDescription('This configured data allows the authentication procedure to generate and/or verify the authentication field in the OSPF header. This value again must be the same for all routers attached to a common network.')
iflanOspfMetricCost = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 3, 2, 1, 29), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65534))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: iflanOspfMetricCost.setStatus('mandatory')
if mibBuilder.loadTexts: iflanOspfMetricCost.setDescription("The cost of sending a packet on the interface, expressed in the link state metric. This is advertised as the link cost for this interface in the router's router links advertisement.")
iflanIpRipTxRx = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 3, 2, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 254, 255))).clone(namedValues=NamedValues(("duplex", 1), ("tx-only", 2), ("rx-only", 3), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: iflanIpRipTxRx.setStatus('mandatory')
if mibBuilder.loadTexts: iflanIpRipTxRx.setDescription('This parameter allows RIP frames transmission only, RIP frames reception only or both transmission and reception of RIP frames.')
iflanIpRipAuthType = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 3, 2, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("none", 1), ("simple", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: iflanIpRipAuthType.setStatus('mandatory')
if mibBuilder.loadTexts: iflanIpRipAuthType.setDescription('Enable or disable password authentication for the interface. If you select Simple Password, the password will be included in the sent RIP frames. The received frames containing authentication will be accepted only if the password is valid.')
iflanIpRipPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 3, 2, 1, 32), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: iflanIpRipPassword.setStatus('mandatory')
if mibBuilder.loadTexts: iflanIpRipPassword.setDescription('This configured data allows the authentication procedure to generate and/or verify the authentication field in the RIP header. This value again must be the same for each interface on each side of the link.')
puNumber = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 4, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: puNumber.setStatus('mandatory')
if mibBuilder.loadTexts: puNumber.setDescription('The number of controller present on this system.')
puTable = MibTable((1, 3, 6, 1, 4, 1, 727, 7, 2, 4, 2), )
if mibBuilder.loadTexts: puTable.setStatus('mandatory')
if mibBuilder.loadTexts: puTable.setDescription('A list of controller entries. The number of entries is given by the value of puNumber.')
puEntry = MibTableRow((1, 3, 6, 1, 4, 1, 727, 7, 2, 4, 2, 1), ).setIndexNames((0, "PRESTICOM7-MIB", "puIndex"))
if mibBuilder.loadTexts: puEntry.setStatus('mandatory')
if mibBuilder.loadTexts: puEntry.setDescription('This table contains the principal configurable parameters who are used for a particular PU.')
puIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 4, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: puIndex.setStatus('mandatory')
if mibBuilder.loadTexts: puIndex.setDescription('A unique value for each PU. Its value ranges between 1 and the value of puNumber.')
puMode = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 4, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 254, 255))).clone(namedValues=NamedValues(("off", 1), ("sdlc-llc", 2), ("sdlc-sdlc", 3), ("sdlc-dlsw", 4), ("sdlc-links", 5), ("llc-dlsw", 6), ("llc-links", 7), ("dlsw-links", 8), ("sdlc-ban", 9), ("sdlc-bnn", 10), ("llc-ban", 11), ("llc-bnn", 12), ("dlsw-ban", 13), ("dlsw-bnn", 14), ("ban-link", 15), ("bnn-link", 16), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: puMode.setStatus('mandatory')
if mibBuilder.loadTexts: puMode.setDescription('The PU operating mode.')
puActive = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 4, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("no", 1), ("yes", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: puActive.setStatus('mandatory')
if mibBuilder.loadTexts: puActive.setDescription('Sets the activation status of the PU.')
puDelayBeforeConn_s = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 4, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000))).setLabel("puDelayBeforeConn-s").setMaxAccess("readwrite")
if mibBuilder.loadTexts: puDelayBeforeConn_s.setStatus('mandatory')
if mibBuilder.loadTexts: puDelayBeforeConn_s.setDescription('Delay before connection. Maximum length of time, in seconds, allowed to establish the PU connection or change from one connection status to another.')
puRole = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 4, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("secondary", 1), ("primary", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: puRole.setStatus('mandatory')
if mibBuilder.loadTexts: puRole.setDescription('For LLC-DLSW, LLC-LINKS and DLSW-LINKS modes only. For LLC-DLSW and LLC-LINKS, this variable indicates whether the LLC side acts as a primary (facing the controller) or secondary (facing the host) unit. The unit automatically defines the other side with the opposite value. For DLSW-LINKS, this variable indicates whether the DLSw side acts as a primary or secondary unit. The unit automatically defines the LINKS side with the opposite value.')
puSdlcPort = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 4, 2, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: puSdlcPort.setStatus('mandatory')
if mibBuilder.loadTexts: puSdlcPort.setDescription('For all PU modes with an SDLC connection. Primary SNA/SDLC port (configured with the P-SDLC protocol) to which the PU is attached.')
puSdlcAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 4, 2, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: puSdlcAddress.setStatus('mandatory')
if mibBuilder.loadTexts: puSdlcAddress.setDescription('For all PU modes with an SDLC connection. SDLC address for the PU on the primary side of the connection. Two hexadecimal digits must be selected.')
puSdlcPort2 = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 4, 2, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: puSdlcPort2.setStatus('mandatory')
if mibBuilder.loadTexts: puSdlcPort2.setDescription('For SDLC-SDLC mode only. Secondary port (configured with the S-SDLC protocol) to which the PU is attached.')
puSdlcAddress2 = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 4, 2, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: puSdlcAddress2.setStatus('mandatory')
if mibBuilder.loadTexts: puSdlcAddress2.setDescription('For SDLC-SDLC mode only. SDLC address for the PU on the secondary side of the connection. Two hexadecimal digits must be selected.')
puSdlcTimeout_ms = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 4, 2, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(100, 30000))).setLabel("puSdlcTimeout-ms").setMaxAccess("readwrite")
if mibBuilder.loadTexts: puSdlcTimeout_ms.setStatus('mandatory')
if mibBuilder.loadTexts: puSdlcTimeout_ms.setDescription('For all PU modes with an SDLC connection. Wait for reply timeout before retransmitting a frame. This timeout is defined in milliseconds.')
puSdlcRetry = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 4, 2, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: puSdlcRetry.setStatus('mandatory')
if mibBuilder.loadTexts: puSdlcRetry.setDescription('For all PU modes with an SDLC connection. Maximum number of successive retries on the SDLC side of the connection before the PU is declared inoperative.')
puSdlcWindow = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 4, 2, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: puSdlcWindow.setStatus('mandatory')
if mibBuilder.loadTexts: puSdlcWindow.setDescription('For all PU modes with an SDLC connection. Transmitter window size.')
puSdlcMaxFrame = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 4, 2, 1, 13), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: puSdlcMaxFrame.setStatus('mandatory')
if mibBuilder.loadTexts: puSdlcMaxFrame.setDescription('For SDLC-LINKS, SDLC-LLC and SDLC-DLSW modes only. Maximum frame size on the SDLC side of the connection, excluding SNA headers. For an SDLC-LLC connection, if the value of this parameter is equal to that of the puLlcMaxFrame parameter, then no frame splitting will occur. On the other hand, if the value of this parameter is different from that of the puLlcMaxFrame parameter, the unit will split the frames according to the smaller max frame value. The same is true of an SDLC-DLSW connection, where the value of puSdlcMaxFrame is compared to that of puDlsMaxFrame.')
puLlcDa = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 4, 2, 1, 14), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: puLlcDa.setStatus('mandatory')
if mibBuilder.loadTexts: puLlcDa.setDescription('For all PU modes with an LLC connection. Destination address of the device to be reached on the LAN. This address is defined using 12 hexadecimal digits (6 bytes).')
puLlcTr_Routing = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 4, 2, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("trsp", 1), ("src", 2), ("not-applicable", 254), ("not-available", 255)))).setLabel("puLlcTr-Routing").setMaxAccess("readwrite")
if mibBuilder.loadTexts: puLlcTr_Routing.setStatus('mandatory')
if mibBuilder.loadTexts: puLlcTr_Routing.setDescription('For all PU modes with an LLC connection, Token-Ring only. Type of routing used in the Token-Ring LAN. This parameter defines the type of routing required to access the remote station. Select SRC for source routing through the LAN. Select TRSP for transparent routing.')
puLlcSsap = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 4, 2, 1, 16), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: puLlcSsap.setStatus('mandatory')
if mibBuilder.loadTexts: puLlcSsap.setDescription('For all PU modes with an LLC connection. Source SAP (Service Access Point) used by the unit for this PU. For an LLC-HOST application (LLC side acts as primary unit), the unit can handle multiple PUs over the same pair of network addresses: the host LAN destination address (DA) and the network address of the unit (NA). To distinguish the PUs attached to the same host, you must set the Source SAP parameter to a different value for each PU. Valid values are multiples of 4, from 04 to E8. This parameter must also be set in the host configuration. For an LLC-CONTROLLER application (LLC side acts as secondary unit), this parameter should be set to the default SNA SAP, that is, 04.')
puLlcDsap = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 4, 2, 1, 17), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: puLlcDsap.setStatus('mandatory')
if mibBuilder.loadTexts: puLlcDsap.setDescription('For all PU modes with an LLC connection. Destination SAP that will be used by the remote LAN device for this PU. Valid values are multiples of 4, from 04 to E8. Usually, the SNA destination SAP is 04.')
puLlcTimeout_ms = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 4, 2, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(100, 30000))).setLabel("puLlcTimeout-ms").setMaxAccess("readwrite")
if mibBuilder.loadTexts: puLlcTimeout_ms.setStatus('mandatory')
if mibBuilder.loadTexts: puLlcTimeout_ms.setDescription('For all PU modes with an LLC connection. Wait for reply timeout before retransmitting a frame. This timeout is defined in milliseconds.')
puLlcRetry = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 4, 2, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: puLlcRetry.setStatus('mandatory')
if mibBuilder.loadTexts: puLlcRetry.setDescription('For all PU modes with an LLC connection. Maximum number of successive retries on the LLC side of the connection before the PU is declared inoperative.')
puLlcWindow = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 4, 2, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: puLlcWindow.setStatus('mandatory')
if mibBuilder.loadTexts: puLlcWindow.setDescription('For all PU modes with an LLC connection. Maximum transmitter window size on the LAN. The dynamic window algorithm increases the window size by one each time the number of frames defined by the LLC-NW parameter (see below) has been acknowledged without a retransmission, until the maximum value defined by the LLC-WINDOW parameter has been reached. The window size is reset to 1 when a retransmission occurs.')
puLlcDynamicWindow = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 4, 2, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: puLlcDynamicWindow.setStatus('mandatory')
if mibBuilder.loadTexts: puLlcDynamicWindow.setDescription('For all PU modes with an LLC connection. Number of information frames that are consecutively acknowledged without a retransmission before the window size will be incremented by one. This parameter is used for the dynamic window algorithm, in conjunction with the puLlcWindow parameter.')
puLlcMaxFrame = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 4, 2, 1, 23), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: puLlcMaxFrame.setStatus('mandatory')
if mibBuilder.loadTexts: puLlcMaxFrame.setDescription('For all PU modes with an LLC connection. Maximum frame size on the LLC side of the connection, excluding LLC and SNA headers. For an SDLC-LLC connection, if the value of this parameter is equal to that of the puSdlcMaxFrame parameter, then no frame splitting will occur. On the other hand, if the value of this parameter is different from that of the puSdlcMaxFrame parameter, the unit will split the frames according to the smaller max frame value. The same is true of an LLC-DLSW connection, where the value of puLlcMaxFrame is compared to that of DLS-MAXFRM.')
puDlsDa = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 4, 2, 1, 24), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: puDlsDa.setStatus('mandatory')
if mibBuilder.loadTexts: puDlsDa.setDescription('For all PU modes with a DLSW connection. Destination address of the device to be reached via a DLSw connection. This address is defined using 12 hexadecimal digits (6 bytes).')
puDlsSsap = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 4, 2, 1, 25), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: puDlsSsap.setStatus('mandatory')
if mibBuilder.loadTexts: puDlsSsap.setDescription('For all PU modes with a DLSW connection. Source SAP (Service Access Point) used by the unit for this PU. For a DLSw-HOST application (DLSw side acts as primary unit), the unit can handle multiple PUs over the same pair of network addresses: the host DLSw destination address (DA) and the network address of the unit (NA). To distinguish the PUs attached to the same host, you must set the DLSw SSAP to a different value for each PU. Valid values are multiples of 4, from 04 to E8. This parameter must also be set in the host configuration. For a DLSw-CONTROLLER application (DLSw side acts as secondary unit), this parameter should be set to the default SNA SAP, that is, 04.')
puDlsDsap = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 4, 2, 1, 26), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: puDlsDsap.setStatus('mandatory')
if mibBuilder.loadTexts: puDlsDsap.setDescription('For all PU modes with a DLSW connection. Destination SAP that will be used by the remote DLSw device for this PU. Valid values are multiples of 4, from 04 to E8. Usually, the SNA destination SAP is 04.')
puDlsIpSrc = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 4, 2, 1, 27), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: puDlsIpSrc.setStatus('mandatory')
if mibBuilder.loadTexts: puDlsIpSrc.setDescription('For all PU modes with a DLSW connection. The IP source address, which identifies the port to reach the remote DLS. The port may be the LAN port or one of the serial WAN ports. This address is a 4-byte value in dotted decimal representation, with a maximum value of 255 for each byte. When this parameter is set to 000.000.000.000, no IP address is defined.')
puDlsIpDst = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 4, 2, 1, 28), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: puDlsIpDst.setStatus('mandatory')
if mibBuilder.loadTexts: puDlsIpDst.setDescription('For all PU modes with a DLSW connection. The IP address of the remote PU. This address is a 4-byte value in dotted decimal representation, with a maximum value of 255 for each byte. When this parameter is set to 000.000.000.000, no IP address is defined.')
puDlsMaxFrame = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 4, 2, 1, 29), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: puDlsMaxFrame.setStatus('mandatory')
if mibBuilder.loadTexts: puDlsMaxFrame.setDescription('For all PU modes with a DLSW connection. Maximum frame size on the DLSw side of the connection, excluding SNA headers. For an SDLC-DLSW connection, if the value of this parameter is equal to that of the puSdlcMaxFrame parameter, then no frame splitting will occur. On the other hand, if the value of this parameter is different from that of the puSdlcMaxFrame parameter, the unit will split the frames according to the smaller max frame value. The same is true of an LLC-DLSW connection, where the value of puDlsMaxFrame is compared to that of puLlcMaxFrame.')
puLinkRemoteUnit = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 4, 2, 1, 30), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: puLinkRemoteUnit.setStatus('mandatory')
if mibBuilder.loadTexts: puLinkRemoteUnit.setDescription('Remote unit to which data from this pu should be directed')
puLinkClassNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 4, 2, 1, 31), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: puLinkClassNumber.setStatus('mandatory')
if mibBuilder.loadTexts: puLinkClassNumber.setDescription('The priority class for data from this pu. Classes are defined according to bandwidth weight.')
puLinkRemPu = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 4, 2, 1, 32), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: puLinkRemPu.setStatus('mandatory')
if mibBuilder.loadTexts: puLinkRemPu.setDescription('For all PU modes with a LINKS connection. The PU number on the remote unit.')
puXid = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 4, 2, 1, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 254, 255))).clone(namedValues=NamedValues(("no", 1), ("yes", 2), ("manual", 3), ("auto", 4), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: puXid.setStatus('mandatory')
if mibBuilder.loadTexts: puXid.setDescription('For SDLC-SDLC and SDLC-LINKS modes only. PU exchanges identification. This parameter determines whether the PU expects to exchange PU identification with the device it is connected to, and ensures the identity of the remote PU in SNA applications. Set to NO if the PU does not support XID.')
puXidId = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 4, 2, 1, 34), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: puXidId.setStatus('mandatory')
if mibBuilder.loadTexts: puXidId.setDescription('For all PU modes with an LLC or DLSW connection. This parameter contains the ID block (IDBLK) and ID number (IDNUM) of the PU. The first 3 digits comprise the IDBLK, and the last 5 digits comprise the IDNUM.')
puXidFormat = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 4, 2, 1, 35), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: puXidFormat.setStatus('mandatory')
if mibBuilder.loadTexts: puXidFormat.setDescription('For all PU modes with an LLC or DLSW connection. XID format type. Only types 0 and 1 are supported at this time. Type 0 is used by older IBM controllers: the IBM 3274 and some of the old 3174, 5294 and 5394 models. Type 1 is used by the newer models.')
puXidPuType = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 4, 2, 1, 36), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: puXidPuType.setStatus('mandatory')
if mibBuilder.loadTexts: puXidPuType.setDescription('For all PU modes with an LLC or DLSW connection. The PU type that is possible in the XID. Only PU types 1 and 2 are supported at this time.')
puBnnPvc = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 4, 2, 1, 37), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: puBnnPvc.setStatus('mandatory')
if mibBuilder.loadTexts: puBnnPvc.setDescription('For all PU modes with a BNN connection. The number of the remote PVC to which data from this PU will be sent.')
puBnnFid = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 4, 2, 1, 38), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 254, 255))).clone(namedValues=NamedValues(("fID2", 1), ("fID4", 2), ("aPPN", 3), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: puBnnFid.setStatus('mandatory')
if mibBuilder.loadTexts: puBnnFid.setDescription('For all PU modes with a BNN connection. The type of format Identification Field (FID) for this PU.')
puBanDa = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 4, 2, 1, 39), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: puBanDa.setStatus('mandatory')
if mibBuilder.loadTexts: puBanDa.setDescription('For all PU modes with a BAN or BNN connection. Destination address of the device to be reached on the BAN/BNN connection. This address is defined using 12 hexadecimal digits (6 bytes).')
puBanBnnSsap = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 4, 2, 1, 40), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: puBanBnnSsap.setStatus('mandatory')
if mibBuilder.loadTexts: puBanBnnSsap.setDescription('For all PU modes with a BAN or BNN connection. Source SAP (Service Access Point) used by the BayFRAD for this PU. For an BAN-HOST application (BAN side acts as primary unit), the BayFRAD can handle multiple PUs attached to the same host. For this application you must set the BAN/BNN Source SAP parameter to a different value for each PU. Valid values are multiples of 4, from 04 to DC. For an BAN-CONTROLLER application (BAN side acts as secondary unit), this parameter should be set to the default SNA SAP, that is, 04.')
puBanBnnDsap = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 4, 2, 1, 41), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: puBanBnnDsap.setStatus('mandatory')
if mibBuilder.loadTexts: puBanBnnDsap.setDescription('For all PU modes with a BAN or BNN connection. Destination SAP that will be used by the remote BAN device for this PU. Valid values are multiples of 4, from 04 to DC. Usually, the SNA destination SAP is 04.')
puBanBnnTimeout_ms = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 4, 2, 1, 42), Integer32().subtype(subtypeSpec=ValueRangeConstraint(100, 30000))).setLabel("puBanBnnTimeout-ms").setMaxAccess("readwrite")
if mibBuilder.loadTexts: puBanBnnTimeout_ms.setStatus('mandatory')
if mibBuilder.loadTexts: puBanBnnTimeout_ms.setDescription('For all PU modes with a BAN or BNN connection. Wait for reply timeout before retransmitting a frame. This timeout is defined in milliseconds.')
puBanBnnRetry = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 4, 2, 1, 43), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: puBanBnnRetry.setStatus('mandatory')
if mibBuilder.loadTexts: puBanBnnRetry.setDescription('For all PU modes with a BAN or BNN connection. Maximum number of successive retries on the BAN/BNN side of the connection before the PU is declared inoperative.')
puBanBnnWindow = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 4, 2, 1, 44), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: puBanBnnWindow.setStatus('mandatory')
if mibBuilder.loadTexts: puBanBnnWindow.setDescription('For all PU modes with a BAN or BNN connection. Maximum transmission window size on the BAN. The dynamic window algorithm increases the window size by one each time the number of frames defined by the puBanBnnNw parameter has been acknowledged without a retransmission, until the maximum value defined by the puBanBnnWindow parameter has been reached. The window size is reset to 1 when a retransmission occurs.')
puBanBnnNw = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 4, 2, 1, 45), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: puBanBnnNw.setStatus('mandatory')
if mibBuilder.loadTexts: puBanBnnNw.setDescription('For all PU modes with a BAN or BNN connection. Number of information frames that are consecutively acknowledged without a retransmission before the window size will be incremented by one. This parameter is used for the dynamic window algorithm, in conjunction with the puBanBnnWindow parameter.')
puBanBnnMaxFrame = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 4, 2, 1, 46), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: puBanBnnMaxFrame.setStatus('mandatory')
if mibBuilder.loadTexts: puBanBnnMaxFrame.setDescription('For all PU modes with a BAN or BNN connection. Maximum frame size on the BAN/BNN side of the connection, excluding BAN/BNN and SNA headers. For an SDLC-BAN connection, if the value of this parameter is equal to that of the puSdlcMaxFrame parameter, then no frame splitting will occur. On the other hand, if the value of this parameter is different from that of the puSdlcMaxFrame parameter, the FRAD will split the frames according to the smaller max frame value. The same is true of a SDLC-BNN, LLC-BAN and LLC-BNN connection.')
puBanRouting = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 4, 2, 1, 47), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 254, 255))).clone(namedValues=NamedValues(("transparent", 1), ("source", 2), ("source-a", 3), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: puBanRouting.setStatus('mandatory')
if mibBuilder.loadTexts: puBanRouting.setDescription('For all PU modes with a BAN or BNN connection. This parameter defines the type of routing required to access the remote station. Select SOURCE for source routing, or TRANSPARENT for transparent routing or SOURCE-A for source routing with an all route broadcast response to a single route broadcast request.')
scheduleNumber = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 5, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: scheduleNumber.setStatus('mandatory')
if mibBuilder.loadTexts: scheduleNumber.setDescription('The number of period present on this system.')
scheduleTable = MibTable((1, 3, 6, 1, 4, 1, 727, 7, 2, 5, 2), )
if mibBuilder.loadTexts: scheduleTable.setStatus('mandatory')
if mibBuilder.loadTexts: scheduleTable.setDescription('A list of period entries. The number of entries is given by the value of scheduleNumber.')
scheduleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 727, 7, 2, 5, 2, 1), ).setIndexNames((0, "PRESTICOM7-MIB", "schedulePeriod"))
if mibBuilder.loadTexts: scheduleEntry.setStatus('mandatory')
if mibBuilder.loadTexts: scheduleEntry.setDescription('This table contains the principal configurable parameters who are used for a particular period.')
schedulePeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 5, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: schedulePeriod.setStatus('mandatory')
if mibBuilder.loadTexts: schedulePeriod.setDescription('A unique value for each period. Its value ranges between 1 and the value of scheduleNumber.')
scheduleEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 5, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("no", 1), ("yes", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: scheduleEnable.setStatus('mandatory')
if mibBuilder.loadTexts: scheduleEnable.setDescription('Enable period. This parameter defines whether the period will be used during the time period it covers. When no periods are enabled, or no enabled period covers the current time, the unit uses the default operating mode configured with the WAN link parameters.')
scheduleDay = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 5, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 254, 255))).clone(namedValues=NamedValues(("all", 1), ("sunday", 2), ("monday", 3), ("tuesday", 4), ("wednesday", 5), ("thursday", 6), ("friday", 7), ("saturday", 8), ("workday", 9), ("weekend", 10), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: scheduleDay.setStatus('mandatory')
if mibBuilder.loadTexts: scheduleDay.setDescription('Day(s) of the week during which the period is effective. Select ALL to configure the period for all days of the week. Use weekend for Saturday and Sunday only. Use workday for Monday to Friday.')
scheduleBeginTime = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 5, 2, 1, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: scheduleBeginTime.setStatus('mandatory')
if mibBuilder.loadTexts: scheduleBeginTime.setDescription('Time of day at which the period begins on a 24-hour clock. When the period is enabled, the WAN link operating mode defined for the period will commence at this time on the configured day(s).')
scheduleEndTime = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 5, 2, 1, 5), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: scheduleEndTime.setStatus('mandatory')
if mibBuilder.loadTexts: scheduleEndTime.setDescription('Time of day at which the period ends on a 24-hour clock. When the period is enabled, the WAN link operating mode defined for the period will be disabled at this time on the configured day(s). If no other period is configured and enabled to commence at this time, the unit will activate the default operating mode configured with the WAN link parameters.')
schedulePort1 = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 5, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 254, 255))).clone(namedValues=NamedValues(("inactive", 1), ("dedicated", 2), ("answer", 3), ("call-backup", 4), ("call-bod", 5), ("wait-user", 6), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: schedulePort1.setStatus('mandatory')
if mibBuilder.loadTexts: schedulePort1.setDescription('Operating mode for the WAN link (port configured in PVCR protocol) when this period is activated. The possible settings for this parameter are the following: DEDICATED: Communication is carried out over a dedicated line. ANSWER: The port can receive calls only. CALL-BKUP: Call mode using a backup recovery mechanism. The port is activated in case of line failure on the dedicated WAN links. CALL-BOD: Call mode using Bandwidth On Demand(BOND) processing, which automatically controls both dialing over and hanging up the link. INACTIVE: Deactivation of the link.')
schedulePort2 = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 5, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 254, 255))).clone(namedValues=NamedValues(("inactive", 1), ("dedicated", 2), ("answer", 3), ("call-backup", 4), ("call-bod", 5), ("wait-user", 6), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: schedulePort2.setStatus('mandatory')
schedulePort3 = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 5, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 254, 255))).clone(namedValues=NamedValues(("inactive", 1), ("dedicated", 2), ("answer", 3), ("call-backup", 4), ("call-bod", 5), ("wait-user", 6), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: schedulePort3.setStatus('mandatory')
schedulePort4 = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 5, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 254, 255))).clone(namedValues=NamedValues(("inactive", 1), ("dedicated", 2), ("answer", 3), ("call-backup", 4), ("call-bod", 5), ("wait-user", 6), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: schedulePort4.setStatus('mandatory')
schedulePort5 = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 5, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 254, 255))).clone(namedValues=NamedValues(("inactive", 1), ("dedicated", 2), ("answer", 3), ("call-backup", 4), ("call-bod", 5), ("wait-user", 6), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: schedulePort5.setStatus('mandatory')
schedulePort6 = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 5, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 254, 255))).clone(namedValues=NamedValues(("inactive", 1), ("dedicated", 2), ("answer", 3), ("call-backup", 4), ("call-bod", 5), ("wait-user", 6), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: schedulePort6.setStatus('mandatory')
schedulePort7 = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 5, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 254, 255))).clone(namedValues=NamedValues(("inactive", 1), ("dedicated", 2), ("answer", 3), ("call-backup", 4), ("call-bod", 5), ("wait-user", 6), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: schedulePort7.setStatus('mandatory')
schedulePort8 = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 5, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 254, 255))).clone(namedValues=NamedValues(("inactive", 1), ("dedicated", 2), ("answer", 3), ("call-backup", 4), ("call-bod", 5), ("wait-user", 6), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: schedulePort8.setStatus('mandatory')
bridgeEnable = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 6, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("no", 1), ("yes", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bridgeEnable.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeEnable.setDescription('This variable defines Bridge enable(yes) or disable(no). If you enable the bridge, the unit transfers information between two LAN segments.')
bridgeStpEnable = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 6, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("no", 1), ("yes", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bridgeStpEnable.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeStpEnable.setDescription('This parameter defines whether the Spanning Tree protocol will be enabled. The unit uses the spanning tree algorithm to decide how to forward frames and how to propagate broadcast packets so that only one copy of a broadcast frame is delivered to each LAN. For transparent bridging, STP ensures that only one active route is used at one time during transparent bridging. For source route bridging, it is used to initialize a single-route broadcast route.')
bridgeLanType = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 6, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 254, 255))).clone(namedValues=NamedValues(("ethernet-auto", 1), ("ethernet-802p3", 2), ("ethernet-v2", 3), ("token-ring", 4), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bridgeLanType.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeLanType.setDescription('The type of LAN data that must be bridged via the unit')
bridgeAgingTime_s = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 6, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 1000000))).setLabel("bridgeAgingTime-s").setMaxAccess("readwrite")
if mibBuilder.loadTexts: bridgeAgingTime_s.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeAgingTime_s.setDescription('Aging time, in seconds, for deleting addresses from the routing table. In transparent bridging, the routing table contains a combination of fixed and learned addresses. For the learned addresses, if a station has not been heard from for the AGING TIME period, its entry can be deleted. This process keeps the size of the routing table to a manageable level, and minimizes the amount of memory and processing required to search it.')
bridgeHelloTime_s = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 6, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setLabel("bridgeHelloTime-s").setMaxAccess("readwrite")
if mibBuilder.loadTexts: bridgeHelloTime_s.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeHelloTime_s.setDescription('The interval, in seconds, between HELLO messages that the unit transmits to all LAN segments to which it is connected. HELLO messages carry timestamp information as well as information concerning the current root bridge. From this information the unit is able to determine the current network topology and compute the shortest delay paths to destination devices. Automatic single-route broadcast uses the HELLO message to detect when bridges enter and leave the network.')
bridgeMaxAge_s = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 6, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(6, 40))).setLabel("bridgeMaxAge-s").setMaxAccess("readwrite")
if mibBuilder.loadTexts: bridgeMaxAge_s.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeMaxAge_s.setDescription('The maximum time that the bridge can wait for reception of a HELLO frame. If this bridge is the network root bridge, the MAX AGE value will be coded in all HELLO messages that the unit transmits.')
bridgeForwardDelay_s = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 6, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(4, 30))).setLabel("bridgeForwardDelay-s").setMaxAccess("readwrite")
if mibBuilder.loadTexts: bridgeForwardDelay_s.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeForwardDelay_s.setDescription('The wait time, in seconds, that the unit spends in the Learning state before moving to the Forwarding state. In the Learning state, the unit is building address tables and participating in the spanning tree algorithm, but is not forwarding frames. In the Forwarding state, the unit forwards frames in addition to its other bridge activities.')
bridgePriority = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 6, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bridgePriority.setStatus('mandatory')
if mibBuilder.loadTexts: bridgePriority.setDescription('Priority assigned to this bridge for the Spanning Tree algorithm. The unit uses this parameter to determine the network topology.')
bridgeTr_Number = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 6, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setLabel("bridgeTr-Number").setMaxAccess("readwrite")
if mibBuilder.loadTexts: bridgeTr_Number.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeTr_Number.setDescription('The bridge number, required for source routing of Tocken-Ring data via the unit. This number represents the bridge between two links on a Token-Ring network. You must set the bridge number if the unit acts as an intermediary bridge to reach a remote unit that support a Token-Ring LAN.')
bridgeTr_SteSpan = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 6, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 254, 255))).clone(namedValues=NamedValues(("auto", 1), ("disable", 2), ("forced", 3), ("not-applicable", 254), ("not-available", 255)))).setLabel("bridgeTr-SteSpan").setMaxAccess("readwrite")
if mibBuilder.loadTexts: bridgeTr_SteSpan.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeTr_SteSpan.setDescription('Span mode for STE (Spanning Tree Explorer) frames, required when Token-Ring data is bridged via the unit. This parameter determines how the port will behave when presented with an STE frame (Single Route Broadcast only). You must set the bridge number if the unit acts as an intermediary bridge to reach a remote unit that support a Token-Ring LAN.')
bridgeTr_MaxHop = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 6, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setLabel("bridgeTr-MaxHop").setMaxAccess("readwrite")
if mibBuilder.loadTexts: bridgeTr_MaxHop.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeTr_MaxHop.setDescription('The maximum nember of bridges that a broadcast frame can cross on the way to its destination. The unit discard any frame with a routing information field that exceeds this limits. This parameter is required for source routing of Tocken-Ring data via the unit. You must specify the MAX HOP if the unit acts as an intermediary bridge to reach a remote unit that support a Token-Ring LAN.')
phoneNumber = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 7, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phoneNumber.setStatus('mandatory')
if mibBuilder.loadTexts: phoneNumber.setDescription('The number of phone present on this system.')
phoneTable = MibTable((1, 3, 6, 1, 4, 1, 727, 7, 2, 7, 2), )
if mibBuilder.loadTexts: phoneTable.setStatus('mandatory')
if mibBuilder.loadTexts: phoneTable.setDescription('A list of phone entries. The number of entries is given by the value of phoneNumber.')
phoneEntry = MibTableRow((1, 3, 6, 1, 4, 1, 727, 7, 2, 7, 2, 1), ).setIndexNames((0, "PRESTICOM7-MIB", "phoneIndex"))
if mibBuilder.loadTexts: phoneEntry.setStatus('mandatory')
if mibBuilder.loadTexts: phoneEntry.setDescription('This table contains the principal configurable parameters who are used for a particular phone.')
phoneIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 7, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phoneIndex.setStatus('mandatory')
if mibBuilder.loadTexts: phoneIndex.setDescription('A unique value for each phone. Its value ranges between 1 and the value of phoneNumber.')
phoneRemoteUnit = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 7, 2, 1, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: phoneRemoteUnit.setStatus('mandatory')
if mibBuilder.loadTexts: phoneRemoteUnit.setDescription('Name of the unit that has to be backup.')
phonePhoneNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 7, 2, 1, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: phonePhoneNumber.setStatus('mandatory')
if mibBuilder.loadTexts: phonePhoneNumber.setDescription('Phone number to dial to backup the Remote unit.')
phoneNextHop = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 7, 2, 1, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: phoneNextHop.setStatus('mandatory')
if mibBuilder.loadTexts: phoneNextHop.setDescription('Name of the Next hop by which the Remote unit should normally be seen.')
phoneCost = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 7, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65534))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: phoneCost.setStatus('mandatory')
if mibBuilder.loadTexts: phoneCost.setDescription('Normal cost to reach the remote unit.')
filterNumber = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 8, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: filterNumber.setStatus('mandatory')
if mibBuilder.loadTexts: filterNumber.setDescription('The number of filter present on this system.')
filterTable = MibTable((1, 3, 6, 1, 4, 1, 727, 7, 2, 8, 2), )
if mibBuilder.loadTexts: filterTable.setStatus('mandatory')
if mibBuilder.loadTexts: filterTable.setDescription('A list of filter entries. The number of entries is given by the value of filterNumber.')
filterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 727, 7, 2, 8, 2, 1), ).setIndexNames((0, "PRESTICOM7-MIB", "filterIndex"))
if mibBuilder.loadTexts: filterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: filterEntry.setDescription('This table contains the principal configurable parameters who are used for a particular filter.')
filterIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 8, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: filterIndex.setStatus('mandatory')
if mibBuilder.loadTexts: filterIndex.setDescription('A unique value for each filter. Its value ranges between 1 and the value of filterNumber.')
filterActive = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 8, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("no", 1), ("yes", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: filterActive.setStatus('mandatory')
if mibBuilder.loadTexts: filterActive.setDescription('Sets the activation status of the filter.')
filterDefinition = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 8, 2, 1, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: filterDefinition.setStatus('mandatory')
if mibBuilder.loadTexts: filterDefinition.setDescription('The definition of the filter. Each filter definition contains a set of criteria that prevent extraneous frames from being forwarded, or send specific frames over the high or low-priority bridge channel of the composite link. The latter application allows you to prioritize a particular traffic type over the Bridge 1 channel.')
classNumber = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 9, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: classNumber.setStatus('mandatory')
if mibBuilder.loadTexts: classNumber.setDescription('The number of class present on this system.')
classDefaultClass = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 9, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: classDefaultClass.setStatus('mandatory')
if mibBuilder.loadTexts: classDefaultClass.setDescription('The default class to be used when no class is defined for a port, PU or PVC.')
classTable = MibTable((1, 3, 6, 1, 4, 1, 727, 7, 2, 9, 3), )
if mibBuilder.loadTexts: classTable.setStatus('mandatory')
if mibBuilder.loadTexts: classTable.setDescription('A list of class entries. The number of entries is given by the value of classNumber.')
classEntry = MibTableRow((1, 3, 6, 1, 4, 1, 727, 7, 2, 9, 3, 1), ).setIndexNames((0, "PRESTICOM7-MIB", "classIndex"))
if mibBuilder.loadTexts: classEntry.setStatus('mandatory')
if mibBuilder.loadTexts: classEntry.setDescription('This table contains the principal configurable parameters who are used for a particular class.')
classIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 9, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: classIndex.setStatus('mandatory')
if mibBuilder.loadTexts: classIndex.setDescription('A unique value for each class. Its value ranges between 1 and the value of classNumber.')
classWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 9, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: classWeight.setStatus('mandatory')
if mibBuilder.loadTexts: classWeight.setDescription('The relative bandwidth weight used by this class on the composite link. The higher the weight, the greater the amount of bandwidth allocated to traffic in this class. Thus the class with the highest relative weight will have the highest priority, which can be used to guarantee the response time for mission-critical data.')
classPrefRoute = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 9, 3, 1, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: classPrefRoute.setStatus('mandatory')
if mibBuilder.loadTexts: classPrefRoute.setDescription('Identifies the name of the NetPerformer unit to be used as the next hop for sending transparent or PVC multiplex data over multiple direct links (point-to-point or rack backbone connections), where more than one route is available and all available routes are equal in cost. Assigning a different preferred route to different classes ensures static load balancing of transparent traffic over all routes.')
pvcNumber = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 10, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pvcNumber.setStatus('mandatory')
if mibBuilder.loadTexts: pvcNumber.setDescription('The number of pvc present on this system.')
pvcTable = MibTable((1, 3, 6, 1, 4, 1, 727, 7, 2, 10, 2), )
if mibBuilder.loadTexts: pvcTable.setStatus('mandatory')
if mibBuilder.loadTexts: pvcTable.setDescription('A list of pvc entries. The number of entries is given by the value of pvcNumber.')
pvcEntry = MibTableRow((1, 3, 6, 1, 4, 1, 727, 7, 2, 10, 2, 1), ).setIndexNames((0, "PRESTICOM7-MIB", "pvcIndex"))
if mibBuilder.loadTexts: pvcEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pvcEntry.setDescription('This table contains the principal configurable parameters who are used for a particular pvc.')
pvcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 10, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pvcIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pvcIndex.setDescription('A unique value for each pvc. Its value ranges between 1 and the value of pvcNumber.')
pvcMode = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 10, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 7, 8, 9, 254, 255))).clone(namedValues=NamedValues(("off", 1), ("pvcr", 2), ("multiplex", 3), ("transp", 4), ("rfc-1490", 5), ("fp", 7), ("broadcast", 8), ("fp-multiplex", 9), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvcMode.setStatus('mandatory')
if mibBuilder.loadTexts: pvcMode.setDescription('Operating mode of PVC.')
pvcDlciAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 10, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1022))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvcDlciAddress.setStatus('mandatory')
if mibBuilder.loadTexts: pvcDlciAddress.setDescription('The DLCI address of the PVC, representing the virtual connection identification for accessing the remote unit. This address is provided by the carrier. The value 0 is use for the AUTO DLCI.')
pvcPort = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 10, 2, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvcPort.setStatus('mandatory')
if mibBuilder.loadTexts: pvcPort.setDescription('Frame Relay port used by the PVC. The port you select must be configured as a FR-USER port, using the port PROTOCOL parameter.')
pvcUserPort = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 10, 2, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvcUserPort.setStatus('mandatory')
if mibBuilder.loadTexts: pvcUserPort.setDescription('Frame Relay port used by the PVC. The port you select must be configured as a FR-USER port, using the port PROTOCOL parameter.')
pvcInfoRate = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 10, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1200, 2000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvcInfoRate.setStatus('mandatory')
if mibBuilder.loadTexts: pvcInfoRate.setDescription('PVC Committed Information Rate (CIR). The CIR represents the data throughput that the network can accept on this PVC. The CIR, provided by the carrier, must be set on the unit to prevent data loss in the network (frames exceeding the CIR can be discarded).')
pvcPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 10, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pvcPriority.setStatus('mandatory')
if mibBuilder.loadTexts: pvcPriority.setDescription('Priority assigned to the PVC for the Spanning Tree algorithm.')
pvcCost = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 10, 2, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pvcCost.setStatus('mandatory')
if mibBuilder.loadTexts: pvcCost.setDescription('The path cost assigned to the PVC for the Spanning Tree algorithm. This indicates to the automatic single-route bridge function the relative length of the path between the local PVC and the attached LAN. The higher the value, the less preferred the route.')
pvcRemoteUnit = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 10, 2, 1, 11), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvcRemoteUnit.setStatus('mandatory')
if mibBuilder.loadTexts: pvcRemoteUnit.setDescription('Remote unit to which data from this PVC should be directed.')
pvcTimeout_ms = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 10, 2, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1000, 30000))).setLabel("pvcTimeout-ms").setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvcTimeout_ms.setStatus('mandatory')
if mibBuilder.loadTexts: pvcTimeout_ms.setDescription('The wait for ACK timeout before retransmitting a frame on the PVC.')
pvcRetry = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 10, 2, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvcRetry.setStatus('mandatory')
if mibBuilder.loadTexts: pvcRetry.setDescription('Maximum number of successive retries before the PVC connection is declared down.')
pvcCompression = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 10, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("no", 1), ("yes", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvcCompression.setStatus('mandatory')
if mibBuilder.loadTexts: pvcCompression.setDescription('Use compression on the PVC connection to the remote unit. With compression, the available bandwidth is used more efficiently. When compression is not used, higher speeds can be obtained on the link.')
pvcIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 10, 2, 1, 15), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvcIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: pvcIpAddress.setDescription('IP address of the local PVC. This address is a 4-byte value in dotted decimal representation, with a maximum value of 255 for each byte. When set to 000.000.000.000, no IP address is defined for this PVC. In this case the unit will use the default IP address defined with the global DEFAULT IP ADDR parameter.')
pvcSubnetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 10, 2, 1, 16), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvcSubnetMask.setStatus('mandatory')
if mibBuilder.loadTexts: pvcSubnetMask.setDescription("Subnet mask associated with the PVC's IP address. It is configured like the IP address: a 4-byte value in dotted decimal representation, with a maximum value of 255 for each byte. The subnet mask identifies which bits of the IP address correspond to the physical network, and which bits correspond to host identifiers.")
pvcMaxFrame = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 10, 2, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(128, 8192))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvcMaxFrame.setStatus('mandatory')
if mibBuilder.loadTexts: pvcMaxFrame.setDescription('Maximum frame size, in octets. This parameter determines the largest datagram that can be sent or received on the interface in one IP frame. Datagrams larger than the maximum frame size are divided into fragments before transmission, the reassembled at the remote end.')
pvcBroadcastGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 10, 2, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("no", 1), ("yes", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvcBroadcastGroup.setStatus('mandatory')
if mibBuilder.loadTexts: pvcBroadcastGroup.setDescription(' 0 and 1 apply to a pvc in pvcr mode only to specify if its belongs or not to a broadcast group')
pvcBrgConnection = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 10, 2, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("no", 1), ("yes", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvcBrgConnection.setStatus('mandatory')
if mibBuilder.loadTexts: pvcBrgConnection.setDescription('Bridge connection. Set this parameter to YES if the RFC1490-compatible FRAD at the remote end requires bridge frames. If bridge data it not required, a NO value will prevent the transmission of unnecessary frames from this PVC, thus reducing your network costs.')
pvcIpConnection = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 10, 2, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("no", 1), ("yes", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvcIpConnection.setStatus('mandatory')
if mibBuilder.loadTexts: pvcIpConnection.setDescription('IP connection. Set this parameter to YES if the RFC1490-compatible FRAD at the remote end requires bridge frames. If IP data it not required, a NO value will prevent the transmission of unnecessary frames from this PVC, thus reducing your network costs.')
pvcRemotePvc = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 10, 2, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 300))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvcRemotePvc.setStatus('mandatory')
if mibBuilder.loadTexts: pvcRemotePvc.setDescription('The remote PVC to which data from PVC is sent. Specify the remote PVC number.')
pvcPvcClass = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 10, 2, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvcPvcClass.setStatus('mandatory')
if mibBuilder.loadTexts: pvcPvcClass.setDescription('The priority class for data from this PVC. Classes are defined according to bandwidth weight.')
pvcNetworkPort = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 10, 2, 1, 23), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvcNetworkPort.setStatus('mandatory')
if mibBuilder.loadTexts: pvcNetworkPort.setDescription('The Frame Relay network port used by the transparent PVC. The port you select must be configured as a Frame Relay network port (FR-NET protocol) using the port PROTOC parameter. All frames received on the network port side for that PVC will be transmitted to the user port side.')
pvcRingNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 10, 2, 1, 24), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvcRingNumber.setStatus('mandatory')
if mibBuilder.loadTexts: pvcRingNumber.setDescription('The ring number of the remote Token-Ring LAN, required for source routing of Token-Ring data via the unit.')
pvcIpRip = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 10, 2, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 254, 255))).clone(namedValues=NamedValues(("disable", 1), ("v1", 2), ("v2-broadcast", 3), ("v2-multicast", 4), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvcIpRip.setStatus('mandatory')
if mibBuilder.loadTexts: pvcIpRip.setDescription('When this parameter is set to V1, the RIP routing is done according to the RIP V1 standard. With RIP V2, broadcast or multicast can be used. With RIP V2 MULTICAST, only RIP V2 compliant devices will receive RIP frames.')
pvcBurstInfoRate = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 10, 2, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1200, 2000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvcBurstInfoRate.setStatus('mandatory')
if mibBuilder.loadTexts: pvcBurstInfoRate.setDescription('PVC Burst Information Rate (BIR). The BIR represents the data throughput that the network can accept on this PVC when the network is not congested.')
pvcUserDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 10, 2, 1, 27), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1022))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvcUserDlci.setStatus('mandatory')
if mibBuilder.loadTexts: pvcUserDlci.setDescription('The DLCI address of the PVC on the user side, representing the virtual connection identification on the frame relay interface.')
pvcNetworkDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 10, 2, 1, 28), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1022))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvcNetworkDlci.setStatus('mandatory')
if mibBuilder.loadTexts: pvcNetworkDlci.setDescription('The DLCI address of the PVC on the network side, representing the virtual connection identification on the frame relay interface.')
pvcIpxRip = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 10, 2, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvcIpxRip.setStatus('mandatory')
if mibBuilder.loadTexts: pvcIpxRip.setDescription('if this parameter is enable, the unit will generate IPX RIP frame on the port ( the one used by this pvc) every minute, otherwise the unit will discard all IPX RIP frame received and no one will be generated on that port.')
pvcIpxSap = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 10, 2, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvcIpxSap.setStatus('mandatory')
if mibBuilder.loadTexts: pvcIpxSap.setDescription('if this parameter is enable, the unit will generate IPX SAP frame on the port ( the one used by this pvc) every minute, otherwise the unit will discard all IPX SAP frame received and no one will be generated on that port.')
pvcIpxNetNum = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 10, 2, 1, 31), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvcIpxNetNum.setStatus('mandatory')
if mibBuilder.loadTexts: pvcIpxNetNum.setDescription('This value identify the IPX network number which the unit is connected to')
pvcIpxConnection = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 10, 2, 1, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("no", 1), ("yes", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvcIpxConnection.setStatus('mandatory')
if mibBuilder.loadTexts: pvcIpxConnection.setDescription('IPX connection. Set this parameter to YES if the RFC1490-compatible FRAD at the remote end requires bridge frames. If IPX data it not required, a NO value will prevent the transmission of unnecessary frames from this PVC, thus reducing your network costs.')
pvcType = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 10, 2, 1, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 254, 255))).clone(namedValues=NamedValues(("dedicated", 2), ("answer", 3), ("call-backup", 4), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvcType.setStatus('mandatory')
if mibBuilder.loadTexts: pvcType.setDescription('For PVCR mode only. This parameter defines the PVC as a dedicated PVC or a backup PVC. The ANSWER type is used for the PVC that responds to calls. When you install a backup PVC between two units, one unit must be configured in CALL-BACKUP type and the other as ANSWER.')
pvcBackupCall_s = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 10, 2, 1, 34), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setLabel("pvcBackupCall-s").setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvcBackupCall_s.setStatus('mandatory')
if mibBuilder.loadTexts: pvcBackupCall_s.setDescription('Delay, in seconds, before activating the backup PVC when a line failure has occurred on a dedicated link or PVC.')
pvcBackupHang_s = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 10, 2, 1, 35), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setLabel("pvcBackupHang-s").setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvcBackupHang_s.setStatus('mandatory')
if mibBuilder.loadTexts: pvcBackupHang_s.setDescription('Delay, in seconds, before deactivating the backup WAN PVC after the dedicated link or PVC has been restored.')
pvcBackup = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 10, 2, 1, 36), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(15, 16, 254, 255))).clone(namedValues=NamedValues(("any", 15), ("all", 16), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvcBackup.setStatus('mandatory')
if mibBuilder.loadTexts: pvcBackup.setDescription('Backup PVC can be configured to monitor and backup any link or PCV that fails (ANY) or all links and PVCs (ALL).')
pvcOspfEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 10, 2, 1, 37), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvcOspfEnable.setStatus('mandatory')
if mibBuilder.loadTexts: pvcOspfEnable.setDescription('Indicates whether or not OSPF is enabled on this PVC.')
pvcOspfAreaId = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 10, 2, 1, 38), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvcOspfAreaId.setStatus('mandatory')
if mibBuilder.loadTexts: pvcOspfAreaId.setDescription('Identifies the area to which this PVC belongs.')
pvcOspfTransitDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 10, 2, 1, 39), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 360))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvcOspfTransitDelay.setStatus('mandatory')
if mibBuilder.loadTexts: pvcOspfTransitDelay.setDescription('The estimated number of seconds it takes to transmit a Link State Update Packet over this PVC.')
pvcOspfRetransmitInt = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 10, 2, 1, 40), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 360))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvcOspfRetransmitInt.setStatus('mandatory')
if mibBuilder.loadTexts: pvcOspfRetransmitInt.setDescription('The number of seconds between like state advertisement retransmissions for adjacencies belonging to this PVC. Also used when retransmitting Database Description and Link State Request Packets.')
pvcOspfHelloInt = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 10, 2, 1, 41), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 360))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvcOspfHelloInt.setStatus('mandatory')
if mibBuilder.loadTexts: pvcOspfHelloInt.setDescription("The length of time, in seconds, between the Hello Packets that the router sends on the PVC. This value is advertised in the router's Hello Packets. It must be the same for all routers attached to a common network. The smaller the HelloInterval, the faster topological changes will be detected, but more OSPF routing protocol traffic will ensue.")
pvcOspfDeadInt = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 10, 2, 1, 42), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvcOspfDeadInt.setStatus('mandatory')
if mibBuilder.loadTexts: pvcOspfDeadInt.setDescription("After ceasing to hear a router's Hello Packets, the number of seconds before its neighbors declare the router down. This is also advertised in the router's Hello Packets in their RouterDeadInterval field. This value again bust be the same for all routers attached to a common network.")
pvcOspfPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 10, 2, 1, 43), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvcOspfPassword.setStatus('mandatory')
if mibBuilder.loadTexts: pvcOspfPassword.setDescription('This configured data allows the authentication procedure to generate and/or verify the authentication field in the OSPF header. This value again must be the same for all routers attached to a common network.')
pvcOspfMetricCost = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 10, 2, 1, 44), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65534))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvcOspfMetricCost.setStatus('mandatory')
if mibBuilder.loadTexts: pvcOspfMetricCost.setDescription("The cost of sending a packet on the PVC expressed in the link state metric. This is advertised as the link cost for this PVC in the router's router links advertisement.")
pvcProxyAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 10, 2, 1, 45), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvcProxyAddr.setStatus('mandatory')
if mibBuilder.loadTexts: pvcProxyAddr.setDescription('This variable indicates in what slot of the remote unit (i.e. the SDM-RX unit where this pvc goes) is the SNMP/NMS proxy agent board ')
pvcLlcConnection = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 10, 2, 1, 46), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("no", 1), ("yes", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvcLlcConnection.setStatus('mandatory')
if mibBuilder.loadTexts: pvcLlcConnection.setDescription('IPX connection. Set this parameter to YES if the RFC1490-compatible FRAD at the remote end requires bridge frames. If IPX data it not required, a NO value will prevent the transmission of unnecessary frames from this PVC, thus reducing your network costs.')
pvcDialTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 10, 2, 1, 47), Integer32().subtype(subtypeSpec=ValueRangeConstraint(30, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvcDialTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: pvcDialTimeout.setDescription('Wait time, in seconds, allowed to establish a backup pvc using a dial phone number')
pvcMaxChannels = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 10, 2, 1, 48), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvcMaxChannels.setStatus('mandatory')
if mibBuilder.loadTexts: pvcMaxChannels.setDescription('Indicates the maximum number of voice channels permitted on this PVC.')
pvcHuntForwardingAUnit = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 10, 2, 1, 49), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvcHuntForwardingAUnit.setStatus('mandatory')
if mibBuilder.loadTexts: pvcHuntForwardingAUnit.setDescription('Hunt forwarding group A Unit name. Unit name where a busy call for hunt group A will be forwarded to')
pvcHuntForwardingBUnit = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 10, 2, 1, 50), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvcHuntForwardingBUnit.setStatus('mandatory')
if mibBuilder.loadTexts: pvcHuntForwardingBUnit.setDescription('Hunt forwarding group B Unit name. Unit name where a busy call for hunt group B will be forwarded to')
pvcRemoteFpUnit = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 10, 2, 1, 51), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvcRemoteFpUnit.setStatus('mandatory')
if mibBuilder.loadTexts: pvcRemoteFpUnit.setDescription('Remote FP unit to which data from this PVC should be directed.')
pvcIpRipTxRx = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 10, 2, 1, 52), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 254, 255))).clone(namedValues=NamedValues(("duplex", 1), ("tx-only", 2), ("rx-only", 3), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvcIpRipTxRx.setStatus('mandatory')
if mibBuilder.loadTexts: pvcIpRipTxRx.setDescription('This parameter allows RIP frames transmission only, RIP frames reception only or both transmission and reception of RIP frames.')
pvcIpRipAuthType = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 10, 2, 1, 53), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("none", 1), ("simple", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvcIpRipAuthType.setStatus('mandatory')
if mibBuilder.loadTexts: pvcIpRipAuthType.setDescription('Enable or disable password authentication for the interface. If you select Simple Password, the password will be included in the sent RIP frames. The received frames containing authentication will be accepted only if the password is valid.')
pvcIpRipPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 10, 2, 1, 54), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvcIpRipPassword.setStatus('mandatory')
if mibBuilder.loadTexts: pvcIpRipPassword.setDescription('This configured data allows the authentication procedure to generate and/or verify the authentication field in the RIP header. This value again must be the same for each interface on each side of the link.')
ipxRouterEnable = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 11, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxRouterEnable.setStatus('mandatory')
if mibBuilder.loadTexts: ipxRouterEnable.setDescription('This variable defines the state of IPX Router (enable or disable) . If IPX Router parameter is enable, the unit will Route all IPX frames between different IPX networks which unit is connected to, otherwise, all IPX frames will be bridged (if BRIDGE is enable) or discarded (if not).')
ipxInternalNetNum = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 11, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxInternalNetNum.setStatus('mandatory')
if mibBuilder.loadTexts: ipxInternalNetNum.setDescription('This value identify the IPX internal network number. This value is used on unnumbered links.')
ipRouterEnable = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 14, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipRouterEnable.setStatus('mandatory')
if mibBuilder.loadTexts: ipRouterEnable.setDescription('This variable defines the state of IP Router (enable or disable) . If IP Router parameter is enable, the unit will Route IP frames between different IP networks which unit is connected to, otherwise, all IP frames will be bridged (if BRIDGE is enable) or discarded (if not).')
bootpEnable = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 33, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bootpEnable.setStatus('mandatory')
if mibBuilder.loadTexts: bootpEnable.setDescription('This variable defines the state of the BOOTP protocol If the BOOTP protocol is enable, the unit will act as a BOOTP/DHCP relay agent by forwarding the BOOTP/DHCP frame.')
bootpMaxHops = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 33, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bootpMaxHops.setStatus('mandatory')
if mibBuilder.loadTexts: bootpMaxHops.setDescription('Number maximum of BOOTP relay agent a frame could cross before being discarded')
bootpIpDestAddr1 = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 33, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bootpIpDestAddr1.setStatus('mandatory')
if mibBuilder.loadTexts: bootpIpDestAddr1.setDescription('The Destination IP address 1 - The IP address of the next BOOTP relay agent or server. When a BOOTREQUEST frame is received, this is where the frame is forwarded. Note: When all the Destination IP addresses are 0.0.0.0, BOOTP is in BROADCAST MODE (see documentation).')
bootpIpDestAddr2 = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 33, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bootpIpDestAddr2.setStatus('mandatory')
if mibBuilder.loadTexts: bootpIpDestAddr2.setDescription('The Destination IP address 2 - The IP address of the next BOOTP relay agent or server. When a BOOTREQUEST frame is received, this is where the frame is forwarded. Note: When all the Destination IP addresses are 0.0.0.0, BOOTP is in BROADCAST MODE (see documentation).')
bootpIpDestAddr3 = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 33, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bootpIpDestAddr3.setStatus('mandatory')
if mibBuilder.loadTexts: bootpIpDestAddr3.setDescription('The Destination IP address 3 - The IP address of the next BOOTP relay agent or server. When a BOOTREQUEST frame is received, this is where the frame is forwarded. Note: When all the Destination IP addresses are 0.0.0.0, BOOTP is in BROADCAST MODE (see documentation).')
bootpIpDestAddr4 = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 33, 6), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bootpIpDestAddr4.setStatus('mandatory')
if mibBuilder.loadTexts: bootpIpDestAddr4.setDescription('The Destination IP address 4 - The IP address of the next BOOTP relay agent or server. When a BOOTREQUEST frame is received, this is where the frame is forwarded. Note: When all the Destination IP addresses are 0.0.0.0, BOOTP is in BROADCAST MODE (see documentation).')
timepTimeZoneSign = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 35, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: timepTimeZoneSign.setStatus('mandatory')
if mibBuilder.loadTexts: timepTimeZoneSign.setDescription('Time zone offset sign. YES means negative')
timepTimeZone = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 35, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 720))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: timepTimeZone.setStatus('mandatory')
if mibBuilder.loadTexts: timepTimeZone.setDescription('Time offset from GMT (in minutes).')
timepDaylightSaving = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 35, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: timepDaylightSaving.setStatus('mandatory')
if mibBuilder.loadTexts: timepDaylightSaving.setDescription('Enable daylight saving time (one hour).')
timepServerProtocol = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 35, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("udp", 2), ("tcp", 3), ("both", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: timepServerProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: timepServerProtocol.setDescription('Protocols supported by the time server.')
timepClientProtocol = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 35, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("udp", 2), ("tcp", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: timepClientProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: timepClientProtocol.setDescription('Protocols used by the time client.')
timepServerIpAddress = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 35, 6), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: timepServerIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: timepServerIpAddress.setDescription('IP address of time client server.')
timepClientUpdateInterval = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 35, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65534))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: timepClientUpdateInterval.setStatus('mandatory')
if mibBuilder.loadTexts: timepClientUpdateInterval.setDescription('Time client update interval (in minutes).')
timepClientUdpTimeout = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 35, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65534))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: timepClientUdpTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: timepClientUdpTimeout.setDescription('Time client UDP timeout (in seconds).')
timepClientUdpRetransmissions = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 35, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65534))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: timepClientUdpRetransmissions.setStatus('mandatory')
if mibBuilder.loadTexts: timepClientUdpRetransmissions.setDescription('Time client UDP retransmissions.')
timepGetServerTimeNow = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 35, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: timepGetServerTimeNow.setStatus('mandatory')
if mibBuilder.loadTexts: timepGetServerTimeNow.setDescription('Get time from time server. Do not wait for update timer to expire. Time client must be enabled and time server must be on line. If everything is up, it will take approximately 60 seconds before the time is updated')
ipstaticNumber = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 13, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipstaticNumber.setStatus('mandatory')
if mibBuilder.loadTexts: ipstaticNumber.setDescription('The number of IP static entries present on this system.')
ipstaticTable = MibTable((1, 3, 6, 1, 4, 1, 727, 7, 2, 13, 2), )
if mibBuilder.loadTexts: ipstaticTable.setStatus('mandatory')
if mibBuilder.loadTexts: ipstaticTable.setDescription('A list of IP static entries. The number of entries is given by the value of ipstaticNumber.')
ipstaticEntry = MibTableRow((1, 3, 6, 1, 4, 1, 727, 7, 2, 13, 2, 1), ).setIndexNames((0, "PRESTICOM7-MIB", "ipstaticIndex"))
if mibBuilder.loadTexts: ipstaticEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ipstaticEntry.setDescription('This table contains the principal configurable parameters who are used for a particular IP static entry.')
ipstaticIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 13, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipstaticIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ipstaticIndex.setDescription('A unique value for each entry. Its value ranges between 1 and the value of ipstaticNumber.')
ipstaticValid = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 13, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("no", 1), ("yes", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipstaticValid.setStatus('mandatory')
if mibBuilder.loadTexts: ipstaticValid.setDescription('Sets the activation status of the entry.')
ipstaticIpDest = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 13, 2, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipstaticIpDest.setStatus('mandatory')
if mibBuilder.loadTexts: ipstaticIpDest.setDescription('The destination IP address which we want include in the address table (e.g. RIP table)')
ipstaticMask = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 13, 2, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipstaticMask.setStatus('mandatory')
if mibBuilder.loadTexts: ipstaticMask.setDescription('The destination IP address mask.')
ipstaticNextHop = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 13, 2, 1, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipstaticNextHop.setStatus('mandatory')
if mibBuilder.loadTexts: ipstaticNextHop.setDescription('The IP address of the next hop to reach the destination IP address specified.')
ospfGlobal = MibIdentifier((1, 3, 6, 1, 4, 1, 727, 7, 2, 15, 1))
ospfArea = MibIdentifier((1, 3, 6, 1, 4, 1, 727, 7, 2, 15, 2))
ospfRange = MibIdentifier((1, 3, 6, 1, 4, 1, 727, 7, 2, 15, 3))
ospfVLink = MibIdentifier((1, 3, 6, 1, 4, 1, 727, 7, 2, 15, 4))
ospfGlobalRouterId = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 15, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospfGlobalRouterId.setStatus('mandatory')
if mibBuilder.loadTexts: ospfGlobalRouterId.setDescription('This is a 32-bit number that uniquely identifies the router in the Autonomous System.')
ospfGlobalAutoVLink = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 15, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("no", 1), ("yes", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospfGlobalAutoVLink.setStatus('mandatory')
if mibBuilder.loadTexts: ospfGlobalAutoVLink.setDescription('Indicates if virtual links can be configured automatically or not.')
ospfGlobalRackAreaId = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 15, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospfGlobalRackAreaId.setStatus('mandatory')
if mibBuilder.loadTexts: ospfGlobalRackAreaId.setDescription('Identifies the area to which the backplane belongs. Valid only on rack products.')
ospfGlobalGlobalAreaId = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 15, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospfGlobalGlobalAreaId.setStatus('mandatory')
if mibBuilder.loadTexts: ospfGlobalGlobalAreaId.setDescription("This parameter identifies the area to which the NetPerformer's global Default IP Address belongs.")
ospfAreaNumber = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 15, 2, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaNumber.setStatus('mandatory')
if mibBuilder.loadTexts: ospfAreaNumber.setDescription('The number of areas present on this system.')
ospfAreaTable = MibTable((1, 3, 6, 1, 4, 1, 727, 7, 2, 15, 2, 2), )
if mibBuilder.loadTexts: ospfAreaTable.setStatus('mandatory')
if mibBuilder.loadTexts: ospfAreaTable.setDescription('A list of areas. The number of areas is given by the value of ospfAreaNumber.')
ospfAreaEntry = MibTableRow((1, 3, 6, 1, 4, 1, 727, 7, 2, 15, 2, 2, 1), ).setIndexNames((0, "PRESTICOM7-MIB", "ospfAreaIndex"))
if mibBuilder.loadTexts: ospfAreaEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ospfAreaEntry.setDescription('This table contains the principal configurable parameters who are used for a particular area.')
ospfAreaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 15, 2, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ospfAreaIndex.setDescription('A unique value for each entry. Its value ranges between 1 and the value of ospfAreaNumber.')
ospfAreaAreaId = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 15, 2, 2, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospfAreaAreaId.setStatus('mandatory')
if mibBuilder.loadTexts: ospfAreaAreaId.setDescription('This is a 32-bit number that identifies the area. The Area ID of 0.0.0.0 is reserved for the backbone.')
ospfAreaEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 15, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospfAreaEnable.setStatus('mandatory')
if mibBuilder.loadTexts: ospfAreaEnable.setDescription('Allows you to enable and disable this area.')
ospfAreaAuthType = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 15, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("none", 1), ("simple", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospfAreaAuthType.setStatus('mandatory')
if mibBuilder.loadTexts: ospfAreaAuthType.setDescription('Enables or disables password authentication for the area. If you select Simple Password, only those routers sharing the correct password will be able to communicate with each other.')
ospfAreaImportASExt = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 15, 2, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("no", 1), ("yes", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospfAreaImportASExt.setStatus('mandatory')
if mibBuilder.loadTexts: ospfAreaImportASExt.setDescription('Indicates whether or not this area imports AS external link state advertisements. If AS external advertisements are excluded from the area, the area is called a stub. The backbone cannot be configured as a stub area. Also, virtual links cannot be configured through stub areas.')
ospfAreaStubMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 15, 2, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospfAreaStubMetric.setStatus('mandatory')
if mibBuilder.loadTexts: ospfAreaStubMetric.setDescription('If the area has been configured as a stub area, and the router itself is an area border router, then the StubMetric indicates the cost of the default summary link that the router should advertise into the area.')
ospfRangeNumber = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 15, 3, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfRangeNumber.setStatus('mandatory')
if mibBuilder.loadTexts: ospfRangeNumber.setDescription('The number of ranges present on this system.')
ospfRangeTable = MibTable((1, 3, 6, 1, 4, 1, 727, 7, 2, 15, 3, 2), )
if mibBuilder.loadTexts: ospfRangeTable.setStatus('mandatory')
if mibBuilder.loadTexts: ospfRangeTable.setDescription('A list of ranges. The number of ranges is given by the value of ospfRangeNumber.')
ospfRangeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 727, 7, 2, 15, 3, 2, 1), ).setIndexNames((0, "PRESTICOM7-MIB", "ospfRangeIndex"))
if mibBuilder.loadTexts: ospfRangeEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ospfRangeEntry.setDescription('This table contains the principal configurable parameters who are used for a particular range.')
ospfRangeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 15, 3, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfRangeIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ospfRangeIndex.setDescription('A unique value for each entry. Its value ranges between 1 and the value of ospfRangeNumber.')
ospfRangeNet = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 15, 3, 2, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospfRangeNet.setStatus('mandatory')
if mibBuilder.loadTexts: ospfRangeNet.setDescription('Describes the collection of Ip addresses contained in the address range. This network address, together with the range mask parameter, specifies the subnets to be grouped in this area range. Just one link summary advertisement will be generated for all subnets in this range.')
ospfRangeMask = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 15, 3, 2, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospfRangeMask.setStatus('mandatory')
if mibBuilder.loadTexts: ospfRangeMask.setDescription('This parameter, together with Range Net, indicates all of the networks that belong to this range.')
ospfRangeEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 15, 3, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospfRangeEnable.setStatus('mandatory')
if mibBuilder.loadTexts: ospfRangeEnable.setDescription('Enables or disables this range for the specified area.')
ospfRangeStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 15, 3, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("don-t-adv", 1), ("advertise", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospfRangeStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ospfRangeStatus.setDescription('Set to either Advertise or DoNotAdvertise. Unadvertised ranges allow the existence of certain networks to be intentionally hidden from other areas. Status is set to Advertise by default.')
ospfRangeAddToArea = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 15, 3, 2, 1, 6), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospfRangeAddToArea.setStatus('mandatory')
if mibBuilder.loadTexts: ospfRangeAddToArea.setDescription('The area ID that identifies the area to which this range belongs.')
ospfVLinkNumber = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 15, 4, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfVLinkNumber.setStatus('mandatory')
if mibBuilder.loadTexts: ospfVLinkNumber.setDescription('The number of virtual links present on this system.')
ospfVLinkTable = MibTable((1, 3, 6, 1, 4, 1, 727, 7, 2, 15, 4, 2), )
if mibBuilder.loadTexts: ospfVLinkTable.setStatus('mandatory')
if mibBuilder.loadTexts: ospfVLinkTable.setDescription('A list of virtual links. The number of virtual links is given by the value of ospfVLinkNumber.')
ospfVLinkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 727, 7, 2, 15, 4, 2, 1), ).setIndexNames((0, "PRESTICOM7-MIB", "ospfVLinkIndex"))
if mibBuilder.loadTexts: ospfVLinkEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ospfVLinkEntry.setDescription('This table contains the principal configurable parameters who are used for a particular vlink.')
ospfVLinkIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 15, 4, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfVLinkIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ospfVLinkIndex.setDescription('A unique value for each entry. Its value ranges between 1 and the value of ospfVLinkNumber.')
ospfVLinkTransitAreaId = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 15, 4, 2, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospfVLinkTransitAreaId.setStatus('mandatory')
if mibBuilder.loadTexts: ospfVLinkTransitAreaId.setDescription('Identifies the transit area ID through which the virtual link is configured.')
ospfVLinkNeighborRtrId = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 15, 4, 2, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospfVLinkNeighborRtrId.setStatus('mandatory')
if mibBuilder.loadTexts: ospfVLinkNeighborRtrId.setDescription('Indicates the neighbor router ID at the other end of this virtual link.')
ospfVLinkEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 15, 4, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254, 255))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospfVLinkEnable.setStatus('mandatory')
if mibBuilder.loadTexts: ospfVLinkEnable.setDescription('Enables or disables this virtual link.')
ospfVLinkTransitDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 15, 4, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 360))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospfVLinkTransitDelay.setStatus('mandatory')
if mibBuilder.loadTexts: ospfVLinkTransitDelay.setDescription('The estimated number of seconds it takes to transmit a Link State Update Packet over this interface.')
ospfVLinkRetransmitInt = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 15, 4, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 360))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospfVLinkRetransmitInt.setStatus('mandatory')
if mibBuilder.loadTexts: ospfVLinkRetransmitInt.setDescription('The number of seconds between like state advertisement retransmissions for adjacencies belonging to this interface. Also used when retransmitting Database Description and Link State Request Packets.')
ospfVLinkHelloInt = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 15, 4, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 360))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospfVLinkHelloInt.setStatus('mandatory')
if mibBuilder.loadTexts: ospfVLinkHelloInt.setDescription("The length of time, in seconds, between the Hello Packets that the router sends on the interface. This value is advertised in the router's Hello Packets. It must be the same for all routers attached to a common network. The smaller the HelloInterval, the faster topological changes will be detected, but more OSPF routing protocol traffic will ensue.")
ospfVLinkDeadInt = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 15, 4, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospfVLinkDeadInt.setStatus('mandatory')
if mibBuilder.loadTexts: ospfVLinkDeadInt.setDescription("After ceasing to hear a router's Hello Packets, the number of seconds before its neighbors declare the router down. This is also advertised in the router's Hello Packets in their RouterDeadInterval field. This value again bust be the same for all routers attached to a common network.")
ospfVLinkPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 15, 4, 2, 1, 9), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospfVLinkPassword.setStatus('mandatory')
if mibBuilder.loadTexts: ospfVLinkPassword.setDescription('This configured data allows the authentication procedure to generate and/or verify the authentication field in the OSPF header. This value again must be the same for all routers attached to a common network.')
ipxfilterNumber = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 16, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxfilterNumber.setStatus('mandatory')
if mibBuilder.loadTexts: ipxfilterNumber.setDescription('The number of IPX filter entries present on this system.')
ipxfilterTable = MibTable((1, 3, 6, 1, 4, 1, 727, 7, 2, 16, 2), )
if mibBuilder.loadTexts: ipxfilterTable.setStatus('mandatory')
if mibBuilder.loadTexts: ipxfilterTable.setDescription('A list of IPX filter entries. The number of entries is given by the value of ipxfilterNumber.')
ipxfilterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 727, 7, 2, 16, 2, 1), ).setIndexNames((0, "PRESTICOM7-MIB", "ipxfilterIndex"))
if mibBuilder.loadTexts: ipxfilterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ipxfilterEntry.setDescription('This table contains the principal configurable parameters which are used for a particular IP filter entry.')
ipxfilterIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 16, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxfilterIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ipxfilterIndex.setDescription('A unique value for each entry. Its value ranges between 1 and the value of ipxfilterNumber.')
ipxfilterEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 16, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxfilterEnable.setStatus('mandatory')
if mibBuilder.loadTexts: ipxfilterEnable.setDescription('This variable defines the state of IPX filter (enable or disable). If IPX filter parameter is enable, the unit will filter IPX SAP entries for the SAP given.')
ipxfilterSap = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 16, 2, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxfilterSap.setStatus('mandatory')
if mibBuilder.loadTexts: ipxfilterSap.setDescription('This variable defines the SAP value to be filtered.')
ipxfilterType = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 16, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("standard", 1), ("reverse", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxfilterType.setStatus('mandatory')
if mibBuilder.loadTexts: ipxfilterType.setDescription('This variable defines how apply the filter. If type is standard, the SAP configured is filtered. If type is reverse, all SAPs except the one configured is filtered.')
statAlarmTable = MibTable((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 1), )
if mibBuilder.loadTexts: statAlarmTable.setStatus('mandatory')
if mibBuilder.loadTexts: statAlarmTable.setDescription('The list of alarms for the system. The number of entries is given by the value of StatAlarmNumber.')
statAlarmEntry = MibTableRow((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 1, 1), ).setIndexNames((0, "PRESTICOM7-MIB", "statAlarmIndex"))
if mibBuilder.loadTexts: statAlarmEntry.setStatus('mandatory')
if mibBuilder.loadTexts: statAlarmEntry.setDescription('This table contains the list of alarms arrived on the system.')
statAlarmIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statAlarmIndex.setStatus('mandatory')
if mibBuilder.loadTexts: statAlarmIndex.setDescription('A unique value for each alarm. Its value ranges between 1 and the value of statAlarmNumber.')
statAlarmDesc = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statAlarmDesc.setStatus('mandatory')
if mibBuilder.loadTexts: statAlarmDesc.setDescription('This variable contains a printable octet string which, if available, gives a short description of the alarm.')
statAlarmDate = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 1, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statAlarmDate.setStatus('mandatory')
if mibBuilder.loadTexts: statAlarmDate.setDescription('The date of the alarm.')
statAlarmTime = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 1, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statAlarmTime.setStatus('mandatory')
if mibBuilder.loadTexts: statAlarmTime.setDescription('The time of the alarm.')
statAlarmModule = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statAlarmModule.setStatus('mandatory')
if mibBuilder.loadTexts: statAlarmModule.setDescription('The module who has detected the alarm.')
statAlarmAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statAlarmAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: statAlarmAlarm.setDescription('The name of the alarm.')
statAlarmArg = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statAlarmArg.setStatus('mandatory')
if mibBuilder.loadTexts: statAlarmArg.setDescription('An argument permitting to detect the reason of the alarm')
statIfwanTable = MibTable((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 2), )
if mibBuilder.loadTexts: statIfwanTable.setStatus('mandatory')
if mibBuilder.loadTexts: statIfwanTable.setDescription('A list of statistic entries for the wan interfaces. The number of entries is given by the value of ifwanNumber.')
statIfwanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 2, 1), ).setIndexNames((0, "PRESTICOM7-MIB", "statIfwanIndex"))
if mibBuilder.loadTexts: statIfwanEntry.setStatus('mandatory')
if mibBuilder.loadTexts: statIfwanEntry.setDescription('This table contains the principal statistics for the wan interfaces.')
statIfwanIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statIfwanIndex.setStatus('mandatory')
if mibBuilder.loadTexts: statIfwanIndex.setDescription('A unique value for each interface.')
statIfwanDesc = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 2, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statIfwanDesc.setStatus('mandatory')
if mibBuilder.loadTexts: statIfwanDesc.setDescription('A textual string containing information about a specific interface.')
statIfwanProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 17, 18, 19, 24, 27, 28, 29, 254, 255))).clone(namedValues=NamedValues(("off", 1), ("p-sdlc", 2), ("s-sdlc", 3), ("hdlc", 4), ("ddcmp", 5), ("t-async", 6), ("r-async", 7), ("bsc", 8), ("cop", 9), ("pvcr", 10), ("passthru", 11), ("console", 12), ("fr-net", 17), ("fr-user", 18), ("ppp", 19), ("e1-trsp", 24), ("isdn-bri", 27), ("g703", 28), ("x25", 29), ("not-applicable", 254), ("not-available", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statIfwanProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: statIfwanProtocol.setDescription('The operating mode of the wan interface.')
statIfwanInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 2, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statIfwanInterface.setStatus('mandatory')
if mibBuilder.loadTexts: statIfwanInterface.setDescription('The actual interface used on the port.')
statIfwanModemSignal = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 2, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statIfwanModemSignal.setStatus('mandatory')
if mibBuilder.loadTexts: statIfwanModemSignal.setDescription('This variable contains the modem signal status.')
statIfwanSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statIfwanSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: statIfwanSpeed.setDescription('This variable contains the speed measured by the system.')
statIfwanState = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 2, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statIfwanState.setStatus('mandatory')
if mibBuilder.loadTexts: statIfwanState.setDescription('This variable contains the status of the port.')
statIfwanMeanTx = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 2, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statIfwanMeanTx.setStatus('mandatory')
if mibBuilder.loadTexts: statIfwanMeanTx.setDescription('This variable contains the average line usage for transmissions on the wan port.')
statIfwanMeanRx = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 2, 1, 9), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statIfwanMeanRx.setStatus('mandatory')
if mibBuilder.loadTexts: statIfwanMeanRx.setDescription('This variable contains the average line usage for data received on the wan port.')
statIfwanPeakTx = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 2, 1, 10), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statIfwanPeakTx.setStatus('mandatory')
if mibBuilder.loadTexts: statIfwanPeakTx.setDescription('This variable contains the maximum line usage for transmissions on the wan port.')
statIfwanPeakRx = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 2, 1, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statIfwanPeakRx.setStatus('mandatory')
if mibBuilder.loadTexts: statIfwanPeakRx.setDescription('This variable contains the maximum line usage for data received on the wan port.')
statIfwanBadFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statIfwanBadFrames.setStatus('mandatory')
if mibBuilder.loadTexts: statIfwanBadFrames.setDescription('The number of bad frames received.')
statIfwanBadFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 2, 1, 13), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statIfwanBadFlags.setStatus('mandatory')
if mibBuilder.loadTexts: statIfwanBadFlags.setDescription('These flags are to find the reason of bad frames received. U : Bad length Q : Overflow F : Flush S : Overrun B : Bad CRC A : Abort')
statIfwanUnderruns = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statIfwanUnderruns.setStatus('mandatory')
if mibBuilder.loadTexts: statIfwanUnderruns.setDescription('The number of underruns.')
statIfwanRetries = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statIfwanRetries.setStatus('mandatory')
if mibBuilder.loadTexts: statIfwanRetries.setDescription('The number of retries is incremented when there is a retransmission between the system and the controller or host.')
statIfwanRestart = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 2, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statIfwanRestart.setStatus('mandatory')
if mibBuilder.loadTexts: statIfwanRestart.setDescription('The number of restarts. For a user port this counter is incremented every time an error on the link caused the port to restart. These errors occur over the link, not between equipment. The number of restarts is not calculated for user ports in P-SDLC or S-SDLC.')
statIfwanFramesTx = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 2, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statIfwanFramesTx.setStatus('mandatory')
if mibBuilder.loadTexts: statIfwanFramesTx.setDescription('The number of frames transmitted')
statIfwanFramesRx = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 2, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statIfwanFramesRx.setStatus('mandatory')
if mibBuilder.loadTexts: statIfwanFramesRx.setDescription('The number of frames received')
statIfwanOctetsTx = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 2, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statIfwanOctetsTx.setStatus('mandatory')
if mibBuilder.loadTexts: statIfwanOctetsTx.setDescription('The number of octets transmitted')
statIfwanOctetsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 2, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statIfwanOctetsRx.setStatus('mandatory')
if mibBuilder.loadTexts: statIfwanOctetsRx.setDescription('The number of octets received')
statIfwanOvrFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 2, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statIfwanOvrFrames.setStatus('mandatory')
if mibBuilder.loadTexts: statIfwanOvrFrames.setDescription('The number of frames received and deleted because the input queue is full.')
statIfwanBadOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 2, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statIfwanBadOctets.setStatus('mandatory')
if mibBuilder.loadTexts: statIfwanBadOctets.setDescription('The number of characters received and deleted because of a bad frame.')
statIfwanOvrOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 2, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statIfwanOvrOctets.setStatus('mandatory')
if mibBuilder.loadTexts: statIfwanOvrOctets.setDescription('The number of characters received and deleted because the input queue is full.')
statIfwanT1E1ESS = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 2, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statIfwanT1E1ESS.setStatus('mandatory')
if mibBuilder.loadTexts: statIfwanT1E1ESS.setDescription('The number of ESS')
statIfwanT1E1SES = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 2, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statIfwanT1E1SES.setStatus('mandatory')
if mibBuilder.loadTexts: statIfwanT1E1SES.setDescription('The number of SES')
statIfwanT1E1SEF = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 2, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statIfwanT1E1SEF.setStatus('mandatory')
if mibBuilder.loadTexts: statIfwanT1E1SEF.setDescription('The number of SEF')
statIfwanT1E1UAS = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 2, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statIfwanT1E1UAS.setStatus('mandatory')
if mibBuilder.loadTexts: statIfwanT1E1UAS.setDescription('+The number of UAS')
statIfwanT1E1CSS = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 2, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statIfwanT1E1CSS.setStatus('mandatory')
if mibBuilder.loadTexts: statIfwanT1E1CSS.setDescription('The number of CSS')
statIfwanT1E1PCV = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 2, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statIfwanT1E1PCV.setStatus('mandatory')
if mibBuilder.loadTexts: statIfwanT1E1PCV.setDescription('The number of PCV')
statIfwanT1E1LES = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 2, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statIfwanT1E1LES.setStatus('mandatory')
if mibBuilder.loadTexts: statIfwanT1E1LES.setDescription('The number of LES')
statIfwanT1E1BES = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 2, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statIfwanT1E1BES.setStatus('mandatory')
if mibBuilder.loadTexts: statIfwanT1E1BES.setDescription('The number of BES')
statIfwanT1E1DM = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 2, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statIfwanT1E1DM.setStatus('mandatory')
if mibBuilder.loadTexts: statIfwanT1E1DM.setDescription('The number of DM')
statIfwanT1E1LCV = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 2, 1, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statIfwanT1E1LCV.setStatus('mandatory')
if mibBuilder.loadTexts: statIfwanT1E1LCV.setDescription('The number of LCV')
statIfwanCompErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 2, 1, 34), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statIfwanCompErrs.setStatus('mandatory')
if mibBuilder.loadTexts: statIfwanCompErrs.setDescription('The number of compression errors')
statIfwanChOverflows = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 2, 1, 35), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statIfwanChOverflows.setStatus('mandatory')
if mibBuilder.loadTexts: statIfwanChOverflows.setDescription('The number of channel overflows')
statIfwanChAborts = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 2, 1, 36), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statIfwanChAborts.setStatus('mandatory')
if mibBuilder.loadTexts: statIfwanChAborts.setDescription('The number of frames aborted received')
statIfwanChSeqErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 2, 1, 37), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statIfwanChSeqErrs.setStatus('mandatory')
if mibBuilder.loadTexts: statIfwanChSeqErrs.setDescription('The number of frames reception failure due to at least one missing block')
statIfwanDropInsert = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 2, 1, 38), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statIfwanDropInsert.setStatus('mandatory')
if mibBuilder.loadTexts: statIfwanDropInsert.setDescription('Drop and Insert status.')
statIfwanTrspState = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 2, 1, 39), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statIfwanTrspState.setStatus('mandatory')
if mibBuilder.loadTexts: statIfwanTrspState.setDescription('Indicates the current logical state of the port.')
statIfwanTrspLastError = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 2, 1, 40), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statIfwanTrspLastError.setStatus('mandatory')
if mibBuilder.loadTexts: statIfwanTrspLastError.setDescription('The last error occurred for this port.')
statIfwanQ922State = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 2, 1, 41), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statIfwanQ922State.setStatus('mandatory')
if mibBuilder.loadTexts: statIfwanQ922State.setDescription("Q922 state of the port if SVC's are enabled. Only on FR-USER ports.")
statIflanTable = MibTable((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 3), )
if mibBuilder.loadTexts: statIflanTable.setStatus('mandatory')
if mibBuilder.loadTexts: statIflanTable.setDescription('A list of statistic entries for the lan interfaces. The number of entries is given by the value of iflanNumber.')
statIflanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 3, 1), ).setIndexNames((0, "PRESTICOM7-MIB", "statIflanIndex"))
if mibBuilder.loadTexts: statIflanEntry.setStatus('mandatory')
if mibBuilder.loadTexts: statIflanEntry.setDescription('This table contains the principal statistics for the lan interfaces.')
statIflanIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statIflanIndex.setStatus('mandatory')
if mibBuilder.loadTexts: statIflanIndex.setDescription('A unique value for each interface.')
statIflanProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 13, 14, 15, 16))).clone(namedValues=NamedValues(("off", 1), ("token-ring", 13), ("ethernet-auto", 14), ("ethernet-802p3", 15), ("ethernet-v2", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statIflanProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: statIflanProtocol.setDescription('The operating mode of the lan connection.')
statIflanSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("tr-4-Mbps", 1), ("tr-16-Mbps", 2), ("eth-10-Mbps", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statIflanSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: statIflanSpeed.setDescription('This variable contains the speed measured by the system.')
statIflanConnectionStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 3, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statIflanConnectionStatus.setStatus('mandatory')
if mibBuilder.loadTexts: statIflanConnectionStatus.setDescription('The logical connection status of the lan connection.')
statIflanOperatingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 3, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statIflanOperatingMode.setStatus('mandatory')
if mibBuilder.loadTexts: statIflanOperatingMode.setDescription('The operating mode of the lan connection.')
statIflanEth_Interface = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 3, 1, 6), DisplayString()).setLabel("statIflanEth-Interface").setMaxAccess("readonly")
if mibBuilder.loadTexts: statIflanEth_Interface.setStatus('mandatory')
if mibBuilder.loadTexts: statIflanEth_Interface.setDescription('The interface used by ethernet.')
statIflanMeanTx_kbps = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 3, 1, 7), Gauge32()).setLabel("statIflanMeanTx-kbps").setMaxAccess("readonly")
if mibBuilder.loadTexts: statIflanMeanTx_kbps.setStatus('mandatory')
if mibBuilder.loadTexts: statIflanMeanTx_kbps.setDescription('This is the average throughput for transmissions sent to the LAN.')
statIflanMeanRx_kbps = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 3, 1, 8), Gauge32()).setLabel("statIflanMeanRx-kbps").setMaxAccess("readonly")
if mibBuilder.loadTexts: statIflanMeanRx_kbps.setStatus('mandatory')
if mibBuilder.loadTexts: statIflanMeanRx_kbps.setDescription('This is the average throughput for data received from the LAN.')
statIflanPeakTx_kbps = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 3, 1, 9), Gauge32()).setLabel("statIflanPeakTx-kbps").setMaxAccess("readonly")
if mibBuilder.loadTexts: statIflanPeakTx_kbps.setStatus('mandatory')
if mibBuilder.loadTexts: statIflanPeakTx_kbps.setDescription('This is the maximum throughput for transmissions sent to the LAN.')
statIflanPeakRx_kbps = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 3, 1, 10), Gauge32()).setLabel("statIflanPeakRx-kbps").setMaxAccess("readonly")
if mibBuilder.loadTexts: statIflanPeakRx_kbps.setStatus('mandatory')
if mibBuilder.loadTexts: statIflanPeakRx_kbps.setDescription('This is the maximum throughput for data received from the LAN.')
statIflanRetries = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 3, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statIflanRetries.setStatus('mandatory')
if mibBuilder.loadTexts: statIflanRetries.setDescription('The number of retries is incremented when there is a retransmission between the system and the controller or host.')
statIflanBadFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 3, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statIflanBadFrames.setStatus('mandatory')
if mibBuilder.loadTexts: statIflanBadFrames.setDescription('The number of bad frames received.')
statIflanBadFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 3, 1, 13), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statIflanBadFlags.setStatus('mandatory')
if mibBuilder.loadTexts: statIflanBadFlags.setDescription('These flags are to find the reason of bad frames received. U : Bad length Q : Overflow F : Flush S : Overrun B : Bad CRC A : Abort')
statIflanTrReceiveCongestion = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 3, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statIflanTrReceiveCongestion.setStatus('mandatory')
if mibBuilder.loadTexts: statIflanTrReceiveCongestion.setDescription('This counter contains the number of times the receiver has overrun. Token-Ring only.')
statIflanEthOneCollision = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 3, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statIflanEthOneCollision.setStatus('mandatory')
if mibBuilder.loadTexts: statIflanEthOneCollision.setDescription('The number of one collision.')
statIflanEthTwoCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 3, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statIflanEthTwoCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: statIflanEthTwoCollisions.setDescription('The number of two collisions.')
statIflanEthThreeAndMoreCol = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 3, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statIflanEthThreeAndMoreCol.setStatus('mandatory')
if mibBuilder.loadTexts: statIflanEthThreeAndMoreCol.setDescription('The number of three and more collisions.')
statIflanEthDeferredTrans = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 3, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statIflanEthDeferredTrans.setStatus('mandatory')
if mibBuilder.loadTexts: statIflanEthDeferredTrans.setDescription('This counter contains the Number of frames deferred before transmission.')
statIflanEthExcessiveCollision = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 3, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statIflanEthExcessiveCollision.setStatus('mandatory')
if mibBuilder.loadTexts: statIflanEthExcessiveCollision.setDescription('Excessive collisions. This counter displays the number of frames aborted during transmission due to an excessive number of collisions. These are frames that have not been transmitted successfully.')
statIflanEthLateCollision = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 3, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statIflanEthLateCollision.setStatus('mandatory')
if mibBuilder.loadTexts: statIflanEthLateCollision.setDescription('Late collisions. This counter displays the number of transmit frames with late collision, that is, the number of times that a collision was detected later than 512 bits into the transmitted packet.')
statIflanEthFrameCheckSeq = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 3, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statIflanEthFrameCheckSeq.setStatus('mandatory')
if mibBuilder.loadTexts: statIflanEthFrameCheckSeq.setDescription('Frame check sequence errors. This counter displays the number of frames received on the Ethernet port with FCS errors.')
statIflanEthAlign = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 3, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statIflanEthAlign.setStatus('mandatory')
if mibBuilder.loadTexts: statIflanEthAlign.setDescription('Alignment errors. This counter displays the number of incomplete frames received on the Ethernet port that do not pass the CRC check.')
statIflanEthCarrierSense = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 3, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statIflanEthCarrierSense.setStatus('mandatory')
if mibBuilder.loadTexts: statIflanEthCarrierSense.setDescription('Carrier sense errors. This counter indicates the number of frames transmitted with carrier sense errors: either the carrier sense signal from the physical layer interface was not asserted, or it was unasserted during transmission of the frame without collision.')
statIfvceTable = MibTable((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 10), )
if mibBuilder.loadTexts: statIfvceTable.setStatus('mandatory')
if mibBuilder.loadTexts: statIfvceTable.setDescription('A list of statistic entries for the voice interfaces. The number of entries is given by the value of ifNumber.')
statIfvceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 10, 1), ).setIndexNames((0, "PRESTICOM7-MIB", "statIfvceIndex"))
if mibBuilder.loadTexts: statIfvceEntry.setStatus('mandatory')
if mibBuilder.loadTexts: statIfvceEntry.setDescription('This table contains the principal statistics for the voice interfaces.')
statIfvceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 10, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statIfvceIndex.setStatus('mandatory')
if mibBuilder.loadTexts: statIfvceIndex.setDescription('A unique value for each interface: the same value as the ifIndex in RFC1213 that refers to this voice port')
statIfvceDesc = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 10, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statIfvceDesc.setStatus('mandatory')
if mibBuilder.loadTexts: statIfvceDesc.setDescription('A textual string containing information about a specific interface.')
statIfvceState = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("inactive", 0), ("idle", 1), ("pause", 2), ("local", 3), ("online", 4), ("disconnect", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statIfvceState.setStatus('mandatory')
if mibBuilder.loadTexts: statIfvceState.setDescription('Indicates the current logical state of the port.')
statIfvceProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 21, 22, 23, 24, 26, 30))).clone(namedValues=NamedValues(("off", 1), ("acelp-8-kbs", 21), ("acelp-4-8-kbs", 22), ("pcm64k", 23), ("adpcm32k", 24), ("atc16k", 26), ("acelp-cn", 30)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statIfvceProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: statIfvceProtocol.setDescription('Indicates the current protocol setting the port.')
statIfvceLastError = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 10, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("none", 0), ("incompatibility", 1), ("new-parameters", 2), ("rerouting", 3), ("state-fault", 4), ("unreachable", 5), ("disconnect", 6), ("port-closure", 7), ("no-destination", 8), ("pvc-closure", 9), ("too-many-calls", 10), ("class-mismatch", 11), ("algo-mismatch", 12)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statIfvceLastError.setStatus('mandatory')
if mibBuilder.loadTexts: statIfvceLastError.setDescription('The last error occurred for this port.')
statIfvceFaxRate = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 0), ("fx-2-4Kbps", 1), ("fx-4-8Kbps", 2), ("fx-7-2Kbps", 3), ("fx-9-6Kbps", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statIfvceFaxRate.setStatus('mandatory')
if mibBuilder.loadTexts: statIfvceFaxRate.setDescription('Indicates the current voice compression rate. The possible rates are 4.8 Kbps and 8 Kbps.')
statIfvceFaxMode = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 10, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(255, 0, 1))).clone(namedValues=NamedValues(("none", 255), ("out-of-fax", 0), ("in-fax", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statIfvceFaxMode.setStatus('mandatory')
if mibBuilder.loadTexts: statIfvceFaxMode.setDescription('Indicates the current voice compression rate. The possible rates are 4.8 Kbps and 8 Kbps.')
statIfvceOverruns = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 10, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statIfvceOverruns.setStatus('mandatory')
if mibBuilder.loadTexts: statIfvceOverruns.setDescription('The number of receive overruns that have occurred. ')
statIfvceUnderruns = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 10, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statIfvceUnderruns.setStatus('mandatory')
if mibBuilder.loadTexts: statIfvceUnderruns.setDescription('The number of transmit underruns that have occurred.')
statIfvceDvcPortInUse = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 10, 1, 10), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statIfvceDvcPortInUse.setStatus('mandatory')
if mibBuilder.loadTexts: statIfvceDvcPortInUse.setDescription('Indicates the logical port number that is being used by an active voice connection. For CCS protocols such as QSIG, the E1/CCS card selects which DSP on which DVC card it will use for a connection. The logical port number corresponding to the DSP is reported to the NetPerformer baseboard, and comprises the value of the DVC Port In Use statistic. For slot 1 of the DVC card the possible values are 100 to 106, for slot 2 they are 200 to 206, and so on.')
statPuTable = MibTable((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 4), )
if mibBuilder.loadTexts: statPuTable.setStatus('mandatory')
if mibBuilder.loadTexts: statPuTable.setDescription('A list of statistic entries for the PUs. The number of entries is given by the value of puNumber.')
statPuEntry = MibTableRow((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 4, 1), ).setIndexNames((0, "PRESTICOM7-MIB", "statPuIndex"))
if mibBuilder.loadTexts: statPuEntry.setStatus('mandatory')
if mibBuilder.loadTexts: statPuEntry.setDescription('This table contains the principal statistics for the PUs.')
statPuIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statPuIndex.setStatus('mandatory')
if mibBuilder.loadTexts: statPuIndex.setDescription('A unique value for each PU. Its value ranges between 1 and the value of PuNumber.')
statPuMode = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("off", 1), ("sdlc-llc", 2), ("sdlc-sdlc", 3), ("sdlc-dlsw", 4), ("sdlc-links", 5), ("llc-dlsw", 6), ("llc-links", 7), ("dlsw-links", 8), ("sdlc-ban", 9), ("sdlc-bnn", 10), ("llc-ban", 11), ("llc-bnn", 12), ("dlsw-ban", 13), ("dlsw-bnn", 14), ("ban-link", 15), ("bnn-link", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statPuMode.setStatus('mandatory')
if mibBuilder.loadTexts: statPuMode.setDescription('The PU operating mode.')
statPuConnectionStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 4, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statPuConnectionStatus.setStatus('mandatory')
if mibBuilder.loadTexts: statPuConnectionStatus.setDescription('This variable contains the status of the connection as a whole.')
statPuCompErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 4, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statPuCompErrs.setStatus('mandatory')
if mibBuilder.loadTexts: statPuCompErrs.setDescription('The number of compression errors')
statPuChOverflows = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 4, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statPuChOverflows.setStatus('mandatory')
if mibBuilder.loadTexts: statPuChOverflows.setDescription('The number of channel overflows')
statPuChAborts = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 4, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statPuChAborts.setStatus('mandatory')
if mibBuilder.loadTexts: statPuChAborts.setDescription('The number of frames aborted received')
statPuChSeqErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 4, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statPuChSeqErrs.setStatus('mandatory')
if mibBuilder.loadTexts: statPuChSeqErrs.setDescription('The number of frames reception failure due to at least one missing block')
statBridge = MibIdentifier((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 5))
statBridgeBridge = MibIdentifier((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 5, 1))
statBridgePort = MibIdentifier((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 5, 2))
statBridgeBridgeAddressDiscard = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 5, 1, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statBridgeBridgeAddressDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: statBridgeBridgeAddressDiscard.setDescription('This counter indicates the number of times that an address entry in the filtering database has been removed to make room for a new address. If this counter increases rapidly, the filtering database is too small for the number of addresses (stations) in the network.')
statBridgeBridgeFrameDiscard = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 5, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statBridgeBridgeFrameDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: statBridgeBridgeFrameDiscard.setDescription('This counter indicates the number of times that a frame has not been bridged because its destination is local.')
statBridgeBridgeDesignatedRoot = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 5, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statBridgeBridgeDesignatedRoot.setStatus('mandatory')
if mibBuilder.loadTexts: statBridgeBridgeDesignatedRoot.setDescription("Identifier of the designated root bridge. This is an 8 byte hexadecimal label composed of the bridge priority level (the first 2 bytes) and the address of the adapter connecting the bridge to the LAN segment with the lowest LAN segment number. The root bridge has the lowest bridge identifier of all bridges in the network, and is at the top of the spanning tree. It is also the bridge that sends the 'HELLO' message to detect when other bridges enter and leave the network. The root bridge usually carries the greatest amount of traffic, since it connects the two halves of the network together.")
statBridgeBridgeRootCost = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 5, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statBridgeBridgeRootCost.setStatus('mandatory')
if mibBuilder.loadTexts: statBridgeBridgeRootCost.setDescription('From each unit there are potentially many different paths to the root bridge. The root cost is the lowest path cost, that is, the shortest relative path length to the root bridge. When the root cost is displayed as zero (0), either this unit is the root bridge or there is no direct path from this unit to the root bridge.')
statBridgeBridgeRootPort = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 5, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statBridgeBridgeRootPort.setStatus('mandatory')
if mibBuilder.loadTexts: statBridgeBridgeRootPort.setDescription('The root port is the port with the root cost. In other words, it is the port in the direction of the least path cost to the root bridge. The root port is identified by the attached equipment: LAN, Group 1 (GR1) to Group 4 (GR4). NONE indicates that this unit is the root bridge.')
statBridgeBridgeFrameFiltered = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 5, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statBridgeBridgeFrameFiltered.setStatus('mandatory')
if mibBuilder.loadTexts: statBridgeBridgeFrameFiltered.setDescription('This counter indicates the number of frames that are not forwarded because a filter configured on the unit.')
statBridgeBridgeFrameTimeout = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 5, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statBridgeBridgeFrameTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: statBridgeBridgeFrameTimeout.setDescription('Number of frames discarded because the transit delay for this frame has been reached.')
statBridgePortTable = MibTable((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 5, 2, 1), )
if mibBuilder.loadTexts: statBridgePortTable.setStatus('mandatory')
if mibBuilder.loadTexts: statBridgePortTable.setDescription('A list of statistic entries for the BridgePort.')
statBridgePortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 5, 2, 1, 1), ).setIndexNames((0, "PRESTICOM7-MIB", "statBridgePortIndex"))
if mibBuilder.loadTexts: statBridgePortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: statBridgePortEntry.setDescription('This table contains the principal statistics for the BridgePort.')
statBridgePortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 5, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statBridgePortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: statBridgePortIndex.setDescription('A unique value for each port. Its value ranges between 1 and the value of groupNumber+iflanNumber.')
statBridgePortDestination = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 5, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statBridgePortDestination.setStatus('mandatory')
if mibBuilder.loadTexts: statBridgePortDestination.setDescription('Destination of this port. When the bridge port is the LAN, the displayed destination is always LOCAL LAN. For the other bridge ports the dispayed destination is the name of the attached remote unit.')
statBridgePortState = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 5, 2, 1, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statBridgePortState.setStatus('mandatory')
if mibBuilder.loadTexts: statBridgePortState.setDescription('Current state of the LAN port (or group) in the bridge topology. This state can be one of the following: DISABLED: Not participating in the bridge topology BLOCKING: Participation limited to ensuring that another bridge forwards frames onto the network segment LISTENING: Participates in the spanning tree algorithm LEARNING: Participates in the spanning tree algorithm and builds address tables FORWARD: Participates in the spanning tree algorithm, builds address tables and forwards frames')
statBridgePortDesignatedRoot = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 5, 2, 1, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statBridgePortDesignatedRoot.setStatus('mandatory')
if mibBuilder.loadTexts: statBridgePortDesignatedRoot.setDescription('Identifier of the designated root for this port, that is, the bridge that this port considers to be the root bridge of the network. The bridge ID is an 8-byte hexadecimal label composed of the bridge priority level (the first 2 bytes) and the address of the adapter connecting the bridge to the LAN segment (or group) with the lowest number.')
statBridgePortDesignatedCost = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 5, 2, 1, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statBridgePortDesignatedCost.setStatus('mandatory')
if mibBuilder.loadTexts: statBridgePortDesignatedCost.setDescription('The cost of the path to the root bridge provided by the designated port (see DESIGNATED PORT parameter, below). The designated port connects to the same LAN as the port being examined.')
statBridgePortDesignatedBridge = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 5, 2, 1, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statBridgePortDesignatedBridge.setStatus('mandatory')
if mibBuilder.loadTexts: statBridgePortDesignatedBridge.setDescription('Identifier of the designated bridge. This is an 8-byte hexadecimal label composed of the bridge priority level (the first 2 bytes) and the address of the adapter connecting the bridge to the LAN segment (or group) with the lowest number. For each LAN segment (or group), only one bridge is in the forwarding state at any one time. This is the designated bridge for that LAN (or group). All other bridges in the network are in the blocking state, and do not forward frames or build address tables.')
statBridgePortDesignatedPort = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 5, 2, 1, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statBridgePortDesignatedPort.setStatus('mandatory')
if mibBuilder.loadTexts: statBridgePortDesignatedPort.setDescription('The port that is considered the designated port for this LAN (the LAN to which the port being examined is connected). All LAN data is sent via this port to the root bridge. The designated port ID is a 2-byte hexadecimal label, where the high byte indicates the port priority and the low byte indicates the port number.')
statBridgePortTrspFrameIn = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 5, 2, 1, 1, 8), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statBridgePortTrspFrameIn.setStatus('mandatory')
if mibBuilder.loadTexts: statBridgePortTrspFrameIn.setDescription('Number of frames received on the port for a transparent bridge.')
statBridgePortTrspFrameOut = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 5, 2, 1, 1, 9), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statBridgePortTrspFrameOut.setStatus('mandatory')
if mibBuilder.loadTexts: statBridgePortTrspFrameOut.setDescription('Number of frames forwarded from the port for a transparent bridge.')
statBridgePortTr_SpecRteFrameIn = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 5, 2, 1, 1, 10), DisplayString()).setLabel("statBridgePortTr-SpecRteFrameIn").setMaxAccess("readonly")
if mibBuilder.loadTexts: statBridgePortTr_SpecRteFrameIn.setStatus('mandatory')
if mibBuilder.loadTexts: statBridgePortTr_SpecRteFrameIn.setDescription('Number of frames received on the port that contain a Routing Information field (other than broadcast frames). This statistic is displayed for a source routing bridge only.')
statBridgePortTr_SpecRteFrameOut = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 5, 2, 1, 1, 11), DisplayString()).setLabel("statBridgePortTr-SpecRteFrameOut").setMaxAccess("readonly")
if mibBuilder.loadTexts: statBridgePortTr_SpecRteFrameOut.setStatus('mandatory')
if mibBuilder.loadTexts: statBridgePortTr_SpecRteFrameOut.setDescription('Number of frames forwarded from the port that contain a Routing Information field (other than broadcast frames). This statistic is displayed for a source routing bridge only.')
statBridgePortTr_AllRteFrameIn = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 5, 2, 1, 1, 12), DisplayString()).setLabel("statBridgePortTr-AllRteFrameIn").setMaxAccess("readonly")
if mibBuilder.loadTexts: statBridgePortTr_AllRteFrameIn.setStatus('mandatory')
if mibBuilder.loadTexts: statBridgePortTr_AllRteFrameIn.setDescription('Number of all-routes broadcast frames received on the port. This statistic is displayed for a source routing bridge only.')
statBridgePortTr_AllRteFrameOut = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 5, 2, 1, 1, 13), DisplayString()).setLabel("statBridgePortTr-AllRteFrameOut").setMaxAccess("readonly")
if mibBuilder.loadTexts: statBridgePortTr_AllRteFrameOut.setStatus('mandatory')
if mibBuilder.loadTexts: statBridgePortTr_AllRteFrameOut.setDescription('Number of all-routes broadcast frames forwarded from the port. This statistic is displayed for a source routing bridge only.')
statBridgePortTr_SingleRteFrameIn = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 5, 2, 1, 1, 14), DisplayString()).setLabel("statBridgePortTr-SingleRteFrameIn").setMaxAccess("readonly")
if mibBuilder.loadTexts: statBridgePortTr_SingleRteFrameIn.setStatus('mandatory')
if mibBuilder.loadTexts: statBridgePortTr_SingleRteFrameIn.setDescription('Number of single-route broadcast frames received on the port. This statistic is displayed for a source routing bridge only.')
statBridgePortTr_SingleRteFrameOut = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 5, 2, 1, 1, 15), DisplayString()).setLabel("statBridgePortTr-SingleRteFrameOut").setMaxAccess("readonly")
if mibBuilder.loadTexts: statBridgePortTr_SingleRteFrameOut.setStatus('mandatory')
if mibBuilder.loadTexts: statBridgePortTr_SingleRteFrameOut.setDescription('Number of single-route broadcast frames forwarded from the port. This statistic is displayed for a source routing bridge only.')
statBridgePortTr_SegmentMismatch = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 5, 2, 1, 1, 16), DisplayString()).setLabel("statBridgePortTr-SegmentMismatch").setMaxAccess("readonly")
if mibBuilder.loadTexts: statBridgePortTr_SegmentMismatch.setStatus('mandatory')
if mibBuilder.loadTexts: statBridgePortTr_SegmentMismatch.setDescription('Number of single-route or all-routes broadcast frames that have been discarded by this port because the Routing Information field contained an invalid adjacent segment value. This statistic is displayed for a source routing bridge only.')
statBridgePortTr_SegmentDuplicate = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 5, 2, 1, 1, 17), DisplayString()).setLabel("statBridgePortTr-SegmentDuplicate").setMaxAccess("readonly")
if mibBuilder.loadTexts: statBridgePortTr_SegmentDuplicate.setStatus('mandatory')
if mibBuilder.loadTexts: statBridgePortTr_SegmentDuplicate.setDescription('Number of frames, other than broadcast frames, that have been discarded by this port because the Routing Information field contained the same segment identifier more than once. This statistic is displayed for a source routing bridge only.')
statBridgePortTr_HopCntExceeded = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 5, 2, 1, 1, 18), DisplayString()).setLabel("statBridgePortTr-HopCntExceeded").setMaxAccess("readonly")
if mibBuilder.loadTexts: statBridgePortTr_HopCntExceeded.setStatus('mandatory')
if mibBuilder.loadTexts: statBridgePortTr_HopCntExceeded.setDescription('Number of single-route or all-routes broadcast frames that have been discarded by this port because the Routing Information field reached the maximum number of hops permitted. This statistic is displayed for a source routing bridge only.')
statBridgePortTr_FrmLngExceeded = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 5, 2, 1, 1, 19), DisplayString()).setLabel("statBridgePortTr-FrmLngExceeded").setMaxAccess("readonly")
if mibBuilder.loadTexts: statBridgePortTr_FrmLngExceeded.setStatus('mandatory')
if mibBuilder.loadTexts: statBridgePortTr_FrmLngExceeded.setDescription('This counter displays the number of non-broadcast token-ring frames that have been discarded by this port because the frame length has passed the maximum length permitted.')
statPvcTable = MibTable((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 6), )
if mibBuilder.loadTexts: statPvcTable.setStatus('mandatory')
if mibBuilder.loadTexts: statPvcTable.setDescription('A list of statistic entries for the PVCs. The number of entries is given by the value of pvcNumber.')
statPvcEntry = MibTableRow((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 6, 1), ).setIndexNames((0, "PRESTICOM7-MIB", "statPvcIndex"))
if mibBuilder.loadTexts: statPvcEntry.setStatus('mandatory')
if mibBuilder.loadTexts: statPvcEntry.setDescription('This table contains the principal statistics for the PVCs.')
statPvcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statPvcIndex.setStatus('mandatory')
if mibBuilder.loadTexts: statPvcIndex.setDescription('A unique value for each PVC. Its value ranges between 1 and the value of pvcNumber.')
statPvcProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 6, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statPvcProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: statPvcProtocol.setDescription('PVC protocol.')
statPvcMode = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 6, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statPvcMode.setStatus('mandatory')
if mibBuilder.loadTexts: statPvcMode.setDescription('The mode used (PVCR or OFF).')
statPvcInfoSignal = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 6, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statPvcInfoSignal.setStatus('mandatory')
if mibBuilder.loadTexts: statPvcInfoSignal.setDescription('The information signal status is displayed with a five-character field, where the individual characters have the following meaning: N = New PVC A = Active PVC C = CIR reached F = Forward congestion (to destination PVC) B = Backward congestion (from destination PVC) When an information status signal is not present, the unit displays a dash [-] in the appropriate position.')
statPvcSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 6, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statPvcSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: statPvcSpeed.setDescription('The port speed measured by the unit.')
statPvcState = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 6, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statPvcState.setStatus('mandatory')
if mibBuilder.loadTexts: statPvcState.setDescription('The possible states for a PVC in PVCR mode are: OFF = PVC inactive CALL = Waiting for active signal from the network TEST = PVC in test mode DATA = PVC in operation')
statPvcMeanTx = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 6, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statPvcMeanTx.setStatus('mandatory')
if mibBuilder.loadTexts: statPvcMeanTx.setDescription('The mean bandwidth usage for transmissions to the destination PVC.')
statPvcMeanRx = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 6, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statPvcMeanRx.setStatus('mandatory')
if mibBuilder.loadTexts: statPvcMeanRx.setDescription('The mean bandwidth usage for data received from the destination PVC.')
statPvcPeakTx = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 6, 1, 9), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statPvcPeakTx.setStatus('mandatory')
if mibBuilder.loadTexts: statPvcPeakTx.setDescription('The peak bandwidth usage for transmissions to the destination PVC.')
statPvcPeakRx = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 6, 1, 10), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statPvcPeakRx.setStatus('mandatory')
if mibBuilder.loadTexts: statPvcPeakRx.setDescription('The peak bandwidth usage for data received from the destination PVC.')
statPvcError = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 6, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statPvcError.setStatus('mandatory')
if mibBuilder.loadTexts: statPvcError.setDescription('Number of errors on the PVC. This counter is incremented every time the unit detects an error coming from the PVC.')
statPvcRestart = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 6, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statPvcRestart.setStatus('mandatory')
if mibBuilder.loadTexts: statPvcRestart.setDescription('Number of restarts on the PVC. This counter is incremented every time the link is down for at least 1 second. In addition, if the PVC is not restored within the LINK TIMEOUT value (a Global configuration parameter), the unit will log a LINK PVC DOWN alarm.')
statPvcFramesTx = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 6, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statPvcFramesTx.setStatus('mandatory')
if mibBuilder.loadTexts: statPvcFramesTx.setDescription('The number of frames transmitted')
statPvcFramesRx = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 6, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statPvcFramesRx.setStatus('mandatory')
if mibBuilder.loadTexts: statPvcFramesRx.setDescription('The number of frames received')
statPvcOctetsTx = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 6, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statPvcOctetsTx.setStatus('mandatory')
if mibBuilder.loadTexts: statPvcOctetsTx.setDescription('The number of octets transmitted')
statPvcOctetsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 6, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statPvcOctetsRx.setStatus('mandatory')
if mibBuilder.loadTexts: statPvcOctetsRx.setDescription('The number of octets received')
statPvcBadFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 6, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statPvcBadFrames.setStatus('mandatory')
if mibBuilder.loadTexts: statPvcBadFrames.setDescription('The number of frames received and deleted because the input queue is full.')
statPvcOvrFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 6, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statPvcOvrFrames.setStatus('mandatory')
if mibBuilder.loadTexts: statPvcOvrFrames.setDescription('The number of frames received and deleted because the input queue is full.')
statPvcBadOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 6, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statPvcBadOctets.setStatus('mandatory')
if mibBuilder.loadTexts: statPvcBadOctets.setDescription('The number of characters received and deleted because of a bad frame.')
statPvcOvrOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 6, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statPvcOvrOctets.setStatus('mandatory')
if mibBuilder.loadTexts: statPvcOvrOctets.setDescription('The number of characters received and deleted because the input queue is full.')
statPvcDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 6, 1, 21), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statPvcDlci.setStatus('mandatory')
if mibBuilder.loadTexts: statPvcDlci.setDescription('The current DLCI used by this PVC')
statPvcCompErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 6, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statPvcCompErrs.setStatus('mandatory')
if mibBuilder.loadTexts: statPvcCompErrs.setDescription('The number of compression errors')
statPvcChOverflows = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 6, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statPvcChOverflows.setStatus('mandatory')
if mibBuilder.loadTexts: statPvcChOverflows.setDescription('The number of channel overflows')
statPvcChAborts = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 6, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statPvcChAborts.setStatus('mandatory')
if mibBuilder.loadTexts: statPvcChAborts.setDescription('The number of frames aborted received')
statPvcChSeqErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 6, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statPvcChSeqErrs.setStatus('mandatory')
if mibBuilder.loadTexts: statPvcChSeqErrs.setDescription('The number of frames reception failure due to at least one missing block')
statPvcrRouteTable = MibTable((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 7), )
if mibBuilder.loadTexts: statPvcrRouteTable.setStatus('mandatory')
if mibBuilder.loadTexts: statPvcrRouteTable.setDescription('A list of statistic entries for the unit routing.')
statPvcrRouteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 7, 1), ).setIndexNames((0, "PRESTICOM7-MIB", "statPvcrRouteName"), (0, "PRESTICOM7-MIB", "statPvcrRouteNextHop"))
if mibBuilder.loadTexts: statPvcrRouteEntry.setStatus('mandatory')
if mibBuilder.loadTexts: statPvcrRouteEntry.setDescription('This table contains the principal statistics for the unit route')
statPvcrRouteName = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 7, 1, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statPvcrRouteName.setStatus('mandatory')
if mibBuilder.loadTexts: statPvcrRouteName.setDescription('A unique value for each unit routing entry.')
statPvcrRouteValid = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 7, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statPvcrRouteValid.setStatus('mandatory')
if mibBuilder.loadTexts: statPvcrRouteValid.setDescription('The VALID value (YES or NO) indicates whether the connection to this destination is currently active.')
statPvcrRouteMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 7, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statPvcrRouteMetric.setStatus('mandatory')
if mibBuilder.loadTexts: statPvcrRouteMetric.setDescription('The METRIC provides the hop count, or number of units that must be passed over to reach the destination. When at 0, it indicates a direct connection to the destination. Its value is usually between 1 and 15 for an indirect connection. When at 16, it indicates that the destination is unreachable.')
statPvcrRouteIntrf = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 7, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statPvcrRouteIntrf.setStatus('mandatory')
if mibBuilder.loadTexts: statPvcrRouteIntrf.setDescription('The interface used to reach the destination.')
statPvcrRouteNextHop = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 7, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statPvcrRouteNextHop.setStatus('mandatory')
if mibBuilder.loadTexts: statPvcrRouteNextHop.setDescription('The next unit to be reached on the path to the final destination. The next hop is identified by the IP address of the router that will be used to send the IP frame.')
statPvcrRouteAge = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 7, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statPvcrRouteAge.setStatus('mandatory')
if mibBuilder.loadTexts: statPvcrRouteAge.setDescription('The AGE statistic gives the number of seconds since the entry for this destination was entered on the routing table, the aging time for the entry. For a valid connection (VALID = YES), the time is normally between 0 and 30 seconds. If the destination is reached')
statSystem = MibIdentifier((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 20))
statSystemAlarmNumber = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 20, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statSystemAlarmNumber.setStatus('mandatory')
if mibBuilder.loadTexts: statSystemAlarmNumber.setDescription('The maximum number of alarms that the system records')
statSystemMeanCompRate = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 20, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statSystemMeanCompRate.setStatus('mandatory')
if mibBuilder.loadTexts: statSystemMeanCompRate.setDescription('Average compression rate.')
statSystemMeanDecompRate = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 20, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statSystemMeanDecompRate.setStatus('mandatory')
if mibBuilder.loadTexts: statSystemMeanDecompRate.setDescription('Average decompression rate.')
statSystemPeakCompRate = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 20, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statSystemPeakCompRate.setStatus('mandatory')
if mibBuilder.loadTexts: statSystemPeakCompRate.setDescription('Maximum compression rate.')
statSystemPeakDecompRate = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 20, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statSystemPeakDecompRate.setStatus('mandatory')
if mibBuilder.loadTexts: statSystemPeakDecompRate.setDescription('Maximum decompression rate.')
statSystemSa = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 20, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statSystemSa.setStatus('mandatory')
if mibBuilder.loadTexts: statSystemSa.setDescription('The number of PUs currently active and running.')
statSystemSp = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 20, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statSystemSp.setStatus('mandatory')
if mibBuilder.loadTexts: statSystemSp.setDescription('The number of PUs currently trying to get connected.')
statSystemNa = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 20, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: statSystemNa.setStatus('mandatory')
if mibBuilder.loadTexts: statSystemNa.setDescription('Network address that the system will use to send data on the LAN.')
statSystemBia = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 20, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: statSystemBia.setStatus('mandatory')
if mibBuilder.loadTexts: statSystemBia.setDescription('Burned-in address of the system.')
statSystemTr_Nan = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 20, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setLabel("statSystemTr-Nan").setMaxAccess("readonly")
if mibBuilder.loadTexts: statSystemTr_Nan.setStatus('mandatory')
if mibBuilder.loadTexts: statSystemTr_Nan.setDescription('The address of the nearest active upstream neighbor on the Token-Ring.')
statSystemResetCounters = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 20, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: statSystemResetCounters.setStatus('mandatory')
if mibBuilder.loadTexts: statSystemResetCounters.setDescription('When this variable is set to yes, all statistics counters are reset to 0 value.')
statSystemClearAlarms = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 20, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: statSystemClearAlarms.setStatus('mandatory')
if mibBuilder.loadTexts: statSystemClearAlarms.setDescription('When this variable is set to yes, all alarms are erased.')
statSystemClearErrorLed = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 20, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: statSystemClearErrorLed.setStatus('mandatory')
if mibBuilder.loadTexts: statSystemClearErrorLed.setDescription('When this variable is set to YES, the error LED is cleared.')
statBootp = MibIdentifier((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 21))
statBootpNbRequestReceived = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 21, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statBootpNbRequestReceived.setStatus('mandatory')
if mibBuilder.loadTexts: statBootpNbRequestReceived.setDescription('Number of BOOTREQUEST frame received')
statBootpNbRequestSend = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 21, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statBootpNbRequestSend.setStatus('mandatory')
if mibBuilder.loadTexts: statBootpNbRequestSend.setDescription('Number of BOOTREQUEST frame send')
statBootpNbReplyReceived = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 21, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statBootpNbReplyReceived.setStatus('mandatory')
if mibBuilder.loadTexts: statBootpNbReplyReceived.setDescription('Number of BOOTREPLY frame received')
statBootpNbReplySend = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 21, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statBootpNbReplySend.setStatus('mandatory')
if mibBuilder.loadTexts: statBootpNbReplySend.setDescription('Number of BOOTREPLY frame send')
statBootpReplyWithInvalidGiaddr = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 21, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statBootpReplyWithInvalidGiaddr.setStatus('mandatory')
if mibBuilder.loadTexts: statBootpReplyWithInvalidGiaddr.setDescription('A BOOTREPLY was received but the giaddr (the gateway IP address) fields do not correspond of any IP address of your ports. This frames is discarded.')
statBootpHopsLimitExceed = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 21, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statBootpHopsLimitExceed.setStatus('mandatory')
if mibBuilder.loadTexts: statBootpHopsLimitExceed.setDescription('A BOOTREQUEST frame was received with its hops count that exceed the configured Max hops. This frame is discarded.')
statBootpRequestReceivedOnPortBootpc = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 21, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statBootpRequestReceivedOnPortBootpc.setStatus('mandatory')
if mibBuilder.loadTexts: statBootpRequestReceivedOnPortBootpc.setDescription('A BOOTREQUEST frame was received on the UDP port BOOTPC. That should never occur. This frame is discarded.')
statBootpReplyReceivedOnPortBootpc = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 21, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statBootpReplyReceivedOnPortBootpc.setStatus('mandatory')
if mibBuilder.loadTexts: statBootpReplyReceivedOnPortBootpc.setDescription('A BOOTREPLY frame was received on the UDP port BOOTPC. That could occur when a BOOTP/DHCP server is on the same LAN that we are. But that is considered unusual. This frame is discarded.')
statBootpInvalidOpCodeField = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 21, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statBootpInvalidOpCodeField.setStatus('mandatory')
if mibBuilder.loadTexts: statBootpInvalidOpCodeField.setDescription('A frame is received on BOOTPC or BOOTPS port with a invalid operation code field: It was not a BOOTREQUEST nor BOOTREPLY. This frame is discarded.')
statBootpCannotRouteFrame = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 21, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statBootpCannotRouteFrame.setStatus('mandatory')
if mibBuilder.loadTexts: statBootpCannotRouteFrame.setDescription("Configuration problem: in the IP destination address list, which is configurable, we have an address that we cannot route (we don't know on which port transmit the frame). This frame is discarded.")
statBootpFrameTooSmallToBeABootpFrame = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 21, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statBootpFrameTooSmallToBeABootpFrame.setStatus('mandatory')
if mibBuilder.loadTexts: statBootpFrameTooSmallToBeABootpFrame.setDescription('The frame have not the minimal length of a BOOTP frame, some fields are missing. This frame is discarded.')
statBootpCannotReceiveAndForwardOnTheSamePort = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 21, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statBootpCannotReceiveAndForwardOnTheSamePort.setStatus('mandatory')
if mibBuilder.loadTexts: statBootpCannotReceiveAndForwardOnTheSamePort.setDescription('Number of frame received and try to be send on the same port. This will occur when the relay agents are in BROADCAST MODE. In normal operation, when the product is well configured, this should not occur. This frame is discarded.')
statGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 22))
statGrpNumber = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 22, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statGrpNumber.setStatus('mandatory')
if mibBuilder.loadTexts: statGrpNumber.setDescription('A list of statistic entries for the groups.')
statGrpTable = MibTable((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 22, 2), )
if mibBuilder.loadTexts: statGrpTable.setStatus('mandatory')
if mibBuilder.loadTexts: statGrpTable.setDescription('A list of statistic entries for the groups.')
statGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 22, 2, 1), ).setIndexNames((0, "PRESTICOM7-MIB", "statGrpIndex"))
if mibBuilder.loadTexts: statGrpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: statGrpEntry.setDescription('This table contains the principal statistics for the groups.')
statGrpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 22, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statGrpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: statGrpIndex.setDescription('A unique value for each group. Its value ranges between 1 and the number of groups.')
statGrpDestName = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 22, 2, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statGrpDestName.setStatus('mandatory')
if mibBuilder.loadTexts: statGrpDestName.setDescription('The destination name of the group')
statGrpOutOfSeqErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 22, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statGrpOutOfSeqErrs.setStatus('mandatory')
if mibBuilder.loadTexts: statGrpOutOfSeqErrs.setDescription('')
statGrpSorterTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 22, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statGrpSorterTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: statGrpSorterTimeouts.setDescription('')
statGrpSorterOverruns = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 22, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statGrpSorterOverruns.setStatus('mandatory')
if mibBuilder.loadTexts: statGrpSorterOverruns.setDescription('')
statTimep = MibIdentifier((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 23))
statTimeNbFrameReceived = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 23, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statTimeNbFrameReceived.setStatus('mandatory')
if mibBuilder.loadTexts: statTimeNbFrameReceived.setDescription('Number of frames received.')
statTimeNbFrameSent = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 23, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statTimeNbFrameSent.setStatus('mandatory')
if mibBuilder.loadTexts: statTimeNbFrameSent.setDescription('Number of frames sent.')
statTimeNbRequestReceived = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 23, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statTimeNbRequestReceived.setStatus('mandatory')
if mibBuilder.loadTexts: statTimeNbRequestReceived.setDescription('Number of requests received by time server.')
statTimeNbReplySent = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 23, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statTimeNbReplySent.setStatus('mandatory')
if mibBuilder.loadTexts: statTimeNbReplySent.setDescription('Number of replies sent by time server.')
statTimeNbRequestSent = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 23, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statTimeNbRequestSent.setStatus('mandatory')
if mibBuilder.loadTexts: statTimeNbRequestSent.setDescription('Number of requests sent by time client.')
statTimeNbReplyReceived = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 23, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statTimeNbReplyReceived.setStatus('mandatory')
if mibBuilder.loadTexts: statTimeNbReplyReceived.setDescription('Number of replies received by time client.')
statTimeClientRetransmissions = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 23, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statTimeClientRetransmissions.setStatus('mandatory')
if mibBuilder.loadTexts: statTimeClientRetransmissions.setDescription("Number of client retransmission's.")
statTimeClientSyncFailures = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 23, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statTimeClientSyncFailures.setStatus('mandatory')
if mibBuilder.loadTexts: statTimeClientSyncFailures.setDescription('Number of client sync failures.')
statTimeInvalidLocalIpAddress = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 23, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statTimeInvalidLocalIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: statTimeInvalidLocalIpAddress.setDescription('Number of invalid local IP addresses.')
statTimeInvalidPortNumbers = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 23, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statTimeInvalidPortNumbers.setStatus('mandatory')
if mibBuilder.loadTexts: statTimeInvalidPortNumbers.setDescription('Number of frames with invalid port numbers.')
statQ922counters = MibIdentifier((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 24))
statTxRetransmissions = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 24, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statTxRetransmissions.setStatus('mandatory')
if mibBuilder.loadTexts: statTxRetransmissions.setDescription('Number of retransmissions invoked.')
statReleaseIndications = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 24, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statReleaseIndications.setStatus('mandatory')
if mibBuilder.loadTexts: statReleaseIndications.setDescription('Number of release indications.')
statEstablishIndications = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 24, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statEstablishIndications.setStatus('mandatory')
if mibBuilder.loadTexts: statEstablishIndications.setDescription('Number of establish indications.')
statLinkEstablished = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 24, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statLinkEstablished.setStatus('mandatory')
if mibBuilder.loadTexts: statLinkEstablished.setDescription('Number of links established.')
statTxIframeQdiscards = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 24, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statTxIframeQdiscards.setStatus('mandatory')
if mibBuilder.loadTexts: statTxIframeQdiscards.setDescription('Number of Iframe Q discards.')
statRxframes = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 24, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statRxframes.setStatus('mandatory')
if mibBuilder.loadTexts: statRxframes.setDescription('Number of received frames.')
statTxframes = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 24, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statTxframes.setStatus('mandatory')
if mibBuilder.loadTexts: statTxframes.setDescription('Number of transmitted frames.')
statRxBytes = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 24, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statRxBytes.setStatus('mandatory')
if mibBuilder.loadTexts: statRxBytes.setDescription('Number of received bytes.')
statTxBytes = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 24, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statTxBytes.setStatus('mandatory')
if mibBuilder.loadTexts: statTxBytes.setDescription('Number of transmitted bytes.')
statQ922errors = MibIdentifier((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 25))
statInvalidRxSizes = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 25, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statInvalidRxSizes.setStatus('mandatory')
if mibBuilder.loadTexts: statInvalidRxSizes.setDescription('Number of frames with invalid lengths.')
statMissingControlBlocks = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 25, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statMissingControlBlocks.setStatus('mandatory')
if mibBuilder.loadTexts: statMissingControlBlocks.setDescription('Number of frames without control blocks.')
statRxAcknowledgeExpiry = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 25, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statRxAcknowledgeExpiry.setStatus('mandatory')
if mibBuilder.loadTexts: statRxAcknowledgeExpiry.setDescription('Number of RR ack Tx from Tack expiry.')
statTxAcknowledgeExpiry = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 25, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statTxAcknowledgeExpiry.setStatus('mandatory')
if mibBuilder.loadTexts: statTxAcknowledgeExpiry.setDescription('Number of Tx frame acks delayed waiting for Tack.')
statQ933counters = MibIdentifier((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 26))
statTxSetupMessages = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 26, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statTxSetupMessages.setStatus('mandatory')
if mibBuilder.loadTexts: statTxSetupMessages.setDescription('Number of transmitted setup messages.')
statRxSetupMessages = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 26, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statRxSetupMessages.setStatus('mandatory')
if mibBuilder.loadTexts: statRxSetupMessages.setDescription('Number of received setup messages.')
statTxCallProceedingMessages = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 26, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statTxCallProceedingMessages.setStatus('mandatory')
if mibBuilder.loadTexts: statTxCallProceedingMessages.setDescription('Number of transmitted call proceeding messages.')
statRxCallProceedingMessages = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 26, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statRxCallProceedingMessages.setStatus('mandatory')
if mibBuilder.loadTexts: statRxCallProceedingMessages.setDescription('Number of received call proceeding messages.')
statTxConnectMessages = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 26, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statTxConnectMessages.setStatus('mandatory')
if mibBuilder.loadTexts: statTxConnectMessages.setDescription('Number of Tx connect messages.')
statRxConnectMessages = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 26, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statRxConnectMessages.setStatus('mandatory')
if mibBuilder.loadTexts: statRxConnectMessages.setDescription('Number of Rx connect messages.')
statTxReleaseMessages = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 26, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statTxReleaseMessages.setStatus('mandatory')
if mibBuilder.loadTexts: statTxReleaseMessages.setDescription('Number of transmitted release messages.')
statRxReleaseMessages = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 26, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statRxReleaseMessages.setStatus('mandatory')
if mibBuilder.loadTexts: statRxReleaseMessages.setDescription('Number of received release messages.')
statTxReleaseCompleteMessages = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 26, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statTxReleaseCompleteMessages.setStatus('mandatory')
if mibBuilder.loadTexts: statTxReleaseCompleteMessages.setDescription('Number of transmitted release complete messages.')
statRxReleaseCompleteMessages = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 26, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statRxReleaseCompleteMessages.setStatus('mandatory')
if mibBuilder.loadTexts: statRxReleaseCompleteMessages.setDescription('Number of received release complete messages.')
statTxDisconnectMessages = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 26, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statTxDisconnectMessages.setStatus('mandatory')
if mibBuilder.loadTexts: statTxDisconnectMessages.setDescription('Number of transmitted disconnect messages.')
statRxDisconnectMessages = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 26, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statRxDisconnectMessages.setStatus('mandatory')
if mibBuilder.loadTexts: statRxDisconnectMessages.setDescription('Number of received disconnect messages.')
statTxStatusMessages = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 26, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statTxStatusMessages.setStatus('mandatory')
if mibBuilder.loadTexts: statTxStatusMessages.setDescription('Number of transmitted status messages.')
statRxStatusMessages = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 26, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statRxStatusMessages.setStatus('mandatory')
if mibBuilder.loadTexts: statRxStatusMessages.setDescription('Number of received status messages.')
statTxStatusEnquiryMessages = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 26, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statTxStatusEnquiryMessages.setStatus('mandatory')
if mibBuilder.loadTexts: statTxStatusEnquiryMessages.setDescription('Number of transmitted status enquiry messages.')
statRxStatusEnquiryMessages = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 26, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statRxStatusEnquiryMessages.setStatus('mandatory')
if mibBuilder.loadTexts: statRxStatusEnquiryMessages.setDescription('Number of received status enquiry messages.')
statProtocolTimeouts = MibScalar((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 26, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statProtocolTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: statProtocolTimeouts.setDescription('Number of protocol time-outs.')
statSvcTable = MibTable((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 27), )
if mibBuilder.loadTexts: statSvcTable.setStatus('mandatory')
if mibBuilder.loadTexts: statSvcTable.setDescription('A list of statistic entries for the SVCs.')
statSvcEntry = MibTableRow((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 27, 1), ).setIndexNames((0, "PRESTICOM7-MIB", "statSvcIndex"))
if mibBuilder.loadTexts: statSvcEntry.setStatus('mandatory')
if mibBuilder.loadTexts: statSvcEntry.setDescription('This table contains the principal statistics for the SVCs.')
statSvcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 27, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statSvcIndex.setStatus('mandatory')
if mibBuilder.loadTexts: statSvcIndex.setDescription('A unique value for each SVC.')
statSvcProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 27, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statSvcProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: statSvcProtocol.setDescription('SVC protocol.')
statSvcMode = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 27, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statSvcMode.setStatus('mandatory')
if mibBuilder.loadTexts: statSvcMode.setDescription('SVC mode. PVCR, FP or OFF')
statSvcInfoSignal = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 27, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statSvcInfoSignal.setStatus('mandatory')
if mibBuilder.loadTexts: statSvcInfoSignal.setDescription('The information signal status is displayed with a five-character field, where the individual characters have the following meaning: N = New SVC A = Active SVC C = CIR reached F = Forward congestion (to destination SVC) B = Backward congestion (from destination SVC) When an information status signal is not present, the unit displays a dash [-] in the appropriate position.')
statSvcSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 27, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statSvcSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: statSvcSpeed.setDescription('The port speed measured by the unit.')
statSvcState = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 27, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statSvcState.setStatus('mandatory')
if mibBuilder.loadTexts: statSvcState.setDescription('The possible states for an SVC in PVCR mode are: OFF = SVC inactive CALL = Waiting for active signal from the network TEST = SVC in test mode DATA = SVC in operation')
statSvcMeanTx = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 27, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statSvcMeanTx.setStatus('mandatory')
if mibBuilder.loadTexts: statSvcMeanTx.setDescription('The mean bandwidth usage for transmissions to the destination SVC.')
statSvcMeanRx = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 27, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statSvcMeanRx.setStatus('mandatory')
if mibBuilder.loadTexts: statSvcMeanRx.setDescription('The mean bandwidth usage for data received from the destination SVC.')
statSvcPeakTx = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 27, 1, 9), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statSvcPeakTx.setStatus('mandatory')
if mibBuilder.loadTexts: statSvcPeakTx.setDescription('The peak bandwidth usage for transmissions to the destination SVC.')
statSvcPeakRx = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 27, 1, 10), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statSvcPeakRx.setStatus('mandatory')
if mibBuilder.loadTexts: statSvcPeakRx.setDescription('The peak bandwidth usage for data received from the destination SVC.')
statSvcError = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 27, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statSvcError.setStatus('mandatory')
if mibBuilder.loadTexts: statSvcError.setDescription('Number of errors on the SVC. This counter is incremented every time the unit detects an error coming from the SVC.')
statSvcRestart = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 27, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statSvcRestart.setStatus('mandatory')
if mibBuilder.loadTexts: statSvcRestart.setDescription('Number of restarts on the SVC. This counter is incremented every time the link is down for at least 1 second. In addition, if the SVC is not restored within the LINK TIMEOUT value (a Global configuration parameter), the unit will log a LINK SVC DOWN alarm.')
statSvcFramesTx = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 27, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statSvcFramesTx.setStatus('mandatory')
if mibBuilder.loadTexts: statSvcFramesTx.setDescription('The number of frames transmitted')
statSvcFramesRx = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 27, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statSvcFramesRx.setStatus('mandatory')
if mibBuilder.loadTexts: statSvcFramesRx.setDescription('The number of frames received')
statSvcOctetsTx = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 27, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statSvcOctetsTx.setStatus('mandatory')
if mibBuilder.loadTexts: statSvcOctetsTx.setDescription('The number of octets transmitted')
statSvcOctetsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 27, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statSvcOctetsRx.setStatus('mandatory')
if mibBuilder.loadTexts: statSvcOctetsRx.setDescription('The number of octets received')
statSvcBadFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 27, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statSvcBadFrames.setStatus('mandatory')
if mibBuilder.loadTexts: statSvcBadFrames.setDescription('The number of frames received and deleted because the input queue is full.')
statSvcOvrFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 27, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statSvcOvrFrames.setStatus('mandatory')
if mibBuilder.loadTexts: statSvcOvrFrames.setDescription('The number of frames received and deleted because the input queue is full.')
statSvcBadOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 27, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statSvcBadOctets.setStatus('mandatory')
if mibBuilder.loadTexts: statSvcBadOctets.setDescription('The number of characters received and deleted because of a bad frame.')
statSvcOvrOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 27, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statSvcOvrOctets.setStatus('mandatory')
if mibBuilder.loadTexts: statSvcOvrOctets.setDescription('The number of characters received and deleted because the input queue is full.')
statSvcDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 27, 1, 21), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statSvcDlci.setStatus('mandatory')
if mibBuilder.loadTexts: statSvcDlci.setDescription('The current DLCI used by this SVC')
statIfcemTable = MibTable((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 28), )
if mibBuilder.loadTexts: statIfcemTable.setStatus('mandatory')
if mibBuilder.loadTexts: statIfcemTable.setDescription('A list of statistic entries for the cem interfaces.')
statIfcemEntry = MibTableRow((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 28, 1), ).setIndexNames((0, "PRESTICOM7-MIB", "statIfcemIndex"))
if mibBuilder.loadTexts: statIfcemEntry.setStatus('mandatory')
if mibBuilder.loadTexts: statIfcemEntry.setDescription('This table contains statistics for the cem interfaces.')
statIfcemIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 28, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statIfcemIndex.setStatus('mandatory')
if mibBuilder.loadTexts: statIfcemIndex.setDescription('A unique value for each interface.')
statIfcemDesc = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 28, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statIfcemDesc.setStatus('mandatory')
if mibBuilder.loadTexts: statIfcemDesc.setDescription('A textual string containing information about a specific interface.')
statIfcemClockState = MibTableColumn((1, 3, 6, 1, 4, 1, 727, 7, 2, 20, 28, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statIfcemClockState.setStatus('mandatory')
if mibBuilder.loadTexts: statIfcemClockState.setDescription('This variable contains the status of the clock extracting module.')
connectionDown = NotificationType((1, 3, 6, 1, 4, 1, 727) + (0,600)).setObjects(("PRESTICOM7-MIB", "puIndex"))
if mibBuilder.loadTexts: connectionDown.setDescription('This trap indicates that a PU connection has come down.')
linkDown = NotificationType((1, 3, 6, 1, 4, 1, 727) + (0,601)).setObjects(("PRESTICOM7-MIB", "ifwanIndex"))
if mibBuilder.loadTexts: linkDown.setDescription('This trap indicates that a link has come down.')
pvcDown = NotificationType((1, 3, 6, 1, 4, 1, 727) + (0,602)).setObjects(("PRESTICOM7-MIB", "pvcIndex"))
if mibBuilder.loadTexts: pvcDown.setDescription('This trap indicates that a pvc has come down.')
cardDown = NotificationType((1, 3, 6, 1, 4, 1, 727) + (0,603)).setObjects(("PRESTICOM7-MIB", "sysTrapRackandPos"))
if mibBuilder.loadTexts: cardDown.setDescription('This trap indicates that a card has come down.')
connectionUp = NotificationType((1, 3, 6, 1, 4, 1, 727) + (0,604)).setObjects(("PRESTICOM7-MIB", "puIndex"))
if mibBuilder.loadTexts: connectionUp.setDescription('This trap indicates that a PU connection has come up.')
linkUp = NotificationType((1, 3, 6, 1, 4, 1, 727) + (0,605)).setObjects(("PRESTICOM7-MIB", "ifwanIndex"))
if mibBuilder.loadTexts: linkUp.setDescription('This trap indicates that a link has come up.')
pvcUp = NotificationType((1, 3, 6, 1, 4, 1, 727) + (0,606)).setObjects(("PRESTICOM7-MIB", "pvcIndex"))
if mibBuilder.loadTexts: pvcUp.setDescription('This trap indicates that a pvc has come up.')
cardup = NotificationType((1, 3, 6, 1, 4, 1, 727) + (0,607)).setObjects(("PRESTICOM7-MIB", "sysTrapRackandPos"))
if mibBuilder.loadTexts: cardup.setDescription('This trap indicates that a card has come up.')
periodStarted = NotificationType((1, 3, 6, 1, 4, 1, 727) + (0,608)).setObjects(("PRESTICOM7-MIB", "schedulePeriod"))
if mibBuilder.loadTexts: periodStarted.setDescription('This trap indicates that a period is started.')
periodEnded = NotificationType((1, 3, 6, 1, 4, 1, 727) + (0,609)).setObjects(("PRESTICOM7-MIB", "schedulePeriod"))
if mibBuilder.loadTexts: periodEnded.setDescription('This trap indicates that a period is ended.')
badDestPort = NotificationType((1, 3, 6, 1, 4, 1, 727) + (0,610)).setObjects(("PRESTICOM7-MIB", "ifwanIndex"))
if mibBuilder.loadTexts: badDestPort.setDescription('This trap indicates a bad destination port.')
badDestPvc = NotificationType((1, 3, 6, 1, 4, 1, 727) + (0,611)).setObjects(("PRESTICOM7-MIB", "ifwanIndex"))
if mibBuilder.loadTexts: badDestPvc.setDescription('This trap indicates a bad destination pvc.')
backupCall = NotificationType((1, 3, 6, 1, 4, 1, 727) + (0,612))
if mibBuilder.loadTexts: backupCall.setDescription('A link was activated by the backup mechanism.')
backupHang = NotificationType((1, 3, 6, 1, 4, 1, 727) + (0,613))
if mibBuilder.loadTexts: backupHang.setDescription('A link was de-activated by the backup mechanism.')
manualCall = NotificationType((1, 3, 6, 1, 4, 1, 727) + (0,614))
if mibBuilder.loadTexts: manualCall.setDescription('A link was manually activated.')
manualHang = NotificationType((1, 3, 6, 1, 4, 1, 727) + (0,615))
if mibBuilder.loadTexts: manualHang.setDescription('A link was manually de-activated.')
bondTrig = NotificationType((1, 3, 6, 1, 4, 1, 727) + (0,616))
if mibBuilder.loadTexts: bondTrig.setDescription('Bandwidth On Demand trig.')
bondDeTrig = NotificationType((1, 3, 6, 1, 4, 1, 727) + (0,617))
if mibBuilder.loadTexts: bondDeTrig.setDescription('Bandwidth On Demand de-trig.')
firmwareStored = NotificationType((1, 3, 6, 1, 4, 1, 727) + (0,618))
if mibBuilder.loadTexts: firmwareStored.setDescription('A new firmware was stored in the unit.')
cfgStored = NotificationType((1, 3, 6, 1, 4, 1, 727) + (0,619))
if mibBuilder.loadTexts: cfgStored.setDescription('A new setup was stored in the unit.')
noTrap = NotificationType((1, 3, 6, 1, 4, 1, 727) + (0,620))
if mibBuilder.loadTexts: noTrap.setDescription('The operating system fail to schedule a trap.')
fatalTrap = NotificationType((1, 3, 6, 1, 4, 1, 727) + (0,621))
if mibBuilder.loadTexts: fatalTrap.setDescription('The operating system fail to execute a trap.')
notMemory = NotificationType((1, 3, 6, 1, 4, 1, 727) + (0,622))
if mibBuilder.loadTexts: notMemory.setDescription('The unit has not enough memory.')
setupReset = NotificationType((1, 3, 6, 1, 4, 1, 727) + (0,623))
if mibBuilder.loadTexts: setupReset.setDescription('The setup was reset by the operator.')
badChecksum = NotificationType((1, 3, 6, 1, 4, 1, 727) + (0,624))
if mibBuilder.loadTexts: badChecksum.setDescription('Invalid checksum')
fatalMsg = NotificationType((1, 3, 6, 1, 4, 1, 727) + (0,625))
if mibBuilder.loadTexts: fatalMsg.setDescription('The operating system fail to process a msg.')
noMsg = NotificationType((1, 3, 6, 1, 4, 1, 727) + (0,626))
if mibBuilder.loadTexts: noMsg.setDescription('The operating system fail to allocate a msg.')
bothPsUp = NotificationType((1, 3, 6, 1, 4, 1, 727) + (0,627))
if mibBuilder.loadTexts: bothPsUp.setDescription('Both PS of a rack are running.')
onePsDown = NotificationType((1, 3, 6, 1, 4, 1, 727) + (0,628))
if mibBuilder.loadTexts: onePsDown.setDescription('One PS of the rack is not running.')
bothFansUp = NotificationType((1, 3, 6, 1, 4, 1, 727) + (0,629))
if mibBuilder.loadTexts: bothFansUp.setDescription('Both fans of a rack are running.')
oneOrMoreFanDown = NotificationType((1, 3, 6, 1, 4, 1, 727) + (0,630))
if mibBuilder.loadTexts: oneOrMoreFanDown.setDescription('One fan or more on the rack are not running.')
accountingFileFull = NotificationType((1, 3, 6, 1, 4, 1, 727) + (0,631))
if mibBuilder.loadTexts: accountingFileFull.setDescription('Call accounting log file is 90% full.')
frLinkUp = NotificationType((1, 3, 6, 1, 4, 1, 727) + (0,665)).setObjects(("PRESTICOM7-MIB", "ifwanIndex"))
if mibBuilder.loadTexts: frLinkUp.setDescription('This trap indicates that a frame relay link has come up.')
frLinkDown = NotificationType((1, 3, 6, 1, 4, 1, 727) + (0,666)).setObjects(("PRESTICOM7-MIB", "ifwanIndex"))
if mibBuilder.loadTexts: frLinkDown.setDescription('This trap indicates that a frame relay link has come down.')
q922Up = NotificationType((1, 3, 6, 1, 4, 1, 727) + (0,667)).setObjects(("PRESTICOM7-MIB", "ifwanIndex"))
if mibBuilder.loadTexts: q922Up.setDescription('This trap indicates that a Q922 link has come up.')
q922Down = NotificationType((1, 3, 6, 1, 4, 1, 727) + (0,668)).setObjects(("PRESTICOM7-MIB", "ifwanIndex"))
if mibBuilder.loadTexts: q922Down.setDescription('This trap indicates that a Q922 link has come down.')
accountingFileOverflow = NotificationType((1, 3, 6, 1, 4, 1, 727) + (0,669))
if mibBuilder.loadTexts: accountingFileOverflow.setDescription('Call accounting log file will overflow on next call.')
tMS380C26 = MibIdentifier((1, 3, 6, 1, 4, 1, 727, 7, 50, 1))
mC68EN360 = MibIdentifier((1, 3, 6, 1, 4, 1, 727, 7, 50, 2))
tMS380C30 = MibIdentifier((1, 3, 6, 1, 4, 1, 727, 7, 50, 3))
dP83936 = MibIdentifier((1, 3, 6, 1, 4, 1, 727, 7, 50, 4))
mibBuilder.exportSymbols("PRESTICOM7-MIB", puActive=puActive, statIflanEth_Interface=statIflanEth_Interface, tMS380C26=tMS380C26, statIfwanIndex=statIfwanIndex, ifwanLineBuild=ifwanLineBuild, mibSubVersion=mibSubVersion, ifvceTeTimer_s=ifvceTeTimer_s, puSdlcAddress2=puSdlcAddress2, statIfvceFaxRate=statIfvceFaxRate, proxyEntry=proxyEntry, ifvceRate6kx2=ifvceRate6kx2, ifwanMaxFrame=ifwanMaxFrame, timepClientUpdateInterval=timepClientUpdateInterval, pvcMaxChannels=pvcMaxChannels, sysDay=sysDay, ifvceExtNumber=ifvceExtNumber, statIflanEthTwoCollisions=statIflanEthTwoCollisions, statBootpHopsLimitExceed=statBootpHopsLimitExceed, ifwanIpxSap=ifwanIpxSap, statTxSetupMessages=statTxSetupMessages, ifvceRate8kx2=ifvceRate8kx2, bondDeTrig=bondDeTrig, statIfwanT1E1PCV=statIfwanT1E1PCV, puBanBnnDsap=puBanBnnDsap, sysHuntForwardingBDLCI=sysHuntForwardingBDLCI, iflanEth_LinkIntegrity=iflanEth_LinkIntegrity, statPuMode=statPuMode, statSvcProtocol=statSvcProtocol, ipxfilterEnable=ipxfilterEnable, iflanProtocol=iflanProtocol, statTxframes=statTxframes, ifwanIpxRip=ifwanIpxRip, ifwanMultiframing=ifwanMultiframing, statAlarmDesc=statAlarmDesc, mibVersion=mibVersion, statIfwanOvrFrames=statIfwanOvrFrames, ifwanPppSilent=ifwanPppSilent, statPvcrRouteNextHop=statPvcrRouteNextHop, bootpIpDestAddr3=bootpIpDestAddr3, statBootpNbReplySend=statBootpNbReplySend, ifwanMode=ifwanMode, sysDefaultGateway=sysDefaultGateway, ifwanIdleCode=ifwanIdleCode, statSvcOvrOctets=statSvcOvrOctets, statIfcemClockState=statIfcemClockState, proxyTrapIpAddr=proxyTrapIpAddr, pysmi_class=pysmi_class, iflanIpRipPassword=iflanIpRipPassword, ospfAreaImportASExt=ospfAreaImportASExt, statIfwanUnderruns=statIfwanUnderruns, statIfcemIndex=statIfcemIndex, pvcBackupHang_s=pvcBackupHang_s, ifwanClocking=ifwanClocking, statBridgePortTr_AllRteFrameIn=statBridgePortTr_AllRteFrameIn, ospfRangeEntry=ospfRangeEntry, ifvceRemotePort=ifvceRemotePort, scheduleEnable=scheduleEnable, bridgeAgingTime_s=bridgeAgingTime_s, statPvcMeanRx=statPvcMeanRx, statTimeNbReplyReceived=statTimeNbReplyReceived, intfType=intfType, mgmt=mgmt, pvcTimeout_ms=pvcTimeout_ms, ifwanPriority=ifwanPriority, puBanBnnTimeout_ms=puBanBnnTimeout_ms, statSvcOctetsRx=statSvcOctetsRx, pvcOspfDeadInt=pvcOspfDeadInt, statBootpFrameTooSmallToBeABootpFrame=statBootpFrameTooSmallToBeABootpFrame, statIfwanCompErrs=statIfwanCompErrs, ipxfilterTable=ipxfilterTable, sysThisPosId=sysThisPosId, sysVoiceEncoding=sysVoiceEncoding, pvcRemotePvc=pvcRemotePvc, puXidId=puXidId, pvcOspfRetransmitInt=pvcOspfRetransmitInt, sysUnitRoutingVersion=sysUnitRoutingVersion, statBootp=statBootp, sysExtensionNumLength=sysExtensionNumLength, puBnnPvc=puBnnPvc, statIflanEthCarrierSense=statIflanEthCarrierSense, statPvcChAborts=statPvcChAborts, statRxSetupMessages=statRxSetupMessages, pvcDlciAddress=pvcDlciAddress, statBridgeBridgeAddressDiscard=statBridgeBridgeAddressDiscard, ifwanReportCycle=ifwanReportCycle, scheduleBeginTime=scheduleBeginTime, statPvcRestart=statPvcRestart, statTimeNbFrameSent=statTimeNbFrameSent, ifwanPppNegociateIpAddress=ifwanPppNegociateIpAddress, statPvcMeanTx=statPvcMeanTx, statGrpTable=statGrpTable, ipaddrIndex=ipaddrIndex, ifvceToneType=ifvceToneType, ospfVLinkNumber=ospfVLinkNumber, classEntry=classEntry, statAlarmEntry=statAlarmEntry, statIfwanOctetsTx=statIfwanOctetsTx, iflanIpRipAuthType=iflanIpRipAuthType, intfIndex=intfIndex, timepClientUdpRetransmissions=timepClientUdpRetransmissions, statBridgePortDesignatedPort=statBridgePortDesignatedPort, mibSpecialVersion=mibSpecialVersion, sysDate=sysDate, slot=slot, ipxfilter=ipxfilter, puIndex=puIndex, ospfVLinkTable=ospfVLinkTable, ifwanOspfHelloInt=ifwanOspfHelloInt, statIflanBadFrames=statIflanBadFrames, ospfVLinkEnable=ospfVLinkEnable, bootpMaxHops=bootpMaxHops, ifvceLinkDwnBusy=ifvceLinkDwnBusy, pvcOspfPassword=pvcOspfPassword, ifvceRate8kx1=ifvceRate8kx1, ifwanBodHang_s=ifwanBodHang_s, iflanOspfMetricCost=iflanOspfMetricCost, ospfGlobalRackAreaId=ospfGlobalRackAreaId, ifvceBroadcastDir=ifvceBroadcastDir, ifvceToneDetectRegen_s=ifvceToneDetectRegen_s, statSvcState=statSvcState, ifvceRate4k8x1=ifvceRate4k8x1, ifwanIpRipTxRx=ifwanIpRipTxRx, ifwanBChannels=ifwanBChannels, ifvceR2BusyDigit=ifvceR2BusyDigit, sysSnmpTrapIpAddr4=sysSnmpTrapIpAddr4, iflanTr_RingNumber=iflanTr_RingNumber, ifvceRate5k8x1=ifvceRate5k8x1, statAlarmModule=statAlarmModule, classIndex=classIndex, statBridgeBridgeDesignatedRoot=statBridgeBridgeDesignatedRoot, ifwanQsigPbxXy=ifwanQsigPbxXy, statPvcCompErrs=statPvcCompErrs, iflanPriority=iflanPriority, periodStarted=periodStarted, bridgeHelloTime_s=bridgeHelloTime_s, ospfRangeMask=ospfRangeMask, ifvceInterface=ifvceInterface, statSvcTable=statSvcTable, puLlcTimeout_ms=puLlcTimeout_ms, ifwanSvcIframeRetransmissionsN200=ifwanSvcIframeRetransmissionsN200, ipxInternalNetNum=ipxInternalNetNum, statIflanConnectionStatus=statIflanConnectionStatus, ifwanSvcStatusTimeoutT322=ifwanSvcStatusTimeoutT322, system=system, statBootpReplyReceivedOnPortBootpc=statBootpReplyReceivedOnPortBootpc, ifwanPppAcceptAccmPeer=ifwanPppAcceptAccmPeer, pvcIpxRip=pvcIpxRip, bridgePriority=bridgePriority, ifwanEncodingLaw=ifwanEncodingLaw, statIflanOperatingMode=statIflanOperatingMode, statIfvceUnderruns=statIfvceUnderruns, pvcOspfTransitDelay=pvcOspfTransitDelay, statIfvceProtocol=statIfvceProtocol, statPvcTable=statPvcTable, ospfVLink=ospfVLink, ospfAreaIndex=ospfAreaIndex, statEstablishIndications=statEstablishIndications, statIfwanMeanRx=statIfwanMeanRx, ifwanMsn2=ifwanMsn2, statBridgePortTrspFrameOut=statBridgePortTrspFrameOut, ifwanOspfRetransmitInt=ifwanOspfRetransmitInt, ifwanGroupPoll=ifwanGroupPoll, statBridgePortTr_HopCntExceeded=statBridgePortTr_HopCntExceeded, statPvcrRouteValid=statPvcrRouteValid, sysDesc=sysDesc, ipaddrTable=ipaddrTable, statTimeNbFrameReceived=statTimeNbFrameReceived, noTrap=noTrap, iflanIpxRip=iflanIpxRip, puDlsMaxFrame=puDlsMaxFrame, statBootpInvalidOpCodeField=statBootpInvalidOpCodeField, statGrpDestName=statGrpDestName, ifvceLocalOutbound=ifvceLocalOutbound, sysDefaultIpMask=sysDefaultIpMask, statIfcemTable=statIfcemTable, fatalTrap=fatalTrap, timepGetServerTimeNow=timepGetServerTimeNow, statRxAcknowledgeExpiry=statRxAcknowledgeExpiry, statIfwanDesc=statIfwanDesc, proxyIpMask=proxyIpMask, puEntry=puEntry, proxy=proxy, statBridge=statBridge, statRxReleaseCompleteMessages=statRxReleaseCompleteMessages, sysHuntForwardingBUnit=sysHuntForwardingBUnit, presticom=presticom, puSdlcPort=puSdlcPort, ipaddrEntry=ipaddrEntry, pvc=pvc, filterTable=filterTable, statIflanPeakRx_kbps=statIflanPeakRx_kbps, statPvcOvrFrames=statPvcOvrFrames, ip=ip, statPvcOvrOctets=statPvcOvrOctets, ifwanTable=ifwanTable, cardDown=cardDown, pvcUp=pvcUp, sysCountry=sysCountry, ifvceDTalkThreshold=ifvceDTalkThreshold, ifwanOspfEnable=ifwanOspfEnable, ifwanMsn1=ifwanMsn1, ifwanPppConfigRetries=ifwanPppConfigRetries, statSvcBadOctets=statSvcBadOctets, sysRackId=sysRackId, statIfwanDropInsert=statIfwanDropInsert, pvcBackup=pvcBackup, schedulePort3=schedulePort3, ospfVLinkNeighborRtrId=ospfVLinkNeighborRtrId, statBridgeBridgeRootCost=statBridgeBridgeRootCost, sysSnmpTrapIpAddr1=sysSnmpTrapIpAddr1, iflanIpRip=iflanIpRip, ospfRangeNet=ospfRangeNet, ipaddr=ipaddr, ifvceSpeedDialNum=ifvceSpeedDialNum, statBridgePortTr_SpecRteFrameIn=statBridgePortTr_SpecRteFrameIn, statSvcFramesTx=statSvcFramesTx, sysPsAndFansMonitoring=sysPsAndFansMonitoring, ifwanOspfDeadInt=ifwanOspfDeadInt, statIflanTable=statIflanTable, statTxBytes=statTxBytes, ospfVLinkHelloInt=ospfVLinkHelloInt, schedulePort8=schedulePort8, statBridgePortTable=statBridgePortTable, sysJitterBuf=sysJitterBuf, ipstaticIndex=ipstaticIndex, pvcIpAddress=pvcIpAddress, statAlarmAlarm=statAlarmAlarm, statInvalidRxSizes=statInvalidRxSizes, statIflanMeanRx_kbps=statIflanMeanRx_kbps, statIflanEthExcessiveCollision=statIflanEthExcessiveCollision, ifwanTransparentClassNumber=ifwanTransparentClassNumber, statSvcMeanRx=statSvcMeanRx, statBridgePortDesignatedRoot=statBridgePortDesignatedRoot, pvcDialTimeout=pvcDialTimeout, connectionUp=connectionUp, statAlarmTable=statAlarmTable, statAlarmTime=statAlarmTime, ifvcePulseMakeBreak_ms=ifvcePulseMakeBreak_ms, schedulePeriod=schedulePeriod, statIfwanT1E1ESS=statIfwanT1E1ESS, phoneIndex=phoneIndex, ifwanFallBackSpeedEnable=ifwanFallBackSpeedEnable, statIfwanChAborts=statIfwanChAborts, ifwanCrc4=ifwanCrc4, puTable=puTable, ifwanPortToBack=ifwanPortToBack, dP83936=dP83936, statTxStatusEnquiryMessages=statTxStatusEnquiryMessages, ifwanPppPeerMruUpTo=ifwanPppPeerMruUpTo, proxyIpAddr=proxyIpAddr, statSvcFramesRx=statSvcFramesRx, ospfVLinkTransitDelay=ospfVLinkTransitDelay, ifwanMgmtInterface=ifwanMgmtInterface, bridgeTr_SteSpan=bridgeTr_SteSpan)
mibBuilder.exportSymbols("PRESTICOM7-MIB", statSvcInfoSignal=statSvcInfoSignal, ifwanOspfPassword=ifwanOspfPassword, ifwanHighPriorityTransparentClass=ifwanHighPriorityTransparentClass, ifwanDigitNumber=ifwanDigitNumber, pvcIpRipPassword=pvcIpRipPassword, ospfAreaNumber=ospfAreaNumber, filterActive=filterActive, statRxBytes=statRxBytes, statTxDisconnectMessages=statTxDisconnectMessages, pvcIpRip=pvcIpRip, statSvcMeanTx=statSvcMeanTx, ifwanExtNumber=ifwanExtNumber, statSvcSpeed=statSvcSpeed, pvcIndex=pvcIndex, timepClientProtocol=timepClientProtocol, statSvcError=statSvcError, ifwanMaxChannels=ifwanMaxChannels, statIflanIndex=statIflanIndex, ifvceToneOn_ms=ifvceToneOn_ms, bondTrig=bondTrig, sysSpeedDialNumLength=sysSpeedDialNumLength, schedulePort7=schedulePort7, statBridgePortDesignatedCost=statBridgePortDesignatedCost, iflanIpxNetNum=iflanIpxNetNum, bootpEnable=bootpEnable, ifwanTxStartCop=ifwanTxStartCop, puBnnFid=puBnnFid, statPvcIndex=statPvcIndex, schedulePort2=schedulePort2, ifvceR2Group2Digit=ifvceR2Group2Digit, ipstaticNumber=ipstaticNumber, iflanOspfPriority=iflanOspfPriority, ipstaticNextHop=ipstaticNextHop, statBridgeBridgeFrameDiscard=statBridgeBridgeFrameDiscard, slotIfIndex=slotIfIndex, ifvceAnalogLinkDwnBusy=ifvceAnalogLinkDwnBusy, statIfvceOverruns=statIfvceOverruns, connectionDown=connectionDown, ifwanIpxNetNum=ifwanIpxNetNum, ifwanDialTimeout_s=ifwanDialTimeout_s, ospfAreaEnable=ospfAreaEnable, ifwanIpRipAuthType=ifwanIpRipAuthType, ifvceDtmfOnTime=ifvceDtmfOnTime, statPvcError=statPvcError, badDestPort=badDestPort, statPvcDlci=statPvcDlci, accountingFileOverflow=accountingFileOverflow, statBridgePortTr_AllRteFrameOut=statBridgePortTr_AllRteFrameOut, sysPosRackId=sysPosRackId, puLinkRemoteUnit=puLinkRemoteUnit, statBootpRequestReceivedOnPortBootpc=statBootpRequestReceivedOnPortBootpc, statIfwanT1E1LCV=statIfwanT1E1LCV, schedulePort5=schedulePort5, sysRingFreq=sysRingFreq, bridgeStpEnable=bridgeStpEnable, statIfwanBadOctets=statIfwanBadOctets, statSvcBadFrames=statSvcBadFrames, ifvceFxoTimeout_s=ifvceFxoTimeout_s, statAlarmIndex=statAlarmIndex, ospfRangeStatus=ospfRangeStatus, statPvcOctetsTx=statPvcOctetsTx, schedulePort6=schedulePort6, ospfRangeIndex=ospfRangeIndex, sysPosIpAddr=sysPosIpAddr, ifvceSilenceSuppress=ifvceSilenceSuppress, statIfvceState=statIfvceState, iflanTable=iflanTable, sysLocation=sysLocation, statTimeClientSyncFailures=statTimeClientSyncFailures, statPvcProtocol=statPvcProtocol, iflanOspfAreaId=iflanOspfAreaId, bootpIpDestAddr1=bootpIpDestAddr1, pvcNetworkPort=pvcNetworkPort, intfNumber=intfNumber, ifvceSignaling=ifvceSignaling, ifwanClassNumber=ifwanClassNumber, statIflanEthLateCollision=statIflanEthLateCollision, statBridgePortTr_SegmentMismatch=statBridgePortTr_SegmentMismatch, phoneNumber=phoneNumber, filterIndex=filterIndex, ifwanPppAcceptMagicNum=ifwanPppAcceptMagicNum, filter=filter, ifwanBackupCall_s=ifwanBackupCall_s, statTxStatusMessages=statTxStatusMessages, pvcBackupCall_s=pvcBackupCall_s, sysLinkTimeout_s=sysLinkTimeout_s, ifwanCoding=ifwanCoding, scheduleNumber=scheduleNumber, pvcHuntForwardingAUnit=pvcHuntForwardingAUnit, ipstatic=ipstatic, phonePhoneNumber=phonePhoneNumber, ifvceProtocol=ifvceProtocol, statReleaseIndications=statReleaseIndications, ifwanPppRemoteSubnetMask=ifwanPppRemoteSubnetMask, ifvceDesc=ifvceDesc, statSystemPeakCompRate=statSystemPeakCompRate, iflanOspfRetransmitInt=iflanOspfRetransmitInt, ifwanRingNumber=ifwanRingNumber, iflanEntry=iflanEntry, pvcInfoRate=pvcInfoRate, statBootpCannotReceiveAndForwardOnTheSamePort=statBootpCannotReceiveAndForwardOnTheSamePort, statIflanEthOneCollision=statIflanEthOneCollision, sysClock=sysClock, ifwanMsn3=ifwanMsn3, ifvceRate6kx3=ifvceRate6kx3, statIfwanTable=statIfwanTable, statBridgePortTr_SingleRteFrameIn=statBridgePortTr_SingleRteFrameIn, puBanBnnSsap=puBanBnnSsap, statPuIndex=statPuIndex, ifwanPollDelay_ms=ifwanPollDelay_ms, ifwanEnquiryTimer_s=ifwanEnquiryTimer_s, pvcDown=pvcDown, ifwanPppNegociateAccm=ifwanPppNegociateAccm, cardup=cardup, ifwanT1E1InterBit=ifwanT1E1InterBit, sysSnmpTrapIpAddr3=sysSnmpTrapIpAddr3, statPuChOverflows=statPuChOverflows, statPvcPeakRx=statPvcPeakRx, puNumber=puNumber, puBanBnnWindow=puBanBnnWindow, pvcIpRipAuthType=pvcIpRipAuthType, statPvcrRouteIntrf=statPvcrRouteIntrf, statGrpSorterTimeouts=statGrpSorterTimeouts, pvcType=pvcType, proxyIndex=proxyIndex, pvcMode=pvcMode, puLinkClassNumber=puLinkClassNumber, statIflanEthDeferredTrans=statIflanEthDeferredTrans, sysHuntForwardingAUnit=sysHuntForwardingAUnit, statTxReleaseCompleteMessages=statTxReleaseCompleteMessages, noMsg=noMsg, ifwanIpRipPassword=ifwanIpRipPassword, ver6X_Device=ver6X_Device, statTimep=statTimep, statRxDisconnectMessages=statRxDisconnectMessages, puLinkRemPu=puLinkRemPu, ifwanProtocol=ifwanProtocol, ifvceDVCLocalInbound=ifvceDVCLocalInbound, statPuChSeqErrs=statPuChSeqErrs, timepTimeZoneSign=timepTimeZoneSign, sysBackplaneRipVersion=sysBackplaneRipVersion, iflanIpAddress=iflanIpAddress, ifvceRate4k8x2=ifvceRate4k8x2, ifwanFallBackSpeed_bps=ifwanFallBackSpeed_bps, statSvcRestart=statSvcRestart, pvcRingNumber=pvcRingNumber, ipaddrIfIndex=ipaddrIfIndex, ifwanSfMode=ifwanSfMode, statIfwanT1E1SES=statIfwanT1E1SES, statIfwanMeanTx=statIfwanMeanTx, ifwanSpeed_bps=ifwanSpeed_bps, statIflanEthFrameCheckSeq=statIflanEthFrameCheckSeq, ipxfilterType=ipxfilterType, proxyDefaultGateway=proxyDefaultGateway, intfDesc=intfDesc, statIfwanT1E1UAS=statIfwanT1E1UAS, statLinkEstablished=statLinkEstablished, pvcSubnetMask=pvcSubnetMask, sysHuntForwardingBSvcAddress=sysHuntForwardingBSvcAddress, scheduleTable=scheduleTable, ospfVLinkTransitAreaId=ospfVLinkTransitAreaId, statIflanTrReceiveCongestion=statIflanTrReceiveCongestion, puBanBnnNw=puBanBnnNw, ipstaticMask=ipstaticMask, statGrpIndex=statGrpIndex, q922Up=q922Up, statPvcSpeed=statPvcSpeed, sysPosId=sysPosId, puBanRouting=puBanRouting, ifwanQsigPbxAb=ifwanQsigPbxAb, statIfvceFaxMode=statIfvceFaxMode, ifwanT1E1Status=ifwanT1E1Status, statIfwanBadFlags=statIfwanBadFlags, statIflanMeanTx_kbps=statIflanMeanTx_kbps, statTxAcknowledgeExpiry=statTxAcknowledgeExpiry, ifvceR2ExtendedDigitSrc=ifvceR2ExtendedDigitSrc, sysDefaultIpAddr=sysDefaultIpAddr, sysPosTable=sysPosTable, ifwanRxFlow=ifwanRxFlow, slotPortInSlotTable=slotPortInSlotTable, firmwareStored=firmwareStored, intfTable=intfTable, ospfVLinkDeadInt=ospfVLinkDeadInt, statGrpEntry=statGrpEntry, statSvcMode=statSvcMode, statIfwanChOverflows=statIfwanChOverflows, pvcProxyAddr=pvcProxyAddr, ifwanX25Encapsulation=ifwanX25Encapsulation, ifwanChUse=ifwanChUse, statIfwanInterface=statIfwanInterface, statIfwanTrspState=statIfwanTrspState, statGrp=statGrp, statBootpNbRequestReceived=statBootpNbRequestReceived, ifvceTable=ifvceTable, statTimeInvalidLocalIpAddress=statTimeInvalidLocalIpAddress, bridgeForwardDelay_s=bridgeForwardDelay_s, ospf=ospf, ifwanCllm=ifwanCllm, ifwanRemotePort=ifwanRemotePort, filterNumber=filterNumber, intfSlotType=intfSlotType, ifwanSubnetMask=ifwanSubnetMask, ospfRangeAddToArea=ospfRangeAddToArea, ifwanSvcReleaseTimeoutT308=ifwanSvcReleaseTimeoutT308, statIfvceEntry=statIfvceEntry, statSystemResetCounters=statSystemResetCounters, phoneEntry=phoneEntry, ifvceRate6kx1=ifvceRate6kx1, statAlarmArg=statAlarmArg, sysRacksNr=sysRacksNr, ifvceFwdType=ifvceFwdType, proxyTable=proxyTable, ipstaticTable=ipstaticTable, pvcMaxFrame=pvcMaxFrame, q922Down=q922Down, statTxConnectMessages=statTxConnectMessages, statPvcrRouteMetric=statPvcrRouteMetric, statBridgePort=statBridgePort, ifwanEntry=ifwanEntry, pvcBroadcastGroup=pvcBroadcastGroup, statIfwanOvrOctets=statIfwanOvrOctets, statTxRetransmissions=statTxRetransmissions, sysAcceptLoop=sysAcceptLoop, timepServerIpAddress=timepServerIpAddress, sysExtendedDigitsLength=sysExtendedDigitsLength, statBridgeBridgeFrameFiltered=statBridgeBridgeFrameFiltered, netperformer7=netperformer7, pvcOspfAreaId=pvcOspfAreaId, schedule=schedule, bridgeEnable=bridgeEnable, ifwanBodCall_s=ifwanBodCall_s, pvcHuntForwardingBUnit=pvcHuntForwardingBUnit, puBanDa=puBanDa, statIfwanT1E1LES=statIfwanT1E1LES, ospfVLinkPassword=ospfVLinkPassword, statBridgePortIndex=statBridgePortIndex, ifwanTerminating=ifwanTerminating, statTxReleaseMessages=statTxReleaseMessages, statIfwanQ922State=statIfwanQ922State, bridge=bridge, iflanDesc=iflanDesc, ospfRangeEnable=ospfRangeEnable, statIfwanRestart=statIfwanRestart, statRxStatusMessages=statRxStatusMessages, sysPosEntry=sysPosEntry, statSystemClearAlarms=statSystemClearAlarms, puSdlcMaxFrame=puSdlcMaxFrame, pvcOspfMetricCost=pvcOspfMetricCost, puSdlcAddress=puSdlcAddress, ospfArea=ospfArea, ipstaticIpDest=ipstaticIpDest, statBootpCannotRouteFrame=statBootpCannotRouteFrame, sysTransitDelay_s=sysTransitDelay_s, puLlcWindow=puLlcWindow)
mibBuilder.exportSymbols("PRESTICOM7-MIB", statBridgePortTr_FrmLngExceeded=statBridgePortTr_FrmLngExceeded, statIfwanT1E1BES=statIfwanT1E1BES, statIfcemEntry=statIfcemEntry, mibEvolution=mibEvolution, ospfVLinkEntry=ospfVLinkEntry, classPrefRoute=classPrefRoute, ifwanDialer=ifwanDialer, mibVersionInfo=mibVersionInfo, ifvceDelDigits=ifvceDelDigits, statPuEntry=statPuEntry, statBootpNbRequestSend=statBootpNbRequestSend, ifwan=ifwan, pvcBurstInfoRate=pvcBurstInfoRate, ifwanSvcCallProceedingTimeoutT310=ifwanSvcCallProceedingTimeoutT310, sysDLCI=sysDLCI, ipaddrAddr=ipaddrAddr, ifwanSfCarrierId=ifwanSfCarrierId, statSystemTr_Nan=statSystemTr_Nan, intf=intf, sysVoiceLog=sysVoiceLog, ipRouterEnable=ipRouterEnable, tMS380C30=tMS380C30, ifwanPppAcceptableAccmChar=ifwanPppAcceptableAccmChar, product=product, puSdlcRetry=puSdlcRetry, pvcPriority=pvcPriority, bootpIpDestAddr2=bootpIpDestAddr2, ifwanTxHold_s=ifwanTxHold_s, statSystemMeanDecompRate=statSystemMeanDecompRate, ifvceFwdDigits=ifvceFwdDigits, slotSlot=slotSlot, intfModuleType=intfModuleType, statPvcChOverflows=statPvcChOverflows, pvcBrgConnection=pvcBrgConnection, pvcIpConnection=pvcIpConnection, statBridgeBridgeRootPort=statBridgeBridgeRootPort, ifvceEnableDtmfOnTime=ifvceEnableDtmfOnTime, statSystemAlarmNumber=statSystemAlarmNumber, statPvcOctetsRx=statPvcOctetsRx, backupHang=backupHang, badChecksum=badChecksum, iflanIpxSap=iflanIpxSap, puXidPuType=puXidPuType, intfSlotNumber=intfSlotNumber, phoneRemoteUnit=phoneRemoteUnit, pvcTable=pvcTable, statBridgePortTr_SingleRteFrameOut=statBridgePortTr_SingleRteFrameOut, backupCall=backupCall, statPuTable=statPuTable, ospfAreaAuthType=ospfAreaAuthType, statIflanEthAlign=statIflanEthAlign, statIflanEntry=statIflanEntry, statIfwanBadFrames=statIfwanBadFrames, ifwanDropSyncCounter=ifwanDropSyncCounter, statBridgeBridge=statBridgeBridge, statBootpReplyWithInvalidGiaddr=statBootpReplyWithInvalidGiaddr, statIfwanRetries=statIfwanRetries, ifvceDVCLocalOutbound=ifvceDVCLocalOutbound, pvcUserDlci=pvcUserDlci, ospfVLinkIndex=ospfVLinkIndex, statSystemBia=statSystemBia, statSvcEntry=statSvcEntry, statPvcrRouteName=statPvcrRouteName, statPvcEntry=statPvcEntry, sysPsMonitoring=sysPsMonitoring, pvcCost=pvcCost, iflanTr_Etr=iflanTr_Etr, ipxfilterNumber=ipxfilterNumber, ifwanSvcInactiveTimeoutT203=ifwanSvcInactiveTimeoutT203, puXid=puXid, slotPortInSlot=slotPortInSlot, iflanNumber=iflanNumber, ifwanTxStart=ifwanTxStart, statIflanPeakTx_kbps=statIflanPeakTx_kbps, statIfwanFramesRx=statIfwanFramesRx, pvcCompression=pvcCompression, ifvceRemoteUnit=ifvceRemoteUnit, ifvceRate5k8x2=ifvceRate5k8x2, ifwanPppRequestMagicNum=ifwanPppRequestMagicNum, statAlarmDate=statAlarmDate, statPvcPeakTx=statPvcPeakTx, statPvcFramesTx=statPvcFramesTx, statIfwanPeakTx=statIfwanPeakTx, puXidFormat=puXidFormat, ifwanSvcAddressType=ifwanSvcAddressType, statTimeNbRequestReceived=statTimeNbRequestReceived, ifwanSync=ifwanSync, iflanOspfPassword=iflanOspfPassword, statGrpOutOfSeqErrs=statGrpOutOfSeqErrs, notMemory=notMemory, statSvcOvrFrames=statSvcOvrFrames, ifwanDropSyncCharacter=ifwanDropSyncCharacter, puLlcTr_Routing=puLlcTr_Routing, ifwanIdle=ifwanIdle, puBanBnnRetry=puBanBnnRetry, intfEntry=intfEntry, ifwanPppLocalMru=ifwanPppLocalMru, statRxframes=statRxframes, iflanOspfHelloInt=iflanOspfHelloInt, scheduleEndTime=scheduleEndTime, timepClientUdpTimeout=timepClientUdpTimeout, timep=timep, statPvcChSeqErrs=statPvcChSeqErrs, noDevice=noDevice, phoneTable=phoneTable, manualCall=manualCall, ifwanPppAcceptOldIpAddNeg=ifwanPppAcceptOldIpAddNeg, iflanSpeed=iflanSpeed, ifwanDsOSpeed_bps=ifwanDsOSpeed_bps, statGrpSorterOverruns=statGrpSorterOverruns, bothPsUp=bothPsUp, ifwanSvcDisconnectTimeoutT305=ifwanSvcDisconnectTimeoutT305, statPvcrRouteAge=statPvcrRouteAge, pvcIpxNetNum=pvcIpxNetNum, ifwanGainLimit=ifwanGainLimit, ifwanCellPacketization=ifwanCellPacketization, filterEntry=filterEntry, statIfwanTrspLastError=statIfwanTrspLastError, ospfGlobal=ospfGlobal, classDefaultClass=classDefaultClass, statBridgeBridgeFrameTimeout=statBridgeBridgeFrameTimeout, pvcIpRipTxRx=pvcIpRipTxRx, pvcRemoteFpUnit=pvcRemoteFpUnit, puBanBnnMaxFrame=puBanBnnMaxFrame, ifwanChExp=ifwanChExp, puMode=puMode, intfNumInType=intfNumInType, iflanPhysAddr=iflanPhysAddr, statPuChAborts=statPuChAborts, ifwanPppNegociatePeerMru=ifwanPppNegociatePeerMru, statBridgePortDestination=statBridgePortDestination, iflanTr_Monitor=iflanTr_Monitor, ifwanSvcSetupTimeoutT303=ifwanSvcSetupTimeoutT303, ifwanPppNegociateLocalMru=ifwanPppNegociateLocalMru, accountingFileFull=accountingFileFull, ifwanGroupAddress=ifwanGroupAddress, puLlcDynamicWindow=puLlcDynamicWindow, ifwanOspfMetricCost=ifwanOspfMetricCost, ifwanPppConfigRestartTimer=ifwanPppConfigRestartTimer, timepTimeZone=timepTimeZone, ospfRangeNumber=ospfRangeNumber, statIfwanOctetsRx=statIfwanOctetsRx, statIfwanEntry=statIfwanEntry, statIfcemDesc=statIfcemDesc, iflanIpRipTxRx=iflanIpRipTxRx, statTimeNbReplySent=statTimeNbReplySent, bothFansUp=bothFansUp, ospfRangeTable=ospfRangeTable, statIfvceTable=statIfvceTable, statPvcInfoSignal=statPvcInfoSignal, statSvcPeakTx=statSvcPeakTx, fatalMsg=fatalMsg, ifvceLocalInbound=ifvceLocalInbound, slotPortInSlotEntry=slotPortInSlotEntry, ifwanModem=ifwanModem, puSdlcTimeout_ms=puSdlcTimeout_ms, scheduleDay=scheduleDay, ifwanDuplex=ifwanDuplex, intfSlot=intfSlot, ifvceFaxModemRelay=ifvceFaxModemRelay, ifvceFwdDelay_ms=ifvceFwdDelay_ms, puLlcRetry=puLlcRetry, ifvceBroadcastPvc=ifvceBroadcastPvc, pvcLlcConnection=pvcLlcConnection, statBridgePortTr_SegmentDuplicate=statBridgePortTr_SegmentDuplicate, statQ933counters=statQ933counters, ifwanSignaling=ifwanSignaling, sysName=sysName, schedulePort4=schedulePort4, statIfwanSpeed=statIfwanSpeed, phoneNextHop=phoneNextHop, statIfwanT1E1SEF=statIfwanT1E1SEF, statRxReleaseMessages=statRxReleaseMessages, ifwanOspfTransitDelay=ifwanOspfTransitDelay, statSvcDlci=statSvcDlci, manualHang=manualHang, ifwanIpRip=ifwanIpRip, scheduleEntry=scheduleEntry, ifwanSvcNetworkAddress=ifwanSvcNetworkAddress, statSystemSa=statSystemSa, pvcOspfEnable=pvcOspfEnable, ifvceIndex=ifvceIndex, sysHuntForwardingASvcAddress=sysHuntForwardingASvcAddress, filterDefinition=filterDefinition, pvcPort=pvcPort, info=info, badDestPvc=badDestPvc, phone=phone, classNumber=classNumber, puDlsIpDst=puDlsIpDst, pvcRetry=pvcRetry, statIfwanT1E1CSS=statIfwanT1E1CSS, puRole=puRole, statTimeInvalidPortNumbers=statTimeInvalidPortNumbers, puSdlcPort2=puSdlcPort2, sysTrapRackandPos=sysTrapRackandPos, ifwanPppRemoteIpAddress=ifwanPppRemoteIpAddress, statRxCallProceedingMessages=statRxCallProceedingMessages, timepServerProtocol=timepServerProtocol, ifwanPppRequestedAccmChar=ifwanPppRequestedAccmChar, ipaddrNr=ipaddrNr, bootpIpDestAddr4=bootpIpDestAddr4, sysVoiceClocking=sysVoiceClocking, sysAutoSaveDelay=sysAutoSaveDelay, statSvcIndex=statSvcIndex, schedulePort1=schedulePort1, statPvcrRouteTable=statPvcrRouteTable, statTxCallProceedingMessages=statTxCallProceedingMessages, ifwanFrameDelay=ifwanFrameDelay, statIfvceLastError=statIfvceLastError, statBootpNbReplyReceived=statBootpNbReplyReceived, statBridgePortState=statBridgePortState, ipxRouterEnable=ipxRouterEnable, statIflanProtocol=statIflanProtocol, statBridgePortTr_SpecRteFrameOut=statBridgePortTr_SpecRteFrameOut, ifwanTxStartPass=ifwanTxStartPass, ifwanTxFlow=ifwanTxFlow, ifwanTimeout=ifwanTimeout, pvcOspfHelloInt=pvcOspfHelloInt, pvcRemoteUnit=pvcRemoteUnit, ifwanPppAcceptIpAddress=ifwanPppAcceptIpAddress, puDelayBeforeConn_s=puDelayBeforeConn_s, frLinkUp=frLinkUp, phoneCost=phoneCost, statIfvceDvcPortInUse=statIfvceDvcPortInUse, statPvcBadOctets=statPvcBadOctets, statIfwanProtocol=statIfwanProtocol, statIfwanState=statIfwanState, sysSnmpTrapIpAddr2=sysSnmpTrapIpAddr2, setupReset=setupReset, ifwanLineCoding=ifwanLineCoding, statPvcrRouteEntry=statPvcrRouteEntry, sysContact=sysContact, puLlcSsap=puLlcSsap, pu=pu, ifvceToneEnergyDetec=ifvceToneEnergyDetec, bridgeTr_MaxHop=bridgeTr_MaxHop, bridgeTr_Number=bridgeTr_Number, statQ922errors=statQ922errors, ifvce=ifvce, frLinkDown=frLinkDown, statPvcState=statPvcState, ifwanInterface=ifwanInterface, intfNumInSlot=intfNumInSlot, iflanCost=iflanCost, statMissingControlBlocks=statMissingControlBlocks, ifvceExtendedDigitSrc=ifvceExtendedDigitSrc, pvcUserPort=pvcUserPort, pvcIpxSap=pvcIpxSap, ifwanConnTimeout_s=ifwanConnTimeout_s, ospfGlobalRouterId=ospfGlobalRouterId, iflan=iflan, statPuConnectionStatus=statPuConnectionStatus, iflanOspfEnable=iflanOspfEnable)
mibBuilder.exportSymbols("PRESTICOM7-MIB", proxyNumber=proxyNumber, ifwanSvcMaxTxTimeoutT200=ifwanSvcMaxTxTimeoutT200, ipstaticValid=ipstaticValid, statBridgePortDesignatedBridge=statBridgePortDesignatedBridge, classWeight=classWeight, ifwanIpAddress=ifwanIpAddress, ifwanChannelCompressed=ifwanChannelCompressed, pvcNetworkDlci=pvcNetworkDlci, ifvceR2CompleteDigit=ifvceR2CompleteDigit, ifvceMaxFaxModemRate=ifvceMaxFaxModemRate, proxyComm=proxyComm, ifvceRate8kx3=ifvceRate8kx3, ifwanRetry=ifwanRetry, iflanSubnetMask=iflanSubnetMask, statPuCompErrs=statPuCompErrs, bootp=bootp, ifvceToneOff_ms=ifvceToneOff_ms, statPvcBadFrames=statPvcBadFrames, linkUp=linkUp, ifwanNumber=ifwanNumber, statIflanRetries=statIflanRetries, ifvceHuntGroup=ifvceHuntGroup, ifwanCondLMIPort=ifwanCondLMIPort, ipxfilterEntry=ipxfilterEntry, sysPosProduct=sysPosProduct, ospfAreaAreaId=ospfAreaAreaId, statSystem=statSystem, ospfAreaTable=ospfAreaTable, ifvceNumber=ifvceNumber, ospfRange=ospfRange, statIfwanFramesTx=statIfwanFramesTx, ifvceActivationType=ifvceActivationType, ifwanIndex=ifwanIndex, ifwanDesc=ifwanDesc, stat=stat, puSdlcWindow=puSdlcWindow, periodEnded=periodEnded, statRxStatusEnquiryMessages=statRxStatusEnquiryMessages, iflanOspfDeadInt=iflanOspfDeadInt, sysPosNr=sysPosNr, statTimeNbRequestSent=statTimeNbRequestSent, sysRingVolt=sysRingVolt, statSystemPeakDecompRate=statSystemPeakDecompRate, statGrpNumber=statGrpNumber, ipstaticEntry=ipstaticEntry, ifwanSfType=ifwanSfType, timepDaylightSaving=timepDaylightSaving, ifwanTeiMode=ifwanTeiMode, statSvcPeakRx=statSvcPeakRx, ifwanPvcNumber=ifwanPvcNumber, ifvceDVCSilenceSuppress=ifvceDVCSilenceSuppress, puDlsDsap=puDlsDsap, ipxfilterSap=ipxfilterSap, statIflanSpeed=statIflanSpeed, puLlcDa=puLlcDa, statQ922counters=statQ922counters, mC68EN360=mC68EN360, statSvcOctetsTx=statSvcOctetsTx, ospfGlobalAutoVLink=ospfGlobalAutoVLink, sysVoiceHighestPriority=sysVoiceHighestPriority, oneOrMoreFanDown=oneOrMoreFanDown, statSystemSp=statSystemSp, pvcPvcClass=pvcPvcClass, ospfVLinkRetransmitInt=ospfVLinkRetransmitInt, statSystemClearErrorLed=statSystemClearErrorLed, puDlsSsap=puDlsSsap, ospfAreaStubMetric=ospfAreaStubMetric, classTable=classTable, ifwanFlowControl=ifwanFlowControl, pvcIpxConnection=pvcIpxConnection, statPvcFramesRx=statPvcFramesRx, bridgeMaxAge_s=bridgeMaxAge_s, statIflanEthThreeAndMoreCol=statIflanEthThreeAndMoreCol, puLlcMaxFrame=puLlcMaxFrame, statSystemMeanCompRate=statSystemMeanCompRate, ipaddrType=ipaddrType, ifwanBodLevel=ifwanBodLevel, ifwanDestExtNumber=ifwanDestExtNumber, linkDown=linkDown, ifwanCompression=ifwanCompression, statBridgePortEntry=statBridgePortEntry, ifvceEntry=ifvceEntry, statTimeClientRetransmissions=statTimeClientRetransmissions, statIflanBadFlags=statIflanBadFlags, statIfvceIndex=statIfvceIndex, statTxIframeQdiscards=statTxIframeQdiscards, pvcNumber=pvcNumber, iflanIpxLanType=iflanIpxLanType, ospfAreaEntry=ospfAreaEntry, iflanIndex=iflanIndex, puDlsIpSrc=puDlsIpSrc, statIfwanT1E1DM=statIfwanT1E1DM, statPvcMode=statPvcMode, statRxConnectMessages=statRxConnectMessages, statProtocolTimeouts=statProtocolTimeouts, cfgStored=cfgStored, statIfwanModemSignal=statIfwanModemSignal, sysVoiceClass=sysVoiceClass, ospfGlobalGlobalAreaId=ospfGlobalGlobalAreaId, ifwanBackupHang_s=ifwanBackupHang_s, pvcEntry=pvcEntry, ipxfilterIndex=ipxfilterIndex, statIfwanPeakRx=statIfwanPeakRx, ipx=ipx, puDlsDa=puDlsDa, bridgeLanType=bridgeLanType, ifwanRemoteUnit=ifwanRemoteUnit, puLlcDsap=puLlcDsap, onePsDown=onePsDown, statBridgePortTrspFrameIn=statBridgePortTrspFrameIn, iflanMaxFrame=iflanMaxFrame, statIfvceDesc=statIfvceDesc, sysDialTimer=sysDialTimer, iflanOspfTransitDelay=iflanOspfTransitDelay, sysHuntForwardingADLCI=sysHuntForwardingADLCI, ifwanT1E1LoopBack=ifwanT1E1LoopBack, ifwanFormat=ifwanFormat, ifwanFraming=ifwanFraming, statIfwanChSeqErrs=statIfwanChSeqErrs, ifwanOspfAreaId=ifwanOspfAreaId, statSystemNa=statSystemNa)

#
# PySNMP MIB module IBM6611-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/IBM6611-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:51:24 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ConstraintsIntersection, ValueSizeConstraint, SingleValueConstraint, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ConstraintsIntersection", "ValueSizeConstraint", "SingleValueConstraint", "ValueRangeConstraint")
DisplayString, = mibBuilder.importSymbols("RFC1158-MIB", "DisplayString")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
ModuleIdentity, Counter32, IpAddress, TimeTicks, ObjectIdentity, enterprises, iso, Counter64, Integer32, Unsigned32, Gauge32, Bits, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, NotificationType = mibBuilder.importSymbols("SNMPv2-SMI", "ModuleIdentity", "Counter32", "IpAddress", "TimeTicks", "ObjectIdentity", "enterprises", "iso", "Counter64", "Integer32", "Unsigned32", "Gauge32", "Bits", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "NotificationType")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
ibm = MibIdentifier((1, 3, 6, 1, 4, 1, 2))
ibmProd = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6))
ibm6611 = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2))
ibmSubagents = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 1))
ibmChipSets = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 2))
ibmDSUs = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 3))
ibmsystem = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 4))
ibmicmp = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 5))
ibmsnmp = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 6))
ibmbridge = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 7))
ibmfr = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 8))
ibmdls = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 9))
ibmppp = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 10))
ibmxns = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 11))
ibmipx = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 12))
ibmappn = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 13))
ibmrpq = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 14))
ibmtb = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 15))
ibmapple = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 16))
ibmdec = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 17))
ibmvines = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 18))
ibminterfaces = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 19))
ibmMainProcessorLoadTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 4, 1), )
if mibBuilder.loadTexts: ibmMainProcessorLoadTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmMainProcessorLoadTable.setDescription('A table containing the average main processor load over each minute for the last 60 minutes.')
ibmMainProcessorLoadEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 4, 1, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmMainProcessorLoadIndex"))
if mibBuilder.loadTexts: ibmMainProcessorLoadEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmMainProcessorLoadEntry.setDescription('An entry in the main processor load table.')
ibmMainProcessorLoadIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 60))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMainProcessorLoadIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmMainProcessorLoadIndex.setDescription('Indicates the number of minutes ago that this entry contains main processor load information for.')
ibmMainProcessorLoad = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 4, 1, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMainProcessorLoad.setStatus('mandatory')
if mibBuilder.loadTexts: ibmMainProcessorLoad.setDescription('The main processor load averaged over one minute. The load is given as a percentage. For example, 25% is 25.')
ibmswvpd = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 4, 2))
swVpdTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 4, 2, 1), )
if mibBuilder.loadTexts: swVpdTable.setStatus('mandatory')
if mibBuilder.loadTexts: swVpdTable.setDescription('A table containing software vital product data information.')
swVpdEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 4, 2, 1, 1), ).setIndexNames((0, "IBM6611-MIB", "swvpdIndex"))
if mibBuilder.loadTexts: swVpdEntry.setStatus('mandatory')
if mibBuilder.loadTexts: swVpdEntry.setDescription('An entry for a piece of software installed on this router.')
swvpdIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 4, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swvpdIndex.setStatus('mandatory')
if mibBuilder.loadTexts: swvpdIndex.setDescription('A unique value for each entry in this table.')
swvpdName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 4, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swvpdName.setStatus('mandatory')
if mibBuilder.loadTexts: swvpdName.setDescription('The name of this software product.')
swvpdPtfName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 4, 2, 1, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swvpdPtfName.setStatus('mandatory')
if mibBuilder.loadTexts: swvpdPtfName.setDescription('If this entry represents a PTF, this object contains the name of the PTF. Otherwise this object contains a string of zero length.')
swvpdVerId = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 4, 2, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swvpdVerId.setStatus('mandatory')
if mibBuilder.loadTexts: swvpdVerId.setDescription('The version identifier for this piece of software.')
swvpdRelId = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 4, 2, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swvpdRelId.setStatus('mandatory')
if mibBuilder.loadTexts: swvpdRelId.setDescription('The release identifier for this piece of software.')
swvpdModId = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 4, 2, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swvpdModId.setStatus('mandatory')
if mibBuilder.loadTexts: swvpdModId.setDescription('The modification level identifier for this piece of software.')
swvpdFixId = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 4, 2, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swvpdFixId.setStatus('mandatory')
if mibBuilder.loadTexts: swvpdFixId.setDescription('The fix level identifier for this piece of software.')
swvpdState = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 4, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("complete", 1), ("pending", 2), ("broken", 3), ("cancelled", 4), ("unknown", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swvpdState.setStatus('mandatory')
if mibBuilder.loadTexts: swvpdState.setDescription('The state of the action in swvpdAction being performed on this software.')
swvpdAction = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 4, 2, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("apply", 1), ("commit", 2), ("reject", 3), ("decommit", 4), ("cleanup", 5), ("unknown", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swvpdAction.setStatus('mandatory')
if mibBuilder.loadTexts: swvpdAction.setDescription('The action being performed on this software.')
swvpdPath = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 4, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("root", 1), ("usr", 2), ("share", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swvpdPath.setStatus('mandatory')
if mibBuilder.loadTexts: swvpdPath.setDescription('An indication of which part of the system this software is installed on. The values correspond to the following paths: root(1) /etc/objrepos usr(2) /usr/lib/objrepos share(3) /usr/share/lib/objrepos')
swvpdDateTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 4, 2, 1, 1, 11), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swvpdDateTime.setStatus('mandatory')
if mibBuilder.loadTexts: swvpdDateTime.setDescription('A string indicating the date and time that the action in swvpdAction was performed on this software.')
ibmmaint = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 4, 4))
ibmmaintShutdown = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 4, 4, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4))).clone(namedValues=NamedValues(("running", 1), ("shutdown-noipl", 2), ("shutdown-ipl-local", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmmaintShutdown.setStatus('mandatory')
if mibBuilder.loadTexts: ibmmaintShutdown.setDescription('When read, an active 6611 will return the value running(1). To force a shutdown, without a subsequent re-ipl of the 6611, this value should be set to shutdown-noipl(2). To recyle the 6611, (i.e.- shutdown with a subsequent re-ipl), and use the currently installed configuration, this variable should be set to shutdown-ipl-local(4).')
ibmsysInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 4, 4, 7))
ibmsysMBUFs = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 4, 4, 7, 1))
ibmsysMBUFsInUses = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 4, 4, 7, 1, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmsysMBUFsInUses.setStatus('mandatory')
if mibBuilder.loadTexts: ibmsysMBUFsInUses.setDescription('Number of kernel MBUFs currently in use.')
ibmsysMBUFsKbytes = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 4, 4, 7, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmsysMBUFsKbytes.setStatus('mandatory')
if mibBuilder.loadTexts: ibmsysMBUFsKbytes.setDescription('Kbytes of MBUFs currently allocated to the network.')
ibmsysMBUFsPercents = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 4, 4, 7, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmsysMBUFsPercents.setStatus('mandatory')
if mibBuilder.loadTexts: ibmsysMBUFsPercents.setDescription('Percentage of total MBUFs available that are currently allocated to the network')
ibmsysMBUFsDeniedRequests = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 4, 4, 7, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmsysMBUFsDeniedRequests.setStatus('mandatory')
if mibBuilder.loadTexts: ibmsysMBUFsDeniedRequests.setDescription('Number of MBUF requests that were denied due to lack of resources.')
ibmsysMBUFsDelayedRequests = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 4, 4, 7, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmsysMBUFsDelayedRequests.setStatus('mandatory')
if mibBuilder.loadTexts: ibmsysMBUFsDelayedRequests.setDescription('Number of MBUF requests that were delayed due to lack of resources.')
ibmsysPageSpace = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 4, 4, 7, 2))
ibmsysPageSpaceTotal = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 4, 4, 7, 2, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmsysPageSpaceTotal.setStatus('mandatory')
if mibBuilder.loadTexts: ibmsysPageSpaceTotal.setDescription('Total number of paging space pages available on the 6611. A page is defined as 4096 bytes, so for example, an ibmsysPageSpaceTotal value of 12288 equals 12288 * 4096 = 50331648 bytes of paging space.')
ibmsysPageSpaceInUse = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 4, 4, 7, 2, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmsysPageSpaceInUse.setStatus('mandatory')
if mibBuilder.loadTexts: ibmsysPageSpaceInUse.setDescription('Total number of paging space pages currently in use on the 6611. A page is defined as 4096 bytes, so for example, an ibmsysPageSpaceInUse value of 8839 equals 8839 * 4096 = 36204544 bytes of paging space in use.')
ibmsysRealMem = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 4, 4, 7, 3))
ibmsysRealMemSize = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 4, 4, 7, 3, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmsysRealMemSize.setStatus('mandatory')
if mibBuilder.loadTexts: ibmsysRealMemSize.setDescription('Total number of real memory frames available on the 6611. A frame is defined as 4096 bytes, so for example, an ibmsysRealMemSize value of 4096 equals 4096 * 4096 = 16777216 bytes of real memory.')
ibmsysRealMemInUse = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 4, 4, 7, 3, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmsysRealMemInUse.setStatus('mandatory')
if mibBuilder.loadTexts: ibmsysRealMemInUse.setDescription('Total number of real memory frames currently in use on the 6611. A frame is defined as 4096 bytes, so for example, an ibmsysRealMemInUse value of 4025 equals 4025 * 4096 = 16486400 bytes of real memory in use.')
ibmsysRealMemFree = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 4, 4, 7, 3, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmsysRealMemFree.setStatus('mandatory')
if mibBuilder.loadTexts: ibmsysRealMemFree.setDescription('Total number of real memory frames currently free on the 6611. A frame is defined as 4096 bytes, so for example, an ibmsysRealMemFree value of 71 equals 71 * 4096 = 290816 bytes of real memory free.')
ibmTrapNum = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 6, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmTrapNum.setStatus('mandatory')
if mibBuilder.loadTexts: ibmTrapNum.setDescription('Number of IBM enterprise specific traps generated by this node.')
ibmTrapThrottleCount = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 6, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmTrapThrottleCount.setStatus('mandatory')
if mibBuilder.loadTexts: ibmTrapThrottleCount.setDescription('Number of traps throttled since last trap.')
ibmTrapThrottleId = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 6, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmTrapThrottleId.setStatus('mandatory')
if mibBuilder.loadTexts: ibmTrapThrottleId.setDescription('Trap ID of throttled traps. All throttled traps counted by ibmTrapThrottleCount have the this ID.')
ibmTrapThrottleTime = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 6, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmTrapThrottleTime.setStatus('mandatory')
if mibBuilder.loadTexts: ibmTrapThrottleTime.setDescription('Number of seconds which must separate consecutive enterprise-specific traps with identical ID in order to not throttle them. If the value of this object is 0, then trap throttling is inactive.')
ibmChipSetIntel = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 2, 1))
ibmChipSetIntel82596B = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 2, 1, 1))
ibmChipSetIBM = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 2, 2))
ibmChipSetIBM8025A = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 2, 2, 1))
ibmChipSetIBM8025B = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 2, 2, 2))
ibmChipSetSignetics = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 2, 3))
ibmChipSetSigneticsSCN68562 = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 2, 3, 1))
ibmbridgeMACAddressFilters = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 1))
ibmbridgeSAPFilters = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 2))
ibmbridgeSNAPFilters = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 3))
ibmbridgeRingFilters = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 4))
ibmbridgeHopCountFilters = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 5))
ibmbridgeWindowFilters = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 6))
ibmbridgeFiltOrderTable = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 7))
ibmbridgeRIFFilters = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 8))
ibmmacAddrFilterInfoTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 1, 1), )
if mibBuilder.loadTexts: ibmmacAddrFilterInfoTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmmacAddrFilterInfoTable.setDescription('Table of MAC address filtering information.')
ibmmacAddrFilterInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 1, 1, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmmacAddrFilterType"), (0, "IBM6611-MIB", "ibmmacAddrFilterIfIndex"))
if mibBuilder.loadTexts: ibmmacAddrFilterInfoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmmacAddrFilterInfoEntry.setDescription('MAC address filtering information for a single interface.')
ibmmacAddrFilterIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmmacAddrFilterIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmmacAddrFilterIfIndex.setDescription('The value of this object identifies the interface for which this entry contains management information. The value of this object for a particular interface has the same value as the ifIndex object for the same interface.')
ibmmacAddrFilterInBcastType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("filterARB", 1), ("filterSRB", 2), ("filterBoth", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmmacAddrFilterInBcastType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmmacAddrFilterInBcastType.setDescription('For the incoming MAC address filter table, determines what type of frames will be filtered.')
ibmmacAddrFilterOutBcastType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("filterARB", 1), ("filterSRB", 2), ("filterBoth", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmmacAddrFilterOutBcastType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmmacAddrFilterOutBcastType.setDescription('For the outgoing MAC address filter table, determines what type of frames will be filtered.')
ibmmacAddrFilterInFilterType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("deny", 1), ("permit", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmmacAddrFilterInFilterType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmmacAddrFilterInFilterType.setDescription('For the incoming filter table, determines whether the entries are permit or deny entries.')
ibmmacAddrFilterOutFilterType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("deny", 1), ("permit", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmmacAddrFilterOutFilterType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmmacAddrFilterOutFilterType.setDescription('For the outgoing filter table, determines whether the entries are permit or deny entries.')
ibmmacAddrFilterInNotForwarded = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 1, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmmacAddrFilterInNotForwarded.setStatus('mandatory')
if mibBuilder.loadTexts: ibmmacAddrFilterInNotForwarded.setDescription('Number of packets not forwarded, in the incoming direction, because they were filtered out.')
ibmmacAddrFilterOutNotForwarded = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 1, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmmacAddrFilterOutNotForwarded.setStatus('mandatory')
if mibBuilder.loadTexts: ibmmacAddrFilterOutNotForwarded.setDescription('Number of packets not forwarded, in the outgoing direction, because they were filtered out.')
ibmmacAddrFilterType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("sr", 1), ("tb", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmmacAddrFilterType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmmacAddrFilterType.setDescription('The type of entry, either sr or tb.')
ibmmacAddrFilterInTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 1, 2), )
if mibBuilder.loadTexts: ibmmacAddrFilterInTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmmacAddrFilterInTable.setDescription('Table of MAC address filtering information for incoming frames.')
ibmmacAddrFilterInEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 1, 2, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmmacAddrFilterInType"), (0, "IBM6611-MIB", "ibmmacAddrFilterInIfIndex"), (0, "IBM6611-MIB", "ibmmacAddrFilterInSrcAddress"), (0, "IBM6611-MIB", "ibmmacAddrFilterInDestAddress"))
if mibBuilder.loadTexts: ibmmacAddrFilterInEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmmacAddrFilterInEntry.setDescription('Filtering information for incoming frames.')
ibmmacAddrFilterInIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 1, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmmacAddrFilterInIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmmacAddrFilterInIfIndex.setDescription('The value of this object identifies the interface for which this entry contains management information. The value of this object for a particular interface has the same value as the ifIndex object for the same interface.')
ibmmacAddrFilterInSrcAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 1, 2, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmmacAddrFilterInSrcAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ibmmacAddrFilterInSrcAddress.setDescription('MAC source address to be filtered.')
ibmmacAddrFilterInSrcMask = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 1, 2, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmmacAddrFilterInSrcMask.setStatus('mandatory')
if mibBuilder.loadTexts: ibmmacAddrFilterInSrcMask.setDescription('Mask to allow ibmmacAddrFilterInSrcAddress to be used as a range of values.')
ibmmacAddrFilterInDestAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 1, 2, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmmacAddrFilterInDestAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ibmmacAddrFilterInDestAddress.setDescription('MAC destination address to be filtered.')
ibmmacAddrFilterInDestMask = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 1, 2, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmmacAddrFilterInDestMask.setStatus('mandatory')
if mibBuilder.loadTexts: ibmmacAddrFilterInDestMask.setDescription('Mask to allow ibmmacAddrFilterInDestAddress to be used as a range of values.')
ibmmacAddrFilterInType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 1, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("sr", 1), ("tb", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmmacAddrFilterInType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmmacAddrFilterInType.setDescription('The type of entry, either sr or tb.')
ibmmacAddrFilterOutTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 1, 3), )
if mibBuilder.loadTexts: ibmmacAddrFilterOutTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmmacAddrFilterOutTable.setDescription('Table of MAC address filtering information for outgoing frames.')
ibmmacAddrFilterOutEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 1, 3, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmmacAddrFilterOutType"), (0, "IBM6611-MIB", "ibmmacAddrFilterOutIfIndex"), (0, "IBM6611-MIB", "ibmmacAddrFilterOutSrcAddress"), (0, "IBM6611-MIB", "ibmmacAddrFilterOutDestAddress"))
if mibBuilder.loadTexts: ibmmacAddrFilterOutEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmmacAddrFilterOutEntry.setDescription('Filtering information for outgoing frames.')
ibmmacAddrFilterOutIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 1, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmmacAddrFilterOutIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmmacAddrFilterOutIfIndex.setDescription('The value of this object identifies the interface for which this entry contains management information. The value of this object for a particular interface has the same value as the ifIndex object for the same interface.')
ibmmacAddrFilterOutSrcAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 1, 3, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmmacAddrFilterOutSrcAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ibmmacAddrFilterOutSrcAddress.setDescription('MAC source address to be filtered.')
ibmmacAddrFilterOutSrcMask = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 1, 3, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmmacAddrFilterOutSrcMask.setStatus('mandatory')
if mibBuilder.loadTexts: ibmmacAddrFilterOutSrcMask.setDescription('Mask to allow ibmmacAddrFilterOutSrcAddress to be used as a range of values.')
ibmmacAddrFilterOutDestAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 1, 3, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmmacAddrFilterOutDestAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ibmmacAddrFilterOutDestAddress.setDescription('MAC destination address to be filtered.')
ibmmacAddrFilterOutDestMask = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 1, 3, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmmacAddrFilterOutDestMask.setStatus('mandatory')
if mibBuilder.loadTexts: ibmmacAddrFilterOutDestMask.setDescription('Mask to allow ibmmacAddrFilterOutDestAddress to be used as a range of values.')
ibmmacAddrFilterOutType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 1, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("sr", 1), ("tb", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmmacAddrFilterOutType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmmacAddrFilterOutType.setDescription('Type type of entry either sr or tb')
ibmsapFilterInfoTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 2, 1), )
if mibBuilder.loadTexts: ibmsapFilterInfoTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmsapFilterInfoTable.setDescription('Table of SAP filtering information.')
ibmsapFilterInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 2, 1, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmsapFilterType"), (0, "IBM6611-MIB", "ibmsapFilterIfIndex"))
if mibBuilder.loadTexts: ibmsapFilterInfoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmsapFilterInfoEntry.setDescription('SAP filtering information for a single interface.')
ibmsapFilterIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmsapFilterIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmsapFilterIfIndex.setDescription('The value of this object identifies the interface for which this entry contains management information. The value of this object for a particular interface has the same value as the ifIndex object for the same interface.')
ibmsapFilterInBcastType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("filterARB", 1), ("filterSRB", 2), ("filterBoth", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmsapFilterInBcastType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmsapFilterInBcastType.setDescription('For the incoming SAP filter table, determines what type of frames will be filtered.')
ibmsapFilterOutBcastType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("filterARB", 1), ("filterSRB", 2), ("filterBoth", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmsapFilterOutBcastType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmsapFilterOutBcastType.setDescription('For the outgoing SAP filter table, determines what type of frames will be filtered.')
ibmsapFilterIn = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 2, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmsapFilterIn.setStatus('mandatory')
if mibBuilder.loadTexts: ibmsapFilterIn.setDescription('A bitmap of all possible source SAPs (even) that will be on or off depending on whether or not an incoming frame with that SAP is to be forwarded.')
ibmsapFilterOut = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 2, 1, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmsapFilterOut.setStatus('mandatory')
if mibBuilder.loadTexts: ibmsapFilterOut.setDescription('A bitmap of all possible source SAPs (even) that will be on or off depending on whether or not an outgoing frame with that SAP is to be forwarded.')
ibmsapFilterInNotForwarded = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 2, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmsapFilterInNotForwarded.setStatus('mandatory')
if mibBuilder.loadTexts: ibmsapFilterInNotForwarded.setDescription('Number of packets not forwarded, in the incoming direction, because they were filtered out.')
ibmsapFilterOutNotForwarded = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 2, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmsapFilterOutNotForwarded.setStatus('mandatory')
if mibBuilder.loadTexts: ibmsapFilterOutNotForwarded.setDescription('Number of packets not forwarded, in the outgoing direction, because they were filtered out.')
ibmsapFilterType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("sr", 1), ("tb", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmsapFilterType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmsapFilterType.setDescription('The type of entry, either sr or tb.')
ibmsnapFilterInfoTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 3, 1), )
if mibBuilder.loadTexts: ibmsnapFilterInfoTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmsnapFilterInfoTable.setDescription('Table of SNAP filtering information. Note that SNAP filtering only comes into play if packets with source SAP 0xAA are being forwarded.')
ibmsnapFilterInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 3, 1, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmsnapFilterType"), (0, "IBM6611-MIB", "ibmsnapFilterIfIndex"))
if mibBuilder.loadTexts: ibmsnapFilterInfoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmsnapFilterInfoEntry.setDescription('SNAP filtering information for a single interface.')
ibmsnapFilterIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmsnapFilterIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmsnapFilterIfIndex.setDescription('The value of this object identifies the interface for which this entry contains management information. The value of this object for a particular interface has the same value as the ifIndex object for the same interface.')
ibmsnapFilterInFilterType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("deny", 1), ("permit", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmsnapFilterInFilterType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmsnapFilterInFilterType.setDescription('For the incoming SNAP filter table, determines whether the entries are permit or deny entries.')
ibmsnapFilterOutFilterType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("deny", 1), ("permit", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmsnapFilterOutFilterType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmsnapFilterOutFilterType.setDescription('For the outgoing SNAP filter table, determines whether the entries are permit or deny entries.')
ibmsnapFilterInNotForwarded = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 3, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmsnapFilterInNotForwarded.setStatus('mandatory')
if mibBuilder.loadTexts: ibmsnapFilterInNotForwarded.setDescription('Number of packets not forwarded, in the incoming direction, because they were filtered out.')
ibmsnapFilterOutNotForwarded = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 3, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmsnapFilterOutNotForwarded.setStatus('mandatory')
if mibBuilder.loadTexts: ibmsnapFilterOutNotForwarded.setDescription('Number of packets not forwarded, in the outgoing direction, because they were filtered out.')
ibmsnapFilterType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("sr", 1), ("tb", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmsnapFilterType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmsnapFilterType.setDescription('The type of entry, either sr or tb.')
ibmsnapFilterInTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 3, 2), )
if mibBuilder.loadTexts: ibmsnapFilterInTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmsnapFilterInTable.setDescription('Table of SNAP type filtering information for incoming frames. Note that the entries in this table only come into play if packets with source SAP 0xAA are being forwarded.')
ibmsnapFilterInEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 3, 2, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmsnapFilterInType"), (0, "IBM6611-MIB", "ibmsnapFilterInIfIndex"), (0, "IBM6611-MIB", "ibmsnapFilterInValue"))
if mibBuilder.loadTexts: ibmsnapFilterInEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmsnapFilterInEntry.setDescription('Filtering information for a single SNAP value on a single interface.')
ibmsnapFilterInIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 3, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmsnapFilterInIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmsnapFilterInIfIndex.setDescription('The value of this object identifies the interface for which this entry contains management information. The value of this object for a particular interface has the same value as the ifIndex object for the same interface.')
ibmsnapFilterInValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 3, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmsnapFilterInValue.setStatus('mandatory')
if mibBuilder.loadTexts: ibmsnapFilterInValue.setDescription('Indicates which SNAP value to filter.')
ibmsnapFilterInMask = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 3, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmsnapFilterInMask.setStatus('mandatory')
if mibBuilder.loadTexts: ibmsnapFilterInMask.setDescription('Mask to allow ibmsnapFilterInValue to be used as a range of values.')
ibmsnapFilterInType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 3, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("sr", 1), ("tb", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmsnapFilterInType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmsnapFilterInType.setDescription('The type of entry, either sr or tb.')
ibmsnapFilterOutTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 3, 3), )
if mibBuilder.loadTexts: ibmsnapFilterOutTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmsnapFilterOutTable.setDescription('Table of SNAP filtering information for outgoing frames. Note that the entries in this table only come into play if packets with source SAP 0xAA are being forwarded.')
ibmsnapFilterOutEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 3, 3, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmsnapFilterOutType"), (0, "IBM6611-MIB", "ibmsnapFilterOutIfIndex"), (0, "IBM6611-MIB", "ibmsnapFilterOutValue"))
if mibBuilder.loadTexts: ibmsnapFilterOutEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmsnapFilterOutEntry.setDescription('Filtering information for a single SNAP value on a single interface.')
ibmsnapFilterOutIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 3, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmsnapFilterOutIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmsnapFilterOutIfIndex.setDescription('The value of this object identifies the interface for which this entry contains management information. The value of this object for a particular interface has the same value as the ifIndex object for the same interface.')
ibmsnapFilterOutValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 3, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmsnapFilterOutValue.setStatus('mandatory')
if mibBuilder.loadTexts: ibmsnapFilterOutValue.setDescription('Indicates which SNAP values to filter.')
ibmsnapFilterOutMask = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 3, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmsnapFilterOutMask.setStatus('mandatory')
if mibBuilder.loadTexts: ibmsnapFilterOutMask.setDescription('Mask to allow ibmsnapFilterOutValue to be used as a range of values.')
ibmsnapFilterOutType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 3, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("sr", 1), ("tb", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmsnapFilterOutType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmsnapFilterOutType.setDescription('The type of entry, either sr or tb.')
ibmringFilterInfoTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 4, 1), )
if mibBuilder.loadTexts: ibmringFilterInfoTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmringFilterInfoTable.setDescription('Table of ring filtering information.')
ibmringFilterInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 4, 1, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmringFilterIfIndex"))
if mibBuilder.loadTexts: ibmringFilterInfoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmringFilterInfoEntry.setDescription('Ring filtering information for a single interface.')
ibmringFilterIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 4, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmringFilterIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmringFilterIfIndex.setDescription('The value of this object identifies the interface for which this entry contains management information. The value of this object for a particular interface has the same value as the ifIndex object for the same interface.')
ibmringFilterInBcastType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("filterARB", 1), ("filterSRB", 2), ("filterBoth", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmringFilterInBcastType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmringFilterInBcastType.setDescription('For the incoming ring filter table, determines what type of frames will be filtered.')
ibmringFilterOutBcastType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("filterARB", 1), ("filterSRB", 2), ("filterBoth", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmringFilterOutBcastType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmringFilterOutBcastType.setDescription('For the outgoing ring filter table, determines what type of frames will be filtered.')
ibmringFilterInFilterType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("deny", 1), ("permit", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmringFilterInFilterType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmringFilterInFilterType.setDescription('For the incoming ring filter table, determines whether the entries are permit or deny entries.')
ibmringFilterOutFilterType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 4, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("deny", 1), ("permit", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmringFilterOutFilterType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmringFilterOutFilterType.setDescription('For the outgoing ring filter table, determines whether the entries are permit or deny entries.')
ibmringFilterInNotForwarded = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 4, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmringFilterInNotForwarded.setStatus('mandatory')
if mibBuilder.loadTexts: ibmringFilterInNotForwarded.setDescription('Number of packets not forwarded, in the incoming direction, because they were filtered out.')
ibmringFilterOutNotForwarded = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 4, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmringFilterOutNotForwarded.setStatus('mandatory')
if mibBuilder.loadTexts: ibmringFilterOutNotForwarded.setDescription('Number of packets not forwarded, in the outgoing direction, because they were filtered out.')
ibmringFilterInTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 4, 2), )
if mibBuilder.loadTexts: ibmringFilterInTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmringFilterInTable.setDescription('Table of ring number filtering information for incoming frames.')
ibmringFilterInEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 4, 2, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmringFilterInIfIndex"), (0, "IBM6611-MIB", "ibmringFilterInNumber"))
if mibBuilder.loadTexts: ibmringFilterInEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmringFilterInEntry.setDescription('Filtering information for a single ring number on a single interface.')
ibmringFilterInIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 4, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmringFilterInIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmringFilterInIfIndex.setDescription('The value of this object identifies the interface for which this entry contains management information. The value of this object for a particular interface has the same value as the ifIndex object for the same interface.')
ibmringFilterInNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 4, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmringFilterInNumber.setStatus('mandatory')
if mibBuilder.loadTexts: ibmringFilterInNumber.setDescription('Indicates which ring number to filter.')
ibmringFilterInMask = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 4, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmringFilterInMask.setStatus('mandatory')
if mibBuilder.loadTexts: ibmringFilterInMask.setDescription('Mask to allow ibmringFilterInNumber to be used as a range of values.')
ibmringFilterOutTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 4, 3), )
if mibBuilder.loadTexts: ibmringFilterOutTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmringFilterOutTable.setDescription('Table of ring number filtering information for outgoing frames.')
ibmringFilterOutEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 4, 3, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmringFilterOutIfIndex"), (0, "IBM6611-MIB", "ibmringFilterOutNumber"))
if mibBuilder.loadTexts: ibmringFilterOutEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmringFilterOutEntry.setDescription('Filtering information for a single ring number on a single interface.')
ibmringFilterOutIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 4, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmringFilterOutIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmringFilterOutIfIndex.setDescription('The value of this object identifies the interface for which this entry contains management information. The value of this object for a particular interface has the same value as the ifIndex object for the same interface.')
ibmringFilterOutNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 4, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmringFilterOutNumber.setStatus('mandatory')
if mibBuilder.loadTexts: ibmringFilterOutNumber.setDescription('Indicates which ring number to filter.')
ibmringFilterOutMask = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 4, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmringFilterOutMask.setStatus('mandatory')
if mibBuilder.loadTexts: ibmringFilterOutMask.setDescription('Mask to allow ibmringFilterOutNumber to be used as a range of values.')
ibmhopCountFilterInfoTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 5, 1), )
if mibBuilder.loadTexts: ibmhopCountFilterInfoTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmhopCountFilterInfoTable.setDescription('Table of hop count filtering information.')
ibmhopCountFilterInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 5, 1, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmhopCountFilterIfIndex"))
if mibBuilder.loadTexts: ibmhopCountFilterInfoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmhopCountFilterInfoEntry.setDescription('Hop count filtering information for a single interface.')
ibmhopCountFilterIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 5, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmhopCountFilterIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmhopCountFilterIfIndex.setDescription('The value of this object identifies the interface for which this entry contains management information. The value of this object for a particular interface has the same value as the ifIndex object for the same interface.')
ibmhopCountFilterBcastType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("filterARB", 1), ("filterSRB", 2), ("filterBoth", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmhopCountFilterBcastType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmhopCountFilterBcastType.setDescription('Determines what type of incoming frames will be filtered.')
ibmhopCountFilterCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 5, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmhopCountFilterCount.setStatus('mandatory')
if mibBuilder.loadTexts: ibmhopCountFilterCount.setDescription('The number of hops allowed for incoming frames.')
ibmwindowFilterInfoTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 6, 1), )
if mibBuilder.loadTexts: ibmwindowFilterInfoTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmwindowFilterInfoTable.setDescription('Table of Window filtering information.')
ibmwindowFilterInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 6, 1, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmwindowFilterType"), (0, "IBM6611-MIB", "ibmwindowFilterIfIndex"))
if mibBuilder.loadTexts: ibmwindowFilterInfoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmwindowFilterInfoEntry.setDescription('Window filtering information for a single interface.')
ibmwindowFilterIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 6, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmwindowFilterIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmwindowFilterIfIndex.setDescription('The value of this object identifies the interface for which this entry contains management information. The value of this object for a particular interface has the same value as the ifIndex object for the same interface.')
ibmwindowFilterInBcastType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 6, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("filterARB", 1), ("filterSRB", 2), ("filterBoth", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmwindowFilterInBcastType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmwindowFilterInBcastType.setDescription('For the incoming Window filter table, determines what type of frames will be filtered.')
ibmwindowFilterOutBcastType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 6, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("filterARB", 1), ("filterSRB", 2), ("filterBoth", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmwindowFilterOutBcastType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmwindowFilterOutBcastType.setDescription('For the outgoing Window filter table, determines what type of frames will be filtered.')
ibmwindowFilterInFilterType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 6, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("deny", 1), ("permit", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmwindowFilterInFilterType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmwindowFilterInFilterType.setDescription('For the incoming filter table, determines whether the entries are permit or deny entries.')
ibmwindowFilterOutFilterType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 6, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("deny", 1), ("permit", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmwindowFilterOutFilterType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmwindowFilterOutFilterType.setDescription('For the outgoing filter table, determines whether the entries are permit or deny entries.')
ibmwindowFilterInNotForwarded = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 6, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmwindowFilterInNotForwarded.setStatus('mandatory')
if mibBuilder.loadTexts: ibmwindowFilterInNotForwarded.setDescription('Number of packets not forwarded, in the incoming direction, because they were filtered out.')
ibmwindowFilterOutNotForwarded = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 6, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmwindowFilterOutNotForwarded.setStatus('mandatory')
if mibBuilder.loadTexts: ibmwindowFilterOutNotForwarded.setDescription('Number of packets not forwarded, in the outgoing direction, because they were filtered out.')
ibmwindowFilterType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 6, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("sr", 1), ("tb", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmwindowFilterType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmwindowFilterType.setDescription('The type of entry, either sr or tb.')
ibmwindowFilterInTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 6, 2), )
if mibBuilder.loadTexts: ibmwindowFilterInTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmwindowFilterInTable.setDescription('Table of Window filtering information for incoming frames.')
ibmwindowFilterInEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 6, 2, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmwindowFilterInType"), (0, "IBM6611-MIB", "ibmwindowFilterInIfIndex"), (0, "IBM6611-MIB", "ibmwindowFilterInId"), (0, "IBM6611-MIB", "ibmwindowFilterInContents"))
if mibBuilder.loadTexts: ibmwindowFilterInEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmwindowFilterInEntry.setDescription('Filtering information for incoming frames.')
ibmwindowFilterInIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 6, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmwindowFilterInIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmwindowFilterInIfIndex.setDescription('The value of this object identifies the interface for which this entry contains management information. The value of this object for a particular interface has the same value as the ifIndex object for the same interface.')
ibmwindowFilterInContents = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 6, 2, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmwindowFilterInContents.setStatus('mandatory')
if mibBuilder.loadTexts: ibmwindowFilterInContents.setDescription('String of bytes that will be compared with bytes in the frame. ')
ibmwindowFilterInMaskString = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 6, 2, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmwindowFilterInMaskString.setStatus('mandatory')
if mibBuilder.loadTexts: ibmwindowFilterInMaskString.setDescription('String of bytes that will be masked with bytes in the contents field.')
ibmwindowFilterInOffsetStart = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 6, 2, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmwindowFilterInOffsetStart.setStatus('mandatory')
if mibBuilder.loadTexts: ibmwindowFilterInOffsetStart.setDescription("Determines the starting point where the contents field should be applied. A value of 'MAC' means the base is at the beginning of the destination MAC address field, whereas, a value of 'SAP' means it is applied at the beginning of the destination SAP field.")
ibmwindowFilterInNumBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 6, 2, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmwindowFilterInNumBytes.setStatus('mandatory')
if mibBuilder.loadTexts: ibmwindowFilterInNumBytes.setDescription('Number of bytes in the contents field that are used for filtering. ')
ibmwindowFilterInOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 6, 2, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmwindowFilterInOffset.setStatus('mandatory')
if mibBuilder.loadTexts: ibmwindowFilterInOffset.setDescription('Number of bytes offset into the frame from the offset start point to begin the compare.')
ibmwindowFilterInId = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 6, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmwindowFilterInId.setStatus('mandatory')
if mibBuilder.loadTexts: ibmwindowFilterInId.setDescription('A unique identifier associated with this window filter entry.')
ibmwindowFilterInType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 6, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("sr", 1), ("tb", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmwindowFilterInType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmwindowFilterInType.setDescription('The type of entry, either sr or tb.')
ibmwindowFilterOutTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 6, 3), )
if mibBuilder.loadTexts: ibmwindowFilterOutTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmwindowFilterOutTable.setDescription('Table of Window filtering information for outgoing frames.')
ibmwindowFilterOutEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 6, 3, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmwindowFilterOutType"), (0, "IBM6611-MIB", "ibmwindowFilterOutIfIndex"), (0, "IBM6611-MIB", "ibmwindowFilterOutId"), (0, "IBM6611-MIB", "ibmwindowFilterOutContents"))
if mibBuilder.loadTexts: ibmwindowFilterOutEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmwindowFilterOutEntry.setDescription('Filtering information for outgoing frames.')
ibmwindowFilterOutIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 6, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmwindowFilterOutIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmwindowFilterOutIfIndex.setDescription('The value of this object identifies the interface for which this entry contains management information. The value of this object for a particular interface has the same value as the ifIndex object for the same interface.')
ibmwindowFilterOutContents = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 6, 3, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmwindowFilterOutContents.setStatus('mandatory')
if mibBuilder.loadTexts: ibmwindowFilterOutContents.setDescription('String of bytes that will be compared with bytes in the frame. ')
ibmwindowFilterOutMaskString = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 6, 3, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmwindowFilterOutMaskString.setStatus('mandatory')
if mibBuilder.loadTexts: ibmwindowFilterOutMaskString.setDescription('String of bytes that will be masked with bytes in the contents field. ')
ibmwindowFilterOutOffsetStart = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 6, 3, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmwindowFilterOutOffsetStart.setStatus('mandatory')
if mibBuilder.loadTexts: ibmwindowFilterOutOffsetStart.setDescription("Determines the starting point where the contents field should be applied. A value of 'MAC' means the base is at the beginning of the destination MAC address field, whereas, a value of 'SAP' means it is applied at the beginning of the destination SAP field.")
ibmwindowFilterOutNumBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 6, 3, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmwindowFilterOutNumBytes.setStatus('mandatory')
if mibBuilder.loadTexts: ibmwindowFilterOutNumBytes.setDescription('Number of bytes in the contents field that are used for filtering. ')
ibmwindowFilterOutOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 6, 3, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmwindowFilterOutOffset.setStatus('mandatory')
if mibBuilder.loadTexts: ibmwindowFilterOutOffset.setDescription('Number of bytes offset into the frame from the offset start point to begin the compare.')
ibmwindowFilterOutId = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 6, 3, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmwindowFilterOutId.setStatus('mandatory')
if mibBuilder.loadTexts: ibmwindowFilterOutId.setDescription('A unique identifier associated with this window filter entry.')
ibmwindowFilterOutType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 6, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("sr", 1), ("tb", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmwindowFilterOutType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmwindowFilterOutType.setDescription('The type of entry, either sr or tb.')
ibmFiltOrderInTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 7, 1), )
if mibBuilder.loadTexts: ibmFiltOrderInTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmFiltOrderInTable.setDescription('Table of information describing which order the filters are applied for incoming frames.')
ibmFiltOrderInEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 7, 1, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmFiltOrderInType"), (0, "IBM6611-MIB", "ibmFiltOrderInIfIndex"), (0, "IBM6611-MIB", "ibmFiltOrderInPriority"))
if mibBuilder.loadTexts: ibmFiltOrderInEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmFiltOrderInEntry.setDescription('Filter order information for incoming frames.')
ibmFiltOrderInIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 7, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmFiltOrderInIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmFiltOrderInIfIndex.setDescription('The value of this object identifies the interface for which this entry contains management information. The value of this object for a particular interface has the same value as the ifIndex object for the same interface.')
ibmFiltOrderInPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 7, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmFiltOrderInPriority.setStatus('mandatory')
if mibBuilder.loadTexts: ibmFiltOrderInPriority.setDescription('The priority of when a filter is applied to an incoming frame. A value of 1 signifies that it is applied first.')
ibmFiltOrderInName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 7, 1, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmFiltOrderInName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmFiltOrderInName.setDescription('The name of the filter applied to incoming frames that is associated with the priority, ibmFiltOrderInPriority.')
ibmFiltOrderInType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 7, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("sr", 1), ("tb", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmFiltOrderInType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmFiltOrderInType.setDescription('The type of entry, either sr or tb.')
ibmFiltOrderOutTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 7, 2), )
if mibBuilder.loadTexts: ibmFiltOrderOutTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmFiltOrderOutTable.setDescription('Table of information describing which order the filters are applied for outgoing frames.')
ibmFiltOrderOutEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 7, 2, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmFiltOrderOutType"), (0, "IBM6611-MIB", "ibmFiltOrderOutIfIndex"), (0, "IBM6611-MIB", "ibmFiltOrderOutPriority"))
if mibBuilder.loadTexts: ibmFiltOrderOutEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmFiltOrderOutEntry.setDescription('Filter order information for outgoing frames.')
ibmFiltOrderOutIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 7, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmFiltOrderOutIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmFiltOrderOutIfIndex.setDescription('The value of this object identifies the interface for which this entry contains management information. The value of this object for a particular interface has the same value as the ifIndex object for the same interface.')
ibmFiltOrderOutPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 7, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmFiltOrderOutPriority.setStatus('mandatory')
if mibBuilder.loadTexts: ibmFiltOrderOutPriority.setDescription('The priority of when a filter is applied to an outgoing frame. A value of 1 signifies that it is applied first.')
ibmFiltOrderOutName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 7, 2, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmFiltOrderOutName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmFiltOrderOutName.setDescription('The name of the filter applied to outgoing frames that is associated with the priority, ibmFiltOrderOutPriority.')
ibmFiltOrderOutType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 7, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("sr", 1), ("tb", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmFiltOrderOutType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmFiltOrderOutType.setDescription('The type of entry, either sr or tb.')
ibmRIFFilterInfoTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 8, 1), )
if mibBuilder.loadTexts: ibmRIFFilterInfoTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmRIFFilterInfoTable.setDescription('Table of routing information field filtering information.')
ibmRIFFilterInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 8, 1, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmRIFFilterIfIndex"))
if mibBuilder.loadTexts: ibmRIFFilterInfoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmRIFFilterInfoEntry.setDescription('Routing information field filtering information for a single interface.')
ibmRIFFilterIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 8, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmRIFFilterIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmRIFFilterIfIndex.setDescription('The value of this object identifies the interface for which this entry contains management information. The value of this object for a particular interface has the same value as the ifIndex object for the same interface.')
ibmRIFFilterInBcastType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 8, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("filterARB", 1), ("filterSRB", 2), ("filterBoth", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmRIFFilterInBcastType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmRIFFilterInBcastType.setDescription('For the incoming routing information field filter table, determines what type of frames will be filtered.')
ibmRIFFilterOutBcastType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 8, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("filterARB", 1), ("filterSRB", 2), ("filterBoth", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmRIFFilterOutBcastType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmRIFFilterOutBcastType.setDescription('For the outgoing routing information field filter table, determines what type of frames will be filtered.')
ibmRIFFilterInFilterType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 8, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("deny", 1), ("permit", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmRIFFilterInFilterType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmRIFFilterInFilterType.setDescription('For the incoming routing information filter table, determines whether the entries are permit or deny entries.')
ibmRIFFilterOutFilterType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 8, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("deny", 1), ("permit", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmRIFFilterOutFilterType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmRIFFilterOutFilterType.setDescription('For the outgoing routing information field filter table, determines whether the entries are permit or deny entries.')
ibmRIFFilterInNotForwarded = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 8, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmRIFFilterInNotForwarded.setStatus('mandatory')
if mibBuilder.loadTexts: ibmRIFFilterInNotForwarded.setDescription('Number of packets not forwarded, in the incoming direction, because they were filtered out.')
ibmRIFFilterOutNotForwarded = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 8, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmRIFFilterOutNotForwarded.setStatus('mandatory')
if mibBuilder.loadTexts: ibmRIFFilterOutNotForwarded.setDescription('Number of packets not forwarded, in the outgoing direction, because they were filtered out.')
ibmRIFFilterInTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 8, 2), )
if mibBuilder.loadTexts: ibmRIFFilterInTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmRIFFilterInTable.setDescription('Table of routing information field filtering information for incoming frames.')
ibmRIFFilterInEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 8, 2, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmRIFFilterInIfIndex"), (0, "IBM6611-MIB", "ibmRIFFilterInRingNumber"), (0, "IBM6611-MIB", "ibmRIFFilterInBridgeNumber"))
if mibBuilder.loadTexts: ibmRIFFilterInEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmRIFFilterInEntry.setDescription('Filtering information for a single routing information field on a single interface.')
ibmRIFFilterInIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 8, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmRIFFilterInIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmRIFFilterInIfIndex.setDescription('The value of this object identifies the interface for which this entry contains management information. The value of this object for a particular interface has the same value as the ifIndex object for the same interface.')
ibmRIFFilterInRingNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 8, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmRIFFilterInRingNumber.setStatus('mandatory')
if mibBuilder.loadTexts: ibmRIFFilterInRingNumber.setDescription('Indicates which ring number to filter.')
ibmRIFFilterInRingMask = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 8, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmRIFFilterInRingMask.setStatus('mandatory')
if mibBuilder.loadTexts: ibmRIFFilterInRingMask.setDescription('Mask to allow ibmRIFFilterInRingNumber to be used as a range of values.')
ibmRIFFilterInBridgeNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 8, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmRIFFilterInBridgeNumber.setStatus('mandatory')
if mibBuilder.loadTexts: ibmRIFFilterInBridgeNumber.setDescription('Indicates which bridge number to filter.')
ibmRIFFilterInBridgeMask = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 8, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmRIFFilterInBridgeMask.setStatus('mandatory')
if mibBuilder.loadTexts: ibmRIFFilterInBridgeMask.setDescription('Mask to allow ibmRIFFilterInBridgeNumber to be used as a range of values.')
ibmRIFFilterInRouteDesignator = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 8, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("firstroutedesignator", 1), ("nexttolastroutedesignator", 2), ("allroutedesignators", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmRIFFilterInRouteDesignator.setStatus('mandatory')
if mibBuilder.loadTexts: ibmRIFFilterInRouteDesignator.setDescription('Indicates which route designators in the routing information field are to be used for filtering.')
ibmRIFFilterOutTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 8, 3), )
if mibBuilder.loadTexts: ibmRIFFilterOutTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmRIFFilterOutTable.setDescription('Table of routing information field filtering information for outgoing frames.')
ibmRIFFilterOutEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 8, 3, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmRIFFilterOutIfIndex"), (0, "IBM6611-MIB", "ibmRIFFilterOutRingNumber"), (0, "IBM6611-MIB", "ibmRIFFilterOutBridgeNumber"))
if mibBuilder.loadTexts: ibmRIFFilterOutEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmRIFFilterOutEntry.setDescription('Filtering information for a single routing information field on a single interface.')
ibmRIFFilterOutIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 8, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmRIFFilterOutIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmRIFFilterOutIfIndex.setDescription('The value of this object identifies the interface for which this entry contains management information. The value of this object for a particular interface has the same value as the ifIndex object for the same interface.')
ibmRIFFilterOutRingNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 8, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmRIFFilterOutRingNumber.setStatus('mandatory')
if mibBuilder.loadTexts: ibmRIFFilterOutRingNumber.setDescription('Indicates which ring number to filter.')
ibmRIFFilterOutRingMask = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 8, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmRIFFilterOutRingMask.setStatus('mandatory')
if mibBuilder.loadTexts: ibmRIFFilterOutRingMask.setDescription('Mask to allow ibmRIFFilterOutRingNumber to be used as a range of values.')
ibmRIFFilterOutBridgeNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 8, 3, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmRIFFilterOutBridgeNumber.setStatus('mandatory')
if mibBuilder.loadTexts: ibmRIFFilterOutBridgeNumber.setDescription('Indicates which bridge number to filter.')
ibmRIFFilterOutBridgeMask = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 8, 3, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmRIFFilterOutBridgeMask.setStatus('mandatory')
if mibBuilder.loadTexts: ibmRIFFilterOutBridgeMask.setDescription('Mask to allow ibmRIFFilterOutBridgeNumber to be used as a range of values.')
ibmRIFFilterOutRouteDesignator = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 7, 8, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("firstroutedesignator", 1), ("nexttolastroutedesignator", 2), ("allroutedesignators", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmRIFFilterOutRouteDesignator.setStatus('mandatory')
if mibBuilder.loadTexts: ibmRIFFilterOutRouteDesignator.setDescription('Indicates which route designators in the routing information field are to be used for filtering.')
ibmfrDlcmiTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 8, 1), )
if mibBuilder.loadTexts: ibmfrDlcmiTable.setReference('Draft American National Standard T1.617-1991, Annex D')
if mibBuilder.loadTexts: ibmfrDlcmiTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmfrDlcmiTable.setDescription('The Parameters for the Data Link Connection Management Interface corresponding to any given ifEntry.')
ibmfrDlcmiEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 8, 1, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmfrDlcmiIfIndex"))
if mibBuilder.loadTexts: ibmfrDlcmiEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmfrDlcmiEntry.setDescription('The Parameters for the Data Link Connection Management Interface.')
ibmfrDlcmiIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 8, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmfrDlcmiIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmfrDlcmiIfIndex.setDescription('The ifIndex value of the corresponding ifEn- try.')
ibmfrDlcmiState = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 8, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("noLmiConfigured", 1), ("lmiRev1", 2), ("ansiT1-617-D", 3), ("ansiT1-617-B", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmfrDlcmiState.setReference('Draft American National Standard T1.617-1991')
if mibBuilder.loadTexts: ibmfrDlcmiState.setStatus('mandatory')
if mibBuilder.loadTexts: ibmfrDlcmiState.setDescription('This variable states which Data Link Connec- tion Management scheme is active (and by impli- cation, what DLCI it uses) on the Frame Relay interface.')
ibmfrDlcmiAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 8, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("q921", 1), ("q922March90", 2), ("q922November90", 3), ("q922", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmfrDlcmiAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ibmfrDlcmiAddress.setDescription('This variable states which address format is in use on the Frame Relay interface.')
ibmfrDlcmiAddressLen = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 8, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("two-octets", 2), ("three-octets", 3), ("four-octets", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmfrDlcmiAddressLen.setStatus('mandatory')
if mibBuilder.loadTexts: ibmfrDlcmiAddressLen.setDescription('This variable states which address length in octets. In the case of Q922 format, the length indicates the entire length of the address in- cluding the control portion.')
ibmfrDlcmiPollingInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 8, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 30)).clone(10)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmfrDlcmiPollingInterval.setReference('Draft American National Standard T1.617-1991, Section D.7 Timer T391.')
if mibBuilder.loadTexts: ibmfrDlcmiPollingInterval.setStatus('mandatory')
if mibBuilder.loadTexts: ibmfrDlcmiPollingInterval.setDescription('This is the number of seconds between succes- sive status enquiry messages.')
ibmfrDlcmiFullEnquiryInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 8, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmfrDlcmiFullEnquiryInterval.setReference('Draft American National Standard T1.617-1991, Section D.7 Counter N391.')
if mibBuilder.loadTexts: ibmfrDlcmiFullEnquiryInterval.setStatus('mandatory')
if mibBuilder.loadTexts: ibmfrDlcmiFullEnquiryInterval.setDescription('Number of status enquiry intervals that pass before issuance of a full status enquiry mes- sage.')
ibmfrDlcmiErrorThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 8, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10)).clone(3)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmfrDlcmiErrorThreshold.setReference('Draft American National Standard T1.617-1991, Section D.5.1 Counter N392.')
if mibBuilder.loadTexts: ibmfrDlcmiErrorThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: ibmfrDlcmiErrorThreshold.setDescription('This is the maximum number of unanswered Status Enquiries the equipment shall accept be- fore declaring the interface down.')
ibmfrDlcmiMonitoredEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 8, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10)).clone(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmfrDlcmiMonitoredEvents.setReference('Draft American National Standard T1.617-1991, Section D.5.2 Counter T393.')
if mibBuilder.loadTexts: ibmfrDlcmiMonitoredEvents.setStatus('mandatory')
if mibBuilder.loadTexts: ibmfrDlcmiMonitoredEvents.setDescription('This is the maximum number of responses to FULL STATUS or LINK INTEGERITY VERIFICATION messages missed before the device will mark the interface down.')
ibmfrDlcmiMaxSupportedVCs = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 8, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmfrDlcmiMaxSupportedVCs.setStatus('mandatory')
if mibBuilder.loadTexts: ibmfrDlcmiMaxSupportedVCs.setDescription("The maximum number of Virtual Circuits allowed for this interface. Usually dictated by the Frame Relay network. In response to a SET, if a value less than zero or higher than the agent's maximal capability is configured, the agent should respond bad- Value")
ibmfrDlcmiMulticast = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 8, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("nonBroadcast", 1), ("broadcast", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmfrDlcmiMulticast.setStatus('mandatory')
if mibBuilder.loadTexts: ibmfrDlcmiMulticast.setDescription('This indicates whether the Frame Relay provid- er offers a Multicast Service.')
ibmfrCircuitTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 8, 2), )
if mibBuilder.loadTexts: ibmfrCircuitTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmfrCircuitTable.setDescription('A table containing information about specific Data Link Connection Identifiers and corresponding virtual circuits.')
ibmfrCircuitEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 8, 2, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmfrCircuitIfIndex"), (0, "IBM6611-MIB", "ibmfrCircuitDlci"))
if mibBuilder.loadTexts: ibmfrCircuitEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmfrCircuitEntry.setDescription('The information regarding a single Data Link Connection Identifier.')
ibmfrCircuitIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 8, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmfrCircuitIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmfrCircuitIfIndex.setDescription('The ifIndex Value of the ifEntry this virtual circuit is layered onto.')
ibmfrCircuitDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 8, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmfrCircuitDlci.setReference('Draft American National Standard T1.618-1991, Section 3.3.6')
if mibBuilder.loadTexts: ibmfrCircuitDlci.setStatus('mandatory')
if mibBuilder.loadTexts: ibmfrCircuitDlci.setDescription('The Data Link Connection Identifier for this virtual circuit.')
ibmfrCircuitState = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 8, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("invalid", 1), ("active", 2), ("inactive", 3))).clone('active')).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmfrCircuitState.setStatus('mandatory')
if mibBuilder.loadTexts: ibmfrCircuitState.setDescription("Indicates whether the particular virtual cir- cuit is operational. In the absence of a Data Link Connection Management Interface, virtual circuit entries (rows) may be created by set- ting virtual circuit state to active, or delet- ed by changing Circuit state to deleted. Whether or not the row actually disappears is let to the implementation, so this object may actually read as 'invalid' for some arbitrary length of time. It is also legal to set the state of a virtual circuit to inactive to tem- porarily disable a given circuit.")
ibmfrCircuitReceivedFECNs = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 8, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmfrCircuitReceivedFECNs.setReference('Draft American National Standard T1.618-1991, Section 3.3.3')
if mibBuilder.loadTexts: ibmfrCircuitReceivedFECNs.setStatus('mandatory')
if mibBuilder.loadTexts: ibmfrCircuitReceivedFECNs.setDescription('Number of frames received from the network in- dicating forward congestion since the virtual circuit was created.')
ibmfrCircuitReceivedBECNs = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 8, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmfrCircuitReceivedBECNs.setReference('Draft American National Standard T1.618-1991, Section 3.3.4')
if mibBuilder.loadTexts: ibmfrCircuitReceivedBECNs.setStatus('mandatory')
if mibBuilder.loadTexts: ibmfrCircuitReceivedBECNs.setDescription('Number of frames received from the network in- dicating backward congestion since the virtual circuit was created.')
ibmfrCircuitSentFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 8, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmfrCircuitSentFrames.setStatus('mandatory')
if mibBuilder.loadTexts: ibmfrCircuitSentFrames.setDescription('The number of frames sent from this virtual circuit since it was created.')
ibmfrCircuitSentOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 8, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmfrCircuitSentOctets.setStatus('mandatory')
if mibBuilder.loadTexts: ibmfrCircuitSentOctets.setDescription('The number of octets sent from this virtual circuit since it was created.')
ibmfrCircuitReceivedFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 8, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmfrCircuitReceivedFrames.setStatus('mandatory')
if mibBuilder.loadTexts: ibmfrCircuitReceivedFrames.setDescription('Number of frames received over this virtual circuit since it was created.')
ibmfrCircuitReceivedOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 8, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmfrCircuitReceivedOctets.setStatus('mandatory')
if mibBuilder.loadTexts: ibmfrCircuitReceivedOctets.setDescription('Number of octets received over this virtual circuit since it was created.')
ibmfrCircuitCreationTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 8, 2, 1, 10), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmfrCircuitCreationTime.setStatus('mandatory')
if mibBuilder.loadTexts: ibmfrCircuitCreationTime.setDescription('The time when this virtual circuit was created, whether by the Data Link Connection Management Interface or by a SetRequest. The time value is relative to other times on this interface only.')
ibmfrCircuitLastTimeChange = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 8, 2, 1, 11), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmfrCircuitLastTimeChange.setStatus('mandatory')
if mibBuilder.loadTexts: ibmfrCircuitLastTimeChange.setDescription('The time when last there was a change in the virtual circuit state. The time value is relative to other times on this interface only.')
ibmfrCircuitCommittedBurst = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 8, 2, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmfrCircuitCommittedBurst.setReference('Draft American National Standard T1.617-1991, Section 6.5.19')
if mibBuilder.loadTexts: ibmfrCircuitCommittedBurst.setStatus('mandatory')
if mibBuilder.loadTexts: ibmfrCircuitCommittedBurst.setDescription('This variable indicates the maximum amount of data, in bits, that the network agrees to transfer under normal conditions, during the measurement interval.')
ibmfrCircuitExcessBurst = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 8, 2, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmfrCircuitExcessBurst.setReference('Draft American National Standard T1.617-1991, Section 6.5.19')
if mibBuilder.loadTexts: ibmfrCircuitExcessBurst.setStatus('mandatory')
if mibBuilder.loadTexts: ibmfrCircuitExcessBurst.setDescription('This variable indicates the maximum amount of uncommitted data bits that the network will at- tempt to deliver over the measurement interval. By default, if not configured when creating the entry, the Excess Information Burst Size is set to the value of ifSpeed.')
ibmfrCircuitThroughput = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 8, 2, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmfrCircuitThroughput.setReference('Draft American National Standard T1.617-1991, Section 6.5.19')
if mibBuilder.loadTexts: ibmfrCircuitThroughput.setStatus('mandatory')
if mibBuilder.loadTexts: ibmfrCircuitThroughput.setDescription("Throughput is the average number of 'Frame Re- lay Information Field' bits transferred per second across a user network interface in one direction, measured over the measurement inter- val. If the configured committed burst rate and throughput are both non-zero, the measurement interval T=ibmfrCircuitCommittedBurst/ibmfrCircuitThroughput. If the configured committed burst rate and throughput are both zero, the measurement in- terval T=ibmfrCircuitExcessBurst/ifSpeed.")
ibmfrErrTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 8, 3), )
if mibBuilder.loadTexts: ibmfrErrTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmfrErrTable.setDescription('A table containing information about Errors on the Frame Relay interface.')
ibmfrErrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 8, 3, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmfrErrIfIndex"))
if mibBuilder.loadTexts: ibmfrErrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmfrErrEntry.setDescription('The error information for a single frame relay interface.')
ibmfrErrIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 8, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmfrErrIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmfrErrIfIndex.setDescription('The ifIndex Value of the corresponding ifEn- try.')
ibmfrErrType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 8, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("unknownError", 1), ("receiveShort", 2), ("receiveLong", 3), ("illegalDLCI", 4), ("unknownDLCI", 5), ("dlcmiProtoErr", 6), ("dlcmiUnknownIE", 7), ("dlcmiSequenceErr", 8), ("dlcmiUnknownRpt", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmfrErrType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmfrErrType.setDescription('The type of error that was last seen on this interface.')
ibmfrErrData = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 8, 3, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmfrErrData.setStatus('mandatory')
if mibBuilder.loadTexts: ibmfrErrData.setDescription('An octet string containing as much of the er- ror packet as possible. As a minimum, it must contain the Q.922 Address or as much as was delivered. It is desirable to include all in- formation up to the PDU.')
ibmfrErrTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 8, 3, 1, 4), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmfrErrTime.setStatus('mandatory')
if mibBuilder.loadTexts: ibmfrErrTime.setDescription('The time at which the error was detected. The time value is relative to other times on this interface only.')
ibmdlsVirtualRingSegmentNumber = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdlsVirtualRingSegmentNumber.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsVirtualRingSegmentNumber.setDescription('The token ring segment number used in all frames passed to or from the IBM 6611 Data Link Switching function.')
ibmdlsFrameFilterType = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("deny", 1), ("permit", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdlsFrameFilterType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsFrameFilterType.setDescription('The type of SNA filtering applied using the ibmdlsLocalFrameFilterTable and ibmdlsRemoteFrameFilterTable. If this field = permit(2), then all filters defined for SNA use the action of permitting frames to be forwarded if they meet the criteria given by the source and destination address values. If this field = deny(1), then all filters defined for SNA use the action of denying frames to be forwarded if they meet the criteria given by the source and destination address values.')
ibmdlsNameFilterType = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("deny", 1), ("permit", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdlsNameFilterType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsNameFilterType.setDescription('The type of NetBIOS filtering applied using the ibmdlsLocalNameFilterTable and ibmdlsRemoteNameFilterTable. If this field = permit(2), then all filters defined for NetBIOS use the action of permitting frames to be forwarded if they meet the criteria given by the source and destination address values. If this field = deny(1), then all filters defined for NetBIOS use the action of denying frames to be forwarded if they meet the criteria given by the source and destination address values.')
ibmdlsRouterTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 4), )
if mibBuilder.loadTexts: ibmdlsRouterTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsRouterTable.setDescription('A table of information regarding all routers participating in Data Link Switching.')
ibmdlsRouterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 4, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmdlsRouterAddress"))
if mibBuilder.loadTexts: ibmdlsRouterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsRouterEntry.setDescription('Information for a single participating router.')
ibmdlsRouterAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 4, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdlsRouterAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsRouterAddress.setDescription('The IP address of the router participating in Data Link Switching.')
ibmdlsRouterStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notActive", 1), ("active", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdlsRouterStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsRouterStatus.setDescription('The current state of the remote connection')
ibmdlsRouterDefinedBy = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("user", 1), ("system", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdlsRouterDefinedBy.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsRouterDefinedBy.setDescription('The origin of this entry. user(1) indicates that this router is defined via the Configuration Program. system(2) indicates that this router was defined automatically as a result of a connection request from another router.')
ibmdlsRouterInFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 4, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdlsRouterInFrames.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsRouterInFrames.setDescription('Number of frames received from the partner router.')
ibmdlsRouterOutFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 4, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdlsRouterOutFrames.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsRouterOutFrames.setDescription('Number of frames sent to the partner router.')
ibmdlsLocalFrameFilterTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 5), )
if mibBuilder.loadTexts: ibmdlsLocalFrameFilterTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsLocalFrameFilterTable.setDescription('The SNA local frame filter table. This table contains information regarding the filtering of SNA frames received from local LAN segments.')
ibmdlsLocalFrameFilterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 5, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmdlsLocalFrameFilterID"))
if mibBuilder.loadTexts: ibmdlsLocalFrameFilterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsLocalFrameFilterEntry.setDescription('Filter information for a MAC address source-destination pair.')
ibmdlsLocalFrameFilterID = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdlsLocalFrameFilterID.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsLocalFrameFilterID.setDescription('A unique identifier for this filter.')
ibmdlsLocalFrameFilterSrcAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 5, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdlsLocalFrameFilterSrcAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsLocalFrameFilterSrcAddress.setDescription('The source MAC address that this filter is applied to.')
ibmdlsLocalFrameFilterSrcMask = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 5, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdlsLocalFrameFilterSrcMask.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsLocalFrameFilterSrcMask.setDescription('A mask indicating the bits of the source address considered significant when using the filter. For every bit equal to one in the mask, the same bit in the source address is considered significant.')
ibmdlsLocalFrameFilterDestAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 5, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdlsLocalFrameFilterDestAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsLocalFrameFilterDestAddress.setDescription('The destination MAC address that this filter is applied to.')
ibmdlsLocalFrameFilterDestMask = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 5, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdlsLocalFrameFilterDestMask.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsLocalFrameFilterDestMask.setDescription('A mask indicating the bits of the destination address considered significant when using the filter. For every bit equal to one in the mask, the same bit in the destination address is considered significant.')
ibmdlsRemoteFrameFilterTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 6), )
if mibBuilder.loadTexts: ibmdlsRemoteFrameFilterTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsRemoteFrameFilterTable.setDescription('The SNA remote frame filter table. This table contains information regarding the filtering of SNA frames received from other participating DLS routers.')
ibmdlsRemoteFrameFilterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 6, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmdlsRemoteFrameFilterID"))
if mibBuilder.loadTexts: ibmdlsRemoteFrameFilterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsRemoteFrameFilterEntry.setDescription('Filter information for a MAC address source-destination pair.')
ibmdlsRemoteFrameFilterID = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdlsRemoteFrameFilterID.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsRemoteFrameFilterID.setDescription('A unique identifier for this filter.')
ibmdlsRemoteFrameFilterSrcAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 6, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdlsRemoteFrameFilterSrcAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsRemoteFrameFilterSrcAddress.setDescription('The source MAC address that this filter is applied to.')
ibmdlsRemoteFrameFilterSrcMask = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 6, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdlsRemoteFrameFilterSrcMask.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsRemoteFrameFilterSrcMask.setDescription('A mask indicating the bits of the source address considered significant when using the filter. For every bit equal to one in the mask, the same bit in the source address is considered significant.')
ibmdlsRemoteFrameFilterDestAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 6, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdlsRemoteFrameFilterDestAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsRemoteFrameFilterDestAddress.setDescription('The destination MAC address that this filter is applied to.')
ibmdlsRemoteFrameFilterDestMask = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 6, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdlsRemoteFrameFilterDestMask.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsRemoteFrameFilterDestMask.setDescription('A mask indicating the bits of the destination address considered significant when using the filter. For every bit equal to one in the mask, the same bit in the destination address is considered significant.')
ibmdlsLocalNameFilterTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 7), )
if mibBuilder.loadTexts: ibmdlsLocalNameFilterTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsLocalNameFilterTable.setDescription('The NetBIOS local name filter table. This table contains information regarding the filtering of NetBIOS frames received from local LAN segments.')
ibmdlsLocalNameFilterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 7, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmdlsLocalNameFilterID"))
if mibBuilder.loadTexts: ibmdlsLocalNameFilterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsLocalNameFilterEntry.setDescription('Filter information for a NetBIOS source-destination name pair.')
ibmdlsLocalNameFilterID = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 7, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdlsLocalNameFilterID.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsLocalNameFilterID.setDescription('A unique identifier for this filter.')
ibmdlsLocalNameFilterSrcAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 7, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdlsLocalNameFilterSrcAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsLocalNameFilterSrcAddress.setDescription('The source NetBIOS name that this filter is applied to.')
ibmdlsLocalNameFilterDestAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 7, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdlsLocalNameFilterDestAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsLocalNameFilterDestAddress.setDescription('The destination NetBIOS name that this filter is applied to.')
ibmdlsRemoteNameFilterTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 8), )
if mibBuilder.loadTexts: ibmdlsRemoteNameFilterTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsRemoteNameFilterTable.setDescription('The NetBIOS name filter table. This table contains information regarding the filtering of NetBIOS frames received from other participating DLS routers.')
ibmdlsRemoteNameFilterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 8, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmdlsRemoteNameFilterID"))
if mibBuilder.loadTexts: ibmdlsRemoteNameFilterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsRemoteNameFilterEntry.setDescription('Filter information for a NetBIOS source-destination name pair.')
ibmdlsRemoteNameFilterID = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 8, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdlsRemoteNameFilterID.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsRemoteNameFilterID.setDescription('A unique identifier for this filter.')
ibmdlsRemoteNameFilterSrcAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 8, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdlsRemoteNameFilterSrcAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsRemoteNameFilterSrcAddress.setDescription('The source NetBIOS name that this filter is applied to.')
ibmdlsRemoteNameFilterDestAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 8, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdlsRemoteNameFilterDestAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsRemoteNameFilterDestAddress.setDescription('The destination NetBIOS name that this filter is applied to.')
ibmdlsDefaultDestTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 9), )
if mibBuilder.loadTexts: ibmdlsDefaultDestTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsDefaultDestTable.setDescription('Table of default routers for MAC addresses.')
ibmdlsDefaultDestEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 9, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmdlsDefaultDestAddress"))
if mibBuilder.loadTexts: ibmdlsDefaultDestEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsDefaultDestEntry.setDescription('Mapping of a MAC address to a default router.')
ibmdlsDefaultDestAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 9, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdlsDefaultDestAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsDefaultDestAddress.setDescription('The destination address that this table entry applies to.')
ibmdlsDefaultRouterAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 9, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdlsDefaultRouterAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsDefaultRouterAddress.setDescription('The default router used for reaching the destination address in ibmdlsDefaultDestAddress.')
ibmdlsDefaultNBDestTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 10), )
if mibBuilder.loadTexts: ibmdlsDefaultNBDestTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsDefaultNBDestTable.setDescription('Table of default routers for NetBIOS names.')
ibmdlsDefaultNBDestEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 10, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmdlsDefaultNBDestName"))
if mibBuilder.loadTexts: ibmdlsDefaultNBDestEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsDefaultNBDestEntry.setDescription('Mapping of a NetBIOS name to a default router.')
ibmdlsDefaultNBDestName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 10, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdlsDefaultNBDestName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsDefaultNBDestName.setDescription('The destination NetBIOS name that this table entry applies to.')
ibmdlsDefaultNBRouterAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 10, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdlsDefaultNBRouterAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsDefaultNBRouterAddress.setDescription('The default router used for reaching the destination name in ibmdlsDefaultNBDestName.')
ibmdlsStationTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 11), )
if mibBuilder.loadTexts: ibmdlsStationTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsStationTable.setDescription('Table of configuration information on SNA stations attached to this router.')
ibmdlsStationEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 11, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmdlsStationIfIndex"), (0, "IBM6611-MIB", "ibmdlsStationAddress"))
if mibBuilder.loadTexts: ibmdlsStationEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsStationEntry.setDescription('Information on a single SNA station attached to this router.')
ibmdlsStationIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 11, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdlsStationIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsStationIfIndex.setDescription('The value of IfIndex for the port to which this station is attached.')
ibmdlsStationAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 11, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdlsStationAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsStationAddress.setDescription('The SDLC address of this station.')
ibmdlsStationTransmitWindowCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 11, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 7)).clone(7)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdlsStationTransmitWindowCount.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsStationTransmitWindowCount.setDescription('The number of SDLC information frames to send to this station before turning the line around to get a response.')
ibmdlsStationRetransmitCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 11, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 50)).clone(10)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdlsStationRetransmitCount.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsStationRetransmitCount.setDescription('The number of contiguous information frame bursts that will be transmitted to this station before declaring a permanent transmission error.')
ibmdlsStationRetransmitThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 11, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100)).clone(10)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdlsStationRetransmitThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsStationRetransmitThreshold.setDescription('The number of information frame transmissions allowed as a percentage of total information frame transmissions. The specified rate is the maximum rate of retransmissions allowed above which an error log entry will be make.')
ibmdlsStationForceDisconnectTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 11, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 600)).clone(120)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdlsStationForceDisconnectTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsStationForceDisconnectTimeout.setDescription('The number of seconds that the IBM 6611 will wait after requesting a disconnect from the link (DISC) before forcing a disconnect.')
ibmdlsStationMaxIfieldSize = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 11, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(265, 30729)).clone(265)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdlsStationMaxIfieldSize.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsStationMaxIfieldSize.setDescription('The value in bytes of the maximum I-field size (a multiple of 256 plus 9).')
ibmdlsStationPrimaryRepollTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 11, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 250)).clone(30)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdlsStationPrimaryRepollTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsStationPrimaryRepollTimeout.setDescription('The length of time (in tenths of seconds) that the primary station will wait for a response from the secondary station.')
ibmdlsStationPrimaryRepollCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 11, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(3, 50)).clone(15)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdlsStationPrimaryRepollCount.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsStationPrimaryRepollCount.setDescription('The number of times that the primary station will poll the secondary station unsuccessfully before marking the station as not working.')
ibmdlsStationPrimaryRepollThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 11, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100)).clone(10)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdlsStationPrimaryRepollThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsStationPrimaryRepollThreshold.setDescription('The number of repolls as a percentage of the total polls sent to the secondary station. The specified percentage equals the maximum rate of repolls allowed, above which the IBM 6611 declares that a temporary error has occurred and logs an entry in the system error log.')
ibmdlsStationPrimarySlowListTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 11, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 60)).clone(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdlsStationPrimarySlowListTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsStationPrimarySlowListTimeout.setDescription('The number of seconds that the primary station will wait between polls to stations on the slow list.')
ibmdlsStationSrcAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 11, 1, 12), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdlsStationSrcAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsStationSrcAddress.setDescription('The token ring physical address used for this station.')
ibmdlsStationDestAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 11, 1, 13), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdlsStationDestAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsStationDestAddress.setDescription('The token ring physical address to which this station should be connected. If this information is not available the IBM 6611 Network Processor will return a length of zero for this object.')
ibmdlsCirTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 12), )
if mibBuilder.loadTexts: ibmdlsCirTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsCirTable.setDescription('Table of information on DLS circuits active on this router.')
ibmdlsCirEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 12, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmdlsCirIfIndex"), (0, "IBM6611-MIB", "ibmdlsCirSrcAddress"), (0, "IBM6611-MIB", "ibmdlsCirSrcSap"), (0, "IBM6611-MIB", "ibmdlsCirDestAddress"), (0, "IBM6611-MIB", "ibmdlsCirDestSap"))
if mibBuilder.loadTexts: ibmdlsCirEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsCirEntry.setDescription('Information on a DLS circuit.')
ibmdlsCirIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 12, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdlsCirIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsCirIfIndex.setDescription('The value of IfIndex for the interface supporting this circuit.')
ibmdlsCirSrcAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 12, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdlsCirSrcAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsCirSrcAddress.setDescription('The MAC address of the source of this circuit.')
ibmdlsCirSrcSap = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 12, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdlsCirSrcSap.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsCirSrcSap.setDescription('The SAP identifier of the source of this circuit.')
ibmdlsCirDestAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 12, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdlsCirDestAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsCirDestAddress.setDescription('The MAC address of the destination of this circuit.')
ibmdlsCirDestSap = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 12, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdlsCirDestSap.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsCirDestSap.setDescription('The SAP identifier of the destination of this circuit.')
ibmdlsCirPartnerRouterAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 12, 1, 6), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdlsCirPartnerRouterAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsCirPartnerRouterAddress.setDescription('The IP address of the partner router used by this circuit.')
ibmdlsCirLocalLinkState = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 12, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("opening", 1), ("opened", 2), ("closing", 3), ("inactive", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdlsCirLocalLinkState.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsCirLocalLinkState.setDescription('The state of the local link station used by this circuit.')
ibmdlsCirLocalLinkSubState = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 12, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("calling", 1), ("listening", 2), ("contacted", 3), ("localBusy", 4), ("remoteBusy", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdlsCirLocalLinkSubState.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsCirLocalLinkSubState.setDescription('The sub-state of the local link station used by this circuit.')
ibmdlsCirLocalLinkRouting = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 12, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 18))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdlsCirLocalLinkRouting.setReference("IBM Token-ring Network: Architecture Reference (SC30-3374), see 'Routing Information Field'.")
if mibBuilder.loadTexts: ibmdlsCirLocalLinkRouting.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsCirLocalLinkRouting.setDescription('The routing information field used by the local link portion of this circuit. The routing information field consists of a 2-byte routing control field and up to eight 2-byte route designators.')
ibmdlsCirLocalLinkTestCmdsSent = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 12, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdlsCirLocalLinkTestCmdsSent.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsCirLocalLinkTestCmdsSent.setDescription('The number of test commands sent by the local link station used by this circuit.')
ibmdlsCirLocalLinkTestCmdsFail = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 12, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdlsCirLocalLinkTestCmdsFail.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsCirLocalLinkTestCmdsFail.setDescription('The number of test commands failed by the local link station used by this circuit.')
ibmdlsCirLocalLinkTestCmdsRcv = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 12, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdlsCirLocalLinkTestCmdsRcv.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsCirLocalLinkTestCmdsRcv.setDescription('The number of test commands received by the local link station used by this circuit.')
ibmdlsCirLocalLinkDataPktSent = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 12, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdlsCirLocalLinkDataPktSent.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsCirLocalLinkDataPktSent.setDescription('The number of sequenced data packets sent by the local link station used by this circuit.')
ibmdlsCirLocalLinkDataPktResent = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 12, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdlsCirLocalLinkDataPktResent.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsCirLocalLinkDataPktResent.setDescription('The number of sequenced data packets resent by the local link station used by this circuit.')
ibmdlsCirLocalLinkMaxContResent = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 12, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdlsCirLocalLinkMaxContResent.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsCirLocalLinkMaxContResent.setDescription('The maximum number of contiguous resendings by the local link station used by this circuit.')
ibmdlsCirLocalLinkDataPktRcv = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 12, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdlsCirLocalLinkDataPktRcv.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsCirLocalLinkDataPktRcv.setDescription('The number of sequenced data packets received by the local link station used by this circuit.')
ibmdlsCirLocalLinkInvalidPktRcv = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 12, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdlsCirLocalLinkInvalidPktRcv.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsCirLocalLinkInvalidPktRcv.setDescription('The number of invalid packets received by the local link station used by this circuit.')
ibmdlsCirLocalLinkAdpRcvErr = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 12, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdlsCirLocalLinkAdpRcvErr.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsCirLocalLinkAdpRcvErr.setDescription('The number of data-detected receive errors by the local link station used by this circuit.')
ibmdlsCirLocalLinkAdpSendErr = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 12, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdlsCirLocalLinkAdpSendErr.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsCirLocalLinkAdpSendErr.setDescription('The number of data-detected transmit errors by the local link station used by this circuit.')
ibmdlsCirLocalLinkRcvInactiveTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 12, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdlsCirLocalLinkRcvInactiveTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsCirLocalLinkRcvInactiveTimeouts.setDescription('The number of inactivity timeouts received by the local link station used by this circuit.')
ibmdlsCirLocalLinkCmdPollsSent = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 12, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdlsCirLocalLinkCmdPollsSent.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsCirLocalLinkCmdPollsSent.setDescription('The number of command polls sent by the local link station used by this circuit.')
ibmdlsCirLocalLinkCmdRepollsSent = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 12, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdlsCirLocalLinkCmdRepollsSent.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsCirLocalLinkCmdRepollsSent.setDescription('The number of command repolls sent by the local link station used by this circuit.')
ibmdlsCirLocalLinkCmdContRepolls = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 12, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdlsCirLocalLinkCmdContRepolls.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsCirLocalLinkCmdContRepolls.setDescription('The number of continuous repolls sent by the local link station used by this circuit.')
ibmdlsCirLocalAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 12, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("sourceIsLocal", 1), ("destinationIsLocal", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdlsCirLocalAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsCirLocalAddress.setDescription('The address (ibmdlsCirSrcAddress or ibmdlsCirDestAddress) that is local on this circuit.')
ibmdlsCirLocalConnectionState = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 9, 12, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("discontacted", 1), ("contactPending", 2), ("contacted", 3), ("discontactPending", 4), ("connected", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdlsCirLocalConnectionState.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdlsCirLocalConnectionState.setDescription('The state of the DLSw circuit connection based upon the progression of events as a logical link station and its associated DLSw connection is brought up or down.')
ibmpppLinkControlTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 1), )
if mibBuilder.loadTexts: ibmpppLinkControlTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLinkControlTable.setDescription('A table containing PPP-link specific control variables for this managed object. An entry in this table is uniquely identified by the ibmpppLinkControlIndex value comprised by said entry.')
ibmpppLinkControlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 1, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmpppLinkControlIndex"))
if mibBuilder.loadTexts: ibmpppLinkControlEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLinkControlEntry.setDescription('Management control information about a particular PPP Link.')
ibmpppLinkControlIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppLinkControlIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLinkControlIndex.setDescription("A unique value for each PPP link. Its value ranges between 1 and the value of ifNumber. The interface identified by a particular value of this index is that identified by the same value of an ifIndex object instance. The value for each link must remain constant at least from one re-initialization of the entity's network management system to the next re-initialization.")
ibmpppLinkCRCSize = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(16, 32))).clone(namedValues=NamedValues(("ppp-crc-16", 16), ("ppp-crc-32", 32)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppLinkCRCSize.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLinkCRCSize.setDescription("Number of bits used in the CRC on this link. See section 3.1, 'Frame Check Sequence (FCS) Field' on page 5 of RFC 1171. Setting this object to a new value will have effect when this link is next restarted.")
ibmpppLinkRestartTimerValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppLinkRestartTimerValue.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLinkRestartTimerValue.setDescription("The value used for the Restart Timer. It is in units of hundredths of a second. See section 4.3, 'Timers and Counters' on page 20 of RFC 1171.")
ibmpppLinkMaxRestarts = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppLinkMaxRestarts.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLinkMaxRestarts.setDescription("The Max-Restarts parameter described in section 4.3, 'Timers and Counters' on page 20 of RFC 1171.")
ibmpppLinkLocalMRU = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppLinkLocalMRU.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLinkLocalMRU.setDescription("The MRU (Maximum Receive Unit) of this node on the link. See section 2.1, page 2, 'Maximum Receive Unit' of RFC 1172. Changing this object will have effect when the link is next restarted.")
ibmpppLinkRemoteMRU = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppLinkRemoteMRU.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLinkRemoteMRU.setDescription("What this node believes is the MRU for the node on the other end of the link. See section 2.1, page 2, 'Maximum Receive Unit' of RFC 1172. Changing this object will immediately cause the local node to use the new MRU when transmitting packets. If this number is increased, then the sender MAY elect to use the new MRU. If the MRU is decreased then the sender MUST use the new MRU.")
ibmpppLinkLocalACCMap = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 1, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppLinkLocalACCMap.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLinkLocalACCMap.setDescription("The (ACC) Asynchronous-Control-Character-Map for this node. This is the ACC Map that the node on the other end of the link will use when building a packet to send to this node. See section 2.2, page 3, 'Async-Control- Character-Map' of RFC 1172. The IBM 6611 Network Processor always provides a value of zero for this object.")
ibmpppLinkRemoteACCMap = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 1, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppLinkRemoteACCMap.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLinkRemoteACCMap.setDescription("The (ACC) Asynchronous-Control-Character-Map that this node uses when building a packet to send to the node on the other end of the link. See section 2.2, page 3, 'Async-Control-Character-Map' of RFC 1172. The IBM 6611 Network Processor always provides a value of zero for this object.")
ibmpppLinkMagicLoopCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppLinkMagicLoopCount.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLinkMagicLoopCount.setDescription('The number of times that this node will do a Magic Number Configuration before deciding that the link is looped back. 0 indicates that the node does not do Magic Number Configuration. -1 indicates that it tries forever. Changing this object takes effect the next time that the link is restarted.')
ibmpppLinkCommand = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no-op", 1), ("close", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppLinkCommand.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLinkCommand.setDescription('See section 4.14 on page 13 of RFC 1171. Reading from this variable will return no-op(1). The IBM 6611 Network Processor always provides a value of no-op(1) for this object.')
ibmpppLinkStatusTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 2), )
if mibBuilder.loadTexts: ibmpppLinkStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLinkStatusTable.setDescription('A table containing PPP-link status specific information for this managed object. An entry in this table is uniquely identified by the ibmpppLinkStatusIndex value comprised by said entry.')
ibmpppLinkStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 2, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmpppLinkStatusIndex"))
if mibBuilder.loadTexts: ibmpppLinkStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLinkStatusEntry.setDescription('Status information about a particular PPP Link.')
ibmpppLinkStatusIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppLinkStatusIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLinkStatusIndex.setDescription("A unique value for each PPP link. Its value ranges between 1 and the value of ifNumber. The interface identified by a particular value of this index is that identified by the same value of an ifIndex object instance. The value for each link must remain constant at least from one re-initialization of the entity's network management system to the next re-initialization.")
ibmpppLinkVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppLinkVersion.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLinkVersion.setDescription('The version of LCP that is being run over this link (per RFC 1171). This value currently must be 1.')
ibmpppLinkCurrentState = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("closed", 1), ("listen", 2), ("reqsent", 3), ("ackrecvd", 4), ("acksent", 5), ("open", 6), ("closing", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppLinkCurrentState.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLinkCurrentState.setDescription("The current state of the link automaton. See section 4.1.3. 'State Transition Table' on page 13 of RFC 1171.")
ibmpppLinkPreviousState = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("closed", 1), ("listen", 2), ("reqsent", 3), ("ackrecvd", 4), ("acksent", 5), ("open", 6), ("closing", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppLinkPreviousState.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLinkPreviousState.setDescription("The immediately previous state of the link automaton. See section 4.1.3. 'State Transition Table' on page 13 of RFC 1171.")
ibmpppLinkChangeTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 2, 1, 5), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppLinkChangeTime.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLinkChangeTime.setDescription('The value of sysUpTime when the state of the link automaton last changed.')
ibmpppLinkMagicNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppLinkMagicNumber.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLinkMagicNumber.setDescription("This node's Magic Number. See section 2.4, page 7, 'Magic Number' of RFC 1172.")
ibmpppLinkLocalQualityPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppLinkLocalQualityPeriod.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLinkLocalQualityPeriod.setDescription('This is the maximum interval at which this node will transmit Link-Quality-Report Packets. See section 2.5, on page 10 of RFC 1172. This object is in units of microseconds.')
ibmpppLinkRemoteQualityPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 2, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppLinkRemoteQualityPeriod.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLinkRemoteQualityPeriod.setDescription('This is the maximum interval at which this node expects that the other node will transmit Link-Quality-Report Packets. See section 2.5, on page 10 of RFC 1172. This object is in units of microseconds.')
ibmpppLinkProtocolCompression = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("receive-only", 1), ("send-only", 2), ("receive-and-send", 3), ("none", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppLinkProtocolCompression.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLinkProtocolCompression.setDescription("Indicates the Protocol compression that has been configured on the link. Receive-only(1) indicates that this node can receive compressed packets but won't send them. Send-only(2) indicates that this node will send compressed packets but can not receive them. Receive-and-send(3) indicates that the node will send and can receive compressed packets. None(4) indicates that this node will neither send nor receive compressed packets. See section 2.6, on page 11 of RFC 1172. The IBM 6611 Network Processor always provides a value of none(4) for this object.")
ibmpppLinkACCompression = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("receive-only", 1), ("send-only", 2), ("receive-and-send", 3), ("none", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppLinkACCompression.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLinkACCompression.setDescription("Indicates the Address/Control Field compression that has been configured on the link. Receive-only(1) indicates that this node can receive compressed packets but won't send them. Send-only(2) indicates that this node will send compressed packets but can not receive them. Receive-and- send(3) indicates that the node will send and can receive compressed packets. None(4) indicates that this node will neither send nor receive compressed packets. See section 2.7, on page 13 of RFC 1172. The IBM 6611 Network Processor always provides a value of none(4) for this object.")
ibmpppLinkMeasurementsValid = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 2, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppLinkMeasurementsValid.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLinkMeasurementsValid.setDescription('The current value of the Measurements-Valid state variable used for Link-Quality Management. See section 3.5, page 19, of RFC 1172.')
ibmpppLinkQuality = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("good", 1), ("bad", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppLinkQuality.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLinkQuality.setDescription('The current quality of the link as declared by the nodes Link-Quality Management modules. No effort is made to define good or bad, nor the policy used to determine it.')
ibmpppLinkPhysical = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 2, 1, 13), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppLinkPhysical.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLinkPhysical.setDescription('A reference to MIB definitions specific to the particular physical interface type (e.g. T1) being used by the PPP Link. If the agent is unable to obtain this information, the value of this object will be set to the OBJECT IDENTIFIER { 0 0 }, which is a syntatically valid object identifier, and any conformant implementation of ASN.1 and BER must be able to generate and recognize this value.')
ibmpppLinkErrorsTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 3), )
if mibBuilder.loadTexts: ibmpppLinkErrorsTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLinkErrorsTable.setDescription('A table containing PPP-link specific statistical information for this managed object. An entry in this table is uniquely identified by the ibmpppLinkErrorsIndex value comprised by said entry.')
ibmpppLinkErrorsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 3, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmpppLinkErrorsIndex"))
if mibBuilder.loadTexts: ibmpppLinkErrorsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLinkErrorsEntry.setDescription('Error information about a particular PPP Link.')
ibmpppLinkErrorsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppLinkErrorsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLinkErrorsIndex.setDescription("A unique value for each PPP link. Its value ranges between 1 and the value of ifNumber. The interface identified by a particular value of this index is that identified by the same value of an ifIndex object instance. The value for each link must remain constant at least from one re-initialization of the entity's network management system to the next re-initialization.")
ibmpppLinkBadAddresses = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 3, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppLinkBadAddresses.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLinkBadAddresses.setDescription("The number of packets received with an incorrect Address Field. See section 3.1, Page 5, 'Address Field' of RFC 1171.")
ibmpppLinkLastBadAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 3, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppLinkLastBadAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLinkLastBadAddress.setDescription('The most recent incorrect address received on this link.')
ibmpppLinkBadControls = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 3, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppLinkBadControls.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLinkBadControls.setDescription("The number of packets received on this link with an incorrect Control Field. See Section 3.1, Page 5, 'Flag Sequence' of RFC 1171.")
ibmpppLinkLastBadControl = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 3, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppLinkLastBadControl.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLinkLastBadControl.setDescription('The most recent incorrect Control Field received on this link.')
ibmpppLinkLastUnknownProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 3, 1, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppLinkLastUnknownProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLinkLastUnknownProtocol.setDescription('The most recently received unknown Protocol. An unknown Protocol is one which has a well-formed Protocol number, but which the PPP implementation does not know how to handle.')
ibmpppLinkInvalidProtocols = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 3, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppLinkInvalidProtocols.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLinkInvalidProtocols.setDescription('The number of times that a packet has been received with an invalid Protocol specified in the Protocol Field. An invalid Protocol is one which does not conform to the requirements of section 3.1, page 5 of RFC 1171.')
ibmpppLinkLastInvalidProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 3, 1, 8), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppLinkLastInvalidProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLinkLastInvalidProtocol.setDescription('The most recently received invalid Protocol.')
ibmpppLinkPacketTooLongs = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 3, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppLinkPacketTooLongs.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLinkPacketTooLongs.setDescription('The number of received packets that have been discarded because their length exceeded the MRU.')
ibmpppLinkBadCRCs = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 3, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppLinkBadCRCs.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLinkBadCRCs.setDescription('The number of received packets that have been discarded due to having an incorrect CRC.')
ibmpppLinkConfigTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 3, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppLinkConfigTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLinkConfigTimeouts.setDescription('The number of Configure Request packets that have timed out.')
ibmpppLinkTerminateTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 3, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppLinkTerminateTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLinkTerminateTimeouts.setDescription('The number of Terminate Request packets that have timed out.')
ibmpppLinkQualityTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 4), )
if mibBuilder.loadTexts: ibmpppLinkQualityTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLinkQualityTable.setDescription('A table containing PPP-link specific statistical information for this managed object. An entry in this table is uniquely identified by the ibmpppLinkQualityIndex value comprised by said entry.')
ibmpppLinkQualityEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 4, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmpppLinkQualityIndex"))
if mibBuilder.loadTexts: ibmpppLinkQualityEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLinkQualityEntry.setDescription('Link Quality Management information about a particular PPP Link.')
ibmpppLinkQualityIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppLinkQualityIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLinkQualityIndex.setDescription("A unique value for each PPP link. Its value ranges between 1 and the value of ifNumber. The interface identified by a particular value of this index is that identified by the same value of an ifIndex object instance. The value for each link must remain constant at least from one re-initialization of the entity's network management system to the next re-initialization.")
ibmpppLinkInTxLQRs = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 4, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppLinkInTxLQRs.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLinkInTxLQRs.setDescription('The current value of In-Tx-LQRs used in Link-Quality Management. See section 3.5, page 19, of RFC 1172.')
ibmpppLinkInTxPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 4, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppLinkInTxPackets.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLinkInTxPackets.setDescription('The current value of the In-Tx-Packets counter used for Link-Quality Management. See section 3.5, page 19, of RFC 1172.')
ibmpppLinkLastOutTxPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 4, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppLinkLastOutTxPackets.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLinkLastOutTxPackets.setDescription('The current value of the Last-Out-Tx-Packets-Ctr counter used bu Link-Quality Management. See section 3.5, page 19, of RFC 1172.')
ibmpppLinkInTxOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 4, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppLinkInTxOctets.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLinkInTxOctets.setDescription('The current value of the In-Tx-Octets counter used for Link-Quality Management. See section 3.5, page 19, of RFC 1172.')
ibmpppLinkLastOutTxOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 4, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppLinkLastOutTxOctets.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLinkLastOutTxOctets.setDescription('The current value of the Last-Out-Tx-Octets-Counter counter used for Link-Quality Management. See section 3.5, page 19, of RFC 1172.')
ibmpppLinkInRxPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 4, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppLinkInRxPackets.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLinkInRxPackets.setDescription('The current value of the In-Rx-Packets counter used for Link-Quality Management. See section 3.5, page 19, of RFC 1172.')
ibmpppLinkLastInRxPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 4, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppLinkLastInRxPackets.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLinkLastInRxPackets.setDescription('The current value of the Last-In-Rx-Packets-Ctr counter used for Link-Quality Management. See section 3.5, page 19, of RFC 1172.')
ibmpppLinkInRxOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 4, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppLinkInRxOctets.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLinkInRxOctets.setDescription('The current value of the In-Rx-Octets counter used for Link-Quality Management. See section 3.5, page 19, of RFC 1172.')
ibmpppLinkLastInRxOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 4, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppLinkLastInRxOctets.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLinkLastInRxOctets.setDescription('The current value of the Last-In-Rx-Octets-Ctr counter used for Link-Quality Management. See section 3.5, page 19, of RFC 1172.')
ibmpppProtocolTables = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 5))
ibmpppIPTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 5, 1), )
if mibBuilder.loadTexts: ibmpppIPTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppIPTable.setDescription('A table containing specific information for the running of the IP over PPP in this managed object. An entry in this table is uniquely identified by the ibmpppIPLinkNumber value comprised by said entry.')
ibmpppIPEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 5, 1, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmpppIPLinkNumber"))
if mibBuilder.loadTexts: ibmpppIPEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppIPEntry.setDescription('All information pertinant to running the IP over a single PPP link.')
ibmpppIPLinkNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 5, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppIPLinkNumber.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppIPLinkNumber.setDescription('The value of ibmpppLinkIndex for the link over which this instance of the IP is being run.')
ibmpppIPRejects = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 5, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppIPRejects.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppIPRejects.setDescription('The number of Protocol Reject Messages received when attempting to send an IP packet over the link identified by ibmpppIPLinkNumber.')
ibmpppIPInPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 5, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppIPInPackets.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppIPInPackets.setDescription('The number of IP packets received on the link identified by ibmpppIPLinkNumber.')
ibmpppIPInOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 5, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppIPInOctets.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppIPInOctets.setDescription('The number of octets received in IP packets received on the link identified by ibmpppIPLinkNumber. Only octets in the PPP Information Field are counted. Octets inserted for transparency are not counted. Padding octets are not counted.')
ibmpppIPOutPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 5, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppIPOutPackets.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppIPOutPackets.setDescription('The number of IP packets sent on the link identified by ibmpppIPLinkNumber.')
ibmpppIPOutOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 5, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppIPOutOctets.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppIPOutOctets.setDescription('The number of octets all in IP Packets sent on the link identified by ibmpppIPLinkNumber. Only octets in the PPP Information Field are counted. Octets inserted for transparency are not counted. Padding octets are not counted.')
ibmpppIPCPTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 5, 2), )
if mibBuilder.loadTexts: ibmpppIPCPTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppIPCPTable.setDescription('A table containing specific information for the running of the IPCP over PPP in this managed object. An entry in this table is uniquely identified by the ibmpppIPCPLinkNumber value comprised by said entry.')
ibmpppIPCPEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 5, 2, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmpppIPCPLinkNumber"))
if mibBuilder.loadTexts: ibmpppIPCPEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppIPCPEntry.setDescription('All information pertinant to running the IPCP over a single PPP link.')
ibmpppIPCPLinkNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 5, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppIPCPLinkNumber.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppIPCPLinkNumber.setDescription('The value of ibmpppLinkIndex for the link over which this instance of the IPCP is being run.')
ibmpppIPCPRejects = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 5, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppIPCPRejects.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppIPCPRejects.setDescription('The number of Protocol Reject Messages received when attempting to send an IPCP Packet over the link identified by ibmpppIPCPLinkNumber.')
ibmpppIPCPInPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 5, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppIPCPInPackets.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppIPCPInPackets.setDescription('The number of IPCP packets received on the link identified by ibmpppIPCPLinkNumber.')
ibmpppIPCPInOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 5, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppIPCPInOctets.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppIPCPInOctets.setDescription('The number of octets received in IPCP packets received on the link identified by ibmpppIPCPLinkNumber. Only octets in the PPP Information Field are counted. Octets inserted for transparency are not counted. Padding octets are not counted.')
ibmpppIPCPOutPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 5, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppIPCPOutPackets.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppIPCPOutPackets.setDescription('The number of IPCP packets sent on the link identified by ibmpppIPLinkNumber.')
ibmpppIPCPOutOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 5, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppIPCPOutOctets.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppIPCPOutOctets.setDescription('The number of octets all in IPCP packets sent on the link identified by ibmpppIPCPLinkNumber. Only octets in the PPP Information Field are counted. Octets inserted for transparency are not counted. Padding octets are not counted.')
ibmpppIPCPCompressionType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 5, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("none", 1), ("van-jacobson-compressed-tcp", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppIPCPCompressionType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppIPCPCompressionType.setDescription('The compression type used on this link as defined in section 5.2 of RFC 1172. The numerical values that this object can be are the same as the numerical values that are included in the IPCP compression option configuration packets. The IBM 6611 Network Processor always provides a value of none(1) for this object.')
ibmpppLCPTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 5, 3), )
if mibBuilder.loadTexts: ibmpppLCPTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLCPTable.setDescription('A table containing specific information for the running of LCP over PPP in this managed object. An entry in this table is uniquely identified by the ibmpppLCPLinkNumber value comprised by said entry.')
ibmpppLCPEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 5, 3, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmpppLCPLinkNumber"))
if mibBuilder.loadTexts: ibmpppLCPEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLCPEntry.setDescription('All information pertinant to running LCP over a single PPP link.')
ibmpppLCPLinkNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 5, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppLCPLinkNumber.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLCPLinkNumber.setDescription('The value of ibmpppLinkIndex for the link over which this instance of LCP is being run.')
ibmpppLCPRejects = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 5, 3, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppLCPRejects.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLCPRejects.setDescription('The number of Protocol Reject Messages received when attempting to send an LCP packet over the link identified by ibmpppLCPLinkNumber. This really ought not to happen.')
ibmpppLCPInPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 5, 3, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppLCPInPackets.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLCPInPackets.setDescription('The number of LCP packets received on the link identified by ibmpppLCPLinkNumber.')
ibmpppLCPInOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 5, 3, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppLCPInOctets.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLCPInOctets.setDescription('The number of octets received in LCP packets received on the link identified by ibmpppLCPLinkNumber. Only octets in the PPP Information Field are counted. Octets inserted for transparency are not counted. Padding octets are not counted.')
ibmpppLCPOutPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 5, 3, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppLCPOutPackets.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLCPOutPackets.setDescription('The number of LCP packets sent on the link identified by ibmpppLCPLinkNumber.')
ibmpppLCPOutOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 5, 3, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppLCPOutOctets.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLCPOutOctets.setDescription('The number of octets all in LCP packets sent on the link identified by ibmpppLCPLinkNumber. Only octets in the PPP Information Field are counted. Octets inserted for transparency are not counted. Padding octets are not counted.')
ibmpppLCPOutCRs = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 5, 3, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppLCPOutCRs.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLCPOutCRs.setDescription('Number of Configuration Request packets sent on this link.')
ibmpppLCPInCRs = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 5, 3, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppLCPInCRs.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLCPInCRs.setDescription('Number of Configuration Request packets received on this link.')
ibmpppLCPOutCAs = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 5, 3, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppLCPOutCAs.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLCPOutCAs.setDescription('Number of Configuration Acknowledge packets sent on this link.')
ibmpppLCPInCAs = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 5, 3, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppLCPInCAs.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLCPInCAs.setDescription('Number of Configuration Acknowledge packets received on this link.')
ibmpppLCPOutCNs = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 5, 3, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppLCPOutCNs.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLCPOutCNs.setDescription('Number of Configuration NAK packets sent on this link.')
ibmpppLCPInCNs = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 5, 3, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppLCPInCNs.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLCPInCNs.setDescription('Number of Configuration NAK packets received on this link.')
ibmpppLCPOutCRejs = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 5, 3, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppLCPOutCRejs.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLCPOutCRejs.setDescription('Number of Configuration Reject packets sent on this link.')
ibmpppLCPInCRejs = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 5, 3, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppLCPInCRejs.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLCPInCRejs.setDescription('Number of Configuration Reject packets received on this link.')
ibmpppLCPOutTRs = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 5, 3, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppLCPOutTRs.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLCPOutTRs.setDescription('Number of Terminate Request packets sent on this link.')
ibmpppLCPInTRs = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 5, 3, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppLCPInTRs.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLCPInTRs.setDescription('Number of Terminate Request packets received on this link.')
ibmpppLCPOutTAs = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 5, 3, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppLCPOutTAs.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLCPOutTAs.setDescription('Number of Terminate Acknowledge packets sent on this link.')
ibmpppLCPInTAs = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 5, 3, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppLCPInTAs.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLCPInTAs.setDescription('Number of Terminate Acknowledge packets received on this link.')
ibmpppLCPOutCodeRejs = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 5, 3, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppLCPOutCodeRejs.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLCPOutCodeRejs.setDescription('Number of Code Reject packets sent on this link.')
ibmpppLCPInCodeRejs = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 5, 3, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppLCPInCodeRejs.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLCPInCodeRejs.setDescription('Number of Code Reject packets received on this link.')
ibmpppLCPOutEchoReqs = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 5, 3, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppLCPOutEchoReqs.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLCPOutEchoReqs.setDescription('Number of Echo Request packets sent on this link.')
ibmpppLCPInEchoReqs = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 5, 3, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppLCPInEchoReqs.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLCPInEchoReqs.setDescription('Number of Echo Request packets received on this link.')
ibmpppLCPOutEchoReps = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 5, 3, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppLCPOutEchoReps.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLCPOutEchoReps.setDescription('Number of Echo Reply packets sent on this link.')
ibmpppLCPInEchoReps = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 5, 3, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppLCPInEchoReps.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLCPInEchoReps.setDescription('Number of Echo Reply packets received on this link.')
ibmpppLCPOutDiscReqs = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 5, 3, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppLCPOutDiscReqs.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLCPOutDiscReqs.setDescription('Number of Discard Request packets sent on this link.')
ibmpppLCPInDiscReqs = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 10, 5, 3, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmpppLCPInDiscReqs.setStatus('mandatory')
if mibBuilder.loadTexts: ibmpppLCPInDiscReqs.setDescription('Number of Discard Request packets received on this link.')
ibmxnsidpForwarding = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 11, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("forwarding", 1), ("not-forwarding", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmxnsidpForwarding.setStatus('mandatory')
if mibBuilder.loadTexts: ibmxnsidpForwarding.setDescription('Indicates if this node is acting as an XNS router.')
ibmxnsConfigTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 11, 4), )
if mibBuilder.loadTexts: ibmxnsConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmxnsConfigTable.setDescription('The table of XNS configuration information gathered on a per-interface basis.')
ibmxnsConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 11, 4, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmxnsPortIfIndex"))
if mibBuilder.loadTexts: ibmxnsConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmxnsConfigEntry.setDescription('XNS configuration information for a single interface.')
ibmxnsPortIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 11, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmxnsPortIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmxnsPortIfIndex.setDescription('The value of this object identifies the interface for which this entry contains management information. The value of this object for a particular interface has the same value as the ifIndex object for the same interface.')
ibmxnsPortStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 11, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmxnsPortStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ibmxnsPortStatus.setDescription('The status of the XNS protocol stack on this interface.')
ibmxnsidpChecksum = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 11, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("header", 2), ("packet", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmxnsidpChecksum.setStatus('mandatory')
if mibBuilder.loadTexts: ibmxnsidpChecksum.setDescription('Indicates the type of checksumming being done by IDP.')
ibmxnsErrpActive = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 11, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("suppressed", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmxnsErrpActive.setStatus('mandatory')
if mibBuilder.loadTexts: ibmxnsErrpActive.setDescription('Indicates if this port is originating error protocol packets.')
ibmxnsLoopbackActive = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 11, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("software-loopback-active", 1), ("hardware-loopback-active", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmxnsLoopbackActive.setStatus('mandatory')
if mibBuilder.loadTexts: ibmxnsLoopbackActive.setDescription('Indicates if this port will use the hardware to loopback locally addressed packets or return the packet to the system via a software loopback.')
ibmxnsidpInReceives = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 11, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmxnsidpInReceives.setStatus('mandatory')
if mibBuilder.loadTexts: ibmxnsidpInReceives.setDescription('Total number of IDP datagrams received.')
ibmxnsidpBcastInReceives = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 11, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmxnsidpBcastInReceives.setStatus('mandatory')
if mibBuilder.loadTexts: ibmxnsidpBcastInReceives.setDescription('Number of IDP broadcast datagrams received.')
ibmxnsidpMcastInReceives = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 11, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmxnsidpMcastInReceives.setStatus('mandatory')
if mibBuilder.loadTexts: ibmxnsidpMcastInReceives.setDescription('Number of IDP multicast datagrams received.')
ibmxnsidpInDiscards = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 11, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmxnsidpInDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: ibmxnsidpInDiscards.setDescription('Number of incoming IDP datagrams discarded due to lack of resources.')
ibmxnsidpOutRequests = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 11, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmxnsidpOutRequests.setStatus('mandatory')
if mibBuilder.loadTexts: ibmxnsidpOutRequests.setDescription('Number of IDP datagrams generated by local IDP user protocols. This counter does not include any datagrams counted in ibmxnsidpForwDatagrams.')
ibmxnsidpBcastOutRequests = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 11, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmxnsidpBcastOutRequests.setStatus('mandatory')
if mibBuilder.loadTexts: ibmxnsidpBcastOutRequests.setDescription('Number of IDP broadcast datagrams generated by local IDP user protocols. This counter does not include any datagrams counted in ibmxnsidpForwDatagrams.')
ibmxnsidpMcastOutRequests = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 11, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmxnsidpMcastOutRequests.setStatus('mandatory')
if mibBuilder.loadTexts: ibmxnsidpMcastOutRequests.setDescription('Number of IDP multicast datagrams generated by local IDP user protocols. This counter does not include any datagrams counted in ibmxnsidpForwDatagrams.')
ibmxnsidpForwDatagrams = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 11, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmxnsidpForwDatagrams.setStatus('mandatory')
if mibBuilder.loadTexts: ibmxnsidpForwDatagrams.setDescription('Number of IDP datagrams for which an attempt was made to forward.')
ibmxnsidpOutDiscards = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 11, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmxnsidpOutDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: ibmxnsidpOutDiscards.setDescription('Total number of outgoing IDP datagrams discarded.')
ibmxnsidpOutNoRoutes = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 11, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmxnsidpOutNoRoutes.setStatus('mandatory')
if mibBuilder.loadTexts: ibmxnsidpOutNoRoutes.setDescription('Number of outgoing IDP datagrams discarded because no route was available to the specified destination.')
ibmxnsidpRoutingDiscards = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 11, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmxnsidpRoutingDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: ibmxnsidpRoutingDiscards.setDescription('Number of routing entries discarded even though they were valid.')
ibmxnsidpZeroDirBcast = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 11, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmxnsidpZeroDirBcast.setStatus('mandatory')
if mibBuilder.loadTexts: ibmxnsidpZeroDirBcast.setDescription('Number of IDP datagrams forwarded to the system due to zeronet broadcast.')
ibmxnsidpTooSmall = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 11, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmxnsidpTooSmall.setStatus('mandatory')
if mibBuilder.loadTexts: ibmxnsidpTooSmall.setDescription('Number of IDP datagrams with len < the size of an IDP header.')
ibmxnsidpBadLen = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 11, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmxnsidpBadLen.setStatus('mandatory')
if mibBuilder.loadTexts: ibmxnsidpBadLen.setDescription('Number of IDP datagrams with number of bytes in the packet less than the number of bytes specified in the IDP header field.')
ibmxnsidpBadSum = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 11, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmxnsidpBadSum.setStatus('mandatory')
if mibBuilder.loadTexts: ibmxnsidpBadSum.setDescription('Number of IDP datagrams with a bad checksum')
ibmxnsidpBadTTL = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 11, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmxnsidpBadTTL.setStatus('mandatory')
if mibBuilder.loadTexts: ibmxnsidpBadTTL.setDescription('Number of IDP datagrams with TTL value > IDP maximum hopcount of 16.')
ibmxnsErrUnspec = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 11, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmxnsErrUnspec.setStatus('mandatory')
if mibBuilder.loadTexts: ibmxnsErrUnspec.setDescription('Number of Error packets generated because an IDP datagram was dropped for unspecified reasons.')
ibmxnsErrChecksum = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 11, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmxnsErrChecksum.setStatus('mandatory')
if mibBuilder.loadTexts: ibmxnsErrChecksum.setDescription('Number of Error packets generated because an IDP datagram was dropped due a bad checksum.')
ibmxnsErrUnreach = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 11, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmxnsErrUnreach.setStatus('mandatory')
if mibBuilder.loadTexts: ibmxnsErrUnreach.setDescription('Number of Error packets generated because an IDP datagram was dropped due to an unreachable host.')
ibmxnsErrTTLExpired = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 11, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmxnsErrTTLExpired.setStatus('mandatory')
if mibBuilder.loadTexts: ibmxnsErrTTLExpired.setDescription('Number of Error packets generated because an IDP datagram was dropped because its time-to-live counter had expired.')
ibmxnsErrTooBig = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 11, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmxnsErrTooBig.setStatus('mandatory')
if mibBuilder.loadTexts: ibmxnsErrTooBig.setDescription('Number of Error packets generated because an IDP datagram was dropped because it was too large to be forwarded through this node.')
ibmxnsErrResources = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 11, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmxnsErrResources.setStatus('mandatory')
if mibBuilder.loadTexts: ibmxnsErrResources.setDescription('Number of Error packets generated because an IDP datagram was dropped due to lack of resources.')
ibmxnsErrCongWarn = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 11, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmxnsErrCongWarn.setStatus('mandatory')
if mibBuilder.loadTexts: ibmxnsErrCongWarn.setDescription('Number of Error packets generated for congestion warnings.')
ibmxnsErrCongDiscard = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 11, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmxnsErrCongDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: ibmxnsErrCongDiscard.setDescription('Number of Error packets generated for congestion discards.')
ibmxnsErrSquelched = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 11, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmxnsErrSquelched.setStatus('mandatory')
if mibBuilder.loadTexts: ibmxnsErrSquelched.setDescription('Number of error packets that would have been generated, except that the faulted datagram had one of the following conditions: - was sent as link layer broadcast - NS destination was broadcast - NS source was 0, loopback, or broadcast')
ibmxnsErrOutMsgs = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 11, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmxnsErrOutMsgs.setStatus('mandatory')
if mibBuilder.loadTexts: ibmxnsErrOutMsgs.setDescription('Total number of error packets generated.')
ibmxnsAddrTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 11, 34), )
if mibBuilder.loadTexts: ibmxnsAddrTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmxnsAddrTable.setDescription('The XNS Address Table.')
ibmxnsAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 11, 34, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmxnsAddrAddress"))
if mibBuilder.loadTexts: ibmxnsAddrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmxnsAddrEntry.setDescription('An entry in the XNS address table.')
ibmxnsAddrAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 11, 34, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(12, 12)).setFixedLength(12)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmxnsAddrAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ibmxnsAddrAddress.setDescription("The XNS address to which this entry's addressing information pertains.")
ibmxnsAddrIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 11, 34, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmxnsAddrIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmxnsAddrIfIndex.setDescription('The interface index which identifies the interface to which this entry is applicable.')
ibmxnsRouteTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 11, 35), )
if mibBuilder.loadTexts: ibmxnsRouteTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmxnsRouteTable.setDescription('The XNS Route Table.')
ibmxnsRouteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 11, 35, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmxnsRouteDest"))
if mibBuilder.loadTexts: ibmxnsRouteEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmxnsRouteEntry.setDescription('An entry in the XNS route table.')
ibmxnsRouteDest = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 11, 35, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(12, 12)).setFixedLength(12)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmxnsRouteDest.setStatus('mandatory')
if mibBuilder.loadTexts: ibmxnsRouteDest.setDescription('The desination network of this route.')
ibmxnsRouteIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 11, 35, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmxnsRouteIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmxnsRouteIfIndex.setDescription('The index value which identifies the local interface through which the next hop of this route should be reached.')
ibmxnsRouteNextHop = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 11, 35, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmxnsRouteNextHop.setStatus('mandatory')
if mibBuilder.loadTexts: ibmxnsRouteNextHop.setDescription('The XNS network address of the next hop of this route.')
ibmxnsRouteMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 11, 35, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmxnsRouteMetric.setStatus('mandatory')
if mibBuilder.loadTexts: ibmxnsRouteMetric.setDescription('The hop count to the destination.')
ibmxnsRouteUse = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 11, 35, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmxnsRouteUse.setStatus('mandatory')
if mibBuilder.loadTexts: ibmxnsRouteUse.setDescription('Reference counter for this route.')
ibmxnsFilterTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 11, 36), )
if mibBuilder.loadTexts: ibmxnsFilterTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmxnsFilterTable.setDescription('The XNS Filter Table.')
ibmxnsFilterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 11, 36, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmxnsFilterIfIndex"), (0, "IBM6611-MIB", "ibmxnsFilterNumber"))
if mibBuilder.loadTexts: ibmxnsFilterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmxnsFilterEntry.setDescription('An entry in the XNS filter table.')
ibmxnsFilterIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 11, 36, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmxnsFilterIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmxnsFilterIfIndex.setDescription('The value of this object identifies the interface for which this entry contains management information. The value of this object for a particular interface has the same value as the ifIndex object for the same interface.')
ibmxnsFilterNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 11, 36, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmxnsFilterNumber.setStatus('mandatory')
if mibBuilder.loadTexts: ibmxnsFilterNumber.setDescription('A unique integer identifying this filter entry for this interface.')
ibmxnsFilterValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 11, 36, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(30, 30)).setFixedLength(30)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmxnsFilterValue.setStatus('mandatory')
if mibBuilder.loadTexts: ibmxnsFilterValue.setDescription('An octet string representing the IDP header information required by this filter entry. Incoming IDP packets will be bitwise ANDed with the value of ibmxnsFilterMask, and if the result is equal to the value of this object, the packet will be filtered according to the value of ibmxnsFilterType. The structure of an IDP header is as follows: BIT16 checksum BIT16 length BIT8 transport control (ie. hop count) BIT8 packet type BIT32 destination network address BIT48 destination host address BIT16 destination socket BIT32 source network address BIT48 source host address BIT16 source socket ')
ibmxnsFilterMask = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 11, 36, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(30, 30)).setFixedLength(30)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmxnsFilterMask.setStatus('mandatory')
if mibBuilder.loadTexts: ibmxnsFilterMask.setDescription('An octet string indicating the parts of the IDP header relevant to this filter entry. This mask will be bitwise ANDed with the IDP packet; if the result is equal to the value of ibmxnsFilterValue, the packet will be filtered according to the value of ibmxnsFilterType.')
ibmxnsFilterType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 11, 36, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("deny", 1), ("permit", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmxnsFilterType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmxnsFilterType.setDescription('Determines whether this filter is a deny entry or a permit entry.')
ibmxnsFilterHCCompare = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 11, 36, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("none", 1), ("less-than", 2), ("less-than-equal", 3), ("equal", 4), ("greater-than-equal", 5), ("greater-than", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmxnsFilterHCCompare.setStatus('mandatory')
if mibBuilder.loadTexts: ibmxnsFilterHCCompare.setDescription('Indicates the relational association desired if filtering is being done based on hop count. If filtering is not being done based on hop count (that is, if the hop count portion of ibmxnsFilterMask is 0) the value of this object will be none(1).')
ibmxnsFilterUse = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 11, 36, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmxnsFilterUse.setStatus('mandatory')
if mibBuilder.loadTexts: ibmxnsFilterUse.setDescription('Usage count for this filter entry.')
ibmipxidpForwarding = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 12, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("forwarding", 1), ("not-forwarding", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmipxidpForwarding.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipxidpForwarding.setDescription('Indicates if this node is acting as an IPX router.')
ibmipxConfigTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 12, 4), )
if mibBuilder.loadTexts: ibmipxConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipxConfigTable.setDescription('The table of IPX configuration information gathered on a per-interface basis.')
ibmipxConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 12, 4, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmipxPortIfIndex"))
if mibBuilder.loadTexts: ibmipxConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipxConfigEntry.setDescription('IPX configuration information for a single interface.')
ibmipxPortIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 12, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmipxPortIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipxPortIfIndex.setDescription('The value of this object identifies the interface for which this entry contains management information. The value of this object for a particular interface has the same value as the ifIndex object for the same interface.')
ibmipxPortStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 12, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmipxPortStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipxPortStatus.setDescription('The status of the IPX protocol stack on this interface.')
ibmipxidpChecksum = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 12, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("header", 2), ("packet", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmipxidpChecksum.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipxidpChecksum.setDescription('Indicates the type of checksumming being done by IDP.')
ibmipxLoopbackActive = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 12, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("software-loopback-active", 1), ("hardware-loopback-active", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmipxLoopbackActive.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipxLoopbackActive.setDescription('Indicates if this port will use the hardware to loopback locally addressed packets or return the packet to the system via a software loopback.')
ibmipxidpInReceives = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 12, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmipxidpInReceives.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipxidpInReceives.setDescription('Total number of IDP datagrams received.')
ibmipxidpBcastInReceives = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 12, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmipxidpBcastInReceives.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipxidpBcastInReceives.setDescription('Number of IDP broadcast datagrams received.')
ibmipxidpInDiscards = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 12, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmipxidpInDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipxidpInDiscards.setDescription('Number of incoming IDP datagrams discarded due to lack of resources.')
ibmipxidpInAddrErrors = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 12, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmipxidpInAddrErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipxidpInAddrErrors.setDescription('Number of incoming IDP datagrams discarded because the network portion of the address did not match the configured address for this host.')
ibmipxidpOutRequests = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 12, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmipxidpOutRequests.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipxidpOutRequests.setDescription('Number of IDP datagrams generated by local IDP user protocols. This counter does not include any datagrams counted in ibmipxidpForwDatagrams.')
ibmipxidpBcastOutRequests = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 12, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmipxidpBcastOutRequests.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipxidpBcastOutRequests.setDescription('Number of IDP broadcast datagrams generated by local IDP user protocols. This counter does not include any datagrams counted in ibmipxidpForwDatagrams.')
ibmipxidpForwDatagrams = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 12, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmipxidpForwDatagrams.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipxidpForwDatagrams.setDescription('Number of IDP datagrams for which an attempt was made to forward.')
ibmipxidpOutDiscards = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 12, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmipxidpOutDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipxidpOutDiscards.setDescription('Total number of outgoing IDP datagrams discarded.')
ibmipxidpOutNoRoutes = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 12, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmipxidpOutNoRoutes.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipxidpOutNoRoutes.setDescription('Number of outgoing IDP datagrams discarded because no route was available to the specified destination.')
ibmipxidpRoutingDiscards = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 12, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmipxidpRoutingDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipxidpRoutingDiscards.setDescription('Number of routing entries discarded even though they were valid.')
ibmipxidpZeroDirBcast = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 12, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmipxidpZeroDirBcast.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipxidpZeroDirBcast.setDescription('Number of IDP datagrams forwarded to the system due to zeronet broadcast.')
ibmipxidpTooSmall = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 12, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmipxidpTooSmall.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipxidpTooSmall.setDescription('Number of IDP datagrams with len < the size of an IDP header.')
ibmipxidpBadLen = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 12, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmipxidpBadLen.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipxidpBadLen.setDescription('Number of IDP datagrams with number of bytes in the packet less than the number of bytes specified in the IDP header field.')
ibmipxidpBadSum = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 12, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmipxidpBadSum.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipxidpBadSum.setDescription('Number of IDP datagrams with a bad checksum')
ibmipxidpBadTTL = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 12, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmipxidpBadTTL.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipxidpBadTTL.setDescription('Number of IDP datagrams with TTL value > IDP maximum hopcount of 16.')
ibmipxAddrTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 12, 34), )
if mibBuilder.loadTexts: ibmipxAddrTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipxAddrTable.setDescription('The IPX Address Table.')
ibmipxAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 12, 34, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmipxAddrAddress"))
if mibBuilder.loadTexts: ibmipxAddrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipxAddrEntry.setDescription('An entry in the IPX address table.')
ibmipxAddrAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 12, 34, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(12, 12)).setFixedLength(12)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmipxAddrAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipxAddrAddress.setDescription("The IPX address to which this entry's addressing information pertains.")
ibmipxAddrIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 12, 34, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmipxAddrIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipxAddrIfIndex.setDescription('The interface index which identifies the interface to which this entry is applicable.')
ibmipxRouteTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 12, 35), )
if mibBuilder.loadTexts: ibmipxRouteTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipxRouteTable.setDescription('The IPX Route Table.')
ibmipxRouteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 12, 35, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmipxRouteDest"))
if mibBuilder.loadTexts: ibmipxRouteEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipxRouteEntry.setDescription('An entry in the IPX route table.')
ibmipxRouteDest = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 12, 35, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(12, 12)).setFixedLength(12)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmipxRouteDest.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipxRouteDest.setDescription('The desination network of this route.')
ibmipxRouteIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 12, 35, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmipxRouteIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipxRouteIfIndex.setDescription('The index value which identifies the local interface through which the next hop of this route should be reached.')
ibmipxRouteNextHop = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 12, 35, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmipxRouteNextHop.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipxRouteNextHop.setDescription('The IPX network address of the next hop of this route.')
ibmipxRouteMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 12, 35, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmipxRouteMetric.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipxRouteMetric.setDescription('The hop count to the destination.')
ibmipxRouteUse = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 12, 35, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmipxRouteUse.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipxRouteUse.setDescription('Reference counter for this route.')
ibmipxFilterTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 12, 36), )
if mibBuilder.loadTexts: ibmipxFilterTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipxFilterTable.setDescription('The IPX Filter Table.')
ibmipxFilterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 12, 36, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmipxFilterIfIndex"), (0, "IBM6611-MIB", "ibmipxFilterNumber"))
if mibBuilder.loadTexts: ibmipxFilterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipxFilterEntry.setDescription('An entry in the IPX filter table.')
ibmipxFilterIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 12, 36, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmipxFilterIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipxFilterIfIndex.setDescription('The value of this object identifies the interface for which this entry contains management information. The value of this object for a particular interface has the same value as the ifIndex object for the same interface.')
ibmipxFilterNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 12, 36, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmipxFilterNumber.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipxFilterNumber.setDescription('A unique integer identifying this filter entry for this interface.')
ibmipxFilterValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 12, 36, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(30, 30)).setFixedLength(30)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmipxFilterValue.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipxFilterValue.setDescription('An octet string representing the IDP header information required by this filter entry. Incoming IDP packets will be bitwise ANDed with the value of ibmipxFilterMask, and if the result is equal to the value of this object, the packet will be filtered according to the value of ibmipxFilterType. The structure of an IDP header is as follows: BIT16 checksum BIT16 length BIT8 transport control (ie. hop count) BIT8 packet type BIT32 destination network address BIT48 destination host address BIT16 destination socket BIT32 source network address BIT48 source host address BIT16 source socket ')
ibmipxFilterMask = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 12, 36, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(30, 30)).setFixedLength(30)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmipxFilterMask.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipxFilterMask.setDescription('An octet string indicating the parts of the IDP header relevant to this filter entry. This mask will be bitwise ANDed with the IDP packet; if the result is equal to the value of ibmipxFilterValue, the packet will be filtered according to the value of ibmipxFilterType.')
ibmipxFilterType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 12, 36, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("deny", 1), ("permit", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmipxFilterType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipxFilterType.setDescription('Determines whether this filter is a deny entry or a permit entry.')
ibmipxFilterHCCompare = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 12, 36, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("none", 1), ("less-than", 2), ("less-than-equal", 3), ("equal", 4), ("greater-than-equal", 5), ("greater-than", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmipxFilterHCCompare.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipxFilterHCCompare.setDescription('Indicates the relational association desired if filtering is being done based on hop count. If filtering is not being done based on hop count (that is, if the hop count portion of ibmipxFilterMask is 0) the value of this object will be none(1).')
ibmipxFilterUse = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 12, 36, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmipxFilterUse.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipxFilterUse.setDescription('Usage count for this filter entry.')
ibmipxsapStatInRequests = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 12, 37), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmipxsapStatInRequests.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipxsapStatInRequests.setDescription('Number of SAP requests received by this entity.')
ibmipxsapStatOutRequests = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 12, 38), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmipxsapStatOutRequests.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipxsapStatOutRequests.setDescription('Number of SAP requests sent by this entity.')
ibmipxsapStatInResponses = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 12, 39), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmipxsapStatInResponses.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipxsapStatInResponses.setDescription('Number of SAP responses received by this entity.')
ibmipxsapStatOutResponses = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 12, 40), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmipxsapStatOutResponses.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipxsapStatOutResponses.setDescription('Number of SAP responses sent by this entity.')
ibmipxsapStatInErrors = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 12, 41), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmipxsapStatInErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipxsapStatInErrors.setDescription('Number of incoming SAP packets discarded due to errors.')
ibmipxsapStatOutDiscards = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 12, 42), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmipxsapStatOutDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipxsapStatOutDiscards.setDescription('Number of outgoing SAP packets discarded due to lack of resources.')
ibmipxsapServerTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 12, 43), )
if mibBuilder.loadTexts: ibmipxsapServerTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipxsapServerTable.setDescription('Table of IPX servers.')
ibmipxsapServerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 12, 43, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmipxsapServerType"), (0, "IBM6611-MIB", "ibmipxsapServerNet"), (0, "IBM6611-MIB", "ibmipxsapServerHost"), (0, "IBM6611-MIB", "ibmipxsapServerSocket"), (0, "IBM6611-MIB", "ibmipxsapServerIndex"))
if mibBuilder.loadTexts: ibmipxsapServerEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipxsapServerEntry.setDescription('Information on a single server.')
ibmipxsapServerType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 12, 43, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmipxsapServerType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipxsapServerType.setDescription('The type of this server.')
ibmipxsapServerNet = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 12, 43, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmipxsapServerNet.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipxsapServerNet.setDescription('The IPX network number of this server.')
ibmipxsapServerHost = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 12, 43, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmipxsapServerHost.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipxsapServerHost.setDescription('The IPX host address of this server.')
ibmipxsapServerSocket = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 12, 43, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmipxsapServerSocket.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipxsapServerSocket.setDescription('The IPX socket number this server uses to advertise its service.')
ibmipxsapServerName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 12, 43, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmipxsapServerName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipxsapServerName.setDescription('The name of this server.')
ibmipxsapServerAge = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 12, 43, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmipxsapServerAge.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipxsapServerAge.setDescription('The number of seconds since this server entry was updated by the SAP protocol.')
ibmipxsapServerHops = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 12, 43, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmipxsapServerHops.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipxsapServerHops.setDescription('The number of network hops required to reach this server.')
ibmipxsapServerIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 12, 43, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmipxsapServerIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipxsapServerIfIndex.setDescription('The interface which is used to reach this server. The value of this object for a particular interface has the same value as the ifIndex object for the same interface.')
ibmipxsapServerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 12, 43, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmipxsapServerIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipxsapServerIndex.setDescription('A unique number identifying servers advertised at the same IPX network and host address.')
ibmipxsapServerRequestsFiltered = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 12, 43, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmipxsapServerRequestsFiltered.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipxsapServerRequestsFiltered.setDescription('Number of times a request for this server has been filtered.')
cylink = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 3, 1))
cylinkStatusTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 3, 1, 1), )
if mibBuilder.loadTexts: cylinkStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: cylinkStatusTable.setDescription('The cylink Status table. This table contains information about the current state of the Cylink CSUs attached to the system.')
cylinkStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 3, 1, 1, 1), ).setIndexNames((0, "IBM6611-MIB", "cylinkIndex"))
if mibBuilder.loadTexts: cylinkStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cylinkStatusEntry.setDescription('An entry in the cylink Status table.')
cylinkIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 3, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cylinkIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cylinkIndex.setDescription('An index value that uniquely identifies a cylink system interface. The interface identified by a particular value of this index is the same interface as identified by the same value in an ifIndex object instance.')
cylinkLinkState = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 3, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("cylinkNotConnected", 1), ("cylinkNoInput", 2), ("cylinkNoOutput", 3), ("cylinkConnected", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cylinkLinkState.setStatus('mandatory')
if mibBuilder.loadTexts: cylinkLinkState.setDescription('The current state of the link. The meanings of the values are: cylinkNotConnected(1) The link is not physically connected to the CSU. This may be due to loss of input circuit or loss of output circuit. cylinkNoInput(2) The input circuit is not connected. cylinkNoOutput(3) The output circuit is not connected. cylinkConnected(4) The link is connected to the CSU.')
cylinkLoopback = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 3, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("cylinkNoLoopback", 1), ("cylinkNearEndLoopback", 2), ("cylinkFarEndLoopback", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cylinkLoopback.setStatus('mandatory')
if mibBuilder.loadTexts: cylinkLoopback.setDescription('The loopback mode of the link. The meaning of values are: cylinkNoLoopback(1) The link is not in loopback mode. cylinkNearEndLoopback(2) The link has been placed in loopback mode at the near end: data is being looped back within the local CSU. cylinkFarEndLoopback(3) The link has been placed in loopback mode at the far end: data is being looped across the link to the remote CSU and back.')
cylinkQRSS = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 3, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("cylinkNoQRSS", 1), ("cylinkQRSSMaster", 2), ("cylinkQRSSSlave", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cylinkQRSS.setStatus('mandatory')
if mibBuilder.loadTexts: cylinkQRSS.setDescription('The Quasi-Random Signal Sequence test mode of the CSU. The value of the meanings are: cylinkNoQRSS(1) The CSU is not in QRSS mode. cylinkQRSSMaster(2) The CSU is transmitting a QRSS test pattern. cylinkQRSSSlave(3) The CSU is receiving a QRSS test pattern.')
cylinkConfigTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 3, 1, 3), )
if mibBuilder.loadTexts: cylinkConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: cylinkConfigTable.setDescription('The cylink Configuration table. This table contains information about the configuration of the Cylink CSUs attached to the system.')
cylinkConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 3, 1, 3, 1), ).setIndexNames((0, "IBM6611-MIB", "cylinkConfigIndex"))
if mibBuilder.loadTexts: cylinkConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cylinkConfigEntry.setDescription('An entry in the cylink Configuration table.')
cylinkConfigIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 3, 1, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cylinkConfigIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cylinkConfigIndex.setDescription('The index value which uniquely identifies the CSU to which this entry is applicable. The CSU identified by a particular value of this index is the same CSU as identified by the same value in a cylinkIndex object instance.')
cylinkSerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 3, 1, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cylinkSerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cylinkSerialNumber.setDescription("The manufacturer's serial number of this CSU.")
cylinkSoftwareVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 3, 1, 3, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cylinkSoftwareVersion.setStatus('mandatory')
if mibBuilder.loadTexts: cylinkSoftwareVersion.setDescription('The version number of the microcode running in the CSU.')
cylinkDTEFraming = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 3, 1, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("cylinkDTEFramingD4", 1), ("cylinkDTEFramingESF", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cylinkDTEFraming.setStatus('mandatory')
if mibBuilder.loadTexts: cylinkDTEFraming.setDescription('The DTE framing selected (D4, or ESF). Framing conversion is automatically performed at both ends if the DTE is D4 framed and the network interface is ESF framed.')
cylinkNetworkFraming = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 3, 1, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("cylinkNetworkFramingD4", 1), ("cylinkNetworkFramingESF", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cylinkNetworkFraming.setStatus('mandatory')
if mibBuilder.loadTexts: cylinkNetworkFraming.setDescription('The network framing selected (D4, or ESF). Framing conversion is automatically performed at both ends if the DTE is D4 framed and the network interface is ESF framed.')
cylinkDTEDS1Mode = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 3, 1, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("cylinkDTEDS1ModeB8ZS", 1), ("cylinkDTEDS1ModeAMI", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cylinkDTEDS1Mode.setStatus('mandatory')
if mibBuilder.loadTexts: cylinkDTEDS1Mode.setDescription('The DTE DS-1 mode selected (B8ZS, or AMI).')
cylinkNetworkDS1Mode = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 3, 1, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("cylinkNetworkDS1ModeB8ZS", 1), ("cylinkNetworkDS1ModeAMI", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cylinkNetworkDS1Mode.setStatus('mandatory')
if mibBuilder.loadTexts: cylinkNetworkDS1Mode.setDescription('The network DS-1 mode selected (B8ZS, or AMI).')
cylinkOnesResponsibility = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 3, 1, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("cylinkOnesResponsibilityDTE", 1), ("cylinkOnesResponsibilityACSU", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cylinkOnesResponsibility.setStatus('mandatory')
if mibBuilder.loadTexts: cylinkOnesResponsibility.setDescription('The component selected for Ones Density Responsibility (DTE, or CSU.')
cylinkOnesControl = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 3, 1, 3, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("cylinkOnesControlLSB24", 1), ("cylinkOnesControlD4FRM", 2), ("cylinkOnesControlESFDL", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cylinkOnesControl.setStatus('mandatory')
if mibBuilder.loadTexts: cylinkOnesControl.setDescription('The Ones Density Control selected (LSB 24, D4 FRM, or ESF DL).')
cylinkZeroProtection = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 3, 1, 3, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("cylinkZeroProtection80", 1), ("cylinkZeroProtection15", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cylinkZeroProtection.setStatus('mandatory')
if mibBuilder.loadTexts: cylinkZeroProtection.setDescription('The Consecutive Zero Control selected (15, or 80). This determines the the maximum number of consecutive zeros allowed in the data stream before a one is forced.')
cylinkClockSource = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 3, 1, 3, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("cylinkClockSourceNetwork", 1), ("cylinkClockSourceDTE", 2), ("cylinkClockSourceExternal", 3), ("cylinkClockSourceInternal", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cylinkClockSource.setStatus('mandatory')
if mibBuilder.loadTexts: cylinkClockSource.setDescription("The transmit clock source selected for NRZ DIUs (network, DTE, an external clock, or the CSU's internal clock).")
cylinkClockFrequency = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 3, 1, 3, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("cylinkClockFreq-56kHz", 1), ("cylinkClockFreq-256kHz", 2), ("cylinkClockFreq-1-344MHz", 3), ("cylinkClockFreq-1-544MHz", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cylinkClockFrequency.setStatus('mandatory')
if mibBuilder.loadTexts: cylinkClockFrequency.setDescription('The external clock frequency selected (56 kHz, 256 kHz, 1.344 MHz, 1.544 MHz).')
cylinkClockBackup = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 3, 1, 3, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("cylinkClockBackupNetwork", 1), ("cylinkClockBackupDTE", 2), ("cylinkClockBackupExternal", 3), ("cylinkClockBackupInternal", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cylinkClockBackup.setStatus('mandatory')
if mibBuilder.loadTexts: cylinkClockBackup.setDescription("The transmit clock backup source selected for NRZ DIUs (network, DTE, an external clock, or the CSU's internal clock).")
cylinkDIUFrequency = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 3, 1, 3, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("cylinkDIUFreq-768kbps", 1), ("cylinkDIUFreq-1-344Mbps", 2), ("cylinkDIUFreq-1-528Mbps", 3), ("cylinkDIUFreq-1-536Mbps", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cylinkDIUFrequency.setStatus('mandatory')
if mibBuilder.loadTexts: cylinkDIUFrequency.setDescription('The DIU frequency selected for NRZ DIUs (767 kbps, 1.244 Mbps, 1.528 Mbps, 1.536 Mbps).')
cylinkDIUTiming = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 3, 1, 3, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("cylinkDIUTimingTT", 1), ("cylinkDIUTimingST", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cylinkDIUTiming.setStatus('mandatory')
if mibBuilder.loadTexts: cylinkDIUTiming.setDescription('The DIU transmit timing selected for NRZ DIUs (Send Timing, or Terminal Timing).')
cylinkDialoutCapability = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 3, 1, 3, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("cylinkDialoutCapabilityPolled", 1), ("cylinkDialoutCapabilityTone", 2), ("cylinkDialoutCapabilityPulse", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cylinkDialoutCapability.setStatus('mandatory')
if mibBuilder.loadTexts: cylinkDialoutCapability.setDescription('The DIU dial-out capability selected (polled, tone, or pulse).')
cylinkDialoutHoldoff = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 3, 1, 3, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 99))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cylinkDialoutHoldoff.setStatus('mandatory')
if mibBuilder.loadTexts: cylinkDialoutHoldoff.setDescription('The mininum time, in minutes, between successful CSU-to-NMS connections to report alarm conditions.')
cylinkPrimaryPhone = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 3, 1, 3, 1, 18), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 19))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cylinkPrimaryPhone.setStatus('mandatory')
if mibBuilder.loadTexts: cylinkPrimaryPhone.setDescription('The primary telephone number used by by the CSU to contact the NMS.')
cylinkSecondaryPhone = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 3, 1, 3, 1, 19), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 19))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cylinkSecondaryPhone.setStatus('mandatory')
if mibBuilder.loadTexts: cylinkSecondaryPhone.setDescription('The secondary telephone number used by by the CSU to contact the NMS.')
cylinkAlarmRepeatTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 3, 1, 3, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 99))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cylinkAlarmRepeatTime.setStatus('mandatory')
if mibBuilder.loadTexts: cylinkAlarmRepeatTime.setDescription('The interval, in minutes, that the CSU will insert duplicate messages in the alarm queue for persistant alarm conditions.')
cylinkESThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 3, 1, 3, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 99))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cylinkESThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: cylinkESThreshold.setDescription('The threshold, in seconds, for the errored second value in the current 15-minute interval.')
cylinkSecondaryContact = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 3, 1, 3, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("cylinkSecondaryContactOpen", 1), ("cylinkSecondaryContactClosed", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cylinkSecondaryContact.setStatus('mandatory')
if mibBuilder.loadTexts: cylinkSecondaryContact.setDescription('The state of the CSU secondary contact (open or closed).')
ibmdot1dBase = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 1))
ibmdot1dStp = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 2))
ibmdot1dTp = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 3))
ibmdot1dStatic = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 4))
ibmtbMACAddressFilters = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 5))
ibmtbSAPFilters = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 6))
ibmtbEthTypeFilters = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 7))
ibmtbWindowFilters = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 8))
ibmtbFiltOrderTable = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 9))
ibmdot1dBaseBridgeAddress = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdot1dBaseBridgeAddress.setReference('P802.1d/D9, July 14, 1989: Sections 6.4.1.1.3 and 3.12.5')
if mibBuilder.loadTexts: ibmdot1dBaseBridgeAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdot1dBaseBridgeAddress.setDescription('The MAC address used by this bridge when it must be referred to in a unique fashion. It is recommended that this be the numerically smallest MAC address of all ports that belong to this bridge. However it is only required to be unique. When concatenated with ibmdot1dStpPriority a unique BridgeIdentifier is formed which is used in the Spanning Tree Protocol.')
ibmdot1dBaseNumPorts = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdot1dBaseNumPorts.setReference('P802.1d/D9, July 14, 1989: Section 6.4.1.1.3')
if mibBuilder.loadTexts: ibmdot1dBaseNumPorts.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdot1dBaseNumPorts.setDescription('The number of TB ports controlled by this bridging entity.')
ibmdot1dBaseType = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("transparent-only", 2), ("sourceroute-only", 3), ("srt", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdot1dBaseType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdot1dBaseType.setDescription('Indicates what type of bridging this bridge can perform. If a bridge is actually performing a certain type of bridging this will be indicated by entries in the port table for the given type.')
ibmdot1dBasePortTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 1, 4), )
if mibBuilder.loadTexts: ibmdot1dBasePortTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdot1dBasePortTable.setDescription('A table that contains generic information about every port that is associated with this bridge.')
ibmdot1dBasePortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 1, 4, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmdot1dBasePort"))
if mibBuilder.loadTexts: ibmdot1dBasePortEntry.setReference('P802.1d/D9, July 14, 1989: Section 6.4.2, 6.6.1')
if mibBuilder.loadTexts: ibmdot1dBasePortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdot1dBasePortEntry.setDescription('A list of information for each port of the bridge.')
ibmdot1dBasePort = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 1, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdot1dBasePort.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdot1dBasePort.setDescription('The port number of the port for which this entry contains bridge management information.')
ibmdot1dBasePortIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 1, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdot1dBasePortIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdot1dBasePortIfIndex.setDescription('The value of the instance of the ifIndex object, defined in RFC 1156, RFC 1213 for the interface corresponding to this port.')
ibmdot1dBasePortCircuit = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 1, 4, 1, 3), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdot1dBasePortCircuit.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdot1dBasePortCircuit.setDescription("For a port which potentially has the same value of ibmdot1dBasePortIfIndex as another port on the same bridge, this object contains an identifier unique to this port. For example, in the case where multiple ports correspond one-to-one with multiple Frame Relay circuit's, this value provides the object identifier for the frame relay MIB. Fpr a port which has a unique value of ibmdot1dBasePortIfIndex, this object can have the value {0.0}.")
ibmdot1dBasePortDelayExceededDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 1, 4, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdot1dBasePortDelayExceededDiscards.setReference('P802.1d/D9, July 14, 1989: Section 6.6.1.1.3')
if mibBuilder.loadTexts: ibmdot1dBasePortDelayExceededDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdot1dBasePortDelayExceededDiscards.setDescription('The number of frames discarded by this port due to excessive transit delay through the bridge.')
ibmdot1dBasePortMtuExceededDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 1, 4, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdot1dBasePortMtuExceededDiscards.setReference('P802.1d/D9, July 14, 1989: Section 6.6.1.1.3')
if mibBuilder.loadTexts: ibmdot1dBasePortMtuExceededDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdot1dBasePortMtuExceededDiscards.setDescription('The number of frames discarded by this port due to an excessive size.')
ibmdot1dStpProtocolSpecification = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("decLb100", 2), ("ieee8021d", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdot1dStpProtocolSpecification.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdot1dStpProtocolSpecification.setDescription("An indication of what version of the Spanning Tree Protocol is being run. The value 'decLb100(2)' indicates the DEC LANbridge 100 Spanning Tree protocol. IEEE 802.1d implementations will return 'ieee8021d(3)'. If future versions of the IEEE Spanning Tree Protocol are released that are incompatible with the current version a new value will be defined.")
ibmdot1dStpPriority = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 2, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmdot1dStpPriority.setReference('P802.1d/D9, July 14, 1989: Section 4.5.3.7')
if mibBuilder.loadTexts: ibmdot1dStpPriority.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdot1dStpPriority.setDescription('The value of the write-able portion of the Bridge ID, i.e., the first two octets of the (8 octet long) Bridge ID. The other (last) 6 octets of the Bridge ID are given by the value of ibmdot1dBaseBridgeAddress.')
ibmdot1dStpTimeSinceTopologyChange = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 2, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdot1dStpTimeSinceTopologyChange.setReference('P802.1d/D9, July 14, 1989: Section 6.8.1.1.3')
if mibBuilder.loadTexts: ibmdot1dStpTimeSinceTopologyChange.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdot1dStpTimeSinceTopologyChange.setDescription('The time (in hundredths of a second) since the last time a topology change was detected by the bridge entity.')
ibmdot1dStpTopChanges = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 2, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdot1dStpTopChanges.setReference('P802.1d/D9, July 14, 1989: Section 6.8.1.1.3')
if mibBuilder.loadTexts: ibmdot1dStpTopChanges.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdot1dStpTopChanges.setDescription('The total number of topology changes detected by this bridge since the management entity was last reset or initialized.')
ibmdot1dStpDesignatedRoot = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 2, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdot1dStpDesignatedRoot.setReference('P802.1d/D9, July 14, 1989: Section 4.5.3.1')
if mibBuilder.loadTexts: ibmdot1dStpDesignatedRoot.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdot1dStpDesignatedRoot.setDescription('The bridge identifier of the root of the spanning tree as determined by the Spanning Tree Protocol as executed by this node. This value is used as the Root Identifier parameter in all Configuration Bridge PDUs originated by this node.')
ibmdot1dStpRootCost = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 2, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdot1dStpRootCost.setReference('P802.1d/D9, July 14, 1989: Section 4.5.3.2')
if mibBuilder.loadTexts: ibmdot1dStpRootCost.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdot1dStpRootCost.setDescription('The cost of the path to the root as seen from this bridge.')
ibmdot1dStpRootPort = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 2, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdot1dStpRootPort.setReference('P802.1d/D9, July 14, 1989: Section 4.5.3.3')
if mibBuilder.loadTexts: ibmdot1dStpRootPort.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdot1dStpRootPort.setDescription('The port number of the port which offers the lowest cost path from this bridge to the root bridge.')
ibmdot1dStpMaxAge = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 2, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdot1dStpMaxAge.setReference('P802.1d/D9, July 14, 1989: Section 4.5.3.4')
if mibBuilder.loadTexts: ibmdot1dStpMaxAge.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdot1dStpMaxAge.setDescription('The maximum age of Spanning Tree Protocol information learned from the network on any port before it is discarded, in units of hundredths of a second. This is the actual value that this bridge is currently using.')
ibmdot1dStpHelloTime = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 2, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdot1dStpHelloTime.setReference('P802.1d/D9, July 14, 1989: Section 4.5.3.5')
if mibBuilder.loadTexts: ibmdot1dStpHelloTime.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdot1dStpHelloTime.setDescription('The amount of time between the transmission of Configuration bridge PDUs by this node on any port when it is the root of the spanning tree or trying to become so, in units of hundredths of a second. This is the actual value that this bridge is currently using.')
ibmdot1dStpHoldTime = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 2, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdot1dStpHoldTime.setReference('P802.1d/D9, July 14, 1989: Section 4.5.3.14')
if mibBuilder.loadTexts: ibmdot1dStpHoldTime.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdot1dStpHoldTime.setDescription('This time value determines the interval length during which no more than two Configuration bridge PDUs shall be transmitted by this node, in units of hundredths of a second.')
ibmdot1dStpForwardDelay = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 2, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdot1dStpForwardDelay.setReference('P802.1d/D9, July 14, 1989: Section 4.5.3.6')
if mibBuilder.loadTexts: ibmdot1dStpForwardDelay.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdot1dStpForwardDelay.setDescription('This time value, measured in units of hundredths of a second, controls how fast a port changes its spanning state when moving towards the Forwarding state. The value determines how long the port stays in a particular state before moving to the next state. For example, how long a port stays in the Listening state when moving from Blocking to Learning. This value is also used, when a topology change has been detected and is underway, to age all dynamic entries in the Forwarding Database. (Note that this value is the one that this bridge is currently using, in contrast to ibmdot1dStpBridgeForwardDelay which is the value that this bridge and all others would start using if/when this bridge were to become the root.)')
ibmdot1dStpBridgeMaxAge = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 2, 12), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmdot1dStpBridgeMaxAge.setReference('P802.1d/D9, July 14, 1989: Section 4.5.3.8')
if mibBuilder.loadTexts: ibmdot1dStpBridgeMaxAge.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdot1dStpBridgeMaxAge.setDescription("The value that all bridges use for MaxAge when this bridge is acting as the root. Note that 802.1d/D9 specifies that the range for this parameter is related to the value of ibmdot1dStpBridgeHelloTime. The granularity of this timer is specified by 802.1d/D9 to be 1 second. An agent may return a badValue error if a set is attempted to a value which is not a whole number of seconds. The IBM 6611 Network Processor obtains this value from the 'Max Age' parameter provided to the configuration program.")
ibmdot1dStpBridgeHelloTime = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 2, 13), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmdot1dStpBridgeHelloTime.setReference('P802.1d/D9, July 14, 1989: Section 4.5.3.9')
if mibBuilder.loadTexts: ibmdot1dStpBridgeHelloTime.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdot1dStpBridgeHelloTime.setDescription("The value that all bridges use for HelloTime when this bridge is acting as the root. The granularity of this timer is specified by 802.1d/D9 to be 1 second. An agent may return a badValue error if a set is attempted to a value which is not a whole number of seconds. The IBM 6611 Network Processor obtains this value from the 'Hello Time' parameter provided to the configuration program.")
ibmdot1dStpBridgeForwardDelay = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 2, 14), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmdot1dStpBridgeForwardDelay.setReference('P802.1d/D9, July 14, 1989: Section 4.5.3.10')
if mibBuilder.loadTexts: ibmdot1dStpBridgeForwardDelay.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdot1dStpBridgeForwardDelay.setDescription("The value that all bridges use for ForwardDelay when this bridge is acting as the root. Note that 802.1d/D9 specifies that the range for this parameter is related to the value of ibmdot1dStpBridgeMaxAge. The granularity of this timer is specified by 802.1d/D9 to be 1 second. An agent may return a badValue error if a set is attempted to a value which is not a whole number of seconds. The IBM 6611 Network Processor obtains this value from the 'Forward Delay Time' parameter provided to the configuration program.")
ibmdot1dStpPortTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 2, 15), )
if mibBuilder.loadTexts: ibmdot1dStpPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdot1dStpPortTable.setDescription('A table that contains port-specific information for the Spanning Tree Protocol.')
ibmdot1dStpPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 2, 15, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmdot1dStpPort"))
if mibBuilder.loadTexts: ibmdot1dStpPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdot1dStpPortEntry.setDescription('A list of information maintained by every port about the Spanning Tree Protocol state for that port.')
ibmdot1dStpPort = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 2, 15, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdot1dStpPort.setReference('P802.1d/D9, July 14, 1989: Section 6.8.2.1.2')
if mibBuilder.loadTexts: ibmdot1dStpPort.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdot1dStpPort.setDescription('The port number of the port for which this entry contains Spanning Tree Protocol management information. This port number is the same as that reported by ibmdot1dBasePort.')
ibmdot1dStpPortPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 2, 15, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmdot1dStpPortPriority.setReference('P802.1d/D9, July 14, 1989: Section 4.5.5.1')
if mibBuilder.loadTexts: ibmdot1dStpPortPriority.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdot1dStpPortPriority.setDescription('The value of the priority field which is contained in the first (in network byte order) octet of the (2 octet long) Port ID. The other octet of the Port ID is given by the value of ibmdot1dStpPort.')
ibmdot1dStpPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 2, 15, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("disabled", 1), ("blocking", 2), ("listening", 3), ("learning", 4), ("forwarding", 5), ("broken", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdot1dStpPortState.setReference('P802.1d/D9, July 14, 1989: Section 4.5.5.2')
if mibBuilder.loadTexts: ibmdot1dStpPortState.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdot1dStpPortState.setDescription("The port's current state as defined by application of the Spanning Tree Protocol. This state controls what action a port takes on reception of a frame. If the bridge has detected a port that is malfunctioning it will place that port into the broken(6) state. For ports which are disabled (see ibmdot1dStpPortEnable), this object will have a value of disabled(1).")
ibmdot1dStpPortEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 2, 15, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmdot1dStpPortEnable.setReference('P802.1d/D9, July 14, 1989: Section 4.5.5.2')
if mibBuilder.loadTexts: ibmdot1dStpPortEnable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdot1dStpPortEnable.setDescription('The enabled/disabled status of the port.')
ibmdot1dStpPortPathCost = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 2, 15, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmdot1dStpPortPathCost.setReference('P802.1d/D9, July 14, 1989: Section 4.5.5.3')
if mibBuilder.loadTexts: ibmdot1dStpPortPathCost.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdot1dStpPortPathCost.setDescription("The contribution of this port to the path cost of paths towards the spanning tree root which include this port. The IBM 6611 Network Processor obtains this value from the 'Path Cost' parameter provided to the configuration program.")
ibmdot1dStpPortDesignatedRoot = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 2, 15, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdot1dStpPortDesignatedRoot.setReference('P802.1d/D9, July 14, 1989: Section 4.5.5.4')
if mibBuilder.loadTexts: ibmdot1dStpPortDesignatedRoot.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdot1dStpPortDesignatedRoot.setDescription('The unique Bridge Identifier of the Bridge recorded as the Root in the Configuration BPDUs transmitted by the Designated Bridge for the segment to which the port is attached.')
ibmdot1dStpPortDesignatedCost = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 2, 15, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdot1dStpPortDesignatedCost.setReference('P802.1d/D9, July 14, 1989: Section 4.5.5.5')
if mibBuilder.loadTexts: ibmdot1dStpPortDesignatedCost.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdot1dStpPortDesignatedCost.setDescription('The path cost of the Designated Port of the segment connected to this port. This value is compared to the Root Path Cost field in received bridge PDUs.')
ibmdot1dStpPortDesignatedBridge = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 2, 15, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdot1dStpPortDesignatedBridge.setReference('P802.1d/D9, July 14, 1989: Section 4.5.5.6')
if mibBuilder.loadTexts: ibmdot1dStpPortDesignatedBridge.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdot1dStpPortDesignatedBridge.setDescription("The Bridge Identifier of the bridge which this port considers to be the Designated Bridge for this port's segment.")
ibmdot1dStpPortDesignatedPort = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 2, 15, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdot1dStpPortDesignatedPort.setReference('P802.1d/D9, July 14, 1989: Section 4.5.5.7')
if mibBuilder.loadTexts: ibmdot1dStpPortDesignatedPort.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdot1dStpPortDesignatedPort.setDescription("The Port Identifier of the port on the Designated Bridge for this port's segment.")
ibmdot1dStpPortForwardTransitions = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 2, 15, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdot1dStpPortForwardTransitions.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdot1dStpPortForwardTransitions.setDescription('The number of times this port has transitioned from the Learning state to the Forwarding state.')
ibmdot1dTpLearnedEntryDiscards = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 3, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdot1dTpLearnedEntryDiscards.setReference('P802.1d/D9, July 14, 1989: Section 6.7.1.1.3')
if mibBuilder.loadTexts: ibmdot1dTpLearnedEntryDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdot1dTpLearnedEntryDiscards.setDescription('The total number of Forwarding Database entries, which have been or would have been learnt, but have been discarded due to a lack of space to store them in the Forwarding Database. If this counter is increasing, it indicates that the Forwarding Database is regularly becoming full (a condition which has unpleasant performance effects on the subnetwork). If this counter has a significant value but is not presently increasing, it indicates that the problem has been occurring but is not persistent.')
ibmdot1dTpAgingTime = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 3, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmdot1dTpAgingTime.setReference('P802.1d/D9, July 14, 1989: Section 6.7.1.1.3')
if mibBuilder.loadTexts: ibmdot1dTpAgingTime.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdot1dTpAgingTime.setDescription("The timeout period in seconds for aging out dynamically learned forwarding information. The IBM 6611 Network Processor obtains this value from the 'Aging Time' parameter provided to the configuration program.")
ibmdot1dTpFdbTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 3, 3), )
if mibBuilder.loadTexts: ibmdot1dTpFdbTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdot1dTpFdbTable.setDescription('A table that contains information about unicast entries for which the bridge has forwarding and/or filtering information. This information is used by the transparent bridging function in determining how to propagate a received frame.')
ibmdot1dTpFdbEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 3, 3, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmdot1dTpFdbAddress"))
if mibBuilder.loadTexts: ibmdot1dTpFdbEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdot1dTpFdbEntry.setDescription('Information about a specific unicast MAC address for which the bridge has some forwarding and/or filtering information.')
ibmdot1dTpFdbAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 3, 3, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdot1dTpFdbAddress.setReference('P802.1d/D9, July 14, 1989: Section 3.9.1, 3.9.2')
if mibBuilder.loadTexts: ibmdot1dTpFdbAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdot1dTpFdbAddress.setDescription('A unicast MAC address for which the bridge has forwarding and/or filtering information.')
ibmdot1dTpFdbPort = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 3, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdot1dTpFdbPort.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdot1dTpFdbPort.setDescription("Either the value '0', or the port number of the port on which a frame having a source address equal to the value of the corresponding instance of ibmdot1dTpFdbAddress has been seen. A value of '0' indicates that the port number has not been learned but that the bridge does have some forwarding/filtering information about this address (e.g. in the ibmdot1dStaticTable). Implementors are encouraged to assign the port value to this object whenever it is learned even for addresses for which the corresponding value of ibmdot1dTpFdbStatus is not learned(3).")
ibmdot1dTpFdbStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 3, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("invalid", 2), ("learned", 3), ("self", 4), ("mgmt", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdot1dTpFdbStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdot1dTpFdbStatus.setDescription("The status of this entry. The meanings of the values are: other(1) : none of the following. This would include the case where some other MIB object (not the corresponding instance of ibmdot1dTpFdbPort, nor an entry in the ibmdot1dStaticTable) is being used to determine if and how frames addressed to the value of the corresponding instance of ibmdot1dTpFdbAddress are being forwarded. invalid(2) : this entry is not longer valid (e.g., it was learned but has since aged-out), but has not yet been flushed from the table. learned(3) : the value of the corresponding instance of ibmdot1dTpFdbPort was learned, and is being used. self(4) : the value of the corresponding instance of ibmdot1dTpFdbAddress represents one of the bridge's addresses. The corresponding instance of ibmdot1dTpFdbPort indicates which of the bridge's ports has this address. mgmt(5) : the value of the corresponding instance of ibmdot1dTpFdbAddress is also the value of an existing instance of ibmdot1dStaticAddress.")
ibmdot1dTpPortTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 3, 4), )
if mibBuilder.loadTexts: ibmdot1dTpPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdot1dTpPortTable.setDescription('A table that contains information about every port that is associated with this transparent bridge.')
ibmdot1dTpPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 3, 4, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmdot1dTpPort"))
if mibBuilder.loadTexts: ibmdot1dTpPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdot1dTpPortEntry.setDescription('A list of information for each port of a transparent bridge.')
ibmdot1dTpPort = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 3, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdot1dTpPort.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdot1dTpPort.setDescription('The port number of the port for which this entry contains Transparent bridging management information.')
ibmdot1dTpPortMaxInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 3, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdot1dTpPortMaxInfo.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdot1dTpPortMaxInfo.setDescription('The maximum size of the INFO (non-MAC) field that this port will receive or transmit.')
ibmdot1dTpPortInFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 3, 4, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdot1dTpPortInFrames.setReference('P802.1d/D9, July 14, 1989: Section 6.6.1.1.3')
if mibBuilder.loadTexts: ibmdot1dTpPortInFrames.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdot1dTpPortInFrames.setDescription('The number of frames that have been received by this port from its segment. Note that a frame received on the interface corresponding to this port is only counted by this object if and only if it is for a protocol being processed by the local bridging function.')
ibmdot1dTpPortOutFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 3, 4, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdot1dTpPortOutFrames.setReference('P802.1d/D9, July 14, 1989: Section 6.6.1.1.3')
if mibBuilder.loadTexts: ibmdot1dTpPortOutFrames.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdot1dTpPortOutFrames.setDescription('The number of frames that have been transmitted by this port to its segment. Note that a frame transmitted on the interface corresponding to this port is only counted by this object if and only if it is for a protocol being processed by the local bridging function.')
ibmdot1dTpPortInDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 3, 4, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdot1dTpPortInDiscards.setReference('P802.1d/D9, July 14, 1989: Section 6.6.1.1.3')
if mibBuilder.loadTexts: ibmdot1dTpPortInDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdot1dTpPortInDiscards.setDescription('Count of valid frames received which were discarded (i.e., filtered) by the Forwarding Process.')
ibmdot1dStaticTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 4, 1), )
if mibBuilder.loadTexts: ibmdot1dStaticTable.setReference('P802.1d/D9, July 14, 1989: Section 6.7.2')
if mibBuilder.loadTexts: ibmdot1dStaticTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdot1dStaticTable.setDescription('A table containing filtering information configured into the bridge by (local or network) management specifying the set of ports to which frames received from specific ports and containing specific destination addresses are allowed to be forwarded. The value of zero in this table as the port number from which frames with a specific destination address are received, is used to specify all ports for which there is no specific entry in this table for that particular destination address. Entries are valid for unicast and for group/broadcast addresses.')
ibmdot1dStaticEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 4, 1, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmdot1dStaticAddress"), (0, "IBM6611-MIB", "ibmdot1dStaticReceivePort"))
if mibBuilder.loadTexts: ibmdot1dStaticEntry.setReference('P802.1d/D9, July 14,1989: Section 6.7.2')
if mibBuilder.loadTexts: ibmdot1dStaticEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdot1dStaticEntry.setDescription('Filtering information configured into the bridge by (local or network) management specifying the set of ports to which frames received from a specific port and containing a specific destination address are allowed to be forwarded.')
ibmdot1dStaticAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 4, 1, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmdot1dStaticAddress.setReference('P802.1d/D9, July 14, 1989: Section 3.9.1, 3.9.2')
if mibBuilder.loadTexts: ibmdot1dStaticAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdot1dStaticAddress.setDescription("The destination MAC address in a frame to which this entry's filtering information applies. This object can take the value of a unicast address, a group address or the broadcast address.")
ibmdot1dStaticReceivePort = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 4, 1, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmdot1dStaticReceivePort.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdot1dStaticReceivePort.setDescription("Either the value '0', or the port number of the port from which a frame must be received in order for this entry's filtering information to apply. A value of zero indicates that this entry applies on all ports of the bridge for which there is no other applicable entry.")
ibmdot1dStaticAllowedToGoTo = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 4, 1, 1, 3), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmdot1dStaticAllowedToGoTo.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdot1dStaticAllowedToGoTo.setDescription("The set of ports to which frames received from a specific port and destined for a specific MAC address, are allowed to be forwarded. Each octet within the value of this object specifies a set of eight ports, with the first octet specifying ports 1 through 8, the second octet specifying ports 9 through 16, etc. Within each octet, the most significant bit represents the lowest numbered port, and the least significant bit represents the highest numbered port. Thus, each port of the bridge is represented by a single bit within the value of this object. If that bit has a value of '1' then that port is included in the set of ports; the port is not included if its bit has a value of '0'. (Note that the setting of the bit corresponding to the port from which a frame is received is irrelevant.)")
ibmdot1dStaticStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("invalid", 2), ("permanent", 3), ("deleteOnReset", 4), ("deleteOnTimeout", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmdot1dStaticStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdot1dStaticStatus.setDescription('This object indicates the status of this entry. other(1) - this entry is currently in use but the conditions under which it will remain so are different from each of the following values. invalid(2) - writing this value to the object removes the corresponding entry. permanent(3) - this entry is currently in use and will remain so after the next reset of the bridge. deleteOnReset(4) - this entry is currently in use and will remain so until the next reset of the bridge. deleteOnTimeout(5) - this entry is currently in use and will remain so until it is aged out.')
ibmtbmacFiltInfoTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 5, 1), )
if mibBuilder.loadTexts: ibmtbmacFiltInfoTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbmacFiltInfoTable.setDescription('Table of MAC address filtering information.')
ibmtbmacFiltInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 5, 1, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmtbmacFiltIfIndex"))
if mibBuilder.loadTexts: ibmtbmacFiltInfoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbmacFiltInfoEntry.setDescription('MAC address filtering information for a single interface.')
ibmtbmacFiltIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 5, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmtbmacFiltIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbmacFiltIfIndex.setDescription('The value of this object identifies the interface for which this entry contains management information. The value of this object for a particular interface has the same value as the ifIndex object for the same interface.')
ibmtbmacFiltInFilterType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("deny", 1), ("permit", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmtbmacFiltInFilterType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbmacFiltInFilterType.setDescription('For the incoming filter table, determines whether the entries are permit or deny entries.')
ibmtbmacFiltOutFilterType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 5, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("deny", 1), ("permit", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmtbmacFiltOutFilterType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbmacFiltOutFilterType.setDescription('For the outgoing filter table, determines whether the entries are permit or deny entries.')
ibmtbmacFiltInNotForwarded = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 5, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmtbmacFiltInNotForwarded.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbmacFiltInNotForwarded.setDescription('Number of packets not forwarded, in the incoming direction, because they were filtered out.')
ibmtbmacFiltOutNotForwarded = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 5, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmtbmacFiltOutNotForwarded.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbmacFiltOutNotForwarded.setDescription('Number of packets not forwarded, in the outgoing direction, because they were filtered out.')
ibmtbmacFiltInTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 5, 2), )
if mibBuilder.loadTexts: ibmtbmacFiltInTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbmacFiltInTable.setDescription('Table of MAC address filtering information for incoming frames.')
ibmtbmacFiltInEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 5, 2, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmtbmacFiltInIfIndex"), (0, "IBM6611-MIB", "ibmtbmacFiltInSrcAddress"), (0, "IBM6611-MIB", "ibmtbmacFiltInDestAddress"))
if mibBuilder.loadTexts: ibmtbmacFiltInEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbmacFiltInEntry.setDescription('Filtering information for incoming frames.')
ibmtbmacFiltInIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 5, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmtbmacFiltInIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbmacFiltInIfIndex.setDescription('The value of this object identifies the interface for which this entry contains management information. The value of this object for a particular interface has the same value as the ifIndex object for the same interface.')
ibmtbmacFiltInSrcAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 5, 2, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmtbmacFiltInSrcAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbmacFiltInSrcAddress.setDescription('MAC source address to be filtered.')
ibmtbmacFiltInSrcMask = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 5, 2, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmtbmacFiltInSrcMask.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbmacFiltInSrcMask.setDescription('Mask to allow ibmtbmacFiltInSrcAddress to be used as a range of values.')
ibmtbmacFiltInDestAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 5, 2, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmtbmacFiltInDestAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbmacFiltInDestAddress.setDescription('MAC destination address to be filtered.')
ibmtbmacFiltInDestMask = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 5, 2, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmtbmacFiltInDestMask.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbmacFiltInDestMask.setDescription('Mask to allow ibmtbmacFiltInDestAddress to be used as a range of values.')
ibmtbmacFiltOutTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 5, 3), )
if mibBuilder.loadTexts: ibmtbmacFiltOutTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbmacFiltOutTable.setDescription('Table of MAC address filtering information for outgoing frames.')
ibmtbmacFiltOutEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 5, 3, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmtbmacFiltOutIfIndex"), (0, "IBM6611-MIB", "ibmtbmacFiltOutSrcAddress"), (0, "IBM6611-MIB", "ibmtbmacFiltOutDestAddress"))
if mibBuilder.loadTexts: ibmtbmacFiltOutEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbmacFiltOutEntry.setDescription('Filtering information for outgoing frames.')
ibmtbmacFiltOutIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 5, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmtbmacFiltOutIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbmacFiltOutIfIndex.setDescription('The value of this object identifies the interface for which this entry contains management information. The value of this object for a particular interface has the same value as the ifIndex object for the same interface.')
ibmtbmacFiltOutSrcAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 5, 3, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmtbmacFiltOutSrcAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbmacFiltOutSrcAddress.setDescription('MAC source address to be filtered.')
ibmtbmacFiltOutSrcMask = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 5, 3, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmtbmacFiltOutSrcMask.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbmacFiltOutSrcMask.setDescription('Mask to allow ibmtbmacFiltOutSrcAddress to be used as a range of values.')
ibmtbmacFiltOutDestAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 5, 3, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmtbmacFiltOutDestAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbmacFiltOutDestAddress.setDescription('MAC destination address to be filtered.')
ibmtbmacFiltOutDestMask = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 5, 3, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmtbmacFiltOutDestMask.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbmacFiltOutDestMask.setDescription('Mask to allow ibmtbmacFiltOutDestAddress to be used as a range of values.')
ibmtbsapFiltInfoTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 6, 1), )
if mibBuilder.loadTexts: ibmtbsapFiltInfoTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbsapFiltInfoTable.setDescription('Table of SAP filtering information.')
ibmtbsapFiltInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 6, 1, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmtbsapFiltIfIndex"))
if mibBuilder.loadTexts: ibmtbsapFiltInfoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbsapFiltInfoEntry.setDescription('SAP filtering information for a single interface.')
ibmtbsapFiltIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 6, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmtbsapFiltIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbsapFiltIfIndex.setDescription('The value of this object identifies the interface for which this entry contains management information. The value of this object for a particular interface has the same value as the ifIndex object for the same interface.')
ibmtbsapFiltIn = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 6, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmtbsapFiltIn.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbsapFiltIn.setDescription('A bitmap of all possible source SAPs (even) that will be on or off depending on whether or not an incoming frame with that SAP is to be forwarded.')
ibmtbsapFiltOut = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 6, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmtbsapFiltOut.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbsapFiltOut.setDescription('A bitmap of all possible source SAPs (even) that will be on or off depending on whether or not an outgoing frame with that SAP is to be forwarded.')
ibmtbsapFiltInNotForwarded = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 6, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmtbsapFiltInNotForwarded.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbsapFiltInNotForwarded.setDescription('Number of packets not forwarded, in the incoming direction, because they were filtered out.')
ibmtbsapFiltOutNotForwarded = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 6, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmtbsapFiltOutNotForwarded.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbsapFiltOutNotForwarded.setDescription('Number of packets not forwarded, in the outgoing direction, because they were filtered out.')
ibmtbEthTypeFiltInfoTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 7, 1), )
if mibBuilder.loadTexts: ibmtbEthTypeFiltInfoTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbEthTypeFiltInfoTable.setDescription('Table of Ethernet type filtering information. Note that this filtering only applies to: 1) The Ethernet TYPE field for DIX version 2 frames. 2) The Ethernet TYPE field contained in the SNAP header of 802.3 frames, if the frame contains a SNAP header (SSAP = DSAP = 0xAA)')
ibmtbEthTypeFiltInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 7, 1, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmtbEthTypeFiltIfIndex"))
if mibBuilder.loadTexts: ibmtbEthTypeFiltInfoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbEthTypeFiltInfoEntry.setDescription('Ethernet type filtering information for a single interface.')
ibmtbEthTypeFiltIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 7, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmtbEthTypeFiltIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbEthTypeFiltIfIndex.setDescription('The value of this object identifies the interface for which this entry contains management information. The value of this object for a particular interface has the same value as the ifIndex object for the same interface.')
ibmtbEthTypeFiltInFilterType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 7, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("deny", 1), ("permit", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmtbEthTypeFiltInFilterType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbEthTypeFiltInFilterType.setDescription('For the incoming Ethernet type filter table, determines whether the entries are permit or deny entries.')
ibmtbEthTypeFiltOutFilterType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 7, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("deny", 1), ("permit", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmtbEthTypeFiltOutFilterType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbEthTypeFiltOutFilterType.setDescription('For the outgoing Ethernet type filter table, determines whether the entries are permit or deny entries.')
ibmtbEthTypeFiltInNotForwarded = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 7, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmtbEthTypeFiltInNotForwarded.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbEthTypeFiltInNotForwarded.setDescription('Number of packets not forwarded, in the incoming direction, because they were filtered out.')
ibmtbEthTypeFiltOutNotForwarded = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 7, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmtbEthTypeFiltOutNotForwarded.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbEthTypeFiltOutNotForwarded.setDescription('Number of packets not forwarded, in the outgoing direction, because they were filtered out.')
ibmtbEthTypeFiltInTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 7, 2), )
if mibBuilder.loadTexts: ibmtbEthTypeFiltInTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbEthTypeFiltInTable.setDescription('Table of Ethernet type filtering information for incoming frames. Note that this filtering only applies to: 1) The Ethernet TYPE field for DIX version 2 frames. 2) The Ethernet TYPE field contained in the SNAP header of 802.3 frames, if the frame contains a SNAP header (SSAP = DSAP = 0xAA)')
ibmtbEthTypeFiltInEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 7, 2, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmtbEthTypeFiltInIfIndex"), (0, "IBM6611-MIB", "ibmtbEthTypeFiltInValue"))
if mibBuilder.loadTexts: ibmtbEthTypeFiltInEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbEthTypeFiltInEntry.setDescription('Filtering information for a single Ethernet type on a single interface.')
ibmtbEthTypeFiltInIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 7, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmtbEthTypeFiltInIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbEthTypeFiltInIfIndex.setDescription('The value of this object identifies the interface for which this entry contains management information. The value of this object for a particular interface has the same value as the ifIndex object for the same interface.')
ibmtbEthTypeFiltInValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 7, 2, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmtbEthTypeFiltInValue.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbEthTypeFiltInValue.setDescription('Indicates which Ethernet type to filter.')
ibmtbEthTypeFiltInMask = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 7, 2, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmtbEthTypeFiltInMask.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbEthTypeFiltInMask.setDescription('Mask to allow ibmtbEthTypeFiltInValue to be used as a range of values.')
ibmtbEthTypeFiltOutTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 7, 3), )
if mibBuilder.loadTexts: ibmtbEthTypeFiltOutTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbEthTypeFiltOutTable.setDescription('Table of Ethernet type filtering information for outgoing frames. Note that this filtering only applies to: 1) The Ethernet TYPE field for DIX version 2 frames. 2) The Ethernet TYPE field contained in the SNAP header of 802.3 frames, if the frame contains a SNAP header (SSAP = DSAP = 0xAA)')
ibmtbEthTypeFiltOutEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 7, 3, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmtbEthTypeFiltOutIfIndex"), (0, "IBM6611-MIB", "ibmtbEthTypeFiltOutValue"))
if mibBuilder.loadTexts: ibmtbEthTypeFiltOutEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbEthTypeFiltOutEntry.setDescription('Filtering information for a single Ethernet type on a single interface.')
ibmtbEthTypeFiltOutIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 7, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmtbEthTypeFiltOutIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbEthTypeFiltOutIfIndex.setDescription('The value of this object identifies the interface for which this entry contains management information. The value of this object for a particular interface has the same value as the ifIndex object for the same interface.')
ibmtbEthTypeFiltOutValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 7, 3, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmtbEthTypeFiltOutValue.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbEthTypeFiltOutValue.setDescription('Indicates which Ethernet type to filter.')
ibmtbEthTypeFiltOutMask = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 7, 3, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmtbEthTypeFiltOutMask.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbEthTypeFiltOutMask.setDescription('Mask to allow ibmtbEthTypeFiltOutValue to be used as a range of values.')
ibmtbwinFiltInfoTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 8, 1), )
if mibBuilder.loadTexts: ibmtbwinFiltInfoTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbwinFiltInfoTable.setDescription('Table of Window filtering information.')
ibmtbwinFiltInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 8, 1, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmtbwinFiltIfIndex"))
if mibBuilder.loadTexts: ibmtbwinFiltInfoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbwinFiltInfoEntry.setDescription('Window filtering information for a single interface.')
ibmtbwinFiltIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 8, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmtbwinFiltIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbwinFiltIfIndex.setDescription('The value of this object identifies the interface for which this entry contains management information. The value of this object for a particular interface has the same value as the ifIndex object for the same interface.')
ibmtbwinFiltInFilterType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 8, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("deny", 1), ("permit", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmtbwinFiltInFilterType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbwinFiltInFilterType.setDescription('For the incoming filter table, determines whether the entries are permit or deny entries.')
ibmtbwinFiltOutFilterType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 8, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("deny", 1), ("permit", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmtbwinFiltOutFilterType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbwinFiltOutFilterType.setDescription('For the outgoing filter table, determines whether the entries are permit or deny entries.')
ibmtbwinFiltInNotForwarded = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 8, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmtbwinFiltInNotForwarded.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbwinFiltInNotForwarded.setDescription('Number of packets not forwarded, in the incoming direction, because they were filtered out.')
ibmtbwinFiltOutNotForwarded = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 8, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmtbwinFiltOutNotForwarded.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbwinFiltOutNotForwarded.setDescription('Number of packets not forwarded, in the outgoing direction, because they were filtered out.')
ibmtbwinFiltInTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 8, 2), )
if mibBuilder.loadTexts: ibmtbwinFiltInTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbwinFiltInTable.setDescription('Table of Window filtering information for incoming frames.')
ibmtbwinFiltInEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 8, 2, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmtbwinFiltInIfIndex"), (0, "IBM6611-MIB", "ibmtbwinFiltInId"), (0, "IBM6611-MIB", "ibmtbwinFiltInContents"))
if mibBuilder.loadTexts: ibmtbwinFiltInEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbwinFiltInEntry.setDescription('Filtering information for incoming frames.')
ibmtbwinFiltInIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 8, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmtbwinFiltInIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbwinFiltInIfIndex.setDescription('The value of this object identifies the interface for which this entry contains management information. The value of this object for a particular interface has the same value as the ifIndex object for the same interface.')
ibmtbwinFiltInContents = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 8, 2, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmtbwinFiltInContents.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbwinFiltInContents.setDescription('String of bytes that will be compared with bytes in the frame.')
ibmtbwinFiltInMaskString = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 8, 2, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmtbwinFiltInMaskString.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbwinFiltInMaskString.setDescription('String of bytes that will be masked with bytes in the contents field.')
ibmtbwinFiltInOffsetStart = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 8, 2, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmtbwinFiltInOffsetStart.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbwinFiltInOffsetStart.setDescription("Determines the starting point where the contents field should be applied. A value of 'MAC' means the base is at the beginning of the destination MAC address field, whereas, a value of 'DATA' means it is applied at the beginning of the data field.")
ibmtbwinFiltInNumBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 8, 2, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmtbwinFiltInNumBytes.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbwinFiltInNumBytes.setDescription('Number of bytes in the contents field that are used for filtering')
ibmtbwinFiltInOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 8, 2, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmtbwinFiltInOffset.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbwinFiltInOffset.setDescription('Number of bytes offset into the frame from the offset start point to begin the compare.')
ibmtbwinFiltInId = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 8, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmtbwinFiltInId.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbwinFiltInId.setDescription('A unique identifier associated with this window filter entry.')
ibmtbwinFiltOutTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 8, 3), )
if mibBuilder.loadTexts: ibmtbwinFiltOutTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbwinFiltOutTable.setDescription('Table of Window filtering information for outgoing frames.')
ibmtbwinFiltOutEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 8, 3, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmtbwinFiltOutIfIndex"), (0, "IBM6611-MIB", "ibmtbwinFiltOutId"), (0, "IBM6611-MIB", "ibmtbwinFiltOutContents"))
if mibBuilder.loadTexts: ibmtbwinFiltOutEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbwinFiltOutEntry.setDescription('Filtering information for outgoing frames.')
ibmtbwinFiltOutIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 8, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmtbwinFiltOutIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbwinFiltOutIfIndex.setDescription('The value of this object identifies the interface for which this entry contains management information. The value of this object for a particular interface has the same value as the ifIndex object for the same interface.')
ibmtbwinFiltOutContents = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 8, 3, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmtbwinFiltOutContents.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbwinFiltOutContents.setDescription('String of bytes that will be compared with bytes in the frame.')
ibmtbwinFiltOutMaskString = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 8, 3, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmtbwinFiltOutMaskString.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbwinFiltOutMaskString.setDescription('String of bytes that will be masked with bytes in the contents field.')
ibmtbwinFiltOutOffsetStart = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 8, 3, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmtbwinFiltOutOffsetStart.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbwinFiltOutOffsetStart.setDescription("Determines the starting point where the contents field should be applied. A value of 'MAC' means the base is at the beginning of the destination MAC address field, whereas, a value of 'DATA' means it is applied at the beginning of the data field.")
ibmtbwinFiltOutNumBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 8, 3, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmtbwinFiltOutNumBytes.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbwinFiltOutNumBytes.setDescription('Number of bytes in the contents field that are used for filtering')
ibmtbwinFiltOutOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 8, 3, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmtbwinFiltOutOffset.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbwinFiltOutOffset.setDescription('Number of bytes offset into the frame from the offset start point to begin the compare.')
ibmtbwinFiltOutId = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 8, 3, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmtbwinFiltOutId.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbwinFiltOutId.setDescription('A unique identifier associated with this window filter entry.')
ibmtbFiltOrderInTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 9, 1), )
if mibBuilder.loadTexts: ibmtbFiltOrderInTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbFiltOrderInTable.setDescription('Table of information describing which order the filters are applied for incoming frames.')
ibmtbFiltOrderInEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 9, 1, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmtbFiltOrderInPriority"))
if mibBuilder.loadTexts: ibmtbFiltOrderInEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbFiltOrderInEntry.setDescription('Filter order information for incoming frames.')
ibmtbFiltOrderInIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 9, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmtbFiltOrderInIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbFiltOrderInIfIndex.setDescription('The value of this object identifies the interface for which this entry contains management information. The value of this object for a particular interface has the same value as the ifIndex object for the same interface.')
ibmtbFiltOrderInPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 9, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmtbFiltOrderInPriority.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbFiltOrderInPriority.setDescription('The priority of when a filter is applied to an incoming frame. A value of 1 signifies that it is applied first.')
ibmtbFiltOrderInName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 9, 1, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmtbFiltOrderInName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbFiltOrderInName.setDescription('The name of the filter applied to incoming frames that is associated with the priority, ibmtbFiltOrderInPriority.')
ibmtbFiltOrderOutTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 9, 2), )
if mibBuilder.loadTexts: ibmtbFiltOrderOutTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbFiltOrderOutTable.setDescription('Table of information describing which order the filters are applied for outgoing frames.')
ibmtbFiltOrderOutEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 9, 2, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmtbFiltOrderOutPriority"))
if mibBuilder.loadTexts: ibmtbFiltOrderOutEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbFiltOrderOutEntry.setDescription('Filter order information for outgoing frames.')
ibmtbFiltOrderOutIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 9, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmtbFiltOrderOutIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbFiltOrderOutIfIndex.setDescription('The value of this object identifies the interface for which this entry contains management information. The value of this object for a particular interface has the same value as the ifIndex object for the same interface.')
ibmtbFiltOrderOutPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 9, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmtbFiltOrderOutPriority.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbFiltOrderOutPriority.setDescription('The priority of when a filter is applied to an outgoing frame. A value of 1 signifies that it is applied first.')
ibmtbFiltOrderOutName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 15, 9, 2, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmtbFiltOrderOutName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmtbFiltOrderOutName.setDescription('The name of the filter applied to outgoing frames that is associated with the priority, ibmtbFiltOrderOutPriority.')
ibmSelectNet = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 16, 1))
ibmnbpFilter = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 16, 2))
ibmatportFilter = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 16, 3))
ibmSelectNetFilter = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 16, 4))
ibmSelectNetTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 16, 1, 1), )
if mibBuilder.loadTexts: ibmSelectNetTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSelectNetTable.setDescription('The list of selected network definition entries.')
ibmSelectNetEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 16, 1, 1, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmSelectNetIndex"))
if mibBuilder.loadTexts: ibmSelectNetEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSelectNetEntry.setDescription('The description of a selected network definition.')
ibmSelectNetIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 16, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmSelectNetIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSelectNetIndex.setDescription('An identifier that is unique to the default zone name that is present in this entry.')
ibmSelectNetZone = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 16, 1, 1, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmSelectNetZone.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSelectNetZone.setDescription('The ASCII default zone name of this entry.')
ibmSelectNetNetStart = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 16, 1, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmSelectNetNetStart.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSelectNetNetStart.setDescription('The network address that starts the range for this entry. This address is a two octet DDP network address in network byte order.')
ibmSelectNetNetEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 16, 1, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmSelectNetNetEnd.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSelectNetNetEnd.setDescription('The network address that ends the range for this entry. This address is a two octet DDP network address in network byte order.')
ibmSelectNetInterfaceNetStart = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 16, 1, 1, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmSelectNetInterfaceNetStart.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSelectNetInterfaceNetStart.setDescription('The network address that starts the range for the interface associated with this definition.')
ibmnbpFilterPacketsFiltered = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 16, 2, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmnbpFilterPacketsFiltered.setStatus('mandatory')
if mibBuilder.loadTexts: ibmnbpFilterPacketsFiltered.setDescription('The number of packets filtered by nbp filters.')
ibmnbpFilterPacketsSent = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 16, 2, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmnbpFilterPacketsSent.setStatus('mandatory')
if mibBuilder.loadTexts: ibmnbpFilterPacketsSent.setDescription('The number of packets not filtered by nbp filters.')
ibmatportFilterTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 16, 3, 1), )
if mibBuilder.loadTexts: ibmatportFilterTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmatportFilterTable.setDescription('The list of Appletalk port destination network filter entries.')
ibmatportFilterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 16, 3, 1, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmatportFilterIndex"), (0, "IBM6611-MIB", "ibmatportFilterNetStart"))
if mibBuilder.loadTexts: ibmatportFilterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmatportFilterEntry.setDescription('The description of a filter on this Appletalk port.')
ibmatportFilterIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 16, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmatportFilterIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmatportFilterIndex.setDescription('An identifier that is unique to the Appletalk port to which this filter applies. The port identified by this value is the same port as identified by atportIndex.')
ibmatportFilterNetStart = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 16, 3, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmatportFilterNetStart.setStatus('mandatory')
if mibBuilder.loadTexts: ibmatportFilterNetStart.setDescription('The network address that starts the range for this destination network filter. This address is a two octet DDP network address in network byte order.')
ibmatportFilterNetEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 16, 3, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmatportFilterNetEnd.setStatus('mandatory')
if mibBuilder.loadTexts: ibmatportFilterNetEnd.setDescription('The network address that ends the range for this destination network filter. This address is a two octet DDP network address in network byte order.')
ibmSelectNetFilterTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 16, 4, 1), )
if mibBuilder.loadTexts: ibmSelectNetFilterTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSelectNetFilterTable.setDescription('The list of selected network destination network filter entries.')
ibmSelectNetFilterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 16, 4, 1, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmSelectNetFilterIndex"), (0, "IBM6611-MIB", "ibmSelectNetFilterNetStart"))
if mibBuilder.loadTexts: ibmSelectNetFilterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSelectNetFilterEntry.setDescription('The description of a filter for this selected network definition.')
ibmSelectNetFilterIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 16, 4, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmSelectNetFilterIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSelectNetFilterIndex.setDescription('An identifier that is unique to the selected network definition to which this filter applies. This value is the same as that provided by ibmSelectNetIndex.')
ibmSelectNetFilterNetStart = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 16, 4, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmSelectNetFilterNetStart.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSelectNetFilterNetStart.setDescription('The network address that starts the range for this destination network filter. This address is a two octet DDP network address in network byte order.')
ibmSelectNetFilterNetEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 16, 4, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmSelectNetFilterNetEnd.setStatus('mandatory')
if mibBuilder.loadTexts: ibmSelectNetFilterNetEnd.setDescription('The network address that ends the range for this destination network filter. This address is a two octet DDP network address in network byte order.')
ibmdecAllRoutersFuncAddr = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 17, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdecAllRoutersFuncAddr.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdecAllRoutersFuncAddr.setDescription('The functional address used in communicating with with all DECnet Phase IV and DECnet Phase IV-Prime routers on a token ring LAN.')
ibmdecAllEndNodesFuncAddr = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 17, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdecAllEndNodesFuncAddr.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdecAllEndNodesFuncAddr.setDescription('The functional address used in communicating with with all DECnet Phase IV and DECnet Phase IV-Prime end nodes on a token ring LAN.')
ibmdecSplitHorPoisonRev = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 17, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdecSplitHorPoisonRev.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdecSplitHorPoisonRev.setDescription('Defines whether the Split Horizon with Poison Reverse option is enabled or not')
ibmdecNodeType = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 17, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("routing-III", 1), ("nonrouting-III", 2), ("area", 3), ("routing-IV", 4), ("nonrouting-IV", 5), ("area-IV-Prime", 6), ("routing-IV-Prime", 7), ("nonrouting-IV-Prime", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdecNodeType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdecNodeType.setDescription('This parameter indicates the node type of the router. This object is the same as the phivRouteType object defined by RFC 1289, however, this definition extends the enumerations to provide new values.')
ibmdecLANCircuitTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 17, 5), )
if mibBuilder.loadTexts: ibmdecLANCircuitTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdecLANCircuitTable.setDescription('The list of information relevant to LAN circuits. This table extends the information provided by the phivCircuitParametersTable defined by RFC 1289.')
ibmdecLANCircuitEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 17, 5, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmdecLANCircuitIndex"))
if mibBuilder.loadTexts: ibmdecLANCircuitEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdecLANCircuitEntry.setDescription('Table entry with information relevant to LAN circuits.')
ibmdecLANCircuitIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 17, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdecLANCircuitIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdecLANCircuitIndex.setDescription('A unique index value for each known circuit on a LAN interface. The value of this variable is the same as that provided by phivCircuitIndex.')
ibmdecLANCircuitType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 17, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("bilingual", 1), ("ama", 2), ("phaseIV", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdecLANCircuitType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdecLANCircuitType.setDescription('If the CircuitType is Bilingual for a circuit, the router would use a Phase_IV compliant locally administered MAC address for that circuit and would be configured to communicate with Phase_IV and Phase_IV-Prime nodes over that circuit. A bilingual router can help communication between the Phase_IV and the Phase_IV-Prime nodes over the same extended LAN segment, and prevents a partitioned network. If the CircuitType is AMA ( Arbitrary MAC Address ) for a circuit, the router would use an arbitrary MAC address for that circuit, and would be configured to communicate with Phase_IV-Prime nodes over that circuit. If the CircuitType is PhaseIV for a circuit, the router would use the Phase_IV compliant locally administered MAC address for that circuit, and would be configured to communicate with Phase_IV nodes over that circuit.')
ibmdecLANCircuitSourceRoute = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 17, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("notapplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdecLANCircuitSourceRoute.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdecLANCircuitSourceRoute.setDescription('This parameter indicates if source routing is enabled on a token-ring circuit. A value of 3 is returned for circuits which are not of the 802.5/token-ring type.')
ibmdecLANCircuitAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 17, 5, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("decnet", 1), ("hardware", 2), ("user", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmdecLANCircuitAddrType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmdecLANCircuitAddrType.setDescription('This parameter indicates the type of MAC address used on this circuit. The value returned is decnet(1), if a DECnet Phase_IV compliant locally administered MAC address is being used. The value returned is hardware(2), if the unique assigned ROM address is used. The value returned is user(3), if a non DECnet Phase_IV compliant locally administered MAC address is being used.')
ibmipext = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 19, 1))
ibmptyqueue = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 19, 2))
ibmTG = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 19, 3))
ibmipPtyQueueEnableTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 19, 1, 1), )
if mibBuilder.loadTexts: ibmipPtyQueueEnableTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipPtyQueueEnableTable.setDescription('This table defines which interfaces are enabled for IP prioritization. It also defines the default serial transmission priority queue to be used for IP packets which are not assigned to use a specific transmission queue.')
ibmipPtyQueueEnableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 19, 1, 1, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmipPtyQueueEnableIfIndex"))
if mibBuilder.loadTexts: ibmipPtyQueueEnableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipPtyQueueEnableEntry.setDescription('Each entry defines whether IP prioritization is enabled on a particular interface and the default transmission queue.')
ibmipPtyQueueEnableIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 19, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmipPtyQueueEnableIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipPtyQueueEnableIfIndex.setDescription('Defines the interface associated with IP prioritization. This interface is the same interface as defined by the ifIndex variable of the MIB-II interfaces group.')
ibmipPtyQueueEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 19, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmipPtyQueueEnable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipPtyQueueEnable.setDescription('The value of this object identifies if IP prioritization is enabled on this interface.')
ibmipPtyQueueDefault = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 19, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("high", 1), ("medium", 2), ("low", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmipPtyQueueDefault.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipPtyQueueDefault.setDescription('Identifies the transmission queue to be used for IP packets which are not assigned to use a specific transmission queue.')
ibmipPtyQueueTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 19, 1, 2), )
if mibBuilder.loadTexts: ibmipPtyQueueTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipPtyQueueTable.setDescription('This table contains the assignments of UDP/TCP port numbers to specific transmission queues for a given serial interface.')
ibmipPtyQueueEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 19, 1, 2, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmipPtyQueueIfIndex"), (0, "IBM6611-MIB", "ibmipPtyQueuePort"), (0, "IBM6611-MIB", "ibmipPtyQueueType"))
if mibBuilder.loadTexts: ibmipPtyQueueEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipPtyQueueEntry.setDescription('Each entry defines the UDP/TCP port number and its associated transmission priority queue for a given interface.')
ibmipPtyQueueIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 19, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmipPtyQueueIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipPtyQueueIfIndex.setDescription('Defines the interface on which a UDP/TCP port is associated with a specific transmission priority queue. This interface is the same interface as defined by the ifIndex variable of the MIB-II interfaces group.')
ibmipPtyQueuePort = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 19, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmipPtyQueuePort.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipPtyQueuePort.setDescription('Identifies a UDP or TCP port number.')
ibmipPtyQueueType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 19, 1, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("tcp", 1), ("udp", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmipPtyQueueType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipPtyQueueType.setDescription('Indicates the port type of the port number defined by ibmipPtyQueuePort.')
ibmipPtyQueueNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 19, 1, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("high", 1), ("medium", 2), ("low", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmipPtyQueueNumber.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipPtyQueueNumber.setDescription('Indicates which transmission queue will be used to transmit a packet which has a port number as specified by ibmipPtyQueuePort.')
ibmipFilterTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 19, 1, 3), )
if mibBuilder.loadTexts: ibmipFilterTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipFilterTable.setDescription('Table of IP address/mask filter definitions.')
ibmipFilterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 19, 1, 3, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmipFilterIfIndex"), (0, "IBM6611-MIB", "ibmipFilterId"))
if mibBuilder.loadTexts: ibmipFilterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipFilterEntry.setDescription('An entry in the IP address/mask filter table.')
ibmipFilterIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 19, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmipFilterIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipFilterIfIndex.setDescription('Defines the interface associated with this address/mask filter definition. This interface is the same interface as defined by the ifIndex variable of the MIB-II interfaces group.')
ibmipFilterId = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 19, 1, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 50))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmipFilterId.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipFilterId.setDescription('An id that defines this filter entry. This number is unique within this interface.')
ibmipFilterScope = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 19, 1, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("system", 1), ("interface", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmipFilterScope.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipFilterScope.setDescription('Defines whether this filter is applied to all interfaces or just this one.')
ibmipFilterType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 19, 1, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("singular", 1), ("dual", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmipFilterType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipFilterType.setDescription('Defines the type of filtering.')
ibmipPermitDeny = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 19, 1, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("permit", 1), ("deny", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmipPermitDeny.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipPermitDeny.setDescription('Identifies whether traffic for a specified filter ID is to be permitted to pass through the IBM 6611 or whether it is to be discarded.')
ibmipFilterAddr1 = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 19, 1, 3, 1, 6), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmipFilterAddr1.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipFilterAddr1.setDescription('A valid IP address of the host, subnet or network for this filter. For singular filters, this is the only end point, however, for dual filters this is the source end point.')
ibmipFilterMask1 = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 19, 1, 3, 1, 7), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmipFilterMask1.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipFilterMask1.setDescription('A valid IP address mask used for this filter. In conjunction with the IP address defined by ibmipFilterAddr1, it defines the range of IP addresses to be filtered.')
ibmipFilterAddr2 = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 19, 1, 3, 1, 8), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmipFilterAddr2.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipFilterAddr2.setDescription('Defines the destination IP address if ibmipFilterType is dual. This value is undefined for singular filters.')
ibmipFilterMask2 = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 19, 1, 3, 1, 9), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmipFilterMask2.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipFilterMask2.setDescription('A valid IP address mask used for this filter. In conjunction with the IP address defined by ibmipFilterAddr2, it defines the range of IP addresses to be filtered.')
ibmipFilterExtTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 19, 1, 4), )
if mibBuilder.loadTexts: ibmipFilterExtTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipFilterExtTable.setDescription('Table of IP port number filter definitions.')
ibmipFilterExtEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 19, 1, 4, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmipFilterExtIfIndex"), (0, "IBM6611-MIB", "ibmipFilterExtFilterId"), (0, "IBM6611-MIB", "ibmipFilterExtValue"), (0, "IBM6611-MIB", "ibmipFilterExtProtocol"))
if mibBuilder.loadTexts: ibmipFilterExtEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipFilterExtEntry.setDescription('An entry in the IP port number filter table.')
ibmipFilterExtIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 19, 1, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmipFilterExtIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipFilterExtIfIndex.setDescription('Defines the interface associated with this IP port number filter definition. This interface is the same interface as defined by the ifIndex variable of the MIB-II interfaces group.')
ibmipFilterExtFilterId = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 19, 1, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 50))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmipFilterExtFilterId.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipFilterExtFilterId.setDescription('An id that defines this filter entry. This number is unique within this interface and is the same filter ID as defined by ibmipFilterId.')
ibmipFilterExtValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 19, 1, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmipFilterExtValue.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipFilterExtValue.setDescription('Defines a TCP or UDP port number that will be filtered using this filter specification.')
ibmipFilterExtProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 19, 1, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("none", 1), ("tcpudp", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmipFilterExtProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: ibmipFilterExtProtocol.setDescription('Specifies the protocol associated with the value defined by ibmipFilterExtValue for this filter specification.')
ibmPtyQueueingTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 19, 2, 1), )
if mibBuilder.loadTexts: ibmPtyQueueingTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmPtyQueueingTable.setDescription('This table provides information on a specific transmission queue of a serial interface. Information includes: - Link Bandwidth Allocation (LBA): Identifies the number of packets transmitted from a particular queue before a lower priority transmission queue will be serviced. - Queue Bandwidth Reservation (QBR): Identifies the percentage of buffer space on a serial adapter that is allotted to a particular queue for transmission of packets.')
ibmPtyQueueingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 19, 2, 1, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmPtyQueueingIfIndex"), (0, "IBM6611-MIB", "ibmPtyQueueingQnum"))
if mibBuilder.loadTexts: ibmPtyQueueingEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmPtyQueueingEntry.setDescription('Each entry defines the Link Bandwidth Allocation (LBA) and Queue Bandwidth Reservation (QBR) definitions for a specific transmission queue on a serial interface. Additionally, a counter is provided indicating the number of packets discarded on this queue due to a queue overflow.')
ibmPtyQueueingIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 19, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmPtyQueueingIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmPtyQueueingIfIndex.setDescription('Defines the interface associated with this priority queue information. This interface is the same interface as defined by the ifIndex variable of the MIB-II interfaces group.')
ibmPtyQueueingQnum = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 19, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("high", 1), ("medium", 2), ("low", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmPtyQueueingQnum.setStatus('mandatory')
if mibBuilder.loadTexts: ibmPtyQueueingQnum.setDescription('Identifies the priority queue associated with this interface and its priority queue information.')
ibmPtyQueueingLBA = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 19, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmPtyQueueingLBA.setStatus('mandatory')
if mibBuilder.loadTexts: ibmPtyQueueingLBA.setDescription('Link Bandwidth Allocation (LBA): Identifies the number of packets that will be transmitted from this queue before a lower priority queue will be serviced.')
ibmPtyQueueingQBR = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 19, 2, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmPtyQueueingQBR.setStatus('mandatory')
if mibBuilder.loadTexts: ibmPtyQueueingQBR.setDescription('Queue Bandwidth Reservation (QBR): Identifies the percentage of buffer space on a serial adapter that is allotted to a particular queue for transmission of packets. The sum of all QBR values on an interface must add up to 100%.')
ibmPtyQueueingDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 19, 2, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmPtyQueueingDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: ibmPtyQueueingDiscards.setDescription('Identifies the number of packets discarded from this queue due to a queue overflow.')
ibmTGTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 19, 3, 1), )
if mibBuilder.loadTexts: ibmTGTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmTGTable.setDescription('This table provides information about serial point-to-point links which are participating in the 2 T1 in a transmission group (TG) function.')
ibmTGEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 19, 3, 1, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmTGProtocol"), (0, "IBM6611-MIB", "ibmTGIfIndex"))
if mibBuilder.loadTexts: ibmTGEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmTGEntry.setDescription('Each entry identifies an interface participating in the 2 T1 in a TG function, along with its associated TG name and which protocol is using the function.')
ibmTGProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 19, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2048))).clone(namedValues=NamedValues(("ip", 2048)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmTGProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: ibmTGProtocol.setDescription('Defines the protocol that is supported for this particular interface and TG name. Currently, only the IP protocol is supported')
ibmTGIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 19, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmTGIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmTGIfIndex.setDescription('Defines the interface associated with this particular TG name and protocol. This interface is the same interface as defined by the ifIndex variable of the MIB-II interfaces group.')
ibmTGEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 19, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmTGEnable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmTGEnable.setDescription('Defines whether the 2 T1 in a TG function is enabled on this interface')
ibmTGGroupName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 19, 3, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmTGGroupName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmTGGroupName.setDescription('Defines the common TG name assigned to all interfaces in this group. All interfaces with the same TG name will belong to the same group.')
ibmTGSwitchOuts = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 19, 3, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmTGSwitchOuts.setStatus('mandatory')
if mibBuilder.loadTexts: ibmTGSwitchOuts.setDescription('Counts the number of times a packet had to be switched to another interface in the transmission group.')
ibmvSysConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 1))
ibmvIP = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 2))
ibmvNeighbor = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 3))
ibmvRouting = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 4))
ibmvICP = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 5))
ibmvFRP = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 6))
ibmvInterface = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 7))
ibmvSysRtr = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvSysRtr.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvSysRtr.setDescription('Indicates whether this node is acting as a VINES router.')
ibmvRouterName = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvRouterName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvRouterName.setDescription('The name of the router node, up to 15 characters long.')
ibmvRouterNetid = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvRouterNetid.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvRouterNetid.setDescription("The VINES network ID of the router node equal to the router node's serial number. This id may be up to 4 bytes in length.")
ibmvipTotalIn = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 2, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvipTotalIn.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvipTotalIn.setDescription('The total number of VINES IP packets that the router node has received since the last reboot.')
ibmvipTotalOut = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 2, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvipTotalOut.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvipTotalOut.setDescription('The total number of VINES IP packets that the router node has sent since the last reboot.')
ibmvipRouted = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 2, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvipRouted.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvipRouted.setDescription('The total number of packets that were routed to another node since the last reboot.')
ibmvipBcast = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 2, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvipBcast.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvipBcast.setDescription('The number of VINES IP broadcast packets sent, both generated from the router node and routed from other nodes, since the last reboot.')
ibmvipInReceives = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 2, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvipInReceives.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvipInReceives.setDescription('The number of unicast VINES IP packets received since the last reboot. A unicast packet is destined for this particular router node. It is not being forwarded, multicasted or broadcasted.')
ibmvipBcastInReceives = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 2, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvipBcastInReceives.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvipBcastInReceives.setDescription('The number of VINES IP broadcast packets received since the last reboot.')
ibmvipBad = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 2, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvipBad.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvipBad.setDescription('The total number of badly formed packets that the router node has received since the last booted.')
ibmvipBadHeaders = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 2, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvipBadHeaders.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvipBadHeaders.setDescription('The number of incoming VINES IP packets received since the last reboot which contained a header error; excluding the following errors: length, checksum and time to live.')
ibmvipTooSmalls = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 2, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvipTooSmalls.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvipTooSmalls.setDescription('The number of VINES IP packets received since the last reboot with len < the size of a VINES IP header.')
ibmvipBadLens = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 2, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvipBadLens.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvipBadLens.setDescription('The number of VINES IP packets received since the last reboot whose packet size is not equal to the number of bytes specified in the VINES IP header field.')
ibmvipBadSums = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 2, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvipBadSums.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvipBadSums.setDescription('The number of VINES IP packets received since the last reboot with a bad checksum.')
ibmvipInDiscards = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 2, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvipInDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvipInDiscards.setDescription('The number of incoming VINES IP packets discarded since the last reboot due to lack of resources.')
ibmvipZeroHops = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 2, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvipZeroHops.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvipZeroHops.setDescription('The number of VINES IP packets discarded since the last reboot because the hop count equals zero and the current node is not the destination.')
ibmvipOutNoRoutes = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 2, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvipOutNoRoutes.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvipOutNoRoutes.setDescription('The number of outgoing VINES IP packets discarded since the last reboot because no route is available.')
ibmvARP = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 3, 1))
ibmvarpQueryReqs = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 3, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvarpQueryReqs.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvarpQueryReqs.setDescription('The number of query requests received from clients since the last reboot. When a client is first booted up, it sends out a broadcast query request packet on its LAN segment.')
ibmvarpServiceResps = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 3, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvarpServiceResps.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvarpServiceResps.setDescription('The number of ARP query responses sent out from this router node since the last reboot. Each router node on the same LAN segment that is providing address assignments will respond.')
ibmvarpAssignReqs = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 3, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvarpAssignReqs.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvarpAssignReqs.setDescription('The number of ARP assignment request received from clients since the last reboot. The client issues an assignment request packet to the router node that responded first to the query request.')
ibmvarpAssignResps = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 3, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvarpAssignResps.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvarpAssignResps.setDescription('The number of ARP assignment responses sent to clients since the last reboot. The router node issues a VINES internet address for the client and sends it back in an assignment response packet.')
ibmvarpHeaderError = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 3, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvarpHeaderError.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvarpHeaderError.setDescription('The number of ARP packets received since the last reboot with a header error.')
ibmvNbrNumber = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 3, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvNbrNumber.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvNbrNumber.setDescription('The number of entries in the neighbor table.')
ibmvNbrTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 3, 3), )
if mibBuilder.loadTexts: ibmvNbrTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvNbrTable.setDescription("A list of information about IBM's VINES router neighbor table.")
ibmvNbrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 3, 3, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmvNbrNetid"), (0, "IBM6611-MIB", "ibmvNbrSubNetid"), (0, "IBM6611-MIB", "ibmvNbrIfType"), (0, "IBM6611-MIB", "ibmvNbrLocSlot"), (0, "IBM6611-MIB", "ibmvNbrLocPort"))
if mibBuilder.loadTexts: ibmvNbrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvNbrEntry.setDescription('The information for each entry in the neighbor table.')
ibmvNbrNetid = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 3, 3, 1, 1), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvNbrNetid.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvNbrNetid.setDescription("The network ID of the neighbor. The VINES internet address has the following form: 'nnnnnnnn.ssss'hex, where n = network ID and s = subnetwork ID. If the neighbor is a router, then network ID is the router node's (the neighbor's) serial number.")
ibmvNbrSubNetid = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 3, 3, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvNbrSubNetid.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvNbrSubNetid.setDescription("The subnetwork ID of the neighbor. The VINES internet address has the following form: 'nnnnnnnn.ssss'hex, where n = network ID and s = subnetwork ID. If the neighbor is a router node, then the subnetwork ID for the router node (the neighbor) is 1.")
ibmvNbrType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 3, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("server", 1), ("workstation", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvNbrType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvNbrType.setDescription('The type of the neighbor (workstation = pc).')
ibmvNbrIfType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 3, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32))).clone(namedValues=NamedValues(("other", 1), ("regular1822", 2), ("hdh1822", 3), ("ddn-x25", 4), ("rfc877-x25", 5), ("ethernet-csmacd", 6), ("iso88023-csmacd", 7), ("iso88024-tokenBus", 8), ("iso88025-tokenRing", 9), ("iso88026-man", 10), ("starLan", 11), ("proteon-10Mbit", 12), ("proteon-80Mbit", 13), ("hyperchannel", 14), ("fddi", 15), ("lapb", 16), ("sdlc", 17), ("ds1", 18), ("cept", 19), ("basicISDN", 20), ("primaryISDN", 21), ("propPointToPointSerial", 22), ("ppp", 23), ("loopback", 24), ("eon", 25), ("ethernet-3Mbit", 26), ("nsip", 27), ("slip", 28), ("ultra", 29), ("ds3", 30), ("sip", 31), ("frame-relay", 32)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvNbrIfType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvNbrIfType.setDescription('The type of interface that the server uses to reach the neighbor.')
ibmvNbrRemAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 3, 3, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvNbrRemAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvNbrRemAddress.setDescription("The address of the neighbor's physical interface. For LAN's, it is the hardware address of the neighbor.")
ibmvNbrLocAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 3, 3, 1, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvNbrLocAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvNbrLocAddress.setDescription("The address of the router node's physical interface, such as a LAN address.")
ibmvNbrLocSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 3, 3, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvNbrLocSlot.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvNbrLocSlot.setDescription('The slot number of the interface card that the router node uses to reach the neighbor.')
ibmvNbrLocPort = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 3, 3, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvNbrLocPort.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvNbrLocPort.setDescription('The port number on the interface card that the router node used to reach the neighbor.')
ibmvNbrAging = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 3, 3, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvNbrAging.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvNbrAging.setDescription('The amount of time left before a neighbor entry will be removed because of aging. For a WAN link, which is defined to be permanent, this object is not applicable.')
ibmvNbrFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 3, 3, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("permanent", 1), ("nonpermanent", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvNbrFlags.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvNbrFlags.setDescription('Only applicable to a WAN link; states if the link is permanent or non-permanent.')
ibmvNbrRIF = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 3, 3, 1, 11), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvNbrRIF.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvNbrRIF.setDescription('LAN - MAC address and if applicable, source routing information. Frame Relay - n/a PPP - n/a')
ibmvNbrIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 3, 3, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvNbrIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvNbrIfIndex.setDescription('The interface (using the MIB II standard) used to reach the neighbor. This number corresponds to the IfIndex object found in MIB II.')
ibmvNbrMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 3, 3, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvNbrMetric.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvNbrMetric.setDescription('The cost to reach the neighbor.')
ibmvRtConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 4, 1))
ibmvRtCfgMax = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvRtCfgMax.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvRtCfgMax.setDescription('The maximum number of entries allowed in the routing table. This value is not defined by administrator.')
ibmvRtCfgInFlt = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvRtCfgInFlt.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvRtCfgInFlt.setDescription("Enables or disables all inbound RTP filters defined. If no inbound RTP filters are defined, then this object has no effect. If a filter is defined, then the default value is 'enabled'.")
ibmvRtCfgInFltNum = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 4, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvRtCfgInFltNum.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvRtCfgInFltNum.setDescription('The number of inbound RTP filters currently defined.')
ibmvRtCfgInFltTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 4, 1, 4), )
if mibBuilder.loadTexts: ibmvRtCfgInFltTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvRtCfgInFltTable.setDescription('A list of information about the inbound RTP filters which are specified for this router node.')
ibmvRtCfgInFltEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 4, 1, 4, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmvRtCfgInFltNetID"), (0, "IBM6611-MIB", "ibmvRtCfgInFltIfIndex"))
if mibBuilder.loadTexts: ibmvRtCfgInFltEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvRtCfgInFltEntry.setDescription('The information for each entry in the inbound RTP filter table.')
ibmvRtCfgInFltNetID = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 4, 1, 4, 1, 1), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvRtCfgInFltNetID.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvRtCfgInFltNetID.setDescription('Administrator defined object which specifies the VINES network number to be filtered on the port. The range of the network number is 00000000 - FFFFFFFE. If the network number, 0xFFFFFFFF, is defined, then all network numbers will be filtered.')
ibmvRtCfgInFltIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 4, 1, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvRtCfgInFltIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvRtCfgInFltIfIndex.setDescription('The interface (using the MIB II standard) for which the inbound RTP filters were defined. This number corresponds to the IfIndex object found in MIB II.')
ibmvRtCfgInFltMode = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 4, 1, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("permit", 1), ("deny", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvRtCfgInFltMode.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvRtCfgInFltMode.setDescription("The filtering action for the inbound RTP filter. The inbound RTP filters operate on network numbers contained in the topological entries in the RTP update, response, and redirect packets received over a specified interface. In deny mode, the 6611 ignores route information for a network if the network number and the port on which the route information was received matches any inbound RTP filter. In permit mode, the IBM 6611 processes route information for a network only if the network number and the port on which the route information was received matches any inbound RTP filter. The default for this object is 'deny'.")
ibmvRtCfgInFltUses = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 4, 1, 4, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvRtCfgInFltUses.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvRtCfgInFltUses.setDescription('The number of times the defined filter was used.')
ibmvRtCfgOutFlt = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvRtCfgOutFlt.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvRtCfgOutFlt.setDescription("Enables or disables all outbound RTP filters defined. If no outbound RTP filters are defined, then this object has no effect. If a filter is defined, then the default value is 'enabled'.")
ibmvRtCfgOutFltNum = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 4, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvRtCfgOutFltNum.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvRtCfgOutFltNum.setDescription('The number of outbound RTP filters currently defined.')
ibmvRtCfgOutFltTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 4, 1, 7), )
if mibBuilder.loadTexts: ibmvRtCfgOutFltTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvRtCfgOutFltTable.setDescription('A list of information about the outbound RTP filters which are specified for this router node.')
ibmvRtCfgOutFltEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 4, 1, 7, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmvRtCfgOutFltNetID"), (0, "IBM6611-MIB", "ibmvRtCfgOutFltIfIndex"))
if mibBuilder.loadTexts: ibmvRtCfgOutFltEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvRtCfgOutFltEntry.setDescription('The information for each entry in the outbound RTP filter table.')
ibmvRtCfgOutFltNetID = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 4, 1, 7, 1, 1), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvRtCfgOutFltNetID.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvRtCfgOutFltNetID.setDescription('Administrator defined object which specifies the VINES network number to be filtered on the port. The range of the network number is 00000000 - FFFFFFFE. If the network number, 0xFFFFFFFF, is defined, then all network numbers will be filtered.')
ibmvRtCfgOutFltIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 4, 1, 7, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvRtCfgOutFltIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvRtCfgOutFltIfIndex.setDescription('The interface (using the MIB II standard) for which the outbound RTP filters were defined. This number corresponds to the IfIndex object found in MIB II.')
ibmvRtCfgOutFltMode = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 4, 1, 7, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("permit", 1), ("deny", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvRtCfgOutFltMode.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvRtCfgOutFltMode.setDescription("The filtering action for the outbound RTP filter. The outbound RTP filters operate on the network numbers contained in the topological entries in RTP update and response packets transmitted over a specified interface. In deny mode, filters operate on interface names and network numbers (that is, the network numbers contained in the topological entries in the RTP packets). In deny mode, the IBM 6611 does not advertise route information for a network if the network number and the interface on which the route information is to be transmitted matches any outbound RTP filter. In permit mode, the 6611 advertises route information for a network only if the network number and the interface on which the route information is to be transmitted matches any outbound RTP filter. The default for this object is 'Deny'.")
ibmvRtCfgOutFltUses = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 4, 1, 7, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvRtCfgOutFltUses.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvRtCfgOutFltUses.setDescription('The number of times the defined filter was used.')
ibmvRtCfgFlt = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 4, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvRtCfgFlt.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvRtCfgFlt.setDescription("Enables or disables all RTP router filters defined. If no RTP router filters are defined, then this object has no effect. If a filter is defined, then the default value is 'enabled'.")
ibmvRtCfgFltNum = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 4, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvRtCfgFltNum.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvRtCfgFltNum.setDescription('The number of RTP router filters currently defined.')
ibmvRtCfgFltTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 4, 1, 10), )
if mibBuilder.loadTexts: ibmvRtCfgFltTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvRtCfgFltTable.setDescription('A list of information about the RTP router filters which are specified for this router node.')
ibmvRtCfgFltEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 4, 1, 10, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmvRtCfgFltNetID"))
if mibBuilder.loadTexts: ibmvRtCfgFltEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvRtCfgFltEntry.setDescription('The information for each entry in the RTP router filter table.')
ibmvRtCfgFltNetID = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 4, 1, 10, 1, 1), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvRtCfgFltNetID.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvRtCfgFltNetID.setDescription('Administrator defined object which specifies the VINES network number to be filtered on the port. The range of the network number is 00000000 - FFFFFFFE. If the network number, 0xFFFFFFFF, is defined, then all network numbers will be filtered.')
ibmvRtCfgFltMode = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 4, 1, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("permit", 1), ("deny", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvRtCfgFltMode.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvRtCfgFltMode.setDescription("The filtering action for the RTP router filter. The RTP router filters operate on the network number contained in the source network number field in the IP header of any RTP packet (update, request, response, and redirect). (The subnetwork ID is assumed to be 0x0001.) In deny mode, the IBM 6611 ignores route information from a service node if the sending router's network number matches any RTP router filter. In permit mode, the IBM 6611 processes route information from a router only if the sending router's network number matches any RTP router filter. The default for this object is 'deny'.")
ibmvRtCfgFltUses = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 4, 1, 10, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvRtCfgFltUses.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvRtCfgFltUses.setDescription('The number of times the defined filter was used.')
ibmvRTP = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 4, 2))
ibmvrtpUpdSents = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 4, 2, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvrtpUpdSents.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvrtpUpdSents.setDescription('The number of routing update packets sent since the last reboot. The routing update packets are periodically broadcast by nodes to notify neighboring nodes of their existence. Router nodes include network topology information in these updates.')
ibmvrtpUpdRecs = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 4, 2, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvrtpUpdRecs.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvrtpUpdRecs.setDescription('The number of routing update packets received since the last reboot. The routing update packets are sent from neighboring node making known their existence. Packets received from router nodes include network topology information.')
ibmvrtpReqSents = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 4, 2, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvrtpReqSents.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvrtpReqSents.setDescription('The number of routing request packets sent since the last reboot. Routing request packets are sent by a node when it requires an immediate update.')
ibmvrtpReqRecs = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 4, 2, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvrtpReqRecs.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvrtpReqRecs.setDescription('The number of routing request packets received since the last reboot. The 6611 receives routing request packets when another node requires an immediate update. The 6611 will send the update in a routing response packet.')
ibmvrtpResSents = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 4, 2, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvrtpResSents.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvrtpResSents.setDescription('The number of routing response packets sent since the last reboot. Routing response packets are sent in response to a routing request packet.')
ibmvrtpResRecs = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 4, 2, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvrtpResRecs.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvrtpResRecs.setDescription('The number of routing response packets received since the last reboot. When a node sends out a routing request packet, it receives a routing response packet which contains all the routing information requested.')
ibmvrtpRedSents = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 4, 2, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvrtpRedSents.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvrtpRedSents.setDescription('The number of routing redirect packets sent since the last reboot. The routing redirect packets are sent by a node to notify another node of a more direct path to a destination node.')
ibmvrtpRedRecs = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 4, 2, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvrtpRedRecs.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvrtpRedRecs.setDescription('The number of routing redirect packets received since the last reboot. A 6611 receives a routing redirect packet when another node knows a more direct path to the destination node.')
ibmvrtpHeaderError = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 4, 2, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvrtpHeaderError.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvrtpHeaderError.setDescription('The number of RTP packets received since the last reboot with a RTP header error.')
ibmvRtNumber = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 4, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvRtNumber.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvRtNumber.setDescription('The number of entires in the route table.')
ibmvRtTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 4, 4), )
if mibBuilder.loadTexts: ibmvRtTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvRtTable.setDescription("A list of information about IBM's VINES router table.")
ibmvRtEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 4, 4, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmvRtNetid"))
if mibBuilder.loadTexts: ibmvRtEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvRtEntry.setDescription('The information for each entry in the router table.')
ibmvRtNetid = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 4, 4, 1, 1), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvRtNetid.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvRtNetid.setDescription("The network ID of the router node's destination router node.")
ibmvRtMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 4, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvRtMetric.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvRtMetric.setDescription('The routing metric used by the called router node to reach the destination. A routing metric is an estimated round-trip delay time associated with the router that maximum sized VINES IP packets will take to reach the destination. The metric reflects the cost of the path to the destination, it is in 200-millisecond units.')
ibmvRtIdle = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 4, 4, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvRtIdle.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvRtIdle.setDescription("The time to live timer for this router node's entry. This value indicates the amount of time before the entry is removed from the called router node's routing table. The value is returned in 90 second units.")
ibmvRtGateNetid = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 4, 4, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvRtGateNetid.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvRtGateNetid.setDescription('The network ID of the router node that acts as the router for reaching the destination router node.')
ibmvRtIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 4, 4, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvRtIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvRtIfIndex.setDescription('The interface (using the MIB II standard) which identifies the local interface through which the next hop of this route should be reached. This number corresponds to the IfIndex object found in MIB II.')
ibmvRtState = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 4, 4, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("permanent", 1), ("nonpermanent", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvRtState.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvRtState.setDescription('The state the routing entry; permanent or not permanent.')
ibmvicpExcGens = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 5, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvicpExcGens.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvicpExcGens.setDescription('Number of exception notifications generated from this router node since the last reboot.')
ibmvicpMetricGens = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 5, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvicpMetricGens.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvicpMetricGens.setDescription('The number of metric notifications generated from this router node since the last reboot. The ICP packet contains metric information about the final transmission medium used to reach a client node.')
ibmvicpHeaderError = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 5, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvicpHeaderError.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvicpHeaderError.setDescription('The number of ICP packets received since the last reboot with an ICP header error.')
ibmvFRPreassembles = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 6, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvFRPreassembles.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvFRPreassembles.setDescription('The number of times packets were reassembled since the last reboot. One VINES IP packet being broken into three message fragments is counted as one fragmentation. The three fragments being reassembled into one VINES IP packet counts as one reassembly.')
ibmvFRPfragsReassembled = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 6, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvFRPfragsReassembled.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvFRPfragsReassembled.setDescription('The number of fragments that were reassembled since the last reboot. If three fragments are to be reassembled into one packet, then this object value will add three to its total.')
ibmvFRPreasFails = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 6, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvFRPreasFails.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvFRPreasFails.setDescription('The number of times the reassembly of fragments fails since the last reboot.')
ibmvFRPfragmented = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 6, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvFRPfragmented.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvFRPfragmented.setDescription('The number of packet fragmentations performed since the last reboot.')
ibmvFRPfrgCreated = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 6, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvFRPfrgCreated.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvFRPfrgCreated.setDescription('The number of fragments created since the last reboot when fragmenting VINES IP packets. If a VINES IP packet is fragmented into three fragments, then this object value will add three to its total.')
ibmvFRPfrgFails = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 6, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvFRPfrgFails.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvFRPfrgFails.setDescription('The number of times the fragmentation of a VINES IP packets fails since the last reboot.')
ibmvPortCfgTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 7, 1), )
if mibBuilder.loadTexts: ibmvPortCfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvPortCfgTable.setDescription('The list of information about port configuration at each interface.')
ibmvPortCfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 7, 1, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmvPortCfgIfIndex"))
if mibBuilder.loadTexts: ibmvPortCfgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvPortCfgEntry.setDescription('The information for each entry in the port configuration table.')
ibmvPortCfgIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 7, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvPortCfgIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvPortCfgIfIndex.setDescription('The interface (using the MIB II standard) which uniquely identifies each interface and allows multiple tables to be associated with a given interface. This number corresponds to the IfIndex object found in MIB II.')
ibmvPortCfgARP = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 7, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvPortCfgARP.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvPortCfgARP.setDescription("Administrator defined value which specifies whether the router node will assign VINES addresses to clients that reside on the LAN attached to this port. The default value for this object is 'disable'.")
ibmvPortCfgServ = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 7, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvPortCfgServ.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvPortCfgServ.setDescription("Administrator defined value specifying whether the serverless option is enables or disabled. When the serverless option is enabled; the router looks for particular broadcasts that clients use in finding the services on the VINES server. This allows client nodes on a serverless LAN to communicate with a VINES server more than one hop away. The default value for this object is 'disable'.")
ibmvPortCfgHCtoServ = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 7, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvPortCfgHCtoServ.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvPortCfgHCtoServ.setDescription('Administrator defined value which specifies the number of hops from the client to the router node.')
ibmvPortCfgPerUpdate = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 7, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("na", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvPortCfgPerUpdate.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvPortCfgPerUpdate.setDescription('Administrator defined value which specifies whether periodic updates will be sent over a WAN link.')
ibmvPortCfgMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 7, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvPortCfgMetric.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvPortCfgMetric.setDescription('Administrator defined value for port metric. This value overrides the metric which is used by the IBM 6611 to make routing decisions. If no response is provided to this parameter, the IBM 6611 will use defaults contained within the MPNP program. These defaults are based on values assigned by Banyan Systems for its VINES servers. The port metric is a rough estimate of the round trip delay for a maximum sized VINES IP packet to travel to any neighbor on this port. The unit for the metric value is 200 milliseconds. The default metric for an Ethernet port is 2. The default metric for a Token-Ring is determined by the response to the Token-Ring Data Rate parameter. The default metric for a serial port is determined by the response to the Serial-Line Speed parameter.')
ibmvPortCfgTR = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 7, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("na", 1), ("snap", 2), ("vines-tr", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvPortCfgTR.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvPortCfgTR.setDescription('Administrator defined value which determines the encapsulation method used for receiving and transmitting VINES packets on this port. IEEE 802.5 LLC uses 802.2 encapsulation followed by an LLC field using SAP value 0xBC You cannot use IEEE 802.5 LLC encapsulation on the same port that performs data link switching, if the 0xBC SAP has been configured for frame forwarding by the data link switching function. IEEE 802.5 SNAP uses 802.2 encapsulation followed by a SNAP header using the organizationally unique ID 0x08 00 4A, the protocol id 0x80C4 for VINES IP and the protocol id 0x80C5 for VINES Link Level Echo.')
ibmvPortCfgEN = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 7, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("na", 1), ("snap", 2), ("v2", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvPortCfgEN.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvPortCfgEN.setDescription('Administrator defined value which determines the encapsulation method used for receiving and transmitting VINES packets on this port. Ethernet II uses DIX encapsulation with a packet type 0x0BAD for VINES IP and 0x0BAF for VINES Link Level Echo. IEEE 802.3 SNAP uses 802.2 encapsulation followed by a SNAP header using the organizationally unique ID 0x08 00 4A, the protocol id 0x80C4 for VINES IP and the protocol id 0x80C5 for VINES Link Level Echo.')
ibmvPortCfgInFlt = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 7, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvPortCfgInFlt.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvPortCfgInFlt.setDescription("Administrator defined value which allows inbound port filters to be defined. The default value is 'disabled'.")
ibmvPortCfgInFltNum = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 7, 1, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvPortCfgInFltNum.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvPortCfgInFltNum.setDescription('The number of inbound port filters defined for this port.')
ibmvPortCfgOutFlt = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 7, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvPortCfgOutFlt.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvPortCfgOutFlt.setDescription("Administrator defined value which allows outbound port filters to be defined. The default value is 'disabled'.")
ibmvPortCfgOutFltNum = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 7, 1, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvPortCfgOutFltNum.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvPortCfgOutFltNum.setDescription('The number of outbound port filters defined for this port.')
ibmvFltTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 7, 2), )
if mibBuilder.loadTexts: ibmvFltTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvFltTable.setDescription('The list of information about port filter configurations at each interface .')
ibmvFltEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 7, 2, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmvFltIfIndex"), (0, "IBM6611-MIB", "ibmvFltNo"))
if mibBuilder.loadTexts: ibmvFltEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvFltEntry.setDescription('The information for each entry in the port filter configuration table.')
ibmvFltIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 7, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvFltIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvFltIfIndex.setDescription('The value of this object identifies the interface for which this entry contains management information. The IfIndex allows a subset of the filter table to be associated with a particular interface.')
ibmvFltNo = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 7, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvFltNo.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvFltNo.setDescription('A unique integer identifying this filter entry for this interface.')
ibmvFltMode = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 7, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("inbound", 1), ("outbound", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvFltMode.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvFltMode.setDescription('Identifies if the port filter is an inbound or outbound filter.')
ibmvFltValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 7, 2, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(18, 18)).setFixedLength(18)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvFltValue.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvFltValue.setDescription('An octet string representing the concatenation of VINES IP header fields and VINES transport header fields required by this filter entry. Incoming packets will be bitwise ANDed with the value of ibmvFltMask, and if the result is equal to the value of this object, the packet will be filtered according to the value of ibmvFltValue. Fields from VINES IP and transport headers used for filtering: field length field name ------------ ------------------------------ 8 BITS protocol type 4 BITS hop count 32 BITS destination network number 16 BITS destination subnetwork number 16 BITS destination port number 32 BITS source network number 16 BITS source subnetwork number 16 BITS source port number')
ibmvFltMask = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 7, 2, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(18, 18)).setFixedLength(18)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvFltMask.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvFltMask.setDescription('An octet string indicating the parts of the VIP header and transport header relevant to this filter entry. This mask will be bitwise ANDed with the appropriate header fields; if the result is equal to the value of ibmvnFilterValue, the packet will be filtered according to the value of ibmvnFilterType.')
ibmvFltType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 7, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("permit", 1), ("deny", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvFltType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvFltType.setDescription('Administrator defined value which determines the filtering mode for all filters defined on this port. If the port is using Deny mode, then all packets matching a defined port filter will be discarded. If the port is using Permit mode, then only the packets matching a defined port filter will be forwarded. The default value is Deny.')
ibmvFltHCCompare = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 7, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("less-than", 1), ("less-than-equal", 2), ("equal", 3), ("greater-than-equal", 4), ("greater-than", 5), ("na", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvFltHCCompare.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvFltHCCompare.setDescription('Administrator defined value which indicates the relational association desired if filtering is being done based on hop count. If filtering is not being done based on hop count (that is, if the hop count portion of IBM VINES Port Mask is 0) the value of this object will be none(1).')
ibmvFltUses = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 7, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvFltUses.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvFltUses.setDescription('This object counts how many times the defined filter was used.')
ibmvifNumber = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 7, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvifNumber.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvifNumber.setDescription('The number of VINES interfaces configured on the router node.')
ibmvifTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 7, 4), )
if mibBuilder.loadTexts: ibmvifTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvifTable.setDescription('List of interfaces with some statistics about each interface.')
ibmvifEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 7, 4, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmvifSlot"), (0, "IBM6611-MIB", "ibmvifPort"))
if mibBuilder.loadTexts: ibmvifEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvifEntry.setDescription('Information about one interface.')
ibmvifSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 7, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvifSlot.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvifSlot.setDescription("The slot number of the interface's communications card.")
ibmvifPort = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 7, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvifPort.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvifPort.setDescription('The port number of the interface.')
ibmvifDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 7, 4, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvifDescr.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvifDescr.setDescription('A textual description of the interface.')
ibmvifAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 7, 4, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvifAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvifAddress.setDescription('The physical address of the interface, applies to LAN interfaces only.')
ibmvifInPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 7, 4, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvifInPkts.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvifInPkts.setDescription('The total number of VINES IP packets that the router node received since the last reboot.')
ibmvifInErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 7, 4, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvifInErrs.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvifInErrs.setDescription('The total number of received VINES IP packets that contained errors since the last reboot.')
ibmvifOutPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 7, 4, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvifOutPkts.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvifOutPkts.setDescription('The total number of VINES IP packets that the router node sent since the last reboot.')
ibmvifOutErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 18, 7, 4, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmvifOutErrs.setStatus('mandatory')
if mibBuilder.loadTexts: ibmvifOutErrs.setDescription('The total number of transmitted VINES IP packets that contained errors since the last reboot.')
ibmappnNode = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1))
ibmappnGeneralInfoAndCaps = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 1))
ibmappnNnUniqueInfoAndCaps = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 2))
ibmappnEnUniqueCaps = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 3))
ibmappnPortInformation = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4))
ibmappnLinkStationInformation = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5))
ibmappnSnmpInformation = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 6))
ibmappnMemoryUse = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 7))
ibmappnXidInformation = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 8))
ibmappnNodeCpName = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeCpName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeCpName.setDescription('Administratively-assigned network name for this node in the format NETID.CPNAME.')
ibmappnNodeNetid = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeNetid.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeNetid.setDescription('Administratively-assigned APPN network identification, which can be from one to eight characters. This ID is used with the control point name to create a fully-qualified control point name.')
ibmappnNodeBlockNum = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 3)).setFixedLength(3)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeBlockNum.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeBlockNum.setDescription('The block number is the first three digits of the node_id. These 3 hexadecimal digits identify the product and are not configurable.')
ibmappnNodeIdNum = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(5, 5)).setFixedLength(5)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeIdNum.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeIdNum.setDescription('The ID number is the last 5 digits of the node_id. These 5 hexadecimal digits are administratively defined and combined with the 3 digit block number form the node_id. This node_id is used to identify the local node and is include in APPN alerts as well as being included in XIDs. A unique value is required for connections to SNA sub-area.')
ibmappnNodeType = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4))).clone(namedValues=NamedValues(("networkNode", 1), ("endNode", 2), ("len", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeType.setDescription('Type of APPN node, either network, len, or end node.')
ibmappnNodeUpTime = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 1, 6), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeUpTime.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeUpTime.setDescription('Time (in hundredths of a second) since this APPN node was initialized.')
ibmappnNodeNegotLs = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeNegotLs.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeNegotLs.setDescription('Indicates whether this node supports negotiable link stations.')
ibmappnNodeSegReasm = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeSegReasm.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeSegReasm.setDescription('Indicates whether this node supports segment reassembly. This is only supported when segment generation is also supported.')
ibmappnNodeBindReasm = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeBindReasm.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeBindReasm.setDescription('Indicates whether this node supports Bind segment reassembly. This will only be supported when Bind segment generation is also supported.')
ibmappnNodeParallelTg = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeParallelTg.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeParallelTg.setDescription('Indicates whether this node supports parallel TGs.')
ibmappnNodeService = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeService.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeService.setDescription('Indicates whether this node allows call-in from nodes not defined locally.')
ibmappnNodeAdaptiveBindPacing = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeAdaptiveBindPacing.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeAdaptiveBindPacing.setDescription('Indicates whether this node supports adaptive bind pacing.')
ibmappnNodeNnRcvRegChar = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeNnRcvRegChar.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeNnRcvRegChar.setDescription('Indicates whether this node supports receiving registered characteristics.')
ibmappnNodeNnGateway = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeNnGateway.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeNnGateway.setDescription('Indicates whether this is a gateway node.')
ibmappnNodeNnCentralDirectory = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeNnCentralDirectory.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeNnCentralDirectory.setDescription('Indicates whether this node supports central directory cache.')
ibmappnNodeNnTreeCache = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 2, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeNnTreeCache.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeNnTreeCache.setDescription('Indicates whether this node supports route tree cache.')
ibmappnNodeNnTreeUpdate = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 2, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeNnTreeUpdate.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeNnTreeUpdate.setDescription('Indicates whether this node supports incremental_tree_update, which is only supported when tree caching is supported.')
ibmappnNodeNnRouteAddResist = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 2, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeNnRouteAddResist.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeNnRouteAddResist.setDescription('Route addition resistance is a value that indicates the relative desirability of using this node for intermediate session traffic. The value, which can be any integer 0-255, is used in route computation. The lower the value, the more desirable the node is for intermediate routing.')
ibmappnNodeNnIsr = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 2, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeNnIsr.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeNnIsr.setDescription('Indicates whether the node supports intermediate session routing.')
ibmappnNodeNnFrsn = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 2, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeNnFrsn.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeNnFrsn.setDescription('Flow reduction sequence numbers (FRSNs) are associated with Topology Database Updates (TDUs) and are unique only within each APPN network node. A TDU can be associated with multiple APPN resources. This object is the last FRSN sent in a topology update to adjacent network nodes.')
ibmappnNodeEnSegGen = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeEnSegGen.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeEnSegGen.setDescription('Indicates whether this end node supports segment generation.')
ibmappnNodeEnModeCosMap = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 3, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeEnModeCosMap.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeEnModeCosMap.setDescription('Indicates whether this end node supports mode name to COS name mapping.')
ibmappnNodeEnLocateCdinit = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 3, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeEnLocateCdinit.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeEnLocateCdinit.setDescription('Indicates whether this end node supports Locate Cdinit.')
ibmappnNodeEnSendRegNames = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 3, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeEnSendRegNames.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeEnSendRegNames.setDescription('Indicates whether the node will register its LUs with the adjacent serving network node: NO - do not register names YES - register names')
ibmappnNodeEnSendRegChar = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 3, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeEnSendRegChar.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeEnSendRegChar.setDescription('Indicates whether this node supports send register characteristics, which is only supported when send registered names is also supported.')
ibmappnNodePortTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4, 1), )
if mibBuilder.loadTexts: ibmappnNodePortTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodePortTable.setDescription('The Port table describes the configuration and current status of the ports used by APPN. The type of DLC is included in this table as a pointer to the DLC port specific tables.')
ibmappnNodePortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4, 1, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmappnNodePortName"))
if mibBuilder.loadTexts: ibmappnNodePortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodePortEntry.setDescription('The Port Name is used as the index to this table.')
ibmappnNodePortName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodePortName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodePortName.setDescription('Administratively-assigned name for this APPN port. The name can be from one to eight characters.')
ibmappnNodePortState = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("inactive", 1), ("pendactive", 2), ("active", 3), ("pendinact", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmappnNodePortState.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodePortState.setDescription('Indicates the current state of this port.')
ibmappnNodePortDlcType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("sdlc", 2), ("dls", 3), ("socket", 4), ("ethernet", 5), ("tokenRing", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodePortDlcType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodePortDlcType.setDescription("The type of DLC interface, distinguished according to the protocol immediately 'below' this layer.")
ibmappnNodePortPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("leased", 1), ("switched", 2), ("sharedAccessFacilities", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodePortPortType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodePortPortType.setDescription('Identifies the type of line used by this port.')
ibmappnNodePortSIMRIM = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodePortSIMRIM.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodePortSIMRIM.setDescription('Indicates whether Set Initialization Mode (SIM) and Receive Initialization Mode (RIM) are supported.')
ibmappnNodePortLsRole = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("primary", 1), ("secondary", 2), ("negotiable", 3), ("abm", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodePortLsRole.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodePortLsRole.setDescription("Initial role for LSs activated through this port, where 'abm' indicates asynchronous balance mode.")
ibmappnNodePortMaxRcvBtuSize = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodePortMaxRcvBtuSize.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodePortMaxRcvBtuSize.setDescription('Maximum Basic Transmission Size (BTU) that a link station on this port can receive.')
ibmappnNodePortMaxIframeWindow = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodePortMaxIframeWindow.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodePortMaxIframeWindow.setDescription('Maximum number of I-frames that can be received by the XID sender before an acknowledgement is received.')
ibmappnNodePortDefLsGoodXids = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodePortDefLsGoodXids.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodePortDefLsGoodXids.setDescription('The total number of successfull XIDs that have occurred on all defined link stations on this port since the last time this port was started.')
ibmappnNodePortDefLsBadXids = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodePortDefLsBadXids.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodePortDefLsBadXids.setDescription('The total number of unsuccessfull XIDs that have occurred on all defined link stations on this port since the last time this port was started.')
ibmappnNodePortDynLsGoodXids = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodePortDynLsGoodXids.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodePortDynLsGoodXids.setDescription('The total number of successfull XIDs that have occurred on all dynamic link stations on this port since the last time this port was started.')
ibmappnNodePortDynLsBadXids = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodePortDynLsBadXids.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodePortDynLsBadXids.setDescription('The total number of unsuccessfull XIDs that have occurred on all dynamic link stations on this port since the last time this port was started.')
ibmappnNodePortSpecific = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4, 1, 1, 13), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodePortSpecific.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodePortSpecific.setDescription('Identifies the port specific OBJECT IDENTIFIER that can provide additional information.')
ibmappnNodePortIpTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4, 2), )
if mibBuilder.loadTexts: ibmappnNodePortIpTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodePortIpTable.setDescription('Port table (TCP/IP specific).')
ibmappnNodePortIpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4, 2, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmappnNodePortIpName"))
if mibBuilder.loadTexts: ibmappnNodePortIpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodePortIpEntry.setDescription('The IP Name is used as the index to this table.')
ibmappnNodePortIpName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4, 2, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodePortIpName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodePortIpName.setDescription('Administratively-assigned name for this APPN port. The name can be from one to eight characters.')
ibmappnNodePortIpPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodePortIpPortNum.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodePortIpPortNum.setDescription('Local TCP/IP port number.')
ibmappnNodePortDlsTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4, 3), )
if mibBuilder.loadTexts: ibmappnNodePortDlsTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodePortDlsTable.setDescription('Port table (DLS specific).')
ibmappnNodePortDlsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4, 3, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmappnNodePortDlsName"))
if mibBuilder.loadTexts: ibmappnNodePortDlsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodePortDlsEntry.setDescription('The DLS Name is used as the index to this table.')
ibmappnNodePortDlsName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4, 3, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodePortDlsName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodePortDlsName.setDescription('Administratively-assigned name for this APPN DLS port. The name can be from one to eight characters.')
ibmappnNodePortDlsMac = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4, 3, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodePortDlsMac.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodePortDlsMac.setDescription('Local DLS MAC address.')
ibmappnNodePortDlsSap = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4, 3, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodePortDlsSap.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodePortDlsSap.setDescription('Local DLS Sap address.')
ibmappnNodePortTrTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4, 4), )
if mibBuilder.loadTexts: ibmappnNodePortTrTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodePortTrTable.setDescription('Port table (Token Ring specific).')
ibmappnNodePortTrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4, 4, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmappnNodePortTrName"))
if mibBuilder.loadTexts: ibmappnNodePortTrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodePortTrEntry.setDescription('The TR Name is used as the index to this table.')
ibmappnNodePortTrName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4, 4, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodePortTrName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodePortTrName.setDescription('Administratively-assigned name for this APPN port. The name can be from one to eight characters.')
ibmappnNodePortTrMac = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4, 4, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodePortTrMac.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodePortTrMac.setDescription('Local Token Ring MAC address.')
ibmappnNodePortTrSap = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4, 4, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodePortTrSap.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodePortTrSap.setDescription('Local Token Ring Sap address.')
ibmappnNodePortDlcTraceTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4, 5), )
if mibBuilder.loadTexts: ibmappnNodePortDlcTraceTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodePortDlcTraceTable.setDescription('Port table generic DLC trace table.')
ibmappnNodePortDlcTraceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4, 5, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmappnNodePortDlcTracPortName"), (0, "IBM6611-MIB", "ibmappnNodePortDlcTracIndex"))
if mibBuilder.loadTexts: ibmappnNodePortDlcTraceEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodePortDlcTraceEntry.setDescription('The Port name and a dynamic integer are the index to this table.')
ibmappnNodePortDlcTracPortName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4, 5, 1, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodePortDlcTracPortName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodePortDlcTracPortName.setDescription('The Port name associated with this this trace table entry.')
ibmappnNodePortDlcTracIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4, 5, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodePortDlcTracIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodePortDlcTracIndex.setDescription('This index value is updated every time a new trace entry is created which provides a means to retrieve only the updated entries and also provides a simple method of correlating the entries. The table will wrap when the table is full, which will result in previous entries being written over. The mangement station can over come this by retrieving the table using this index to retrieve only the new table entries.')
ibmappnNodePortDlcTracDlcType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("sdlc", 2), ("dls", 3), ("socket", 4), ("ethernet", 5), ("tokenRing", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodePortDlcTracDlcType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodePortDlcTracDlcType.setDescription("The type of DLC interface, distinguished according to the protocol immediately 'below' this layer.")
ibmappnNodePortDlcTracLocalAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4, 5, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodePortDlcTracLocalAddr.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodePortDlcTracLocalAddr.setDescription('Local address in format described below: other = free form DisplayString ip = ld.ld.ld.ld/2d tr = lx:lx:lx:lx:lx:lx.lx dlsw = lx:lx:lx:lx:lx:lx.lx ethernet = lx:lx:lx:lx:lx:lx.lx ')
ibmappnNodePortDlcTracRemoteAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4, 5, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodePortDlcTracRemoteAddr.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodePortDlcTracRemoteAddr.setDescription('Remote Address in the format described below: other = free form DisplayString ip = ld.ld.ld.ld/2d tr = lx:lx:lx:lx:lx:lx.lx dlsw = lx:lx:lx:lx:lx:lx.lx ethernet = lx:lx:lx:lx:lx:lx.lx ')
ibmappnNodePortDlcTracMsgType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4, 5, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("unknown", 2), ("request", 3), ("confirm", 4), ("indication", 5), ("response", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodePortDlcTracMsgType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodePortDlcTracMsgType.setDescription('Indicates the type of trace record entry')
ibmappnNodePortDlcTracCmdType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4, 5, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2024, 2025, 2026, 2027, 2028, 2029, 4122, 4123, 4124, 6001, 6002, 6003, 6004, 6005, 6006, 6007, 6008, 6009, 6010, 6012, 6013, 6014, 6015, 6016, 6017, 6018, 6019, 6020, 6021, 6022, 6023, 6024, 6025, 6026, 6027, 6028, 6029))).clone(namedValues=NamedValues(("testFrame", 1), ("respFrame", 2), ("curFrame", 3), ("icrFrame", 4), ("respAck", 5), ("dgrmFrame", 6), ("xidFrame", 7), ("contFrame", 8), ("contedFrame", 9), ("iFrame", 10), ("enterBusy", 12), ("exitBusy", 13), ("haltFrame", 14), ("lsHalted", 15), ("restartLs", 16), ("lsRestarted", 17), ("netBioSnq", 18), ("netBioSnr", 19), ("gnetFrame", 20), ("netdFrame", 21), ("oobFrame", 22), ("alterSap", 23), ("testRsp", 24), ("haltLsNow", 25), ("netBioAnq", 26), ("netBioAnr", 27), ("mibLsFrame", 28), ("iamOkay", 29), ("ipTestFrame", 2001), ("ipRespFrame", 2002), ("ipCurFrame", 2003), ("ipIcrFrame", 2004), ("ipRespAck", 2005), ("ipDgrmFrame", 2006), ("ipXidFrame", 2007), ("ipContFrame", 2008), ("ipContedFrame", 2009), ("ipIFrame", 2010), ("ipEnterBusy", 2012), ("ipExitBusy", 2013), ("ipHaltFrame", 2014), ("ipLsHalted", 2015), ("ipRestartLs", 2016), ("ipLsRestarted", 2017), ("ipNetBioSnq", 2018), ("ipNetBioSnr", 2019), ("ipGnetFrame", 2020), ("ipNetdFrame", 2021), ("ipOobFrame", 2022), ("ipAlterSap", 2023), ("ipTestRsp", 2024), ("ipHaltLsNow", 2025), ("ipNetBioAnq", 2026), ("ipNetBioAnr", 2027), ("ipMibLsFrame", 2028), ("ipIamOkay", 2029), ("dlsTestReq", 4122), ("dlsTestRsp", 4123), ("dlsIpm", 4124), ("trTestFrame", 6001), ("trRespFrame", 6002), ("trCurFrame", 6003), ("trIcrFrame", 6004), ("trRespAck", 6005), ("trDgrmFrame", 6006), ("trXidFrame", 6007), ("trContFrame", 6008), ("trContedFrame", 6009), ("trIFrame", 6010), ("trEnterBusy", 6012), ("trExitBusy", 6013), ("trHaltFrame", 6014), ("trLsHalted", 6015), ("trRestartLs", 6016), ("trLsRestarted", 6017), ("trNetBioSnq", 6018), ("trNetBioSnr", 6019), ("trGnetFrame", 6020), ("trNetdFrame", 6021), ("trOobFrame", 6022), ("trAlterSap", 6023), ("trTestRsp", 6024), ("trHaltLsNow", 6025), ("trNetBioAnq", 6026), ("trNetBioAnr", 6027), ("trMibLsFrame", 6028), ("trIamOkay", 6029)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodePortDlcTracCmdType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodePortDlcTracCmdType.setDescription('Indicates the command type of the trace entry.')
ibmappnNodePortDlcTracUseWan = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4, 5, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("notApplicable", 2), ("useUnknown", 3), ("useWan", 4), ("useLan", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodePortDlcTracUseWan.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodePortDlcTracUseWan.setDescription(' ')
ibmappnNodeLsTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1), )
if mibBuilder.loadTexts: ibmappnNodeLsTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsTable.setDescription('This table contains detail information about the link station configuration and current status.')
ibmappnNodeLsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmappnNodeLsName"))
if mibBuilder.loadTexts: ibmappnNodeLsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsEntry.setDescription('This table is indexed by the link station name.')
ibmappnNodeLsName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsName.setDescription('Administratively-assigned name for the link station. The name can be from one to eight characters.')
ibmappnNodeLsPortName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsPortName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsPortName.setDescription('Administratively-assigned name for the port. The name can be from one to eight characters.')
ibmappnNodeLsDlcType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("sdlc", 2), ("dls", 3), ("socket", 4), ("ethernet", 5), ("tokenRing", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsDlcType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsDlcType.setDescription("The type of DLC interface, distinguished according to the protocol immediately 'below' this layer.")
ibmappnNodeLsDynamic = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsDynamic.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsDynamic.setDescription('Identifies whether this resource is a dynamic link station. Dynamic link stations are created when adjacent nodes that have not been locally defined establish a connection with this node.')
ibmappnNodeLsState = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("inactive", 1), ("pendactive", 2), ("active", 3), ("pendinact", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmappnNodeLsState.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsState.setDescription('State of this link station.')
ibmappnNodeLsCpName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsCpName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsCpName.setDescription('Fully-qualified name of the adjacent node for this link station. The name can be from three to seventeen characters. Format is netid.cpname.')
ibmappnNodeLsTgNum = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsTgNum.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsTgNum.setDescription('Number associated with the TG to this link station.')
ibmappnNodeLsLimResource = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsLimResource.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsLimResource.setDescription('Indicates whether the link station is a limited resource. If it is, the TG is deactivated when there are no sessions.')
ibmappnNodeLsMigration = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsMigration.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsMigration.setDescription('Indicates whether this link station will be used for connections to down-level or migration partners.')
ibmappnNodeLsBlockNum = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 3)).setFixedLength(3)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsBlockNum.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsBlockNum.setDescription('The block number is the first three digits of the node_id. These 3 hexideimal digits identify the product and are not configurable.')
ibmappnNodeLsIdNum = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(5, 5)).setFixedLength(5)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsIdNum.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsIdNum.setDescription('The ID number is the last 5 digits of the node_id. These 5 hexadecimal digits are administratively defined and combined with the 3 digit block number form the node_id. This node_id is used to identify the local node and is include in APPN alerts as well as being included in XIDs. A unique value is required for connections to SNA sub-area.')
ibmappnNodeLsCpCpSession = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsCpCpSession.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsCpCpSession.setDescription('Indicates whether CP-CP sessions are supported by this link station.')
ibmappnNodeLsTargetPacingCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsTargetPacingCount.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsTargetPacingCount.setDescription('Numeric value between 0 and 32767 inclusive indicating the desired pacing window size for BINDs on this TG. The number is significant only when fixed bind pacing is being performed.')
ibmappnNodeLsMaxSendBtuSize = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsMaxSendBtuSize.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsMaxSendBtuSize.setDescription('Numeric value between 0 and 32767 inclusive indicating the desired number of bytes in a Basic Transmission Unit (BTU) that can be sent on this TG. This is an administratively assigned value.')
ibmappnNodeLsEffCap = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsEffCap.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsEffCap.setDescription('The effective capacity is an integer value that indicates the kilo bits per second. It is derived from the link bandwidth and maximum load factor with the range of 0 thru 603,979,776. This is an administratively assigned value associated with the TG using this link station.')
ibmappnNodeLsConnCost = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsConnCost.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsConnCost.setDescription('Cost per connect time: a value representing the relative cost per unit of time to use the TG. Range is from 0, which means no cost, to 255, which indicates maximum cost. This is an administratively assigned value associated with the TG using this link station.')
ibmappnNodeLsByteCost = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsByteCost.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsByteCost.setDescription('Relative cost of transmitting a byte over this link. Range is from 0 (lowest cost) to 255. This is an administratively assigned value associated with the TG using this link station.')
ibmappnNodeLsSecurity = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 32, 64, 96, 128, 160, 192))).clone(namedValues=NamedValues(("nonsecure", 1), ("publicSwitchedNetwork", 32), ("undergroundCable", 64), ("secureConduit", 96), ("guardedConduit", 128), ("encrypted", 160), ("guardedRadiation", 192)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsSecurity.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsSecurity.setDescription('The security is represented as an integer with a range of 1 thru 255 with the most common values enumerated as defined above. This is an administratively assigned value associated with the TG using this link station.')
ibmappnNodeLsDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 384, 9216, 147456, 294912, 2013265920))).clone(namedValues=NamedValues(("minimum", 1), ("negligible", 384), ("terrestrial", 9216), ("packet", 147456), ("long", 294912), ("maximum", 2013265920)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsDelay.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsDelay.setDescription('Relative amount of time that it takes for a signal to travel the length of the logical link. This time is represented in micro seconds, with some of the more common values enumerated. This is an administratively assigned value associated with the TG using this link station.')
ibmappnNodeLsUsr1 = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsUsr1.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsUsr1.setDescription('First user-defined TG characteristic for this TG with a range of 0-255. This is an administratively assigned value associated with the TG using this link station.')
ibmappnNodeLsUsr2 = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsUsr2.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsUsr2.setDescription('Second user-defined TG characteristic for this TG with a range of 0-255. This is an administratively assigned value associated with the TG using this link station.')
ibmappnNodeLsUsr3 = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsUsr3.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsUsr3.setDescription('Third user-defined TG characteristic for this TG with a range of 0-255. This is an administratively assigned value associated with the TG using this link station.')
ibmappnNodeLsInXidBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsInXidBytes.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsInXidBytes.setDescription('Number of XID bytes received.')
ibmappnNodeLsInMsgBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsInMsgBytes.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsInMsgBytes.setDescription('Number of message (I-frame) bytes received.')
ibmappnNodeLsInXidFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsInXidFrames.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsInXidFrames.setDescription('Number of XID frames received.')
ibmappnNodeLsInMsgFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsInMsgFrames.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsInMsgFrames.setDescription('Number of message (I-frame) frames received.')
ibmappnNodeLsOutXidBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsOutXidBytes.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsOutXidBytes.setDescription('Number of XID bytes sent.')
ibmappnNodeLsOutMsgBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsOutMsgBytes.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsOutMsgBytes.setDescription('Number of message (I-frame) bytes sent.')
ibmappnNodeLsOutXidFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsOutXidFrames.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsOutXidFrames.setDescription('Number of XID frames sent.')
ibmappnNodeLsOutMsgFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsOutMsgFrames.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsOutMsgFrames.setDescription('Number of message (I-frame) frames sent.')
ibmappnNodeLsEchoRsps = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsEchoRsps.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsEchoRsps.setDescription('Number of responses returned from adjacent link station. A response should be returned for each test frame sent by this node. Test frames are sent to adjacent nodes periodically to verify connectivity and to measure that actual round trip time, that is the time the test frame is sent until the response is received.')
ibmappnNodeLsCurrentDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 32), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsCurrentDelay.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsCurrentDelay.setDescription('The time that it took for the last test signal to be sent and returned from this link station to the adjacent links station. This time is represented in milliseconds.')
ibmappnNodeLsMaxDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 33), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsMaxDelay.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsMaxDelay.setDescription('The longest time it took for a test signal to be sent and returned from this link station to the adjacent links station. This time is represented in milliseconds .')
ibmappnNodeLsMinDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 34), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsMinDelay.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsMinDelay.setDescription('The shortest time it took for a test signal to be sent and returned from this link station to the adjacent links station. This time is represented in milliseconds.')
ibmappnNodeLsMaxDelayTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 35), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsMaxDelayTime.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsMaxDelayTime.setDescription('The time (since system up in hundredth of seconds) when the longest delay occurred. This time can be used to identify when this high water mark occurred in relation to the last initialization of the APPN node.')
ibmappnNodeLsGoodXids = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 36), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsGoodXids.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsGoodXids.setDescription('The total number of successful XIDs that have occurred on this link station since the time it was started.')
ibmappnNodeLsBadXids = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 37), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsBadXids.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsBadXids.setDescription('The total number of unsuccessful XIDs that have occurred on this link station since the time it was started.')
ibmappnNodeLsSpecific = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 38), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsSpecific.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsSpecific.setDescription('Identifies the DLC specific OBJECT IDENTIFIER that can provide additional information.')
ibmappnNodeLsSubState = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 39), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))).clone(namedValues=NamedValues(("inactive", 1), ("sentReqOpnstn", 2), ("pendXidExch", 3), ("sentActAs", 4), ("sentSetMode", 5), ("active", 6), ("sentDeactAsOrd", 7), ("sentDiscOrd", 8), ("sentDestroyTg", 9), ("sentCreateTg", 10), ("sentConnReq", 11), ("pendRcvConnInd", 12), ("pendSendConnRsp", 13), ("sentConnRsp", 14), ("pendDeact", 15)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsSubState.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsSubState.setDescription('State of this link station.')
ibmappnNodeLsStartTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 40), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsStartTime.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsStartTime.setDescription('The time (in hundredth of seconds) this link station has been active the last time since the time APPN was initialized.')
ibmappnNodeLsActiveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 41), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsActiveTime.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsActiveTime.setDescription('The time (in hundredth of seconds) this link station has been in the active state. A zero value indicates the link station has never been active.')
ibmappnNodeLsCurrentStateTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 42), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsCurrentStateTime.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsCurrentStateTime.setDescription('The time (in hundredth of seconds) the link station is in the current state.')
ibmappnNodeLsIpTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 2), )
if mibBuilder.loadTexts: ibmappnNodeLsIpTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsIpTable.setDescription('Link station table (TCP/IP specific).')
ibmappnNodeLsIpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 2, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmappnNodeLsIpName"))
if mibBuilder.loadTexts: ibmappnNodeLsIpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsIpEntry.setDescription('The IP Name is used as the index to this table.')
ibmappnNodeLsIpName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 2, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsIpName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsIpName.setDescription('Administratively-assigned name for this link station. The name can be from one to eight characters.')
ibmappnNodeLsIpState = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("inactive", 1), ("pendactive", 2), ("active", 3), ("pendinact", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsIpState.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsIpState.setDescription('State of this link station.')
ibmappnNodeLsLocalIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 2, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsLocalIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsLocalIpAddr.setDescription('Local IP address.')
ibmappnNodeLsLocalIpPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsLocalIpPortNum.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsLocalIpPortNum.setDescription('Local TCP/IP port number. The default listening port will be administratively assigned and will dynamically change if this node initiates a session with adjacent node.')
ibmappnNodeLsRemoteIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 2, 1, 5), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsRemoteIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsRemoteIpAddr.setDescription('Remote IP address.')
ibmappnNodeLsRemoteIpPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsRemoteIpPortNum.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsRemoteIpPortNum.setDescription('Remote TCP/IP port number.')
ibmappnNodeLsDlsTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 3), )
if mibBuilder.loadTexts: ibmappnNodeLsDlsTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsDlsTable.setDescription('Ls Table (DLS specific).')
ibmappnNodeLsDlsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 3, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmappnNodeLsDlsName"))
if mibBuilder.loadTexts: ibmappnNodeLsDlsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsDlsEntry.setDescription('The DLS Name is used as the index to this table.')
ibmappnNodeLsDlsName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 3, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsDlsName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsDlsName.setDescription('Administratively-assigned name for this link station. The name can be from one to eight characters.')
ibmappnNodeLsDlsState = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("inactive", 1), ("pendactive", 2), ("active", 3), ("pendinact", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsDlsState.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsDlsState.setDescription('State of this link station.')
ibmappnNodeLsLocalDlsMac = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 3, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsLocalDlsMac.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsLocalDlsMac.setDescription('Local MAC address.')
ibmappnNodeLsLocalDlsSap = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 3, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsLocalDlsSap.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsLocalDlsSap.setDescription('Local SAP address.')
ibmappnNodeLsRemoteDlsMac = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 3, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsRemoteDlsMac.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsRemoteDlsMac.setDescription('Remote MAC address.')
ibmappnNodeLsRemoteDlsSap = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 3, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsRemoteDlsSap.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsRemoteDlsSap.setDescription('Remote SAP address.')
ibmappnNodeLsTrTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 4), )
if mibBuilder.loadTexts: ibmappnNodeLsTrTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsTrTable.setDescription('Ls Table (Token Ring specific).')
ibmappnNodeLsTrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 4, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmappnNodeLsTrName"))
if mibBuilder.loadTexts: ibmappnNodeLsTrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsTrEntry.setDescription('The TR Name is used as the index to this table.')
ibmappnNodeLsTrName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 4, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsTrName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsTrName.setDescription('Administratively-assigned name for this link station. The name can be from one to eight characters.')
ibmappnNodeLsTrState = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("inactive", 1), ("pendactive", 2), ("active", 3), ("pendinact", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsTrState.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsTrState.setDescription('State of this link station.')
ibmappnNodeLsLocalTrMac = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 4, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsLocalTrMac.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsLocalTrMac.setDescription('Local MAC address.')
ibmappnNodeLsLocalTrSap = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 4, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsLocalTrSap.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsLocalTrSap.setDescription('Local SAP address.')
ibmappnNodeLsRemoteTrMac = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 4, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsRemoteTrMac.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsRemoteTrMac.setDescription('Remote MAC address.')
ibmappnNodeLsRemoteTrSap = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 4, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsRemoteTrSap.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsRemoteTrSap.setDescription('Remote SAP address.')
ibmappnNodeLsStatusTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 5), )
if mibBuilder.loadTexts: ibmappnNodeLsStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsStatusTable.setDescription('This table contains information related to exceptional and potential exceptional conditions that occur during the activation, XID exchange, and termination of the connection.')
ibmappnNodeLsStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 5, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmappnNodeLsStatusIndex"))
if mibBuilder.loadTexts: ibmappnNodeLsStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsStatusEntry.setDescription('This table is indexed by the LsStatusIndex, which is an integer that is continuously updated until it eventually wraps. This provides the management station the ability to retrieve only the updates to the table by using the standard GET NEXT.')
ibmappnNodeLsStatusIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsStatusIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsStatusIndex.setDescription('Table index. The value of the index begins at zero and is incremented up to a maximum value of 2**31-1 (2,147,483,647) before wrapping.')
ibmappnNodeLsStatusTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 5, 1, 2), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsStatusTime.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsStatusTime.setDescription('Time (in hundreds of a second) since this node was last initialized.')
ibmappnNodeLsStatusLsName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 5, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsStatusLsName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsStatusLsName.setDescription('Administratively-assigned name for this link station.')
ibmappnNodeLsStatusCpName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 5, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 18))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsStatusCpName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsStatusCpName.setDescription('Administratively-assigned fully-qualified name of the adjacent node partner. This will be provided when the adjacent node has been defined at this node or when the XID sequence has proceeded far enough to to identify the adjacent node. A blank CP name will indicate the name is unknown.')
ibmappnNodeLsStatusNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 5, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsStatusNodeId.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsStatusNodeId.setDescription('Adjacent Node id')
ibmappnNodeLsStatusTgNum = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 5, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsStatusTgNum.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsStatusTgNum.setDescription('Number associated with the TG to this link station with a range from 0 to 256. A value of 256 indicates the tg number has not been negotiated and is unknown at this time.')
ibmappnNodeLsStatusGeneralSense = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 5, 1, 7), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsStatusGeneralSense.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsStatusGeneralSense.setDescription('The error sense code associated with the start sequence of activation of a link up to the beginning of the XID sequence.')
ibmappnNodeLsStatusNofRetry = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 5, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("retry", 1), ("noretry", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsStatusNofRetry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsStatusNofRetry.setDescription('Indicates whether NOF will retry the start request to activate the link.')
ibmappnNodeLsStatusEndSense = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 5, 1, 9), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsStatusEndSense.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsStatusEndSense.setDescription('The sense code associated with the termination of the link connection to adjacent node. This includes all sense information included in the disconnect recieved from the lower layer DLCs and also sense information indicating the link termination originated by upper layer APPN components.')
ibmappnNodeLsStatusXidLocalSense = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 5, 1, 10), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsStatusXidLocalSense.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsStatusXidLocalSense.setDescription('The error sense code associated with the rejection of the XID.')
ibmappnNodeLsStatusXidRemoteSense = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 5, 1, 11), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsStatusXidRemoteSense.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsStatusXidRemoteSense.setDescription('The error sense code adjacent node returned to this node indicating the reason the XID was rejected.')
ibmappnNodeLsStatusXidByteInError = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 5, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1000))).clone(namedValues=NamedValues(("na", 1000)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsStatusXidByteInError.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsStatusXidByteInError.setDescription('This identifies the actual byte in the XID that caused the error. The value of zero (0) indicates that the variable has no meaning.')
ibmappnNodeLsStatusXidBitInError = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 5, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(8))).clone(namedValues=NamedValues(("na", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsStatusXidBitInError.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsStatusXidBitInError.setDescription('This identifies the actual bit within the error byte of the XID. This only has meaning when the byte in error is greater than zero.')
ibmappnNodeLsStatusDlcType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 5, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("sdlc", 2), ("dls", 3), ("socket", 4), ("ethernet", 5), ("tr", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsStatusDlcType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsStatusDlcType.setDescription('This identifies DLC type that was being used when error occurred. This also is used to the format of the local and remote address provided. other = free form DisplayString ip = ld.ld.ld.ld/2d tr = lx:lx:lx:lx:lx:lx.lx dlsw = lx:lx:lx:lx:lx:lx.lx ethernet = lx:lx:lx:lx:lx:lx.lx ')
ibmappnNodeLsStatusLocalAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 5, 1, 15), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsStatusLocalAddr.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsStatusLocalAddr.setDescription('This contains a displayable string that identifies the DLC type and appropriate address. See DlcType above for details of the format.')
ibmappnNodeLsStatusRemoteAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 5, 1, 16), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsStatusRemoteAddr.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsStatusRemoteAddr.setDescription('This contains a displayable string that identifies the DLC type and appropriate address. See DlcType above for details of the format.')
ibmappnSnmpInPkts = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 6, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnSnmpInPkts.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnSnmpInPkts.setDescription('Total number of messages delivered to the APPN SNMP sub-agent.')
ibmappnSnmpInGetRequests = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 6, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnSnmpInGetRequests.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnSnmpInGetRequests.setDescription('Total number of GET requests delivered to the APPN SNMP sub-agent.')
ibmappnSnmpInGetNexts = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 6, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnSnmpInGetNexts.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnSnmpInGetNexts.setDescription('Total number of GETNEXT requests delivered to the APPN SNMP sub-agent.')
ibmappnSnmpInSetRequests = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 6, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnSnmpInSetRequests.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnSnmpInSetRequests.setDescription('Total number of SET requests delivered to the APPN SNMP sub-agent.')
ibmappnSnmpInTotalVars = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 6, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnSnmpInTotalVars.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnSnmpInTotalVars.setDescription('Total number of VARIABLES included in both GET and GETNEXT requests to the APPN SNMP sub-agent.')
ibmappnSnmpInGetVars = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 6, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnSnmpInGetVars.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnSnmpInGetVars.setDescription('Total number of VARIBLES included in all GET requests to the APPN SNMP sub-agent.')
ibmappnSnmpInGetNextVars = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 6, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnSnmpInGetNextVars.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnSnmpInGetNextVars.setDescription('Total number of VARIABLES included in all GETNEXT requests to the APPN SNMP sub-agent.')
ibmappnSnmpInSetVars = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 6, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnSnmpInSetVars.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnSnmpInSetVars.setDescription('Total number of VARIBLES included in all SET requests to the APPN SNMP sub-agent.')
ibmappnSnmpOutNoSuchNames = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 6, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnSnmpOutNoSuchNames.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnSnmpOutNoSuchNames.setDescription('Total number of VARIABLES that could not be found by the APPN SNMP sub-agent.')
ibmappnSnmpOutGenErrs = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 6, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnSnmpOutGenErrs.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnSnmpOutGenErrs.setDescription('Total number of undefined errors that occurred processing SNMP request to the APPN SNMP sub-agent.')
ibmappnMemorySize = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 7, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnMemorySize.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnMemorySize.setDescription('Size of the shared storage segment, as obtained by storage management from the underlying operating system.')
ibmappnMemoryUsed = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 7, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnMemoryUsed.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnMemoryUsed.setDescription('Number of bytes in the segment that are currently allocated to process.')
ibmappnMemoryWarnThresh = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 7, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnMemoryWarnThresh.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnMemoryWarnThresh.setDescription('Allocation threshold beyond which storage management considers the storage resources to be constrained.')
ibmappnMemoryCritThresh = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 7, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnMemoryCritThresh.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnMemoryCritThresh.setDescription('Allocation threshold beyond which storage management considers the storage resources to be critically constrained.')
ibmappnNodeDefLsGoodXids = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 8, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeDefLsGoodXids.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeDefLsGoodXids.setDescription('The current number of successfull XIDs that have occurred on all defined link stations since the last time this node was initialized.')
ibmappnNodeDefLsBadXids = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 8, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeDefLsBadXids.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeDefLsBadXids.setDescription('The current number of unsuccessfull XIDs that have occurred on all defined link stations since the last time this node was initialized.')
ibmappnNodeDynLsGoodXids = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 8, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeDynLsGoodXids.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeDynLsGoodXids.setDescription('The current number of successfull XIDs that have occurred on all dynamic link stations since the last time this node was initialized.')
ibmappnNodeDynLsBadXids = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 8, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeDynLsBadXids.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeDynLsBadXids.setDescription('The current number of unsuccessfull XIDs that have occurred on all dynamic link stations since the last time this node was initialized.')
ibmappnNn = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2))
ibmappnNnTopo = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 1))
ibmappnNnTopology = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3))
ibmappnNnTopoMaxNodes = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTopoMaxNodes.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTopoMaxNodes.setDescription('Maximum number of nodes allowed in the APPN topology database This administratively assigned value must be equal to or greater than the maximum total number of end nodes and network nodes. If the number of nodes exceeds this value, APPN will issue an Alert and the node can no longer participate as a network node.')
ibmappnNnTopoCurNumNodes = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTopoCurNumNodes.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTopoCurNumNodes.setDescription("Current number of nodes in this node's topology database. If this value exceeds the maximum number of nodes allowed (NnTopoMaxNodes), APPN alert CPDB002 is issued.")
ibmappnNnTopoInTdus = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTopoInTdus.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTopoInTdus.setDescription('Total number of TDUs received from all adjacent NN since last initialization.')
ibmappnNnTopoOutTdus = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTopoOutTdus.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTopoOutTdus.setDescription('Total number of TDUs built by this node to be sent to all adjacent NN since last initialization.')
ibmappnNnTopoNodeLowRsns = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTopoNodeLowRsns.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTopoNodeLowRsns.setDescription("Total number of topology node updates received by this node with a RSN less than the current RSN. Both even and odd RSN are included in this count. These TDUs are not errors, but result when TDUs are broadcast to all adjacent network nodes. No update to this node's topology database occurs, but this node will send a TDU with it's higher RSN to the adjacent node that sent this low RSN.")
ibmappnNnTopoNodeEqualRsns = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTopoNodeEqualRsns.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTopoNodeEqualRsns.setDescription("Total number of topology node updates received by this node with a RSN equal to the current RSN. Both even and odd RSN are included in this count. These TDUs are not errors, but result when TDUs are broadcast to all adjacent network nodes. No update to this node's topology database occurs.")
ibmappnNnTopoNodeGoodHighRsns = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTopoNodeGoodHighRsns.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTopoNodeGoodHighRsns.setDescription('Total number of topology node updates received by this node with a RSN greater than the current RSN. This results in updating this nodes topology and broadcasting a TDU to all adjacent network nodes. It is not required to send a TDU to the sender of this update because that node already has the update.')
ibmappnNnTopoNodeBadHighRsns = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTopoNodeBadHighRsns.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTopoNodeBadHighRsns.setDescription('Total number of topology node updates received by this node with an odd RSN greater than the current RSN. These updates represent a topology inconsistency detected by one of the APPN network nodes. This results in updating this nodes topology and broadcasting a TDU to all adjacent network nodes.')
ibmappnNnTopoNodeStateUpdates = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTopoNodeStateUpdates.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTopoNodeStateUpdates.setDescription('Total number of topology Node records built as a result of internally detected node state changes that affect APPN topology and routing. Updates are sent via TDUs to all adjacent network nodes.')
ibmappnNnTopoNodeErrors = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTopoNodeErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTopoNodeErrors.setDescription('Total number of topology node records inconsistencies detected by this node. This occurs when this node attempts to update its topology database and detects a data inconsistency. This node will create a TDU with the current RSN incremented to the next odd number and broadcast it to all adjacent NNs.')
ibmappnNnTopoNodeTimerUpdates = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTopoNodeTimerUpdates.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTopoNodeTimerUpdates.setDescription("Total number of topology node records built for this node's resource due to timer updates. Updates are sent via TDUs to all adjacent network nodes. These updates insure other network nodes do not delete this node's resources from their topology database.")
ibmappnNnTopoNodePurges = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTopoNodePurges.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTopoNodePurges.setDescription("Total number of topology node records purged from this node's topology database. This occurs when a node has not been updated in a specified amount of time. The owning node is responsible for broadcasting updates for its resource that it wants kept in the network topology.")
ibmappnNnTopoTgLowRsns = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTopoTgLowRsns.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTopoTgLowRsns.setDescription("Total number of topology TG updates received by this node with a RSN less than the current RSN. Both even and odd RSN are included in this count. These TDUs are not errors, but result when TDUs are broadcast to all adjacent network nodes. No update to this node's topology database occurs, but this node will send a TDU with it's higher RSN to the sender of the low RSN.")
ibmappnNnTopoTgEqualRsns = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTopoTgEqualRsns.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTopoTgEqualRsns.setDescription("Total number of topology TG updates received by this node with a RSN equal to the current RSN. Both even and odd RSN are included in this count. These TDUs are not errors, but result when TDUs are broadcast to all adjacent network nodes. No update to this node's topology database occurs.")
ibmappnNnTopoTgGoodHighRsns = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTopoTgGoodHighRsns.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTopoTgGoodHighRsns.setDescription('Total number of topology TG updates received by this node with a RSN greater than the current RSN. This results in updating this nodes topology and broadcasting the update to all adjacent network nodes.')
ibmappnNnTopoTgBadHighRsns = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTopoTgBadHighRsns.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTopoTgBadHighRsns.setDescription('Total number of topology TG updates received by this node with an odd RSN greater than the current RSN. These updates represent a topology inconsistency detected by one of the APPN network nodes. This results in updating this nodes topology and broadcasting a TDU to all adjacent network nodes.')
ibmappnNnTopoTgStateUpdates = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTopoTgStateUpdates.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTopoTgStateUpdates.setDescription('Total number of topology TG records built as a result of internally detected node state changes that affect APPN topology and routing. Updates are sent via TDUs to all adjacent network nodes.')
ibmappnNnTopoTgErrors = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTopoTgErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTopoTgErrors.setDescription('Total number of topology TG records inconsistencies detected by this node. This occurs when this node attempts to update its topology database and detects a data inconsistency. This node will create a TDU with the current RSN incremented to the next odd number and broadcast it to all adjacent NNs.')
ibmappnNnTopoTgTimerUpdates = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTopoTgTimerUpdates.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTopoTgTimerUpdates.setDescription("Total number of topology TG records built for this node's resource due to timer updates. Updates are sent via TDUs to all adjacent network nodes. These updates insure other network nodes do not delete this node's resources from their topology database.")
ibmappnNnTopoTgPurges = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTopoTgPurges.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTopoTgPurges.setDescription("Total number of topology TG records purged from this node's topology database. This occurs when a TG has not been updated in a specified amount of time. The owning node is responsible for broadcasting updates for its resource that it wants to keep in the network topology.")
ibmappnNnTopoTotalRouteCalcs = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTopoTotalRouteCalcs.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTopoTotalRouteCalcs.setDescription('Number of routes calculated for all class of services since the last initialization.')
ibmappnNnTopoTotalRouteRejs = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTopoTotalRouteRejs.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTopoTotalRouteRejs.setDescription('Number of route requests for all class of services that could not be calculated since last initialization.')
ibmappnNnTopoRouteTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 1, 23), )
if mibBuilder.loadTexts: ibmappnNnTopoRouteTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTopoRouteTable.setDescription('Table containing an entry for every Class of Service that it has calculated a route for.')
ibmappnNnTopoRouteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 1, 23, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmappnNnTopoRouteCos"))
if mibBuilder.loadTexts: ibmappnNnTopoRouteEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTopoRouteEntry.setDescription('The Class of Service name is the index for this table.')
ibmappnNnTopoRouteCos = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 1, 23, 1, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTopoRouteCos.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTopoRouteCos.setDescription('The Class of Service for the route.')
ibmappnNnTopoRouteTrees = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 1, 23, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTopoRouteTrees.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTopoRouteTrees.setDescription('Number of routes tree caches built for this Class of Service since the last initialization.')
ibmappnNnTopoRouteCalcs = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 1, 23, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTopoRouteCalcs.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTopoRouteCalcs.setDescription('Number of routes calculated since last initialization.')
ibmappnNnTopoRouteRejs = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 1, 23, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTopoRouteRejs.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTopoRouteRejs.setDescription('Number of route requests that could not be calculated since last initialization.')
ibmappnNnAdjNodeTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 2), )
if mibBuilder.loadTexts: ibmappnNnAdjNodeTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnAdjNodeTable.setDescription('Table containing an entry for every node. The information kept in this table is the last FRSN sent and received, the status of the CP-CP sessions, and a gauge that indicates the number of outstanding TDUs.')
ibmappnNnAdjNodeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 2, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmappnNnAdjNodeAdjName"))
if mibBuilder.loadTexts: ibmappnNnAdjNodeEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnAdjNodeEntry.setDescription('The adjacent node name is the index for this table.')
ibmappnNnAdjNodeAdjName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 2, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnAdjNodeAdjName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnAdjNodeAdjName.setDescription("An administratively-assigned fully-qualified name of this node's adjacent network node.")
ibmappnNnAdjNodeCpCpSessStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("active", 1), ("conLoserActive", 2), ("conWinnerActive", 3), ("inactive", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnAdjNodeCpCpSessStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnAdjNodeCpCpSessStatus.setDescription('Indicates the state of CP-CP sessions between this node and adjacent network and end nodes. Incative indicates no CP-CP sessions exists between this node and the adjacent node. Active indicates CP-CP sessons are active using both the ConWinner and ConLoser sessions. The session initiated by this node is refered to as the ConWinner session and is used by this node to send to the adjacent node. The ConLoserr session is initiated by the adjacent node and is used by this node to receive from the adjacent node.')
ibmappnNnAdjNodeOutOfSeqTdus = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 2, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnAdjNodeOutOfSeqTdus.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnAdjNodeOutOfSeqTdus.setDescription('Number of out of sequence Topology Database Updates (TDUs). In a quiesced state, this value is zero. In normal operation, the value varies depending on the network environment.')
ibmappnNnAdjNodeLastFrsnSent = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnAdjNodeLastFrsnSent.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnAdjNodeLastFrsnSent.setDescription('Flow reduction sequence numbers (FRSNs) are associated with Topology Database Updates (TDUs) and are unique only within each APPN network node. A TDU can be associated with multiple APPN resources. This FRSN indicates the last TDU sent to this adjacent node.')
ibmappnNnAdjNodeLastFrsnRcvd = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnAdjNodeLastFrsnRcvd.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnAdjNodeLastFrsnRcvd.setDescription('Flow reduction sequence numbers (FRSNs) are associated with Topology Database Updates (TDUs) and are unique only within each APPN network node. A TDU can be associated with multiple APPN resources. This FRSN indicates the last TDU received from this adjacent node.')
ibmappnNnTopologyTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 1), )
if mibBuilder.loadTexts: ibmappnNnTopologyTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTopologyTable.setDescription('Portion of the APPN routing table that describes all of the APPN network nodes and virtual nodes known to this node.')
ibmappnNnTopologyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 1, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmappnNnNodeName"))
if mibBuilder.loadTexts: ibmappnNnTopologyEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTopologyEntry.setDescription('The fully-qualified node name is used to index this table.')
ibmappnNnNodeName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnNodeName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnNodeName.setDescription('Administratively-assigned network name that is locally defined at each network node in the format NETID.CPNAME.')
ibmappnNnNodeFrsn = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnNodeFrsn.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnNodeFrsn.setDescription('Flow reduction sequence numbers (FRSNs) are associated with Topology Database Updates (TDUs) and are unique only within each APPN network node. A TDU can be associated with multiple APPN resources. This FRSN indicates the last time this resource was updated at this node.')
ibmappnNnNodeEntryTimeLeft = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnNodeEntryTimeLeft.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnNodeEntryTimeLeft.setDescription('Number of days before deletion of this network node entry. Range is 0-31.')
ibmappnNnNodeType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3))).clone(namedValues=NamedValues(("networknode", 1), ("virtualnode", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnNodeType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnNodeType.setDescription('Type of APPN node.')
ibmappnNnNodeRsn = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnNodeRsn.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnNodeRsn.setDescription('Resource sequence number that is assigned and controlled by the network node that owns this resource. This is always an even 32-bit number unless an error has occurred.')
ibmappnNnNodeRouteAddResist = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnNodeRouteAddResist.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnNodeRouteAddResist.setDescription('Route addition resistance indicates the relative desirability of using this node for intermediate session traffic. The value, which can be any integer 0-255, is used in route computation. The lower the value, the more desirable the node is for intermediate routing.')
ibmappnNnNodeCongested = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnNodeCongested.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnNodeCongested.setDescription('Indicates whether this node is congested. This node is not be included in route selection by other nodes when this congestion exists.')
ibmappnNnNodeIsrDepleted = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnNodeIsrDepleted.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnNodeIsrDepleted.setDescription('Indicates whether intermediate session routing resources are depleted. This node is not included in intermediate route selection by other nodes when resources are depleted.')
ibmappnNnNodeEndptDepleted = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnNodeEndptDepleted.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnNodeEndptDepleted.setDescription('Indicates whether session endpoint resources are depleted.')
ibmappnNnNodeQuiescing = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnNodeQuiescing.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnNodeQuiescing.setDescription('Indicates whether the node is quiescing. This node is not included in route selection by other nodes when the node is quiescing.')
ibmappnNnNodeGateway = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnNodeGateway.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnNodeGateway.setDescription('Indicates whether the node provide gateway functions.')
ibmappnNnNodeCentralDirectory = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnNodeCentralDirectory.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnNodeCentralDirectory.setDescription('Indicates whether the node is central directory.')
ibmappnNnNodeIsr = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnNodeIsr.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnNodeIsr.setDescription('Indicates whether the node supports intermediate session routing (ISR).')
ibmappnNnNodeChainSupport = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnNodeChainSupport.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnNodeChainSupport.setDescription('Indicates whether the node supports chaining.')
ibmappnNnTgTopologyTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 2), )
if mibBuilder.loadTexts: ibmappnNnTgTopologyTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgTopologyTable.setDescription('Portion of the APPN topology database that describes all of the APPN transmissions groups used by the APPN network nodes.')
ibmappnNnTgTopologyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 2, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmappnNnTgOwner"), (0, "IBM6611-MIB", "ibmappnNnTgDest"), (0, "IBM6611-MIB", "ibmappnNnTgNum"))
if mibBuilder.loadTexts: ibmappnNnTgTopologyEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgTopologyEntry.setDescription('This table requires three indexes to provide a unique index. The indexes are the owning or originating CPname, the destination CPname, and the TG number.')
ibmappnNnTgOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 2, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgOwner.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgOwner.setDescription('Administratively-assigned name for the originating node for this TG. The format is NETID.CPNAME and is the same name specified in the node table.')
ibmappnNnTgDest = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgDest.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgDest.setDescription('Administratively-assigned fully-qualified network name for the destination node for this TG.')
ibmappnNnTgNum = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgNum.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgNum.setDescription('Number associated with this transmission group. Range is 0-255.')
ibmappnNnTgFrsn = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgFrsn.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgFrsn.setDescription('Flow reduction sequence numbers (FRSNs) are associated with Topology Database Updates (TDUs) and are unique only within each APPN network node. A TDU can be associated with multiple APPN resources. This FRSN indicates the last time this resource was updated at this node.')
ibmappnNnTgEntryTimeLeft = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgEntryTimeLeft.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgEntryTimeLeft.setDescription('Number of days before deletion of this network node TG entry. Range is 0-31.')
ibmappnNnTgDestVirtual = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgDestVirtual.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgDestVirtual.setDescription('Indicates whether the destination node is a virtual node.')
ibmappnNnTgDlcData = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 2, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 9))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgDlcData.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgDlcData.setDescription('DLC specific data related to the link connection network. Token-Ring - MAC/SAP X.25 Switched - dial digits X.21 Switched - dial digits Circuit Swtch - dial digits')
ibmappnNnTgRsn = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 2, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgRsn.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgRsn.setDescription("Current owning node's resource sequence number for this resource.")
ibmappnNnTgOperational = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgOperational.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgOperational.setDescription('Indicates whether the transmission group is operational.')
ibmappnNnTgQuiescing = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgQuiescing.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgQuiescing.setDescription('Indicates whether the transmission group is quiescing.')
ibmappnNnTgCpCpSession = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgCpCpSession.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgCpCpSession.setDescription('Indicates whether CP-CP sessions are supported on this TG.')
ibmappnNnTgEffCap = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 2, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgEffCap.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgEffCap.setDescription('The effective capacity is an integer value that indicates the kilo bits per second. It is derived from the link bandwidth and maximum load factor with the range of 0 thru 603,979,776. This is an administratively assigned value associated with this TG.')
ibmappnNnTgConnCost = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 2, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgConnCost.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgConnCost.setDescription('Cost per connect time: a value representing the relative cost per unit of time to use the TG. Range is from 0, which means no cost, to 255, which indicates maximum cost. This is an administratively assigned value associated with this TG.')
ibmappnNnTgByteCost = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 2, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgByteCost.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgByteCost.setDescription('Relative cost of transmitting a byte over this link. Range is from 0 (lowest cost) to 255. This is an administratively assigned value associated with this TG.')
ibmappnNnTgSecurity = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 2, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 32, 64, 96, 128, 160, 192))).clone(namedValues=NamedValues(("nonsecure", 1), ("publicSwitchedNetwork", 32), ("undergroundCable", 64), ("secureConduit", 96), ("guardedConduit", 128), ("encrypted", 160), ("guardedRadiation", 192)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgSecurity.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgSecurity.setDescription('The security is represented as an integer with a range of 1 thru 255 with the most common values enumerated as defined above. This is an administratively assigned value associated with this TG.')
ibmappnNnTgDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 2, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 384, 9216, 147456, 294912, 2013265920))).clone(namedValues=NamedValues(("minimum", 1), ("negligible", 384), ("terrestrial", 9216), ("packet", 147456), ("long", 294912), ("maximum", 2013265920)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgDelay.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgDelay.setDescription('Relative amount of time that it takes for a signal to travel the length of the logical link. This time is represented in micro seconds, with some of the more common values enumerated. This is an administratively assigned value associated with this TG.')
ibmappnNnTgModemClass = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 2, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgModemClass.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgModemClass.setDescription("This is used to have multiple images for a connection network. For a connection network it is the same as in the TG vector; for a non-connection network it is X'00'.")
ibmappnNnTgUsr1 = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 2, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgUsr1.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgUsr1.setDescription('First user-defined TG characteristic for this TG with a range of 0-255. This is an administratively assigned value associated with this TG.')
ibmappnNnTgUsr2 = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 2, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgUsr2.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgUsr2.setDescription('Second user-defined TG characteristic for this TG with a range of 0-255. This is an administratively assigned value associated with this TG.')
ibmappnNnTgUsr3 = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 2, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgUsr3.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgUsr3.setDescription('Third user-defined TG characteristic for this TG with a range of 0-255. This is an administratively assigned value associated with this TG.')
ibmappnNnTopologyFRTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 3), )
if mibBuilder.loadTexts: ibmappnNnTopologyFRTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTopologyFRTable.setDescription('Portion of the APPN routing table that describes all of the APPN network nodes and virtual nodes known to this node.')
ibmappnNnTopologyFREntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 3, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmappnNnNodeFRFrsn"), (0, "IBM6611-MIB", "ibmappnNnNodeFRName"))
if mibBuilder.loadTexts: ibmappnNnTopologyFREntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTopologyFREntry.setDescription('The fully-qualified node name is used to index this table.')
ibmappnNnNodeFRName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 3, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnNodeFRName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnNodeFRName.setDescription('Administratively-assigned network name that is locally defined at each network node in the format NETID.CPNAME.')
ibmappnNnNodeFRFrsn = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnNodeFRFrsn.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnNodeFRFrsn.setDescription('Flow reduction sequence numbers (FRSNs) are associated with Topology Database Updates (TDUs) and are unique only within each APPN network node. A TDU can be associated with multiple APPN resources. This FRSN indicates the last time this resource was updated at this node.')
ibmappnNnNodeFREntryTimeLeft = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnNodeFREntryTimeLeft.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnNodeFREntryTimeLeft.setDescription('Number of days before deletion of this network node entry. Range is 0-31.')
ibmappnNnNodeFRType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3))).clone(namedValues=NamedValues(("networknode", 1), ("virtualnode", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnNodeFRType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnNodeFRType.setDescription('Type of APPN node.')
ibmappnNnNodeFRRsn = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 3, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnNodeFRRsn.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnNodeFRRsn.setDescription('Resource sequence number that is assigned and controlled by the network node that owns this resource. This is always an even 32-bit number unless an error has occurred.')
ibmappnNnNodeFRRouteAddResist = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 3, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnNodeFRRouteAddResist.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnNodeFRRouteAddResist.setDescription('Route addition resistance indicates the relative desirability of using this node for intermediate session traffic. The value, which can be any integer 0-255, is used in route computation. The lower the value, the more desirable the node is for intermediate routing.')
ibmappnNnNodeFRCongested = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnNodeFRCongested.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnNodeFRCongested.setDescription('Indicates whether this node is congested. This node is not be included in route selection by other nodes when this congestion exists.')
ibmappnNnNodeFRIsrDepleted = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnNodeFRIsrDepleted.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnNodeFRIsrDepleted.setDescription('Indicates whether intermediate session routing resources are depleted. This node is not included in intermediate route selection by other nodes when resources are depleted.')
ibmappnNnNodeFREndptDepleted = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 3, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnNodeFREndptDepleted.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnNodeFREndptDepleted.setDescription('Indicates whether session endpoint resources are depleted.')
ibmappnNnNodeFRQuiescing = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 3, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnNodeFRQuiescing.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnNodeFRQuiescing.setDescription('Indicates whether the node is quiescing. This node is not included in route selection by other nodes when the node is quiescing.')
ibmappnNnNodeFRGateway = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 3, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnNodeFRGateway.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnNodeFRGateway.setDescription('Indicates whether the node provide gateway functions.')
ibmappnNnNodeFRCentralDirectory = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 3, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnNodeFRCentralDirectory.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnNodeFRCentralDirectory.setDescription('Indicates whether the node is central directory.')
ibmappnNnNodeFRIsr = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 3, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnNodeFRIsr.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnNodeFRIsr.setDescription('Indicates whether the node supports intermediate session routing (ISR).')
ibmappnNnNodeFRChainSupport = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 3, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnNodeFRChainSupport.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnNodeFRChainSupport.setDescription('Indicates whether the node supports chaining.')
ibmappnNnTgTopologyFRTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 4), )
if mibBuilder.loadTexts: ibmappnNnTgTopologyFRTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgTopologyFRTable.setDescription('Portion of the APPN topology database that describes all of the APPN transmissions groups used by the APPN network nodes.')
ibmappnNnTgTopologyFREntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 4, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmappnNnTgFRFrsn"), (0, "IBM6611-MIB", "ibmappnNnTgFROwner"), (0, "IBM6611-MIB", "ibmappnNnTgFRDest"), (0, "IBM6611-MIB", "ibmappnNnTgFRNum"))
if mibBuilder.loadTexts: ibmappnNnTgTopologyFREntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgTopologyFREntry.setDescription('This table is indexed by four columns: FRSN, TG owner fully-qualified node name, TG destination fully-qualified node name, TG number.')
ibmappnNnTgFROwner = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 4, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgFROwner.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgFROwner.setDescription('Administratively-assigned name for the originating node for this TG. The format is NETID.CPNAME and is the same name specified in the node table.')
ibmappnNnTgFRDest = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 4, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgFRDest.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgFRDest.setDescription('Administratively-assigned fully-qualified network name for the destination node for this TG.')
ibmappnNnTgFRNum = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgFRNum.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgFRNum.setDescription('Number associated with this transmission group. Range is 0-255.')
ibmappnNnTgFRFrsn = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgFRFrsn.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgFRFrsn.setDescription('Flow reduction sequence numbers (FRSNs) are associated with Topology Database Updates (TDUs) and are unique only within each APPN network node. A TDU can be associated with multiple APPN resources. This FRSN indicates the last time this resource was updated at this node.')
ibmappnNnTgFREntryTimeLeft = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 4, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgFREntryTimeLeft.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgFREntryTimeLeft.setDescription('Number of days before deletion of this network node TG entry. Range is 0-31.')
ibmappnNnTgFRDestVirtual = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 4, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgFRDestVirtual.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgFRDestVirtual.setDescription('Indicates whether the destination node is a virtual node.')
ibmappnNnTgFRDlcData = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 4, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 9))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgFRDlcData.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgFRDlcData.setDescription('DLC specific data related to the link connection network. Token-Ring - MAC/SAP X.25 Switched - dial digits X.21 Switched - dial digits Circuit Swtch - dial digits')
ibmappnNnTgFRRsn = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 4, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgFRRsn.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgFRRsn.setDescription("Current owning node's resource sequence number for this resource.")
ibmappnNnTgFROperational = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 4, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgFROperational.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgFROperational.setDescription('Indicates whether the transmission group is operational.')
ibmappnNnTgFRQuiescing = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 4, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgFRQuiescing.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgFRQuiescing.setDescription('Indicates whether the transmission group is quiescing.')
ibmappnNnTgFRCpCpSession = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 4, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgFRCpCpSession.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgFRCpCpSession.setDescription('Indicates whether CP-CP sessions are supported on this TG.')
ibmappnNnTgFREffCap = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 4, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgFREffCap.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgFREffCap.setDescription('The effective capacity is an integer value that indicates the kilo bits per second. It is derived from the link bandwidth and maximum load factor with the range of 0 thru 603,979,776. This is an administratively assigned value associated with this TG.')
ibmappnNnTgFRConnCost = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 4, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgFRConnCost.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgFRConnCost.setDescription('Cost per connect time: a value representing the relative cost per unit of time to use the TG. Range is from 0, which means no cost, to 255, which indicates maximum cost. This is an administratively assigned value associated with this TG.')
ibmappnNnTgFRByteCost = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 4, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgFRByteCost.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgFRByteCost.setDescription('Relative cost of transmitting a byte over this link. Range is from 0 (lowest cost) to 255. This is an administratively assigned value associated with this TG.')
ibmappnNnTgFRSecurity = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 4, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 32, 64, 96, 128, 160, 192))).clone(namedValues=NamedValues(("nonsecure", 1), ("publicSwitchedNetwork", 32), ("undergroundCable", 64), ("secureConduit", 96), ("guardedConduit", 128), ("encrypted", 160), ("guardedRadiation", 192)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgFRSecurity.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgFRSecurity.setDescription('The security is represented as an integer with a range of 1 thru 255 with the most common values enumerated as defined above. This is an administratively assigned value associated with this TG.')
ibmappnNnTgFRDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 4, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 384, 9216, 147456, 294912, 2013265920))).clone(namedValues=NamedValues(("minimum", 1), ("negligible", 384), ("terrestrial", 9216), ("packet", 147456), ("long", 294912), ("maximum", 2013265920)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgFRDelay.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgFRDelay.setDescription('Relative amount of time that it takes for a signal to travel the length of the logical link. This time is represented in micro seconds, with some of the more common values enumerated. This is an administratively assigned value associated with this TG.')
ibmappnNnTgFRModemClass = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 4, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgFRModemClass.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgFRModemClass.setDescription("This is used to have multiple images for a connection network. For a connection network it is the same as in the TG vector; for a non-connection network it is X'00'.")
ibmappnNnTgFRUsr1 = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 4, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgFRUsr1.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgFRUsr1.setDescription('First user-defined TG characteristic for this TG with a range of 0-255. This is an administratively assigned value associated with this TG.')
ibmappnNnTgFRUsr2 = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 4, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgFRUsr2.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgFRUsr2.setDescription('Second user-defined TG characteristic for this TG with a range of 0-255. This is an administratively assigned value associated with this TG.')
ibmappnNnTgFRUsr3 = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 4, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgFRUsr3.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgFRUsr3.setDescription('Third user-defined TG characteristic for this TG with a range of 0-255. This is an administratively assigned value associated with this TG.')
ibmappnLocalTopology = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3))
ibmappnLocalThisNode = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 1))
ibmappnLocalGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 1, 1))
ibmappnLocalNnSpecific = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 1, 2))
ibmappnLocalTg = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 1, 3))
ibmappnLocalEnTopology = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 2))
ibmappnLocalNodeName = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalNodeName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalNodeName.setDescription('Administratively-assigned fully-qualified name for this node. Format is NETID.CPNAME.')
ibmappnLocalNodeType = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4))).clone(namedValues=NamedValues(("networknode", 1), ("endnode", 2), ("len", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalNodeType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalNodeType.setDescription('Type of APPN node.')
ibmappnLocalNnRsn = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 1, 2, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalNnRsn.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalNnRsn.setDescription('Resource sequence number is assigned and controlled by the network node that owns this resource. This is always an even unsigned number unless an error has occurred.')
ibmappnLocalNnRouteAddResist = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 1, 2, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalNnRouteAddResist.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalNnRouteAddResist.setDescription('Route addition resistance indicates the relative desirability of using this node for intermediate session traffic. The value, which can be any integer 0-255, is used in route computation. The lower the value, the more desirable the node is for intermediate routing.')
ibmappnLocalNnCongested = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 1, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalNnCongested.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalNnCongested.setDescription('Indicates whether this node is congested. Other network nodes stop routing traffic to this node while this flag is on.')
ibmappnLocalNnIsrDepleted = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 1, 2, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalNnIsrDepleted.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalNnIsrDepleted.setDescription('Indicate whether intermediated session routing resources are depleted. Other network nodes stop routing traffic through this node while this flag is on.')
ibmappnLocalNnEndptDepleted = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 1, 2, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalNnEndptDepleted.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalNnEndptDepleted.setDescription('Indicates whether session endpoint resources are depleted.')
ibmappnLocalNnQuiescing = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 1, 2, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalNnQuiescing.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalNnQuiescing.setDescription('Indicates whether the node is quiescing.')
ibmappnLocalNnGateway = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 1, 2, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalNnGateway.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalNnGateway.setDescription('Indicates whether the node is a gateway.')
ibmappnLocalNnCentralDirectory = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 1, 2, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalNnCentralDirectory.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalNnCentralDirectory.setDescription('Indicates whether the node is a central directory.')
ibmappnLocalNnIsr = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 1, 2, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalNnIsr.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalNnIsr.setDescription('Indicates whether the node supports intermediate session routing.')
ibmappnLocalNnChainSupport = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 1, 2, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalNnChainSupport.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalNnChainSupport.setDescription('Indicates whether the node supports chaining.')
ibmappnLocalNnFrsn = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 1, 2, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalNnFrsn.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalNnFrsn.setDescription('Flow reduction sequence numbers (FRSNs) are associated with Topology Database Updates (TDUs) and are unique only within each APPN network node. A TDU can be associated with multiple APPN resources. This object is the last FRSN sent in a topology update to adjacent network nodes.')
ibmappnLocalTgTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 1, 3, 1), )
if mibBuilder.loadTexts: ibmappnLocalTgTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalTgTable.setDescription('TG Table describes all of the TGs owned by this node. The TG destination can be a virtual node, network node, len, or end node.')
ibmappnLocalTgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 1, 3, 1, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmappnLocalTgDest"), (0, "IBM6611-MIB", "ibmappnLocalTgNum"))
if mibBuilder.loadTexts: ibmappnLocalTgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalTgEntry.setDescription('This table is indexed by the destination CPname and the TG number.')
ibmappnLocalTgDest = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 1, 3, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalTgDest.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalTgDest.setDescription('Administratively-assigned name for the destination node for this TG. This is the fully-qualified network node name.')
ibmappnLocalTgNum = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 1, 3, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalTgNum.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalTgNum.setDescription('Number associated with this transmission group.')
ibmappnLocalTgDestVirtual = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 1, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalTgDestVirtual.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalTgDestVirtual.setDescription('Indicates whether the destination node is a Virtual node.')
ibmappnLocalTgDlcData = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 1, 3, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 9))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalTgDlcData.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalTgDlcData.setDescription('DLC specific data related to the link connection network. Token-Ring - MAC/SAP X.25 Switched - dial digits X.21 Switched - dial digits Circuit Swtch - dial digits')
ibmappnLocalTgRsn = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 1, 3, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalTgRsn.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalTgRsn.setDescription('The resource sequence number is assigned and controlled by the network node that owns this resource. This is always an even unsigned number unless an error has occurred.')
ibmappnLocalTgQuiescing = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 1, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalTgQuiescing.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalTgQuiescing.setDescription('Indicates whether the Transmission Group is quiescing.')
ibmappnLocalTgOperational = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 1, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalTgOperational.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalTgOperational.setDescription('Indicates whether the Transmission Group is operational.')
ibmappnLocalTgCpCpSession = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 1, 3, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalTgCpCpSession.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalTgCpCpSession.setDescription('Indicates whether the CP-CP Sessions are supported on this TG.')
ibmappnLocalTgEffCap = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 1, 3, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalTgEffCap.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalTgEffCap.setDescription('The effective capacity is an integer value that indicates the actual kilo bits per second. It is derived from the link bandwidth and maximum load factor with the range of 0 thru 603,979,776.')
ibmappnLocalTgConnCost = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 1, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalTgConnCost.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalTgConnCost.setDescription('Cost per connect time: a value representing the relative cost per unit of time to use the TG. Range is from 0, which means no cost, to 255.')
ibmappnLocalTgByteCost = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 1, 3, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalTgByteCost.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalTgByteCost.setDescription('Relative cost of transmitting a byte over this link. Range is from 0 (lowest cost) to 255.')
ibmappnLocalTgSecurity = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 1, 3, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 32, 64, 96, 128, 160, 192))).clone(namedValues=NamedValues(("nonsecure", 1), ("publicSwitchedNetwork", 32), ("undergroundCable", 64), ("secureConduit", 96), ("guardedConduit", 128), ("encrypted", 160), ("guardedRadiation", 192)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalTgSecurity.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalTgSecurity.setDescription('Security level for this TG.')
ibmappnLocalTgDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 1, 3, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 384, 9216, 147456, 294912, 2013265920))).clone(namedValues=NamedValues(("minimum", 1), ("negligible", 384), ("terrestrial", 9216), ("packet", 147456), ("long", 294912), ("maximum", 2013265920)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalTgDelay.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalTgDelay.setDescription('Relative amount of time that it takes for a signal to travel the length of the logical link. This time is represented in micro seconds, with some of the more common values enumerated.')
ibmappnLocalTgModemClass = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 1, 3, 1, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalTgModemClass.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalTgModemClass.setDescription('This is used to have multiple images for a connection network. For a connection network it is the same as in the TG vector and for a non-connection network it is zero.')
ibmappnLocalTgUsr1 = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 1, 3, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalTgUsr1.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalTgUsr1.setDescription('Value of the first user-defined TG characteristic for this TG. Range is 0-255.')
ibmappnLocalTgUsr2 = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 1, 3, 1, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalTgUsr2.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalTgUsr2.setDescription('Value of the second user-defined TG characteristic for this TG. Range is 0-255.')
ibmappnLocalTgUsr3 = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 1, 3, 1, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalTgUsr3.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalTgUsr3.setDescription('Value of the third user-defined TG characteristic for this TG. Range is 0-255.')
ibmappnLocalEnTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 2, 1), )
if mibBuilder.loadTexts: ibmappnLocalEnTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalEnTable.setDescription('Portion of the APPN topology database that describes the end nodes known to this node.')
ibmappnLocalEnEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 2, 1, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmappnLocalEnName"))
if mibBuilder.loadTexts: ibmappnLocalEnEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalEnEntry.setDescription('This table is indexed by the end node CPname.')
ibmappnLocalEnName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 2, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalEnName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalEnName.setDescription('Administratively-assigned fully-qualified name of end node in the format NETID.CPNAME.')
ibmappnLocalEnEntryTimeLeft = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalEnEntryTimeLeft.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalEnEntryTimeLeft.setDescription('Number of days before deletion of this end node entry. Range is 0-31.')
ibmappnLocalEnType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 4))).clone(namedValues=NamedValues(("endnode", 2), ("len", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalEnType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalEnType.setDescription('Type of APPN node (must always be a len or end node).')
ibmappnLocalEnTgTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 2, 2), )
if mibBuilder.loadTexts: ibmappnLocalEnTgTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalEnTgTable.setDescription('Table describing all of the TGs owned by the end nodes known to this node. The TG destination can be a virtual node, network node, or end node.')
ibmappnLocalEnTgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 2, 2, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmappnLocalEnTgOrigin"), (0, "IBM6611-MIB", "ibmappnLocalEnTgDest"), (0, "IBM6611-MIB", "ibmappnLocalEnTgNum"))
if mibBuilder.loadTexts: ibmappnLocalEnTgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalEnTgEntry.setDescription('This table requires multiple indexes to uniquely identify each TG. They are originating CPname, destination CPname, and the TG number.')
ibmappnLocalEnTgOrigin = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 2, 2, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalEnTgOrigin.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalEnTgOrigin.setDescription('Administratively-assigned name for the origination node for this TG. This is the fully-qualified network name.')
ibmappnLocalEnTgDest = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 2, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalEnTgDest.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalEnTgDest.setDescription('Administratively-assigned name for the destination node for this TG. This is the fully-qualified network name.')
ibmappnLocalEnTgNum = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 2, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalEnTgNum.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalEnTgNum.setDescription('Number associated with this transmission group.')
ibmappnLocalEnTgEntryTimeLeft = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalEnTgEntryTimeLeft.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalEnTgEntryTimeLeft.setDescription('Number of days before deletion of this end node TG entry. Range is 0-31.')
ibmappnLocalEnTgDestVirtual = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 2, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalEnTgDestVirtual.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalEnTgDestVirtual.setDescription('Indicates whether the destination node is a virtual node.')
ibmappnLocalEnTgDlcData = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 2, 2, 1, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalEnTgDlcData.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalEnTgDlcData.setDescription('DLC specific data related to the link connection network. Token-Ring - MAC/SAP X.25 Switched - dial digits X.21 Switched - dial digits Circuit Swtch - dial digits')
ibmappnLocalEnTgOperational = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 2, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalEnTgOperational.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalEnTgOperational.setDescription('Indicates whether the Transmission Group is operational.')
ibmappnLocalEnTgCpCpSession = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 2, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalEnTgCpCpSession.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalEnTgCpCpSession.setDescription('Indicates whether CP-CP sessions are supported on this TG.')
ibmappnLocalEnTgEffCap = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 2, 2, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalEnTgEffCap.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalEnTgEffCap.setDescription('The effective capacity is an integer value that indicates the actual kilo bits per second. It is derived from the link bandwidth and maximum load factor with the range of 0 thru 603,979,776.')
ibmappnLocalEnTgConnCost = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 2, 2, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalEnTgConnCost.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalEnTgConnCost.setDescription('Cost per connect time: a value representing the relative cost per unit of time to use the TG. Range is from 0, which means no cost, to 255.')
ibmappnLocalEnTgByteCost = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 2, 2, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalEnTgByteCost.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalEnTgByteCost.setDescription('Relative cost of transmitting a byte over this link. Range is from 0, which means no cost, to 255.')
ibmappnLocalEnTgSecurity = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 2, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 32, 64, 96, 128, 160, 192))).clone(namedValues=NamedValues(("nonsecure", 1), ("publicSwitchedNetwork", 32), ("undergroundCable", 64), ("secureConduit", 96), ("guardedConduit", 128), ("encrypted", 160), ("guardedRadiation", 192)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalEnTgSecurity.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalEnTgSecurity.setDescription('Security level for this TG.')
ibmappnLocalEnTgDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 2, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 384, 9216, 147456, 294912, 2013265920))).clone(namedValues=NamedValues(("minimum", 1), ("negligible", 384), ("terrestrial", 9216), ("packet", 147456), ("long", 294912), ("maximum", 2013265920)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalEnTgDelay.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalEnTgDelay.setDescription('Relative amount of time that it takes for a signal to travel the length of the logical link. This time is represented in micro seconds, with some of the more common values enumerated.')
ibmappnLocalEnTgModemClass = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 2, 2, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalEnTgModemClass.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalEnTgModemClass.setDescription('This is used to have multiple images for a connection network. For a connection network it is the same as in the TG vector and for a non connection network it is zero.')
ibmappnLocalEnTgUsr1 = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 2, 2, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalEnTgUsr1.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalEnTgUsr1.setDescription('First user-defined TG characteristic for this TG. Range of values is 0-255.')
ibmappnLocalEnTgUsr2 = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 2, 2, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalEnTgUsr2.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalEnTgUsr2.setDescription('Second user-defined TG characteristic for this TG. Range of values is 0-255.')
ibmappnLocalEnTgUsr3 = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 2, 2, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalEnTgUsr3.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalEnTgUsr3.setDescription('Third user-defined TG characteristic for this TG. Range of values is 0-255.')
ibmappnDir = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 5))
ibmappnDirPerf = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 5, 1))
ibmappnDirMaxCaches = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnDirMaxCaches.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnDirMaxCaches.setDescription('Maximum number of cache entries allowed. This is an administratively assigned value.')
ibmappnDirCurCaches = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 5, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnDirCurCaches.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnDirCurCaches.setDescription('Current number of cache entries.')
ibmappnDirCurHomeEntries = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 5, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnDirCurHomeEntries.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnDirCurHomeEntries.setDescription('Current number of home entries.')
ibmappnDirRegEntries = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 5, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnDirRegEntries.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnDirRegEntries.setDescription('Current number of registered entries.')
ibmappnDirInLocates = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 5, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnDirInLocates.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnDirInLocates.setDescription('Number of directed locates received.')
ibmappnDirInBcastLocates = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 5, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnDirInBcastLocates.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnDirInBcastLocates.setDescription('Number of broadcast locates received.')
ibmappnDirOutLocates = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 5, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnDirOutLocates.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnDirOutLocates.setDescription('Number of directed locates sent.')
ibmappnDirOutBcastLocates = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 5, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnDirOutBcastLocates.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnDirOutBcastLocates.setDescription('Number of broadcast locates sent.')
ibmappnDirNotFoundLocates = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 5, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnDirNotFoundLocates.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnDirNotFoundLocates.setDescription("Number of directed locates returned with a 'not found'.")
ibmappnDirNotFoundBcastLocates = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 5, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnDirNotFoundBcastLocates.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnDirNotFoundBcastLocates.setDescription('Number of broadcast locates returned with a not found.')
ibmappnDirLocateOutstands = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 5, 1, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnDirLocateOutstands.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnDirLocateOutstands.setDescription('Current number of outstanding locates, both directed and broadcast. This value varies. A value of zero indicates that no locates are unanswered.')
ibmappnDirTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 5, 2), )
if mibBuilder.loadTexts: ibmappnDirTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnDirTable.setDescription('Table containing information about all known LUs and TPs.')
ibmappnDirEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 5, 2, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmappnDirLuName"))
if mibBuilder.loadTexts: ibmappnDirEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnDirEntry.setDescription('This table is indexed by the LU name.')
ibmappnDirLuName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 5, 2, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnDirLuName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnDirLuName.setDescription('Fully-qualified network LU name in the domain of the serving network node.')
ibmappnDirServerName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 5, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnDirServerName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnDirServerName.setDescription('Fully-qualified control point (CP) name of the network node server. For unassociated end node entries, the end node fully-qualified name is returned.')
ibmappnDirLuOwnerName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 5, 2, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnDirLuOwnerName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnDirLuOwnerName.setDescription('Fully-qualified CP name of the node at which the LU is located. This name is the same as the serving NN name when the LU is located at a network node or an unassociated end node. It is also the same as the fully-qualified LU name when this is the control point LU for this node.')
ibmappnDirLuLocation = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 5, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("local", 1), ("domain", 2), ("xdomain", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnDirLuLocation.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnDirLuLocation.setDescription('Specifies the location of the LU.')
ibmappnDirType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 5, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("home", 1), ("cache", 2), ("registered", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnDirType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnDirType.setDescription('Directory types are: 1 - Home The LU is in the domain of the local network node and the LU information has been configured at the local node. 2 - Cache The LU has previously been located by a broadcast search and the location information has been saved. 3 - Register The LU is at an end node that is in the domain of the local network node. Registered entries are registered by the served end node.')
ibmappnDirWildCard = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 5, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("explicit-entry", 2), ("partial-wildcard", 3), ("full-wildcard", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnDirWildCard.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnDirWildCard.setDescription('1 - Other means unknown type of LU entry. 2 - Expliced-entry means the full LUNAME will be used for locating this LU. 3 - Partial-wildcard means only the non-blank portions of the LUNAME will be used for locating this LU. 4 - Full-wildcard means all LUNAMES will be directed to this LU.')
ibmappnCos = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 6))
ibmappnCosModeTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 6, 1), )
if mibBuilder.loadTexts: ibmappnCosModeTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnCosModeTable.setDescription('Table representing all of the defined mode names for this node. The table contains the matching COS name.')
ibmappnCosModeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 6, 1, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmappnCosModeName"))
if mibBuilder.loadTexts: ibmappnCosModeEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnCosModeEntry.setDescription('This table is indexed by the Mode Name.')
ibmappnCosModeName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 6, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnCosModeName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnCosModeName.setDescription('Administratively-assigned name for this mode entry.')
ibmappnCosModeCosName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 6, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnCosModeCosName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnCosModeCosName.setDescription('An administratively assigned name for this Class of Service.')
ibmappnCosNameTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 6, 2), )
if mibBuilder.loadTexts: ibmappnCosNameTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnCosNameTable.setDescription('Table representing all of the defined class-of-service names for this node. The COS node and TG tables are accessed using the same index, which is the COS name.')
ibmappnCosNameEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 6, 2, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmappnCosName"))
if mibBuilder.loadTexts: ibmappnCosNameEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnCosNameEntry.setDescription('The COS name is the index to this table.')
ibmappnCosName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 6, 2, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnCosName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnCosName.setDescription('Administratively-assigned name for this class of service.')
ibmappnCosTransPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 6, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("low", 1), ("medium", 2), ("high", 3), ("network", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnCosTransPriority.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnCosTransPriority.setDescription('Transmission priority for this class of service. Values are: Low Medium High Network ')
ibmappnCosNodeRowTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 6, 3), )
if mibBuilder.loadTexts: ibmappnCosNodeRowTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnCosNodeRowTable.setDescription('This table contains all node-row information for all class of service in this node.')
ibmappnCosNodeRowEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 6, 3, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmappnCosNodeRowName"), (0, "IBM6611-MIB", "ibmappnCosNodeRowIndex"))
if mibBuilder.loadTexts: ibmappnCosNodeRowEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnCosNodeRowEntry.setDescription('The COS name is the first index and a integer is the second index to insure a unique index.')
ibmappnCosNodeRowName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 6, 3, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnCosNodeRowName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnCosNodeRowName.setDescription('Administratively-assigned name for this class of service.')
ibmappnCosNodeRowIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 6, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnCosNodeRowIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnCosNodeRowIndex.setDescription('Index of COS name. This same value is used to access the node and TG COS tables. Range of values is 0-255.')
ibmappnCosNodeRowWgt = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 6, 3, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnCosNodeRowWgt.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnCosNodeRowWgt.setDescription('Weight to be associated with the nodes that fit the criteria specified by this node row.')
ibmappnCosNodeRowResistMin = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 6, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnCosNodeRowResistMin.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnCosNodeRowResistMin.setDescription('Minimum route addition resistance value for this node. Range of values is 0-255. The lower the value, the more desirable the node is for intermediate routing.')
ibmappnCosNodeRowResistMax = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 6, 3, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnCosNodeRowResistMax.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnCosNodeRowResistMax.setDescription('Maximum route addition resistance value for this node. Range of values is 0-255. The lower the value, the more desirable the node is for intermediate routing.')
ibmappnCosNodeRowMinCongestAllow = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 6, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnCosNodeRowMinCongestAllow.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnCosNodeRowMinCongestAllow.setDescription('Indicates whether low congestion will be tolerated. The minimum and maximum parameters will allow specifying either low-congested, high-congested, or either to be used.')
ibmappnCosNodeRowMaxCongestAllow = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 6, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnCosNodeRowMaxCongestAllow.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnCosNodeRowMaxCongestAllow.setDescription('Indicates whether high congestion will be tolerated. The minimum and maximum parameters will allow specifying either low-congested, high-congested, or either to be used.')
ibmappnCosTgRowTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 6, 4), )
if mibBuilder.loadTexts: ibmappnCosTgRowTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnCosTgRowTable.setDescription('Table containing all the Tg-row information for all class of service defined in this node.')
ibmappnCosTgRowEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 6, 4, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmappnCosTgRowName"), (0, "IBM6611-MIB", "ibmappnCosTgRowIndex"))
if mibBuilder.loadTexts: ibmappnCosTgRowEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnCosTgRowEntry.setDescription('The TgRowName and the TgRowIndex are the index for this table.')
ibmappnCosTgRowName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 6, 4, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnCosTgRowName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnCosTgRowName.setDescription('Administratively-assigned name for this class of service.')
ibmappnCosTgRowIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 6, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnCosTgRowIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnCosTgRowIndex.setDescription('Index of COS name. This same value is used to access the node and TG COS tables.')
ibmappnCosTgRowWgt = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 6, 4, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnCosTgRowWgt.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnCosTgRowWgt.setDescription('Weight to be associated with the nodes that fit the criteria specified by this tg-row.')
ibmappnCosTgRowEffCapMin = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 6, 4, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnCosTgRowEffCapMin.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnCosTgRowEffCapMin.setDescription('Minimum acceptable speed for this Class of Service. The effective capacity is an integer value that indicates the actual kilo bits per second. It is derived from the link bandwidth and maximum load factor with the range of 0 thru 603,979,776.')
ibmappnCosTgRowEffCapMax = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 6, 4, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnCosTgRowEffCapMax.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnCosTgRowEffCapMax.setDescription('Maximum acceptable speed for this Class of Service. The effective capacity is an integer value that indicates the actual kilo bits per second. It is derived from the link bandwidth and maximum load factor with the range of 0 thru 603,979,776.')
ibmappnCosTgRowConnCostMin = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 6, 4, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnCosTgRowConnCostMin.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnCosTgRowConnCostMin.setDescription('Minimum acceptable cost per connect time for this Class of Service. Cost per connect time: a value representing the relative cost per unit of time to use the TG. Range is from 0, which means no cost, to 255.')
ibmappnCosTgRowConnCostMax = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 6, 4, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnCosTgRowConnCostMax.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnCosTgRowConnCostMax.setDescription('Maximum acceptable cost per connect time for this Class of Service. Cost per connect time: a value representing the relative cost per unit of time to use the TG. Range is from 0, which means no cost, to 255.')
ibmappnCosTgRowByteCostMin = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 6, 4, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnCosTgRowByteCostMin.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnCosTgRowByteCostMin.setDescription('Minimum acceptable cost per byte for this Class of Service.')
ibmappnCosTgRowByteCostMax = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 6, 4, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnCosTgRowByteCostMax.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnCosTgRowByteCostMax.setDescription('Maximum acceptable cost per byte for this Class of Service.')
ibmappnCosTgRowSecurityMin = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 6, 4, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 32, 64, 96, 128, 160, 192))).clone(namedValues=NamedValues(("nonsecure", 1), ("publicSwitchedNetwork", 32), ("undergroundCable", 64), ("secureConduit", 96), ("guardedConduit", 128), ("encrypted", 160), ("guardedRadiation", 192)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnCosTgRowSecurityMin.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnCosTgRowSecurityMin.setDescription('Minimum acceptable security for this Class of Service.')
ibmappnCosTgRowSecurityMax = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 6, 4, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 32, 64, 96, 128, 160, 192))).clone(namedValues=NamedValues(("nonsecure", 1), ("publicSwitchedNetwork", 32), ("undergroundCable", 64), ("secureConduit", 96), ("guardedConduit", 128), ("encrypted", 160), ("guardedRadiation", 192)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnCosTgRowSecurityMax.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnCosTgRowSecurityMax.setDescription('Maximum acceptable security for this Class of Service.')
ibmappnCosTgRowDelayMin = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 6, 4, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 384, 9216, 147456, 294912, 2013265920))).clone(namedValues=NamedValues(("minimum", 1), ("negligible", 384), ("terrestrial", 9216), ("packet", 147456), ("long", 294912), ("maximum", 2013265920)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnCosTgRowDelayMin.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnCosTgRowDelayMin.setDescription('Minimum acceptable propagation delay for this class of service. Relative amount of time that it takes for a signal to travel the length of the logical link. This time is represented in micro seconds, with the more values enumerated.')
ibmappnCosTgRowDelayMax = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 6, 4, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 384, 9216, 147456, 294912, 2013265920))).clone(namedValues=NamedValues(("minimum", 1), ("negligible", 384), ("terrestrial", 9216), ("packet", 147456), ("long", 294912), ("maximum", 2013265920)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnCosTgRowDelayMax.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnCosTgRowDelayMax.setDescription('Maximum acceptable propagation delay for this class of service. Relative amount of time that it takes for a signal to travel the length of the logical link. This time is represented in micro seconds, with the more values enumerated.')
ibmappnCosTgRowUsr1Min = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 6, 4, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnCosTgRowUsr1Min.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnCosTgRowUsr1Min.setDescription('Minimum acceptable value for this user defined characteristic. Range of values is 0-255.')
ibmappnCosTgRowUsr1Max = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 6, 4, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnCosTgRowUsr1Max.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnCosTgRowUsr1Max.setDescription('Maximum acceptable value for this user defined characteristic. Range of values is 0-255.')
ibmappnCosTgRowUsr2Min = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 6, 4, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnCosTgRowUsr2Min.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnCosTgRowUsr2Min.setDescription('Minimum acceptable value for this user defined characteristic. Range of values is 0-255.')
ibmappnCosTgRowUsr2Max = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 6, 4, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnCosTgRowUsr2Max.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnCosTgRowUsr2Max.setDescription('A Maximum acceptable value for this user defined characteristic.')
ibmappnCosTgRowUsr3Min = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 6, 4, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnCosTgRowUsr3Min.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnCosTgRowUsr3Min.setDescription('Minimum acceptable value for this user defined characteristic. Range of values is 0-255.')
ibmappnCosTgRowUsr3Max = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 6, 4, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnCosTgRowUsr3Max.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnCosTgRowUsr3Max.setDescription('Maximum acceptable value for this user defined characteristic. Range of values is 0-255.')
ibmappnSession = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7))
ibmappnConversation = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 8))
ibmappnSessGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 1))
ibmappnSessEndPoint = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2))
ibmappnSessIntermediate = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3))
ibmappnConvGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 8, 1))
ibmappnConvEndPoint = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 8, 2))
ibmappnIsInformation = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 1))
ibmappnIsAccounting = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2))
ibmappnIsInGlobal = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 1, 1))
ibmappnIsInGlobeStatus = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notActive", 1), ("active", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmappnIsInGlobeStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsInGlobeStatus.setDescription('Indicates the current collection options in effect: 1. notActive: collection of counters and some names is not active. 2. active: collection of counters and some names is active.')
ibmappnIsInGlobeRscv = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notActive", 1), ("active", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmappnIsInGlobeRscv.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsInGlobeRscv.setDescription('Indicates the current collection options in effect: 1. notActive: collection of route selection control vectors is not active. 2. active: collection of route selection control vectors is active.')
ibmappnIsInGlobeRscvTime = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 1, 1, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsInGlobeRscvTime.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsInGlobeRscvTime.setDescription('Time when the ibmappnIsInGlobeRscv object last changed. This time is in hundreds of a second.')
ibmappnIsInGlobeCtrStatus = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notActive", 1), ("active", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmappnIsInGlobeCtrStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsInGlobeCtrStatus.setDescription('Indicates whether or not the intermediate session counters are active. This object reflects the combination of the ibmappnIsInGlobeStatus object and the ibmappnIsAcBtypeActive object. The values are: 1. notActive: collection of counters and some names is not active. 2. active: collection of counters and some names is active.')
ibmappnIsInGlobeCtrStatusTime = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 1, 1, 5), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsInGlobeCtrStatusTime.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsInGlobeCtrStatusTime.setDescription('Time when the ibmappnIsInGlobeCtrStatus object last changed. This time is in hundreds of a second.')
ibmappnIsInTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 1, 2), )
if mibBuilder.loadTexts: ibmappnIsInTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsInTable.setDescription('Intermediate Session Information Table')
ibmappnIsInEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 1, 2, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmappnIsInFqLuName"), (0, "IBM6611-MIB", "ibmappnIsInPcid"))
if mibBuilder.loadTexts: ibmappnIsInEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsInEntry.setDescription('Entry of Intermediate Session Information Table.')
ibmappnIsInFqLuName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 1, 2, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsInFqLuName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsInFqLuName.setDescription('The network-qualified CP name or PU name of the node at which the session and cid originated. For APPN and LEN nodes, this is either CP name of the APPN node at which the origin LU is located or the CP name of the NN serving the LEN node at which the origin LU is located. This field is from 3 to 17 characters in length, including a period (.) which separates the NetId from the NAU name.')
ibmappnIsInPcid = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 1, 2, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsInPcid.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsInPcid.setDescription('The procedure correlation identifier (pcid) of a session. It is an 8-octet value assigned by the primary LU.')
ibmappnIsInPriLuName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 1, 2, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsInPriLuName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsInPriLuName.setDescription('The primary LU name of the session.')
ibmappnIsInSecLuName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 1, 2, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsInSecLuName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsInSecLuName.setDescription('The secondary LU name of the session.')
ibmappnIsInModeName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 1, 2, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsInModeName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsInModeName.setDescription('The Mode Name name used for this session. This is a 1-8 character name.')
ibmappnIsInCosName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 1, 2, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsInCosName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsInCosName.setDescription('The Class of Service (COS) name used for this session. This is a 1-8 character name.')
ibmappnIsInTransPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 1, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsInTransPriority.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsInTransPriority.setDescription('The transmission priority of this session.')
ibmappnIsInSessType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 1, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("lu62", 1), ("lu0thru3", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsInSessType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsInSessType.setDescription('The type of intermediate session.')
ibmappnIsInSessState = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 1, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("inactive", 1), ("pendactive", 2), ("active", 3), ("pendinact", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmappnIsInSessState.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsInSessState.setDescription('Indicates the state of the session. 1. session is pending inactive or, 2. session is pending active or, 3. session is active or, 4. session is inactive Existing sessions can be deactivated by setting this object to inactive.')
ibmappnIsInSessStartTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 1, 2, 1, 10), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsInSessStartTime.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsInSessStartTime.setDescription('Time when the session started in hundreds of a second.')
ibmappnIsInSessUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 1, 2, 1, 11), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsInSessUpTime.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsInSessUpTime.setDescription('Length of time the session has been active in hundreds of a second.')
ibmappnIsInCtrUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 1, 2, 1, 12), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsInCtrUpTime.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsInCtrUpTime.setDescription('Length of time the session counters have been active in hundreds of a second.')
ibmappnIsInP2SFmdPius = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 1, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsInP2SFmdPius.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsInP2SFmdPius.setDescription('Number of FMD PIUs sent from the Primary LU to the Secondary LU')
ibmappnIsInS2PFmdPius = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 1, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsInS2PFmdPius.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsInS2PFmdPius.setDescription('Number of FMD PIUs sent from the Secondary LU to the Primary LU')
ibmappnIsInP2SNonFmdPius = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 1, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsInP2SNonFmdPius.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsInP2SNonFmdPius.setDescription('Number of non-FMD PIUs sent from the Primary LU to the Secondary LU')
ibmappnIsInS2PNonFmdPius = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 1, 2, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsInS2PNonFmdPius.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsInS2PNonFmdPius.setDescription('Number of non-FMD PIUs sent from the Secondary LU to the Primary LU')
ibmappnIsInP2SFmdBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 1, 2, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsInP2SFmdBytes.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsInP2SFmdBytes.setDescription('Number of FMD Bytes sent from the Primary LU to the Secondary LU')
ibmappnIsInS2PFmdBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 1, 2, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsInS2PFmdBytes.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsInS2PFmdBytes.setDescription('Number of FMD Bytes sent from the Secondary LU to the Primary LU')
ibmappnIsInP2SNonFmdBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 1, 2, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsInP2SNonFmdBytes.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsInP2SNonFmdBytes.setDescription('Number of non-FMD Bytes sent from the Primary LU to the Secondary LU')
ibmappnIsInS2PNonFmdBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 1, 2, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsInS2PNonFmdBytes.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsInS2PNonFmdBytes.setDescription('Number of non-FMD Bytes sent from the Secondary LU to the Primary LU')
ibmappnIsInPsAdjCpName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 1, 2, 1, 21), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsInPsAdjCpName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsInPsAdjCpName.setDescription('The primary stage adjacent CP name of this session.')
ibmappnIsInPsAdjTgNum = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 1, 2, 1, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsInPsAdjTgNum.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsInPsAdjTgNum.setDescription('The primary stage adjacent transmission group (TG) number associated with this session.')
ibmappnIsInPsSendMaxBtuSize = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 1, 2, 1, 23), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsInPsSendMaxBtuSize.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsInPsSendMaxBtuSize.setDescription('The primary stage maximum basic transmission size (BTU) for sending data.')
ibmappnIsInPsSendPacingType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 1, 2, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("fixed", 1), ("adaptive", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsInPsSendPacingType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsInPsSendPacingType.setDescription('The primary stage type of pacing being used for sending data.')
ibmappnIsInPsSendRpc = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 1, 2, 1, 25), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsInPsSendRpc.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsInPsSendRpc.setDescription("The primary stage send residual pace count. This represents the primary stage number of MU's that can still be sent in the current session window.")
ibmappnIsInPsSendNxWndwSize = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 1, 2, 1, 26), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsInPsSendNxWndwSize.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsInPsSendNxWndwSize.setDescription('The primary stage size of the next window which will be used to send data.')
ibmappnIsInPsRecvPacingType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 1, 2, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("fixed", 1), ("adaptive", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsInPsRecvPacingType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsInPsRecvPacingType.setDescription('The primary stage type of pacing being used for receiving data.')
ibmappnIsInPsRecvRpc = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 1, 2, 1, 28), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsInPsRecvRpc.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsInPsRecvRpc.setDescription("The primary stage receive residual pace count. This represents the primary stage number of MU's that can still be received in the current session window.")
ibmappnIsInPsRecvNxWndwSize = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 1, 2, 1, 29), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsInPsRecvNxWndwSize.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsInPsRecvNxWndwSize.setDescription('The primary stage size of the next window which will be used to receive data.')
ibmappnIsInSsAdjCpName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 1, 2, 1, 30), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsInSsAdjCpName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsInSsAdjCpName.setDescription('The secondary stage adjacent CP name of this session.')
ibmappnIsInSsAdjTgNum = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 1, 2, 1, 31), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsInSsAdjTgNum.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsInSsAdjTgNum.setDescription('The secondary stage adjacent transmission group (TG) number associated with this session.')
ibmappnIsInSsSendMaxBtuSize = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 1, 2, 1, 32), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsInSsSendMaxBtuSize.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsInSsSendMaxBtuSize.setDescription('The secondary stage maximum basic transmission size (BTU) for sending data.')
ibmappnIsInSsSendPacingType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 1, 2, 1, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("fixed", 1), ("adaptive", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsInSsSendPacingType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsInSsSendPacingType.setDescription('The secondary stage type of pacing being used for sending data.')
ibmappnIsInSsSendRpc = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 1, 2, 1, 34), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsInSsSendRpc.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsInSsSendRpc.setDescription("The secondary stage send residual pace count. This represents the secondary stage number of MU's that can still be sent in the current session window.")
ibmappnIsInSsSendNxWndwSize = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 1, 2, 1, 35), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsInSsSendNxWndwSize.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsInSsSendNxWndwSize.setDescription('The secondary stage size of the next window which will be used to send data.')
ibmappnIsInSsRecvPacingType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 1, 2, 1, 36), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("fixed", 1), ("adaptive", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsInSsRecvPacingType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsInSsRecvPacingType.setDescription('The secondary stage type of pacing being used for receiving data.')
ibmappnIsInSsRecvRpc = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 1, 2, 1, 37), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsInSsRecvRpc.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsInSsRecvRpc.setDescription("The secondary stage send residual pace count. This represents the secondary stage number of MU's that can still be received in the current session window.")
ibmappnIsInSsRecvNxWndwSize = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 1, 2, 1, 38), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsInSsRecvNxWndwSize.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsInSsRecvNxWndwSize.setDescription('The secondary stage size of the next window which will be used to receive data.')
ibmappnIsInRouteInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 1, 2, 1, 39), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsInRouteInfo.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsInRouteInfo.setDescription("The route selection control vector (RSCV x'2B') used for this session. It is present for APPN nodes; but is not present for LEN nodes. The format of this vector is described in SNA Formats.")
ibmappnIsAcGlobal = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 1))
ibmappnIsAcGlobeStatus = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notActive", 1), ("activeNotFull", 2), ("activeButFull", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsAcGlobeStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcGlobeStatus.setDescription('This object indicates the current status for accounting type. 1. indicates collection is not active for any media type. 2. indicates collection is active for at least one media type; and that media is not full. 3. indicates collection is active for at least one media type; but all active medias are full.')
ibmappnIsAcGlobeByteThresh = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmappnIsAcGlobeByteThresh.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcGlobeByteThresh.setDescription('The byte threshold for recording accounting information for an active session. If the total of the byte counters (FmdBytes and NonFmdBtyes) is an even multiple of this non-zero value, statistics for this session will be recorded to all active buffers. A value of zero indicates that no byte threshold has been set.')
ibmappnIsAcGlobeCheckPt = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ready", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmappnIsAcGlobeCheckPt.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcGlobeCheckPt.setDescription('By setting this value to yes, the agent will collect accounting information for all active sessions. This information will be recorded to all active buffers.')
ibmappnIsAcGlobeMgrUtcSecs = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmappnIsAcGlobeMgrUtcSecs.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcGlobeMgrUtcSecs.setDescription('The managers Coordinated Universal Time (UTC) seconds. It contains an integer from 0 to 59. By setting this value, the agent will create time record with its corresponding time and name. When setting this object, the manager should also set all other ibmappnIsAcGlobeMgr objects with the same SET operation.')
ibmappnIsAcGlobeMgrUtcMins = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmappnIsAcGlobeMgrUtcMins.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcGlobeMgrUtcMins.setDescription('The managers Coordinated Universal Time (UTC) minutes. It contains an integer from 0 to 59. By setting this value, the agent will create time record with its corresponding time and name. When setting this object, the manager should also set all other ibmappnIsAcGlobeMgr objects with the same SET operation.')
ibmappnIsAcGlobeMgrUtcHours = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmappnIsAcGlobeMgrUtcHours.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcGlobeMgrUtcHours.setDescription('The managers Coordinated Universal Time (UTC) hours. It contains an integer from 0 to 23. By setting this value, the agent will create time record with its corresponding time and name. When setting this object, the manager should also set all other ibmappnIsAcGlobeMgr objects with the same SET operation.')
ibmappnIsAcGlobeMgrUtcMdays = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmappnIsAcGlobeMgrUtcMdays.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcGlobeMgrUtcMdays.setDescription('The managers Coordinated Universal Time (UTC) day of the month. It contains an integer from 1 to 31; or 0 if the manager has not set this object. By setting this value, the agent will create time record with its corresponding time and name. When setting this object, the manager should also set all other ibmappnIsAcGlobeMgr objects with the same SET operation.')
ibmappnIsAcGlobeMgrUtcMonths = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))).clone(namedValues=NamedValues(("january", 12), ("february", 1), ("march", 2), ("april", 3), ("may", 4), ("june", 5), ("july", 6), ("august", 7), ("september", 8), ("october", 9), ("november", 10), ("december", 11)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmappnIsAcGlobeMgrUtcMonths.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcGlobeMgrUtcMonths.setDescription('The managers Coordinated Universal Time (UTC) months since January. It contains an integer from 0 to 11. By setting this value, the agent will create time record with its corresponding time and name. When setting this object, the manager should also set all other ibmappnIsAcGlobeMgr objects with the same SET operation.')
ibmappnIsAcGlobeMgrUtcYears = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmappnIsAcGlobeMgrUtcYears.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcGlobeMgrUtcYears.setDescription('The managers Coordinated Universal Time (UTC) years since 1900. By setting this value, the agent will create time record with its corresponding time and name. When setting this object, the manager should also set all other ibmappnIsAcGlobeMgr objects with the same SET operation.')
ibmappnIsAcGlobeMgrUtcWdays = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(7, 1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("sunday", 7), ("monday", 1), ("tuesday", 2), ("wednesday", 3), ("thursday", 4), ("friday", 5), ("saturday", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmappnIsAcGlobeMgrUtcWdays.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcGlobeMgrUtcWdays.setDescription('The managers Coordinated Universal Time (UTC) days since Sunday. It contains an integer from 0 to 6. By setting this value, the agent will create time record with its corresponding time and name. When setting this object, the manager should also set all other ibmappnIsAcGlobeMgr objects with the same SET operation.')
ibmappnIsAcGlobeMgrUtcYdays = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 1, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmappnIsAcGlobeMgrUtcYdays.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcGlobeMgrUtcYdays.setDescription('The managers Coordinated Universal Time (UTC) days since January 1. It contains an integer from 0 to 365. By setting this value, the agent will create time record with its corresponding time and name. When setting this object, the manager should also set all other ibmappnIsAcGlobeMgr objects with the same SET operation.')
ibmappnIsAcGlobeMgrUtcIsdst = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 1, 12), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmappnIsAcGlobeMgrUtcIsdst.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcGlobeMgrUtcIsdst.setDescription('The managers Coordinated Universal Time (UTC) daylight saving time flag. It is positive if daylight saving time is in effect. It is zero if daylight saving time is not in effect. By setting this value, the agent will create time record with its corresponding time and name. When setting this object, the manager should also set all other ibmappnIsAcGlobeMgr objects with the same SET operation.')
ibmappnIsAcGlobeMgrName = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 1, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 17))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmappnIsAcGlobeMgrName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcGlobeMgrName.setDescription('The name of the manager who set the manager UTC times or NULL if the manager name has not been set. It contains: a. the network id of the manager, b. a period (.) c. the cp name of the manager. By setting this value, the agent will create time record with its corresponding time and name. When setting this object, the manager should also set all other ibmappnIsAcGlobeMgr objects with the same SET operation.')
ibmappnIsAcBtypeTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 2), )
if mibBuilder.loadTexts: ibmappnIsAcBtypeTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcBtypeTable.setDescription('Intermediate Session Accounting Buffer Type Table')
ibmappnIsAcBtypeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 2, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmappnIsAcBtypeMedia"))
if mibBuilder.loadTexts: ibmappnIsAcBtypeEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcBtypeEntry.setDescription('Entry of Intermediate Session Accounting Buffer Type Table.')
ibmappnIsAcBtypeMedia = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("memory", 1), ("dasd", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsAcBtypeMedia.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcBtypeMedia.setDescription('The media for storing the intermediate session accounting records.')
ibmappnIsAcBtypeActive = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmappnIsAcBtypeActive.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcBtypeActive.setDescription('Indicates whether or not the buffer media is active. 1. no: indicates the buffer media is not currently used for recording. 2. yes: indicates the buffer media is currently being used for recording.')
ibmappnIsAcBtypeDirName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 2, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsAcBtypeDirName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcBtypeDirName.setDescription('The name of the directory which will be used to allocate and write buffers of this type. For memory buffer types, this field will be NULL.')
ibmappnIsAcBtypePrdMaxBufs = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsAcBtypePrdMaxBufs.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcBtypePrdMaxBufs.setDescription('The maximum number of buffer medias supported by the product.')
ibmappnIsAcBtypeMaxBufs = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 2, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmappnIsAcBtypeMaxBufs.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcBtypeMaxBufs.setDescription('The maximum number of buffer medias which will be used for recording accounting information. This value must be in the range of zero to the Product Maximum.')
ibmappnIsAcBtypeCurBufs = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 2, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsAcBtypeCurBufs.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcBtypeCurBufs.setDescription('The current number of buffer media. This is the sum of all full and in use buffers of this type.')
ibmappnIsAcBtypePrdRecPerBuf = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsAcBtypePrdRecPerBuf.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcBtypePrdRecPerBuf.setDescription('The maximum number of records supported by the product.')
ibmappnIsAcBtypeRecPerBuf = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 2, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmappnIsAcBtypeRecPerBuf.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcBtypeRecPerBuf.setDescription('The maximum number of records which will be recorded in an individual buffer. This value must be in the range of zero to the Product Maximum.')
ibmappnIsAcBtypeRecFormat = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ascii", 1), ("binary", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmappnIsAcBtypeRecFormat.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcBtypeRecFormat.setDescription('This defines the recording format of records. (1) ascii: records are recorded in ascii (english text format) (2) binary: records are recorded in binary (machine readable format)')
ibmappnIsAcBtypeFullAction = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("halt", 1), ("wrap", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmappnIsAcBtypeFullAction.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcBtypeFullAction.setDescription('This defines the behaviour used when all buffer medias are full. (1) halt: stop creating new records (2) wrap: overwrite the existing records.')
ibmappnIsAcBtypeFullTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 2, 1, 11), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsAcBtypeFullTime.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcBtypeFullTime.setDescription('The time which the full condition was encountered. This time is represented in hundreds of a second since the node was started. 2**32-1 (4,294,967,295), and wraps.')
ibmappnIsAcBtypeFullReason = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notFull", 1), ("physicallyFull", 2), ("logicallyFull", 3), ("ioErrors", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsAcBtypeFullReason.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcBtypeFullReason.setDescription('The reason the buffer media is full. (1) The media is not full. (2) The maximum number of buffers have been reach, all buffers are full and the full action is halt. (3) The maximum number of buffers is zero or the maximum number of records is less than 5 or a unique record number cannot be generated. (4) Unable to write to the media due to I/O errors.')
ibmappnIsAcBtypeFullWraps = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 2, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsAcBtypeFullWraps.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcBtypeFullWraps.setDescription('The number of accounting records being overwritten due to buffer full situation.')
ibmappnIsAcBtypeFullLosts = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 2, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsAcBtypeFullLosts.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcBtypeFullLosts.setDescription('The number of new accounting records lost due to the buffer full situation.')
ibmappnIsAcBtypeErrorWraps = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 2, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsAcBtypeErrorWraps.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcBtypeErrorWraps.setDescription('The number of accounting records lost to due to other reasons, (e.g. I/O error, software error) while in a wrap condition.')
ibmappnIsAcBtypeErrorLosts = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 2, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsAcBtypeErrorLosts.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcBtypeErrorLosts.setDescription('The number of accounting records lost to due to other reasons, (e.g. I/O error, software error) while not in a full condition.')
ibmappnIsAcBtypeCheckPts = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 2, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsAcBtypeCheckPts.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcBtypeCheckPts.setDescription('The number of times a buffer of this type has been recorded to for checkpointing active intermediate sessions.')
ibmappnIsAcBtypePurges = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 2, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsAcBtypePurges.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcBtypePurges.setDescription('The number of times a buffer of this type has been purged.')
ibmappnIsAcBtypeDeletes = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 2, 1, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsAcBtypeDeletes.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcBtypeDeletes.setDescription('The number of times an entry has been deleted from a buffer of this type.')
ibmappnIsAcBtypeResets = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 2, 1, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsAcBtypeResets.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcBtypeResets.setDescription('The number of times the Btype counters have been reset as a result of a SET.')
ibmappnIsAcBtypeClearStats = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 2, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ready", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmappnIsAcBtypeClearStats.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcBtypeClearStats.setDescription('By setting this object to yes, all statistics for this media type will be cleared (set to zero); and the Btype reset counter will be incremented. Objects affected by this include: - ibmappnIsAcBtypeFullTime - ibmappnIsAcBtypeFullReason - ibmappnIsAcBtypeFullWraps - ibmappnIsAcBtypeFullLosts - ibmappnIsAcBtypeErrorWraps - ibmappnIsAcBtypeErrorLosts - ibmappnIsAcBtypeCheckPts - ibmappnIsAcBtypePurges - ibmappnIsAcBtypeDeletes')
ibmappnIsAcBufTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 3), )
if mibBuilder.loadTexts: ibmappnIsAcBufTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcBufTable.setDescription('Intermediate Session Accounting Buffer Table')
ibmappnIsAcBufEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 3, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmappnIsAcBufMedia"), (0, "IBM6611-MIB", "ibmappnIsAcBufNumber"))
if mibBuilder.loadTexts: ibmappnIsAcBufEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcBufEntry.setDescription('Entry of Intermediate Session Accounting Buffer Table.')
ibmappnIsAcBufMedia = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("memory", 1), ("dasd", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsAcBufMedia.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcBufMedia.setDescription('The media for storing the intermediate session accounting records.')
ibmappnIsAcBufNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsAcBufNumber.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcBufNumber.setDescription('Number of the buffer. Each time a new buffer is used for recording, an incremented number will be assigned. Thus, the order of in which the buffers filled can be determined.')
ibmappnIsAcBufState = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("complete", 1), ("active", 2), ("purge", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmappnIsAcBufState.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcBufState.setDescription('The current buffer state. 1. complete: indicates the buffer is full or recording is not active for this buffer. In either case, the buffer is ready to be retrieved. This value may be specified in a SET operation to change a buffers state from active to complete. 2. active: indicates the buffer is currently being used for recording. This value is not valid for use in a SET operation. 3. purge: indicates the buffer should be purged. This value may be specified in a SET operation to remove a buffer. Specification of this value is only valid for complete buffers. It is not valid for active buffers.')
ibmappnIsAcBufRecFormat = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ascii", 1), ("binary", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsAcBufRecFormat.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcBufRecFormat.setDescription('This defines the recording format of records. (1) ascii: records are recorded in ascii (english text format) (2) binary: records are recorded in binary (machine readable format)')
ibmappnIsAcBufMaxRecords = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 3, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsAcBufMaxRecords.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcBufMaxRecords.setDescription('The maximum number of records this buffer may contain. It is derived from the number of records per buffer set in the buffer type table.')
ibmappnIsAcBufOldestIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 3, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmappnIsAcBufOldestIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcBufOldestIndex.setDescription('The oldest accounting index contained in this buffer. By setting this object, all records with indexes less than this value will be deleted. The set value must be greater than or equal to the current oldest index and less than or equal to the current newest index. Setting of this object will not be honored for all types of buffers.')
ibmappnIsAcBufNewestIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 3, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsAcBufNewestIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcBufNewestIndex.setDescription('The newest accounting index contained in this buffer.')
ibmappnIsAcBufName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 3, 1, 8), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsAcBufName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcBufName.setDescription('The name of the buffer.')
ibmappnIsAcTimeTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 4), )
if mibBuilder.loadTexts: ibmappnIsAcTimeTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcTimeTable.setDescription('Intermediate Session Accounting Time Table')
ibmappnIsAcTimeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 4, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmappnIsAcTimeIndex"))
if mibBuilder.loadTexts: ibmappnIsAcTimeEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcTimeEntry.setDescription('Entry of Intermediate Session Accounting Time Table.')
ibmappnIsAcTimeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsAcTimeIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcTimeIndex.setDescription('Intermediate Session Time record index. It starts with 0, and increase up to maximum value of 2**31-1 (2,147,483,647), and wraps.')
ibmappnIsAcTimeEntryType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("startCollection", 1), ("endCollection", 2), ("createdMedia", 3), ("wrappedMedia", 4), ("timeChange", 5), ("managerSetTime", 6), ("recordFormatChanged", 7), ("timeReference", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsAcTimeEntryType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcTimeEntryType.setDescription('Indicates whether the entry was made as the result of: 1. a SET to start collecting accounting data, or 2. a SET to stop collecting accounting data, or 3. the creation of a new media to store accounting data, or 4. a media was full and wrapped (over writing records), or 5. the system time changed, or 6. a manager set the manager times and/or manager name, or 7. the record format for this media changed, or 8. time reference for the media')
ibmappnIsAcTimeForMedia = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 99))).clone(namedValues=NamedValues(("memoryMedia", 1), ("dasdMedia", 2), ("allMedias", 99)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsAcTimeForMedia.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcTimeForMedia.setDescription('This object qualifies the time entry type. It indicates the media type for which the entry occured.')
ibmappnIsAcTimeRecTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 4, 1, 4), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsAcTimeRecTime.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcTimeRecTime.setDescription('Intermediate Session Record time. It represents the time in hundreds of a second since the node was started. 2**32-1 (4,294,967,295), and wraps.')
ibmappnIsAcTimeAgtUtcSecs = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 4, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsAcTimeAgtUtcSecs.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcTimeAgtUtcSecs.setDescription('The agents Coordinated Universal Time (UTC) seconds. It contains an integer from 0 to 59.')
ibmappnIsAcTimeAgtUtcMins = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 4, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsAcTimeAgtUtcMins.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcTimeAgtUtcMins.setDescription('The agents Coordinated Universal Time (UTC) minutes. It contains an integer from 0 to 59.')
ibmappnIsAcTimeAgtUtcHours = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 4, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsAcTimeAgtUtcHours.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcTimeAgtUtcHours.setDescription('The agents Coordinated Universal Time (UTC) hours. It contains an integer from 0 to 23.')
ibmappnIsAcTimeAgtUtcMdays = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 4, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsAcTimeAgtUtcMdays.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcTimeAgtUtcMdays.setDescription('The agents Coordinated Universal Time (UTC) day of the month. It contains an integer from 1 to 31.')
ibmappnIsAcTimeAgtUtcMonths = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 4, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))).clone(namedValues=NamedValues(("january", 12), ("february", 1), ("march", 2), ("april", 3), ("may", 4), ("june", 5), ("july", 6), ("august", 7), ("september", 8), ("october", 9), ("november", 10), ("december", 11)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsAcTimeAgtUtcMonths.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcTimeAgtUtcMonths.setDescription('The agents Coordinated Universal Time (UTC) months since January. It contains an integer from 0 to 11.')
ibmappnIsAcTimeAgtUtcYears = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 4, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsAcTimeAgtUtcYears.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcTimeAgtUtcYears.setDescription('The agents Coordinated Universal Time (UTC) years since 1900.')
ibmappnIsAcTimeAgtUtcWdays = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 4, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(7, 1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("sunday", 7), ("monday", 1), ("tuesday", 2), ("wednesday", 3), ("thursday", 4), ("friday", 5), ("saturday", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsAcTimeAgtUtcWdays.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcTimeAgtUtcWdays.setDescription('The agents Coordinated Universal Time (UTC) days since Sunday. It contains an integer from 0 to 6.')
ibmappnIsAcTimeAgtUtcYdays = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 4, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsAcTimeAgtUtcYdays.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcTimeAgtUtcYdays.setDescription('The agents Coordinated Universal Time (UTC) days since January 1. It contains an integer from 0 to 365.')
ibmappnIsAcTimeAgtUtcIsdst = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 4, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsAcTimeAgtUtcIsdst.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcTimeAgtUtcIsdst.setDescription('The agents Coordinated Universal Time (UTC) daylight saving time flag. It is positive if daylight saving time is in effect. It is zero if daylight saving time is not in effect.')
ibmappnIsAcTimeAgtName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 4, 1, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsAcTimeAgtName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcTimeAgtName.setDescription('The name of the agent who set the agent UTC times. It contains: a. the network id of the agent, b. a period (.) c. the cp name of the agent.')
ibmappnIsAcTimeMgrUtcSecs = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 4, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsAcTimeMgrUtcSecs.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcTimeMgrUtcSecs.setDescription('The managers Coordinated Universal Time (UTC) seconds. It contains an integer from 0 to 59.')
ibmappnIsAcTimeMgrUtcMins = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 4, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsAcTimeMgrUtcMins.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcTimeMgrUtcMins.setDescription('The managers Coordinated Universal Time (UTC) minutes. It contains an integer from 0 to 59.')
ibmappnIsAcTimeMgrUtcHours = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 4, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsAcTimeMgrUtcHours.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcTimeMgrUtcHours.setDescription('The managers Coordinated Universal Time (UTC) hours. It contains an integer from 0 to 23.')
ibmappnIsAcTimeMgrUtcMdays = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 4, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsAcTimeMgrUtcMdays.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcTimeMgrUtcMdays.setDescription('The managers Coordinated Universal Time (UTC) day of the month. It contains an integer from 1 to 31; or 0 if the manager has not set this object.')
ibmappnIsAcTimeMgrUtcMonths = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 4, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))).clone(namedValues=NamedValues(("january", 12), ("february", 1), ("march", 2), ("april", 3), ("may", 4), ("june", 5), ("july", 6), ("august", 7), ("september", 8), ("october", 9), ("november", 10), ("december", 11)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsAcTimeMgrUtcMonths.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcTimeMgrUtcMonths.setDescription('The managers Coordinated Universal Time (UTC) months since January. It contains an integer from 0 to 11.')
ibmappnIsAcTimeMgrUtcYears = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 4, 1, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsAcTimeMgrUtcYears.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcTimeMgrUtcYears.setDescription('The managers Coordinated Universal Time (UTC) years since 1900.')
ibmappnIsAcTimeMgrUtcWdays = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 4, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(7, 1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("sunday", 7), ("monday", 1), ("tuesday", 2), ("wednesday", 3), ("thursday", 4), ("friday", 5), ("saturday", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsAcTimeMgrUtcWdays.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcTimeMgrUtcWdays.setDescription('The managers Coordinated Universal Time (UTC) days since Sunday. It contains an integer from 0 to 6.')
ibmappnIsAcTimeMgrUtcYdays = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 4, 1, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsAcTimeMgrUtcYdays.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcTimeMgrUtcYdays.setDescription('The managers Coordinated Universal Time (UTC) days since January 1. It contains an integer from 0 to 365.')
ibmappnIsAcTimeMgrUtcIsdst = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 4, 1, 23), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsAcTimeMgrUtcIsdst.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcTimeMgrUtcIsdst.setDescription('The managers Coordinated Universal Time (UTC) daylight saving time flag. It is positive if daylight saving time is in effect. It is zero if daylight saving time is not in effect.')
ibmappnIsAcTimeMgrName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 4, 1, 24), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsAcTimeMgrName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcTimeMgrName.setDescription('The name of the manager who set the manager UTC times or NULL if the manager name has not been set. It contains: a. the network id of the manager, b. a period (.) c. the cp name of the manager.')
ibmappnIsAcTimeMgrTimeValid = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 4, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notvalid", 1), ("valid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmappnIsAcTimeMgrTimeValid.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcTimeMgrTimeValid.setDescription('This indicates whether or not the the manager UTC times are valid. It is set by the manager if the manager determines the manager UTC times are valid.')
ibmappnIsAcDataTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 5), )
if mibBuilder.loadTexts: ibmappnIsAcDataTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcDataTable.setDescription('Intermediate Session Accounting Data Table')
ibmappnIsAcDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 5, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmappnIsAcIndex"))
if mibBuilder.loadTexts: ibmappnIsAcDataEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcDataEntry.setDescription('Entry of Intermediate Session Accounting Data Table.')
ibmappnIsAcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsAcIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcIndex.setDescription('Session accounting record index. Upon initial startup, it will begin with 0, and increase up to maximum value of 2**31-1 (2,147,483,647), and wraps. Upon subsequent startups, it will be initialized with the value of the oldest index in any media type; or 0 if no indices are found.')
ibmappnIsAcEntryType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("startEntry", 1), ("endEntry", 2), ("thresholdEntry", 3), ("checkpointEntry", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsAcEntryType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcEntryType.setDescription('Indicates whether the entry was made as the result of: 1. a session starting or, 2. a session ending or, 3. a session threshold reached or 4. a session checkpoint request')
ibmappnIsAcRecTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 5, 1, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsAcRecTime.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcRecTime.setDescription('Intermediate Session Record time. It represents the time in hundreds of a second since the node was started. 2**32-1 (4,294,967,295), and wraps.')
ibmappnIsAcFqLuName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 5, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsAcFqLuName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcFqLuName.setDescription('The network-qualified CP name or PU name of the node at which the session and pcid originated. For APPN and LEN nodes, this is either CP name of the APPN node at which the origin LU is located or the CP name of the NN serving the LEN node at which the origin LU is located. This field is from 3 to 17 characters in length, including a period (.) which separates the NetId from the NAU name.')
ibmappnIsAcPcid = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 5, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsAcPcid.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcPcid.setDescription('The procedure correlation identifier (pcid) of a session. It is an 8-octet value assigned by the primary LU.')
ibmappnIsAcPriLuName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 5, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsAcPriLuName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcPriLuName.setDescription('Primary LU Name of the session.')
ibmappnIsAcSecLuName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 5, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsAcSecLuName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcSecLuName.setDescription('Secondary LU Name of the session.')
ibmappnIsAcModeName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 5, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsAcModeName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcModeName.setDescription('The mode name used for this session')
ibmappnIsAcCosName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 5, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsAcCosName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcCosName.setDescription('The class of service (cos) used for this session')
ibmappnIsAcTransPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 5, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("low", 1), ("medium", 2), ("high", 3), ("network", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsAcTransPriority.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcTransPriority.setDescription('Transmission priority for this session. The values are: 1. Low 2. Medium 3. High 4. Network')
ibmappnIsAcSessType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 5, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("lu62", 1), ("lu0thru3", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsAcSessType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcSessType.setDescription('The type of intermediate session.')
ibmappnIsAcSessState = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 5, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("inactive", 1), ("pendactive", 2), ("active", 3), ("pendinact", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsAcSessState.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcSessState.setDescription('Indicates the state of the session. 1. session is pending inactive or, 2. session is pending active or, 3. session is active or, 4. session is inactive ')
ibmappnIsAcSessStartTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 5, 1, 13), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsAcSessStartTime.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcSessStartTime.setDescription('Time when the session started in hundreds of a second.')
ibmappnIsAcSessUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 5, 1, 14), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsAcSessUpTime.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcSessUpTime.setDescription('Length of time the session has been active in hundreds of a second.')
ibmappnIsAcCtrUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 5, 1, 15), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsAcCtrUpTime.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcCtrUpTime.setDescription('Length of time the session counters have been active in hundreds of a second.')
ibmappnIsAcEndReason = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 5, 1, 16), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsAcEndReason.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcEndReason.setDescription('The SNA sense code which resulted when the session ended.')
ibmappnIsAcP2SFmdPius = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 5, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsAcP2SFmdPius.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcP2SFmdPius.setDescription("The number of FMD PIU's sent from the primary LU to the secondary LU. The counter has a range of of 0 to 2**32; and then wraps.")
ibmappnIsAcS2PFmdPius = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 5, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsAcS2PFmdPius.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcS2PFmdPius.setDescription("The number of FMD PIU's sent from the secondary LU to the primary LU. The counter has a range of of 0 to 2**32; and then wraps.")
ibmappnIsAcP2SNonFmdPius = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 5, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsAcP2SNonFmdPius.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcP2SNonFmdPius.setDescription("The number of non-FMD PIU's sent from the primary LU to the secondary LU. The counter has a range of of 0 to 2**32; and then wraps.")
ibmappnIsAcS2PNonFmdPius = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 5, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsAcS2PNonFmdPius.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcS2PNonFmdPius.setDescription("The number of non-FMD PIU's sent from the secondary LU to the primary LU. The counter has a range of of 0 to 2**32; and then wraps.")
ibmappnIsAcP2SFmdBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 5, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsAcP2SFmdBytes.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcP2SFmdBytes.setDescription('The number of FMD bytes sent from the primary LU to the secondary LU. The counter has a range of of 0 to 2**32; and then wraps.')
ibmappnIsAcS2PFmdBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 5, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsAcS2PFmdBytes.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcS2PFmdBytes.setDescription('The number of FMD bytes sent from the secondary LU to the primary LU. The counter has a range of of 0 to 2**32; and then wraps.')
ibmappnIsAcP2SNonFmdBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 5, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsAcP2SNonFmdBytes.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcP2SNonFmdBytes.setDescription('The number of non-FMD bytes sent from the primary LU to the secondary LU. The counter has a range of of 0 to 2**32; and then wraps.')
ibmappnIsAcS2PNonFmdBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 5, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsAcS2PNonFmdBytes.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcS2PNonFmdBytes.setDescription('The number of non-FMD bytes sent from the secondary LU to the primary LU. The counter has a range of of 0 to 2**32; and then wraps.')
ibmappnIsAcRouteInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 3, 2, 5, 1, 25), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnIsAcRouteInfo.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnIsAcRouteInfo.setDescription("The route selection control vector (RSCV x'2B') used for this session. It is present for APPN nodes; but is not present for LEN nodes.")
ibmappcInformation = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1))
ibmappcInGlobal = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 1))
ibmappcInGlobeStatus = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notActive", 1), ("active", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmappcInGlobeStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInGlobeStatus.setDescription('Indicates the current collection options in effect: 1. notActive: collection of counters and some names is not active. 2. active: collection of counters and some names is active.')
ibmappcInGlobeRscv = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notActive", 1), ("active", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmappcInGlobeRscv.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInGlobeRscv.setDescription('Indicates the current collection options in effect: 1. notActive: collection of route selection control vectors is not active. 2. active: collection of route selection control vectors is active.')
ibmappcInGlobeRscvTime = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 1, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInGlobeRscvTime.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInGlobeRscvTime.setDescription('Time when the ibmappcInGlobeRscv object last changed. This time is in hundreds of a second.')
ibmappcInGlobeCtrStatus = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notActive", 1), ("active", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmappcInGlobeCtrStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInGlobeCtrStatus.setDescription('Indicates whether or not the appc session counters are active. This object reflects the combination of the ibmappcInGlobeStatus object and any other product dependant object(s). The values are: 1. notActive: collection of counters and some names is not active. 2. active: collection of counters and some names is active.')
ibmappcInGlobeCtrStatusTime = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 1, 5), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInGlobeCtrStatusTime.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInGlobeCtrStatusTime.setDescription('Time when the ibmappcInGlobeCtrStatus object last changed. This time is in hundreds of a second.')
ibmappcInGlobeActSess = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInGlobeActSess.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInGlobeActSess.setDescription('Number of currently active APPC sessions')
ibmappcInLluTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 2), )
if mibBuilder.loadTexts: ibmappcInLluTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInLluTable.setDescription('APPC Local Lu Table')
ibmappcInLluEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 2, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmappcInLluLuName"))
if mibBuilder.loadTexts: ibmappcInLluEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInLluEntry.setDescription('Entry of APPC Local Lu Information Table.')
ibmappcInLluLuName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 2, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInLluLuName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInLluLuName.setDescription('The network-qualified LU name. This field is from 3 to 17 characters in length, including a period (.) which separates the NetId from the NAU name.')
ibmappcInLluDefType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("sysdef", 1), ("dynamic", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInLluDefType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInLluDefType.setDescription('Indicates whether the LU definition was specified in the nodes system definitions or was dynamically created.')
ibmappcInLluSessLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInLluSessLimit.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInLluSessLimit.setDescription('The maximum number of session supported by this LU.')
ibmappcInLluBindRspMayQ = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInLluBindRspMayQ.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInLluBindRspMayQ.setDescription('Indicates whether or not a received bind response will be queued if the LU is not currently active.')
ibmappcInLluDefaultLu = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInLluDefaultLu.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInLluDefaultLu.setDescription('Indicates whether the LU is the default LU for the node.')
ibmappcInLluCntlPtLu = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInLluCntlPtLu.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInLluCntlPtLu.setDescription('Indicates whether or not the LU is the control point (CP) LU.')
ibmappcInLluCurActSess = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 2, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInLluCurActSess.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInLluCurActSess.setDescription('The number of currently active sessions.')
ibmappcInRluTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 3), )
if mibBuilder.loadTexts: ibmappcInRluTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInRluTable.setDescription('APPC Remote Partner Lu Table')
ibmappcInRluEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 3, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmappcInRluLocLuName"), (0, "IBM6611-MIB", "ibmappcInRluParLuName"))
if mibBuilder.loadTexts: ibmappcInRluEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInRluEntry.setDescription('Entry of APPC Remote Partner Lu Information Table.')
ibmappcInRluLocLuName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 3, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInRluLocLuName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInRluLocLuName.setDescription('The network-qualified local LU name. This field is from 3 to 17 characters in length, including a period (.) which separates the NetId from the NAU name.')
ibmappcInRluParLuName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 3, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInRluParLuName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInRluParLuName.setDescription('The network-qualified partner LU name. This field is from 3 to 17 characters in length, including a period (.) which separates the NetId from the NAU name.')
ibmappcInRluParLuLocName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 3, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInRluParLuLocName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInRluParLuLocName.setDescription('The network-qualified partner LU local name. This field is from 3 to 17 characters in length, including a period (.) which separates the NetId from the NAU name.')
ibmappcInRluDefType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("sysdef", 1), ("dynamic", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInRluDefType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInRluDefType.setDescription('Indicates whether the LU definition was specified in the nodes system definitions or was dynamically created.')
ibmappcInRluDefParaSessSup = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInRluDefParaSessSup.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInRluDefParaSessSup.setDescription('Defined Parallel Sessions Supported. Indicates whether or not multiple session between the partner LU and its associated local LU are permitted.')
ibmappcInRluDefCnosSup = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInRluDefCnosSup.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInRluDefCnosSup.setDescription('Defined CNOS Supported. Indicates whether or not Change Number of Sessions (CNOS) will be used to negotiate session limits between the logical points.')
ibmappcInRluDefAllVerSup = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInRluDefAllVerSup.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInRluDefAllVerSup.setDescription('Defined Already Verified Accepted. Indicates whether or not an attach, specifying that TP security has already been verified, is accepted by the adjacent CP LU.')
ibmappcInRluDefAttSecSup = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInRluDefAttSecSup.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInRluDefAttSecSup.setDescription('Defined Attach Security Supported. Indicates whether or not the adjacent CP LU supports attach security.')
ibmappcInRluDefSessSecSup = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 3, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInRluDefSessSecSup.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInRluDefSessSecSup.setDescription('Defined Session Security Supported. Indicates whether or not the adjacent CP LU may omit a password in the user data portion of the BIND.')
ibmappcInRluDefEnhanSecSup = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 3, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("level1", 2), ("level2", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInRluDefEnhanSecSup.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInRluDefEnhanSecSup.setDescription('Defined Enhance Security Supported. Indicates the level of enhance security support: 1 = none 2 = level 1 3 = level 2')
ibmappcInRluActType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 3, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("notActive", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInRluActType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInRluActType.setDescription('Indicates whether the LU active definitions are currently active or not currently active.')
ibmappcInRluActParaSessSup = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 3, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInRluActParaSessSup.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInRluActParaSessSup.setDescription('Active Parallel Sessions Supported. Indicates whether or not multiple session between the partner LU and its associated local LU are permitted.')
ibmappcInRluActCnosSup = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 3, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInRluActCnosSup.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInRluActCnosSup.setDescription('Active CNOS Supported. Indicates whether or not Change Number of Sessions (CNOS) will be used to negotiate session limits between the logical points.')
ibmappcInRluActAllVerSup = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 3, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInRluActAllVerSup.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInRluActAllVerSup.setDescription('Active Already Verified Accepted. Indicates whether or not an attach, specifying that TP security has already been verified, is accepted by the adjacent CP LU.')
ibmappcInRluActAttSecSup = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 3, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInRluActAttSecSup.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInRluActAttSecSup.setDescription('Active Attach Security Supported. Indicates whether or not the adjacent CP LU supports attach security.')
ibmappcInRluActSessSecSup = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 3, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInRluActSessSecSup.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInRluActSessSecSup.setDescription('Active Session Security Supported. Indicates whether or not the adjacent CP LU may omit a password in the user data portion of the BIND.')
ibmappcInRluActEnhanSecSup = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 3, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("level1", 2), ("level2", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInRluActEnhanSecSup.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInRluActEnhanSecSup.setDescription('Active Enhance Security Supported. Indicates the level of enhance security support: 1 = none 2 = level 1 3 = level 2')
ibmappcInMdTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 4), )
if mibBuilder.loadTexts: ibmappcInMdTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInMdTable.setDescription('APPC Mode Table')
ibmappcInMdEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 4, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmappcInMdLluName"), (0, "IBM6611-MIB", "ibmappcInMdRluName"), (0, "IBM6611-MIB", "ibmappcInMdModeName"))
if mibBuilder.loadTexts: ibmappcInMdEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInMdEntry.setDescription('Entry of APPC Mode Information Table.')
ibmappcInMdLluName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 4, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInMdLluName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInMdLluName.setDescription('The network-qualified local LU name. This field is from 3 to 17 characters in length, including a period (.) which separates the NetId from the NAU name.')
ibmappcInMdRluName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 4, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInMdRluName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInMdRluName.setDescription('The network-qualified remote LU name. This field is from 3 to 17 characters in length, including a period (.) which separates the NetId from the NAU name.')
ibmappcInMdModeName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 4, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInMdModeName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInMdModeName.setDescription('The mode name.')
ibmappcInMdDefType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("sysdef", 1), ("dynamic", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInMdDefType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInMdDefType.setDescription('Indicates whether the mode definition was specified in the nodes system definitions or was dynamically created.')
ibmappcInMdSessEndTpName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 4, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInMdSessEndTpName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInMdSessEndTpName.setDescription('The session end point transaction program name.')
ibmappcInMdSessLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 4, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInMdSessLimit.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInMdSessLimit.setDescription('Session Limit. Identifies the total number of sessions that can be established with the partner LU.')
ibmappcInMdMaxSessLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 4, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInMdMaxSessLimit.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInMdMaxSessLimit.setDescription('Maximum Session Limit. Specifies the maximum number of sessions supported by the LU pair using this mode name.')
ibmappcInMdAutoActLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 4, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInMdAutoActLimit.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInMdAutoActLimit.setDescription('Auto Activate Limit. Specifies the maximum number of sessions which can be activated when this mode is active.')
ibmappcInMdDrainSelf = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 4, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInMdDrainSelf.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInMdDrainSelf.setDescription('Drain Self. Indicates whether or not the local LU can be drained.')
ibmappcInMdDrainPart = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 4, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInMdDrainPart.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInMdDrainPart.setDescription('Drain Partner. Indicates whether or not the partner LU can be drained.')
ibmappcInMdMinCwinLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 4, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInMdMinCwinLimit.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInMdMinCwinLimit.setDescription('Minimum Conwinners Limit. Identifies the minimum number of conwinner sessions.')
ibmappcInMdMinClosLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 4, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInMdMinClosLimit.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInMdMinClosLimit.setDescription('Minimum Conlossers Limit. Identifies the minimum number of conloser sessions.')
ibmappcInMdRecvPacWinSz = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 4, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInMdRecvPacWinSz.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInMdRecvPacWinSz.setDescription('The size of the receive pacing window.')
ibmappcInMdSendPacWinSz = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 4, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInMdSendPacWinSz.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInMdSendPacWinSz.setDescription('The size of the send pacing window.')
ibmappcInMdPrefRecvRuSz = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 4, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInMdPrefRecvRuSz.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInMdPrefRecvRuSz.setDescription('The preferred receive ru size.')
ibmappcInMdPrefSendRuSz = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 4, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInMdPrefSendRuSz.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInMdPrefSendRuSz.setDescription('The preferred send ru size.')
ibmappcInMdRecvRuSzUpBnd = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 4, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInMdRecvRuSzUpBnd.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInMdRecvRuSzUpBnd.setDescription('The receive ru upper boundary size.')
ibmappcInMdSendRuSzUpBnd = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 4, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInMdSendRuSzUpBnd.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInMdSendRuSzUpBnd.setDescription('The send ru upper boundary size.')
ibmappcInMdRecvRuSzLoBnd = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 4, 1, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInMdRecvRuSzLoBnd.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInMdRecvRuSzLoBnd.setDescription('The receive ru lower boundary size.')
ibmappcInMdSendRuSzLoBnd = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 4, 1, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInMdSendRuSzLoBnd.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInMdSendRuSzLoBnd.setDescription('The send ru lower boundary size.')
ibmappcInMdDfSyncLvl = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 4, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("confirm", 2), ("syncPoint", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInMdDfSyncLvl.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInMdDfSyncLvl.setDescription('The defined sync level.')
ibmappcInMdAcSyncLvl = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 4, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("confirm", 2), ("syncPoint", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInMdAcSyncLvl.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInMdAcSyncLvl.setDescription('The active sync level.')
ibmappcInMdDfCrypto = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 4, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInMdDfCrypto.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInMdDfCrypto.setDescription('Defined cryoptograhy supported.')
ibmappcInMdAcCrypto = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 4, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInMdAcCrypto.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInMdAcCrypto.setDescription('Active cryptography supported.')
ibmappcInMdReinit = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 4, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("operatorControlled", 1), ("primaryOnly", 2), ("secondaryOnly", 3), ("primaryOrSecondary", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInMdReinit.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInMdReinit.setDescription('The reinitialization parameter.')
ibmappcInMdAltCode = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 4, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInMdAltCode.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInMdAltCode.setDescription('Alternate code supported.')
ibmappcInMdActCwin = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 4, 1, 27), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInMdActCwin.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInMdActCwin.setDescription('The number of active conwinners.')
ibmappcInMdActClos = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 4, 1, 28), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInMdActClos.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInMdActClos.setDescription('The number of active conlosers.')
ibmappcInMdPndCwin = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 4, 1, 29), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInMdPndCwin.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInMdPndCwin.setDescription('The number of pending conwinners.')
ibmappcInMdPndClos = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 4, 1, 30), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInMdPndClos.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInMdPndClos.setDescription('The number of pending conlosers.')
ibmappcInMdPtmCwin = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 4, 1, 31), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInMdPtmCwin.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInMdPtmCwin.setDescription('The number of pending termination conlosers.')
ibmappcInMdPtmClos = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 4, 1, 32), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInMdPtmClos.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInMdPtmClos.setDescription('The number of pending termination conwinners.')
ibmappcInMdFreeSessLst = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 4, 1, 33), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInMdFreeSessLst.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInMdFreeSessLst.setDescription('The size of the free seesion list.')
ibmappcInMdWaitReqLst = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 4, 1, 34), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInMdWaitReqLst.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInMdWaitReqLst.setDescription('The size of the waiting request list.')
ibmappcInLtpTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 5), )
if mibBuilder.loadTexts: ibmappcInLtpTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInLtpTable.setDescription('APPC Local TP Table')
ibmappcInLtpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 5, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmappcInLtpLuName"), (0, "IBM6611-MIB", "ibmappcInLtpTpName"))
if mibBuilder.loadTexts: ibmappcInLtpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInLtpEntry.setDescription('Entry of APPC Local TP Information Table.')
ibmappcInLtpLuName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 5, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInLtpLuName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInLtpLuName.setDescription('The network-qualified local LU name. This field is from 3 to 17 characters in length, including a period (.) which separates the NetId from the NAU name.')
ibmappcInLtpTpName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 5, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInLtpTpName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInLtpTpName.setDescription('The local transaction program name.')
ibmappcInLtpDefType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("sysdef", 1), ("dynamic", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInLtpDefType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInLtpDefType.setDescription('The TP definition type. Indicates whether the TP was specified in the nodes system definitions or was dynamically created.')
ibmappcInLtpSyncLvl = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 5, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("confirm", 2), ("syncPoint", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInLtpSyncLvl.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInLtpSyncLvl.setDescription('The TP synchroniztion level.')
ibmappcInLtpInstLmt = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 5, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInLtpInstLmt.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInLtpInstLmt.setDescription('The TP instance limit.')
ibmappcInLtpInstNum = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 5, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInLtpInstNum.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInLtpInstNum.setDescription('The number of TP instances.')
ibmappcInLtpStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 5, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("tempDisabled", 2), ("permDisabled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInLtpStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInLtpStatus.setDescription('The TP status.')
ibmappcInLtpLongRun = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 5, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInLtpLongRun.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInLtpLongRun.setDescription('The long running transaction program.')
ibmappcInLtpPfCnos = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 5, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInLtpPfCnos.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInLtpPfCnos.setDescription('The TP Change Number of Sessions (CNOS) privileged function. This parameter specifies whether or not this program is allowed to issue CNOS verbs.')
ibmappcInLtpPfSessCntl = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 5, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInLtpPfSessCntl.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInLtpPfSessCntl.setDescription('The TP Session Control privileged function. This parameter specifies whether or not this program is allowed to issue ACTIVATE_SESSION and DEACTIVATE_SESSION verbs.')
ibmappcInLtpPfDefine = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 5, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInLtpPfDefine.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInLtpPfDefine.setDescription('The TP Define privileged function. This parameter specifies whether or not this program is allowed to issue DEFINE and DELETE verbs.')
ibmappcInLtpPfDisplay = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 5, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInLtpPfDisplay.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInLtpPfDisplay.setDescription('The TP Display privileged function. This parameter specifies whether or not this program is allowed to issue DISPLAY verbs.')
ibmappcInLtpPfAllocSer = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 5, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInLtpPfAllocSer.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInLtpPfAllocSer.setDescription('The TP Allocate Service privileged function. This parameter specifies whether or not this program is allowed to issue the ALLOCATE verb with its TPN parameter specifying an SNA service transmission program.')
ibmappcInLtpRescSup = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 5, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("basicConv", 1), ("mappedConv", 2), ("allConv", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInLtpRescSup.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInLtpRescSup.setDescription('The TP resources supported parameter. 1. basic conversations 2. mapped conversations 3. all conversations')
ibmappcInLtpRecoSup = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 5, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInLtpRecoSup.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInLtpRecoSup.setDescription('The TP reconnect supported parameter.')
ibmappcInLtpSecReq = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 5, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInLtpSecReq.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInLtpSecReq.setDescription('The TP security required parameter.')
ibmappcInLtpSecLvl = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 5, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("noAdditional", 1), ("specificUsers", 2), ("specificProfiles", 3), ("specificUserProfiles", 4), ("specificUserLus", 5), ("specificUserProfLus", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInLtpSecLvl.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInLtpSecLvl.setDescription('The TP security level parameter.')
ibmappcInLtpVerPip = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 5, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInLtpVerPip.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInLtpVerPip.setDescription('The TP verify pip parameter.')
ibmappcInLtpPipSubNum = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 5, 1, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInLtpPipSubNum.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInLtpPipSubNum.setDescription('The TP number of pip subfields.')
ibmappcInSsTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 6), )
if mibBuilder.loadTexts: ibmappcInSsTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInSsTable.setDescription('APPC Session Table')
ibmappcInSsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 6, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmappcInSsFqLuName"), (0, "IBM6611-MIB", "ibmappcInSsPcid"))
if mibBuilder.loadTexts: ibmappcInSsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInSsEntry.setDescription('Entry of APPC Session Information Table.')
ibmappcInSsFqLuName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 6, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInSsFqLuName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInSsFqLuName.setDescription('The network-qualified CP name or PU name of the node at which the session and cid originated. For APPN and LEN nodes, this is either CP name of the APPN node at which the origin LU is located or the CP name of the NN serving the LEN node at which the origin LU is located. This field is from 3 to 17 characters in length, including a period (.) which separates the NetId from the NAU name.')
ibmappcInSsPcid = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 6, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInSsPcid.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInSsPcid.setDescription('The procedure correlation identifier (pcid) of a session. It is an 8-octet value assigned by the primary LU.')
ibmappcInSsPluName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 6, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInSsPluName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInSsPluName.setDescription('The primary LU name of the session.')
ibmappcInSsSluName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 6, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInSsSluName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInSsSluName.setDescription('The secondary LU name of the session.')
ibmappcInSsModeName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 6, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInSsModeName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInSsModeName.setDescription('The Mode Name name used for this session. This is a 1-8 character name.')
ibmappcInSsCosName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 6, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInSsCosName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInSsCosName.setDescription('The Class of Service (COS) name used for this session. This is a 1-8 character name.')
ibmappcInSsSessType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 6, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("lu62", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInSsSessType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInSsSessType.setDescription('The type of session.')
ibmappcInSsSessState = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 6, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("inactive", 1), ("pendactive", 2), ("active", 3), ("pendinact", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInSsSessState.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInSsSessState.setDescription('Indicates the state of the session. 1. session is pending inactive or, 2. session is pending active or, 3. session is active or, 4. session is inactive')
ibmappcInSsTransPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 6, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInSsTransPriority.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInSsTransPriority.setDescription('The transmission priority of this session.')
ibmappcInSsPaceType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 6, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("fixed", 2), ("adaptive", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInSsPaceType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInSsPaceType.setDescription('The type of pacing used for this session.')
ibmappcInSsSendMaxRuSz = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 6, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInSsSendMaxRuSz.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInSsSendMaxRuSz.setDescription('The maximum ru size which can be sent.')
ibmappcInSsRecvMaxRuSz = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 6, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInSsRecvMaxRuSz.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInSsRecvMaxRuSz.setDescription('The maximum ru size which can be received.')
ibmappcInSsEnhanceSecSup = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 6, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("level1", 2), ("level2", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInSsEnhanceSecSup.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInSsEnhanceSecSup.setDescription('Enhanced security supported. Indicates the level of enhance security support: 1 = none 2 = level 1 3 = level 2')
ibmappcInSsSendPacingType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 6, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("fixed", 2), ("adaptive", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInSsSendPacingType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInSsSendPacingType.setDescription('The type of pacing being used for sending data.')
ibmappcInSsSendRpc = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 6, 1, 15), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInSsSendRpc.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInSsSendRpc.setDescription("The send residual pace count. This represents the number of MU's that can still be sent in the current session window.")
ibmappcInSsSendNxWndwSize = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 6, 1, 16), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInSsSendNxWndwSize.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInSsSendNxWndwSize.setDescription('The size of the next window which will be used to send data.')
ibmappcInSsRecvPacingType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 6, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("fixed", 2), ("adaptive", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInSsRecvPacingType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInSsRecvPacingType.setDescription('The type of pacing being used for receiving data.')
ibmappcInSsRecvRpc = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 6, 1, 18), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInSsRecvRpc.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInSsRecvRpc.setDescription("The receive residual pace count. This represents the number of MU's that can still be received in the current session window.")
ibmappcInSsRecvNxWndwSize = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 6, 1, 19), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInSsRecvNxWndwSize.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInSsRecvNxWndwSize.setDescription('The size of the next window which will be used to receive data.')
ibmappcInSsSessStartTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 6, 1, 20), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInSsSessStartTime.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInSsSessStartTime.setDescription('Time when the session started in hundreds of a second.')
ibmappcInSsSessUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 6, 1, 21), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInSsSessUpTime.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInSsSessUpTime.setDescription('Length of time the session has been active in hundreds of a second.')
ibmappcInSsCtrUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 6, 1, 22), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInSsCtrUpTime.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInSsCtrUpTime.setDescription('Length of time the session counters have been active in hundreds of a second.')
ibmappcInSsP2SFmdPius = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 6, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInSsP2SFmdPius.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInSsP2SFmdPius.setDescription('Number of FMD PIUs sent from the Primary LU to the Secondary LU')
ibmappcInSsS2PFmdPius = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 6, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInSsS2PFmdPius.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInSsS2PFmdPius.setDescription('Number of FMD PIUs sent from the Secondary LU to the Primary LU')
ibmappcInSsP2SNonFmdPius = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 6, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInSsP2SNonFmdPius.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInSsP2SNonFmdPius.setDescription('Number of non-FMD PIUs sent from the Primary LU to the Secondary LU')
ibmappcInSsS2PNonFmdPius = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 6, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInSsS2PNonFmdPius.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInSsS2PNonFmdPius.setDescription('Number of non-FMD PIUs sent from the Secondary LU to the Primary LU')
ibmappcInSsP2SFmdBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 6, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInSsP2SFmdBytes.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInSsP2SFmdBytes.setDescription('Number of FMD Bytes sent from the Primary LU to the Secondary LU')
ibmappcInSsS2PFmdBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 6, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInSsS2PFmdBytes.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInSsS2PFmdBytes.setDescription('Number of FMD Bytes sent from the Secondary LU to the Primary LU')
ibmappcInSsP2SNonFmdBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 6, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInSsP2SNonFmdBytes.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInSsP2SNonFmdBytes.setDescription('Number of non-FMD Bytes sent from the Primary LU to the Secondary LU')
ibmappcInSsS2PNonFmdBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 6, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInSsS2PNonFmdBytes.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInSsS2PNonFmdBytes.setDescription('Number of non-FMD Bytes sent from the Secondary LU to the Primary LU')
ibmappcInSsRscv = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 6, 1, 31), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInSsRscv.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInSsRscv.setDescription("The route selection control vector (RSCV x'2B') used for this session. It is not present for APPN CP-CP sessions and also not present for LEN nodes. The format of this vector is described in SNA Formats.")
ibmappcInSsStatusTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 7), )
if mibBuilder.loadTexts: ibmappcInSsStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInSsStatusTable.setDescription('APPC Session Status Table')
ibmappcInSsStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 7, 1), ).setIndexNames((0, "IBM6611-MIB", "ibmappcInSsStatusIndex"))
if mibBuilder.loadTexts: ibmappcInSsStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInSsStatusEntry.setDescription('Entry of APPC Session Status Information Table. This table is indexed by the SsStatusIndex, which is an integer that is continuously updated until it eventually wraps. This provides the management station the ability to retrieve only the updates to the table by using the standard GET NEXT.')
ibmappcInSsStatusIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 7, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInSsStatusIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInSsStatusIndex.setDescription('Table index. The value of the index begins at zero and is incremented up to a maximum value of 2**31-1 (2,147,483,647) before wrapping.')
ibmappcInSsStatusTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 7, 1, 2), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInSsStatusTime.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInSsStatusTime.setDescription('Time (in hundreds of a second) since this node was last initialized.')
ibmappcInSsStatusType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 7, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("recvNegBindRsp", 1), ("sendNegBindRsp", 2), ("sessActRejected", 3), ("unbindSent", 4), ("unbindReceived", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInSsStatusType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInSsStatusType.setDescription('Indicates the entry type: 1. Received a negative bind response from the partner LU. 2. Sent a negative bind response to the partner LU. 3. Session activation rejected by the partner LU. 4. Unbind sent to the partner LU. 5. Unbind received from the partner LU.')
ibmappcInSsStatusLocLuName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 7, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInSsStatusLocLuName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInSsStatusLocLuName.setDescription('The network-qualified local LU name. This field is from 3 to 17 characters in length, including a period (.) which separates the NetId from the NAU name.')
ibmappcInSsStatusParLuName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 7, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInSsStatusParLuName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInSsStatusParLuName.setDescription('The network-qualified partner LU name. This field is from 3 to 17 characters in length, including a period (.) which separates the NetId from the NAU name.')
ibmappcInSsStatusModeName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 7, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInSsStatusModeName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInSsStatusModeName.setDescription('The mode name.')
ibmappcInSsStatusUnbindType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 7, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInSsStatusUnbindType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInSsStatusUnbindType.setDescription('The type of unbind which terminated the session. This value is consists of one (1) octet; and its meaning is defined in SNA Formats.')
ibmappcInSsStatusSenseCode = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 7, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInSsStatusSenseCode.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInSsStatusSenseCode.setDescription('The sense code associated with the termination of the session. This value consists of four (4) octets; and its meaning is defined in SNA Formats.')
ibmappcInSsStatusComponentId = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 7, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInSsStatusComponentId.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInSsStatusComponentId.setDescription('The name of the component which sent the entry.')
ibmappcInSsStatusDetectModule = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 7, 2, 1, 7, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappcInSsStatusDetectModule.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappcInSsStatusDetectModule.setDescription('The name of the module which detected the condition and sent the entry.')
mibBuilder.exportSymbols("IBM6611-MIB", ibmtbsapFiltInfoEntry=ibmtbsapFiltInfoEntry, ibmappnIsAcPcid=ibmappnIsAcPcid, ibmappnIsAcBufRecFormat=ibmappnIsAcBufRecFormat, ibmappnMemoryUse=ibmappnMemoryUse, ibmappcInRluActType=ibmappcInRluActType, ibmappnIsInTable=ibmappnIsInTable, ibmipxPortIfIndex=ibmipxPortIfIndex, ibmpppLinkRestartTimerValue=ibmpppLinkRestartTimerValue, ibmtbmacFiltInSrcMask=ibmtbmacFiltInSrcMask, ibmfrCircuitReceivedFrames=ibmfrCircuitReceivedFrames, ibmdlsCirIfIndex=ibmdlsCirIfIndex, ibmtbsapFiltOut=ibmtbsapFiltOut, swvpdModId=swvpdModId, ibmipPtyQueueTable=ibmipPtyQueueTable, ibmipFilterExtValue=ibmipFilterExtValue, ibmappnNodePortName=ibmappnNodePortName, ibmipxsapServerRequestsFiltered=ibmipxsapServerRequestsFiltered, ibmappnIsInP2SFmdPius=ibmappnIsInP2SFmdPius, ibmappnIsAcCtrUpTime=ibmappnIsAcCtrUpTime, ibmpppLinkCRCSize=ibmpppLinkCRCSize, ibmdot1dBasePortCircuit=ibmdot1dBasePortCircuit, ibmsysPageSpace=ibmsysPageSpace, ibmipxFilterValue=ibmipxFilterValue, ibmpppIPCPCompressionType=ibmpppIPCPCompressionType, ibmvifNumber=ibmvifNumber, ibmTGSwitchOuts=ibmTGSwitchOuts, ibmfrDlcmiIfIndex=ibmfrDlcmiIfIndex, ibmwindowFilterOutType=ibmwindowFilterOutType, ibmappcInMdPndCwin=ibmappcInMdPndCwin, cylinkSoftwareVersion=cylinkSoftwareVersion, cylinkESThreshold=cylinkESThreshold, ibmipPtyQueueType=ibmipPtyQueueType, ibmpppIPCPInPackets=ibmpppIPCPInPackets, ibmappnIsAcBufNumber=ibmappnIsAcBufNumber, ibmappnNodePortIpPortNum=ibmappnNodePortIpPortNum, ibmappcInLtpPfDisplay=ibmappcInLtpPfDisplay, ibmvRtNumber=ibmvRtNumber, ibmappnIsInformation=ibmappnIsInformation, ibmxnsFilterMask=ibmxnsFilterMask, ibmappnIsAcTimeAgtUtcMdays=ibmappnIsAcTimeAgtUtcMdays, ibmvNbrType=ibmvNbrType, ibmappnNodePortDynLsGoodXids=ibmappnNodePortDynLsGoodXids, ibmpppIPOutPackets=ibmpppIPOutPackets, cylinkDIUTiming=cylinkDIUTiming, ibmdlsCirLocalLinkRcvInactiveTimeouts=ibmdlsCirLocalLinkRcvInactiveTimeouts, ibmappcInSsFqLuName=ibmappcInSsFqLuName, ibmvNeighbor=ibmvNeighbor, ibmappnNnNodeCongested=ibmappnNnNodeCongested, ibmappnDirOutBcastLocates=ibmappnDirOutBcastLocates, ibmpppLinkLastInvalidProtocol=ibmpppLinkLastInvalidProtocol, ibmappnNodePortIpTable=ibmappnNodePortIpTable, ibmappnNnTgByteCost=ibmappnNnTgByteCost, ibmappcInLtpStatus=ibmappcInLtpStatus, ibmdot1dStpPortDesignatedRoot=ibmdot1dStpPortDesignatedRoot, ibmappnNnTgOwner=ibmappnNnTgOwner, ibmtbFiltOrderOutIfIndex=ibmtbFiltOrderOutIfIndex, ibmvRtMetric=ibmvRtMetric, ibmdlsStationPrimarySlowListTimeout=ibmdlsStationPrimarySlowListTimeout, ibmappnCosNodeRowWgt=ibmappnCosNodeRowWgt, ibmxnsErrpActive=ibmxnsErrpActive, ibmappnNodeLsIpEntry=ibmappnNodeLsIpEntry, ibmpppLCPOutOctets=ibmpppLCPOutOctets, ibmappcInSsRecvPacingType=ibmappcInSsRecvPacingType, ibmvipInDiscards=ibmvipInDiscards, ibmdot1dStpPortDesignatedBridge=ibmdot1dStpPortDesignatedBridge, ibmappnIsAcBtypeFullLosts=ibmappnIsAcBtypeFullLosts, ibmappnIsInEntry=ibmappnIsInEntry, ibmappcInMdPrefSendRuSz=ibmappcInMdPrefSendRuSz, ibmfrCircuitIfIndex=ibmfrCircuitIfIndex, ibmvicpHeaderError=ibmvicpHeaderError, ibmdlsDefaultDestEntry=ibmdlsDefaultDestEntry, ibmappnIsAcGlobeByteThresh=ibmappnIsAcGlobeByteThresh, ibmdot1dTpFdbStatus=ibmdot1dTpFdbStatus, ibmipxFilterHCCompare=ibmipxFilterHCCompare, ibmappnNodeLsConnCost=ibmappnNodeLsConnCost, ibmappcInSsSessState=ibmappcInSsSessState, ibmfrDlcmiEntry=ibmfrDlcmiEntry, ibmFiltOrderInName=ibmFiltOrderInName, ibmdecLANCircuitSourceRoute=ibmdecLANCircuitSourceRoute, ibmtbmacFiltInSrcAddress=ibmtbmacFiltInSrcAddress, ibmappcInLtpPfDefine=ibmappcInLtpPfDefine, ibmappnIsAcGlobeMgrUtcSecs=ibmappnIsAcGlobeMgrUtcSecs, ibmdlsCirLocalLinkMaxContResent=ibmdlsCirLocalLinkMaxContResent, ibmappnLocalEnTgOrigin=ibmappnLocalEnTgOrigin, ibmringFilterInfoTable=ibmringFilterInfoTable, ibmtbmacFiltInfoEntry=ibmtbmacFiltInfoEntry, ibmappnNodeLsOutXidFrames=ibmappnNodeLsOutXidFrames, ibmRIFFilterInEntry=ibmRIFFilterInEntry, cylinkQRSS=cylinkQRSS, ibmTrapThrottleId=ibmTrapThrottleId, ibmvRtIfIndex=ibmvRtIfIndex, ibmappcInSsRscv=ibmappcInSsRscv, ibmvRtCfgFlt=ibmvRtCfgFlt, ibmpppLCPInCAs=ibmpppLCPInCAs, ibmvRtIdle=ibmvRtIdle, ibmvRtCfgInFlt=ibmvRtCfgInFlt, ibmappcInSsSendRpc=ibmappcInSsSendRpc, ibmappnNnNodeFREntryTimeLeft=ibmappnNnNodeFREntryTimeLeft, ibmappnIsAcBtypeFullTime=ibmappnIsAcBtypeFullTime, ibmappnIsAcSessUpTime=ibmappnIsAcSessUpTime, ibmappnNodeLsRemoteTrMac=ibmappnNodeLsRemoteTrMac, ibmappnNodePortDlsTable=ibmappnNodePortDlsTable, ibmappnLocalTgNum=ibmappnLocalTgNum, ibmappnIsInGlobeRscvTime=ibmappnIsInGlobeRscvTime, ibmappnNodeLsActiveTime=ibmappnNodeLsActiveTime, ibmsystem=ibmsystem, ibmpppLinkLastBadAddress=ibmpppLinkLastBadAddress, ibmappnMemorySize=ibmappnMemorySize, ibmtbmacFiltOutSrcAddress=ibmtbmacFiltOutSrcAddress, ibmdecNodeType=ibmdecNodeType, ibmpppLCPInEchoReqs=ibmpppLCPInEchoReqs, ibmdlsRemoteFrameFilterTable=ibmdlsRemoteFrameFilterTable, ibmwindowFilterOutEntry=ibmwindowFilterOutEntry, ibmappnNodeLsStatusCpName=ibmappnNodeLsStatusCpName, ibmtbmacFiltOutTable=ibmtbmacFiltOutTable, ibmfrErrEntry=ibmfrErrEntry, ibmxnsErrTTLExpired=ibmxnsErrTTLExpired, ibmappnNodeLsLocalIpPortNum=ibmappnNodeLsLocalIpPortNum, ibmappnIsAcTimeEntryType=ibmappnIsAcTimeEntryType, ibmdot1dBaseBridgeAddress=ibmdot1dBaseBridgeAddress, ibmpppIPCPRejects=ibmpppIPCPRejects, ibmvSysConfig=ibmvSysConfig, ibmringFilterInNumber=ibmringFilterInNumber, ibmappnLocalEnTgEffCap=ibmappnLocalEnTgEffCap, ibmvipBadHeaders=ibmvipBadHeaders, ibmvNbrIfIndex=ibmvNbrIfIndex, ibmappnIsAcS2PNonFmdPius=ibmappnIsAcS2PNonFmdPius, ibmappnNnTgDelay=ibmappnNnTgDelay, ibmdlsDefaultNBDestTable=ibmdlsDefaultNBDestTable, ibmappnNodeLsDynamic=ibmappnNodeLsDynamic, ibmmacAddrFilterInNotForwarded=ibmmacAddrFilterInNotForwarded, ibmipxsapServerName=ibmipxsapServerName, ibmfrErrIfIndex=ibmfrErrIfIndex, ibmappcInLtpInstLmt=ibmappcInLtpInstLmt, ibmappnCosTgRowByteCostMax=ibmappnCosTgRowByteCostMax, ibmappnNodeLsBlockNum=ibmappnNodeLsBlockNum, ibmappnIsInP2SNonFmdBytes=ibmappnIsInP2SNonFmdBytes, ibmtbmacFiltOutSrcMask=ibmtbmacFiltOutSrcMask, ibmpppLinkProtocolCompression=ibmpppLinkProtocolCompression, ibmfrCircuitThroughput=ibmfrCircuitThroughput, ibmsapFilterInNotForwarded=ibmsapFilterInNotForwarded, ibmdlsDefaultDestTable=ibmdlsDefaultDestTable, ibmipxidpBcastInReceives=ibmipxidpBcastInReceives, ibmpppLinkConfigTimeouts=ibmpppLinkConfigTimeouts, ibmbridgeRingFilters=ibmbridgeRingFilters, ibmappnNnTgConnCost=ibmappnNnTgConnCost, ibmappnNodePortEntry=ibmappnNodePortEntry, ibmappnNodeDefLsBadXids=ibmappnNodeDefLsBadXids, ibmappnLocalNnIsr=ibmappnLocalNnIsr, ibmvRtCfgInFltNum=ibmvRtCfgInFltNum, ibmappnNodeNnIsr=ibmappnNodeNnIsr, ibmRIFFilterOutTable=ibmRIFFilterOutTable, ibmtbFiltOrderInPriority=ibmtbFiltOrderInPriority, ibmappnNodeLsTrTable=ibmappnNodeLsTrTable, ibmappnCosTgRowDelayMin=ibmappnCosTgRowDelayMin, ibmvrtpUpdRecs=ibmvrtpUpdRecs, ibmbridgeSAPFilters=ibmbridgeSAPFilters, ibmappnIsAcBtypeErrorLosts=ibmappnIsAcBtypeErrorLosts, ibmwindowFilterOutNotForwarded=ibmwindowFilterOutNotForwarded, ibmdlsStationAddress=ibmdlsStationAddress, ibmappnNnNodeFRRouteAddResist=ibmappnNnNodeFRRouteAddResist, ibmipFilterExtFilterId=ibmipFilterExtFilterId, ibmappnCosTgRowWgt=ibmappnCosTgRowWgt, ibmappcInMdDrainSelf=ibmappcInMdDrainSelf, ibmtbwinFiltOutFilterType=ibmtbwinFiltOutFilterType, ibmvFltTable=ibmvFltTable, ibmvPortCfgPerUpdate=ibmvPortCfgPerUpdate, ibmsysPageSpaceInUse=ibmsysPageSpaceInUse, ibmappnCosTgRowTable=ibmappnCosTgRowTable, ibmtbmacFiltInIfIndex=ibmtbmacFiltInIfIndex, ibmdlsRouterDefinedBy=ibmdlsRouterDefinedBy, ibmpppLCPInCRejs=ibmpppLCPInCRejs, ibmappnNodePortTrTable=ibmappnNodePortTrTable, ibmappnLinkStationInformation=ibmappnLinkStationInformation, ibmappnLocalEnTgUsr3=ibmappnLocalEnTgUsr3, ibmipext=ibmipext, ibmappcInRluLocLuName=ibmappcInRluLocLuName, ibmappcInLtpRescSup=ibmappcInLtpRescSup, ibmappnIsInGlobeStatus=ibmappnIsInGlobeStatus, ibmipPtyQueueDefault=ibmipPtyQueueDefault, ibmipxidpOutRequests=ibmipxidpOutRequests, ibmicmp=ibmicmp, ibmxnsAddrEntry=ibmxnsAddrEntry, ibmpppLCPOutCRs=ibmpppLCPOutCRs, ibmvPortCfgOutFltNum=ibmvPortCfgOutFltNum, ibmsnapFilterInMask=ibmsnapFilterInMask, ibmdlsStationRetransmitThreshold=ibmdlsStationRetransmitThreshold, ibmpppLCPOutPackets=ibmpppLCPOutPackets, ibmappnNnNodeType=ibmappnNnNodeType, ibmappnNodeLsDlsTable=ibmappnNodeLsDlsTable, ibmvPortCfgIfIndex=ibmvPortCfgIfIndex, ibmdot1dStpBridgeMaxAge=ibmdot1dStpBridgeMaxAge, ibmdot1dStaticReceivePort=ibmdot1dStaticReceivePort, ibmappnCosTgRowName=ibmappnCosTgRowName, ibmappnIsAcTimeEntry=ibmappnIsAcTimeEntry, ibmappnNodeLsPortName=ibmappnNodeLsPortName, ibmipxAddrAddress=ibmipxAddrAddress, ibmappnCosTgRowConnCostMin=ibmappnCosTgRowConnCostMin, ibmvicpMetricGens=ibmvicpMetricGens, ibmtbwinFiltIfIndex=ibmtbwinFiltIfIndex, ibmsysMBUFsKbytes=ibmsysMBUFsKbytes, ibmvarpHeaderError=ibmvarpHeaderError, ibmappnNodePortDlsMac=ibmappnNodePortDlsMac, ibmappnSnmpInGetNexts=ibmappnSnmpInGetNexts, ibmdot1dStpPortEnable=ibmdot1dStpPortEnable, ibmfrDlcmiMonitoredEvents=ibmfrDlcmiMonitoredEvents, ibmappnDirMaxCaches=ibmappnDirMaxCaches, ibmSelectNetEntry=ibmSelectNetEntry, ibmdot1dStpPortEntry=ibmdot1dStpPortEntry, ibmfrDlcmiFullEnquiryInterval=ibmfrDlcmiFullEnquiryInterval, ibmappnIsInS2PNonFmdBytes=ibmappnIsInS2PNonFmdBytes, ibmfrCircuitCommittedBurst=ibmfrCircuitCommittedBurst, ibmipFilterScope=ibmipFilterScope, ibmvNbrEntry=ibmvNbrEntry, ibmxnsRouteEntry=ibmxnsRouteEntry, ibmvRtCfgOutFlt=ibmvRtCfgOutFlt, ibmappnNnTgFRByteCost=ibmappnNnTgFRByteCost, ibmappnNodeLsInMsgBytes=ibmappnNodeLsInMsgBytes, ibmppp=ibmppp, ibmvRtCfgOutFltEntry=ibmvRtCfgOutFltEntry, ibmvRtNetid=ibmvRtNetid, ibmdlsRemoteFrameFilterSrcMask=ibmdlsRemoteFrameFilterSrcMask, ibmappnNnTopoRouteCos=ibmappnNnTopoRouteCos, ibmappnIsInSsRecvNxWndwSize=ibmappnIsInSsRecvNxWndwSize, ibmappcInSsStatusParLuName=ibmappcInSsStatusParLuName, ibmpppLinkMaxRestarts=ibmpppLinkMaxRestarts, ibmappnDirType=ibmappnDirType, ibmappnDirPerf=ibmappnDirPerf, ibmipFilterExtTable=ibmipFilterExtTable, ibmbridgeMACAddressFilters=ibmbridgeMACAddressFilters, ibmappnNodeLsEchoRsps=ibmappnNodeLsEchoRsps, ibmvicpExcGens=ibmvicpExcGens, ibmappnNodeLsInXidBytes=ibmappnNodeLsInXidBytes, ibmappnIsAcGlobeMgrUtcIsdst=ibmappnIsAcGlobeMgrUtcIsdst, ibmappnIsAcTimeAgtUtcWdays=ibmappnIsAcTimeAgtUtcWdays, ibmappnNodeParallelTg=ibmappnNodeParallelTg, ibmtbSAPFilters=ibmtbSAPFilters, ibmappnNnTgUsr1=ibmappnNnTgUsr1, ibmappcInLtpPfCnos=ibmappcInLtpPfCnos, ibmdot1dStpPortDesignatedPort=ibmdot1dStpPortDesignatedPort, ibmxnsidpBadLen=ibmxnsidpBadLen, ibmRIFFilterInRingNumber=ibmRIFFilterInRingNumber, ibmdot1dStpPortState=ibmdot1dStpPortState, ibmappcInMdDrainPart=ibmappcInMdDrainPart, ibmpppLCPOutEchoReps=ibmpppLCPOutEchoReps, ibmappnIsAcTimeIndex=ibmappnIsAcTimeIndex, ibmtbmacFiltOutEntry=ibmtbmacFiltOutEntry, ibmappnNodePortDlcTraceEntry=ibmappnNodePortDlcTraceEntry, ibmtbEthTypeFiltOutNotForwarded=ibmtbEthTypeFiltOutNotForwarded, ibmappnIsAcBtypeDeletes=ibmappnIsAcBtypeDeletes, ibmappnIsAcPriLuName=ibmappnIsAcPriLuName, ibmxnsErrCongWarn=ibmxnsErrCongWarn, ibmtbFiltOrderInEntry=ibmtbFiltOrderInEntry, ibmappnIsAcTimeMgrUtcYears=ibmappnIsAcTimeMgrUtcYears)
mibBuilder.exportSymbols("IBM6611-MIB", ibmtbFiltOrderOutEntry=ibmtbFiltOrderOutEntry, ibmipxFilterNumber=ibmipxFilterNumber, ibmsnapFilterOutNotForwarded=ibmsnapFilterOutNotForwarded, ibmappnNodeLsStatusNofRetry=ibmappnNodeLsStatusNofRetry, ibmTGTable=ibmTGTable, ibmsnapFilterOutType=ibmsnapFilterOutType, ibmtbwinFiltOutNumBytes=ibmtbwinFiltOutNumBytes, ibmvFltHCCompare=ibmvFltHCCompare, ibmfrCircuitReceivedFECNs=ibmfrCircuitReceivedFECNs, ibmvrtpReqSents=ibmvrtpReqSents, ibmappnNodeNegotLs=ibmappnNodeNegotLs, ibmwindowFilterInId=ibmwindowFilterInId, ibmappnNnTgSecurity=ibmappnNnTgSecurity, ibmappnIsInGlobeCtrStatusTime=ibmappnIsInGlobeCtrStatusTime, ibmtbwinFiltOutOffsetStart=ibmtbwinFiltOutOffsetStart, ibmdlsRemoteFrameFilterID=ibmdlsRemoteFrameFilterID, ibmappnIsAcBtypeErrorWraps=ibmappnIsAcBtypeErrorWraps, ibmtbmacFiltOutIfIndex=ibmtbmacFiltOutIfIndex, ibmipxsapServerType=ibmipxsapServerType, ibmappnNodePortTrMac=ibmappnNodePortTrMac, ibmappnNodeBindReasm=ibmappnNodeBindReasm, ibmipxsapServerSocket=ibmipxsapServerSocket, ibmvines=ibmvines, ibmxnsErrTooBig=ibmxnsErrTooBig, ibmpppLCPInCRs=ibmpppLCPInCRs, ibmTGProtocol=ibmTGProtocol, ibmappcInLtpPfSessCntl=ibmappcInLtpPfSessCntl, ibmxnsRouteDest=ibmxnsRouteDest, ibmappnIsAcGlobeMgrUtcMonths=ibmappnIsAcGlobeMgrUtcMonths, ibmappnNnAdjNodeLastFrsnSent=ibmappnNnAdjNodeLastFrsnSent, ibmappcInSsSendMaxRuSz=ibmappcInSsSendMaxRuSz, ibmtbwinFiltOutId=ibmtbwinFiltOutId, ibmvRtCfgFltMode=ibmvRtCfgFltMode, ibmvNbrRemAddress=ibmvNbrRemAddress, ibmpppLinkCommand=ibmpppLinkCommand, ibmappnNnTgUsr3=ibmappnNnTgUsr3, ibmappnIsAcBtypeCurBufs=ibmappnIsAcBtypeCurBufs, ibmappcInSsCtrUpTime=ibmappcInSsCtrUpTime, ibmdlsCirPartnerRouterAddress=ibmdlsCirPartnerRouterAddress, ibmappcInLtpEntry=ibmappcInLtpEntry, ibmdlsCirLocalLinkCmdContRepolls=ibmdlsCirLocalLinkCmdContRepolls, ibmappnIsAcBtypePurges=ibmappnIsAcBtypePurges, ibmappnNodeLsSubState=ibmappnNodeLsSubState, ibmappnNodeUpTime=ibmappnNodeUpTime, ibmappnNnTgRsn=ibmappnNnTgRsn, ibmpppLCPOutTRs=ibmpppLCPOutTRs, ibmappnIsAcS2PFmdPius=ibmappnIsAcS2PFmdPius, ibmappnIsAcIndex=ibmappnIsAcIndex, ibmappnLocalTgEffCap=ibmappnLocalTgEffCap, ibmappcInSsModeName=ibmappcInSsModeName, ibmdot1dTpPortTable=ibmdot1dTpPortTable, ibmChipSetIBM8025B=ibmChipSetIBM8025B, ibmappnNnTopoNodeErrors=ibmappnNnTopoNodeErrors, ibmdlsLocalFrameFilterID=ibmdlsLocalFrameFilterID, ibmipPtyQueuePort=ibmipPtyQueuePort, ibmdot1dStpProtocolSpecification=ibmdot1dStpProtocolSpecification, ibmTrapThrottleTime=ibmTrapThrottleTime, ibmmacAddrFilterInFilterType=ibmmacAddrFilterInFilterType, ibmvFltType=ibmvFltType, ibmipxFilterMask=ibmipxFilterMask, ibmappnLocalNnRsn=ibmappnLocalNnRsn, ibmdot1dBasePortIfIndex=ibmdot1dBasePortIfIndex, ibmappnNodeLsLocalIpAddr=ibmappnNodeLsLocalIpAddr, ibmappnNodeLsLocalTrSap=ibmappnNodeLsLocalTrSap, ibmxnsErrChecksum=ibmxnsErrChecksum, ibmappnNodeLsTargetPacingCount=ibmappnNodeLsTargetPacingCount, ibmappnLocalNodeName=ibmappnLocalNodeName, ibmappnNnTgFRUsr1=ibmappnNnTgFRUsr1, ibmPtyQueueingIfIndex=ibmPtyQueueingIfIndex, ibmChipSetIntel=ibmChipSetIntel, ibmappnIsInGlobeRscv=ibmappnIsInGlobeRscv, ibmappnLocalTgDestVirtual=ibmappnLocalTgDestVirtual, ibmdlsCirLocalLinkTestCmdsRcv=ibmdlsCirLocalLinkTestCmdsRcv, ibmpppProtocolTables=ibmpppProtocolTables, ibmdlsCirLocalLinkDataPktRcv=ibmdlsCirLocalLinkDataPktRcv, ibmxnsRouteUse=ibmxnsRouteUse, ibmappnNnTopoNodeEqualRsns=ibmappnNnTopoNodeEqualRsns, ibmwindowFilterInfoEntry=ibmwindowFilterInfoEntry, ibmChipSetIBM8025A=ibmChipSetIBM8025A, ibmFiltOrderOutType=ibmFiltOrderOutType, ibmappnNnNodeIsr=ibmappnNnNodeIsr, ibmappnNodePortDlsName=ibmappnNodePortDlsName, ibmipFilterAddr2=ibmipFilterAddr2, ibmfrCircuitReceivedOctets=ibmfrCircuitReceivedOctets, ibmappcInMdAcCrypto=ibmappcInMdAcCrypto, ibm=ibm, ibmappnNodeLsLocalDlsMac=ibmappnNodeLsLocalDlsMac, ibmtbwinFiltInfoEntry=ibmtbwinFiltInfoEntry, ibmappnIsAcTimeAgtUtcYears=ibmappnIsAcTimeAgtUtcYears, ibmtbmacFiltOutDestAddress=ibmtbmacFiltOutDestAddress, ibmPtyQueueingLBA=ibmPtyQueueingLBA, ibmappnDirLuName=ibmappnDirLuName, ibmappnIsAcTimeMgrUtcMins=ibmappnIsAcTimeMgrUtcMins, ibmsapFilterInfoEntry=ibmsapFilterInfoEntry, ibmappcInRluDefParaSessSup=ibmappcInRluDefParaSessSup, ibmappnNodeEnSendRegChar=ibmappnNodeEnSendRegChar, ibmappnLocalEnTgDlcData=ibmappnLocalEnTgDlcData, ibmappnCosModeCosName=ibmappnCosModeCosName, ibmappnIsAcTimeMgrName=ibmappnIsAcTimeMgrName, ibmpppLCPOutTAs=ibmpppLCPOutTAs, ibmvFltEntry=ibmvFltEntry, ibmappnCosTgRowUsr2Min=ibmappnCosTgRowUsr2Min, ibmpppLinkRemoteQualityPeriod=ibmpppLinkRemoteQualityPeriod, ibmvifOutErrs=ibmvifOutErrs, ibmappnLocalEnTopology=ibmappnLocalEnTopology, ibmappnNodePortDlcTracPortName=ibmappnNodePortDlcTracPortName, ibmRIFFilterInFilterType=ibmRIFFilterInFilterType, ibmmacAddrFilterOutNotForwarded=ibmmacAddrFilterOutNotForwarded, ibmappnCosNodeRowResistMax=ibmappnCosNodeRowResistMax, ibmappcInSsStatusType=ibmappcInSsStatusType, ibmsysRealMem=ibmsysRealMem, ibmappnNnTgQuiescing=ibmappnNnTgQuiescing, ibmappnNnTgFREntryTimeLeft=ibmappnNnTgFREntryTimeLeft, ibmappnIsInSsSendRpc=ibmappnIsInSsSendRpc, ibmappnSnmpInSetVars=ibmappnSnmpInSetVars, ibmsnapFilterType=ibmsnapFilterType, ibmFiltOrderInTable=ibmFiltOrderInTable, ibmappnNnNodeRouteAddResist=ibmappnNnNodeRouteAddResist, ibmappcInMdPtmCwin=ibmappcInMdPtmCwin, ibmipxsapServerHost=ibmipxsapServerHost, ibmpppLCPInTAs=ibmpppLCPInTAs, ibmdlsRouterAddress=ibmdlsRouterAddress, ibmappnNodeLsTrState=ibmappnNodeLsTrState, ibmsnapFilterInTable=ibmsnapFilterInTable, ibmdot1dStpBridgeForwardDelay=ibmdot1dStpBridgeForwardDelay, ibmmacAddrFilterOutSrcMask=ibmmacAddrFilterOutSrcMask, ibmappnNnTopoMaxNodes=ibmappnNnTopoMaxNodes, ibmmacAddrFilterInIfIndex=ibmmacAddrFilterInIfIndex, ibmsnapFilterInValue=ibmsnapFilterInValue, ibmappnNodeLsTrName=ibmappnNodeLsTrName, ibmsysMBUFsDeniedRequests=ibmsysMBUFsDeniedRequests, ibmvipTotalOut=ibmvipTotalOut, ibmvFRPfrgFails=ibmvFRPfrgFails, ibmappnIsAcTimeAgtUtcMins=ibmappnIsAcTimeAgtUtcMins, ibmdecLANCircuitIndex=ibmdecLANCircuitIndex, ibmdecLANCircuitEntry=ibmdecLANCircuitEntry, ibmappnNnTgNum=ibmappnNnTgNum, ibmipxidpInAddrErrors=ibmipxidpInAddrErrors, ibmappnNnAdjNodeAdjName=ibmappnNnAdjNodeAdjName, ibmdlsStationTable=ibmdlsStationTable, ibmfrCircuitDlci=ibmfrCircuitDlci, ibmipxPortStatus=ibmipxPortStatus, ibmringFilterOutFilterType=ibmringFilterOutFilterType, ibmvNbrIfType=ibmvNbrIfType, ibmappnNodeLsName=ibmappnNodeLsName, ibmappnCosTgRowByteCostMin=ibmappnCosTgRowByteCostMin, cylinkIndex=cylinkIndex, ibmdot1dStpPort=ibmdot1dStpPort, ibmvRtCfgInFltUses=ibmvRtCfgInFltUses, ibmappcInLtpTable=ibmappcInLtpTable, ibmbridgeHopCountFilters=ibmbridgeHopCountFilters, ibmappnNodeLsOutMsgFrames=ibmappnNodeLsOutMsgFrames, ibmappnNodeLsStatusGeneralSense=ibmappnNodeLsStatusGeneralSense, ibmappcInSsStatusSenseCode=ibmappcInSsStatusSenseCode, ibmappcInRluDefAttSecSup=ibmappcInRluDefAttSecSup, ibmxnsErrResources=ibmxnsErrResources, ibmdlsRemoteFrameFilterSrcAddress=ibmdlsRemoteFrameFilterSrcAddress, ibmSelectNetZone=ibmSelectNetZone, ibmappnLocalEnTgDelay=ibmappnLocalEnTgDelay, ibmappnCosNameEntry=ibmappnCosNameEntry, ibmFiltOrderOutName=ibmFiltOrderOutName, ibmappcInRluDefCnosSup=ibmappcInRluDefCnosSup, ibmappnLocalTgQuiescing=ibmappnLocalTgQuiescing, ibmtbFiltOrderInName=ibmtbFiltOrderInName, ibmappnLocalEnTgDest=ibmappnLocalEnTgDest, ibmvPortCfgHCtoServ=ibmvPortCfgHCtoServ, ibmChipSets=ibmChipSets, ibmvNbrAging=ibmvNbrAging, ibmtb=ibmtb, ibmSelectNetFilterTable=ibmSelectNetFilterTable, ibmappnNodeLsGoodXids=ibmappnNodeLsGoodXids, ibmSelectNet=ibmSelectNet, ibmipxidpRoutingDiscards=ibmipxidpRoutingDiscards, ibmappcInSsSendNxWndwSize=ibmappcInSsSendNxWndwSize, cylink=cylink, ibmappnIsAcBufMaxRecords=ibmappnIsAcBufMaxRecords, ibmvFRPreassembles=ibmvFRPreassembles, ibmappnIsAcBtypePrdMaxBufs=ibmappnIsAcBtypePrdMaxBufs, ibmappnIsAcBtypeClearStats=ibmappnIsAcBtypeClearStats, ibmappnIsAcBtypeDirName=ibmappnIsAcBtypeDirName, ibmpppIPEntry=ibmpppIPEntry, ibmringFilterOutIfIndex=ibmringFilterOutIfIndex, ibmappnIsAcTimeForMedia=ibmappnIsAcTimeForMedia, ibmdecSplitHorPoisonRev=ibmdecSplitHorPoisonRev, ibmvNbrTable=ibmvNbrTable, ibmtbFiltOrderInTable=ibmtbFiltOrderInTable, ibmappn=ibmappn, ibmappnNnTopologyFRTable=ibmappnNnTopologyFRTable, ibmappcInMdPrefRecvRuSz=ibmappcInMdPrefRecvRuSz, ibmappnLocalTgModemClass=ibmappnLocalTgModemClass, ibmappnNodeNnGateway=ibmappnNodeNnGateway, ibmappnNnNodeEndptDepleted=ibmappnNnNodeEndptDepleted, ibmappnIsAcTransPriority=ibmappnIsAcTransPriority, ibmvNbrSubNetid=ibmvNbrSubNetid, ibmappnNodeLsByteCost=ibmappnNodeLsByteCost, ibmappcInMdDfSyncLvl=ibmappcInMdDfSyncLvl, ibmdot1dStpRootPort=ibmdot1dStpRootPort, ibmdlsNameFilterType=ibmdlsNameFilterType, cylinkNetworkFraming=cylinkNetworkFraming, ibmappnIsAcDataTable=ibmappnIsAcDataTable, ibmappcInSsStatusTable=ibmappcInSsStatusTable, ibmappcInLtpLuName=ibmappcInLtpLuName, ibmRIFFilterOutBridgeNumber=ibmRIFFilterOutBridgeNumber, ibmdlsCirDestSap=ibmdlsCirDestSap, ibmdecLANCircuitAddrType=ibmdecLANCircuitAddrType, ibmipxidpBadSum=ibmipxidpBadSum, ibmtbmacFiltInNotForwarded=ibmtbmacFiltInNotForwarded, ibmdlsRemoteFrameFilterDestAddress=ibmdlsRemoteFrameFilterDestAddress, ibmdlsCirLocalLinkCmdPollsSent=ibmdlsCirLocalLinkCmdPollsSent, ibmappnNnAdjNodeTable=ibmappnNnAdjNodeTable, ibmvRtCfgInFltIfIndex=ibmvRtCfgInFltIfIndex, ibmdot1dTpFdbPort=ibmdot1dTpFdbPort, ibmappnDirEntry=ibmappnDirEntry, ibmpppLCPInOctets=ibmpppLCPInOctets, ibmappnNodePortDlcTracMsgType=ibmappnNodePortDlcTracMsgType, ibmdlsRouterOutFrames=ibmdlsRouterOutFrames, ibmappnIsAcDataEntry=ibmappnIsAcDataEntry, ibmringFilterInMask=ibmringFilterInMask, ibmappcInMdRluName=ibmappcInMdRluName, ibmipxidpBcastOutRequests=ibmipxidpBcastOutRequests, ibmsapFilterIn=ibmsapFilterIn, ibmappnIsAcGlobeMgrUtcYdays=ibmappnIsAcGlobeMgrUtcYdays, ibmappnNodeLsStartTime=ibmappnNodeLsStartTime, ibmappnNnTopoTgPurges=ibmappnNnTopoTgPurges, swvpdAction=swvpdAction, ibmappnNnTgFRDest=ibmappnNnTgFRDest, ibmvrtpRedSents=ibmvrtpRedSents, ibmhopCountFilterInfoEntry=ibmhopCountFilterInfoEntry, ibmappcInRluTable=ibmappcInRluTable, ibmappnLocalNnCentralDirectory=ibmappnLocalNnCentralDirectory, ibmappnNodePortTrEntry=ibmappnNodePortTrEntry, ibmappnCosModeTable=ibmappnCosModeTable, ibmpppLCPOutCRejs=ibmpppLCPOutCRejs, ibmappnNodeLsMaxDelay=ibmappnNodeLsMaxDelay, ibmdlsCirLocalLinkRouting=ibmdlsCirLocalLinkRouting, ibmappnIsInGlobeCtrStatus=ibmappnIsInGlobeCtrStatus, ibmappcInSsSendPacingType=ibmappcInSsSendPacingType, ibmappnNodeNetid=ibmappnNodeNetid, ibmxnsFilterUse=ibmxnsFilterUse, cylinkOnesControl=cylinkOnesControl, ibmtbwinFiltInFilterType=ibmtbwinFiltInFilterType, ibmmacAddrFilterInDestMask=ibmmacAddrFilterInDestMask, ibmpppLCPInEchoReps=ibmpppLCPInEchoReps, ibmappcInformation=ibmappcInformation, ibmappnNnTgEffCap=ibmappnNnTgEffCap, ibmappnNodeLsStatusEntry=ibmappnNodeLsStatusEntry, ibmtbsapFiltInfoTable=ibmtbsapFiltInfoTable, ibmxnsidpChecksum=ibmxnsidpChecksum, ibmappnNnTopoOutTdus=ibmappnNnTopoOutTdus, ibmappcInMdAltCode=ibmappcInMdAltCode, ibmappnNnTopoRouteCalcs=ibmappnNnTopoRouteCalcs, ibmvifTable=ibmvifTable, ibmwindowFilterInTable=ibmwindowFilterInTable, ibmappcInMdLluName=ibmappcInMdLluName)
mibBuilder.exportSymbols("IBM6611-MIB", ibmtbwinFiltInEntry=ibmtbwinFiltInEntry, ibmappcInSsStatusComponentId=ibmappcInSsStatusComponentId, ibmwindowFilterInIfIndex=ibmwindowFilterInIfIndex, ibmappnLocalTgByteCost=ibmappnLocalTgByteCost, ibmappnNodePortDlcTracIndex=ibmappnNodePortDlcTracIndex, ibmwindowFilterOutNumBytes=ibmwindowFilterOutNumBytes, cylinkClockFrequency=cylinkClockFrequency, ibmappcInMdSessEndTpName=ibmappcInMdSessEndTpName, ibmappnMemoryWarnThresh=ibmappnMemoryWarnThresh, ibmappnIsAcBtypeCheckPts=ibmappnIsAcBtypeCheckPts, ibmappnNodeLsBadXids=ibmappnNodeLsBadXids, ibmvNbrRIF=ibmvNbrRIF, ibmvNbrLocPort=ibmvNbrLocPort, ibmappnIsAcS2PFmdBytes=ibmappnIsAcS2PFmdBytes, ibmdot1dTpLearnedEntryDiscards=ibmdot1dTpLearnedEntryDiscards, ibmtbEthTypeFiltInTable=ibmtbEthTypeFiltInTable, ibmappnNnTgFRFrsn=ibmappnNnTgFRFrsn, ibmtbEthTypeFiltInNotForwarded=ibmtbEthTypeFiltInNotForwarded, ibmappcInGlobeRscvTime=ibmappcInGlobeRscvTime, ibmxnsidpInReceives=ibmxnsidpInReceives, ibmappnNnNodeFRType=ibmappnNnNodeFRType, ibmtbwinFiltOutEntry=ibmtbwinFiltOutEntry, ibmappnIsAcBtypeMedia=ibmappnIsAcBtypeMedia, ibmxnsRouteMetric=ibmxnsRouteMetric, ibmappnNnTopologyTable=ibmappnNnTopologyTable, ibmappnCosTgRowEntry=ibmappnCosTgRowEntry, ibmipxConfigTable=ibmipxConfigTable, ibmappnCosTgRowConnCostMax=ibmappnCosTgRowConnCostMax, ibmhopCountFilterIfIndex=ibmhopCountFilterIfIndex, ibmdlsLocalNameFilterID=ibmdlsLocalNameFilterID, ibmappcInMdAutoActLimit=ibmappcInMdAutoActLimit, ibmappnNnTopoNodeLowRsns=ibmappnNnTopoNodeLowRsns, ibmappnNodePortState=ibmappnNodePortState, ibmappnNodePortDlcTracLocalAddr=ibmappnNodePortDlcTracLocalAddr, ibmappnNodeLsMinDelay=ibmappnNodeLsMinDelay, ibmappnNnAdjNodeCpCpSessStatus=ibmappnNnAdjNodeCpCpSessStatus, ibmtbFiltOrderOutPriority=ibmtbFiltOrderOutPriority, ibmappnDirInLocates=ibmappnDirInLocates, ibmvrtpReqRecs=ibmvrtpReqRecs, ibmappcInLluDefaultLu=ibmappcInLluDefaultLu, ibmdot1dStpRootCost=ibmdot1dStpRootCost, ibmappnNodeNnRouteAddResist=ibmappnNodeNnRouteAddResist, ibmappnIsInPsRecvPacingType=ibmappnIsInPsRecvPacingType, ibmtbsapFiltOutNotForwarded=ibmtbsapFiltOutNotForwarded, ibmapple=ibmapple, ibmappnDirCurCaches=ibmappnDirCurCaches, ibmappcInLtpTpName=ibmappcInLtpTpName, ibmpppLinkErrorsTable=ibmpppLinkErrorsTable, ibmappnIsAcBufName=ibmappnIsAcBufName, ibmappcInSsPluName=ibmappcInSsPluName, ibmvRtCfgFltUses=ibmvRtCfgFltUses, ibmappnIsInPsSendRpc=ibmappnIsInPsSendRpc, ibmappnDirWildCard=ibmappnDirWildCard, ibmappcInSsEntry=ibmappcInSsEntry, ibmdlsLocalFrameFilterDestMask=ibmdlsLocalFrameFilterDestMask, ibmipFilterExtProtocol=ibmipFilterExtProtocol, ibmappnDir=ibmappnDir, ibmpppLinkPhysical=ibmpppLinkPhysical, ibmappnNodeLsCpName=ibmappnNodeLsCpName, ibmipFilterType=ibmipFilterType, ibmatportFilterNetEnd=ibmatportFilterNetEnd, ibmappnNnTgFRDelay=ibmappnNnTgFRDelay, ibmipPtyQueueEnable=ibmipPtyQueueEnable, ibmdot1dTpFdbTable=ibmdot1dTpFdbTable, ibmpppLinkQuality=ibmpppLinkQuality, ibmvipInReceives=ibmvipInReceives, ibmappnIsAcEndReason=ibmappnIsAcEndReason, ibmtbwinFiltOutContents=ibmtbwinFiltOutContents, ibmappcInLluDefType=ibmappcInLluDefType, ibmwindowFilterInFilterType=ibmwindowFilterInFilterType, ibmappnNnNodeFRCentralDirectory=ibmappnNnNodeFRCentralDirectory, ibmxnsAddrIfIndex=ibmxnsAddrIfIndex, ibmappnIsAcTimeTable=ibmappnIsAcTimeTable, ibmsnapFilterOutValue=ibmsnapFilterOutValue, ibmFiltOrderInIfIndex=ibmFiltOrderInIfIndex, ibmipPermitDeny=ibmipPermitDeny, ibmappnIsInSessState=ibmappnIsInSessState, ibmDSUs=ibmDSUs, ibmvipBcast=ibmvipBcast, ibmappnLocalEnEntry=ibmappnLocalEnEntry, ibmswvpd=ibmswvpd, ibmappnNnTgTopologyFRTable=ibmappnNnTgTopologyFRTable, ibmappnNodeLsRemoteIpAddr=ibmappnNodeLsRemoteIpAddr, ibmappnIsInPsRecvNxWndwSize=ibmappnIsInPsRecvNxWndwSize, ibmappcInRluActEnhanSecSup=ibmappcInRluActEnhanSecSup, ibmappcInRluDefEnhanSecSup=ibmappcInRluDefEnhanSecSup, ibmappnIsInCosName=ibmappnIsInCosName, ibmappnIsAcTimeMgrUtcMonths=ibmappnIsAcTimeMgrUtcMonths, ibmipFilterMask1=ibmipFilterMask1, ibmappnIsAcBtypeResets=ibmappnIsAcBtypeResets, ibmwindowFilterInEntry=ibmwindowFilterInEntry, cylinkLoopback=cylinkLoopback, ibmxnsidpForwDatagrams=ibmxnsidpForwDatagrams, ibmappnIsAcTimeAgtName=ibmappnIsAcTimeAgtName, ibmtbEthTypeFiltInMask=ibmtbEthTypeFiltInMask, ibmappnIsAcGlobal=ibmappnIsAcGlobal, ibmappnNnTgDestVirtual=ibmappnNnTgDestVirtual, ibmdot1dStpHelloTime=ibmdot1dStpHelloTime, ibmipxLoopbackActive=ibmipxLoopbackActive, ibmRIFFilterIfIndex=ibmRIFFilterIfIndex, ibmvNbrNetid=ibmvNbrNetid, ibmdlsCirLocalLinkState=ibmdlsCirLocalLinkState, ibmdlsStationMaxIfieldSize=ibmdlsStationMaxIfieldSize, ibmdot1dTpPortInDiscards=ibmdot1dTpPortInDiscards, ibmvRtCfgOutFltIfIndex=ibmvRtCfgOutFltIfIndex, ibmatportFilterIndex=ibmatportFilterIndex, ibmappnDirTable=ibmappnDirTable, ibmappcInMdRecvRuSzLoBnd=ibmappcInMdRecvRuSzLoBnd, ibmappnSnmpInformation=ibmappnSnmpInformation, ibmappnIsAcCosName=ibmappnIsAcCosName, ibmappnNnNodeFREndptDepleted=ibmappnNnNodeFREndptDepleted, ibmTGEntry=ibmTGEntry, ibmappnCosTgRowSecurityMin=ibmappnCosTgRowSecurityMin, ibmfrDlcmiMulticast=ibmfrDlcmiMulticast, ibmdlsStationForceDisconnectTimeout=ibmdlsStationForceDisconnectTimeout, ibmappnNodePortIpEntry=ibmappnNodePortIpEntry, ibmpppLCPInPackets=ibmpppLCPInPackets, ibmsapFilterInfoTable=ibmsapFilterInfoTable, ibmvipBcastInReceives=ibmvipBcastInReceives, ibmappnLocalEnTgConnCost=ibmappnLocalEnTgConnCost, ibmappnNodeLsDlsState=ibmappnNodeLsDlsState, ibmpppLinkRemoteMRU=ibmpppLinkRemoteMRU, ibmappnIsAcTimeMgrUtcMdays=ibmappnIsAcTimeMgrUtcMdays, ibmappnNodeDefLsGoodXids=ibmappnNodeDefLsGoodXids, ibmappnNnTgUsr2=ibmappnNnTgUsr2, swvpdPath=swvpdPath, ibmappnLocalEnEntryTimeLeft=ibmappnLocalEnEntryTimeLeft, ibmappnSnmpInGetVars=ibmappnSnmpInGetVars, ibmipxidpForwDatagrams=ibmipxidpForwDatagrams, ibmappnXidInformation=ibmappnXidInformation, ibmipxsapServerAge=ibmipxsapServerAge, ibmappnNodePortDynLsBadXids=ibmappnNodePortDynLsBadXids, ibmfrCircuitReceivedBECNs=ibmfrCircuitReceivedBECNs, ibmdot1dBasePort=ibmdot1dBasePort, ibmxnsErrUnreach=ibmxnsErrUnreach, ibmappnIsAcGlobeMgrUtcWdays=ibmappnIsAcGlobeMgrUtcWdays, ibmvPortCfgInFltNum=ibmvPortCfgInFltNum, ibmvifOutPkts=ibmvifOutPkts, ibmsapFilterOut=ibmsapFilterOut, ibmappnIsAcSessState=ibmappnIsAcSessState, ibmappnNodeType=ibmappnNodeType, ibmipxFilterIfIndex=ibmipxFilterIfIndex, ibmwindowFilterInType=ibmwindowFilterInType, ibmdlsCirDestAddress=ibmdlsCirDestAddress, ibmvRtCfgInFltEntry=ibmvRtCfgInFltEntry, ibmappnLocalNnChainSupport=ibmappnLocalNnChainSupport, ibmappnCosNodeRowTable=ibmappnCosNodeRowTable, ibmappnIsInS2PFmdBytes=ibmappnIsInS2PFmdBytes, cylinkStatusTable=cylinkStatusTable, ibmPtyQueueingQnum=ibmPtyQueueingQnum, ibmtbmacFiltInEntry=ibmtbmacFiltInEntry, ibmpppLinkQualityIndex=ibmpppLinkQualityIndex, ibmappcInSsSessStartTime=ibmappcInSsSessStartTime, ibmxnsErrUnspec=ibmxnsErrUnspec, ibmappnNodePortMaxRcvBtuSize=ibmappnNodePortMaxRcvBtuSize, ibmSelectNetNetStart=ibmSelectNetNetStart, ibmpppLCPLinkNumber=ibmpppLCPLinkNumber, ibmxnsidpBcastOutRequests=ibmxnsidpBcastOutRequests, ibmChipSetIntel82596B=ibmChipSetIntel82596B, ibmpppLCPInCodeRejs=ibmpppLCPInCodeRejs, ibmmacAddrFilterInBcastType=ibmmacAddrFilterInBcastType, ibmappnNodeLsCpCpSession=ibmappnNodeLsCpCpSession, ibmpppLinkBadControls=ibmpppLinkBadControls, ibmappnNodeLsStatusXidByteInError=ibmappnNodeLsStatusXidByteInError, ibmappnIsInCtrUpTime=ibmappnIsInCtrUpTime, swvpdName=swvpdName, cylinkClockSource=cylinkClockSource, ibmappcInRluParLuName=ibmappcInRluParLuName, ibmdot1dBasePortTable=ibmdot1dBasePortTable, ibmvrtpResSents=ibmvrtpResSents, ibmappcInMdEntry=ibmappcInMdEntry, ibmvRtCfgInFltTable=ibmvRtCfgInFltTable, ibmappcInMdMinClosLimit=ibmappcInMdMinClosLimit, ibmRIFFilterOutRouteDesignator=ibmRIFFilterOutRouteDesignator, ibmappnIsInS2PFmdPius=ibmappnIsInS2PFmdPius, ibmpppLinkStatusTable=ibmpppLinkStatusTable, ibmfrCircuitTable=ibmfrCircuitTable, ibmappnNodeSegReasm=ibmappnNodeSegReasm, ibmipxsapStatOutResponses=ibmipxsapStatOutResponses, ibmipxRouteIfIndex=ibmipxRouteIfIndex, ibmvRtCfgOutFltTable=ibmvRtCfgOutFltTable, ibmpppLinkLastInRxOctets=ibmpppLinkLastInRxOctets, ibmappnIsAcTimeMgrUtcWdays=ibmappnIsAcTimeMgrUtcWdays, ibmmaint=ibmmaint, ibmappcInMdRecvRuSzUpBnd=ibmappcInMdRecvRuSzUpBnd, ibmipxFilterEntry=ibmipxFilterEntry, ibmsnapFilterOutMask=ibmsnapFilterOutMask, ibmfrCircuitExcessBurst=ibmfrCircuitExcessBurst, ibmipxsapServerNet=ibmipxsapServerNet, ibmbridge=ibmbridge, ibmvFltIfIndex=ibmvFltIfIndex, ibmappnNnTopoTgEqualRsns=ibmappnNnTopoTgEqualRsns, ibmappnIsAcSessType=ibmappnIsAcSessType, ibmappcInRluEntry=ibmappcInRluEntry, ibmappnDirNotFoundBcastLocates=ibmappnDirNotFoundBcastLocates, ibmappnNnTgTopologyTable=ibmappnNnTgTopologyTable, ibmvipBadSums=ibmvipBadSums, ibmipPtyQueueIfIndex=ibmipPtyQueueIfIndex, ibmdlsRemoteNameFilterEntry=ibmdlsRemoteNameFilterEntry, ibmmacAddrFilterOutEntry=ibmmacAddrFilterOutEntry, ibmappnNnTopoNodePurges=ibmappnNnTopoNodePurges, ibmappnLocalTgCpCpSession=ibmappnLocalTgCpCpSession, ibmrpq=ibmrpq, cylinkPrimaryPhone=cylinkPrimaryPhone, ibmsysRealMemInUse=ibmsysRealMemInUse, ibmappnMemoryUsed=ibmappnMemoryUsed, ibmdlsStationPrimaryRepollTimeout=ibmdlsStationPrimaryRepollTimeout, ibmvrtpUpdSents=ibmvrtpUpdSents, ibmvFltMask=ibmvFltMask, ibmtbmacFiltOutFilterType=ibmtbmacFiltOutFilterType, ibmpppLinkPacketTooLongs=ibmpppLinkPacketTooLongs, ibmdot1dTpPortEntry=ibmdot1dTpPortEntry, ibmringFilterInBcastType=ibmringFilterInBcastType, ibmappnLocalEnTgTable=ibmappnLocalEnTgTable, ibmhopCountFilterBcastType=ibmhopCountFilterBcastType, ibmappcInSsStatusIndex=ibmappcInSsStatusIndex, ibmappnIsAcP2SFmdBytes=ibmappnIsAcP2SFmdBytes, ibmappcInSsS2PFmdPius=ibmappcInSsS2PFmdPius, cylinkDialoutCapability=cylinkDialoutCapability, ibmvNbrLocAddress=ibmvNbrLocAddress, ibmappnNodeLsLocalDlsSap=ibmappnNodeLsLocalDlsSap, ibmappnIsInPcid=ibmappnIsInPcid, ibmappnNodeLsState=ibmappnNodeLsState, ibmpppLinkInvalidProtocols=ibmpppLinkInvalidProtocols, ibmFiltOrderInType=ibmFiltOrderInType, ibmtbFiltOrderTable=ibmtbFiltOrderTable, ibmappnNodeLsDelay=ibmappnNodeLsDelay, ibmtbwinFiltOutMaskString=ibmtbwinFiltOutMaskString, ibmappnNodeAdaptiveBindPacing=ibmappnNodeAdaptiveBindPacing, ibmvifInPkts=ibmvifInPkts, ibmappnIsInPsSendNxWndwSize=ibmappnIsInPsSendNxWndwSize, ibmpppLinkQualityTable=ibmpppLinkQualityTable, ibmappnIsAcTimeMgrUtcYdays=ibmappnIsAcTimeMgrUtcYdays, ibmipxsapStatOutDiscards=ibmipxsapStatOutDiscards, ibmdlsCirTable=ibmdlsCirTable, ibmpppLinkStatusIndex=ibmpppLinkStatusIndex, ibmpppLinkStatusEntry=ibmpppLinkStatusEntry, ibmappnNnAdjNodeLastFrsnRcvd=ibmappnNnAdjNodeLastFrsnRcvd, ibmRIFFilterInBcastType=ibmRIFFilterInBcastType, ibmvifSlot=ibmvifSlot, ibmRIFFilterInBridgeMask=ibmRIFFilterInBridgeMask, ibmappcInLluCntlPtLu=ibmappcInLluCntlPtLu, ibmappcInSsP2SFmdPius=ibmappcInSsP2SFmdPius, ibmappnIsAccounting=ibmappnIsAccounting, ibmPtyQueueingDiscards=ibmPtyQueueingDiscards, ibmwindowFilterInNotForwarded=ibmwindowFilterInNotForwarded, ibmappnNodeLsCurrentDelay=ibmappnNodeLsCurrentDelay, ibmpppLinkLastUnknownProtocol=ibmpppLinkLastUnknownProtocol, ibmappcInMdTable=ibmappcInMdTable, ibmvarpAssignReqs=ibmvarpAssignReqs, ibmvNbrMetric=ibmvNbrMetric, ibmappnNnTopoNodeBadHighRsns=ibmappnNnTopoNodeBadHighRsns, ibmappcInSsPcid=ibmappcInSsPcid, ibmFiltOrderOutPriority=ibmFiltOrderOutPriority)
mibBuilder.exportSymbols("IBM6611-MIB", ibmappnNodeEnSendRegNames=ibmappnNodeEnSendRegNames, ibmdlsLocalFrameFilterSrcMask=ibmdlsLocalFrameFilterSrcMask, ibmappnNnTgTopologyFREntry=ibmappnNnTgTopologyFREntry, ibmipxAddrIfIndex=ibmipxAddrIfIndex, ibmmacAddrFilterInType=ibmmacAddrFilterInType, ibmappnNnTopoRouteTrees=ibmappnNnTopoRouteTrees, ibmappnNodeLsOutXidBytes=ibmappnNodeLsOutXidBytes, ibmwindowFilterOutIfIndex=ibmwindowFilterOutIfIndex, ibmappnNodeLsOutMsgBytes=ibmappnNodeLsOutMsgBytes, ibmappnIsAcP2SNonFmdPius=ibmappnIsAcP2SNonFmdPius, ibmringFilterOutEntry=ibmringFilterOutEntry, cylinkConfigEntry=cylinkConfigEntry, cylinkNetworkDS1Mode=cylinkNetworkDS1Mode, ibmipxsapStatInErrors=ibmipxsapStatInErrors, ibmxnsRouteNextHop=ibmxnsRouteNextHop, ibmappnNodePortDlcTracRemoteAddr=ibmappnNodePortDlcTracRemoteAddr, ibmappnNodeLsStatusXidRemoteSense=ibmappnNodeLsStatusXidRemoteSense, ibmappnNodeLsLocalTrMac=ibmappnNodeLsLocalTrMac, ibmdot1dBase=ibmdot1dBase, ibmappnIsInSessUpTime=ibmappnIsInSessUpTime, ibmappnNnNodeFRCongested=ibmappnNnNodeFRCongested, ibmipxsapServerTable=ibmipxsapServerTable, ibmsnapFilterInIfIndex=ibmsnapFilterInIfIndex, ibmmacAddrFilterOutSrcAddress=ibmmacAddrFilterOutSrcAddress, ibmappnNodePortTrName=ibmappnNodePortTrName, ibmxnsidpOutDiscards=ibmxnsidpOutDiscards, ibmdlsFrameFilterType=ibmdlsFrameFilterType, ibmappnDirRegEntries=ibmappnDirRegEntries, cylinkSecondaryContact=cylinkSecondaryContact, ibmappnIsAcGlobeMgrUtcMdays=ibmappnIsAcGlobeMgrUtcMdays, ibmappnNnNodeQuiescing=ibmappnNnNodeQuiescing, ibmappnCosTgRowIndex=ibmappnCosTgRowIndex, ibmappnIsInPsAdjTgNum=ibmappnIsInPsAdjTgNum, ibmdlsCirLocalLinkTestCmdsFail=ibmdlsCirLocalLinkTestCmdsFail, ibmtbwinFiltInId=ibmtbwinFiltInId, ibmmacAddrFilterOutBcastType=ibmmacAddrFilterOutBcastType, ibmappnIsAcTimeAgtUtcYdays=ibmappnIsAcTimeAgtUtcYdays, ibmappnNodeIdNum=ibmappnNodeIdNum, ibmappnNnNodeFRGateway=ibmappnNnNodeFRGateway, ibmappnIsAcSecLuName=ibmappnIsAcSecLuName, ibmappnNode=ibmappnNode, ibmipFilterMask2=ibmipFilterMask2, ibmRIFFilterOutRingMask=ibmRIFFilterOutRingMask, ibmappcInLtpLongRun=ibmappcInLtpLongRun, ibmwindowFilterInfoTable=ibmwindowFilterInfoTable, ibmappnIsAcTimeAgtUtcMonths=ibmappnIsAcTimeAgtUtcMonths, ibmmacAddrFilterInfoTable=ibmmacAddrFilterInfoTable, ibmpppLinkErrorsIndex=ibmpppLinkErrorsIndex, ibmipFilterTable=ibmipFilterTable, ibmappcInLluLuName=ibmappcInLluLuName, ibmappnLocalTgSecurity=ibmappnLocalTgSecurity, ibmappnNodeLsTrEntry=ibmappnNodeLsTrEntry, ibmipxRouteEntry=ibmipxRouteEntry, ibmtbEthTypeFiltOutTable=ibmtbEthTypeFiltOutTable, ibmipxidpInReceives=ibmipxidpInReceives, ibmappnNodeLsSpecific=ibmappnNodeLsSpecific, ibmappnLocalNnQuiescing=ibmappnLocalNnQuiescing, ibmpppIPCPOutPackets=ibmpppIPCPOutPackets, ibmappnDirCurHomeEntries=ibmappnDirCurHomeEntries, ibmvPortCfgInFlt=ibmvPortCfgInFlt, ibmappnNodeLsStatusNodeId=ibmappnNodeLsStatusNodeId, ibmpppLinkControlEntry=ibmpppLinkControlEntry, ibmvipBad=ibmvipBad, ibmdot1dTpFdbEntry=ibmdot1dTpFdbEntry, ibmappnIsInFqLuName=ibmappnIsInFqLuName, ibmxnsidpRoutingDiscards=ibmxnsidpRoutingDiscards, ibmtbwinFiltInMaskString=ibmtbwinFiltInMaskString, ibmSelectNetFilterNetEnd=ibmSelectNetFilterNetEnd, ibmappnNodeEnSegGen=ibmappnNodeEnSegGen, ibmappnLocalEnTgDestVirtual=ibmappnLocalEnTgDestVirtual, ibmappnNnNodeRsn=ibmappnNnNodeRsn, ibmappnIsAcRecTime=ibmappnIsAcRecTime, ibmappnNodeLsDlcType=ibmappnNodeLsDlcType, ibmipxConfigEntry=ibmipxConfigEntry, ibmappnNodeService=ibmappnNodeService, ibmappcInMdWaitReqLst=ibmappcInMdWaitReqLst, ibmappcInLtpDefType=ibmappcInLtpDefType, ibmappnNnTgDest=ibmappnNnTgDest, cylinkConfigTable=cylinkConfigTable, ibmtbsapFiltInNotForwarded=ibmtbsapFiltInNotForwarded, ibmappnLocalEnTgUsr2=ibmappnLocalEnTgUsr2, ibmRIFFilterInTable=ibmRIFFilterInTable, ibmvarpQueryReqs=ibmvarpQueryReqs, ibmappnNnNodeIsrDepleted=ibmappnNnNodeIsrDepleted, ibmappcInMdActClos=ibmappcInMdActClos, ibmappnSnmpInTotalVars=ibmappnSnmpInTotalVars, ibmtbEthTypeFiltInfoEntry=ibmtbEthTypeFiltInfoEntry, ibmsapFilterOutNotForwarded=ibmsapFilterOutNotForwarded, ibmvipZeroHops=ibmvipZeroHops, ibmappcInMdSendPacWinSz=ibmappcInMdSendPacWinSz, ibmappnIsAcSessStartTime=ibmappnIsAcSessStartTime, ibmappnLocalTgConnCost=ibmappnLocalTgConnCost, ibmvRtCfgOutFltUses=ibmvRtCfgOutFltUses, ibmfrCircuitSentFrames=ibmfrCircuitSentFrames, ibmappcInRluActCnosSup=ibmappcInRluActCnosSup, ibmdot1dStaticStatus=ibmdot1dStaticStatus, ibmfrDlcmiTable=ibmfrDlcmiTable, ibmtbwinFiltInNotForwarded=ibmtbwinFiltInNotForwarded, ibmipPtyQueueEnableIfIndex=ibmipPtyQueueEnableIfIndex, ibmsysPageSpaceTotal=ibmsysPageSpaceTotal, ibmnbpFilterPacketsSent=ibmnbpFilterPacketsSent, ibmpppLinkBadCRCs=ibmpppLinkBadCRCs, ibmappnLocalEnTgNum=ibmappnLocalEnTgNum, ibmvipTooSmalls=ibmvipTooSmalls, ibmappnIsInSsAdjCpName=ibmappnIsInSsAdjCpName, ibmappcInMdMaxSessLimit=ibmappcInMdMaxSessLimit, ibmappnDirOutLocates=ibmappnDirOutLocates, ibmappcInSsStatusModeName=ibmappcInSsStatusModeName, ibmappnLocalGeneral=ibmappnLocalGeneral, ibmRIFFilterOutRingNumber=ibmRIFFilterOutRingNumber, ibmvRtEntry=ibmvRtEntry, ibmpppIPCPInOctets=ibmpppIPCPInOctets, ibmappnCosNodeRowResistMin=ibmappnCosNodeRowResistMin, ibmappcInGlobeCtrStatus=ibmappcInGlobeCtrStatus, ibmappnNnTgFRRsn=ibmappnNnTgFRRsn, ibmappnLocalEnTgUsr1=ibmappnLocalEnTgUsr1, ibmappcInLtpSecReq=ibmappcInLtpSecReq, ibmbridgeWindowFilters=ibmbridgeWindowFilters, ibmxnsLoopbackActive=ibmxnsLoopbackActive, ibmappnLocalNnEndptDepleted=ibmappnLocalNnEndptDepleted, ibmpppLinkLocalQualityPeriod=ibmpppLinkLocalQualityPeriod, ibmappnIsAcTimeMgrUtcSecs=ibmappnIsAcTimeMgrUtcSecs, ibmdlsCirSrcAddress=ibmdlsCirSrcAddress, ibmmacAddrFilterType=ibmmacAddrFilterType, ibmipFilterAddr1=ibmipFilterAddr1, ibmvInterface=ibmvInterface, ibmvNbrNumber=ibmvNbrNumber, ibmdecLANCircuitTable=ibmdecLANCircuitTable, ibmappnLocalNnGateway=ibmappnLocalNnGateway, ibmappnNodePortTable=ibmappnNodePortTable, ibmsnapFilterOutFilterType=ibmsnapFilterOutFilterType, ibmappcInSsSessType=ibmappcInSsSessType, ibmtbEthTypeFiltOutMask=ibmtbEthTypeFiltOutMask, ibmdot1dTpFdbAddress=ibmdot1dTpFdbAddress, ibmtbmacFiltInFilterType=ibmtbmacFiltInFilterType, ibmdlsStationSrcAddress=ibmdlsStationSrcAddress, ibmappnNodeLsIpTable=ibmappnNodeLsIpTable, ibmmaintShutdown=ibmmaintShutdown, ibmfrCircuitEntry=ibmfrCircuitEntry, ibmappcInSsEnhanceSecSup=ibmappcInSsEnhanceSecSup, ibmappcInMdRecvPacWinSz=ibmappcInMdRecvPacWinSz, ibmappnNnTgCpCpSession=ibmappnNnTgCpCpSession, ibmtbwinFiltInOffset=ibmtbwinFiltInOffset, ibmappnNnTopoNodeStateUpdates=ibmappnNnTopoNodeStateUpdates, ibmringFilterInEntry=ibmringFilterInEntry, ibmappnIsInModeName=ibmappnIsInModeName, ibmipxAddrEntry=ibmipxAddrEntry, ibmappcInMdActCwin=ibmappcInMdActCwin, ibmappcInSsStatusTime=ibmappcInSsStatusTime, ibmappnDirServerName=ibmappnDirServerName, ibmSelectNetFilter=ibmSelectNetFilter, ibmwindowFilterInOffset=ibmwindowFilterInOffset, ibmipxsapStatOutRequests=ibmipxsapStatOutRequests, ibmappcInSsRecvMaxRuSz=ibmappcInSsRecvMaxRuSz, ibmappnNodeLsSecurity=ibmappnNodeLsSecurity, ibmappcInRluActAttSecSup=ibmappcInRluActAttSecSup, swvpdState=swvpdState, ibmxnsidpBadTTL=ibmxnsidpBadTTL, ibmvrtpResRecs=ibmvrtpResRecs, ibmappcInLtpSyncLvl=ibmappcInLtpSyncLvl, ibmtbwinFiltInOffsetStart=ibmtbwinFiltInOffsetStart, ibmipxRouteTable=ibmipxRouteTable, ibmvNbrLocSlot=ibmvNbrLocSlot, ibmappnNnTgFRDlcData=ibmappnNnTgFRDlcData, ibmappnLocalTg=ibmappnLocalTg, swVpdTable=swVpdTable, ibmappnIsInSsRecvPacingType=ibmappnIsInSsRecvPacingType, ibmpppLCPOutDiscReqs=ibmpppLCPOutDiscReqs, ibmappcInLluEntry=ibmappcInLluEntry, ibmsysRealMemSize=ibmsysRealMemSize, ibmvFRP=ibmvFRP, ibmsapFilterType=ibmsapFilterType, ibmfr=ibmfr, ibmappnIsAcGlobeMgrName=ibmappnIsAcGlobeMgrName, ibmfrCircuitSentOctets=ibmfrCircuitSentOctets, ibmdot1dTpAgingTime=ibmdot1dTpAgingTime, ibmappnNnTgDlcData=ibmappnNnTgDlcData, ibmvFRPfrgCreated=ibmvFRPfrgCreated, ibmvFltUses=ibmvFltUses, ibmpppLCPOutCodeRejs=ibmpppLCPOutCodeRejs, ibmappnNnNodeGateway=ibmappnNnNodeGateway, ibmappcInSsP2SNonFmdPius=ibmappcInSsP2SNonFmdPius, ibmappnIsAcFqLuName=ibmappnIsAcFqLuName, ibmappnNodeLsIdNum=ibmappnNodeLsIdNum, ibmpppLCPOutEchoReqs=ibmpppLCPOutEchoReqs, ibmappnIsInSsSendNxWndwSize=ibmappnIsInSsSendNxWndwSize, ibmvFRPfragsReassembled=ibmvFRPfragsReassembled, ibmipxsapStatInRequests=ibmipxsapStatInRequests, ibmappcInMdDfCrypto=ibmappcInMdDfCrypto, ibmdlsRemoteNameFilterID=ibmdlsRemoteNameFilterID, ibmappnIsInSsRecvRpc=ibmappnIsInSsRecvRpc, ibmbridgeSNAPFilters=ibmbridgeSNAPFilters, ibmappnNnUniqueInfoAndCaps=ibmappnNnUniqueInfoAndCaps, ibmtbEthTypeFiltOutIfIndex=ibmtbEthTypeFiltOutIfIndex, ibmappcInMdSendRuSzLoBnd=ibmappcInMdSendRuSzLoBnd, ibmMainProcessorLoadTable=ibmMainProcessorLoadTable, ibmvRtTable=ibmvRtTable, ibmhopCountFilterCount=ibmhopCountFilterCount, ibmvipRouted=ibmvipRouted, ibmappnNnTgModemClass=ibmappnNnTgModemClass, ibmappnNnAdjNodeOutOfSeqTdus=ibmappnNnAdjNodeOutOfSeqTdus, ibmappnLocalTgOperational=ibmappnLocalTgOperational, ibmappnIsAcBtypeActive=ibmappnIsAcBtypeActive, ibmappnCosNodeRowIndex=ibmappnCosNodeRowIndex, ibmappnNodeLsMigration=ibmappnNodeLsMigration, ibmTrapThrottleCount=ibmTrapThrottleCount, ibmappnNnTopoRouteEntry=ibmappnNnTopoRouteEntry, ibmappnNodeLsUsr1=ibmappnNodeLsUsr1, ibmpppLinkLastOutTxPackets=ibmpppLinkLastOutTxPackets, ibmtbwinFiltInfoTable=ibmtbwinFiltInfoTable, ibmtbEthTypeFiltIfIndex=ibmtbEthTypeFiltIfIndex, ibmvifPort=ibmvifPort, ibmdlsCirLocalLinkAdpRcvErr=ibmdlsCirLocalLinkAdpRcvErr, ibmhopCountFilterInfoTable=ibmhopCountFilterInfoTable, ibmappnIsInPriLuName=ibmappnIsInPriLuName, ibmappnPortInformation=ibmappnPortInformation, ibmappnLocalEnTgEntry=ibmappnLocalEnTgEntry, ibmsysMBUFs=ibmsysMBUFs, ibmpppLCPEntry=ibmpppLCPEntry, ibmvRtCfgOutFltNetID=ibmvRtCfgOutFltNetID, ibmappnIsAcTimeRecTime=ibmappnIsAcTimeRecTime, ibmpppLinkInRxOctets=ibmpppLinkInRxOctets, ibmipxidpForwarding=ibmipxidpForwarding, ibmappnNnTgOperational=ibmappnNnTgOperational, ibmfrErrTime=ibmfrErrTime, ibmxnsPortIfIndex=ibmxnsPortIfIndex, ibmwindowFilterOutMaskString=ibmwindowFilterOutMaskString, ibmdlsRouterTable=ibmdlsRouterTable, ibmappcInMdModeName=ibmappcInMdModeName, ibmTGGroupName=ibmTGGroupName, ibmpppLCPInCNs=ibmpppLCPInCNs, ibmappnLocalTgDest=ibmappnLocalTgDest, ibmappnNodeLsStatusTable=ibmappnNodeLsStatusTable, ibmappnNodeNnTreeUpdate=ibmappnNodeNnTreeUpdate, ibmappnNnNodeFRRsn=ibmappnNnNodeFRRsn, ibmpppIPLinkNumber=ibmpppIPLinkNumber, cylinkDTEFraming=cylinkDTEFraming, ibmtbwinFiltInIfIndex=ibmtbwinFiltInIfIndex, ibmappnNnTopoTotalRouteCalcs=ibmappnNnTopoTotalRouteCalcs, ibmvRtState=ibmvRtState, ibmappnIsInPsSendPacingType=ibmappnIsInPsSendPacingType, ibmappnSessGeneral=ibmappnSessGeneral, ibmappnNodeDynLsBadXids=ibmappnNodeDynLsBadXids, ibmfrCircuitLastTimeChange=ibmfrCircuitLastTimeChange, ibmappnSnmpOutNoSuchNames=ibmappnSnmpOutNoSuchNames, ibmappcInMdDefType=ibmappcInMdDefType, ibmdlsRouterEntry=ibmdlsRouterEntry, ibmpppLinkTerminateTimeouts=ibmpppLinkTerminateTimeouts, ibmappnNodeLsStatusLocalAddr=ibmappnNodeLsStatusLocalAddr, ibmwindowFilterInNumBytes=ibmwindowFilterInNumBytes, ibmbridgeFiltOrderTable=ibmbridgeFiltOrderTable, ibmbridgeRIFFilters=ibmbridgeRIFFilters, ibmipFilterExtEntry=ibmipFilterExtEntry, ibmappnNodeLsStatusXidLocalSense=ibmappnNodeLsStatusXidLocalSense)
mibBuilder.exportSymbols("IBM6611-MIB", ibmpppLinkRemoteACCMap=ibmpppLinkRemoteACCMap, cylinkDIUFrequency=cylinkDIUFrequency, ibmappnNnTopo=ibmappnNnTopo, ibmappnLocalEnName=ibmappnLocalEnName, ibmringFilterOutBcastType=ibmringFilterOutBcastType, ibmappnCosName=ibmappnCosName, ibmappnNodeLsMaxDelayTime=ibmappnNodeLsMaxDelayTime, ibmappnIsAcBtypeRecPerBuf=ibmappnIsAcBtypeRecPerBuf, ibmmacAddrFilterOutIfIndex=ibmmacAddrFilterOutIfIndex, ibmwindowFilterInBcastType=ibmwindowFilterInBcastType, ibmappnNnNodeName=ibmappnNnNodeName, ibmappnNodeLsEffCap=ibmappnNodeLsEffCap, ibmdot1dStaticTable=ibmdot1dStaticTable, ibmvFRPreasFails=ibmvFRPreasFails, ibmappnCosTgRowUsr1Max=ibmappnCosTgRowUsr1Max, ibmFiltOrderOutIfIndex=ibmFiltOrderOutIfIndex, ibmappcInSsStatusDetectModule=ibmappcInSsStatusDetectModule, ibmtbwinFiltInTable=ibmtbwinFiltInTable, ibmpppLinkInTxLQRs=ibmpppLinkInTxLQRs, ibmtbwinFiltOutTable=ibmtbwinFiltOutTable, ibmSelectNetFilterIndex=ibmSelectNetFilterIndex, ibmappnNnTgFRModemClass=ibmappnNnTgFRModemClass, ibmappnNnTopoNodeTimerUpdates=ibmappnNnTopoNodeTimerUpdates, ibmdlsCirLocalLinkAdpSendErr=ibmdlsCirLocalLinkAdpSendErr, ibmappnIsInGlobal=ibmappnIsInGlobal, ibmappnNnTopoTgTimerUpdates=ibmappnNnTopoTgTimerUpdates, ibmtbEthTypeFiltOutEntry=ibmtbEthTypeFiltOutEntry, ibmSelectNetFilterNetStart=ibmSelectNetFilterNetStart, ibmsapFilterOutBcastType=ibmsapFilterOutBcastType, ibmappnIsAcP2SFmdPius=ibmappnIsAcP2SFmdPius, ibmappnIsAcBtypeEntry=ibmappnIsAcBtypeEntry, ibmwindowFilterIfIndex=ibmwindowFilterIfIndex, ibmdlsDefaultRouterAddress=ibmdlsDefaultRouterAddress, ibmdlsCirLocalConnectionState=ibmdlsCirLocalConnectionState, ibmappnNnNodeFrsn=ibmappnNnNodeFrsn, ibmdot1dStpPriority=ibmdot1dStpPriority, ibmappnConvEndPoint=ibmappnConvEndPoint, ibmfrDlcmiMaxSupportedVCs=ibmfrDlcmiMaxSupportedVCs, ibmappnIsAcGlobeCheckPt=ibmappnIsAcGlobeCheckPt, ibmappnIsAcGlobeStatus=ibmappnIsAcGlobeStatus, swvpdPtfName=swvpdPtfName, ibmipFilterEntry=ibmipFilterEntry, cylinkSecondaryPhone=cylinkSecondaryPhone, ibmRIFFilterOutNotForwarded=ibmRIFFilterOutNotForwarded, ibmappnSessIntermediate=ibmappnSessIntermediate, ibmappnLocalThisNode=ibmappnLocalThisNode, ibmdot1dStpPortTable=ibmdot1dStpPortTable, ibmTG=ibmTG, ibmdot1dTp=ibmdot1dTp, ibmappnNnNodeFRChainSupport=ibmappnNnNodeFRChainSupport, swvpdIndex=swvpdIndex, ibmipxRouteNextHop=ibmipxRouteNextHop, ibmdot1dStpForwardDelay=ibmdot1dStpForwardDelay, ibmpppLinkInTxPackets=ibmpppLinkInTxPackets, ibmsnapFilterInfoEntry=ibmsnapFilterInfoEntry, ibmappcInGlobeStatus=ibmappcInGlobeStatus, ibmdlsDefaultNBRouterAddress=ibmdlsDefaultNBRouterAddress, ibmPtyQueueingTable=ibmPtyQueueingTable, ibmipxidpOutNoRoutes=ibmipxidpOutNoRoutes, ibmappnIsInP2SNonFmdPius=ibmappnIsInP2SNonFmdPius, ibmappnLocalEnTable=ibmappnLocalEnTable, ibmxnsFilterNumber=ibmxnsFilterNumber, ibmappnLocalEnTgByteCost=ibmappnLocalEnTgByteCost, ibmdlsLocalNameFilterDestAddress=ibmdlsLocalNameFilterDestAddress, swvpdDateTime=swvpdDateTime, ibmxnsFilterType=ibmxnsFilterType, ibmsysMBUFsPercents=ibmsysMBUFsPercents, ibmxnsErrOutMsgs=ibmxnsErrOutMsgs, ibmRIFFilterInNotForwarded=ibmRIFFilterInNotForwarded, ibmfrErrTable=ibmfrErrTable, ibmFiltOrderOutEntry=ibmFiltOrderOutEntry, ibmsysInfo=ibmsysInfo, ibmtbEthTypeFiltInIfIndex=ibmtbEthTypeFiltInIfIndex, ibmtbmacFiltIfIndex=ibmtbmacFiltIfIndex, ibmpppLinkControlIndex=ibmpppLinkControlIndex, ibmappnNnTgFRConnCost=ibmappnNnTgFRConnCost, ibmmacAddrFilterOutDestMask=ibmmacAddrFilterOutDestMask, ibmappnCosNameTable=ibmappnCosNameTable, ibmdot1dStp=ibmdot1dStp, ibmipxidpBadTTL=ibmipxidpBadTTL, ibmtbsapFiltIfIndex=ibmtbsapFiltIfIndex, ibmxnsFilterValue=ibmxnsFilterValue, ibmSelectNetIndex=ibmSelectNetIndex, ibmappcInSsP2SFmdBytes=ibmappcInSsP2SFmdBytes, ibmdlsRemoteNameFilterSrcAddress=ibmdlsRemoteNameFilterSrcAddress, ibmappnLocalNnSpecific=ibmappnLocalNnSpecific, ibmdlsLocalFrameFilterTable=ibmdlsLocalFrameFilterTable, ibmappnNnTgFROperational=ibmappnNnTgFROperational, ibmappnLocalTgDlcData=ibmappnLocalTgDlcData, ibmappnIsInP2SFmdBytes=ibmappnIsInP2SFmdBytes, ibmappnSessEndPoint=ibmappnSessEndPoint, ibmwindowFilterOutId=ibmwindowFilterOutId, ibmappnIsInPsAdjCpName=ibmappnIsInPsAdjCpName, ibmMainProcessorLoadIndex=ibmMainProcessorLoadIndex, ibmtbmacFiltInDestAddress=ibmtbmacFiltInDestAddress, ibmappnDirLocateOutstands=ibmappnDirLocateOutstands, ibmdot1dStpPortDesignatedCost=ibmdot1dStpPortDesignatedCost, ibmSelectNetFilterEntry=ibmSelectNetFilterEntry, ibmappcInRluActParaSessSup=ibmappcInRluActParaSessSup, ibmsapFilterIfIndex=ibmsapFilterIfIndex, ibmTrapNum=ibmTrapNum, ibmRIFFilterOutFilterType=ibmRIFFilterOutFilterType, ibmvRouterNetid=ibmvRouterNetid, ibmdot1dStpTimeSinceTopologyChange=ibmdot1dStpTimeSinceTopologyChange, ibmappnIsAcP2SNonFmdBytes=ibmappnIsAcP2SNonFmdBytes, ibmappnIsAcBufOldestIndex=ibmappnIsAcBufOldestIndex, ibmdlsCirEntry=ibmdlsCirEntry, ibmvarpServiceResps=ibmvarpServiceResps, ibmappnNodePortLsRole=ibmappnNodePortLsRole, ibmdecAllEndNodesFuncAddr=ibmdecAllEndNodesFuncAddr, ibmappnCosNodeRowName=ibmappnCosNodeRowName, ibmipxFilterTable=ibmipxFilterTable, ibmxnsidpBcastInReceives=ibmxnsidpBcastInReceives, ibmappnMemoryCritThresh=ibmappnMemoryCritThresh, ibmipxsapStatInResponses=ibmipxsapStatInResponses, ibmappnNodePortDlsEntry=ibmappnNodePortDlsEntry, ibmappnIsAcGlobeMgrUtcHours=ibmappnIsAcGlobeMgrUtcHours, ibmChipSetSignetics=ibmChipSetSignetics, ibmappnConvGeneral=ibmappnConvGeneral, ibmfrDlcmiAddressLen=ibmfrDlcmiAddressLen, ibmdlsStationTransmitWindowCount=ibmdlsStationTransmitWindowCount, ibmdot1dTpPortMaxInfo=ibmdot1dTpPortMaxInfo, ibmappnNodeLsCurrentStateTime=ibmappnNodeLsCurrentStateTime, ibmatportFilterTable=ibmatportFilterTable, ibmappnNodeLsRemoteDlsSap=ibmappnNodeLsRemoteDlsSap, ibmappnNodeLsInMsgFrames=ibmappnNodeLsInMsgFrames, ibmappcInSsS2PNonFmdBytes=ibmappcInSsS2PNonFmdBytes, cylinkAlarmRepeatTime=cylinkAlarmRepeatTime, ibmmacAddrFilterInSrcMask=ibmmacAddrFilterInSrcMask, ibmipxidpTooSmall=ibmipxidpTooSmall, ibmappcInLluBindRspMayQ=ibmappcInLluBindRspMayQ, ibmdlsStationIfIndex=ibmdlsStationIfIndex, ibmipxFilterType=ibmipxFilterType, ibmappcInLluSessLimit=ibmappcInLluSessLimit, ibmappnNodeNnCentralDirectory=ibmappnNodeNnCentralDirectory, ibmpppLinkMeasurementsValid=ibmpppLinkMeasurementsValid, ibmappnLocalNnCongested=ibmappnLocalNnCongested, ibmappnNodeLsStatusTime=ibmappnNodeLsStatusTime, ibmmacAddrFilterOutFilterType=ibmmacAddrFilterOutFilterType, ibmsnapFilterInfoTable=ibmsnapFilterInfoTable, ibmappnLocalEnType=ibmappnLocalEnType, ibmpppLinkInRxPackets=ibmpppLinkInRxPackets, ibmwindowFilterOutTable=ibmwindowFilterOutTable, ibmappnNnTgFRQuiescing=ibmappnNnTgFRQuiescing, ibmtbmacFiltInTable=ibmtbmacFiltInTable, ibmappnNodeLsUsr2=ibmappnNodeLsUsr2, ibminterfaces=ibminterfaces, ibmappnIsInPsSendMaxBtuSize=ibmappnIsInPsSendMaxBtuSize, ibmappnNodeLsRemoteIpPortNum=ibmappnNodeLsRemoteIpPortNum, ibmdot1dBasePortEntry=ibmdot1dBasePortEntry, ibmfrDlcmiAddress=ibmfrDlcmiAddress, ibmipx=ibmipx, ibmappcInGlobeCtrStatusTime=ibmappcInGlobeCtrStatusTime, ibmappnIsAcBufState=ibmappnIsAcBufState, ibmappnNnTgFREffCap=ibmappnNnTgFREffCap, cylinkDTEDS1Mode=cylinkDTEDS1Mode, ibmxnsFilterIfIndex=ibmxnsFilterIfIndex, ibmvRtCfgOutFltMode=ibmvRtCfgOutFltMode, ibmappnNnTopologyFREntry=ibmappnNnTopologyFREntry, ibmappcInMdPtmClos=ibmappcInMdPtmClos, ibmRIFFilterInRouteDesignator=ibmRIFFilterInRouteDesignator, ibmsnapFilterOutTable=ibmsnapFilterOutTable, ibmsysMBUFsInUses=ibmsysMBUFsInUses, ibmappnNnTopologyEntry=ibmappnNnTopologyEntry, ibmtbMACAddressFilters=ibmtbMACAddressFilters, ibmdlsCirSrcSap=ibmdlsCirSrcSap, ibmsnapFilterIfIndex=ibmsnapFilterIfIndex, ibmpppIPCPOutOctets=ibmpppIPCPOutOctets, ibmappnNodePortMaxIframeWindow=ibmappnNodePortMaxIframeWindow, ibmpppIPCPLinkNumber=ibmpppIPCPLinkNumber, ibmipxidpZeroDirBcast=ibmipxidpZeroDirBcast, swvpdFixId=swvpdFixId, ibmvRtCfgMax=ibmvRtCfgMax, ibmvRtCfgFltNetID=ibmvRtCfgFltNetID, ibmxnsErrSquelched=ibmxnsErrSquelched, ibmvRtCfgOutFltNum=ibmvRtCfgOutFltNum, ibmappnNodeLsIpState=ibmappnNodeLsIpState, ibmtbmacFiltInfoTable=ibmtbmacFiltInfoTable, ibmTGEnable=ibmTGEnable, ibmpppLinkLocalMRU=ibmpppLinkLocalMRU, ibmipPtyQueueEnableTable=ibmipPtyQueueEnableTable, ibmappnNnTgFRUsr3=ibmappnNnTgFRUsr3, ibmappnNnTopology=ibmappnNnTopology, ibmappnNnTgTopologyEntry=ibmappnNnTgTopologyEntry, swVpdEntry=swVpdEntry, ibmvRtConfig=ibmvRtConfig, ibmappcInRluDefAllVerSup=ibmappcInRluDefAllVerSup, ibmwindowFilterOutContents=ibmwindowFilterOutContents, ibmvNbrFlags=ibmvNbrFlags, ibmdecAllRoutersFuncAddr=ibmdecAllRoutersFuncAddr, ibmappnCosModeName=ibmappnCosModeName, ibmdot1dStpPortPathCost=ibmdot1dStpPortPathCost, ibmappcInRluDefSessSecSup=ibmappcInRluDefSessSecSup, ibmvRtCfgFltNum=ibmvRtCfgFltNum, ibmdlsCirLocalLinkDataPktSent=ibmdlsCirLocalLinkDataPktSent, ibmappcInLtpInstNum=ibmappcInLtpInstNum, ibmFiltOrderInPriority=ibmFiltOrderInPriority, ibmappnNodePortDlcTracDlcType=ibmappnNodePortDlcTracDlcType, ibmringFilterOutTable=ibmringFilterOutTable, ibmappnLocalTgUsr3=ibmappnLocalTgUsr3, ibmringFilterOutNumber=ibmringFilterOutNumber, ibmappnNnTgFrsn=ibmappnNnTgFrsn, ibmdlsLocalFrameFilterDestAddress=ibmdlsLocalFrameFilterDestAddress, ibmdot1dBasePortMtuExceededDiscards=ibmdot1dBasePortMtuExceededDiscards, ibmFiltOrderInEntry=ibmFiltOrderInEntry, ibm6611=ibm6611, ibmappnIsInSessType=ibmappnIsInSessType, ibmvFltNo=ibmvFltNo, ibmxns=ibmxns, ibmappnLocalNnIsrDepleted=ibmappnLocalNnIsrDepleted, ibmipxidpBadLen=ibmipxidpBadLen, ibmdlsRouterStatus=ibmdlsRouterStatus, ibmappnIsInS2PNonFmdPius=ibmappnIsInS2PNonFmdPius, ibmfrCircuitState=ibmfrCircuitState, ibmappnNodeLsStatusIndex=ibmappnNodeLsStatusIndex, ibmsysRealMemFree=ibmsysRealMemFree, ibmappnGeneralInfoAndCaps=ibmappnGeneralInfoAndCaps, ibmvFltValue=ibmvFltValue, ibmappcInMdPndClos=ibmappcInMdPndClos, ibmSelectNetTable=ibmSelectNetTable, ibmdlsLocalNameFilterTable=ibmdlsLocalNameFilterTable, ibmappnNnTopoNodeGoodHighRsns=ibmappnNnTopoNodeGoodHighRsns, ibmappcInMdSessLimit=ibmappcInMdSessLimit, ibmappcInSsS2PFmdBytes=ibmappcInSsS2PFmdBytes, ibmxnsidpInDiscards=ibmxnsidpInDiscards, ibmdot1dStpBridgeHelloTime=ibmdot1dStpBridgeHelloTime, ibmvifDescr=ibmvifDescr, ibmringFilterInfoEntry=ibmringFilterInfoEntry, ibmdlsCirLocalLinkDataPktResent=ibmdlsCirLocalLinkDataPktResent, ibmpppIPCPTable=ibmpppIPCPTable, ibmmacAddrFilterInfoEntry=ibmmacAddrFilterInfoEntry, ibmptyqueue=ibmptyqueue, ibmappcInSsSessUpTime=ibmappcInSsSessUpTime, ibmdot1dStatic=ibmdot1dStatic, ibmwindowFilterType=ibmwindowFilterType, ibmpppLinkMagicNumber=ibmpppLinkMagicNumber, ibmtbEthTypeFiltOutValue=ibmtbEthTypeFiltOutValue, ibmappnLocalTgTable=ibmappnLocalTgTable, ibmappnNnTopoCurNumNodes=ibmappnNnTopoCurNumNodes, ibmdot1dStaticAddress=ibmdot1dStaticAddress, ibmwindowFilterInMaskString=ibmwindowFilterInMaskString, ibmipPtyQueueEntry=ibmipPtyQueueEntry, ibmvRtCfgInFltNetID=ibmvRtCfgInFltNetID, ibmappnNodeEnModeCosMap=ibmappnNodeEnModeCosMap, ibmringFilterInTable=ibmringFilterInTable, ibmxnsidpForwarding=ibmxnsidpForwarding, ibmappnCosTgRowUsr2Max=ibmappnCosTgRowUsr2Max, ibmappnIsInSsSendPacingType=ibmappnIsInSsSendPacingType, ibmdot1dStaticEntry=ibmdot1dStaticEntry, ibmdlsDefaultNBDestEntry=ibmdlsDefaultNBDestEntry, ibmpppLCPTable=ibmpppLCPTable, ibmpppLCPOutCNs=ibmpppLCPOutCNs, ibmappnNodeEnLocateCdinit=ibmappnNodeEnLocateCdinit, ibmtbwinFiltInContents=ibmtbwinFiltInContents)
mibBuilder.exportSymbols("IBM6611-MIB", ibmappnCos=ibmappnCos, ibmvifAddress=ibmvifAddress, ibmChipSetSigneticsSCN68562=ibmChipSetSigneticsSCN68562, ibmappnNnTgFRSecurity=ibmappnNnTgFRSecurity, ibmappnDirLuLocation=ibmappnDirLuLocation, ibmxnsidpMcastOutRequests=ibmxnsidpMcastOutRequests, ibmpppLinkErrorsEntry=ibmpppLinkErrorsEntry, ibmringFilterInNotForwarded=ibmringFilterInNotForwarded, ibmpppLinkLastOutTxOctets=ibmpppLinkLastOutTxOctets, ibmappcInMdReinit=ibmappcInMdReinit, ibmvRTP=ibmvRTP, ibmappnNodePortIpName=ibmappnNodePortIpName, ibmvPortCfgOutFlt=ibmvPortCfgOutFlt, ibmpppLinkCurrentState=ibmpppLinkCurrentState, ibmappnLocalTgEntry=ibmappnLocalTgEntry, ibmappnNodePortDlcTraceTable=ibmappnNodePortDlcTraceTable, ibmtbEthTypeFiltOutFilterType=ibmtbEthTypeFiltOutFilterType, ibmappnNodeLsIpName=ibmappnNodeLsIpName, ibmappnIsAcTimeMgrTimeValid=ibmappnIsAcTimeMgrTimeValid, ibmdlsRouterInFrames=ibmdlsRouterInFrames, ibmtbEthTypeFiltInValue=ibmtbEthTypeFiltInValue, ibmappnNnTopoTotalRouteRejs=ibmappnNnTopoTotalRouteRejs, ibmringFilterOutNotForwarded=ibmringFilterOutNotForwarded, ibmwindowFilterInContents=ibmwindowFilterInContents, ibmRIFFilterInBridgeNumber=ibmRIFFilterInBridgeNumber, ibmdlsDefaultDestAddress=ibmdlsDefaultDestAddress, ibmsnapFilterOutEntry=ibmsnapFilterOutEntry, ibmappcInSsPaceType=ibmappcInSsPaceType, ibmwindowFilterInOffsetStart=ibmwindowFilterInOffsetStart, ibmappnIsInSsAdjTgNum=ibmappnIsInSsAdjTgNum, swvpdRelId=swvpdRelId, ibmappnNodeLsStatusDlcType=ibmappnNodeLsStatusDlcType, ibmpppIPOutOctets=ibmpppIPOutOctets, ibmRIFFilterOutBcastType=ibmRIFFilterOutBcastType, ibmappnIsAcGlobeMgrUtcMins=ibmappnIsAcGlobeMgrUtcMins, ibmappnNodePortDefLsGoodXids=ibmappnNodePortDefLsGoodXids, ibmdlsCirLocalAddress=ibmdlsCirLocalAddress, ibmRIFFilterInRingMask=ibmRIFFilterInRingMask, ibmappcInSsSluName=ibmappcInSsSluName, ibmappnNodePortDefLsBadXids=ibmappnNodePortDefLsBadXids, ibmxnsPortStatus=ibmxnsPortStatus, ibmappnNodePortDlcTracCmdType=ibmappnNodePortDlcTracCmdType, ibmappnLocalEnTgEntryTimeLeft=ibmappnLocalEnTgEntryTimeLeft, ibmappnCosTgRowSecurityMax=ibmappnCosTgRowSecurityMax, ibmappnCosTransPriority=ibmappnCosTransPriority, ibmappnNodeLsStatusXidBitInError=ibmappnNodeLsStatusXidBitInError, ibmappnCosNodeRowMaxCongestAllow=ibmappnCosNodeRowMaxCongestAllow, ibmsnmp=ibmsnmp, ibmappnLocalNnFrsn=ibmappnLocalNnFrsn, ibmappnCosModeEntry=ibmappnCosModeEntry, ibmappcInLtpVerPip=ibmappcInLtpVerPip, ibmnbpFilterPacketsFiltered=ibmnbpFilterPacketsFiltered, ibmtbFiltOrderOutName=ibmtbFiltOrderOutName, ibmappnNnNodeFRIsr=ibmappnNnNodeFRIsr, ibmpppIPInOctets=ibmpppIPInOctets, ibmappnNnNodeChainSupport=ibmappnNnNodeChainSupport, ibmappnIsAcTimeMgrUtcIsdst=ibmappnIsAcTimeMgrUtcIsdst, ibmMainProcessorLoadEntry=ibmMainProcessorLoadEntry, ibmdot1dBasePortDelayExceededDiscards=ibmdot1dBasePortDelayExceededDiscards, ibmpppLCPOutCAs=ibmpppLCPOutCAs, ibmipxRouteUse=ibmipxRouteUse, ibmappnIsAcTimeAgtUtcIsdst=ibmappnIsAcTimeAgtUtcIsdst, ibmappnNnTgFRNum=ibmappnNnTgFRNum, ibmRIFFilterInfoTable=ibmRIFFilterInfoTable, ibmsapFilterInBcastType=ibmsapFilterInBcastType, ibmvPortCfgMetric=ibmvPortCfgMetric, ibmxnsRouteIfIndex=ibmxnsRouteIfIndex, ibmxnsFilterHCCompare=ibmxnsFilterHCCompare, ibmappnDirNotFoundLocates=ibmappnDirNotFoundLocates, ibmappnNn=ibmappnNn, ibmtbEthTypeFiltInEntry=ibmtbEthTypeFiltInEntry, ibmwindowFilterOutOffsetStart=ibmwindowFilterOutOffsetStart, ibmpppIPCPEntry=ibmpppIPCPEntry, ibmvPortCfgEN=ibmvPortCfgEN, ibmappnLocalTopology=ibmappnLocalTopology, ibmTGIfIndex=ibmTGIfIndex, ibmfrDlcmiErrorThreshold=ibmfrDlcmiErrorThreshold, ibmappnCosNodeRowEntry=ibmappnCosNodeRowEntry, ibmappnCosTgRowDelayMax=ibmappnCosTgRowDelayMax, ibmappcInSsStatusEntry=ibmappcInSsStatusEntry, ibmChipSetIBM=ibmChipSetIBM, ibmtbwinFiltOutOffset=ibmtbwinFiltOutOffset, ibmdot1dTpPort=ibmdot1dTpPort, cylinkOnesResponsibility=cylinkOnesResponsibility, ibmsnapFilterInNotForwarded=ibmsnapFilterInNotForwarded, ibmtbFiltOrderOutTable=ibmtbFiltOrderOutTable, ibmxnsFilterEntry=ibmxnsFilterEntry, cylinkLinkState=cylinkLinkState, ibmRIFFilterInIfIndex=ibmRIFFilterInIfIndex, ibmsnapFilterInType=ibmsnapFilterInType, ibmxnsAddrTable=ibmxnsAddrTable, ibmtbwinFiltOutIfIndex=ibmtbwinFiltOutIfIndex, ibmipFilterExtIfIndex=ibmipFilterExtIfIndex, ibmpppLinkVersion=ibmpppLinkVersion, ibmtbwinFiltOutNotForwarded=ibmtbwinFiltOutNotForwarded, ibmvIP=ibmvIP, ibmappnNodePortTrSap=ibmappnNodePortTrSap, ibmdot1dStaticAllowedToGoTo=ibmdot1dStaticAllowedToGoTo, ibmappnIsAcBufMedia=ibmappnIsAcBufMedia, ibmdlsLocalNameFilterSrcAddress=ibmdlsLocalNameFilterSrcAddress, ibmappnIsAcBtypePrdRecPerBuf=ibmappnIsAcBtypePrdRecPerBuf, ibmpppLinkLocalACCMap=ibmpppLinkLocalACCMap, ibmpppIPTable=ibmpppIPTable, ibmappcInSsRecvNxWndwSize=ibmappcInSsRecvNxWndwSize, ibmappnLocalEnTgCpCpSession=ibmappnLocalEnTgCpCpSession, ibmappnNnNodeFRName=ibmappnNnNodeFRName, ibmdlsStationDestAddress=ibmdlsStationDestAddress, cylinkSerialNumber=cylinkSerialNumber, ibmSubagents=ibmSubagents, ibmipFilterId=ibmipFilterId, ibmmacAddrFilterInDestAddress=ibmmacAddrFilterInDestAddress, ibmappnNnNodeFRQuiescing=ibmappnNnNodeFRQuiescing, ibmpppLCPInTRs=ibmpppLCPInTRs, ibmmacAddrFilterInEntry=ibmmacAddrFilterInEntry, ibmdec=ibmdec, ibmappnNodeLsRemoteDlsMac=ibmappnNodeLsRemoteDlsMac, ibmRIFFilterInfoEntry=ibmRIFFilterInfoEntry, ibmdlsStationRetransmitCount=ibmdlsStationRetransmitCount, ibmxnsidpOutNoRoutes=ibmxnsidpOutNoRoutes, ibmvICP=ibmvICP, ibmappcInLluTable=ibmappcInLluTable, ibmvPortCfgARP=ibmvPortCfgARP, ibmdlsVirtualRingSegmentNumber=ibmdlsVirtualRingSegmentNumber, ibmPtyQueueingQBR=ibmPtyQueueingQBR, ibmdlsCirLocalLinkInvalidPktRcv=ibmdlsCirLocalLinkInvalidPktRcv, ibmappcInRluParLuLocName=ibmappcInRluParLuLocName, ibmdlsCirLocalLinkTestCmdsSent=ibmdlsCirLocalLinkTestCmdsSent, ibmxnsidpBadSum=ibmxnsidpBadSum, ibmappnCosTgRowUsr3Min=ibmappnCosTgRowUsr3Min, ibmappnNodeLsStatusLsName=ibmappnNodeLsStatusLsName, cylinkStatusEntry=cylinkStatusEntry, ibmtbEthTypeFilters=ibmtbEthTypeFilters, ibmvRtGateNetid=ibmvRtGateNetid, ibmdlsRemoteFrameFilterEntry=ibmdlsRemoteFrameFilterEntry, ibmxnsFilterTable=ibmxnsFilterTable, ibmmacAddrFilterOutTable=ibmmacAddrFilterOutTable, ibmipFilterIfIndex=ibmipFilterIfIndex, ibmappnNodePortSIMRIM=ibmappnNodePortSIMRIM, ibmpppLinkLastInRxPackets=ibmpppLinkLastInRxPackets, swvpdVerId=swvpdVerId, ibmappnIsInTransPriority=ibmappnIsInTransPriority, ibmappnIsInRouteInfo=ibmappnIsInRouteInfo, ibmfrDlcmiPollingInterval=ibmfrDlcmiPollingInterval, ibmringFilterInIfIndex=ibmringFilterInIfIndex, ibmappnIsInPsRecvRpc=ibmappnIsInPsRecvRpc, ibmvRtCfgFltEntry=ibmvRtCfgFltEntry, ibmappnNodeLsStatusEndSense=ibmappnNodeLsStatusEndSense, ibmmacAddrFilterOutType=ibmmacAddrFilterOutType, ibmringFilterInFilterType=ibmringFilterInFilterType, ibmappnNodeLsEntry=ibmappnNodeLsEntry, ibmappnIsAcBtypeFullReason=ibmappnIsAcBtypeFullReason, ibmappcInMdFreeSessLst=ibmappcInMdFreeSessLst, ibmvFRPfragmented=ibmvFRPfragmented, ibmappnLocalEnTgOperational=ibmappnLocalEnTgOperational, ibmPtyQueueingEntry=ibmPtyQueueingEntry, cylinkDialoutHoldoff=cylinkDialoutHoldoff, ibmdot1dBaseType=ibmdot1dBaseType, ibmvipOutNoRoutes=ibmvipOutNoRoutes, ibmappnIsAcBufNewestIndex=ibmappnIsAcBufNewestIndex, ibmappnIsAcBtypeFullAction=ibmappnIsAcBtypeFullAction, ibmRIFFilterOutIfIndex=ibmRIFFilterOutIfIndex, ibmmacAddrFilterInSrcAddress=ibmmacAddrFilterInSrcAddress, ibmappnIsAcTimeAgtUtcSecs=ibmappnIsAcTimeAgtUtcSecs, ibmxnsidpOutRequests=ibmxnsidpOutRequests, ibmdot1dStpTopChanges=ibmdot1dStpTopChanges, ibmpppLinkMagicLoopCount=ibmpppLinkMagicLoopCount, ibmmacAddrFilterOutDestAddress=ibmmacAddrFilterOutDestAddress, ibmappcInLluCurActSess=ibmappcInLluCurActSess, ibmpppLinkInTxOctets=ibmpppLinkInTxOctets, ibmappnNodeLsStatusTgNum=ibmappnNodeLsStatusTgNum, ibmdot1dBaseNumPorts=ibmdot1dBaseNumPorts, ibmpppLinkQualityEntry=ibmpppLinkQualityEntry, ibmdecLANCircuitType=ibmdecLANCircuitType, ibmdlsRemoteNameFilterTable=ibmdlsRemoteNameFilterTable, ibmdlsLocalFrameFilterSrcAddress=ibmdlsLocalFrameFilterSrcAddress, ibmvARP=ibmvARP, ibmvipBadLens=ibmvipBadLens, ibmvipTotalIn=ibmvipTotalIn, ibmappnNnAdjNodeEntry=ibmappnNnAdjNodeEntry, ibmfrCircuitCreationTime=ibmfrCircuitCreationTime, ibmappnNnTopoTgBadHighRsns=ibmappnNnTopoTgBadHighRsns, ibmappnCosTgRowUsr1Min=ibmappnCosTgRowUsr1Min, ibmappnNnNodeFRIsrDepleted=ibmappnNnNodeFRIsrDepleted, ibmipxidpChecksum=ibmipxidpChecksum, ibmpppLinkPreviousState=ibmpppLinkPreviousState, ibmappnNodeNnTreeCache=ibmappnNodeNnTreeCache, ibmipxRouteDest=ibmipxRouteDest, ibmappnSnmpOutGenErrs=ibmappnSnmpOutGenErrs, ibmdot1dTpPortInFrames=ibmdot1dTpPortInFrames, ibmappnNnTopoTgGoodHighRsns=ibmappnNnTopoTgGoodHighRsns, ibmappcInSsTransPriority=ibmappcInSsTransPriority, ibmwindowFilterOutOffset=ibmwindowFilterOutOffset, ibmvrtpRedRecs=ibmvrtpRedRecs, ibmdlsStationPrimaryRepollCount=ibmdlsStationPrimaryRepollCount, ibmtbEthTypeFiltInFilterType=ibmtbEthTypeFiltInFilterType, ibmatportFilter=ibmatportFilter, ibmappnNnTgFRCpCpSession=ibmappnNnTgFRCpCpSession, ibmvrtpHeaderError=ibmvrtpHeaderError, ibmappnNnTgFRDestVirtual=ibmappnNnTgFRDestVirtual, ibmappnNodeCpName=ibmappnNodeCpName, ibmsysMBUFsDelayedRequests=ibmsysMBUFsDelayedRequests, ibmappnIsAcTimeMgrUtcHours=ibmappnIsAcTimeMgrUtcHours, ibmdot1dTpPortOutFrames=ibmdot1dTpPortOutFrames, ibmxnsConfigTable=ibmxnsConfigTable, ibmappnNodePortDlcTracUseWan=ibmappnNodePortDlcTracUseWan, ibmdot1dStpPortForwardTransitions=ibmdot1dStpPortForwardTransitions, ibmappnIsAcTimeAgtUtcHours=ibmappnIsAcTimeAgtUtcHours, ibmappnNodeLsDlsName=ibmappnNodeLsDlsName, ibmappnIsInSecLuName=ibmappnIsInSecLuName, ibmappnEnUniqueCaps=ibmappnEnUniqueCaps, ibmappnCosTgRowEffCapMin=ibmappnCosTgRowEffCapMin, ibmappnIsAcBtypeMaxBufs=ibmappnIsAcBtypeMaxBufs, ibmdlsStationPrimaryRepollThreshold=ibmdlsStationPrimaryRepollThreshold, ibmappnIsInSsSendMaxBtuSize=ibmappnIsInSsSendMaxBtuSize, ibmpppLinkACCompression=ibmpppLinkACCompression, ibmtbmacFiltInDestMask=ibmtbmacFiltInDestMask, ibmappcInMdMinCwinLimit=ibmappcInMdMinCwinLimit, ibmpppLinkChangeTime=ibmpppLinkChangeTime, ibmappnCosNodeRowMinCongestAllow=ibmappnCosNodeRowMinCongestAllow, ibmtbEthTypeFiltInfoTable=ibmtbEthTypeFiltInfoTable, ibmappnLocalTgDelay=ibmappnLocalTgDelay, ibmvRouting=ibmvRouting, ibmappcInSsRecvRpc=ibmappcInSsRecvRpc, ibmappnNnTgEntryTimeLeft=ibmappnNnTgEntryTimeLeft, ibmappnLocalEnTgSecurity=ibmappnLocalEnTgSecurity, ibmsnapFilterInEntry=ibmsnapFilterInEntry, ibmappnNodePortDlcType=ibmappnNodePortDlcType, ibmtbWindowFilters=ibmtbWindowFilters, ibmmacAddrFilterInTable=ibmmacAddrFilterInTable, ibmappnNnNodeFRFrsn=ibmappnNnNodeFRFrsn, ibmdls=ibmdls, ibmappnConversation=ibmappnConversation, ibmappcInLtpSecLvl=ibmappcInLtpSecLvl, ibmpppLCPInDiscReqs=ibmpppLCPInDiscReqs, ibmpppIPRejects=ibmpppIPRejects, ibmappnLocalEnTgModemClass=ibmappnLocalEnTgModemClass, ibmappcInRluActSessSecSup=ibmappcInRluActSessSecSup, ibmappnDirInBcastLocates=ibmappnDirInBcastLocates, ibmdlsDefaultNBDestName=ibmdlsDefaultNBDestName, ibmipxsapServerIfIndex=ibmipxsapServerIfIndex, ibmdot1dStpHoldTime=ibmdot1dStpHoldTime, ibmvFltMode=ibmvFltMode, ibmipxsapServerIndex=ibmipxsapServerIndex, ibmappnNodeLsRemoteTrSap=ibmappnNodeLsRemoteTrSap, ibmvRtCfgInFltMode=ibmvRtCfgInFltMode, ibmappnIsAcEntryType=ibmappnIsAcEntryType, ibmappcInSsStatusLocLuName=ibmappcInSsStatusLocLuName, ibmappcInRluDefType=ibmappcInRluDefType, ibmappnIsAcBufEntry=ibmappnIsAcBufEntry, ibmappnLocalTgRsn=ibmappnLocalTgRsn, ibmSelectNetNetEnd=ibmSelectNetNetEnd, ibmpppLinkControlTable=ibmpppLinkControlTable, ibmfrErrData=ibmfrErrData, ibmappcInGlobeActSess=ibmappcInGlobeActSess)
mibBuilder.exportSymbols("IBM6611-MIB", ibmpppLinkBadAddresses=ibmpppLinkBadAddresses, ibmdlsLocalFrameFilterEntry=ibmdlsLocalFrameFilterEntry, ibmvSysRtr=ibmvSysRtr, ibmipxFilterUse=ibmipxFilterUse, ibmappnNodeNnRcvRegChar=ibmappnNodeNnRcvRegChar, ibmappcInRluActAllVerSup=ibmappcInRluActAllVerSup, ibmappcInLtpPipSubNum=ibmappcInLtpPipSubNum, ibmvPortCfgTR=ibmvPortCfgTR, ibmappnSnmpInPkts=ibmappnSnmpInPkts, ibmappnSnmpInGetNextVars=ibmappnSnmpInGetNextVars, ibmappnNodeDynLsGoodXids=ibmappnNodeDynLsGoodXids, ibmipxRouteMetric=ibmipxRouteMetric, ibmappnNodeLsLimResource=ibmappnNodeLsLimResource, ibmdlsCirLocalLinkSubState=ibmdlsCirLocalLinkSubState, ibmsnapFilterInFilterType=ibmsnapFilterInFilterType, ibmtbsapFiltIn=ibmtbsapFiltIn, ibmfrDlcmiState=ibmfrDlcmiState, ibmappnNnTopoInTdus=ibmappnNnTopoInTdus, ibmdot1dStpPortPriority=ibmdot1dStpPortPriority, ibmipxsapServerHops=ibmipxsapServerHops, ibmappnNnTopoTgErrors=ibmappnNnTopoTgErrors, ibmwindowFilterOutBcastType=ibmwindowFilterOutBcastType, ibmappnNodeNnFrsn=ibmappnNodeNnFrsn, ibmxnsErrCongDiscard=ibmxnsErrCongDiscard, ibmipxAddrTable=ibmipxAddrTable, ibmappnNnTopoTgLowRsns=ibmappnNnTopoTgLowRsns, ibmsnapFilterOutIfIndex=ibmsnapFilterOutIfIndex, ibmappnNnTgFROwner=ibmappnNnTgFROwner, ibmpppLCPRejects=ibmpppLCPRejects, ibmappnNodeLsDlsEntry=ibmappnNodeLsDlsEntry, ibmappcInSsTable=ibmappcInSsTable, ibmappnCosTgRowUsr3Max=ibmappnCosTgRowUsr3Max, ibmvifEntry=ibmvifEntry, ibmappnIsAcBtypeTable=ibmappnIsAcBtypeTable, ibmdot1dStpDesignatedRoot=ibmdot1dStpDesignatedRoot, ibmipPtyQueueNumber=ibmipPtyQueueNumber, ibmappnNodeLsTable=ibmappnNodeLsTable, cylinkZeroProtection=cylinkZeroProtection, ibmringFilterOutMask=ibmringFilterOutMask, ibmxnsConfigEntry=ibmxnsConfigEntry, ibmxnsAddrAddress=ibmxnsAddrAddress, ibmappcInSsP2SNonFmdBytes=ibmappcInSsP2SNonFmdBytes, ibmappnIsInSessStartTime=ibmappnIsInSessStartTime, ibmipxsapServerEntry=ibmipxsapServerEntry, ibmappnIsAcModeName=ibmappnIsAcModeName, ibmRIFFilterOutBridgeMask=ibmRIFFilterOutBridgeMask, ibmSelectNetInterfaceNetStart=ibmSelectNetInterfaceNetStart, ibmxnsidpMcastInReceives=ibmxnsidpMcastInReceives, ibmappnNodeLsInXidFrames=ibmappnNodeLsInXidFrames, ibmappnIsAcBtypeFullWraps=ibmappnIsAcBtypeFullWraps, ibmappcInMdAcSyncLvl=ibmappcInMdAcSyncLvl, ibmappnNodeLsMaxSendBtuSize=ibmappnNodeLsMaxSendBtuSize, ibmappnLocalTgUsr2=ibmappnLocalTgUsr2, ibmappnNnNodeEntryTimeLeft=ibmappnNnNodeEntryTimeLeft, ibmtbmacFiltOutDestMask=ibmtbmacFiltOutDestMask, ibmmacAddrFilterIfIndex=ibmmacAddrFilterIfIndex, ibmappnNodeLsTgNum=ibmappnNodeLsTgNum, ibmfrErrType=ibmfrErrType, cylinkConfigIndex=cylinkConfigIndex, ibmdot1dStpMaxAge=ibmdot1dStpMaxAge, ibmFiltOrderOutTable=ibmFiltOrderOutTable, ibmvRouterName=ibmvRouterName, ibmappnNodePortPortType=ibmappnNodePortPortType, ibmvPortCfgEntry=ibmvPortCfgEntry, ibmappnNnTopoRouteRejs=ibmappnNnTopoRouteRejs, ibmtbmacFiltOutNotForwarded=ibmtbmacFiltOutNotForwarded, ibmappnIsAcS2PNonFmdBytes=ibmappnIsAcS2PNonFmdBytes, ibmipxidpOutDiscards=ibmipxidpOutDiscards, ibmappnNnTgFRUsr2=ibmappnNnTgFRUsr2, ibmappcInMdSendRuSzUpBnd=ibmappcInMdSendRuSzUpBnd, ibmxnsRouteTable=ibmxnsRouteTable, ibmappnNnTopoRouteTable=ibmappnNnTopoRouteTable, ibmappnSession=ibmappnSession, ibmxnsidpZeroDirBcast=ibmxnsidpZeroDirBcast, ibmdlsCirLocalLinkCmdRepollsSent=ibmdlsCirLocalLinkCmdRepollsSent, ibmappnSnmpInGetRequests=ibmappnSnmpInGetRequests, ibmappnNodePortSpecific=ibmappnNodePortSpecific, ibmdlsRemoteFrameFilterDestMask=ibmdlsRemoteFrameFilterDestMask, ibmpppIPInPackets=ibmpppIPInPackets, ibmatportFilterEntry=ibmatportFilterEntry, ibmappcInLtpRecoSup=ibmappcInLtpRecoSup, ibmtbFiltOrderInIfIndex=ibmtbFiltOrderInIfIndex, ibmMainProcessorLoad=ibmMainProcessorLoad, ibmwindowFilterOutFilterType=ibmwindowFilterOutFilterType, ibmappnNnNodeCentralDirectory=ibmappnNnNodeCentralDirectory, cylinkClockBackup=cylinkClockBackup, ibmnbpFilter=ibmnbpFilter, ibmxnsidpTooSmall=ibmxnsidpTooSmall, ibmvRtCfgFltTable=ibmvRtCfgFltTable, ibmappnCosTgRowEffCapMax=ibmappnCosTgRowEffCapMax, ibmProd=ibmProd, ibmappnLocalTgUsr1=ibmappnLocalTgUsr1, ibmappnIsAcRouteInfo=ibmappnIsAcRouteInfo, ibmdlsRemoteNameFilterDestAddress=ibmdlsRemoteNameFilterDestAddress, ibmappnIsAcGlobeMgrUtcYears=ibmappnIsAcGlobeMgrUtcYears, ibmappcInGlobeRscv=ibmappcInGlobeRscv, ibmringFilterIfIndex=ibmringFilterIfIndex, ibmipPtyQueueEnableEntry=ibmipPtyQueueEnableEntry, ibmappnLocalNnRouteAddResist=ibmappnLocalNnRouteAddResist, ibmappnIsAcBufTable=ibmappnIsAcBufTable, ibmtbwinFiltInNumBytes=ibmtbwinFiltInNumBytes, ibmvarpAssignResps=ibmvarpAssignResps, ibmappnNodePortDlsSap=ibmappnNodePortDlsSap, ibmvPortCfgServ=ibmvPortCfgServ, ibmappcInSsStatusUnbindType=ibmappcInSsStatusUnbindType, ibmpppLinkLastBadControl=ibmpppLinkLastBadControl, ibmappnLocalNodeType=ibmappnLocalNodeType, ibmappcInSsS2PNonFmdPius=ibmappcInSsS2PNonFmdPius, ibmvifInErrs=ibmvifInErrs, ibmappcInGlobal=ibmappcInGlobal, ibmappnNodeLsUsr3=ibmappnNodeLsUsr3, ibmdlsLocalNameFilterEntry=ibmdlsLocalNameFilterEntry, ibmappnIsAcBtypeRecFormat=ibmappnIsAcBtypeRecFormat, ibmappcInSsCosName=ibmappcInSsCosName, ibmRIFFilterOutEntry=ibmRIFFilterOutEntry, ibmappcInLtpPfAllocSer=ibmappcInLtpPfAllocSer, ibmatportFilterNetStart=ibmatportFilterNetStart, ibmappnNodeLsStatusRemoteAddr=ibmappnNodeLsStatusRemoteAddr, ibmappnNodeBlockNum=ibmappnNodeBlockNum, ibmappnDirLuOwnerName=ibmappnDirLuOwnerName, ibmappnNnTopoTgStateUpdates=ibmappnNnTopoTgStateUpdates, ibmvPortCfgTable=ibmvPortCfgTable, ibmdlsStationEntry=ibmdlsStationEntry, ibmappnSnmpInSetRequests=ibmappnSnmpInSetRequests, ibmipxidpInDiscards=ibmipxidpInDiscards)

#
# PySNMP MIB module IBM-6611-APPN-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/IBM-6611-APPN-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:50:44 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ValueRangeConstraint, SingleValueConstraint, ConstraintsIntersection, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsIntersection", "ValueSizeConstraint")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
ModuleIdentity, Gauge32, NotificationType, Integer32, IpAddress, Counter64, ObjectIdentity, Unsigned32, enterprises, Counter32, iso, TimeTicks, Bits, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn = mibBuilder.importSymbols("SNMPv2-SMI", "ModuleIdentity", "Gauge32", "NotificationType", "Integer32", "IpAddress", "Counter64", "ObjectIdentity", "Unsigned32", "enterprises", "Counter32", "iso", "TimeTicks", "Bits", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
ibm = MibIdentifier((1, 3, 6, 1, 4, 1, 2))
ibmProd = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6))
ibm6611 = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2))
ibmappn = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 13))
ibmappnNode = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1))
ibmappnGeneralInfoAndCaps = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 1))
ibmappnNnUniqueInfoAndCaps = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 2))
ibmappnEnUniqueCaps = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 3))
ibmappnPortInformation = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4))
ibmappnLinkStationInformation = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5))
ibmappnSnmpInformation = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 6))
ibmappnMemoryUse = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 7))
ibmappnXidInformation = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 8))
ibmappnNodeCpName = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeCpName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeCpName.setDescription('Administratively-assigned network name for this node in the format NETID.CPNAME.')
ibmappnNodeNetid = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeNetid.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeNetid.setDescription('Administratively-assigned APPN network identification, which can be from one to eight characters. This ID is used with the control point name to create a fully-qualified control point name.')
ibmappnNodeBlockNum = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 3)).setFixedLength(3)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeBlockNum.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeBlockNum.setDescription('The block number is the first three digits of the node_id. These 3 hexadecimal digits identify the product and are not configurable.')
ibmappnNodeIdNum = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(5, 5)).setFixedLength(5)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeIdNum.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeIdNum.setDescription('The ID number is the last 5 digits of the node_id. These 5 hexadecimal digits are administratively defined and combined with the 3 digit block number form the node_id. This node_id is used to identify the local node and is include in APPN alerts as well as being included in XIDs. A unique value is required for connections to SNA sub-area.')
ibmappnNodeType = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4))).clone(namedValues=NamedValues(("networkNode", 1), ("endNode", 2), ("len", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeType.setDescription('Type of APPN node, either network, len, or end node.')
ibmappnNodeUpTime = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 1, 6), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeUpTime.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeUpTime.setDescription('Time (in hundredths of a second) since this APPN node was initialized.')
ibmappnNodeNegotLs = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeNegotLs.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeNegotLs.setDescription('Indicates whether this node supports negotiable link stations.')
ibmappnNodeSegReasm = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeSegReasm.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeSegReasm.setDescription('Indicates whether this node supports segment reassembly. This is only supported when segment generation is also supported.')
ibmappnNodeBindReasm = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeBindReasm.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeBindReasm.setDescription('Indicates whether this node supports Bind segment reassembly. This will only be supported when Bind segment generation is also supported.')
ibmappnNodeParallelTg = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeParallelTg.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeParallelTg.setDescription('Indicates whether this node supports parallel TGs.')
ibmappnNodeService = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeService.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeService.setDescription('Indicates whether this node allows call-in from nodes not defined locally.')
ibmappnNodeAdaptiveBindPacing = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeAdaptiveBindPacing.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeAdaptiveBindPacing.setDescription('Indicates whether this node supports adaptive bind pacing.')
ibmappnNodeNnRcvRegChar = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeNnRcvRegChar.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeNnRcvRegChar.setDescription('Indicates whether this node supports receiving registered characteristics.')
ibmappnNodeNnGateway = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeNnGateway.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeNnGateway.setDescription('Indicates whether this is a gateway node.')
ibmappnNodeNnCentralDirectory = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeNnCentralDirectory.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeNnCentralDirectory.setDescription('Indicates whether this node supports central directory cache.')
ibmappnNodeNnTreeCache = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 2, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeNnTreeCache.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeNnTreeCache.setDescription('Indicates whether this node supports route tree cache.')
ibmappnNodeNnTreeUpdate = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 2, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeNnTreeUpdate.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeNnTreeUpdate.setDescription('Indicates whether this node supports incremental_tree_update, which is only supported when tree caching is supported.')
ibmappnNodeNnRouteAddResist = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 2, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeNnRouteAddResist.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeNnRouteAddResist.setDescription('Route addition resistance is a value that indicates the relative desirability of using this node for intermediate session traffic. The value, which can be any integer 0-255, is used in route computation. The lower the value, the more desirable the node is for intermediate routing.')
ibmappnNodeNnIsr = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 2, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeNnIsr.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeNnIsr.setDescription('Indicates whether the node supports intermediate session routing.')
ibmappnNodeNnFrsn = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 2, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeNnFrsn.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeNnFrsn.setDescription('Flow reduction sequence numbers (FRSNs) are associated with Topology Database Updates (TDUs) and are unique only within each APPN network node. A TDU can be associated with multiple APPN resources. This object is the last FRSN sent in a topology update to adjacent network nodes.')
ibmappnNodeEnSegGen = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeEnSegGen.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeEnSegGen.setDescription('Indicates whether this end node supports segment generation.')
ibmappnNodeEnModeCosMap = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 3, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeEnModeCosMap.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeEnModeCosMap.setDescription('Indicates whether this end node supports mode name to COS name mapping.')
ibmappnNodeEnLocateCdinit = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 3, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeEnLocateCdinit.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeEnLocateCdinit.setDescription('Indicates whether this end node supports Locate Cdinit.')
ibmappnNodeEnSendRegNames = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 3, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeEnSendRegNames.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeEnSendRegNames.setDescription('Indicates whether the node will register its LUs with the adjacent serving network node: NO - do not register names YES - register names')
ibmappnNodeEnSendRegChar = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 3, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeEnSendRegChar.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeEnSendRegChar.setDescription('Indicates whether this node supports send register characteristics, which is only supported when send registered names is also supported.')
ibmappnNodePortTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4, 1), )
if mibBuilder.loadTexts: ibmappnNodePortTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodePortTable.setDescription('The Port table describes the configuration and current status of the ports used by APPN. The type of DLC is included in this table as a pointer to the DLC port specific tables.')
ibmappnNodePortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4, 1, 1), ).setIndexNames((0, "IBM-6611-APPN-MIB", "ibmappnNodePortName"))
if mibBuilder.loadTexts: ibmappnNodePortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodePortEntry.setDescription('The Port Name is used as the index to this table.')
ibmappnNodePortName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodePortName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodePortName.setDescription('Administratively-assigned name for this APPN port. The name can be from one to eight characters.')
ibmappnNodePortState = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("inactive", 1), ("pendactive", 2), ("active", 3), ("pendinact", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmappnNodePortState.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodePortState.setDescription('Indicates the current state of this port.')
ibmappnNodePortDlcType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("sdlc", 2), ("dls", 3), ("socket", 4), ("ethernet", 5), ("tokenRing", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodePortDlcType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodePortDlcType.setDescription("The type of DLC interface, distinguished according to the protocol immediately 'below' this layer.")
ibmappnNodePortPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("leased", 1), ("switched", 2), ("sharedAccessFacilities", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodePortPortType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodePortPortType.setDescription('Identifies the type of line used by this port.')
ibmappnNodePortSIMRIM = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodePortSIMRIM.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodePortSIMRIM.setDescription('Indicates whether Set Initialization Mode (SIM) and Receive Initialization Mode (RIM) are supported.')
ibmappnNodePortLsRole = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("primary", 1), ("secondary", 2), ("negotiable", 3), ("abm", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodePortLsRole.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodePortLsRole.setDescription("Initial role for LSs activated through this port, where 'abm' indicates asynchronous balance mode.")
ibmappnNodePortMaxRcvBtuSize = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodePortMaxRcvBtuSize.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodePortMaxRcvBtuSize.setDescription('Maximum Basic Transmission Size (BTU) that a link station on this port can receive.')
ibmappnNodePortMaxIframeWindow = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodePortMaxIframeWindow.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodePortMaxIframeWindow.setDescription('Maximum number of I-frames that can be received by the XID sender before an acknowledgement is received.')
ibmappnNodePortDefLsGoodXids = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodePortDefLsGoodXids.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodePortDefLsGoodXids.setDescription('The total number of successfull XIDs that have occurred on all defined link stations on this port since the last time this port was started.')
ibmappnNodePortDefLsBadXids = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodePortDefLsBadXids.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodePortDefLsBadXids.setDescription('The total number of unsuccessfull XIDs that have occurred on all defined link stations on this port since the last time this port was started.')
ibmappnNodePortDynLsGoodXids = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodePortDynLsGoodXids.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodePortDynLsGoodXids.setDescription('The total number of successfull XIDs that have occurred on all dynamic link stations on this port since the last time this port was started.')
ibmappnNodePortDynLsBadXids = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodePortDynLsBadXids.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodePortDynLsBadXids.setDescription('The total number of unsuccessfull XIDs that have occurred on all dynamic link stations on this port since the last time this port was started.')
ibmappnNodePortSpecific = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4, 1, 1, 13), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodePortSpecific.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodePortSpecific.setDescription('Identifies the port specific OBJECT IDENTIFIER that can provide additional information.')
ibmappnNodePortIpTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4, 2), )
if mibBuilder.loadTexts: ibmappnNodePortIpTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodePortIpTable.setDescription('Port table (TCP/IP specific).')
ibmappnNodePortIpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4, 2, 1), ).setIndexNames((0, "IBM-6611-APPN-MIB", "ibmappnNodePortIpName"))
if mibBuilder.loadTexts: ibmappnNodePortIpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodePortIpEntry.setDescription('The IP Name is used as the index to this table.')
ibmappnNodePortIpName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4, 2, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodePortIpName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodePortIpName.setDescription('Administratively-assigned name for this APPN port. The name can be from one to eight characters.')
ibmappnNodePortIpPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodePortIpPortNum.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodePortIpPortNum.setDescription('Local TCP/IP port number.')
ibmappnNodePortDlsTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4, 3), )
if mibBuilder.loadTexts: ibmappnNodePortDlsTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodePortDlsTable.setDescription('Port table (DLS specific).')
ibmappnNodePortDlsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4, 3, 1), ).setIndexNames((0, "IBM-6611-APPN-MIB", "ibmappnNodePortDlsName"))
if mibBuilder.loadTexts: ibmappnNodePortDlsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodePortDlsEntry.setDescription('The DLS Name is used as the index to this table.')
ibmappnNodePortDlsName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4, 3, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodePortDlsName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodePortDlsName.setDescription('Administratively-assigned name for this APPN DLS port. The name can be from one to eight characters.')
ibmappnNodePortDlsMac = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4, 3, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodePortDlsMac.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodePortDlsMac.setDescription('Local DLS MAC address.')
ibmappnNodePortDlsSap = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4, 3, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodePortDlsSap.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodePortDlsSap.setDescription('Local DLS Sap address.')
ibmappnNodePortTrTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4, 4), )
if mibBuilder.loadTexts: ibmappnNodePortTrTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodePortTrTable.setDescription('Port table (Token Ring specific).')
ibmappnNodePortTrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4, 4, 1), ).setIndexNames((0, "IBM-6611-APPN-MIB", "ibmappnNodePortTrName"))
if mibBuilder.loadTexts: ibmappnNodePortTrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodePortTrEntry.setDescription('The TR Name is used as the index to this table.')
ibmappnNodePortTrName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4, 4, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodePortTrName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodePortTrName.setDescription('Administratively-assigned name for this APPN port. The name can be from one to eight characters.')
ibmappnNodePortTrMac = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4, 4, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodePortTrMac.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodePortTrMac.setDescription('Local Token Ring MAC address.')
ibmappnNodePortTrSap = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4, 4, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodePortTrSap.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodePortTrSap.setDescription('Local Token Ring Sap address.')
ibmappnNodePortDlcTraceTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4, 5), )
if mibBuilder.loadTexts: ibmappnNodePortDlcTraceTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodePortDlcTraceTable.setDescription('Port table generic DLC trace table.')
ibmappnNodePortDlcTraceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4, 5, 1), ).setIndexNames((0, "IBM-6611-APPN-MIB", "ibmappnNodePortDlcTracPortName"), (0, "IBM-6611-APPN-MIB", "ibmappnNodePortDlcTracIndex"))
if mibBuilder.loadTexts: ibmappnNodePortDlcTraceEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodePortDlcTraceEntry.setDescription('The Port name and a dynamic integer are the index to this table.')
ibmappnNodePortDlcTracPortName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4, 5, 1, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodePortDlcTracPortName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodePortDlcTracPortName.setDescription('The Port name associated with this this trace table entry.')
ibmappnNodePortDlcTracIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4, 5, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodePortDlcTracIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodePortDlcTracIndex.setDescription('This index value is updated every time a new trace entry is created which provides a means to retrieve only the updated entries and also provides a simple method of correlating the entries. The table will wrap when the table is full, which will result in previous entries being written over. The mangement station can over come this by retrieving the table using this index to retrieve only the new table entries.')
ibmappnNodePortDlcTracDlcType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("sdlc", 2), ("dls", 3), ("socket", 4), ("ethernet", 5), ("tokenRing", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodePortDlcTracDlcType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodePortDlcTracDlcType.setDescription("The type of DLC interface, distinguished according to the protocol immediately 'below' this layer.")
ibmappnNodePortDlcTracLocalAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4, 5, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodePortDlcTracLocalAddr.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodePortDlcTracLocalAddr.setDescription('Local address in format described below: other = free form DisplayString ip = ld. ld. ld. ld / 2d tr = lx: lx: lx: lx: lx: lx . lx dlsw = lx: lx: lx: lx: lx: lx . lx ethernet = lx: lx: lx: lx: lx: lx . lx ')
ibmappnNodePortDlcTracRemoteAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4, 5, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodePortDlcTracRemoteAddr.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodePortDlcTracRemoteAddr.setDescription('Remote Address in the format described below: other = free form DisplayString ip = ld. ld. ld. ld / 2d tr = lx: lx: lx: lx: lx: lx . lx dlsw = lx: lx: lx: lx: lx: lx . lx ethernet = lx: lx: lx: lx: lx: lx . lx ')
ibmappnNodePortDlcTracMsgType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4, 5, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("unknown", 2), ("request", 3), ("confirm", 4), ("indication", 5), ("response", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodePortDlcTracMsgType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodePortDlcTracMsgType.setDescription('Indicates the type of trace record entry')
ibmappnNodePortDlcTracCmdType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4, 5, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2024, 2025, 2026, 4124, 6001, 6002, 6003, 6004, 6005, 6006, 6007, 6008, 6009, 6010, 6012, 6013, 6014, 6015, 6016, 6017, 6018, 6019, 6020, 6021, 6022, 6023, 6024, 6025, 6026))).clone(namedValues=NamedValues(("testFrame", 1), ("respFrame", 2), ("curFrame", 3), ("icrFrame", 4), ("respAck", 5), ("dgrmFrame", 6), ("xidFrame", 7), ("contFrame", 8), ("contedFrame", 9), ("iFrame", 10), ("enterBusy", 12), ("exitBusy", 13), ("haltFrame", 14), ("lsHalted", 15), ("restartLs", 16), ("lsRestarted", 17), ("netBioSnq", 18), ("netBioSnr", 19), ("gnetFrame", 20), ("netdFrame", 21), ("oobFrame", 22), ("alterSap", 23), ("testRsp", 24), ("haltLsNow", 25), ("testReq", 26), ("ipTestFrame", 2001), ("ipRespFrame", 2002), ("ipCurFrame", 2003), ("ipIcrFrame", 2004), ("ipRespAck", 2005), ("ipDgrmFrame", 2006), ("ipXidFrame", 2007), ("ipContFrame", 2008), ("ipContedFrame", 2009), ("ipIFrame", 2010), ("ipEnterBusy", 2012), ("ipExitBusy", 2013), ("ipHaltFrame", 2014), ("ipLsHalted", 2015), ("ipRestartLs", 2016), ("ipLsRestarted", 2017), ("ipNetBioSnq", 2018), ("ipNetBioSnr", 2019), ("ipGnetFrame", 2020), ("ipNetdFrame", 2021), ("ipOobFrame", 2022), ("ipAlterSap", 2023), ("ipTestRsp", 2024), ("ipHaltLsNow", 2025), ("ipTestReq", 2026), ("dlsIpm", 4124), ("trTestFrame", 6001), ("trRespFrame", 6002), ("trCurFrame", 6003), ("trIcrFrame", 6004), ("trRespAck", 6005), ("trDgrmFrame", 6006), ("trXidFrame", 6007), ("trContFrame", 6008), ("trContedFrame", 6009), ("trIFrame", 6010), ("trEnterBusy", 6012), ("trExitBusy", 6013), ("trHaltFrame", 6014), ("trLsHalted", 6015), ("trRestartLs", 6016), ("trLsRestarted", 6017), ("trNetBioSnq", 6018), ("trNetBioSnr", 6019), ("trGnetFrame", 6020), ("trNetdFrame", 6021), ("trOobFrame", 6022), ("trAlterSap", 6023), ("trTestRsp", 6024), ("trHaltLsNow", 6025), ("trTestReq", 6026)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodePortDlcTracCmdType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodePortDlcTracCmdType.setDescription('Indicates the command type of the trace entry.')
ibmappnNodePortDlcTracUseWan = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 4, 5, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("notApplicable", 2), ("useUnknown", 3), ("useWan", 4), ("useLan", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodePortDlcTracUseWan.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodePortDlcTracUseWan.setDescription('Indicates the type of connection of the trace entry. For example, token ring and ethernet ports will have useLan as connection. For the dls port, it could be either useWan if connection is across Wan via dls sessions, or useLan if connection is to a local attached LAN.')
ibmappnNodeLsTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1), )
if mibBuilder.loadTexts: ibmappnNodeLsTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsTable.setDescription('This table contains detail information about the link station configuration and current status.')
ibmappnNodeLsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1), ).setIndexNames((0, "IBM-6611-APPN-MIB", "ibmappnNodeLsName"))
if mibBuilder.loadTexts: ibmappnNodeLsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsEntry.setDescription('This table is indexed by the link station name.')
ibmappnNodeLsName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsName.setDescription('Administratively-assigned name for the link station. The name can be from one to eight characters.')
ibmappnNodeLsPortName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsPortName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsPortName.setDescription('Administratively-assigned name for the port. The name can be from one to eight characters.')
ibmappnNodeLsDlcType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("sdlc", 2), ("dls", 3), ("socket", 4), ("ethernet", 5), ("tokenRing", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsDlcType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsDlcType.setDescription("The type of DLC interface, distinguished according to the protocol immediately 'below' this layer.")
ibmappnNodeLsDynamic = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsDynamic.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsDynamic.setDescription('Identifies whether this resource is a dynamic link station. Dynamic link stations are created when adjacent nodes that have not been locally defined establish a connection with this node.')
ibmappnNodeLsState = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("inactive", 1), ("pendactive", 2), ("active", 3), ("pendinact", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmappnNodeLsState.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsState.setDescription('State of this link station.')
ibmappnNodeLsCpName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsCpName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsCpName.setDescription('Fully-qualified name of the adjacent node for this link station. The name can be from three to seventeen characters. Format is netid.cpname.')
ibmappnNodeLsTgNum = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsTgNum.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsTgNum.setDescription('Number associated with the TG to this link station.')
ibmappnNodeLsLimResource = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsLimResource.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsLimResource.setDescription('Indicates whether the link station is a limited resource. If it is, the TG is deactivated when there are no sessions.')
ibmappnNodeLsMigration = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsMigration.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsMigration.setDescription('Indicates whether this link station will be used for connections to down-level or migration partners.')
ibmappnNodeLsBlockNum = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 3)).setFixedLength(3)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsBlockNum.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsBlockNum.setDescription('The block number is the first three digits of the node_id. These 3 hexideimal digits identify the product and are not configurable.')
ibmappnNodeLsIdNum = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(5, 5)).setFixedLength(5)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsIdNum.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsIdNum.setDescription('The ID number is the last 5 digits of the node_id. These 5 hexadecimal digits are administratively defined and combined with the 3 digit block number form the node_id. This node_id is used to identify the local node and is include in APPN alerts as well as being included in XIDs. A unique value is required for connections to SNA sub-area.')
ibmappnNodeLsCpCpSession = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsCpCpSession.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsCpCpSession.setDescription('Indicates whether CP-CP sessions are supported by this link station.')
ibmappnNodeLsTargetPacingCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsTargetPacingCount.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsTargetPacingCount.setDescription('Numeric value between 0 and 32767 inclusive indicating the desired pacing window size for BINDs on this TG. The number is significant only when fixed bind pacing is being performed.')
ibmappnNodeLsMaxSendBtuSize = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsMaxSendBtuSize.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsMaxSendBtuSize.setDescription('Numeric value between 0 and 32767 inclusive indicating the desired number of bytes in a Basic Transmission Unit (BTU) that can be sent on this TG. This is an administratively assigned value.')
ibmappnNodeLsEffCap = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsEffCap.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsEffCap.setDescription('The effective capacity is an integer value that indicates the kilo bits per second. It is derived from the link bandwidth and maximum load factor with the range of 0 thru 603,979,776. This is an administratively assigned value associated with the TG using this link station.')
ibmappnNodeLsConnCost = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsConnCost.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsConnCost.setDescription('Cost per connect time: a value representing the relative cost per unit of time to use the TG. Range is from 0, which means no cost, to 255, which indicates maximum cost. This is an administratively assigned value associated with the TG using this link station.')
ibmappnNodeLsByteCost = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsByteCost.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsByteCost.setDescription('Relative cost of transmitting a byte over this link. Range is from 0 (lowest cost) to 255. This is an administratively assigned value associated with the TG using this link station.')
ibmappnNodeLsSecurity = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 32, 64, 96, 128, 160, 192))).clone(namedValues=NamedValues(("nonsecure", 1), ("publicSwitchedNetwork", 32), ("undergroundCable", 64), ("secureConduit", 96), ("guardedConduit", 128), ("encrypted", 160), ("guardedRadiation", 192)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsSecurity.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsSecurity.setDescription('The security is represented as an integer with a range of 1 thru 255 with the most common values enumerated as defined above. This is an administratively assigned value associated with the TG using this link station.')
ibmappnNodeLsDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 384, 9216, 147456, 294912, 2013265920))).clone(namedValues=NamedValues(("minimum", 0), ("negligible", 384), ("terrestrial", 9216), ("packet", 147456), ("long", 294912), ("maximum", 2013265920)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsDelay.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsDelay.setDescription('Relative amount of time that it takes for a signal to travel the length of the logical link. This time is represented in micro seconds, with some of the more common values enumerated. This is an administratively assigned value associated with the TG using this link station.')
ibmappnNodeLsUsr1 = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsUsr1.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsUsr1.setDescription('First user-defined TG characteristic for this TG with a range of 0-255. This is an administratively assigned value associated with the TG using this link station.')
ibmappnNodeLsUsr2 = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsUsr2.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsUsr2.setDescription('Second user-defined TG characteristic for this TG with a range of 0-255. This is an administratively assigned value associated with the TG using this link station.')
ibmappnNodeLsUsr3 = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsUsr3.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsUsr3.setDescription('Third user-defined TG characteristic for this TG with a range of 0-255. This is an administratively assigned value associated with the TG using this link station.')
ibmappnNodeLsInXidBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsInXidBytes.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsInXidBytes.setDescription('Number of XID bytes received.')
ibmappnNodeLsInMsgBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsInMsgBytes.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsInMsgBytes.setDescription('Number of message (I-frame) bytes received.')
ibmappnNodeLsInXidFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsInXidFrames.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsInXidFrames.setDescription('Number of XID frames received.')
ibmappnNodeLsInMsgFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsInMsgFrames.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsInMsgFrames.setDescription('Number of message (I-frame) frames received.')
ibmappnNodeLsOutXidBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsOutXidBytes.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsOutXidBytes.setDescription('Number of XID bytes sent.')
ibmappnNodeLsOutMsgBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsOutMsgBytes.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsOutMsgBytes.setDescription('Number of message (I-frame) bytes sent.')
ibmappnNodeLsOutXidFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsOutXidFrames.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsOutXidFrames.setDescription('Number of XID frames sent.')
ibmappnNodeLsOutMsgFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsOutMsgFrames.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsOutMsgFrames.setDescription('Number of message (I-frame) frames sent.')
ibmappnNodeLsEchoRsps = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsEchoRsps.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsEchoRsps.setDescription('Number of responses returned from adjacent link station. A response should be returned for each test frame sent by this node. Test frames are sent to adjacent nodes periodically to verify connectivity and to measure that actual round trip time, that is the time the test frame is sent until the response is received.')
ibmappnNodeLsCurrentDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 32), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsCurrentDelay.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsCurrentDelay.setDescription('The time that it took for the last test signal to be sent and returned from this link station to the adjacent links station. This time is represented in milliseconds.')
ibmappnNodeLsMaxDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 33), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsMaxDelay.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsMaxDelay.setDescription('The longest time it took for a test signal to be sent and returned from this link station to the adjacent links station. This time is represented in milliseconds .')
ibmappnNodeLsMinDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 34), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsMinDelay.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsMinDelay.setDescription('The shortest time it took for a test signal to be sent and returned from this link station to the adjacent links station. This time is represented in milliseconds.')
ibmappnNodeLsMaxDelayTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 35), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsMaxDelayTime.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsMaxDelayTime.setDescription('The time (since system up in hundredth of seconds) when the longest delay occurred. This time can be used to identify when this high water mark occurred in relation to the last initialization of the APPN node.')
ibmappnNodeLsGoodXids = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 36), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsGoodXids.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsGoodXids.setDescription('The total number of successful XIDs that have occurred on this link station since the time it was started.')
ibmappnNodeLsBadXids = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 37), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsBadXids.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsBadXids.setDescription('The total number of unsuccessful XIDs that have occurred on this link station since the time it was started.')
ibmappnNodeLsSpecific = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 38), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsSpecific.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsSpecific.setDescription('Identifies the DLC specific OBJECT IDENTIFIER that can provide additional information.')
ibmappnNodeLsSubState = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 39), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))).clone(namedValues=NamedValues(("inactive", 1), ("sentReqOpnstn", 2), ("pendXidExch", 3), ("sentActAs", 4), ("sentSetMode", 5), ("active", 6), ("sentDeactAsOrd", 7), ("sentDiscOrd", 8), ("sentDestroyTg", 9), ("sentCreateTg", 10), ("sentConnReq", 11), ("pendRcvConnInd", 12), ("pendSendConnRsp", 13), ("sentConnRsp", 14), ("pendDeact", 15)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsSubState.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsSubState.setDescription('State of this link station.')
ibmappnNodeLsStartTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 40), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsStartTime.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsStartTime.setDescription('The time (in hundredth of seconds) this link station has been active the last time since the time APPN was initialized.')
ibmappnNodeLsActiveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 41), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsActiveTime.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsActiveTime.setDescription('The time (in hundredth of seconds) this link station has been in the active state. A zero value indicates the link station has never been active.')
ibmappnNodeLsCurrentStateTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 1, 1, 42), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsCurrentStateTime.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsCurrentStateTime.setDescription('The time (in hundredth of seconds) the link station is in the current state.')
ibmappnNodeLsIpTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 2), )
if mibBuilder.loadTexts: ibmappnNodeLsIpTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsIpTable.setDescription('Link station table (TCP/IP specific).')
ibmappnNodeLsIpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 2, 1), ).setIndexNames((0, "IBM-6611-APPN-MIB", "ibmappnNodeLsIpName"))
if mibBuilder.loadTexts: ibmappnNodeLsIpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsIpEntry.setDescription('The IP Name is used as the index to this table.')
ibmappnNodeLsIpName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 2, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsIpName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsIpName.setDescription('Administratively-assigned name for this link station. The name can be from one to eight characters.')
ibmappnNodeLsIpState = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("inactive", 1), ("pendactive", 2), ("active", 3), ("pendinact", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsIpState.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsIpState.setDescription('State of this link station.')
ibmappnNodeLsLocalIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 2, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsLocalIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsLocalIpAddr.setDescription('Local IP address.')
ibmappnNodeLsLocalIpPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsLocalIpPortNum.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsLocalIpPortNum.setDescription('Local TCP/IP port number. The default listening port will be administratively assigned and will dynamically change if this node initiates a session with adjacent node.')
ibmappnNodeLsRemoteIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 2, 1, 5), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsRemoteIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsRemoteIpAddr.setDescription('Remote IP address.')
ibmappnNodeLsRemoteIpPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsRemoteIpPortNum.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsRemoteIpPortNum.setDescription('Remote TCP/IP port number.')
ibmappnNodeLsDlsTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 3), )
if mibBuilder.loadTexts: ibmappnNodeLsDlsTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsDlsTable.setDescription('Ls Table (DLS specific).')
ibmappnNodeLsDlsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 3, 1), ).setIndexNames((0, "IBM-6611-APPN-MIB", "ibmappnNodeLsDlsName"))
if mibBuilder.loadTexts: ibmappnNodeLsDlsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsDlsEntry.setDescription('The DLS Name is used as the index to this table.')
ibmappnNodeLsDlsName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 3, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsDlsName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsDlsName.setDescription('Administratively-assigned name for this link station. The name can be from one to eight characters.')
ibmappnNodeLsDlsState = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("inactive", 1), ("pendactive", 2), ("active", 3), ("pendinact", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsDlsState.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsDlsState.setDescription('State of this link station.')
ibmappnNodeLsLocalDlsMac = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 3, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsLocalDlsMac.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsLocalDlsMac.setDescription('Local MAC address.')
ibmappnNodeLsLocalDlsSap = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 3, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsLocalDlsSap.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsLocalDlsSap.setDescription('Local SAP address.')
ibmappnNodeLsRemoteDlsMac = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 3, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsRemoteDlsMac.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsRemoteDlsMac.setDescription('Remote MAC address.')
ibmappnNodeLsRemoteDlsSap = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 3, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsRemoteDlsSap.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsRemoteDlsSap.setDescription('Remote SAP address.')
ibmappnNodeLsTrTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 4), )
if mibBuilder.loadTexts: ibmappnNodeLsTrTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsTrTable.setDescription('Ls Table (Token Ring specific).')
ibmappnNodeLsTrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 4, 1), ).setIndexNames((0, "IBM-6611-APPN-MIB", "ibmappnNodeLsTrName"))
if mibBuilder.loadTexts: ibmappnNodeLsTrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsTrEntry.setDescription('The TR Name is used as the index to this table.')
ibmappnNodeLsTrName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 4, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsTrName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsTrName.setDescription('Administratively-assigned name for this link station. The name can be from one to eight characters.')
ibmappnNodeLsTrState = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("inactive", 1), ("pendactive", 2), ("active", 3), ("pendinact", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsTrState.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsTrState.setDescription('State of this link station.')
ibmappnNodeLsLocalTrMac = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 4, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsLocalTrMac.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsLocalTrMac.setDescription('Local MAC address.')
ibmappnNodeLsLocalTrSap = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 4, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsLocalTrSap.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsLocalTrSap.setDescription('Local SAP address.')
ibmappnNodeLsRemoteTrMac = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 4, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsRemoteTrMac.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsRemoteTrMac.setDescription('Remote MAC address.')
ibmappnNodeLsRemoteTrSap = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 4, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsRemoteTrSap.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsRemoteTrSap.setDescription('Remote SAP address.')
ibmappnNodeLsStatusTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 5), )
if mibBuilder.loadTexts: ibmappnNodeLsStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsStatusTable.setDescription('This table contains information related to exceptional and potential exceptional conditions that occur during the activation, XID exchange, and termination of the connection.')
ibmappnNodeLsStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 5, 1), ).setIndexNames((0, "IBM-6611-APPN-MIB", "ibmappnNodeLsStatusIndex"))
if mibBuilder.loadTexts: ibmappnNodeLsStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsStatusEntry.setDescription('This table is indexed by the LsStatusIndex, which is an integer that is continuously updated until it eventually wraps. This provides the management station the ability to retrieve only the updates to the table by using the standard GET NEXT.')
ibmappnNodeLsStatusIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsStatusIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsStatusIndex.setDescription('This index is continuous index this table.')
ibmappnNodeLsStatusTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 5, 1, 2), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsStatusTime.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsStatusTime.setDescription('Time (in hundreds of a second) since this node was last initialized.')
ibmappnNodeLsStatusLsName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 5, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsStatusLsName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsStatusLsName.setDescription('Administratively-assigned name for this link station.')
ibmappnNodeLsStatusCpName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 5, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsStatusCpName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsStatusCpName.setDescription('Administratively-assigned fully-qualified name of the adjacent node partner. This will be provided when the adjacent node has been defined at this node or when the XID sequence has proceeded far enough to to identify the adjacent node. A blank CP name will indicate the name is unknown.')
ibmappnNodeLsStatusNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 5, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsStatusNodeId.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsStatusNodeId.setDescription('Adjacent Node id')
ibmappnNodeLsStatusTgNum = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 5, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsStatusTgNum.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsStatusTgNum.setDescription('Number associated with the TG to this link station with a range from 0 to 256. A value of 256 indicates the tg number has not been negotiated and is unknown at this time.')
ibmappnNodeLsStatusGeneralSense = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 5, 1, 7), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsStatusGeneralSense.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsStatusGeneralSense.setDescription('The error sense code associated with the start sequence of activation of a link up to the beginning of the XID sequence.')
ibmappnNodeLsStatusNofRetry = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 5, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("retry", 1), ("noretry", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsStatusNofRetry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsStatusNofRetry.setDescription('Indicates whether Node Operator Facility will retry the start request to activate the link.')
ibmappnNodeLsStatusEndSense = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 5, 1, 9), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsStatusEndSense.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsStatusEndSense.setDescription('The sense code associated with the termination of the link connection to adjacent node. This includes all sense information included in the disconnect recieved from the lower layer DLCs and also sense information indicating the link termination originated by upper layer APPN components.')
ibmappnNodeLsStatusXidLocalSense = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 5, 1, 10), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsStatusXidLocalSense.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsStatusXidLocalSense.setDescription('The error sense code associated with the rejection of the XID.')
ibmappnNodeLsStatusXidRemoteSense = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 5, 1, 11), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsStatusXidRemoteSense.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsStatusXidRemoteSense.setDescription('The error sense code adjacent node returned to this node indicating the reason the XID was rejected.')
ibmappnNodeLsStatusXidByteInError = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 5, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1000))).clone(namedValues=NamedValues(("na", 1000)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsStatusXidByteInError.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsStatusXidByteInError.setDescription('This identifies the actual byte in the XID that caused the error. The value of zero (0) indicates that the variable has no meaning.')
ibmappnNodeLsStatusXidBitInError = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 5, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(8))).clone(namedValues=NamedValues(("na", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsStatusXidBitInError.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsStatusXidBitInError.setDescription('This identifies the actual bit within the error byte of the XID. This only has meaning when the byte in error is greater than zero.')
ibmappnNodeLsStatusDlcType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 5, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("sdlc", 2), ("dls", 3), ("socket", 4), ("ethernet", 5), ("tr", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsStatusDlcType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsStatusDlcType.setDescription('This identifies DLC type that was being used when error occurred. This also is used to the format of the local and remote address provided. other = free form DisplayString ip = ld. ld. ld. ld / 2d tr = lx: lx: lx: lx: lx: lx . lx dlsw = lx: lx: lx: lx: lx: lx . lx ethernet = lx: lx: lx: lx: lx: lx . lx ')
ibmappnNodeLsStatusLocalAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 5, 1, 15), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsStatusLocalAddr.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsStatusLocalAddr.setDescription('This contains a displayable string that identifies the DLC type and appropriate address. See DlcType above for details of the format.')
ibmappnNodeLsStatusRemoteAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 5, 5, 1, 16), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeLsStatusRemoteAddr.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeLsStatusRemoteAddr.setDescription('This contains a displayable string that identifies the DLC type and appropriate address. See DlcType above for details of the format.')
ibmappnSnmpInPkts = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 6, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnSnmpInPkts.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnSnmpInPkts.setDescription('Total number of messages delivered to the APPN SNMP sub-agent.')
ibmappnSnmpInGetRequests = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 6, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnSnmpInGetRequests.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnSnmpInGetRequests.setDescription('Total number of GET requests delivered to the APPN SNMP sub-agent.')
ibmappnSnmpInGetNexts = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 6, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnSnmpInGetNexts.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnSnmpInGetNexts.setDescription('Total number of GETNEXT requests delivered to the APPN SNMP sub-agent.')
ibmappnSnmpInSetRequests = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 6, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnSnmpInSetRequests.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnSnmpInSetRequests.setDescription('Total number of SET requests delivered to the APPN SNMP sub-agent.')
ibmappnSnmpInTotalVars = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 6, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnSnmpInTotalVars.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnSnmpInTotalVars.setDescription('Total number of VARIABLES included in both GET and GETNEXT requests to the APPN SNMP sub-agent.')
ibmappnSnmpInGetVars = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 6, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnSnmpInGetVars.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnSnmpInGetVars.setDescription('Total number of VARIBLES included in all GET requests to the APPN SNMP sub-agent.')
ibmappnSnmpInGetNextVars = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 6, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnSnmpInGetNextVars.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnSnmpInGetNextVars.setDescription('Total number of VARIABLES included in all GETNEXT requests to the APPN SNMP sub-agent.')
ibmappnSnmpInSetVars = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 6, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnSnmpInSetVars.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnSnmpInSetVars.setDescription('Total number of VARIBLES included in all SET requests to the APPN SNMP sub-agent.')
ibmappnSnmpOutNoSuchNames = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 6, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnSnmpOutNoSuchNames.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnSnmpOutNoSuchNames.setDescription('Total number of VARIABLES that could not be found by the APPN SNMP sub-agent.')
ibmappnSnmpOutGenErrs = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 6, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnSnmpOutGenErrs.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnSnmpOutGenErrs.setDescription('Total number of undefined errors that occurred processing SNMP request to the APPN SNMP sub-agent.')
ibmappnMemorySize = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 7, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnMemorySize.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnMemorySize.setDescription('Size of the shared storage segment, as obtained by storage management from the underlying operating system.')
ibmappnMemoryUsed = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 7, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnMemoryUsed.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnMemoryUsed.setDescription('Number of bytes in the segment that are currently allocated to process.')
ibmappnMemoryWarnThresh = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 7, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnMemoryWarnThresh.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnMemoryWarnThresh.setDescription('Allocation threshold beyond which storage management considers the storage resources to be constrained.')
ibmappnMemoryCritThresh = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 7, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnMemoryCritThresh.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnMemoryCritThresh.setDescription('Allocation threshold beyond which storage management considers the storage resources to be critically constrained.')
ibmappnNodeDefLsGoodXids = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 8, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeDefLsGoodXids.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeDefLsGoodXids.setDescription('The current number of successfull XIDs that have occurred on all defined link stations since the last time this node was initialized.')
ibmappnNodeDefLsBadXids = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 8, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeDefLsBadXids.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeDefLsBadXids.setDescription('The current number of unsuccessfull XIDs that have occurred on all defined link stations since the last time this node was initialized.')
ibmappnNodeDynLsGoodXids = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 8, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeDynLsGoodXids.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeDynLsGoodXids.setDescription('The current number of successfull XIDs that have occurred on all dynamic link stations since the last time this node was initialized.')
ibmappnNodeDynLsBadXids = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 1, 8, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNodeDynLsBadXids.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNodeDynLsBadXids.setDescription('The current number of unsuccessfull XIDs that have occurred on all dynamic link stations since the last time this node was initialized.')
ibmappnNn = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2))
ibmappnNnTopo = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 1))
ibmappnNnTopology = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3))
ibmappnNnTopoMaxNodes = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTopoMaxNodes.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTopoMaxNodes.setDescription('Maximum number of nodes allowed in the APPN topology database. This administratively assigned value must be equal to or greater than the maximum total number of end nodes and network nodes. If the number of nodes exceeds this value, APPN will issue an Alert and the node can no longer participate as a network node.')
ibmappnNnTopoCurNumNodes = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTopoCurNumNodes.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTopoCurNumNodes.setDescription("Current number of nodes in this node's topology database. If this value exceeds the maximum number of nodes allowed (NnTopoMaxNodes), APPN alert CPDB002 is issued.")
ibmappnNnTopoInTdus = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTopoInTdus.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTopoInTdus.setDescription('Total number of TDUs received from all adjacent NN since last initialization.')
ibmappnNnTopoOutTdus = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTopoOutTdus.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTopoOutTdus.setDescription('Total number of TDUs built by this node to be sent to all adjacent NN since last initialization.')
ibmappnNnTopoNodeLowRsns = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTopoNodeLowRsns.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTopoNodeLowRsns.setDescription("Total number of topology node updates received by this node with a RSN less than the current RSN. Both even and odd RSN are included in this count. These TDUs are not errors, but result when TDUs are broadcast to all adjacent network nodes. No update to this node's topology database occurs, but this node will send a TDU with it's higher RSN to the adjacent node that sent this low RSN.")
ibmappnNnTopoNodeEqualRsns = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTopoNodeEqualRsns.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTopoNodeEqualRsns.setDescription("Total number of topology node updates received by this node with a RSN equal to the current RSN. Both even and odd RSN are included in this count. These TDUs are not errors, but result when TDUs are broadcast to all adjacent network nodes. No update to this node's topology database occurs.")
ibmappnNnTopoNodeGoodHighRsns = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTopoNodeGoodHighRsns.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTopoNodeGoodHighRsns.setDescription('Total number of topology node updates received by this node with a RSN greater than the current RSN. This results in updating this nodes topology and broadcasting a TDU to all adjacent network nodes. It is not required to send a TDU to the sender of this update because that node already has the update.')
ibmappnNnTopoNodeBadHighRsns = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTopoNodeBadHighRsns.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTopoNodeBadHighRsns.setDescription('Total number of topology node updates received by this node with an odd RSN greater than the current RSN. These updates represent a topology inconsistency detected by one of the APPN network nodes. This results in updating this nodes topology and broadcasting a TDU to all adjacent network nodes.')
ibmappnNnTopoNodeStateUpdates = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTopoNodeStateUpdates.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTopoNodeStateUpdates.setDescription('Total number of topology Node records built as a result of internally detected node state changes that affect APPN topology and routing. Updates are sent via TDUs to all adjacent network nodes.')
ibmappnNnTopoNodeErrors = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTopoNodeErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTopoNodeErrors.setDescription('Total number of topology node records inconsistencies detected by this node. This occurs when this node attempts to update its topology database and detects a data inconsistency. This node will create a TDU with the current RSN incremented to the next odd number and broadcast it to all adjacent NNs.')
ibmappnNnTopoNodeTimerUpdates = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTopoNodeTimerUpdates.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTopoNodeTimerUpdates.setDescription("Total number of topology node records built for this node's resource due to timer updates. Updates are sent via TDUs to all adjacent network nodes. These updates insure other network nodes do not delete this node's resources from their topology database.")
ibmappnNnTopoNodePurges = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTopoNodePurges.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTopoNodePurges.setDescription("Total number of topology node records purged from this node's topology database. This occurs when a node has not been updated in a specified amount of time. The owning node is responsible for broadcasting updates for its resource that it wants kept in the network topology.")
ibmappnNnTopoTgLowRsns = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTopoTgLowRsns.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTopoTgLowRsns.setDescription("Total number of topology TG updates received by this node with a RSN less than the current RSN. Both even and odd RSN are included in this count. These TDUs are not errors, but result when TDUs are broadcast to all adjacent network nodes. No update to this node's topology database occurs, but this node will send a TDU with it's higher RSN to the sender of the low RSN.")
ibmappnNnTopoTgEqualRsns = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTopoTgEqualRsns.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTopoTgEqualRsns.setDescription("Total number of topology TG updates received by this node with a RSN equal to the current RSN. Both even and odd RSN are included in this count. These TDUs are not errors, but result when TDUs are broadcast to all adjacent network nodes. No update to this node's topology database occurs.")
ibmappnNnTopoTgGoodHighRsns = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTopoTgGoodHighRsns.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTopoTgGoodHighRsns.setDescription('Total number of topology TG updates received by this node with a RSN greater than the current RSN. This results in updating this nodes topology and broadcasting the update to all adjacent network nodes.')
ibmappnNnTopoTgBadHighRsns = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTopoTgBadHighRsns.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTopoTgBadHighRsns.setDescription('Total number of topology TG updates received by this node with an odd RSN greater than the current RSN. These updates represent a topology inconsistency detected by one of the APPN network nodes. This results in updating this nodes topology and broadcasting a TDU to all adjacent network nodes.')
ibmappnNnTopoTgStateUpdates = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTopoTgStateUpdates.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTopoTgStateUpdates.setDescription('Total number of topology TG records built as a result of internally detected node state changes that affect APPN topology and routing. Updates are sent via TDUs to all adjacent network nodes.')
ibmappnNnTopoTgErrors = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTopoTgErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTopoTgErrors.setDescription('Total number of topology TG records inconsistencies detected by this node. This occurs when this node attempts to update its topology database and detects a data inconsistency. This node will create a TDU with the current RSN incremented to the next odd number and broadcast it to all adjacent NNs.')
ibmappnNnTopoTgTimerUpdates = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTopoTgTimerUpdates.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTopoTgTimerUpdates.setDescription("Total number of topology TG records built for this node's resource due to timer updates. Updates are sent via TDUs to all adjacent network nodes. These updates insure other network nodes do not delete this node's resources from their topology database.")
ibmappnNnTopoTgPurges = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTopoTgPurges.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTopoTgPurges.setDescription("Total number of topology TG records purged from this node's topology database. This occurs when a TG has not been updated in a specified amount of time. The owning node is responsible for broadcasting updates for its resource that it wants to keep in the network topology.")
ibmappnNnTopoTotalRouteCalcs = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTopoTotalRouteCalcs.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTopoTotalRouteCalcs.setDescription('Number of routes calculated for all class of services since the last initialization.')
ibmappnNnTopoTotalRouteRejs = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTopoTotalRouteRejs.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTopoTotalRouteRejs.setDescription('Number of route requests for all class of services that could not be calculated since last initialization.')
ibmappnNnTopoRouteTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 1, 23), )
if mibBuilder.loadTexts: ibmappnNnTopoRouteTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTopoRouteTable.setDescription('Table containing an entry for every Class of Service that it has calculated a route for.')
ibmappnNnTopoRouteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 1, 23, 1), ).setIndexNames((0, "IBM-6611-APPN-MIB", "ibmappnNnTopoRouteCos"))
if mibBuilder.loadTexts: ibmappnNnTopoRouteEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTopoRouteEntry.setDescription('The Class of Service name is the index for this table.')
ibmappnNnTopoRouteCos = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 1, 23, 1, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTopoRouteCos.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTopoRouteCos.setDescription('The Class of Service for the route.')
ibmappnNnTopoRouteTrees = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 1, 23, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTopoRouteTrees.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTopoRouteTrees.setDescription('Number of routes tree caches built for this Class of Service since the last initialization.')
ibmappnNnTopoRouteCalcs = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 1, 23, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTopoRouteCalcs.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTopoRouteCalcs.setDescription('Number of routes calculated since last initialization.')
ibmappnNnTopoRouteRejs = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 1, 23, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTopoRouteRejs.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTopoRouteRejs.setDescription('Number of route requests that could not be calculated since last initialization.')
ibmappnNnAdjNodeTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 2), )
if mibBuilder.loadTexts: ibmappnNnAdjNodeTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnAdjNodeTable.setDescription('Table containing an entry for every node. The information kept in this table is the last FRSN sent and received, the status of the CP-CP sessions, and a gauge that indicates the number of outstanding TDUs.')
ibmappnNnAdjNodeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 2, 1), ).setIndexNames((0, "IBM-6611-APPN-MIB", "ibmappnNnAdjNodeAdjName"))
if mibBuilder.loadTexts: ibmappnNnAdjNodeEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnAdjNodeEntry.setDescription('The adjacent node name is the index for this table.')
ibmappnNnAdjNodeAdjName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 2, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnAdjNodeAdjName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnAdjNodeAdjName.setDescription("An administratively-assigned fully-qualified name of this node's adjacent network node.")
ibmappnNnAdjNodeCpCpSessStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("active", 1), ("conLoserActive", 2), ("conWinnerActive", 3), ("inactive", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnAdjNodeCpCpSessStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnAdjNodeCpCpSessStatus.setDescription('Indicates the state of CP-CP sessions between this node and adjacent network and end nodes. Incative indicates no CP-CP sessions exists between this node and the adjacent node. Active indicates CP-CP sessons are active using both the ConWinner and ConLoser sessions. The session initiated by this node is refered to as the ConWinner session and is used by this node to send to the adjacent node. The ConLoserr session is initiated by the adjacent node and is used by this node to receive from the adjacent node.')
ibmappnNnAdjNodeOutOfSeqTdus = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 2, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnAdjNodeOutOfSeqTdus.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnAdjNodeOutOfSeqTdus.setDescription('Number of out of sequence Topology Database Updates (TDUs). In a quiesced state, this value is zero. In normal operation, the value varies depending on the network environment.')
ibmappnNnAdjNodeLastFrsnSent = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnAdjNodeLastFrsnSent.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnAdjNodeLastFrsnSent.setDescription('Flow reduction sequence numbers (FRSNs) are associated with Topology Database Updates (TDUs) and are unique only within each APPN network node. A TDU can be associated with multiple APPN resources. This FRSN indicates the last TDU sent to this adjacent node.')
ibmappnNnAdjNodeLastFrsnRcvd = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnAdjNodeLastFrsnRcvd.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnAdjNodeLastFrsnRcvd.setDescription('Flow reduction sequence numbers (FRSNs) are associated with Topology Database Updates (TDUs) and are unique only within each APPN network node. A TDU can be associated with multiple APPN resources. This FRSN indicates the last TDU received from this adjacent node.')
ibmappnNnTopologyTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 1), )
if mibBuilder.loadTexts: ibmappnNnTopologyTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTopologyTable.setDescription('Portion of the APPN routing table that describes all of the APPN network nodes and virtual nodes known to this node.')
ibmappnNnTopologyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 1, 1), ).setIndexNames((0, "IBM-6611-APPN-MIB", "ibmappnNnNodeName"))
if mibBuilder.loadTexts: ibmappnNnTopologyEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTopologyEntry.setDescription('The fully-qualified node name is used to index this table.')
ibmappnNnNodeName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnNodeName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnNodeName.setDescription('Administratively-assigned network name that is locally defined at each network node in the format NETID.CPNAME.')
ibmappnNnNodeFrsn = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnNodeFrsn.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnNodeFrsn.setDescription('Flow reduction sequence numbers (FRSNs) are associated with Topology Database Updates (TDUs) and are unique only within each APPN network node. A TDU can be associated with multiple APPN resources. This FRSN indicates the last time this resource was updated at this node.')
ibmappnNnNodeEntryTimeLeft = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnNodeEntryTimeLeft.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnNodeEntryTimeLeft.setDescription('Number of days before deletion of this network node entry. Range is 0-31.')
ibmappnNnNodeType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3))).clone(namedValues=NamedValues(("networknode", 1), ("virtualnode", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnNodeType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnNodeType.setDescription('Type of APPN node.')
ibmappnNnNodeRsn = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnNodeRsn.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnNodeRsn.setDescription('Resource sequence number that is assigned and controlled by the network node that owns this resource. This is always an even 32-bit number unless an error has occurred.')
ibmappnNnNodeRouteAddResist = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnNodeRouteAddResist.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnNodeRouteAddResist.setDescription('Route addition resistance indicates the relative desirability of using this node for intermediate session traffic. The value, which can be any integer 0-255, is used in route computation. The lower the value, the more desirable the node is for intermediate routing.')
ibmappnNnNodeCongested = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnNodeCongested.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnNodeCongested.setDescription('Indicates whether this node is congested. This node is not be included in route selection by other nodes when this congestion exists.')
ibmappnNnNodeIsrDepleted = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnNodeIsrDepleted.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnNodeIsrDepleted.setDescription('Indicates whether intermediate session routing resources are depleted. This node is not included in intermediate route selection by other nodes when resources are depleted.')
ibmappnNnNodeEndptDepleted = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnNodeEndptDepleted.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnNodeEndptDepleted.setDescription('Indicates whether session endpoint resources are depleted.')
ibmappnNnNodeQuiescing = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnNodeQuiescing.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnNodeQuiescing.setDescription('Indicates whether the node is quiescing. This node is not included in route selection by other nodes when the node is quiescing.')
ibmappnNnNodeGateway = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnNodeGateway.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnNodeGateway.setDescription('Indicates whether the node provide gateway functions.')
ibmappnNnNodeCentralDirectory = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnNodeCentralDirectory.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnNodeCentralDirectory.setDescription('Indicates whether the node is central directory.')
ibmappnNnNodeIsr = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnNodeIsr.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnNodeIsr.setDescription('Indicates whether the node supports intermediate session routing (ISR).')
ibmappnNnNodeChainSupport = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnNodeChainSupport.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnNodeChainSupport.setDescription('Indicates whether the node supports chaining.')
ibmappnNnTgTopologyTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 2), )
if mibBuilder.loadTexts: ibmappnNnTgTopologyTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgTopologyTable.setDescription('Portion of the APPN topology database that describes all of the APPN transmissions groups used by the APPN network nodes.')
ibmappnNnTgTopologyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 2, 1), ).setIndexNames((0, "IBM-6611-APPN-MIB", "ibmappnNnTgOwner"), (0, "IBM-6611-APPN-MIB", "ibmappnNnTgDest"), (0, "IBM-6611-APPN-MIB", "ibmappnNnTgNum"))
if mibBuilder.loadTexts: ibmappnNnTgTopologyEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgTopologyEntry.setDescription('This table requires three indexes to provide a unique index. The indexes are the owning or originating CPname, the destination CPname, and the TG number.')
ibmappnNnTgOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 2, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgOwner.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgOwner.setDescription('Administratively-assigned name for the originating node for this TG. The format is NETID.CPNAME and is the same name specified in the node table.')
ibmappnNnTgDest = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgDest.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgDest.setDescription('Administratively-assigned fully-qualified network name for the destination node for this TG.')
ibmappnNnTgNum = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgNum.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgNum.setDescription('Number associated with this transmission group. Range is 0-255.')
ibmappnNnTgFrsn = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgFrsn.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgFrsn.setDescription('Flow reduction sequence numbers (FRSNs) are associated with Topology Database Updates (TDUs) and are unique only within each APPN network node. A TDU can be associated with multiple APPN resources. This FRSN indicates the last time this resource was updated at this node.')
ibmappnNnTgEntryTimeLeft = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgEntryTimeLeft.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgEntryTimeLeft.setDescription('Number of days before deletion of this network node TG entry. Range is 0-31.')
ibmappnNnTgDestVirtual = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgDestVirtual.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgDestVirtual.setDescription('Indicates whether the destination node is a virtual node.')
ibmappnNnTgDlcData = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 2, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 9))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgDlcData.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgDlcData.setDescription('DLC specific data related to the link connection network. Token-Ring - MAC/SAP X.25 Switched - dial digits X.21 Switched - dial digits Circuit Swtch - dial digits')
ibmappnNnTgRsn = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 2, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgRsn.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgRsn.setDescription("Current owning node's resource sequence number for this resource.")
ibmappnNnTgOperational = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgOperational.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgOperational.setDescription('Indicates whether the transmission group is operational.')
ibmappnNnTgQuiescing = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgQuiescing.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgQuiescing.setDescription('Indicates whether the transmission group is quiescing.')
ibmappnNnTgCpCpSession = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgCpCpSession.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgCpCpSession.setDescription('Indicates whether CP-CP sessions are supported on this TG.')
ibmappnNnTgEffCap = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 2, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgEffCap.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgEffCap.setDescription('The effective capacity is an integer value that indicates the kilo bits per second. It is derived from the link bandwidth and maximum load factor with the range of 0 thru 603,979,776. This is an administratively assigned value associated with this TG.')
ibmappnNnTgConnCost = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 2, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgConnCost.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgConnCost.setDescription('Cost per connect time: a value representing the relative cost per unit of time to use the TG. Range is from 0, which means no cost, to 255, which indicates maximum cost. This is an administratively assigned value associated with this TG.')
ibmappnNnTgByteCost = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 2, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgByteCost.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgByteCost.setDescription('Relative cost of transmitting a byte over this link. Range is from 0 (lowest cost) to 255. This is an administratively assigned value associated with this TG.')
ibmappnNnTgSecurity = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 2, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 32, 64, 96, 128, 160, 192))).clone(namedValues=NamedValues(("nonsecure", 1), ("publicSwitchedNetwork", 32), ("undergroundCable", 64), ("secureConduit", 96), ("guardedConduit", 128), ("encrypted", 160), ("guardedRadiation", 192)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgSecurity.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgSecurity.setDescription('The security is represented as an integer with a range of 1 thru 255 with the most common values enumerated as defined above. This is an administratively assigned value associated with this TG.')
ibmappnNnTgDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 2, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 384, 9216, 147456, 294912, 2013265920))).clone(namedValues=NamedValues(("minimum", 0), ("negligible", 384), ("terrestrial", 9216), ("packet", 147456), ("long", 294912), ("maximum", 2013265920)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgDelay.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgDelay.setDescription('Relative amount of time that it takes for a signal to travel the length of the logical link. This time is represented in micro seconds, with some of the more common values enumerated. This is an administratively assigned value associated with this TG.')
ibmappnNnTgModemClass = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 2, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgModemClass.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgModemClass.setDescription("This is used to have multiple images for a connection network. For a connection network it is the same as in the TG vector; for a non-connection network it is X'00'.")
ibmappnNnTgUsr1 = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 2, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgUsr1.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgUsr1.setDescription('First user-defined TG characteristic for this TG with a range of 0-255. This is an administratively assigned value associated with this TG.')
ibmappnNnTgUsr2 = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 2, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgUsr2.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgUsr2.setDescription('Second user-defined TG characteristic for this TG with a range of 0-255. This is an administratively assigned value associated with this TG.')
ibmappnNnTgUsr3 = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 2, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgUsr3.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgUsr3.setDescription('Third user-defined TG characteristic for this TG with a range of 0-255. This is an administratively assigned value associated with this TG.')
ibmappnNnTopologyFRTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 3), )
if mibBuilder.loadTexts: ibmappnNnTopologyFRTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTopologyFRTable.setDescription('Portion of the APPN routing table that describes all of the APPN network nodes and virtual nodes known to this node.')
ibmappnNnTopologyFREntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 3, 1), ).setIndexNames((0, "IBM-6611-APPN-MIB", "ibmappnNnNodeFRFrsn"), (0, "IBM-6611-APPN-MIB", "ibmappnNnNodeFRName"))
if mibBuilder.loadTexts: ibmappnNnTopologyFREntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTopologyFREntry.setDescription('This table is indexed by two columns: FRSN, followed by fully-qualified node name.')
ibmappnNnNodeFRName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 3, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnNodeFRName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnNodeFRName.setDescription('Administratively-assigned network name that is locally defined at each network node in the format NETID.CPNAME.')
ibmappnNnNodeFRFrsn = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnNodeFRFrsn.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnNodeFRFrsn.setDescription('Flow reduction sequence numbers (FRSNs) are associated with Topology Database Updates (TDUs) and are unique only within each APPN network node. A TDU can be associated with multiple APPN resources. This FRSN indicates the last time this resource was updated at this node.')
ibmappnNnNodeFREntryTimeLeft = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnNodeFREntryTimeLeft.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnNodeFREntryTimeLeft.setDescription('Number of days before deletion of this network node entry. Range is 0-31.')
ibmappnNnNodeFRType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3))).clone(namedValues=NamedValues(("networknode", 1), ("virtualnode", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnNodeFRType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnNodeFRType.setDescription('Type of APPN node.')
ibmappnNnNodeFRRsn = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 3, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnNodeFRRsn.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnNodeFRRsn.setDescription('Resource sequence number that is assigned and controlled by the network node that owns this resource. This is always an even 32-bit number unless an error has occurred.')
ibmappnNnNodeFRRouteAddResist = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 3, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnNodeFRRouteAddResist.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnNodeFRRouteAddResist.setDescription('Route addition resistance indicates the relative desirability of using this node for intermediate session traffic. The value, which can be any integer 0-255, is used in route computation. The lower the value, the more desirable the node is for intermediate routing.')
ibmappnNnNodeFRCongested = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnNodeFRCongested.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnNodeFRCongested.setDescription('Indicates whether this node is congested. This node is not be included in route selection by other nodes when this congestion exists.')
ibmappnNnNodeFRIsrDepleted = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnNodeFRIsrDepleted.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnNodeFRIsrDepleted.setDescription('Indicates whether intermediate session routing resources are depleted. This node is not included in intermediate route selection by other nodes when resources are depleted.')
ibmappnNnNodeFREndptDepleted = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 3, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnNodeFREndptDepleted.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnNodeFREndptDepleted.setDescription('Indicates whether session endpoint resources are depleted.')
ibmappnNnNodeFRQuiescing = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 3, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnNodeFRQuiescing.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnNodeFRQuiescing.setDescription('Indicates whether the node is quiescing. This node is not included in route selection by other nodes when the node is quiescing.')
ibmappnNnNodeFRGateway = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 3, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnNodeFRGateway.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnNodeFRGateway.setDescription('Indicates whether the node provide gateway functions.')
ibmappnNnNodeFRCentralDirectory = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 3, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnNodeFRCentralDirectory.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnNodeFRCentralDirectory.setDescription('Indicates whether the node is central directory.')
ibmappnNnNodeFRIsr = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 3, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnNodeFRIsr.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnNodeFRIsr.setDescription('Indicates whether the node supports intermediate session routing (ISR).')
ibmappnNnNodeFRChainSupport = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 3, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnNodeFRChainSupport.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnNodeFRChainSupport.setDescription('Indicates whether the node supports chaining.')
ibmappnNnTgTopologyFRTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 4), )
if mibBuilder.loadTexts: ibmappnNnTgTopologyFRTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgTopologyFRTable.setDescription('Portion of the APPN topology database that describes all of the APPN transmissions groups used by the APPN network nodes.')
ibmappnNnTgTopologyFREntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 4, 1), ).setIndexNames((0, "IBM-6611-APPN-MIB", "ibmappnNnTgFRFrsn"), (0, "IBM-6611-APPN-MIB", "ibmappnNnTgFROwner"), (0, "IBM-6611-APPN-MIB", "ibmappnNnTgFRDest"), (0, "IBM-6611-APPN-MIB", "ibmappnNnTgFRNum"))
if mibBuilder.loadTexts: ibmappnNnTgTopologyFREntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgTopologyFREntry.setDescription('This table is indexed by four columns: FRSN, TG owner fully-qualified node name, TG destination fully-qualified node name, and TG number.')
ibmappnNnTgFROwner = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 4, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgFROwner.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgFROwner.setDescription('Administratively-assigned name for the originating node for this TG. The format is NETID.CPNAME and is the same name specified in the node table.')
ibmappnNnTgFRDest = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 4, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgFRDest.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgFRDest.setDescription('Administratively-assigned fully-qualified network name for the destination node for this TG.')
ibmappnNnTgFRNum = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgFRNum.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgFRNum.setDescription('Number associated with this transmission group. Range is 0-255.')
ibmappnNnTgFRFrsn = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgFRFrsn.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgFRFrsn.setDescription('Flow reduction sequence numbers (FRSNs) are associated with Topology Database Updates (TDUs) and are unique only within each APPN network node. A TDU can be associated with multiple APPN resources. This FRSN indicates the last time this resource was updated at this node.')
ibmappnNnTgFREntryTimeLeft = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 4, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgFREntryTimeLeft.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgFREntryTimeLeft.setDescription('Number of days before deletion of this network node TG entry. Range is 0-31.')
ibmappnNnTgFRDestVirtual = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 4, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgFRDestVirtual.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgFRDestVirtual.setDescription('Indicates whether the destination node is a virtual node.')
ibmappnNnTgFRDlcData = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 4, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 9))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgFRDlcData.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgFRDlcData.setDescription('DLC specific data related to the link connection network. Token-Ring - MAC/SAP X.25 Switched - dial digits X.21 Switched - dial digits Circuit Swtch - dial digits')
ibmappnNnTgFRRsn = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 4, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgFRRsn.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgFRRsn.setDescription("Current owning node's resource sequence number for this resource.")
ibmappnNnTgFROperational = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 4, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgFROperational.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgFROperational.setDescription('Indicates whether the transmission group is operational.')
ibmappnNnTgFRQuiescing = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 4, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgFRQuiescing.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgFRQuiescing.setDescription('Indicates whether the transmission group is quiescing.')
ibmappnNnTgFRCpCpSession = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 4, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgFRCpCpSession.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgFRCpCpSession.setDescription('Indicates whether CP-CP sessions are supported on this TG.')
ibmappnNnTgFREffCap = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 4, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgFREffCap.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgFREffCap.setDescription('The effective capacity is an integer value that indicates the kilo bits per second. It is derived from the link bandwidth and maximum load factor with the range of 0 thru 603,979,776. This is an administratively assigned value associated with this TG.')
ibmappnNnTgFRConnCost = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 4, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgFRConnCost.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgFRConnCost.setDescription('Cost per connect time: a value representing the relative cost per unit of time to use the TG. Range is from 0, which means no cost, to 255, which indicates maximum cost. This is an administratively assigned value associated with this TG.')
ibmappnNnTgFRByteCost = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 4, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgFRByteCost.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgFRByteCost.setDescription('Relative cost of transmitting a byte over this link. Range is from 0 (lowest cost) to 255. This is an administratively assigned value associated with this TG.')
ibmappnNnTgFRSecurity = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 4, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 32, 64, 96, 128, 160, 192))).clone(namedValues=NamedValues(("nonsecure", 1), ("publicSwitchedNetwork", 32), ("undergroundCable", 64), ("secureConduit", 96), ("guardedConduit", 128), ("encrypted", 160), ("guardedRadiation", 192)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgFRSecurity.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgFRSecurity.setDescription('The security is represented as an integer with a range of 1 thru 255 with the most common values enumerated as defined above. This is an administratively assigned value associated with this TG.')
ibmappnNnTgFRDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 4, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 384, 9216, 147456, 294912, 2013265920))).clone(namedValues=NamedValues(("minimum", 0), ("negligible", 384), ("terrestrial", 9216), ("packet", 147456), ("long", 294912), ("maximum", 2013265920)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgFRDelay.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgFRDelay.setDescription('Relative amount of time that it takes for a signal to travel the length of the logical link. This time is represented in micro seconds, with some of the more common values enumerated. This is an administratively assigned value associated with this TG.')
ibmappnNnTgFRModemClass = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 4, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgFRModemClass.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgFRModemClass.setDescription("This is used to have multiple images for a connection network. For a connection network it is the same as in the TG vector; for a non-connection network it is X'00'.")
ibmappnNnTgFRUsr1 = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 4, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgFRUsr1.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgFRUsr1.setDescription('First user-defined TG characteristic for this TG with a range of 0-255. This is an administratively assigned value associated with this TG.')
ibmappnNnTgFRUsr2 = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 4, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgFRUsr2.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgFRUsr2.setDescription('Second user-defined TG characteristic for this TG with a range of 0-255. This is an administratively assigned value associated with this TG.')
ibmappnNnTgFRUsr3 = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 2, 3, 4, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnNnTgFRUsr3.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnNnTgFRUsr3.setDescription('Third user-defined TG characteristic for this TG with a range of 0-255. This is an administratively assigned value associated with this TG.')
ibmappnLocalTopology = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3))
ibmappnLocalThisNode = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 1))
ibmappnLocalGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 1, 1))
ibmappnLocalNnSpecific = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 1, 2))
ibmappnLocalTg = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 1, 3))
ibmappnLocalEnTopology = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 2))
ibmappnLocalNodeName = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalNodeName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalNodeName.setDescription('Administratively-assigned fully-qualified name for this node. Format is NETID.CPNAME.')
ibmappnLocalNodeType = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4))).clone(namedValues=NamedValues(("networknode", 1), ("endnode", 2), ("len", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalNodeType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalNodeType.setDescription('Type of APPN node.')
ibmappnLocalNnRsn = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 1, 2, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalNnRsn.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalNnRsn.setDescription('Resource sequence number is assigned and controlled by the network node that owns this resource. This is always an even unsigned number unless an error has occurred.')
ibmappnLocalNnRouteAddResist = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 1, 2, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalNnRouteAddResist.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalNnRouteAddResist.setDescription('Route addition resistance indicates the relative desirability of using this node for intermediate session traffic. The value, which can be any integer 0-255, is used in route computation. The lower the value, the more desirable the node is for intermediate routing.')
ibmappnLocalNnCongested = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 1, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalNnCongested.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalNnCongested.setDescription('Indicates whether this node is congested. Other network nodes stop routing traffic to this node while this flag is on.')
ibmappnLocalNnIsrDepleted = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 1, 2, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalNnIsrDepleted.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalNnIsrDepleted.setDescription('Indicate whether intermediated session routing resources are depleted. Other network nodes stop routing traffic through this node while this flag is on.')
ibmappnLocalNnEndptDepleted = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 1, 2, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalNnEndptDepleted.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalNnEndptDepleted.setDescription('Indicates whether session endpoint resources are depleted.')
ibmappnLocalNnQuiescing = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 1, 2, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalNnQuiescing.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalNnQuiescing.setDescription('Indicates whether the node is quiescing.')
ibmappnLocalNnGateway = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 1, 2, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalNnGateway.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalNnGateway.setDescription('Indicates whether the node is a gateway.')
ibmappnLocalNnCentralDirectory = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 1, 2, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalNnCentralDirectory.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalNnCentralDirectory.setDescription('Indicates whether the node is a central directory.')
ibmappnLocalNnIsr = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 1, 2, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalNnIsr.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalNnIsr.setDescription('Indicates whether the node supports intermediate session routing.')
ibmappnLocalNnChainSupport = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 1, 2, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalNnChainSupport.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalNnChainSupport.setDescription('Indicates whether the node supports chaining.')
ibmappnLocalNnFrsn = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 1, 2, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalNnFrsn.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalNnFrsn.setDescription('Flow reduction sequence numbers (FRSNs) are associated with Topology Database Updates (TDUs) and are unique only within each APPN network node. A TDU can be associated with multiple APPN resources. This object is the last FRSN sent in a topology update to adjacent network nodes.')
ibmappnLocalTgTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 1, 3, 1), )
if mibBuilder.loadTexts: ibmappnLocalTgTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalTgTable.setDescription('TG Table describes all of the TGs owned by this node. The TG destination can be a virtual node, network node, len, or end node.')
ibmappnLocalTgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 1, 3, 1, 1), ).setIndexNames((0, "IBM-6611-APPN-MIB", "ibmappnLocalTgDest"), (0, "IBM-6611-APPN-MIB", "ibmappnLocalTgNum"))
if mibBuilder.loadTexts: ibmappnLocalTgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalTgEntry.setDescription('This table is indexed by the destination CPname and the TG number.')
ibmappnLocalTgDest = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 1, 3, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalTgDest.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalTgDest.setDescription('Administratively-assigned name for the destination node for this TG. This is the fully-qualified network node name.')
ibmappnLocalTgNum = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 1, 3, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalTgNum.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalTgNum.setDescription('Number associated with this transmission group.')
ibmappnLocalTgDestVirtual = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 1, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalTgDestVirtual.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalTgDestVirtual.setDescription('Indicates whether the destination node is a Virtual node.')
ibmappnLocalTgDlcData = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 1, 3, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 9))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalTgDlcData.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalTgDlcData.setDescription('DLC specific data related to the link connection network. Token-Ring - MAC/SAP X.25 Switched - dial digits X.21 Switched - dial digits Circuit Swtch - dial digits')
ibmappnLocalTgRsn = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 1, 3, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalTgRsn.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalTgRsn.setDescription('The resource sequence number is assigned and controlled by the network node that owns this resource. This is always an even unsigned number unless an error has occurred.')
ibmappnLocalTgQuiescing = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 1, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalTgQuiescing.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalTgQuiescing.setDescription('Indicates whether the Transmission Group is quiescing.')
ibmappnLocalTgOperational = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 1, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalTgOperational.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalTgOperational.setDescription('Indicates whether the Transmission Group is operational.')
ibmappnLocalTgCpCpSession = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 1, 3, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalTgCpCpSession.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalTgCpCpSession.setDescription('Indicates whether the CP-CP Sessions are supported on this TG.')
ibmappnLocalTgEffCap = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 1, 3, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalTgEffCap.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalTgEffCap.setDescription('The effective capacity is an integer value that indicates the actual kilo bits per second. It is derived from the link bandwidth and maximum load factor with the range of 0 thru 603,979,776.')
ibmappnLocalTgConnCost = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 1, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalTgConnCost.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalTgConnCost.setDescription('Cost per connect time: a value representing the relative cost per unit of time to use the TG. Range is from 0, which means no cost, to 255.')
ibmappnLocalTgByteCost = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 1, 3, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalTgByteCost.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalTgByteCost.setDescription('Relative cost of transmitting a byte over this link. Range is from 0 (lowest cost) to 255.')
ibmappnLocalTgSecurity = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 1, 3, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 32, 64, 96, 128, 160, 192))).clone(namedValues=NamedValues(("nonsecure", 1), ("publicSwitchedNetwork", 32), ("undergroundCable", 64), ("secureConduit", 96), ("guardedConduit", 128), ("encrypted", 160), ("guardedRadiation", 192)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalTgSecurity.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalTgSecurity.setDescription('Security level for this TG.')
ibmappnLocalTgDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 1, 3, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 384, 9216, 147456, 294912, 2013265920))).clone(namedValues=NamedValues(("minimum", 0), ("negligible", 384), ("terrestrial", 9216), ("packet", 147456), ("long", 294912), ("maximum", 2013265920)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalTgDelay.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalTgDelay.setDescription('Relative amount of time that it takes for a signal to travel the length of the logical link. This time is represented in micro seconds, with some of the more common values enumerated.')
ibmappnLocalTgModemClass = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 1, 3, 1, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalTgModemClass.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalTgModemClass.setDescription('This is used to have multiple images for a connection network. For a connection network it is the same as in the TG vector and for a non-connection network it is zero.')
ibmappnLocalTgUsr1 = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 1, 3, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalTgUsr1.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalTgUsr1.setDescription('Value of the first user-defined TG characteristic for this TG. Range is 0-255.')
ibmappnLocalTgUsr2 = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 1, 3, 1, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalTgUsr2.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalTgUsr2.setDescription('Value of the second user-defined TG characteristic for this TG. Range is 0-255.')
ibmappnLocalTgUsr3 = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 1, 3, 1, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalTgUsr3.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalTgUsr3.setDescription('Value of the third user-defined TG characteristic for this TG. Range is 0-255.')
ibmappnLocalEnTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 2, 1), )
if mibBuilder.loadTexts: ibmappnLocalEnTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalEnTable.setDescription('Portion of the APPN topology database that describes the end nodes known to this node.')
ibmappnLocalEnEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 2, 1, 1), ).setIndexNames((0, "IBM-6611-APPN-MIB", "ibmappnLocalEnName"))
if mibBuilder.loadTexts: ibmappnLocalEnEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalEnEntry.setDescription('This table is indexed by the end node CPname.')
ibmappnLocalEnName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 2, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalEnName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalEnName.setDescription('Administratively-assigned fully-qualified name of end node in the format NETID.CPNAME.')
ibmappnLocalEnEntryTimeLeft = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalEnEntryTimeLeft.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalEnEntryTimeLeft.setDescription('Number of days before deletion of this end node entry. Range is 0-31.')
ibmappnLocalEnType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 4))).clone(namedValues=NamedValues(("endnode", 2), ("len", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalEnType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalEnType.setDescription('Type of APPN node (must always be a len or end node).')
ibmappnLocalEnTgTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 2, 2), )
if mibBuilder.loadTexts: ibmappnLocalEnTgTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalEnTgTable.setDescription('Table describing all of the TGs owned by the end nodes known to this node. The TG destination can be a virtual node, network node, or end node.')
ibmappnLocalEnTgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 2, 2, 1), ).setIndexNames((0, "IBM-6611-APPN-MIB", "ibmappnLocalEnTgOrigin"), (0, "IBM-6611-APPN-MIB", "ibmappnLocalEnTgDest"), (0, "IBM-6611-APPN-MIB", "ibmappnLocalEnTgNum"))
if mibBuilder.loadTexts: ibmappnLocalEnTgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalEnTgEntry.setDescription('This table requires multiple indexes to uniquely identify each TG. They are originating CPname, destination CPname, and the TG number.')
ibmappnLocalEnTgOrigin = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 2, 2, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalEnTgOrigin.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalEnTgOrigin.setDescription('Administratively-assigned name for the origination node for this TG. This is the fully-qualified network name.')
ibmappnLocalEnTgDest = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 2, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalEnTgDest.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalEnTgDest.setDescription('Administratively-assigned name for the destination node for this TG. This is the fully-qualified network name.')
ibmappnLocalEnTgNum = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 2, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalEnTgNum.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalEnTgNum.setDescription('Number associated with this transmission group.')
ibmappnLocalEnTgEntryTimeLeft = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalEnTgEntryTimeLeft.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalEnTgEntryTimeLeft.setDescription('Number of days before deletion of this end node TG entry. Range is 0-31.')
ibmappnLocalEnTgDestVirtual = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 2, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalEnTgDestVirtual.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalEnTgDestVirtual.setDescription('Indicates whether the destination node is a virtual node.')
ibmappnLocalEnTgDlcData = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 2, 2, 1, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalEnTgDlcData.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalEnTgDlcData.setDescription('DLC specific data related to the link connection network. Token-Ring - MAC/SAP X.25 Switched - dial digits X.21 Switched - dial digits Circuit Swtch - dial digits')
ibmappnLocalEnTgOperational = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 2, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalEnTgOperational.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalEnTgOperational.setDescription('Indicates whether the Transmission Group is operational.')
ibmappnLocalEnTgCpCpSession = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 2, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalEnTgCpCpSession.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalEnTgCpCpSession.setDescription('Indicates whether CP-CP sessions are supported on this TG.')
ibmappnLocalEnTgEffCap = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 2, 2, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalEnTgEffCap.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalEnTgEffCap.setDescription('The effective capacity is an integer value that indicates the actual kilo bits per second. It is derived from the link bandwidth and maximum load factor with the range of 0 thru 603,979,776.')
ibmappnLocalEnTgConnCost = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 2, 2, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalEnTgConnCost.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalEnTgConnCost.setDescription('Cost per connect time: a value representing the relative cost per unit of time to use the TG. Range is from 0, which means no cost, to 255.')
ibmappnLocalEnTgByteCost = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 2, 2, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalEnTgByteCost.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalEnTgByteCost.setDescription('Relative cost of transmitting a byte over this link. Range is from 0, which means no cost, to 255.')
ibmappnLocalEnTgSecurity = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 2, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 32, 64, 96, 128, 160, 192))).clone(namedValues=NamedValues(("nonsecure", 1), ("publicSwitchedNetwork", 32), ("undergroundCable", 64), ("secureConduit", 96), ("guardedConduit", 128), ("encrypted", 160), ("guardedRadiation", 192)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalEnTgSecurity.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalEnTgSecurity.setDescription('Security level for this TG.')
ibmappnLocalEnTgDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 2, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 384, 9216, 147456, 294912, 2013265920))).clone(namedValues=NamedValues(("minimum", 0), ("negligible", 384), ("terrestrial", 9216), ("packet", 147456), ("long", 294912), ("maximum", 2013265920)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalEnTgDelay.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalEnTgDelay.setDescription('Relative amount of time that it takes for a signal to travel the length of the logical link. This time is represented in micro seconds, with some of the more common values enumerated.')
ibmappnLocalEnTgModemClass = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 2, 2, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalEnTgModemClass.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalEnTgModemClass.setDescription('This is used to have multiple images for a connection network. For a connection network it is the same as in the TG vector and for a non connection network it is zero.')
ibmappnLocalEnTgUsr1 = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 2, 2, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalEnTgUsr1.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalEnTgUsr1.setDescription('First user-defined TG characteristic for this TG. Range of values is 0-255.')
ibmappnLocalEnTgUsr2 = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 2, 2, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalEnTgUsr2.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalEnTgUsr2.setDescription('Second user-defined TG characteristic for this TG. Range of values is 0-255.')
ibmappnLocalEnTgUsr3 = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 3, 2, 2, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnLocalEnTgUsr3.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnLocalEnTgUsr3.setDescription('Third user-defined TG characteristic for this TG. Range of values is 0-255.')
ibmappnDir = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 5))
ibmappnDirPerf = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 5, 1))
ibmappnDirMaxCaches = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnDirMaxCaches.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnDirMaxCaches.setDescription('Maximum number of cache entries allowed. This is an administratively assigned value.')
ibmappnDirCurCaches = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 5, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnDirCurCaches.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnDirCurCaches.setDescription('Current number of cache entries.')
ibmappnDirCurHomeEntries = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 5, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnDirCurHomeEntries.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnDirCurHomeEntries.setDescription('Current number of home entries.')
ibmappnDirRegEntries = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 5, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnDirRegEntries.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnDirRegEntries.setDescription('Current number of registered entries.')
ibmappnDirInLocates = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 5, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnDirInLocates.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnDirInLocates.setDescription('Number of directed locates received.')
ibmappnDirInBcastLocates = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 5, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnDirInBcastLocates.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnDirInBcastLocates.setDescription('Number of broadcast locates received.')
ibmappnDirOutLocates = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 5, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnDirOutLocates.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnDirOutLocates.setDescription('Number of directed locates sent.')
ibmappnDirOutBcastLocates = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 5, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnDirOutBcastLocates.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnDirOutBcastLocates.setDescription('Number of broadcast locates sent.')
ibmappnDirNotFoundLocates = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 5, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnDirNotFoundLocates.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnDirNotFoundLocates.setDescription("Number of directed locates returned with a 'not found'.")
ibmappnDirNotFoundBcastLocates = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 5, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnDirNotFoundBcastLocates.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnDirNotFoundBcastLocates.setDescription('Number of broadcast locates returned with a not found.')
ibmappnDirLocateOutstands = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 5, 1, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnDirLocateOutstands.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnDirLocateOutstands.setDescription('Current number of outstanding locates, both directed and broadcast. This value varies. A value of zero indicates that no locates are unanswered.')
ibmappnDirTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 5, 2), )
if mibBuilder.loadTexts: ibmappnDirTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnDirTable.setDescription('Table containing information about all known LUs and TPs.')
ibmappnDirEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 5, 2, 1), ).setIndexNames((0, "IBM-6611-APPN-MIB", "ibmappnDirLuName"))
if mibBuilder.loadTexts: ibmappnDirEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnDirEntry.setDescription('This table is indexed by the LU name.')
ibmappnDirLuName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 5, 2, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnDirLuName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnDirLuName.setDescription('Fully-qualified network LU name in the domain of the serving network node.')
ibmappnDirServerName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 5, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnDirServerName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnDirServerName.setDescription('Fully-qualified control point (CP) name of the network node server. For unassociated end node entries, the end node fully-qualified name is returned.')
ibmappnDirLuOwnerName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 5, 2, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnDirLuOwnerName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnDirLuOwnerName.setDescription('Fully-qualified CP name of the node at which the LU is located. This name is the same as the serving NN name when the LU is located at a network node or an unassociated end node. It is also the same as the fully-qualified LU name when this is the control point LU for this node.')
ibmappnDirLuLocation = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 5, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("local", 1), ("domain", 2), ("xdomain", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnDirLuLocation.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnDirLuLocation.setDescription('Specifies the location of the LU.')
ibmappnDirType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 5, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("home", 1), ("cache", 2), ("registered", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnDirType.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnDirType.setDescription('Directory types are: 1 - Home The LU is in the domain of the local network node and the LU information has been configured at the local node. 2 - Cache The LU has previously been located by a broadcast search and the location information has been saved. 3 - Register The LU is at an end node that is in the domain of the local network node. Registered entries are registered by the served end node.')
ibmappnDirWildCard = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 5, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("explicit-entry", 2), ("partial-wildcard", 3), ("full-wildcard", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnDirWildCard.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnDirWildCard.setDescription('1 - Other means unknown type of LU entry. 2 - Expliced-entry means the full LUNAME will be used for locating this LU. 3 - Partial-wildcard means only the non-blank portions of the LUNAME will be used for locating this LU. 4 - Full-wildcard means all LUNAMES will be directed to this LU.')
ibmappnCos = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 6))
ibmappnCosModeTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 6, 1), )
if mibBuilder.loadTexts: ibmappnCosModeTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnCosModeTable.setDescription('Table representing all of the defined mode names for this node. The table contains the matching COS name.')
ibmappnCosModeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 6, 1, 1), ).setIndexNames((0, "IBM-6611-APPN-MIB", "ibmappnCosModeName"))
if mibBuilder.loadTexts: ibmappnCosModeEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnCosModeEntry.setDescription('This table is indexed by the Mode Name.')
ibmappnCosModeName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 6, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnCosModeName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnCosModeName.setDescription('Administratively-assigned name for this mode entry.')
ibmappnCosModeCosName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 6, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnCosModeCosName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnCosModeCosName.setDescription('An administratively assigned name for this Class of Service.')
ibmappnCosNameTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 6, 2), )
if mibBuilder.loadTexts: ibmappnCosNameTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnCosNameTable.setDescription('Table representing all of the defined class-of-service names for this node. The COS node and TG tables are accessed using the same index, which is the COS name.')
ibmappnCosNameEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 6, 2, 1), ).setIndexNames((0, "IBM-6611-APPN-MIB", "ibmappnCosName"))
if mibBuilder.loadTexts: ibmappnCosNameEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnCosNameEntry.setDescription('The COS name is the index to this table.')
ibmappnCosName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 6, 2, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnCosName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnCosName.setDescription('Administratively-assigned name for this class of service.')
ibmappnCosTransPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 6, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("low", 1), ("medium", 2), ("high", 3), ("network", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnCosTransPriority.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnCosTransPriority.setDescription('Transmission priority for this class of service. Values are: Low Medium High Network ')
ibmappnCosNodeRowTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 6, 3), )
if mibBuilder.loadTexts: ibmappnCosNodeRowTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnCosNodeRowTable.setDescription('This table contains all node-row information for all class of service in this node.')
ibmappnCosNodeRowEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 6, 3, 1), ).setIndexNames((0, "IBM-6611-APPN-MIB", "ibmappnCosNodeRowName"), (0, "IBM-6611-APPN-MIB", "ibmappnCosNodeRowIndex"))
if mibBuilder.loadTexts: ibmappnCosNodeRowEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnCosNodeRowEntry.setDescription('The COS name is the first index and a integer is the second index to insure a unique index.')
ibmappnCosNodeRowName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 6, 3, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnCosNodeRowName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnCosNodeRowName.setDescription('Administratively-assigned name for this class of service.')
ibmappnCosNodeRowIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 6, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnCosNodeRowIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnCosNodeRowIndex.setDescription('Index of COS name. This same value is used to access the node and TG COS tables. Range of values is 0-255.')
ibmappnCosNodeRowWgt = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 6, 3, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnCosNodeRowWgt.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnCosNodeRowWgt.setDescription('Weight to be associated with the nodes that fit the criteria specified by this node row.')
ibmappnCosNodeRowResistMin = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 6, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnCosNodeRowResistMin.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnCosNodeRowResistMin.setDescription('Minimum route addition resistance value for this node. Range of values is 0-255. The lower the value, the more desirable the node is for intermediate routing.')
ibmappnCosNodeRowResistMax = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 6, 3, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnCosNodeRowResistMax.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnCosNodeRowResistMax.setDescription('Maximum route addition resistance value for this node. Range of values is 0-255. The lower the value, the more desirable the node is for intermediate routing.')
ibmappnCosNodeRowMinCongestAllow = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 6, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnCosNodeRowMinCongestAllow.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnCosNodeRowMinCongestAllow.setDescription('Indicates whether low congestion will be tolerated. The minimum and maximum parameters will allow specifying either low-congested, high-congested, or either to be used.')
ibmappnCosNodeRowMaxCongestAllow = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 6, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnCosNodeRowMaxCongestAllow.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnCosNodeRowMaxCongestAllow.setDescription('Indicates whether high congestion will be tolerated. The minimum and maximum parameters will allow specifying either low-congested, high-congested, or either to be used.')
ibmappnCosTgRowTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 6, 4), )
if mibBuilder.loadTexts: ibmappnCosTgRowTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnCosTgRowTable.setDescription('Table containing all the Tg-row information for all class of service defined in this node.')
ibmappnCosTgRowEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 6, 4, 1), ).setIndexNames((0, "IBM-6611-APPN-MIB", "ibmappnCosTgRowName"), (0, "IBM-6611-APPN-MIB", "ibmappnCosTgRowIndex"))
if mibBuilder.loadTexts: ibmappnCosTgRowEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnCosTgRowEntry.setDescription('The TgRowName and the TgRowIndex are the index for this table.')
ibmappnCosTgRowName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 6, 4, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnCosTgRowName.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnCosTgRowName.setDescription('Administratively-assigned name for this class of service.')
ibmappnCosTgRowIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 6, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnCosTgRowIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnCosTgRowIndex.setDescription('Index of COS name. This same value is used to access the node and TG COS tables.')
ibmappnCosTgRowWgt = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 6, 4, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnCosTgRowWgt.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnCosTgRowWgt.setDescription('Weight to be associated with the nodes that fit the criteria specified by this tg-row.')
ibmappnCosTgRowEffCapMin = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 6, 4, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnCosTgRowEffCapMin.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnCosTgRowEffCapMin.setDescription('Minimum acceptable speed for this Class of Service. The effective capacity is an integer value that indicates the actual kilo bits per second. It is derived from the link bandwidth and maximum load factor with the range of 0 thru 603,979,776.')
ibmappnCosTgRowEffCapMax = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 6, 4, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnCosTgRowEffCapMax.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnCosTgRowEffCapMax.setDescription('Maximum acceptable speed for this Class of Service. The effective capacity is an integer value that indicates the actual kilo bits per second. It is derived from the link bandwidth and maximum load factor with the range of 0 thru 603,979,776.')
ibmappnCosTgRowConnCostMin = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 6, 4, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnCosTgRowConnCostMin.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnCosTgRowConnCostMin.setDescription('Minimum acceptable cost per connect time for this Class of Service. Cost per connect time: a value representing the relative cost per unit of time to use the TG. Range is from 0, which means no cost, to 255.')
ibmappnCosTgRowConnCostMax = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 6, 4, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnCosTgRowConnCostMax.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnCosTgRowConnCostMax.setDescription('Maximum acceptable cost per connect time for this Class of Service. Cost per connect time: a value representing the relative cost per unit of time to use the TG. Range is from 0, which means no cost, to 255.')
ibmappnCosTgRowByteCostMin = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 6, 4, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnCosTgRowByteCostMin.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnCosTgRowByteCostMin.setDescription('Minimum acceptable cost per byte for this Class of Service.')
ibmappnCosTgRowByteCostMax = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 6, 4, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnCosTgRowByteCostMax.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnCosTgRowByteCostMax.setDescription('Maximum acceptable cost per byte for this Class of Service.')
ibmappnCosTgRowSecurityMin = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 6, 4, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 32, 64, 96, 128, 160, 192))).clone(namedValues=NamedValues(("nonsecure", 1), ("publicSwitchedNetwork", 32), ("undergroundCable", 64), ("secureConduit", 96), ("guardedConduit", 128), ("encrypted", 160), ("guardedRadiation", 192)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnCosTgRowSecurityMin.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnCosTgRowSecurityMin.setDescription('Minimum acceptable security for this Class of Service.')
ibmappnCosTgRowSecurityMax = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 6, 4, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 32, 64, 96, 128, 160, 192))).clone(namedValues=NamedValues(("nonsecure", 1), ("publicSwitchedNetwork", 32), ("undergroundCable", 64), ("secureConduit", 96), ("guardedConduit", 128), ("encrypted", 160), ("guardedRadiation", 192)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnCosTgRowSecurityMax.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnCosTgRowSecurityMax.setDescription('Maximum acceptable security for this Class of Service.')
ibmappnCosTgRowDelayMin = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 6, 4, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 384, 9216, 147456, 294912, 2013265920))).clone(namedValues=NamedValues(("minimum", 0), ("negligible", 384), ("terrestrial", 9216), ("packet", 147456), ("long", 294912), ("maximum", 2013265920)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnCosTgRowDelayMin.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnCosTgRowDelayMin.setDescription('Minimum acceptable propagation delay for this class of service. Relative amount of time that it takes for a signal to travel the length of the logical link. This time is represented in micro seconds, with the more values enumerated.')
ibmappnCosTgRowDelayMax = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 6, 4, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 384, 9216, 147456, 294912, 2013265920))).clone(namedValues=NamedValues(("minimum", 0), ("negligible", 384), ("terrestrial", 9216), ("packet", 147456), ("long", 294912), ("maximum", 2013265920)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnCosTgRowDelayMax.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnCosTgRowDelayMax.setDescription('Maximum acceptable propagation delay for this class of service. Relative amount of time that it takes for a signal to travel the length of the logical link. This time is represented in micro seconds, with the more values enumerated.')
ibmappnCosTgRowUsr1Min = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 6, 4, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnCosTgRowUsr1Min.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnCosTgRowUsr1Min.setDescription('Minimum acceptable value for this user defined characteristic. Range of values is 0-255.')
ibmappnCosTgRowUsr1Max = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 6, 4, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnCosTgRowUsr1Max.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnCosTgRowUsr1Max.setDescription('Maximum acceptable value for this user defined characteristic. Range of values is 0-255.')
ibmappnCosTgRowUsr2Min = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 6, 4, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnCosTgRowUsr2Min.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnCosTgRowUsr2Min.setDescription('Minimum acceptable value for this user defined characteristic. Range of values is 0-255.')
ibmappnCosTgRowUsr2Max = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 6, 4, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnCosTgRowUsr2Max.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnCosTgRowUsr2Max.setDescription('A Maximum acceptable value for this user defined characteristic.')
ibmappnCosTgRowUsr3Min = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 6, 4, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnCosTgRowUsr3Min.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnCosTgRowUsr3Min.setDescription('Minimum acceptable value for this user defined characteristic. Range of values is 0-255.')
ibmappnCosTgRowUsr3Max = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 2, 13, 6, 4, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmappnCosTgRowUsr3Max.setStatus('mandatory')
if mibBuilder.loadTexts: ibmappnCosTgRowUsr3Max.setDescription('Maximum acceptable value for this user defined characteristic. Range of values is 0-255.')
mibBuilder.exportSymbols("IBM-6611-APPN-MIB", ibmappnNnNodeName=ibmappnNnNodeName, ibmappnNodeLsRemoteIpAddr=ibmappnNodeLsRemoteIpAddr, ibmappnLocalNodeType=ibmappnLocalNodeType, ibmappnNnTgFRSecurity=ibmappnNnTgFRSecurity, ibmappnNodeLsOutMsgFrames=ibmappnNodeLsOutMsgFrames, ibmappnNodeLsLocalTrMac=ibmappnNodeLsLocalTrMac, ibmappnNnTopoNodeTimerUpdates=ibmappnNnTopoNodeTimerUpdates, ibmappnMemorySize=ibmappnMemorySize, ibmappnCos=ibmappnCos, ibmappnNnTgFRDestVirtual=ibmappnNnTgFRDestVirtual, ibmappnNodeLsDlsTable=ibmappnNodeLsDlsTable, ibmappnEnUniqueCaps=ibmappnEnUniqueCaps, ibmappnLocalEnTgDelay=ibmappnLocalEnTgDelay, ibmappnNodeNnRouteAddResist=ibmappnNodeNnRouteAddResist, ibmappnNnAdjNodeLastFrsnRcvd=ibmappnNnAdjNodeLastFrsnRcvd, ibmappnNnTopoRouteTrees=ibmappnNnTopoRouteTrees, ibmappnNodePortIpPortNum=ibmappnNodePortIpPortNum, ibmappnNodePortDlsName=ibmappnNodePortDlsName, ibmappnNodeNnTreeUpdate=ibmappnNodeNnTreeUpdate, ibmappnNodePortDlcTracRemoteAddr=ibmappnNodePortDlcTracRemoteAddr, ibmappnLocalTgDest=ibmappnLocalTgDest, ibmappnNodePortMaxRcvBtuSize=ibmappnNodePortMaxRcvBtuSize, ibmappnDirNotFoundBcastLocates=ibmappnDirNotFoundBcastLocates, ibmappnNnNodeFRFrsn=ibmappnNnNodeFRFrsn, ibmappnLocalEnTgByteCost=ibmappnLocalEnTgByteCost, ibmappnDirLuLocation=ibmappnDirLuLocation, ibmappnNnTgFRDest=ibmappnNnTgFRDest, ibmappnSnmpInPkts=ibmappnSnmpInPkts, ibmappnNodeLsGoodXids=ibmappnNodeLsGoodXids, ibmappnCosTgRowConnCostMax=ibmappnCosTgRowConnCostMax, ibmappnCosNodeRowName=ibmappnCosNodeRowName, ibmappnLocalEnTgEntry=ibmappnLocalEnTgEntry, ibmappnSnmpInGetNexts=ibmappnSnmpInGetNexts, ibmappnNodeLsTargetPacingCount=ibmappnNodeLsTargetPacingCount, ibmappnNnNodeCentralDirectory=ibmappnNnNodeCentralDirectory, ibmappnLocalNnRsn=ibmappnLocalNnRsn, ibmappnLocalNnSpecific=ibmappnLocalNnSpecific, ibmappnLocalEnTgConnCost=ibmappnLocalEnTgConnCost, ibmappnNodePortDlcTracDlcType=ibmappnNodePortDlcTracDlcType, ibmappnNodeEnSendRegChar=ibmappnNodeEnSendRegChar, ibmappnNodeLsStatusTgNum=ibmappnNodeLsStatusTgNum, ibmappnLocalTgEntry=ibmappnLocalTgEntry, ibmappnNnTgEntryTimeLeft=ibmappnNnTgEntryTimeLeft, ibmappnNodeLsMaxDelay=ibmappnNodeLsMaxDelay, ibmappnNnTgFRQuiescing=ibmappnNnTgFRQuiescing, ibmappnNnTgModemClass=ibmappnNnTgModemClass, ibmappnNodePortIpName=ibmappnNodePortIpName, ibmappnNodeDefLsGoodXids=ibmappnNodeDefLsGoodXids, ibmappnNnTgConnCost=ibmappnNnTgConnCost, ibmappnNnNodeIsr=ibmappnNnNodeIsr, ibmappnNodeLsRemoteTrMac=ibmappnNodeLsRemoteTrMac, ibmappnNodeType=ibmappnNodeType, ibmappnNodeLsCurrentStateTime=ibmappnNodeLsCurrentStateTime, ibmappnLocalEnTgDlcData=ibmappnLocalEnTgDlcData, ibmappnNodePortDlcTracPortName=ibmappnNodePortDlcTracPortName, ibmappnNodeLsState=ibmappnNodeLsState, ibmappnNodeService=ibmappnNodeService, ibmappnCosTgRowEntry=ibmappnCosTgRowEntry, ibmappnNnTopologyFREntry=ibmappnNnTopologyFREntry, ibmappnNodeLsLocalIpPortNum=ibmappnNodeLsLocalIpPortNum, ibmappnNnNodeRouteAddResist=ibmappnNnNodeRouteAddResist, ibmappnCosModeTable=ibmappnCosModeTable, ibmappnNodeLsStatusXidBitInError=ibmappnNodeLsStatusXidBitInError, ibmappnLocalEnTgNum=ibmappnLocalEnTgNum, ibmappnLocalEnTgUsr3=ibmappnLocalEnTgUsr3, ibmappnSnmpInGetRequests=ibmappnSnmpInGetRequests, ibmappnNodeLsCpName=ibmappnNodeLsCpName, ibmappnNnTgTopologyTable=ibmappnNnTgTopologyTable, ibmappnNodeLsMigration=ibmappnNodeLsMigration, ibmappnNodeLsInXidBytes=ibmappnNodeLsInXidBytes, ibmProd=ibmProd, ibmappnNodeLsStatusCpName=ibmappnNodeLsStatusCpName, ibmappnCosNodeRowMaxCongestAllow=ibmappnCosNodeRowMaxCongestAllow, ibmappnNodePortTrTable=ibmappnNodePortTrTable, ibmappnNodeLsDlsState=ibmappnNodeLsDlsState, ibmappnNodePortIpEntry=ibmappnNodePortIpEntry, ibmappnNn=ibmappnNn, ibmappnNnTopoTgBadHighRsns=ibmappnNnTopoTgBadHighRsns, ibmappnNnTopologyTable=ibmappnNnTopologyTable, ibmappnCosNodeRowIndex=ibmappnCosNodeRowIndex, ibmappnNodeLsStatusTable=ibmappnNodeLsStatusTable, ibmappnDirTable=ibmappnDirTable, ibmappnNnAdjNodeLastFrsnSent=ibmappnNnAdjNodeLastFrsnSent, ibmappnNodePortDlsMac=ibmappnNodePortDlsMac, ibmappnLocalTgUsr1=ibmappnLocalTgUsr1, ibmappnNnTopoNodePurges=ibmappnNnTopoNodePurges, ibmappnLocalTgOperational=ibmappnLocalTgOperational, ibmappnNodePortIpTable=ibmappnNodePortIpTable, ibmappnMemoryCritThresh=ibmappnMemoryCritThresh, ibmappnLocalNnRouteAddResist=ibmappnLocalNnRouteAddResist, ibm=ibm, ibmappnLocalEnType=ibmappnLocalEnType, ibmappnNnTopo=ibmappnNnTopo, ibmappnNnNodeFrsn=ibmappnNnNodeFrsn, ibmappnCosNameTable=ibmappnCosNameTable, ibmappnNodeLsTgNum=ibmappnNodeLsTgNum, ibmappnNnTgFRUsr3=ibmappnNnTgFRUsr3, ibmappnNodeLsStatusGeneralSense=ibmappnNodeLsStatusGeneralSense, ibmappnNodeLsStatusEntry=ibmappnNodeLsStatusEntry, ibmappnLocalNnChainSupport=ibmappnLocalNnChainSupport, ibmappnLinkStationInformation=ibmappnLinkStationInformation, ibmappnLocalNnFrsn=ibmappnLocalNnFrsn, ibmappnPortInformation=ibmappnPortInformation, ibmappnNodeLsInXidFrames=ibmappnNodeLsInXidFrames, ibmappnNodeLsPortName=ibmappnNodeLsPortName, ibmappnDirInLocates=ibmappnDirInLocates, ibmappnNodeLsUsr1=ibmappnNodeLsUsr1, ibmappnNnTopoTgEqualRsns=ibmappnNnTopoTgEqualRsns, ibmappnNodePortPortType=ibmappnNodePortPortType, ibmappnNodeLsUsr2=ibmappnNodeLsUsr2, ibmappnNnTopology=ibmappnNnTopology, ibmappnLocalNnIsr=ibmappnLocalNnIsr, ibmappnDirNotFoundLocates=ibmappnDirNotFoundLocates, ibmappnNodeLsCurrentDelay=ibmappnNodeLsCurrentDelay, ibmappnMemoryWarnThresh=ibmappnMemoryWarnThresh, ibmappnNnNodeEndptDepleted=ibmappnNnNodeEndptDepleted, ibmappnLocalNnEndptDepleted=ibmappnLocalNnEndptDepleted, ibmappnNodeLsDlsEntry=ibmappnNodeLsDlsEntry, ibmappnGeneralInfoAndCaps=ibmappnGeneralInfoAndCaps, ibmappnNnTopologyEntry=ibmappnNnTopologyEntry, ibmappnCosNodeRowTable=ibmappnCosNodeRowTable, ibmappnCosNodeRowMinCongestAllow=ibmappnCosNodeRowMinCongestAllow, ibmappnNnTgFREffCap=ibmappnNnTgFREffCap, ibmappnCosName=ibmappnCosName, ibmappnNodeLsEntry=ibmappnNodeLsEntry, ibmappnCosTgRowUsr1Min=ibmappnCosTgRowUsr1Min, ibmappnNnTgEffCap=ibmappnNnTgEffCap, ibmappnNnTopoTgStateUpdates=ibmappnNnTopoTgStateUpdates, ibmappnNnNodeIsrDepleted=ibmappnNnNodeIsrDepleted, ibmappnNodePortDlsEntry=ibmappnNodePortDlsEntry, ibmappnNodeEnModeCosMap=ibmappnNodeEnModeCosMap, ibmappnSnmpOutNoSuchNames=ibmappnSnmpOutNoSuchNames, ibmappnNodeLsRemoteDlsMac=ibmappnNodeLsRemoteDlsMac, ibmappnNnTopoNodeEqualRsns=ibmappnNnTopoNodeEqualRsns, ibmappnNnNodeFREndptDepleted=ibmappnNnNodeFREndptDepleted, ibmappnNnTgUsr2=ibmappnNnTgUsr2, ibmappnCosNodeRowResistMin=ibmappnCosNodeRowResistMin, ibmappnNnAdjNodeTable=ibmappnNnAdjNodeTable, ibmappnNnNodeFRChainSupport=ibmappnNnNodeFRChainSupport, ibmappnCosTgRowUsr2Max=ibmappnCosTgRowUsr2Max, ibmappnDirEntry=ibmappnDirEntry, ibmappnNodeBindReasm=ibmappnNodeBindReasm, ibmappnNnTgTopologyFREntry=ibmappnNnTgTopologyFREntry, ibmappnNodeLsCpCpSession=ibmappnNodeLsCpCpSession, ibmappnSnmpInTotalVars=ibmappnSnmpInTotalVars, ibmappnNnTopoNodeStateUpdates=ibmappnNnTopoNodeStateUpdates, ibmappnLocalTgQuiescing=ibmappnLocalTgQuiescing, ibmappnNodeLsSpecific=ibmappnNodeLsSpecific, ibmappnNnTopoNodeLowRsns=ibmappnNnTopoNodeLowRsns, ibmappnDirServerName=ibmappnDirServerName, ibmappnNnTopoTotalRouteRejs=ibmappnNnTopoTotalRouteRejs, ibmappnNnTgCpCpSession=ibmappnNnTgCpCpSession, ibmappnDirPerf=ibmappnDirPerf, ibmappnNodeEnSendRegNames=ibmappnNodeEnSendRegNames, ibmappnNnTgFREntryTimeLeft=ibmappnNnTgFREntryTimeLeft, ibmappnNodeLsIpName=ibmappnNodeLsIpName, ibmappnLocalEnTgTable=ibmappnLocalEnTgTable, ibmappnDirWildCard=ibmappnDirWildCard, ibmappnNodeLsStatusXidRemoteSense=ibmappnNodeLsStatusXidRemoteSense, ibmappnNnNodeChainSupport=ibmappnNnNodeChainSupport, ibmappnCosTgRowDelayMax=ibmappnCosTgRowDelayMax, ibmappnDirLuOwnerName=ibmappnDirLuOwnerName, ibmappnCosTransPriority=ibmappnCosTransPriority, ibmappnNnTopoRouteRejs=ibmappnNnTopoRouteRejs, ibmappnNnTgQuiescing=ibmappnNnTgQuiescing, ibmappnNodePortSIMRIM=ibmappnNodePortSIMRIM, ibmappnNodeNnGateway=ibmappnNodeNnGateway, ibmappnLocalEnTgOrigin=ibmappnLocalEnTgOrigin, ibmappnCosNodeRowEntry=ibmappnCosNodeRowEntry, ibmappnCosTgRowSecurityMin=ibmappnCosTgRowSecurityMin, ibmappnNodeDefLsBadXids=ibmappnNodeDefLsBadXids, ibmappnNodeLsIpEntry=ibmappnNodeLsIpEntry, ibmappnNodeLsRemoteDlsSap=ibmappnNodeLsRemoteDlsSap, ibmappnLocalThisNode=ibmappnLocalThisNode, ibmappnNodeLsTrState=ibmappnNodeLsTrState, ibmappnCosNameEntry=ibmappnCosNameEntry, ibmappnLocalEnTgUsr2=ibmappnLocalEnTgUsr2, ibmappnNodeLsStatusLsName=ibmappnNodeLsStatusLsName, ibmappnDirOutBcastLocates=ibmappnDirOutBcastLocates, ibmappnNodeLsDynamic=ibmappnNodeLsDynamic, ibmappnCosTgRowByteCostMax=ibmappnCosTgRowByteCostMax, ibmappnNnTgSecurity=ibmappnNnTgSecurity, ibmappnNnTgFRByteCost=ibmappnNnTgFRByteCost, ibmappnNnTopologyFRTable=ibmappnNnTopologyFRTable, ibmappnLocalTgDelay=ibmappnLocalTgDelay, ibmappnSnmpInformation=ibmappnSnmpInformation, ibmappnNnTgOwner=ibmappnNnTgOwner, ibmappnLocalEnTgCpCpSession=ibmappnLocalEnTgCpCpSession, ibmappnNodeNnRcvRegChar=ibmappnNodeNnRcvRegChar, ibmappnNnTopoTgErrors=ibmappnNnTopoTgErrors, ibmappnLocalGeneral=ibmappnLocalGeneral, ibmappnNnTgFROperational=ibmappnNnTgFROperational, ibmappnNnNodeQuiescing=ibmappnNnNodeQuiescing, ibmappnNodeLsStatusTime=ibmappnNodeLsStatusTime, ibmappnLocalTg=ibmappnLocalTg, ibmappnCosTgRowEffCapMin=ibmappnCosTgRowEffCapMin, ibmappnLocalEnTgEntryTimeLeft=ibmappnLocalEnTgEntryTimeLeft, ibmappnNodeLsTrEntry=ibmappnNodeLsTrEntry, ibmappnNnTopoTgGoodHighRsns=ibmappnNnTopoTgGoodHighRsns, ibmappnNodeLsIpState=ibmappnNodeLsIpState, ibmappnSnmpInSetRequests=ibmappnSnmpInSetRequests, ibmappnNodeLsStatusXidByteInError=ibmappnNodeLsStatusXidByteInError, ibmappnNodeLsLocalIpAddr=ibmappnNodeLsLocalIpAddr, ibmappnNodeLsUsr3=ibmappnNodeLsUsr3, ibmappnNodeLsRemoteIpPortNum=ibmappnNodeLsRemoteIpPortNum, ibmappnNnNodeFREntryTimeLeft=ibmappnNnNodeFREntryTimeLeft, ibmappnLocalNnCongested=ibmappnLocalNnCongested, ibmappnNodeLsSecurity=ibmappnNodeLsSecurity, ibmappnNnTgFRDlcData=ibmappnNnTgFRDlcData, ibmappnCosTgRowUsr1Max=ibmappnCosTgRowUsr1Max, ibmappnNodeCpName=ibmappnNodeCpName, ibmappnNnAdjNodeAdjName=ibmappnNnAdjNodeAdjName, ibmappnDirCurCaches=ibmappnDirCurCaches, ibmappnNodeLsEchoRsps=ibmappnNodeLsEchoRsps, ibmappnXidInformation=ibmappnXidInformation, ibmappnLocalNnIsrDepleted=ibmappnLocalNnIsrDepleted, ibmappnNodePortTrMac=ibmappnNodePortTrMac, ibmappnNnNodeRsn=ibmappnNnNodeRsn, ibmappnNnTgDlcData=ibmappnNnTgDlcData, ibmappnDirMaxCaches=ibmappnDirMaxCaches, ibmappnNnNodeGateway=ibmappnNnNodeGateway, ibmappnLocalNnCentralDirectory=ibmappnLocalNnCentralDirectory, ibmappnNodePortState=ibmappnNodePortState, ibmappnNodeLsEffCap=ibmappnNodeLsEffCap, ibmappnSnmpInGetVars=ibmappnSnmpInGetVars, ibmappnCosTgRowByteCostMin=ibmappnCosTgRowByteCostMin, ibmappnNodePortDlcTracLocalAddr=ibmappnNodePortDlcTracLocalAddr, ibmappnNnTopoNodeBadHighRsns=ibmappnNnTopoNodeBadHighRsns, ibmappnLocalEnTgDestVirtual=ibmappnLocalEnTgDestVirtual, ibmappnNnNodeType=ibmappnNnNodeType, ibmappnNodeLsMaxSendBtuSize=ibmappnNodeLsMaxSendBtuSize, ibmappnNnNodeFRRsn=ibmappnNnNodeFRRsn, ibmappnNnNodeFRType=ibmappnNnNodeFRType, ibmappnNodeNegotLs=ibmappnNodeNegotLs, ibmappnNodeLsConnCost=ibmappnNodeLsConnCost, ibmappnCosTgRowIndex=ibmappnCosTgRowIndex, ibmappnLocalTgCpCpSession=ibmappnLocalTgCpCpSession, ibmappnDir=ibmappnDir, ibmappnLocalNodeName=ibmappnLocalNodeName, ibmappnSnmpOutGenErrs=ibmappnSnmpOutGenErrs, ibmappnNodeLsMinDelay=ibmappnNodeLsMinDelay, ibmappnNodeNnIsr=ibmappnNodeNnIsr, ibmappnCosTgRowConnCostMin=ibmappnCosTgRowConnCostMin, ibmappnNnTopoNodeErrors=ibmappnNnTopoNodeErrors, ibmappnNnTopoNodeGoodHighRsns=ibmappnNnTopoNodeGoodHighRsns, ibmappnLocalEnEntry=ibmappnLocalEnEntry, ibmappnNodeLsMaxDelayTime=ibmappnNodeLsMaxDelayTime, ibmappnDirType=ibmappnDirType, ibmappnNnTgDest=ibmappnNnTgDest, ibmappnNodePortTrEntry=ibmappnNodePortTrEntry, ibmappnNnTgFRConnCost=ibmappnNnTgFRConnCost, ibmappnNnTopoTgTimerUpdates=ibmappnNnTopoTgTimerUpdates, ibmappnNnNodeFRIsr=ibmappnNnNodeFRIsr, ibmappnNnTgTopologyFRTable=ibmappnNnTgTopologyFRTable)
mibBuilder.exportSymbols("IBM-6611-APPN-MIB", ibmappnNodeLsInMsgBytes=ibmappnNodeLsInMsgBytes, ibmappnDirLuName=ibmappnDirLuName, ibmappnCosTgRowUsr3Max=ibmappnCosTgRowUsr3Max, ibmappnNnTgOperational=ibmappnNnTgOperational, ibmappnNodeNetid=ibmappnNodeNetid, ibmappnNodePortDynLsGoodXids=ibmappnNodePortDynLsGoodXids, ibmappnLocalTgUsr3=ibmappnLocalTgUsr3, ibmappnNodePortName=ibmappnNodePortName, ibmappnLocalEnName=ibmappnLocalEnName, ibmappnNodeParallelTg=ibmappnNodeParallelTg, ibmappnNodeLsDlcType=ibmappnNodeLsDlcType, ibmappnNodeLsStatusIndex=ibmappnNodeLsStatusIndex, ibmappnNodeLsTable=ibmappnNodeLsTable, ibmappnLocalEnTgDest=ibmappnLocalEnTgDest, ibmappnNodeLsActiveTime=ibmappnNodeLsActiveTime, ibmappnNnTopoCurNumNodes=ibmappnNnTopoCurNumNodes, ibmappnMemoryUse=ibmappnMemoryUse, ibmappnLocalTgConnCost=ibmappnLocalTgConnCost, ibmappnNodeLsLocalTrSap=ibmappnNodeLsLocalTrSap, ibmappnSnmpInGetNextVars=ibmappnSnmpInGetNextVars, ibmappnNnNodeFRRouteAddResist=ibmappnNnNodeFRRouteAddResist, ibm6611=ibm6611, ibmappnCosNodeRowResistMax=ibmappnCosNodeRowResistMax, ibmappnNnTopoRouteTable=ibmappnNnTopoRouteTable, ibmappnLocalNnGateway=ibmappnLocalNnGateway, ibmappnNnTgFRUsr1=ibmappnNnTgFRUsr1, ibmappnNodeLsLocalDlsSap=ibmappnNodeLsLocalDlsSap, ibmappnCosTgRowUsr2Min=ibmappnCosTgRowUsr2Min, ibmappnNodePortDlcType=ibmappnNodePortDlcType, ibmappnSnmpInSetVars=ibmappnSnmpInSetVars, ibmappnNodePortTrName=ibmappnNodePortTrName, ibmappnNodeNnFrsn=ibmappnNodeNnFrsn, ibmappnNnTgDestVirtual=ibmappnNnTgDestVirtual, ibmappnNodeLsLocalDlsMac=ibmappnNodeLsLocalDlsMac, ibmappnNnAdjNodeCpCpSessStatus=ibmappnNnAdjNodeCpCpSessStatus, ibmappnNnTgFRCpCpSession=ibmappnNnTgFRCpCpSession, ibmappnNnTopoInTdus=ibmappnNnTopoInTdus, ibmappnCosTgRowTable=ibmappnCosTgRowTable, ibmappnNodePortDefLsGoodXids=ibmappnNodePortDefLsGoodXids, ibmappnCosTgRowName=ibmappnCosTgRowName, ibmappnLocalEnTgModemClass=ibmappnLocalEnTgModemClass, ibmappnNodeLsInMsgFrames=ibmappnNodeLsInMsgFrames, ibmappnNnTgFROwner=ibmappnNnTgFROwner, ibmappnNnNodeCongested=ibmappnNnNodeCongested, ibmappnNodeLsStatusNofRetry=ibmappnNodeLsStatusNofRetry, ibmappnCosModeEntry=ibmappnCosModeEntry, ibmappnNnNodeFRIsrDepleted=ibmappnNnNodeFRIsrDepleted, ibmappnLocalTgModemClass=ibmappnLocalTgModemClass, ibmappnCosTgRowDelayMin=ibmappnCosTgRowDelayMin, ibmappnNodePortTrSap=ibmappnNodePortTrSap, ibmappnNodeAdaptiveBindPacing=ibmappnNodeAdaptiveBindPacing, ibmappnNnTgRsn=ibmappnNnTgRsn, ibmappnNodePortDlcTracIndex=ibmappnNodePortDlcTracIndex, ibmappnNnTopoTgPurges=ibmappnNnTopoTgPurges, ibmappnNodePortDlcTracMsgType=ibmappnNodePortDlcTracMsgType, ibmappnNodePortEntry=ibmappnNodePortEntry, ibmappnNodeLsIpTable=ibmappnNodeLsIpTable, ibmappnNnNodeEntryTimeLeft=ibmappnNnNodeEntryTimeLeft, ibmappnNodeNnCentralDirectory=ibmappnNodeNnCentralDirectory, ibmappnNodePortDlsTable=ibmappnNodePortDlsTable, ibmappnNode=ibmappnNode, ibmappnNodeLsStatusXidLocalSense=ibmappnNodeLsStatusXidLocalSense, ibmappnLocalTgByteCost=ibmappnLocalTgByteCost, ibmappnCosNodeRowWgt=ibmappnCosNodeRowWgt, ibmappnNodeEnLocateCdinit=ibmappnNodeEnLocateCdinit, ibmappnCosTgRowSecurityMax=ibmappnCosTgRowSecurityMax, ibmappnNnTgDelay=ibmappnNnTgDelay, ibmappnNnAdjNodeOutOfSeqTdus=ibmappnNnAdjNodeOutOfSeqTdus, ibmappnCosTgRowEffCapMax=ibmappnCosTgRowEffCapMax, ibmappnDirLocateOutstands=ibmappnDirLocateOutstands, ibmappnCosTgRowUsr3Min=ibmappnCosTgRowUsr3Min, ibmappnNodePortDlcTraceTable=ibmappnNodePortDlcTraceTable, ibmappnNodeDynLsGoodXids=ibmappnNodeDynLsGoodXids, ibmappnNnTgByteCost=ibmappnNnTgByteCost, ibmappnNnTopoRouteCalcs=ibmappnNnTopoRouteCalcs, ibmappnNodePortDynLsBadXids=ibmappnNodePortDynLsBadXids, ibmappnNodeLsBlockNum=ibmappnNodeLsBlockNum, ibmappnDirOutLocates=ibmappnDirOutLocates, ibmappnNodeLsTrTable=ibmappnNodeLsTrTable, ibmappnNnNodeFRGateway=ibmappnNnNodeFRGateway, ibmappnLocalEnTgOperational=ibmappnLocalEnTgOperational, ibmappnNnTopoOutTdus=ibmappnNnTopoOutTdus, ibmappnCosTgRowWgt=ibmappnCosTgRowWgt, ibmappnCosModeName=ibmappnCosModeName, ibmappnNodeNnTreeCache=ibmappnNodeNnTreeCache, ibmappnLocalTgTable=ibmappnLocalTgTable, ibmappnNnTgUsr1=ibmappnNnTgUsr1, ibmappnNodeLsTrName=ibmappnNodeLsTrName, ibmappnNnNodeFRCentralDirectory=ibmappnNnNodeFRCentralDirectory, ibmappnNodeLsDlsName=ibmappnNodeLsDlsName, ibmappnNodeEnSegGen=ibmappnNodeEnSegGen, ibmappnNodeLsBadXids=ibmappnNodeLsBadXids, ibmappnNnTgFRDelay=ibmappnNnTgFRDelay, ibmappnNodePortTable=ibmappnNodePortTable, ibmappnNodePortDlcTracUseWan=ibmappnNodePortDlcTracUseWan, ibmappnNodeLsByteCost=ibmappnNodeLsByteCost, ibmappnNodeLsSubState=ibmappnNodeLsSubState, ibmappnNnTgFrsn=ibmappnNnTgFrsn, ibmappnNodeLsIdNum=ibmappnNodeLsIdNum, ibmappnMemoryUsed=ibmappnMemoryUsed, ibmappnLocalEnTgSecurity=ibmappnLocalEnTgSecurity, ibmappnNodeLsStatusDlcType=ibmappnNodeLsStatusDlcType, ibmappnNodeLsStatusNodeId=ibmappnNodeLsStatusNodeId, ibmappnLocalTgEffCap=ibmappnLocalTgEffCap, ibmappnLocalEnTopology=ibmappnLocalEnTopology, ibmappnLocalTgRsn=ibmappnLocalTgRsn, ibmappnLocalTgDlcData=ibmappnLocalTgDlcData, ibmappnNodePortMaxIframeWindow=ibmappnNodePortMaxIframeWindow, ibmappnLocalTgSecurity=ibmappnLocalTgSecurity, ibmappnLocalTgUsr2=ibmappnLocalTgUsr2, ibmappnNnUniqueInfoAndCaps=ibmappnNnUniqueInfoAndCaps, ibmappnNodeSegReasm=ibmappnNodeSegReasm, ibmappnNodePortDlcTracCmdType=ibmappnNodePortDlcTracCmdType, ibmappnLocalTgDestVirtual=ibmappnLocalTgDestVirtual, ibmappnNodeLsStartTime=ibmappnNodeLsStartTime, ibmappnNodeLsRemoteTrSap=ibmappnNodeLsRemoteTrSap, ibmappnNnAdjNodeEntry=ibmappnNnAdjNodeEntry, ibmappnNodePortSpecific=ibmappnNodePortSpecific, ibmappnNnTopoMaxNodes=ibmappnNnTopoMaxNodes, ibmappnDirInBcastLocates=ibmappnDirInBcastLocates, ibmappnLocalEnTgEffCap=ibmappnLocalEnTgEffCap, ibmappnNodeBlockNum=ibmappnNodeBlockNum, ibmappnNodeUpTime=ibmappnNodeUpTime, ibmappnDirCurHomeEntries=ibmappnDirCurHomeEntries, ibmappnLocalEnEntryTimeLeft=ibmappnLocalEnEntryTimeLeft, ibmappnNnTgFRModemClass=ibmappnNnTgFRModemClass, ibmappnNodeLsDelay=ibmappnNodeLsDelay, ibmappnNodePortDlsSap=ibmappnNodePortDlsSap, ibmappnLocalTgNum=ibmappnLocalTgNum, ibmappnNnTopoRouteEntry=ibmappnNnTopoRouteEntry, ibmappnNnTgTopologyEntry=ibmappnNnTgTopologyEntry, ibmappnLocalEnTable=ibmappnLocalEnTable, ibmappnNnNodeFRName=ibmappnNnNodeFRName, ibmappnNnTgFRFrsn=ibmappnNnTgFRFrsn, ibmappnLocalEnTgUsr1=ibmappnLocalEnTgUsr1, ibmappnNodeLsLimResource=ibmappnNodeLsLimResource, ibmappnNodePortDefLsBadXids=ibmappnNodePortDefLsBadXids, ibmappnNnTopoTotalRouteCalcs=ibmappnNnTopoTotalRouteCalcs, ibmappnNodeLsStatusEndSense=ibmappnNodeLsStatusEndSense, ibmappnNnNodeFRQuiescing=ibmappnNnNodeFRQuiescing, ibmappnNnTgNum=ibmappnNnTgNum, ibmappnLocalNnQuiescing=ibmappnLocalNnQuiescing, ibmappnNodeLsName=ibmappnNodeLsName, ibmappnNodeLsOutXidFrames=ibmappnNodeLsOutXidFrames, ibmappnNnTgFRNum=ibmappnNnTgFRNum, ibmappnNodeLsStatusRemoteAddr=ibmappnNodeLsStatusRemoteAddr, ibmappnNnTgFRUsr2=ibmappnNnTgFRUsr2, ibmappn=ibmappn, ibmappnNodePortLsRole=ibmappnNodePortLsRole, ibmappnNodeLsStatusLocalAddr=ibmappnNodeLsStatusLocalAddr, ibmappnNnTopoRouteCos=ibmappnNnTopoRouteCos, ibmappnNodeLsOutXidBytes=ibmappnNodeLsOutXidBytes, ibmappnDirRegEntries=ibmappnDirRegEntries, ibmappnNodePortDlcTraceEntry=ibmappnNodePortDlcTraceEntry, ibmappnNodeDynLsBadXids=ibmappnNodeDynLsBadXids, ibmappnCosModeCosName=ibmappnCosModeCosName, ibmappnNodeLsOutMsgBytes=ibmappnNodeLsOutMsgBytes, ibmappnLocalTopology=ibmappnLocalTopology, ibmappnNnTgFRRsn=ibmappnNnTgFRRsn, ibmappnNnTopoTgLowRsns=ibmappnNnTopoTgLowRsns, ibmappnNodeIdNum=ibmappnNodeIdNum, ibmappnNnTgUsr3=ibmappnNnTgUsr3, ibmappnNnNodeFRCongested=ibmappnNnNodeFRCongested)

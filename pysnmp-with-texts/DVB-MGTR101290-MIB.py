#
# PySNMP MIB module DVB-MGTR101290-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/DVB-MGTR101290-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:54:58 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint")
ModuleCompliance, ObjectGroup, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "ObjectGroup", "NotificationGroup")
Integer32, Gauge32, MibScalar, MibTable, MibTableRow, MibTableColumn, ModuleIdentity, NotificationType, enterprises, iso, Bits, Counter64, ObjectIdentity, TimeTicks, MibIdentifier, IpAddress, Counter32, Unsigned32 = mibBuilder.importSymbols("SNMPv2-SMI", "Integer32", "Gauge32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ModuleIdentity", "NotificationType", "enterprises", "iso", "Bits", "Counter64", "ObjectIdentity", "TimeTicks", "MibIdentifier", "IpAddress", "Counter32", "Unsigned32")
DateAndTime, TruthValue, DisplayString, RowStatus, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DateAndTime", "TruthValue", "DisplayString", "RowStatus", "TextualConvention")
tr101290 = ModuleIdentity((1, 3, 6, 1, 4, 1, 2696, 3, 2))
if mibBuilder.loadTexts: tr101290.setLastUpdated('200111071400Z')
if mibBuilder.loadTexts: tr101290.setOrganization('DVB')
if mibBuilder.loadTexts: tr101290.setContactInfo('DVB project European Broadcasting Union CH-1218 GRAND SACONNEX (Geneva) Switzerland Tel: +41 22 717 21 11 Fax: +41 22 717 24 81')
if mibBuilder.loadTexts: tr101290.setDescription('DVB Measurement Group MIB to support TR 101 290. This tr101290 module contains measurements defined in TR 101 290.')
class ActiveTime(TextualConvention, Unsigned32):
    description = "This is a monotonically increasing value in units of seconds that represents the total amount of time for which the instrument has been able to perform a particular test or measurement. The instrument might not be performing the test because some other error condition prevented it, because it was operating in a polled mode where it looked at one input at a time or because it had been placed in an inactive state for a while. 'Able to perform the test' corresponds to the TestState being either 'pass' or 'fail'. The existence of this attribute allows a management system to calculate a realistic errors per second value for any test."
    status = 'current'
    displayHint = 'd'

class Availability(TextualConvention, Integer32):
    description = 'Availability is used in the capabilities branch of the MIB to indicate whether the instrument is equipped to provide a specific test and/or measurement.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("notAvailable", 1), ("testAvailable", 2), ("measurementAvailable", 3), ("measurementAndTestAvailable", 4))

class BERMeasurementMethod(TextualConvention, Integer32):
    description = 'Indicates the method used for measuring BER before Viterbi decoding'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("iqSeparate", 1), ("iqCombined", 2))

class BitRateElement(TextualConvention, Integer32):
    reference = 'TR 101 290 5.3.3.1'
    description = 'The fundamental data unit that is being counted by the bit rate measurement algorithm.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("bit", 1), ("byte", 2), ("packet", 3), ("other", 4))

class DeliverySystemType(TextualConvention, Integer32):
    description = 'Specifies the physical delivery system used for a Transport Stream.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("unknown", 1), ("cable", 2), ("satellite", 3), ("terrestrial", 4))

class Enable(TextualConvention, Bits):
    description = "This type is used for the '...Enable' objects of tests and measurements. It determines whether the test is enabled and also which traps can be generated by this test/measurement. If the testEnable bit is zero, the test will not be performed and the failTrapEnable bit is ignored. If the testEnable bit is one, the test will be performed. Additionally, a testFailTrap or measurementFailTrap will be sent when the test state becomes 'fail'. The 'unknownTrapEnable' bit is only relevant to measurements. If it is set to one, a 'measurementUnknownTrap' will be sent when the '...MeasurementState' object becomes 'unknown'."
    status = 'current'
    namedValues = NamedValues(("testEnable", 0), ("failTrapEnable", 1), ("unknownTrapEnable", 2))

class FloatingPoint(TextualConvention, OctetString):
    description = "FloatingPoint provides a way of representing non-integer numbers in SNMP. Numbers are represented as a string of ASCII characters in the natural way. So for example, '3', '3.142' and '0.3142E1' are all valid numbers. The syntax for the string is as follows. [] enclose an optional element, | is the separator for a set of alternatives. () enclose syntax which is to be viewed as a unit. FloatingPoint ::= [Sign] (Float1 | Float2 | DigitSequence) [ExponentPart] Float1 ::= DigitSequence '.' [DigitSequence] Float2 ::= '.' DigitSequence DigitSequence ::= Digit [DigitSequence] ExponentPart ::= ('e' | 'E') [Sign] DigitSequence Digit ::= '0'..'9' Sign ::= '+' | '-'"
    status = 'current'
    displayHint = '63a'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(1, 63)

class GroupAvailability(TextualConvention, Integer32):
    description = "This is used in the tr101290Capability branch of the MIB to specify an agent's degree of support for a whole branch of the MIB. The individual values mean: noSupport no objects in this branch are available selectiveSupport some but not all objects are available, refer to the test table for further details completeSupport all objects defined in the stated revision of the MIB are available"
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("noSupport", 1), ("selectiveSupport", 2), ("completeSupport", 3))

class GuardInterval(TextualConvention, Integer32):
    reference = 'EN 300 744 section 4.1'
    description = 'Guard intervals as specified for DVB-T transmissions. interval1d4 means a guard interval of 1/4.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("interval1d4", 1), ("interval1d8", 2), ("interval1d16", 3), ("interval1d32", 4))

class Hierarchy(TextualConvention, Integer32):
    description = 'In DVB-T systems this is used to specify whether the transmission is hierarchical, and if so, the value of alpha.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("nonHierarchical", 1), ("hierarchicalAlphaOne", 2), ("hierarchicalAphaTwo", 3), ("hierarchicalAlphaFour", 4))

class IndexConsistencyTest(TextualConvention, Integer32):
    reference = 'TR 101 290 section 5.3.4'
    description = 'Index of consistency check tests'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1))
    namedValues = NamedValues(("tsIdCheck", 1))

class IndexMIPSyntaxTest(TextualConvention, Integer32):
    reference = 'TR 101 290 section 9.20'
    description = 'This assigns numbers to the MIP syntax tests. These numbers are then used as indexes into the MIP syntax table.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))
    namedValues = NamedValues(("mipTimingError", 1), ("mipStructureError", 2), ("mipPresenceError", 3), ("mipPointerError", 4), ("mipPeriodicityError", 5), ("mipTsRateError", 6))

class IndexPCRMeasurement(TextualConvention, Integer32):
    reference = 'TR 101 290 section 5.3.2'
    description = 'This assigns numbers to the PCR measurements. These numbers are then used as indexes into the PCR measurement table.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("pcrFO", 1), ("pcrDR", 2), ("pcrOJ", 3), ("pcrAC", 4))

class IndexServicePerformance(TextualConvention, Integer32):
    reference = 'TR 101 290 section 5.5'
    description = 'This assigns numbers to the Service Performance measurements. These numbers are then used as indexes into the Service Performance measurement table.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("serviceAvailability", 1), ("serviceDegradation", 2), ("serviceImpairments", 3))

class IndexTransportStreamTest(TextualConvention, Integer32):
    reference = 'TR 101 290 section 5.2'
    description = "IndexTransportStreamTest assigns a unique numerical value to each of the TR 101 290 Transport Stream tests in section 5.2. The number allocated is: priority * 1000 + test number * 10 + subtest Subtest is zero if there is no subtest. Subtest 'a' is numbered 1, 'b' is numbered 2 etc. The enumeration names are derived directly from the test names in TR 101 290 taking into account the syntax requirements of the MIB."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1010, 1020, 1031, 1040, 1051, 1060, 2010, 2020, 2031, 2032, 2040, 2050, 2060, 3011, 3012, 3020, 3030, 3041, 3051, 3052, 3061, 3062, 3063, 3070, 3080, 3090, 3100))
    namedValues = NamedValues(("tsSyncLoss", 1010), ("syncByteError", 1020), ("patError2", 1031), ("continuityCountError", 1040), ("pmtError2", 1051), ("pidError", 1060), ("transportError", 2010), ("crcError", 2020), ("pcrRepetitionError", 2031), ("pcrDiscontinuityError", 2032), ("pcrAccuracyError", 2040), ("ptsError", 2050), ("catError", 2060), ("nitActualError", 3011), ("nitOtherError", 3012), ("siRepetitionError", 3020), ("bufferError", 3030), ("unreferencedPID", 3041), ("sdtActualError", 3051), ("sdtOtherError", 3052), ("eitActualError", 3061), ("eitOtherError", 3062), ("eitPfError", 3063), ("rstError", 3070), ("tdtError", 3080), ("emptyBufferError", 3090), ("dataDelayError", 3100))

class InputNumber(TextualConvention, Integer32):
    description = 'InputNumber objects are used to select a specific Transport Stream input on a multi-input monitoring/measurement device. On a single input monitoring/measuring device, InputNumber objects will always have the value one.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 2147483647)

class MeasurementState(TextualConvention, Integer32):
    description = "MeasurementState is used to represent the state of a single measurement. 'disabled' means that the measurement has been disabled by setting the 'testEnable' bit in its ...Enable object to zero. 'unknown' means that the equipment cannot provide a value because of temporary circumstances, for example some other signal condition makes this measurement impossible. 'abnormal' means that the measurement value is incorrect for reasons connected with that measurement itself. For example the measurement may be out of range. A measurement value is still provided and users or managers with knowledge of the behaviour of this specific measuring equipment may be able to interpret the value. 'normal' means that the measurement is enabled and has been evaluated."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("disabled", 1), ("unknown", 2), ("normal", 3), ("abnormal", 4))

class Modulation(TextualConvention, Integer32):
    reference = 'TR 101 198 (BPSK) EN 300 421 (QPSK) EN 301 210 (8PSK, 16QAM) EN 300 429 (16QAM, 32QAM, 64QAM, 128QAM, 256QAM) EN 300 744 (QPSK, 16QAM, 64QAM, 16QAM/alpha=2, 64QAM/alpha=2, 16QAM/alpha=4, 64QAM/alpha=4) '
    description = 'Modulation systems used in RF transmissions'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))
    namedValues = NamedValues(("bpsk", 1), ("qpsk", 2), ("psk8", 3), ("qam16", 4), ("qam32", 5), ("qam64", 6), ("qam128", 7), ("qam256", 8), ("qam16Alpha2", 9), ("qam64Alpha2", 10), ("qam16Alpha4", 11), ("qam64Alpha4", 12))

class PIDPlusOne(TextualConvention, Integer32):
    reference = 'ISO 13818-1 2.1.32'
    description = 'An object of type PIDPlusOne represents an MPEG-2 PID number. The numeric value of the object is the PID + 1, to allow for its use as a table index.'
    status = 'current'
    displayHint = 'x'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 8192)

class PollingInterval(TextualConvention, Integer32):
    description = 'Objects of this type are used by the agent to indicate how often it internally updates the information related to a particular test or measurement. The manager can then adjust its polling behaviour accordingly. The polling interval should be interpreted by the manager as approximate. In practice the agent may update the information faster or slower than indicated depending on the circumstances. The meaning of the value is: positive - represents a normal value in milliseconds zero - the value is updated continuously negative - unknown or not applicable '
    status = 'current'

class RateStatus(TextualConvention, Integer32):
    description = 'RateStatus is used in trap control'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("disabled", 1), ("enabled", 2), ("enabledThrottled", 3))

class ServiceId(TextualConvention, Integer32):
    description = 'Allowed values of program_number/service_id. Note that zero is used in the PAT to represent the NIT PID and so will never occur as a service_id.'
    status = 'current'
    displayHint = 'x'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 65535)

class TerrestrialTransmissionMode(TextualConvention, Integer32):
    reference = 'EN 300 744 section 4.1'
    description = 'Transmission mode for DVB-T transmissions, specifies whether there are 2k or 8k carriers.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("mode2k", 1), ("mode8k", 2))

class TestState(TextualConvention, Integer32):
    description = "TestState is used to represent the state of a single test. 'disabled' means that the test has been disabled by setting the 'testEnable' bit of its ...Enable variable to zero. 'unknown' means that the equipment cannot provide a value for the state because of temporary circumstances (for example some other error makes this test impossible to evaluate). 'pass' means that the test is enabled, can be evaluated and is not failing. For a 'Status error', 'fail' means that the state of the input is currently in error. For an 'Event error', 'fail' means that an error event has occurred within the most recent persistence interval as defined by the 'controlEventPersistence' object."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("disabled", 1), ("unknown", 2), ("pass", 3), ("fail", 4))

class TestSummary(TextualConvention, Bits):
    description = "Bit String providing a status summary for all the tests defined in this MIB module. A bit is set to one if the state of that test is 'fail'. In several cases, a single bit summarises the results of a set of tests. In that case, if the state of any of the tests is 'fail', the bit is set to one. An example of this is 'bitratePID' where the single bit summarises whether all the PID bitrates are within range. To aid identification, the bits are numbered in the order in which the associated tests appear in the MIB. Other than this, there is no connection between the bit number and the OID of the test."
    status = 'current'
    namedValues = NamedValues(("tsTsSyncLoss", 0), ("tsSyncByteError", 1), ("tsPatError2", 2), ("tsContinuityCountError", 3), ("tsPmtError2", 4), ("tsPidError", 5), ("tsTransportError", 6), ("tsCrcError", 7), ("tsPcrRepetitionError", 8), ("tsPcrDiscontinuityError", 9), ("tsPcrAccuracyError", 10), ("tsPtsError", 11), ("tsCatError", 12), ("tsNitActualError", 13), ("tsNitOtherError", 14), ("tsSiRepetitionError", 15), ("tsBufferError", 16), ("tsUnreferencedPID", 17), ("tsSdtActualError", 18), ("tsSdtOtherError", 19), ("tsEitActualError", 20), ("tsEitOtherError", 21), ("tsEitPfError", 22), ("tsRstError", 23), ("tsTdtError", 24), ("tsEmptyBufferError", 25), ("tsDataDelayError", 26), ("pcrPcrFO", 27), ("pcrPcrDR", 28), ("pcrPcrOJ", 29), ("pcrPcrAC", 30), ("bitrateTransportStream", 31), ("bitrateService", 32), ("bitratePID", 33), ("tsTsConsistency", 34), ("performanceServiceAvailability", 35), ("performanceServiceDegradation", 36), ("performanceServiceImpairments", 37), ("csSysAvailability", 38), ("csLinkAvailability", 39), ("csBerRS", 40), ("csRFIFSignalPower", 41), ("csNoisePower", 42), ("csMer", 43), ("csSteMean", 44), ("csSteDeviation", 45), ("csCS", 46), ("csAI", 47), ("csQE", 48), ("csRTE", 49), ("csCI", 50), ("csPJ", 51), ("csSNR", 52), ("cNoiseMargin", 53), ("cEstNoiseMargin", 54), ("cSignQualMarT", 55), ("cEND", 56), ("cOutBandEmiss", 57), ("sBerViterbi", 58), ("sIfSpectrum", 59), ("tRFAccuracy", 60), ("tRFChannelWidth", 61), ("tSymbolLength", 62), ("tRFIFPower", 63), ("tRFIFSpectrum", 64), ("tEND", 65), ("tENF", 66), ("tENDLP", 67), ("tENFLP", 68), ("tLinearity", 69), ("tBerViterbi", 70), ("tBerViterbiLP", 71), ("tBerRS", 72), ("tBerRSLP", 73), ("tMER", 74), ("tSteMean", 75), ("tSteDeviation", 76), ("tCS", 77), ("tAI", 78), ("tQE", 79), ("tPJ", 80), ("tMipTimingError", 81), ("tMipStructureError", 82), ("tMipPresenceError", 83), ("tMipPointerError", 84), ("tMipPeriodicityError", 85), ("tMipTsRateError", 86), ("tSepEti", 87), ("tSepSeti", 88))

class TransportStreamID(TextualConvention, Integer32):
    description = 'Range of possible values for a transport_stream_id as found in the PAT.'
    status = 'current'
    displayHint = 'x'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 65535)

class UATMode(TextualConvention, Integer32):
    reference = 'TR 101 290 section 5.4.5'
    description = 'Method of determining the start and end of a period of Unavailable Time.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("nConsecutive", 1), ("rollingWindow", 2))

dvb = MibIdentifier((1, 3, 6, 1, 4, 1, 2696))
mg = MibIdentifier((1, 3, 6, 1, 4, 1, 2696, 3))
tr101290Objects = MibIdentifier((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1))
tr101290Control = MibIdentifier((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 1))
controlNow = MibScalar((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 1, 1), DateAndTime()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: controlNow.setStatus('current')
if mibBuilder.loadTexts: controlNow.setDescription('The current date and time at the location of the measurement equipment. It is highly desirable that the offset from UTC should be included. It is possible to set the time and date through this object, but it is expected that most systems will incorporate a more accurate method for doing this.')
controlEventPersistence = MibScalar((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 1, 2), FloatingPoint().clone('2')).setUnits('second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: controlEventPersistence.setStatus('current')
if mibBuilder.loadTexts: controlEventPersistence.setDescription("The persistence timer used with Event errors. An Event error test remains in the 'fail' state for this length of time after the occurrence of the Event.")
controlRFSystemTable = MibTable((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 1, 3), )
if mibBuilder.loadTexts: controlRFSystemTable.setStatus('current')
if mibBuilder.loadTexts: controlRFSystemTable.setDescription('Table which controls the RF modulation expected to be received on each input.')
controlRFSystemEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 1, 3, 1), ).setIndexNames((0, "DVB-MGTR101290-MIB", "rfSystemInputNumber"))
if mibBuilder.loadTexts: controlRFSystemEntry.setStatus('current')
if mibBuilder.loadTexts: controlRFSystemEntry.setDescription('Row specification')
rfSystemInputNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 1, 3, 1, 1), InputNumber())
if mibBuilder.loadTexts: rfSystemInputNumber.setStatus('current')
if mibBuilder.loadTexts: rfSystemInputNumber.setDescription('RF input whose mode of operation is to be set')
rfSystemDelivery = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 1, 3, 1, 2), DeliverySystemType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rfSystemDelivery.setStatus('current')
if mibBuilder.loadTexts: rfSystemDelivery.setDescription('The type of signal the instrument should expect at its input.')
controlSynchronizationTable = MibTable((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 1, 4), )
if mibBuilder.loadTexts: controlSynchronizationTable.setStatus('current')
if mibBuilder.loadTexts: controlSynchronizationTable.setDescription('Table reserved for future specification of synchronized timing.')
controlSynchronizationEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 1, 4, 1), ).setIndexNames((0, "DVB-MGTR101290-MIB", "controlSynchronizationInputNumber"))
if mibBuilder.loadTexts: controlSynchronizationEntry.setStatus('current')
if mibBuilder.loadTexts: controlSynchronizationEntry.setDescription('Row specification')
controlSynchronizationInputNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 1, 4, 1, 1), InputNumber())
if mibBuilder.loadTexts: controlSynchronizationInputNumber.setStatus('current')
if mibBuilder.loadTexts: controlSynchronizationInputNumber.setDescription('Transport Stream number to which the objects in this row apply.')
controlSynchronizedTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 1, 4, 1, 2), FloatingPoint()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: controlSynchronizedTime.setStatus('current')
if mibBuilder.loadTexts: controlSynchronizedTime.setDescription('This object is reserved pending future standardisation of timestamping of Transport Streams. ')
tr101290Trap = MibIdentifier((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 2))
trapPrefix = MibIdentifier((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 2, 0))
testFailTrap = NotificationType((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 2, 0, 1)).setObjects(("DVB-MGTR101290-MIB", "trapControlOID"), ("DVB-MGTR101290-MIB", "trapControlGenerationTime"), ("DVB-MGTR101290-MIB", "trapControlFailureSummary"), ("DVB-MGTR101290-MIB", "trapInput"))
if mibBuilder.loadTexts: testFailTrap.setStatus('current')
if mibBuilder.loadTexts: testFailTrap.setDescription("This trap is sent when a test which is not associated with a measurement fails. This trap is triggered by the transition of the '...State' or '...TestState' object associated with the test to the 'fail' state from any other state. Transmission of the trap is subject to rate control and to the enable status of each test.")
measurementFailTrap = NotificationType((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 2, 0, 2)).setObjects(("DVB-MGTR101290-MIB", "trapControlOID"), ("DVB-MGTR101290-MIB", "trapControlGenerationTime"), ("DVB-MGTR101290-MIB", "trapControlMeasurementValue"), ("DVB-MGTR101290-MIB", "trapControlFailureSummary"), ("DVB-MGTR101290-MIB", "trapInput"))
if mibBuilder.loadTexts: measurementFailTrap.setStatus('current')
if mibBuilder.loadTexts: measurementFailTrap.setDescription("Trap which is sent when a test which is associated with a measurement fails. This trap is triggered by the transition of the '...State' or '...TestState' object associated with the test to the 'fail' state from any other state. Transmission of the trap is subject to rate control and to the enable status of each test.")
measurementUnknownTrap = NotificationType((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 2, 0, 3)).setObjects(("DVB-MGTR101290-MIB", "trapControlOID"), ("DVB-MGTR101290-MIB", "trapControlGenerationTime"), ("DVB-MGTR101290-MIB", "trapControlFailureSummary"), ("DVB-MGTR101290-MIB", "trapInput"))
if mibBuilder.loadTexts: measurementUnknownTrap.setStatus('current')
if mibBuilder.loadTexts: measurementUnknownTrap.setDescription("Trap which is sent when a measurement value becomes unavailable. This trap is triggered by the transition of the '...MeasurementState' object associated with the measurement to the 'unknown' state from any other state. Transmission of the trap is subject to rate control.")
trapControlTable = MibTable((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 2, 1), )
if mibBuilder.loadTexts: trapControlTable.setStatus('current')
if mibBuilder.loadTexts: trapControlTable.setDescription('Table of trap control information for each input')
trapControlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 2, 1, 1), ).setIndexNames((0, "DVB-MGTR101290-MIB", "trapControlInputNumber"))
if mibBuilder.loadTexts: trapControlEntry.setStatus('current')
if mibBuilder.loadTexts: trapControlEntry.setDescription('Row specification')
trapControlInputNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 2, 1, 1, 1), InputNumber())
if mibBuilder.loadTexts: trapControlInputNumber.setStatus('current')
if mibBuilder.loadTexts: trapControlInputNumber.setDescription('Each Transport Stream input has separate trap control parameters. This object identifies the Transport Stream input to which the trap control parameters apply')
trapControlOID = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 2, 1, 1, 2), ObjectIdentifier()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: trapControlOID.setStatus('current')
if mibBuilder.loadTexts: trapControlOID.setDescription("In the case of a testFailTrap or a measurementFailTrap, this object holds the OID of the '...State' or '...TestState' object whose transition to 'fail' has triggered the trap. In the case of a measurementUnknownTrap, this object holds the OID of the '...MeasurementState' object whose transition to 'unknown' has triggered the trap. This object is present for the formal purpose of defining the variable bindings returned with the traps. It is not accessible for normal reading.")
trapControlGenerationTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 2, 1, 1, 3), DateAndTime()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: trapControlGenerationTime.setStatus('current')
if mibBuilder.loadTexts: trapControlGenerationTime.setDescription("In the case of a testFailTrap or a measurementFailTrap, at the moment when the trap is generated, the value of the '...LatestError' object associated with the test which caused the trap is copied here. In the case of a measurementUnknownTrap, the time at which the measurement became unknown is copied here. This object is present for the formal purpose of defining the variable bindings returned with the traps. It is not accessible for normal reading.")
trapControlMeasurementValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 2, 1, 1, 4), FloatingPoint()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: trapControlMeasurementValue.setStatus('current')
if mibBuilder.loadTexts: trapControlMeasurementValue.setDescription("At the moment when a measurementFailTrap is generated, the value of this object is set from the '...Value' object associated with the measurement which caused the trap. Where a measurement returns multiple values, the value which is copied here is the one which is compared with the threshold(s) to generate the test result. The measurement units are the same as those of the source object. This object is present for the formal purpose of defining the variable bindings returned with the traps. It is not accessible for normal reading.")
trapControlRateStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 2, 1, 1, 5), RateStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trapControlRateStatus.setStatus('current')
if mibBuilder.loadTexts: trapControlRateStatus.setDescription("This object is used for rate control of traps, preventing overload of the management network by transmission of an excessive number of traps. The value 'disabled' means that traps are never sent. The value 'enabled' means that a trap will be sent when triggered. When a trap is sent, the agent changes the value of this object to 'enabledThrottled'. In this state the agent will not send any more traps. The agent automatically changes the value back to 'enabled' when the time specified by trapControlPeriod expires. A management application may set the value to 'enabled' at any time, but must never set the value to 'enabledThrottled'. This single status applies to all the trap types, so for example if an agent sends a testFailTrap it will not send a measurementFailTrap until the trapControlPeriod expires.")
trapControlPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 2, 1, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 3600000))).setUnits('millisecond').setMaxAccess("readwrite")
if mibBuilder.loadTexts: trapControlPeriod.setStatus('current')
if mibBuilder.loadTexts: trapControlPeriod.setDescription("An agent will ensure that the interval between sending traps is no shorter than this time period. The management system can override this by setting trapControlRateStatus back to 'enabled' within the time period.")
trapControlFailureSummary = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 2, 1, 1, 7), TestSummary()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trapControlFailureSummary.setStatus('current')
if mibBuilder.loadTexts: trapControlFailureSummary.setDescription('This bit string contains a summary of all the test failures. If the bit for the test is set to one, that test is in a fail state. When a trap is being generated, the agent should ensure that this information is as up to date as possible, without causing undue delay in sending the trap.')
trapInput = MibScalar((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 2, 2), InputNumber()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: trapInput.setStatus('current')
if mibBuilder.loadTexts: trapInput.setDescription('The Transport Stream input whose change triggered the current trap. This information can also be obtained by analysing the trapControlOID, but trapInput provides the information directly. This object is present for the formal purpose of defining the variable bindings returned with the traps. It is not accessible for normal reading.')
tr101290Capability = MibIdentifier((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 3))
capabilityMIBRevision = MibScalar((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 3, 1), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: capabilityMIBRevision.setStatus('current')
if mibBuilder.loadTexts: capabilityMIBRevision.setDescription('The capabilities of the agent are expressed in relation to a specific revision of the tr101290 MIB module. The date and time here must exactly match one of the revision dates in the MODULE-IDENTITY section of the MIB.')
capabilityTS = MibIdentifier((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 3, 5))
capabilityTSGroup = MibScalar((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 3, 5, 1), GroupAvailability()).setMaxAccess("readonly")
if mibBuilder.loadTexts: capabilityTSGroup.setStatus('current')
if mibBuilder.loadTexts: capabilityTSGroup.setDescription('Specifies the overall availability of the Transport Stream group of tests and measurements, tr101290TS.')
capabilityTSTable = MibTable((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 3, 5, 2), )
if mibBuilder.loadTexts: capabilityTSTable.setStatus('current')
if mibBuilder.loadTexts: capabilityTSTable.setDescription('Specifies the individual availability of the Transport Stream group of tests and measurements, tr101290TS.')
capabilityTSEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 3, 5, 2, 1), ).setIndexNames((0, "DVB-MGTR101290-MIB", "capabilityTSOID"))
if mibBuilder.loadTexts: capabilityTSEntry.setStatus('current')
if mibBuilder.loadTexts: capabilityTSEntry.setDescription('Row specification')
capabilityTSOID = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 3, 5, 2, 1, 1), ObjectIdentifier())
if mibBuilder.loadTexts: capabilityTSOID.setStatus('current')
if mibBuilder.loadTexts: capabilityTSOID.setDescription("The object identifier of a specific test/measurement. The object identifier of the object within the table whose SYNTAX is 'TestState' is used to identify the test/measurement. Table index components of the object identifier are set to zero, except for those which identify specific tests/measurements. Such index objects always have a syntax which begins 'Index...' in this MIB.")
capabilityTSAvailability = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 3, 5, 2, 1, 2), Availability()).setMaxAccess("readonly")
if mibBuilder.loadTexts: capabilityTSAvailability.setStatus('current')
if mibBuilder.loadTexts: capabilityTSAvailability.setDescription('The availability of a specific test or measurement')
capabilityTSPollInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 3, 5, 2, 1, 3), PollingInterval()).setUnits('millisecond').setMaxAccess("readonly")
if mibBuilder.loadTexts: capabilityTSPollInterval.setStatus('current')
if mibBuilder.loadTexts: capabilityTSPollInterval.setDescription('Indicates the interval between updates of the information supplied by this object.')
capabilityCableSat = MibIdentifier((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 3, 6))
capabilityCableSatGroup = MibScalar((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 3, 6, 1), GroupAvailability()).setMaxAccess("readonly")
if mibBuilder.loadTexts: capabilityCableSatGroup.setStatus('current')
if mibBuilder.loadTexts: capabilityCableSatGroup.setDescription('Specifies the overall availability of the cable and satellite group of tests and measurements, tr101290CableSat.')
capabilityCableSatTable = MibTable((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 3, 6, 2), )
if mibBuilder.loadTexts: capabilityCableSatTable.setStatus('current')
if mibBuilder.loadTexts: capabilityCableSatTable.setDescription('Specifies the individual availability of the cable and satellite group of tests and measurements, tr101290CableSat.')
capabilityCableSatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 3, 6, 2, 1), ).setIndexNames((0, "DVB-MGTR101290-MIB", "capabilityCableSatOID"))
if mibBuilder.loadTexts: capabilityCableSatEntry.setStatus('current')
if mibBuilder.loadTexts: capabilityCableSatEntry.setDescription('Row specification')
capabilityCableSatOID = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 3, 6, 2, 1, 1), ObjectIdentifier())
if mibBuilder.loadTexts: capabilityCableSatOID.setStatus('current')
if mibBuilder.loadTexts: capabilityCableSatOID.setDescription("The object identifier of a specific test/measurement. The object identifier of the object within the table whose SYNTAX is 'TestState' is used to identify the test/measurement. Table index components of the object identifier are set to zero, except for those which identify specific tests/measurements. Such index objects always have a syntax which begins 'Index...' in this MIB.")
capabilityCableSatAvailability = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 3, 6, 2, 1, 2), Availability()).setMaxAccess("readonly")
if mibBuilder.loadTexts: capabilityCableSatAvailability.setStatus('current')
if mibBuilder.loadTexts: capabilityCableSatAvailability.setDescription('The availability of a specific test or measurement')
capabilityCableSatPollInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 3, 6, 2, 1, 3), PollingInterval()).setUnits('millisecond').setMaxAccess("readonly")
if mibBuilder.loadTexts: capabilityCableSatPollInterval.setStatus('current')
if mibBuilder.loadTexts: capabilityCableSatPollInterval.setDescription('Indicates the interval between updates of the information supplied by this object.')
capabilityCable = MibIdentifier((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 3, 7))
capabilityCableGroup = MibScalar((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 3, 7, 1), GroupAvailability()).setMaxAccess("readonly")
if mibBuilder.loadTexts: capabilityCableGroup.setStatus('current')
if mibBuilder.loadTexts: capabilityCableGroup.setDescription('Specifies the overall availability of the cable group of tests and measurements, tr101290Cable.')
capabilityCableTable = MibTable((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 3, 7, 2), )
if mibBuilder.loadTexts: capabilityCableTable.setStatus('current')
if mibBuilder.loadTexts: capabilityCableTable.setDescription('Specifies the individual availability of the cable group of tests and measurements, tr101290Cable.')
capabilityCableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 3, 7, 2, 1), ).setIndexNames((0, "DVB-MGTR101290-MIB", "capabilityCableOID"))
if mibBuilder.loadTexts: capabilityCableEntry.setStatus('current')
if mibBuilder.loadTexts: capabilityCableEntry.setDescription('Row specification')
capabilityCableOID = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 3, 7, 2, 1, 1), ObjectIdentifier())
if mibBuilder.loadTexts: capabilityCableOID.setStatus('current')
if mibBuilder.loadTexts: capabilityCableOID.setDescription("The object identifier of a specific test/measurement. The object identifier of the object within the table whose SYNTAX is 'TestState' is used to identify the test/measurement. Table index components of the object identifier are set to zero, except for those which identify specific tests/measurements. Such index objects always have a syntax which begins 'Index...' in this MIB.")
capabilityCableAvailability = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 3, 7, 2, 1, 2), Availability()).setMaxAccess("readonly")
if mibBuilder.loadTexts: capabilityCableAvailability.setStatus('current')
if mibBuilder.loadTexts: capabilityCableAvailability.setDescription('The availability of a specific test or measurement')
capabilityCablePollInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 3, 7, 2, 1, 3), PollingInterval()).setUnits('millisecond').setMaxAccess("readonly")
if mibBuilder.loadTexts: capabilityCablePollInterval.setStatus('current')
if mibBuilder.loadTexts: capabilityCablePollInterval.setDescription('Indicates the interval between updates of the information supplied by this object.')
capabilitySatellite = MibIdentifier((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 3, 8))
capabilitySatelliteGroup = MibScalar((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 3, 8, 1), GroupAvailability()).setMaxAccess("readonly")
if mibBuilder.loadTexts: capabilitySatelliteGroup.setStatus('current')
if mibBuilder.loadTexts: capabilitySatelliteGroup.setDescription('Specifies the overall availability of the satellite group of tests and measurements, tr101290Satellite.')
capabilitySatelliteTable = MibTable((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 3, 8, 2), )
if mibBuilder.loadTexts: capabilitySatelliteTable.setStatus('current')
if mibBuilder.loadTexts: capabilitySatelliteTable.setDescription('Specifies the individual availability of the satellite group of tests and measurements, tr101290Satellite.')
capabilitySatelliteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 3, 8, 2, 1), ).setIndexNames((0, "DVB-MGTR101290-MIB", "capabilitySatelliteOID"))
if mibBuilder.loadTexts: capabilitySatelliteEntry.setStatus('current')
if mibBuilder.loadTexts: capabilitySatelliteEntry.setDescription('Row specification')
capabilitySatelliteOID = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 3, 8, 2, 1, 1), ObjectIdentifier())
if mibBuilder.loadTexts: capabilitySatelliteOID.setStatus('current')
if mibBuilder.loadTexts: capabilitySatelliteOID.setDescription("The object identifier of a specific test/measurement. The object identifier of the object within the table whose SYNTAX is 'TestState' is used to identify the test/measurement. Table index components of the object identifier are set to zero, except for those which identify specific tests/measurements. Such index objects always have a syntax which begins 'Index...' in this MIB.")
capabilitySatelliteAvailability = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 3, 8, 2, 1, 2), Availability()).setMaxAccess("readonly")
if mibBuilder.loadTexts: capabilitySatelliteAvailability.setStatus('current')
if mibBuilder.loadTexts: capabilitySatelliteAvailability.setDescription('The availability of a specific test or measurement')
capabilitySatellitePollInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 3, 8, 2, 1, 3), PollingInterval()).setUnits('millisecond').setMaxAccess("readonly")
if mibBuilder.loadTexts: capabilitySatellitePollInterval.setStatus('current')
if mibBuilder.loadTexts: capabilitySatellitePollInterval.setDescription('Indicates the interval between updates of the information supplied by this object.')
capabilityTerrestrial = MibIdentifier((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 3, 9))
capabilityTerrestrialGroup = MibScalar((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 3, 9, 1), GroupAvailability()).setMaxAccess("readonly")
if mibBuilder.loadTexts: capabilityTerrestrialGroup.setStatus('current')
if mibBuilder.loadTexts: capabilityTerrestrialGroup.setDescription('Specifies the overall availability of the terrestrial group of tests and measurements, tr101290Terrestrial.')
capabilityTerrestrialTable = MibTable((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 3, 9, 2), )
if mibBuilder.loadTexts: capabilityTerrestrialTable.setStatus('current')
if mibBuilder.loadTexts: capabilityTerrestrialTable.setDescription('Specifies the individual availability of the terrestrial group of tests and measurements, tr101290Terrestrial.')
capabilityTerrestrialEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 3, 9, 2, 1), ).setIndexNames((0, "DVB-MGTR101290-MIB", "capabilityTerrestrialOID"))
if mibBuilder.loadTexts: capabilityTerrestrialEntry.setStatus('current')
if mibBuilder.loadTexts: capabilityTerrestrialEntry.setDescription('Row specification')
capabilityTerrestrialOID = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 3, 9, 2, 1, 1), ObjectIdentifier())
if mibBuilder.loadTexts: capabilityTerrestrialOID.setStatus('current')
if mibBuilder.loadTexts: capabilityTerrestrialOID.setDescription("The object identifier of a specific test/measurement. The object identifier of the object within the table whose SYNTAX is 'TestState' is used to identify the test/measurement. Table index components of the object identifier are set to zero, except for those which identify specific tests/measurements. Such index objects always have a syntax which begins 'Index...' in this MIB.")
capabilityTerrestrialAvailability = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 3, 9, 2, 1, 2), Availability()).setMaxAccess("readonly")
if mibBuilder.loadTexts: capabilityTerrestrialAvailability.setStatus('current')
if mibBuilder.loadTexts: capabilityTerrestrialAvailability.setDescription('The availability of a specific test or measurement')
capabilityTerrestrialPollInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 3, 9, 2, 1, 3), PollingInterval()).setUnits('millisecond').setMaxAccess("readonly")
if mibBuilder.loadTexts: capabilityTerrestrialPollInterval.setStatus('current')
if mibBuilder.loadTexts: capabilityTerrestrialPollInterval.setDescription('Indicates the interval between updates of the information supplied by this object.')
tr101290TS = MibIdentifier((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5))
tsTests = MibIdentifier((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 2))
tsTestsSummaryTable = MibTable((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 2, 2), )
if mibBuilder.loadTexts: tsTestsSummaryTable.setReference('TR 101 290 section 5.2')
if mibBuilder.loadTexts: tsTestsSummaryTable.setStatus('current')
if mibBuilder.loadTexts: tsTestsSummaryTable.setDescription("The tsTestsSummaryTable provides access to the state of all of the Transport Stream tests enumerated in IndexTransportStreamTest. The status relates to the whole Transport Stream. In the case of tests which have a status per PID, the tsTestsSummaryTable gives the 'worst' status across all the PIDs and the status for each PID is available in tsTestsPIDTable.")
tsTestsSummaryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 2, 2, 1), ).setIndexNames((0, "DVB-MGTR101290-MIB", "tsTestsSummaryTestNumber"), (0, "DVB-MGTR101290-MIB", "tsTestsSummaryInputNumber"))
if mibBuilder.loadTexts: tsTestsSummaryEntry.setStatus('current')
if mibBuilder.loadTexts: tsTestsSummaryEntry.setDescription('Row specification')
tsTestsSummaryInputNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 2, 2, 1, 1), InputNumber())
if mibBuilder.loadTexts: tsTestsSummaryInputNumber.setStatus('current')
if mibBuilder.loadTexts: tsTestsSummaryInputNumber.setDescription('Transport Stream on which the test is made')
tsTestsSummaryTestNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 2, 2, 1, 2), IndexTransportStreamTest())
if mibBuilder.loadTexts: tsTestsSummaryTestNumber.setStatus('current')
if mibBuilder.loadTexts: tsTestsSummaryTestNumber.setDescription('Specifies the test, see definition of IndexTransportStreamTest. Rows in the table exist only for tests which are actually implemented by the measuring equipment.')
tsTestsSummaryState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 2, 2, 1, 3), TestState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsTestsSummaryState.setStatus('current')
if mibBuilder.loadTexts: tsTestsSummaryState.setDescription('This gives the overall pass/fail state of the test. For tests which have a state per PID, tsTestsSummaryState contains the highest numeric value of all the tsTestsPIDState objects for the test.')
tsTestsSummaryEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 2, 2, 1, 4), Enable().clone(namedValues=NamedValues(("testEnable", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tsTestsSummaryEnable.setStatus('current')
if mibBuilder.loadTexts: tsTestsSummaryEnable.setDescription('Determines whether this test and associated traps are enabled. Setting tsTestsSummaryEnable affects tsTestsPIDEnable in tsTestsPIDTable. When tsTestsSummaryEnable is set, all existing instances of tsTestsPIDEnable are set to the same value. Any new rows in tsTestsPIDTable which are created will also have this value for tsTestsPIDEnable (unless the row is created by explicitly setting the value of tsTestsPIDEnable).')
tsTestsSummaryCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 2, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsTestsSummaryCounter.setStatus('current')
if mibBuilder.loadTexts: tsTestsSummaryCounter.setDescription('Count of the number of times this error has occurred. For Status errors this is the number of times the TestState has entered the fail state from some other state. For Error events this is the total number of events; the persistence timer is not taken into account by the counter.')
tsTestsSummaryCounterDiscontinuity = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 2, 2, 1, 6), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsTestsSummaryCounterDiscontinuity.setStatus('current')
if mibBuilder.loadTexts: tsTestsSummaryCounterDiscontinuity.setDescription('Provides the last time at which there was a discontinuity in the tsTestsSummaryCounter object.')
tsTestsSummaryCounterReset = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 2, 2, 1, 7), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tsTestsSummaryCounterReset.setStatus('current')
if mibBuilder.loadTexts: tsTestsSummaryCounterReset.setDescription("tsTestsSummaryCounter is reset to zero and tsTestsSummaryCounterDiscontinuity is set to the current time if this object is set to 'true'. This object has no effect on the tsTestsPIDCounter objects.")
tsTestsSummaryLatestError = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 2, 2, 1, 8), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsTestsSummaryLatestError.setStatus('current')
if mibBuilder.loadTexts: tsTestsSummaryLatestError.setDescription('The timestamp at the most recent occurrence of the error. For Status errors this is the most recent time the TestState entered the fail state from some other state. For Error events this is the most recent occurrence; the persistence timer is not taken into account.')
tsTestsSummaryActiveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 2, 2, 1, 9), ActiveTime()).setUnits('second').setMaxAccess("readonly")
if mibBuilder.loadTexts: tsTestsSummaryActiveTime.setStatus('current')
if mibBuilder.loadTexts: tsTestsSummaryActiveTime.setDescription('The total time when it has been possible to evaluate this test.')
tsTestsPIDTable = MibTable((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 2, 3), )
if mibBuilder.loadTexts: tsTestsPIDTable.setReference('TR 101 290 section 5.2')
if mibBuilder.loadTexts: tsTestsPIDTable.setStatus('current')
if mibBuilder.loadTexts: tsTestsPIDTable.setDescription('The tsTestsPIDTable provides access to the state of those Transport Stream tests enumerated in IndexTransportStreamTest which relate to individual PIDs. These tests are: 1.4 Continuity_count_error 1.5.a PMT_error_2 1.6 PID_error 2.3.a PCR_repetition_error 2.3.b PCR_discontinuity_indicator_error 2.4 PCR_accuracy_error 2.5 PTS_error 3.3 Buffer_error 3.4.a Unreferenced_PID')
tsTestsPIDEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 2, 3, 1), ).setIndexNames((0, "DVB-MGTR101290-MIB", "tsTestsPIDPID"), (0, "DVB-MGTR101290-MIB", "tsTestsPIDTestNumber"), (0, "DVB-MGTR101290-MIB", "tsTestsPIDInputNumber"))
if mibBuilder.loadTexts: tsTestsPIDEntry.setStatus('current')
if mibBuilder.loadTexts: tsTestsPIDEntry.setDescription('Row specification')
tsTestsPIDInputNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 2, 3, 1, 1), InputNumber())
if mibBuilder.loadTexts: tsTestsPIDInputNumber.setStatus('current')
if mibBuilder.loadTexts: tsTestsPIDInputNumber.setDescription('Transport Stream on which the test is made')
tsTestsPIDPID = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 2, 3, 1, 2), PIDPlusOne())
if mibBuilder.loadTexts: tsTestsPIDPID.setStatus('current')
if mibBuilder.loadTexts: tsTestsPIDPID.setDescription('PID (plus one) on which the test is made')
tsTestsPIDTestNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 2, 3, 1, 3), IndexTransportStreamTest())
if mibBuilder.loadTexts: tsTestsPIDTestNumber.setStatus('current')
if mibBuilder.loadTexts: tsTestsPIDTestNumber.setDescription('Specifies the test, see definition of IndexTransportStreamTest. Rows in the table exist only for tests which are actually implemented by the measuring equipment.')
tsTestsPIDRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 2, 3, 1, 4), RowStatus().clone('active')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tsTestsPIDRowStatus.setReference('RFC 2579')
if mibBuilder.loadTexts: tsTestsPIDRowStatus.setStatus('current')
if mibBuilder.loadTexts: tsTestsPIDRowStatus.setDescription('This is used by the manager to create and delete rows in tsTestsPIDTable. The agent automatically creates rows for PID/test combinations where there are errors to report.')
tsTestsPIDState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 2, 3, 1, 5), TestState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsTestsPIDState.setStatus('current')
if mibBuilder.loadTexts: tsTestsPIDState.setDescription('This gives the overall pass/fail state of the test')
tsTestsPIDEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 2, 3, 1, 6), Enable().clone(namedValues=NamedValues(("testEnable", 0)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tsTestsPIDEnable.setStatus('current')
if mibBuilder.loadTexts: tsTestsPIDEnable.setDescription('Determines whether this test and associated traps are enabled. When a trap triggering condition arises for a per PID test, this object alone is used to determine whether a trap will be generated, without any reference to tsTestsSummaryEnable.')
tsTestsPIDCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 2, 3, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsTestsPIDCounter.setStatus('current')
if mibBuilder.loadTexts: tsTestsPIDCounter.setDescription('Count of the number of times this error has occurred. For Status errors this is the number of times the TestState has entered the fail state from some other state. For Error events this is the total number of events; the persistence timer is not taken into account by the counter.')
tsTestsPIDCounterDiscontinuity = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 2, 3, 1, 8), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsTestsPIDCounterDiscontinuity.setStatus('current')
if mibBuilder.loadTexts: tsTestsPIDCounterDiscontinuity.setDescription('Provides the last time at which there was a discontinuity in the tsTestsSummaryCounter object.')
tsTestsPIDCounterReset = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 2, 3, 1, 9), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tsTestsPIDCounterReset.setStatus('current')
if mibBuilder.loadTexts: tsTestsPIDCounterReset.setDescription("tsTestsPIDCounter is reset to zero and tsTestsPIDCounterDiscontinuity is set to the current time if 'true' is written to this variable. When read, the value of this object is always 'false'.")
tsTestsPIDLatestError = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 2, 3, 1, 10), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsTestsPIDLatestError.setStatus('current')
if mibBuilder.loadTexts: tsTestsPIDLatestError.setDescription('The timestamp at the most recent occurrence of the error. For Status errors this is the most recent time the TestState entered the fail state from some other state. For Error events this is the most recent occurrence; the persistence timer is not taken into account.')
tsTestsPIDActiveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 2, 3, 1, 11), ActiveTime()).setUnits('second').setMaxAccess("readonly")
if mibBuilder.loadTexts: tsTestsPIDActiveTime.setStatus('current')
if mibBuilder.loadTexts: tsTestsPIDActiveTime.setDescription('The total time when it has been possible to evaluate this test.')
tsTestsPreferences = MibIdentifier((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 2, 100))
tsTestsPreferencesTable = MibTable((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 2, 100, 1), )
if mibBuilder.loadTexts: tsTestsPreferencesTable.setStatus('current')
if mibBuilder.loadTexts: tsTestsPreferencesTable.setDescription('This table contains measurement thresholds and other configuration information that is applied on a per Transport Stream basis.')
tsTestsPreferencesEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 2, 100, 1, 1), ).setIndexNames((0, "DVB-MGTR101290-MIB", "tsTestsPrefInputNumber"))
if mibBuilder.loadTexts: tsTestsPreferencesEntry.setStatus('current')
if mibBuilder.loadTexts: tsTestsPreferencesEntry.setDescription('Row specification')
tsTestsPrefInputNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 2, 100, 1, 1, 1), InputNumber())
if mibBuilder.loadTexts: tsTestsPrefInputNumber.setStatus('current')
if mibBuilder.loadTexts: tsTestsPrefInputNumber.setDescription('Transport Stream input to which the preferences apply')
tsTestsPrefTransitionDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 2, 100, 1, 1, 2), FloatingPoint().clone('0.5')).setUnits('second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tsTestsPrefTransitionDuration.setReference('TR 101 290 section 5.2.3 NOTE 1')
if mibBuilder.loadTexts: tsTestsPrefTransitionDuration.setStatus('current')
if mibBuilder.loadTexts: tsTestsPrefTransitionDuration.setDescription('Various tests, including CAT_error (2.6) and Unreferenced_PID (3.4) must take into account that short transition periods can exist where the state of the SI and PSI information is inconsistent with the state of the stream. These transitions should not cause error indications. This parameter specifies the period which must be allowed for transition states.')
tsTestsPrefPATSectionIntervalMax = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 2, 100, 1, 1, 3), FloatingPoint().clone('0.5')).setUnits('second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tsTestsPrefPATSectionIntervalMax.setReference('TR 101 290 section 5.2.1 (PAT_error_2 1.3.a)')
if mibBuilder.loadTexts: tsTestsPrefPATSectionIntervalMax.setStatus('current')
if mibBuilder.loadTexts: tsTestsPrefPATSectionIntervalMax.setDescription('Maximum repetition interval for PAT sections.')
tsTestsPrefPMTSectionIntervalMax = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 2, 100, 1, 1, 4), FloatingPoint().clone('0.5')).setUnits('second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tsTestsPrefPMTSectionIntervalMax.setReference('TR 101 290 section 5.2.1 (PMT_error_2 1.5.a)')
if mibBuilder.loadTexts: tsTestsPrefPMTSectionIntervalMax.setStatus('current')
if mibBuilder.loadTexts: tsTestsPrefPMTSectionIntervalMax.setDescription('Maximum repetition interval for PMT sections.')
tsTestsPrefReferredIntervalMax = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 2, 100, 1, 1, 5), FloatingPoint().clone('5')).setUnits('s').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tsTestsPrefReferredIntervalMax.setReference('TR 101 290 section 5.2.1 (PID_error 1.6)')
if mibBuilder.loadTexts: tsTestsPrefReferredIntervalMax.setStatus('current')
if mibBuilder.loadTexts: tsTestsPrefReferredIntervalMax.setDescription('Maximum permitted interval between the arrival of consecutive packets for all PIDs. When the value of this object is set, the value of tsTestsPrefPIDReferredIntervalMax is changed for every PID. The value of this object is also used as a default for tsTestsPrefPIDReferredIntervalMax when a new row is created in tsTestsPreferencesPIDTable.')
tsTestsPrefPCRIntervalMax = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 2, 100, 1, 1, 6), FloatingPoint().clone('0.04')).setUnits('second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tsTestsPrefPCRIntervalMax.setReference('TR 101 290 section 5.2.2 (PCR_repetition_error 2.3.a)')
if mibBuilder.loadTexts: tsTestsPrefPCRIntervalMax.setStatus('current')
if mibBuilder.loadTexts: tsTestsPrefPCRIntervalMax.setDescription('Maximum permitted interval between PCR arrival times on each PCR PID.')
tsTestsPrefPCRDiscontinuityMax = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 2, 100, 1, 1, 7), FloatingPoint().clone('0.1')).setUnits('second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tsTestsPrefPCRDiscontinuityMax.setReference('TR 101 290 section 5.2.2 (PCR_discontinuity_indication_error 2.3.b)')
if mibBuilder.loadTexts: tsTestsPrefPCRDiscontinuityMax.setStatus('current')
if mibBuilder.loadTexts: tsTestsPrefPCRDiscontinuityMax.setDescription('Maximum permitted difference between two consecutive PCR values.')
tsTestsPrefPCRInaccuracyMax = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 2, 100, 1, 1, 8), FloatingPoint().clone('500E-9')).setUnits('second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tsTestsPrefPCRInaccuracyMax.setReference('TR 101 290 section 5.2.2 (PCR_accuracy_error 2.4)')
if mibBuilder.loadTexts: tsTestsPrefPCRInaccuracyMax.setStatus('current')
if mibBuilder.loadTexts: tsTestsPrefPCRInaccuracyMax.setDescription('Maximum permitted PCR inaccuracy. An error is indicated if the PCR inaccuracy is outside the range: [-tsTestsPrefPCRInaccuracyMax .. +tsTestsPrefPCRInaccuracyMax].')
tsTestsPrefPTSIntervalMax = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 2, 100, 1, 1, 9), FloatingPoint().clone('0.7')).setUnits('second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tsTestsPrefPTSIntervalMax.setReference('TR 101 290 section 5.2.2 (PTS_error 2.5)')
if mibBuilder.loadTexts: tsTestsPrefPTSIntervalMax.setStatus('current')
if mibBuilder.loadTexts: tsTestsPrefPTSIntervalMax.setDescription('Maximum permitted PTS repetition interval')
tsTestsPrefNITActualIntervalMax = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 2, 100, 1, 1, 10), FloatingPoint().clone('10')).setUnits('second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tsTestsPrefNITActualIntervalMax.setReference('TR 101 290 section 5.2.3 test 3.1.a')
if mibBuilder.loadTexts: tsTestsPrefNITActualIntervalMax.setStatus('current')
if mibBuilder.loadTexts: tsTestsPrefNITActualIntervalMax.setDescription('Maximum permitted NIT_actual section repetition interval')
tsTestsPrefNITActualIntervalMin = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 2, 100, 1, 1, 11), FloatingPoint().clone('0.025')).setUnits('second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tsTestsPrefNITActualIntervalMin.setReference('TR 101 290 section 5.2.3 test 3.1.a')
if mibBuilder.loadTexts: tsTestsPrefNITActualIntervalMin.setStatus('current')
if mibBuilder.loadTexts: tsTestsPrefNITActualIntervalMin.setDescription('Minimum permitted NIT_actual section repetition interval')
tsTestsPrefNITOtherIntervalMax = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 2, 100, 1, 1, 12), FloatingPoint().clone('10')).setUnits('second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tsTestsPrefNITOtherIntervalMax.setReference('TR 101 290 section 5.2.3 test 3.1.b')
if mibBuilder.loadTexts: tsTestsPrefNITOtherIntervalMax.setStatus('current')
if mibBuilder.loadTexts: tsTestsPrefNITOtherIntervalMax.setDescription('Maximum permitted NIT_other section repetition interval')
tsTestsPrefSIGapMin = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 2, 100, 1, 1, 13), FloatingPoint().clone('0.025')).setUnits('second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tsTestsPrefSIGapMin.setReference('TR 101 290 section 5.2.3 test 3.2 EN 300 468 section 5.1.4')
if mibBuilder.loadTexts: tsTestsPrefSIGapMin.setStatus('current')
if mibBuilder.loadTexts: tsTestsPrefSIGapMin.setDescription('Minimum permitted gap between packets containing sections.')
tsTestsPrefNITTableIntervalMax = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 2, 100, 1, 1, 14), FloatingPoint().clone('10')).setUnits('second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tsTestsPrefNITTableIntervalMax.setReference('TR 101 290 section 5.2.3 test 3.2 TR 101 211 section 4.4.1 a) and 4.4.2 a)')
if mibBuilder.loadTexts: tsTestsPrefNITTableIntervalMax.setStatus('current')
if mibBuilder.loadTexts: tsTestsPrefNITTableIntervalMax.setDescription('Maximum permitted NIT table repetition interval')
tsTestsPrefBATTableIntervalMax = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 2, 100, 1, 1, 15), FloatingPoint().clone('10')).setUnits('second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tsTestsPrefBATTableIntervalMax.setReference('TR 101 290 section 5.2.3 test 3.2 TR 101 211 section 4.4.1 b) and 4.4.2 b)')
if mibBuilder.loadTexts: tsTestsPrefBATTableIntervalMax.setStatus('current')
if mibBuilder.loadTexts: tsTestsPrefBATTableIntervalMax.setDescription('Maximum permitted BAT table repetition interval')
tsTestsPrefSDTActualTableIntervalMax = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 2, 100, 1, 1, 16), FloatingPoint().clone('2')).setUnits('second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tsTestsPrefSDTActualTableIntervalMax.setReference('TR 101 290 section 5.2.3 test 3.2 TR 101 211 section 4.4.1 c) and 4.4.2 c)')
if mibBuilder.loadTexts: tsTestsPrefSDTActualTableIntervalMax.setStatus('current')
if mibBuilder.loadTexts: tsTestsPrefSDTActualTableIntervalMax.setDescription('Maximum permitted SDT actual transport stream table repetition interval')
tsTestsPrefSDTOtherTableIntervalMax = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 2, 100, 1, 1, 17), FloatingPoint().clone('10')).setUnits('second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tsTestsPrefSDTOtherTableIntervalMax.setReference('TR 101 290 section 5.2.3 test 3.2 TR 101 211 section 4.4.1 d) and 4.4.2 d)')
if mibBuilder.loadTexts: tsTestsPrefSDTOtherTableIntervalMax.setStatus('current')
if mibBuilder.loadTexts: tsTestsPrefSDTOtherTableIntervalMax.setDescription('Maximum permitted SDT other transport stream table repetition interval')
tsTestsPrefEITPFActualTableIntervalMax = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 2, 100, 1, 1, 18), FloatingPoint().clone('2')).setUnits('second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tsTestsPrefEITPFActualTableIntervalMax.setReference('TR 101 290 section 5.2.3 test 3.2 TR 101 211 section 4.4.1 e) and 4.4.2 e:')
if mibBuilder.loadTexts: tsTestsPrefEITPFActualTableIntervalMax.setStatus('current')
if mibBuilder.loadTexts: tsTestsPrefEITPFActualTableIntervalMax.setDescription('Maximum permitted EIT Present/Following actual transport stream table repetition interval')
tsTestsPrefEITPFOtherTableIntervalMax = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 2, 100, 1, 1, 19), FloatingPoint().clone('10')).setUnits('second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tsTestsPrefEITPFOtherTableIntervalMax.setReference('TR 101 290 section 5.2.3 test 3.2 TR 101 211 section 4.4.1 f) and 4.4.2 f)')
if mibBuilder.loadTexts: tsTestsPrefEITPFOtherTableIntervalMax.setStatus('current')
if mibBuilder.loadTexts: tsTestsPrefEITPFOtherTableIntervalMax.setDescription('Maximum permitted EIT Present/Following other transport stream table repetition interval')
tsTestsPrefEITSActualNearTableIntervalMax = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 2, 100, 1, 1, 20), FloatingPoint().clone('10')).setUnits('second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tsTestsPrefEITSActualNearTableIntervalMax.setReference('TR 101 290 section 5.2.3 test 3.2 TR 101 211 section 4.4.1 g) and 4.4.2 second a)')
if mibBuilder.loadTexts: tsTestsPrefEITSActualNearTableIntervalMax.setStatus('current')
if mibBuilder.loadTexts: tsTestsPrefEITSActualNearTableIntervalMax.setDescription('Maximum permitted EIT Schedule actual transport stream table repetition interval for the near future (the next 8 days for satellite and cable, the next day for terrestrial).')
tsTestsPrefEITSActualFarTableIntervalMax = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 2, 100, 1, 1, 21), FloatingPoint().clone('10')).setUnits('second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tsTestsPrefEITSActualFarTableIntervalMax.setReference('TR 101 290 section 5.2.3 test 3.2 TR 101 211 section 4.4.1 h) and 4.4.2 second c)')
if mibBuilder.loadTexts: tsTestsPrefEITSActualFarTableIntervalMax.setStatus('current')
if mibBuilder.loadTexts: tsTestsPrefEITSActualFarTableIntervalMax.setDescription('Maximum permitted EIT Schedule actual transport stream table repetition interval for the far future (beyond the next 8 days for satellite and cable, beyond the next day for terrestrial).')
tsTestsPrefEITSOtherNearTableIntervalMax = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 2, 100, 1, 1, 22), FloatingPoint().clone('10')).setUnits('second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tsTestsPrefEITSOtherNearTableIntervalMax.setReference('TR 101 290 section 5.2.3 test 3.2 TR 101 211 section 4.4.1 g) and 4.4.2 second b)')
if mibBuilder.loadTexts: tsTestsPrefEITSOtherNearTableIntervalMax.setStatus('current')
if mibBuilder.loadTexts: tsTestsPrefEITSOtherNearTableIntervalMax.setDescription('Maximum permitted EIT Schedule other transport stream table repetition interval for the near future (the next 8 days for satellite and cable, the next day for terrestrial).')
tsTestsPrefEITSOtherFarTableIntervalMax = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 2, 100, 1, 1, 23), FloatingPoint().clone('30')).setUnits('second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tsTestsPrefEITSOtherFarTableIntervalMax.setReference('TR 101 290 section 5.2.3 test 3.2 TR 101 211 section 4.4.1 h) and 4.4.2 second d)')
if mibBuilder.loadTexts: tsTestsPrefEITSOtherFarTableIntervalMax.setStatus('current')
if mibBuilder.loadTexts: tsTestsPrefEITSOtherFarTableIntervalMax.setDescription('Maximum permitted EIT Schedule other transport stream table repetition interval for the far future (beyond the next 8 days for satellite and cable, beyond the next day for terrestrial).')
tsTestsPrefTxTTableIntervalMax = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 2, 100, 1, 1, 24), FloatingPoint().clone('30')).setUnits('second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tsTestsPrefTxTTableIntervalMax.setReference('TR 101 290 section 5.2.3 test 3.2 TR 101 211 section 4.4.1 i) and 4.4.2 second e)')
if mibBuilder.loadTexts: tsTestsPrefTxTTableIntervalMax.setStatus('current')
if mibBuilder.loadTexts: tsTestsPrefTxTTableIntervalMax.setDescription('Maximum permitted TDT and TOT table repetition intervals')
tsTestsPrefSDTActualIntervalMax = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 2, 100, 1, 1, 25), FloatingPoint().clone('2')).setUnits('second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tsTestsPrefSDTActualIntervalMax.setReference('TR 101 290 section 5.2.3 test 3.5.a')
if mibBuilder.loadTexts: tsTestsPrefSDTActualIntervalMax.setStatus('current')
if mibBuilder.loadTexts: tsTestsPrefSDTActualIntervalMax.setDescription('Maximum permitted SDT_actual section repetition interval')
tsTestsPrefSDTActualIntervalMin = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 2, 100, 1, 1, 26), FloatingPoint().clone('0.025')).setUnits('second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tsTestsPrefSDTActualIntervalMin.setReference('TR 101 290 section 5.2.3 test 3.5.a')
if mibBuilder.loadTexts: tsTestsPrefSDTActualIntervalMin.setStatus('current')
if mibBuilder.loadTexts: tsTestsPrefSDTActualIntervalMin.setDescription('Minimum permitted SDT_actual section repetition interval')
tsTestsPrefSDTOtherIntervalMax = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 2, 100, 1, 1, 27), FloatingPoint().clone('10')).setUnits('second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tsTestsPrefSDTOtherIntervalMax.setReference('TR 101 290 section 5.2.3 test 3.5.b')
if mibBuilder.loadTexts: tsTestsPrefSDTOtherIntervalMax.setStatus('current')
if mibBuilder.loadTexts: tsTestsPrefSDTOtherIntervalMax.setDescription('Maximum permitted SDT_other section repetition interval')
tsTestsPrefEITActualIntervalMax = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 2, 100, 1, 1, 28), FloatingPoint().clone('2')).setUnits('second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tsTestsPrefEITActualIntervalMax.setReference('TR 101 290 section 5.2.3 test 3.6.a')
if mibBuilder.loadTexts: tsTestsPrefEITActualIntervalMax.setStatus('current')
if mibBuilder.loadTexts: tsTestsPrefEITActualIntervalMax.setDescription('Maximum permitted EIT_actual section repetition interval (applies to both present and following sections).')
tsTestsPrefEITActualIntervalMin = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 2, 100, 1, 1, 29), FloatingPoint().clone('0.025')).setUnits('second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tsTestsPrefEITActualIntervalMin.setReference('TR 101 290 section 5.2.3 test 3.5.a')
if mibBuilder.loadTexts: tsTestsPrefEITActualIntervalMin.setStatus('current')
if mibBuilder.loadTexts: tsTestsPrefEITActualIntervalMin.setDescription('Minimum permitted EIT_actual section repetition interval')
tsTestsPrefEITOtherIntervalMax = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 2, 100, 1, 1, 30), FloatingPoint().clone('10')).setUnits('second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tsTestsPrefEITOtherIntervalMax.setReference('TR 101 290 section 5.2.3 test 3.6.b')
if mibBuilder.loadTexts: tsTestsPrefEITOtherIntervalMax.setStatus('current')
if mibBuilder.loadTexts: tsTestsPrefEITOtherIntervalMax.setDescription('Maximum permitted EIT_other section repetition interval (applies to both present and following sections).')
tsTestsPrefRSTIntervalMin = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 2, 100, 1, 1, 31), FloatingPoint().clone('0.025')).setUnits('second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tsTestsPrefRSTIntervalMin.setReference('TR 101 290 section 5.2.3 test 3.7')
if mibBuilder.loadTexts: tsTestsPrefRSTIntervalMin.setStatus('current')
if mibBuilder.loadTexts: tsTestsPrefRSTIntervalMin.setDescription('Minimum permitted RST section repetition interval')
tsTestsPrefTDTIntervalMax = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 2, 100, 1, 1, 32), FloatingPoint().clone('10')).setUnits('second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tsTestsPrefTDTIntervalMax.setReference('TR 101 290 section 5.2.3 test 3.8')
if mibBuilder.loadTexts: tsTestsPrefTDTIntervalMax.setStatus('current')
if mibBuilder.loadTexts: tsTestsPrefTDTIntervalMax.setDescription('Maximum permitted TDT section repetition interval')
tsTestsPrefTDTIntervalMin = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 2, 100, 1, 1, 33), FloatingPoint().clone('0.025')).setUnits('second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tsTestsPrefTDTIntervalMin.setReference('TR 101 290 section 5.2.3 test 3.8')
if mibBuilder.loadTexts: tsTestsPrefTDTIntervalMin.setStatus('current')
if mibBuilder.loadTexts: tsTestsPrefTDTIntervalMin.setDescription('Minimum permitted TDT section repetition interval')
tsTestsPreferencesPIDTable = MibTable((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 2, 100, 2), )
if mibBuilder.loadTexts: tsTestsPreferencesPIDTable.setStatus('current')
if mibBuilder.loadTexts: tsTestsPreferencesPIDTable.setDescription('This table contains measurement thresholds and other configuration information that is applied on a per PID per Transport Stream basis.')
tsTestsPreferencesPIDEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 2, 100, 2, 1), ).setIndexNames((0, "DVB-MGTR101290-MIB", "tsTestsPrefPIDInputNumber"), (0, "DVB-MGTR101290-MIB", "tsTestsPrefPIDPID"))
if mibBuilder.loadTexts: tsTestsPreferencesPIDEntry.setStatus('current')
if mibBuilder.loadTexts: tsTestsPreferencesPIDEntry.setDescription('Description.')
tsTestsPrefPIDInputNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 2, 100, 2, 1, 1), InputNumber())
if mibBuilder.loadTexts: tsTestsPrefPIDInputNumber.setStatus('current')
if mibBuilder.loadTexts: tsTestsPrefPIDInputNumber.setDescription('Transport Stream input to which the preferences apply')
tsTestsPrefPIDPID = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 2, 100, 2, 1, 2), PIDPlusOne())
if mibBuilder.loadTexts: tsTestsPrefPIDPID.setStatus('current')
if mibBuilder.loadTexts: tsTestsPrefPIDPID.setDescription('PID to which these preferences apply')
tsTestsPrefPIDRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 2, 100, 2, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tsTestsPrefPIDRowStatus.setStatus('current')
if mibBuilder.loadTexts: tsTestsPrefPIDRowStatus.setDescription('This object is used to manage the rows in this table.')
tsTestsPrefPIDReferredIntervalMax = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 2, 100, 2, 1, 4), FloatingPoint()).setUnits('second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tsTestsPrefPIDReferredIntervalMax.setReference('TR 101 290 section 5.2.1 (PID_error 1.6)')
if mibBuilder.loadTexts: tsTestsPrefPIDReferredIntervalMax.setStatus('current')
if mibBuilder.loadTexts: tsTestsPrefPIDReferredIntervalMax.setDescription('Maximum permitted interval between the arrival of consecutive packets of this PID. The default value for this object is the current value of tsTestsPrefReferredIntervalMax for the same input.')
tsMeasurements = MibIdentifier((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4))
tsPcrMeasurementTable = MibTable((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 1), )
if mibBuilder.loadTexts: tsPcrMeasurementTable.setReference('TR 101 290 section 5.3.2')
if mibBuilder.loadTexts: tsPcrMeasurementTable.setStatus('current')
if mibBuilder.loadTexts: tsPcrMeasurementTable.setDescription('This table makes available the PCR_FO, PCR_DR, PCR_OJ and PCR_AC measurements.')
tsPcrMeasurementEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 1, 1), ).setIndexNames((0, "DVB-MGTR101290-MIB", "tsPcrMeasurementPID"), (0, "DVB-MGTR101290-MIB", "tsPcrMeasurementNumber"), (0, "DVB-MGTR101290-MIB", "tsPcrMeasurementInputNumber"))
if mibBuilder.loadTexts: tsPcrMeasurementEntry.setStatus('current')
if mibBuilder.loadTexts: tsPcrMeasurementEntry.setDescription('Row specification')
tsPcrMeasurementInputNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 1, 1, 1), InputNumber())
if mibBuilder.loadTexts: tsPcrMeasurementInputNumber.setStatus('current')
if mibBuilder.loadTexts: tsPcrMeasurementInputNumber.setDescription('Input on which the measurement is made')
tsPcrMeasurementPID = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 1, 1, 2), PIDPlusOne())
if mibBuilder.loadTexts: tsPcrMeasurementPID.setStatus('current')
if mibBuilder.loadTexts: tsPcrMeasurementPID.setDescription('PID (plus one) in the Transport Stream carrying (or expected to carry) PCRs.')
tsPcrMeasurementNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 1, 1, 3), IndexPCRMeasurement())
if mibBuilder.loadTexts: tsPcrMeasurementNumber.setStatus('current')
if mibBuilder.loadTexts: tsPcrMeasurementNumber.setDescription('This selects one of the four PCR measurements')
tsPcrMeasurementRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 1, 1, 4), RowStatus().clone('active')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tsPcrMeasurementRowStatus.setReference('RFC 2579')
if mibBuilder.loadTexts: tsPcrMeasurementRowStatus.setStatus('current')
if mibBuilder.loadTexts: tsPcrMeasurementRowStatus.setDescription('This object is used by the manager to create and delete rows in the table. The agent automatically creates rows for PIDs where it detects the presence of a PCR.')
tsPcrMeasurementState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 1, 1, 5), TestState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsPcrMeasurementState.setStatus('current')
if mibBuilder.loadTexts: tsPcrMeasurementState.setDescription('This gives the overall pass/fail state of the threshold test on this measurement')
tsPcrMeasurementEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 1, 1, 6), Enable().clone(namedValues=NamedValues(("testEnable", 0)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tsPcrMeasurementEnable.setStatus('current')
if mibBuilder.loadTexts: tsPcrMeasurementEnable.setDescription('Determines whether this test and associated traps are enabled.')
tsPcrMeasurementCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsPcrMeasurementCounter.setStatus('current')
if mibBuilder.loadTexts: tsPcrMeasurementCounter.setDescription('Count of the number of times a threshold error has occurred for this measurement.')
tsPcrMeasurementCounterDiscontinuity = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 1, 1, 8), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsPcrMeasurementCounterDiscontinuity.setStatus('current')
if mibBuilder.loadTexts: tsPcrMeasurementCounterDiscontinuity.setDescription('Provides the last time at which there was a discontinuity in the tsPcrMeasurementCounter object.')
tsPcrMeasurementCounterReset = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 1, 1, 9), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tsPcrMeasurementCounterReset.setStatus('current')
if mibBuilder.loadTexts: tsPcrMeasurementCounterReset.setDescription("tsPcrMeasurementCounter is reset to zero and tsPcrMeasurementCounterDiscontinuity is set to the current time if 'true' is written to this variable. When read, the value of this object is always 'false'.")
tsPcrMeasurementLatestError = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 1, 1, 10), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsPcrMeasurementLatestError.setStatus('current')
if mibBuilder.loadTexts: tsPcrMeasurementLatestError.setDescription('The timestamp at the most recent occurrence of a threshold error on this measurement.')
tsPcrMeasurementActiveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 1, 1, 11), ActiveTime()).setUnits('second').setMaxAccess("readonly")
if mibBuilder.loadTexts: tsPcrMeasurementActiveTime.setStatus('current')
if mibBuilder.loadTexts: tsPcrMeasurementActiveTime.setDescription('The total time when it has been possible to make this measurement')
tsPcrMeasurementMeasurementState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 1, 1, 12), MeasurementState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsPcrMeasurementMeasurementState.setStatus('current')
if mibBuilder.loadTexts: tsPcrMeasurementMeasurementState.setDescription('Indicates the validity of the measurement')
tsPcrMeasurementValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 1, 1, 13), FloatingPoint()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsPcrMeasurementValue.setStatus('current')
if mibBuilder.loadTexts: tsPcrMeasurementValue.setDescription("The units for the measured value depend on the measurement: PCR_FO Hz PCR_DR Hz/s Values for PCR_OJ and PCR_AC are not provided as they occur too quickly to be usefully retrieved via SNMP. For these measurements, the MeasurementState is always 'unknown'. However, the threshold tests are expected to work correctly for these measurements.")
bitRate = MibIdentifier((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 2))
tsTransportStreamBitRateTable = MibTable((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 2, 1), )
if mibBuilder.loadTexts: tsTransportStreamBitRateTable.setReference('TR 101 290 section 5.3.3')
if mibBuilder.loadTexts: tsTransportStreamBitRateTable.setStatus('current')
if mibBuilder.loadTexts: tsTransportStreamBitRateTable.setDescription('Bit rates for each complete Transport Stream')
tsTransportStreamBitRateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 2, 1, 1), ).setIndexNames((0, "DVB-MGTR101290-MIB", "tsTransportStreamBitRateInputNumber"))
if mibBuilder.loadTexts: tsTransportStreamBitRateEntry.setStatus('current')
if mibBuilder.loadTexts: tsTransportStreamBitRateEntry.setDescription('Row specification')
tsTransportStreamBitRateInputNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 2, 1, 1, 1), InputNumber())
if mibBuilder.loadTexts: tsTransportStreamBitRateInputNumber.setStatus('current')
if mibBuilder.loadTexts: tsTransportStreamBitRateInputNumber.setDescription('Transport Stream on which the measurement is made')
tsTransportStreamBitRateState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 2, 1, 1, 2), TestState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsTransportStreamBitRateState.setStatus('current')
if mibBuilder.loadTexts: tsTransportStreamBitRateState.setDescription('This gives the overall pass/fail state of the threshold test on this measurement')
tsTransportStreamBitRateEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 2, 1, 1, 3), Enable()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tsTransportStreamBitRateEnable.setStatus('current')
if mibBuilder.loadTexts: tsTransportStreamBitRateEnable.setDescription('Determines whether the threshold test and associated traps for this measurement are enabled.')
tsTransportStreamBitRateCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 2, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsTransportStreamBitRateCounter.setStatus('current')
if mibBuilder.loadTexts: tsTransportStreamBitRateCounter.setDescription('Count of the number of times a threshold error has occurred for this measurement.')
tsTransportStreamBitRateCounterDiscontinuity = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 2, 1, 1, 5), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsTransportStreamBitRateCounterDiscontinuity.setStatus('current')
if mibBuilder.loadTexts: tsTransportStreamBitRateCounterDiscontinuity.setDescription('Provides the last time at which there was a discontinuity in the tsTransportStreamBitRateCounterobject.')
tsTransportStreamBitRateCounterReset = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 2, 1, 1, 6), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tsTransportStreamBitRateCounterReset.setStatus('current')
if mibBuilder.loadTexts: tsTransportStreamBitRateCounterReset.setDescription("tsTransportStreamBitRateCounteris reset to zero and tsTransportStreamBitRateCounterDiscontinuity is set to the current time if 'true' is written to this variable. When read, the value of this object is always 'false'.")
tsTransportStreamBitRateLatestError = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 2, 1, 1, 7), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsTransportStreamBitRateLatestError.setStatus('current')
if mibBuilder.loadTexts: tsTransportStreamBitRateLatestError.setDescription('The timestamp at the most recent occurrence of a threshold error on this measurement.')
tsTransportStreamBitRateActiveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 2, 1, 1, 8), ActiveTime()).setUnits('second').setMaxAccess("readonly")
if mibBuilder.loadTexts: tsTransportStreamBitRateActiveTime.setStatus('current')
if mibBuilder.loadTexts: tsTransportStreamBitRateActiveTime.setDescription('The total time when it has been possible to perform this measurement')
tsTransportStreamBitRateMeasurementState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 2, 1, 1, 9), MeasurementState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsTransportStreamBitRateMeasurementState.setStatus('current')
if mibBuilder.loadTexts: tsTransportStreamBitRateMeasurementState.setDescription('Indicates the validity of the measurement')
tsTransportStreamBitRateValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 2, 1, 1, 10), FloatingPoint()).setUnits('bit/s').setMaxAccess("readonly")
if mibBuilder.loadTexts: tsTransportStreamBitRateValue.setStatus('current')
if mibBuilder.loadTexts: tsTransportStreamBitRateValue.setDescription('The overall Transport Stream bit rate')
tsTransportStreamBitRateNomenclature = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 2, 1, 1, 11), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsTransportStreamBitRateNomenclature.setReference('TR 101 290 5.3.3.3')
if mibBuilder.loadTexts: tsTransportStreamBitRateNomenclature.setStatus('current')
if mibBuilder.loadTexts: tsTransportStreamBitRateNomenclature.setDescription("Standardised description of the method of measurement of the bitrate, for example 'bit/s @MGB2'")
tsServiceBitRateTable = MibTable((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 2, 2), )
if mibBuilder.loadTexts: tsServiceBitRateTable.setReference('TR 101 290 section 5.3.3')
if mibBuilder.loadTexts: tsServiceBitRateTable.setStatus('current')
if mibBuilder.loadTexts: tsServiceBitRateTable.setDescription("Bit rates for each service/program within each Transport Stream. The table is sparse, in that only services mentioned in the PMT will be present. The bit rate of a service is the sum of the bit rates of the elementary_PID's in its PMT and the CA_PID's in any CA_descriptors in its PMT (ECMs). The bit rate of the PMT itself is excluded. The bit rate of the PCR_PID is excluded unless the PCR_PID is also one of the elementary_PID's in the PMT.")
tsServiceBitRateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 2, 2, 1), ).setIndexNames((0, "DVB-MGTR101290-MIB", "tsServiceBitRateService"), (0, "DVB-MGTR101290-MIB", "tsServiceBitRateInputNumber"))
if mibBuilder.loadTexts: tsServiceBitRateEntry.setStatus('current')
if mibBuilder.loadTexts: tsServiceBitRateEntry.setDescription('Row specification')
tsServiceBitRateInputNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 2, 2, 1, 1), InputNumber())
if mibBuilder.loadTexts: tsServiceBitRateInputNumber.setStatus('current')
if mibBuilder.loadTexts: tsServiceBitRateInputNumber.setDescription('Transport Stream on which the measurement is made')
tsServiceBitRateService = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 2, 2, 1, 2), ServiceId())
if mibBuilder.loadTexts: tsServiceBitRateService.setStatus('current')
if mibBuilder.loadTexts: tsServiceBitRateService.setDescription('The program_number/service_id to which the information in the rest of the row applies.')
tsServiceBitRateRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 2, 2, 1, 3), RowStatus().clone('active')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tsServiceBitRateRowStatus.setReference('RFC 2579')
if mibBuilder.loadTexts: tsServiceBitRateRowStatus.setStatus('current')
if mibBuilder.loadTexts: tsServiceBitRateRowStatus.setDescription('This is used by the manager to create and delete rows in the table. The agent will automatically create rows for services it finds in the PMT.')
tsServiceBitRateState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 2, 2, 1, 4), TestState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsServiceBitRateState.setStatus('current')
if mibBuilder.loadTexts: tsServiceBitRateState.setDescription('This gives the overall pass/fail state of the threshold test on this measurement')
tsServiceBitRateEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 2, 2, 1, 5), Enable().clone(namedValues=NamedValues(("testEnable", 0)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tsServiceBitRateEnable.setStatus('current')
if mibBuilder.loadTexts: tsServiceBitRateEnable.setDescription('Determines whether the threshold test and associated traps for this measurement are enabled.')
tsServiceBitRateCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 2, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsServiceBitRateCounter.setStatus('current')
if mibBuilder.loadTexts: tsServiceBitRateCounter.setDescription('Count of the number of times a threshold error has occurred for this measurement.')
tsServiceBitRateCounterDiscontinuity = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 2, 2, 1, 7), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsServiceBitRateCounterDiscontinuity.setStatus('current')
if mibBuilder.loadTexts: tsServiceBitRateCounterDiscontinuity.setDescription('Provides the last time at which there was a discontinuity in the tsServiceBitRateCounter object.')
tsServiceBitRateCounterReset = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 2, 2, 1, 8), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tsServiceBitRateCounterReset.setStatus('current')
if mibBuilder.loadTexts: tsServiceBitRateCounterReset.setDescription("tsServiceBitRateCounter is reset to zero and tsServiceBitRateCounterDiscontinuity is set to the current time if 'true' is written to this variable. When read, the value of this object is always 'false'.")
tsServiceBitRateLatestError = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 2, 2, 1, 9), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsServiceBitRateLatestError.setStatus('current')
if mibBuilder.loadTexts: tsServiceBitRateLatestError.setDescription('The timestamp at the most recent occurrence of a threshold error on this measurement.')
tsServiceBitRateActiveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 2, 2, 1, 10), ActiveTime()).setUnits('second').setMaxAccess("readonly")
if mibBuilder.loadTexts: tsServiceBitRateActiveTime.setStatus('current')
if mibBuilder.loadTexts: tsServiceBitRateActiveTime.setDescription('The total time when it has been possible to perform this measurement')
tsServiceBitRateMeasurementState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 2, 2, 1, 11), MeasurementState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsServiceBitRateMeasurementState.setStatus('current')
if mibBuilder.loadTexts: tsServiceBitRateMeasurementState.setDescription('Indicates the validity of the measurement')
tsServiceBitRateValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 2, 2, 1, 12), FloatingPoint()).setUnits('bit/s').setMaxAccess("readonly")
if mibBuilder.loadTexts: tsServiceBitRateValue.setStatus('current')
if mibBuilder.loadTexts: tsServiceBitRateValue.setDescription('Overall bit rate for the service')
tsServiceBitRateNomenclature = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 2, 2, 1, 13), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsServiceBitRateNomenclature.setReference('TR 101 290 5.3.3.3')
if mibBuilder.loadTexts: tsServiceBitRateNomenclature.setStatus('current')
if mibBuilder.loadTexts: tsServiceBitRateNomenclature.setDescription("Standardised description of the method of measurement of the bitrate, for example 'bit/s @MGB2'")
tsPIDBitRateTable = MibTable((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 2, 3), )
if mibBuilder.loadTexts: tsPIDBitRateTable.setReference('TR 101 290 section 5.3.3')
if mibBuilder.loadTexts: tsPIDBitRateTable.setStatus('current')
if mibBuilder.loadTexts: tsPIDBitRateTable.setDescription('Bit rates for each PID within each Transport Stream. The table is sparse, in that only PIDs whose bit rate is currently greater than zero will be present in the table. This allows for faster traversal of the table to build up a list of PID bit rates.')
tsPIDBitRateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 2, 3, 1), ).setIndexNames((0, "DVB-MGTR101290-MIB", "tsPIDBitRateInputNumber"), (0, "DVB-MGTR101290-MIB", "tsPIDBitRatePID"))
if mibBuilder.loadTexts: tsPIDBitRateEntry.setStatus('current')
if mibBuilder.loadTexts: tsPIDBitRateEntry.setDescription('Row specification')
tsPIDBitRateInputNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 2, 3, 1, 1), InputNumber())
if mibBuilder.loadTexts: tsPIDBitRateInputNumber.setStatus('current')
if mibBuilder.loadTexts: tsPIDBitRateInputNumber.setDescription('Transport Stream on which the measurement is made')
tsPIDBitRatePID = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 2, 3, 1, 2), PIDPlusOne())
if mibBuilder.loadTexts: tsPIDBitRatePID.setStatus('current')
if mibBuilder.loadTexts: tsPIDBitRatePID.setDescription('PID whose bit rate is being measured (plus one)')
tsPIDBitRateRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 2, 3, 1, 3), RowStatus().clone('active')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tsPIDBitRateRowStatus.setStatus('current')
if mibBuilder.loadTexts: tsPIDBitRateRowStatus.setDescription('This is used by the manager to create and delete rows in the table. The agent will automatically create rows for PIDs whose bit rate is non-zero.')
tsPIDBitRateState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 2, 3, 1, 4), TestState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsPIDBitRateState.setStatus('current')
if mibBuilder.loadTexts: tsPIDBitRateState.setDescription('This gives the overall pass/fail state of the threshold test on this measurement')
tsPIDBitRateEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 2, 3, 1, 5), Enable().clone(namedValues=NamedValues(("testEnable", 0)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tsPIDBitRateEnable.setStatus('current')
if mibBuilder.loadTexts: tsPIDBitRateEnable.setDescription('Determines whether the threshold test and associated traps for this measurement are enabled.')
tsPIDBitRateCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 2, 3, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsPIDBitRateCounter.setStatus('current')
if mibBuilder.loadTexts: tsPIDBitRateCounter.setDescription('Count of the number of times a threshold error has occurred for this measurement.')
tsPIDBitRateCounterDiscontinuity = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 2, 3, 1, 7), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsPIDBitRateCounterDiscontinuity.setStatus('current')
if mibBuilder.loadTexts: tsPIDBitRateCounterDiscontinuity.setDescription('Provides the last time at which there was a discontinuity in the tsPIDBitRateCounter object.')
tsPIDBitRateCounterReset = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 2, 3, 1, 8), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tsPIDBitRateCounterReset.setStatus('current')
if mibBuilder.loadTexts: tsPIDBitRateCounterReset.setDescription("tsPIDBitRateCounter is reset to zero and tsPIDBitRateCounterDiscontinuity is set to the current time if 'true' is written to this variable. When read, the value of this object is always 'false'.")
tsPIDBitRateLatestError = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 2, 3, 1, 9), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsPIDBitRateLatestError.setStatus('current')
if mibBuilder.loadTexts: tsPIDBitRateLatestError.setDescription('The timestamp at the most recent occurrence of a threshold error on this measurement.')
tsPIDBitRateActiveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 2, 3, 1, 10), ActiveTime()).setUnits('second').setMaxAccess("readonly")
if mibBuilder.loadTexts: tsPIDBitRateActiveTime.setStatus('current')
if mibBuilder.loadTexts: tsPIDBitRateActiveTime.setDescription('The total time when it has been possible to perform this measurement')
tsPIDBitRateMeasurementState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 2, 3, 1, 11), MeasurementState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsPIDBitRateMeasurementState.setStatus('current')
if mibBuilder.loadTexts: tsPIDBitRateMeasurementState.setDescription('Indicates the validity of the measurement')
tsPIDBitRateValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 2, 3, 1, 12), FloatingPoint()).setUnits('bit/s').setMaxAccess("readonly")
if mibBuilder.loadTexts: tsPIDBitRateValue.setStatus('current')
if mibBuilder.loadTexts: tsPIDBitRateValue.setDescription('Bit rate for the PID.')
tsPIDBitRateNomenclature = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 2, 3, 1, 13), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsPIDBitRateNomenclature.setReference('TR 101 290 5.3.3.3')
if mibBuilder.loadTexts: tsPIDBitRateNomenclature.setStatus('current')
if mibBuilder.loadTexts: tsPIDBitRateNomenclature.setDescription("Standardised description of the method of measurement of the bitrate, for example 'bit/s @MGB2'")
tsConsistencyTable = MibTable((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 3), )
if mibBuilder.loadTexts: tsConsistencyTable.setReference('TR 101 290 section 5.3.4')
if mibBuilder.loadTexts: tsConsistencyTable.setStatus('current')
if mibBuilder.loadTexts: tsConsistencyTable.setDescription('This table provides the result of the Transport Stream consistency test for each input.')
tsConsistencyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 3, 1), ).setIndexNames((0, "DVB-MGTR101290-MIB", "tsConsistencyInputNumber"), (0, "DVB-MGTR101290-MIB", "tsConsistencyTestNumber"))
if mibBuilder.loadTexts: tsConsistencyEntry.setStatus('current')
if mibBuilder.loadTexts: tsConsistencyEntry.setDescription('Row specification')
tsConsistencyInputNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 3, 1, 1), InputNumber())
if mibBuilder.loadTexts: tsConsistencyInputNumber.setStatus('current')
if mibBuilder.loadTexts: tsConsistencyInputNumber.setDescription('Input (Transport Stream) on which the consistency check is made.')
tsConsistencyTestNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 3, 1, 2), IndexConsistencyTest())
if mibBuilder.loadTexts: tsConsistencyTestNumber.setStatus('current')
if mibBuilder.loadTexts: tsConsistencyTestNumber.setDescription('Specifies the consistency check test')
tsConsistencyState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 3, 1, 3), TestState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsConsistencyState.setStatus('current')
if mibBuilder.loadTexts: tsConsistencyState.setDescription('This gives the overall pass/fail state of the consistency check.')
tsConsistencyEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 3, 1, 4), Enable().clone(namedValues=NamedValues(("testEnable", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tsConsistencyEnable.setStatus('current')
if mibBuilder.loadTexts: tsConsistencyEnable.setDescription('Determines whether this test and associated traps are enabled.')
tsConsistencyCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 3, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsConsistencyCounter.setStatus('current')
if mibBuilder.loadTexts: tsConsistencyCounter.setDescription('Count of the number of times the consistency check has failed.')
tsConsistencyCounterDiscontinuity = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 3, 1, 6), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsConsistencyCounterDiscontinuity.setStatus('current')
if mibBuilder.loadTexts: tsConsistencyCounterDiscontinuity.setDescription('Provides the last time at which there was a discontinuity in the tsConsistencyCounter object.')
tsConsistencyCounterReset = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 3, 1, 7), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tsConsistencyCounterReset.setStatus('current')
if mibBuilder.loadTexts: tsConsistencyCounterReset.setDescription("tsConsistencyCounter is reset to zero and tsConsistencyCounterDiscontinuity is set to the current time if 'true' is written to this variable. When read, the value of this object is always 'false'.")
tsConsistencyLatestError = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 3, 1, 8), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsConsistencyLatestError.setStatus('current')
if mibBuilder.loadTexts: tsConsistencyLatestError.setDescription('The timestamp at the most recent failure of the consistency check.')
tsConsistencyActiveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 3, 1, 9), ActiveTime()).setUnits('second').setMaxAccess("readonly")
if mibBuilder.loadTexts: tsConsistencyActiveTime.setStatus('current')
if mibBuilder.loadTexts: tsConsistencyActiveTime.setDescription('The total time when it has been possible to perform this test')
tsMeasurePreferences = MibIdentifier((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 100))
tsMeasurePreferencesTable = MibTable((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 100, 1), )
if mibBuilder.loadTexts: tsMeasurePreferencesTable.setStatus('current')
if mibBuilder.loadTexts: tsMeasurePreferencesTable.setDescription('This table contains configuration information for the tsMeasurements branch of the MIB. Configuration related to the whole Transport Stream is found here.')
tsMeasurePreferencesEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 100, 1, 1), ).setIndexNames((0, "DVB-MGTR101290-MIB", "tsMeasurePrefInputNumber"))
if mibBuilder.loadTexts: tsMeasurePreferencesEntry.setStatus('current')
if mibBuilder.loadTexts: tsMeasurePreferencesEntry.setDescription('Row specification')
tsMeasurePrefInputNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 100, 1, 1, 1), InputNumber())
if mibBuilder.loadTexts: tsMeasurePrefInputNumber.setStatus('current')
if mibBuilder.loadTexts: tsMeasurePrefInputNumber.setDescription('Transport Stream input to which the preferences apply')
tsMeasurePrefPCRDemarcationFrequency = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 100, 1, 1, 2), FloatingPoint().clone('0.01')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tsMeasurePrefPCRDemarcationFrequency.setReference('TR 101 290 section 5.3.2.2')
if mibBuilder.loadTexts: tsMeasurePrefPCRDemarcationFrequency.setStatus('current')
if mibBuilder.loadTexts: tsMeasurePrefPCRDemarcationFrequency.setDescription('This is the demarcation frequency used by the PCR measurement system to distinguish between inaccuracy/jitter and drift.')
tsMeasurePrefPCRFOMax = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 100, 1, 1, 3), FloatingPoint().clone('810')).setUnits('Hz').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tsMeasurePrefPCRFOMax.setReference('ISO/IEC 13818-1 section 2.4.2.1')
if mibBuilder.loadTexts: tsMeasurePrefPCRFOMax.setStatus('current')
if mibBuilder.loadTexts: tsMeasurePrefPCRFOMax.setDescription('Maximum permitted PCR_FO (frequency offset). An error is indicated if the measured PCR_FO is outside the range [-tsMeasurePrefPCRFOMax .. +tsMeasurePrefPCRFOMax].')
tsMeasurePrefPCRDRMax = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 100, 1, 1, 4), FloatingPoint().clone('0.075')).setUnits('Hz/s').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tsMeasurePrefPCRDRMax.setReference('ISO/IEC 13818-1 section 2.4.2.1')
if mibBuilder.loadTexts: tsMeasurePrefPCRDRMax.setStatus('current')
if mibBuilder.loadTexts: tsMeasurePrefPCRDRMax.setDescription('Maximum permitted PCR_DR (drift rate). An error is indicated if the measured PCR_DR is outside the range [-tsMeasurePrefPCRDRMax .. +tsMeasurePrefPCRDRMax]')
tsMeasurePrefPCROJMax = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 100, 1, 1, 5), FloatingPoint().clone('25E-06')).setUnits('second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tsMeasurePrefPCROJMax.setReference('ISO/IEC 13818-9 section 3.3')
if mibBuilder.loadTexts: tsMeasurePrefPCROJMax.setStatus('current')
if mibBuilder.loadTexts: tsMeasurePrefPCROJMax.setDescription('Maximum permitted PCR_OJ (overall jitter). An error is indicated if the measured PCR_OJ is outside the range [-tsMeasurePrefPCROJMax .. +tsMeasurePrefPCROJMax]')
tsMeasurePrefTSBitRateTau = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 100, 1, 1, 6), FloatingPoint().clone('0.1')).setUnits('second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tsMeasurePrefTSBitRateTau.setReference('TR 101 290 section 5.3.3.1')
if mibBuilder.loadTexts: tsMeasurePrefTSBitRateTau.setStatus('current')
if mibBuilder.loadTexts: tsMeasurePrefTSBitRateTau.setDescription("'tau' value for Transport Stream bit rate measurement. The MIB provides very flexible ways of setting the bit rate measurement parameters tau, N and element for the Transport Stream, services, PIDs and for individual services and PIDs. Real measurement equipment can be expected to provide much less flexibility. Management software should anticipate this by either being statically aware of the capabilities of the agent or by checking that preference settings have been accepted by reading them back after each attempt to set them.")
tsMeasurePrefTSBitRateN = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 100, 1, 1, 7), Unsigned32().clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tsMeasurePrefTSBitRateN.setReference('TR 101 290 section 5.3.3.1')
if mibBuilder.loadTexts: tsMeasurePrefTSBitRateN.setStatus('current')
if mibBuilder.loadTexts: tsMeasurePrefTSBitRateN.setDescription("'N' value for Transport Stream bit rate measurement. See note in description for tsMeasurePrefTSBitRateTau.")
tsMeasurePrefTSBitRateElement = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 100, 1, 1, 8), BitRateElement().clone('packet')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tsMeasurePrefTSBitRateElement.setReference('TR 101 290 section 5.3.3.1')
if mibBuilder.loadTexts: tsMeasurePrefTSBitRateElement.setStatus('current')
if mibBuilder.loadTexts: tsMeasurePrefTSBitRateElement.setDescription('Data unit which is counted by the bit rate measurement algorithm. See note in description for tsMeasurePrefTSBitRateTau.')
tsMeasurePrefTSBitRateMin = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 100, 1, 1, 9), FloatingPoint()).setUnits('bit/s').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tsMeasurePrefTSBitRateMin.setStatus('current')
if mibBuilder.loadTexts: tsMeasurePrefTSBitRateMin.setDescription('An error is generated if the Transport Stream bit rate is below this value.')
tsMeasurePrefTSBitRateMax = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 100, 1, 1, 10), FloatingPoint()).setUnits('bit/s').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tsMeasurePrefTSBitRateMax.setStatus('current')
if mibBuilder.loadTexts: tsMeasurePrefTSBitRateMax.setDescription('An error is generated if the Transport Stream bit rate exceeds this value.')
tsMeasurePrefAllServiceBitRateTau = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 100, 1, 1, 11), FloatingPoint().clone('0.1')).setUnits('second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tsMeasurePrefAllServiceBitRateTau.setReference('TR 101 290 section 5.3.3.1')
if mibBuilder.loadTexts: tsMeasurePrefAllServiceBitRateTau.setStatus('current')
if mibBuilder.loadTexts: tsMeasurePrefAllServiceBitRateTau.setDescription("'tau' value for Service bit rate measurement. When a manager sets the value of this object, the values of the tsMeasurePrefServiceBitRateTau columns in all the rows of the tsMeasurePreferencesServiceTable are set to this same value. This also becomes the default value for any new rows created subsequently. See note in description for tsMeasurePrefTSBitRateTau.")
tsMeasurePrefAllServiceBitRateN = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 100, 1, 1, 12), Unsigned32().clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tsMeasurePrefAllServiceBitRateN.setReference('TR 101 290 section 5.3.3.1')
if mibBuilder.loadTexts: tsMeasurePrefAllServiceBitRateN.setStatus('current')
if mibBuilder.loadTexts: tsMeasurePrefAllServiceBitRateN.setDescription("'N' value for Service bit rate measurement. When a manager sets the value of this object, the values of the tsMeasurePrefServiceBitRateN columns in all the rows of the tsMeasurePreferencesServiceTable are set to this same value. This also becomes the default value for any new rows created subsequently. See note in description for tsMeasurePrefTSBitRateTau.")
tsMeasurePrefAllServiceBitRateElement = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 100, 1, 1, 13), BitRateElement().clone('packet')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tsMeasurePrefAllServiceBitRateElement.setReference('TR 101 290 section 5.3.3.1')
if mibBuilder.loadTexts: tsMeasurePrefAllServiceBitRateElement.setStatus('current')
if mibBuilder.loadTexts: tsMeasurePrefAllServiceBitRateElement.setDescription('Data unit which is counted by the bit rate measurement algorithm for services. When a manager sets the value of this object, the values of the tsMeasurePrefServiceBitRateElement columns in all the rows of the tsMeasurePreferencesServiceTable are set to this same value. This also becomes the default value for any new rows created subsequently. See note in description for tsMeasurePrefTSBitRateTau.')
tsMeasurePrefAllPIDBitRateTau = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 100, 1, 1, 14), FloatingPoint().clone('0.1')).setUnits('second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tsMeasurePrefAllPIDBitRateTau.setReference('TR 101 290 section 5.3.3.1')
if mibBuilder.loadTexts: tsMeasurePrefAllPIDBitRateTau.setStatus('current')
if mibBuilder.loadTexts: tsMeasurePrefAllPIDBitRateTau.setDescription("'tau' value for Service bit rate measurement. When a manager sets the value of this object, the values of the tsMeasurePrefPIDBitRateTau columns in all the rows of the tsMeasurePreferencesPIDTable are set to this same value. This also becomes the default value for any new rows created subsequently. See note in description for tsMeasurePrefTSBitRateTau.")
tsMeasurePrefAllPIDBitRateN = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 100, 1, 1, 15), Unsigned32().clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tsMeasurePrefAllPIDBitRateN.setReference('TR 101 290 section 5.3.3.1')
if mibBuilder.loadTexts: tsMeasurePrefAllPIDBitRateN.setStatus('current')
if mibBuilder.loadTexts: tsMeasurePrefAllPIDBitRateN.setDescription("'N' value for PID bit rate measurement. When a manager sets the value of this object, the values of the tsMeasurePrefPIDBitRateN columns in all the rows of the tsMeasurePreferencesPIDTable are set to this same value. This also becomes the default value for any new rows created subsequently. See note in description for tsMeasurePrefTSBitRateTau.")
tsMeasurePrefAllPIDBitRateElement = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 100, 1, 1, 16), BitRateElement().clone('packet')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tsMeasurePrefAllPIDBitRateElement.setReference('TR 101 290 section 5.3.3.1')
if mibBuilder.loadTexts: tsMeasurePrefAllPIDBitRateElement.setStatus('current')
if mibBuilder.loadTexts: tsMeasurePrefAllPIDBitRateElement.setDescription('Data unit which is counted by the bit rate measurement algorithm for PIDs. When a manager sets the value of this object, the values of the tsMeasurePrefPIDBitRateElement columns in all the rows of the tsMeasurePreferencesPIDTable are set to this same value. This also becomes the default value for any new rows created subsequently. See note in description for tsMeasurePrefTSBitRateTau.')
tsMeasurePrefExpectedTSID = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 100, 1, 1, 17), TransportStreamID()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tsMeasurePrefExpectedTSID.setReference('TR 101 290 5.3.4')
if mibBuilder.loadTexts: tsMeasurePrefExpectedTSID.setStatus('current')
if mibBuilder.loadTexts: tsMeasurePrefExpectedTSID.setDescription('This object defines the expected Transport Stream ID that is compared with the actual ID to perform the consistency of information check.')
tsMeasurePreferencesServiceTable = MibTable((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 100, 2), )
if mibBuilder.loadTexts: tsMeasurePreferencesServiceTable.setStatus('current')
if mibBuilder.loadTexts: tsMeasurePreferencesServiceTable.setDescription('This table contains configuration information for the tsMeasurements branch of the MIB. Configuration related to individual services is found here.')
tsMeasurePreferencesServiceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 100, 2, 1), ).setIndexNames((0, "DVB-MGTR101290-MIB", "tsMeasurePrefServiceInputNumber"), (0, "DVB-MGTR101290-MIB", "tsMeasurePrefServiceService"))
if mibBuilder.loadTexts: tsMeasurePreferencesServiceEntry.setStatus('current')
if mibBuilder.loadTexts: tsMeasurePreferencesServiceEntry.setDescription('Row specification')
tsMeasurePrefServiceInputNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 100, 2, 1, 1), InputNumber())
if mibBuilder.loadTexts: tsMeasurePrefServiceInputNumber.setStatus('current')
if mibBuilder.loadTexts: tsMeasurePrefServiceInputNumber.setDescription('Transport Stream input to which the preferences apply')
tsMeasurePrefServiceService = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 100, 2, 1, 2), ServiceId())
if mibBuilder.loadTexts: tsMeasurePrefServiceService.setStatus('current')
if mibBuilder.loadTexts: tsMeasurePrefServiceService.setDescription('Service to which the preferences apply.')
tsMeasurePrefServiceRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 100, 2, 1, 3), RowStatus().clone('active')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tsMeasurePrefServiceRowStatus.setStatus('current')
if mibBuilder.loadTexts: tsMeasurePrefServiceRowStatus.setDescription('This is used by the manager to create and delete rows in the table. The agent will automatically create rows for services it finds in the PMT.')
tsMeasurePrefServiceBitRateTau = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 100, 2, 1, 4), FloatingPoint().clone('0.1')).setUnits('second').setMaxAccess("readcreate")
if mibBuilder.loadTexts: tsMeasurePrefServiceBitRateTau.setReference('TR 101 290 section 5.3.3.1')
if mibBuilder.loadTexts: tsMeasurePrefServiceBitRateTau.setStatus('current')
if mibBuilder.loadTexts: tsMeasurePrefServiceBitRateTau.setDescription("'tau' value for bit rate measurement for this service. See note in description for tsMeasurePrefTSBitRateTau. If an agent does not support per service tau settings, it shall ignore attempts to change the setting by writing to this object.")
tsMeasurePrefServiceBitRateN = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 100, 2, 1, 5), Unsigned32().clone(10)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tsMeasurePrefServiceBitRateN.setReference('TR 101 290 section 5.3.3.1')
if mibBuilder.loadTexts: tsMeasurePrefServiceBitRateN.setStatus('current')
if mibBuilder.loadTexts: tsMeasurePrefServiceBitRateN.setDescription("'N' value for rate measurement for this service. See note in description for tsMeasurePrefTSBitRateTau. If an agent does not support per service 'N' settings, it shall ignore attempts to change the setting by writing to this object.")
tsMeasurePrefServiceBitRateElement = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 100, 2, 1, 6), BitRateElement().clone('packet')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tsMeasurePrefServiceBitRateElement.setReference('TR 101 290 section 5.3.3.1')
if mibBuilder.loadTexts: tsMeasurePrefServiceBitRateElement.setStatus('current')
if mibBuilder.loadTexts: tsMeasurePrefServiceBitRateElement.setDescription('Data unit which is counted by the bit rate measurement algorithm for this service. See note in description for tsMeasurePrefTSBitRateTau. If an agent does not support per service element settings, it shall ignore attempts to change the setting by writing to this object.')
tsMeasurePrefServiceBitRateMin = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 100, 2, 1, 7), FloatingPoint()).setUnits('bit/s').setMaxAccess("readcreate")
if mibBuilder.loadTexts: tsMeasurePrefServiceBitRateMin.setStatus('current')
if mibBuilder.loadTexts: tsMeasurePrefServiceBitRateMin.setDescription('An error is generated if the Service bit rate is below this value.')
tsMeasurePrefServiceBitRateMax = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 100, 2, 1, 8), FloatingPoint()).setUnits('bit/s').setMaxAccess("readcreate")
if mibBuilder.loadTexts: tsMeasurePrefServiceBitRateMax.setStatus('current')
if mibBuilder.loadTexts: tsMeasurePrefServiceBitRateMax.setDescription('An error is generated if the Transport Stream bit rate exceeds this value.')
tsMeasurePreferencesPIDTable = MibTable((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 100, 3), )
if mibBuilder.loadTexts: tsMeasurePreferencesPIDTable.setStatus('current')
if mibBuilder.loadTexts: tsMeasurePreferencesPIDTable.setDescription('This table contains configuration information for the tsMeasurements branch of the MIB. Configuration related to individual PIDs is found here.')
tsMeasurePreferencesPIDEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 100, 3, 1), ).setIndexNames((0, "DVB-MGTR101290-MIB", "tsMeasurePrefPIDInputNumber"), (0, "DVB-MGTR101290-MIB", "tsMeasurePrefPIDPID"))
if mibBuilder.loadTexts: tsMeasurePreferencesPIDEntry.setStatus('current')
if mibBuilder.loadTexts: tsMeasurePreferencesPIDEntry.setDescription('Row specification')
tsMeasurePrefPIDInputNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 100, 3, 1, 1), InputNumber())
if mibBuilder.loadTexts: tsMeasurePrefPIDInputNumber.setStatus('current')
if mibBuilder.loadTexts: tsMeasurePrefPIDInputNumber.setDescription('Transport Stream input to which the preferences apply')
tsMeasurePrefPIDPID = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 100, 3, 1, 2), PIDPlusOne())
if mibBuilder.loadTexts: tsMeasurePrefPIDPID.setStatus('current')
if mibBuilder.loadTexts: tsMeasurePrefPIDPID.setDescription('PID (plus one) to which the preferences apply.')
tsMeasurePrefPIDRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 100, 3, 1, 3), RowStatus().clone('active')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tsMeasurePrefPIDRowStatus.setStatus('current')
if mibBuilder.loadTexts: tsMeasurePrefPIDRowStatus.setDescription('This is used by the manager to create and delete rows in the table. The agent will automatically create rows for PIDs which have a non-zero bit rate.')
tsMeasurePrefPIDBitRateTau = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 100, 3, 1, 4), FloatingPoint().clone('0.1')).setUnits('second').setMaxAccess("readcreate")
if mibBuilder.loadTexts: tsMeasurePrefPIDBitRateTau.setReference('TR 101 290 section 5.3.3.1')
if mibBuilder.loadTexts: tsMeasurePrefPIDBitRateTau.setStatus('current')
if mibBuilder.loadTexts: tsMeasurePrefPIDBitRateTau.setDescription("'tau' value for bit rate measurement for this PID. See note in description for tsMeasurePrefTSBitRateTau. If an agent does not support per PID tau settings, it shall ignore attempts to change the setting by writing to this object.")
tsMeasurePrefPIDBitRateN = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 100, 3, 1, 5), Unsigned32().clone(10)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tsMeasurePrefPIDBitRateN.setReference('TR 101 290 section 5.3.3.1')
if mibBuilder.loadTexts: tsMeasurePrefPIDBitRateN.setStatus('current')
if mibBuilder.loadTexts: tsMeasurePrefPIDBitRateN.setDescription("'N' value for bit rate measurement for this PID. See note in description for tsMeasurePrefTSBitRateTau. If an agent does not support per PID 'N' settings, it shall ignore attempts to change the setting by writing to this object.")
tsMeasurePrefPIDBitRateElement = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 100, 3, 1, 6), BitRateElement().clone('packet')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tsMeasurePrefPIDBitRateElement.setReference('TR 101 290 section 5.3.3.1')
if mibBuilder.loadTexts: tsMeasurePrefPIDBitRateElement.setStatus('current')
if mibBuilder.loadTexts: tsMeasurePrefPIDBitRateElement.setDescription('Data unit which is counted by the bit rate measurement algorithm for this PID. See note in description for tsMeasurePrefTSBitRateTau. If an agent does not support per PID element settings, it shall ignore attempts to change the setting by writing to this object.')
tsMeasurePrefPIDBitRateMin = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 100, 3, 1, 7), FloatingPoint()).setUnits('bit/s').setMaxAccess("readcreate")
if mibBuilder.loadTexts: tsMeasurePrefPIDBitRateMin.setStatus('current')
if mibBuilder.loadTexts: tsMeasurePrefPIDBitRateMin.setDescription('An error is generated if the PID bit rate is below this value.')
tsMeasurePrefPIDBitRateMax = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 4, 100, 3, 1, 8), FloatingPoint()).setUnits('bit/s').setMaxAccess("readcreate")
if mibBuilder.loadTexts: tsMeasurePrefPIDBitRateMax.setStatus('current')
if mibBuilder.loadTexts: tsMeasurePrefPIDBitRateMax.setDescription('An error is generated if the PID bit rate exceeds this value.')
tsServicePerformance = MibIdentifier((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 5))
tsServicePerformanceTable = MibTable((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 5, 2), )
if mibBuilder.loadTexts: tsServicePerformanceTable.setReference('TR 101 290 section 5.5')
if mibBuilder.loadTexts: tsServicePerformanceTable.setStatus('current')
if mibBuilder.loadTexts: tsServicePerformanceTable.setDescription('This table gives access to the Service Performance measurements and tests')
tsServicePerformanceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 5, 2, 1), ).setIndexNames((0, "DVB-MGTR101290-MIB", "tsServicePerformanceNumber"), (0, "DVB-MGTR101290-MIB", "tsServicePerformanceInputNumber"))
if mibBuilder.loadTexts: tsServicePerformanceEntry.setStatus('current')
if mibBuilder.loadTexts: tsServicePerformanceEntry.setDescription('Row specification')
tsServicePerformanceInputNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 5, 2, 1, 1), InputNumber())
if mibBuilder.loadTexts: tsServicePerformanceInputNumber.setStatus('current')
if mibBuilder.loadTexts: tsServicePerformanceInputNumber.setDescription('Transport Stream on which the measurement is made')
tsServicePerformanceNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 5, 2, 1, 2), IndexServicePerformance())
if mibBuilder.loadTexts: tsServicePerformanceNumber.setStatus('current')
if mibBuilder.loadTexts: tsServicePerformanceNumber.setDescription('The Service Performance measurement which this row applies to.')
tsServicePerformanceState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 5, 2, 1, 3), TestState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsServicePerformanceState.setStatus('current')
if mibBuilder.loadTexts: tsServicePerformanceState.setDescription('This gives the overall pass/fail state of the threshold test on this measurement. The threshold test fails if the value of tsServicePerformanceErrorRatio exceeds the value given in the preferences.')
tsServicePerformanceEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 5, 2, 1, 4), Enable().clone(namedValues=NamedValues(("testEnable", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tsServicePerformanceEnable.setStatus('current')
if mibBuilder.loadTexts: tsServicePerformanceEnable.setDescription('Determines whether the threshold test and associated traps for this measurement are enabled.')
tsServicePerformanceCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 5, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsServicePerformanceCounter.setStatus('current')
if mibBuilder.loadTexts: tsServicePerformanceCounter.setDescription('Count of the number of times a threshold error has occurred for this measurement.')
tsServicePerformanceCounterDiscontinuity = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 5, 2, 1, 6), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsServicePerformanceCounterDiscontinuity.setStatus('current')
if mibBuilder.loadTexts: tsServicePerformanceCounterDiscontinuity.setDescription('Provides the last time at which there was a discontinuity in the tsServicePerformanceCounter object.')
tsServicePerformanceCounterReset = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 5, 2, 1, 7), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tsServicePerformanceCounterReset.setStatus('current')
if mibBuilder.loadTexts: tsServicePerformanceCounterReset.setDescription("tsServicePerformanceCounter is reset to zero and tsServicePerformanceCounterDiscontinuity is set to the current time if 'true' is written to this variable. The value read from this object is always 'false'.")
tsServicePerformanceLatestError = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 5, 2, 1, 8), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsServicePerformanceLatestError.setStatus('current')
if mibBuilder.loadTexts: tsServicePerformanceLatestError.setDescription('The timestamp at the most recent occurrence of a threshold error on this measurement.')
tsServicePerformanceActiveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 5, 2, 1, 9), ActiveTime()).setUnits('second').setMaxAccess("readonly")
if mibBuilder.loadTexts: tsServicePerformanceActiveTime.setStatus('current')
if mibBuilder.loadTexts: tsServicePerformanceActiveTime.setDescription('The total time when it has been possible to perform this measurement')
tsServicePerformanceMeasurementState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 5, 2, 1, 10), MeasurementState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsServicePerformanceMeasurementState.setStatus('current')
if mibBuilder.loadTexts: tsServicePerformanceMeasurementState.setDescription('Indicates the validity of the measurement')
tsServicePerformanceError = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 5, 2, 1, 11), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsServicePerformanceError.setStatus('current')
if mibBuilder.loadTexts: tsServicePerformanceError.setDescription('The calculated xxx_Error parameter as measured at the end of the most recently completed DeltaT period.')
tsServicePerformanceErrorRatio = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 5, 2, 1, 12), FloatingPoint()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsServicePerformanceErrorRatio.setStatus('current')
if mibBuilder.loadTexts: tsServicePerformanceErrorRatio.setDescription("This is the calculated xxx_Error_Ratio as a percentage (e.g. '1.32'). The value is for the most recently completed evaluation time (e.g. 10 minutes).")
tsServicePerformancePreferencesTable = MibTable((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 5, 100), )
if mibBuilder.loadTexts: tsServicePerformancePreferencesTable.setStatus('current')
if mibBuilder.loadTexts: tsServicePerformancePreferencesTable.setDescription('Parameters controlling the Service Performance measurements')
tsServicePerformancePreferencesEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 5, 100, 1), ).setIndexNames((0, "DVB-MGTR101290-MIB", "tsSPPrefInputNumber"), (0, "DVB-MGTR101290-MIB", "tsSPPrefNumber"))
if mibBuilder.loadTexts: tsServicePerformancePreferencesEntry.setStatus('current')
if mibBuilder.loadTexts: tsServicePerformancePreferencesEntry.setDescription('Row specification')
tsSPPrefInputNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 5, 100, 1, 1), InputNumber())
if mibBuilder.loadTexts: tsSPPrefInputNumber.setStatus('current')
if mibBuilder.loadTexts: tsSPPrefInputNumber.setDescription('Transport Stream input to which the preferences apply')
tsSPPrefNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 5, 100, 1, 2), IndexServicePerformance())
if mibBuilder.loadTexts: tsSPPrefNumber.setStatus('current')
if mibBuilder.loadTexts: tsSPPrefNumber.setDescription('The service performance parameter to which these preferences apply.')
tsSPPrefDeltaT = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 5, 100, 1, 3), FloatingPoint()).setUnits('second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tsSPPrefDeltaT.setReference('TR 101 290 section 5.5')
if mibBuilder.loadTexts: tsSPPrefDeltaT.setStatus('current')
if mibBuilder.loadTexts: tsSPPrefDeltaT.setDescription('The defined time interval over which errors are counted')
tsSPPrefEvaluationTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 5, 100, 1, 4), FloatingPoint()).setUnits('second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tsSPPrefEvaluationTime.setReference('TR 101 290 section 5.5')
if mibBuilder.loadTexts: tsSPPrefEvaluationTime.setStatus('current')
if mibBuilder.loadTexts: tsSPPrefEvaluationTime.setDescription('The period over which the ...Error_Ratio is calculated')
tsSPPrefThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 5, 5, 100, 1, 5), FloatingPoint()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tsSPPrefThreshold.setReference('TR 101 290 section 5.5')
if mibBuilder.loadTexts: tsSPPrefThreshold.setStatus('current')
if mibBuilder.loadTexts: tsSPPrefThreshold.setDescription('The threshold value used in calculating the ..._Error_Ratio.')
tr101290CableSat = MibIdentifier((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6))
sysAvailabilityTable = MibTable((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 1), )
if mibBuilder.loadTexts: sysAvailabilityTable.setReference('TR 101 290 section 6.1 TR 101 290 section 5.4')
if mibBuilder.loadTexts: sysAvailabilityTable.setStatus('current')
if mibBuilder.loadTexts: sysAvailabilityTable.setDescription('System availability measurement')
sysAvailabilityEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 1, 1), ).setIndexNames((0, "DVB-MGTR101290-MIB", "sysAvailabilityInputNumber"))
if mibBuilder.loadTexts: sysAvailabilityEntry.setStatus('current')
if mibBuilder.loadTexts: sysAvailabilityEntry.setDescription('Row specification')
sysAvailabilityInputNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 1, 1, 1), InputNumber())
if mibBuilder.loadTexts: sysAvailabilityInputNumber.setStatus('current')
if mibBuilder.loadTexts: sysAvailabilityInputNumber.setDescription('Transport Stream on which the measurement is made')
sysAvailabilityTestState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 1, 1, 2), TestState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysAvailabilityTestState.setStatus('current')
if mibBuilder.loadTexts: sysAvailabilityTestState.setDescription("A 'fail' is an approximate indication that the system is in a period of unavailable time (UAT). 'fail' is indicated as soon as a trigger period for unavailable time completes. 'pass' is indicated as soon as a trigger period for available time completes. This necessarily differs from the strict definition of UAT because the measuring equipment is unable to look into the future.")
sysAvailabilityEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 1, 1, 3), Enable().clone(namedValues=NamedValues(("testEnable", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysAvailabilityEnable.setStatus('current')
if mibBuilder.loadTexts: sysAvailabilityEnable.setDescription('Determines whether system availability testing is performed and whether the associated traps are generated.')
sysAvailabilityCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysAvailabilityCounter.setStatus('current')
if mibBuilder.loadTexts: sysAvailabilityCounter.setDescription('Count of the number of times the system has become unavailable')
sysAvailabilityCounterDiscontinuity = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 1, 1, 5), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysAvailabilityCounterDiscontinuity.setStatus('current')
if mibBuilder.loadTexts: sysAvailabilityCounterDiscontinuity.setDescription('Provides the last time at which there was a discontinuity in the sysAvailabilityCounter object.')
sysAvailabilityCounterReset = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 1, 1, 6), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysAvailabilityCounterReset.setStatus('current')
if mibBuilder.loadTexts: sysAvailabilityCounterReset.setDescription("sysAvailabilityCounter is reset to zero and sysAvailabilityCounterDiscontinuity is set to the current time if 'true' is written to this variable. When read, the value of this object is always 'false'.")
sysAvailabilityLatestError = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 1, 1, 7), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysAvailabilityLatestError.setStatus('current')
if mibBuilder.loadTexts: sysAvailabilityLatestError.setDescription('The timestamp when the system most recently became unavailable.')
sysAvailabilityActiveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 1, 1, 8), ActiveTime()).setUnits('second').setMaxAccess("readonly")
if mibBuilder.loadTexts: sysAvailabilityActiveTime.setStatus('current')
if mibBuilder.loadTexts: sysAvailabilityActiveTime.setDescription('This is a monotonically increasing value in units of seconds that represents the total amount of time for which the instrument has been able to perform the test/measurement. It can be used to calculate the Total Time in the calculation of the availability.')
sysAvailabilityMeasurementState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 1, 1, 9), MeasurementState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysAvailabilityMeasurementState.setStatus('current')
if mibBuilder.loadTexts: sysAvailabilityMeasurementState.setDescription('Indicates the validity of the measurement')
sysAvailabilityUnavailableTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 1, 1, 10), Unsigned32()).setUnits('second').setMaxAccess("readonly")
if mibBuilder.loadTexts: sysAvailabilityUnavailableTime.setStatus('current')
if mibBuilder.loadTexts: sysAvailabilityUnavailableTime.setDescription('This is a monotonically increasing time in seconds which measures the total Unavailable Time (UAT) since the measuring system was last restarted.')
sysAvailabilityRatio = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 1, 1, 11), FloatingPoint()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysAvailabilityRatio.setStatus('current')
if mibBuilder.loadTexts: sysAvailabilityRatio.setDescription("This is the System Availability ratio as a percentage (e.g. 99.643) measured over the previous 'Total Time' measurement period.")
sysAvailabilityInSETI = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 1, 1, 12), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysAvailabilityInSETI.setStatus('current')
if mibBuilder.loadTexts: sysAvailabilityInSETI.setDescription("This object has the value 'true' if and only if the most recently completed Time Interval (TI) was a Severely Errored Time Interval (SETI).")
linkAvailabilityTable = MibTable((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 2), )
if mibBuilder.loadTexts: linkAvailabilityTable.setReference('TR 101 290 section 6.2 TR 101 290 section 5.4')
if mibBuilder.loadTexts: linkAvailabilityTable.setStatus('current')
if mibBuilder.loadTexts: linkAvailabilityTable.setDescription('Link availability measurement')
linkAvailabilityEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 2, 1), ).setIndexNames((0, "DVB-MGTR101290-MIB", "linkAvailabilityInputNumber"))
if mibBuilder.loadTexts: linkAvailabilityEntry.setStatus('current')
if mibBuilder.loadTexts: linkAvailabilityEntry.setDescription('Row specification')
linkAvailabilityInputNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 2, 1, 1), InputNumber())
if mibBuilder.loadTexts: linkAvailabilityInputNumber.setStatus('current')
if mibBuilder.loadTexts: linkAvailabilityInputNumber.setDescription('Transport Stream on which the measurement is made')
linkAvailabilityTestState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 2, 1, 2), TestState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: linkAvailabilityTestState.setStatus('current')
if mibBuilder.loadTexts: linkAvailabilityTestState.setDescription("A 'fail' is an approximate indication that the system is in a period of link unavailable time (LUAT). 'fail' is indicated as soon as a trigger period for link unavailable time completes. 'pass' is indicated as soon as a trigger period for link available time completes. This necessarily differs from the strict definition of LUAT because the measuring equipment is unable to look into the future.")
linkAvailabilityEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 2, 1, 3), Enable().clone(namedValues=NamedValues(("testEnable", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: linkAvailabilityEnable.setStatus('current')
if mibBuilder.loadTexts: linkAvailabilityEnable.setDescription('Determines whether link availability testing is performed and whether the associated traps are generated.')
linkAvailabilityCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: linkAvailabilityCounter.setStatus('current')
if mibBuilder.loadTexts: linkAvailabilityCounter.setDescription('Count of the number of times the link has become unavailable.')
linkAvailabilityCounterDiscontinuity = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 2, 1, 5), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: linkAvailabilityCounterDiscontinuity.setStatus('current')
if mibBuilder.loadTexts: linkAvailabilityCounterDiscontinuity.setDescription('Provides the last time at which there was a discontinuity in the linkAvailabilityCounter object.')
linkAvailabilityCounterReset = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 2, 1, 6), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: linkAvailabilityCounterReset.setStatus('current')
if mibBuilder.loadTexts: linkAvailabilityCounterReset.setDescription("linkAvailabilityCounter is reset to zero and linkAvailabilityCounterDiscontinuity is set to the current time if 'true' is written to this variable. When read, the value of this object is always 'false'.")
linkAvailabilityLatestError = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 2, 1, 7), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: linkAvailabilityLatestError.setStatus('current')
if mibBuilder.loadTexts: linkAvailabilityLatestError.setDescription('The timestamp when the link most recently became unavailable.')
linkAvailabilityActiveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 2, 1, 8), ActiveTime()).setUnits('second').setMaxAccess("readonly")
if mibBuilder.loadTexts: linkAvailabilityActiveTime.setStatus('current')
if mibBuilder.loadTexts: linkAvailabilityActiveTime.setDescription('This is a monotonically increasing value in units of seconds that represents the total amount of time for which the instrument has been able to perform the measurement. It can be used to calculate the Total Time in the calculation of the availability.')
linkAvailabilityMeasurementState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 2, 1, 9), MeasurementState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: linkAvailabilityMeasurementState.setStatus('current')
if mibBuilder.loadTexts: linkAvailabilityMeasurementState.setDescription('Indicates the validity of the measurement')
linkAvailabilityUnavailableTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 2, 1, 10), Unsigned32()).setUnits('second').setMaxAccess("readonly")
if mibBuilder.loadTexts: linkAvailabilityUnavailableTime.setStatus('current')
if mibBuilder.loadTexts: linkAvailabilityUnavailableTime.setDescription('This is a monotonically increasing time in seconds which measures the total link unavailable time (LUAT) since the measuring system was last restarted.')
linkAvailabilityRatio = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 2, 1, 11), FloatingPoint()).setMaxAccess("readonly")
if mibBuilder.loadTexts: linkAvailabilityRatio.setStatus('current')
if mibBuilder.loadTexts: linkAvailabilityRatio.setDescription("This is the Link Availability ratio as a percentage (e.g. 99.643) measured over the previous 'Total Time' measurement period.")
linkAvailabilityInSUTI = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 2, 1, 12), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: linkAvailabilityInSUTI.setStatus('current')
if mibBuilder.loadTexts: linkAvailabilityInSUTI.setDescription("This object has the value 'true' if and only if the most recently completed Time Interval (TI) was a Severely Uncorrectable Time Interval (SETI).")
berRSinServiceTable = MibTable((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 3), )
if mibBuilder.loadTexts: berRSinServiceTable.setReference('TR 101 290 section 6.3.2')
if mibBuilder.loadTexts: berRSinServiceTable.setStatus('current')
if mibBuilder.loadTexts: berRSinServiceTable.setDescription('Measurement of BER before RS decoder')
berRSinServiceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 3, 1), ).setIndexNames((0, "DVB-MGTR101290-MIB", "berRSinServiceInputNumber"))
if mibBuilder.loadTexts: berRSinServiceEntry.setStatus('current')
if mibBuilder.loadTexts: berRSinServiceEntry.setDescription('Row specification')
berRSinServiceInputNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 3, 1, 1), InputNumber())
if mibBuilder.loadTexts: berRSinServiceInputNumber.setStatus('current')
if mibBuilder.loadTexts: berRSinServiceInputNumber.setDescription('Transport Stream on which the measurement is made')
berRSinServiceTestState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 3, 1, 2), TestState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: berRSinServiceTestState.setStatus('current')
if mibBuilder.loadTexts: berRSinServiceTestState.setDescription('This indicates whether the berRSinServiceValue is below the maximum.')
berRSinServiceEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 3, 1, 3), Enable().clone(namedValues=NamedValues(("testEnable", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: berRSinServiceEnable.setStatus('current')
if mibBuilder.loadTexts: berRSinServiceEnable.setDescription('Determines whether the threshold test and associated traps for this measurement are enabled.')
berRSinServiceCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 3, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: berRSinServiceCounter.setStatus('current')
if mibBuilder.loadTexts: berRSinServiceCounter.setDescription('Count of the number of times a threshold error has occurred for this measurement.')
berRSinServiceCounterDiscontinuity = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 3, 1, 5), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: berRSinServiceCounterDiscontinuity.setStatus('current')
if mibBuilder.loadTexts: berRSinServiceCounterDiscontinuity.setDescription('Provides the last time at which there was a discontinuity in the berRSinServiceCounter object.')
berRSinServiceCounterReset = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 3, 1, 6), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: berRSinServiceCounterReset.setStatus('current')
if mibBuilder.loadTexts: berRSinServiceCounterReset.setDescription("berRSinServiceCounter is reset to zero and berRSinServiceCounterDiscontinuity is set to the current time if 'true' is written to this object. When read, the value of this object is always 'false'.")
berRSinServiceLatestError = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 3, 1, 7), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: berRSinServiceLatestError.setStatus('current')
if mibBuilder.loadTexts: berRSinServiceLatestError.setDescription('The timestamp at the most recent occurrence of a threshold error on this measurement.')
berRSinServiceActiveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 3, 1, 8), ActiveTime()).setUnits('second').setMaxAccess("readonly")
if mibBuilder.loadTexts: berRSinServiceActiveTime.setStatus('current')
if mibBuilder.loadTexts: berRSinServiceActiveTime.setDescription('The total time when it has been possible to perform this measurement')
berRSinServiceMeasurementState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 3, 1, 9), MeasurementState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: berRSinServiceMeasurementState.setStatus('current')
if mibBuilder.loadTexts: berRSinServiceMeasurementState.setDescription('Indicates the validity of the measurement')
berRSinServiceValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 3, 1, 10), FloatingPoint()).setMaxAccess("readonly")
if mibBuilder.loadTexts: berRSinServiceValue.setReference('TR 101 290 section 6.3.2')
if mibBuilder.loadTexts: berRSinServiceValue.setStatus('current')
if mibBuilder.loadTexts: berRSinServiceValue.setDescription('This is the current BER as a numeric value, for example 0.0000023')
rfIFsignalPowerTable = MibTable((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 6), )
if mibBuilder.loadTexts: rfIFsignalPowerTable.setReference('TR 101 290 section 6.6')
if mibBuilder.loadTexts: rfIFsignalPowerTable.setStatus('current')
if mibBuilder.loadTexts: rfIFsignalPowerTable.setDescription('RF or IF signal power measurement')
rfIFsignalPowerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 6, 1), ).setIndexNames((0, "DVB-MGTR101290-MIB", "rfIFsignalPowerInputNumber"))
if mibBuilder.loadTexts: rfIFsignalPowerEntry.setStatus('current')
if mibBuilder.loadTexts: rfIFsignalPowerEntry.setDescription('Row specification')
rfIFsignalPowerInputNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 6, 1, 1), InputNumber())
if mibBuilder.loadTexts: rfIFsignalPowerInputNumber.setStatus('current')
if mibBuilder.loadTexts: rfIFsignalPowerInputNumber.setDescription('Transport Stream on which the measurement is made')
rfIFsignalPowerTestState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 6, 1, 2), TestState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rfIFsignalPowerTestState.setStatus('current')
if mibBuilder.loadTexts: rfIFsignalPowerTestState.setDescription('This indicates whether the rfIFsignalPowerValue is currently within the thresholds.')
rfIFsignalPowerEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 6, 1, 3), Enable().clone(namedValues=NamedValues(("testEnable", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rfIFsignalPowerEnable.setStatus('current')
if mibBuilder.loadTexts: rfIFsignalPowerEnable.setDescription('Determines whether the threshold test and associated traps for this measurement are enabled.')
rfIFsignalPowerCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 6, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rfIFsignalPowerCounter.setStatus('current')
if mibBuilder.loadTexts: rfIFsignalPowerCounter.setDescription('Count of the number of times a threshold error has occurred for this measurement.')
rfIFsignalPowerCounterDiscontinuity = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 6, 1, 5), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rfIFsignalPowerCounterDiscontinuity.setStatus('current')
if mibBuilder.loadTexts: rfIFsignalPowerCounterDiscontinuity.setDescription('Provides the last time at which there was a discontinuity in the rfIFsignalPowerCounter object.')
rfIFsignalPowerCounterReset = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 6, 1, 6), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rfIFsignalPowerCounterReset.setStatus('current')
if mibBuilder.loadTexts: rfIFsignalPowerCounterReset.setDescription("rfIFsignalPowerCounter is reset to zero and rfIFsignalPowerCounterDiscontinuity is set to the current time if 'true' is written to this object. When read, the value of this object is always 'false'.")
rfIFsignalPowerLatestError = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 6, 1, 7), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rfIFsignalPowerLatestError.setStatus('current')
if mibBuilder.loadTexts: rfIFsignalPowerLatestError.setDescription('The timestamp at the most recent occurrence of a threshold error on this measurement.')
rfIFsignalPowerActiveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 6, 1, 8), ActiveTime()).setUnits('second').setMaxAccess("readonly")
if mibBuilder.loadTexts: rfIFsignalPowerActiveTime.setStatus('current')
if mibBuilder.loadTexts: rfIFsignalPowerActiveTime.setDescription('The total time when it has been possible to perform this measurement')
rfIFsignalPowerMeasurementState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 6, 1, 9), MeasurementState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rfIFsignalPowerMeasurementState.setStatus('current')
if mibBuilder.loadTexts: rfIFsignalPowerMeasurementState.setDescription('Indicates the validity of the measurement')
rfIFsignalPowerValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 6, 1, 10), FloatingPoint()).setUnits('dBm').setMaxAccess("readonly")
if mibBuilder.loadTexts: rfIFsignalPowerValue.setStatus('current')
if mibBuilder.loadTexts: rfIFsignalPowerValue.setDescription('The current RF power expressed in dBm, which references 0 dBm as the power of 1 mW. ')
noisePowerTable = MibTable((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 7), )
if mibBuilder.loadTexts: noisePowerTable.setReference('TR 101 290 section 6.7')
if mibBuilder.loadTexts: noisePowerTable.setStatus('current')
if mibBuilder.loadTexts: noisePowerTable.setDescription('Noise power measurement')
noisePowerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 7, 1), ).setIndexNames((0, "DVB-MGTR101290-MIB", "noisePowerInputNumber"))
if mibBuilder.loadTexts: noisePowerEntry.setStatus('current')
if mibBuilder.loadTexts: noisePowerEntry.setDescription('Row specification')
noisePowerInputNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 7, 1, 1), InputNumber())
if mibBuilder.loadTexts: noisePowerInputNumber.setStatus('current')
if mibBuilder.loadTexts: noisePowerInputNumber.setDescription('Transport Stream on which the measurement is made')
noisePowerTestState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 7, 1, 2), TestState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: noisePowerTestState.setStatus('current')
if mibBuilder.loadTexts: noisePowerTestState.setDescription('This indicates whether the noisePowerValue is currently below the maximum limit.')
noisePowerEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 7, 1, 3), Enable().clone(namedValues=NamedValues(("testEnable", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: noisePowerEnable.setStatus('current')
if mibBuilder.loadTexts: noisePowerEnable.setDescription('Determines whether the threshold test and associated traps for this measurement are enabled.')
noisePowerCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 7, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: noisePowerCounter.setStatus('current')
if mibBuilder.loadTexts: noisePowerCounter.setDescription('Count of the number of times a threshold error has occurred for this measurement.')
noisePowerCounterDiscontinuity = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 7, 1, 5), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: noisePowerCounterDiscontinuity.setStatus('current')
if mibBuilder.loadTexts: noisePowerCounterDiscontinuity.setDescription('Provides the last time at which there was a discontinuity in the noisePowerCounter object.')
noisePowerCounterReset = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 7, 1, 6), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: noisePowerCounterReset.setStatus('current')
if mibBuilder.loadTexts: noisePowerCounterReset.setDescription("noisePowerCounter is reset to zero and noisePowerCounterDiscontinuity is set to the current time if 'true' is written to this object. When read, the value of this object is always 'false'.")
noisePowerLatestError = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 7, 1, 7), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: noisePowerLatestError.setStatus('current')
if mibBuilder.loadTexts: noisePowerLatestError.setDescription('The timestamp at the most recent occurrence of a threshold error on this measurement.')
noisePowerActiveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 7, 1, 8), ActiveTime()).setUnits('second').setMaxAccess("readonly")
if mibBuilder.loadTexts: noisePowerActiveTime.setStatus('current')
if mibBuilder.loadTexts: noisePowerActiveTime.setDescription('The total time when it has been possible to perform this measurement')
noisePowerMeasurementState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 7, 1, 9), MeasurementState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: noisePowerMeasurementState.setStatus('current')
if mibBuilder.loadTexts: noisePowerMeasurementState.setDescription('Indicates the validity of the measurement')
noisePowerValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 7, 1, 10), FloatingPoint()).setUnits('dBm').setMaxAccess("readonly")
if mibBuilder.loadTexts: noisePowerValue.setStatus('current')
if mibBuilder.loadTexts: noisePowerValue.setDescription('The current RF noise power expressed in dBm, which references 0 dBm as the power of 1 mW.')
iqAnalysisCS = MibIdentifier((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9))
merCSTable = MibTable((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 2), )
if mibBuilder.loadTexts: merCSTable.setReference('TR 101 290 section 6.9.2')
if mibBuilder.loadTexts: merCSTable.setStatus('current')
if mibBuilder.loadTexts: merCSTable.setDescription('Modulation Error Ratio (MER)')
merCSEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 2, 1), ).setIndexNames((0, "DVB-MGTR101290-MIB", "merCSInputNumber"))
if mibBuilder.loadTexts: merCSEntry.setStatus('current')
if mibBuilder.loadTexts: merCSEntry.setDescription('Row specification')
merCSInputNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 2, 1, 1), InputNumber())
if mibBuilder.loadTexts: merCSInputNumber.setStatus('current')
if mibBuilder.loadTexts: merCSInputNumber.setDescription('Transport Stream on which the measurement is made')
merCSTestState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 2, 1, 2), TestState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: merCSTestState.setStatus('current')
if mibBuilder.loadTexts: merCSTestState.setDescription('This indicates whether the merCSValue is currently below the maximum limit.')
merCSEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 2, 1, 3), Enable().clone(namedValues=NamedValues(("testEnable", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: merCSEnable.setStatus('current')
if mibBuilder.loadTexts: merCSEnable.setDescription('Determines whether the threshold test and associated traps for this measurement are enabled.')
merCSCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: merCSCounter.setStatus('current')
if mibBuilder.loadTexts: merCSCounter.setDescription('Count of the number of times a threshold error has occurred for this measurement.')
merCSCounterDiscontinuity = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 2, 1, 5), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: merCSCounterDiscontinuity.setStatus('current')
if mibBuilder.loadTexts: merCSCounterDiscontinuity.setDescription('Provides the last time at which there was a discontinuity in the merCSCounter object.')
merCSCounterReset = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 2, 1, 6), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: merCSCounterReset.setStatus('current')
if mibBuilder.loadTexts: merCSCounterReset.setDescription("merCSCounter is reset to zero and merCSCounterDiscontinuity is set to the current time if 'true' is written to this object. When read, the value of this object is always 'false'.")
merCSLatestError = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 2, 1, 7), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: merCSLatestError.setStatus('current')
if mibBuilder.loadTexts: merCSLatestError.setDescription('The timestamp at the most recent occurrence of a threshold error on this measurement.')
merCSActiveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 2, 1, 8), ActiveTime()).setUnits('second').setMaxAccess("readonly")
if mibBuilder.loadTexts: merCSActiveTime.setStatus('current')
if mibBuilder.loadTexts: merCSActiveTime.setDescription('The total time when it has been possible to perform this measurement')
merCSMeasurementState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 2, 1, 9), MeasurementState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: merCSMeasurementState.setStatus('current')
if mibBuilder.loadTexts: merCSMeasurementState.setDescription('Indicates the validity of the measurement')
merCSValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 2, 1, 10), FloatingPoint()).setUnits('dB').setMaxAccess("readonly")
if mibBuilder.loadTexts: merCSValue.setStatus('current')
if mibBuilder.loadTexts: merCSValue.setDescription('The Modulation Error Ratio expressed in dB')
steCS = MibIdentifier((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 3))
steMeanCSTable = MibTable((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 3, 1), )
if mibBuilder.loadTexts: steMeanCSTable.setReference('TR 101 290 section 6.9.3')
if mibBuilder.loadTexts: steMeanCSTable.setStatus('current')
if mibBuilder.loadTexts: steMeanCSTable.setDescription('System Target Error (mean value)')
steMeanCSEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 3, 1, 1), ).setIndexNames((0, "DVB-MGTR101290-MIB", "steMeanCSInputNumber"))
if mibBuilder.loadTexts: steMeanCSEntry.setStatus('current')
if mibBuilder.loadTexts: steMeanCSEntry.setDescription('Row specification')
steMeanCSInputNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 3, 1, 1, 1), InputNumber())
if mibBuilder.loadTexts: steMeanCSInputNumber.setStatus('current')
if mibBuilder.loadTexts: steMeanCSInputNumber.setDescription('Transport Stream on which the measurement is made')
steMeanCSTestState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 3, 1, 1, 2), TestState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: steMeanCSTestState.setStatus('current')
if mibBuilder.loadTexts: steMeanCSTestState.setDescription('This indicates whether the steMeanCSValue is currently within the thresholds.')
steMeanCSEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 3, 1, 1, 3), Enable().clone(namedValues=NamedValues(("testEnable", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: steMeanCSEnable.setStatus('current')
if mibBuilder.loadTexts: steMeanCSEnable.setDescription('Determines whether the threshold test and associated traps for this measurement are enabled.')
steMeanCSCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 3, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: steMeanCSCounter.setStatus('current')
if mibBuilder.loadTexts: steMeanCSCounter.setDescription('Count of the number of times a threshold error has occurred for this measurement.')
steMeanCSCounterDiscontinuity = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 3, 1, 1, 5), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: steMeanCSCounterDiscontinuity.setStatus('current')
if mibBuilder.loadTexts: steMeanCSCounterDiscontinuity.setDescription('Provides the last time at which there was a discontinuity in the counter object.')
steMeanCSCounterReset = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 3, 1, 1, 6), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: steMeanCSCounterReset.setStatus('current')
if mibBuilder.loadTexts: steMeanCSCounterReset.setDescription("The counter object is reset to zero and the counter discontinuity object is set to the current time if 'true' is written to this object. When read, the value of this object is always 'false'.")
steMeanCSLatestError = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 3, 1, 1, 7), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: steMeanCSLatestError.setStatus('current')
if mibBuilder.loadTexts: steMeanCSLatestError.setDescription('The timestamp at the most recent occurrence of a threshold error on this measurement.')
steMeanCSActiveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 3, 1, 1, 8), ActiveTime()).setUnits('second').setMaxAccess("readonly")
if mibBuilder.loadTexts: steMeanCSActiveTime.setStatus('current')
if mibBuilder.loadTexts: steMeanCSActiveTime.setDescription('The total time when it has been possible to perform this measurement')
steMeanCSMeasurementState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 3, 1, 1, 9), MeasurementState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: steMeanCSMeasurementState.setStatus('current')
if mibBuilder.loadTexts: steMeanCSMeasurementState.setDescription('Indicates the validity of the measurement')
steMeanCSValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 3, 1, 1, 10), FloatingPoint()).setMaxAccess("readonly")
if mibBuilder.loadTexts: steMeanCSValue.setStatus('current')
if mibBuilder.loadTexts: steMeanCSValue.setDescription('The current System Target Error Mean as a numeric value')
steDeviationCSTable = MibTable((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 3, 2), )
if mibBuilder.loadTexts: steDeviationCSTable.setReference('TR 101 290 section 6.9.3')
if mibBuilder.loadTexts: steDeviationCSTable.setStatus('current')
if mibBuilder.loadTexts: steDeviationCSTable.setDescription('System Target Error (deviation value)')
steDeviationCSEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 3, 2, 1), ).setIndexNames((0, "DVB-MGTR101290-MIB", "steDeviationCSInputNumber"))
if mibBuilder.loadTexts: steDeviationCSEntry.setStatus('current')
if mibBuilder.loadTexts: steDeviationCSEntry.setDescription('Row specification')
steDeviationCSInputNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 3, 2, 1, 1), InputNumber())
if mibBuilder.loadTexts: steDeviationCSInputNumber.setStatus('current')
if mibBuilder.loadTexts: steDeviationCSInputNumber.setDescription('Transport Stream on which the measurement is made')
steDeviationCSTestState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 3, 2, 1, 2), TestState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: steDeviationCSTestState.setStatus('current')
if mibBuilder.loadTexts: steDeviationCSTestState.setDescription('This indicates whether the steDeviationCSValue is currently within the thresholds.')
steDeviationCSEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 3, 2, 1, 3), Enable().clone(namedValues=NamedValues(("testEnable", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: steDeviationCSEnable.setStatus('current')
if mibBuilder.loadTexts: steDeviationCSEnable.setDescription('Determines whether the threshold test and associated traps for this measurement are enabled.')
steDeviationCSCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 3, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: steDeviationCSCounter.setStatus('current')
if mibBuilder.loadTexts: steDeviationCSCounter.setDescription('Count of the number of times a threshold error has occurred for this measurement.')
steDeviationCSCounterDiscontinuity = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 3, 2, 1, 5), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: steDeviationCSCounterDiscontinuity.setStatus('current')
if mibBuilder.loadTexts: steDeviationCSCounterDiscontinuity.setDescription('Provides the last time at which there was a discontinuity in the counter object.')
steDeviationCSCounterReset = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 3, 2, 1, 6), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: steDeviationCSCounterReset.setStatus('current')
if mibBuilder.loadTexts: steDeviationCSCounterReset.setDescription("The counter object is reset to zero and the counter discontinuity object is set to the current time if 'true' is written to this object. When read, the value of this object is always 'false'.")
steDeviationCSLatestError = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 3, 2, 1, 7), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: steDeviationCSLatestError.setStatus('current')
if mibBuilder.loadTexts: steDeviationCSLatestError.setDescription('The timestamp at the most recent occurrence of a threshold error on this measurement.')
steDeviationCSActiveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 3, 2, 1, 8), ActiveTime()).setUnits('second').setMaxAccess("readonly")
if mibBuilder.loadTexts: steDeviationCSActiveTime.setStatus('current')
if mibBuilder.loadTexts: steDeviationCSActiveTime.setDescription('The total time when it has been possible to perform this measurement ')
steDeviationCSMeasurementState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 3, 2, 1, 9), MeasurementState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: steDeviationCSMeasurementState.setStatus('current')
if mibBuilder.loadTexts: steDeviationCSMeasurementState.setDescription('Indicates the validity of the measurement')
steDeviationCSValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 3, 2, 1, 10), FloatingPoint()).setMaxAccess("readonly")
if mibBuilder.loadTexts: steDeviationCSValue.setStatus('current')
if mibBuilder.loadTexts: steDeviationCSValue.setDescription('The current System Target Error Deviation as a numeric value')
csCSTable = MibTable((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 4), )
if mibBuilder.loadTexts: csCSTable.setReference('TR 101 290 section 6.9.4')
if mibBuilder.loadTexts: csCSTable.setStatus('current')
if mibBuilder.loadTexts: csCSTable.setDescription('Carrier suppression measurement')
csCSEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 4, 1), ).setIndexNames((0, "DVB-MGTR101290-MIB", "csCSInputNumber"))
if mibBuilder.loadTexts: csCSEntry.setStatus('current')
if mibBuilder.loadTexts: csCSEntry.setDescription('Row specification')
csCSInputNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 4, 1, 1), InputNumber())
if mibBuilder.loadTexts: csCSInputNumber.setStatus('current')
if mibBuilder.loadTexts: csCSInputNumber.setDescription('Transport Stream on which the measurement is made')
csCSTestState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 4, 1, 2), TestState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csCSTestState.setStatus('current')
if mibBuilder.loadTexts: csCSTestState.setDescription('This indicates whether the csCSValue is currently within the thresholds.')
csCSEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 4, 1, 3), Enable().clone(namedValues=NamedValues(("testEnable", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: csCSEnable.setStatus('current')
if mibBuilder.loadTexts: csCSEnable.setDescription('Determines whether the threshold test and associated traps for this measurement are enabled.')
csCSCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 4, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csCSCounter.setStatus('current')
if mibBuilder.loadTexts: csCSCounter.setDescription('Count of the number of times a threshold error has occurred for this measurement.')
csCSCounterDiscontinuity = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 4, 1, 5), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csCSCounterDiscontinuity.setStatus('current')
if mibBuilder.loadTexts: csCSCounterDiscontinuity.setDescription('Provides the last time at which there was a discontinuity in the counter object.')
csCSCounterReset = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 4, 1, 6), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: csCSCounterReset.setStatus('current')
if mibBuilder.loadTexts: csCSCounterReset.setDescription("The counter object is reset to zero and the counter discontinuity object is set to the current time if 'true' is written to this object. When read, the value of this object is always 'false'.")
csCSLatestError = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 4, 1, 7), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csCSLatestError.setStatus('current')
if mibBuilder.loadTexts: csCSLatestError.setDescription('The timestamp at the most recent occurrence of a threshold error on this measurement.')
csCSActiveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 4, 1, 8), ActiveTime()).setUnits('second').setMaxAccess("readonly")
if mibBuilder.loadTexts: csCSActiveTime.setStatus('current')
if mibBuilder.loadTexts: csCSActiveTime.setDescription('The total time when it has been possible to perform this measurement')
csCSMeasurementState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 4, 1, 9), MeasurementState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csCSMeasurementState.setStatus('current')
if mibBuilder.loadTexts: csCSMeasurementState.setDescription('Indicates the validity of the measurement')
csCSValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 4, 1, 10), FloatingPoint()).setUnits('dB').setMaxAccess("readonly")
if mibBuilder.loadTexts: csCSValue.setStatus('current')
if mibBuilder.loadTexts: csCSValue.setDescription('The current Carrier Suppression value in dB.')
aiCSTable = MibTable((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 5), )
if mibBuilder.loadTexts: aiCSTable.setReference('TR 101 290 section 6.9.5')
if mibBuilder.loadTexts: aiCSTable.setStatus('current')
if mibBuilder.loadTexts: aiCSTable.setDescription('Amplitude Imbalance (AI) measurement')
aiCSEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 5, 1), ).setIndexNames((0, "DVB-MGTR101290-MIB", "aiCSInputNumber"))
if mibBuilder.loadTexts: aiCSEntry.setStatus('current')
if mibBuilder.loadTexts: aiCSEntry.setDescription('Row specification')
aiCSInputNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 5, 1, 1), InputNumber())
if mibBuilder.loadTexts: aiCSInputNumber.setStatus('current')
if mibBuilder.loadTexts: aiCSInputNumber.setDescription('Transport Stream on which the measurement is made')
aiCSTestState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 5, 1, 2), TestState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aiCSTestState.setStatus('current')
if mibBuilder.loadTexts: aiCSTestState.setDescription('This indicates whether the aiCSValue is currently within the thresholds.')
aiCSEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 5, 1, 3), Enable().clone(namedValues=NamedValues(("testEnable", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCSEnable.setStatus('current')
if mibBuilder.loadTexts: aiCSEnable.setDescription('Determines whether the threshold test and associated traps for this measurement are enabled.')
aiCSCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 5, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aiCSCounter.setStatus('current')
if mibBuilder.loadTexts: aiCSCounter.setDescription('Count of the number of times a threshold error has occurred for this measurement.')
aiCSCounterDiscontinuity = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 5, 1, 5), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aiCSCounterDiscontinuity.setStatus('current')
if mibBuilder.loadTexts: aiCSCounterDiscontinuity.setDescription('Provides the last time at which there was a discontinuity in the counter object.')
aiCSCounterReset = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 5, 1, 6), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCSCounterReset.setStatus('current')
if mibBuilder.loadTexts: aiCSCounterReset.setDescription("The counter object is reset to zero and the counter discontinuity object is set to the current time if 'true' is written to this object. When read, the value of this object is always 'false'.")
aiCSLatestError = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 5, 1, 7), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aiCSLatestError.setStatus('current')
if mibBuilder.loadTexts: aiCSLatestError.setDescription('The timestamp at the most recent occurrence of a threshold error on this measurement.')
aiCSActiveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 5, 1, 8), ActiveTime()).setUnits('second').setMaxAccess("readonly")
if mibBuilder.loadTexts: aiCSActiveTime.setStatus('current')
if mibBuilder.loadTexts: aiCSActiveTime.setDescription('The total time when it has been possible to perform this measurement')
aiCSMeasurementState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 5, 1, 9), MeasurementState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aiCSMeasurementState.setStatus('current')
if mibBuilder.loadTexts: aiCSMeasurementState.setDescription('Indicates the validity of the measurement')
aiCSValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 5, 1, 10), FloatingPoint()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aiCSValue.setStatus('current')
if mibBuilder.loadTexts: aiCSValue.setDescription('The current Amplitude Imbalance as a percentage')
qeCSTable = MibTable((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 6), )
if mibBuilder.loadTexts: qeCSTable.setReference('TR 101 290 section 6.9.6')
if mibBuilder.loadTexts: qeCSTable.setStatus('current')
if mibBuilder.loadTexts: qeCSTable.setDescription('Quadrature Error (QE) measurement')
qeCSEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 6, 1), ).setIndexNames((0, "DVB-MGTR101290-MIB", "qeCSInputNumber"))
if mibBuilder.loadTexts: qeCSEntry.setStatus('current')
if mibBuilder.loadTexts: qeCSEntry.setDescription('Row specification')
qeCSInputNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 6, 1, 1), InputNumber())
if mibBuilder.loadTexts: qeCSInputNumber.setStatus('current')
if mibBuilder.loadTexts: qeCSInputNumber.setDescription('Transport Stream on which the measurement is made')
qeCSTestState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 6, 1, 2), TestState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: qeCSTestState.setStatus('current')
if mibBuilder.loadTexts: qeCSTestState.setDescription('This indicates whether the qeCSValue is currently within the thresholds.')
qeCSEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 6, 1, 3), Enable().clone(namedValues=NamedValues(("testEnable", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qeCSEnable.setStatus('current')
if mibBuilder.loadTexts: qeCSEnable.setDescription('Determines whether the threshold test and associated traps for this measurement are enabled.')
qeCSCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 6, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: qeCSCounter.setStatus('current')
if mibBuilder.loadTexts: qeCSCounter.setDescription('Count of the number of times a threshold error has occurred for this measurement.')
qeCSCounterDiscontinuity = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 6, 1, 5), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: qeCSCounterDiscontinuity.setStatus('current')
if mibBuilder.loadTexts: qeCSCounterDiscontinuity.setDescription('Provides the last time at which there was a discontinuity in the counter object.')
qeCSCounterReset = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 6, 1, 6), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qeCSCounterReset.setStatus('current')
if mibBuilder.loadTexts: qeCSCounterReset.setDescription("The counter object is reset to zero and the counter discontinuity object is set to the current time if 'true' is written to this object. When read, the value of this object is always 'false'.")
qeCSLatestError = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 6, 1, 7), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: qeCSLatestError.setStatus('current')
if mibBuilder.loadTexts: qeCSLatestError.setDescription('The timestamp at the most recent occurrence of a threshold error on this measurement.')
qeCSActiveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 6, 1, 8), ActiveTime()).setUnits('second').setMaxAccess("readonly")
if mibBuilder.loadTexts: qeCSActiveTime.setStatus('current')
if mibBuilder.loadTexts: qeCSActiveTime.setDescription('The total time when it has been possible to perform this measurement')
qeCSMeasurementState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 6, 1, 9), MeasurementState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: qeCSMeasurementState.setStatus('current')
if mibBuilder.loadTexts: qeCSMeasurementState.setDescription('Indicates the validity of the measurement')
qeCSValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 6, 1, 10), FloatingPoint()).setUnits('degree').setMaxAccess("readonly")
if mibBuilder.loadTexts: qeCSValue.setStatus('current')
if mibBuilder.loadTexts: qeCSValue.setDescription('The current Quadrature Error value in degrees.')
rteCSTable = MibTable((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 7), )
if mibBuilder.loadTexts: rteCSTable.setReference('TR 101 290 section 6.9.7')
if mibBuilder.loadTexts: rteCSTable.setStatus('current')
if mibBuilder.loadTexts: rteCSTable.setDescription('Residual Target Error (RTE) measurement')
rteCSEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 7, 1), ).setIndexNames((0, "DVB-MGTR101290-MIB", "rteCSInputNumber"))
if mibBuilder.loadTexts: rteCSEntry.setStatus('current')
if mibBuilder.loadTexts: rteCSEntry.setDescription('Row description')
rteCSInputNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 7, 1, 1), InputNumber())
if mibBuilder.loadTexts: rteCSInputNumber.setStatus('current')
if mibBuilder.loadTexts: rteCSInputNumber.setDescription('Transport Stream on which the measurement is made')
rteCSTestState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 7, 1, 2), TestState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rteCSTestState.setStatus('current')
if mibBuilder.loadTexts: rteCSTestState.setDescription('This indicates whether the rteCSValue is currently within the thresholds.')
rteCSEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 7, 1, 3), Enable().clone(namedValues=NamedValues(("testEnable", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rteCSEnable.setStatus('current')
if mibBuilder.loadTexts: rteCSEnable.setDescription('Determines whether the threshold test and associated traps for this measurement are enabled.')
rteCSCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 7, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rteCSCounter.setStatus('current')
if mibBuilder.loadTexts: rteCSCounter.setDescription('Count of the number of times a threshold error has occurred for this measurement.')
rteCSCounterDiscontinuity = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 7, 1, 5), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rteCSCounterDiscontinuity.setStatus('current')
if mibBuilder.loadTexts: rteCSCounterDiscontinuity.setDescription('Provides the last time at which there was a discontinuity in the counter object.')
rteCSCounterReset = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 7, 1, 6), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rteCSCounterReset.setStatus('current')
if mibBuilder.loadTexts: rteCSCounterReset.setDescription("The counter object is reset to zero and the counter discontinuity object is set to the current time if 'true' is written to this object. When read, the value of this object is always 'false'.")
rteCSLatestError = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 7, 1, 7), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rteCSLatestError.setStatus('current')
if mibBuilder.loadTexts: rteCSLatestError.setDescription('The timestamp at the most recent occurrence of a threshold error on this measurement.')
rteCSActiveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 7, 1, 8), ActiveTime()).setUnits('second').setMaxAccess("readonly")
if mibBuilder.loadTexts: rteCSActiveTime.setStatus('current')
if mibBuilder.loadTexts: rteCSActiveTime.setDescription('The total time when it has been possible to perform this measurement')
rteCSMeasurementState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 7, 1, 9), MeasurementState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rteCSMeasurementState.setStatus('current')
if mibBuilder.loadTexts: rteCSMeasurementState.setDescription('Indicates the validity of the measurement')
rteCSValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 7, 1, 10), FloatingPoint()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rteCSValue.setStatus('current')
if mibBuilder.loadTexts: rteCSValue.setDescription('The current Residual Target Error value as a numeric value.')
ciCSTable = MibTable((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 8), )
if mibBuilder.loadTexts: ciCSTable.setReference('TR 101 290 section 6.9.8')
if mibBuilder.loadTexts: ciCSTable.setStatus('current')
if mibBuilder.loadTexts: ciCSTable.setDescription('Coherent Interferer measurement')
ciCSEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 8, 1), ).setIndexNames((0, "DVB-MGTR101290-MIB", "ciCSInputNumber"))
if mibBuilder.loadTexts: ciCSEntry.setStatus('current')
if mibBuilder.loadTexts: ciCSEntry.setDescription('Row specification')
ciCSInputNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 8, 1, 1), InputNumber())
if mibBuilder.loadTexts: ciCSInputNumber.setStatus('current')
if mibBuilder.loadTexts: ciCSInputNumber.setDescription('Transport Stream on which the measurement is made')
ciCSTestState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 8, 1, 2), TestState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciCSTestState.setStatus('current')
if mibBuilder.loadTexts: ciCSTestState.setDescription('This indicates whether the ciCSValue is currently within the thresholds.')
ciCSEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 8, 1, 3), Enable().clone(namedValues=NamedValues(("testEnable", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciCSEnable.setStatus('current')
if mibBuilder.loadTexts: ciCSEnable.setDescription('Determines whether the threshold test and associated traps for this measurement are enabled.')
ciCSCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 8, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciCSCounter.setStatus('current')
if mibBuilder.loadTexts: ciCSCounter.setDescription('Count of the number of times a threshold error has occurred for this measurement.')
ciCSCounterDiscontinuity = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 8, 1, 5), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciCSCounterDiscontinuity.setStatus('current')
if mibBuilder.loadTexts: ciCSCounterDiscontinuity.setDescription('Provides the last time at which there was a discontinuity in the counter object.')
ciCSCounterReset = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 8, 1, 6), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciCSCounterReset.setStatus('current')
if mibBuilder.loadTexts: ciCSCounterReset.setDescription("The counter object is reset to zero and the counter discontinuity object is set to the current time if 'true' is written to this object. When read, the value of this object is always 'false'.")
ciCSLatestError = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 8, 1, 7), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciCSLatestError.setStatus('current')
if mibBuilder.loadTexts: ciCSLatestError.setDescription('The timestamp at the most recent occurrence of a threshold error on this measurement.')
ciCSActiveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 8, 1, 8), ActiveTime()).setUnits('second').setMaxAccess("readonly")
if mibBuilder.loadTexts: ciCSActiveTime.setStatus('current')
if mibBuilder.loadTexts: ciCSActiveTime.setDescription('The total time when it has been possible to perform this measurement')
ciCSMeasurementState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 8, 1, 9), MeasurementState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciCSMeasurementState.setStatus('current')
if mibBuilder.loadTexts: ciCSMeasurementState.setDescription('Indicates the validity of the measurement')
ciCSValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 8, 1, 10), FloatingPoint()).setUnits('dB').setMaxAccess("readonly")
if mibBuilder.loadTexts: ciCSValue.setStatus('current')
if mibBuilder.loadTexts: ciCSValue.setDescription('The current Coherent Interferer value in dB.')
pjCSTable = MibTable((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 9), )
if mibBuilder.loadTexts: pjCSTable.setReference('TR 101 290 section 6.9.9')
if mibBuilder.loadTexts: pjCSTable.setStatus('current')
if mibBuilder.loadTexts: pjCSTable.setDescription('Phase Jitter (PJ) measurement')
pjCSEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 9, 1), ).setIndexNames((0, "DVB-MGTR101290-MIB", "pjCSInputNumber"))
if mibBuilder.loadTexts: pjCSEntry.setStatus('current')
if mibBuilder.loadTexts: pjCSEntry.setDescription('Row specification')
pjCSInputNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 9, 1, 1), InputNumber())
if mibBuilder.loadTexts: pjCSInputNumber.setStatus('current')
if mibBuilder.loadTexts: pjCSInputNumber.setDescription('Transport Stream on which the measurement is made')
pjCSTestState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 9, 1, 2), TestState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pjCSTestState.setStatus('current')
if mibBuilder.loadTexts: pjCSTestState.setDescription('This indicates whether the pjCSValue is currently within the thresholds.')
pjCSEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 9, 1, 3), Enable().clone(namedValues=NamedValues(("testEnable", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pjCSEnable.setStatus('current')
if mibBuilder.loadTexts: pjCSEnable.setDescription('Determines whether the threshold test and associated traps for this measurement are enabled.')
pjCSCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 9, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pjCSCounter.setStatus('current')
if mibBuilder.loadTexts: pjCSCounter.setDescription('Count of the number of times a threshold error has occurred for this measurement.')
pjCSCounterDiscontinuity = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 9, 1, 5), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pjCSCounterDiscontinuity.setStatus('current')
if mibBuilder.loadTexts: pjCSCounterDiscontinuity.setDescription('Provides the last time at which there was a discontinuity in the counter object.')
pjCSCounterReset = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 9, 1, 6), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pjCSCounterReset.setStatus('current')
if mibBuilder.loadTexts: pjCSCounterReset.setDescription("The counter object is reset to zero and the counter discontinuity object is set to the current time if 'true' is written to this object. When read, the value of this object is always 'false'.")
pjCSLatestError = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 9, 1, 7), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pjCSLatestError.setStatus('current')
if mibBuilder.loadTexts: pjCSLatestError.setDescription('The timestamp at the most recent occurrence of a threshold error on this measurement.')
pjCSActiveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 9, 1, 8), ActiveTime()).setUnits('second').setMaxAccess("readonly")
if mibBuilder.loadTexts: pjCSActiveTime.setStatus('current')
if mibBuilder.loadTexts: pjCSActiveTime.setDescription('The total time when it has been possible to perform this measurement')
pjCSMeasurementState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 9, 1, 9), MeasurementState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pjCSMeasurementState.setStatus('current')
if mibBuilder.loadTexts: pjCSMeasurementState.setDescription('Indicates the validity of the measurement')
pjCSValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 9, 1, 10), FloatingPoint()).setUnits('degree').setMaxAccess("readonly")
if mibBuilder.loadTexts: pjCSValue.setStatus('current')
if mibBuilder.loadTexts: pjCSValue.setDescription('The current Phase Jitter value in degrees.')
snrCSTable = MibTable((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 10), )
if mibBuilder.loadTexts: snrCSTable.setReference('TR 101 290 section 6.9.10')
if mibBuilder.loadTexts: snrCSTable.setStatus('current')
if mibBuilder.loadTexts: snrCSTable.setDescription('Signal-to-Noise Ratio (SNR)')
snrCSEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 10, 1), ).setIndexNames((0, "DVB-MGTR101290-MIB", "snrCSInputNumber"))
if mibBuilder.loadTexts: snrCSEntry.setStatus('current')
if mibBuilder.loadTexts: snrCSEntry.setDescription('Row specification')
snrCSInputNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 10, 1, 1), InputNumber())
if mibBuilder.loadTexts: snrCSInputNumber.setStatus('current')
if mibBuilder.loadTexts: snrCSInputNumber.setDescription('Transport Stream on which the measurement is made')
snrCSTestState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 10, 1, 2), TestState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snrCSTestState.setStatus('current')
if mibBuilder.loadTexts: snrCSTestState.setDescription('This indicates whether the snrCSValue is currently within the thresholds.')
snrCSEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 10, 1, 3), Enable().clone(namedValues=NamedValues(("testEnable", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snrCSEnable.setStatus('current')
if mibBuilder.loadTexts: snrCSEnable.setDescription('Determines whether the threshold test and associated traps for this measurement are enabled.')
snrCSCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 10, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snrCSCounter.setStatus('current')
if mibBuilder.loadTexts: snrCSCounter.setDescription('Count of the number of times a threshold error has occurred for this measurement.')
snrCSCounterDiscontinuity = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 10, 1, 5), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snrCSCounterDiscontinuity.setStatus('current')
if mibBuilder.loadTexts: snrCSCounterDiscontinuity.setDescription('Provides the last time at which there was a discontinuity in the counter object.')
snrCSCounterReset = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 10, 1, 6), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snrCSCounterReset.setStatus('current')
if mibBuilder.loadTexts: snrCSCounterReset.setDescription("The counter object is reset to zero and the counter discontinuity object is set to the current time if 'true' is written to this object. When read, the value of this object is always 'false'.")
snrCSLatestError = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 10, 1, 7), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snrCSLatestError.setStatus('current')
if mibBuilder.loadTexts: snrCSLatestError.setDescription('The timestamp at the most recent occurrence of a threshold error on this measurement.')
snrCSActiveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 10, 1, 8), ActiveTime()).setUnits('second').setMaxAccess("readonly")
if mibBuilder.loadTexts: snrCSActiveTime.setStatus('current')
if mibBuilder.loadTexts: snrCSActiveTime.setDescription('The total time when it has been possible to perform this measurement')
snrCSMeasurementState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 10, 1, 9), MeasurementState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snrCSMeasurementState.setStatus('current')
if mibBuilder.loadTexts: snrCSMeasurementState.setDescription('Indicates the validity of the measurement')
snrCSValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 9, 10, 1, 10), FloatingPoint()).setUnits('dB').setMaxAccess("readonly")
if mibBuilder.loadTexts: snrCSValue.setStatus('current')
if mibBuilder.loadTexts: snrCSValue.setDescription('The current Signal-to-Noise value in dB.')
cableSatPreferencesTable = MibTable((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 100), )
if mibBuilder.loadTexts: cableSatPreferencesTable.setStatus('current')
if mibBuilder.loadTexts: cableSatPreferencesTable.setDescription('Table containing per input configuration information for cable and satellite common measurements.')
cableSatPreferencesEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 100, 1), ).setIndexNames((0, "DVB-MGTR101290-MIB", "cableSatPrefInputNumber"))
if mibBuilder.loadTexts: cableSatPreferencesEntry.setStatus('current')
if mibBuilder.loadTexts: cableSatPreferencesEntry.setDescription('Row specification')
cableSatPrefInputNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 100, 1, 1), InputNumber())
if mibBuilder.loadTexts: cableSatPrefInputNumber.setStatus('current')
if mibBuilder.loadTexts: cableSatPrefInputNumber.setDescription('Transport Stream input to which the preferences apply')
cableSatPrefCentreFrequency = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 100, 1, 2), FloatingPoint()).setUnits('MHz').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cableSatPrefCentreFrequency.setStatus('current')
if mibBuilder.loadTexts: cableSatPrefCentreFrequency.setDescription("This is the centre frequency to which the measuring equipment is tuned for making cable and satellite measurements. This frequency is the actual input frequency to the measuring equipment, which may be at an intermediate frequency (IF) rather than the final RF. This setting affects the objects in the 'tr101290Cable' and 'tr101290Satellite' branches of the MIB as well as the 'tr101290CableSat' branch.")
cableSatPrefModulation = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 100, 1, 3), Modulation()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cableSatPrefModulation.setStatus('current')
if mibBuilder.loadTexts: cableSatPrefModulation.setDescription("This is the modulation which the measuring equipment expects to see and against which it makes modulation measurements. This applies to cable and satellite measurements. This setting affects the objects in the 'tr101290Cable' and 'tr101290Satellite' branches of the MIB as well as the 'tr101290CableSat' branch.")
cableSatPrefSysAvailUATMode = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 100, 1, 4), UATMode()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cableSatPrefSysAvailUATMode.setReference('TR 101 290 section 5.4.5')
if mibBuilder.loadTexts: cableSatPrefSysAvailUATMode.setStatus('current')
if mibBuilder.loadTexts: cableSatPrefSysAvailUATMode.setDescription("Determines whether the 'N consecutive' or 'rolling window' mode of determining the start of a period of Unavailable Time (UAT) is used. If the 'N consecutive' mode is selected, the 'M' and 'T' preference parameters are ignored. Likewise, if the 'rolling window' mode is selected, the 'N' preference parameter is ignored.")
cableSatPrefSysAvailN = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 100, 1, 5), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cableSatPrefSysAvailN.setReference('TR 101 290 section 5.4.5')
if mibBuilder.loadTexts: cableSatPrefSysAvailN.setStatus('current')
if mibBuilder.loadTexts: cableSatPrefSysAvailN.setDescription('The N value used to identify the start and end of a period of unavailable time (UAT).')
cableSatPrefSysAvailT = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 100, 1, 6), FloatingPoint()).setUnits('second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cableSatPrefSysAvailT.setReference('TR 101 290 section 5.4.5')
if mibBuilder.loadTexts: cableSatPrefSysAvailT.setStatus('current')
if mibBuilder.loadTexts: cableSatPrefSysAvailT.setDescription('The T value used to identify the start and end of a period of unavailable time (UAT).')
cableSatPrefSysAvailM = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 100, 1, 7), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cableSatPrefSysAvailM.setReference('TR 101 290 section 5.4.5')
if mibBuilder.loadTexts: cableSatPrefSysAvailM.setStatus('current')
if mibBuilder.loadTexts: cableSatPrefSysAvailM.setDescription('The M value used to identify the start and end of a period of unavailable time (UAT).')
cableSatPrefSysAvailTI = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 100, 1, 8), FloatingPoint()).setUnits('second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cableSatPrefSysAvailTI.setReference('TR 101 290 section 5.4.4')
if mibBuilder.loadTexts: cableSatPrefSysAvailTI.setStatus('current')
if mibBuilder.loadTexts: cableSatPrefSysAvailTI.setDescription('Each Time Interval of this length is assessed as to whether it is a Severely Errored Time Interval.')
cableSatPrefSysAvailEBPerCent = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 100, 1, 9), FloatingPoint()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cableSatPrefSysAvailEBPerCent.setReference('TR 101 290 section 5.4.4')
if mibBuilder.loadTexts: cableSatPrefSysAvailEBPerCent.setStatus('current')
if mibBuilder.loadTexts: cableSatPrefSysAvailEBPerCent.setDescription("If more than this percentage of blocks within a Time Interval is an Errored Block, the Time Interval is a Severely Errored Time Interval (SETI). Example values are: '1.53', '10', '0.33'.")
cableSatPrefSysAvailTotalTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 100, 1, 10), FloatingPoint()).setUnits('second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cableSatPrefSysAvailTotalTime.setReference('TR 101 290 section 6.1')
if mibBuilder.loadTexts: cableSatPrefSysAvailTotalTime.setStatus('current')
if mibBuilder.loadTexts: cableSatPrefSysAvailTotalTime.setDescription('The Total Time over which the System Availability is calculated.')
cableSatPrefLinkAvailUATMode = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 100, 1, 11), UATMode()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cableSatPrefLinkAvailUATMode.setReference('TR 101 290 section 6.2')
if mibBuilder.loadTexts: cableSatPrefLinkAvailUATMode.setStatus('current')
if mibBuilder.loadTexts: cableSatPrefLinkAvailUATMode.setDescription("Determines whether the 'N consecutive' or 'rolling window' mode of determining the start of a period of Link Unavailable Time (LUAT) is used. If the 'N consecutive' mode is selected, the 'M' and 'T' preference parameters are ignored. Likewise, if the 'rolling window' mode is selected, the 'N' preference parameter is ignored.")
cableSatPrefLinkAvailN = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 100, 1, 12), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cableSatPrefLinkAvailN.setReference('TR 101 290 section 6.2')
if mibBuilder.loadTexts: cableSatPrefLinkAvailN.setStatus('current')
if mibBuilder.loadTexts: cableSatPrefLinkAvailN.setDescription('The N value used to identify the start and end of a period of Link Unavailable Time (LUAT).')
cableSatPrefLinkAvailT = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 100, 1, 13), FloatingPoint()).setUnits('second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cableSatPrefLinkAvailT.setReference('TR 101 290 section 6.2')
if mibBuilder.loadTexts: cableSatPrefLinkAvailT.setStatus('current')
if mibBuilder.loadTexts: cableSatPrefLinkAvailT.setDescription('The T value used to identify the start and end of a period of Link Unavailable Time (LUAT).')
cableSatPrefLinkAvailM = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 100, 1, 14), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cableSatPrefLinkAvailM.setReference('TR 101 290 section 6.2')
if mibBuilder.loadTexts: cableSatPrefLinkAvailM.setStatus('current')
if mibBuilder.loadTexts: cableSatPrefLinkAvailM.setDescription('The M value used to identify the start and end of a period of Link Unavailable Time (LUAT).')
cableSatPrefLinkAvailTI = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 100, 1, 15), FloatingPoint()).setUnits('second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cableSatPrefLinkAvailTI.setReference('TR 101 290 section 6.2')
if mibBuilder.loadTexts: cableSatPrefLinkAvailTI.setStatus('current')
if mibBuilder.loadTexts: cableSatPrefLinkAvailTI.setDescription('Each Time Interval of this length is assessed as to whether it is a Severely Uncorrectable Time Interval (SUTI).')
cableSatPrefLinkAvailUPPerCent = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 100, 1, 16), FloatingPoint()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cableSatPrefLinkAvailUPPerCent.setReference('TR 101 290 section 6.2')
if mibBuilder.loadTexts: cableSatPrefLinkAvailUPPerCent.setStatus('current')
if mibBuilder.loadTexts: cableSatPrefLinkAvailUPPerCent.setDescription("If more than this percentage of packets within a Time Interval is an Uncorrectable Packet (UP), the Time Interval is a Severely Uncorrectable Time Interval (SUTI). Example values are: '1.53', '10', '0.33'.")
cableSatPrefLinkAvailTotalTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 100, 1, 17), FloatingPoint()).setUnits('second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cableSatPrefLinkAvailTotalTime.setReference('TR 101 290 section 6.2')
if mibBuilder.loadTexts: cableSatPrefLinkAvailTotalTime.setStatus('current')
if mibBuilder.loadTexts: cableSatPrefLinkAvailTotalTime.setDescription('The Total Time over which the Link Availability is calculated.')
cableSatPrefBERMax = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 100, 1, 18), FloatingPoint()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cableSatPrefBERMax.setStatus('current')
if mibBuilder.loadTexts: cableSatPrefBERMax.setDescription('If the berRSinServiceValue exceeds this value, the associated test fails.')
cableSatPrefSignalPowerMin = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 100, 1, 19), FloatingPoint()).setUnits('dBm').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cableSatPrefSignalPowerMin.setReference('TR 101 290 section 6.6')
if mibBuilder.loadTexts: cableSatPrefSignalPowerMin.setStatus('current')
if mibBuilder.loadTexts: cableSatPrefSignalPowerMin.setDescription('If the power measured by rfIFsignalPowerValue is less than this value, the associated test fails.')
cableSatPrefSignalPowerMax = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 100, 1, 20), FloatingPoint()).setUnits('dBm').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cableSatPrefSignalPowerMax.setReference('TR 101 290 section 6.6')
if mibBuilder.loadTexts: cableSatPrefSignalPowerMax.setStatus('current')
if mibBuilder.loadTexts: cableSatPrefSignalPowerMax.setDescription('If the power measured by rfIFsignalPowerValue is greater than this value, the associated test fails.')
cableSatPrefNoisePowerMax = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 100, 1, 21), FloatingPoint()).setUnits('dBm').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cableSatPrefNoisePowerMax.setReference('TR 101 290 section 6.7')
if mibBuilder.loadTexts: cableSatPrefNoisePowerMax.setStatus('current')
if mibBuilder.loadTexts: cableSatPrefNoisePowerMax.setDescription('If the noise power measured by noisePowerValue exceeds this value, the associated test fails.')
cableSatPrefMerCSMin = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 100, 1, 22), FloatingPoint()).setUnits('dB').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cableSatPrefMerCSMin.setReference('TR 101 290 section 6.9.2')
if mibBuilder.loadTexts: cableSatPrefMerCSMin.setStatus('current')
if mibBuilder.loadTexts: cableSatPrefMerCSMin.setDescription('If the merCSValue is less than this value, the associated test fails.')
cableSatPrefSteMeanCSMax = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 100, 1, 23), FloatingPoint()).setUnits('dB').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cableSatPrefSteMeanCSMax.setReference('TR 101 290 section 6.9.3')
if mibBuilder.loadTexts: cableSatPrefSteMeanCSMax.setStatus('current')
if mibBuilder.loadTexts: cableSatPrefSteMeanCSMax.setDescription('If the steMeanCSValue exceeds this value, the associated test fails.')
cableSatPrefSteDeviationCSMax = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 100, 1, 24), FloatingPoint()).setUnits('dB').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cableSatPrefSteDeviationCSMax.setReference('TR 101 290 section 6.9.3')
if mibBuilder.loadTexts: cableSatPrefSteDeviationCSMax.setStatus('current')
if mibBuilder.loadTexts: cableSatPrefSteDeviationCSMax.setDescription('If the steDeviationCSValue exceeds this value, the associated test fails.')
cableSatPrefCsCSMin = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 100, 1, 25), FloatingPoint()).setUnits('dB').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cableSatPrefCsCSMin.setReference('TR 101 290 section 6.9.4')
if mibBuilder.loadTexts: cableSatPrefCsCSMin.setStatus('current')
if mibBuilder.loadTexts: cableSatPrefCsCSMin.setDescription('If the csCSValue is less than this value, the associated test fails')
cableSatPrefAiCSMax = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 100, 1, 26), FloatingPoint()).setUnits('dB').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cableSatPrefAiCSMax.setReference('TR 101 290 section 6.9.5')
if mibBuilder.loadTexts: cableSatPrefAiCSMax.setStatus('current')
if mibBuilder.loadTexts: cableSatPrefAiCSMax.setDescription('If aiCSValue exceeds this value, the associated test fails.')
cableSatPrefQeCSMax = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 100, 1, 27), FloatingPoint()).setUnits('dB').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cableSatPrefQeCSMax.setReference('TR 101 290 section 6.9.6')
if mibBuilder.loadTexts: cableSatPrefQeCSMax.setStatus('current')
if mibBuilder.loadTexts: cableSatPrefQeCSMax.setDescription('If qeCSValue exceeds this value, the associated test fails.')
cableSatPrefRteCSMax = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 100, 1, 28), FloatingPoint()).setUnits('dB').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cableSatPrefRteCSMax.setReference('TR 101 290 section 6.9.7')
if mibBuilder.loadTexts: cableSatPrefRteCSMax.setStatus('current')
if mibBuilder.loadTexts: cableSatPrefRteCSMax.setDescription('If rteCSValue exceeds this value, the associated test fails.')
cableSatPrefCiCSMin = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 100, 1, 29), FloatingPoint()).setUnits('dB').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cableSatPrefCiCSMin.setReference('TR 101 290 section 6.9.8')
if mibBuilder.loadTexts: cableSatPrefCiCSMin.setStatus('current')
if mibBuilder.loadTexts: cableSatPrefCiCSMin.setDescription('If ciCSValue is less than this value, the associated test fails.')
cableSatPrefPjCSMax = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 100, 1, 30), FloatingPoint()).setUnits('dB').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cableSatPrefPjCSMax.setReference('TR 101 290 section 6.9.9')
if mibBuilder.loadTexts: cableSatPrefPjCSMax.setStatus('current')
if mibBuilder.loadTexts: cableSatPrefPjCSMax.setDescription('If pjCSValue exceeds this value, the associated test fails.')
cableSatPrefSnrCSMin = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 6, 100, 1, 31), FloatingPoint()).setUnits('dB').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cableSatPrefSnrCSMin.setReference('TR 101 290 section 6.9.10')
if mibBuilder.loadTexts: cableSatPrefSnrCSMin.setStatus('current')
if mibBuilder.loadTexts: cableSatPrefSnrCSMin.setDescription('If snrCSValue is less than this value, the associated test fails.')
tr101290Cable = MibIdentifier((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 7))
noiseMarginTable = MibTable((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 7, 1), )
if mibBuilder.loadTexts: noiseMarginTable.setReference('TR 101 290 section 7.1')
if mibBuilder.loadTexts: noiseMarginTable.setStatus('current')
if mibBuilder.loadTexts: noiseMarginTable.setDescription('Noise margin measurement')
noiseMarginEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 7, 1, 1), ).setIndexNames((0, "DVB-MGTR101290-MIB", "noiseMarginInputNumber"))
if mibBuilder.loadTexts: noiseMarginEntry.setStatus('current')
if mibBuilder.loadTexts: noiseMarginEntry.setDescription('Row description')
noiseMarginInputNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 7, 1, 1, 1), InputNumber())
if mibBuilder.loadTexts: noiseMarginInputNumber.setStatus('current')
if mibBuilder.loadTexts: noiseMarginInputNumber.setDescription('Transport Stream on which the measurement is made')
noiseMarginTestState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 7, 1, 1, 2), TestState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: noiseMarginTestState.setStatus('current')
if mibBuilder.loadTexts: noiseMarginTestState.setDescription('This indicates whether the noiseMarginValue is currently within the thresholds.')
noiseMarginEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 7, 1, 1, 3), Enable().clone(namedValues=NamedValues(("testEnable", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: noiseMarginEnable.setStatus('current')
if mibBuilder.loadTexts: noiseMarginEnable.setDescription('Determines whether the threshold test and associated traps for this measurement are enabled.')
noiseMarginCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 7, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: noiseMarginCounter.setStatus('current')
if mibBuilder.loadTexts: noiseMarginCounter.setDescription('Count of the number of times a threshold error has occurred for this measurement.')
noiseMarginCounterDiscontinuity = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 7, 1, 1, 5), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: noiseMarginCounterDiscontinuity.setStatus('current')
if mibBuilder.loadTexts: noiseMarginCounterDiscontinuity.setDescription('Provides the last time at which there was a discontinuity in the counter object.')
noiseMarginCounterReset = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 7, 1, 1, 6), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: noiseMarginCounterReset.setStatus('current')
if mibBuilder.loadTexts: noiseMarginCounterReset.setDescription("The counter object is reset to zero and the counter discontinuity object is set to the current time if 'true' is written to this object. When read, the value of this object is always 'false'.")
noiseMarginLatestError = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 7, 1, 1, 7), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: noiseMarginLatestError.setStatus('current')
if mibBuilder.loadTexts: noiseMarginLatestError.setDescription('The timestamp at the most recent occurrence of a threshold error on this measurement.')
noiseMarginActiveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 7, 1, 1, 8), ActiveTime()).setUnits('second').setMaxAccess("readonly")
if mibBuilder.loadTexts: noiseMarginActiveTime.setStatus('current')
if mibBuilder.loadTexts: noiseMarginActiveTime.setDescription('The total time when it has been possible to perform this measurement ')
noiseMarginMeasurementState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 7, 1, 1, 9), MeasurementState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: noiseMarginMeasurementState.setStatus('current')
if mibBuilder.loadTexts: noiseMarginMeasurementState.setDescription('Indicates the validity of the measurement')
noiseMarginValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 7, 1, 1, 10), FloatingPoint()).setUnits('dB').setMaxAccess("readonly")
if mibBuilder.loadTexts: noiseMarginValue.setStatus('current')
if mibBuilder.loadTexts: noiseMarginValue.setDescription('The current Noise Margin value in dB.')
estNoiseMarginTable = MibTable((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 7, 2), )
if mibBuilder.loadTexts: estNoiseMarginTable.setReference('TR 101 290 section 7.2')
if mibBuilder.loadTexts: estNoiseMarginTable.setStatus('current')
if mibBuilder.loadTexts: estNoiseMarginTable.setDescription('Estimated noise margin measurement')
estNoiseMarginEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 7, 2, 1), ).setIndexNames((0, "DVB-MGTR101290-MIB", "estNoiseMarginInputNumber"))
if mibBuilder.loadTexts: estNoiseMarginEntry.setStatus('current')
if mibBuilder.loadTexts: estNoiseMarginEntry.setDescription('Row description')
estNoiseMarginInputNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 7, 2, 1, 1), InputNumber())
if mibBuilder.loadTexts: estNoiseMarginInputNumber.setStatus('current')
if mibBuilder.loadTexts: estNoiseMarginInputNumber.setDescription('Transport Stream on which the measurement is made')
estNoiseMarginTestState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 7, 2, 1, 2), TestState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: estNoiseMarginTestState.setStatus('current')
if mibBuilder.loadTexts: estNoiseMarginTestState.setDescription('This indicates whether the estNoiseMarginValue is currently within the thresholds.')
estNoiseMarginEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 7, 2, 1, 3), Enable().clone(namedValues=NamedValues(("testEnable", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: estNoiseMarginEnable.setStatus('current')
if mibBuilder.loadTexts: estNoiseMarginEnable.setDescription('Determines whether the threshold test and associated traps for this measurement are enabled.')
estNoiseMarginCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 7, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: estNoiseMarginCounter.setStatus('current')
if mibBuilder.loadTexts: estNoiseMarginCounter.setDescription('Count of the number of times a threshold error has occurred for this measurement.')
estNoiseMarginCounterDiscontinuity = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 7, 2, 1, 5), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: estNoiseMarginCounterDiscontinuity.setStatus('current')
if mibBuilder.loadTexts: estNoiseMarginCounterDiscontinuity.setDescription('Provides the last time at which there was a discontinuity in the counter object.')
estNoiseMarginCounterReset = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 7, 2, 1, 6), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: estNoiseMarginCounterReset.setStatus('current')
if mibBuilder.loadTexts: estNoiseMarginCounterReset.setDescription("The counter object is reset to zero and the counter discontinuity object is set to the current time if 'true' is written to this object. When read, the value of this object is always 'false'.")
estNoiseMarginLatestError = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 7, 2, 1, 7), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: estNoiseMarginLatestError.setStatus('current')
if mibBuilder.loadTexts: estNoiseMarginLatestError.setDescription('The timestamp at the most recent occurrence of a threshold error on this measurement.')
estNoiseMarginActiveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 7, 2, 1, 8), ActiveTime()).setUnits('second').setMaxAccess("readonly")
if mibBuilder.loadTexts: estNoiseMarginActiveTime.setStatus('current')
if mibBuilder.loadTexts: estNoiseMarginActiveTime.setDescription('The total time when it has been possible to perform this measurement')
estNoiseMarginMeasurementState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 7, 2, 1, 9), MeasurementState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: estNoiseMarginMeasurementState.setStatus('current')
if mibBuilder.loadTexts: estNoiseMarginMeasurementState.setDescription('Indicates the validity of the measurement')
estNoiseMarginValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 7, 2, 1, 10), FloatingPoint()).setUnits('dB').setMaxAccess("readonly")
if mibBuilder.loadTexts: estNoiseMarginValue.setStatus('current')
if mibBuilder.loadTexts: estNoiseMarginValue.setDescription('The current Estimated Noise Margin value in dB.')
signQualMarTTable = MibTable((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 7, 3), )
if mibBuilder.loadTexts: signQualMarTTable.setReference('TR 101 290 section 7.3')
if mibBuilder.loadTexts: signQualMarTTable.setStatus('current')
if mibBuilder.loadTexts: signQualMarTTable.setDescription('Signal quality margin test')
signQualMarTEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 7, 3, 1), ).setIndexNames((0, "DVB-MGTR101290-MIB", "signQualMarTInputNumber"))
if mibBuilder.loadTexts: signQualMarTEntry.setStatus('current')
if mibBuilder.loadTexts: signQualMarTEntry.setDescription('Row description')
signQualMarTInputNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 7, 3, 1, 1), InputNumber())
if mibBuilder.loadTexts: signQualMarTInputNumber.setStatus('current')
if mibBuilder.loadTexts: signQualMarTInputNumber.setDescription('Transport Stream on which the test is done')
signQualMarTTestState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 7, 3, 1, 2), TestState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: signQualMarTTestState.setStatus('current')
if mibBuilder.loadTexts: signQualMarTTestState.setDescription('This indicates an error if the percentage of IQ points outside the threshold box exceeds cablePrefSignQualPercentMax.')
signQualMarTEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 7, 3, 1, 3), Enable().clone(namedValues=NamedValues(("testEnable", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: signQualMarTEnable.setStatus('current')
if mibBuilder.loadTexts: signQualMarTEnable.setDescription('Determines whether the threshold test and associated traps for this measurement are enabled.')
signQualMarTCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 7, 3, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: signQualMarTCounter.setStatus('current')
if mibBuilder.loadTexts: signQualMarTCounter.setDescription('Count of the number of times an error has occurred.')
signQualMarTCounterDiscontinuity = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 7, 3, 1, 5), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: signQualMarTCounterDiscontinuity.setStatus('current')
if mibBuilder.loadTexts: signQualMarTCounterDiscontinuity.setDescription('Provides the last time at which there was a discontinuity in the counter object.')
signQualMarTCounterReset = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 7, 3, 1, 6), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: signQualMarTCounterReset.setStatus('current')
if mibBuilder.loadTexts: signQualMarTCounterReset.setDescription("The counter object is reset to zero and the counter discontinuity object is set to the current time if 'true' is written to this object. When read, the value of this object is always 'false'.")
signQualMarTLatestError = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 7, 3, 1, 7), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: signQualMarTLatestError.setStatus('current')
if mibBuilder.loadTexts: signQualMarTLatestError.setDescription('The timestamp at the most recent occurrence of an error.')
signQualMarTActiveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 7, 3, 1, 8), ActiveTime()).setUnits('second').setMaxAccess("readonly")
if mibBuilder.loadTexts: signQualMarTActiveTime.setStatus('current')
if mibBuilder.loadTexts: signQualMarTActiveTime.setDescription('The total time when it has been possible to perform this measurement')
eNDCTable = MibTable((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 7, 4), )
if mibBuilder.loadTexts: eNDCTable.setReference('TR 101 290 section 7.4')
if mibBuilder.loadTexts: eNDCTable.setStatus('current')
if mibBuilder.loadTexts: eNDCTable.setDescription('Equivalent Noise Degradation (END) measurement')
eNDCEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 7, 4, 1), ).setIndexNames((0, "DVB-MGTR101290-MIB", "eNDCInputNumber"))
if mibBuilder.loadTexts: eNDCEntry.setStatus('current')
if mibBuilder.loadTexts: eNDCEntry.setDescription('Row description')
eNDCInputNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 7, 4, 1, 1), InputNumber())
if mibBuilder.loadTexts: eNDCInputNumber.setStatus('current')
if mibBuilder.loadTexts: eNDCInputNumber.setDescription('Transport Stream on which the measurement is made')
eNDCTestState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 7, 4, 1, 2), TestState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eNDCTestState.setStatus('current')
if mibBuilder.loadTexts: eNDCTestState.setDescription('This indicates an error when the eNDCValue exceeds the threshold.')
eNDCEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 7, 4, 1, 3), Enable().clone(namedValues=NamedValues(("testEnable", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: eNDCEnable.setStatus('current')
if mibBuilder.loadTexts: eNDCEnable.setDescription('Determines whether the threshold test and associated traps for this measurement are enabled.')
eNDCCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 7, 4, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eNDCCounter.setStatus('current')
if mibBuilder.loadTexts: eNDCCounter.setDescription('Count of the number of times a threshold error has occurred for this measurement.')
eNDCCounterDiscontinuity = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 7, 4, 1, 5), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eNDCCounterDiscontinuity.setStatus('current')
if mibBuilder.loadTexts: eNDCCounterDiscontinuity.setDescription('Provides the last time at which there was a discontinuity in the counter object.')
eNDCCounterReset = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 7, 4, 1, 6), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: eNDCCounterReset.setStatus('current')
if mibBuilder.loadTexts: eNDCCounterReset.setDescription("The counter object is reset to zero and the counter discontinuity object is set to the current time if 'true' is written to this object. When read, the value of this object is always 'false'.")
eNDCLatestError = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 7, 4, 1, 7), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eNDCLatestError.setStatus('current')
if mibBuilder.loadTexts: eNDCLatestError.setDescription('The timestamp at the most recent occurrence of a threshold error on this measurement.')
eNDCActiveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 7, 4, 1, 8), ActiveTime()).setUnits('second').setMaxAccess("readonly")
if mibBuilder.loadTexts: eNDCActiveTime.setStatus('current')
if mibBuilder.loadTexts: eNDCActiveTime.setDescription('The total time when it has been possible to perform this measurement')
eNDCMeasurementState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 7, 4, 1, 9), MeasurementState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eNDCMeasurementState.setStatus('current')
if mibBuilder.loadTexts: eNDCMeasurementState.setDescription('Indicates the validity of the measurement')
eNDCValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 7, 4, 1, 10), FloatingPoint()).setUnits('dB').setMaxAccess("readonly")
if mibBuilder.loadTexts: eNDCValue.setStatus('current')
if mibBuilder.loadTexts: eNDCValue.setDescription('The current Equivalent Noise Degradation value in dB.')
outBandEmissTable = MibTable((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 7, 5), )
if mibBuilder.loadTexts: outBandEmissTable.setReference('TR 101 290 section 7.8')
if mibBuilder.loadTexts: outBandEmissTable.setStatus('current')
if mibBuilder.loadTexts: outBandEmissTable.setDescription('Out of band emissions test')
outBandEmissEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 7, 5, 1), ).setIndexNames((0, "DVB-MGTR101290-MIB", "outBandEmissInputNumber"))
if mibBuilder.loadTexts: outBandEmissEntry.setStatus('current')
if mibBuilder.loadTexts: outBandEmissEntry.setDescription('Row specification')
outBandEmissInputNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 7, 5, 1, 1), InputNumber())
if mibBuilder.loadTexts: outBandEmissInputNumber.setStatus('current')
if mibBuilder.loadTexts: outBandEmissInputNumber.setDescription('Transport Stream on which the test is made')
outBandEmissTestState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 7, 5, 1, 2), TestState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: outBandEmissTestState.setStatus('current')
if mibBuilder.loadTexts: outBandEmissTestState.setDescription('This indicates whether the spectrum is within the spectrum mask. Note that the spectrum mask must be provided to the instrument by means outside the scope of this MIB.')
outBandEmissEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 7, 5, 1, 3), Enable().clone(namedValues=NamedValues(("testEnable", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: outBandEmissEnable.setStatus('current')
if mibBuilder.loadTexts: outBandEmissEnable.setDescription('Determines whether the threshold test and associated traps for this measurement are enabled.')
outBandEmissCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 7, 5, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: outBandEmissCounter.setStatus('current')
if mibBuilder.loadTexts: outBandEmissCounter.setDescription('Count of the number of times an error has occurred for this test.')
outBandEmissCounterDiscontinuity = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 7, 5, 1, 5), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: outBandEmissCounterDiscontinuity.setStatus('current')
if mibBuilder.loadTexts: outBandEmissCounterDiscontinuity.setDescription('Provides the last time at which there was a discontinuity in the counter object.')
outBandEmissCounterReset = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 7, 5, 1, 6), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: outBandEmissCounterReset.setStatus('current')
if mibBuilder.loadTexts: outBandEmissCounterReset.setDescription("The counter object is reset to zero and the counter discontinuity object is set to the current time if 'true' is written to this object. When read, the value of this object is always 'false'.")
outBandEmissLatestError = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 7, 5, 1, 7), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: outBandEmissLatestError.setStatus('current')
if mibBuilder.loadTexts: outBandEmissLatestError.setDescription('The timestamp at the most recent occurrence of an error on this test.')
outBandEmissActiveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 7, 5, 1, 8), ActiveTime()).setUnits('second').setMaxAccess("readonly")
if mibBuilder.loadTexts: outBandEmissActiveTime.setStatus('current')
if mibBuilder.loadTexts: outBandEmissActiveTime.setDescription('The total time when it has been possible to perform this measurement')
cablePreferencesTable = MibTable((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 7, 100), )
if mibBuilder.loadTexts: cablePreferencesTable.setStatus('current')
if mibBuilder.loadTexts: cablePreferencesTable.setDescription('Table containing per input preferences for cable measurements.')
cablePreferencesEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 7, 100, 1), ).setIndexNames((0, "DVB-MGTR101290-MIB", "cablePrefInputNumber"))
if mibBuilder.loadTexts: cablePreferencesEntry.setStatus('current')
if mibBuilder.loadTexts: cablePreferencesEntry.setDescription('Row specification')
cablePrefInputNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 7, 100, 1, 1), InputNumber())
if mibBuilder.loadTexts: cablePrefInputNumber.setStatus('current')
if mibBuilder.loadTexts: cablePrefInputNumber.setDescription('Transport Stream input to which the preferences apply')
cablePrefNoiseMarginMin = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 7, 100, 1, 2), FloatingPoint()).setUnits('dB').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cablePrefNoiseMarginMin.setReference('TR 101 290 section 7.1')
if mibBuilder.loadTexts: cablePrefNoiseMarginMin.setStatus('current')
if mibBuilder.loadTexts: cablePrefNoiseMarginMin.setDescription('If the measured noiseMarginValue is less than this value the associated test fails.')
cablePrefEstNoiseMarginMin = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 7, 100, 1, 3), FloatingPoint()).setUnits('dB').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cablePrefEstNoiseMarginMin.setReference('TR 101 290 section 7.1')
if mibBuilder.loadTexts: cablePrefEstNoiseMarginMin.setStatus('current')
if mibBuilder.loadTexts: cablePrefEstNoiseMarginMin.setDescription('If the measured estNoiseMarginValue is less than this value the associated test fails.')
cablePrefSignQualBoxSize = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 7, 100, 1, 4), FloatingPoint()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cablePrefSignQualBoxSize.setReference('TR 101 290 section 7.3')
if mibBuilder.loadTexts: cablePrefSignQualBoxSize.setStatus('current')
if mibBuilder.loadTexts: cablePrefSignQualBoxSize.setDescription("This object determines the size of the quality threshold box for the signal quality margin test. The quality threshold box is assumed to be square. The value is the ratio of the length of one side of a threshold box to the length of one side of the IQ decision boundary box. An example value is '0.5'.")
cablePrefSignQualPercentMax = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 7, 100, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cablePrefSignQualPercentMax.setReference('TR 101 290 section 7.3')
if mibBuilder.loadTexts: cablePrefSignQualPercentMax.setStatus('current')
if mibBuilder.loadTexts: cablePrefSignQualPercentMax.setDescription("This object sets the limit on how many constellation points may fall outside the threshold box before the signal quality margin test fails. The value is expressed as a percentage, for example '7.5'.")
cablePrefENDBER = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 7, 100, 1, 6), FloatingPoint().clone('1E-04')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cablePrefENDBER.setReference('TR 101 290 section 7.4')
if mibBuilder.loadTexts: cablePrefENDBER.setStatus('current')
if mibBuilder.loadTexts: cablePrefENDBER.setDescription('BER value which is to be used for the END measurement.')
cablePrefENDCtoNSpecified = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 7, 100, 1, 7), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cablePrefENDCtoNSpecified.setReference('TR 101 290 section 7.4')
if mibBuilder.loadTexts: cablePrefENDCtoNSpecified.setStatus('current')
if mibBuilder.loadTexts: cablePrefENDCtoNSpecified.setDescription('This determines whether cablePrefENDIdeal is expressed as a C/N ratio (value is true) or an Eb/No ratio (value is false).')
cablePrefENDIdeal = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 7, 100, 1, 8), FloatingPoint()).setUnits('dB').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cablePrefENDIdeal.setReference('TR 101 290 section 7.4')
if mibBuilder.loadTexts: cablePrefENDIdeal.setStatus('current')
if mibBuilder.loadTexts: cablePrefENDIdeal.setDescription("This is the 'ideal' value of C/N or Eb/No for the given BER.")
cablePrefENDMax = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 7, 100, 1, 9), FloatingPoint()).setUnits('dB').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cablePrefENDMax.setReference('TR 101 290 section 7.4')
if mibBuilder.loadTexts: cablePrefENDMax.setStatus('current')
if mibBuilder.loadTexts: cablePrefENDMax.setDescription('If the measured END exceeds this value the associated test fails.')
tr101290Satellite = MibIdentifier((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 8))
berViterbiSTable = MibTable((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 8, 1), )
if mibBuilder.loadTexts: berViterbiSTable.setReference('TR 101 290 section 8.1')
if mibBuilder.loadTexts: berViterbiSTable.setStatus('current')
if mibBuilder.loadTexts: berViterbiSTable.setDescription('BER before Viterbi decoding measurement')
berViterbiSEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 8, 1, 1), ).setIndexNames((0, "DVB-MGTR101290-MIB", "berViterbiSInputNumber"))
if mibBuilder.loadTexts: berViterbiSEntry.setStatus('current')
if mibBuilder.loadTexts: berViterbiSEntry.setDescription('Row description')
berViterbiSInputNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 8, 1, 1, 1), InputNumber())
if mibBuilder.loadTexts: berViterbiSInputNumber.setStatus('current')
if mibBuilder.loadTexts: berViterbiSInputNumber.setDescription('Transport Stream on which the measurement is made')
berViterbiSTestState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 8, 1, 1, 2), TestState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: berViterbiSTestState.setStatus('current')
if mibBuilder.loadTexts: berViterbiSTestState.setDescription('This test fails if either berViterbiSIValue or berViterbiSQValue exceeds the threshold set by satellitePrefBERMax.')
berViterbiSEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 8, 1, 1, 3), Enable().clone(namedValues=NamedValues(("testEnable", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: berViterbiSEnable.setStatus('current')
if mibBuilder.loadTexts: berViterbiSEnable.setDescription('Determines whether the threshold test and associated traps for this measurement are enabled.')
berViterbiSCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 8, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: berViterbiSCounter.setStatus('current')
if mibBuilder.loadTexts: berViterbiSCounter.setDescription('Count of the number of times a threshold error has occurred for this measurement.')
berViterbiSCounterDiscontinuity = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 8, 1, 1, 5), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: berViterbiSCounterDiscontinuity.setStatus('current')
if mibBuilder.loadTexts: berViterbiSCounterDiscontinuity.setDescription('Provides the last time at which there was a discontinuity in the berViterbiSCounter object.')
berViterbiSCounterReset = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 8, 1, 1, 6), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: berViterbiSCounterReset.setStatus('current')
if mibBuilder.loadTexts: berViterbiSCounterReset.setDescription("The counter object is reset to zero and the counter discontinuity object is set to the current time if 'true' is written to this object. When read, the value of this object is always 'false'.")
berViterbiSLatestError = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 8, 1, 1, 7), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: berViterbiSLatestError.setStatus('current')
if mibBuilder.loadTexts: berViterbiSLatestError.setDescription('The timestamp at the most recent occurrence of a threshold error on this measurement.')
berViterbiSActiveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 8, 1, 1, 8), ActiveTime()).setUnits('second').setMaxAccess("readonly")
if mibBuilder.loadTexts: berViterbiSActiveTime.setStatus('current')
if mibBuilder.loadTexts: berViterbiSActiveTime.setDescription('The total time when it has been possible to perform this measurement')
berViterbiSMeasurementState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 8, 1, 1, 9), MeasurementState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: berViterbiSMeasurementState.setStatus('current')
if mibBuilder.loadTexts: berViterbiSMeasurementState.setDescription('Indicates the validity of the measurement')
berViterbiSIValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 8, 1, 1, 10), FloatingPoint()).setMaxAccess("readonly")
if mibBuilder.loadTexts: berViterbiSIValue.setReference('TR 101 290 section 8.1')
if mibBuilder.loadTexts: berViterbiSIValue.setStatus('current')
if mibBuilder.loadTexts: berViterbiSIValue.setDescription('This is the pre-Viterbi I path BER value, for example 0.0000023')
berViterbiSQValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 8, 1, 1, 11), FloatingPoint()).setMaxAccess("readonly")
if mibBuilder.loadTexts: berViterbiSQValue.setReference('TR 101 290 section 8.1')
if mibBuilder.loadTexts: berViterbiSQValue.setStatus('current')
if mibBuilder.loadTexts: berViterbiSQValue.setDescription('This is the pre-Viterbi Q path BER value, for example 0.0000023')
berViterbiSMeasurementMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 8, 1, 1, 12), BERMeasurementMethod()).setMaxAccess("readonly")
if mibBuilder.loadTexts: berViterbiSMeasurementMethod.setStatus('current')
if mibBuilder.loadTexts: berViterbiSMeasurementMethod.setDescription('This indicates whether the measurement was made separately for the I and Q parts of the signal or by a measurement of I and Q combined.')
ifSpectrumTable = MibTable((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 8, 2), )
if mibBuilder.loadTexts: ifSpectrumTable.setReference('TR 101 290 section 8.3')
if mibBuilder.loadTexts: ifSpectrumTable.setStatus('current')
if mibBuilder.loadTexts: ifSpectrumTable.setDescription('IF spectrum test')
ifSpectrumEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 8, 2, 1), ).setIndexNames((0, "DVB-MGTR101290-MIB", "ifSpectrumInputNumber"))
if mibBuilder.loadTexts: ifSpectrumEntry.setStatus('current')
if mibBuilder.loadTexts: ifSpectrumEntry.setDescription('Row specification')
ifSpectrumInputNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 8, 2, 1, 1), InputNumber())
if mibBuilder.loadTexts: ifSpectrumInputNumber.setStatus('current')
if mibBuilder.loadTexts: ifSpectrumInputNumber.setDescription('Transport Stream on which the measurement is made')
ifSpectrumTestState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 8, 2, 1, 2), TestState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifSpectrumTestState.setStatus('current')
if mibBuilder.loadTexts: ifSpectrumTestState.setDescription('This indicates whether the spectrum conforms to the template. Note that the spectrum mask must be provided to the instrument by means outside the scope of this MIB. The group delay is not tested.')
ifSpectrumEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 8, 2, 1, 3), Enable().clone(namedValues=NamedValues(("testEnable", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifSpectrumEnable.setStatus('current')
if mibBuilder.loadTexts: ifSpectrumEnable.setDescription('Determines whether the threshold test and associated traps for this measurement are enabled.')
ifSpectrumCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 8, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifSpectrumCounter.setStatus('current')
if mibBuilder.loadTexts: ifSpectrumCounter.setDescription('Count of the number of times an error has occurred for this test.')
ifSpectrumCounterDiscontinuity = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 8, 2, 1, 5), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifSpectrumCounterDiscontinuity.setStatus('current')
if mibBuilder.loadTexts: ifSpectrumCounterDiscontinuity.setDescription('Provides the last time at which there was a discontinuity in the counter object.')
ifSpectrumCounterReset = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 8, 2, 1, 6), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifSpectrumCounterReset.setStatus('current')
if mibBuilder.loadTexts: ifSpectrumCounterReset.setDescription("The counter object is reset to zero and the counter discontinuity object is set to the current time if 'true' is written to this object. When read, the value of this object is always 'false'.")
ifSpectrumLatestError = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 8, 2, 1, 7), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifSpectrumLatestError.setStatus('current')
if mibBuilder.loadTexts: ifSpectrumLatestError.setDescription('The timestamp at the most recent occurrence of an error on this test.')
ifSpectrumActiveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 8, 2, 1, 8), ActiveTime()).setUnits('second').setMaxAccess("readonly")
if mibBuilder.loadTexts: ifSpectrumActiveTime.setStatus('current')
if mibBuilder.loadTexts: ifSpectrumActiveTime.setDescription('The total time when it has been possible to perform this measurement')
satellitePreferencesTable = MibTable((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 8, 100), )
if mibBuilder.loadTexts: satellitePreferencesTable.setStatus('current')
if mibBuilder.loadTexts: satellitePreferencesTable.setDescription('Table of satellite specific measurement preferences.')
satellitePreferencesEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 8, 100, 1), ).setIndexNames((0, "DVB-MGTR101290-MIB", "satellitePrefInputNumber"))
if mibBuilder.loadTexts: satellitePreferencesEntry.setStatus('current')
if mibBuilder.loadTexts: satellitePreferencesEntry.setDescription('Row specification')
satellitePrefInputNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 8, 100, 1, 1), InputNumber())
if mibBuilder.loadTexts: satellitePrefInputNumber.setStatus('current')
if mibBuilder.loadTexts: satellitePrefInputNumber.setDescription('Transport Stream input to which the preferences apply')
satellitePrefBERMax = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 8, 100, 1, 2), FloatingPoint()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: satellitePrefBERMax.setReference('TR 101 290 section 8.1')
if mibBuilder.loadTexts: satellitePrefBERMax.setStatus('current')
if mibBuilder.loadTexts: satellitePrefBERMax.setDescription('This defines the upper limit on the BER before Viterbi measurement')
tr101290Terrestrial = MibIdentifier((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9))
rfTerr = MibIdentifier((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 1))
rfAccuracyTable = MibTable((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 1, 1), )
if mibBuilder.loadTexts: rfAccuracyTable.setReference('TR 101 290 section 9.1.1')
if mibBuilder.loadTexts: rfAccuracyTable.setStatus('current')
if mibBuilder.loadTexts: rfAccuracyTable.setDescription('RF frequency accuracy (Precision)')
rfAccuracyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 1, 1, 1), ).setIndexNames((0, "DVB-MGTR101290-MIB", "rfAccuracyInputNumber"))
if mibBuilder.loadTexts: rfAccuracyEntry.setStatus('current')
if mibBuilder.loadTexts: rfAccuracyEntry.setDescription('Row specification')
rfAccuracyInputNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 1, 1, 1, 1), InputNumber())
if mibBuilder.loadTexts: rfAccuracyInputNumber.setStatus('current')
if mibBuilder.loadTexts: rfAccuracyInputNumber.setDescription('RF input on which the measurement is made')
rfAccuracyTestState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 1, 1, 1, 2), TestState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rfAccuracyTestState.setStatus('current')
if mibBuilder.loadTexts: rfAccuracyTestState.setDescription('This indicates whether the rfAccuracyValue is within the thresholds.')
rfAccuracyEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 1, 1, 1, 3), Enable().clone(namedValues=NamedValues(("testEnable", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rfAccuracyEnable.setStatus('current')
if mibBuilder.loadTexts: rfAccuracyEnable.setDescription('Determines whether the threshold test and associated traps for this measurement are enabled.')
rfAccuracyCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 1, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rfAccuracyCounter.setStatus('current')
if mibBuilder.loadTexts: rfAccuracyCounter.setDescription('Count of the number of times a threshold error has occurred for this measurement.')
rfAccuracyCounterDiscontinuity = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 1, 1, 1, 5), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rfAccuracyCounterDiscontinuity.setStatus('current')
if mibBuilder.loadTexts: rfAccuracyCounterDiscontinuity.setDescription('Provides the last time at which there was a discontinuity in the counter object.')
rfAccuracyCounterReset = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 1, 1, 1, 6), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rfAccuracyCounterReset.setStatus('current')
if mibBuilder.loadTexts: rfAccuracyCounterReset.setDescription("The counter object is reset to zero and the counter discontinuity object is set to the current time if 'true' is written to this object. When read, the value of this object is always 'false'.")
rfAccuracyLatestError = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 1, 1, 1, 7), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rfAccuracyLatestError.setStatus('current')
if mibBuilder.loadTexts: rfAccuracyLatestError.setDescription('The timestamp at the most recent occurrence of a threshold error on this measurement.')
rfAccuracyActiveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 1, 1, 1, 8), ActiveTime()).setUnits('second').setMaxAccess("readonly")
if mibBuilder.loadTexts: rfAccuracyActiveTime.setStatus('current')
if mibBuilder.loadTexts: rfAccuracyActiveTime.setDescription('The total time when it has been possible to perform this measurement')
rfAccuracyMeasurementState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 1, 1, 1, 9), MeasurementState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rfAccuracyMeasurementState.setStatus('current')
if mibBuilder.loadTexts: rfAccuracyMeasurementState.setDescription('Indicates the validity of the measurement')
rfAccuracyValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 1, 1, 1, 10), FloatingPoint()).setUnits('Hz').setMaxAccess("readonly")
if mibBuilder.loadTexts: rfAccuracyValue.setStatus('current')
if mibBuilder.loadTexts: rfAccuracyValue.setDescription('This is the RF carrier frequency in Hz.')
rfChannelWidthTable = MibTable((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 1, 2), )
if mibBuilder.loadTexts: rfChannelWidthTable.setReference('TR 101 290 section 9.1.2')
if mibBuilder.loadTexts: rfChannelWidthTable.setStatus('current')
if mibBuilder.loadTexts: rfChannelWidthTable.setDescription('RF channel width (Sampling Frequency Accuracy)')
rfChannelWidthEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 1, 2, 1), ).setIndexNames((0, "DVB-MGTR101290-MIB", "rfChannelWidthInputNumber"))
if mibBuilder.loadTexts: rfChannelWidthEntry.setStatus('current')
if mibBuilder.loadTexts: rfChannelWidthEntry.setDescription('Row specification')
rfChannelWidthInputNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 1, 2, 1, 1), InputNumber())
if mibBuilder.loadTexts: rfChannelWidthInputNumber.setStatus('current')
if mibBuilder.loadTexts: rfChannelWidthInputNumber.setDescription('Transport Stream on which the measurement is made')
rfChannelWidthTestState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 1, 2, 1, 2), TestState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rfChannelWidthTestState.setStatus('current')
if mibBuilder.loadTexts: rfChannelWidthTestState.setDescription('This indicates whether the rfChannelWidthValue is within the thresholds.')
rfChannelWidthEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 1, 2, 1, 3), Enable().clone(namedValues=NamedValues(("testEnable", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rfChannelWidthEnable.setStatus('current')
if mibBuilder.loadTexts: rfChannelWidthEnable.setDescription('Determines whether the threshold test and associated traps for this measurement are enabled.')
rfChannelWidthCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 1, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rfChannelWidthCounter.setStatus('current')
if mibBuilder.loadTexts: rfChannelWidthCounter.setDescription('Count of the number of times a threshold error has occurred for this measurement.')
rfChannelWidthCounterDiscontinuity = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 1, 2, 1, 5), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rfChannelWidthCounterDiscontinuity.setStatus('current')
if mibBuilder.loadTexts: rfChannelWidthCounterDiscontinuity.setDescription('Provides the last time at which there was a discontinuity in the counter object.')
rfChannelWidthCounterReset = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 1, 2, 1, 6), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rfChannelWidthCounterReset.setStatus('current')
if mibBuilder.loadTexts: rfChannelWidthCounterReset.setDescription("The counter object is reset to zero and the counter discontinuity object is set to the current time if 'true' is written to this object. When read, the value of this object is always 'false'.")
rfChannelWidthLatestError = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 1, 2, 1, 7), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rfChannelWidthLatestError.setStatus('current')
if mibBuilder.loadTexts: rfChannelWidthLatestError.setDescription('The timestamp at the most recent occurrence of a threshold error on this measurement.')
rfChannelWidthActiveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 1, 2, 1, 8), ActiveTime()).setUnits('second').setMaxAccess("readonly")
if mibBuilder.loadTexts: rfChannelWidthActiveTime.setStatus('current')
if mibBuilder.loadTexts: rfChannelWidthActiveTime.setDescription('The total time when it has been possible to perform this measurement')
rfChannelWidthMeasurementState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 1, 2, 1, 9), MeasurementState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rfChannelWidthMeasurementState.setStatus('current')
if mibBuilder.loadTexts: rfChannelWidthMeasurementState.setDescription('Specifies the validity of the measurement value')
rfChannelWidthValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 1, 2, 1, 10), FloatingPoint()).setUnits('Hz').setMaxAccess("readonly")
if mibBuilder.loadTexts: rfChannelWidthValue.setStatus('current')
if mibBuilder.loadTexts: rfChannelWidthValue.setDescription('This is the RF channel width in Hz.')
symbolLengthTable = MibTable((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 1, 3), )
if mibBuilder.loadTexts: symbolLengthTable.setReference('TR 101 290 section 9.1.3')
if mibBuilder.loadTexts: symbolLengthTable.setStatus('current')
if mibBuilder.loadTexts: symbolLengthTable.setDescription('Symbol Length measurement at RF (Guard Interval verification)')
symbolLengthEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 1, 3, 1), ).setIndexNames((0, "DVB-MGTR101290-MIB", "symbolLengthInputNumber"))
if mibBuilder.loadTexts: symbolLengthEntry.setStatus('current')
if mibBuilder.loadTexts: symbolLengthEntry.setDescription('Row specification')
symbolLengthInputNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 1, 3, 1, 1), InputNumber())
if mibBuilder.loadTexts: symbolLengthInputNumber.setStatus('current')
if mibBuilder.loadTexts: symbolLengthInputNumber.setDescription('Transport Stream on which the measurement is made')
symbolLengthTestState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 1, 3, 1, 2), TestState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: symbolLengthTestState.setStatus('current')
if mibBuilder.loadTexts: symbolLengthTestState.setDescription('This indicates whether the symbolLengthValue is within the thresholds.')
symbolLengthEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 1, 3, 1, 3), Enable().clone(namedValues=NamedValues(("testEnable", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: symbolLengthEnable.setStatus('current')
if mibBuilder.loadTexts: symbolLengthEnable.setDescription('Determines whether the threshold test and associated traps for this measurement are enabled.')
symbolLengthCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 1, 3, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: symbolLengthCounter.setStatus('current')
if mibBuilder.loadTexts: symbolLengthCounter.setDescription('Count of the number of times a threshold error has occurred for this measurement.')
symbolLengthCounterDiscontinuity = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 1, 3, 1, 5), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: symbolLengthCounterDiscontinuity.setStatus('current')
if mibBuilder.loadTexts: symbolLengthCounterDiscontinuity.setDescription('Provides the last time at which there was a discontinuity in the counter object.')
symbolLengthCounterReset = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 1, 3, 1, 6), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: symbolLengthCounterReset.setStatus('current')
if mibBuilder.loadTexts: symbolLengthCounterReset.setDescription("The counter object is reset to zero and the counter discontinuity object is set to the current time if 'true' is written to this object. When read, the value of this object is always 'false'.")
symbolLengthLatestError = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 1, 3, 1, 7), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: symbolLengthLatestError.setStatus('current')
if mibBuilder.loadTexts: symbolLengthLatestError.setDescription('The timestamp at the most recent occurrence of a threshold error on this measurement.')
symbolLengthActiveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 1, 3, 1, 8), ActiveTime()).setUnits('second').setMaxAccess("readonly")
if mibBuilder.loadTexts: symbolLengthActiveTime.setStatus('current')
if mibBuilder.loadTexts: symbolLengthActiveTime.setDescription('The total time when it has been possible to perform this measurement')
symbolLengthMeasurementState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 1, 3, 1, 9), MeasurementState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: symbolLengthMeasurementState.setStatus('current')
if mibBuilder.loadTexts: symbolLengthMeasurementState.setDescription('Specifies the validity of the measurement value')
symbolLengthValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 1, 3, 1, 10), FloatingPoint()).setUnits('microsecond').setMaxAccess("readonly")
if mibBuilder.loadTexts: symbolLengthValue.setStatus('current')
if mibBuilder.loadTexts: symbolLengthValue.setDescription('This is the symbol length in microseconds.')
rfIfPowerTable = MibTable((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 5), )
if mibBuilder.loadTexts: rfIfPowerTable.setReference('TR 101 290 section 9.5')
if mibBuilder.loadTexts: rfIfPowerTable.setStatus('current')
if mibBuilder.loadTexts: rfIfPowerTable.setDescription('RF/IF signal power')
rfIfPowerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 5, 1), ).setIndexNames((0, "DVB-MGTR101290-MIB", "rfIfPowerInputNumber"))
if mibBuilder.loadTexts: rfIfPowerEntry.setStatus('current')
if mibBuilder.loadTexts: rfIfPowerEntry.setDescription('Row specification')
rfIfPowerInputNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 5, 1, 1), InputNumber())
if mibBuilder.loadTexts: rfIfPowerInputNumber.setStatus('current')
if mibBuilder.loadTexts: rfIfPowerInputNumber.setDescription('RF input on which the measurement is made')
rfIfPowerTestState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 5, 1, 2), TestState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rfIfPowerTestState.setStatus('current')
if mibBuilder.loadTexts: rfIfPowerTestState.setDescription('This indicates whether the rfIfPowerValue is within the thresholds.')
rfIfPowerEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 5, 1, 3), Enable().clone(namedValues=NamedValues(("testEnable", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rfIfPowerEnable.setStatus('current')
if mibBuilder.loadTexts: rfIfPowerEnable.setDescription('Determines whether the threshold test and associated traps for this measurement are enabled.')
rfIfPowerCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 5, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rfIfPowerCounter.setStatus('current')
if mibBuilder.loadTexts: rfIfPowerCounter.setDescription('Count of the number of times a threshold error has occurred for this measurement.')
rfIfPowerCounterDiscontinuity = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 5, 1, 5), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rfIfPowerCounterDiscontinuity.setStatus('current')
if mibBuilder.loadTexts: rfIfPowerCounterDiscontinuity.setDescription('Provides the last time at which there was a discontinuity in the counter object.')
rfIfPowerCounterReset = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 5, 1, 6), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rfIfPowerCounterReset.setStatus('current')
if mibBuilder.loadTexts: rfIfPowerCounterReset.setDescription("The counter object is reset to zero and the counter discontinuity object is set to the current time if 'true' is written to this object. When read, the value of this object is always 'false'.")
rfIfPowerLatestError = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 5, 1, 7), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rfIfPowerLatestError.setStatus('current')
if mibBuilder.loadTexts: rfIfPowerLatestError.setDescription('The timestamp at the most recent occurrence of a threshold error on this measurement.')
rfIfPowerActiveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 5, 1, 8), ActiveTime()).setUnits('second').setMaxAccess("readonly")
if mibBuilder.loadTexts: rfIfPowerActiveTime.setStatus('current')
if mibBuilder.loadTexts: rfIfPowerActiveTime.setDescription('The total time when it has been possible to perform this measurement')
rfIfPowerMeasurementState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 5, 1, 9), MeasurementState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rfIfPowerMeasurementState.setStatus('current')
if mibBuilder.loadTexts: rfIfPowerMeasurementState.setDescription('Specifies the validity of the measurement value')
rfIfPowerValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 5, 1, 10), FloatingPoint()).setUnits('dBm').setMaxAccess("readonly")
if mibBuilder.loadTexts: rfIfPowerValue.setStatus('current')
if mibBuilder.loadTexts: rfIfPowerValue.setDescription('The current RF power expressed in dBm, which references 0 dBm as the power of 1 mW.')
rfIfSpectrumTable = MibTable((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 7), )
if mibBuilder.loadTexts: rfIfSpectrumTable.setReference('TR 101 290 section 9.7')
if mibBuilder.loadTexts: rfIfSpectrumTable.setStatus('current')
if mibBuilder.loadTexts: rfIfSpectrumTable.setDescription('RF and IF spectrum mask test')
rfIfSpectrumEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 7, 1), ).setIndexNames((0, "DVB-MGTR101290-MIB", "rfIfSpectrumInputNumber"))
if mibBuilder.loadTexts: rfIfSpectrumEntry.setStatus('current')
if mibBuilder.loadTexts: rfIfSpectrumEntry.setDescription('Row specification')
rfIfSpectrumInputNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 7, 1, 1), InputNumber())
if mibBuilder.loadTexts: rfIfSpectrumInputNumber.setStatus('current')
if mibBuilder.loadTexts: rfIfSpectrumInputNumber.setDescription('Transport Stream on which the measurement is made')
rfIfSpectrumTestState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 7, 1, 2), TestState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rfIfSpectrumTestState.setStatus('current')
if mibBuilder.loadTexts: rfIfSpectrumTestState.setDescription('This indicates whether the signal conforms to the spectrum mask')
rfIfSpectrumEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 7, 1, 3), Enable().clone(namedValues=NamedValues(("testEnable", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rfIfSpectrumEnable.setStatus('current')
if mibBuilder.loadTexts: rfIfSpectrumEnable.setDescription('Determines whether the spectrum mask test and the associated trap are enabled.')
rfIfSpectrumCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 7, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rfIfSpectrumCounter.setStatus('current')
if mibBuilder.loadTexts: rfIfSpectrumCounter.setDescription('Count of the number of times an error has occurred.')
rfIfSpectrumCounterDiscontinuity = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 7, 1, 5), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rfIfSpectrumCounterDiscontinuity.setStatus('current')
if mibBuilder.loadTexts: rfIfSpectrumCounterDiscontinuity.setDescription('Provides the last time at which there was a discontinuity in the counter object.')
rfIfSpectrumCounterReset = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 7, 1, 6), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rfIfSpectrumCounterReset.setStatus('current')
if mibBuilder.loadTexts: rfIfSpectrumCounterReset.setDescription("The counter object is reset to zero and the counter discontinuity object is set to the current time if 'true' is written to this object. When read, the value of this object is always 'false'.")
rfIfSpectrumLatestError = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 7, 1, 7), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rfIfSpectrumLatestError.setStatus('current')
if mibBuilder.loadTexts: rfIfSpectrumLatestError.setDescription('The timestamp at the most recent occurrence of an error.')
rfIfSpectrumActiveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 7, 1, 8), ActiveTime()).setUnits('second').setMaxAccess("readonly")
if mibBuilder.loadTexts: rfIfSpectrumActiveTime.setStatus('current')
if mibBuilder.loadTexts: rfIfSpectrumActiveTime.setDescription('The total time when it has been possible to perform this measurement')
eNDT = MibIdentifier((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 9))
eNDTTable = MibTable((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 9, 1), )
if mibBuilder.loadTexts: eNDTTable.setReference('TR 101 290 section 9.9')
if mibBuilder.loadTexts: eNDTTable.setStatus('current')
if mibBuilder.loadTexts: eNDTTable.setDescription('Equivalent Noise Degradation measurement. If the DVB-T transmission is hierarchical, this table contains the measurement for the HP (high priority) stream. If the transmission is not hierarchical, this table contains the measurement for the whole stream.')
eNDTEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 9, 1, 1), ).setIndexNames((0, "DVB-MGTR101290-MIB", "eNDTInputNumber"))
if mibBuilder.loadTexts: eNDTEntry.setStatus('current')
if mibBuilder.loadTexts: eNDTEntry.setDescription('Row specification')
eNDTInputNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 9, 1, 1, 1), InputNumber())
if mibBuilder.loadTexts: eNDTInputNumber.setStatus('current')
if mibBuilder.loadTexts: eNDTInputNumber.setDescription('Transport Stream on which the measurement is made')
eNDTTestState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 9, 1, 1, 2), TestState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eNDTTestState.setStatus('current')
if mibBuilder.loadTexts: eNDTTestState.setDescription('This indicates whether eNDTValue is within the thresholds.')
eNDTEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 9, 1, 1, 3), Enable().clone(namedValues=NamedValues(("testEnable", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: eNDTEnable.setStatus('current')
if mibBuilder.loadTexts: eNDTEnable.setDescription('Determines whether the threshold test and associated traps for this measurement are enabled.')
eNDTCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 9, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eNDTCounter.setStatus('current')
if mibBuilder.loadTexts: eNDTCounter.setDescription('Count of the number of times a threshold error has occurred for this measurement.')
eNDTCounterDiscontinuity = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 9, 1, 1, 5), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eNDTCounterDiscontinuity.setStatus('current')
if mibBuilder.loadTexts: eNDTCounterDiscontinuity.setDescription('Provides the last time at which there was a discontinuity in the counter object.')
eNDTCounterReset = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 9, 1, 1, 6), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: eNDTCounterReset.setStatus('current')
if mibBuilder.loadTexts: eNDTCounterReset.setDescription("The counter object is reset to zero and the counter discontinuity object is set to the current time if 'true' is written to this object. When read, the value of this object is always 'false'.")
eNDTLatestError = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 9, 1, 1, 7), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eNDTLatestError.setStatus('current')
if mibBuilder.loadTexts: eNDTLatestError.setDescription('The timestamp at the most recent occurrence of a threshold error on this measurement.')
eNDTActiveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 9, 1, 1, 8), ActiveTime()).setUnits('second').setMaxAccess("readonly")
if mibBuilder.loadTexts: eNDTActiveTime.setStatus('current')
if mibBuilder.loadTexts: eNDTActiveTime.setDescription('The total time when it has been possible to perform this measurement')
eNDTMeasurementState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 9, 1, 1, 9), MeasurementState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eNDTMeasurementState.setStatus('current')
if mibBuilder.loadTexts: eNDTMeasurementState.setDescription('Specifies the validity of the measurement value')
eNDTValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 9, 1, 1, 10), FloatingPoint()).setUnits('dB').setMaxAccess("readonly")
if mibBuilder.loadTexts: eNDTValue.setStatus('current')
if mibBuilder.loadTexts: eNDTValue.setDescription('The current Equivalent Noise Degradation expressed in dB.')
eNFTTable = MibTable((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 9, 2), )
if mibBuilder.loadTexts: eNFTTable.setReference('TR 101 290 section 9.9.1')
if mibBuilder.loadTexts: eNFTTable.setStatus('current')
if mibBuilder.loadTexts: eNFTTable.setDescription('Equivalent Noise Floor measurement. If the DVB-T transmission is hierarchical, this table contains the measurement for the HP (high priority) stream. If the transmission is not hierarchical, this table contains the measurement for the whole stream.')
eNFTEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 9, 2, 1), ).setIndexNames((0, "DVB-MGTR101290-MIB", "eNFTInputNumber"))
if mibBuilder.loadTexts: eNFTEntry.setStatus('current')
if mibBuilder.loadTexts: eNFTEntry.setDescription('Row specification')
eNFTInputNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 9, 2, 1, 1), InputNumber())
if mibBuilder.loadTexts: eNFTInputNumber.setStatus('current')
if mibBuilder.loadTexts: eNFTInputNumber.setDescription('Transport Stream on which the measurement is made')
eNFTTestState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 9, 2, 1, 2), TestState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eNFTTestState.setStatus('current')
if mibBuilder.loadTexts: eNFTTestState.setDescription('This indicates whether the eNFTValue is within the thresholds.')
eNFTEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 9, 2, 1, 3), Enable().clone(namedValues=NamedValues(("testEnable", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: eNFTEnable.setStatus('current')
if mibBuilder.loadTexts: eNFTEnable.setDescription('Determines whether the threshold test and associated traps for this measurement are enabled.')
eNFTCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 9, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eNFTCounter.setStatus('current')
if mibBuilder.loadTexts: eNFTCounter.setDescription('Count of the number of times a threshold error has occurred for this measurement.')
eNFTCounterDiscontinuity = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 9, 2, 1, 5), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eNFTCounterDiscontinuity.setStatus('current')
if mibBuilder.loadTexts: eNFTCounterDiscontinuity.setDescription('Provides the last time at which there was a discontinuity in the counter object.')
eNFTCounterReset = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 9, 2, 1, 6), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: eNFTCounterReset.setStatus('current')
if mibBuilder.loadTexts: eNFTCounterReset.setDescription("The counter object is reset to zero and the counter discontinuity object is set to the current time if 'true' is written to this object. When read, the value of this object is always 'false'.")
eNFTLatestError = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 9, 2, 1, 7), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eNFTLatestError.setStatus('current')
if mibBuilder.loadTexts: eNFTLatestError.setDescription('The timestamp at the most recent occurrence of a threshold error on this measurement.')
eNFTActiveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 9, 2, 1, 8), ActiveTime()).setUnits('second').setMaxAccess("readonly")
if mibBuilder.loadTexts: eNFTActiveTime.setStatus('current')
if mibBuilder.loadTexts: eNFTActiveTime.setDescription('The total time when it has been possible to perform this measurement')
eNFTMeasurementState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 9, 2, 1, 9), MeasurementState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eNFTMeasurementState.setStatus('current')
if mibBuilder.loadTexts: eNFTMeasurementState.setDescription('Specifies the validity of the measurement value')
eNFTValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 9, 2, 1, 10), FloatingPoint()).setUnits('dB').setMaxAccess("readonly")
if mibBuilder.loadTexts: eNFTValue.setReference('TR 101 290 E.9.1')
if mibBuilder.loadTexts: eNFTValue.setStatus('current')
if mibBuilder.loadTexts: eNFTValue.setDescription('The current Equivalent Noise Floor expressed in dB, see the reference for the method of calculation.')
eNDTLPTable = MibTable((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 9, 3), )
if mibBuilder.loadTexts: eNDTLPTable.setStatus('current')
if mibBuilder.loadTexts: eNDTLPTable.setDescription("Equivalent Noise Degradation measurement. If the DVB-T transmission is hierarchical, this table contains the measurement for the LP (low priority) stream. If the transmission is not hierarchical, the MeasurementState for this table will be 'unknown'.")
eNDTLPEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 9, 3, 1), ).setIndexNames((0, "DVB-MGTR101290-MIB", "eNDTLPInputNumber"))
if mibBuilder.loadTexts: eNDTLPEntry.setStatus('current')
if mibBuilder.loadTexts: eNDTLPEntry.setDescription('Row specification')
eNDTLPInputNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 9, 3, 1, 1), InputNumber())
if mibBuilder.loadTexts: eNDTLPInputNumber.setStatus('current')
if mibBuilder.loadTexts: eNDTLPInputNumber.setDescription('Transport Stream on which the measurement is made')
eNDTLPTestState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 9, 3, 1, 2), TestState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eNDTLPTestState.setStatus('current')
if mibBuilder.loadTexts: eNDTLPTestState.setDescription('This indicates whether eNDTLPValue is within the thresholds.')
eNDTLPEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 9, 3, 1, 3), Enable().clone(namedValues=NamedValues(("testEnable", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: eNDTLPEnable.setStatus('current')
if mibBuilder.loadTexts: eNDTLPEnable.setDescription('Determines whether the threshold test and associated traps for this measurement are enabled.')
eNDTLPCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 9, 3, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eNDTLPCounter.setStatus('current')
if mibBuilder.loadTexts: eNDTLPCounter.setDescription('Count of the number of times a threshold error has occurred for this measurement.')
eNDTLPCounterDiscontinuity = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 9, 3, 1, 5), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eNDTLPCounterDiscontinuity.setStatus('current')
if mibBuilder.loadTexts: eNDTLPCounterDiscontinuity.setDescription('Provides the last time at which there was a discontinuity in the counter object.')
eNDTLPCounterReset = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 9, 3, 1, 6), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: eNDTLPCounterReset.setStatus('current')
if mibBuilder.loadTexts: eNDTLPCounterReset.setDescription("The counter object is reset to zero and the counter discontinuity object is set to the current time if 'true' is written to this object. When read, the value of this object is always 'false'.")
eNDTLPLatestError = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 9, 3, 1, 7), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eNDTLPLatestError.setStatus('current')
if mibBuilder.loadTexts: eNDTLPLatestError.setDescription('The timestamp at the most recent occurrence of a threshold error on this measurement.')
eNDTLPActiveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 9, 3, 1, 8), ActiveTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eNDTLPActiveTime.setStatus('current')
if mibBuilder.loadTexts: eNDTLPActiveTime.setDescription('The total time when it has been possible to perform this measurement')
eNDTLPMeasurementState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 9, 3, 1, 9), MeasurementState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eNDTLPMeasurementState.setStatus('current')
if mibBuilder.loadTexts: eNDTLPMeasurementState.setDescription('Specifies the validity of the measurement value')
eNDTLPValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 9, 3, 1, 10), FloatingPoint()).setUnits('dB').setMaxAccess("readonly")
if mibBuilder.loadTexts: eNDTLPValue.setStatus('current')
if mibBuilder.loadTexts: eNDTLPValue.setDescription('The current Equivalent Noise Degradation for the low priority stream expressed in dB.')
eNFTLPTable = MibTable((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 9, 4), )
if mibBuilder.loadTexts: eNFTLPTable.setStatus('current')
if mibBuilder.loadTexts: eNFTLPTable.setDescription("Equivalent Noise Floor measurement. If the DVB-T transmission is hierarchical, this table contains the measurement for the LP (low priority) stream. If the transmission is not hierarchical, the MeasurementState for this table will be 'unknown'.")
eNFTLPEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 9, 4, 1), ).setIndexNames((0, "DVB-MGTR101290-MIB", "eNDTLPInputNumber"))
if mibBuilder.loadTexts: eNFTLPEntry.setStatus('current')
if mibBuilder.loadTexts: eNFTLPEntry.setDescription('Row specification')
eNFTLPInputNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 9, 4, 1, 1), InputNumber())
if mibBuilder.loadTexts: eNFTLPInputNumber.setStatus('current')
if mibBuilder.loadTexts: eNFTLPInputNumber.setDescription('Transport Stream on which the measurement is made')
eNFTLPTestState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 9, 4, 1, 2), TestState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eNFTLPTestState.setStatus('current')
if mibBuilder.loadTexts: eNFTLPTestState.setDescription('This indicates whether eNFTLPValue is within the thresholds.')
eNFTLPEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 9, 4, 1, 3), Enable().clone(namedValues=NamedValues(("testEnable", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: eNFTLPEnable.setStatus('current')
if mibBuilder.loadTexts: eNFTLPEnable.setDescription('Determines whether the threshold test and associated traps for this measurement are enabled.')
eNFTLPCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 9, 4, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eNFTLPCounter.setStatus('current')
if mibBuilder.loadTexts: eNFTLPCounter.setDescription('Count of the number of times a threshold error has occurred for this measurement.')
eNFTLPCounterDiscontinuity = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 9, 4, 1, 5), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eNFTLPCounterDiscontinuity.setStatus('current')
if mibBuilder.loadTexts: eNFTLPCounterDiscontinuity.setDescription('Provides the last time at which there was a discontinuity in the counter object.')
eNFTLPCounterReset = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 9, 4, 1, 6), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: eNFTLPCounterReset.setStatus('current')
if mibBuilder.loadTexts: eNFTLPCounterReset.setDescription("The counter object is reset to zero and the counter discontinuity object is set to the current time if 'true' is written to this object. When read, the value of this object is always 'false'.")
eNFTLPLatestError = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 9, 4, 1, 7), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eNFTLPLatestError.setStatus('current')
if mibBuilder.loadTexts: eNFTLPLatestError.setDescription('The timestamp at the most recent occurrence of a threshold error on this measurement.')
eNFTLPActiveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 9, 4, 1, 8), ActiveTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eNFTLPActiveTime.setStatus('current')
if mibBuilder.loadTexts: eNFTLPActiveTime.setDescription('The total time when it has been possible to perform this measurement')
eNFTLPMeasurementState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 9, 4, 1, 9), MeasurementState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eNFTLPMeasurementState.setStatus('current')
if mibBuilder.loadTexts: eNFTLPMeasurementState.setDescription('Specifies the validity of the measurement value')
eNFTLPValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 9, 4, 1, 10), FloatingPoint()).setUnits('dB').setMaxAccess("readonly")
if mibBuilder.loadTexts: eNFTLPValue.setReference('TR 101 290 E.9.1')
if mibBuilder.loadTexts: eNFTLPValue.setStatus('current')
if mibBuilder.loadTexts: eNFTLPValue.setDescription('The current Equivalent Noise Floor for the low priority stream, expressed in dB, see the reference for the method of calculation.')
linearityTable = MibTable((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 10), )
if mibBuilder.loadTexts: linearityTable.setReference('TR 101 290 section 9.10')
if mibBuilder.loadTexts: linearityTable.setStatus('current')
if mibBuilder.loadTexts: linearityTable.setDescription('Linearity characterization (shoulder attenuation)')
linearityEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 10, 1), ).setIndexNames((0, "DVB-MGTR101290-MIB", "linearityInputNumber"))
if mibBuilder.loadTexts: linearityEntry.setStatus('current')
if mibBuilder.loadTexts: linearityEntry.setDescription('Row specification')
linearityInputNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 10, 1, 1), InputNumber())
if mibBuilder.loadTexts: linearityInputNumber.setStatus('current')
if mibBuilder.loadTexts: linearityInputNumber.setDescription('Transport Stream on which the measurement is made')
linearityTestState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 10, 1, 2), TestState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: linearityTestState.setStatus('current')
if mibBuilder.loadTexts: linearityTestState.setDescription('This indicates whether the linearityValue is above the minimum permitted.')
linearityEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 10, 1, 3), Enable().clone(namedValues=NamedValues(("testEnable", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: linearityEnable.setStatus('current')
if mibBuilder.loadTexts: linearityEnable.setDescription('Determines whether the threshold test and associated traps for this measurement are enabled.')
linearityCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 10, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: linearityCounter.setStatus('current')
if mibBuilder.loadTexts: linearityCounter.setDescription('Count of the number of times a threshold error has occurred for this measurement.')
linearityCounterDiscontinuity = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 10, 1, 5), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: linearityCounterDiscontinuity.setStatus('current')
if mibBuilder.loadTexts: linearityCounterDiscontinuity.setDescription('Provides the last time at which there was a discontinuity in the counter object.')
linearityCounterReset = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 10, 1, 6), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: linearityCounterReset.setStatus('current')
if mibBuilder.loadTexts: linearityCounterReset.setDescription("The counter object is reset to zero and the counter discontinuity object is set to the current time if 'true' is written to this object. When read, the value of this object is always 'false'.")
linearityLatestError = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 10, 1, 7), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: linearityLatestError.setStatus('current')
if mibBuilder.loadTexts: linearityLatestError.setDescription('The timestamp at the most recent occurrence of a threshold error on this measurement.')
linearityActiveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 10, 1, 8), ActiveTime()).setUnits('second').setMaxAccess("readonly")
if mibBuilder.loadTexts: linearityActiveTime.setStatus('current')
if mibBuilder.loadTexts: linearityActiveTime.setDescription('The total time when it has been possible to perform this measurement')
linearityMeasurementState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 10, 1, 9), MeasurementState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: linearityMeasurementState.setStatus('current')
if mibBuilder.loadTexts: linearityMeasurementState.setDescription('Specifies the validity of the measurement value')
linearityValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 10, 1, 10), FloatingPoint()).setUnits('dB').setMaxAccess("readonly")
if mibBuilder.loadTexts: linearityValue.setStatus('current')
if mibBuilder.loadTexts: linearityValue.setDescription('The current linearity (shoulder attenuation) expressed in dB.')
berViterbiT = MibIdentifier((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 15))
berViterbiTTable = MibTable((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 15, 1), )
if mibBuilder.loadTexts: berViterbiTTable.setReference('TR 101 290 section 9.15')
if mibBuilder.loadTexts: berViterbiTTable.setStatus('current')
if mibBuilder.loadTexts: berViterbiTTable.setDescription('BER before Viterbi measurement. If the DVB-T transmission is hierarchical, this table contains the measurement for the HP (high priority) stream. If the transmission is not hierarchical, this table contains the measurement for the whole stream.')
berViterbiTEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 15, 1, 1), ).setIndexNames((0, "DVB-MGTR101290-MIB", "berViterbiTInputNumber"))
if mibBuilder.loadTexts: berViterbiTEntry.setStatus('current')
if mibBuilder.loadTexts: berViterbiTEntry.setDescription('Row specification')
berViterbiTInputNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 15, 1, 1, 1), InputNumber())
if mibBuilder.loadTexts: berViterbiTInputNumber.setStatus('current')
if mibBuilder.loadTexts: berViterbiTInputNumber.setDescription('Transport Stream on which the measurement is made')
berViterbiTTestState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 15, 1, 1, 2), TestState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: berViterbiTTestState.setStatus('current')
if mibBuilder.loadTexts: berViterbiTTestState.setDescription('This indicates whether the berViterbiTValue is within the thresholds.')
berViterbiTEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 15, 1, 1, 3), Enable().clone(namedValues=NamedValues(("testEnable", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: berViterbiTEnable.setStatus('current')
if mibBuilder.loadTexts: berViterbiTEnable.setDescription('Determines whether the threshold test and associated traps for this measurement are enabled.')
berViterbiTCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 15, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: berViterbiTCounter.setStatus('current')
if mibBuilder.loadTexts: berViterbiTCounter.setDescription('Count of the number of times a threshold error has occurred for this measurement.')
berViterbiTCounterDiscontinuity = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 15, 1, 1, 5), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: berViterbiTCounterDiscontinuity.setStatus('current')
if mibBuilder.loadTexts: berViterbiTCounterDiscontinuity.setDescription('Provides the last time at which there was a discontinuity in the counter object.')
berViterbiTCounterReset = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 15, 1, 1, 6), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: berViterbiTCounterReset.setStatus('current')
if mibBuilder.loadTexts: berViterbiTCounterReset.setDescription("The counter object is reset to zero and the counter discontinuity object is set to the current time if 'true' is written to this object. When read, the value of this object is always 'false'.")
berViterbiTLatestError = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 15, 1, 1, 7), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: berViterbiTLatestError.setStatus('current')
if mibBuilder.loadTexts: berViterbiTLatestError.setDescription('The timestamp at the most recent occurrence of a threshold error on this measurement.')
berViterbiTActiveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 15, 1, 1, 8), ActiveTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: berViterbiTActiveTime.setStatus('current')
if mibBuilder.loadTexts: berViterbiTActiveTime.setDescription('The total time when it has been possible to perform this measurement')
berViterbiTMeasurementState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 15, 1, 1, 9), MeasurementState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: berViterbiTMeasurementState.setStatus('current')
if mibBuilder.loadTexts: berViterbiTMeasurementState.setDescription('Specifies the validity of the measurement value')
berViterbiTValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 15, 1, 1, 10), FloatingPoint()).setMaxAccess("readonly")
if mibBuilder.loadTexts: berViterbiTValue.setStatus('current')
if mibBuilder.loadTexts: berViterbiTValue.setDescription('This is the overall pre-Viterbi BER value, for example 0.0000046')
berViterbiTLPTable = MibTable((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 15, 2), )
if mibBuilder.loadTexts: berViterbiTLPTable.setStatus('current')
if mibBuilder.loadTexts: berViterbiTLPTable.setDescription("BER before Viterbi measurement. If the DVB-T transmission is hierarchical, this table contains the measurement for the LP (low priority) stream. If the transmission is not hierarchical, the MeasurementState for this table will be 'unknown'.")
berViterbiTLPEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 15, 2, 1), ).setIndexNames((0, "DVB-MGTR101290-MIB", "berViterbiTLPInputNumber"))
if mibBuilder.loadTexts: berViterbiTLPEntry.setStatus('current')
if mibBuilder.loadTexts: berViterbiTLPEntry.setDescription('Row specification')
berViterbiTLPInputNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 15, 2, 1, 1), InputNumber())
if mibBuilder.loadTexts: berViterbiTLPInputNumber.setStatus('current')
if mibBuilder.loadTexts: berViterbiTLPInputNumber.setDescription('Transport Stream on which the measurement is made')
berViterbiTLPTestState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 15, 2, 1, 2), TestState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: berViterbiTLPTestState.setStatus('current')
if mibBuilder.loadTexts: berViterbiTLPTestState.setDescription('This indicates whether the berViterbiTLPValue is within the thresholds.')
berViterbiTLPEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 15, 2, 1, 3), Enable().clone(namedValues=NamedValues(("testEnable", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: berViterbiTLPEnable.setStatus('current')
if mibBuilder.loadTexts: berViterbiTLPEnable.setDescription('Determines whether the threshold test and associated traps for this measurement are enabled.')
berViterbiTLPCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 15, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: berViterbiTLPCounter.setStatus('current')
if mibBuilder.loadTexts: berViterbiTLPCounter.setDescription('Count of the number of times a threshold error has occurred for this measurement.')
berViterbiTLPCounterDiscontinuity = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 15, 2, 1, 5), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: berViterbiTLPCounterDiscontinuity.setStatus('current')
if mibBuilder.loadTexts: berViterbiTLPCounterDiscontinuity.setDescription('Provides the last time at which there was a discontinuity in the counter object.')
berViterbiTLPCounterReset = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 15, 2, 1, 6), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: berViterbiTLPCounterReset.setStatus('current')
if mibBuilder.loadTexts: berViterbiTLPCounterReset.setDescription("The counter object is reset to zero and the counter discontinuity object is set to the current time if 'true' is written to this object. When read, the value of this object is always 'false'.")
berViterbiTLPLatestError = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 15, 2, 1, 7), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: berViterbiTLPLatestError.setStatus('current')
if mibBuilder.loadTexts: berViterbiTLPLatestError.setDescription('The timestamp at the most recent occurrence of a threshold error on this measurement.')
berViterbiTLPActiveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 15, 2, 1, 8), ActiveTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: berViterbiTLPActiveTime.setStatus('current')
if mibBuilder.loadTexts: berViterbiTLPActiveTime.setDescription('The total time when it has been possible to perform this measurement')
berViterbiTLPMeasurementState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 15, 2, 1, 9), MeasurementState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: berViterbiTLPMeasurementState.setStatus('current')
if mibBuilder.loadTexts: berViterbiTLPMeasurementState.setDescription('Specifies the validity of the measurement value')
berViterbiTLPValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 15, 2, 1, 10), FloatingPoint()).setUnits('dB').setMaxAccess("readonly")
if mibBuilder.loadTexts: berViterbiTLPValue.setStatus('current')
if mibBuilder.loadTexts: berViterbiTLPValue.setDescription('This is the overall pre-Viterbi BER value, for example 0.0000046')
berRS = MibIdentifier((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 16))
berRSTable = MibTable((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 16, 1), )
if mibBuilder.loadTexts: berRSTable.setReference('TR 101 290 section 9.16')
if mibBuilder.loadTexts: berRSTable.setStatus('current')
if mibBuilder.loadTexts: berRSTable.setDescription('BER before RS measurement. If the DVB-T transmission is hierarchical, this table contains the measurement for the HP (high priority) stream. If the transmission is not hierarchical, this table contains the measurement for the whole stream.')
berRSEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 16, 1, 1), ).setIndexNames((0, "DVB-MGTR101290-MIB", "berRSInputNumber"))
if mibBuilder.loadTexts: berRSEntry.setStatus('current')
if mibBuilder.loadTexts: berRSEntry.setDescription('Row specification')
berRSInputNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 16, 1, 1, 1), InputNumber())
if mibBuilder.loadTexts: berRSInputNumber.setStatus('current')
if mibBuilder.loadTexts: berRSInputNumber.setDescription('Transport Stream on which the measurement is made')
berRSTestState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 16, 1, 1, 2), TestState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: berRSTestState.setStatus('current')
if mibBuilder.loadTexts: berRSTestState.setDescription('This indicates whether berRSValue is below the maximum.')
berRSEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 16, 1, 1, 3), Enable().clone(namedValues=NamedValues(("testEnable", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: berRSEnable.setStatus('current')
if mibBuilder.loadTexts: berRSEnable.setDescription('Determines whether the threshold test and associated traps for this measurement are enabled.')
berRSCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 16, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: berRSCounter.setStatus('current')
if mibBuilder.loadTexts: berRSCounter.setDescription('Count of the number of times a threshold error has occurred for this measurement.')
berRSCounterDiscontinuity = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 16, 1, 1, 5), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: berRSCounterDiscontinuity.setStatus('current')
if mibBuilder.loadTexts: berRSCounterDiscontinuity.setDescription('Provides the last time at which there was a discontinuity in the counter object.')
berRSCounterReset = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 16, 1, 1, 6), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: berRSCounterReset.setStatus('current')
if mibBuilder.loadTexts: berRSCounterReset.setDescription("The counter object is reset to zero and the counter discontinuity object is set to the current time if 'true' is written to this object. When read, the value of this object is always 'false'.")
berRSLatestError = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 16, 1, 1, 7), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: berRSLatestError.setStatus('current')
if mibBuilder.loadTexts: berRSLatestError.setDescription('The timestamp at the most recent occurrence of a threshold error on this measurement.')
berRSActiveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 16, 1, 1, 8), ActiveTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: berRSActiveTime.setStatus('current')
if mibBuilder.loadTexts: berRSActiveTime.setDescription('The total time when it has been possible to perform this measurement')
berRSMeasurementState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 16, 1, 1, 9), MeasurementState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: berRSMeasurementState.setStatus('current')
if mibBuilder.loadTexts: berRSMeasurementState.setDescription('Specifies the validity of the measurement value')
berRSValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 16, 1, 1, 10), FloatingPoint()).setMaxAccess("readonly")
if mibBuilder.loadTexts: berRSValue.setStatus('current')
if mibBuilder.loadTexts: berRSValue.setDescription('This is the BER before RS (outer) decoder measured using the in-service method. It is expressed as a number, e.g. 0.0000034')
berRSLPTable = MibTable((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 16, 2), )
if mibBuilder.loadTexts: berRSLPTable.setStatus('current')
if mibBuilder.loadTexts: berRSLPTable.setDescription("BER before RS measurement. If the DVB-T transmission is hierarchical, this table contains the measurement for the LP (low priority) stream. If the transmission is not hierarchical, the MeasurementState for this table will be 'unknown'.")
berRSLPEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 16, 2, 1), ).setIndexNames((0, "DVB-MGTR101290-MIB", "berRSLPInputNumber"))
if mibBuilder.loadTexts: berRSLPEntry.setStatus('current')
if mibBuilder.loadTexts: berRSLPEntry.setDescription('Row specification')
berRSLPInputNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 16, 2, 1, 1), InputNumber())
if mibBuilder.loadTexts: berRSLPInputNumber.setStatus('current')
if mibBuilder.loadTexts: berRSLPInputNumber.setDescription('Transport Stream on which the measurement is made')
berRSLPTestState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 16, 2, 1, 2), TestState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: berRSLPTestState.setStatus('current')
if mibBuilder.loadTexts: berRSLPTestState.setDescription('This indicates whether berRSLPValue is within the thresholds.')
berRSLPEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 16, 2, 1, 3), Enable().clone(namedValues=NamedValues(("testEnable", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: berRSLPEnable.setStatus('current')
if mibBuilder.loadTexts: berRSLPEnable.setDescription('Determines whether the threshold test and associated traps for this measurement are enabled.')
berRSLPCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 16, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: berRSLPCounter.setStatus('current')
if mibBuilder.loadTexts: berRSLPCounter.setDescription('Count of the number of times a threshold error has occurred for this measurement.')
berRSLPCounterDiscontinuity = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 16, 2, 1, 5), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: berRSLPCounterDiscontinuity.setStatus('current')
if mibBuilder.loadTexts: berRSLPCounterDiscontinuity.setDescription('Provides the last time at which there was a discontinuity in the counter object.')
berRSLPCounterReset = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 16, 2, 1, 6), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: berRSLPCounterReset.setStatus('current')
if mibBuilder.loadTexts: berRSLPCounterReset.setDescription("The counter object is reset to zero and the counter discontinuity object is set to the current time if 'true' is written to this object. When read, the value of this object is always 'false'.")
berRSLPLatestError = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 16, 2, 1, 7), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: berRSLPLatestError.setStatus('current')
if mibBuilder.loadTexts: berRSLPLatestError.setDescription('The timestamp at the most recent occurrence of a threshold error on this measurement.')
berRSLPActiveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 16, 2, 1, 8), ActiveTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: berRSLPActiveTime.setStatus('current')
if mibBuilder.loadTexts: berRSLPActiveTime.setDescription('The total time when it has been possible to perform this measurement')
berRSLPMeasurementState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 16, 2, 1, 9), MeasurementState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: berRSLPMeasurementState.setStatus('current')
if mibBuilder.loadTexts: berRSLPMeasurementState.setDescription('Specifies the validity of the measurement value')
berRSLPValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 16, 2, 1, 10), FloatingPoint()).setMaxAccess("readonly")
if mibBuilder.loadTexts: berRSLPValue.setStatus('current')
if mibBuilder.loadTexts: berRSLPValue.setDescription('This is the BER before RS (outer) decoder for the low priority stream measured using the in-service method. It is expressed as a number, e.g. 0.0000034')
iqAnalysisT = MibIdentifier((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18))
merTTable = MibTable((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 2), )
if mibBuilder.loadTexts: merTTable.setReference('TR 101 290 section 9.18.2')
if mibBuilder.loadTexts: merTTable.setStatus('current')
if mibBuilder.loadTexts: merTTable.setDescription('Modulation Error Ratio (MER) measurement')
merTEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 2, 1), ).setIndexNames((0, "DVB-MGTR101290-MIB", "merTInputNumber"))
if mibBuilder.loadTexts: merTEntry.setStatus('current')
if mibBuilder.loadTexts: merTEntry.setDescription('Row specification')
merTInputNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 2, 1, 1), InputNumber())
if mibBuilder.loadTexts: merTInputNumber.setStatus('current')
if mibBuilder.loadTexts: merTInputNumber.setDescription('Transport Stream on which the measurement is made')
merTTestState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 2, 1, 2), TestState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: merTTestState.setStatus('current')
if mibBuilder.loadTexts: merTTestState.setDescription('This indicates whether merTValue is within the thresholds.')
merTEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 2, 1, 3), Enable().clone(namedValues=NamedValues(("testEnable", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: merTEnable.setStatus('current')
if mibBuilder.loadTexts: merTEnable.setDescription('Determines whether the threshold test and associated traps for this measurement are enabled.')
merTCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: merTCounter.setStatus('current')
if mibBuilder.loadTexts: merTCounter.setDescription('Count of the number of times a threshold error has occurred for this measurement.')
merTCounterDiscontinuity = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 2, 1, 5), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: merTCounterDiscontinuity.setStatus('current')
if mibBuilder.loadTexts: merTCounterDiscontinuity.setDescription('Provides the last time at which there was a discontinuity in the merTCounter object.')
merTCounterReset = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 2, 1, 6), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: merTCounterReset.setStatus('current')
if mibBuilder.loadTexts: merTCounterReset.setDescription("The counter object is reset to zero and the counter discontinuity object is set to the current time if 'true' is written to this object. When read, the value of this object is always 'false'.")
merTLatestError = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 2, 1, 7), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: merTLatestError.setStatus('current')
if mibBuilder.loadTexts: merTLatestError.setDescription('The timestamp at the most recent occurrence of a threshold error on this measurement.')
merTActiveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 2, 1, 8), ActiveTime()).setUnits('second').setMaxAccess("readonly")
if mibBuilder.loadTexts: merTActiveTime.setStatus('current')
if mibBuilder.loadTexts: merTActiveTime.setDescription('The total time when it has been possible to perform this measurement')
merTMeasurementState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 2, 1, 9), MeasurementState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: merTMeasurementState.setStatus('current')
if mibBuilder.loadTexts: merTMeasurementState.setDescription('Specifies the validity of the measurement value')
merTValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 2, 1, 10), FloatingPoint()).setUnits('dB').setMaxAccess("readonly")
if mibBuilder.loadTexts: merTValue.setStatus('current')
if mibBuilder.loadTexts: merTValue.setDescription('The current Modulation Error Ratio expressed in dB')
steT = MibIdentifier((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 3))
steMeanTTable = MibTable((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 3, 1), )
if mibBuilder.loadTexts: steMeanTTable.setReference('TR 101 290 section 9.18.3')
if mibBuilder.loadTexts: steMeanTTable.setStatus('current')
if mibBuilder.loadTexts: steMeanTTable.setDescription('System Target Error Mean (STEM) measurement')
steMeanTEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 3, 1, 1), ).setIndexNames((0, "DVB-MGTR101290-MIB", "steMeanTInputNumber"))
if mibBuilder.loadTexts: steMeanTEntry.setStatus('current')
if mibBuilder.loadTexts: steMeanTEntry.setDescription('Row specification')
steMeanTInputNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 3, 1, 1, 1), InputNumber())
if mibBuilder.loadTexts: steMeanTInputNumber.setStatus('current')
if mibBuilder.loadTexts: steMeanTInputNumber.setDescription('Transport Stream on which the measurement is made')
steMeanTTestState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 3, 1, 1, 2), TestState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: steMeanTTestState.setStatus('current')
if mibBuilder.loadTexts: steMeanTTestState.setDescription('This indicates whether steMeanTValue is currently within the thresholds.')
steMeanTEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 3, 1, 1, 3), Enable().clone(namedValues=NamedValues(("testEnable", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: steMeanTEnable.setStatus('current')
if mibBuilder.loadTexts: steMeanTEnable.setDescription('Determines whether the threshold test and associated traps for this measurement are enabled.')
steMeanTCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 3, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: steMeanTCounter.setStatus('current')
if mibBuilder.loadTexts: steMeanTCounter.setDescription('Count of the number of times a threshold error has occurred for this measurement.')
steMeanTCounterDiscontinuity = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 3, 1, 1, 5), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: steMeanTCounterDiscontinuity.setStatus('current')
if mibBuilder.loadTexts: steMeanTCounterDiscontinuity.setDescription('Provides the last time at which there was a discontinuity in the counter object.')
steMeanTCounterReset = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 3, 1, 1, 6), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: steMeanTCounterReset.setStatus('current')
if mibBuilder.loadTexts: steMeanTCounterReset.setDescription("The counter object is reset to zero and the counter discontinuity object is set to the current time if 'true' is written to this object. When read, the value of this object is always 'false'.")
steMeanTLatestError = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 3, 1, 1, 7), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: steMeanTLatestError.setStatus('current')
if mibBuilder.loadTexts: steMeanTLatestError.setDescription('The timestamp at the most recent occurrence of a threshold error on this measurement.')
steMeanTActiveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 3, 1, 1, 8), ActiveTime()).setUnits('second').setMaxAccess("readonly")
if mibBuilder.loadTexts: steMeanTActiveTime.setStatus('current')
if mibBuilder.loadTexts: steMeanTActiveTime.setDescription('The total time when it has been possible to perform this measurement')
steMeanTMeasurementState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 3, 1, 1, 9), MeasurementState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: steMeanTMeasurementState.setStatus('current')
if mibBuilder.loadTexts: steMeanTMeasurementState.setDescription('Specifies the validity of the measurement value')
steMeanTValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 3, 1, 1, 10), FloatingPoint()).setMaxAccess("readonly")
if mibBuilder.loadTexts: steMeanTValue.setStatus('current')
if mibBuilder.loadTexts: steMeanTValue.setDescription('The current System Target Error Mean as a numeric value')
steDeviationTTable = MibTable((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 3, 2), )
if mibBuilder.loadTexts: steDeviationTTable.setReference('TR 101 290 section 9.18.3')
if mibBuilder.loadTexts: steDeviationTTable.setStatus('current')
if mibBuilder.loadTexts: steDeviationTTable.setDescription('System Target Error Deviation (STED) measurement')
steDeviationTEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 3, 2, 1), ).setIndexNames((0, "DVB-MGTR101290-MIB", "steDeviationTInputNumber"))
if mibBuilder.loadTexts: steDeviationTEntry.setStatus('current')
if mibBuilder.loadTexts: steDeviationTEntry.setDescription('Row specification')
steDeviationTInputNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 3, 2, 1, 1), InputNumber())
if mibBuilder.loadTexts: steDeviationTInputNumber.setStatus('current')
if mibBuilder.loadTexts: steDeviationTInputNumber.setDescription('Transport Stream on which the measurement is made')
steDeviationTTestState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 3, 2, 1, 2), TestState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: steDeviationTTestState.setStatus('current')
if mibBuilder.loadTexts: steDeviationTTestState.setDescription('This indicates whether steDeviationTValue is currently within the thresholds.')
steDeviationTEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 3, 2, 1, 3), Enable().clone(namedValues=NamedValues(("testEnable", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: steDeviationTEnable.setStatus('current')
if mibBuilder.loadTexts: steDeviationTEnable.setDescription('Determines whether the threshold test and associated traps for this measurement are enabled.')
steDeviationTCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 3, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: steDeviationTCounter.setStatus('current')
if mibBuilder.loadTexts: steDeviationTCounter.setDescription('Count of the number of times a threshold error has occurred for this measurement.')
steDeviationTCounterDiscontinuity = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 3, 2, 1, 5), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: steDeviationTCounterDiscontinuity.setStatus('current')
if mibBuilder.loadTexts: steDeviationTCounterDiscontinuity.setDescription('Provides the last time at which there was a discontinuity in the counter object.')
steDeviationTCounterReset = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 3, 2, 1, 6), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: steDeviationTCounterReset.setStatus('current')
if mibBuilder.loadTexts: steDeviationTCounterReset.setDescription("The counter object is reset to zero and the counter discontinuity object is set to the current time if 'true' is written to this object. When read, the value of this object is always 'false'.")
steDeviationTLatestError = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 3, 2, 1, 7), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: steDeviationTLatestError.setStatus('current')
if mibBuilder.loadTexts: steDeviationTLatestError.setDescription('The timestamp at the most recent occurrence of a threshold error on this measurement.')
steDeviationTActiveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 3, 2, 1, 8), ActiveTime()).setUnits('second').setMaxAccess("readonly")
if mibBuilder.loadTexts: steDeviationTActiveTime.setStatus('current')
if mibBuilder.loadTexts: steDeviationTActiveTime.setDescription('The total time when it has been possible to perform this measurement')
steDeviationTMeasurementState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 3, 2, 1, 9), MeasurementState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: steDeviationTMeasurementState.setStatus('current')
if mibBuilder.loadTexts: steDeviationTMeasurementState.setDescription('Specifies the validity of the measurement value')
steDeviationTValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 3, 2, 1, 10), FloatingPoint()).setMaxAccess("readonly")
if mibBuilder.loadTexts: steDeviationTValue.setStatus('current')
if mibBuilder.loadTexts: steDeviationTValue.setDescription('The current System Target Error Deviation as a numeric value')
csTTable = MibTable((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 4), )
if mibBuilder.loadTexts: csTTable.setReference('TR 101 290 section 9.18.4')
if mibBuilder.loadTexts: csTTable.setStatus('current')
if mibBuilder.loadTexts: csTTable.setDescription('Carrier Suppression (CS) measurement')
csTEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 4, 1), ).setIndexNames((0, "DVB-MGTR101290-MIB", "csTInputNumber"))
if mibBuilder.loadTexts: csTEntry.setStatus('current')
if mibBuilder.loadTexts: csTEntry.setDescription('Row specification')
csTInputNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 4, 1, 1), InputNumber())
if mibBuilder.loadTexts: csTInputNumber.setStatus('current')
if mibBuilder.loadTexts: csTInputNumber.setDescription('Transport Stream on which the measurement is made')
csTTestState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 4, 1, 2), TestState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csTTestState.setStatus('current')
if mibBuilder.loadTexts: csTTestState.setDescription('This indicates whether csTValue is currently within the thresholds.')
csTEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 4, 1, 3), Enable().clone(namedValues=NamedValues(("testEnable", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: csTEnable.setStatus('current')
if mibBuilder.loadTexts: csTEnable.setDescription('Determines whether the threshold test and associated traps for this measurement are enabled.')
csTCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 4, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csTCounter.setStatus('current')
if mibBuilder.loadTexts: csTCounter.setDescription('Count of the number of times a threshold error has occurred for this measurement.')
csTCounterDiscontinuity = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 4, 1, 5), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csTCounterDiscontinuity.setStatus('current')
if mibBuilder.loadTexts: csTCounterDiscontinuity.setDescription('Provides the last time at which there was a discontinuity in the counter object.')
csTCounterReset = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 4, 1, 6), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: csTCounterReset.setStatus('current')
if mibBuilder.loadTexts: csTCounterReset.setDescription("The counter object is reset to zero and the counter discontinuity object is set to the current time if 'true' is written to this object. When read, the value of this object is always 'false'.")
csTLatestError = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 4, 1, 7), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csTLatestError.setStatus('current')
if mibBuilder.loadTexts: csTLatestError.setDescription('The timestamp at the most recent occurrence of a threshold error on this measurement.')
csTActiveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 4, 1, 8), ActiveTime()).setUnits('second').setMaxAccess("readonly")
if mibBuilder.loadTexts: csTActiveTime.setStatus('current')
if mibBuilder.loadTexts: csTActiveTime.setDescription('The total time when it has been possible to perform this measurement')
csTMeasurementState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 4, 1, 9), MeasurementState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csTMeasurementState.setStatus('current')
if mibBuilder.loadTexts: csTMeasurementState.setDescription('Specifies the validity of the measurement value')
csTValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 4, 1, 10), FloatingPoint()).setUnits('dB').setMaxAccess("readonly")
if mibBuilder.loadTexts: csTValue.setStatus('current')
if mibBuilder.loadTexts: csTValue.setDescription('The current Carrier Suppression value in dB.')
aiTTable = MibTable((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 5), )
if mibBuilder.loadTexts: aiTTable.setReference('TR 101 290 section 9.18.5')
if mibBuilder.loadTexts: aiTTable.setStatus('current')
if mibBuilder.loadTexts: aiTTable.setDescription('Amplitude Imbalance (AI) measurement')
aiTEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 5, 1), ).setIndexNames((0, "DVB-MGTR101290-MIB", "aiTInputNumber"))
if mibBuilder.loadTexts: aiTEntry.setStatus('current')
if mibBuilder.loadTexts: aiTEntry.setDescription('Row specification')
aiTInputNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 5, 1, 1), InputNumber())
if mibBuilder.loadTexts: aiTInputNumber.setStatus('current')
if mibBuilder.loadTexts: aiTInputNumber.setDescription('Transport Stream on which the measurement is made')
aiTTestState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 5, 1, 2), TestState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aiTTestState.setStatus('current')
if mibBuilder.loadTexts: aiTTestState.setDescription('This indicates whether aiTValue is currently within the thresholds.')
aiTEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 5, 1, 3), Enable().clone(namedValues=NamedValues(("testEnable", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiTEnable.setStatus('current')
if mibBuilder.loadTexts: aiTEnable.setDescription('Determines whether the threshold test and associated traps for this measurement are enabled.')
aiTCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 5, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aiTCounter.setStatus('current')
if mibBuilder.loadTexts: aiTCounter.setDescription('Count of the number of times a threshold error has occurred for this measurement.')
aiTCounterDiscontinuity = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 5, 1, 5), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aiTCounterDiscontinuity.setStatus('current')
if mibBuilder.loadTexts: aiTCounterDiscontinuity.setDescription('Provides the last time at which there was a discontinuity in the counter object.')
aiTCounterReset = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 5, 1, 6), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiTCounterReset.setStatus('current')
if mibBuilder.loadTexts: aiTCounterReset.setDescription("The counter object is reset to zero and the counter discontinuity object is set to the current time if 'true' is written to this object. When read, the value of this object is always 'false'.")
aiTLatestError = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 5, 1, 7), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aiTLatestError.setStatus('current')
if mibBuilder.loadTexts: aiTLatestError.setDescription('The timestamp at the most recent occurrence of a threshold error on this measurement.')
aiTActiveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 5, 1, 8), ActiveTime()).setUnits('second').setMaxAccess("readonly")
if mibBuilder.loadTexts: aiTActiveTime.setStatus('current')
if mibBuilder.loadTexts: aiTActiveTime.setDescription('The total time when it has been possible to perform this measurement')
aiTMeasurementState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 5, 1, 9), MeasurementState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aiTMeasurementState.setStatus('current')
if mibBuilder.loadTexts: aiTMeasurementState.setDescription('Specifies the validity of the measurement value')
aiTValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 5, 1, 10), FloatingPoint()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aiTValue.setStatus('current')
if mibBuilder.loadTexts: aiTValue.setDescription('The current Amplitude Imbalance as a percentage')
qeTTable = MibTable((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 6), )
if mibBuilder.loadTexts: qeTTable.setReference('TR 101 290 section 9.18.6')
if mibBuilder.loadTexts: qeTTable.setStatus('current')
if mibBuilder.loadTexts: qeTTable.setDescription('Quadrature Error (QE) measurement')
qeTEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 6, 1), ).setIndexNames((0, "DVB-MGTR101290-MIB", "qeTInputNumber"))
if mibBuilder.loadTexts: qeTEntry.setStatus('current')
if mibBuilder.loadTexts: qeTEntry.setDescription('Row specification')
qeTInputNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 6, 1, 1), InputNumber())
if mibBuilder.loadTexts: qeTInputNumber.setStatus('current')
if mibBuilder.loadTexts: qeTInputNumber.setDescription('Transport Stream on which the measurement is made')
qeTTestState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 6, 1, 2), TestState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: qeTTestState.setStatus('current')
if mibBuilder.loadTexts: qeTTestState.setDescription('This indicates whether qeTValue is currently within the thresholds.')
qeTEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 6, 1, 3), Enable().clone(namedValues=NamedValues(("testEnable", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qeTEnable.setStatus('current')
if mibBuilder.loadTexts: qeTEnable.setDescription('Determines whether the threshold test and associated traps for this measurement are enabled.')
qeTCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 6, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: qeTCounter.setStatus('current')
if mibBuilder.loadTexts: qeTCounter.setDescription('Count of the number of times a threshold error has occurred for this measurement.')
qeTCounterDiscontinuity = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 6, 1, 5), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: qeTCounterDiscontinuity.setStatus('current')
if mibBuilder.loadTexts: qeTCounterDiscontinuity.setDescription('Provides the last time at which there was a discontinuity in the counter object.')
qeTCounterReset = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 6, 1, 6), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qeTCounterReset.setStatus('current')
if mibBuilder.loadTexts: qeTCounterReset.setDescription("The counter object is reset to zero and the counter discontinuity object is set to the current time if 'true' is written to this object. When read, the value of this object is always 'false'.")
qeTLatestError = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 6, 1, 7), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: qeTLatestError.setStatus('current')
if mibBuilder.loadTexts: qeTLatestError.setDescription('The timestamp at the most recent occurrence of a threshold error on this measurement.')
qeTActiveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 6, 1, 8), ActiveTime()).setUnits('second').setMaxAccess("readonly")
if mibBuilder.loadTexts: qeTActiveTime.setStatus('current')
if mibBuilder.loadTexts: qeTActiveTime.setDescription('The total time when it has been possible to perform this measurement')
qeTMeasurementState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 6, 1, 9), MeasurementState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: qeTMeasurementState.setStatus('current')
if mibBuilder.loadTexts: qeTMeasurementState.setDescription('Specifies the validity of the measurement value')
qeTValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 6, 1, 10), FloatingPoint()).setUnits('degree').setMaxAccess("readonly")
if mibBuilder.loadTexts: qeTValue.setStatus('current')
if mibBuilder.loadTexts: qeTValue.setDescription('The current Quadrature Error value in degrees.')
pjTTable = MibTable((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 7), )
if mibBuilder.loadTexts: pjTTable.setReference('TR 101 290 section 9.18.7')
if mibBuilder.loadTexts: pjTTable.setStatus('current')
if mibBuilder.loadTexts: pjTTable.setDescription('Phase Jitter (PJ) measurement')
pjTEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 7, 1), ).setIndexNames((0, "DVB-MGTR101290-MIB", "pjTInputNumber"))
if mibBuilder.loadTexts: pjTEntry.setStatus('current')
if mibBuilder.loadTexts: pjTEntry.setDescription('Row specification')
pjTInputNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 7, 1, 1), InputNumber())
if mibBuilder.loadTexts: pjTInputNumber.setStatus('current')
if mibBuilder.loadTexts: pjTInputNumber.setDescription('Transport Stream on which the measurement is made')
pjTTestState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 7, 1, 2), TestState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pjTTestState.setStatus('current')
if mibBuilder.loadTexts: pjTTestState.setDescription('This indicates whether pjTValue is currently within the thresholds.')
pjTEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 7, 1, 3), Enable().clone(namedValues=NamedValues(("testEnable", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pjTEnable.setStatus('current')
if mibBuilder.loadTexts: pjTEnable.setDescription('Determines whether the threshold test and associated traps for this measurement are enabled.')
pjTCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 7, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pjTCounter.setStatus('current')
if mibBuilder.loadTexts: pjTCounter.setDescription('Count of the number of times a threshold error has occurred for this measurement.')
pjTCounterDiscontinuity = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 7, 1, 5), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pjTCounterDiscontinuity.setStatus('current')
if mibBuilder.loadTexts: pjTCounterDiscontinuity.setDescription('Provides the last time at which there was a discontinuity in the counter object.')
pjTCounterReset = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 7, 1, 6), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pjTCounterReset.setStatus('current')
if mibBuilder.loadTexts: pjTCounterReset.setDescription("The counter object is reset to zero and the counter discontinuity object is set to the current time if 'true' is written to this object. When read, the value of this object is always 'false'.")
pjTLatestError = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 7, 1, 7), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pjTLatestError.setStatus('current')
if mibBuilder.loadTexts: pjTLatestError.setDescription('The timestamp at the most recent occurrence of a threshold error on this measurement.')
pjTActiveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 7, 1, 8), ActiveTime()).setUnits('second').setMaxAccess("readonly")
if mibBuilder.loadTexts: pjTActiveTime.setStatus('current')
if mibBuilder.loadTexts: pjTActiveTime.setDescription('The total time when it has been possible to perform this measurement')
pjTMeasurementState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 7, 1, 9), MeasurementState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pjTMeasurementState.setStatus('current')
if mibBuilder.loadTexts: pjTMeasurementState.setDescription('Specifies the validity of the measurement value')
pjTValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 18, 7, 1, 10), FloatingPoint()).setUnits('degree').setMaxAccess("readonly")
if mibBuilder.loadTexts: pjTValue.setStatus('current')
if mibBuilder.loadTexts: pjTValue.setDescription('The current Phase Jitter value in degrees.')
mipSyntaxTable = MibTable((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 20), )
if mibBuilder.loadTexts: mipSyntaxTable.setReference('TR 101 290 section 9.20')
if mibBuilder.loadTexts: mipSyntaxTable.setStatus('current')
if mibBuilder.loadTexts: mipSyntaxTable.setDescription('SFN MIP baseband tests')
mipSyntaxEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 20, 1), ).setIndexNames((0, "DVB-MGTR101290-MIB", "mipSyntaxTestNumber"), (0, "DVB-MGTR101290-MIB", "mipSyntaxInputNumber"))
if mibBuilder.loadTexts: mipSyntaxEntry.setStatus('current')
if mibBuilder.loadTexts: mipSyntaxEntry.setDescription('Row specification')
mipSyntaxInputNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 20, 1, 1), InputNumber())
if mibBuilder.loadTexts: mipSyntaxInputNumber.setStatus('current')
if mibBuilder.loadTexts: mipSyntaxInputNumber.setDescription('Transport Stream on which the measurement is made')
mipSyntaxTestNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 20, 1, 2), IndexMIPSyntaxTest())
if mibBuilder.loadTexts: mipSyntaxTestNumber.setStatus('current')
if mibBuilder.loadTexts: mipSyntaxTestNumber.setDescription('The specific SFN MIP test that this row applies to')
mipSyntaxState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 20, 1, 3), TestState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mipSyntaxState.setStatus('current')
if mibBuilder.loadTexts: mipSyntaxState.setDescription('This gives the overall pass/fail state of the test.')
mipSyntaxEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 20, 1, 4), Enable().clone(namedValues=NamedValues(("testEnable", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mipSyntaxEnable.setStatus('current')
if mibBuilder.loadTexts: mipSyntaxEnable.setDescription('Determines whether this test and the associated trap are enabled.')
mipSyntaxCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 20, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mipSyntaxCounter.setStatus('current')
if mibBuilder.loadTexts: mipSyntaxCounter.setDescription('Count of the number of times this error has occurred')
mipSyntaxCounterDiscontinuity = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 20, 1, 6), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mipSyntaxCounterDiscontinuity.setStatus('current')
if mibBuilder.loadTexts: mipSyntaxCounterDiscontinuity.setDescription('Provides the last time at which there was a discontinuity in the mipSyntaxCounter object.')
mipSyntaxCounterReset = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 20, 1, 7), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mipSyntaxCounterReset.setStatus('current')
if mibBuilder.loadTexts: mipSyntaxCounterReset.setDescription("The counter object is reset to zero and the counter discontinuity object is set to the current time if 'true' is written to this object. When read, the value of this object is always 'false'.")
mipSyntaxLatestError = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 20, 1, 8), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mipSyntaxLatestError.setStatus('current')
if mibBuilder.loadTexts: mipSyntaxLatestError.setDescription('The timestamp at the most recent occurrence of the error')
mipSyntaxActiveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 20, 1, 9), ActiveTime()).setUnits('second').setMaxAccess("readonly")
if mibBuilder.loadTexts: mipSyntaxActiveTime.setStatus('current')
if mibBuilder.loadTexts: mipSyntaxActiveTime.setDescription('The total time when it has been possible to perform this measurement')
systemErrorPerformance = MibIdentifier((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 21))
sepEtiTable = MibTable((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 21, 1), )
if mibBuilder.loadTexts: sepEtiTable.setReference('TR 101 290 section 9.21')
if mibBuilder.loadTexts: sepEtiTable.setStatus('current')
if mibBuilder.loadTexts: sepEtiTable.setDescription('Measurement of Errored Second Ratio (ESR) or Errored Time Interval Ratio (ETIR).')
sepEtiEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 21, 1, 1), ).setIndexNames((0, "DVB-MGTR101290-MIB", "sepEtiInputNumber"))
if mibBuilder.loadTexts: sepEtiEntry.setStatus('current')
if mibBuilder.loadTexts: sepEtiEntry.setDescription('Row specification')
sepEtiInputNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 21, 1, 1, 1), InputNumber())
if mibBuilder.loadTexts: sepEtiInputNumber.setStatus('current')
if mibBuilder.loadTexts: sepEtiInputNumber.setDescription('Transport Stream on which the measurement is made')
sepEtiTestState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 21, 1, 1, 2), TestState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sepEtiTestState.setStatus('current')
if mibBuilder.loadTexts: sepEtiTestState.setDescription("A 'fail' indicaties that the most recently completed time interval TI was an Errored Time Interval (ETI). A 'pass' indicates that the most recent TI was not errored.")
sepEtiEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 21, 1, 1, 3), Enable().clone(namedValues=NamedValues(("testEnable", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sepEtiEnable.setStatus('current')
if mibBuilder.loadTexts: sepEtiEnable.setDescription('Determines whether the threshold test and associated traps for this measurement are enabled.')
sepEtiCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 21, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sepEtiCounter.setStatus('current')
if mibBuilder.loadTexts: sepEtiCounter.setDescription('Count of the number of times an ETI has occurred.')
sepEtiCounterDiscontinuity = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 21, 1, 1, 5), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sepEtiCounterDiscontinuity.setStatus('current')
if mibBuilder.loadTexts: sepEtiCounterDiscontinuity.setDescription('Provides the last time at which there was a discontinuity in the counter object.')
sepEtiCounterReset = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 21, 1, 1, 6), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sepEtiCounterReset.setStatus('current')
if mibBuilder.loadTexts: sepEtiCounterReset.setDescription("The counter object is reset to zero and the counter discontinuity object is set to the current time if 'true' is written to this object. When read, the value of this object is always 'false'.")
sepEtiLatestError = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 21, 1, 1, 7), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sepEtiLatestError.setStatus('current')
if mibBuilder.loadTexts: sepEtiLatestError.setDescription('The timestamp at the most recent occurrence of an ETI.')
sepEtiActiveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 21, 1, 1, 8), ActiveTime()).setUnits('second').setMaxAccess("readonly")
if mibBuilder.loadTexts: sepEtiActiveTime.setStatus('current')
if mibBuilder.loadTexts: sepEtiActiveTime.setDescription('The total time when it has been possible to perform this measurement')
sepEtiMeasurementState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 21, 1, 1, 9), MeasurementState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sepEtiMeasurementState.setStatus('current')
if mibBuilder.loadTexts: sepEtiMeasurementState.setDescription('Specifies the validity of the measurement value')
sepEtiValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 21, 1, 1, 10), FloatingPoint()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sepEtiValue.setStatus('current')
if mibBuilder.loadTexts: sepEtiValue.setDescription('This is the Errored Time Interval Ratio (ETIR) for the most recently completed Measurement Interval (MI). It is expressed as a numeric value.')
sepSetiTable = MibTable((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 21, 2), )
if mibBuilder.loadTexts: sepSetiTable.setReference('TR 101 290 section 9.21')
if mibBuilder.loadTexts: sepSetiTable.setStatus('current')
if mibBuilder.loadTexts: sepSetiTable.setDescription('Measurement of Severly Errored Second Ratio (SESR) or Severely Errored Time Interval Ratio (SETIR).')
sepSetiEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 21, 2, 1), ).setIndexNames((0, "DVB-MGTR101290-MIB", "sepSetiInputNumber"))
if mibBuilder.loadTexts: sepSetiEntry.setStatus('current')
if mibBuilder.loadTexts: sepSetiEntry.setDescription('Row specification')
sepSetiInputNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 21, 2, 1, 1), InputNumber())
if mibBuilder.loadTexts: sepSetiInputNumber.setStatus('current')
if mibBuilder.loadTexts: sepSetiInputNumber.setDescription('Transport Stream on which the measurement is made')
sepSetiTestState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 21, 2, 1, 2), TestState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sepSetiTestState.setStatus('current')
if mibBuilder.loadTexts: sepSetiTestState.setDescription("A 'fail' indicaties that the most recently completed time interval TI was a Severely Errored Time Interval (SETI). A 'pass' indicates that the most recent TI was not severely errored.")
sepSetiEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 21, 2, 1, 3), Enable().clone(namedValues=NamedValues(("testEnable", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sepSetiEnable.setStatus('current')
if mibBuilder.loadTexts: sepSetiEnable.setDescription('Determines whether the threshold test and associated traps for this measurement are enabled.')
sepSetiCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 21, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sepSetiCounter.setStatus('current')
if mibBuilder.loadTexts: sepSetiCounter.setDescription('Count of the number of times an SETI has occurred.')
sepSetiCounterDiscontinuity = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 21, 2, 1, 5), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sepSetiCounterDiscontinuity.setStatus('current')
if mibBuilder.loadTexts: sepSetiCounterDiscontinuity.setDescription('Provides the last time at which there was a discontinuity in the counter object.')
sepSetiCounterReset = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 21, 2, 1, 6), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sepSetiCounterReset.setStatus('current')
if mibBuilder.loadTexts: sepSetiCounterReset.setDescription("The counter object is reset to zero and the counter discontinuity object is set to the current time if 'true' is written to this object. When read, the value of this object is always 'false'.")
sepSetiLatestError = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 21, 2, 1, 7), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sepSetiLatestError.setStatus('current')
if mibBuilder.loadTexts: sepSetiLatestError.setDescription('The timestamp at the most recent occurrence of a SETI.')
sepSetiActiveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 21, 2, 1, 8), ActiveTime()).setUnits('second').setMaxAccess("readonly")
if mibBuilder.loadTexts: sepSetiActiveTime.setStatus('current')
if mibBuilder.loadTexts: sepSetiActiveTime.setDescription('The total time when it has been possible to perform this measurement')
sepSetiMeasurementState = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 21, 2, 1, 9), MeasurementState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sepSetiMeasurementState.setStatus('current')
if mibBuilder.loadTexts: sepSetiMeasurementState.setDescription('Specifies the validity of the measurement value')
sepSetiValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 21, 2, 1, 10), FloatingPoint()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sepSetiValue.setStatus('current')
if mibBuilder.loadTexts: sepSetiValue.setDescription('This is the Severely Errored Time Interval Ratio (SETIR) for the most recently completed Measurement Interval (MI). It is expressed as a numeric value.')
terrestrialPreferencesTable = MibTable((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 100), )
if mibBuilder.loadTexts: terrestrialPreferencesTable.setStatus('current')
if mibBuilder.loadTexts: terrestrialPreferencesTable.setDescription('Table of terrestrial specific measurement preferences.')
terrestrialPreferencesEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 100, 1), ).setIndexNames((0, "DVB-MGTR101290-MIB", "terrestrialPrefInputNumber"))
if mibBuilder.loadTexts: terrestrialPreferencesEntry.setStatus('current')
if mibBuilder.loadTexts: terrestrialPreferencesEntry.setDescription('Row specification')
terrestrialPrefInputNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 100, 1, 1), InputNumber())
if mibBuilder.loadTexts: terrestrialPrefInputNumber.setStatus('current')
if mibBuilder.loadTexts: terrestrialPrefInputNumber.setDescription('Transport Stream input to which the preferences apply')
terrestrialPrefCentreFrequency = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 100, 1, 2), FloatingPoint()).setUnits('MHz').setMaxAccess("readwrite")
if mibBuilder.loadTexts: terrestrialPrefCentreFrequency.setStatus('current')
if mibBuilder.loadTexts: terrestrialPrefCentreFrequency.setDescription('This is the centre frequency to which the measuring equipment is tuned for making terrestrial measurements. This frequency is the actual input frequency to the measuring equipment, which may be at an intermediate frequency (IF) rather than the final RF.')
terrestrialPrefBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 100, 1, 3), FloatingPoint()).setUnits('MHz').setMaxAccess("readwrite")
if mibBuilder.loadTexts: terrestrialPrefBandwidth.setStatus('current')
if mibBuilder.loadTexts: terrestrialPrefBandwidth.setDescription('The instrument is set to expect a DVB-T transmission adapted for this bandwidth. Normal values will be 6.0MHz, 7.0MHz or 8.0MHz.')
terrestrialPrefModulation = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 100, 1, 4), Modulation()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: terrestrialPrefModulation.setReference('EN 300 744 section 4.3.5')
if mibBuilder.loadTexts: terrestrialPrefModulation.setStatus('current')
if mibBuilder.loadTexts: terrestrialPrefModulation.setDescription('This is the modulation which the measuring equipment expects to see and against which it makes modulation measurements. This applies to terrestrial measurements.')
terrestrialPrefTransmissionMode = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 100, 1, 5), TerrestrialTransmissionMode()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: terrestrialPrefTransmissionMode.setStatus('current')
if mibBuilder.loadTexts: terrestrialPrefTransmissionMode.setDescription('The instrument is set to expect a transmission in either 2k mode or 8k mode as set by this object.')
terrestrialPrefGuardInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 100, 1, 6), GuardInterval()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: terrestrialPrefGuardInterval.setStatus('current')
if mibBuilder.loadTexts: terrestrialPrefGuardInterval.setDescription('The instrument is set to expect a transmission using the guard interval specified by this object.')
terrestrialPrefHierarchical = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 100, 1, 7), Hierarchy()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: terrestrialPrefHierarchical.setStatus('current')
if mibBuilder.loadTexts: terrestrialPrefHierarchical.setDescription('The instrument is set according to the value of this object to expect a transmission which is either non-hierachical or hierarchical using the specified alpha value.')
terrestrialPrefCentreFreqExpected = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 100, 1, 8), FloatingPoint()).setUnits('Hz').setMaxAccess("readwrite")
if mibBuilder.loadTexts: terrestrialPrefCentreFreqExpected.setReference('TR 101 290 section 9.1.1')
if mibBuilder.loadTexts: terrestrialPrefCentreFreqExpected.setStatus('current')
if mibBuilder.loadTexts: terrestrialPrefCentreFreqExpected.setDescription('This is the expected value for the centre frequency as measured by rfAccuracyValue.')
terrestrialPrefCentreFreqLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 100, 1, 9), FloatingPoint()).setUnits('Hz').setMaxAccess("readwrite")
if mibBuilder.loadTexts: terrestrialPrefCentreFreqLimit.setReference('TR 101 290 section 9.1.1')
if mibBuilder.loadTexts: terrestrialPrefCentreFreqLimit.setStatus('current')
if mibBuilder.loadTexts: terrestrialPrefCentreFreqLimit.setDescription('This is the permitted deviation for the centre frequency as measured by rfAccuracyValue. If rfAccuracyValue is outside the range: [terrestrialPrefCentreFreqExpected - terrestrialPrefCentreFreqLimit .. terrestrialPrefCentreFreqExpected + terrestrialPrefCentreFreqLimit] an error will be indicated.')
terrestrialPrefChannelWidthLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 100, 1, 10), FloatingPoint()).setUnits('Hz').setMaxAccess("readwrite")
if mibBuilder.loadTexts: terrestrialPrefChannelWidthLimit.setReference('TR 101 290 section 9.1.2')
if mibBuilder.loadTexts: terrestrialPrefChannelWidthLimit.setStatus('current')
if mibBuilder.loadTexts: terrestrialPrefChannelWidthLimit.setDescription('This is the permitted deviation for the channel width as measured by rfChannelWidthValue. The nominal value of the channel width has a fixed value which depends on the bandwidth (as set by terrestrialPrefBandwidth). If rfChannelWidthValue is outside the range [nominalWidth - terrestrialPrefChannelWidthLimit .. nominalWidth + terrestrialPrefChannelWidthLimit] an error will be indicated.')
terrestrialPrefSymbolLengthLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 100, 1, 11), FloatingPoint()).setUnits('s').setMaxAccess("readwrite")
if mibBuilder.loadTexts: terrestrialPrefSymbolLengthLimit.setReference('TR 101 290 section 9.1.3 EN 300 744 section 4.4 and Annex E')
if mibBuilder.loadTexts: terrestrialPrefSymbolLengthLimit.setStatus('current')
if mibBuilder.loadTexts: terrestrialPrefSymbolLengthLimit.setDescription('This is the permitted deviation for the symbol length as measured by symbolLengthValue. The nominal value of the symbol length has a fixed value which depends on the bandwidth, the mode and the guard interval (as set by terrestrialPrefBandwidth, terrestrialPrefTransmissionMode and terrestrialPrefGuardInterval respectively). If symbolLengthValue is outside the range [nominalLength - terrestrialPrefSymbolLengthLimit .. nominalLength + terrestrialPrefSymbolLengthLimit] an error will be indicated.')
terrestrialPrefPowerMin = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 100, 1, 12), FloatingPoint()).setUnits('dBm').setMaxAccess("readwrite")
if mibBuilder.loadTexts: terrestrialPrefPowerMin.setReference('TR 101 290 section 9.5')
if mibBuilder.loadTexts: terrestrialPrefPowerMin.setStatus('current')
if mibBuilder.loadTexts: terrestrialPrefPowerMin.setDescription('If the power measured by rfIfPowerValue is less than this value, the associated test fails.')
terrestrialPrefPowerMax = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 100, 1, 13), FloatingPoint()).setUnits('dBm').setMaxAccess("readwrite")
if mibBuilder.loadTexts: terrestrialPrefPowerMax.setReference('TR 101 290 section 9.5')
if mibBuilder.loadTexts: terrestrialPrefPowerMax.setStatus('current')
if mibBuilder.loadTexts: terrestrialPrefPowerMax.setDescription('If the power measured by rfIfPowerValue is greater than this value, the associated test fails.')
terrestrialPrefENDBER = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 100, 1, 14), FloatingPoint().clone('2E-04')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: terrestrialPrefENDBER.setReference('TR 101 290 section 9.9')
if mibBuilder.loadTexts: terrestrialPrefENDBER.setStatus('current')
if mibBuilder.loadTexts: terrestrialPrefENDBER.setDescription('BER value which is to be used for the END and ENF measurements.')
terrestrialPrefENDIdeal = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 100, 1, 15), FloatingPoint()).setUnits('dB').setMaxAccess("readwrite")
if mibBuilder.loadTexts: terrestrialPrefENDIdeal.setReference('TR 101 290 section 9.9')
if mibBuilder.loadTexts: terrestrialPrefENDIdeal.setStatus('current')
if mibBuilder.loadTexts: terrestrialPrefENDIdeal.setDescription("This is the 'ideal' value of C/N for measurement of END on the whole or high priority stream. It is used in the measurement of eNDTValue.")
terrestrialPrefENDMax = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 100, 1, 16), FloatingPoint()).setUnits('dB').setMaxAccess("readwrite")
if mibBuilder.loadTexts: terrestrialPrefENDMax.setReference('TR 101 290 section 9.9')
if mibBuilder.loadTexts: terrestrialPrefENDMax.setStatus('current')
if mibBuilder.loadTexts: terrestrialPrefENDMax.setDescription('If the measured value of eNDTValue exceeds this, the associated test fails.')
terrestrialPrefENFIdeal = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 100, 1, 17), FloatingPoint()).setUnits('dB').setMaxAccess("readwrite")
if mibBuilder.loadTexts: terrestrialPrefENFIdeal.setReference('TR 101 290 section 9.9.1')
if mibBuilder.loadTexts: terrestrialPrefENFIdeal.setStatus('current')
if mibBuilder.loadTexts: terrestrialPrefENFIdeal.setDescription("This is the 'ideal' value of C/N for measurement of ENF on the whole or high priority stream. It is used in the measurement of eNFTValue.")
terrestrialPrefENFMax = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 100, 1, 18), FloatingPoint()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: terrestrialPrefENFMax.setReference('TR 101 290 section 9.9.1')
if mibBuilder.loadTexts: terrestrialPrefENFMax.setStatus('current')
if mibBuilder.loadTexts: terrestrialPrefENFMax.setDescription('If the measured value of eNFTValue is exceeds this value, the associated test fails.')
terrestrialPrefENDLPIdeal = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 100, 1, 19), FloatingPoint()).setUnits('dB').setMaxAccess("readwrite")
if mibBuilder.loadTexts: terrestrialPrefENDLPIdeal.setReference('TR 101 290 section 9.9')
if mibBuilder.loadTexts: terrestrialPrefENDLPIdeal.setStatus('current')
if mibBuilder.loadTexts: terrestrialPrefENDLPIdeal.setDescription("This is the 'ideal' value of C/N for measurement of END on the low priority stream. It is used in the measurement of eNDTLPValue.")
terrestrialPrefENDLPMax = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 100, 1, 20), FloatingPoint()).setUnits('dB').setMaxAccess("readwrite")
if mibBuilder.loadTexts: terrestrialPrefENDLPMax.setReference('TR 101 290 section 9.9')
if mibBuilder.loadTexts: terrestrialPrefENDLPMax.setStatus('current')
if mibBuilder.loadTexts: terrestrialPrefENDLPMax.setDescription('If the measured value of eNDTLPValue exceeds this, the associated test fails.')
terrestrialPrefENFLPIdeal = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 100, 1, 21), FloatingPoint()).setUnits('dB').setMaxAccess("readwrite")
if mibBuilder.loadTexts: terrestrialPrefENFLPIdeal.setReference('TR 101 290 section 9.9.1')
if mibBuilder.loadTexts: terrestrialPrefENFLPIdeal.setStatus('current')
if mibBuilder.loadTexts: terrestrialPrefENFLPIdeal.setDescription("This is the 'ideal' value of C/N for measurement of ENF on the low priority stream. It is used in the measurement of eNFTLPValue.")
terrestrialPrefENFLPMax = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 100, 1, 22), FloatingPoint()).setUnits('dB').setMaxAccess("readwrite")
if mibBuilder.loadTexts: terrestrialPrefENFLPMax.setReference('TR 101 290 section 9.9.1')
if mibBuilder.loadTexts: terrestrialPrefENFLPMax.setStatus('current')
if mibBuilder.loadTexts: terrestrialPrefENFLPMax.setDescription('If the measured value of eNFTLPValue exeeds this value, the associated test fails.')
terrestrialPrefLinearityMin = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 100, 1, 23), FloatingPoint()).setUnits('dB').setMaxAccess("readwrite")
if mibBuilder.loadTexts: terrestrialPrefLinearityMin.setReference('TR 101 290 section 9.10')
if mibBuilder.loadTexts: terrestrialPrefLinearityMin.setStatus('current')
if mibBuilder.loadTexts: terrestrialPrefLinearityMin.setDescription('If the shoulder attenuation as measured by linearityValue is less than this value, an error is indicated.')
terrestrialPrefBERViterbiMax = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 100, 1, 24), FloatingPoint()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: terrestrialPrefBERViterbiMax.setReference('TR 101 290 section 9.15')
if mibBuilder.loadTexts: terrestrialPrefBERViterbiMax.setStatus('current')
if mibBuilder.loadTexts: terrestrialPrefBERViterbiMax.setDescription('If the BER measured by berViterbiTValue exceeds this value, an error is indicated.')
terrestrialPrefBERViterbiLPMax = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 100, 1, 25), FloatingPoint()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: terrestrialPrefBERViterbiLPMax.setReference('TR 101 290 section 9.15')
if mibBuilder.loadTexts: terrestrialPrefBERViterbiLPMax.setStatus('current')
if mibBuilder.loadTexts: terrestrialPrefBERViterbiLPMax.setDescription('If the BER measured by berViterbiTLPValue exceeds this value, an error is indicated.')
terrestrialPrefBERRSMax = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 100, 1, 26), FloatingPoint()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: terrestrialPrefBERRSMax.setReference('TR 101 290 section 9.16')
if mibBuilder.loadTexts: terrestrialPrefBERRSMax.setStatus('current')
if mibBuilder.loadTexts: terrestrialPrefBERRSMax.setDescription('If the BER measured by berRSValue exceeds this value, an error is indicated.')
terrestrialPrefBERRSLPMax = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 100, 1, 27), FloatingPoint()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: terrestrialPrefBERRSLPMax.setReference('TR 101 290 section 9.16')
if mibBuilder.loadTexts: terrestrialPrefBERRSLPMax.setStatus('current')
if mibBuilder.loadTexts: terrestrialPrefBERRSLPMax.setDescription('If the BER measured by berRSLPValue exceeds this value, an error is indicated.')
terrestrialPrefMerTMin = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 100, 1, 28), FloatingPoint()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: terrestrialPrefMerTMin.setReference('TR 101 290 section 9.18.2')
if mibBuilder.loadTexts: terrestrialPrefMerTMin.setStatus('current')
if mibBuilder.loadTexts: terrestrialPrefMerTMin.setDescription('If merTValue is less than this value, the associated test fails.')
terrestrialPrefSteMeanMax = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 100, 1, 29), FloatingPoint()).setUnits('dB').setMaxAccess("readwrite")
if mibBuilder.loadTexts: terrestrialPrefSteMeanMax.setReference('TR 101 290 section 9.18.3')
if mibBuilder.loadTexts: terrestrialPrefSteMeanMax.setStatus('current')
if mibBuilder.loadTexts: terrestrialPrefSteMeanMax.setDescription('If steMeanTValue exceeds this value, the associated test fails.')
terrestrialPrefSteDeviationMax = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 100, 1, 30), FloatingPoint()).setUnits('dB').setMaxAccess("readwrite")
if mibBuilder.loadTexts: terrestrialPrefSteDeviationMax.setReference('TR 101 290 section 9.18.3')
if mibBuilder.loadTexts: terrestrialPrefSteDeviationMax.setStatus('current')
if mibBuilder.loadTexts: terrestrialPrefSteDeviationMax.setDescription('If steDeviationTValue exceeds this value, the associated test fails.')
terrestrialPrefCsMin = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 100, 1, 31), FloatingPoint()).setUnits('dB').setMaxAccess("readwrite")
if mibBuilder.loadTexts: terrestrialPrefCsMin.setReference('TR 101 290 section 9.18.4')
if mibBuilder.loadTexts: terrestrialPrefCsMin.setStatus('current')
if mibBuilder.loadTexts: terrestrialPrefCsMin.setDescription('If csTValue is less than this value, the associated test fails')
terrestrialPrefAiMax = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 100, 1, 32), FloatingPoint()).setUnits('dB').setMaxAccess("readwrite")
if mibBuilder.loadTexts: terrestrialPrefAiMax.setReference('TR 101 290 section 9.18.5')
if mibBuilder.loadTexts: terrestrialPrefAiMax.setStatus('current')
if mibBuilder.loadTexts: terrestrialPrefAiMax.setDescription('If aiTValue exceeds this value, the associated test fails.')
terrestrialPrefQeMax = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 100, 1, 33), FloatingPoint()).setUnits('dB').setMaxAccess("readwrite")
if mibBuilder.loadTexts: terrestrialPrefQeMax.setReference('TR 101 290 section 9.18.6')
if mibBuilder.loadTexts: terrestrialPrefQeMax.setStatus('current')
if mibBuilder.loadTexts: terrestrialPrefQeMax.setDescription('If qeTValue exceeds this value, the associated test fails.')
terrestrialPrefPjMax = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 100, 1, 34), FloatingPoint()).setUnits('dB').setMaxAccess("readwrite")
if mibBuilder.loadTexts: terrestrialPrefPjMax.setReference('TR 101 290 section 9.18.7')
if mibBuilder.loadTexts: terrestrialPrefPjMax.setStatus('current')
if mibBuilder.loadTexts: terrestrialPrefPjMax.setDescription('If pjTValue exceeds this value, the associated test fails.')
terrestrialPrefMIPTimingLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 100, 1, 35), FloatingPoint()).setUnits('second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: terrestrialPrefMIPTimingLimit.setReference('TR 101 290 section 9.20.1')
if mibBuilder.loadTexts: terrestrialPrefMIPTimingLimit.setStatus('current')
if mibBuilder.loadTexts: terrestrialPrefMIPTimingLimit.setDescription('This preference affects the MIP_timing_error test. If the calculated value of nT differs from an integral number of seconds by more than terrestrialPrefMIPTimingLimit then an error is indicated.')
terrestrialPrefMIPDeviationMax = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 100, 1, 36), FloatingPoint()).setUnits('bit/s').setMaxAccess("readwrite")
if mibBuilder.loadTexts: terrestrialPrefMIPDeviationMax.setReference('TR 101 290 section 9.20.6')
if mibBuilder.loadTexts: terrestrialPrefMIPDeviationMax.setStatus('current')
if mibBuilder.loadTexts: terrestrialPrefMIPDeviationMax.setDescription('This preference affects the MIP_ts_rate_error test. It is the value of Max_deviation in the inequality given in TR 101 290 as the condition for an error indication.')
terrestrialPrefSEPUATMode = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 100, 1, 37), UATMode()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: terrestrialPrefSEPUATMode.setReference('TR 101 290 section 9.21')
if mibBuilder.loadTexts: terrestrialPrefSEPUATMode.setStatus('current')
if mibBuilder.loadTexts: terrestrialPrefSEPUATMode.setDescription("Determines whether the 'N consecutive' or 'rolling window' mode of determining the start of a period of Unavailable Time (UAT) is used. If the 'N consecutive' mode is selected, the 'M' and 'T' preference parameters are ignored. Likewise, if the 'rolling window' mode is selected, the 'N' preference parameter is ignored.")
terrestrialPrefSEPN = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 100, 1, 38), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: terrestrialPrefSEPN.setReference('TR 101 290 section 9.21')
if mibBuilder.loadTexts: terrestrialPrefSEPN.setStatus('current')
if mibBuilder.loadTexts: terrestrialPrefSEPN.setDescription('The N value used to identify the start and end of a period of unavailable time (UAT).')
terrestrialPrefSEPT = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 100, 1, 39), FloatingPoint()).setUnits('second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: terrestrialPrefSEPT.setReference('TR 101 290 section 9.21')
if mibBuilder.loadTexts: terrestrialPrefSEPT.setStatus('current')
if mibBuilder.loadTexts: terrestrialPrefSEPT.setDescription('The T value used to identify the start and end of a period of unavailable time (UAT).')
terrestrialPrefSEPM = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 100, 1, 40), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: terrestrialPrefSEPM.setReference('TR 101 290 section 9.21')
if mibBuilder.loadTexts: terrestrialPrefSEPM.setStatus('current')
if mibBuilder.loadTexts: terrestrialPrefSEPM.setDescription('The M value used to identify the start and end of a period of unavailable time (UAT).')
terrestrialPrefSEPTI = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 100, 1, 41), FloatingPoint()).setUnits('second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: terrestrialPrefSEPTI.setReference('TR 101 290 section 9.21')
if mibBuilder.loadTexts: terrestrialPrefSEPTI.setStatus('current')
if mibBuilder.loadTexts: terrestrialPrefSEPTI.setDescription('Each Time Interval of this length is assessed as to whether it is an Errored Time Interval or a Severely Errored Time Interval.')
terrestrialPrefSEPEBPerCent = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 100, 1, 42), FloatingPoint()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: terrestrialPrefSEPEBPerCent.setReference('TR 101 290 section 9.21')
if mibBuilder.loadTexts: terrestrialPrefSEPEBPerCent.setStatus('current')
if mibBuilder.loadTexts: terrestrialPrefSEPEBPerCent.setDescription("If more than this percentage of blocks within a Time Interval is an Errored Block, the Time Interval is a Severely Errored Time Interval (SETI). Example values are: '1.53', '10', '0.33'.")
terrestrialPrefSEPMeasurementInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 2696, 3, 2, 1, 9, 100, 1, 43), FloatingPoint()).setUnits('second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: terrestrialPrefSEPMeasurementInterval.setReference('TR 101 290 section 6.1')
if mibBuilder.loadTexts: terrestrialPrefSEPMeasurementInterval.setStatus('current')
if mibBuilder.loadTexts: terrestrialPrefSEPMeasurementInterval.setDescription('The Measurement Interval (MI) over which the ESR/ETIR and SESR/SETIR are calculated.')
tr101290Conformance = MibIdentifier((1, 3, 6, 1, 4, 1, 2696, 3, 2, 3))
tr101290Compliances = MibIdentifier((1, 3, 6, 1, 4, 1, 2696, 3, 2, 3, 1))
complianceTransportStream = ModuleCompliance((1, 3, 6, 1, 4, 1, 2696, 3, 2, 3, 1, 1)).setObjects(("DVB-MGTR101290-MIB", "groupControl"), ("DVB-MGTR101290-MIB", "groupCapability"), ("DVB-MGTR101290-MIB", "groupTransportStream"), ("DVB-MGTR101290-MIB", "groupTrapControl"), ("DVB-MGTR101290-MIB", "groupTraps"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    complianceTransportStream = complianceTransportStream.setStatus('current')
if mibBuilder.loadTexts: complianceTransportStream.setDescription('Compliance for Transport Stream monitor devices')
complianceCable = ModuleCompliance((1, 3, 6, 1, 4, 1, 2696, 3, 2, 3, 1, 2)).setObjects(("DVB-MGTR101290-MIB", "groupControl"), ("DVB-MGTR101290-MIB", "groupTrapControl"), ("DVB-MGTR101290-MIB", "groupTraps"), ("DVB-MGTR101290-MIB", "groupCapability"), ("DVB-MGTR101290-MIB", "groupCable"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    complianceCable = complianceCable.setStatus('current')
if mibBuilder.loadTexts: complianceCable.setDescription('Compliance for Cable RF measurement devices')
complianceSatellite = ModuleCompliance((1, 3, 6, 1, 4, 1, 2696, 3, 2, 3, 1, 3)).setObjects(("DVB-MGTR101290-MIB", "groupControl"), ("DVB-MGTR101290-MIB", "groupTrapControl"), ("DVB-MGTR101290-MIB", "groupTraps"), ("DVB-MGTR101290-MIB", "groupCapability"), ("DVB-MGTR101290-MIB", "groupSatellite"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    complianceSatellite = complianceSatellite.setStatus('current')
if mibBuilder.loadTexts: complianceSatellite.setDescription('Compliance for Satellite RF measurement devices')
complianceTerrestrial = ModuleCompliance((1, 3, 6, 1, 4, 1, 2696, 3, 2, 3, 1, 4)).setObjects(("DVB-MGTR101290-MIB", "groupControl"), ("DVB-MGTR101290-MIB", "groupTrapControl"), ("DVB-MGTR101290-MIB", "groupTraps"), ("DVB-MGTR101290-MIB", "groupCapability"), ("DVB-MGTR101290-MIB", "groupTerrestrial"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    complianceTerrestrial = complianceTerrestrial.setStatus('current')
if mibBuilder.loadTexts: complianceTerrestrial.setDescription('Compliance for Terrestrial RF measurement devices')
tr101290ObjectGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 2696, 3, 2, 3, 2))
groupControl = ObjectGroup((1, 3, 6, 1, 4, 1, 2696, 3, 2, 3, 2, 1)).setObjects(("DVB-MGTR101290-MIB", "controlNow"), ("DVB-MGTR101290-MIB", "controlEventPersistence"), ("DVB-MGTR101290-MIB", "rfSystemDelivery"), ("DVB-MGTR101290-MIB", "controlSynchronizedTime"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    groupControl = groupControl.setStatus('current')
if mibBuilder.loadTexts: groupControl.setDescription('Contains all the objects from the tr101290Control branch of the MIB')
groupTrapControl = ObjectGroup((1, 3, 6, 1, 4, 1, 2696, 3, 2, 3, 2, 2)).setObjects(("DVB-MGTR101290-MIB", "trapControlOID"), ("DVB-MGTR101290-MIB", "trapControlGenerationTime"), ("DVB-MGTR101290-MIB", "trapControlMeasurementValue"), ("DVB-MGTR101290-MIB", "trapControlRateStatus"), ("DVB-MGTR101290-MIB", "trapControlPeriod"), ("DVB-MGTR101290-MIB", "trapControlFailureSummary"), ("DVB-MGTR101290-MIB", "trapInput"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    groupTrapControl = groupTrapControl.setStatus('current')
if mibBuilder.loadTexts: groupTrapControl.setDescription('Contains all the normal objects from the tr101290Trap branch of the MIB')
groupTraps = NotificationGroup((1, 3, 6, 1, 4, 1, 2696, 3, 2, 3, 2, 3)).setObjects(("DVB-MGTR101290-MIB", "testFailTrap"), ("DVB-MGTR101290-MIB", "measurementFailTrap"), ("DVB-MGTR101290-MIB", "measurementUnknownTrap"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    groupTraps = groupTraps.setStatus('current')
if mibBuilder.loadTexts: groupTraps.setDescription('Contains all the traps/notifications from the MIB.')
groupCapability = ObjectGroup((1, 3, 6, 1, 4, 1, 2696, 3, 2, 3, 2, 4)).setObjects(("DVB-MGTR101290-MIB", "capabilityMIBRevision"), ("DVB-MGTR101290-MIB", "capabilityTSGroup"), ("DVB-MGTR101290-MIB", "capabilityTSAvailability"), ("DVB-MGTR101290-MIB", "capabilityTSPollInterval"), ("DVB-MGTR101290-MIB", "capabilityCableSatGroup"), ("DVB-MGTR101290-MIB", "capabilityCableSatAvailability"), ("DVB-MGTR101290-MIB", "capabilityCableSatPollInterval"), ("DVB-MGTR101290-MIB", "capabilityCableGroup"), ("DVB-MGTR101290-MIB", "capabilityCableAvailability"), ("DVB-MGTR101290-MIB", "capabilityCablePollInterval"), ("DVB-MGTR101290-MIB", "capabilitySatelliteGroup"), ("DVB-MGTR101290-MIB", "capabilitySatelliteAvailability"), ("DVB-MGTR101290-MIB", "capabilitySatellitePollInterval"), ("DVB-MGTR101290-MIB", "capabilityTerrestrialGroup"), ("DVB-MGTR101290-MIB", "capabilityTerrestrialAvailability"), ("DVB-MGTR101290-MIB", "capabilityTerrestrialPollInterval"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    groupCapability = groupCapability.setStatus('current')
if mibBuilder.loadTexts: groupCapability.setDescription('Contains all objects from the tr101290Capability branch of the MIB')
groupTransportStream = ObjectGroup((1, 3, 6, 1, 4, 1, 2696, 3, 2, 3, 2, 5)).setObjects(("DVB-MGTR101290-MIB", "tsTestsSummaryState"), ("DVB-MGTR101290-MIB", "tsTestsSummaryEnable"), ("DVB-MGTR101290-MIB", "tsTestsSummaryCounter"), ("DVB-MGTR101290-MIB", "tsTestsSummaryCounterDiscontinuity"), ("DVB-MGTR101290-MIB", "tsTestsSummaryCounterReset"), ("DVB-MGTR101290-MIB", "tsTestsSummaryLatestError"), ("DVB-MGTR101290-MIB", "tsTestsSummaryActiveTime"), ("DVB-MGTR101290-MIB", "tsTestsPIDRowStatus"), ("DVB-MGTR101290-MIB", "tsTestsPIDState"), ("DVB-MGTR101290-MIB", "tsTestsPIDEnable"), ("DVB-MGTR101290-MIB", "tsTestsPIDCounter"), ("DVB-MGTR101290-MIB", "tsTestsPIDCounterDiscontinuity"), ("DVB-MGTR101290-MIB", "tsTestsPIDCounterReset"), ("DVB-MGTR101290-MIB", "tsTestsPIDLatestError"), ("DVB-MGTR101290-MIB", "tsTestsPIDActiveTime"), ("DVB-MGTR101290-MIB", "tsTestsPrefTransitionDuration"), ("DVB-MGTR101290-MIB", "tsTestsPrefPATSectionIntervalMax"), ("DVB-MGTR101290-MIB", "tsTestsPrefPMTSectionIntervalMax"), ("DVB-MGTR101290-MIB", "tsTestsPrefReferredIntervalMax"), ("DVB-MGTR101290-MIB", "tsTestsPrefPCRIntervalMax"), ("DVB-MGTR101290-MIB", "tsTestsPrefPCRDiscontinuityMax"), ("DVB-MGTR101290-MIB", "tsTestsPrefPCRInaccuracyMax"), ("DVB-MGTR101290-MIB", "tsTestsPrefPTSIntervalMax"), ("DVB-MGTR101290-MIB", "tsTestsPrefNITActualIntervalMax"), ("DVB-MGTR101290-MIB", "tsTestsPrefNITActualIntervalMin"), ("DVB-MGTR101290-MIB", "tsTestsPrefNITOtherIntervalMax"), ("DVB-MGTR101290-MIB", "tsTestsPrefSIGapMin"), ("DVB-MGTR101290-MIB", "tsTestsPrefNITTableIntervalMax"), ("DVB-MGTR101290-MIB", "tsTestsPrefBATTableIntervalMax"), ("DVB-MGTR101290-MIB", "tsTestsPrefSDTActualTableIntervalMax"), ("DVB-MGTR101290-MIB", "tsTestsPrefSDTOtherTableIntervalMax"), ("DVB-MGTR101290-MIB", "tsTestsPrefEITPFActualTableIntervalMax"), ("DVB-MGTR101290-MIB", "tsTestsPrefEITPFOtherTableIntervalMax"), ("DVB-MGTR101290-MIB", "tsTestsPrefEITSActualNearTableIntervalMax"), ("DVB-MGTR101290-MIB", "tsTestsPrefEITSActualFarTableIntervalMax"), ("DVB-MGTR101290-MIB", "tsTestsPrefEITSOtherNearTableIntervalMax"), ("DVB-MGTR101290-MIB", "tsTestsPrefEITSOtherFarTableIntervalMax"), ("DVB-MGTR101290-MIB", "tsTestsPrefTxTTableIntervalMax"), ("DVB-MGTR101290-MIB", "tsTestsPrefSDTActualIntervalMax"), ("DVB-MGTR101290-MIB", "tsTestsPrefSDTActualIntervalMin"), ("DVB-MGTR101290-MIB", "tsTestsPrefSDTOtherIntervalMax"), ("DVB-MGTR101290-MIB", "tsTestsPrefEITActualIntervalMax"), ("DVB-MGTR101290-MIB", "tsTestsPrefEITActualIntervalMin"), ("DVB-MGTR101290-MIB", "tsTestsPrefEITOtherIntervalMax"), ("DVB-MGTR101290-MIB", "tsTestsPrefRSTIntervalMin"), ("DVB-MGTR101290-MIB", "tsTestsPrefTDTIntervalMax"), ("DVB-MGTR101290-MIB", "tsTestsPrefTDTIntervalMin"), ("DVB-MGTR101290-MIB", "tsTestsPrefPIDRowStatus"), ("DVB-MGTR101290-MIB", "tsTestsPrefPIDReferredIntervalMax"), ("DVB-MGTR101290-MIB", "tsPcrMeasurementRowStatus"), ("DVB-MGTR101290-MIB", "tsPcrMeasurementState"), ("DVB-MGTR101290-MIB", "tsPcrMeasurementEnable"), ("DVB-MGTR101290-MIB", "tsPcrMeasurementCounter"), ("DVB-MGTR101290-MIB", "tsPcrMeasurementCounterDiscontinuity"), ("DVB-MGTR101290-MIB", "tsPcrMeasurementCounterReset"), ("DVB-MGTR101290-MIB", "tsPcrMeasurementLatestError"), ("DVB-MGTR101290-MIB", "tsPcrMeasurementActiveTime"), ("DVB-MGTR101290-MIB", "tsPcrMeasurementMeasurementState"), ("DVB-MGTR101290-MIB", "tsPcrMeasurementValue"), ("DVB-MGTR101290-MIB", "tsTransportStreamBitRateState"), ("DVB-MGTR101290-MIB", "tsTransportStreamBitRateEnable"), ("DVB-MGTR101290-MIB", "tsTransportStreamBitRateCounter"), ("DVB-MGTR101290-MIB", "tsTransportStreamBitRateCounterDiscontinuity"), ("DVB-MGTR101290-MIB", "tsTransportStreamBitRateCounterReset"), ("DVB-MGTR101290-MIB", "tsTransportStreamBitRateLatestError"), ("DVB-MGTR101290-MIB", "tsTransportStreamBitRateActiveTime"), ("DVB-MGTR101290-MIB", "tsTransportStreamBitRateMeasurementState"), ("DVB-MGTR101290-MIB", "tsTransportStreamBitRateValue"), ("DVB-MGTR101290-MIB", "tsTransportStreamBitRateNomenclature"), ("DVB-MGTR101290-MIB", "tsServiceBitRateRowStatus"), ("DVB-MGTR101290-MIB", "tsServiceBitRateState"), ("DVB-MGTR101290-MIB", "tsServiceBitRateEnable"), ("DVB-MGTR101290-MIB", "tsServiceBitRateCounter"), ("DVB-MGTR101290-MIB", "tsServiceBitRateCounterDiscontinuity"), ("DVB-MGTR101290-MIB", "tsServiceBitRateCounterReset"), ("DVB-MGTR101290-MIB", "tsServiceBitRateLatestError"), ("DVB-MGTR101290-MIB", "tsServiceBitRateActiveTime"), ("DVB-MGTR101290-MIB", "tsServiceBitRateMeasurementState"), ("DVB-MGTR101290-MIB", "tsServiceBitRateValue"), ("DVB-MGTR101290-MIB", "tsServiceBitRateNomenclature"), ("DVB-MGTR101290-MIB", "tsPIDBitRateRowStatus"), ("DVB-MGTR101290-MIB", "tsPIDBitRateState"), ("DVB-MGTR101290-MIB", "tsPIDBitRateEnable"), ("DVB-MGTR101290-MIB", "tsPIDBitRateCounter"), ("DVB-MGTR101290-MIB", "tsPIDBitRateCounterDiscontinuity"), ("DVB-MGTR101290-MIB", "tsPIDBitRateCounterReset"), ("DVB-MGTR101290-MIB", "tsPIDBitRateLatestError"), ("DVB-MGTR101290-MIB", "tsPIDBitRateActiveTime"), ("DVB-MGTR101290-MIB", "tsPIDBitRateMeasurementState"), ("DVB-MGTR101290-MIB", "tsPIDBitRateValue"), ("DVB-MGTR101290-MIB", "tsPIDBitRateNomenclature"), ("DVB-MGTR101290-MIB", "tsConsistencyState"), ("DVB-MGTR101290-MIB", "tsConsistencyEnable"), ("DVB-MGTR101290-MIB", "tsConsistencyCounter"), ("DVB-MGTR101290-MIB", "tsConsistencyCounterDiscontinuity"), ("DVB-MGTR101290-MIB", "tsConsistencyCounterReset"), ("DVB-MGTR101290-MIB", "tsConsistencyLatestError"), ("DVB-MGTR101290-MIB", "tsConsistencyActiveTime"), ("DVB-MGTR101290-MIB", "tsMeasurePrefPCRDemarcationFrequency"), ("DVB-MGTR101290-MIB", "tsMeasurePrefPCRFOMax"), ("DVB-MGTR101290-MIB", "tsMeasurePrefPCRDRMax"), ("DVB-MGTR101290-MIB", "tsMeasurePrefPCROJMax"), ("DVB-MGTR101290-MIB", "tsMeasurePrefTSBitRateTau"), ("DVB-MGTR101290-MIB", "tsMeasurePrefTSBitRateN"), ("DVB-MGTR101290-MIB", "tsMeasurePrefTSBitRateElement"), ("DVB-MGTR101290-MIB", "tsMeasurePrefTSBitRateMin"), ("DVB-MGTR101290-MIB", "tsMeasurePrefTSBitRateMax"), ("DVB-MGTR101290-MIB", "tsMeasurePrefAllServiceBitRateTau"), ("DVB-MGTR101290-MIB", "tsMeasurePrefAllServiceBitRateN"), ("DVB-MGTR101290-MIB", "tsMeasurePrefAllServiceBitRateElement"), ("DVB-MGTR101290-MIB", "tsMeasurePrefAllPIDBitRateTau"), ("DVB-MGTR101290-MIB", "tsMeasurePrefAllPIDBitRateN"), ("DVB-MGTR101290-MIB", "tsMeasurePrefAllPIDBitRateElement"), ("DVB-MGTR101290-MIB", "tsMeasurePrefExpectedTSID"), ("DVB-MGTR101290-MIB", "tsMeasurePrefServiceRowStatus"), ("DVB-MGTR101290-MIB", "tsMeasurePrefServiceBitRateTau"), ("DVB-MGTR101290-MIB", "tsMeasurePrefServiceBitRateN"), ("DVB-MGTR101290-MIB", "tsMeasurePrefServiceBitRateElement"), ("DVB-MGTR101290-MIB", "tsMeasurePrefServiceBitRateMin"), ("DVB-MGTR101290-MIB", "tsMeasurePrefServiceBitRateMax"), ("DVB-MGTR101290-MIB", "tsMeasurePrefPIDRowStatus"), ("DVB-MGTR101290-MIB", "tsMeasurePrefPIDBitRateTau"), ("DVB-MGTR101290-MIB", "tsMeasurePrefPIDBitRateN"), ("DVB-MGTR101290-MIB", "tsMeasurePrefPIDBitRateElement"), ("DVB-MGTR101290-MIB", "tsMeasurePrefPIDBitRateMin"), ("DVB-MGTR101290-MIB", "tsMeasurePrefPIDBitRateMax"), ("DVB-MGTR101290-MIB", "tsServicePerformanceState"), ("DVB-MGTR101290-MIB", "tsServicePerformanceEnable"), ("DVB-MGTR101290-MIB", "tsServicePerformanceCounter"), ("DVB-MGTR101290-MIB", "tsServicePerformanceCounterDiscontinuity"), ("DVB-MGTR101290-MIB", "tsServicePerformanceCounterReset"), ("DVB-MGTR101290-MIB", "tsServicePerformanceLatestError"), ("DVB-MGTR101290-MIB", "tsServicePerformanceActiveTime"), ("DVB-MGTR101290-MIB", "tsServicePerformanceMeasurementState"), ("DVB-MGTR101290-MIB", "tsServicePerformanceError"), ("DVB-MGTR101290-MIB", "tsServicePerformanceErrorRatio"), ("DVB-MGTR101290-MIB", "tsSPPrefDeltaT"), ("DVB-MGTR101290-MIB", "tsSPPrefEvaluationTime"), ("DVB-MGTR101290-MIB", "tsSPPrefThreshold"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    groupTransportStream = groupTransportStream.setStatus('current')
if mibBuilder.loadTexts: groupTransportStream.setDescription('Contains all objects relevant to Transport Stream measurement')
groupCable = ObjectGroup((1, 3, 6, 1, 4, 1, 2696, 3, 2, 3, 2, 6)).setObjects(("DVB-MGTR101290-MIB", "sysAvailabilityTestState"), ("DVB-MGTR101290-MIB", "sysAvailabilityEnable"), ("DVB-MGTR101290-MIB", "sysAvailabilityCounter"), ("DVB-MGTR101290-MIB", "sysAvailabilityCounterDiscontinuity"), ("DVB-MGTR101290-MIB", "sysAvailabilityCounterReset"), ("DVB-MGTR101290-MIB", "sysAvailabilityLatestError"), ("DVB-MGTR101290-MIB", "sysAvailabilityActiveTime"), ("DVB-MGTR101290-MIB", "sysAvailabilityMeasurementState"), ("DVB-MGTR101290-MIB", "sysAvailabilityUnavailableTime"), ("DVB-MGTR101290-MIB", "sysAvailabilityRatio"), ("DVB-MGTR101290-MIB", "sysAvailabilityInSETI"), ("DVB-MGTR101290-MIB", "linkAvailabilityTestState"), ("DVB-MGTR101290-MIB", "linkAvailabilityEnable"), ("DVB-MGTR101290-MIB", "linkAvailabilityCounter"), ("DVB-MGTR101290-MIB", "linkAvailabilityCounterDiscontinuity"), ("DVB-MGTR101290-MIB", "linkAvailabilityCounterReset"), ("DVB-MGTR101290-MIB", "linkAvailabilityLatestError"), ("DVB-MGTR101290-MIB", "linkAvailabilityActiveTime"), ("DVB-MGTR101290-MIB", "linkAvailabilityMeasurementState"), ("DVB-MGTR101290-MIB", "linkAvailabilityUnavailableTime"), ("DVB-MGTR101290-MIB", "linkAvailabilityRatio"), ("DVB-MGTR101290-MIB", "linkAvailabilityInSUTI"), ("DVB-MGTR101290-MIB", "berRSinServiceTestState"), ("DVB-MGTR101290-MIB", "berRSinServiceEnable"), ("DVB-MGTR101290-MIB", "berRSinServiceCounter"), ("DVB-MGTR101290-MIB", "berRSinServiceCounterDiscontinuity"), ("DVB-MGTR101290-MIB", "berRSinServiceCounterReset"), ("DVB-MGTR101290-MIB", "berRSinServiceLatestError"), ("DVB-MGTR101290-MIB", "berRSinServiceActiveTime"), ("DVB-MGTR101290-MIB", "berRSinServiceMeasurementState"), ("DVB-MGTR101290-MIB", "berRSinServiceValue"), ("DVB-MGTR101290-MIB", "rfIFsignalPowerTestState"), ("DVB-MGTR101290-MIB", "rfIFsignalPowerEnable"), ("DVB-MGTR101290-MIB", "rfIFsignalPowerCounter"), ("DVB-MGTR101290-MIB", "rfIFsignalPowerCounterDiscontinuity"), ("DVB-MGTR101290-MIB", "rfIFsignalPowerCounterReset"), ("DVB-MGTR101290-MIB", "rfIFsignalPowerLatestError"), ("DVB-MGTR101290-MIB", "rfIFsignalPowerActiveTime"), ("DVB-MGTR101290-MIB", "rfIFsignalPowerMeasurementState"), ("DVB-MGTR101290-MIB", "rfIFsignalPowerValue"), ("DVB-MGTR101290-MIB", "noisePowerTestState"), ("DVB-MGTR101290-MIB", "noisePowerEnable"), ("DVB-MGTR101290-MIB", "noisePowerCounter"), ("DVB-MGTR101290-MIB", "noisePowerCounterDiscontinuity"), ("DVB-MGTR101290-MIB", "noisePowerCounterReset"), ("DVB-MGTR101290-MIB", "noisePowerLatestError"), ("DVB-MGTR101290-MIB", "noisePowerActiveTime"), ("DVB-MGTR101290-MIB", "noisePowerMeasurementState"), ("DVB-MGTR101290-MIB", "noisePowerValue"), ("DVB-MGTR101290-MIB", "merCSTestState"), ("DVB-MGTR101290-MIB", "merCSEnable"), ("DVB-MGTR101290-MIB", "merCSCounter"), ("DVB-MGTR101290-MIB", "merCSCounterDiscontinuity"), ("DVB-MGTR101290-MIB", "merCSCounterReset"), ("DVB-MGTR101290-MIB", "merCSLatestError"), ("DVB-MGTR101290-MIB", "merCSActiveTime"), ("DVB-MGTR101290-MIB", "merCSMeasurementState"), ("DVB-MGTR101290-MIB", "merCSValue"), ("DVB-MGTR101290-MIB", "steMeanCSTestState"), ("DVB-MGTR101290-MIB", "steMeanCSEnable"), ("DVB-MGTR101290-MIB", "steMeanCSCounter"), ("DVB-MGTR101290-MIB", "steMeanCSCounterDiscontinuity"), ("DVB-MGTR101290-MIB", "steMeanCSCounterReset"), ("DVB-MGTR101290-MIB", "steMeanCSLatestError"), ("DVB-MGTR101290-MIB", "steMeanCSActiveTime"), ("DVB-MGTR101290-MIB", "steMeanCSMeasurementState"), ("DVB-MGTR101290-MIB", "steMeanCSValue"), ("DVB-MGTR101290-MIB", "steDeviationCSTestState"), ("DVB-MGTR101290-MIB", "steDeviationCSEnable"), ("DVB-MGTR101290-MIB", "steDeviationCSCounter"), ("DVB-MGTR101290-MIB", "steDeviationCSCounterDiscontinuity"), ("DVB-MGTR101290-MIB", "steDeviationCSCounterReset"), ("DVB-MGTR101290-MIB", "steDeviationCSLatestError"), ("DVB-MGTR101290-MIB", "steDeviationCSActiveTime"), ("DVB-MGTR101290-MIB", "steDeviationCSMeasurementState"), ("DVB-MGTR101290-MIB", "steDeviationCSValue"), ("DVB-MGTR101290-MIB", "csCSTestState"), ("DVB-MGTR101290-MIB", "csCSEnable"), ("DVB-MGTR101290-MIB", "csCSCounter"), ("DVB-MGTR101290-MIB", "csCSCounterDiscontinuity"), ("DVB-MGTR101290-MIB", "csCSCounterReset"), ("DVB-MGTR101290-MIB", "csCSLatestError"), ("DVB-MGTR101290-MIB", "csCSActiveTime"), ("DVB-MGTR101290-MIB", "csCSMeasurementState"), ("DVB-MGTR101290-MIB", "csCSValue"), ("DVB-MGTR101290-MIB", "aiCSTestState"), ("DVB-MGTR101290-MIB", "aiCSEnable"), ("DVB-MGTR101290-MIB", "aiCSCounter"), ("DVB-MGTR101290-MIB", "aiCSCounterDiscontinuity"), ("DVB-MGTR101290-MIB", "aiCSCounterReset"), ("DVB-MGTR101290-MIB", "aiCSLatestError"), ("DVB-MGTR101290-MIB", "aiCSActiveTime"), ("DVB-MGTR101290-MIB", "aiCSMeasurementState"), ("DVB-MGTR101290-MIB", "aiCSValue"), ("DVB-MGTR101290-MIB", "qeCSTestState"), ("DVB-MGTR101290-MIB", "qeCSEnable"), ("DVB-MGTR101290-MIB", "qeCSCounter"), ("DVB-MGTR101290-MIB", "qeCSCounterDiscontinuity"), ("DVB-MGTR101290-MIB", "qeCSCounterReset"), ("DVB-MGTR101290-MIB", "qeCSLatestError"), ("DVB-MGTR101290-MIB", "qeCSActiveTime"), ("DVB-MGTR101290-MIB", "qeCSMeasurementState"), ("DVB-MGTR101290-MIB", "qeCSValue"), ("DVB-MGTR101290-MIB", "rteCSTestState"), ("DVB-MGTR101290-MIB", "rteCSEnable"), ("DVB-MGTR101290-MIB", "rteCSCounter"), ("DVB-MGTR101290-MIB", "rteCSCounterDiscontinuity"), ("DVB-MGTR101290-MIB", "rteCSCounterReset"), ("DVB-MGTR101290-MIB", "rteCSLatestError"), ("DVB-MGTR101290-MIB", "rteCSActiveTime"), ("DVB-MGTR101290-MIB", "rteCSMeasurementState"), ("DVB-MGTR101290-MIB", "rteCSValue"), ("DVB-MGTR101290-MIB", "ciCSTestState"), ("DVB-MGTR101290-MIB", "ciCSEnable"), ("DVB-MGTR101290-MIB", "ciCSCounter"), ("DVB-MGTR101290-MIB", "ciCSCounterDiscontinuity"), ("DVB-MGTR101290-MIB", "ciCSCounterReset"), ("DVB-MGTR101290-MIB", "ciCSLatestError"), ("DVB-MGTR101290-MIB", "ciCSActiveTime"), ("DVB-MGTR101290-MIB", "ciCSMeasurementState"), ("DVB-MGTR101290-MIB", "ciCSValue"), ("DVB-MGTR101290-MIB", "pjCSTestState"), ("DVB-MGTR101290-MIB", "pjCSEnable"), ("DVB-MGTR101290-MIB", "pjCSCounter"), ("DVB-MGTR101290-MIB", "pjCSCounterDiscontinuity"), ("DVB-MGTR101290-MIB", "pjCSCounterReset"), ("DVB-MGTR101290-MIB", "pjCSLatestError"), ("DVB-MGTR101290-MIB", "pjCSActiveTime"), ("DVB-MGTR101290-MIB", "pjCSMeasurementState"), ("DVB-MGTR101290-MIB", "pjCSValue"), ("DVB-MGTR101290-MIB", "snrCSTestState"), ("DVB-MGTR101290-MIB", "snrCSEnable"), ("DVB-MGTR101290-MIB", "snrCSCounter"), ("DVB-MGTR101290-MIB", "snrCSCounterDiscontinuity"), ("DVB-MGTR101290-MIB", "snrCSCounterReset"), ("DVB-MGTR101290-MIB", "snrCSLatestError"), ("DVB-MGTR101290-MIB", "snrCSActiveTime"), ("DVB-MGTR101290-MIB", "snrCSMeasurementState"), ("DVB-MGTR101290-MIB", "snrCSValue"), ("DVB-MGTR101290-MIB", "cableSatPrefCentreFrequency"), ("DVB-MGTR101290-MIB", "cableSatPrefModulation"), ("DVB-MGTR101290-MIB", "cableSatPrefSysAvailUATMode"), ("DVB-MGTR101290-MIB", "cableSatPrefSysAvailN"), ("DVB-MGTR101290-MIB", "cableSatPrefSysAvailT"), ("DVB-MGTR101290-MIB", "cableSatPrefSysAvailM"), ("DVB-MGTR101290-MIB", "cableSatPrefSysAvailTI"), ("DVB-MGTR101290-MIB", "cableSatPrefSysAvailEBPerCent"), ("DVB-MGTR101290-MIB", "cableSatPrefSysAvailTotalTime"), ("DVB-MGTR101290-MIB", "cableSatPrefLinkAvailUATMode"), ("DVB-MGTR101290-MIB", "cableSatPrefLinkAvailN"), ("DVB-MGTR101290-MIB", "cableSatPrefLinkAvailT"), ("DVB-MGTR101290-MIB", "cableSatPrefLinkAvailM"), ("DVB-MGTR101290-MIB", "cableSatPrefLinkAvailTI"), ("DVB-MGTR101290-MIB", "cableSatPrefLinkAvailUPPerCent"), ("DVB-MGTR101290-MIB", "cableSatPrefLinkAvailTotalTime"), ("DVB-MGTR101290-MIB", "cableSatPrefBERMax"), ("DVB-MGTR101290-MIB", "cableSatPrefSignalPowerMin"), ("DVB-MGTR101290-MIB", "cableSatPrefSignalPowerMax"), ("DVB-MGTR101290-MIB", "cableSatPrefNoisePowerMax"), ("DVB-MGTR101290-MIB", "cableSatPrefMerCSMin"), ("DVB-MGTR101290-MIB", "cableSatPrefSteMeanCSMax"), ("DVB-MGTR101290-MIB", "cableSatPrefSteDeviationCSMax"), ("DVB-MGTR101290-MIB", "cableSatPrefCsCSMin"), ("DVB-MGTR101290-MIB", "cableSatPrefAiCSMax"), ("DVB-MGTR101290-MIB", "cableSatPrefQeCSMax"), ("DVB-MGTR101290-MIB", "cableSatPrefRteCSMax"), ("DVB-MGTR101290-MIB", "cableSatPrefCiCSMin"), ("DVB-MGTR101290-MIB", "cableSatPrefPjCSMax"), ("DVB-MGTR101290-MIB", "cableSatPrefSnrCSMin"), ("DVB-MGTR101290-MIB", "noiseMarginTestState"), ("DVB-MGTR101290-MIB", "noiseMarginEnable"), ("DVB-MGTR101290-MIB", "noiseMarginCounter"), ("DVB-MGTR101290-MIB", "noiseMarginCounterDiscontinuity"), ("DVB-MGTR101290-MIB", "noiseMarginCounterReset"), ("DVB-MGTR101290-MIB", "noiseMarginLatestError"), ("DVB-MGTR101290-MIB", "noiseMarginActiveTime"), ("DVB-MGTR101290-MIB", "noiseMarginMeasurementState"), ("DVB-MGTR101290-MIB", "noiseMarginValue"), ("DVB-MGTR101290-MIB", "estNoiseMarginTestState"), ("DVB-MGTR101290-MIB", "estNoiseMarginEnable"), ("DVB-MGTR101290-MIB", "estNoiseMarginCounter"), ("DVB-MGTR101290-MIB", "estNoiseMarginCounterDiscontinuity"), ("DVB-MGTR101290-MIB", "estNoiseMarginCounterReset"), ("DVB-MGTR101290-MIB", "estNoiseMarginLatestError"), ("DVB-MGTR101290-MIB", "estNoiseMarginActiveTime"), ("DVB-MGTR101290-MIB", "estNoiseMarginMeasurementState"), ("DVB-MGTR101290-MIB", "estNoiseMarginValue"), ("DVB-MGTR101290-MIB", "signQualMarTTestState"), ("DVB-MGTR101290-MIB", "signQualMarTEnable"), ("DVB-MGTR101290-MIB", "signQualMarTCounter"), ("DVB-MGTR101290-MIB", "signQualMarTCounterDiscontinuity"), ("DVB-MGTR101290-MIB", "signQualMarTCounterReset"), ("DVB-MGTR101290-MIB", "signQualMarTLatestError"), ("DVB-MGTR101290-MIB", "signQualMarTActiveTime"), ("DVB-MGTR101290-MIB", "eNDCTestState"), ("DVB-MGTR101290-MIB", "eNDCEnable"), ("DVB-MGTR101290-MIB", "eNDCCounter"), ("DVB-MGTR101290-MIB", "eNDCCounterDiscontinuity"), ("DVB-MGTR101290-MIB", "eNDCCounterReset"), ("DVB-MGTR101290-MIB", "eNDCLatestError"), ("DVB-MGTR101290-MIB", "eNDCActiveTime"), ("DVB-MGTR101290-MIB", "eNDCMeasurementState"), ("DVB-MGTR101290-MIB", "eNDCValue"), ("DVB-MGTR101290-MIB", "outBandEmissTestState"), ("DVB-MGTR101290-MIB", "outBandEmissEnable"), ("DVB-MGTR101290-MIB", "outBandEmissCounter"), ("DVB-MGTR101290-MIB", "outBandEmissCounterDiscontinuity"), ("DVB-MGTR101290-MIB", "outBandEmissCounterReset"), ("DVB-MGTR101290-MIB", "outBandEmissLatestError"), ("DVB-MGTR101290-MIB", "outBandEmissActiveTime"), ("DVB-MGTR101290-MIB", "cablePrefNoiseMarginMin"), ("DVB-MGTR101290-MIB", "cablePrefEstNoiseMarginMin"), ("DVB-MGTR101290-MIB", "cablePrefSignQualBoxSize"), ("DVB-MGTR101290-MIB", "cablePrefSignQualPercentMax"), ("DVB-MGTR101290-MIB", "cablePrefENDBER"), ("DVB-MGTR101290-MIB", "cablePrefENDCtoNSpecified"), ("DVB-MGTR101290-MIB", "cablePrefENDIdeal"), ("DVB-MGTR101290-MIB", "cablePrefENDMax"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    groupCable = groupCable.setStatus('current')
if mibBuilder.loadTexts: groupCable.setDescription('Contains all objects relevant to cable RF measurement')
groupSatellite = ObjectGroup((1, 3, 6, 1, 4, 1, 2696, 3, 2, 3, 2, 7)).setObjects(("DVB-MGTR101290-MIB", "sysAvailabilityTestState"), ("DVB-MGTR101290-MIB", "sysAvailabilityEnable"), ("DVB-MGTR101290-MIB", "sysAvailabilityCounter"), ("DVB-MGTR101290-MIB", "sysAvailabilityCounterDiscontinuity"), ("DVB-MGTR101290-MIB", "sysAvailabilityCounterReset"), ("DVB-MGTR101290-MIB", "sysAvailabilityLatestError"), ("DVB-MGTR101290-MIB", "sysAvailabilityActiveTime"), ("DVB-MGTR101290-MIB", "sysAvailabilityMeasurementState"), ("DVB-MGTR101290-MIB", "sysAvailabilityUnavailableTime"), ("DVB-MGTR101290-MIB", "sysAvailabilityRatio"), ("DVB-MGTR101290-MIB", "sysAvailabilityInSETI"), ("DVB-MGTR101290-MIB", "linkAvailabilityTestState"), ("DVB-MGTR101290-MIB", "linkAvailabilityEnable"), ("DVB-MGTR101290-MIB", "linkAvailabilityCounter"), ("DVB-MGTR101290-MIB", "linkAvailabilityCounterDiscontinuity"), ("DVB-MGTR101290-MIB", "linkAvailabilityCounterReset"), ("DVB-MGTR101290-MIB", "linkAvailabilityLatestError"), ("DVB-MGTR101290-MIB", "linkAvailabilityActiveTime"), ("DVB-MGTR101290-MIB", "linkAvailabilityMeasurementState"), ("DVB-MGTR101290-MIB", "linkAvailabilityUnavailableTime"), ("DVB-MGTR101290-MIB", "linkAvailabilityRatio"), ("DVB-MGTR101290-MIB", "linkAvailabilityInSUTI"), ("DVB-MGTR101290-MIB", "berRSinServiceTestState"), ("DVB-MGTR101290-MIB", "berRSinServiceEnable"), ("DVB-MGTR101290-MIB", "berRSinServiceCounter"), ("DVB-MGTR101290-MIB", "berRSinServiceCounterDiscontinuity"), ("DVB-MGTR101290-MIB", "berRSinServiceCounterReset"), ("DVB-MGTR101290-MIB", "berRSinServiceLatestError"), ("DVB-MGTR101290-MIB", "berRSinServiceActiveTime"), ("DVB-MGTR101290-MIB", "berRSinServiceMeasurementState"), ("DVB-MGTR101290-MIB", "berRSinServiceValue"), ("DVB-MGTR101290-MIB", "rfIFsignalPowerTestState"), ("DVB-MGTR101290-MIB", "rfIFsignalPowerEnable"), ("DVB-MGTR101290-MIB", "rfIFsignalPowerCounter"), ("DVB-MGTR101290-MIB", "rfIFsignalPowerCounterDiscontinuity"), ("DVB-MGTR101290-MIB", "rfIFsignalPowerCounterReset"), ("DVB-MGTR101290-MIB", "rfIFsignalPowerLatestError"), ("DVB-MGTR101290-MIB", "rfIFsignalPowerActiveTime"), ("DVB-MGTR101290-MIB", "rfIFsignalPowerMeasurementState"), ("DVB-MGTR101290-MIB", "rfIFsignalPowerValue"), ("DVB-MGTR101290-MIB", "noisePowerTestState"), ("DVB-MGTR101290-MIB", "noisePowerEnable"), ("DVB-MGTR101290-MIB", "noisePowerCounter"), ("DVB-MGTR101290-MIB", "noisePowerCounterDiscontinuity"), ("DVB-MGTR101290-MIB", "noisePowerCounterReset"), ("DVB-MGTR101290-MIB", "noisePowerLatestError"), ("DVB-MGTR101290-MIB", "noisePowerActiveTime"), ("DVB-MGTR101290-MIB", "noisePowerMeasurementState"), ("DVB-MGTR101290-MIB", "noisePowerValue"), ("DVB-MGTR101290-MIB", "merCSTestState"), ("DVB-MGTR101290-MIB", "merCSEnable"), ("DVB-MGTR101290-MIB", "merCSCounter"), ("DVB-MGTR101290-MIB", "merCSCounterDiscontinuity"), ("DVB-MGTR101290-MIB", "merCSCounterReset"), ("DVB-MGTR101290-MIB", "merCSLatestError"), ("DVB-MGTR101290-MIB", "merCSActiveTime"), ("DVB-MGTR101290-MIB", "merCSMeasurementState"), ("DVB-MGTR101290-MIB", "merCSValue"), ("DVB-MGTR101290-MIB", "steMeanCSTestState"), ("DVB-MGTR101290-MIB", "steMeanCSEnable"), ("DVB-MGTR101290-MIB", "steMeanCSCounter"), ("DVB-MGTR101290-MIB", "steMeanCSCounterDiscontinuity"), ("DVB-MGTR101290-MIB", "steMeanCSCounterReset"), ("DVB-MGTR101290-MIB", "steMeanCSLatestError"), ("DVB-MGTR101290-MIB", "steMeanCSActiveTime"), ("DVB-MGTR101290-MIB", "steMeanCSMeasurementState"), ("DVB-MGTR101290-MIB", "steMeanCSValue"), ("DVB-MGTR101290-MIB", "steDeviationCSTestState"), ("DVB-MGTR101290-MIB", "steDeviationCSEnable"), ("DVB-MGTR101290-MIB", "steDeviationCSCounter"), ("DVB-MGTR101290-MIB", "steDeviationCSCounterDiscontinuity"), ("DVB-MGTR101290-MIB", "steDeviationCSCounterReset"), ("DVB-MGTR101290-MIB", "steDeviationCSLatestError"), ("DVB-MGTR101290-MIB", "steDeviationCSActiveTime"), ("DVB-MGTR101290-MIB", "steDeviationCSMeasurementState"), ("DVB-MGTR101290-MIB", "steDeviationCSValue"), ("DVB-MGTR101290-MIB", "csCSTestState"), ("DVB-MGTR101290-MIB", "csCSEnable"), ("DVB-MGTR101290-MIB", "csCSCounter"), ("DVB-MGTR101290-MIB", "csCSCounterDiscontinuity"), ("DVB-MGTR101290-MIB", "csCSCounterReset"), ("DVB-MGTR101290-MIB", "csCSLatestError"), ("DVB-MGTR101290-MIB", "csCSActiveTime"), ("DVB-MGTR101290-MIB", "csCSMeasurementState"), ("DVB-MGTR101290-MIB", "csCSValue"), ("DVB-MGTR101290-MIB", "aiCSTestState"), ("DVB-MGTR101290-MIB", "aiCSEnable"), ("DVB-MGTR101290-MIB", "aiCSCounter"), ("DVB-MGTR101290-MIB", "aiCSCounterDiscontinuity"), ("DVB-MGTR101290-MIB", "aiCSCounterReset"), ("DVB-MGTR101290-MIB", "aiCSLatestError"), ("DVB-MGTR101290-MIB", "aiCSActiveTime"), ("DVB-MGTR101290-MIB", "aiCSMeasurementState"), ("DVB-MGTR101290-MIB", "aiCSValue"), ("DVB-MGTR101290-MIB", "qeCSTestState"), ("DVB-MGTR101290-MIB", "qeCSEnable"), ("DVB-MGTR101290-MIB", "qeCSCounter"), ("DVB-MGTR101290-MIB", "qeCSCounterDiscontinuity"), ("DVB-MGTR101290-MIB", "qeCSCounterReset"), ("DVB-MGTR101290-MIB", "qeCSLatestError"), ("DVB-MGTR101290-MIB", "qeCSActiveTime"), ("DVB-MGTR101290-MIB", "qeCSMeasurementState"), ("DVB-MGTR101290-MIB", "qeCSValue"), ("DVB-MGTR101290-MIB", "rteCSTestState"), ("DVB-MGTR101290-MIB", "rteCSEnable"), ("DVB-MGTR101290-MIB", "rteCSCounter"), ("DVB-MGTR101290-MIB", "rteCSCounterDiscontinuity"), ("DVB-MGTR101290-MIB", "rteCSCounterReset"), ("DVB-MGTR101290-MIB", "rteCSLatestError"), ("DVB-MGTR101290-MIB", "rteCSActiveTime"), ("DVB-MGTR101290-MIB", "rteCSMeasurementState"), ("DVB-MGTR101290-MIB", "rteCSValue"), ("DVB-MGTR101290-MIB", "ciCSTestState"), ("DVB-MGTR101290-MIB", "ciCSEnable"), ("DVB-MGTR101290-MIB", "ciCSCounter"), ("DVB-MGTR101290-MIB", "ciCSCounterDiscontinuity"), ("DVB-MGTR101290-MIB", "ciCSCounterReset"), ("DVB-MGTR101290-MIB", "ciCSLatestError"), ("DVB-MGTR101290-MIB", "ciCSActiveTime"), ("DVB-MGTR101290-MIB", "ciCSMeasurementState"), ("DVB-MGTR101290-MIB", "ciCSValue"), ("DVB-MGTR101290-MIB", "pjCSTestState"), ("DVB-MGTR101290-MIB", "pjCSEnable"), ("DVB-MGTR101290-MIB", "pjCSCounter"), ("DVB-MGTR101290-MIB", "pjCSCounterDiscontinuity"), ("DVB-MGTR101290-MIB", "pjCSCounterReset"), ("DVB-MGTR101290-MIB", "pjCSLatestError"), ("DVB-MGTR101290-MIB", "pjCSActiveTime"), ("DVB-MGTR101290-MIB", "pjCSMeasurementState"), ("DVB-MGTR101290-MIB", "pjCSValue"), ("DVB-MGTR101290-MIB", "snrCSTestState"), ("DVB-MGTR101290-MIB", "snrCSEnable"), ("DVB-MGTR101290-MIB", "snrCSCounter"), ("DVB-MGTR101290-MIB", "snrCSCounterDiscontinuity"), ("DVB-MGTR101290-MIB", "snrCSCounterReset"), ("DVB-MGTR101290-MIB", "snrCSLatestError"), ("DVB-MGTR101290-MIB", "snrCSActiveTime"), ("DVB-MGTR101290-MIB", "snrCSMeasurementState"), ("DVB-MGTR101290-MIB", "snrCSValue"), ("DVB-MGTR101290-MIB", "cableSatPrefCentreFrequency"), ("DVB-MGTR101290-MIB", "cableSatPrefModulation"), ("DVB-MGTR101290-MIB", "cableSatPrefSysAvailUATMode"), ("DVB-MGTR101290-MIB", "cableSatPrefSysAvailN"), ("DVB-MGTR101290-MIB", "cableSatPrefSysAvailT"), ("DVB-MGTR101290-MIB", "cableSatPrefSysAvailM"), ("DVB-MGTR101290-MIB", "cableSatPrefSysAvailTI"), ("DVB-MGTR101290-MIB", "cableSatPrefSysAvailEBPerCent"), ("DVB-MGTR101290-MIB", "cableSatPrefSysAvailTotalTime"), ("DVB-MGTR101290-MIB", "cableSatPrefLinkAvailUATMode"), ("DVB-MGTR101290-MIB", "cableSatPrefLinkAvailN"), ("DVB-MGTR101290-MIB", "cableSatPrefLinkAvailT"), ("DVB-MGTR101290-MIB", "cableSatPrefLinkAvailM"), ("DVB-MGTR101290-MIB", "cableSatPrefLinkAvailTI"), ("DVB-MGTR101290-MIB", "cableSatPrefLinkAvailUPPerCent"), ("DVB-MGTR101290-MIB", "cableSatPrefLinkAvailTotalTime"), ("DVB-MGTR101290-MIB", "cableSatPrefBERMax"), ("DVB-MGTR101290-MIB", "cableSatPrefSignalPowerMin"), ("DVB-MGTR101290-MIB", "cableSatPrefSignalPowerMax"), ("DVB-MGTR101290-MIB", "cableSatPrefNoisePowerMax"), ("DVB-MGTR101290-MIB", "cableSatPrefMerCSMin"), ("DVB-MGTR101290-MIB", "cableSatPrefSteMeanCSMax"), ("DVB-MGTR101290-MIB", "cableSatPrefSteDeviationCSMax"), ("DVB-MGTR101290-MIB", "cableSatPrefCsCSMin"), ("DVB-MGTR101290-MIB", "cableSatPrefAiCSMax"), ("DVB-MGTR101290-MIB", "cableSatPrefQeCSMax"), ("DVB-MGTR101290-MIB", "cableSatPrefRteCSMax"), ("DVB-MGTR101290-MIB", "cableSatPrefCiCSMin"), ("DVB-MGTR101290-MIB", "cableSatPrefPjCSMax"), ("DVB-MGTR101290-MIB", "cableSatPrefSnrCSMin"), ("DVB-MGTR101290-MIB", "berViterbiSTestState"), ("DVB-MGTR101290-MIB", "berViterbiSEnable"), ("DVB-MGTR101290-MIB", "berViterbiSCounter"), ("DVB-MGTR101290-MIB", "berViterbiSCounterDiscontinuity"), ("DVB-MGTR101290-MIB", "berViterbiSCounterReset"), ("DVB-MGTR101290-MIB", "berViterbiSLatestError"), ("DVB-MGTR101290-MIB", "berViterbiSActiveTime"), ("DVB-MGTR101290-MIB", "berViterbiSMeasurementState"), ("DVB-MGTR101290-MIB", "berViterbiSIValue"), ("DVB-MGTR101290-MIB", "berViterbiSQValue"), ("DVB-MGTR101290-MIB", "berViterbiSMeasurementMethod"), ("DVB-MGTR101290-MIB", "ifSpectrumTestState"), ("DVB-MGTR101290-MIB", "ifSpectrumEnable"), ("DVB-MGTR101290-MIB", "ifSpectrumCounter"), ("DVB-MGTR101290-MIB", "ifSpectrumCounterDiscontinuity"), ("DVB-MGTR101290-MIB", "ifSpectrumCounterReset"), ("DVB-MGTR101290-MIB", "ifSpectrumLatestError"), ("DVB-MGTR101290-MIB", "ifSpectrumActiveTime"), ("DVB-MGTR101290-MIB", "satellitePrefBERMax"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    groupSatellite = groupSatellite.setStatus('current')
if mibBuilder.loadTexts: groupSatellite.setDescription('Contains all objects relevent to satellite RF measurements')
groupTerrestrial = ObjectGroup((1, 3, 6, 1, 4, 1, 2696, 3, 2, 3, 2, 8)).setObjects(("DVB-MGTR101290-MIB", "rfAccuracyTestState"), ("DVB-MGTR101290-MIB", "rfAccuracyEnable"), ("DVB-MGTR101290-MIB", "rfAccuracyCounter"), ("DVB-MGTR101290-MIB", "rfAccuracyCounterDiscontinuity"), ("DVB-MGTR101290-MIB", "rfAccuracyCounterReset"), ("DVB-MGTR101290-MIB", "rfAccuracyLatestError"), ("DVB-MGTR101290-MIB", "rfAccuracyActiveTime"), ("DVB-MGTR101290-MIB", "rfAccuracyMeasurementState"), ("DVB-MGTR101290-MIB", "rfAccuracyValue"), ("DVB-MGTR101290-MIB", "rfChannelWidthTestState"), ("DVB-MGTR101290-MIB", "rfChannelWidthEnable"), ("DVB-MGTR101290-MIB", "rfChannelWidthCounter"), ("DVB-MGTR101290-MIB", "rfChannelWidthCounterDiscontinuity"), ("DVB-MGTR101290-MIB", "rfChannelWidthCounterReset"), ("DVB-MGTR101290-MIB", "rfChannelWidthLatestError"), ("DVB-MGTR101290-MIB", "rfChannelWidthActiveTime"), ("DVB-MGTR101290-MIB", "rfChannelWidthMeasurementState"), ("DVB-MGTR101290-MIB", "rfChannelWidthValue"), ("DVB-MGTR101290-MIB", "symbolLengthTestState"), ("DVB-MGTR101290-MIB", "symbolLengthEnable"), ("DVB-MGTR101290-MIB", "symbolLengthCounter"), ("DVB-MGTR101290-MIB", "symbolLengthCounterDiscontinuity"), ("DVB-MGTR101290-MIB", "symbolLengthCounterReset"), ("DVB-MGTR101290-MIB", "symbolLengthLatestError"), ("DVB-MGTR101290-MIB", "symbolLengthActiveTime"), ("DVB-MGTR101290-MIB", "symbolLengthMeasurementState"), ("DVB-MGTR101290-MIB", "symbolLengthValue"), ("DVB-MGTR101290-MIB", "rfIfPowerTestState"), ("DVB-MGTR101290-MIB", "rfIfPowerEnable"), ("DVB-MGTR101290-MIB", "rfIfPowerCounter"), ("DVB-MGTR101290-MIB", "rfIfPowerCounterDiscontinuity"), ("DVB-MGTR101290-MIB", "rfIfPowerCounterReset"), ("DVB-MGTR101290-MIB", "rfIfPowerLatestError"), ("DVB-MGTR101290-MIB", "rfIfPowerActiveTime"), ("DVB-MGTR101290-MIB", "rfIfPowerMeasurementState"), ("DVB-MGTR101290-MIB", "rfIfPowerValue"), ("DVB-MGTR101290-MIB", "rfIfSpectrumTestState"), ("DVB-MGTR101290-MIB", "rfIfSpectrumEnable"), ("DVB-MGTR101290-MIB", "rfIfSpectrumCounter"), ("DVB-MGTR101290-MIB", "rfIfSpectrumCounterDiscontinuity"), ("DVB-MGTR101290-MIB", "rfIfSpectrumCounterReset"), ("DVB-MGTR101290-MIB", "rfIfSpectrumLatestError"), ("DVB-MGTR101290-MIB", "rfIfSpectrumActiveTime"), ("DVB-MGTR101290-MIB", "eNDTTestState"), ("DVB-MGTR101290-MIB", "eNDTEnable"), ("DVB-MGTR101290-MIB", "eNDTCounter"), ("DVB-MGTR101290-MIB", "eNDTCounterDiscontinuity"), ("DVB-MGTR101290-MIB", "eNDTCounterReset"), ("DVB-MGTR101290-MIB", "eNDTLatestError"), ("DVB-MGTR101290-MIB", "eNDTActiveTime"), ("DVB-MGTR101290-MIB", "eNDTMeasurementState"), ("DVB-MGTR101290-MIB", "eNDTValue"), ("DVB-MGTR101290-MIB", "eNFTTestState"), ("DVB-MGTR101290-MIB", "eNFTEnable"), ("DVB-MGTR101290-MIB", "eNFTCounter"), ("DVB-MGTR101290-MIB", "eNFTCounterDiscontinuity"), ("DVB-MGTR101290-MIB", "eNFTCounterReset"), ("DVB-MGTR101290-MIB", "eNFTLatestError"), ("DVB-MGTR101290-MIB", "eNFTActiveTime"), ("DVB-MGTR101290-MIB", "eNFTMeasurementState"), ("DVB-MGTR101290-MIB", "eNFTValue"), ("DVB-MGTR101290-MIB", "eNDTLPTestState"), ("DVB-MGTR101290-MIB", "eNDTLPEnable"), ("DVB-MGTR101290-MIB", "eNDTLPCounter"), ("DVB-MGTR101290-MIB", "eNDTLPCounterDiscontinuity"), ("DVB-MGTR101290-MIB", "eNDTLPCounterReset"), ("DVB-MGTR101290-MIB", "eNDTLPLatestError"), ("DVB-MGTR101290-MIB", "eNDTLPActiveTime"), ("DVB-MGTR101290-MIB", "eNDTLPMeasurementState"), ("DVB-MGTR101290-MIB", "eNDTLPValue"), ("DVB-MGTR101290-MIB", "eNFTLPTestState"), ("DVB-MGTR101290-MIB", "eNFTLPEnable"), ("DVB-MGTR101290-MIB", "eNFTLPCounter"), ("DVB-MGTR101290-MIB", "eNFTLPCounterDiscontinuity"), ("DVB-MGTR101290-MIB", "eNFTLPCounterReset"), ("DVB-MGTR101290-MIB", "eNFTLPLatestError"), ("DVB-MGTR101290-MIB", "eNFTLPActiveTime"), ("DVB-MGTR101290-MIB", "eNFTLPMeasurementState"), ("DVB-MGTR101290-MIB", "eNFTLPValue"), ("DVB-MGTR101290-MIB", "linearityTestState"), ("DVB-MGTR101290-MIB", "linearityEnable"), ("DVB-MGTR101290-MIB", "linearityCounter"), ("DVB-MGTR101290-MIB", "linearityCounterDiscontinuity"), ("DVB-MGTR101290-MIB", "linearityCounterReset"), ("DVB-MGTR101290-MIB", "linearityLatestError"), ("DVB-MGTR101290-MIB", "linearityActiveTime"), ("DVB-MGTR101290-MIB", "linearityMeasurementState"), ("DVB-MGTR101290-MIB", "linearityValue"), ("DVB-MGTR101290-MIB", "berViterbiTTestState"), ("DVB-MGTR101290-MIB", "berViterbiTEnable"), ("DVB-MGTR101290-MIB", "berViterbiTCounter"), ("DVB-MGTR101290-MIB", "berViterbiTCounterDiscontinuity"), ("DVB-MGTR101290-MIB", "berViterbiTCounterReset"), ("DVB-MGTR101290-MIB", "berViterbiTLatestError"), ("DVB-MGTR101290-MIB", "berViterbiTActiveTime"), ("DVB-MGTR101290-MIB", "berViterbiTMeasurementState"), ("DVB-MGTR101290-MIB", "berViterbiTValue"), ("DVB-MGTR101290-MIB", "berViterbiTLPTestState"), ("DVB-MGTR101290-MIB", "berViterbiTLPEnable"), ("DVB-MGTR101290-MIB", "berViterbiTLPCounter"), ("DVB-MGTR101290-MIB", "berViterbiTLPCounterDiscontinuity"), ("DVB-MGTR101290-MIB", "berViterbiTLPCounterReset"), ("DVB-MGTR101290-MIB", "berViterbiTLPLatestError"), ("DVB-MGTR101290-MIB", "berViterbiTLPActiveTime"), ("DVB-MGTR101290-MIB", "berViterbiTLPMeasurementState"), ("DVB-MGTR101290-MIB", "berViterbiTLPValue"), ("DVB-MGTR101290-MIB", "berRSTestState"), ("DVB-MGTR101290-MIB", "berRSEnable"), ("DVB-MGTR101290-MIB", "berRSCounter"), ("DVB-MGTR101290-MIB", "berRSCounterDiscontinuity"), ("DVB-MGTR101290-MIB", "berRSCounterReset"), ("DVB-MGTR101290-MIB", "berRSLatestError"), ("DVB-MGTR101290-MIB", "berRSActiveTime"), ("DVB-MGTR101290-MIB", "berRSMeasurementState"), ("DVB-MGTR101290-MIB", "berRSValue"), ("DVB-MGTR101290-MIB", "berRSLPTestState"), ("DVB-MGTR101290-MIB", "berRSLPEnable"), ("DVB-MGTR101290-MIB", "berRSLPCounter"), ("DVB-MGTR101290-MIB", "berRSLPCounterDiscontinuity"), ("DVB-MGTR101290-MIB", "berRSLPCounterReset"), ("DVB-MGTR101290-MIB", "berRSLPLatestError"), ("DVB-MGTR101290-MIB", "berRSLPActiveTime"), ("DVB-MGTR101290-MIB", "berRSLPMeasurementState"), ("DVB-MGTR101290-MIB", "berRSLPValue"), ("DVB-MGTR101290-MIB", "merTTestState"), ("DVB-MGTR101290-MIB", "merTEnable"), ("DVB-MGTR101290-MIB", "merTCounter"), ("DVB-MGTR101290-MIB", "merTCounterDiscontinuity"), ("DVB-MGTR101290-MIB", "merTCounterReset"), ("DVB-MGTR101290-MIB", "merTLatestError"), ("DVB-MGTR101290-MIB", "merTActiveTime"), ("DVB-MGTR101290-MIB", "merTMeasurementState"), ("DVB-MGTR101290-MIB", "merTValue"), ("DVB-MGTR101290-MIB", "steMeanTTestState"), ("DVB-MGTR101290-MIB", "steMeanTEnable"), ("DVB-MGTR101290-MIB", "steMeanTCounter"), ("DVB-MGTR101290-MIB", "steMeanTCounterDiscontinuity"), ("DVB-MGTR101290-MIB", "steMeanTCounterReset"), ("DVB-MGTR101290-MIB", "steMeanTLatestError"), ("DVB-MGTR101290-MIB", "steMeanTActiveTime"), ("DVB-MGTR101290-MIB", "steMeanTMeasurementState"), ("DVB-MGTR101290-MIB", "steMeanTValue"), ("DVB-MGTR101290-MIB", "steDeviationTTestState"), ("DVB-MGTR101290-MIB", "steDeviationTEnable"), ("DVB-MGTR101290-MIB", "steDeviationTCounter"), ("DVB-MGTR101290-MIB", "steDeviationTCounterDiscontinuity"), ("DVB-MGTR101290-MIB", "steDeviationTCounterReset"), ("DVB-MGTR101290-MIB", "steDeviationTLatestError"), ("DVB-MGTR101290-MIB", "steDeviationTActiveTime"), ("DVB-MGTR101290-MIB", "steDeviationTMeasurementState"), ("DVB-MGTR101290-MIB", "steDeviationTValue"), ("DVB-MGTR101290-MIB", "csTTestState"), ("DVB-MGTR101290-MIB", "csTEnable"), ("DVB-MGTR101290-MIB", "csTCounter"), ("DVB-MGTR101290-MIB", "csTCounterDiscontinuity"), ("DVB-MGTR101290-MIB", "csTCounterReset"), ("DVB-MGTR101290-MIB", "csTLatestError"), ("DVB-MGTR101290-MIB", "csTActiveTime"), ("DVB-MGTR101290-MIB", "csTMeasurementState"), ("DVB-MGTR101290-MIB", "csTValue"), ("DVB-MGTR101290-MIB", "aiTTestState"), ("DVB-MGTR101290-MIB", "aiTEnable"), ("DVB-MGTR101290-MIB", "aiTCounter"), ("DVB-MGTR101290-MIB", "aiTCounterDiscontinuity"), ("DVB-MGTR101290-MIB", "aiTCounterReset"), ("DVB-MGTR101290-MIB", "aiTLatestError"), ("DVB-MGTR101290-MIB", "aiTActiveTime"), ("DVB-MGTR101290-MIB", "aiTMeasurementState"), ("DVB-MGTR101290-MIB", "aiTValue"), ("DVB-MGTR101290-MIB", "qeTTestState"), ("DVB-MGTR101290-MIB", "qeTEnable"), ("DVB-MGTR101290-MIB", "qeTCounter"), ("DVB-MGTR101290-MIB", "qeTCounterDiscontinuity"), ("DVB-MGTR101290-MIB", "qeTCounterReset"), ("DVB-MGTR101290-MIB", "qeTLatestError"), ("DVB-MGTR101290-MIB", "qeTActiveTime"), ("DVB-MGTR101290-MIB", "qeTMeasurementState"), ("DVB-MGTR101290-MIB", "qeTValue"), ("DVB-MGTR101290-MIB", "pjTTestState"), ("DVB-MGTR101290-MIB", "pjTEnable"), ("DVB-MGTR101290-MIB", "pjTCounter"), ("DVB-MGTR101290-MIB", "pjTCounterDiscontinuity"), ("DVB-MGTR101290-MIB", "pjTCounterReset"), ("DVB-MGTR101290-MIB", "pjTLatestError"), ("DVB-MGTR101290-MIB", "pjTActiveTime"), ("DVB-MGTR101290-MIB", "pjTMeasurementState"), ("DVB-MGTR101290-MIB", "pjTValue"), ("DVB-MGTR101290-MIB", "mipSyntaxState"), ("DVB-MGTR101290-MIB", "mipSyntaxEnable"), ("DVB-MGTR101290-MIB", "mipSyntaxCounter"), ("DVB-MGTR101290-MIB", "mipSyntaxCounterDiscontinuity"), ("DVB-MGTR101290-MIB", "mipSyntaxCounterReset"), ("DVB-MGTR101290-MIB", "mipSyntaxLatestError"), ("DVB-MGTR101290-MIB", "mipSyntaxActiveTime"), ("DVB-MGTR101290-MIB", "sepEtiTestState"), ("DVB-MGTR101290-MIB", "sepEtiEnable"), ("DVB-MGTR101290-MIB", "sepEtiCounter"), ("DVB-MGTR101290-MIB", "sepEtiCounterDiscontinuity"), ("DVB-MGTR101290-MIB", "sepEtiCounterReset"), ("DVB-MGTR101290-MIB", "sepEtiLatestError"), ("DVB-MGTR101290-MIB", "sepEtiActiveTime"), ("DVB-MGTR101290-MIB", "sepEtiMeasurementState"), ("DVB-MGTR101290-MIB", "sepEtiValue"), ("DVB-MGTR101290-MIB", "sepSetiTestState"), ("DVB-MGTR101290-MIB", "sepSetiEnable"), ("DVB-MGTR101290-MIB", "sepSetiCounter"), ("DVB-MGTR101290-MIB", "sepSetiCounterDiscontinuity"), ("DVB-MGTR101290-MIB", "sepSetiCounterReset"), ("DVB-MGTR101290-MIB", "sepSetiLatestError"), ("DVB-MGTR101290-MIB", "sepSetiActiveTime"), ("DVB-MGTR101290-MIB", "sepSetiMeasurementState"), ("DVB-MGTR101290-MIB", "sepSetiValue"), ("DVB-MGTR101290-MIB", "terrestrialPrefCentreFrequency"), ("DVB-MGTR101290-MIB", "terrestrialPrefBandwidth"), ("DVB-MGTR101290-MIB", "terrestrialPrefModulation"), ("DVB-MGTR101290-MIB", "terrestrialPrefTransmissionMode"), ("DVB-MGTR101290-MIB", "terrestrialPrefGuardInterval"), ("DVB-MGTR101290-MIB", "terrestrialPrefHierarchical"), ("DVB-MGTR101290-MIB", "terrestrialPrefCentreFreqExpected"), ("DVB-MGTR101290-MIB", "terrestrialPrefCentreFreqLimit"), ("DVB-MGTR101290-MIB", "terrestrialPrefChannelWidthLimit"), ("DVB-MGTR101290-MIB", "terrestrialPrefSymbolLengthLimit"), ("DVB-MGTR101290-MIB", "terrestrialPrefPowerMin"), ("DVB-MGTR101290-MIB", "terrestrialPrefPowerMax"), ("DVB-MGTR101290-MIB", "terrestrialPrefENDBER"), ("DVB-MGTR101290-MIB", "terrestrialPrefENDIdeal"), ("DVB-MGTR101290-MIB", "terrestrialPrefENDMax"), ("DVB-MGTR101290-MIB", "terrestrialPrefENFIdeal"), ("DVB-MGTR101290-MIB", "terrestrialPrefENFMax"), ("DVB-MGTR101290-MIB", "terrestrialPrefENDLPIdeal"), ("DVB-MGTR101290-MIB", "terrestrialPrefENDLPMax"), ("DVB-MGTR101290-MIB", "terrestrialPrefENFLPIdeal"), ("DVB-MGTR101290-MIB", "terrestrialPrefENFLPMax"), ("DVB-MGTR101290-MIB", "terrestrialPrefLinearityMin"), ("DVB-MGTR101290-MIB", "terrestrialPrefBERViterbiMax"), ("DVB-MGTR101290-MIB", "terrestrialPrefBERViterbiLPMax"), ("DVB-MGTR101290-MIB", "terrestrialPrefBERRSMax"), ("DVB-MGTR101290-MIB", "terrestrialPrefBERRSLPMax"), ("DVB-MGTR101290-MIB", "terrestrialPrefMerTMin"), ("DVB-MGTR101290-MIB", "terrestrialPrefSteMeanMax"), ("DVB-MGTR101290-MIB", "terrestrialPrefSteDeviationMax"), ("DVB-MGTR101290-MIB", "terrestrialPrefCsMin"), ("DVB-MGTR101290-MIB", "terrestrialPrefAiMax"), ("DVB-MGTR101290-MIB", "terrestrialPrefQeMax"), ("DVB-MGTR101290-MIB", "terrestrialPrefPjMax"), ("DVB-MGTR101290-MIB", "terrestrialPrefMIPTimingLimit"), ("DVB-MGTR101290-MIB", "terrestrialPrefMIPDeviationMax"), ("DVB-MGTR101290-MIB", "terrestrialPrefSEPUATMode"), ("DVB-MGTR101290-MIB", "terrestrialPrefSEPN"), ("DVB-MGTR101290-MIB", "terrestrialPrefSEPT"), ("DVB-MGTR101290-MIB", "terrestrialPrefSEPM"), ("DVB-MGTR101290-MIB", "terrestrialPrefSEPTI"), ("DVB-MGTR101290-MIB", "terrestrialPrefSEPEBPerCent"), ("DVB-MGTR101290-MIB", "terrestrialPrefSEPMeasurementInterval"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    groupTerrestrial = groupTerrestrial.setStatus('current')
if mibBuilder.loadTexts: groupTerrestrial.setDescription('Contains all objects relevant to terrestrial RF measurements')
mibBuilder.exportSymbols("DVB-MGTR101290-MIB", tsConsistencyLatestError=tsConsistencyLatestError, tsTestsPIDTestNumber=tsTestsPIDTestNumber, cablePrefENDIdeal=cablePrefENDIdeal, rfIfPowerCounterDiscontinuity=rfIfPowerCounterDiscontinuity, rfIfPowerLatestError=rfIfPowerLatestError, tsPIDBitRateState=tsPIDBitRateState, rfAccuracyActiveTime=rfAccuracyActiveTime, ifSpectrumCounterDiscontinuity=ifSpectrumCounterDiscontinuity, eNDTValue=eNDTValue, merTEntry=merTEntry, tsTestsPrefEITActualIntervalMax=tsTestsPrefEITActualIntervalMax, tsPcrMeasurementCounterReset=tsPcrMeasurementCounterReset, terrestrialPrefENDIdeal=terrestrialPrefENDIdeal, tsMeasurePrefPIDRowStatus=tsMeasurePrefPIDRowStatus, steMeanCSLatestError=steMeanCSLatestError, linkAvailabilityEntry=linkAvailabilityEntry, csCSCounter=csCSCounter, symbolLengthCounter=symbolLengthCounter, berViterbiTMeasurementState=berViterbiTMeasurementState, tsMeasurePrefPIDBitRateMin=tsMeasurePrefPIDBitRateMin, tr101290Control=tr101290Control, noisePowerCounter=noisePowerCounter, eNDTLPEnable=eNDTLPEnable, csTActiveTime=csTActiveTime, rfChannelWidthEnable=rfChannelWidthEnable, capabilityTSPollInterval=capabilityTSPollInterval, aiTEnable=aiTEnable, TestSummary=TestSummary, controlSynchronizationTable=controlSynchronizationTable, tsTestsSummaryInputNumber=tsTestsSummaryInputNumber, ifSpectrumCounterReset=ifSpectrumCounterReset, satellitePrefInputNumber=satellitePrefInputNumber, tsTestsPrefPIDRowStatus=tsTestsPrefPIDRowStatus, IndexConsistencyTest=IndexConsistencyTest, cableSatPrefInputNumber=cableSatPrefInputNumber, tsTestsPIDState=tsTestsPIDState, aiCSLatestError=aiCSLatestError, outBandEmissLatestError=outBandEmissLatestError, berViterbiSTable=berViterbiSTable, linkAvailabilityEnable=linkAvailabilityEnable, csCSCounterReset=csCSCounterReset, eNFTLPTable=eNFTLPTable, tsTestsPrefSIGapMin=tsTestsPrefSIGapMin, rfAccuracyTestState=rfAccuracyTestState, csCSTable=csCSTable, trapControlEntry=trapControlEntry, terrestrialPrefENDBER=terrestrialPrefENDBER, berViterbiTValue=berViterbiTValue, tsTestsPrefEITSOtherNearTableIntervalMax=tsTestsPrefEITSOtherNearTableIntervalMax, eNDCActiveTime=eNDCActiveTime, systemErrorPerformance=systemErrorPerformance, tsMeasurePrefAllPIDBitRateElement=tsMeasurePrefAllPIDBitRateElement, mipSyntaxTestNumber=mipSyntaxTestNumber, ifSpectrumInputNumber=ifSpectrumInputNumber, eNFTLPLatestError=eNFTLPLatestError, mipSyntaxCounterDiscontinuity=mipSyntaxCounterDiscontinuity, linearityTable=linearityTable, steMeanTCounterDiscontinuity=steMeanTCounterDiscontinuity, qeTTestState=qeTTestState, mipSyntaxTable=mipSyntaxTable, tsServicePerformanceActiveTime=tsServicePerformanceActiveTime, rfIFsignalPowerTestState=rfIFsignalPowerTestState, tsMeasurePreferences=tsMeasurePreferences, tsTestsPrefRSTIntervalMin=tsTestsPrefRSTIntervalMin, noiseMarginInputNumber=noiseMarginInputNumber, noisePowerTable=noisePowerTable, steDeviationCSMeasurementState=steDeviationCSMeasurementState, terrestrialPrefMIPTimingLimit=terrestrialPrefMIPTimingLimit, tsMeasurements=tsMeasurements, capabilityTS=capabilityTS, pjCSTestState=pjCSTestState, csTCounterReset=csTCounterReset, tsServiceBitRateCounter=tsServiceBitRateCounter, capabilityCableTable=capabilityCableTable, tsTransportStreamBitRateTable=tsTransportStreamBitRateTable, tsServiceBitRateInputNumber=tsServiceBitRateInputNumber, merCSEnable=merCSEnable, terrestrialPrefPowerMin=terrestrialPrefPowerMin, tsTestsSummaryTestNumber=tsTestsSummaryTestNumber, tsTestsPrefTxTTableIntervalMax=tsTestsPrefTxTTableIntervalMax, tsPIDBitRateLatestError=tsPIDBitRateLatestError, qeCSEntry=qeCSEntry, tsSPPrefThreshold=tsSPPrefThreshold, terrestrialPrefCentreFreqLimit=terrestrialPrefCentreFreqLimit, snrCSMeasurementState=snrCSMeasurementState, berViterbiSTestState=berViterbiSTestState, noisePowerEnable=noisePowerEnable, terrestrialPrefBERViterbiMax=terrestrialPrefBERViterbiMax, qeTInputNumber=qeTInputNumber, steDeviationCSActiveTime=steDeviationCSActiveTime, tsTestsPIDLatestError=tsTestsPIDLatestError, rfIfPowerCounterReset=rfIfPowerCounterReset, capabilityTSTable=capabilityTSTable, tsTestsPIDEntry=tsTestsPIDEntry, tsConsistencyTestNumber=tsConsistencyTestNumber, tsMeasurePrefPCROJMax=tsMeasurePrefPCROJMax, steMeanTLatestError=steMeanTLatestError, eNFTTestState=eNFTTestState, rteCSCounterReset=rteCSCounterReset, eNDTEntry=eNDTEntry, berRSLPInputNumber=berRSLPInputNumber, Modulation=Modulation, linkAvailabilityRatio=linkAvailabilityRatio, eNDTLPTestState=eNDTLPTestState, tsMeasurePrefPCRDRMax=tsMeasurePrefPCRDRMax, tsTestsPrefSDTActualIntervalMin=tsTestsPrefSDTActualIntervalMin, terrestrialPrefInputNumber=terrestrialPrefInputNumber, linkAvailabilityCounter=linkAvailabilityCounter, tsConsistencyInputNumber=tsConsistencyInputNumber, berViterbiSCounter=berViterbiSCounter, berViterbiTLPEnable=berViterbiTLPEnable, csCSActiveTime=csCSActiveTime, cableSatPrefSteDeviationCSMax=cableSatPrefSteDeviationCSMax, tsTestsPrefPCRIntervalMax=tsTestsPrefPCRIntervalMax, noisePowerInputNumber=noisePowerInputNumber, cableSatPreferencesTable=cableSatPreferencesTable, controlRFSystemEntry=controlRFSystemEntry, steMeanTValue=steMeanTValue, aiCSInputNumber=aiCSInputNumber, capabilitySatelliteTable=capabilitySatelliteTable, estNoiseMarginValue=estNoiseMarginValue, eNFTMeasurementState=eNFTMeasurementState, csCSInputNumber=csCSInputNumber, tsConsistencyState=tsConsistencyState, ciCSActiveTime=ciCSActiveTime, sepSetiInputNumber=sepSetiInputNumber, cableSatPrefQeCSMax=cableSatPrefQeCSMax, capabilityCableSatOID=capabilityCableSatOID, tsPcrMeasurementLatestError=tsPcrMeasurementLatestError, estNoiseMarginEnable=estNoiseMarginEnable, sysAvailabilityLatestError=sysAvailabilityLatestError, iqAnalysisT=iqAnalysisT, tsServicePerformanceError=tsServicePerformanceError, tsPcrMeasurementInputNumber=tsPcrMeasurementInputNumber, tsMeasurePrefServiceBitRateElement=tsMeasurePrefServiceBitRateElement, berRSinServiceCounterDiscontinuity=berRSinServiceCounterDiscontinuity, tsMeasurePreferencesEntry=tsMeasurePreferencesEntry, terrestrialPrefSEPMeasurementInterval=terrestrialPrefSEPMeasurementInterval, berViterbiTCounterReset=berViterbiTCounterReset, noiseMarginActiveTime=noiseMarginActiveTime, tsTestsPIDActiveTime=tsTestsPIDActiveTime, tsMeasurePrefAllServiceBitRateN=tsMeasurePrefAllServiceBitRateN, tsTestsPrefPMTSectionIntervalMax=tsTestsPrefPMTSectionIntervalMax, steDeviationTMeasurementState=steDeviationTMeasurementState, tsMeasurePrefPCRDemarcationFrequency=tsMeasurePrefPCRDemarcationFrequency, tsMeasurePrefTSBitRateTau=tsMeasurePrefTSBitRateTau, groupTraps=groupTraps, tsTestsPrefEITOtherIntervalMax=tsTestsPrefEITOtherIntervalMax, outBandEmissEnable=outBandEmissEnable, berViterbiTTable=berViterbiTTable, Enable=Enable, rfAccuracyValue=rfAccuracyValue, csCSMeasurementState=csCSMeasurementState, capabilityCableSatPollInterval=capabilityCableSatPollInterval, tsConsistencyCounterReset=tsConsistencyCounterReset, capabilityTerrestrialTable=capabilityTerrestrialTable, eNDCLatestError=eNDCLatestError, merCSCounterDiscontinuity=merCSCounterDiscontinuity, eNFTEnable=eNFTEnable, merTCounter=merTCounter, steMeanCSCounter=steMeanCSCounter, UATMode=UATMode, tsTestsPrefEITActualIntervalMin=tsTestsPrefEITActualIntervalMin, ciCSCounterReset=ciCSCounterReset, aiTValue=aiTValue, linearityLatestError=linearityLatestError, steMeanCSCounterDiscontinuity=steMeanCSCounterDiscontinuity, cableSatPrefSignalPowerMax=cableSatPrefSignalPowerMax, rfChannelWidthCounterDiscontinuity=rfChannelWidthCounterDiscontinuity, steDeviationTEntry=steDeviationTEntry, cableSatPrefSysAvailTI=cableSatPrefSysAvailTI, noisePowerActiveTime=noisePowerActiveTime, trapControlPeriod=trapControlPeriod, rteCSValue=rteCSValue, terrestrialPrefQeMax=terrestrialPrefQeMax, tsMeasurePrefPIDBitRateMax=tsMeasurePrefPIDBitRateMax, steMeanCSEntry=steMeanCSEntry, merCSMeasurementState=merCSMeasurementState, snrCSEntry=snrCSEntry, tsTestsPrefNITOtherIntervalMax=tsTestsPrefNITOtherIntervalMax, terrestrialPrefGuardInterval=terrestrialPrefGuardInterval, aiCSEnable=aiCSEnable, steMeanTInputNumber=steMeanTInputNumber, pjCSActiveTime=pjCSActiveTime, terrestrialPrefHierarchical=terrestrialPrefHierarchical, cableSatPrefRteCSMax=cableSatPrefRteCSMax, rfAccuracyInputNumber=rfAccuracyInputNumber, terrestrialPrefTransmissionMode=terrestrialPrefTransmissionMode, rteCSEnable=rteCSEnable, tsConsistencyTable=tsConsistencyTable, tsTransportStreamBitRateValue=tsTransportStreamBitRateValue, rteCSLatestError=rteCSLatestError, berRSCounter=berRSCounter, ServiceId=ServiceId, tsMeasurePreferencesPIDTable=tsMeasurePreferencesPIDTable, trapControlTable=trapControlTable, tsTransportStreamBitRateCounterReset=tsTransportStreamBitRateCounterReset, outBandEmissTable=outBandEmissTable, linearityInputNumber=linearityInputNumber, berRSLPEnable=berRSLPEnable, capabilitySatellite=capabilitySatellite, terrestrialPrefChannelWidthLimit=terrestrialPrefChannelWidthLimit, complianceTerrestrial=complianceTerrestrial, aiCSCounter=aiCSCounter, steCS=steCS, sysAvailabilityEnable=sysAvailabilityEnable, noisePowerValue=noisePowerValue, estNoiseMarginLatestError=estNoiseMarginLatestError, berRSEntry=berRSEntry, tsPIDBitRateNomenclature=tsPIDBitRateNomenclature, tsTestsPIDInputNumber=tsTestsPIDInputNumber, rfIFsignalPowerLatestError=rfIFsignalPowerLatestError, eNDCCounterReset=eNDCCounterReset, tsTestsPrefPIDInputNumber=tsTestsPrefPIDInputNumber, tsServicePerformanceInputNumber=tsServicePerformanceInputNumber, sepSetiEntry=sepSetiEntry, capabilityCableSatTable=capabilityCableSatTable, berRSTestState=berRSTestState, tsPcrMeasurementActiveTime=tsPcrMeasurementActiveTime, merCSInputNumber=merCSInputNumber, merCSCounter=merCSCounter, noiseMarginMeasurementState=noiseMarginMeasurementState, rfTerr=rfTerr, tsTestsSummaryActiveTime=tsTestsSummaryActiveTime, berViterbiTLPInputNumber=berViterbiTLPInputNumber, eNFTLPEntry=eNFTLPEntry, tsServicePerformancePreferencesEntry=tsServicePerformancePreferencesEntry, rfIfPowerCounter=rfIfPowerCounter, measurementUnknownTrap=measurementUnknownTrap, aiCSEntry=aiCSEntry, cableSatPrefLinkAvailN=cableSatPrefLinkAvailN, terrestrialPrefENDMax=terrestrialPrefENDMax, linkAvailabilityInputNumber=linkAvailabilityInputNumber, aiTEntry=aiTEntry, IndexMIPSyntaxTest=IndexMIPSyntaxTest, berViterbiTLPTestState=berViterbiTLPTestState, merTCounterDiscontinuity=merTCounterDiscontinuity, tsTestsPIDPID=tsTestsPIDPID, berRSinServiceLatestError=berRSinServiceLatestError, ciCSValue=ciCSValue, csTTestState=csTTestState, capabilityCableSatEntry=capabilityCableSatEntry, steDeviationTActiveTime=steDeviationTActiveTime, pjTCounterDiscontinuity=pjTCounterDiscontinuity, symbolLengthEnable=symbolLengthEnable, capabilityCablePollInterval=capabilityCablePollInterval, terrestrialPrefENFIdeal=terrestrialPrefENFIdeal, tsMeasurePreferencesTable=tsMeasurePreferencesTable, symbolLengthEntry=symbolLengthEntry, capabilityTerrestrialOID=capabilityTerrestrialOID, berViterbiTLPLatestError=berViterbiTLPLatestError, terrestrialPrefENDLPIdeal=terrestrialPrefENDLPIdeal, qeTLatestError=qeTLatestError, ifSpectrumEntry=ifSpectrumEntry)
mibBuilder.exportSymbols("DVB-MGTR101290-MIB", sepEtiInputNumber=sepEtiInputNumber, cableSatPrefSysAvailUATMode=cableSatPrefSysAvailUATMode, eNFTLPTestState=eNFTLPTestState, aiCSTestState=aiCSTestState, capabilityTSOID=capabilityTSOID, tsServicePerformancePreferencesTable=tsServicePerformancePreferencesTable, cableSatPrefNoisePowerMax=cableSatPrefNoisePowerMax, berRSinServiceInputNumber=berRSinServiceInputNumber, BERMeasurementMethod=BERMeasurementMethod, eNFTLPCounter=eNFTLPCounter, tsTransportStreamBitRateNomenclature=tsTransportStreamBitRateNomenclature, terrestrialPrefSEPUATMode=terrestrialPrefSEPUATMode, merTInputNumber=merTInputNumber, tsTestsPrefInputNumber=tsTestsPrefInputNumber, berRSinServiceMeasurementState=berRSinServiceMeasurementState, noisePowerEntry=noisePowerEntry, tsPIDBitRateActiveTime=tsPIDBitRateActiveTime, steDeviationTValue=steDeviationTValue, estNoiseMarginTable=estNoiseMarginTable, capabilityTSEntry=capabilityTSEntry, rfChannelWidthInputNumber=rfChannelWidthInputNumber, outBandEmissTestState=outBandEmissTestState, aiTCounterDiscontinuity=aiTCounterDiscontinuity, ciCSCounterDiscontinuity=ciCSCounterDiscontinuity, aiTCounterReset=aiTCounterReset, pjTCounterReset=pjTCounterReset, merCSActiveTime=merCSActiveTime, rfIfSpectrumTable=rfIfSpectrumTable, GroupAvailability=GroupAvailability, controlRFSystemTable=controlRFSystemTable, eNFTActiveTime=eNFTActiveTime, steDeviationCSTestState=steDeviationCSTestState, rfIfSpectrumInputNumber=rfIfSpectrumInputNumber, sepEtiActiveTime=sepEtiActiveTime, rfChannelWidthActiveTime=rfChannelWidthActiveTime, rfIFsignalPowerCounterReset=rfIFsignalPowerCounterReset, rteCSCounterDiscontinuity=rteCSCounterDiscontinuity, cableSatPrefAiCSMax=cableSatPrefAiCSMax, rfAccuracyEnable=rfAccuracyEnable, trapControlOID=trapControlOID, capabilityTerrestrialEntry=capabilityTerrestrialEntry, berViterbiSActiveTime=berViterbiSActiveTime, capabilityTSAvailability=capabilityTSAvailability, tsPcrMeasurementValue=tsPcrMeasurementValue, tsMeasurePrefInputNumber=tsMeasurePrefInputNumber, tsTestsSummaryCounterDiscontinuity=tsTestsSummaryCounterDiscontinuity, mipSyntaxLatestError=mipSyntaxLatestError, csTInputNumber=csTInputNumber, trapInput=trapInput, rfAccuracyEntry=rfAccuracyEntry, controlSynchronizedTime=controlSynchronizedTime, linkAvailabilityCounterDiscontinuity=linkAvailabilityCounterDiscontinuity, cableSatPrefCentreFrequency=cableSatPrefCentreFrequency, rfIfPowerInputNumber=rfIfPowerInputNumber, steMeanTTable=steMeanTTable, rfSystemInputNumber=rfSystemInputNumber, berViterbiTTestState=berViterbiTTestState, tsPIDBitRateMeasurementState=tsPIDBitRateMeasurementState, capabilitySatelliteEntry=capabilitySatelliteEntry, terrestrialPrefSEPN=terrestrialPrefSEPN, controlSynchronizationInputNumber=controlSynchronizationInputNumber, terrestrialPrefENFLPMax=terrestrialPrefENFLPMax, pjTEntry=pjTEntry, tsPIDBitRateCounterReset=tsPIDBitRateCounterReset, tsTransportStreamBitRateState=tsTransportStreamBitRateState, rfIfPowerEnable=rfIfPowerEnable, pjTTestState=pjTTestState, eNDCEnable=eNDCEnable, tsMeasurePreferencesServiceEntry=tsMeasurePreferencesServiceEntry, tsServicePerformanceNumber=tsServicePerformanceNumber, qeCSTestState=qeCSTestState, tsServicePerformanceErrorRatio=tsServicePerformanceErrorRatio, PYSNMP_MODULE_ID=tr101290, tsTestsSummaryCounterReset=tsTestsSummaryCounterReset, trapControlRateStatus=trapControlRateStatus, berViterbiTCounter=berViterbiTCounter, tsTestsPreferencesPIDEntry=tsTestsPreferencesPIDEntry, linearityCounterDiscontinuity=linearityCounterDiscontinuity, pjTTable=pjTTable, sepSetiMeasurementState=sepSetiMeasurementState, rfIfSpectrumCounter=rfIfSpectrumCounter, rfChannelWidthLatestError=rfChannelWidthLatestError, eNDTCounterReset=eNDTCounterReset, FloatingPoint=FloatingPoint, eNDTLPCounter=eNDTLPCounter, terrestrialPrefBERRSLPMax=terrestrialPrefBERRSLPMax, rfAccuracyCounterDiscontinuity=rfAccuracyCounterDiscontinuity, terrestrialPrefBandwidth=terrestrialPrefBandwidth, tsTestsPrefTDTIntervalMax=tsTestsPrefTDTIntervalMax, groupTransportStream=groupTransportStream, tsTestsSummaryEnable=tsTestsSummaryEnable, outBandEmissActiveTime=outBandEmissActiveTime, rfIFsignalPowerCounter=rfIFsignalPowerCounter, eNDCValue=eNDCValue, snrCSActiveTime=snrCSActiveTime, eNFTLPInputNumber=eNFTLPInputNumber, groupSatellite=groupSatellite, cableSatPreferencesEntry=cableSatPreferencesEntry, outBandEmissCounter=outBandEmissCounter, steDeviationTCounter=steDeviationTCounter, signQualMarTLatestError=signQualMarTLatestError, steDeviationTCounterReset=steDeviationTCounterReset, tsMeasurePrefServiceRowStatus=tsMeasurePrefServiceRowStatus, eNFTLatestError=eNFTLatestError, tsMeasurePrefAllPIDBitRateN=tsMeasurePrefAllPIDBitRateN, pjCSCounter=pjCSCounter, IndexPCRMeasurement=IndexPCRMeasurement, outBandEmissCounterReset=outBandEmissCounterReset, tsTestsPrefNITActualIntervalMin=tsTestsPrefNITActualIntervalMin, ciCSLatestError=ciCSLatestError, snrCSInputNumber=snrCSInputNumber, berRSLPEntry=berRSLPEntry, pjTInputNumber=pjTInputNumber, tsTestsSummaryTable=tsTestsSummaryTable, qeCSLatestError=qeCSLatestError, tsTransportStreamBitRateActiveTime=tsTransportStreamBitRateActiveTime, berRSCounterDiscontinuity=berRSCounterDiscontinuity, tsServiceBitRateEntry=tsServiceBitRateEntry, aiTCounter=aiTCounter, tsConsistencyEnable=tsConsistencyEnable, snrCSTestState=snrCSTestState, pjCSCounterReset=pjCSCounterReset, tsTestsPrefPCRDiscontinuityMax=tsTestsPrefPCRDiscontinuityMax, Hierarchy=Hierarchy, symbolLengthLatestError=symbolLengthLatestError, csTCounter=csTCounter, csTCounterDiscontinuity=csTCounterDiscontinuity, cablePreferencesTable=cablePreferencesTable, rfSystemDelivery=rfSystemDelivery, tsMeasurePrefTSBitRateElement=tsMeasurePrefTSBitRateElement, steDeviationCSLatestError=steDeviationCSLatestError, noiseMarginCounterReset=noiseMarginCounterReset, DeliverySystemType=DeliverySystemType, terrestrialPrefENFLPIdeal=terrestrialPrefENFLPIdeal, eNFTEntry=eNFTEntry, symbolLengthInputNumber=symbolLengthInputNumber, csTLatestError=csTLatestError, aiTActiveTime=aiTActiveTime, rfIfPowerEntry=rfIfPowerEntry, terrestrialPrefMerTMin=terrestrialPrefMerTMin, eNDTLPEntry=eNDTLPEntry, cableSatPrefCsCSMin=cableSatPrefCsCSMin, tsTransportStreamBitRateMeasurementState=tsTransportStreamBitRateMeasurementState, complianceTransportStream=complianceTransportStream, capabilityCableSatGroup=capabilityCableSatGroup, tsMeasurePrefServiceInputNumber=tsMeasurePrefServiceInputNumber, eNDTLatestError=eNDTLatestError, tsTestsPrefPIDPID=tsTestsPrefPIDPID, tsPcrMeasurementTable=tsPcrMeasurementTable, tsTestsPIDCounterDiscontinuity=tsTestsPIDCounterDiscontinuity, tsTestsPrefBATTableIntervalMax=tsTestsPrefBATTableIntervalMax, steDeviationCSCounterDiscontinuity=steDeviationCSCounterDiscontinuity, tsMeasurePrefExpectedTSID=tsMeasurePrefExpectedTSID, steT=steT, sepEtiCounterReset=sepEtiCounterReset, tsMeasurePrefPIDInputNumber=tsMeasurePrefPIDInputNumber, ciCSEnable=ciCSEnable, signQualMarTEnable=signQualMarTEnable, steDeviationTInputNumber=steDeviationTInputNumber, tsTestsPrefSDTActualTableIntervalMax=tsTestsPrefSDTActualTableIntervalMax, csCSLatestError=csCSLatestError, capabilitySatelliteOID=capabilitySatelliteOID, RateStatus=RateStatus, eNDT=eNDT, steDeviationCSValue=steDeviationCSValue, symbolLengthMeasurementState=symbolLengthMeasurementState, rfIfPowerMeasurementState=rfIfPowerMeasurementState, mipSyntaxEntry=mipSyntaxEntry, eNDTInputNumber=eNDTInputNumber, terrestrialPrefSEPM=terrestrialPrefSEPM, cablePrefNoiseMarginMin=cablePrefNoiseMarginMin, berRSinServiceValue=berRSinServiceValue, pjCSTable=pjCSTable, noisePowerLatestError=noisePowerLatestError, sepSetiActiveTime=sepSetiActiveTime, symbolLengthActiveTime=symbolLengthActiveTime, aiTTable=aiTTable, PollingInterval=PollingInterval, tr101290Cable=tr101290Cable, merCSEntry=merCSEntry, berViterbiTLPCounterReset=berViterbiTLPCounterReset, trapControlInputNumber=trapControlInputNumber, sepEtiEntry=sepEtiEntry, linearityEnable=linearityEnable, snrCSCounterReset=snrCSCounterReset, eNDTLPMeasurementState=eNDTLPMeasurementState, berViterbiTLatestError=berViterbiTLatestError, trapControlGenerationTime=trapControlGenerationTime, tsMeasurePrefPIDPID=tsMeasurePrefPIDPID, tsPIDBitRateInputNumber=tsPIDBitRateInputNumber, tsConsistencyCounter=tsConsistencyCounter, tsMeasurePrefServiceBitRateMin=tsMeasurePrefServiceBitRateMin, satellitePreferencesEntry=satellitePreferencesEntry, groupCapability=groupCapability, tr101290ObjectGroups=tr101290ObjectGroups, mipSyntaxCounterReset=mipSyntaxCounterReset, eNDTTable=eNDTTable, terrestrialPrefPjMax=terrestrialPrefPjMax, csCSEnable=csCSEnable, tsServiceBitRateTable=tsServiceBitRateTable, capabilityCableEntry=capabilityCableEntry, ciCSMeasurementState=ciCSMeasurementState, sepEtiLatestError=sepEtiLatestError, TransportStreamID=TransportStreamID, tsServicePerformanceMeasurementState=tsServicePerformanceMeasurementState, pjTValue=pjTValue, steMeanCSTable=steMeanCSTable, terrestrialPrefMIPDeviationMax=terrestrialPrefMIPDeviationMax, tsSPPrefInputNumber=tsSPPrefInputNumber, steDeviationCSInputNumber=steDeviationCSInputNumber, tsConsistencyActiveTime=tsConsistencyActiveTime, ciCSInputNumber=ciCSInputNumber, qeCSTable=qeCSTable, cableSatPrefLinkAvailTotalTime=cableSatPrefLinkAvailTotalTime, steMeanTMeasurementState=steMeanTMeasurementState, tsTestsSummaryEntry=tsTestsSummaryEntry, steDeviationTTable=steDeviationTTable, qeTActiveTime=qeTActiveTime, berViterbiTInputNumber=berViterbiTInputNumber, mipSyntaxEnable=mipSyntaxEnable, steMeanCSValue=steMeanCSValue, linearityActiveTime=linearityActiveTime, berViterbiSCounterDiscontinuity=berViterbiSCounterDiscontinuity, controlEventPersistence=controlEventPersistence, tsTestsPrefEITSOtherFarTableIntervalMax=tsTestsPrefEITSOtherFarTableIntervalMax, berViterbiTLPMeasurementState=berViterbiTLPMeasurementState, tsTestsPrefSDTOtherIntervalMax=tsTestsPrefSDTOtherIntervalMax, terrestrialPreferencesTable=terrestrialPreferencesTable, cablePrefSignQualPercentMax=cablePrefSignQualPercentMax, rfIFsignalPowerEntry=rfIFsignalPowerEntry, testFailTrap=testFailTrap, tsPcrMeasurementCounterDiscontinuity=tsPcrMeasurementCounterDiscontinuity, eNFTTable=eNFTTable, signQualMarTCounter=signQualMarTCounter, merCSValue=merCSValue, sysAvailabilityUnavailableTime=sysAvailabilityUnavailableTime, rfIFsignalPowerMeasurementState=rfIFsignalPowerMeasurementState, symbolLengthCounterReset=symbolLengthCounterReset, eNDCTable=eNDCTable, berViterbiSMeasurementMethod=berViterbiSMeasurementMethod, groupTrapControl=groupTrapControl, tsTransportStreamBitRateEntry=tsTransportStreamBitRateEntry, tsSPPrefEvaluationTime=tsSPPrefEvaluationTime, tsServicePerformanceTable=tsServicePerformanceTable, berRSValue=berRSValue, BitRateElement=BitRateElement, cableSatPrefSnrCSMin=cableSatPrefSnrCSMin, terrestrialPrefSteMeanMax=terrestrialPrefSteMeanMax, tsMeasurePrefTSBitRateMax=tsMeasurePrefTSBitRateMax, tsTestsPrefPIDReferredIntervalMax=tsTestsPrefPIDReferredIntervalMax, steDeviationTEnable=steDeviationTEnable, sysAvailabilityInputNumber=sysAvailabilityInputNumber, eNDTActiveTime=eNDTActiveTime, capabilitySatelliteAvailability=capabilitySatelliteAvailability)
mibBuilder.exportSymbols("DVB-MGTR101290-MIB", tr101290TS=tr101290TS, steMeanCSMeasurementState=steMeanCSMeasurementState, steMeanTEnable=steMeanTEnable, rfIFsignalPowerEnable=rfIFsignalPowerEnable, berRSLPCounterDiscontinuity=berRSLPCounterDiscontinuity, steDeviationCSCounter=steDeviationCSCounter, berViterbiTEnable=berViterbiTEnable, eNDCEntry=eNDCEntry, tsServiceBitRateMeasurementState=tsServiceBitRateMeasurementState, cableSatPrefSysAvailTotalTime=cableSatPrefSysAvailTotalTime, ActiveTime=ActiveTime, eNDTMeasurementState=eNDTMeasurementState, berViterbiTLPCounter=berViterbiTLPCounter, noiseMarginCounterDiscontinuity=noiseMarginCounterDiscontinuity, tsTestsPreferencesPIDTable=tsTestsPreferencesPIDTable, eNFTLPMeasurementState=eNFTLPMeasurementState, eNFTInputNumber=eNFTInputNumber, tsPIDBitRateRowStatus=tsPIDBitRateRowStatus, terrestrialPrefBERViterbiLPMax=terrestrialPrefBERViterbiLPMax, eNDTLPLatestError=eNDTLPLatestError, rteCSInputNumber=rteCSInputNumber, merCSTestState=merCSTestState, sepEtiMeasurementState=sepEtiMeasurementState, IndexServicePerformance=IndexServicePerformance, mipSyntaxCounter=mipSyntaxCounter, cableSatPrefSysAvailN=cableSatPrefSysAvailN, tsTestsSummaryLatestError=tsTestsSummaryLatestError, sysAvailabilityMeasurementState=sysAvailabilityMeasurementState, sysAvailabilityInSETI=sysAvailabilityInSETI, InputNumber=InputNumber, mipSyntaxState=mipSyntaxState, linkAvailabilityLatestError=linkAvailabilityLatestError, pjCSLatestError=pjCSLatestError, linearityEntry=linearityEntry, terrestrialPrefENDLPMax=terrestrialPrefENDLPMax, linearityValue=linearityValue, terrestrialPrefCentreFreqExpected=terrestrialPrefCentreFreqExpected, MeasurementState=MeasurementState, tsPcrMeasurementEntry=tsPcrMeasurementEntry, linkAvailabilityUnavailableTime=linkAvailabilityUnavailableTime, berRSinServiceTestState=berRSinServiceTestState, tsConsistencyEntry=tsConsistencyEntry, sepEtiCounter=sepEtiCounter, noisePowerCounterReset=noisePowerCounterReset, cableSatPrefLinkAvailM=cableSatPrefLinkAvailM, estNoiseMarginEntry=estNoiseMarginEntry, symbolLengthTable=symbolLengthTable, linearityTestState=linearityTestState, qeCSCounterReset=qeCSCounterReset, noisePowerTestState=noisePowerTestState, eNDTLPInputNumber=eNDTLPInputNumber, berRSLPMeasurementState=berRSLPMeasurementState, aiTLatestError=aiTLatestError, estNoiseMarginCounter=estNoiseMarginCounter, bitRate=bitRate, rteCSCounter=rteCSCounter, tsTestsPrefEITSActualFarTableIntervalMax=tsTestsPrefEITSActualFarTableIntervalMax, cableSatPrefSysAvailT=cableSatPrefSysAvailT, capabilityTerrestrialPollInterval=capabilityTerrestrialPollInterval, qeCSMeasurementState=qeCSMeasurementState, measurementFailTrap=measurementFailTrap, linkAvailabilityMeasurementState=linkAvailabilityMeasurementState, qeTEntry=qeTEntry, tsTestsPrefReferredIntervalMax=tsTestsPrefReferredIntervalMax, rfChannelWidthCounter=rfChannelWidthCounter, outBandEmissInputNumber=outBandEmissInputNumber, estNoiseMarginCounterReset=estNoiseMarginCounterReset, pjCSValue=pjCSValue, berViterbiSIValue=berViterbiSIValue, tsServicePerformanceLatestError=tsServicePerformanceLatestError, steMeanTActiveTime=steMeanTActiveTime, noiseMarginEntry=noiseMarginEntry, rfIfPowerValue=rfIfPowerValue, qeTEnable=qeTEnable, sepEtiCounterDiscontinuity=sepEtiCounterDiscontinuity, tsTestsPrefNITActualIntervalMax=tsTestsPrefNITActualIntervalMax, rfIFsignalPowerTable=rfIFsignalPowerTable, tr101290Compliances=tr101290Compliances, sepSetiValue=sepSetiValue, rfAccuracyTable=rfAccuracyTable, tsTransportStreamBitRateCounter=tsTransportStreamBitRateCounter, tsTestsPrefPTSIntervalMax=tsTestsPrefPTSIntervalMax, tsPcrMeasurementMeasurementState=tsPcrMeasurementMeasurementState, rfIFsignalPowerValue=rfIFsignalPowerValue, symbolLengthValue=symbolLengthValue, tr101290CableSat=tr101290CableSat, rfIfSpectrumTestState=rfIfSpectrumTestState, terrestrialPrefCsMin=terrestrialPrefCsMin, berRSinServiceCounterReset=berRSinServiceCounterReset, tsServiceBitRateValue=tsServiceBitRateValue, berRSTable=berRSTable, tsTestsSummaryState=tsTestsSummaryState, csCSValue=csCSValue, tsSPPrefNumber=tsSPPrefNumber, tsPIDBitRateEntry=tsPIDBitRateEntry, cablePrefENDCtoNSpecified=cablePrefENDCtoNSpecified, aiCSTable=aiCSTable, ifSpectrumTable=ifSpectrumTable, berRSCounterReset=berRSCounterReset, trapPrefix=trapPrefix, rfIfSpectrumCounterReset=rfIfSpectrumCounterReset, tsPcrMeasurementPID=tsPcrMeasurementPID, steMeanCSTestState=steMeanCSTestState, groupCable=groupCable, tsServicePerformanceCounter=tsServicePerformanceCounter, capabilityTerrestrial=capabilityTerrestrial, csCSEntry=csCSEntry, rfAccuracyLatestError=rfAccuracyLatestError, mipSyntaxInputNumber=mipSyntaxInputNumber, sepSetiCounterDiscontinuity=sepSetiCounterDiscontinuity, trapControlMeasurementValue=trapControlMeasurementValue, berRSLPValue=berRSLPValue, steDeviationTTestState=steDeviationTTestState, snrCSCounter=snrCSCounter, eNDTCounterDiscontinuity=eNDTCounterDiscontinuity, snrCSTable=snrCSTable, berRSLPCounter=berRSLPCounter, rteCSTable=rteCSTable, linkAvailabilityInSUTI=linkAvailabilityInSUTI, terrestrialPrefBERRSMax=terrestrialPrefBERRSMax, cablePrefENDBER=cablePrefENDBER, berViterbiSInputNumber=berViterbiSInputNumber, eNDTTestState=eNDTTestState, ifSpectrumEnable=ifSpectrumEnable, steMeanCSInputNumber=steMeanCSInputNumber, tsPIDBitRateValue=tsPIDBitRateValue, capabilityMIBRevision=capabilityMIBRevision, tsMeasurePrefAllServiceBitRateTau=tsMeasurePrefAllServiceBitRateTau, terrestrialPrefLinearityMin=terrestrialPrefLinearityMin, tsTestsPIDCounterReset=tsTestsPIDCounterReset, controlSynchronizationEntry=controlSynchronizationEntry, berViterbiSEntry=berViterbiSEntry, rfAccuracyMeasurementState=rfAccuracyMeasurementState, pjTEnable=pjTEnable, terrestrialPrefSymbolLengthLimit=terrestrialPrefSymbolLengthLimit, sysAvailabilityCounterReset=sysAvailabilityCounterReset, steMeanTEntry=steMeanTEntry, sysAvailabilityTestState=sysAvailabilityTestState, aiTTestState=aiTTestState, sepEtiTestState=sepEtiTestState, tsTestsPrefPCRInaccuracyMax=tsTestsPrefPCRInaccuracyMax, noiseMarginTestState=noiseMarginTestState, berViterbiSQValue=berViterbiSQValue, ifSpectrumCounter=ifSpectrumCounter, snrCSLatestError=snrCSLatestError, estNoiseMarginTestState=estNoiseMarginTestState, tsTransportStreamBitRateLatestError=tsTransportStreamBitRateLatestError, tsMeasurePrefPIDBitRateN=tsMeasurePrefPIDBitRateN, steDeviationCSTable=steDeviationCSTable, tsMeasurePrefServiceBitRateTau=tsMeasurePrefServiceBitRateTau, tsTestsPrefNITTableIntervalMax=tsTestsPrefNITTableIntervalMax, tr101290Capability=tr101290Capability, tsTestsPIDRowStatus=tsTestsPIDRowStatus, tsMeasurePrefServiceBitRateN=tsMeasurePrefServiceBitRateN, pjCSInputNumber=pjCSInputNumber, terrestrialPrefCentreFrequency=terrestrialPrefCentreFrequency, terrestrialPrefAiMax=terrestrialPrefAiMax, tsTransportStreamBitRateCounterDiscontinuity=tsTransportStreamBitRateCounterDiscontinuity, berViterbiSEnable=berViterbiSEnable, berViterbiTLPValue=berViterbiTLPValue, berRSLPActiveTime=berRSLPActiveTime, csCSTestState=csCSTestState, rfChannelWidthTable=rfChannelWidthTable, tr101290=tr101290, eNFTCounterReset=eNFTCounterReset, berRSLPTable=berRSLPTable, tsTestsPrefSDTOtherTableIntervalMax=tsTestsPrefSDTOtherTableIntervalMax, cableSatPrefPjCSMax=cableSatPrefPjCSMax, berRS=berRS, estNoiseMarginInputNumber=estNoiseMarginInputNumber, eNDTEnable=eNDTEnable, eNDTLPActiveTime=eNDTLPActiveTime, sepSetiCounter=sepSetiCounter, capabilityCableSat=capabilityCableSat, Availability=Availability, TestState=TestState, satellitePreferencesTable=satellitePreferencesTable, tsTestsPIDCounter=tsTestsPIDCounter, berViterbiSMeasurementState=berViterbiSMeasurementState, aiTInputNumber=aiTInputNumber, capabilityCableAvailability=capabilityCableAvailability, tsPIDBitRateCounterDiscontinuity=tsPIDBitRateCounterDiscontinuity, eNFTCounterDiscontinuity=eNFTCounterDiscontinuity, tsTestsPrefTDTIntervalMin=tsTestsPrefTDTIntervalMin, ciCSEntry=ciCSEntry, tsServiceBitRateActiveTime=tsServiceBitRateActiveTime, snrCSValue=snrCSValue, terrestrialPrefPowerMax=terrestrialPrefPowerMax, steDeviationTCounterDiscontinuity=steDeviationTCounterDiscontinuity, noiseMarginValue=noiseMarginValue, tsServiceBitRateLatestError=tsServiceBitRateLatestError, tsServiceBitRateService=tsServiceBitRateService, signQualMarTCounterDiscontinuity=signQualMarTCounterDiscontinuity, groupTerrestrial=groupTerrestrial, signQualMarTCounterReset=signQualMarTCounterReset, PIDPlusOne=PIDPlusOne, rfIFsignalPowerActiveTime=rfIFsignalPowerActiveTime, snrCSEnable=snrCSEnable, tsMeasurePreferencesPIDEntry=tsMeasurePreferencesPIDEntry, rfChannelWidthCounterReset=rfChannelWidthCounterReset, linkAvailabilityActiveTime=linkAvailabilityActiveTime, tr101290Terrestrial=tr101290Terrestrial, tsMeasurePrefTSBitRateMin=tsMeasurePrefTSBitRateMin, tsServiceBitRateRowStatus=tsServiceBitRateRowStatus, tsServiceBitRateEnable=tsServiceBitRateEnable, eNDCMeasurementState=eNDCMeasurementState, satellitePrefBERMax=satellitePrefBERMax, signQualMarTTable=signQualMarTTable, csTEntry=csTEntry, ifSpectrumLatestError=ifSpectrumLatestError, rfAccuracyCounterReset=rfAccuracyCounterReset, tsTestsPreferencesTable=tsTestsPreferencesTable, sepSetiTestState=sepSetiTestState, linkAvailabilityCounterReset=linkAvailabilityCounterReset, rfChannelWidthTestState=rfChannelWidthTestState, tsTestsSummaryCounter=tsTestsSummaryCounter, sysAvailabilityCounterDiscontinuity=sysAvailabilityCounterDiscontinuity, cablePreferencesEntry=cablePreferencesEntry, berViterbiTEntry=berViterbiTEntry, tsPIDBitRateEnable=tsPIDBitRateEnable, steMeanCSCounterReset=steMeanCSCounterReset, berRSInputNumber=berRSInputNumber, merTLatestError=merTLatestError, TerrestrialTransmissionMode=TerrestrialTransmissionMode, sepEtiEnable=sepEtiEnable, linkAvailabilityTestState=linkAvailabilityTestState, eNFTValue=eNFTValue, tsPIDBitRatePID=tsPIDBitRatePID, rfIfSpectrumEnable=rfIfSpectrumEnable, berViterbiTLPTable=berViterbiTLPTable, cableSatPrefLinkAvailUPPerCent=cableSatPrefLinkAvailUPPerCent, GuardInterval=GuardInterval, tsTestsPrefPATSectionIntervalMax=tsTestsPrefPATSectionIntervalMax, eNDTLPValue=eNDTLPValue, eNDCCounter=eNDCCounter, aiCSCounterDiscontinuity=aiCSCounterDiscontinuity, aiCSActiveTime=aiCSActiveTime, groupControl=groupControl, merCSCounterReset=merCSCounterReset, berViterbiSLatestError=berViterbiSLatestError, merTEnable=merTEnable, aiCSMeasurementState=aiCSMeasurementState, merTActiveTime=merTActiveTime, pjCSMeasurementState=pjCSMeasurementState, qeTCounterDiscontinuity=qeTCounterDiscontinuity, tr101290Objects=tr101290Objects, csTTable=csTTable, tsTestsPrefEITSActualNearTableIntervalMax=tsTestsPrefEITSActualNearTableIntervalMax, eNFTLPCounterReset=eNFTLPCounterReset, tsMeasurePrefPIDBitRateTau=tsMeasurePrefPIDBitRateTau, capabilityCableSatAvailability=capabilityCableSatAvailability, berRSinServiceActiveTime=berRSinServiceActiveTime, ifSpectrumActiveTime=ifSpectrumActiveTime, tsServicePerformanceCounterReset=tsServicePerformanceCounterReset)
mibBuilder.exportSymbols("DVB-MGTR101290-MIB", eNDCTestState=eNDCTestState, noiseMarginTable=noiseMarginTable, outBandEmissCounterDiscontinuity=outBandEmissCounterDiscontinuity, eNFTLPValue=eNFTLPValue, eNFTLPCounterDiscontinuity=eNFTLPCounterDiscontinuity, csTValue=csTValue, rfChannelWidthEntry=rfChannelWidthEntry, ifSpectrumTestState=ifSpectrumTestState, terrestrialPrefSEPTI=terrestrialPrefSEPTI, iqAnalysisCS=iqAnalysisCS, dvb=dvb, capabilityCableOID=capabilityCableOID, eNFTLPEnable=eNFTLPEnable, tsMeasurePrefServiceService=tsMeasurePrefServiceService, tr101290Satellite=tr101290Satellite, signQualMarTTestState=signQualMarTTestState, trapControlFailureSummary=trapControlFailureSummary, qeTCounter=qeTCounter, IndexTransportStreamTest=IndexTransportStreamTest, tsTestsPreferencesEntry=tsTestsPreferencesEntry, berViterbiTLPActiveTime=berViterbiTLPActiveTime, tsTransportStreamBitRateEnable=tsTransportStreamBitRateEnable, tsPIDBitRateCounter=tsPIDBitRateCounter, cablePrefSignQualBoxSize=cablePrefSignQualBoxSize, csTEnable=csTEnable, sepSetiCounterReset=sepSetiCounterReset, qeCSCounter=qeCSCounter, cableSatPrefLinkAvailTI=cableSatPrefLinkAvailTI, terrestrialPrefModulation=terrestrialPrefModulation, complianceSatellite=complianceSatellite, rteCSMeasurementState=rteCSMeasurementState, steMeanTTestState=steMeanTTestState, tsTestsPrefEITPFOtherTableIntervalMax=tsTestsPrefEITPFOtherTableIntervalMax, mipSyntaxActiveTime=mipSyntaxActiveTime, rfIfPowerTestState=rfIfPowerTestState, cableSatPrefSysAvailEBPerCent=cableSatPrefSysAvailEBPerCent, complianceCable=complianceCable, berRSLatestError=berRSLatestError, eNDTLPCounterReset=eNDTLPCounterReset, qeTMeasurementState=qeTMeasurementState, symbolLengthTestState=symbolLengthTestState, tsTestsPIDEnable=tsTestsPIDEnable, rfAccuracyCounter=rfAccuracyCounter, linearityMeasurementState=linearityMeasurementState, tsServicePerformance=tsServicePerformance, rteCSTestState=rteCSTestState, tsMeasurePrefTSBitRateN=tsMeasurePrefTSBitRateN, eNDTLPCounterDiscontinuity=eNDTLPCounterDiscontinuity, pjTCounter=pjTCounter, merCSTable=merCSTable, rfIFsignalPowerCounterDiscontinuity=rfIFsignalPowerCounterDiscontinuity, tsTestsPrefTransitionDuration=tsTestsPrefTransitionDuration, ciCSTable=ciCSTable, pjTLatestError=pjTLatestError, sysAvailabilityCounter=sysAvailabilityCounter, pjCSCounterDiscontinuity=pjCSCounterDiscontinuity, qeTTable=qeTTable, tsServiceBitRateCounterDiscontinuity=tsServiceBitRateCounterDiscontinuity, tsConsistencyCounterDiscontinuity=tsConsistencyCounterDiscontinuity, cableSatPrefSysAvailM=cableSatPrefSysAvailM, eNDCCounterDiscontinuity=eNDCCounterDiscontinuity, tsServicePerformanceCounterDiscontinuity=tsServicePerformanceCounterDiscontinuity, merTValue=merTValue, capabilitySatelliteGroup=capabilitySatelliteGroup, tsMeasurePrefAllServiceBitRateElement=tsMeasurePrefAllServiceBitRateElement, rteCSEntry=rteCSEntry, estNoiseMarginCounterDiscontinuity=estNoiseMarginCounterDiscontinuity, eNDTCounter=eNDTCounter, eNDTLPTable=eNDTLPTable, pjTMeasurementState=pjTMeasurementState, aiCSCounterReset=aiCSCounterReset, tsTestsPrefSDTActualIntervalMax=tsTestsPrefSDTActualIntervalMax, pjCSEntry=pjCSEntry, cableSatPrefSignalPowerMin=cableSatPrefSignalPowerMin, steDeviationTLatestError=steDeviationTLatestError, berRSinServiceEnable=berRSinServiceEnable, signQualMarTActiveTime=signQualMarTActiveTime, eNFTCounter=eNFTCounter, linearityCounter=linearityCounter, qeCSValue=qeCSValue, steMeanCSEnable=steMeanCSEnable, steMeanTCounterReset=steMeanTCounterReset, noisePowerCounterDiscontinuity=noisePowerCounterDiscontinuity, steDeviationCSEnable=steDeviationCSEnable, merTMeasurementState=merTMeasurementState, merCSLatestError=merCSLatestError, noiseMarginCounter=noiseMarginCounter, pjTActiveTime=pjTActiveTime, outBandEmissEntry=outBandEmissEntry, sepSetiEnable=sepSetiEnable, noisePowerMeasurementState=noisePowerMeasurementState, tr101290Trap=tr101290Trap, tsServicePerformanceState=tsServicePerformanceState, rfIfSpectrumLatestError=rfIfSpectrumLatestError, tsPIDBitRateTable=tsPIDBitRateTable, csCSCounterDiscontinuity=csCSCounterDiscontinuity, tsMeasurePrefServiceBitRateMax=tsMeasurePrefServiceBitRateMax, tsServicePerformanceEntry=tsServicePerformanceEntry, ciCSTestState=ciCSTestState, qeCSActiveTime=qeCSActiveTime, terrestrialPrefSEPT=terrestrialPrefSEPT, tsServiceBitRateCounterReset=tsServiceBitRateCounterReset, snrCSCounterDiscontinuity=snrCSCounterDiscontinuity, sysAvailabilityTable=sysAvailabilityTable, noiseMarginEnable=noiseMarginEnable, terrestrialPrefSteDeviationMax=terrestrialPrefSteDeviationMax, berViterbiT=berViterbiT, symbolLengthCounterDiscontinuity=symbolLengthCounterDiscontinuity, qeCSCounterDiscontinuity=qeCSCounterDiscontinuity, capabilityTSGroup=capabilityTSGroup, mg=mg, tsTransportStreamBitRateInputNumber=tsTransportStreamBitRateInputNumber, cableSatPrefLinkAvailUATMode=cableSatPrefLinkAvailUATMode, cablePrefEstNoiseMarginMin=cablePrefEstNoiseMarginMin, cableSatPrefModulation=cableSatPrefModulation, tsServicePerformanceEnable=tsServicePerformanceEnable, berViterbiTCounterDiscontinuity=berViterbiTCounterDiscontinuity, tsTestsPrefEITPFActualTableIntervalMax=tsTestsPrefEITPFActualTableIntervalMax, berRSMeasurementState=berRSMeasurementState, terrestrialPrefENFMax=terrestrialPrefENFMax, estNoiseMarginMeasurementState=estNoiseMarginMeasurementState, rfIfPowerTable=rfIfPowerTable, tsMeasurePrefAllPIDBitRateTau=tsMeasurePrefAllPIDBitRateTau, linkAvailabilityTable=linkAvailabilityTable, rfIfSpectrumEntry=rfIfSpectrumEntry, qeCSInputNumber=qeCSInputNumber, berViterbiTActiveTime=berViterbiTActiveTime, tsMeasurePrefPIDBitRateElement=tsMeasurePrefPIDBitRateElement, tsPcrMeasurementRowStatus=tsPcrMeasurementRowStatus, rfIFsignalPowerInputNumber=rfIFsignalPowerInputNumber, cableSatPrefSteMeanCSMax=cableSatPrefSteMeanCSMax, eNDCInputNumber=eNDCInputNumber, berRSActiveTime=berRSActiveTime, qeCSEnable=qeCSEnable, merTTable=merTTable, terrestrialPreferencesEntry=terrestrialPreferencesEntry, berViterbiSCounterReset=berViterbiSCounterReset, berRSLPTestState=berRSLPTestState, steMeanTCounter=steMeanTCounter, rfChannelWidthMeasurementState=rfChannelWidthMeasurementState, rfIfSpectrumCounterDiscontinuity=rfIfSpectrumCounterDiscontinuity, tsServiceBitRateNomenclature=tsServiceBitRateNomenclature, eNFTLPActiveTime=eNFTLPActiveTime, cableSatPrefMerCSMin=cableSatPrefMerCSMin, estNoiseMarginActiveTime=estNoiseMarginActiveTime, steDeviationCSCounterReset=steDeviationCSCounterReset, tsPcrMeasurementNumber=tsPcrMeasurementNumber, berRSLPLatestError=berRSLPLatestError, cableSatPrefCiCSMin=cableSatPrefCiCSMin, qeTValue=qeTValue, rteCSActiveTime=rteCSActiveTime, noiseMarginLatestError=noiseMarginLatestError, capabilityTerrestrialAvailability=capabilityTerrestrialAvailability, rfIfPowerActiveTime=rfIfPowerActiveTime, csTMeasurementState=csTMeasurementState, tr101290Conformance=tr101290Conformance, sysAvailabilityRatio=sysAvailabilityRatio, cablePrefENDMax=cablePrefENDMax, berRSEnable=berRSEnable, tsTests=tsTests, qeTCounterReset=qeTCounterReset, tsMeasurePrefPCRFOMax=tsMeasurePrefPCRFOMax, berRSLPCounterReset=berRSLPCounterReset, tsMeasurePreferencesServiceTable=tsMeasurePreferencesServiceTable, ciCSCounter=ciCSCounter, sysAvailabilityActiveTime=sysAvailabilityActiveTime, tsTestsPIDTable=tsTestsPIDTable, berViterbiTLPEntry=berViterbiTLPEntry, signQualMarTInputNumber=signQualMarTInputNumber, tsPcrMeasurementEnable=tsPcrMeasurementEnable, sepEtiTable=sepEtiTable, berViterbiTLPCounterDiscontinuity=berViterbiTLPCounterDiscontinuity, tsServiceBitRateState=tsServiceBitRateState, cablePrefInputNumber=cablePrefInputNumber, rfChannelWidthValue=rfChannelWidthValue, sepEtiValue=sepEtiValue, steMeanCSActiveTime=steMeanCSActiveTime, rfIfSpectrumActiveTime=rfIfSpectrumActiveTime, berRSinServiceEntry=berRSinServiceEntry, tsSPPrefDeltaT=tsSPPrefDeltaT, terrestrialPrefSEPEBPerCent=terrestrialPrefSEPEBPerCent, tsTestsPreferences=tsTestsPreferences, capabilityCableGroup=capabilityCableGroup, linearityCounterReset=linearityCounterReset, tsPcrMeasurementCounter=tsPcrMeasurementCounter, steDeviationCSEntry=steDeviationCSEntry, cableSatPrefBERMax=cableSatPrefBERMax, signQualMarTEntry=signQualMarTEntry, cableSatPrefLinkAvailT=cableSatPrefLinkAvailT, berRSinServiceCounter=berRSinServiceCounter, aiTMeasurementState=aiTMeasurementState, merTCounterReset=merTCounterReset, capabilityTerrestrialGroup=capabilityTerrestrialGroup, sepSetiLatestError=sepSetiLatestError, tsPcrMeasurementState=tsPcrMeasurementState, sepSetiTable=sepSetiTable, controlNow=controlNow, capabilityCable=capabilityCable, pjCSEnable=pjCSEnable, sysAvailabilityEntry=sysAvailabilityEntry, capabilitySatellitePollInterval=capabilitySatellitePollInterval, merTTestState=merTTestState, aiCSValue=aiCSValue, berRSinServiceTable=berRSinServiceTable)

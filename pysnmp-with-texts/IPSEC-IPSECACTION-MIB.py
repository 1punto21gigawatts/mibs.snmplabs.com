#
# PySNMP MIB module IPSEC-IPSECACTION-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/IPSEC-IPSECACTION-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:56:24 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ValueRangeConstraint, SingleValueConstraint, ConstraintsIntersection, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsIntersection", "ValueSizeConstraint")
IfDirection, = mibBuilder.importSymbols("DIFFSERV-MIB", "IfDirection")
InetAddressType, InetAddress = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddressType", "InetAddress")
SpdAdminStatus, spdActions, SpdIPPacketLogging = mibBuilder.importSymbols("IPSEC-SPD-MIB", "SpdAdminStatus", "spdActions", "SpdIPPacketLogging")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
ModuleCompliance, NotificationGroup, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup", "ObjectGroup")
TimeTicks, Gauge32, IpAddress, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter64, Integer32, Bits, iso, ObjectIdentity, Unsigned32, MibIdentifier, NotificationType, Counter32, ModuleIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "TimeTicks", "Gauge32", "IpAddress", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter64", "Integer32", "Bits", "iso", "ObjectIdentity", "Unsigned32", "MibIdentifier", "NotificationType", "Counter32", "ModuleIdentity")
StorageType, DisplayString, TruthValue, RowStatus, TextualConvention, TimeStamp = mibBuilder.importSymbols("SNMPv2-TC", "StorageType", "DisplayString", "TruthValue", "RowStatus", "TextualConvention", "TimeStamp")
ipsaMIB = ModuleIdentity((1, 3, 6, 1, 2, 1, 153, 4, 1))
ipsaMIB.setRevisions(('2006-10-17 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ipsaMIB.setRevisionsDescriptions(('Initial version, published as RFC XXXX.',))
if mibBuilder.loadTexts: ipsaMIB.setLastUpdated('200610170000Z')
if mibBuilder.loadTexts: ipsaMIB.setOrganization('IETF IP Security Policy Working Group')
if mibBuilder.loadTexts: ipsaMIB.setContactInfo('Michael Baer P.O. Box 72682 Davis, CA 95617 Phone: +1 530 902 3131 Email: baerm@tislabs.com Ricky Charlet Email: rcharlet@alumni.calpoly.edu Wes Hardaker Sparta, Inc. P.O. Box 382 Davis, CA 95617 Phone: +1 530 792 1913 Email: hardaker@tislabs.com Robert Story Revelstone Software PO Box 1812 Tucker, GA 30085 Phone: +1 770 617 3722 Email: rstory@sparta.com Cliff Wang ARO/North Carolina State University 4300 S. Miami Blvd. RTP, NC 27709 E-Mail: cliffwangmail@yahoo.com')
if mibBuilder.loadTexts: ipsaMIB.setDescription('The MIB module defines IPsec actions for managing IPsec Security Policy. Copyright (C) The Internet Society (2006). This version of this MIB module is part of RFC XXXX, see the RFC itself for full legal notices.')
ipsaConfigObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 153, 4, 1, 1))
ipsaNotificationObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 153, 4, 1, 2))
ipsaConformanceObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 153, 4, 1, 3))
class IpsecDoiEncapsulationMode(TextualConvention, Unsigned32):
    description = 'The Encapsulation Mode used as an IPsec DOI SA Attributes definition in the Transform Payload of a Phase II IKE negotiation. This set of values defines encapsulation modes used for AH, ESP, and IPCOMP when the associated Proposal Payload has a Protocol-ID of 3 (ESP). Unused values <= 61439 are reserved to IANA. Currently assigned values at the time of this writing: reserved(0), -- reserved in DOI tunnel(1), transport(2) Values 61440-65535 are for private use.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(0, 65535)

class IpsecDoiIpcompTransform(TextualConvention, Unsigned32):
    reference = 'RFC 2407 sections 4.4.5 and 6.6, RFC 3051'
    description = "The IPsec DOI IPCOMP Transform Identifier is an 8-bit value which identifies a particular algorithm to be used to provide IP-level compression before ESP. It is used in the Tranform-ID field of a ISAKMP Transform Payload for the IPsec DOI, when the Protocol-Id of the associated Proposal Payload is 4 (IPCOMP). The values 1-47 are reserved for algorithms for which an RFC has been approved for publication. Currently assigned values at the time of this writing: reserved(0), -- reserved in DOI ipcompOui(1), -- proprietary compression -- transform ipcompDeflate(2), -- 'zlib' deflate algorithm ipcompLzs(3), -- Stac Electronics LZS ipcompLzjh(4) -- ITU-T V.44 packet method The values 48-63 are reserved for private use amongst cooperating systems. The values 64-255 are reserved for future expansion."
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(0, 255)

class IpsecDoiAuthAlgorithm(TextualConvention, Unsigned32):
    reference = 'RFC 2407 section 4.5, RFC 2407 section 4.4.3.1, RFC 1826, IANA, RFC 2857'
    description = 'The ESP Authentication Algorithm used in the IPsec DOI as a SA Attributes definition in the Transform Payload of Phase II of an IKE negotiation. This set of values defines the AH authentication algorithm, when the associated Proposal Payload has a Protocol-ID of 2 (AH). This set of values defines the ESP authentication algorithm, when the associated Proposal Payload has a Protocol-ID of 3 (ESP). Unused values <= 61439 are reserved to IANA. Currently assigned values at the time of this writing: none(0), -- reserved in DOI, used -- in MIBs to reflect no -- encryption used hmacMd5(1), -- hashed MAC using MD5 hmacSha(2), -- hashed MAC using SHA-1 desMac(3), -- DES MAC kpdk(4), -- RFC 1826 -- Key/Pad/Data/Key hmacSha256(5), -- hashed MAC using SHA-256 hmacSha384(6), -- hashed MAC using SHA-384 hmacSha512(7), -- hashed MAC using SHA-512 hamcRipemd(8) -- hashed MAC using -- RIPEMD-160-96 Values 61440-65535 are for private use. In a MIB, a value of 0 indicates that ESP has been negotiated without authentication.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(0, 65535)

class IpsecDoiEspTransform(TextualConvention, Unsigned32):
    reference = 'RFC 2407 sections 4.4.4 and 6.5, IANA'
    description = 'The values of the IPsec DOI ESP Transform Identifier which identify a particular algorithm to be used to provide secrecy protection for ESP. It is used in the Tranform-ID field of a ISAKMP Transform Payload for the IPsec DOI, when the Protocol-Id of the associated Proposal Payload is 2 (AH), 3 (ESP), and 4 (IPCOMP). Currently assigned values at the time of this writing: none(0), -- reserved in DOI, used -- in MIBs to reflect no -- encryption used espDesIv64(1), -- DES-CBC transform defined -- in RFC 1827 and RFC 1829 -- using a 64-bit IV espDes(2), -- generic DES transform -- using DES-CBC esp3Des(3), -- generic triple-DES -- transform espRc5(4), -- RC5 transform espIdea(5), -- IDEA transform espCast(6), -- CAST transform espBlowfish(7), -- BLOWFISH transform esp3Idea(8), -- reserved for triple-IDEA espDesIv32(9), -- DES-CBC transform defined -- in RFC 1827 and RFC 1829 -- using a 32-bit IV espRc4(10), -- reserved for RC4 espNull(11), -- no confidentiality -- provided by ESP espAes(12) -- NIST AES transform The values 249-255 are reserved for private use amongst cooperating systems.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(0, 255)

class IpsecDoiIdentType(TextualConvention, Unsigned32):
    reference = 'RFC 2407 sections 4.4.5, 4.6.2.1, and 6.9'
    description = 'The IPsec DOI Identification Type is an 8-bit value which is used in the ID Type field as a discriminant for interpretation of the variable-length Identification Payload. Currently assigned values at the time of this writing: reserved(0), -- reserved in DOI idIpv4Addr(1), -- a single four (4) octet -- IPv4 address idFqdn(2), -- fully-qualified domain -- name string idUserFqdn(3), -- fully-qualified username -- string idIpv4AddrSubnet(4), -- a range of IPv4 addresses, -- represented by two -- four (4) octet values, -- where the first is an -- address and the second -- is a mask idIpv6Addr(5), -- a single sixteen (16) -- octet IPv6 address idIpv6AddrSubnet(6), -- a range of IPv6 addresses, -- represented by two -- sixteen (16) octet values, -- where the first is an -- address and the second -- is a mask idIpv4AddrRange(7), -- a range of IPv4 addresses, -- represented by two -- four (4) octet values, -- where the first is the -- beginning IPv4 address -- and the second is the -- ending IPv4 address idIpv6AddrRange(8), -- a range of IPv6 addresses, -- represented by two -- sixteen (16) octet values, -- where the first is the -- beginning IPv6 address -- and the second is the -- ending IPv6 address idDerAsn1Dn(9), -- the binary DER encoding of -- ASN1 X.500 -- DistinguishedName idDerAsn1Gn(10), -- the binary DER encoding of -- ASN1 X.500 GeneralName idKeyId(11) -- opaque byte stream which -- may be used to pass -- vendor-specific -- information The values 249-255 are reserved for private use amongst cooperating systems.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(0, 255)

class IpsaCredentialType(TextualConvention, Integer32):
    description = 'IpsaCredentialType identifies the type of credential contained in a corresponding IpsaIdentityFilter object.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))
    namedValues = NamedValues(("reserved", 0), ("unknown", 1), ("sharedSecret", 2), ("x509", 3), ("kerberos", 4))

class IpsaIdentityFilter(TextualConvention, OctetString):
    description = 'IpsaIdentityFilter contains a string encoded Identity Type value to be used in comparisons against an IKE Identity payload. Wherever this TC is used, there SHOULD be an accompanying column which uses the IpsecDoiIdentType TC to specify the type of data in this object. See the IpsecDoiIdentType TC for the supported identity types available. Note that the IpsecDoiIdentType TC sepcifies how to encode binary values, while this object will contain human readable string versions.'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(1, 256)

ipsaSaPreconfiguredActionTable = MibTable((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 1), )
if mibBuilder.loadTexts: ipsaSaPreconfiguredActionTable.setStatus('current')
if mibBuilder.loadTexts: ipsaSaPreconfiguredActionTable.setDescription('This table is a list of non-negotiated IPsec actions (SAs) that can be performed and contains or indicates the data necessary to create such an SA.')
ipsaSaPreconfiguredActionEntry = MibTableRow((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 1, 1), ).setIndexNames((0, "IPSEC-IPSECACTION-MIB", "ipsaSaPreActActionName"), (0, "IPSEC-IPSECACTION-MIB", "ipsaSaPreActSADirection"))
if mibBuilder.loadTexts: ipsaSaPreconfiguredActionEntry.setStatus('current')
if mibBuilder.loadTexts: ipsaSaPreconfiguredActionEntry.setDescription('One entry in the ipsaSaPreconfiguredActionTable.')
ipsaSaPreActActionName = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 1, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32)))
if mibBuilder.loadTexts: ipsaSaPreActActionName.setStatus('current')
if mibBuilder.loadTexts: ipsaSaPreActActionName.setDescription('This object contains the name of this SaPreconfiguredActionEntry.')
ipsaSaPreActSADirection = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 1, 1, 2), IfDirection())
if mibBuilder.loadTexts: ipsaSaPreActSADirection.setStatus('current')
if mibBuilder.loadTexts: ipsaSaPreActSADirection.setDescription('This object indicates whether a row applies to egress or ingress SAs')
ipsaSaPreActActionDescription = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 1, 1, 3), SnmpAdminString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsaSaPreActActionDescription.setStatus('current')
if mibBuilder.loadTexts: ipsaSaPreActActionDescription.setDescription('An administratively assigned string which can be used to describe what the action does.')
ipsaSaPreActActionLifetimeSec = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 1, 1, 4), Unsigned32().clone(28800)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsaSaPreActActionLifetimeSec.setStatus('current')
if mibBuilder.loadTexts: ipsaSaPreActActionLifetimeSec.setDescription('ipsaSaPreActActionLifetimeSec specifies how long in seconds the security association derived from this action is used. The default lifetime is 8 hours. Note: the actual lifetime of the preconfigured SA will be the lesser of the value of this object and of the value of the MaxLifetimeSecs property of the associated transform. A value of 0 indicates no time limit on the lifetime of the SA.')
ipsaSaPreActActionLifetimeKB = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 1, 1, 5), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsaSaPreActActionLifetimeKB.setStatus('current')
if mibBuilder.loadTexts: ipsaSaPreActActionLifetimeKB.setDescription("ipsaSaPreActActionLifetimeKB specifies how long the security association derived from this action is used. After this value in KiloBytes has passed through the security association, this SA SHOULD be destroyed. Note: the actual lifetime of the preconfigured SA will be the lesser of the value of this object and of the value of the MaxLifetimeKB property of the associated transform. The default value, '0', indicates no kilobyte limit.")
ipsaSaPreActDoActionLogging = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 1, 1, 6), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsaSaPreActDoActionLogging.setStatus('current')
if mibBuilder.loadTexts: ipsaSaPreActDoActionLogging.setDescription('ipsaSaPreActDoActionLogging specifies whether or not an audit message SHOULD be logged when a preconfigured SA is created.')
ipsaSaPreActDoPacketLogging = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 1, 1, 7), SpdIPPacketLogging().clone(-1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsaSaPreActDoPacketLogging.setStatus('current')
if mibBuilder.loadTexts: ipsaSaPreActDoPacketLogging.setDescription('ipsaSaPreActDoPacketLogging specifies whether or not an audit message SHOULD be logged and if there is logging, how many bytes of the packet to place in the notification.')
ipsaSaPreActDFHandling = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("copy", 1), ("set", 2), ("clear", 3))).clone('copy')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsaSaPreActDFHandling.setStatus('current')
if mibBuilder.loadTexts: ipsaSaPreActDFHandling.setDescription('This object specifies how to process the DF bit in packets sent through the preconfigured SA. This object is not used for transport SAs.')
ipsaSaPreActActionType = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 1, 1, 9), IpsecDoiEncapsulationMode().clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsaSaPreActActionType.setStatus('current')
if mibBuilder.loadTexts: ipsaSaPreActActionType.setDescription('This object specifies the encapsulation mode to use for the preconfigured SA: tunnel or transport mode.')
ipsaSaPreActAHSPI = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 1, 1, 10), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsaSaPreActAHSPI.setStatus('current')
if mibBuilder.loadTexts: ipsaSaPreActAHSPI.setDescription('This object represents the SPI value for the AH SA.')
ipsaSaPreActAHTransformName = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 1, 1, 11), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsaSaPreActAHTransformName.setStatus('current')
if mibBuilder.loadTexts: ipsaSaPreActAHTransformName.setDescription('This object is the name of the AH transform to use as an index into the AHTransformTable. A zero length value indicates no transform of this type is used.')
ipsaSaPreActAHSharedSecretName = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 1, 1, 12), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsaSaPreActAHSharedSecretName.setStatus('current')
if mibBuilder.loadTexts: ipsaSaPreActAHSharedSecretName.setDescription('This object contains a name value to be used as an index into the ipsaCredentialTable which holds the pertinent keying information for the AH SA.')
ipsaSaPreActESPSPI = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 1, 1, 13), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsaSaPreActESPSPI.setStatus('current')
if mibBuilder.loadTexts: ipsaSaPreActESPSPI.setDescription('This object represents the SPI value for the ESP SA.')
ipsaSaPreActESPTransformName = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 1, 1, 14), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsaSaPreActESPTransformName.setStatus('current')
if mibBuilder.loadTexts: ipsaSaPreActESPTransformName.setDescription('This object is the name of the ESP transform to use as an index into the ESPTransformTable. A zero length value indicates no transform of this type is used.')
ipsaSaPreActESPEncSecretName = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 1, 1, 15), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsaSaPreActESPEncSecretName.setStatus('current')
if mibBuilder.loadTexts: ipsaSaPreActESPEncSecretName.setDescription('This object contains a name value to be used as an index into the ipsaCredentialTable which holds the pertinent keying information for the encryption algorithm of the ESP SA.')
ipsaSaPreActESPAuthSecretName = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 1, 1, 16), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsaSaPreActESPAuthSecretName.setStatus('current')
if mibBuilder.loadTexts: ipsaSaPreActESPAuthSecretName.setDescription('This object contains a name value to be used as an index into the ipsaCredentialTable which holds the pertinent keying information for the authentication algorithm of the ESP SA.')
ipsaSaPreActIPCompSPI = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 1, 1, 17), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsaSaPreActIPCompSPI.setStatus('current')
if mibBuilder.loadTexts: ipsaSaPreActIPCompSPI.setDescription('This object represents the SPI value for the IPComp SA.')
ipsaSaPreActIPCompTransformName = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 1, 1, 18), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsaSaPreActIPCompTransformName.setStatus('current')
if mibBuilder.loadTexts: ipsaSaPreActIPCompTransformName.setDescription('This object is the name of the IPComp transform to use as an index into the IPCompTransformTable. A zero length value indicates no transform of this type is used.')
ipsaSaPreActPeerGatewayIdName = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 1, 1, 19), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsaSaPreActPeerGatewayIdName.setStatus('current')
if mibBuilder.loadTexts: ipsaSaPreActPeerGatewayIdName.setDescription('This object indicates the peer id name of the peer gateway. This object can be used to look up the peer gateway address in the ipsaPeerIdentityTable. This object is only used when initiating a tunnel SA, and is not used for transport SAs. If ipsaSaPreActActionType specifies tunnel mode and this object is empty, the peer gateway is determined from the source or destination of the packet.')
ipsaSaPreActLastChanged = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 1, 1, 20), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsaSaPreActLastChanged.setStatus('current')
if mibBuilder.loadTexts: ipsaSaPreActLastChanged.setDescription('The value of sysUpTime when this row was last modified or created either through SNMP SETs or by some other external means. If this row has not been modified since the last re-initialization of the network management subsystem, this object SHOULD have a zero value.')
ipsaSaPreActStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 1, 1, 21), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsaSaPreActStorageType.setStatus('current')
if mibBuilder.loadTexts: ipsaSaPreActStorageType.setDescription('The storage type for this row. Rows in this table which were created through an external process MAY have a storage type of readOnly or permanent. For a storage type of permanent, none of the columns have to be writable.')
ipsaSaPreActRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 1, 1, 22), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsaSaPreActRowStatus.setStatus('current')
if mibBuilder.loadTexts: ipsaSaPreActRowStatus.setDescription('This object indicates the conceptual status of this row. The value of this object has no effect on whether other objects in this conceptual row can be modified. If active, this object MUST remain active if it is referenced by an active row in another table. An attempt to set it to anything other than active while it is referenced by an active row in another table MUST result in an inconsistentValue error.')
ipsaAhTransformTable = MibTable((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 2), )
if mibBuilder.loadTexts: ipsaAhTransformTable.setStatus('current')
if mibBuilder.loadTexts: ipsaAhTransformTable.setDescription('This table lists all the AH transforms which can be used to build IPsec proposals.')
ipsaAhTransformEntry = MibTableRow((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 2, 1), ).setIndexNames((0, "IPSEC-IPSECACTION-MIB", "ipsaAhTranName"))
if mibBuilder.loadTexts: ipsaAhTransformEntry.setStatus('current')
if mibBuilder.loadTexts: ipsaAhTransformEntry.setDescription('This entry contains the attributes of one AH transform.')
ipsaAhTranName = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 2, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32)))
if mibBuilder.loadTexts: ipsaAhTranName.setStatus('current')
if mibBuilder.loadTexts: ipsaAhTranName.setDescription('This object contains the name of this AH transform. This row will be referred to by an ipsaIpsecTransformsEntry.')
ipsaAhTranMaxLifetimeSec = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 2, 1, 2), Unsigned32()).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsaAhTranMaxLifetimeSec.setStatus('current')
if mibBuilder.loadTexts: ipsaAhTranMaxLifetimeSec.setDescription('ipsaAhTranMaxLifetimeSec specifies how long in seconds the security association derived from this transform SHOULD be used. A value of 0 indicates that the default lifetime of 8 hours SHOULD be used.')
ipsaAhTranMaxLifetimeKB = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 2, 1, 3), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsaAhTranMaxLifetimeKB.setStatus('current')
if mibBuilder.loadTexts: ipsaAhTranMaxLifetimeKB.setDescription('ipsaAhTranMaxLifetimeKB specifies how long in kilobytes the security association derived from this transform SHOULD be used.')
ipsaAhTranAlgorithm = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 2, 1, 4), IpsecDoiAuthAlgorithm()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsaAhTranAlgorithm.setStatus('current')
if mibBuilder.loadTexts: ipsaAhTranAlgorithm.setDescription('This object specifies the AH algorithm for this transform.')
ipsaAhTranReplayProtection = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 2, 1, 5), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsaAhTranReplayProtection.setStatus('current')
if mibBuilder.loadTexts: ipsaAhTranReplayProtection.setDescription('ipsaAhTranReplayProtection indicates whether or not anti replay service is to be provided by this SA.')
ipsaAhTranReplayWindowSize = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 2, 1, 6), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsaAhTranReplayWindowSize.setStatus('current')
if mibBuilder.loadTexts: ipsaAhTranReplayWindowSize.setDescription('ipsaAhTranReplayWindowSize indicates the size, in bits, of the replay window to use if replay protection is true for this transform. The window size is assumed to be a power of two. If Replay Protection is false, this value can be ignored.')
ipsaAhTranLastChanged = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 2, 1, 7), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsaAhTranLastChanged.setStatus('current')
if mibBuilder.loadTexts: ipsaAhTranLastChanged.setDescription('The value of sysUpTime when this row was last modified or created either through SNMP SETs or by some other external means. If this row has not been modified since the last re-initialization of the network management subsystem, this object SHOULD have a zero value.')
ipsaAhTranStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 2, 1, 8), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsaAhTranStorageType.setStatus('current')
if mibBuilder.loadTexts: ipsaAhTranStorageType.setDescription('The storage type for this row. Rows in this table which were created through an external process MAY have a storage type of readOnly or permanent. For a storage type of permanent, none of the columns have to be writable.')
ipsaAhTranRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 2, 1, 9), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsaAhTranRowStatus.setStatus('current')
if mibBuilder.loadTexts: ipsaAhTranRowStatus.setDescription('This object indicates the conceptual status of this row. The value of this object has no effect on whether other objects in this conceptual row can be modified. If active, this object MUST remain active if it is referenced by an active row in another table. An attempt to set it to anything other than active while it is referenced by an active row in another table MUST result in an inconsistentValue error.')
ipsaEspTransformTable = MibTable((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 3), )
if mibBuilder.loadTexts: ipsaEspTransformTable.setStatus('current')
if mibBuilder.loadTexts: ipsaEspTransformTable.setDescription('This table lists all the ESP transforms which can be used to build IPsec proposals')
ipsaEspTransformEntry = MibTableRow((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 3, 1), ).setIndexNames((0, "IPSEC-IPSECACTION-MIB", "ipsaEspTranName"))
if mibBuilder.loadTexts: ipsaEspTransformEntry.setStatus('current')
if mibBuilder.loadTexts: ipsaEspTransformEntry.setDescription('This entry contains the attributes of one ESP transform.')
ipsaEspTranName = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 3, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32)))
if mibBuilder.loadTexts: ipsaEspTranName.setStatus('current')
if mibBuilder.loadTexts: ipsaEspTranName.setDescription('The name of this particular espTransform be referred to by an ipsaIpsecTransformsEntry.')
ipsaEspTranMaxLifetimeSec = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 3, 1, 2), Unsigned32()).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsaEspTranMaxLifetimeSec.setStatus('current')
if mibBuilder.loadTexts: ipsaEspTranMaxLifetimeSec.setDescription('ipsaEspTranMaxLifetimeSec specifies how long in seconds the security association derived from this transform SHOULD be used. A value of 0 indicates that the default lifetime of 8 hours SHOULD be used.')
ipsaEspTranMaxLifetimeKB = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 3, 1, 3), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsaEspTranMaxLifetimeKB.setStatus('current')
if mibBuilder.loadTexts: ipsaEspTranMaxLifetimeKB.setDescription('ipsaEspTranMaxLifetimeKB specifies how long in kilobytes the security association derived from this transform is used.')
ipsaEspTranCipherTransformId = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 3, 1, 4), IpsecDoiEspTransform()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsaEspTranCipherTransformId.setStatus('current')
if mibBuilder.loadTexts: ipsaEspTranCipherTransformId.setDescription('This object specifies the transform ID of the ESP cipher algorithm.')
ipsaEspTranCipherKeyLength = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 3, 1, 5), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsaEspTranCipherKeyLength.setStatus('current')
if mibBuilder.loadTexts: ipsaEspTranCipherKeyLength.setDescription('This object specifies, in bits, the key length for the ESP cipher algorithm.')
ipsaEspTranCipherKeyRounds = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 3, 1, 6), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsaEspTranCipherKeyRounds.setStatus('current')
if mibBuilder.loadTexts: ipsaEspTranCipherKeyRounds.setDescription('This object specifies the number of key rounds for the ESP cipher algorithm.')
ipsaEspTranIntegrityAlgorithmId = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 3, 1, 7), IpsecDoiAuthAlgorithm()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsaEspTranIntegrityAlgorithmId.setStatus('current')
if mibBuilder.loadTexts: ipsaEspTranIntegrityAlgorithmId.setDescription('This object specifies the ESP integrity algorithm ID.')
ipsaEspTranReplayPrevention = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 3, 1, 8), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsaEspTranReplayPrevention.setStatus('current')
if mibBuilder.loadTexts: ipsaEspTranReplayPrevention.setDescription('ipsaEspTranReplayPrevention indicates whether or not anti-replay service is to be provided by this SA.')
ipsaEspTranReplayWindowSize = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 3, 1, 9), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsaEspTranReplayWindowSize.setStatus('current')
if mibBuilder.loadTexts: ipsaEspTranReplayWindowSize.setDescription('ipsaEspTranReplayWindowSize indicates the size, in bits, of the replay window to use if replay protection is true for this transform. The window size is assumed to be a power of two. If Replay Protection is false, this value can be ignored.')
ipsaEspTranLastChanged = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 3, 1, 10), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsaEspTranLastChanged.setStatus('current')
if mibBuilder.loadTexts: ipsaEspTranLastChanged.setDescription('The value of sysUpTime when this row was last modified or created either through SNMP SETs or by some other external means. If this row has not been modified since the last re-initialization of the network management subsystem, this object SHOULD have a zero value.')
ipsaEspTranStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 3, 1, 11), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsaEspTranStorageType.setStatus('current')
if mibBuilder.loadTexts: ipsaEspTranStorageType.setDescription('The storage type for this row. Rows in this table which were created through an external process MAY have a storage type of readOnly or permanent. For a storage type of permanent, none of the columns have to be writable.')
ipsaEspTranRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 3, 1, 12), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsaEspTranRowStatus.setStatus('current')
if mibBuilder.loadTexts: ipsaEspTranRowStatus.setDescription('This object indicates the conceptual status of this row. The value of this object has no effect on whether other objects in this conceptual row can be modified. If active, this object MUST remain active if it is referenced by a row in another table. An attempt to set it to anything other than active while it is referenced by an active row in another table MUST result in an inconsistentValue error.')
ipsaIpcompTransformTable = MibTable((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 4), )
if mibBuilder.loadTexts: ipsaIpcompTransformTable.setStatus('current')
if mibBuilder.loadTexts: ipsaIpcompTransformTable.setDescription('This table lists all the IP compression transforms which can be used to build IPsec proposals during negotiation of a phase 2 SA.')
ipsaIpcompTransformEntry = MibTableRow((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 4, 1), ).setIndexNames((0, "IPSEC-IPSECACTION-MIB", "ipsaIpcompTranName"))
if mibBuilder.loadTexts: ipsaIpcompTransformEntry.setStatus('current')
if mibBuilder.loadTexts: ipsaIpcompTransformEntry.setDescription('This entry contains the attributes of one IP compression transform.')
ipsaIpcompTranName = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 4, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32)))
if mibBuilder.loadTexts: ipsaIpcompTranName.setStatus('current')
if mibBuilder.loadTexts: ipsaIpcompTranName.setDescription('The name of this ipsaIpcompTransformEntry.')
ipsaIpcompTranMaxLifetimeSec = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 4, 1, 2), Unsigned32()).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsaIpcompTranMaxLifetimeSec.setStatus('current')
if mibBuilder.loadTexts: ipsaIpcompTranMaxLifetimeSec.setDescription('ipsaIpcompTranMaxLifetimeSec specifies how long in seconds the security association derived from this transform SHOULD be used. A value of 0 indicates that the default lifetime of 8 hours SHOULD be used.')
ipsaIpcompTranMaxLifetimeKB = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 4, 1, 3), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsaIpcompTranMaxLifetimeKB.setStatus('current')
if mibBuilder.loadTexts: ipsaIpcompTranMaxLifetimeKB.setDescription('ipsaIpcompTranMaxLifetimeKB specifies how long in kilobytes the security association derived from this transform SHOULD be used.')
ipsaIpcompTranAlgorithm = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 4, 1, 4), IpsecDoiIpcompTransform()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsaIpcompTranAlgorithm.setStatus('current')
if mibBuilder.loadTexts: ipsaIpcompTranAlgorithm.setDescription('ipsaIpcompTranAlgorithm specifies the transform ID of the IP compression algorithm.')
ipsaIpcompTranDictionarySize = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 4, 1, 5), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsaIpcompTranDictionarySize.setStatus('current')
if mibBuilder.loadTexts: ipsaIpcompTranDictionarySize.setDescription('If the algorithm in ipsaIpcompTranAlgorithm requires a dictionary size configuration parameter, then this is the place to put it. This object specifies the log2 maximum size of the dictionary for the compression algorithm.')
ipsaIpcompTranPrivateAlgorithm = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 4, 1, 6), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsaIpcompTranPrivateAlgorithm.setStatus('current')
if mibBuilder.loadTexts: ipsaIpcompTranPrivateAlgorithm.setDescription('If ipsaIpcompTranPrivateAlgorithm has a value other zero, then it is up to the vendors implementation to determine the meaning of this field and substitute a data compression algorithm in place of ipsaIpcompTranAlgorithm.')
ipsaIpcompTranLastChanged = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 4, 1, 7), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsaIpcompTranLastChanged.setStatus('current')
if mibBuilder.loadTexts: ipsaIpcompTranLastChanged.setDescription('The value of sysUpTime when this row was last modified or created either through SNMP SETs or by some other external means. If this row has not been modified since the last re-initialization of the network management subsystem, this object SHOULD have a zero value.')
ipsaIpcompTranStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 4, 1, 8), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsaIpcompTranStorageType.setStatus('current')
if mibBuilder.loadTexts: ipsaIpcompTranStorageType.setDescription('The storage type for this row. Rows in this table which were created through an external process MAY have a storage type of readOnly or permanent. For a storage type of permanent, none of the columns have to be writable.')
ipsaIpcompTranRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 4, 1, 9), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsaIpcompTranRowStatus.setStatus('current')
if mibBuilder.loadTexts: ipsaIpcompTranRowStatus.setDescription('This object indicates the conceptual status of this row. The value of this object has no effect on whether other objects in this conceptual row can be modified. If active, this object MUST remain active if it is referenced by an active row in another table. An attempt to set it to anything other than active while it is referenced by an active row in another table MUST result in an inconsistentValue error.')
ipsaCredentialTable = MibTable((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 5), )
if mibBuilder.loadTexts: ipsaCredentialTable.setStatus('current')
if mibBuilder.loadTexts: ipsaCredentialTable.setDescription('A table of credential values. Example of Credentials are shared secrets, certificates or kerberos tickets.')
ipsaCredentialEntry = MibTableRow((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 5, 1), ).setIndexNames((0, "IPSEC-IPSECACTION-MIB", "ipsaCredName"))
if mibBuilder.loadTexts: ipsaCredentialEntry.setStatus('current')
if mibBuilder.loadTexts: ipsaCredentialEntry.setDescription('A row in the ipsaCredentialTable.')
ipsaCredName = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 5, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32)))
if mibBuilder.loadTexts: ipsaCredName.setStatus('current')
if mibBuilder.loadTexts: ipsaCredName.setDescription('This object represents the name for an entry in this table.')
ipsaCredType = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 5, 1, 2), IpsaCredentialType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsaCredType.setStatus('current')
if mibBuilder.loadTexts: ipsaCredType.setDescription('This object represents the type of the credential for this row.')
ipsaCredCredential = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 5, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 1024))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsaCredCredential.setStatus('current')
if mibBuilder.loadTexts: ipsaCredCredential.setDescription('This object represents the credential value. If the size of the credential is greater than 1024, the credential MUST be configured via the ipsaCredSegmentTable. For credential type where the disclosure of the credential would compromise the credential (e.g. shared secrets), when this object is accessed for reading, it MUST return a null length (0 length) string and MUST NOT return the configured credential.')
ipsaCredSize = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 5, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsaCredSize.setStatus('current')
if mibBuilder.loadTexts: ipsaCredSize.setDescription('This value represents the size of the credential. If this value is greater than 1024, the ipsaCreCredential column will return an empty (0 length) string. In this case, the value of the credential is retrived from the ipsaCredSegmentTable. For credential type where the disclosure of the credential would compromise the credential (e.g. shared secrets), when this object is accessed for reading, it MUST return a value of 0 and MUST NOT return the size credential.')
ipsaCredMngName = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 5, 1, 5), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsaCredMngName.setStatus('current')
if mibBuilder.loadTexts: ipsaCredMngName.setDescription('This value is used as an index into the ipsaIpsecCredMngServiceTable. For IDs that have no credential management service, this value is left blank.')
ipsaCredRemoteID = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 5, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 256))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsaCredRemoteID.setStatus('current')
if mibBuilder.loadTexts: ipsaCredRemoteID.setDescription('This object represents the Identification (e.g. user name) of the user of the key information on the remote site. If there is no ID associated with this credential, the value of this object SHOULD be the null string.')
ipsaCredAdminStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 5, 1, 7), SpdAdminStatus().clone('disabled')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsaCredAdminStatus.setStatus('current')
if mibBuilder.loadTexts: ipsaCredAdminStatus.setDescription('Indicates whether this credential is considered active. Rows with a disabled status MUST NOT be used for any purpose, including IKE or IPSEC processing. For credentials whose size does not execeed the maximum size for the ipsaCredCredential, it MAY be set to enabled during row creation. For larger credentials, it SHOULD be left as disabled until all rows have been uploaded to the ipsaCredSegmentTable.')
ipsaCredLastChanged = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 5, 1, 8), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsaCredLastChanged.setStatus('current')
if mibBuilder.loadTexts: ipsaCredLastChanged.setDescription('The value of sysUpTime when this row was last modified or created either through SNMP SETs or by some other external means. If this row has not been modified since the last re-initialization of the network management subsystem, this object SHOULD have a zero value.')
ipsaCredStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 5, 1, 9), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsaCredStorageType.setStatus('current')
if mibBuilder.loadTexts: ipsaCredStorageType.setDescription('The storage type for this row. Rows in this table which were created through an external process MAY have a storage type of readOnly or permanent. For a storage type of permanent, none of the columns have to be writable.')
ipsaCredRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 5, 1, 10), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsaCredRowStatus.setStatus('current')
if mibBuilder.loadTexts: ipsaCredRowStatus.setDescription('This object indicates the conceptual status of this row. The value of this object has no effect on whether other objects in this conceptual row can be modified. If active, this object MUST remain active if it is referenced by an active row in another table. An attempt to set it to anything other than active while it is referenced by an active row in another table MUST result in an inconsistentValue error.')
ipsaCredentialSegmentTable = MibTable((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 6), )
if mibBuilder.loadTexts: ipsaCredentialSegmentTable.setStatus('current')
if mibBuilder.loadTexts: ipsaCredentialSegmentTable.setDescription('A table of credential segments. This table is used for credentials which are larger than the maximum size allowed for ipsaCredCredential.')
ipsaCredentialSegmentEntry = MibTableRow((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 6, 1), ).setIndexNames((0, "IPSEC-IPSECACTION-MIB", "ipsaCredName"), (0, "IPSEC-IPSECACTION-MIB", "ipsaCredSegIndex"))
if mibBuilder.loadTexts: ipsaCredentialSegmentEntry.setStatus('current')
if mibBuilder.loadTexts: ipsaCredentialSegmentEntry.setDescription('A row in the ipsaCredentialSegmentTable.')
ipsaCredSegIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: ipsaCredSegIndex.setStatus('current')
if mibBuilder.loadTexts: ipsaCredSegIndex.setDescription("This object represents the segment number for this segment. By default, each segment will be 1024 octets. However, when this table is accessed using a context of 'ipsa4096', 'ipsa8192' or 'ipsa16384' a segment size of 4096, 8192 or 16384 (respectively) will be used instead. The number of rows which need to be retrieved or set can be calculated by obtaining the value of the ipsaCredSize column from the corresponding ipsaCredentialTable row and dividing it by the segment size.")
ipsaCredSegValue = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 6, 1, 2), OctetString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsaCredSegValue.setStatus('current')
if mibBuilder.loadTexts: ipsaCredSegValue.setDescription("This object represents one segment of the credential. By default, each complete segment will be 1024 octets. (The last row for a given credential might be smaller, if the credential size is not a multiple of the segment size). An implementation MAY optionally support segment sizes of 256, 4096, 8192 or the full object size when this table is is accessed using a context of 'ipsaCred256', 'ipsaCred4096', 'ipsaCred8192' or 'ipsaCredFull' (respectively). The number of rows which need to be retrieved or set can be calculated by obtaining the value of the ipsaCredSize column from the corresponding ipsaCredentialTable row and dividing it by the segment size.")
ipsaCredSegLastChanged = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 6, 1, 3), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsaCredSegLastChanged.setStatus('current')
if mibBuilder.loadTexts: ipsaCredSegLastChanged.setDescription('The value of sysUpTime when this credential was last modified or created either through SNMP SETs or by some other external means. Note that the last changed type will be the same for all segemnts of the credential. If this row has not been modified since the last re-initialization of the network management subsystem, this object SHOULD have a zero value.')
ipsaCredSegStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 6, 1, 4), StorageType().clone('nonVolatile')).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsaCredSegStorageType.setStatus('current')
if mibBuilder.loadTexts: ipsaCredSegStorageType.setDescription('The storage type for this row. This object is read-only. Rows in this table have the same value as the ipsaCrendStorageType for the corresponding row in the ipsaCredentialTable. For a storage type of permanent, none of the columns have to be writable.')
ipsaCredSegRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 6, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsaCredSegRowStatus.setStatus('current')
if mibBuilder.loadTexts: ipsaCredSegRowStatus.setDescription('This object indicates the conceptual status of this row. The segment of this object has no effect on whether other objects in this conceptual row can be modified. If active, this object MUST remain active if it is referenced by an active row in another table. An attempt to set it to anything other than active while it is referenced by an active row in another table MUST result in an inconsistentValue error.')
ipsaPeerIdentityTable = MibTable((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 7), )
if mibBuilder.loadTexts: ipsaPeerIdentityTable.setStatus('current')
if mibBuilder.loadTexts: ipsaPeerIdentityTable.setDescription('PeerIdentity is used to represent the identities that are used for peers to identify themselves in IKE phase I/II negotiations. PeerIdentityTable aggregates the table entries that provide mappings between identities and their addresses.')
ipsaPeerIdentityEntry = MibTableRow((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 7, 1), ).setIndexNames((0, "IPSEC-IPSECACTION-MIB", "ipsaPeerIdName"), (0, "IPSEC-IPSECACTION-MIB", "ipsaPeerIdPriority"))
if mibBuilder.loadTexts: ipsaPeerIdentityEntry.setStatus('current')
if mibBuilder.loadTexts: ipsaPeerIdentityEntry.setDescription("peerIdentity matches a peer's identity to its address.")
ipsaPeerIdName = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 7, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32)))
if mibBuilder.loadTexts: ipsaPeerIdName.setStatus('current')
if mibBuilder.loadTexts: ipsaPeerIdName.setDescription('This is an administratively assigned value that, together with ipsaPeerIdPriority, uniquely identifies an entry in this table.')
ipsaPeerIdPriority = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 7, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)))
if mibBuilder.loadTexts: ipsaPeerIdPriority.setStatus('current')
if mibBuilder.loadTexts: ipsaPeerIdPriority.setDescription('This object, along with ipsaPeerIdName, uniquely identifies an entry in this table. The priority also indicates the ordering of peer gateways from which to initiate or accept SAs. The priority value is ordered from low to high. For example, a row with a priority of 0 is used before a row with a priority of 1, a 1 before a 2, etc....')
ipsaPeerIdType = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 7, 1, 3), IpsecDoiIdentType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsaPeerIdType.setStatus('current')
if mibBuilder.loadTexts: ipsaPeerIdType.setDescription('ipsaPeerIdType is an enumeration identifying the type of the Identity value.')
ipsaPeerIdValue = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 7, 1, 4), IpsaIdentityFilter()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsaPeerIdValue.setStatus('current')
if mibBuilder.loadTexts: ipsaPeerIdValue.setDescription('ipsaPeerIdValue contains an Identity filter to be used to match against the identity payload in an IKE request, or blank otherwise. If this value matches the value in the identity payload, the credential for the peer can be found using the ipsaPeerIdCredentialName as an index into the credential table.')
ipsaPeerIdAddressType = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 7, 1, 5), InetAddressType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsaPeerIdAddressType.setStatus('current')
if mibBuilder.loadTexts: ipsaPeerIdAddressType.setDescription('The property ipsaPeerIdAddressType specifies the format of the ipsaPeerIdAddress property value.')
ipsaPeerIdAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 7, 1, 6), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsaPeerIdAddress.setStatus('current')
if mibBuilder.loadTexts: ipsaPeerIdAddress.setDescription('The property PeerAddress specifies the IP address of the peer. The format is specified by the ipsaPeerIdAddressType.')
ipsaPeerIdCredentialName = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 7, 1, 7), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsaPeerIdCredentialName.setStatus('current')
if mibBuilder.loadTexts: ipsaPeerIdCredentialName.setDescription('This value is used as an index into the ipsaCredentialTable to look up the actual credential value and other credential information. For peer IDs that have no associated credential information, this value is left blank.')
ipsaPeerIdLastChanged = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 7, 1, 8), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsaPeerIdLastChanged.setStatus('current')
if mibBuilder.loadTexts: ipsaPeerIdLastChanged.setDescription('The value of sysUpTime when this row was last modified or created either through SNMP SETs or by some other external means. If this row has not been modified since the last re-initialization of the network management subsystem, this object SHOULD have a zero value.')
ipsaPeerIdStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 7, 1, 9), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsaPeerIdStorageType.setStatus('current')
if mibBuilder.loadTexts: ipsaPeerIdStorageType.setDescription('The storage type for this row. Rows in this table which were created through an external process MAY have a storage type of readOnly or permanent. For a storage type of permanent, none of the columns have to be writable.')
ipsaPeerIdRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 153, 4, 1, 1, 7, 1, 10), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipsaPeerIdRowStatus.setStatus('current')
if mibBuilder.loadTexts: ipsaPeerIdRowStatus.setDescription('This object indicates the conceptual status of this row. The value of this object has no effect on whether other objects in this conceptual row can be modified. If active, this object MUST remain active if it is referenced by an active row in another table. An attempt to set it to anything other than active while it is referenced by an active row in another table MUST result in an inconsistentValue error.')
ipsaNotificationVariables = MibIdentifier((1, 3, 6, 1, 2, 1, 153, 4, 1, 2, 1))
ipsaNotifications = MibIdentifier((1, 3, 6, 1, 2, 1, 153, 4, 1, 2, 0))
ipsaCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 153, 4, 1, 3, 1))
ipsaGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 153, 4, 1, 3, 2))
ipsaIPsecCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 153, 4, 1, 3, 1, 1)).setObjects(("IPSEC-IPSECACTION-MIB", "ipsaPreconfiguredGroup"), ("IPSEC-IPSECACTION-MIB", "ipsaSharedGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ipsaIPsecCompliance = ipsaIPsecCompliance.setStatus('current')
if mibBuilder.loadTexts: ipsaIPsecCompliance.setDescription('The compliance statement for SNMP entities that include an IPsec MIB implementation and supports IPsec actions. There are a number of INDEX objects that cannot be represented in the form of OBJECT clauses in SMIv2, but for which we have the following compliance requirements, expressed in OBJECT clause form in this description clause: -- OBJECT ipsaPeerIdAddressType -- SYNTAX InetAddressType { ipv4(1), ipv6(2) } -- DESCRIPTION -- Only support for global IPv4 and IPv6 address -- types is required. -- -- OBJECT ipsaPeerIdAddress -- SYNTAX InetAddress (SIZE(4|16)) -- DESCRIPTION -- Only support for global IPv4 and IPv6 address -- types is required. --')
ipsaPreconfiguredGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 153, 4, 1, 3, 2, 1)).setObjects(("IPSEC-IPSECACTION-MIB", "ipsaSaPreActActionDescription"), ("IPSEC-IPSECACTION-MIB", "ipsaSaPreActActionLifetimeSec"), ("IPSEC-IPSECACTION-MIB", "ipsaSaPreActActionLifetimeKB"), ("IPSEC-IPSECACTION-MIB", "ipsaSaPreActDoActionLogging"), ("IPSEC-IPSECACTION-MIB", "ipsaSaPreActDoPacketLogging"), ("IPSEC-IPSECACTION-MIB", "ipsaSaPreActDFHandling"), ("IPSEC-IPSECACTION-MIB", "ipsaSaPreActActionType"), ("IPSEC-IPSECACTION-MIB", "ipsaSaPreActAHSPI"), ("IPSEC-IPSECACTION-MIB", "ipsaSaPreActAHTransformName"), ("IPSEC-IPSECACTION-MIB", "ipsaSaPreActAHSharedSecretName"), ("IPSEC-IPSECACTION-MIB", "ipsaSaPreActESPSPI"), ("IPSEC-IPSECACTION-MIB", "ipsaSaPreActESPTransformName"), ("IPSEC-IPSECACTION-MIB", "ipsaSaPreActESPEncSecretName"), ("IPSEC-IPSECACTION-MIB", "ipsaSaPreActESPAuthSecretName"), ("IPSEC-IPSECACTION-MIB", "ipsaSaPreActIPCompSPI"), ("IPSEC-IPSECACTION-MIB", "ipsaSaPreActIPCompTransformName"), ("IPSEC-IPSECACTION-MIB", "ipsaSaPreActPeerGatewayIdName"), ("IPSEC-IPSECACTION-MIB", "ipsaSaPreActLastChanged"), ("IPSEC-IPSECACTION-MIB", "ipsaSaPreActStorageType"), ("IPSEC-IPSECACTION-MIB", "ipsaSaPreActRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ipsaPreconfiguredGroup = ipsaPreconfiguredGroup.setStatus('current')
if mibBuilder.loadTexts: ipsaPreconfiguredGroup.setDescription('This group is the set of objects that support preconfigured IPsec actions. These objects are from The Preconfigured Action Table. This group also includes objects from the shared tables: Peer Identity Table, Credential Table, Credential Management Service Table and the AH, ESP, and IPComp Transform Tables.')
ipsaSharedGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 153, 4, 1, 3, 2, 2)).setObjects(("IPSEC-IPSECACTION-MIB", "ipsaAhTranMaxLifetimeSec"), ("IPSEC-IPSECACTION-MIB", "ipsaAhTranMaxLifetimeKB"), ("IPSEC-IPSECACTION-MIB", "ipsaAhTranAlgorithm"), ("IPSEC-IPSECACTION-MIB", "ipsaAhTranReplayProtection"), ("IPSEC-IPSECACTION-MIB", "ipsaAhTranReplayWindowSize"), ("IPSEC-IPSECACTION-MIB", "ipsaAhTranLastChanged"), ("IPSEC-IPSECACTION-MIB", "ipsaAhTranStorageType"), ("IPSEC-IPSECACTION-MIB", "ipsaAhTranRowStatus"), ("IPSEC-IPSECACTION-MIB", "ipsaEspTranMaxLifetimeSec"), ("IPSEC-IPSECACTION-MIB", "ipsaEspTranMaxLifetimeKB"), ("IPSEC-IPSECACTION-MIB", "ipsaEspTranCipherTransformId"), ("IPSEC-IPSECACTION-MIB", "ipsaEspTranCipherKeyLength"), ("IPSEC-IPSECACTION-MIB", "ipsaEspTranCipherKeyRounds"), ("IPSEC-IPSECACTION-MIB", "ipsaEspTranIntegrityAlgorithmId"), ("IPSEC-IPSECACTION-MIB", "ipsaEspTranReplayPrevention"), ("IPSEC-IPSECACTION-MIB", "ipsaEspTranReplayWindowSize"), ("IPSEC-IPSECACTION-MIB", "ipsaEspTranLastChanged"), ("IPSEC-IPSECACTION-MIB", "ipsaEspTranStorageType"), ("IPSEC-IPSECACTION-MIB", "ipsaEspTranRowStatus"), ("IPSEC-IPSECACTION-MIB", "ipsaIpcompTranDictionarySize"), ("IPSEC-IPSECACTION-MIB", "ipsaIpcompTranAlgorithm"), ("IPSEC-IPSECACTION-MIB", "ipsaIpcompTranMaxLifetimeSec"), ("IPSEC-IPSECACTION-MIB", "ipsaIpcompTranMaxLifetimeKB"), ("IPSEC-IPSECACTION-MIB", "ipsaIpcompTranPrivateAlgorithm"), ("IPSEC-IPSECACTION-MIB", "ipsaIpcompTranLastChanged"), ("IPSEC-IPSECACTION-MIB", "ipsaIpcompTranStorageType"), ("IPSEC-IPSECACTION-MIB", "ipsaIpcompTranRowStatus"), ("IPSEC-IPSECACTION-MIB", "ipsaCredType"), ("IPSEC-IPSECACTION-MIB", "ipsaCredCredential"), ("IPSEC-IPSECACTION-MIB", "ipsaCredMngName"), ("IPSEC-IPSECACTION-MIB", "ipsaCredSize"), ("IPSEC-IPSECACTION-MIB", "ipsaCredRemoteID"), ("IPSEC-IPSECACTION-MIB", "ipsaCredAdminStatus"), ("IPSEC-IPSECACTION-MIB", "ipsaCredLastChanged"), ("IPSEC-IPSECACTION-MIB", "ipsaCredStorageType"), ("IPSEC-IPSECACTION-MIB", "ipsaCredRowStatus"), ("IPSEC-IPSECACTION-MIB", "ipsaCredSegValue"), ("IPSEC-IPSECACTION-MIB", "ipsaCredSegLastChanged"), ("IPSEC-IPSECACTION-MIB", "ipsaCredSegStorageType"), ("IPSEC-IPSECACTION-MIB", "ipsaCredSegRowStatus"), ("IPSEC-IPSECACTION-MIB", "ipsaPeerIdValue"), ("IPSEC-IPSECACTION-MIB", "ipsaPeerIdType"), ("IPSEC-IPSECACTION-MIB", "ipsaPeerIdAddress"), ("IPSEC-IPSECACTION-MIB", "ipsaPeerIdAddressType"), ("IPSEC-IPSECACTION-MIB", "ipsaPeerIdCredentialName"), ("IPSEC-IPSECACTION-MIB", "ipsaPeerIdLastChanged"), ("IPSEC-IPSECACTION-MIB", "ipsaPeerIdStorageType"), ("IPSEC-IPSECACTION-MIB", "ipsaPeerIdRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ipsaSharedGroup = ipsaSharedGroup.setStatus('current')
if mibBuilder.loadTexts: ipsaSharedGroup.setDescription('This group includes objects from tables expected to be shared by other modules: Peer Identity Table, Credential Table, Credential Management Service Table and the AH, ESP, and IPComp Transform Tables.')
mibBuilder.exportSymbols("IPSEC-IPSECACTION-MIB", IpsecDoiEspTransform=IpsecDoiEspTransform, ipsaSaPreActESPEncSecretName=ipsaSaPreActESPEncSecretName, ipsaSaPreActStorageType=ipsaSaPreActStorageType, ipsaCredName=ipsaCredName, ipsaSaPreconfiguredActionEntry=ipsaSaPreconfiguredActionEntry, ipsaPeerIdAddressType=ipsaPeerIdAddressType, ipsaIpcompTranMaxLifetimeSec=ipsaIpcompTranMaxLifetimeSec, ipsaCredSegStorageType=ipsaCredSegStorageType, ipsaSaPreActESPSPI=ipsaSaPreActESPSPI, ipsaPeerIdStorageType=ipsaPeerIdStorageType, ipsaEspTranMaxLifetimeSec=ipsaEspTranMaxLifetimeSec, ipsaPeerIdentityEntry=ipsaPeerIdentityEntry, ipsaEspTranName=ipsaEspTranName, ipsaIpcompTranName=ipsaIpcompTranName, ipsaPeerIdPriority=ipsaPeerIdPriority, ipsaAhTranMaxLifetimeKB=ipsaAhTranMaxLifetimeKB, ipsaCompliances=ipsaCompliances, ipsaAhTranReplayWindowSize=ipsaAhTranReplayWindowSize, ipsaCredSegLastChanged=ipsaCredSegLastChanged, ipsaSaPreActESPTransformName=ipsaSaPreActESPTransformName, ipsaCredentialSegmentTable=ipsaCredentialSegmentTable, ipsaSaPreActActionLifetimeKB=ipsaSaPreActActionLifetimeKB, ipsaEspTranReplayPrevention=ipsaEspTranReplayPrevention, ipsaEspTranCipherTransformId=ipsaEspTranCipherTransformId, ipsaCredentialTable=ipsaCredentialTable, ipsaSaPreActActionType=ipsaSaPreActActionType, IpsecDoiIpcompTransform=IpsecDoiIpcompTransform, ipsaIpcompTranRowStatus=ipsaIpcompTranRowStatus, ipsaEspTranIntegrityAlgorithmId=ipsaEspTranIntegrityAlgorithmId, ipsaGroups=ipsaGroups, ipsaEspTransformTable=ipsaEspTransformTable, ipsaCredSegValue=ipsaCredSegValue, ipsaIpcompTranDictionarySize=ipsaIpcompTranDictionarySize, ipsaNotifications=ipsaNotifications, ipsaNotificationObjects=ipsaNotificationObjects, ipsaPeerIdType=ipsaPeerIdType, ipsaSaPreActSADirection=ipsaSaPreActSADirection, ipsaSaPreActDoActionLogging=ipsaSaPreActDoActionLogging, ipsaAhTranLastChanged=ipsaAhTranLastChanged, IpsecDoiIdentType=IpsecDoiIdentType, ipsaCredRowStatus=ipsaCredRowStatus, ipsaAhTranRowStatus=ipsaAhTranRowStatus, ipsaSaPreActLastChanged=ipsaSaPreActLastChanged, ipsaSaPreconfiguredActionTable=ipsaSaPreconfiguredActionTable, ipsaConformanceObjects=ipsaConformanceObjects, ipsaSaPreActIPCompTransformName=ipsaSaPreActIPCompTransformName, ipsaIpcompTransformTable=ipsaIpcompTransformTable, ipsaAhTranReplayProtection=ipsaAhTranReplayProtection, ipsaCredMngName=ipsaCredMngName, ipsaSaPreActActionDescription=ipsaSaPreActActionDescription, ipsaSaPreActAHSharedSecretName=ipsaSaPreActAHSharedSecretName, ipsaMIB=ipsaMIB, ipsaAhTranMaxLifetimeSec=ipsaAhTranMaxLifetimeSec, ipsaIpcompTransformEntry=ipsaIpcompTransformEntry, ipsaSaPreActActionLifetimeSec=ipsaSaPreActActionLifetimeSec, ipsaEspTranLastChanged=ipsaEspTranLastChanged, ipsaPeerIdentityTable=ipsaPeerIdentityTable, ipsaCredStorageType=ipsaCredStorageType, ipsaAhTransformTable=ipsaAhTransformTable, ipsaCredentialEntry=ipsaCredentialEntry, ipsaSaPreActActionName=ipsaSaPreActActionName, ipsaAhTranAlgorithm=ipsaAhTranAlgorithm, ipsaIpcompTranMaxLifetimeKB=ipsaIpcompTranMaxLifetimeKB, ipsaCredAdminStatus=ipsaCredAdminStatus, IpsaIdentityFilter=IpsaIdentityFilter, ipsaSaPreActDFHandling=ipsaSaPreActDFHandling, ipsaPreconfiguredGroup=ipsaPreconfiguredGroup, ipsaCredentialSegmentEntry=ipsaCredentialSegmentEntry, ipsaCredLastChanged=ipsaCredLastChanged, ipsaIpcompTranAlgorithm=ipsaIpcompTranAlgorithm, ipsaCredSegIndex=ipsaCredSegIndex, ipsaAhTranName=ipsaAhTranName, ipsaPeerIdValue=ipsaPeerIdValue, ipsaSaPreActDoPacketLogging=ipsaSaPreActDoPacketLogging, ipsaIpcompTranStorageType=ipsaIpcompTranStorageType, IpsecDoiAuthAlgorithm=IpsecDoiAuthAlgorithm, ipsaNotificationVariables=ipsaNotificationVariables, PYSNMP_MODULE_ID=ipsaMIB, ipsaPeerIdName=ipsaPeerIdName, ipsaSaPreActAHSPI=ipsaSaPreActAHSPI, ipsaEspTranCipherKeyRounds=ipsaEspTranCipherKeyRounds, ipsaEspTransformEntry=ipsaEspTransformEntry, ipsaPeerIdCredentialName=ipsaPeerIdCredentialName, ipsaSaPreActPeerGatewayIdName=ipsaSaPreActPeerGatewayIdName, ipsaSaPreActESPAuthSecretName=ipsaSaPreActESPAuthSecretName, ipsaEspTranRowStatus=ipsaEspTranRowStatus, ipsaCredCredential=ipsaCredCredential, ipsaPeerIdLastChanged=ipsaPeerIdLastChanged, ipsaSaPreActRowStatus=ipsaSaPreActRowStatus, ipsaIpcompTranLastChanged=ipsaIpcompTranLastChanged, ipsaCredSegRowStatus=ipsaCredSegRowStatus, IpsecDoiEncapsulationMode=IpsecDoiEncapsulationMode, ipsaCredType=ipsaCredType, ipsaCredSize=ipsaCredSize, ipsaCredRemoteID=ipsaCredRemoteID, ipsaSaPreActAHTransformName=ipsaSaPreActAHTransformName, ipsaPeerIdAddress=ipsaPeerIdAddress, ipsaEspTranCipherKeyLength=ipsaEspTranCipherKeyLength, ipsaIPsecCompliance=ipsaIPsecCompliance, ipsaIpcompTranPrivateAlgorithm=ipsaIpcompTranPrivateAlgorithm, ipsaEspTranMaxLifetimeKB=ipsaEspTranMaxLifetimeKB, ipsaAhTranStorageType=ipsaAhTranStorageType, ipsaEspTranReplayWindowSize=ipsaEspTranReplayWindowSize, ipsaConfigObjects=ipsaConfigObjects, ipsaEspTranStorageType=ipsaEspTranStorageType, ipsaAhTransformEntry=ipsaAhTransformEntry, ipsaPeerIdRowStatus=ipsaPeerIdRowStatus, IpsaCredentialType=IpsaCredentialType, ipsaSharedGroup=ipsaSharedGroup, ipsaSaPreActIPCompSPI=ipsaSaPreActIPCompSPI)

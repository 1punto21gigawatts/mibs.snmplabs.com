#
# PySNMP MIB module LANNET-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/LANNET-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:05:39 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ValueRangeConstraint, SingleValueConstraint, ConstraintsIntersection, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsIntersection", "ConstraintsUnion")
DisplayString, = mibBuilder.importSymbols("RFC1158-MIB", "DisplayString")
MibScalar, MibTable, MibTableRow, MibTableColumn = mibBuilder.importSymbols("RFC1212", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Counter64, Unsigned32, ObjectIdentity, Bits, MibIdentifier, enterprises, ModuleIdentity, Integer32, MibScalar, MibTable, MibTableRow, MibTableColumn, Gauge32, IpAddress, iso, NotificationType, TimeTicks, Counter32 = mibBuilder.importSymbols("SNMPv2-SMI", "Counter64", "Unsigned32", "ObjectIdentity", "Bits", "MibIdentifier", "enterprises", "ModuleIdentity", "Integer32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Gauge32", "IpAddress", "iso", "NotificationType", "TimeTicks", "Counter32")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
lannet = MibIdentifier((1, 3, 6, 1, 4, 1, 81))
chassis = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 7))
genGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 8))
genPort = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 9))
genIntPort = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 10))
softRedundancy = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 11))
eth = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 12))
tok = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 13))
ts = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 14))
ltalk = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 15))
cl = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 16))
lntOID = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 17))
chHWType = MibScalar((1, 3, 6, 1, 4, 1, 81, 7, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 255))).clone(namedValues=NamedValues(("let18", 1), ("let3", 2), ("let36", 3), ("let18Extended", 4), ("lert40", 5), ("let10", 6), ("fdx100", 7), ("unknown", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chHWType.setStatus('mandatory')
if mibBuilder.loadTexts: chHWType.setDescription('Indicates type of enclosure in which the LANNET SNMP agent operates.')
chNumberOfSlots = MibScalar((1, 3, 6, 1, 4, 1, 81, 7, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chNumberOfSlots.setStatus('mandatory')
if mibBuilder.loadTexts: chNumberOfSlots.setDescription('Number of manageable slots in the chassis. In LANNET implementation it describes the number of manageable slots in the chassis (not all slots should be ocuppied).')
chNumberOfEthernetBuses = MibScalar((1, 3, 6, 1, 4, 1, 81, 7, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chNumberOfEthernetBuses.setStatus('mandatory')
if mibBuilder.loadTexts: chNumberOfEthernetBuses.setDescription('Indicates the number of internal Ethernet buses provided by the box.')
chNumberOfTRBuses = MibScalar((1, 3, 6, 1, 4, 1, 81, 7, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chNumberOfTRBuses.setStatus('mandatory')
if mibBuilder.loadTexts: chNumberOfTRBuses.setDescription('Indicates the number of internal Token Ring buses provided by the box.')
chNumberOfFDDIBuses = MibScalar((1, 3, 6, 1, 4, 1, 81, 7, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chNumberOfFDDIBuses.setStatus('mandatory')
if mibBuilder.loadTexts: chNumberOfFDDIBuses.setDescription('Indicates the number of internal FDDI buses provided by the box.')
chNumberOfLocalTalkBuses = MibScalar((1, 3, 6, 1, 4, 1, 81, 7, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chNumberOfLocalTalkBuses.setStatus('mandatory')
if mibBuilder.loadTexts: chNumberOfLocalTalkBuses.setDescription('Indicates the number of internal Local Talk buses provided by the box.')
chReset = MibScalar((1, 3, 6, 1, 4, 1, 81, 7, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chReset.setStatus('mandatory')
if mibBuilder.loadTexts: chReset.setDescription('Setting the value of this attribute to ON is interpreted as a reset command for the whole chassis. It initiates a complete reinitialisation of the chassis and of all the devices incorporated inside the chassis.')
chFullConfig = MibScalar((1, 3, 6, 1, 4, 1, 81, 7, 8), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chFullConfig.setStatus('mandatory')
if mibBuilder.loadTexts: chFullConfig.setDescription('Full configuration message retrieved by LANNET management stations at periodic interrogation times. Coded in compact internal LANNET application format.')
chAg = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 7, 9))
chGenAgTable = MibTable((1, 3, 6, 1, 4, 1, 81, 7, 9, 1), )
if mibBuilder.loadTexts: chGenAgTable.setStatus('mandatory')
if mibBuilder.loadTexts: chGenAgTable.setDescription('Table of configuration attributes common to all SNMP agents in LANNET hubs.')
chGenAgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 7, 9, 1, 1), ).setIndexNames((0, "LANNET-MIB", "chGenAgId"))
if mibBuilder.loadTexts: chGenAgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: chGenAgEntry.setDescription('An entry in the table, containing configuration attributes for a single agent.')
chGenAgId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 7, 9, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chGenAgId.setStatus('mandatory')
if mibBuilder.loadTexts: chGenAgId.setDescription('Agent index for identifying the agent.Takes the value of the slot number where the agent card is inserted. For box agents the value of chGenAgId is chNumberOfSlots+1.')
chGenAgType = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 7, 9, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 255))).clone(namedValues=NamedValues(("nma1-et", 1), ("nma1-et-e", 2), ("nma1-tr", 3), ("nma2-et", 4), ("nma2-tr", 5), ("nma2-fddi", 6), ("ielb", 7), ("itlb", 8), ("lts16", 9), ("unknown", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chGenAgType.setStatus('mandatory')
if mibBuilder.loadTexts: chGenAgType.setDescription('Agent type.')
chGenAgMgmtIfType = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 7, 9, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 255))).clone(namedValues=NamedValues(("none", 1), ("regular1822", 2), ("hdh1822", 3), ("ddn-x25", 4), ("rfc877-x25", 5), ("ethernet-csmacd", 6), ("iso88023-csmacd", 7), ("iso88024-tokenBus", 8), ("iso88025-tokenRing", 9), ("iso88026-man", 10), ("starLan", 11), ("proteon-10MBit", 12), ("proteon-80MBit", 13), ("hyperchannel", 14), ("fddi", 15), ("lapb", 16), ("sdlc", 17), ("t1-carrier", 18), ("cept", 19), ("basicIsdn", 20), ("primaryIsdn", 21), ("propPointToPointSerial", 22), ("ppp", 23), ("softwareLoopback", 24), ("eon", 25), ("ethernet-3Mbit", 26), ("nsip", 27), ("slip", 28), ("ip", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chGenAgMgmtIfType.setStatus('mandatory')
if mibBuilder.loadTexts: chGenAgMgmtIfType.setDescription("This attribute describes one of the interfaces of agents existing on LANNET modules and their type. Value 'none' defines the lack of an interface recognized by the management console. Any other value defines an interface whose type is recognized by the management console and may be used as a management channel.")
chGenAgAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 7, 9, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chGenAgAddr.setStatus('mandatory')
if mibBuilder.loadTexts: chGenAgAddr.setDescription('This attribute defines an unique address by which the agent may be addressed by the management console. The address format should be consistent with the type defined by chGenAgMgmtIfType.')
chGenAgSpecificOID = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 7, 9, 1, 1, 5), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chGenAgSpecificOID.setStatus('mandatory')
if mibBuilder.loadTexts: chGenAgSpecificOID.setDescription('This attribute provides the OID of another group containing additional more specific information regarding this instance.')
chLntAgTable = MibTable((1, 3, 6, 1, 4, 1, 81, 7, 9, 2), )
if mibBuilder.loadTexts: chLntAgTable.setStatus('mandatory')
if mibBuilder.loadTexts: chLntAgTable.setDescription('Table of configuration attributes of LANNET SNMP box agents in LANNET hubs.')
chLntAgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 7, 9, 2, 1), ).setIndexNames((0, "LANNET-MIB", "chLntAgId"))
if mibBuilder.loadTexts: chLntAgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: chLntAgEntry.setDescription('An entry in the table, containing configuration attributes for a single agent.')
chLntAgId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 7, 9, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chLntAgId.setStatus('mandatory')
if mibBuilder.loadTexts: chLntAgId.setDescription('Agent index for identifying the agent. Identical to the index in chGenAgTable for the described agent.')
chLntAgSLIPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 7, 9, 2, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chLntAgSLIPAddress.setStatus('mandatory')
if mibBuilder.loadTexts: chLntAgSLIPAddress.setDescription('IP address of the SLIP channel of the agent')
chLntAgSWVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 7, 9, 2, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chLntAgSWVersion.setStatus('mandatory')
if mibBuilder.loadTexts: chLntAgSWVersion.setDescription('ASCII string for description and display of the agent software version.')
chLntAgKernelVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 7, 9, 2, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chLntAgKernelVersion.setStatus('mandatory')
if mibBuilder.loadTexts: chLntAgKernelVersion.setDescription('ASCII string for description and display of the agent operating system (kernel) version.')
chLntAgCoprocSWVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 7, 9, 2, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chLntAgCoprocSWVersion.setStatus('mandatory')
if mibBuilder.loadTexts: chLntAgCoprocSWVersion.setDescription("ASCII string describing the software version of the agent's coprocessor.")
chLntAgSWFault = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 7, 9, 2, 1, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chLntAgSWFault.setStatus('mandatory')
if mibBuilder.loadTexts: chLntAgSWFault.setDescription('System fault emitted by agent software. It covers faults detected by the agent operating system and drivers. EnterpriseSpecific traps mechanism is used for transfering these traps to the management system.')
chLntAgMgmtBusSelection = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 7, 9, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chLntAgMgmtBusSelection.setStatus('mandatory')
if mibBuilder.loadTexts: chLntAgMgmtBusSelection.setDescription('Attribute describing the number of the bus on which management data are reported.')
chLntAgCoprocCommStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 7, 9, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ok", 1), ("commProblems", 2), ("timeout", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chLntAgCoprocCommStatus.setStatus('mandatory')
if mibBuilder.loadTexts: chLntAgCoprocCommStatus.setDescription('Attribute describing the status of the communication between the agent and its coprocessor.')
chLntAgCommDebugMode = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 7, 9, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chLntAgCommDebugMode.setStatus('mandatory')
if mibBuilder.loadTexts: chLntAgCommDebugMode.setDescription("Attribute describing the agent mode in which communication problem traps are sent to managers (value 'on') or are not sent to managers (value 'off').")
chLntAgConfigChangeTraps = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 7, 9, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chLntAgConfigChangeTraps.setStatus('mandatory')
if mibBuilder.loadTexts: chLntAgConfigChangeTraps.setDescription('The value of this attributes determines whether or not the agent sends Configuration Change traps to the manager.')
chLntAgFaultTraps = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 7, 9, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chLntAgFaultTraps.setStatus('mandatory')
if mibBuilder.loadTexts: chLntAgFaultTraps.setDescription('The value of this attributes determines whether or not the agent sends Fault traps to the manager.')
chLntAgTrafficThreshTraps = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 7, 9, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chLntAgTrafficThreshTraps.setStatus('mandatory')
if mibBuilder.loadTexts: chLntAgTrafficThreshTraps.setDescription('The value of this attributes determines whether or not the agent sends Traffic Threshold traps to the manager.')
chLntAgGroupEnrollDeenrollTraps = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 7, 9, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chLntAgGroupEnrollDeenrollTraps.setStatus('mandatory')
if mibBuilder.loadTexts: chLntAgGroupEnrollDeenrollTraps.setDescription('The value of this attributes determines whether or not the agent sends Group Enrollment and Group Deenrollment traps to the manager.')
chLntAgSoftFaultTraps = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 7, 9, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chLntAgSoftFaultTraps.setStatus('mandatory')
if mibBuilder.loadTexts: chLntAgSoftFaultTraps.setDescription('The value of this attributes determines whether or not the agent sends Software Fault traps to the manager.')
chLntAgHubEnrollTraps = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 7, 9, 2, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chLntAgHubEnrollTraps.setStatus('mandatory')
if mibBuilder.loadTexts: chLntAgHubEnrollTraps.setDescription('The value of this attributes determines whether or not the agent sends periodic Hub Enrollment traps to the manager.')
chLntAgTempThreshTraps = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 7, 9, 2, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chLntAgTempThreshTraps.setStatus('mandatory')
if mibBuilder.loadTexts: chLntAgTempThreshTraps.setDescription('The value of this attributes determines whether or not the agent sends Temperature Threshold traps to the manager.')
chLntAgSpecificOID = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 7, 9, 2, 1, 17), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chLntAgSpecificOID.setStatus('mandatory')
if mibBuilder.loadTexts: chLntAgSpecificOID.setDescription('This attribute provides the OID of another group containing additional more specific information regarding this instance.')
chLntAgLastAddrConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 7, 9, 2, 1, 18), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chLntAgLastAddrConfig.setStatus('mandatory')
if mibBuilder.loadTexts: chLntAgLastAddrConfig.setDescription('Configuration attribute describing the last physical address detected at each port. Coded in internal LANNET application format. ')
chLntAgSecAddrConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 7, 9, 2, 1, 19), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chLntAgSecAddrConfig.setStatus('mandatory')
if mibBuilder.loadTexts: chLntAgSecAddrConfig.setDescription('Configuration attribute describing the configuration of the secure addresses. Coded in internal LANNET application format. ')
chLntAgSoftwareStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 7, 9, 2, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unLoadable", 1), ("loaded", 2), ("downLoading", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chLntAgSoftwareStatus.setStatus('mandatory')
if mibBuilder.loadTexts: chLntAgSoftwareStatus.setDescription('Describes configuration of the firmware on this agent. unLoadable(1) - is returned by agents which do not support the Software Download feature; loaded(2) - is returned by agents with loaded software; downLoading(3) - when the attribute is set to this value by manager, it triggers the Software Download procedure. When procedure finished, agent software will restablish value loaded(2).')
chLntAgConfigurationSymbol = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 7, 9, 2, 1, 21), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chLntAgConfigurationSymbol.setStatus('mandatory')
if mibBuilder.loadTexts: chLntAgConfigurationSymbol.setDescription("Defines the Configuration Symbol attached to any hardware module manufactured by LANNET. One single character A..Z defines the CS version. For older modules which did not support this option on SNMP character '*' will be returned.")
chLntAgIntTemp = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 7, 9, 2, 1, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chLntAgIntTemp.setStatus('mandatory')
if mibBuilder.loadTexts: chLntAgIntTemp.setDescription('Internal temperature measured by the temperature sensor placed on the agent card. Expressed in Celsius degrees.')
chLntAgBootVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 7, 9, 2, 1, 23), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chLntAgBootVersion.setStatus('mandatory')
if mibBuilder.loadTexts: chLntAgBootVersion.setDescription('ASCII string for description and display of the agent boot software version.')
chMgr = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 7, 10))
chMgrTrapRepStatus = MibScalar((1, 3, 6, 1, 4, 1, 81, 7, 10, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chMgrTrapRepStatus.setStatus('mandatory')
if mibBuilder.loadTexts: chMgrTrapRepStatus.setDescription("Value 'on' indicates that SNMP agent should send SNMP traps (traffic ex- cluded) to the manager.")
chMgrContPerfRep = MibScalar((1, 3, 6, 1, 4, 1, 81, 7, 10, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chMgrContPerfRep.setStatus('mandatory')
if mibBuilder.loadTexts: chMgrContPerfRep.setDescription("Value 'on' indicates that the SNMP agent should send traffic SNMP traps to the manager.")
chMgrMngmtState = MibScalar((1, 3, 6, 1, 4, 1, 81, 7, 10, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chMgrMngmtState.setStatus('mandatory')
if mibBuilder.loadTexts: chMgrMngmtState.setDescription("Attribute to be set by manager in order to instruct the agent to enter into a management session with the console. Setting this value to 'on' has the effect of performing an 'I am your manager' action upon the agent.")
chHW = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 7, 11))
chHWPSUTable = MibTable((1, 3, 6, 1, 4, 1, 81, 7, 11, 1), )
if mibBuilder.loadTexts: chHWPSUTable.setStatus('mandatory')
if mibBuilder.loadTexts: chHWPSUTable.setDescription('Table of configuration attributes for Power Supply Units. This table can be retrieved only from agents equipped with adequate hardware.')
chHWPSUEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 7, 11, 1, 1), ).setIndexNames((0, "LANNET-MIB", "chHWPSUId"))
if mibBuilder.loadTexts: chHWPSUEntry.setStatus('mandatory')
if mibBuilder.loadTexts: chHWPSUEntry.setDescription('An entry in the table, containing configuration attributes for a single Power Supply Unit.')
chHWPSUId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 7, 11, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chHWPSUId.setStatus('mandatory')
if mibBuilder.loadTexts: chHWPSUId.setDescription('PSU index for identifying the PSU.')
chHWPSUActivityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 7, 11, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notActive", 1), ("dormant", 2), ("active", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chHWPSUActivityStatus.setStatus('mandatory')
if mibBuilder.loadTexts: chHWPSUActivityStatus.setDescription('This attribute defines the status of the PSU in what concerns supplying power to the chassis. NotActive - indicates a disabled or defective PSU which cannot supply power to the chassis. Dormant - indicates a functional PSU which is installed for backup purposes and can at any moment supply power to the devices in the chassis. Active - indicates that the PSU supplies power to the chassis.')
chHWPSULocation = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 7, 11, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("internal", 2), ("external", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chHWPSULocation.setStatus('mandatory')
if mibBuilder.loadTexts: chHWPSULocation.setDescription('Describes the location (internal or external) of the PSU.')
chHWPSUVoltage = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 7, 11, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chHWPSUVoltage.setStatus('mandatory')
if mibBuilder.loadTexts: chHWPSUVoltage.setDescription('Indicates voltage of PSU expressed in miliVolts.')
chHWIntTempWarning = MibScalar((1, 3, 6, 1, 4, 1, 81, 7, 11, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("exceeded", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chHWIntTempWarning.setStatus('mandatory')
if mibBuilder.loadTexts: chHWIntTempWarning.setDescription('Fault condition indicating that the temperature measured by one of the sensors internal to the box exceeded chHWIntTempThresh.')
chHWIntTempThresh = MibScalar((1, 3, 6, 1, 4, 1, 81, 7, 11, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chHWIntTempThresh.setStatus('mandatory')
if mibBuilder.loadTexts: chHWIntTempThresh.setDescription('Internal enclosure temperature threshold value, expressed in degrees Celsius. When exceeded, a trap is sent to the management console. ')
chHWPeakIntTemp = MibScalar((1, 3, 6, 1, 4, 1, 81, 7, 11, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chHWPeakIntTemp.setStatus('mandatory')
if mibBuilder.loadTexts: chHWPeakIntTemp.setDescription('Maximum internal temperature inside the chassis. It is the maximum of the temperature values detected by different temperature sensors inside the box. ')
genGroupTable = MibTable((1, 3, 6, 1, 4, 1, 81, 8, 1), )
if mibBuilder.loadTexts: genGroupTable.setStatus('mandatory')
if mibBuilder.loadTexts: genGroupTable.setDescription('Table of configuration attributes for managed LANNET modules. Includes configuration data which are independent of the specific functionality of the module.')
genGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 8, 1, 1), ).setIndexNames((0, "LANNET-MIB", "genGroupId"))
if mibBuilder.loadTexts: genGroupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: genGroupEntry.setDescription('An entry in the table, containing data about a single group.')
genGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 8, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: genGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: genGroupId.setDescription('Index which identifies the group inside the chassis for which this entry contains information. Equals the number of the slot by which the group is accessed. This value is never greater than chNumberOfSlots.')
genGroupSWVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 8, 1, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: genGroupSWVersion.setStatus('mandatory')
if mibBuilder.loadTexts: genGroupSWVersion.setDescription('ASCII string for description and display of the group software version.')
genGroupKernelVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 8, 1, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: genGroupKernelVersion.setStatus('mandatory')
if mibBuilder.loadTexts: genGroupKernelVersion.setDescription('ASCII string for description and display of the group kernel version.')
genGroupType = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 8, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 255))).clone(namedValues=NamedValues(("le10b", 1), ("le10b-2", 2), ("le10c", 3), ("le10c-2", 4), ("le15", 5), ("le15-2", 6), ("le20", 7), ("le30x", 8), ("le30x-2", 9), ("le30xd", 10), ("le40x", 11), ("le40xt", 12), ("ltr4-RJ45", 13), ("ltr4-D9", 14), ("ltr4-D25", 15), ("ltr4-FO", 16), ("ltrio-RJ45", 19), ("ltrio-D9", 20), ("ltrio-D25", 21), ("ltrio-FO", 22), ("ltrio-Con1", 23), ("ltrio-Con2", 24), ("le10b-2r", 25), ("le10c-2r", 26), ("le80xt", 27), ("le140xt", 28), ("ielb", 29), ("ltrf4", 30), ("ltrf16", 31), ("lts16", 32), ("le20n", 33), ("ltr104-RJ45", 34), ("le20r", 35), ("llt8", 36), ("le20s", 37), ("le10b2n", 38), ("ltr104-D9", 39), ("ltr104-D25", 40), ("ltrt-RJ45", 41), ("ltrt-D9", 42), ("ltr104f", 43), ("itlb", 44), ("le140xtf", 45), ("le120r", 46), ("le120r-2", 47), ("le140xtc", 48), ("le110b", 49), ("le110bq", 50), ("lcl100", 51), ("le140xtq", 52), ("le20n-fb", 53), ("le20s-fb", 54), ("le140xtf-fb", 55), ("ltr104s", 56), ("lert40-AUI", 57), ("lert40-10BASET", 58), ("lfd104-mic", 59), ("lfd104-stm", 60), ("lfd104-stl", 61), ("lfd104-stp", 62), ("lfd104-utp", 63), ("lfd102-mic", 64), ("lfd102-stm", 65), ("lfd102-sts", 66), ("le140xtn", 67), ("unknown", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: genGroupType.setStatus('mandatory')
if mibBuilder.loadTexts: genGroupType.setDescription('Attribute describing the type of LANNET Ethernet group.')
genGroupDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 8, 1, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: genGroupDescr.setStatus('mandatory')
if mibBuilder.loadTexts: genGroupDescr.setDescription('Descriptor of the group in ASCII (readable) format, mainly for use with generic management applications.')
genGroupNumberOfPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 8, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: genGroupNumberOfPorts.setStatus('mandatory')
if mibBuilder.loadTexts: genGroupNumberOfPorts.setDescription('Number of ports in group. It is assumed that on each group the ports are assigned unique numbers in the range from 1 to genGroupNumberOfPorts. They correspond to the number of ports on the module (FRU)')
genGroupNumberOfIntPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 8, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: genGroupNumberOfIntPorts.setStatus('mandatory')
if mibBuilder.loadTexts: genGroupNumberOfIntPorts.setDescription('Number of internal ports (ports connected to the chassis buses) on the module.')
genGroupReset = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 8, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: genGroupReset.setStatus('mandatory')
if mibBuilder.loadTexts: genGroupReset.setDescription("Setting the value of this attribute to 'on' is interpreted as a software RESET command. Sensor software is reinitialized and according to the sensor specifications, partial or total reset of the module hardware may be performed.")
genGroupAutoMan = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 8, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("auto", 1), ("man", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: genGroupAutoMan.setStatus('mandatory')
if mibBuilder.loadTexts: genGroupAutoMan.setDescription('This attribute reflects the status of the Auto/Manual switch which defines the working mode of LANNET sensors. In the MANUAL mode no set operations may be performed on attributes related to the sensor. The sensor works according to configuration switches set by hardware and transmits all configuration information to the agent. In the AUTO mode, hardware switches are overridden by set commands.')
genGroupFullConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 8, 1, 1, 10), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: genGroupFullConfig.setStatus('mandatory')
if mibBuilder.loadTexts: genGroupFullConfig.setDescription('Attribute describing the full configuration of a group in internal LANNET application format.')
genGroupRedun12 = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 8, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: genGroupRedun12.setStatus('mandatory')
if mibBuilder.loadTexts: genGroupRedun12.setDescription('Value ON of this attribute defines a redundancy (backup) relationship between synchronous external ports 1 and 2 on a LANNET module.')
genGroupRedun34 = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 8, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: genGroupRedun34.setStatus('mandatory')
if mibBuilder.loadTexts: genGroupRedun34.setDescription('Value ON of this attribute defines a redundancy (backup) relationship between synchronous external ports 3 and 4 on a LANNET module.')
genGroupRedun13_14 = MibScalar((1, 3, 6, 1, 4, 1, 81, 8, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setLabel("genGroupRedun13-14").setMaxAccess("readwrite")
if mibBuilder.loadTexts: genGroupRedun13_14.setStatus('mandatory')
if mibBuilder.loadTexts: genGroupRedun13_14.setDescription('Value ON of this attribute defines a redundancy (backup) relationship between synchronous external ports 13 and 14 on a LANNET module.')
genGroupStandAloneMode = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 8, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: genGroupStandAloneMode.setStatus('mandatory')
if mibBuilder.loadTexts: genGroupStandAloneMode.setDescription("Value ON of this attribute indicates the sensor's operation Stand Alone mode . Internal ports are disabled and the card functions in a local star configuration toward its external ports.")
genGroupInterProcCommStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 8, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 255))).clone(namedValues=NamedValues(("ok", 1), ("commProblems", 2), ("noCommunication", 3), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: genGroupInterProcCommStatus.setStatus('mandatory')
if mibBuilder.loadTexts: genGroupInterProcCommStatus.setDescription('This attribute describes the status of the communication between the microprocessor of the sensor and the microprocessor of the agent on cards with embedded agents.')
genGroupCommStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 8, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 255))).clone(namedValues=NamedValues(("ok", 1), ("commProblems", 2), ("noCommunication", 3), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: genGroupCommStatus.setStatus('mandatory')
if mibBuilder.loadTexts: genGroupCommStatus.setDescription('This attribute describes the communication status of the group with the SNMP Agent as detected and reported by the agent.')
genGroupHWStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 8, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("ok", 1), ("hardwareProblems", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: genGroupHWStatus.setStatus('mandatory')
if mibBuilder.loadTexts: genGroupHWStatus.setDescription('This attribute describes the status of the group hardware as detected by the sensors software.')
genGroupSupplyVoltageFault = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 8, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: genGroupSupplyVoltageFault.setStatus('mandatory')
if mibBuilder.loadTexts: genGroupSupplyVoltageFault.setDescription("A value 'on' of this attribute informs of a 'voltage supply out-of-range' error condition on sensor equipped with hardware which checks this condition.")
genGroupIntTemp = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 8, 1, 1, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: genGroupIntTemp.setStatus('mandatory')
if mibBuilder.loadTexts: genGroupIntTemp.setDescription('Internal temperature of the enclosure as measured by the specific module instance.')
genGroupSpecificOID = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 8, 1, 1, 20), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: genGroupSpecificOID.setStatus('mandatory')
if mibBuilder.loadTexts: genGroupSpecificOID.setDescription('This attribute provides the OID of another group containing additional more specific information regarding this instance.')
genGroupConfigurationSymbol = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 8, 1, 1, 21), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: genGroupConfigurationSymbol.setStatus('mandatory')
if mibBuilder.loadTexts: genGroupConfigurationSymbol.setDescription("Defines the Configuration Symbol attached to any hardware module manufactured by LANNET. One single character A..Z defines the CS version. For older modules which did not support this option on SNMP character '*' will be returned.")
genPortTable = MibTable((1, 3, 6, 1, 4, 1, 81, 9, 1), )
if mibBuilder.loadTexts: genPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: genPortTable.setDescription('Table of configuration attributes for managed LANNET ports. Includes configuration data which are independent of the specific functionality of the port.')
genPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 9, 1, 1), ).setIndexNames((0, "LANNET-MIB", "genPortGroupId"), (0, "LANNET-MIB", "genPortId"))
if mibBuilder.loadTexts: genPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: genPortEntry.setDescription('An entry in the table, containing data about a single port.')
genPortGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 9, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: genPortGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: genPortGroupId.setDescription('Index which identifies the group inside the chassis for which this entry contains information. Equals the number of the slot by which the group containing the port is accessed. This value is never greater than chNumberOfSlots.')
genPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 9, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: genPortId.setStatus('mandatory')
if mibBuilder.loadTexts: genPortId.setDescription('Index which identifies the port inside the group for which this entry contains information. It generally corresponds with the number by which the port is identified and is marked on the module. This value is never greater than genGroupNumberOfPorts of the group to which the port belongs.')
genPortFunctionality = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 9, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("private", 1), ("repeaterAUI", 2), ("repeaterThin", 3), ("repeater10BaseT", 4), ("tenBaseFSyncAct", 5), ("foirl", 6), ("xcvr", 7), ("lobe", 8), ("ri", 9), ("ro", 10), ("serial", 11), ("localTalk", 12), ("fddi", 13), ("clock", 14), ("genTokenRing", 15), ("dte", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: genPortFunctionality.setStatus('mandatory')
if mibBuilder.loadTexts: genPortFunctionality.setDescription('Describes the functionality of the port according to international standards.')
genPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 9, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 255))).clone(namedValues=NamedValues(("le10bPort", 1), ("le10cPort", 2), ("le15Port", 3), ("le20Port", 4), ("le30xPort", 5), ("le30xdPort", 6), ("le40xPort", 7), ("le40xtPort", 8), ("lobeRJ45", 9), ("lobeD9", 10), ("lobeD25", 11), ("lobeFO", 12), ("ri104D25", 13), ("ro104D25", 14), ("riRJ45", 15), ("riD9", 16), ("riD25", 17), ("riFO", 18), ("ri104RJ45", 19), ("ri104D9", 20), ("roRJ45", 21), ("roD9", 22), ("roD25", 23), ("roFO", 24), ("ro104RJ45", 25), ("ro104D9", 26), ("le80xtPort", 27), ("le140xtPort", 28), ("ielb-AUIPort", 29), ("ielb-10btPort", 30), ("ltrf4Port", 31), ("ltrf16Port", 32), ("lts16Port", 33), ("llt8Port", 34), ("le20rPort", 35), ("itlbRoPort", 36), ("itlbRiPort", 37), ("itlbDTEPort", 38), ("starFO", 39), ("le10bnPort", 40), ("le120rPort", 41), ("le140xtf-foPort", 42), ("le140xtf-10btPort", 43), ("le140xtcPort", 44), ("le110bPort", 45), ("le110bqPort", 46), ("le140xtqPort", 47), ("lert40-AUIPort", 48), ("lert40-10btPort", 49), ("clock-int", 50), ("clock-ext", 51), ("ri104RJ45S", 52), ("r0104RJ45S", 53), ("lobe104RJ45S", 54), ("le20fbPort", 55), ("le140xtf-fofbPort", 56), ("fddi-micPort1", 57), ("fddi-micPort2", 58), ("fddi-micPort3", 59), ("fddi-stmPort1", 60), ("fddi-stmPort2", 61), ("fddi-stmPort3", 62), ("fddi-stlPort1", 63), ("fddi-stlPort2", 64), ("fddi-stlPort3", 65), ("fddi-stpPort1", 66), ("fddi-stpPort2", 67), ("fddi-stpPort3", 68), ("fddi-utpPort1", 69), ("fddi-utpPort2", 70), ("fddi-utpPort3", 71), ("fddi-stsPort1", 72), ("fddi-stsPort2", 73), ("fddi-stsPort3", 74), ("le140xtnPort", 75), ("unknownPort", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: genPortType.setStatus('mandatory')
if mibBuilder.loadTexts: genPortType.setDescription('Attribute describing the type of LANNET port.')
genPortDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 9, 1, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: genPortDescr.setStatus('mandatory')
if mibBuilder.loadTexts: genPortDescr.setDescription('Descriptor of the port in ASCII (readable) format, mainly for use with generic management applications.')
genPortActivityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 9, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 255))).clone(namedValues=NamedValues(("notActive", 1), ("dormant", 2), ("active", 3), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: genPortActivityStatus.setStatus('mandatory')
if mibBuilder.loadTexts: genPortActivityStatus.setDescription('This attribute defines the status of ports that may be part of a redundancy scheme. NotActive - indicates a disabled port which cannot transmit or receive packets even if included in a redundancy scheme. Dormant - indicates an enabled port which does not transmit or receive packets, but because it is included in a redundancy scheme, it may at any moment become responsible packet transmission and reception. Active - indicates that the port transmits and receives packets, serving as the main path in the redundant configuration.')
genPortSecurityPolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 9, 1, 1, 7), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: genPortSecurityPolicy.setStatus('mandatory')
if mibBuilder.loadTexts: genPortSecurityPolicy.setDescription('Security policy (Trap Only or Trap and Close) assigned to this port. The information is coded in internal LANNET format.')
genPortSecureAddresses = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 9, 1, 1, 8), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: genPortSecureAddresses.setStatus('mandatory')
if mibBuilder.loadTexts: genPortSecureAddresses.setDescription('This attribute defines the security information (physical addresses) relevant for the entry. Coded in internal format, cryptographic methods may be used for privacy purposes.')
genPortIntPortConnection = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 9, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: genPortIntPortConnection.setStatus('mandatory')
if mibBuilder.loadTexts: genPortIntPortConnection.setDescription('The value of this attribute defines the internal port to which the port is connected. A value 0 of this attribute would indicate no internal port connection (stand-alone mode). Any other positive value equals the number of the internal port.')
genPortAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 9, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: genPortAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: genPortAdminStatus.setDescription('A disabled port neither transmits nor receives. The port must be explici- tenly enabled to restore operation. For token ring ports, this attribute is read-only.')
genPortSpecificOID = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 9, 1, 1, 11), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: genPortSpecificOID.setStatus('mandatory')
if mibBuilder.loadTexts: genPortSpecificOID.setDescription('This attribute provides the OID of another group containing additional more specific information regarding this instance.')
genIntPortTable = MibTable((1, 3, 6, 1, 4, 1, 81, 10, 1), )
if mibBuilder.loadTexts: genIntPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: genIntPortTable.setDescription('Table of configuration attributes of LANNET internal ports. Internal ports are physical and/or logical entities which transfer information and connect LANNET modules to the internal networks (buses).')
genIntPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 10, 1, 1), ).setIndexNames((0, "LANNET-MIB", "genIntPortGroupId"), (0, "LANNET-MIB", "genIntPortId"))
if mibBuilder.loadTexts: genIntPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: genIntPortEntry.setDescription('An entry in the table, containing data about a single port.')
genIntPortGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 10, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: genIntPortGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: genIntPortGroupId.setDescription('Index which identifies the group inside the chassis for which this entry contains information. Equals the number of the slot by which the group containing the internal port is accessed. This value is never greater than chNumberOfSlots.')
genIntPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 10, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: genIntPortId.setStatus('mandatory')
if mibBuilder.loadTexts: genIntPortId.setDescription('Index which identifies the port inside the group for which this entry contains information. This value is never greater than genGroupNumberOfIntPorts of the group to which the port belongs.')
genIntPortAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 10, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: genIntPortAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: genIntPortAdminStatus.setDescription('Defines the capability of the internal port to transmit or receive data. A disabled internal port neither transmits or receives. The port must be explicitly enabled to restore operation.')
genIntPortActivityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 10, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 255))).clone(namedValues=NamedValues(("notActive", 1), ("dormant", 2), ("active", 3), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: genIntPortActivityStatus.setStatus('mandatory')
if mibBuilder.loadTexts: genIntPortActivityStatus.setDescription('This attribute defines the status of internal ports that may be part of a redundancy scheme. NotActive - indicates a disabled port which cannot transmit or receive packets even if included in a redundancy scheme. Dormant - indicates an enabled port which does not transmit or receive packets, but because it is included in a redundancy scheme, it may at any moment become responsible for packet transmission and reception. Active - indicates that the port transmits and receives packets, serving as the main path in the redundant configuration.')
genIntPortBusConnNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 10, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: genIntPortBusConnNumber.setStatus('mandatory')
if mibBuilder.loadTexts: genIntPortBusConnNumber.setDescription('The value of this attribute defines the bus to which the internal port is connected.')
genIntPortBusConnType = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 10, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 255))).clone(namedValues=NamedValues(("ethernet", 1), ("token-ring", 2), ("local-talk", 3), ("fddi", 4), ("other", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: genIntPortBusConnType.setStatus('mandatory')
if mibBuilder.loadTexts: genIntPortBusConnType.setDescription('The value of this attribute defines the type of the bus to which the internal port is connected.')
genIntPortSpecificOID = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 10, 1, 1, 7), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: genIntPortSpecificOID.setStatus('mandatory')
if mibBuilder.loadTexts: genIntPortSpecificOID.setDescription('This attribute provides the OID of another group containing additional more specific information regarding this instance.')
softRedundancyTable = MibTable((1, 3, 6, 1, 4, 1, 81, 11, 1), )
if mibBuilder.loadTexts: softRedundancyTable.setStatus('mandatory')
if mibBuilder.loadTexts: softRedundancyTable.setDescription('Table of attributes which define software redundancy links defined by means of the LANNET chassis SNMP agents.')
softRedundancyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 11, 1, 1), ).setIndexNames((0, "LANNET-MIB", "softRedundancyId"))
if mibBuilder.loadTexts: softRedundancyEntry.setStatus('mandatory')
if mibBuilder.loadTexts: softRedundancyEntry.setDescription('An entry in the table, containing data about a single software redundancy link.')
softRedundancyId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 11, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: softRedundancyId.setStatus('mandatory')
if mibBuilder.loadTexts: softRedundancyId.setDescription('Index which identifies the software redundancy link which for which the current entry provides information.')
softRedundancyName = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 11, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(15, 15)).setFixedLength(15)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: softRedundancyName.setStatus('mandatory')
if mibBuilder.loadTexts: softRedundancyName.setDescription('Logical name of the software redundancy link')
softRedundancyGroupId1 = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 11, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: softRedundancyGroupId1.setStatus('mandatory')
if mibBuilder.loadTexts: softRedundancyGroupId1.setDescription('ID of the group to which the main port on the software redundancy link belongs. This value is never greater than chNumberOfSlots.')
softRedundancyPortId1 = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 11, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: softRedundancyPortId1.setStatus('mandatory')
if mibBuilder.loadTexts: softRedundancyPortId1.setDescription('ID of the main port on the software redundancy link.')
softRedundancyGroupId2 = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 11, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: softRedundancyGroupId2.setStatus('mandatory')
if mibBuilder.loadTexts: softRedundancyGroupId2.setDescription('ID of the group to which the secondary port on the software redundancy link belongs. This value is never greater than chNumberOfSlots.')
softRedundancyPortId2 = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 11, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: softRedundancyPortId2.setStatus('mandatory')
if mibBuilder.loadTexts: softRedundancyPortId2.setDescription('ID of the secondary port on the software redundancy link.')
softRedundancyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 11, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("valid", 1), ("createRequest", 2), ("underCreation", 3), ("invalid", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: softRedundancyStatus.setStatus('mandatory')
if mibBuilder.loadTexts: softRedundancyStatus.setDescription("Status of the entry in the softRedundancy Table: valid(1) indicates that row is busy with meaningful values; createRequest(2) will be set by manager when creating a new row; underCreation(3) indicates that agent accepts create command and performs it; invalid(4) indicates that no meaningful values are present in the row. Managers set this value in order to transmit a 'Delete row' command to agent.")
ethAg = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 12, 1))
ethAgTable = MibTable((1, 3, 6, 1, 4, 1, 81, 12, 1, 1), )
if mibBuilder.loadTexts: ethAgTable.setStatus('mandatory')
if mibBuilder.loadTexts: ethAgTable.setDescription('Table of attributes which define configuration characteristics for LANNET chassis SNMP agents which use Ethernet as in-band management protocol.')
ethAgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 12, 1, 1, 1), ).setIndexNames((0, "LANNET-MIB", "ethAgId"))
if mibBuilder.loadTexts: ethAgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ethAgEntry.setDescription('An entry in the table, containing data about a single Ethernet agent.')
ethAgId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethAgId.setStatus('mandatory')
if mibBuilder.loadTexts: ethAgId.setDescription('Index which identifies the Ethernet agent for which the current entry provides information.')
ethAgPerfBusSelection = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 1, 1, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethAgPerfBusSelection.setStatus('mandatory')
if mibBuilder.loadTexts: ethAgPerfBusSelection.setDescription('Attribute describing the bus attached to the performance data collection hardware on those LANNET agent hardware implementations which support configuration management on multi-Ethernet bus enclosures, but performan- ce data collection on a single bus.')
ethGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 12, 2))
ethGroupTable = MibTable((1, 3, 6, 1, 4, 1, 81, 12, 2, 1), )
if mibBuilder.loadTexts: ethGroupTable.setStatus('mandatory')
if mibBuilder.loadTexts: ethGroupTable.setDescription('Table of attributes which define configuration characteristics for LANNET Ethernet modules.')
ethGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 12, 2, 1, 1), ).setIndexNames((0, "LANNET-MIB", "ethGroupId"))
if mibBuilder.loadTexts: ethGroupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ethGroupEntry.setDescription('An entry in the table, containing data about a single Ethernet module (group).')
ethGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: ethGroupId.setDescription('Index which identifies the group inside the chassis for which this entry contains information. Equals the number of the slot by which the group is accessed. This value is never greater than chNumberOfSlots.')
ethGroupFIFO = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethGroupFIFO.setStatus('mandatory')
if mibBuilder.loadTexts: ethGroupFIFO.setDescription('Value ON of this attribute describes an internal FIFO error sensed by the internal hardware mechanism of a LANNET repeater.')
ethGroup10BTPlus = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethGroup10BTPlus.setStatus('mandatory')
if mibBuilder.loadTexts: ethGroup10BTPlus.setDescription('Value ON of this attribute defines activation of the 10BaseTPlus mode - a LANNET extension of the 10BaseT standard.')
ethGroupIntPortsRedundancy = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethGroupIntPortsRedundancy.setStatus('mandatory')
if mibBuilder.loadTexts: ethGroupIntPortsRedundancy.setDescription('Value ON of this attribute defines a redundancy (backup) relationship between internal ports 1 and 2 on a LANNET module.')
ethGroupBackboneMode = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethGroupBackboneMode.setStatus('mandatory')
if mibBuilder.loadTexts: ethGroupBackboneMode.setDescription('Value On of this attribute defines Backbone Mode of a sensor. Internal ports are enabled and the information path goes straightly from external port to internal bus, via corresponding internal port.')
ethGroupFOIRLPlusMode = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethGroupFOIRLPlusMode.setStatus('mandatory')
if mibBuilder.loadTexts: ethGroupFOIRLPlusMode.setDescription('Value On of this attribute defines FOIRL of a sensor. When this attribute has value ON, FOIRL Plus mode is enabled, while value OFF indicates stan- dard FOIRL mode.')
ethGroupWrongPortSelection = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethGroupWrongPortSelection.setStatus('mandatory')
if mibBuilder.loadTexts: ethGroupWrongPortSelection.setDescription('A value ON of this attribute warns of incorrect selection of enabled ports on sensors which impose restrictions on this configura- tion (e.g. integrated local bridges.)')
ethGroupBackupBus = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethGroupBackupBus.setStatus('mandatory')
if mibBuilder.loadTexts: ethGroupBackupBus.setDescription('Defines the common secondary bus for Ethernet groups with bus redundancy defined at port level.')
ethGroupSingleBusMode = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 2, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethGroupSingleBusMode.setStatus('mandatory')
if mibBuilder.loadTexts: ethGroupSingleBusMode.setDescription("Value 'on of this attribute defines bus-star mode for cards supporting this type of configuration.")
ethGroupSpecificOID = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 2, 1, 1, 10), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethGroupSpecificOID.setStatus('mandatory')
if mibBuilder.loadTexts: ethGroupSpecificOID.setDescription('This attribute provides the OID of another group containing additional more specific information regarding this instance.')
ethPort = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 12, 3))
ethPortTable = MibTable((1, 3, 6, 1, 4, 1, 81, 12, 3, 1), )
if mibBuilder.loadTexts: ethPortTable.setStatus('mandatory')
ethPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 12, 3, 1, 1), ).setIndexNames((0, "LANNET-MIB", "ethPortGroupId"), (0, "LANNET-MIB", "ethPortId"))
if mibBuilder.loadTexts: ethPortEntry.setStatus('mandatory')
ethPortGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethPortGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: ethPortGroupId.setDescription('Id of the group to which the port belongs.')
ethPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 3, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethPortId.setStatus('mandatory')
if mibBuilder.loadTexts: ethPortId.setDescription('Unique Id of the port in the ethPortTable.')
ethPortFunctionalStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 255))).clone(namedValues=NamedValues(("ok", 1), ("rld", 2), ("localJabber", 3), ("tld", 4), ("remoteJabber", 5), ("illSeq", 6), ("shortCirc", 7), ("partitionOrLocalJabber", 8), ("remoteFaultOrLockLost", 9), ("remoteFault", 10), ("lockLost", 11), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethPortFunctionalStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ethPortFunctionalStatus.setDescription('The value of this attribute reflects the functional status of LANNET synchronous ports. Note that it is not mandatory that all ports support all the enumerated states. Here is the minimal set possible states: OK - fully functional port, transmitting and receiving packets. RLD - receive link down condition on the port. TLD - transmit link down condition on the port. LocalJabber - fault condition indicating that the port emitted jabber. RemoteJabber - fault condition indicating that remote jabber was sensed at the port. IllSeq - Fault condition indicating an illegal synchronization sequence at the port. ShortCircuit - short-circuit fault condition detected at the port. PartitionOrLocalJabber - RemoteFaultOrLockLoss - ')
ethPortManPart = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethPortManPart.setStatus('mandatory')
if mibBuilder.loadTexts: ethPortManPart.setDescription('Setting the value of this attribute to ON activates the manual partition mechanism at the port level. Setting the value of this attribute to OFF cancels the partition mechanism. The segment may reconnect after the reception of 32 packets. Attribute vaild for repeater modules from the LE-10 family.')
ethPortJabber = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethPortJabber.setStatus('mandatory')
if mibBuilder.loadTexts: ethPortJabber.setDescription('Value ON of this attribute reflects jabber transmitted to the port by the hardware of a LANNET repeater or transceiver, as a result of collisions detected on the port. Valid for all modules in the LE-10 and LE-15 families.')
ethPortNoAUILoop = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethPortNoAUILoop.setStatus('mandatory')
if mibBuilder.loadTexts: ethPortNoAUILoop.setDescription('Value ON of this attribute indicates that a No AUI Loop fault condition was detected on an AUI repeater port. Valid for LE-10C family of modu- les.')
ethPortMJLP = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethPortMJLP.setStatus('mandatory')
if mibBuilder.loadTexts: ethPortMJLP.setDescription('Value ON of this attribute describes an internal MJLP (MAU Jabber Lockup Protection) error sensed by the internal hardware mechanism of a LANNET repeater. Valid for LE140XTF.')
ethPortFIFO = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 3, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethPortFIFO.setStatus('mandatory')
if mibBuilder.loadTexts: ethPortFIFO.setDescription('Value ON of this attribute describes an internal FIFO error sensed by the internal hardware mechanism of a LANNET repeater. Valid for LE140XTF.')
ethPortAutoPartitionState = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 3, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("autoPartition", 1), ("notAutoPartition", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethPortAutoPartitionState.setStatus('mandatory')
if mibBuilder.loadTexts: ethPortAutoPartitionState.setDescription('The AutoPart condition indicates that the port is currently partitioned by the auto-partition protection mechanism.')
ethPortSQETest = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethPortSQETest.setStatus('mandatory')
if mibBuilder.loadTexts: ethPortSQETest.setDescription('Settable attribute which allows activation of SQE test for LANNET integrated transceivers.')
ethPortLastSourceAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 3, 1, 1, 11), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethPortLastSourceAddr.setStatus('mandatory')
if mibBuilder.loadTexts: ethPortLastSourceAddr.setDescription('Ethernet source address of the last readable frame received by this port.')
ethPortUserStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 3, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("singleUser", 1), ("multiUser", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethPortUserStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ethPortUserStatus.setDescription('Attribute defining the connection of a port to a single Ethernet source or to a multi-source (segment or star).')
ethPortMainBusSelection = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 3, 1, 1, 13), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethPortMainBusSelection.setStatus('mandatory')
if mibBuilder.loadTexts: ethPortMainBusSelection.setDescription('On cards with port-level redundancy, defines the main bus for each port instance as selected by user.')
ethPortTraffic = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 3, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethPortTraffic.setStatus('mandatory')
if mibBuilder.loadTexts: ethPortTraffic.setDescription('Counter for the number of bits received on this port in frames with legal length information.')
ethPortFramesReceivedOK = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 3, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethPortFramesReceivedOK.setStatus('mandatory')
if mibBuilder.loadTexts: ethPortFramesReceivedOK.setDescription('A representation of the total number of frames of legal length that have not been corrupted in transmission. These frames can be encoded and decoded by the commonly available MACs and provide a measure of the network bandwidth being used. The number does not include frames received with frame-too-long, FCS, alignment errors, frames lost due to internal MAC sublayer errors, runts or pygmys.')
ethPortRunts = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 3, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethPortRunts.setStatus('mandatory')
if mibBuilder.loadTexts: ethPortRunts.setDescription('Counter for the number of collision fragments longer than a pygmy and shorter than a legal packet, detected on this port.')
ethPortPacketErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 3, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethPortPacketErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ethPortPacketErrors.setDescription('Counter for the number of frames with errors detected on the port by the LANNET agent hardware. This generic port error comprises too long packets, CRC and alignment errors.')
ethPortSpecificOID = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 3, 1, 1, 18), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethPortSpecificOID.setStatus('mandatory')
if mibBuilder.loadTexts: ethPortSpecificOID.setDescription('This attribute provides the OID of another group containing additional more specific information regarding this instance.')
ethIntPort = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 12, 4))
ethIntPortTable = MibTable((1, 3, 6, 1, 4, 1, 81, 12, 4, 1), )
if mibBuilder.loadTexts: ethIntPortTable.setStatus('mandatory')
ethIntPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 12, 4, 1, 1), ).setIndexNames((0, "LANNET-MIB", "ethIntPortGroupId"), (0, "LANNET-MIB", "ethIntPortId"))
if mibBuilder.loadTexts: ethIntPortEntry.setStatus('mandatory')
ethIntPortGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIntPortGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: ethIntPortGroupId.setDescription('ID of the group to which the internal port belongs.')
ethIntPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIntPortId.setStatus('mandatory')
if mibBuilder.loadTexts: ethIntPortId.setDescription('ID of the internal port in the ethIntPortTable.')
ethIntPortPartition = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIntPortPartition.setStatus('mandatory')
if mibBuilder.loadTexts: ethIntPortPartition.setDescription('This condition indicates that the internal port is currently partitioned from the bus by the auto-partition protection mechanism.')
ethIntPortJabber = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIntPortJabber.setStatus('mandatory')
if mibBuilder.loadTexts: ethIntPortJabber.setDescription('Value ON of this attribute reflects jabber being transmitted to the bus by the hardware of a LANNET repeater, as a result of collisions detected on the internal bus of the enclosure. This situation is similar to MJLP as defined by the Repeater Management standard.')
ethIntPortBackedUp = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 4, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethIntPortBackedUp.setStatus('mandatory')
if mibBuilder.loadTexts: ethIntPortBackedUp.setDescription('Indicates that internal port is part of a redundancy scheme.')
ethBus = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 12, 5))
ethBusPerfTable = MibTable((1, 3, 6, 1, 4, 1, 81, 12, 5, 1), )
if mibBuilder.loadTexts: ethBusPerfTable.setStatus('mandatory')
ethBusPerfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 12, 5, 1, 1), ).setIndexNames((0, "LANNET-MIB", "ethBusPerfAgId"), (0, "LANNET-MIB", "ethBusPerfId"))
if mibBuilder.loadTexts: ethBusPerfEntry.setStatus('mandatory')
ethBusPerfAgId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 5, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethBusPerfAgId.setStatus('mandatory')
if mibBuilder.loadTexts: ethBusPerfAgId.setDescription('ID of the agent in the ethBusPerfTable.')
ethBusPerfId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethBusPerfId.setStatus('mandatory')
if mibBuilder.loadTexts: ethBusPerfId.setDescription('ID of the bus in the ethBusPerfTable.')
ethBusTrafficBuffer = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 5, 1, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethBusTrafficBuffer.setStatus('mandatory')
if mibBuilder.loadTexts: ethBusTrafficBuffer.setDescription('Record of traffic for the last second with a resolution of 100 msec. The traffic is expressed in percents of the maximum Ethernet traffic and each record contains 10 readings, in the range 1..20, expressed on a log(10) scale ( value = 10*log10(percent) ).')
ethBusTrafficThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 5, 1, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethBusTrafficThresh.setStatus('mandatory')
if mibBuilder.loadTexts: ethBusTrafficThresh.setDescription('Traffic threshold value. When exceeded, a trap is send to the management console. Expressed in percents of the maximum Ethernet traffic, in the range 1..20, expressed on a log(10) scale.')
ethBusPeakTraffic = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 5, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethBusPeakTraffic.setStatus('mandatory')
if mibBuilder.loadTexts: ethBusPeakTraffic.setDescription('Maximal traffic value since last reset of hub or relay. Expressed in per- cents of the maximum Ethernet traffic, in the range 1..20, expressed on log(10) scale.')
ethBusTotalCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 5, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethBusTotalCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: ethBusTotalCollisions.setDescription('Counter incremented every time the hub enters a condition caused by simultaneous transmission and detection of external activity on one or more of its ports.')
ethBusTotalPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 5, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethBusTotalPackets.setStatus('mandatory')
if mibBuilder.loadTexts: ethBusTotalPackets.setDescription('Counter for number of packets (good and errors) detected on the Ethernet bus.')
ethBusTotalErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 5, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethBusTotalErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ethBusTotalErrors.setDescription('Counter for number of errors detected on the Ethernet bus. Does not take into account the collisions.')
ethBusTraffic = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 5, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethBusTraffic.setStatus('mandatory')
if mibBuilder.loadTexts: ethBusTraffic.setDescription('Last traffic reading (sampling time = 100 msec). The traffic is expressed in percents of the maximum Ethernet traffic in the range 1..20, expressed on a log(10) scale ( value = 10*log10(percent) ).')
ethBusClockTable = MibTable((1, 3, 6, 1, 4, 1, 81, 12, 5, 2), )
if mibBuilder.loadTexts: ethBusClockTable.setStatus('mandatory')
ethBusClockEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 12, 5, 2, 1), ).setIndexNames((0, "LANNET-MIB", "ethBusClockBusId"), (0, "LANNET-MIB", "ethBusClockId"))
if mibBuilder.loadTexts: ethBusClockEntry.setStatus('mandatory')
ethBusClockBusId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 5, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethBusClockBusId.setStatus('mandatory')
if mibBuilder.loadTexts: ethBusClockBusId.setDescription('ID of the bus in the ethBusClockTable.')
ethBusClockId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 5, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethBusClockId.setStatus('mandatory')
if mibBuilder.loadTexts: ethBusClockId.setDescription('ID of the clock in the ethBusClockTable.')
ethBusClockTestResult = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 12, 5, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 255))).clone(namedValues=NamedValues(("ok", 1), ("clockFailure", 2), ("busFailure", 3), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethBusClockTestResult.setStatus('mandatory')
if mibBuilder.loadTexts: ethBusClockTestResult.setDescription('Values clockFailure and busFailure define the faulty statuses for clock tests. The test is performed by LCL100 module.')
tokRing = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 13, 1))
tokRingTable = MibTable((1, 3, 6, 1, 4, 1, 81, 13, 1, 1), )
if mibBuilder.loadTexts: tokRingTable.setStatus('mandatory')
tokRingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 13, 1, 1, 1), ).setIndexNames((0, "LANNET-MIB", "tokRingAgId"), (0, "LANNET-MIB", "tokRingId"))
if mibBuilder.loadTexts: tokRingEntry.setStatus('mandatory')
tokRingAgId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokRingAgId.setStatus('mandatory')
if mibBuilder.loadTexts: tokRingAgId.setDescription('ID of the agent to which the ring belongs in the tokRingTable.')
tokRingId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokRingId.setStatus('mandatory')
if mibBuilder.loadTexts: tokRingId.setDescription('ID of the ring in the tokRingTable.')
tokRingLeftSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokRingLeftSlot.setStatus('mandatory')
if mibBuilder.loadTexts: tokRingLeftSlot.setDescription('Slot number of the left-most slot of the ring.')
tokRingRightSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tokRingRightSlot.setStatus('mandatory')
if mibBuilder.loadTexts: tokRingRightSlot.setDescription('Slot number of the right-most slot of the ring.')
tokRingTrafficBuffer = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 1, 1, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokRingTrafficBuffer.setStatus('mandatory')
if mibBuilder.loadTexts: tokRingTrafficBuffer.setDescription('Record of traffic for the last second with a resolution of 100 msec. The traffic is expressed in percents of the maximum effective TR traffic (token messages are excluded) and each record contains 10 readings, in range 1..20 on log(10) scale.')
tokRingTrafficThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 1, 1, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tokRingTrafficThresh.setStatus('mandatory')
if mibBuilder.loadTexts: tokRingTrafficThresh.setDescription('Traffic threshold value. When exceeded, a trap is send to the management console. Expressed in percents of the maximum effective TR traffic (token messages are excluded) in the range 1..20 on log(10) scale.')
tokRingPeakTraffic = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 1, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokRingPeakTraffic.setStatus('mandatory')
if mibBuilder.loadTexts: tokRingPeakTraffic.setDescription('Maximal traffic value since last reset of agent. Expressed in percents of the maximum effective TR traffic (token messages are excluded), in the range 1..20 on log(10) scale.')
tokRingNumberOfStations = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 1, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokRingNumberOfStations.setStatus('mandatory')
if mibBuilder.loadTexts: tokRingNumberOfStations.setDescription('Number of Token Ring stations (controllers) detected on the ring. The TR controller of the agent card is included in this count.')
tokRingConfiguration = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 1, 1, 1, 9), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokRingConfiguration.setStatus('mandatory')
if mibBuilder.loadTexts: tokRingConfiguration.setDescription('Configuration attribute describing the list of physical addresses detected on the Token Ring. Coded in internal LANNET application format. ')
tokRingBeaconing = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokRingBeaconing.setStatus('mandatory')
if mibBuilder.loadTexts: tokRingBeaconing.setDescription('This attribute indicates if a beaconing condition is currently detected on the ring.')
tokRingBeaconingStation = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 1, 1, 1, 11), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokRingBeaconingStation.setStatus('mandatory')
if mibBuilder.loadTexts: tokRingBeaconingStation.setDescription('The MAC address of the last station which was detected as sending Beaconing MAC frames on the ring.')
tokRingStationsMatch = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 1, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokRingStationsMatch.setStatus('mandatory')
if mibBuilder.loadTexts: tokRingStationsMatch.setDescription('This attribute indicates matching between the number of stations detected on the ring between the current agent and the next agent on Up Stream sense and the number of connected lobe ports.Used by the port address correlation mechanism.')
tokRingTraffic = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 1, 1, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokRingTraffic.setStatus('mandatory')
if mibBuilder.loadTexts: tokRingTraffic.setDescription('Last traffic reading (sampling time = 100 msec). The traffic is expressed in percents of the maximum Ethernet traffic in the range 1..20, expressed on a log(10) scale ( value = 10*log10(percent) ).')
tokGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 13, 2))
tokGroupTable = MibTable((1, 3, 6, 1, 4, 1, 81, 13, 2, 1), )
if mibBuilder.loadTexts: tokGroupTable.setStatus('mandatory')
tokGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 13, 2, 1, 1), ).setIndexNames((0, "LANNET-MIB", "tokGroupId"))
if mibBuilder.loadTexts: tokGroupEntry.setStatus('mandatory')
tokGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: tokGroupId.setDescription('Number of the slot in which the group is installed.')
tokGroupAutoRightLoop = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokGroupAutoRightLoop.setStatus('mandatory')
if mibBuilder.loadTexts: tokGroupAutoRightLoop.setDescription('Value ON of this attribute signifies that a hardware loop was automatically created on a Token Ring module which does not sense the existence of another token ring group on the right hand side.')
tokGroupAutoLeftLoop = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokGroupAutoLeftLoop.setStatus('mandatory')
if mibBuilder.loadTexts: tokGroupAutoLeftLoop.setDescription('Value ON of this attribute signifies that a hardware loop was automatically created on a Token Ring module which does not sense the existence of another token ring group on the left hand side.')
tokGroupManRightLoop = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tokGroupManRightLoop.setStatus('mandatory')
if mibBuilder.loadTexts: tokGroupManRightLoop.setDescription('Setting this attribute to ON signifies a command to the hardware to create a loop on the Token Ring module which isolates the ring from the right hand side.')
tokGroupManLeftLoop = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tokGroupManLeftLoop.setStatus('mandatory')
if mibBuilder.loadTexts: tokGroupManLeftLoop.setDescription('Setting this attribute to ON signifies a command to the hardware to create a loop on the Token Ring module which isolates the ring from the left hand side.')
tokGroupRightNeighbor = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("exist", 1), ("notExist", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokGroupRightNeighbor.setStatus('mandatory')
if mibBuilder.loadTexts: tokGroupRightNeighbor.setDescription('Attribute defining the existence of a neighbor another token ring group on the right hand side of the module.')
tokGroupLeftNeighbor = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("exist", 1), ("notExist", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokGroupLeftNeighbor.setStatus('mandatory')
if mibBuilder.loadTexts: tokGroupLeftNeighbor.setDescription('Attribute defining the existence of a neighbor another token ring group on the left hand side of the module.')
tokGroupIOMode = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 255))).clone(namedValues=NamedValues(("single", 1), ("dualRingIn", 2), ("dualRingOut", 3), ("illegalMode", 4), ("lobe", 5), ("intRepeater", 6), ("star", 7), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tokGroupIOMode.setStatus('mandatory')
if mibBuilder.loadTexts: tokGroupIOMode.setDescription('Attribute defining the I/O mode (single, dual-ring-in, dual-ring-out) Lobe, Internal Repeater or Star) of a module from the the LTR-IO family.')
tokGroupBridgeMode = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 2, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 255))).clone(namedValues=NamedValues(("modeA", 1), ("modeB", 2), ("modeC", 3), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tokGroupBridgeMode.setStatus('mandatory')
if mibBuilder.loadTexts: tokGroupBridgeMode.setDescription('Attribute describing the operational mode of the bridge. For ITLB the following modes are defined: - Mode A: First channel connected to an external ring (RI,RO connectors) and second channel connected to an internal ring; - Mode B: First channel connected to an external ring by a DTE connector and second channel connected to an internal ring; - Mode C: First channel connected to an internal left ring and second channel connected to an internal right ring.')
tokGroupManLinkLoop = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tokGroupManLinkLoop.setStatus('mandatory')
if mibBuilder.loadTexts: tokGroupManLinkLoop.setDescription('Setting the value of this attribute to ON instructs the hardware of a LANNET Token Ring repeater module to close the loop in the direction of the external connection.')
tokGroupManBusLoop = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 2, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tokGroupManBusLoop.setStatus('mandatory')
if mibBuilder.loadTexts: tokGroupManBusLoop.setDescription('Setting the value of this attribute to ON instructs the hardware of a LANNET Token Ring repeater module to close the loop in the direction of the internal bus.')
tokGroupAutoLinkLoop = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 2, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokGroupAutoLinkLoop.setStatus('mandatory')
if mibBuilder.loadTexts: tokGroupAutoLinkLoop.setDescription('Value ON of this attribute signifies that a hardware loop has been auto- matically closed by the hardwar of the LANNET Token Ring repeater as a result of problems on the external link.')
tokGroupAutoBusLoop = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 2, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokGroupAutoBusLoop.setStatus('mandatory')
if mibBuilder.loadTexts: tokGroupAutoBusLoop.setDescription('Value ON of this attribute signifies that a hardware loop has been auto- matically closed by the hardware of the LANNET Token Ring repeater as a result of problems on the internal bus.')
tokGroupSpecificOID = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 2, 1, 1, 14), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokGroupSpecificOID.setStatus('mandatory')
if mibBuilder.loadTexts: tokGroupSpecificOID.setDescription('This attribute provides the OID of another group containing additional more specific information regarding this instance.')
tokGroupRingTable = MibTable((1, 3, 6, 1, 4, 1, 81, 13, 2, 2), )
if mibBuilder.loadTexts: tokGroupRingTable.setStatus('mandatory')
tokGroupRingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 13, 2, 2, 1), ).setIndexNames((0, "LANNET-MIB", "tokGroupRingGroupId"), (0, "LANNET-MIB", "tokGroupRingId"))
if mibBuilder.loadTexts: tokGroupRingEntry.setStatus('mandatory')
tokGroupRingGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokGroupRingGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: tokGroupRingGroupId.setDescription('ID of the group to which the ring belongs.')
tokGroupRingId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokGroupRingId.setStatus('mandatory')
if mibBuilder.loadTexts: tokGroupRingId.setDescription('ID of the ring.')
tokGroupRingSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("oneMegabit", 2), ("fourMegabit", 3), ("sixteenMegabit", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tokGroupRingSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: tokGroupRingSpeed.setDescription('Attribute describing the bandwidth of the ring.')
tokGroupRingInserted = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notInserted", 1), ("inserted", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokGroupRingInserted.setStatus('mandatory')
if mibBuilder.loadTexts: tokGroupRingInserted.setDescription('Indicates that the bridge interface has inserted itself into the ring.')
tokPort = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 13, 3))
tokPortTable = MibTable((1, 3, 6, 1, 4, 1, 81, 13, 3, 1), )
if mibBuilder.loadTexts: tokPortTable.setStatus('mandatory')
tokPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 13, 3, 1, 1), ).setIndexNames((0, "LANNET-MIB", "tokPortGroupId"), (0, "LANNET-MIB", "tokPortId"))
if mibBuilder.loadTexts: tokPortEntry.setStatus('mandatory')
tokPortGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokPortGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: tokPortGroupId.setDescription('ID of the group to which the token ring port belongs.')
tokPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokPortId.setStatus('mandatory')
if mibBuilder.loadTexts: tokPortId.setDescription('ID of the port in the tokPortTable.')
tokPortBypass = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tokPortBypass.setStatus('mandatory')
if mibBuilder.loadTexts: tokPortBypass.setDescription('Setting the value of this attribute to ON causes the by- passing of the TokenRing LANNET port.')
tokPortConnected = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("connected", 1), ("notConnected", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokPortConnected.setStatus('mandatory')
if mibBuilder.loadTexts: tokPortConnected.setDescription('Attribute which describes the connection status of a Token Ring port (inclusion of the Token Ring controller in the ring).')
tokPortTCP = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tokPortTCP.setStatus('mandatory')
if mibBuilder.loadTexts: tokPortTCP.setDescription('Setting the value of this attribute to ON causes the activation of the cable-fault detection mechanism.')
tokPortCableFault = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokPortCableFault.setStatus('mandatory')
if mibBuilder.loadTexts: tokPortCableFault.setDescription('Value ON of this attribute signifies the detection of a cable-fault on this specific Token Ring port.')
tokPortFunctionalStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 255))).clone(namedValues=NamedValues(("ok", 1), ("rld", 2), ("tld", 4), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokPortFunctionalStatus.setStatus('mandatory')
if mibBuilder.loadTexts: tokPortFunctionalStatus.setDescription('The value of this attribute reflects the functional status of LANNET Token Ring ports. Note that it is not mandatory that a certain port support all the enumerated states. Here is the lest of the possible states: OK - fully functional port, transmitting and receiving packets. RLD - receive link down condition on the port. TLD - transmit link down condition on the port.')
tokPortLastSourceAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 3, 1, 1, 8), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokPortLastSourceAddr.setStatus('mandatory')
if mibBuilder.loadTexts: tokPortLastSourceAddr.setDescription('MAC source address of the last readable frame received by this port.')
tokPortSpecificOID = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 13, 3, 1, 1, 9), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokPortSpecificOID.setStatus('mandatory')
if mibBuilder.loadTexts: tokPortSpecificOID.setDescription('This attribute provides the OID of another group containing additional more specific information regarding this instance.')
tsGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 14, 1))
tsGroupTable = MibTable((1, 3, 6, 1, 4, 1, 81, 14, 1, 1), )
if mibBuilder.loadTexts: tsGroupTable.setStatus('mandatory')
tsGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 14, 1, 1, 1), ).setIndexNames((0, "LANNET-MIB", "tsGroupId"))
if mibBuilder.loadTexts: tsGroupEntry.setStatus('mandatory')
tsGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 14, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: tsGroupId.setDescription('Number of the slot in which the group is installed.')
tsGroupLATStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 14, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsGroupLATStatus.setStatus('mandatory')
if mibBuilder.loadTexts: tsGroupLATStatus.setDescription('Value ON of this attribute means that LAT protocol is Enabled on the LANNET Ethernet module.')
tsGroupOperationMode = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 14, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("diagnostics", 1), ("diagnosticsFailure", 2), ("loading", 3), ("loadingFailure", 4), ("operational", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsGroupOperationMode.setStatus('mandatory')
if mibBuilder.loadTexts: tsGroupOperationMode.setDescription('This attribute describes the operation mode of the module in a multiprocessor configuration sensor, as reported by interprocessors communication.')
ltalkPort = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 15, 1))
ltalkPortTable = MibTable((1, 3, 6, 1, 4, 1, 81, 15, 1, 1), )
if mibBuilder.loadTexts: ltalkPortTable.setStatus('mandatory')
ltalkPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 15, 1, 1, 1), ).setIndexNames((0, "LANNET-MIB", "ltalkPortGroupId"), (0, "LANNET-MIB", "ltalkPortId"))
if mibBuilder.loadTexts: ltalkPortEntry.setStatus('mandatory')
ltalkPortGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 15, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ltalkPortGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: ltalkPortGroupId.setDescription('Number of the group to which the port belongs.')
ltalkPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 15, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ltalkPortId.setStatus('mandatory')
if mibBuilder.loadTexts: ltalkPortId.setDescription('ID of the port in the ltalkPortTable.')
ltalkPortTest = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 15, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ltalkPortTest.setStatus('mandatory')
if mibBuilder.loadTexts: ltalkPortTest.setDescription('A value ON of this attribute indicates that a port test should be performed upon the port defined by the attribute instance.')
ltalkPortTestResult = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 15, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("faulty", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ltalkPortTestResult.setStatus('mandatory')
if mibBuilder.loadTexts: ltalkPortTestResult.setDescription('Indicates the result of a port test performed on this port.')
ltalkPortJam = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 15, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ltalkPortJam.setStatus('mandatory')
if mibBuilder.loadTexts: ltalkPortJam.setDescription('An ON value of this attribute indicates a Jam error on the specific port.')
clGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 16, 1))
clGroupTable = MibTable((1, 3, 6, 1, 4, 1, 81, 16, 1, 1), )
if mibBuilder.loadTexts: clGroupTable.setStatus('mandatory')
clGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 16, 1, 1, 1), ).setIndexNames((0, "LANNET-MIB", "clGroupId"))
if mibBuilder.loadTexts: clGroupEntry.setStatus('mandatory')
clGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 16, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: clGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: clGroupId.setDescription('Number of the slot in which the group is installed.')
clGroupClockRedundancy = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 16, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: clGroupClockRedundancy.setStatus('mandatory')
if mibBuilder.loadTexts: clGroupClockRedundancy.setDescription('Value ON of this attribute defines a redundancy (backup) relationship between the internal and external clocks on the LCL100 module.')
clGroupMainClock = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 16, 1, 1, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: clGroupMainClock.setStatus('mandatory')
if mibBuilder.loadTexts: clGroupMainClock.setDescription("Value of this attribute is an index into clPortTable, and defines the clock that should operate or a main clock in redundancy scheme. Serves as 'Clock selection' switch on the card.")
clGroupTestClocks = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 16, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: clGroupTestClocks.setStatus('mandatory')
if mibBuilder.loadTexts: clGroupTestClocks.setDescription('A value ON of this attribute indicates that a test should be performed on all clock ports.')
clPort = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 16, 2))
clPortTable = MibTable((1, 3, 6, 1, 4, 1, 81, 16, 2, 1), )
if mibBuilder.loadTexts: clPortTable.setStatus('mandatory')
clPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 16, 2, 1, 1), ).setIndexNames((0, "LANNET-MIB", "clPortGroupId"), (0, "LANNET-MIB", "clPortId"))
if mibBuilder.loadTexts: clPortEntry.setStatus('mandatory')
clPortGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 16, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: clPortGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: clPortGroupId.setDescription('Number of the group to which the port belongs.')
clPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 16, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: clPortId.setStatus('mandatory')
if mibBuilder.loadTexts: clPortId.setDescription('ID of the port in the clPortTable.')
clPortFunctionalStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 16, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("faulty", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: clPortFunctionalStatus.setStatus('mandatory')
if mibBuilder.loadTexts: clPortFunctionalStatus.setDescription('Indicates whether the clock is faulty or not.')
lBoxOID = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 17, 1))
lUnknownBoxOID = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 17, 1, 1))
lLET18BoxOID = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 17, 1, 2))
lLET3BoxOID = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 17, 1, 3))
lLET36BoxOID = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 17, 1, 4))
lLET18EBoxOID = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 17, 1, 5))
lLERT40BoxOID = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 17, 1, 6))
lLET10BoxOID = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 17, 1, 7))
lFDX100BoxOID = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 17, 1, 8))
mibBuilder.exportSymbols("LANNET-MIB", tokPortEntry=tokPortEntry, chHWIntTempWarning=chHWIntTempWarning, genGroupRedun12=genGroupRedun12, genPortIntPortConnection=genPortIntPortConnection, chGenAgAddr=chGenAgAddr, ethPortGroupId=ethPortGroupId, ethIntPort=ethIntPort, ethGroupFOIRLPlusMode=ethGroupFOIRLPlusMode, tokRingRightSlot=tokRingRightSlot, tokRingNumberOfStations=tokRingNumberOfStations, genGroupSWVersion=genGroupSWVersion, chMgrContPerfRep=chMgrContPerfRep, genGroupEntry=genGroupEntry, tokGroupRingTable=tokGroupRingTable, tokRingAgId=tokRingAgId, chLntAgHubEnrollTraps=chLntAgHubEnrollTraps, chHWIntTempThresh=chHWIntTempThresh, tokGroupManLeftLoop=tokGroupManLeftLoop, tsGroupOperationMode=tsGroupOperationMode, genGroupFullConfig=genGroupFullConfig, ethPortRunts=ethPortRunts, tokPortFunctionalStatus=tokPortFunctionalStatus, genIntPort=genIntPort, ethIntPortJabber=ethIntPortJabber, clGroupClockRedundancy=clGroupClockRedundancy, tokGroupEntry=tokGroupEntry, tokPortSpecificOID=tokPortSpecificOID, ltalkPortTable=ltalkPortTable, clGroupEntry=clGroupEntry, chGenAgEntry=chGenAgEntry, tsGroupLATStatus=tsGroupLATStatus, ethBusTraffic=ethBusTraffic, ethPortUserStatus=ethPortUserStatus, lLERT40BoxOID=lLERT40BoxOID, ltalkPortTestResult=ltalkPortTestResult, softRedundancyPortId1=softRedundancyPortId1, tokGroupAutoBusLoop=tokGroupAutoBusLoop, chLntAgLastAddrConfig=chLntAgLastAddrConfig, genIntPortAdminStatus=genIntPortAdminStatus, ethGroup=ethGroup, genPortSecureAddresses=genPortSecureAddresses, ethAgTable=ethAgTable, tokGroup=tokGroup, tokGroupRingEntry=tokGroupRingEntry, genGroupDescr=genGroupDescr, chHWPSUEntry=chHWPSUEntry, ethGroup10BTPlus=ethGroup10BTPlus, tokRingBeaconing=tokRingBeaconing, ethPortMainBusSelection=ethPortMainBusSelection, chLntAgIntTemp=chLntAgIntTemp, ethIntPortTable=ethIntPortTable, clGroupTable=clGroupTable, tokRingLeftSlot=tokRingLeftSlot, genIntPortId=genIntPortId, lLET3BoxOID=lLET3BoxOID, tokPortTable=tokPortTable, tokRingPeakTraffic=tokRingPeakTraffic, ethPortSQETest=ethPortSQETest, chLntAgSoftwareStatus=chLntAgSoftwareStatus, lFDX100BoxOID=lFDX100BoxOID, chLntAgTempThreshTraps=chLntAgTempThreshTraps, genIntPortBusConnNumber=genIntPortBusConnNumber, lLET18EBoxOID=lLET18EBoxOID, ethBus=ethBus, tokGroupBridgeMode=tokGroupBridgeMode, lannet=lannet, genIntPortEntry=genIntPortEntry, chNumberOfLocalTalkBuses=chNumberOfLocalTalkBuses, chLntAgSLIPAddress=chLntAgSLIPAddress, ethPortNoAUILoop=ethPortNoAUILoop, ethBusTrafficThresh=ethBusTrafficThresh, genGroupConfigurationSymbol=genGroupConfigurationSymbol, tokGroupManBusLoop=tokGroupManBusLoop, ethPortTable=ethPortTable, chFullConfig=chFullConfig, ethIntPortEntry=ethIntPortEntry, genPortSecurityPolicy=genPortSecurityPolicy, tokRingBeaconingStation=tokRingBeaconingStation, ethGroupWrongPortSelection=ethGroupWrongPortSelection, ethAgId=ethAgId, genGroupSupplyVoltageFault=genGroupSupplyVoltageFault, ethBusPerfEntry=ethBusPerfEntry, ethGroupIntPortsRedundancy=ethGroupIntPortsRedundancy, ethPortLastSourceAddr=ethPortLastSourceAddr, tsGroup=tsGroup, lBoxOID=lBoxOID, chLntAgSWVersion=chLntAgSWVersion, genGroupNumberOfPorts=genGroupNumberOfPorts, genGroupNumberOfIntPorts=genGroupNumberOfIntPorts, chLntAgTrafficThreshTraps=chLntAgTrafficThreshTraps, ethPortMJLP=ethPortMJLP, chNumberOfTRBuses=chNumberOfTRBuses, clGroupMainClock=clGroupMainClock, genGroupRedun34=genGroupRedun34, genPortType=genPortType, tokPortConnected=tokPortConnected, genPortActivityStatus=genPortActivityStatus, genIntPortTable=genIntPortTable, clPortEntry=clPortEntry, tsGroupTable=tsGroupTable, ltalkPortId=ltalkPortId, tokGroupIOMode=tokGroupIOMode, genPortTable=genPortTable, ethBusPerfId=ethBusPerfId, genGroup=genGroup, genPortSpecificOID=genPortSpecificOID, softRedundancyName=softRedundancyName, clPortTable=clPortTable, chLntAgSecAddrConfig=chLntAgSecAddrConfig, tokRingTrafficThresh=tokRingTrafficThresh, genGroupCommStatus=genGroupCommStatus, chLntAgSoftFaultTraps=chLntAgSoftFaultTraps, ethPortFramesReceivedOK=ethPortFramesReceivedOK, ethBusClockId=ethBusClockId, chReset=chReset, softRedundancyEntry=softRedundancyEntry, ethGroupBackboneMode=ethGroupBackboneMode, lLET36BoxOID=lLET36BoxOID, genGroupIntTemp=genGroupIntTemp, ts=ts, chLntAgMgmtBusSelection=chLntAgMgmtBusSelection, chHWPSUId=chHWPSUId, genGroupRedun13_14=genGroupRedun13_14, genPortId=genPortId, chHWPSUTable=chHWPSUTable, cl=cl, ethBusPerfAgId=ethBusPerfAgId, chLntAgCoprocSWVersion=chLntAgCoprocSWVersion, lUnknownBoxOID=lUnknownBoxOID, tokGroupManRightLoop=tokGroupManRightLoop, ethPort=ethPort, ethBusClockTable=ethBusClockTable, ltalkPortJam=ltalkPortJam, clPortId=clPortId, ethGroupTable=ethGroupTable, tokGroupRingId=tokGroupRingId, softRedundancy=softRedundancy, genGroupHWStatus=genGroupHWStatus, genIntPortSpecificOID=genIntPortSpecificOID, genPortEntry=genPortEntry, ltalk=ltalk, chMgr=chMgr, ethIntPortPartition=ethIntPortPartition, ltalkPortTest=ltalkPortTest, genGroupAutoMan=genGroupAutoMan, ethBusTotalPackets=ethBusTotalPackets, ethBusTotalCollisions=ethBusTotalCollisions, tokPortTCP=tokPortTCP, lLET10BoxOID=lLET10BoxOID, tokRingTraffic=tokRingTraffic, chLntAgEntry=chLntAgEntry, ethGroupFIFO=ethGroupFIFO, tokGroupAutoLeftLoop=tokGroupAutoLeftLoop, tokGroupManLinkLoop=tokGroupManLinkLoop, chHWPSUVoltage=chHWPSUVoltage, chHWPeakIntTemp=chHWPeakIntTemp, chNumberOfEthernetBuses=chNumberOfEthernetBuses, chLntAgCoprocCommStatus=chLntAgCoprocCommStatus, genGroupInterProcCommStatus=genGroupInterProcCommStatus, softRedundancyStatus=softRedundancyStatus, chLntAgBootVersion=chLntAgBootVersion, chLntAgSpecificOID=chLntAgSpecificOID, tokGroupSpecificOID=tokGroupSpecificOID, clPortFunctionalStatus=clPortFunctionalStatus, softRedundancyGroupId2=softRedundancyGroupId2, chGenAgId=chGenAgId, chMgrTrapRepStatus=chMgrTrapRepStatus, chNumberOfFDDIBuses=chNumberOfFDDIBuses, genGroupStandAloneMode=genGroupStandAloneMode, chHW=chHW, tokRingTable=tokRingTable, tokGroupRingGroupId=tokGroupRingGroupId, clPortGroupId=clPortGroupId, chLntAgKernelVersion=chLntAgKernelVersion, tokRingEntry=tokRingEntry, softRedundancyPortId2=softRedundancyPortId2, ethPortSpecificOID=ethPortSpecificOID, chGenAgSpecificOID=chGenAgSpecificOID, tsGroupEntry=tsGroupEntry, genIntPortActivityStatus=genIntPortActivityStatus, lntOID=lntOID, tokPortBypass=tokPortBypass, genIntPortGroupId=genIntPortGroupId, tokPortId=tokPortId, genGroupSpecificOID=genGroupSpecificOID, chHWPSUActivityStatus=chHWPSUActivityStatus, chLntAgCommDebugMode=chLntAgCommDebugMode, softRedundancyGroupId1=softRedundancyGroupId1, chLntAgGroupEnrollDeenrollTraps=chLntAgGroupEnrollDeenrollTraps, ethAgEntry=ethAgEntry, ethAgPerfBusSelection=ethAgPerfBusSelection, ethPortManPart=ethPortManPart, ethIntPortId=ethIntPortId, genGroupTable=genGroupTable, ethBusTrafficBuffer=ethBusTrafficBuffer, tokGroupId=tokGroupId, chLntAgTable=chLntAgTable, ltalkPortEntry=ltalkPortEntry, ethPortAutoPartitionState=ethPortAutoPartitionState, chLntAgId=chLntAgId, tokPortGroupId=tokPortGroupId, tokPort=tokPort, ethPortFIFO=ethPortFIFO, tokGroupLeftNeighbor=tokGroupLeftNeighbor, ethIntPortGroupId=ethIntPortGroupId, genGroupType=genGroupType, chMgrMngmtState=chMgrMngmtState, genGroupId=genGroupId, tokRing=tokRing, ethPortTraffic=ethPortTraffic, ethPortPacketErrors=ethPortPacketErrors, tokGroupAutoLinkLoop=tokGroupAutoLinkLoop, ethGroupEntry=ethGroupEntry, tokRingStationsMatch=tokRingStationsMatch, clGroup=clGroup, chLntAgConfigChangeTraps=chLntAgConfigChangeTraps, ethBusClockTestResult=ethBusClockTestResult, tokPortLastSourceAddr=tokPortLastSourceAddr, ethPortFunctionalStatus=ethPortFunctionalStatus, ethBusClockBusId=ethBusClockBusId, ethAg=ethAg, tok=tok, tokRingConfiguration=tokRingConfiguration, chassis=chassis, chLntAgFaultTraps=chLntAgFaultTraps, tokGroupRingSpeed=tokGroupRingSpeed, ethBusClockEntry=ethBusClockEntry, genPortFunctionality=genPortFunctionality, chLntAgConfigurationSymbol=chLntAgConfigurationSymbol, softRedundancyId=softRedundancyId, ethGroupSingleBusMode=ethGroupSingleBusMode, chAg=chAg, tokPortCableFault=tokPortCableFault, lLET18BoxOID=lLET18BoxOID, ethPortEntry=ethPortEntry, softRedundancyTable=softRedundancyTable, eth=eth, ethBusTotalErrors=ethBusTotalErrors, chGenAgType=chGenAgType, genGroupKernelVersion=genGroupKernelVersion, genPortAdminStatus=genPortAdminStatus, ethPortJabber=ethPortJabber, genPort=genPort, ethGroupId=ethGroupId, tsGroupId=tsGroupId, chHWType=chHWType, tokGroupTable=tokGroupTable, ethBusPerfTable=ethBusPerfTable, clGroupId=clGroupId, ethGroupBackupBus=ethGroupBackupBus, chLntAgSWFault=chLntAgSWFault, ethPortId=ethPortId, genPortGroupId=genPortGroupId, ethBusPeakTraffic=ethBusPeakTraffic)
mibBuilder.exportSymbols("LANNET-MIB", genPortDescr=genPortDescr, ethGroupSpecificOID=ethGroupSpecificOID, ltalkPort=ltalkPort, clGroupTestClocks=clGroupTestClocks, clPort=clPort, tokRingTrafficBuffer=tokRingTrafficBuffer, chNumberOfSlots=chNumberOfSlots, chGenAgMgmtIfType=chGenAgMgmtIfType, tokRingId=tokRingId, ethIntPortBackedUp=ethIntPortBackedUp, ltalkPortGroupId=ltalkPortGroupId, tokGroupAutoRightLoop=tokGroupAutoRightLoop, tokGroupRightNeighbor=tokGroupRightNeighbor, genIntPortBusConnType=genIntPortBusConnType, chHWPSULocation=chHWPSULocation, tokGroupRingInserted=tokGroupRingInserted, chGenAgTable=chGenAgTable, genGroupReset=genGroupReset)

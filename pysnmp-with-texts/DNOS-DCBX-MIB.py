#
# PySNMP MIB module DNOS-DCBX-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/DNOS-DCBX-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:51:23 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, SingleValueConstraint, ValueSizeConstraint, ConstraintsUnion, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsUnion", "ValueRangeConstraint")
dnOS, = mibBuilder.importSymbols("DELL-REF-MIB", "dnOS")
InterfaceIndex, = mibBuilder.importSymbols("IF-MIB", "InterfaceIndex")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
MibScalar, MibTable, MibTableRow, MibTableColumn, IpAddress, Integer32, Counter32, MibIdentifier, TimeTicks, ObjectIdentity, NotificationType, Gauge32, ModuleIdentity, Unsigned32, Counter64, iso, Bits = mibBuilder.importSymbols("SNMPv2-SMI", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "IpAddress", "Integer32", "Counter32", "MibIdentifier", "TimeTicks", "ObjectIdentity", "NotificationType", "Gauge32", "ModuleIdentity", "Unsigned32", "Counter64", "iso", "Bits")
TextualConvention, MacAddress, RowStatus, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "MacAddress", "RowStatus", "DisplayString")
fastPathDCBX = ModuleIdentity((1, 3, 6, 1, 4, 1, 674, 10895, 5000, 2, 6132, 1, 1, 58))
fastPathDCBX.setRevisions(('2011-04-20 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: fastPathDCBX.setRevisionsDescriptions(('Initial version.',))
if mibBuilder.loadTexts: fastPathDCBX.setLastUpdated('201101260000Z')
if mibBuilder.loadTexts: fastPathDCBX.setOrganization('Dell, Inc.')
if mibBuilder.loadTexts: fastPathDCBX.setContactInfo('')
if mibBuilder.loadTexts: fastPathDCBX.setDescription('The MIB definitions Data Center Bridging Exchange Protocol.')
class DcbxPortRole(TextualConvention, Integer32):
    description = '.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("manual", 1), ("autoup", 2), ("autodown", 3), ("configSource", 4))

class DcbxVersion(TextualConvention, Integer32):
    description = '.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("auto", 1), ("ieee", 2), ("cin", 3), ("cee", 4))

agentDcbxGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 674, 10895, 5000, 2, 6132, 1, 1, 58, 1))
agentDcbxTable = MibTable((1, 3, 6, 1, 4, 1, 674, 10895, 5000, 2, 6132, 1, 1, 58, 1, 1), )
if mibBuilder.loadTexts: agentDcbxTable.setStatus('current')
if mibBuilder.loadTexts: agentDcbxTable.setDescription('A table providing configuration of DCBX per interface.')
agentDcbxEntry = MibTableRow((1, 3, 6, 1, 4, 1, 674, 10895, 5000, 2, 6132, 1, 1, 58, 1, 1, 1), ).setIndexNames((0, "DNOS-DCBX-MIB", "agentDcbxIntfIndex"))
if mibBuilder.loadTexts: agentDcbxEntry.setStatus('current')
if mibBuilder.loadTexts: agentDcbxEntry.setDescription('DCBX configuration for a port.')
agentDcbxIntfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 674, 10895, 5000, 2, 6132, 1, 1, 58, 1, 1, 1, 1), InterfaceIndex())
if mibBuilder.loadTexts: agentDcbxIntfIndex.setStatus('current')
if mibBuilder.loadTexts: agentDcbxIntfIndex.setDescription('This is a unique index for an entry in the agentDcbxTable. A non-zero value indicates the ifIndex for the corresponding interface entry in the ifTable.')
agentDcbxAutoCfgPortRole = MibTableColumn((1, 3, 6, 1, 4, 1, 674, 10895, 5000, 2, 6132, 1, 1, 58, 1, 1, 1, 2), DcbxPortRole().clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agentDcbxAutoCfgPortRole.setStatus('current')
if mibBuilder.loadTexts: agentDcbxAutoCfgPortRole.setDescription(' Ports operating in the manual role do not have their configuration affected by peer devices or by internal propagation of configuration. These ports will advertise their configuration to their peer if DCBX is enabled on that port. Auto-up: Advertises a configuration, but is also willing to accept a configuration from the link-partner and propagate it internally to the auto-downstream ports as well as receive configuration propagated internally by other auto-upstream ports. Auto-down: Advertises a configuration but is not willing to accept one from the link partner. However, the port will accept a configuration propagated internally by the configuration source. Configuration Source:In this role, the port has been manually selected to be the configuration source. Configuration received over this port is propagated to the other auto-configuration ports.')
agentDcbxVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 674, 10895, 5000, 2, 6132, 1, 1, 58, 1, 1, 1, 3), DcbxVersion().clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agentDcbxVersion.setStatus('deprecated')
if mibBuilder.loadTexts: agentDcbxVersion.setDescription('CIN is Cisco Intel Nuova DCBX (version 1.0). CEE is converged enhanced ethernet DCBX (version 1.06). IEEE is 802-1 az version. The default value is auto. DCBX supports the legacy implementations v1.0 (CIN) and v1.06 (CEE) in addition to standard IEEE version 2.4 DCBX. 1.DCBX starts in standard IEEE mode by sending an IEEE standard version 2.4 DCBX frame. If the peer responds, then IEEE standard version 2.4 DCBX is used,Starts means after a link up, a DCBX timeout (or multiple peer condition) or when commanded by the network operator. If DCBX receives a DCBX frame with an OUI indicating a legacy version, it immediately switches into legacy mode for the detected version and does not wait for the 3x LLDP fast timeout. 2.If no IEEE DCBX response is received within 3 times the LLDP fast transmit timeout period, DCBX immediately transmits a version 1.06 DCBX frame with the appropriate version number. If DCBX receives a DCBX frame with an OUI indicating IEEE standard support, it immediately switches into IEEE standard mode and does not wait for the timer. If DCBX receives a DCBX frame with an OUI indicating legacy mode and a version number indicating version 1.0 support, it immediately switches into legacy 1.0 mode and does not wait for the timer. 3.If no version 1.06 response is received within 3 times the DCBX fast transmit timeout period, DCBX falls back to version 1.0 and immediately transmits a version 1.0 frame. If no response is received within 3 times the DCBX fast transmit period, DCBX waits the standard LLDP timeout period, and then begins again with step 1. If DCBX receives a DCBX frame with an OUI indicating IEEE standard mode, it immediately switches into IEEE standard mode.')
agentDcbxSupportedTLVs = MibTableColumn((1, 3, 6, 1, 4, 1, 674, 10895, 5000, 2, 6132, 1, 1, 58, 1, 1, 1, 4), Bits().clone(namedValues=NamedValues(("pfc", 0), ("etsConfig", 1), ("etsRecom", 2), ("applicationPriority", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agentDcbxSupportedTLVs.setStatus('current')
if mibBuilder.loadTexts: agentDcbxSupportedTLVs.setDescription("Bitmap that includes the supported set of DCBX LLDP TLVs the device is capable of and whose transmission is allowed on the local LLDP agent by network management. Having the bit 'pfc(0)' set indicates that the LLDP transmit PFC TLV as part of DCBX TLVs. Having the bit 'etcConfig(1)' set indicates that the LLDP transmit ETS configuration TLV as part of DCBX TLVs. Having the bit 'etsRecom(2)' set indicates that transmit ETS Recomdenation TLV as part of DCBX TLVs. Having the bit 'applicationPriority(3)' set indicates that the LLDP transmit applicationPriority TLV as part of DCBX TLVs.")
agentDcbxConfigTLVsTxEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 674, 10895, 5000, 2, 6132, 1, 1, 58, 1, 1, 1, 5), Bits().clone(namedValues=NamedValues(("pfc", 0), ("etsConfig", 1), ("etsRecom", 2), ("applicationPriority", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agentDcbxConfigTLVsTxEnable.setStatus('current')
if mibBuilder.loadTexts: agentDcbxConfigTLVsTxEnable.setDescription("Bitmap that includes the DCBX defined set of LLDP TLVs the device is capable of and whose transmission is allowed on the local LLDP agent by network management. Having the bit 'pfc(0)' set indicates that the LLDP transmit PFC TLV as part of DCBX TLVs. Having the bit 'etcConfig(1)' set indicates that the LLDP transmit ETS configuration TLV as part of DCBX TLVs. Having the bit 'etsRecom(2)' set indicates that transmit ETS Recomdenation TLV as part of DCBX TLVs. Having the bit 'applicationPriority(3)' set indicates that the LLDP transmit applicationPriority TLV as part of DCBX TLVs.")
agentDcbxStatusTable = MibTable((1, 3, 6, 1, 4, 1, 674, 10895, 5000, 2, 6132, 1, 1, 58, 1, 2), )
if mibBuilder.loadTexts: agentDcbxStatusTable.setStatus('current')
if mibBuilder.loadTexts: agentDcbxStatusTable.setDescription('.')
agentDcbxStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 674, 10895, 5000, 2, 6132, 1, 1, 58, 1, 2, 1), ).setIndexNames((0, "DNOS-DCBX-MIB", "agentDcbxIntfIndex"))
if mibBuilder.loadTexts: agentDcbxStatusEntry.setStatus('current')
if mibBuilder.loadTexts: agentDcbxStatusEntry.setDescription('.')
agentDcbxOperVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 674, 10895, 5000, 2, 6132, 1, 1, 58, 1, 2, 1, 2), DcbxVersion().clone(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: agentDcbxOperVersion.setStatus('current')
if mibBuilder.loadTexts: agentDcbxOperVersion.setDescription('Specifies the DCBX mode in which the interface is currently operating.')
agentDcbxPeerMACaddress = MibTableColumn((1, 3, 6, 1, 4, 1, 674, 10895, 5000, 2, 6132, 1, 1, 58, 1, 2, 1, 3), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agentDcbxPeerMACaddress.setStatus('current')
if mibBuilder.loadTexts: agentDcbxPeerMACaddress.setDescription('MAC Address of the DCBX peer.')
agentDcbxCfgSource = MibTableColumn((1, 3, 6, 1, 4, 1, 674, 10895, 5000, 2, 6132, 1, 1, 58, 1, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 0))).clone(namedValues=NamedValues(("true", 1), ("false", 0)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agentDcbxCfgSource.setStatus('current')
if mibBuilder.loadTexts: agentDcbxCfgSource.setDescription('Indicates if this port is the source of configuration information for auto-* ports.')
agentDcbxMultiplePeerCount = MibTableColumn((1, 3, 6, 1, 4, 1, 674, 10895, 5000, 2, 6132, 1, 1, 58, 1, 2, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agentDcbxMultiplePeerCount.setStatus('current')
if mibBuilder.loadTexts: agentDcbxMultiplePeerCount.setDescription('Indicates number of times multiple peers were detected. A duplicate peer is when more than one DCBX peer is detected on a port.')
agentDcbxPeerRemovedCount = MibTableColumn((1, 3, 6, 1, 4, 1, 674, 10895, 5000, 2, 6132, 1, 1, 58, 1, 2, 1, 6), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agentDcbxPeerRemovedCount.setStatus('current')
if mibBuilder.loadTexts: agentDcbxPeerRemovedCount.setDescription('.')
agentDcbxPeerOperVersionNum = MibTableColumn((1, 3, 6, 1, 4, 1, 674, 10895, 5000, 2, 6132, 1, 1, 58, 1, 2, 1, 7), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agentDcbxPeerOperVersionNum.setStatus('current')
if mibBuilder.loadTexts: agentDcbxPeerOperVersionNum.setDescription('Specifies the operational version of the peer DCBX device. Valid only when peer device is a CEE/CIN DCBX device.')
agentDcbxPeerMaxVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 674, 10895, 5000, 2, 6132, 1, 1, 58, 1, 2, 1, 8), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agentDcbxPeerMaxVersion.setStatus('current')
if mibBuilder.loadTexts: agentDcbxPeerMaxVersion.setDescription('Specifies the max version of the peer DCBX device. Valid only when peer device is CEE/CIN DCBX device.')
agentDcbxSeqNum = MibTableColumn((1, 3, 6, 1, 4, 1, 674, 10895, 5000, 2, 6132, 1, 1, 58, 1, 2, 1, 9), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agentDcbxSeqNum.setStatus('current')
if mibBuilder.loadTexts: agentDcbxSeqNum.setDescription('Specifies the current sequence number that is sent in DCBX control TLVs in CEE/CIN Mode.')
agentDcbxAckNum = MibTableColumn((1, 3, 6, 1, 4, 1, 674, 10895, 5000, 2, 6132, 1, 1, 58, 1, 2, 1, 10), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agentDcbxAckNum.setStatus('current')
if mibBuilder.loadTexts: agentDcbxAckNum.setDescription('Specifies the current ACK number that is to be sent to peer in DCBX control TLVs in CEE/CIN Mode.')
agentDcbxPeerRcvdAckNum = MibTableColumn((1, 3, 6, 1, 4, 1, 674, 10895, 5000, 2, 6132, 1, 1, 58, 1, 2, 1, 11), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agentDcbxPeerRcvdAckNum.setStatus('current')
if mibBuilder.loadTexts: agentDcbxPeerRcvdAckNum.setDescription('Specifies the current ACK number that is sent by peer in DCBX control TLV in CEE/CIN Mode.')
agentDcbxTxCount = MibTableColumn((1, 3, 6, 1, 4, 1, 674, 10895, 5000, 2, 6132, 1, 1, 58, 1, 2, 1, 12), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agentDcbxTxCount.setStatus('current')
if mibBuilder.loadTexts: agentDcbxTxCount.setDescription('The number of DCBX frames transmitted per interface.')
agentDcbxRxCount = MibTableColumn((1, 3, 6, 1, 4, 1, 674, 10895, 5000, 2, 6132, 1, 1, 58, 1, 2, 1, 13), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agentDcbxRxCount.setStatus('current')
if mibBuilder.loadTexts: agentDcbxRxCount.setDescription('The number of DCBX frames received per interface.')
agentDcbxErrorFramesCount = MibTableColumn((1, 3, 6, 1, 4, 1, 674, 10895, 5000, 2, 6132, 1, 1, 58, 1, 2, 1, 14), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agentDcbxErrorFramesCount.setStatus('current')
if mibBuilder.loadTexts: agentDcbxErrorFramesCount.setDescription('The number of DCBX frames discarded due to errors in the frame.')
agentDcbxUnknownTLVsCount = MibTableColumn((1, 3, 6, 1, 4, 1, 674, 10895, 5000, 2, 6132, 1, 1, 58, 1, 2, 1, 15), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agentDcbxUnknownTLVsCount.setStatus('current')
if mibBuilder.loadTexts: agentDcbxUnknownTLVsCount.setDescription('The number of DCBX (PFC, ETS, Application Priority or other) TLVs not recognized.')
agentDcbxGroupGlobalConfGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 674, 10895, 5000, 2, 6132, 1, 1, 58, 1, 3))
agentDcbxGlobalConfVersion = MibScalar((1, 3, 6, 1, 4, 1, 674, 10895, 5000, 2, 6132, 1, 1, 58, 1, 3, 1), DcbxVersion().clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agentDcbxGlobalConfVersion.setStatus('current')
if mibBuilder.loadTexts: agentDcbxGlobalConfVersion.setDescription('CIN is Cisco Intel Nuova DCBX (version 1.0). CEE is converged enhanced ethernet DCBX (version 1.06). IEEE is 802-1 az version. The default value is auto. DCBX supports the legacy implementations v1.0 (CIN) and v1.06 (CEE) in addition to standard IEEE version 2.4 DCBX. 1.DCBX starts in standard IEEE mode by sending an IEEE standard version 2.4 DCBX frame. If the peer responds, then IEEE standard version 2.4 DCBX is used,Starts means after a link up, a DCBX timeout (or multiple peer condition) or when commanded by the network operator. If DCBX receives a DCBX frame with an OUI indicating a legacy version, it immediately switches into legacy mode for the detected version and does not wait for the 3x LLDP fast timeout. 2.If no IEEE DCBX response is received within 3 times the LLDP fast transmit timeout period, DCBX immediately transmits a version 1.06 DCBX frame with the appropriate version number. If DCBX receives a DCBX frame with an OUI indicating IEEE standard support, it immediately switches into IEEE standard mode and does not wait for the timer. If DCBX receives a DCBX frame with an OUI indicating legacy mode and a version number indicating version 1.0 support, it immediately switches into legacy 1.0 mode and does not wait for the timer. 3.If no version 1.06 response is received within 3 times the DCBX fast transmit timeout period, DCBX falls back to version 1.0 and immediately transmits a version 1.0 frame. If no response is received within 3 times the DCBX fast transmit period, DCBX waits the standard LLDP timeout period, and then begins again with step 1. If DCBX receives a DCBX frame with an OUI indicating IEEE standard mode, it immediately switches into IEEE standard mode.')
mibBuilder.exportSymbols("DNOS-DCBX-MIB", agentDcbxGroupGlobalConfGroup=agentDcbxGroupGlobalConfGroup, agentDcbxOperVersion=agentDcbxOperVersion, agentDcbxAckNum=agentDcbxAckNum, agentDcbxSupportedTLVs=agentDcbxSupportedTLVs, agentDcbxStatusEntry=agentDcbxStatusEntry, agentDcbxUnknownTLVsCount=agentDcbxUnknownTLVsCount, agentDcbxEntry=agentDcbxEntry, agentDcbxTable=agentDcbxTable, agentDcbxRxCount=agentDcbxRxCount, agentDcbxPeerRemovedCount=agentDcbxPeerRemovedCount, agentDcbxCfgSource=agentDcbxCfgSource, agentDcbxPeerRcvdAckNum=agentDcbxPeerRcvdAckNum, agentDcbxVersion=agentDcbxVersion, DcbxPortRole=DcbxPortRole, agentDcbxGroup=agentDcbxGroup, agentDcbxPeerOperVersionNum=agentDcbxPeerOperVersionNum, agentDcbxPeerMaxVersion=agentDcbxPeerMaxVersion, fastPathDCBX=fastPathDCBX, agentDcbxIntfIndex=agentDcbxIntfIndex, agentDcbxStatusTable=agentDcbxStatusTable, agentDcbxAutoCfgPortRole=agentDcbxAutoCfgPortRole, DcbxVersion=DcbxVersion, PYSNMP_MODULE_ID=fastPathDCBX, agentDcbxTxCount=agentDcbxTxCount, agentDcbxErrorFramesCount=agentDcbxErrorFramesCount, agentDcbxConfigTLVsTxEnable=agentDcbxConfigTLVsTxEnable, agentDcbxPeerMACaddress=agentDcbxPeerMACaddress, agentDcbxGlobalConfVersion=agentDcbxGlobalConfVersion, agentDcbxMultiplePeerCount=agentDcbxMultiplePeerCount, agentDcbxSeqNum=agentDcbxSeqNum)

#
# PySNMP MIB module CTRON-SFCS-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CTRON-SFCS-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:30:44 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ConstraintsIntersection, SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ConstraintsIntersection", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint")
atmVcCrossConnectHighVpi, atmVcCrossConnectLowVci, atmVcCrossConnectLowVpi, atmVcCrossConnectHighIfIndex, atmVcCrossConnectHighVci, atmVcCrossConnectIndex, atmVcCrossConnectLowIfIndex = mibBuilder.importSymbols("ATM-MIB", "atmVcCrossConnectHighVpi", "atmVcCrossConnectLowVci", "atmVcCrossConnectLowVpi", "atmVcCrossConnectHighIfIndex", "atmVcCrossConnectHighVci", "atmVcCrossConnectIndex", "atmVcCrossConnectLowIfIndex")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
NotificationType, Bits, MibIdentifier, Gauge32, ModuleIdentity, Counter32, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter64, ObjectIdentity, IpAddress, iso, Unsigned32, enterprises, TimeTicks, Integer32 = mibBuilder.importSymbols("SNMPv2-SMI", "NotificationType", "Bits", "MibIdentifier", "Gauge32", "ModuleIdentity", "Counter32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter64", "ObjectIdentity", "IpAddress", "iso", "Unsigned32", "enterprises", "TimeTicks", "Integer32")
TruthValue, DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "TruthValue", "DisplayString", "TextualConvention")
cabletron = MibIdentifier((1, 3, 6, 1, 4, 1, 52))
mibs = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4))
ctron = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1))
ctDataLink = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2))
ctSwitch = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11))
ctsfSwitch = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1))
ctSFCS = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1))
sfcsSystem = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 1))
sfcsSysConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 1, 1))
sfcsSysStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 1, 2))
sfcsSysSystemCfg = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 1, 3))
sfcsSysBPCfg = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 1, 4))
sfcsEngine = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 2))
sfcsConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 2, 1))
sfcsStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 2, 2))
sfcsUPCEngine = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 2, 3))
sfcsStatisticsEngine = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 2, 4))
sfcsPacketDiscardEngine = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 2, 5))
sfcsANIM = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 3))
sfcsANIMConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 3, 1))
sfcsANIMStatistics = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 3, 2))
sfcsANIMPic = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 3, 3))
sfcsInterface = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 4))
sfcsInterfaceConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 4, 1))
sfcsInterfaceStatistics = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 4, 2))
sfcsQueue = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 5))
sfcsQueueConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 5, 1))
sfcsQueueStatistics = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 5, 2))
sfcsConnection = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 7))
sfcsConnectionConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 7, 1))
sfcsConnectionStatistics = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 7, 2))
sfcsConnectionError = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 7, 3))
sfcsConnectionAPI = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 8))
sfcsCTM = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 9))
sfcsCTMInterfaceConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 9, 1))
sfcsCTMInterfaceStatistics = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 9, 2))
sfcsCTMQueueConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 9, 3))
sfcsCTMQueueStatistics = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 9, 4))
sfcsBWMgr = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12))
sfcsBwNims = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 1))
sfcsBwPorts = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 2))
sfcsBwPortPools = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3))
sfcsBuffPools = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 4))
sfcsProxy = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 13))
sfcsProxyConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 13, 1))
sfcsProxyTrans = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 13, 2))
sfcsProxyRead = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 13, 3))
sfcsSysConfigTable = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 1, 1, 1))
sfcsSysConfigEnt = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 1, 1, 1, 1))
sfcsSysConfigAdminStatus = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 1, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("other", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsSysConfigAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsSysConfigAdminStatus.setDescription('Sets the administrative state of the SFCS switching services for this virtual switch. This controls the SFCS state at a chassis level. Regardless of the per-interface state of each SFCS switching element and the state of active connections, writing the value disabled(2) will cause the entire switch to immediately shutdown. enabled(1) -- startup the SFCS disabled(2) -- shutdown the SFCS other(3) -- none of the following')
sfcsSysConfigOperStatus = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 1, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("other", 3), ("pending-disable", 4), ("pending-enable", 5), ("invalid-config", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsSysConfigOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsSysConfigOperStatus.setDescription('Indicates the current operating condition of this switch. enabled(1) -- running disabled(2) -- not running other(3) -- none of the following pending-disable(4) -- shut-down in progress pending-enable(5) -- start-up in progress invalid-config(6) -- not running,invalid config')
sfcsSysConfigOperTime = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 1, 1, 1, 1, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsSysConfigOperTime.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsSysConfigOperTime.setDescription('Indicates the amount of time (# of time ticks) that this switch system has been in its current operational state.')
sfcsSysConfigLastChange = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 1, 1, 1, 1, 4), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsSysConfigLastChange.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsSysConfigLastChange.setDescription('Indicates the last time a change was made to the configuration entry for this switch.')
sfcsSysConfigSwitchCapacity = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 1, 1, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsSysConfigSwitchCapacity.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsSysConfigSwitchCapacity.setDescription('Indicates the maximum front panel bandwidth based on current hardware configuration of the switch in Mbps')
sfcsSysConfigMaxCnxEntries = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 1, 1, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsSysConfigMaxCnxEntries.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsSysConfigMaxCnxEntries.setDescription('Indicates the maximum number of connections which can be established on this switch.')
sfcsSysConfigMaxStatEntries = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 1, 1, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsSysConfigMaxStatEntries.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsSysConfigMaxStatEntries.setDescription('Indicates the maximum number of stats enabled VCs for this switch.')
sfcsSysConfigMaxUpcEntries = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 1, 1, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsSysConfigMaxUpcEntries.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsSysConfigMaxUpcEntries.setDescription('Indicates the maximum number of UPC enabled VCs for this switch.')
sfcsSysConfigNumberANIMS = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 1, 1, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsSysConfigNumberANIMS.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsSysConfigNumberANIMS.setDescription('Indicates the number of ATM Network Inteface Modules currently configured on this switch.')
sfcsSysConfigInterfaceCapability = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 1, 1, 1, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsSysConfigInterfaceCapability.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsSysConfigInterfaceCapability.setDescription('Indicates the total bandwidth capability(of the engine) for this switch expressed in Mbps.')
sfcsSysConfigTypeofSwitch = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 1, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("sfcellswitch", 2), ("sfpacketswitch", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsSysConfigTypeofSwitch.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsSysConfigTypeofSwitch.setDescription('Indicates what type of switch this is. other(1) sfcellswitch(2) sfpacketswitch(3)')
sfcsSysConfigPolicingSupport = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 1, 1, 1, 1, 12), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsSysConfigPolicingSupport.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsSysConfigPolicingSupport.setDescription('Indicates whether or not this switch supports policing. supported(1) not supported(2)')
sfcsSysConfigPnniNsapPrefix = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 1, 1, 1, 1, 13), OctetString().subtype(subtypeSpec=ValueSizeConstraint(13, 13)).setFixedLength(13)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsSysConfigPnniNsapPrefix.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsSysConfigPnniNsapPrefix.setDescription('This is the 13 byte NSAP prefix to use with address registration.')
sfcsSysConfigPnniNodeLevel = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 1, 1, 1, 1, 14), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsSysConfigPnniNodeLevel.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsSysConfigPnniNodeLevel.setDescription('This is the PNNI node level value. The range can be from 0 to 104.')
sfcsSysConfigPnniAddessingMode = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 1, 1, 1, 1, 15), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsSysConfigPnniAddessingMode.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsSysConfigPnniAddessingMode.setDescription('This is the PNNI addressing mode - that can range from 0 to 2. 0 - Auto Mode using MAC 1 - Auto Mode using board# 2 - Manual ')
sfcsSysConfigPnniAddessingAdmnStatus = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 1, 1, 1, 1, 16), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsSysConfigPnniAddessingAdmnStatus.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsSysConfigPnniAddessingAdmnStatus.setDescription('This is the PNNI addressing admn status. Down - 2. Up - 1.')
sfcsSysConfigFMVer = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 1, 1, 1, 1, 17), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsSysConfigFMVer.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsSysConfigFMVer.setDescription('This is the Firmware Revision of the switch.')
sfcsSysConfigCTMSlotMask = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 1, 1, 1, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsSysConfigCTMSlotMask.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsSysConfigCTMSlotMask.setDescription('This is the slot mask for all ctm boards in the chassis. The least significant bit represents slot 1.')
sfcsSysConfigMaxfreecva = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 1, 1, 1, 1, 19), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsSysConfigMaxfreecva.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsSysConfigMaxfreecva.setDescription('This is the maximum number of CAC connection blocks that CAC will allow on its free list. The default is 1024. If too low CAC performance will degrade (thrashing control blocks), If too high, memory exhaustion may occur. ')
sfcsSysConfigUBR = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 1, 1, 1, 1, 20), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsSysConfigUBR.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsSysConfigUBR.setDescription('For the set operation: UBR_Cfg is set across all boards in the chassis (that are operational and manageable). For the get operation: UBR_Cfg setting is retrived from the current chassis manager only (one slot only). IF boards are introduced or re-introduced to the chassis their UBR value will be 0. In order to insure a required UBR_Cfg value the set operation should be proformed after slot insertions or re-insertions are completed to the chassis. ')
sfcsSysStatusTable = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 1, 2, 1))
sfcsSysStatusEnt = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 1, 2, 1, 1))
sfcsSysStatusTdmCellCount = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 1, 2, 1, 1, 1), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsSysStatusTdmCellCount.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsSysStatusTdmCellCount.setDescription('Indicates the total number of cells being transfered across the TDM for the entire switch.')
sfcsSysStatusTdmUtilization = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 1, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsSysStatusTdmUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsSysStatusTdmUtilization.setDescription('Indicates the total percentage TDM utilization for the switch.')
sfcsSysStatusCurrCnxEntries = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 1, 2, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsSysStatusCurrCnxEntries.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsSysStatusCurrCnxEntries.setDescription('Indicates the current number of connection entries for this switch.')
sfcsSysStatusCurrUPCEntries = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 1, 2, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsSysStatusCurrUPCEntries.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsSysStatusCurrUPCEntries.setDescription('Indicates the current number of UPC entries for this switch.')
sfcsSysStatusCurrStatsEntries = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 1, 2, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsSysStatusCurrStatsEntries.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsSysStatusCurrStatsEntries.setDescription('Indicates the current number of statistics entries for this switch.')
sfcsSysStatusAllocatedBw = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 1, 2, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsSysStatusAllocatedBw.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsSysStatusAllocatedBw.setDescription('Indicates the current allocated bandwidth of the switch in bits per second.')
sfcsSysSystemCfgTable = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 1, 3, 1))
sfcsSysSystemCfgEnt = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 1, 3, 1, 1))
sfcsSysConfigAdminReset = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 1, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsSysConfigAdminReset.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsSysConfigAdminReset.setDescription('Resets this virtual switch. Writing a value of reset(2) will force a restart of the entire switch, without any graceful shutdown. Any active connections or services will be interrupted. other(1) -- none of the following reset(2) -- force a reset')
sfcsSysConfigATOMPersistance = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 1, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsSysConfigATOMPersistance.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsSysConfigATOMPersistance.setDescription('This enables or disables ATOM mib persistance. enabled(1) disabled(2)')
sfcsSysConfigVcSize = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 1, 3, 1, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsSysConfigVcSize.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsSysConfigVcSize.setDescription('This entry is the size of VCs allocated for all VPs in the switch.')
sfcsSysConfigPowerUpDiags = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 1, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsSysConfigPowerUpDiags.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsSysConfigPowerUpDiags.setDescription('This enables or disables power up diags. enabled(1) disabled(2)')
sfcsSysBPTable = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 1, 4, 1))
sfcsSysBPEnt = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 1, 4, 1, 1))
sfcsSysBPClkSelect = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 1, 4, 1, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsSysBPClkSelect.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsSysBPClkSelect.setDescription('This enables one of two backplane clocks from any slot. A valid entry is any number that correspond to a slot having a board supporting this mib. A write to this mib will fail if the board with the number selected is deriving its clock from the backplane. A value of 0 indicates that no board is driving the backplane.')
sfcsConfigTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 2, 1, 1), )
if mibBuilder.loadTexts: sfcsConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsConfigTable.setDescription('This table contains the configuration and administrative information for each SFCS module. Essentially, a separate SFCS instance exists for each switch module. If SFCS is not configured on a module, than an entry will not exist.')
sfcsConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 2, 1, 1, 1), ).setIndexNames((0, "CTRON-SFCS-MIB", "sfcsConfigSlotIndex"))
if mibBuilder.loadTexts: sfcsConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsConfigEntry.setDescription('Each entry specifies the SFCS configuration for the SFCS module.')
sfcsConfigSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 2, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsConfigSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsConfigSlotIndex.setDescription('The primary index to the SFCS switch table. This identifies the chassis slot number for this switch module.')
sfcsConfigAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 2, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("other", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsConfigAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsConfigAdminStatus.setDescription('Sets the administrative state of the SFCS switching services for this SFCS module. This controls the SFCS state at a module level. Regardless of the per-interface state of each SFCS switching interface and the state of active connections, writing the value disabled(2) will cause the SFCS to immediately shutdown. A gracefull shutdown will be attempted. enabled(1) -- startup the SFCS disabled(2) -- shutdown the SFCS other(3) -- none of the following')
sfcsConfigAdminReset = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 2, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsConfigAdminReset.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsConfigAdminReset.setDescription('Resets this SFCS module. Writing a value of reset(2) will force a soft restart of the SFCS without any graceful shutdown. Any active connections or services will be interrupted. other(1) -- none of the following reset(2) -- force a reset')
sfcsConfigOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 2, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("other", 3), ("pending-disable", 4), ("pending-enable", 5), ("invalid-config", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsConfigOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsConfigOperStatus.setDescription('Indicates the current operating condition of the SFCS module. enabled(1) -- running disabled(2) -- not running other(3) -- none of the following pending-disable(4) -- shut-down in progress pending-enable(5) -- start-up in progress invalid-config(6) -- not running,invalid config')
sfcsConfigOperTime = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 2, 1, 1, 1, 5), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsConfigOperTime.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsConfigOperTime.setDescription('Indicates the amount of time (# of time ticks) that this SFCS module has been in its current operational state.')
sfcsConfigLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 2, 1, 1, 1, 6), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsConfigLastChange.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsConfigLastChange.setDescription('Indicates the last time a change was made to the configuration entry for this SFCS switch module.')
sfcsConfigVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 2, 1, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsConfigVersion.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsConfigVersion.setDescription('Indicates the current revision level of the SFCS MIB for this switch module expressed as an integer.')
sfcsConfigMibRev = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 2, 1, 1, 1, 8), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsConfigMibRev.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsConfigMibRev.setDescription('Indicates in textual format the current revision level of the Cabletron SFCS MIB for this switch module.')
sfcsConfigSwitchHostPort = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 2, 1, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsConfigSwitchHostPort.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsConfigSwitchHostPort.setDescription('Indicates the switch port that is attached to the host.')
sfcsConfigHostCtrlATMAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 2, 1, 1, 1, 10), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsConfigHostCtrlATMAddr.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsConfigHostCtrlATMAddr.setDescription('Indicates the ATM address of the host. (SAR)')
sfcsConfigSwitchCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 2, 1, 1, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsConfigSwitchCapacity.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsConfigSwitchCapacity.setDescription('Indicates the front panel bandwidth based on the hardware that is currently installed, in Mbps. (number of ports and the port type)')
sfcsConfigMaxCnxEntries = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 2, 1, 1, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsConfigMaxCnxEntries.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsConfigMaxCnxEntries.setDescription('Indicates the maximum number of connections which can be established on this switch module.')
sfcsConfigMaxStatEntries = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 2, 1, 1, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsConfigMaxStatEntries.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsConfigMaxStatEntries.setDescription('Indicates the maximum number of stats enabled VCs for this switch module.')
sfcsConfigMaxUpcEntries = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 2, 1, 1, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsConfigMaxUpcEntries.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsConfigMaxUpcEntries.setDescription('Indicates the maximum number of UPC enabled VCs for this switch module.')
sfcsConfigNumberANIMS = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 2, 1, 1, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsConfigNumberANIMS.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsConfigNumberANIMS.setDescription('Indicates the number of ATM Network Inteface Modules currently configured on this switch module.')
sfcsConfigBwCapability = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 2, 1, 1, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsConfigBwCapability.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsConfigBwCapability.setDescription('Indicates the total bandwidth capability for this switch engine expressed in Mbps.')
sfcsConfigMasterClock1Source = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 2, 1, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("anim-one-clk", 1), ("anim-two-clk", 2), ("anim-three-clk", 3), ("anim-four-clk", 4), ("backplane-one", 5), ("backplane-two", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsConfigMasterClock1Source.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsConfigMasterClock1Source.setDescription('Indicates the clocking source for MasterClock1 on each board. The write will fail if it is also currently the source of the backplane. The write will also fail if the board does not support backplane clocking.')
sfcsConfigMasterClock2Source = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 2, 1, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("anim-one-clk", 1), ("anim-two-clk", 2), ("anim-three-clk", 3), ("anim-four-clk", 4), ("backplane-one", 5), ("backplane-two", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsConfigMasterClock2Source.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsConfigMasterClock2Source.setDescription('Indicates the clocking source for MasterClock2 on each board. The write will fail if it is also currently the source of the backplane. The write will also fail if the board does not support backplane clocking.')
sfcsConfigMasterClock1Standby = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 2, 1, 1, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("anim-one-clk", 1), ("anim-two-clk", 2), ("anim-three-clk", 3), ("anim-four-clk", 4), ("backplane-one", 5), ("backplane-two", 6), ("none", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsConfigMasterClock1Standby.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsConfigMasterClock1Standby.setDescription('Indicates the clocking stand-by for MasterClock1 on each board. The write will fail if it is also currently the source of the backplane. The write will also fail if the board does not support backplane clocking. If this value is none(7) and an interrupt on the primary interface for MasterClock1 is received. MasterClock1 will switch to that anims local clock.')
sfcsConfigMasterClock2Standby = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 2, 1, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("anim-one-clk", 1), ("anim-two-clk", 2), ("anim-three-clk", 3), ("anim-four-clk", 4), ("backplane-one", 5), ("backplane-two", 6), ("none", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsConfigMasterClock2Standby.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsConfigMasterClock2Standby.setDescription('Indicates the clocking stand-by for MasterClock2 on each board. The write will fail if it is also currently the source of the backplane. The write will also fail if the board does not support backplane clocking. If this value is none(7) and an interrupt on the primary interface for MasterClock1 is received. MasterClock1 will switch to that anims local clock.')
sfcsStatusTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 2, 2, 1), )
if mibBuilder.loadTexts: sfcsStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsStatusTable.setDescription('This table contains the status information for each SFCS switch module.')
sfcsStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 2, 2, 1, 1), ).setIndexNames((0, "CTRON-SFCS-MIB", "sfcsStatusSlotIndex"))
if mibBuilder.loadTexts: sfcsStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsStatusEntry.setDescription('Each entry contains the SFCS statistics for the SFCS instance.')
sfcsStatusSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 2, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsStatusSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsStatusSlotIndex.setDescription('The primary index to the SFCS switch table. This identifies the chassis slot number for this SFCS module.')
sfcsStatusTdmCellCount = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 2, 2, 1, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsStatusTdmCellCount.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsStatusTdmCellCount.setDescription('Indicates the total number of cells being transfered across the TDM for this switch module.')
sfcsStatusTdmUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 2, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsStatusTdmUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsStatusTdmUtilization.setDescription('Indicates the percentage TDM utilization for this switch module.')
sfcsStatusCurrCnxEntries = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 2, 2, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsStatusCurrCnxEntries.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsStatusCurrCnxEntries.setDescription('Indicates the current number of connection entries for this switch module.')
sfcsStatusCurrUPCEntries = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 2, 2, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsStatusCurrUPCEntries.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsStatusCurrUPCEntries.setDescription('Indicates the current number of UPC entries for this switch module.')
sfcsStatusCurrStatsEntries = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 2, 2, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsStatusCurrStatsEntries.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsStatusCurrStatsEntries.setDescription('Indicates the current number of statistics entries for this switch module.')
sfcsStatusCurrCtmAgent = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 2, 2, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsStatusCurrCtmAgent.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsStatusCurrCtmAgent.setDescription('Indicates the current board number of the ctm agent for this switch module.')
sfcsUPCTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 2, 3, 1), )
if mibBuilder.loadTexts: sfcsUPCTable.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsUPCTable.setDescription('This table contains the Usage Parameter Control info for this SFCS module.')
sfcsUPCEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 2, 3, 1, 1), ).setIndexNames((0, "CTRON-SFCS-MIB", "sfcsUPCSlotIndex"))
if mibBuilder.loadTexts: sfcsUPCEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsUPCEntry.setDescription('Each entry contains the UPC data for the SFCS instance.')
sfcsUPCSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 2, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsUPCSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsUPCSlotIndex.setDescription('The primary index to the SFCS switch table. This identifies the slot number for this SFCS module.')
sfcsUPCAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 2, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("other", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsUPCAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsUPCAdminStatus.setDescription("Sets the administrative state of the SFCS module's UPC engine. enabled(1) disabled(2) other(3)")
sfcsUPCOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 2, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("other", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsUPCOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsUPCOperStatus.setDescription("Indicates the operational state of the SFCS module's UPC engine.")
sfcsUPCReset = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 2, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsUPCReset.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsUPCReset.setDescription('Resets the UPC engine for this SFCS module. other(1) reset(2)')
sfcsUPCOperTime = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 2, 3, 1, 1, 5), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsUPCOperTime.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsUPCOperTime.setDescription('Indicates the amount of time (# of time ticks) that the UPC engine has been active for this switch module.')
sfcsStatsEngineTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 2, 4, 1), )
if mibBuilder.loadTexts: sfcsStatsEngineTable.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsStatsEngineTable.setDescription('This table contains information for the Statistics engine for a particular switch module.')
sfcsStatsEngineEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 2, 4, 1, 1), ).setIndexNames((0, "CTRON-SFCS-MIB", "sfcsStatsEngineSlotIndex"))
if mibBuilder.loadTexts: sfcsStatsEngineEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsStatsEngineEntry.setDescription('Each entry contains the statistics engine data for the SFCS module.')
sfcsStatsEngineSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 2, 4, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsStatsEngineSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsStatsEngineSlotIndex.setDescription('The primary index to the SFCS stats engine table. This identifies the chassis slot number for this SFCS module.')
sfcsStatsEngineAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 2, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("other", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsStatsEngineAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsStatsEngineAdminStatus.setDescription('Sets the administrative state of the SFCS switch statistics engine. Writing a value of enabled(1) causes these counters to become active for this SFCS switch instance. Writing a value of disabled(2) causes these counters to become inactive for this SFCS module. enabled(1) disabled(2) other(3)')
sfcsStatsEngineOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 2, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("other", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsStatsEngineOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsStatsEngineOperStatus.setDescription('Indicates the operational state of the SFCS switch statistics engine for this switch module. enabled(1) disabled(2) other(3)')
sfcsStatsEngineReset = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 2, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsStatsEngineReset.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsStatsEngineReset.setDescription('Resets the SFCS switch counters for this SFCS module. Writing a value of reset(2) resets the SFCS switch counters to 0 and causes sfcsStatsEngineOperTime to also be reset to 0. other(1) reset(2)')
sfcsStatsEngineOperTime = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 2, 4, 1, 1, 5), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsStatsEngineOperTime.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsStatsEngineOperTime.setDescription('Indicates the amount of time (# of time ticks) that the SFCS switch statistics have been active for this switch module.')
sfcsPacketDiscardEngineTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 2, 5, 1), )
if mibBuilder.loadTexts: sfcsPacketDiscardEngineTable.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsPacketDiscardEngineTable.setDescription('This table contains information for the Packet Discard engine for a particular switch module.')
sfcsPacketDiscardEngineEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 2, 5, 1, 1), ).setIndexNames((0, "CTRON-SFCS-MIB", "sfcsPacketDiscardEngineSlotIndex"))
if mibBuilder.loadTexts: sfcsPacketDiscardEngineEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsPacketDiscardEngineEntry.setDescription('Each entry contains the packet discard engine data for the SFCS module.')
sfcsPacketDiscardEngineSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 2, 5, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsPacketDiscardEngineSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsPacketDiscardEngineSlotIndex.setDescription('The primary index to the SFCS packet discard engine table. This identifies the chassis slot number for this SFCS module.')
sfcsPacketDiscardEngineAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 2, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("other", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsPacketDiscardEngineAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsPacketDiscardEngineAdminStatus.setDescription('Sets the administrative state of the SFCS switch packet discard engine. Writing a value of enabled(1) causes these packet discard registers to become active for this SFCS switch instance. Writing a value of disabled(2) causes these packet discard registers to become inactive for this SFCS module. enabled(1) disabled(2) other(3)')
sfcsPacketDiscardEngineOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 2, 5, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("other", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsPacketDiscardEngineOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsPacketDiscardEngineOperStatus.setDescription('Indicates the operational state of the SFCS switch packet discard engine for this switch module. enabled(1) disabled(2) other(3)')
sfcsPacketDiscardEngineReset = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 2, 5, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsPacketDiscardEngineReset.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsPacketDiscardEngineReset.setDescription('Resets the SFCS switch registers for this SFCS module. Writing a value of reset(2) resets the SFCS switch packet discard registers to 0 and causes sfcsPacketDiscardEngineOperTime to also be reset to 0. other(1) reset(2)')
sfcsPacketDiscardEngineEPDPercentage = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 2, 5, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsPacketDiscardEngineEPDPercentage.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsPacketDiscardEngineEPDPercentage.setDescription('Sets the Early Packet Discard threshold percentage for every port, and every priority on a single blade.')
sfcsPacketDiscardEngineOperTime = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 2, 5, 1, 1, 6), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsPacketDiscardEngineOperTime.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsPacketDiscardEngineOperTime.setDescription('Indicates the amount of time (# of time ticks) that the SFCS switch packet discard engine has been active for this switch module.')
sfcsANIMConfigTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 3, 1, 1), )
if mibBuilder.loadTexts: sfcsANIMConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsANIMConfigTable.setDescription('This table contains the configuration information for each SFCS ANIM instance.')
sfcsANIMConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 3, 1, 1, 1), ).setIndexNames((0, "CTRON-SFCS-MIB", "sfcsANIMConfigANIMIndex"))
if mibBuilder.loadTexts: sfcsANIMConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsANIMConfigEntry.setDescription('Each entry contains the SFCS config info for the SFCS instance.')
sfcsANIMConfigANIMIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 3, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsANIMConfigANIMIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsANIMConfigANIMIndex.setDescription("This index specifies which ANIM we are dealing with. This reference is in the same format as MIB II's InterfaceIndex.")
sfcsANIMConfigAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 3, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("other", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsANIMConfigAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsANIMConfigAdminStatus.setDescription('Sets the administrative state of the SFCS switch ANIM. enabled(1) disabled(2) other(3)')
sfcsANIMConfigOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 3, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("other", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsANIMConfigOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsANIMConfigOperStatus.setDescription('Indicates the operational state of the SFCS switch ANIM for this SFCS ANIM instance. enabled(1) disabled(2) other(3)')
sfcsANIMConfigANIMType = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 3, 1, 1, 1, 4), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsANIMConfigANIMType.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsANIMConfigANIMType.setDescription('Indicates the type of physical interface for this ANIM. The types are described in ctron.oids')
sfcsANIMConfigNumInterfaces = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 3, 1, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsANIMConfigNumInterfaces.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsANIMConfigNumInterfaces.setDescription('Indicates the number of operational interfaces for this ANIM.')
sfcsANIMConfigLineRate = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 3, 1, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsANIMConfigLineRate.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsANIMConfigLineRate.setDescription('Indicates the line rate per port for this ANIM in Mbps.')
sfcsANIMConfigToMB = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 3, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("local-anim-clock", 1), ("port-one-clock", 2), ("port-two-clock", 3), ("port-three-clock", 4), ("port-four-clock", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsANIMConfigToMB.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsANIMConfigToMB.setDescription('This is the ANIM clock source to board.')
sfcsANIMConfigMBClockSelect = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 3, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("master-clk-one", 1), ("master-clk-two", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsANIMConfigMBClockSelect.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsANIMConfigMBClockSelect.setDescription('This indicates the ANIM clock source.')
sfcsANIMStatsTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 3, 2, 1), )
if mibBuilder.loadTexts: sfcsANIMStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsANIMStatsTable.setDescription('This table contains the statistics information for each SFCS ANIM instance.')
sfcsANIMStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 3, 2, 1, 1), ).setIndexNames((0, "CTRON-SFCS-MIB", "sfcsANIMStatsANIMIndex"))
if mibBuilder.loadTexts: sfcsANIMStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsANIMStatsEntry.setDescription('Each entry contains the SFCS statistics for the SFCS instance.')
sfcsANIMStatsANIMIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 3, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsANIMStatsANIMIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsANIMStatsANIMIndex.setDescription("The primary index which specifies which ANIM instance we are dealing with. This index is formatted like MIB II's Interface Index.")
sfcsANIMStatsRxCells = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 3, 2, 1, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsANIMStatsRxCells.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsANIMStatsRxCells.setDescription("Indicates the number of cells received from this ANIM's interfaces.")
sfcsANIMStatsTxCells = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 3, 2, 1, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsANIMStatsTxCells.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsANIMStatsTxCells.setDescription("Indicates the number of cells transmitted from this ANIM's interfaces.")
sfcsANIMPicTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 3, 3, 1), )
if mibBuilder.loadTexts: sfcsANIMPicTable.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsANIMPicTable.setDescription('This table contains the PIC information for each SFCS ANIM instance.')
sfcsANIMPicEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 3, 3, 1, 1), ).setIndexNames((0, "CTRON-SFCS-MIB", "sfcsANIMPicIndex"))
if mibBuilder.loadTexts: sfcsANIMPicEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsANIMPicEntry.setDescription('Each entry contains the SFCS PIC info for the SFCS instance.')
sfcsANIMPicSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 3, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsANIMPicSlot.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsANIMPicSlot.setDescription('Specific slot which the module that realizes this PIC resides. If the PIC is associated with the chassis and not a specific module then this value will be 0.')
sfcsANIMPicIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 3, 3, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsANIMPicIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsANIMPicIndex.setDescription('Uniquely identifies the instance of a PIC in a particular slot.')
sfcsANIMPicLocation = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 3, 3, 1, 1, 3), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsANIMPicLocation.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsANIMPicLocation.setDescription('Defines location of the PIC chip. This takes on any of the encoding values defined below for backplane, module, daughter board, brim.')
sfcsANIMPicStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 3, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("present", 2), ("notPresent", 3), ("checkSum", 4), ("error", 5), ("limited", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsANIMPicStatus.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsANIMPicStatus.setDescription('Provides the status of the specific PIC chip. the values are defined as follows: other(1) - firmware can not determine status present(2) - PIC seems to be functional notPresent(3) - PIC not found but expected checkSum(4) - A check sum error occured error(5) - An undefined error condition exists. limited(6) - A limited PIC implementation only type code information is present.')
sfcsANIMPicVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 3, 3, 1, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsANIMPicVersion.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsANIMPicVersion.setDescription('Reflects the version of the PIC implementation that this PIC conforms to. This has the format x.yy . If non-existent, this object will be set to all blanks(ascii 32).')
sfcsANIMPicModuleType = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 3, 3, 1, 1, 6), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsANIMPicModuleType.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsANIMPicModuleType.setDescription('Defines the standard module type value as defined in ctron-oids.')
sfcsANIMPicMfgPN = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 3, 3, 1, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(9, 9)).setFixedLength(9)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsANIMPicMfgPN.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsANIMPicMfgPN.setDescription('Describes the manufacturing level part number of the module associated with this PIC. This information is encoded as follows: 7 Characters Part Number 2 Characters Rework Location. If any field of this object is non-existent, it will be set to all blanks(ascii 32).')
sfcsANIMPicMfgSN = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 3, 3, 1, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(12, 12)).setFixedLength(12)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsANIMPicMfgSN.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsANIMPicMfgSN.setDescription('Describes the manufacturing level serial number of the module associated with this PIC. This information is encoded as follows: 3 bytes - Date code (year/week) 4 bytes - Serial number 2 bytes - Manufacture location 3 bytes - Board level revision If any field of this object is non-existent, it will be set to all blanks(ascii 32).')
sfcsANIMPicMfgPartNumb = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 3, 3, 1, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(7, 7)).setFixedLength(7)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsANIMPicMfgPartNumb.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsANIMPicMfgPartNumb.setDescription('This object presents the part number portion of the ctPicMfgPN object. This object contains the same information however in a more human readable format. If non-existent, this object will be set to all blanks(ascii 32).')
sfcsANIMPicMfgSerialNumb = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 3, 3, 1, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsANIMPicMfgSerialNumb.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsANIMPicMfgSerialNumb.setDescription('This object presents the serial number portion of the ctPicMfgSN object. This object contains the same information however in a more human readable format. If non-existent, this object will be set to all blanks(ascii 32).')
sfcsANIMPicMfgReworkLocation = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 3, 3, 1, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsANIMPicMfgReworkLocation.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsANIMPicMfgReworkLocation.setDescription('The 2 character code that defines the location this module was last reworked. This object contains the same information as presented in ctPicMfgPN object however in a more human readable format. If non-existent, this object will be set to all blanks(ascii 32).')
sfcsANIMPicMfgMfgLocation = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 3, 3, 1, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsANIMPicMfgMfgLocation.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsANIMPicMfgMfgLocation.setDescription('The two character code that defines the location this module was manufactured at. This object contains the same information as presented in ctPicMfgSN object however in a more human readable format. If non-existent, this object will be set to all blanks(ascii 32).')
sfcsANIMPicMfgDateCode = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 3, 3, 1, 1, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 3)).setFixedLength(3)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsANIMPicMfgDateCode.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsANIMPicMfgDateCode.setDescription('The 3 byte date code field when this module was last reworked. This is in year/week format. This object contains the same information as presented in ctPicMfgSN object however in a more human readable format. If non-existent, this object will be set to all blanks(ascii 32).')
sfcsANIMPicMfgRevisionCode = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 3, 3, 1, 1, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 3)).setFixedLength(3)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsANIMPicMfgRevisionCode.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsANIMPicMfgRevisionCode.setDescription('The 3 character board level revision code field of this module. This object contains the same information as presented in ctPicMfgSN object however in a more human readable format. If non-existent, this object will be set to all blanks (ascii 32).')
sfcsANIMPicTLPN = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 3, 3, 1, 1, 15), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(9, 9)).setFixedLength(9)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsANIMPicTLPN.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsANIMPicTLPN.setDescription('Describes the top level part number of the module associated with this PIC. This information is encoded as follows: 7 Characters Part Number 2 Characters Rework Location. If any field of this object is non-existent, it will be set to all blanks(ascii 32).')
sfcsANIMPicTLSN = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 3, 3, 1, 1, 16), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(12, 12)).setFixedLength(12)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsANIMPicTLSN.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsANIMPicTLSN.setDescription('Describes the top level serial number of the module associated with this PIC. This information is encoded as follows: 3 bytes - Date code (year/week) 4 bytes - Serial number 2 bytes - Manufacture location 3 bytes - Top level revision If any field of this object is non-existent, it will be set to all blanks(ascii 32).')
sfcsANIMPicTLPartNumb = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 3, 3, 1, 1, 17), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(7, 7)).setFixedLength(7)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsANIMPicTLPartNumb.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsANIMPicTLPartNumb.setDescription('This object presents the part number portion of the ctPicTLPN object. This object contains the same information however in a more human readable format. If non-existent, this object will be set to all blanks(ascii 32).')
sfcsANIMPicTLSerialNumb = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 3, 3, 1, 1, 18), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsANIMPicTLSerialNumb.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsANIMPicTLSerialNumb.setDescription('This object presents the serial number portion of the ctPicTLSN object. This object contains the same information however in a more human readable format. If non-existent, this object will be set to all blanks(ascii 32).')
sfcsANIMPicTLReworkLocation = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 3, 3, 1, 1, 19), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsANIMPicTLReworkLocation.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsANIMPicTLReworkLocation.setDescription('The 2 character code that defines the location this module was last reworked. This object contains the same information as presented in ctPicTLPN object however in a more human readable format. If non-existent, this object will be set to all blanks(ascii 32).')
sfcsANIMPicTLMfgLocation = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 3, 3, 1, 1, 20), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsANIMPicTLMfgLocation.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsANIMPicTLMfgLocation.setDescription('The two character code that defines the location this module was manufactured at. This object contains the same information as presented in ctPicTLSN object however in a more human readable format. If non-existent, this object will be set to all blanks(ascii 32).')
sfcsANIMPicTLDateCode = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 3, 3, 1, 1, 21), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 3)).setFixedLength(3)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsANIMPicTLDateCode.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsANIMPicTLDateCode.setDescription('The 3 byte date code field when this module was last reworked. This is in year/week format. This object contains the same information as presented in ctPicTLSN object however in a more human readable format. If non-existent, this object will be set to all blanks(ascii 32).')
sfcsANIMPicTLRevisionCode = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 3, 3, 1, 1, 22), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 3)).setFixedLength(3)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsANIMPicTLRevisionCode.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsANIMPicTLRevisionCode.setDescription('The 3 character top level revision code field of this module. This object contains the same information as presented in ctPicTLSN object however in a more human readable format. If non-existent, this object will be set to all blanks (ascii 32).')
sfcsANIMPicTLPcbRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 3, 3, 1, 1, 23), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsANIMPicTLPcbRevision.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsANIMPicTLPcbRevision.setDescription('Defines the Cabletron revision of the art work for this module. If non-existent, this object will be set to all blanks(ascii 32).')
sfcsANIMPicMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 3, 3, 1, 1, 24), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 6))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsANIMPicMacAddr.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsANIMPicMacAddr.setDescription('The base MAC address(ethernet format)assigned to the module. If this field is not used then it should have a value of a zero length string. If non-existent, this object will be set to all blanks(ascii 32).')
sfcsANIMPicNumbRsvdAddrs = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 3, 3, 1, 1, 25), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsANIMPicNumbRsvdAddrs.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsANIMPicNumbRsvdAddrs.setDescription('The number of reserved MAC addresses starting at the address as defined in ctPicMacAddr. If no MAC addresses are reserved this object should have a value of 0.')
sfcsANIMPicBoardLevelRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 3, 3, 1, 1, 26), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 3)).setFixedLength(3)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsANIMPicBoardLevelRevision.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsANIMPicBoardLevelRevision.setDescription('Defines the Cabletron board level revision level code for this module. If non-existent, this object will be set to blanks (ascii 32).')
sfcsANIMPicModuleTypeString = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 3, 3, 1, 1, 27), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsANIMPicModuleTypeString.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsANIMPicModuleTypeString.setDescription('Describes the module associated with this PIC in a human readable format. If non-existent, this object will be set to blanks (ascii 32).')
sfcsANIMPicDcDcConverterType = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 3, 3, 1, 1, 28), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(12, 12)).setFixedLength(12)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsANIMPicDcDcConverterType.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsANIMPicDcDcConverterType.setDescription('Describes the voltage of the installed DCDC Converter input and output lines. If the Module does not contain a DCDC Converter this object will be set to blanks (ascii 32).')
sfcsANIMPicDcDcConverterInputPower = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 3, 3, 1, 1, 29), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 3)).setFixedLength(3)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsANIMPicDcDcConverterInputPower.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsANIMPicDcDcConverterInputPower.setDescription('Describes the maximum allowed input power for the DCDC input line. If the Module does not contain a DCDC Converter this object will be set to blanks (ascii 32).')
sfcsANIMPicSmb1PromVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 3, 3, 1, 1, 30), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsANIMPicSmb1PromVersion.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsANIMPicSmb1PromVersion.setDescription('Describes the current version of the SMB1 prom. If the Module does not contain an SMB1 prom this object will be set to blanks (ascii 32).')
sfcsInterfaceConfigTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 4, 1, 1), )
if mibBuilder.loadTexts: sfcsInterfaceConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsInterfaceConfigTable.setDescription('This table contains the configuration information of each configured SFCS switch interface. If SFCS is not configured on a port, than an entry will not exist.')
sfcsInterfaceConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 4, 1, 1, 1), ).setIndexNames((0, "CTRON-SFCS-MIB", "sfcsInterfaceConfigInterfaceIndex"))
if mibBuilder.loadTexts: sfcsInterfaceConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsInterfaceConfigEntry.setDescription('Each entry specifies the SFCS configuration for the SFCS switch interface for which the entry exists.')
sfcsInterfaceConfigInterfaceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 4, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsInterfaceConfigInterfaceIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsInterfaceConfigInterfaceIndex.setDescription('The index which specifies which interface we are dealing with.')
sfcsInterfaceConfigType = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 4, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("access-port", 2), ("network-port", 3), ("host-mgmt-port", 4), ("host-ctl-port", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsInterfaceConfigType.setStatus('deprecated')
if mibBuilder.loadTexts: sfcsInterfaceConfigType.setDescription('Sets the type of interface access attribute for the SFCS interfaces. Access ports allow single user or shared access and perform statisics and control; network ports are equivalent to trunk ports with no access control; host management port indicates the (virtual) port to which the (internal) management agent is attached; host control port indicates the port to redirect non-management packets. other(1) access-port(2) network-port(3) host-mgmt-port(4) host-ctl-port(5)')
sfcsInterfacePeakBufferUseage = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 4, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsInterfacePeakBufferUseage.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsInterfacePeakBufferUseage.setDescription('An accumulated snap shot of the current peak queue depth for the configured buffer queues. This information is obtained from a read/reset register.')
sfcsInterfaceConfigNumberOfQueues = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 4, 1, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsInterfaceConfigNumberOfQueues.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsInterfaceConfigNumberOfQueues.setDescription('Indicates the number of priority queues configured on this interface.')
sfcsInterfaceConfigSigStackID = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 4, 1, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsInterfaceConfigSigStackID.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsInterfaceConfigSigStackID.setDescription('Indicates the user signalling stack ID for this interface.')
sfcsInterfaceConfigClockingSource = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 4, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("local-anim-clock", 1), ("mother-board-master-clock", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsInterfaceConfigClockingSource.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsInterfaceConfigClockingSource.setDescription('The interface clocking source.')
sfcsInterfaceStatsTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 4, 2, 1), )
if mibBuilder.loadTexts: sfcsInterfaceStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsInterfaceStatsTable.setDescription('This table contains the cell counts for each SFCS switch interface.')
sfcsInterfaceStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 4, 2, 1, 1), ).setIndexNames((0, "CTRON-SFCS-MIB", "sfcsInterfaceStatsInterfaceIndex"))
if mibBuilder.loadTexts: sfcsInterfaceStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsInterfaceStatsEntry.setDescription('Specifies the SFCS cell counts for the SFCS interface for which this entry exists.')
sfcsInterfaceStatsInterfaceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 4, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsInterfaceStatsInterfaceIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsInterfaceStatsInterfaceIndex.setDescription('The index which specifies which interface we are dealing with.')
sfcsInterfaceStatsRxErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 4, 2, 1, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsInterfaceStatsRxErrors.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsInterfaceStatsRxErrors.setDescription('Indicates the number of receive path lookup invalid and out of range errors.')
sfcsInterfaceStatsVPILookupInvalidErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 4, 2, 1, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsInterfaceStatsVPILookupInvalidErrors.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsInterfaceStatsVPILookupInvalidErrors.setDescription('Indicates the number of VPI lookup invalid and out of range errors.')
sfcsInterfaceStatsRxCnxLookupInvalidErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 4, 2, 1, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsInterfaceStatsRxCnxLookupInvalidErrors.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsInterfaceStatsRxCnxLookupInvalidErrors.setDescription('Indicates the number of receive connection lookup invalid errors.')
sfcsInterfaceStatsRxCellCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 4, 2, 1, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsInterfaceStatsRxCellCnt.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsInterfaceStatsRxCellCnt.setDescription('Indicates the number of receive cells on this interface.')
sfcsInterfaceStatsTxCellCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 4, 2, 1, 1, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsInterfaceStatsTxCellCnt.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsInterfaceStatsTxCellCnt.setDescription('Indicates the number of transmit cells on this interface.')
sfcsInterfaceStatsOverflowDropCellCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 4, 2, 1, 1, 7), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsInterfaceStatsOverflowDropCellCnt.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsInterfaceStatsOverflowDropCellCnt.setDescription('Indicates the number of cells that were dropped due to queue overflows.')
sfcsQueueConfigTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 5, 1, 1), )
if mibBuilder.loadTexts: sfcsQueueConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsQueueConfigTable.setDescription('This table contains the configuration information for all queues on the SFCS.')
sfcsQueueConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 5, 1, 1, 1), ).setIndexNames((0, "CTRON-SFCS-MIB", "sfcsQueueConfigInterfaceIndex"), (0, "CTRON-SFCS-MIB", "sfcsQueueConfigQueueIndex"))
if mibBuilder.loadTexts: sfcsQueueConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsQueueConfigEntry.setDescription('Each entry specifies the queue information for the SFCS switch for which the entry exists.')
sfcsQueueConfigInterfaceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 5, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsQueueConfigInterfaceIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsQueueConfigInterfaceIndex.setDescription('The index which specifies which interface we are dealing with.')
sfcsQueueConfigQueueIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 5, 1, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsQueueConfigQueueIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsQueueConfigQueueIndex.setDescription('The index which specifies which transmit queue we are dealing with.')
sfcsQueueConfigQueueSize = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 5, 1, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsQueueConfigQueueSize.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsQueueConfigQueueSize.setDescription('Indicates the size of the transmit queue for this queue instance.')
sfcsQueueConfigQueueBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 5, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsQueueConfigQueueBandwidth.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsQueueConfigQueueBandwidth.setDescription("Indicates the percentage of this interface's bandwidth utilized by this particular queue.")
sfcsQueueConfigClpDropThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 5, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsQueueConfigClpDropThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsQueueConfigClpDropThreshold.setDescription("Indicates the queue level to start dropping CLP=1 cells for this queue. This level is expressed as the percentage of this queue's size.")
sfcsQueueConfigCongestionThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 5, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsQueueConfigCongestionThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsQueueConfigCongestionThreshold.setDescription("Indicates the level to consider this queue congested. This level is expressed as the percentage of this queue's size.")
sfcsQueueConfigEFCILowThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 5, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsQueueConfigEFCILowThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsQueueConfigEFCILowThreshold.setDescription("Indicates the lower threshold used for EFCI for this queue instance. This level is expressed as the percentage of this queue's size.")
sfcsQueueConfigRMThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 5, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsQueueConfigRMThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsQueueConfigRMThreshold.setDescription("Indicates the remote management queue threshold expressed as a percentage of the queue's size. When this level is hit, a management message is sent to the sender notifying it to slow down.")
sfcsQueueConfigEPDThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 5, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsQueueConfigEPDThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsQueueConfigEPDThreshold.setDescription("Indicates the Early Packet Discard threshold expressed as a percentage of the queue's size. When this level is exceeded the Transmit ASIC starts to drop all cells entering this queue.")
sfcsQueueStatsTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 5, 2, 1), )
if mibBuilder.loadTexts: sfcsQueueStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsQueueStatsTable.setDescription('This table contains the statistics information for all queues on the SFCS.')
sfcsQueueStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 5, 2, 1, 1), ).setIndexNames((0, "CTRON-SFCS-MIB", "sfcsQueueStatsInterfaceIndex"), (0, "CTRON-SFCS-MIB", "sfcsQueueStatsQueue"))
if mibBuilder.loadTexts: sfcsQueueStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsQueueStatsEntry.setDescription('Each entry specifies the queue information for the SFCS switch for which the entry exists.')
sfcsQueueStatsInterfaceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 5, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsQueueStatsInterfaceIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsQueueStatsInterfaceIndex.setDescription('The index which specifies which interface we are dealing with.')
sfcsQueueStatsQueue = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 5, 2, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsQueueStatsQueue.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsQueueStatsQueue.setDescription('The index which specifies which queue we are dealing with.')
sfcsQueueStatsTxClpCellsDiscarded = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 5, 2, 1, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsQueueStatsTxClpCellsDiscarded.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsQueueStatsTxClpCellsDiscarded.setDescription('Indicates the number of cells with CLP=1 that were discarded for this queue instance.')
sfcsQueueStatsTxCellsDropped = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 5, 2, 1, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsQueueStatsTxCellsDropped.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsQueueStatsTxCellsDropped.setDescription('Indicates the number of cells that overflowed the buffer for this queue instance.')
sfcsQueueStatsQueuePeakLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 5, 2, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsQueueStatsQueuePeakLevel.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsQueueStatsQueuePeakLevel.setDescription('Indicates the peak level since last read for this queue instance.')
sfcsQueueStatsTxCellCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 5, 2, 1, 1, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsQueueStatsTxCellCnt.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsQueueStatsTxCellCnt.setDescription('Indicates the transmit cell count on a per queue basis. A value of zero indicates not available')
sfcsCnxCfgTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 7, 1, 1), )
if mibBuilder.loadTexts: sfcsCnxCfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsCnxCfgTable.setDescription('This table contains the connection configuration information.')
sfcsCnxCfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 7, 1, 1, 1), ).setIndexNames((0, "CTRON-SFCS-MIB", "sfcsCnxCfgCrossConnectIndex"), (0, "CTRON-SFCS-MIB", "sfcsCnxCfgCrossConnectLowIfIndex"), (0, "CTRON-SFCS-MIB", "sfcsCnxCfgCrossConnectLowVpi"), (0, "CTRON-SFCS-MIB", "sfcsCnxCfgCrossConnectLowVci"), (0, "CTRON-SFCS-MIB", "sfcsCnxCfgCrossConnectHighIfIndex"), (0, "CTRON-SFCS-MIB", "sfcsCnxCfgCrossConnectHighVpi"), (0, "CTRON-SFCS-MIB", "sfcsCnxCfgCrossConnectHighVci"))
if mibBuilder.loadTexts: sfcsCnxCfgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsCnxCfgEntry.setDescription('Each entry specifies the connection configuration information for the SFCS switch connection instance.')
sfcsCnxCfgCrossConnectIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 7, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsCnxCfgCrossConnectIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsCnxCfgCrossConnectIndex.setDescription('A unique value to identify this cross-connect.')
sfcsCnxCfgCrossConnectLowIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 7, 1, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsCnxCfgCrossConnectLowIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsCnxCfgCrossConnectLowIfIndex.setDescription('The value of this object is equal to the low MIB II IfIndex value of the ATM interface port for this cross-connect.')
sfcsCnxCfgCrossConnectLowVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 7, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsCnxCfgCrossConnectLowVpi.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsCnxCfgCrossConnectLowVpi.setDescription('The value of this object is equal to the low VPI value at the ATM interface associated with the cross-connect that is identified by sfcsCnxCfgCrossConnectIndex.')
sfcsCnxCfgCrossConnectLowVci = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 7, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsCnxCfgCrossConnectLowVci.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsCnxCfgCrossConnectLowVci.setDescription('The value of this object is equal to the low VCI value at the ATM interface associated with this cross-connect that is identified by sfcsCnxCfgCrossConnectIndex.')
sfcsCnxCfgCrossConnectHighIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 7, 1, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsCnxCfgCrossConnectHighIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsCnxCfgCrossConnectHighIfIndex.setDescription('The value of this object is equal to the high MIB II IfIndex value of the ATM interface port for this cross-connect.')
sfcsCnxCfgCrossConnectHighVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 7, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsCnxCfgCrossConnectHighVpi.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsCnxCfgCrossConnectHighVpi.setDescription('The value of this object is equal to the high VPI value at the ATM interface associated with the cross-connect that is identified by sfcsCnxCfgCrossConnectIndex.')
sfcsCnxCfgCrossConnectHighVci = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 7, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsCnxCfgCrossConnectHighVci.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsCnxCfgCrossConnectHighVci.setDescription('The value of this object is equal to the high VCI value at the ATM interface associated with this cross-connect that is identified by sfcsCnxCfgCrossConnectIndex.')
sfcsCnxCfgType = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 7, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("point-to-point-vpl", 1), ("point-to-mpoint-vpl", 2), ("mpoint-to-mpoint-vpl", 3), ("point-to-point-vcl", 4), ("point-to-mpoint-vcl", 5), ("mpoint-to-mpoint-vcl", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsCnxCfgType.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsCnxCfgType.setDescription('Indicates the connection type for this VC. point-to-point-vpl(1) point-to-mpoint-vpl(2) mpoint-to-mpoint-vpl(3) point-to-point-vcl(4) point-to-mpoint-vcl(5) mpoint-to-mpoint-vcl(6)')
sfcsCnxCfgTmType = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 7, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("efci", 2), ("er", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsCnxCfgTmType.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsCnxCfgTmType.setDescription('Indicates the type of traffic management used on this VC. other (1) efci (2) er (3)')
sfcsCnxCfgUPCEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 7, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))).clone(namedValues=NamedValues(("l-h-upc-enabled", 1), ("l-h-tag-enabled", 2), ("l-h-upc-tag-enabled", 3), ("h-l-upc-enabled", 4), ("l-h-upc-and-h-l-upc-enabled", 5), ("l-h-Tag-and-h-l-upc-enabled", 6), ("l-h-upc-tag-and-h-l-upc-enabled", 7), ("h-l-tag-enabled", 8), ("l-h-upc-and-h-l-tag-enabled", 9), ("l-h-tag-and-h-l-tag-enabled", 10), ("l-h-upc-tag-and-h-l-tag-enabled", 11), ("h-l-upc-tag-enabled", 12), ("l-h-upc-and-h-l-upc-tag-enabled", 13), ("l-h-tag-and-h-l-upc-tag-enabled", 14), ("l-h-upc-tag-and-h-l-upc-tag-enabled", 15)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsCnxCfgUPCEnable.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsCnxCfgUPCEnable.setDescription('Indicates whether or not UPC policing is enabled on this VC. A VC can be bi-directional or uni-directional. Due to this, the UPC bit is a masking based on directionality. Where direction is in terms of high interface (H) and low interface (L). (Where not specified, assume disabled.) L to H UPC enabled(1) L to H Tagging enabled(2) L to H UPC/Tagging enabled(3) H to L UPC enabled(4) L to H UPC enabled & H to L UPC enabled(5) L to H Tagging enabled & H to L UPC enabled(6) L to H UPC/Tagging enabled & H to L UPC enabled(7) H to L Tagging enabled(8) L to H UPC enabled & H to L Tagging enabled(9) L to H Tagging enabled & H to L Tagging enabled(10) L to H UPC/Tagging enabled & H to L Tagging enabled(11) H to L UPC/Tagging enabled(12) L to H UPC enabled & H to L UPC/Tagging enabled(13) L to H Tagging enabled and H to L UPC/Tagging enabled(14) L to H UPC/Tagging enabled & H to L UPC/Tagging enabled(15)')
sfcsCnxCfgStatsEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 7, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("other", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsCnxCfgStatsEnable.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsCnxCfgStatsEnable.setDescription('Indicates whether statistics will be kept on this VC. enabled(1) disabled(2) other(3)')
sfcsCnxCfgStatsTableCounterSizes = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 7, 1, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("thirtytwobittagcounter", 1), ("thirtytwobitdropcounter", 2), ("sixteenbiteachcounter", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsCnxCfgStatsTableCounterSizes.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsCnxCfgStatsTableCounterSizes.setDescription('Indicates the size of the drop counter for this VC. thirtytwobittagcounter (1) thirtytwobitdropcounter (2) sixteenbiteachcounter (3)')
sfcsCnxCfgOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 7, 1, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("own", 2), ("dontown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsCnxCfgOwner.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsCnxCfgOwner.setDescription('Indicates the owner of this cross connect. other(1) own(2) dontown(3)')
sfcsCnxStatsTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 7, 2, 1), )
if mibBuilder.loadTexts: sfcsCnxStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsCnxStatsTable.setDescription('This table contains the connection configuration information.')
sfcsCnxStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 7, 2, 1, 1), ).setIndexNames((0, "CTRON-SFCS-MIB", "sfcsCnxStatsCrossConnectIndex"), (0, "CTRON-SFCS-MIB", "sfcsCnxStatsCrossConnectLowIfIndex"), (0, "CTRON-SFCS-MIB", "sfcsCnxStatsCrossConnectLowVpi"), (0, "CTRON-SFCS-MIB", "sfcsCnxStatsCrossConnectLowVci"), (0, "CTRON-SFCS-MIB", "sfcsCnxStatsCrossConnectHighIfIndex"), (0, "CTRON-SFCS-MIB", "sfcsCnxStatsCrossConnectHighVpi"), (0, "CTRON-SFCS-MIB", "sfcsCnxStatsCrossConnectHighVci"))
if mibBuilder.loadTexts: sfcsCnxStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsCnxStatsEntry.setDescription('Each entry specifies the connection statistics information for the SFCS switch connection instance.')
sfcsCnxStatsCrossConnectIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 7, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsCnxStatsCrossConnectIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsCnxStatsCrossConnectIndex.setDescription('A unique value to identify this cross-connect.')
sfcsCnxStatsCrossConnectLowIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 7, 2, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsCnxStatsCrossConnectLowIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsCnxStatsCrossConnectLowIfIndex.setDescription('The value of this object is equal to the low MIB II IfIndex value of the ATM interface port for this cross-connect.')
sfcsCnxStatsCrossConnectLowVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 7, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsCnxStatsCrossConnectLowVpi.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsCnxStatsCrossConnectLowVpi.setDescription('The value of this object is equal to the low VPI value at the ATM interface associated with the cross-connect that is identified by sfcsCnxStatsCrossConnectIndex.')
sfcsCnxStatsCrossConnectLowVci = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 7, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsCnxStatsCrossConnectLowVci.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsCnxStatsCrossConnectLowVci.setDescription('The value of this object is equal to the low VCI value at the ATM interface associated with this cross-connect that is identified by sfcsCnxStatsCrossConnectIndex.')
sfcsCnxStatsCrossConnectHighIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 7, 2, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsCnxStatsCrossConnectHighIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsCnxStatsCrossConnectHighIfIndex.setDescription('The value of this object is equal to the high MIB II IfIndex value of the ATM interface port for this cross-connect.')
sfcsCnxStatsCrossConnectHighVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 7, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsCnxStatsCrossConnectHighVpi.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsCnxStatsCrossConnectHighVpi.setDescription('The value of this object is equal to the high VPI value at the ATM interface associated with the cross-connect that is identified by sfcsCnxStatsCrossConnectIndex.')
sfcsCnxStatsCrossConnectHighVci = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 7, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsCnxStatsCrossConnectHighVci.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsCnxStatsCrossConnectHighVci.setDescription('The value of this object is equal to the high VCI value at the ATM interface associated with this cross-connect that is identified by sfcsCnxStatsCrossConnectIndex.')
sfcsCnxStatsLoToHiHTxCells = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 7, 2, 1, 1, 8), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsCnxStatsLoToHiHTxCells.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsCnxStatsLoToHiHTxCells.setDescription('Indicates the transmitted cell count for this connection. This entry specifies the count from the low port/vpi/vci to the high port/vpi/vci')
sfcsCnxStatsLoToHiDroppedCells = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 7, 2, 1, 1, 9), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsCnxStatsLoToHiDroppedCells.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsCnxStatsLoToHiDroppedCells.setDescription('Indicates the dropped cell count for this connection instance. This entry specifies the count from the low port/vpi/vci to the high port/vpi/vci.')
sfcsCnxStatsLoToHiTaggedCells = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 7, 2, 1, 1, 10), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsCnxStatsLoToHiTaggedCells.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsCnxStatsLoToHiTaggedCells.setDescription('Indicates the tagged cell count for this connection instance. This entry specifies the count from the low port/vpi/vci to the high port/vpi/vci.')
sfcsCnxStatsHiToLoHTxCells = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 7, 2, 1, 1, 11), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsCnxStatsHiToLoHTxCells.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsCnxStatsHiToLoHTxCells.setDescription('Indicates the transmitted cell count for this connection. This entry specifies the count from the high port/vpi/vci to the low port/vpi/vci')
sfcsCnxStatsHiToLoDroppedCells = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 7, 2, 1, 1, 12), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsCnxStatsHiToLoDroppedCells.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsCnxStatsHiToLoDroppedCells.setDescription('Indicates the dropped cell count for this connection instance. This entry specifies the count from the high port/vpi/vci to the low port/vpi/vci.')
sfcsCnxStatsHiToLoTaggedCells = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 7, 2, 1, 1, 13), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsCnxStatsHiToLoTaggedCells.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsCnxStatsHiToLoTaggedCells.setDescription('Indicates the tagged cell count for this connection instance. This entry specifies the count from the high port/vpi/vci to the low port/vpi/vci.')
sfcsCnxErrorTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 7, 3, 1), )
if mibBuilder.loadTexts: sfcsCnxErrorTable.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsCnxErrorTable.setDescription('This table contains the connection error information supplied by the atmAPI mib.')
sfcsCnxErrorEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 7, 3, 1, 1), ).setIndexNames((0, "ATM-MIB", "atmVcCrossConnectIndex"), (0, "ATM-MIB", "atmVcCrossConnectLowIfIndex"), (0, "ATM-MIB", "atmVcCrossConnectLowVpi"), (0, "ATM-MIB", "atmVcCrossConnectLowVci"), (0, "ATM-MIB", "atmVcCrossConnectHighIfIndex"), (0, "ATM-MIB", "atmVcCrossConnectHighVpi"), (0, "ATM-MIB", "atmVcCrossConnectHighVci"))
if mibBuilder.loadTexts: sfcsCnxErrorEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsCnxErrorEntry.setDescription('A list of VCC connection request failures. This table is indexed the same way as the atmVcCrossConnectTable in the AToM mib.')
sfcsCnxErrorCode = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 7, 3, 1, 1, 1), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsCnxErrorCode.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsCnxErrorCode.setDescription('Specifies the error reason for failure of the connection setup. 01 fatal_error 02 moe_table_out_of_range 03 moe_mem_not_allocated 04 mem_fetch_double_reqst 05 lo_port_invalid 06 lo_port_locked 07 lo_vpi_invalid 08 lo_vci_invalid 09 hi_port_invalid 10 hi_port_locked 11 hi_vpi_invalid 12 hi_vci_invalid 13 trfc_desc_l2h_invalid 14 trfc_desc_h2l_invalid 15 ccid_invalid 16 ccid_not_assigned 17 atm_api_type_invalid 18 atm_api_verb_invalid 19 pt_to_pt_over_write_reqst 20 pt_reqst_over_mpt_conn 21 mask_table_full 22 duplicate_request 23 moe_table_out_of_memory 24 vpi0_non_term_reqst 25 hardware_out_of_heap 26 tx_conn_table_out_of_mem 27 tx_conn_table_time_out 28 ctm_communication_error 29 connection_table_out_of_sync 30 invalid_connection_entry 31 ctm_resource_alloc_error 32 front_panel_bandwidth_alloc_error 33 ccid_in_use')
sfcsCnxErrorTimeStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 7, 3, 1, 1, 2), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsCnxErrorTimeStamp.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsCnxErrorTimeStamp.setDescription('Indicates the value of the sysUpTime when this connection request failed. We will support this field only if the element management uses this table.')
sfcsCnxErrorRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 7, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("inactive", 2), ("active", 3), ("delete", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsCnxErrorRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsCnxErrorRowStatus.setDescription('The administrative control of this entry. The owner could delete this entry after reading it, to prevent this table from growing too big. other (1) inactive (2) active (3) delete (4)')
sfcsCnxAPIEntry = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 8, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsCnxAPIEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsCnxAPIEntry.setDescription(' The connection API leaf provides a method for contool for creating PVCs. This always returns a value of 0. ')
sfcsCTMInterfaceConfigTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 9, 1, 1), )
if mibBuilder.loadTexts: sfcsCTMInterfaceConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsCTMInterfaceConfigTable.setDescription('This table contains the configuration information of each configured SHEMP interface. If SFCS is not configured on a port, than an entry will not exist.')
sfcsCTMInterfaceConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 9, 1, 1, 1), ).setIndexNames((0, "CTRON-SFCS-MIB", "sfcsCTMInterfaceConfigInterfaceIndex"))
if mibBuilder.loadTexts: sfcsCTMInterfaceConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsCTMInterfaceConfigEntry.setDescription('Each entry specifies the SFCS configuration for the SFCS switch interface for which the entry exists.')
sfcsCTMInterfaceConfigInterfaceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 9, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsCTMInterfaceConfigInterfaceIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsCTMInterfaceConfigInterfaceIndex.setDescription('The index which specifies which interface we are dealing with.')
sfcsCTMInterfaceConfigType = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 9, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("access-port", 2), ("network-port", 3), ("host-mgmt-port", 4), ("host-ctl-port", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsCTMInterfaceConfigType.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsCTMInterfaceConfigType.setDescription('Sets the type of interface access attribute for the SFCS interfaces. Access ports allow single user or shared access and perform statisics and control; network ports are equivalent to trunk ports with no access control; host management port indicates the (virtual) port to which the (internal) management agent is attached; host control port indicates the port to redirect non-management packets. other(1), access-port(2), network-port(3), host-mgmt-port(4), host-ctl-port(5) ')
sfcsCTMInterfacePeakBufferUseage = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 9, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsCTMInterfacePeakBufferUseage.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsCTMInterfacePeakBufferUseage.setDescription('Indicates the number of cells in transmit buffer memory.')
sfcsCTMInterfaceConfigNumberOfQueues = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 9, 1, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsCTMInterfaceConfigNumberOfQueues.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsCTMInterfaceConfigNumberOfQueues.setDescription('Indicates the number of priority queues configured on this interface.')
sfcsCTMInterfaceConfigSigStackID = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 9, 1, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsCTMInterfaceConfigSigStackID.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsCTMInterfaceConfigSigStackID.setDescription('Indicates the user signalling stack ID for this interface.')
sfcsCTMInterfaceConfigClocking = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 9, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("generated-transmit-clock", 1), ("channel-recovered-clock", 2), ("system-master-clock", 3), ("not-supported", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsCTMInterfaceConfigClocking.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsCTMInterfaceConfigClocking.setDescription('The anim clocking source. one - use the generated-transmit-clock two - use the channel-recovered-clock three - use the system-master-clock four - option not supported by this interface')
sfcsCTMInterfaceConfigNextVPI = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 9, 1, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsCTMInterfaceConfigNextVPI.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsCTMInterfaceConfigNextVPI.setDescription('Indicates the next vpi for this interface.')
sfcsCTMInterfaceConfigNextVCI = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 9, 1, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsCTMInterfaceConfigNextVCI.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsCTMInterfaceConfigNextVCI.setDescription('Indicates the next vci for this interface.')
sfcsCTMInterfaceStatsTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 9, 2, 1), )
if mibBuilder.loadTexts: sfcsCTMInterfaceStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsCTMInterfaceStatsTable.setDescription('This table contains the cell counts for each SFCS switch interface.')
sfcsCTMInterfaceStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 9, 2, 1, 1), ).setIndexNames((0, "CTRON-SFCS-MIB", "sfcsCTMInterfaceStatsInterfaceIndex"))
if mibBuilder.loadTexts: sfcsCTMInterfaceStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsCTMInterfaceStatsEntry.setDescription('Specifies the SFCS cell counts for the SFCS interface for which this entry exists.')
sfcsCTMInterfaceStatsInterfaceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 9, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsCTMInterfaceStatsInterfaceIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsCTMInterfaceStatsInterfaceIndex.setDescription('The index which specifies which interface we are dealing with.')
sfcsCTMInterfaceStatsRxErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 9, 2, 1, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsCTMInterfaceStatsRxErrors.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsCTMInterfaceStatsRxErrors.setDescription('Indicates the number of receive path lookup invalid and out of range errors.')
sfcsCTMInterfaceStatsVPILookupInvalidErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 9, 2, 1, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsCTMInterfaceStatsVPILookupInvalidErrors.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsCTMInterfaceStatsVPILookupInvalidErrors.setDescription('Indicates the number of VPI lookup invalid and out of range errors.')
sfcsCTMInterfaceStatsRxCnxLookupInvalidErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 9, 2, 1, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsCTMInterfaceStatsRxCnxLookupInvalidErrors.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsCTMInterfaceStatsRxCnxLookupInvalidErrors.setDescription('Indicates the number of receive connection lookup invalid errors.')
sfcsCTMInterfaceStatsRxCellCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 9, 2, 1, 1, 7), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsCTMInterfaceStatsRxCellCnt.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsCTMInterfaceStatsRxCellCnt.setDescription('Indicates the number of receive cells on this interface.')
sfcsCTMInterfaceStatsTxCellCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 9, 2, 1, 1, 8), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsCTMInterfaceStatsTxCellCnt.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsCTMInterfaceStatsTxCellCnt.setDescription('Indicates the number of transmit cells on this interface.')
sfcsCTMInterfaceStatsOverflowDropCellCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 9, 2, 1, 1, 9), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsCTMInterfaceStatsOverflowDropCellCnt.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsCTMInterfaceStatsOverflowDropCellCnt.setDescription('Indicates the number of cells that were dropped due to queue overflows.')
sfcsCTMQueueConfigTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 9, 3, 1), )
if mibBuilder.loadTexts: sfcsCTMQueueConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsCTMQueueConfigTable.setDescription('This table contains the configuration information for all queues on the SFCS.')
sfcsCTMQueueConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 9, 3, 1, 1), ).setIndexNames((0, "CTRON-SFCS-MIB", "sfcsCTMQueueConfigInterfaceIndex"), (0, "CTRON-SFCS-MIB", "sfcsQueueConfigQueueIndex"))
if mibBuilder.loadTexts: sfcsCTMQueueConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsCTMQueueConfigEntry.setDescription('Each entry specifies the queue information for the SFCS switch for which the entry exists.')
sfcsCTMQueueConfigInterfaceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 9, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsCTMQueueConfigInterfaceIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsCTMQueueConfigInterfaceIndex.setDescription('The index which specifies which interface we are dealing with.')
sfcsCTMQueueConfigQueueIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 9, 3, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsCTMQueueConfigQueueIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsCTMQueueConfigQueueIndex.setDescription('The index which specifies which transmit queue we are dealing with.')
sfcsCTMQueueConfigQueueSize = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 9, 3, 1, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsCTMQueueConfigQueueSize.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsCTMQueueConfigQueueSize.setDescription('Indicates the size of the transmit queue for this queue instance.')
sfcsCTMQueueConfigQueueBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 9, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsCTMQueueConfigQueueBandwidth.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsCTMQueueConfigQueueBandwidth.setDescription("Indicates the percentage of this interface's bandwidth utilized by this particular queue.")
sfcsCTMQueueConfigClpDropThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 9, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsCTMQueueConfigClpDropThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsCTMQueueConfigClpDropThreshold.setDescription("Indicates the queue level to start dropping CLP=1 cells for this queue. This level is expressed as the percentage of this queue's size.")
sfcsCTMQueueConfigCongestionThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 9, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsCTMQueueConfigCongestionThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsCTMQueueConfigCongestionThreshold.setDescription("Indicates the level to consider this queue congested. This level is expressed as the percentage of this queue's size.")
sfcsCTMQueueConfigEFCILowThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 9, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsCTMQueueConfigEFCILowThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsCTMQueueConfigEFCILowThreshold.setDescription("Indicates the lower threshold used for EFCI for this queue instance. This level is expressed as the percentage of this queue's size.")
sfcsCTMQueueConfigRMThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 9, 3, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsCTMQueueConfigRMThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsCTMQueueConfigRMThreshold.setDescription("Indicates the remote management queue threshold expressed as a percentage of the queue's size. When this level is hit, a management message is sent to the sender notifying it to slow down.")
sfcsCTMQueueStatsTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 9, 4, 1), )
if mibBuilder.loadTexts: sfcsCTMQueueStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsCTMQueueStatsTable.setDescription('This table contains the statistics information for all queues on the SFCS.')
sfcsCTMQueueStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 9, 4, 1, 1), ).setIndexNames((0, "CTRON-SFCS-MIB", "sfcsCTMQueueStatsInterfaceIndex"), (0, "CTRON-SFCS-MIB", "sfcsQueueStatsQueue"))
if mibBuilder.loadTexts: sfcsCTMQueueStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsCTMQueueStatsEntry.setDescription('Each entry specifies the queue information for the SFCS switch for which the entry exists.')
sfcsCTMQueueStatsInterfaceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 9, 4, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsCTMQueueStatsInterfaceIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsCTMQueueStatsInterfaceIndex.setDescription('The index which specifies which interface we are dealing with.')
sfcsCTMQueueStatsQueue = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 9, 4, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsCTMQueueStatsQueue.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsCTMQueueStatsQueue.setDescription('The index which specifies which queue we are dealing with.')
sfcsCTMQueueStatsTxClpCellsDiscarded = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 9, 4, 1, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsCTMQueueStatsTxClpCellsDiscarded.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsCTMQueueStatsTxClpCellsDiscarded.setDescription('Indicates the number of cells with CLP=1 that were discarded for this queue instance.')
sfcsCTMQueueStatsTxCellsDropped = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 9, 4, 1, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsCTMQueueStatsTxCellsDropped.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsCTMQueueStatsTxCellsDropped.setDescription('Indicates the number of cells that overflowed the buffer for this queue instance.')
sfcsCTMQueueStatsQueuePeakLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 9, 4, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsCTMQueueStatsQueuePeakLevel.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsCTMQueueStatsQueuePeakLevel.setDescription('Indicates the peak level since last read for this queue instance.')
sfcsCTMQueueStatsTxCellCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 9, 4, 1, 1, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsCTMQueueStatsTxCellCnt.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsCTMQueueStatsTxCellCnt.setDescription('Indicates the transmit cell count on a per queue basis. A value of zero indicates not available')
sfcsBwNimsTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 1, 1), )
if mibBuilder.loadTexts: sfcsBwNimsTable.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwNimsTable.setDescription('This table contains the Nim Oid and the Nim Administrative Status reading functions.')
sfcsBwNimsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 1, 1, 1), ).setIndexNames((0, "CTRON-SFCS-MIB", "sfcsBwNimsIndex"))
if mibBuilder.loadTexts: sfcsBwNimsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwNimsEntry.setDescription('Each entry contains a Nim Oid and the Nim Administrative Status.')
sfcsBwNimsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsBwNimsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwNimsIndex.setDescription("This index specifies which NIM we are dealing with. This reference is in the same format as MIB II's Interface index.")
sfcsBwNimsAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 1, 1, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsBwNimsAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwNimsAdminStatus.setDescription('Indicates the administrative status of this Nim. 10 - Active 20 - Inactive ')
sfcsBWNimsBuffCount = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 1, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsBWNimsBuffCount.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBWNimsBuffCount.setDescription('The number of transmit buffers for this NIM')
sfcsBWNimsPortCount = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 1, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsBWNimsPortCount.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBWNimsPortCount.setDescription('The number of ports for this NIM')
sfcsBWNimsPrioCount = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 1, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsBWNimsPrioCount.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBWNimsPrioCount.setDescription('The number of priority queues for this NIM')
sfcsBwPortsTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 2, 1), )
if mibBuilder.loadTexts: sfcsBwPortsTable.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortsTable.setDescription('This table contains the Port Oid, Port Administrative Status and the forward/reverse physical bandwidth reading functions.')
sfcsBwPortsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 2, 1, 1), ).setIndexNames((0, "CTRON-SFCS-MIB", "sfcsBwPortsIndex"))
if mibBuilder.loadTexts: sfcsBwPortsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortsEntry.setDescription('Each entry contains the Port Oid, Port Administrative Status and the forward/reverse physical bandwidth.')
sfcsBwPortsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsBwPortsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortsIndex.setDescription("This index specifies which Port we are dealing with. This reference is in the same format as MIB II's Interface index.")
sfcsBwPortsAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 2, 1, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsBwPortsAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortsAdminStatus.setDescription('Indicates the administrative status of this Port. 10 - Active 20 - Inactive ')
sfcsBwPortsPhysBwFwd = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 2, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsBwPortsPhysBwFwd.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortsPhysBwFwd.setDescription('This is the forward physical bandwidth of the port in cells/sec.')
sfcsBwPortsPhysBwRev = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 2, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsBwPortsPhysBwRev.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortsPhysBwRev.setDescription('This is the reverse physical bandwidth of the port in cells/sec.')
sfcsBwPortsZone = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 2, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsBwPortsZone.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortsZone.setDescription('The range of the current bw operational point for this port. If a value has never been set the value will be -1.')
sfcsBwPortsMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 2, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsBwPortsMetric.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortsMetric.setDescription('The current bw operational point for this port. If a value has never been set the value will be -1.')
sfcsBwPortPoolLimitsTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 1), )
if mibBuilder.loadTexts: sfcsBwPortPoolLimitsTable.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolLimitsTable.setDescription('This table contains ')
sfcsBwPortPoolLimitsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 1, 1), ).setIndexNames((0, "CTRON-SFCS-MIB", "sfcsBwPortPoolLimitsIndex"), (0, "CTRON-SFCS-MIB", "sfcsBwPortPoolLimitsPoolIndex"))
if mibBuilder.loadTexts: sfcsBwPortPoolLimitsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolLimitsEntry.setDescription('Each entry contains ')
sfcsBwPortPoolLimitsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsBwPortPoolLimitsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolLimitsIndex.setDescription("This index specifies which Port we are dealing with. This reference is in the same format as MIB II's Interface index.")
sfcsBwPortPoolLimitsPoolIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsBwPortPoolLimitsPoolIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolLimitsPoolIndex.setDescription("This index specifies which Pool within Port we are dealing with. This reference is in the same format as MIB II's Interface index.")
sfcsBwPortPoolLimitsMaxAllocBwFwd = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 1, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsBwPortPoolLimitsMaxAllocBwFwd.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolLimitsMaxAllocBwFwd.setDescription(" Upper Limit for BW to be allocated forward direction. It is defaulted to the physical BW and is set by administrative action. Can't be set to a value greater than physical BW")
sfcsBwPortPoolLimitsMaxAllocBwRev = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 1, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsBwPortPoolLimitsMaxAllocBwRev.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolLimitsMaxAllocBwRev.setDescription(" Upper Limit for BW to be allocated reverse direction. It is defaulted to the physical BW and is set by administrative action. Can't be set to a value greater than physical BW")
sfcsBwPortPoolLimitsBwAllocStrat = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 1, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsBwPortPoolLimitsBwAllocStrat.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolLimitsBwAllocStrat.setDescription(' Determines which of 3 sets of formulas will be used for computing the amount of variable bandwidth to be allocated. Conservative allocates the full amount of variable bandwidth, Moderate allocates approximately half of the variable bandwidth, Liberal supports very aggressive allocation and should only be used with caution. Conservative is the default.')
sfcsBwPortPoolLimitsBwConstant = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 1, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsBwPortPoolLimitsBwConstant.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolLimitsBwConstant.setDescription(' A ratio used in formulas for computing the amount of variable bandwidth to be allocated. Valid values are 1-255 which is the numerator of a fraction whose fixed denominator is 256. Thus the value 255 is really 255/256 the most conservative value; the value 1 is really 1/256 the most liberal value; the value 128 is really 128/256 or 50%. The default is 50%.')
sfcsBwPortPoolLimitsCBRLimitFwd = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 1, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsBwPortPoolLimitsCBRLimitFwd.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolLimitsCBRLimitFwd.setDescription(' A ratio used in allocating the allocatable bandwidth among the various Service classes. This value is the amount of the overall allocatable bw that can be allocated to CBR. The values are 1-255. For a more detailed description of value useage see sfcsBwPortPoolLimitsBwConstant. Total of all service classes for a given direction should not exceed 256. (If it has never been set, the value will be -1.)')
sfcsBwPortPoolLimitsCBRLimitRev = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 1, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsBwPortPoolLimitsCBRLimitRev.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolLimitsCBRLimitRev.setDescription(' A ratio used in allocating the allocatable bandwidth among the various Service classes. This value is the amount of the overall allocatable bw that can be allocated to CBR. The values are 1-255. For a more detailed description of value useage see sfcsBwPortPoolLimitsBwConstant. Total of all service classes for a given direction should not exceed 256. (If it has never been set, the value will be -1.)')
sfcsBwPortPoolLimitsABRLimitFwd = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 1, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsBwPortPoolLimitsABRLimitFwd.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolLimitsABRLimitFwd.setDescription(' A ratio used in allocating the allocatable bandwidth among the various Service classes. This value is the amount of the overall allocatable bw that can be allocated to ABR. The values are 1-255. For a more detailed description of value useage see sfcsBwPortPoolLimitsBwConstant. Total of all service classes for a given direction should not exceed 256. (If it has never been set, the value will be -1.)')
sfcsBwPortPoolLimitsABRLimitRev = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 1, 1, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsBwPortPoolLimitsABRLimitRev.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolLimitsABRLimitRev.setDescription(' A ratio used in allocating the allocatable bandwidth among the various Service classes. This value is the amount of the overall allocatable bw that can be allocated to ABR. The values are 1-255. For a more detailed description of value useage see sfcsBwPortPoolLimitsBwConstant. Total of all service classes for a given direction should not exceed 256. (If it has never been set, the value will be -1.)')
sfcsBwPortPoolLimitsVBRLimitFwd = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 1, 1, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsBwPortPoolLimitsVBRLimitFwd.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolLimitsVBRLimitFwd.setDescription(' A ratio used in allocating the allocatable bandwidth among the various Service classes. This value is the amount of the overall allocatable bw that can be allocated to VBR. The values are 1-255. For a more detailed description of value useage see sfcsBwPortPoolLimitsBwConstant. Total of all service classes for a given direction should not exceed 256. (If it has never been set, the value will be -1.) WARNING - Setting this limit to an arbitrarily low value may cause the switch to become inoperable as an SVC switch. PNNI establishes VBR connections for switch to switch communications. If an arbitrarily low limit is established, it may preclude PNNI inter-switch operability.')
sfcsBwPortPoolLimitsVBRLimitRev = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 1, 1, 12), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsBwPortPoolLimitsVBRLimitRev.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolLimitsVBRLimitRev.setDescription(' A ratio used in allocating the allocatable bandwidth among the various Service classes. This value is the amount of the overall allocatable bw that can be allocated to VBR. The values are 1-255. For a more detailed description of value useage see sfcsBwPortPoolLimitsBwConstant. Total of all service classes for a given direction should not exceed 256. (If it has never been set, the value will be -1.) WARNING - Setting this limit to an arbitrarily low value may cause the switch to become inoperable as an SVC switch. PNNI establishes VBR connections for switch to switch communications. If an arbitrarily low limit is established, it may preclude PNNI inter-switch operability.')
sfcsBwPortPoolLimitsUBRLimitFwd = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 1, 1, 13), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsBwPortPoolLimitsUBRLimitFwd.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolLimitsUBRLimitFwd.setDescription(' A ratio used in allocating the allocatable bandwidth among the various Service classes. This value is the amount of the overall allocatable bw that can be allocated to UBR. The values are 1-255. For a more detailed description of value useage see sfcsBwPortPoolLimitsBwConstant. Total of all service classes for a given direction should not exceed 256. (If it has never been set, the value will be -1.) WARNING - Setting this limit to an arbitrarily low value may cause the switch to become inoperable as an SVC switch. Many internal management functions use UBR connections to establish connections with neighboring switches for keep alive and discovery functions. If an arbitrarily low limit is established, it may preclude SVC inter-switch operability.')
sfcsBwPortPoolLimitsUBRLimitRev = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 1, 1, 14), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsBwPortPoolLimitsUBRLimitRev.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolLimitsUBRLimitRev.setDescription(' A ratio used in allocating the allocatable bandwidth among the various Service classes. This value is the amount of the overall allocatable bw that can be allocated to UBR. The values are 1-255. For a more detailed description of value useage see sfcsBwPortPoolLimitsBwConstant. Total of all service classes for a given direction should not exceed 256. (If it has never been set, the value will be -1.) WARNING - Setting this limit to an arbitrarily low value may cause the switch to become inoperable as an SVC switch. Many internal management functions use UBR connections to establish connections with neighboring switches for keep alive and discovery functions. If an arbitrarily low limit is established, it may preclude SVC inter-switch operability.')
sfcsBwPortPoolLimitsUBRConnLimitFwd = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 1, 1, 15), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsBwPortPoolLimitsUBRConnLimitFwd.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolLimitsUBRConnLimitFwd.setDescription(' A Limit to the number of UBR connections which can be established through this port. The limit applies to both user connections and management connections. The default is no limit. (If it has never been set, the value will be -1.)')
sfcsBwPortPoolLimitsUBRConnLimitRev = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 1, 1, 16), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsBwPortPoolLimitsUBRConnLimitRev.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolLimitsUBRConnLimitRev.setDescription(' A Limit to the number of UBR connections which can be established through this port. The limit applies to both user connections and management connections. The default is no limit. (If it has never been set, the value will be -1.)')
sfcsBwPortPoolStatTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 2), )
if mibBuilder.loadTexts: sfcsBwPortPoolStatTable.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolStatTable.setDescription('This table contains ')
sfcsBwPortPoolStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 2, 1), ).setIndexNames((0, "CTRON-SFCS-MIB", "sfcsBwPortPoolStatsIndex"), (0, "CTRON-SFCS-MIB", "sfcsBwPortPoolStatsPoolIndex"))
if mibBuilder.loadTexts: sfcsBwPortPoolStatEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolStatEntry.setDescription('Each entry contains ')
sfcsBwPortPoolStatsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsBwPortPoolStatsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolStatsIndex.setDescription("This index specifies which Port we are dealing with. This reference is in the same format as MIB II's Interface index.")
sfcsBwPortPoolStatsPoolIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsBwPortPoolStatsPoolIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolStatsPoolIndex.setDescription("This index specifies which Pool within Port we are dealing with. This reference is in the same format as MIB II's Interface index.")
sfcsBwPortPoolStatConnCntFwd = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsBwPortPoolStatConnCntFwd.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolStatConnCntFwd.setDescription(' The current total number of calls in the forward direction.')
sfcsBwPortPoolStatConnCntRev = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsBwPortPoolStatConnCntRev.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolStatConnCntRev.setDescription(' The current total number of calls in the reverse direction.')
sfcsBwPortPoolStatAllocBwFwd = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsBwPortPoolStatAllocBwFwd.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolStatAllocBwFwd.setDescription(' The current amount of allocated Bw in the forward direction.')
sfcsBwPortPoolStatAllocBwRev = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsBwPortPoolStatAllocBwRev.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolStatAllocBwRev.setDescription(' The current amount of allocated Bw in the reverse direction.')
sfcsBwPortPoolStatAvailBwFwd = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsBwPortPoolStatAvailBwFwd.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolStatAvailBwFwd.setDescription(' The current amount of available Bw in the forward direction.')
sfcsBwPortPoolStatAvailBwRev = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 2, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsBwPortPoolStatAvailBwRev.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolStatAvailBwRev.setDescription(' The current amount of available Bw in the reverse direction.')
sfcsBwPortPoolStatPeakBwFwd = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 2, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsBwPortPoolStatPeakBwFwd.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolStatPeakBwFwd.setDescription(' The peak amount of allocated Bw in the forward direction since the port was initialized OR the switch was reset.')
sfcsBwPortPoolStatPeakBwRev = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 2, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsBwPortPoolStatPeakBwRev.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolStatPeakBwRev.setDescription(' The peak amount of allocated Bw in the reverse direction since the port was initialized OR the switch was reset.')
sfcsBwPortPoolStatRejConnFwd = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 2, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsBwPortPoolStatRejConnFwd.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolStatRejConnFwd.setDescription(' The number of connections which were rejected because of insufficient forward bandwidth since the port was initialized or the switch was reset last.')
sfcsBwPortPoolStatRejConnRev = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 2, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsBwPortPoolStatRejConnRev.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolStatRejConnRev.setDescription(' The number of connections which were rejected because of insufficient reverse bandwidth since the port was initialized or the switch was reset last.')
sfcsBwPortPoolStatPrevAdverMAXCRFwd = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 2, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsBwPortPoolStatPrevAdverMAXCRFwd.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolStatPrevAdverMAXCRFwd.setDescription(' The amount of physical forward BW reported to PNNI in the latest reporting period.')
sfcsBwPortPoolStatPrevAdverMAXCRRev = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 2, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsBwPortPoolStatPrevAdverMAXCRRev.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolStatPrevAdverMAXCRRev.setDescription(' The amount of physical reverse BW reported to PNNI in the latest reporting period.')
sfcsBwPortPoolStatPrevAdverAvailCRFwd = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 2, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsBwPortPoolStatPrevAdverAvailCRFwd.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolStatPrevAdverAvailCRFwd.setDescription(' The amount of avail forward BW reported to PNNI in the latest reporting period.')
sfcsBwPortPoolStatPrevAdverAvailCRRev = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 2, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsBwPortPoolStatPrevAdverAvailCRRev.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolStatPrevAdverAvailCRRev.setDescription(' The amount of avail reverse BW reported to PNNI in the latest reporting period.')
sfcsBwPortPoolStatCBRConnCntFwd = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 2, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsBwPortPoolStatCBRConnCntFwd.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolStatCBRConnCntFwd.setDescription(' The number of currently established CBR connections for the forward direction.')
sfcsBwPortPoolStatCBRConnCntRev = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 2, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsBwPortPoolStatCBRConnCntRev.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolStatCBRConnCntRev.setDescription(' The number of currently established CBR connections for the reverse direction.')
sfcsBwPortPoolStatCBRConnRejFwd = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 2, 1, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsBwPortPoolStatCBRConnRejFwd.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolStatCBRConnRejFwd.setDescription(' The number of CBR forward connections rejected since the port was initialized or the switch was reset last.')
sfcsBwPortPoolStatCBRConnRejRev = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 2, 1, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsBwPortPoolStatCBRConnRejRev.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolStatCBRConnRejRev.setDescription(' The number of CBR reverse connections rejected since the port was initialized or the switch was reset last.')
sfcsBwPortPoolStatCBRAllocBwFwd = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 2, 1, 21), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsBwPortPoolStatCBRAllocBwFwd.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolStatCBRAllocBwFwd.setDescription(' The amount of forward allocated Bw that is CBR service class.')
sfcsBwPortPoolStatCBRAllocBwRev = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 2, 1, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsBwPortPoolStatCBRAllocBwRev.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolStatCBRAllocBwRev.setDescription(' The amount of reverse allocated Bw that is CBR service class.')
sfcsBwPortPoolStatCBRAggPCRFwd = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 2, 1, 23), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsBwPortPoolStatCBRAggPCRFwd.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolStatCBRAggPCRFwd.setDescription(' The aggregated forward PCR for all established CBR connections.')
sfcsBwPortPoolStatCBRAggPCRRev = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 2, 1, 24), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsBwPortPoolStatCBRAggPCRRev.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolStatCBRAggPCRRev.setDescription(' The aggregated reverse PCR for all established CBR connections.')
sfcsBwPortPoolStatCBRPrevAdverMAXCTD = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 2, 1, 25), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsBwPortPoolStatCBRPrevAdverMAXCTD.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolStatCBRPrevAdverMAXCTD.setDescription(' The maxCTD for the forward direction reported to PNNI for the last update period for CBR service class.')
sfcsBwPortPoolStatCBRPrevAdverCDV = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 2, 1, 26), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsBwPortPoolStatCBRPrevAdverCDV.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolStatCBRPrevAdverCDV.setDescription(' The CDV for the forward direction reported to PNNI for the last update period for CBR service class.')
sfcsBwPortPoolStatABRConnCntFwd = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 2, 1, 27), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsBwPortPoolStatABRConnCntFwd.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolStatABRConnCntFwd.setDescription(' The number of currently established ABR connections for the forward direction.')
sfcsBwPortPoolStatABRConnCntRev = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 2, 1, 28), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsBwPortPoolStatABRConnCntRev.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolStatABRConnCntRev.setDescription(' The number of currently established ABR connections for the reverse direction.')
sfcsBwPortPoolStatABRConnRejFwd = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 2, 1, 29), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsBwPortPoolStatABRConnRejFwd.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolStatABRConnRejFwd.setDescription(' The number of ABR forward connections rejected since the port was initialized or the switch was reset last.')
sfcsBwPortPoolStatABRConnRejRev = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 2, 1, 30), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsBwPortPoolStatABRConnRejRev.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolStatABRConnRejRev.setDescription(' The number of ABR reverse connections rejected since the port was initialized or the switch was reset last.')
sfcsBwPortPoolStatABRAllocBwFwd = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 2, 1, 31), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsBwPortPoolStatABRAllocBwFwd.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolStatABRAllocBwFwd.setDescription(' The amount of forward allocated Bw that is ABR service class.')
sfcsBwPortPoolStatABRAllocBwRev = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 2, 1, 32), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsBwPortPoolStatABRAllocBwRev.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolStatABRAllocBwRev.setDescription(' The amount of reverse allocated Bw that is ABR service class.')
sfcsBwPortPoolStatABRAggPCRFwd = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 2, 1, 33), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsBwPortPoolStatABRAggPCRFwd.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolStatABRAggPCRFwd.setDescription(' The aggregated forward PCR for all established ABR connections.')
sfcsBwPortPoolStatABRAggPCRRev = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 2, 1, 34), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsBwPortPoolStatABRAggPCRRev.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolStatABRAggPCRRev.setDescription(' The aggregated reverse PCR for all established ABR connections.')
sfcsBwPortPoolStatABRPrevAdverMAXCTD = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 2, 1, 35), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsBwPortPoolStatABRPrevAdverMAXCTD.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolStatABRPrevAdverMAXCTD.setDescription(' The maxCTD for the forward direction reported to PNNI for the last update period for ABR service class.')
sfcsBwPortPoolStatABRPrevAdverCDV = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 2, 1, 36), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsBwPortPoolStatABRPrevAdverCDV.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolStatABRPrevAdverCDV.setDescription(' The CDV for the forward direction reported to PNNI for the last update period for ABR service class.')
sfcsBwPortPoolStatVBRConnCntFwd = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 2, 1, 37), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsBwPortPoolStatVBRConnCntFwd.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolStatVBRConnCntFwd.setDescription(' The number of currently established VBR connections for the forward direction.')
sfcsBwPortPoolStatVBRConnCntRev = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 2, 1, 38), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsBwPortPoolStatVBRConnCntRev.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolStatVBRConnCntRev.setDescription(' The number of currently established VBR connections for the reverse direction.')
sfcsBwPortPoolStatVBRConnRejFwd = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 2, 1, 39), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsBwPortPoolStatVBRConnRejFwd.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolStatVBRConnRejFwd.setDescription(' The number of VBR forward connections rejected since the port was initialized or the switch was reset last.')
sfcsBwPortPoolStatVBRConnRejRev = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 2, 1, 40), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsBwPortPoolStatVBRConnRejRev.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolStatVBRConnRejRev.setDescription(' The number of VBR reverse connections rejected since the port was initialized or the switch was reset last.')
sfcsBwPortPoolStatVBRAllocBwFwd = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 2, 1, 41), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsBwPortPoolStatVBRAllocBwFwd.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolStatVBRAllocBwFwd.setDescription(' The amount of forward allocated Bw that is VBR service class.')
sfcsBwPortPoolStatVBRAllocBwRev = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 2, 1, 42), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsBwPortPoolStatVBRAllocBwRev.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolStatVBRAllocBwRev.setDescription(' The amount of reverse allocated Bw that is VBR service class.')
sfcsBwPortPoolStatVBRAggPCRFwd = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 2, 1, 43), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsBwPortPoolStatVBRAggPCRFwd.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolStatVBRAggPCRFwd.setDescription(' The aggregated forward PCR for all established VBR connections.')
sfcsBwPortPoolStatVBRAggPCRRev = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 2, 1, 44), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsBwPortPoolStatVBRAggPCRRev.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolStatVBRAggPCRRev.setDescription(' The aggregated reverse PCR for all established VBR connections.')
sfcsBwPortPoolStatVBRPrevAdverMAXCTD = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 2, 1, 45), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsBwPortPoolStatVBRPrevAdverMAXCTD.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolStatVBRPrevAdverMAXCTD.setDescription(' The maxCTD for the forward direction reported to PNNI for the last update period for VBR service class.')
sfcsBwPortPoolStatVBRPrevAdverCDV = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 2, 1, 46), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsBwPortPoolStatVBRPrevAdverCDV.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolStatVBRPrevAdverCDV.setDescription(' The CDV for the forward direction reported to PNNI for the last update period for VBR service class.')
sfcsBwPortPoolStatUBRConnCntFwd = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 2, 1, 47), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsBwPortPoolStatUBRConnCntFwd.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolStatUBRConnCntFwd.setDescription(' The number of currently established UBR connections for the forward direction.')
sfcsBwPortPoolStatUBRConnCntRev = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 2, 1, 48), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsBwPortPoolStatUBRConnCntRev.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolStatUBRConnCntRev.setDescription(' The number of currently established UBR connections for the reverse direction.')
sfcsBwPortPoolStatUBRConnRejFwd = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 2, 1, 49), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsBwPortPoolStatUBRConnRejFwd.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolStatUBRConnRejFwd.setDescription(' The number of UBR forward connections rejected since the port was initialized or the switch was reset last.')
sfcsBwPortPoolStatUBRConnRejRev = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 2, 1, 50), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsBwPortPoolStatUBRConnRejRev.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolStatUBRConnRejRev.setDescription(' The number of UBR reverse connections rejected since the port was initialized or the switch was reset last.')
sfcsBwPortPoolStatUBRAllocBwFwd = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 2, 1, 51), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsBwPortPoolStatUBRAllocBwFwd.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolStatUBRAllocBwFwd.setDescription(' The amount of forward allocated Bw that is UBR service class.')
sfcsBwPortPoolStatUBRAllocBwRev = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 2, 1, 52), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsBwPortPoolStatUBRAllocBwRev.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolStatUBRAllocBwRev.setDescription(' The amount of reverse allocated Bw that is UBR service class.')
sfcsBwPortPoolStatUBRAggPCRFwd = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 2, 1, 53), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsBwPortPoolStatUBRAggPCRFwd.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolStatUBRAggPCRFwd.setDescription(' The aggregated forward PCR for all established UBR connections.')
sfcsBwPortPoolStatUBRAggPCRRev = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 2, 1, 54), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsBwPortPoolStatUBRAggPCRRev.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolStatUBRAggPCRRev.setDescription(' The aggregated reverse PCR for all established UBR connections.')
sfcsBwPortPoolStatUBRPrevAdverMAXCTD = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 2, 1, 55), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsBwPortPoolStatUBRPrevAdverMAXCTD.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolStatUBRPrevAdverMAXCTD.setDescription(' The maxCTD for the forward direction reported to PNNI for the last update period for UBR service class.')
sfcsBwPortPoolStatUBRPrevAdverCDV = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 2, 1, 56), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsBwPortPoolStatUBRPrevAdverCDV.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolStatUBRPrevAdverCDV.setDescription(' The CDV for the forward direction reported to PNNI for the last update period for UBR service class.')
sfcsBwPortPoolTrapMgmtTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 3), )
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtTable.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtTable.setDescription('This table contains ')
sfcsBwPortPoolTrapMgmtEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 3, 1), ).setIndexNames((0, "CTRON-SFCS-MIB", "sfcsBwPortPoolTrapMgmtIndex"), (0, "CTRON-SFCS-MIB", "sfcsBwPortPoolTrapMgmtPoolIndex"))
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtEntry.setDescription('Each entry contains ')
sfcsBwPortPoolTrapMgmtIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtIndex.setDescription("This index specifies which Port we are dealing with. This reference is in the same format as MIB II's Interface index.")
sfcsBwPortPoolTrapMgmtPoolIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtPoolIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtPoolIndex.setDescription("This index specifies which Pool within Port we are dealing with. This reference is in the same format as MIB II's Interface index. (If it has never been set, the value will be -1.)")
sfcsBwPortPoolTrapMgmtAllocBwTholdHiFwd = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 3, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtAllocBwTholdHiFwd.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtAllocBwTholdHiFwd.setDescription('The upper threshold for the Alloc BW fwd trap. When an allocation causes the currently allocated bw to exceed this value the trap is generated. (If it has never been set, the value will be -1.)')
sfcsBwPortPoolTrapMgmtAllocBwTholdHiRev = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 3, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtAllocBwTholdHiRev.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtAllocBwTholdHiRev.setDescription(' The upper threshold for the Alloc BW rev trap. When an allocation causes the currently allocated bw to exceed this value the trap is generated. (If it has never been set, the value will be -1.)')
sfcsBwPortPoolTrapMgmtAllocBwTholdLoFwd = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 3, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtAllocBwTholdLoFwd.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtAllocBwTholdLoFwd.setDescription(' The lower threshold for the Alloc BW fwd trap. When an allocation causes the currently allocated bw be below this value the trap is generated. (If it has never been set, the value will be -1.)')
sfcsBwPortPoolTrapMgmtAllocBwTholdLoRev = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 3, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtAllocBwTholdLoRev.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtAllocBwTholdLoRev.setDescription(' The lower threshold for the Alloc BW rev trap. When an allocation causes the currently allocated bw be below this value the trap is generated. (If it has never been set, the value will be -1.)')
sfcsBwPortPoolTrapMgmtPeakBwTholdFwd = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 3, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtPeakBwTholdFwd.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtPeakBwTholdFwd.setDescription('The upper threshold for the Peak BW fwd trap. When an allocation causes the allocated BW to exceed this value the trap is generated. (If it has never been set, the value will be -1.)')
sfcsBwPortPoolTrapMgmtPeakBwTholdRev = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 3, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtPeakBwTholdRev.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtPeakBwTholdRev.setDescription('The upper threshold for the Peak BW rev trap. When an allocation causes the allocated BW to exceed this value the trap is generated. (If it has never been set, the value will be -1.)')
sfcsBwPortPoolTrapMgmtHoldDownTime = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 3, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtHoldDownTime.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtHoldDownTime.setDescription(' The time between traps of the same type. If a trap of a particular type is generated for a particular port, another of that type for that port will not be generated until the hold down time has expired. (If it has never been set, the value will be -1.)')
sfcsBwPortPoolTrapMgmtCBRConnCntTholdHiFwd = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 3, 1, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtCBRConnCntTholdHiFwd.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtCBRConnCntTholdHiFwd.setDescription(' The upper threshold for the CBR connection count Fwd trap. When an allocation causes the CBR connection count to exceed this value, the trap is generated. (If it has never been set, the value will be -1.)')
sfcsBwPortPoolTrapMgmtCBRConnCntTholdHiRev = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 3, 1, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtCBRConnCntTholdHiRev.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtCBRConnCntTholdHiRev.setDescription(' The upper threshold for the CBR connection count Rev trap. When an allocation causes the CBR connection count to exceed this value, the trap is generated. (If it has never been set, the value will be -1.)')
sfcsBwPortPoolTrapMgmtCBRConnCntTholdLoFwd = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 3, 1, 12), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtCBRConnCntTholdLoFwd.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtCBRConnCntTholdLoFwd.setDescription(' The lower threshold for the CBR connection count Fwd trap. When an allocation causes the CBR connection count to fall below this value, the trap is generated. (If it has never been set, the value will be -1.)')
sfcsBwPortPoolTrapMgmtCBRConnCntTholdLoRev = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 3, 1, 13), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtCBRConnCntTholdLoRev.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtCBRConnCntTholdLoRev.setDescription(' The lower threshold for the CBR connection count Rev trap. When an allocation causes the CBR connection count to fall below this value, the trap is generated. (If it has never been set, the value will be -1.)')
sfcsBwPortPoolTrapMgmtCBRAllocBwTholdHiFwd = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 3, 1, 14), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtCBRAllocBwTholdHiFwd.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtCBRAllocBwTholdHiFwd.setDescription(' The upper threshold for the CBR Allocated Bw Fwd trap. When an allocation causes the CBR Allocated Bw to exceed this value, the trap is generated. (If it has never been set, the value will be -1.)')
sfcsBwPortPoolTrapMgmtCBRAllocBwTholdHiRev = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 3, 1, 15), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtCBRAllocBwTholdHiRev.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtCBRAllocBwTholdHiRev.setDescription(' The upper threshold for the CBR connection count Rev trap. When an allocation causes the CBR connection count to exceed this value, the trap is generated. (If it has never been set, the value will be -1.)')
sfcsBwPortPoolTrapMgmtCBRAllocBwTholdLoFwd = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 3, 1, 16), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtCBRAllocBwTholdLoFwd.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtCBRAllocBwTholdLoFwd.setDescription(' The lower threshold for the CBR Allocated Bw Fwd trap. When an allocation causes the CBR Allocated Bw to fall below this value, the trap is generated. (If it has never been set, the value will be -1.)')
sfcsBwPortPoolTrapMgmtCBRAllocBwTholdLoRev = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 3, 1, 17), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtCBRAllocBwTholdLoRev.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtCBRAllocBwTholdLoRev.setDescription(' The lower threshold for the CBR Allocated Bw Rev trap. When an allocation causes the CBR Allocated Bw to fall below this value, the trap is generated. (If it has never been set, the value will be -1.)')
sfcsBwPortPoolTrapMgmtABRConnCntTholdHiFwd = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 3, 1, 18), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtABRConnCntTholdHiFwd.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtABRConnCntTholdHiFwd.setDescription(' The upper threshold for the ABR connection count Fwd trap. When an allocation causes the ABR connection count to exceed this value, the trap is generated. (If it has never been set, the value will be -1.)')
sfcsBwPortPoolTrapMgmtABRConnCntTholdHiRev = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 3, 1, 19), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtABRConnCntTholdHiRev.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtABRConnCntTholdHiRev.setDescription(' The upper threshold for the ABR connection count Rev trap. When an allocation causes the ABR connection count to exceed this value, the trap is generated. (If it has never been set, the value will be -1.)')
sfcsBwPortPoolTrapMgmtABRConnCntTholdLoFwd = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 3, 1, 20), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtABRConnCntTholdLoFwd.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtABRConnCntTholdLoFwd.setDescription(' The lower threshold for the ABR connection count Fwd trap. When an allocation causes the ABR connection count to fall below this value, the trap is generated. (If it has never been set, the value will be -1.)')
sfcsBwPortPoolTrapMgmtABRConnCntTholdLoRev = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 3, 1, 21), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtABRConnCntTholdLoRev.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtABRConnCntTholdLoRev.setDescription(' The lower threshold for the ABR connection count Rev trap. When an allocation causes the ABR connection count to fall below this value, the trap is generated. (If it has never been set, the value will be -1.)')
sfcsBwPortPoolTrapMgmtABRAllocBwTholdHiFwd = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 3, 1, 22), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtABRAllocBwTholdHiFwd.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtABRAllocBwTholdHiFwd.setDescription(' The upper threshold for the ABR Allocated Bw Fwd trap. When an allocation causes the ABR Allocated Bw to exceed this value, the trap is generated. (If it has never been set, the value will be -1.)')
sfcsBwPortPoolTrapMgmtABRAllocBwTholdHiRev = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 3, 1, 23), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtABRAllocBwTholdHiRev.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtABRAllocBwTholdHiRev.setDescription(' The upper threshold for the ABR Allocated Bw Rev trap. When an allocation causes the ABR Allocated Bw to exceed this value, the trap is generated. (If it has never been set, the value will be -1.)')
sfcsBwPortPoolTrapMgmtABRAllocBwTholdLoFwd = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 3, 1, 24), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtABRAllocBwTholdLoFwd.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtABRAllocBwTholdLoFwd.setDescription(' The lower threshold for the ABR Allocated Bw Fwd trap. When an allocation causes the ABR Allocated Bw to fall below this value, the trap is generated. (If it has never been set, the value will be -1.)')
sfcsBwPortPoolTrapMgmtABRAllocBwTholdLoRev = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 3, 1, 25), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtABRAllocBwTholdLoRev.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtABRAllocBwTholdLoRev.setDescription(' The lower threshold for the ABR Allocated Bw Rev trap. When an allocation causes the ABR Allocated Bw to fall below this value, the trap is generated. (If it has never been set, the value will be -1.)')
sfcsBwPortPoolTrapMgmtVBRConnCntTholdHiFwd = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 3, 1, 26), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtVBRConnCntTholdHiFwd.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtVBRConnCntTholdHiFwd.setDescription(' The upper threshold for the VBR connection count Fwd trap. When an allocation causes the VBR connection count to exceed this value, the trap is generated. (If it has never been set, the value will be -1.)')
sfcsBwPortPoolTrapMgmtVBRConnCntTholdHiRev = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 3, 1, 27), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtVBRConnCntTholdHiRev.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtVBRConnCntTholdHiRev.setDescription(' The upper threshold for the VBR connection count Rev trap. When an allocation causes the VBR connection count to exceed this value, the trap is generated. (If it has never been set, the value will be -1.)')
sfcsBwPortPoolTrapMgmtVBRConnCntTholdLoFwd = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 3, 1, 28), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtVBRConnCntTholdLoFwd.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtVBRConnCntTholdLoFwd.setDescription(' The lower threshold for the VBR connection count Fwd trap. When an allocation causes the VBR connection count to fall below this value, the trap is generated. (If it has never been set, the value will be -1.)')
sfcsBwPortPoolTrapMgmtVBRConnCntTholdLoRev = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 3, 1, 29), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtVBRConnCntTholdLoRev.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtVBRConnCntTholdLoRev.setDescription(' The lower threshold for the VBR connection count Rev trap. When an allocation causes the VBR connection count to fall below this value, the trap is generated. (If it has never been set, the value will be -1.)')
sfcsBwPortPoolTrapMgmtVBRAllocBwTholdHiFwd = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 3, 1, 30), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtVBRAllocBwTholdHiFwd.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtVBRAllocBwTholdHiFwd.setDescription(' The upper threshold for the VBR Allocated Bw Fwd trap. When an allocation causes the VBR Allocated Bw to exceed this value, the trap is generated. (If it has never been set, the value will be -1.)')
sfcsBwPortPoolTrapMgmtVBRAllocBwTholdHiRev = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 3, 1, 31), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtVBRAllocBwTholdHiRev.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtVBRAllocBwTholdHiRev.setDescription(' The upper threshold for the VBR Allocated Bw Rev trap. When an allocation causes the VBR Allocated Bw to exceed this value, the trap is generated. (If it has never been set, the value will be -1.)')
sfcsBwPortPoolTrapMgmtVBRAllocBwTholdLoFwd = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 3, 1, 32), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtVBRAllocBwTholdLoFwd.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtVBRAllocBwTholdLoFwd.setDescription(' The lower threshold for the VBR Allocated Bw Fwd trap. When an allocation causes the VBR Allocated Bw to fall below this value, the trap is generated. (If it has never been set, the value will be -1.)')
sfcsBwPortPoolTrapMgmtVBRAllocBwTholdLoRev = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 3, 1, 33), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtVBRAllocBwTholdLoRev.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtVBRAllocBwTholdLoRev.setDescription(' The lower threshold for the VBR Allocated Bw Rev trap. When an allocation causes the VBR Allocated Bw to fall below this value, the trap is generated. (If it has never been set, the value will be -1.)')
sfcsBwPortPoolTrapMgmtUBRConnCntTholdHiFwd = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 3, 1, 34), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtUBRConnCntTholdHiFwd.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtUBRConnCntTholdHiFwd.setDescription(' The upper threshold for the UBR connection count Fwd trap. When an allocation causes the UBR connection count to exceed this value, the trap is generated. (If it has never been set, the value will be -1.)')
sfcsBwPortPoolTrapMgmtUBRConnCntTholdHiRev = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 3, 1, 35), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtUBRConnCntTholdHiRev.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtUBRConnCntTholdHiRev.setDescription(' The upper threshold for the UBR connection count Rev trap. When an allocation causes the UBR connection count to exceed this value, the trap is generated. (If it has never been set, the value will be -1.)')
sfcsBwPortPoolTrapMgmtUBRConnCntTholdLoFwd = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 3, 1, 36), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtUBRConnCntTholdLoFwd.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtUBRConnCntTholdLoFwd.setDescription(' The lower threshold for the UBR connection count Fwd trap. When an allocation causes the UBR connection count to fall below this value, the trap is generated. (If it has never been set, the value will be -1.)')
sfcsBwPortPoolTrapMgmtUBRConnCntTholdLoRev = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 3, 1, 37), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtUBRConnCntTholdLoRev.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtUBRConnCntTholdLoRev.setDescription(' The lower threshold for the UBR connection count Rev trap. When an allocation causes the UBR connection count to fall below this value, the trap is generated. (If it has never been set, the value will be -1.)')
sfcsBwPortPoolTrapMgmtUBRAllocBwTholdHiFwd = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 3, 1, 38), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtUBRAllocBwTholdHiFwd.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtUBRAllocBwTholdHiFwd.setDescription(' The upper threshold for the UBR Allocated Bw Fwd trap. When an allocation causes the UBR Allocated Bw to exceed this value, the trap is generated. (If it has never been set, the value will be -1.)')
sfcsBwPortPoolTrapMgmtUBRAllocBwTholdHiRev = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 3, 1, 39), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtUBRAllocBwTholdHiRev.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtUBRAllocBwTholdHiRev.setDescription(' The upper threshold for the UBR Allocated Bw Rev trap. When an allocation causes the UBR Allocated Bw to exceed this value, the trap is generated. (If it has never been set, the value will be -1.)')
sfcsBwPortPoolTrapMgmtUBRAllocBwTholdLoFwd = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 3, 1, 40), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtUBRAllocBwTholdLoFwd.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtUBRAllocBwTholdLoFwd.setDescription(' The lower threshold for the UBR Allocated Bw Fwd trap. When an allocation causes the UBR Allocated Bw to fall below this value, the trap is generated. (If it has never been set, the value will be -1.)')
sfcsBwPortPoolTrapMgmtUBRAllocBwTholdLoRev = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 3, 1, 41), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtUBRAllocBwTholdLoRev.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBwPortPoolTrapMgmtUBRAllocBwTholdLoRev.setDescription(' The lower threshold for the UBR Allocated Bw Rev trap. When an allocation causes the UBR Allocated Bw to fall below this value, the trap is generated. (If it has never been set, the value will be -1.)')
sfcsBWPortPoolTrapMgmtBuffUpThold = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 3, 1, 42), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsBWPortPoolTrapMgmtBuffUpThold.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBWPortPoolTrapMgmtBuffUpThold.setDescription(' The upper threshold for buffer allocation trap .')
sfcsBWPortPoolTrapMgmtBuffLoThold = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 3, 1, 43), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsBWPortPoolTrapMgmtBuffLoThold.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBWPortPoolTrapMgmtBuffLoThold.setDescription(' The lower threshold for buffer allocation trap .')
sfcsBWPortPoolTrapMgmtConnRejThold = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 3, 3, 1, 44), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsBWPortPoolTrapMgmtConnRejThold.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBWPortPoolTrapMgmtConnRejThold.setDescription(' The lower threshold for conn rejects trap .')
sfcsBuffPrioTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 4, 1), )
if mibBuilder.loadTexts: sfcsBuffPrioTable.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBuffPrioTable.setDescription('This table contains the rows of all the buffer pools.')
sfcsBuffPrioEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 4, 1, 1), ).setIndexNames((0, "CTRON-SFCS-MIB", "sfcsBuffPrioPortIndex"), (0, "CTRON-SFCS-MIB", "sfcsBuffPrioPriority"))
if mibBuilder.loadTexts: sfcsBuffPrioEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBuffPrioEntry.setDescription('Each entry contains the rows of all the buffer pools.')
sfcsBuffPrioPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 4, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsBuffPrioPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBuffPrioPortIndex.setDescription("This index specifies which port we are dealing with. This reference is in the same format as MIB II's Interface index.")
sfcsBuffPrioPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 4, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsBuffPrioPriority.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBuffPrioPriority.setDescription('This index specifies which priority we are dealing with.')
sfcsBuffPrioAssignCtl = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 4, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsBuffPrioAssignCtl.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBuffPrioAssignCtl.setDescription(' The status of how assignment is controlled. Static,Manual,Adaptive. ')
sfcsBuffPrioMinCtl = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 4, 1, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsBuffPrioMinCtl.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBuffPrioMinCtl.setDescription(' The minimum number of cells which can be assigned to this port/prioity.')
sfcsBuffPrioAssigned = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 4, 1, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsBuffPrioAssigned.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBuffPrioAssigned.setDescription(' The number of cells which are currently assigned to this port/priority.')
sfcsBuffPrioAllocated = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 4, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsBuffPrioAllocated.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBuffPrioAllocated.setDescription(' The number of assigned cells which are currently allocated to VCs for this port/priority.')
sfcsBuffPrioAvailable = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 4, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsBuffPrioAvailable.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBuffPrioAvailable.setDescription(' The number of assigned cells which are free to be allocated.')
sfcsBuffPrioPeakAlloc = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 4, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsBuffPrioPeakAlloc.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBuffPrioPeakAlloc.setDescription(' The peak number of cells which have been allocated to this port/priority.')
sfcsBuffPrioConnRejs = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 4, 1, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsBuffPrioConnRejs.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBuffPrioConnRejs.setDescription(' The number of connections rejected because of a lack of buffers.')
sfcsBuffPrioUpTholdTrap = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 4, 1, 1, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsBuffPrioUpTholdTrap.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBuffPrioUpTholdTrap.setDescription(' The upper threshold of allocations to trigger an upper thold trap.')
sfcsBuffPrioLoTholdTrap = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 4, 1, 1, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsBuffPrioLoTholdTrap.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBuffPrioLoTholdTrap.setDescription(' The lower threshold of allocations to trigger a lower thold trap.')
sfcsBuffPrioConnRejThold = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 12, 4, 1, 1, 12), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsBuffPrioConnRejThold.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsBuffPrioConnRejThold.setDescription(' The lower threshold of conn rejects trap because of inadequate buffers.')
sfcsProxyConfigTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 13, 1, 1), )
if mibBuilder.loadTexts: sfcsProxyConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsProxyConfigTable.setDescription('This table contains the config info and a port reading function.')
sfcsProxyConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 13, 1, 1, 1), ).setIndexNames((0, "CTRON-SFCS-MIB", "sfcsProxyConfigANIMIndex"))
if mibBuilder.loadTexts: sfcsProxyConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsProxyConfigEntry.setDescription('Each entry contains ANIM Proxy config info or a function.')
sfcsProxyConfigANIMIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 13, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsProxyConfigANIMIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsProxyConfigANIMIndex.setDescription("This index specifies which ANIM Proxy we are dealing with. This reference is in the same format as MIB II's Interface index.")
sfcsProxyConfigNUMPORTS = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 13, 1, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsProxyConfigNUMPORTS.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsProxyConfigNUMPORTS.setDescription('Indicates the number of ports per Proxy which is always 4.')
sfcsProxyConfigTxMemSize = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 13, 1, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsProxyConfigTxMemSize.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsProxyConfigTxMemSize.setDescription("Indicates the size of the port's Transmission memory in K. The memory size is always 1K.")
sfcsProxyConfigRxMaxPduSize = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 13, 1, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsProxyConfigRxMaxPduSize.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsProxyConfigRxMaxPduSize.setDescription("Indicates the size of the port's Transmission memory in K. The memory size is always 1K.")
sfcsProxyConfigBandWidth = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 13, 1, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsProxyConfigBandWidth.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsProxyConfigBandWidth.setDescription('Indicates the bandwidth for the port, which is ?????')
sfcsProxyConfigTransmitDone = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 13, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsProxyConfigTransmitDone.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsProxyConfigTransmitDone.setDescription('Checks if the Transmission has finished.')
sfcsProxyConfigReceiveFifoState = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 13, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("full", 1), ("not-full", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsProxyConfigReceiveFifoState.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsProxyConfigReceiveFifoState.setDescription("Checks if the port's receive Fifo is full or not.")
sfcsProxyConfigPortTransmitMode = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 13, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("stop", 1), ("start-stay", 2), ("reread", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsProxyConfigPortTransmitMode.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsProxyConfigPortTransmitMode.setDescription('Controls Transmission of cells in port Transmit memory.')
sfcsProxyConfigReceiveFifoReset = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 13, 1, 1, 1, 9), Integer32()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: sfcsProxyConfigReceiveFifoReset.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsProxyConfigReceiveFifoReset.setDescription("Controls the receive buffer's memory. Reset clears memory.")
sfcsProxyConfigTxFifoReset = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 13, 1, 1, 1, 10), Integer32()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: sfcsProxyConfigTxFifoReset.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsProxyConfigTxFifoReset.setDescription("Controls the port's transmit memory. Reset clears memory.")
sfcsProxyConfigReceiveMode = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 13, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("receiving", 1), ("not-receiving", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsProxyConfigReceiveMode.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsProxyConfigReceiveMode.setDescription('Controls whether or not the port receives cells.')
sfcsProxyConfigCaptureMode = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 13, 1, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("all", 1), ("header", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsProxyConfigCaptureMode.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsProxyConfigCaptureMode.setDescription('Controls how much of the cell is received.')
sfcsProxyConfigInitPort = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 13, 1, 1, 1, 13), Integer32()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: sfcsProxyConfigInitPort.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsProxyConfigInitPort.setDescription('Setting this returns the port to the initial setup.')
sfcsProxyConfigLoad = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 13, 1, 1, 1, 14), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsProxyConfigLoad.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsProxyConfigLoad.setDescription('Transmit load for port.')
sfcsProxyConfigGumbo = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 13, 1, 1, 1, 15), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsProxyConfigGumbo.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsProxyConfigGumbo.setDescription('Unreadable octet string used for control information.')
sfcsProxyTransTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 13, 2, 1), )
if mibBuilder.loadTexts: sfcsProxyTransTable.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsProxyTransTable.setDescription('This table contains the arguments and the function for the Transmit function.')
sfcsProxyTransEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 13, 2, 1, 1), ).setIndexNames((0, "CTRON-SFCS-MIB", "sfcsProxyTransANIMIndex"))
if mibBuilder.loadTexts: sfcsProxyTransEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsProxyTransEntry.setDescription('The entries are the arguments for the Transmit function.')
sfcsProxyTransANIMIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 13, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsProxyTransANIMIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsProxyTransANIMIndex.setDescription("This index specifies which ANIM Port we are dealing with. This reference is in the same format as MIB II's Interface Index.")
sfcsProxyTransEncodeNewPdu = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 13, 2, 1, 1, 2), Integer32()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: sfcsProxyTransEncodeNewPdu.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsProxyTransEncodeNewPdu.setDescription("Setting this encodes a new PDU based on the current PDU parameters into the port's transmit memory.")
sfcsProxyTransVPI = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 13, 2, 1, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsProxyTransVPI.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsProxyTransVPI.setDescription('This is the VPI for the PDU.')
sfcsProxyTransVCI = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 13, 2, 1, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsProxyTransVCI.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsProxyTransVCI.setDescription('This is the VCI for the PDU.')
sfcsProxyTransPTI = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 13, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsProxyTransPTI.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsProxyTransPTI.setDescription('Payload Type Indicator: the value of the 3 bit Payload Type field in the header. The most signifigant bit indicates user or control data, the next bit indicates congestion, and the last bit indicates AAL encoding.')
sfcsProxyTransCLP = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 13, 2, 1, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsProxyTransCLP.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsProxyTransCLP.setDescription('The cell loss priority: 1 or 0.')
sfcsProxyTransPayloadType = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 13, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("user-input", 1), ("sequential", 2), ("uniform", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsProxyTransPayloadType.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsProxyTransPayloadType.setDescription('The payload type for the cell.')
sfcsProxyTransPayloadLength = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 13, 2, 1, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsProxyTransPayloadLength.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsProxyTransPayloadLength.setDescription('The length of the payload in bytes.')
sfcsProxyTransPayloadData = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 13, 2, 1, 1, 9), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsProxyTransPayloadData.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsProxyTransPayloadData.setDescription('If the payload type is user input, this is the payload itself.')
sfcsProxyTransCount = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 13, 2, 1, 1, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsProxyTransCount.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsProxyTransCount.setDescription('Number of copies of the pdu to encode in port transmit memory.')
sfcsProxyTransPayloadAdaptionLayer = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 13, 2, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("raw", 1), ("aal5", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsProxyTransPayloadAdaptionLayer.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsProxyTransPayloadAdaptionLayer.setDescription('The format of the payload: either raw cells or AAL5.')
sfcsProxyTransMpxMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 13, 2, 1, 1, 12), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsProxyTransMpxMethod.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsProxyTransMpxMethod.setDescription('The format of the payload: either raw cells or AAL5.')
sfcsProxyTransControl = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 13, 2, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("send-once", 1), ("repeat", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsProxyTransControl.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsProxyTransControl.setDescription("Controls how many times to send what's in the port's transmit memory.")
sfcsProxyTransGumbo = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 13, 2, 1, 1, 14), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsProxyTransGumbo.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsProxyTransGumbo.setDescription('Returns the vpi, vci, pti, clp, payload_type, payload_length, count, PAL, mpx method, and control entires for this table in a string where the entries are separated by semicolons.')
sfcsProxyReadTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 13, 3, 1), )
if mibBuilder.loadTexts: sfcsProxyReadTable.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsProxyReadTable.setDescription('This table contains information read from the cells in the receive fifo.')
sfcsProxyReadEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 13, 3, 1, 1), ).setIndexNames((0, "CTRON-SFCS-MIB", "sfcsProxyReadANIMIndex"))
if mibBuilder.loadTexts: sfcsProxyReadEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsProxyReadEntry.setDescription('The entries are the information about the cells or the PDU.')
sfcsProxyReadANIMIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 13, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsProxyReadANIMIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsProxyReadANIMIndex.setDescription('This index specifies which ANIM Port we are dealing with. This reference is in the same format as the MIB II Interface Index.')
sfcsProxyReadMode = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 13, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("reassemble-PDU", 1), ("cell-by-cell", 2), ("all-data", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfcsProxyReadMode.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsProxyReadMode.setDescription('How the receive fifo is read.')
sfcsProxyReadNewPdu = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 13, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("get-next-pdu", 1), ("reread-from-beginning", 2)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: sfcsProxyReadNewPdu.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsProxyReadNewPdu.setDescription('Pops a new Pdu from the receive fifo to be examined and read.')
sfcsProxyReadGumbo = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 13, 3, 1, 1, 4), OctetString()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: sfcsProxyReadGumbo.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsProxyReadGumbo.setDescription('Unreadable control information.')
sfcsProxyReadVPI = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 13, 3, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsProxyReadVPI.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsProxyReadVPI.setDescription('This is the VPI for the PDU.')
sfcsProxyReadVCI = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 13, 3, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsProxyReadVCI.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsProxyReadVCI.setDescription('This is the VCI for the PDU.')
sfcsProxyReadPTI = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 13, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsProxyReadPTI.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsProxyReadPTI.setDescription('Payload Type Indicator: the value of the 3 bit Payload Type field in the header. The most signifigant bit indicates user or control data, the next bit indicates congestion, and the last bit indicates AAL encoding.')
sfcsProxyReadCLP = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 13, 3, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsProxyReadCLP.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsProxyReadCLP.setDescription('The cell loss priority: 1 or 0.')
sfcsProxyReadDataLength = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 13, 3, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsProxyReadDataLength.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsProxyReadDataLength.setDescription('The length of the PDU in bytes.')
sfcsProxyReadData = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 13, 3, 1, 1, 10), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsProxyReadData.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsProxyReadData.setDescription('The actual data of the PDU.')
sfcsProxyReadPal = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 13, 3, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("raw", 1), ("aal5", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsProxyReadPal.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsProxyReadPal.setDescription('The format of the payload: either raw cells or AAL5.')
sfcsProxyReadInbyteslosts = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 13, 3, 1, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsProxyReadInbyteslosts.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsProxyReadInbyteslosts.setDescription('The number of bytes that were dropped while reading. Usually because they occurred before the Start of Cell was discovered.')
sfcsProxyReadInCells = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 13, 3, 1, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsProxyReadInCells.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsProxyReadInCells.setDescription('The number of cells read since this port was last reset.')
sfcsProxyReadInError = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 13, 3, 1, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsProxyReadInError.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsProxyReadInError.setDescription("The number of pdu's that had to be dropped due to errors.")
sfcsProxyReadInCellReadError = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 13, 3, 1, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsProxyReadInCellReadError.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsProxyReadInCellReadError.setDescription('The number of cells that had to be dropped due to errors.')
sfcsProxyReadInHecError = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 13, 3, 1, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsProxyReadInHecError.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsProxyReadInHecError.setDescription('The number of cell headers that contained errors.')
sfcsProxyReadInTooBigError = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 13, 3, 1, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsProxyReadInTooBigError.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsProxyReadInTooBigError.setDescription("The number of pdu's that were too large to be received.")
sfcsProxyReadInCRCError = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 13, 3, 1, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsProxyReadInCRCError.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsProxyReadInCRCError.setDescription("The number of pdu's that failed the CRC check.")
sfcsProxyReadInLengthMismatchError = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 13, 3, 1, 1, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsProxyReadInLengthMismatchError.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsProxyReadInLengthMismatchError.setDescription('The length stored in the pdu did not match the actual length of the pdu read in.')
sfcsProxyReadInTotalCells = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 11, 1, 1, 13, 3, 1, 1, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfcsProxyReadInTotalCells.setStatus('mandatory')
if mibBuilder.loadTexts: sfcsProxyReadInTotalCells.setDescription('Total number of cells read in by the snapshot.')
mibBuilder.exportSymbols("CTRON-SFCS-MIB", sfcsCnxErrorEntry=sfcsCnxErrorEntry, sfcsBwPortPoolTrapMgmtABRAllocBwTholdLoFwd=sfcsBwPortPoolTrapMgmtABRAllocBwTholdLoFwd, sfcsCTMQueueStatsTxCellsDropped=sfcsCTMQueueStatsTxCellsDropped, sfcsBuffPrioMinCtl=sfcsBuffPrioMinCtl, sfcsANIMPicMfgPN=sfcsANIMPicMfgPN, sfcsQueueStatsTxCellsDropped=sfcsQueueStatsTxCellsDropped, sfcsConfigSwitchHostPort=sfcsConfigSwitchHostPort, sfcsConfigMasterClock1Standby=sfcsConfigMasterClock1Standby, sfcsInterfaceConfigNumberOfQueues=sfcsInterfaceConfigNumberOfQueues, sfcsANIMConfigToMB=sfcsANIMConfigToMB, ctron=ctron, sfcsCnxCfgType=sfcsCnxCfgType, ctDataLink=ctDataLink, sfcsQueueConfigRMThreshold=sfcsQueueConfigRMThreshold, sfcsANIMStatsRxCells=sfcsANIMStatsRxCells, sfcsProxyTransEntry=sfcsProxyTransEntry, sfcsInterfaceStatsTxCellCnt=sfcsInterfaceStatsTxCellCnt, sfcsConnectionConfig=sfcsConnectionConfig, sfcsCnxAPIEntry=sfcsCnxAPIEntry, sfcsCTMQueueConfigCongestionThreshold=sfcsCTMQueueConfigCongestionThreshold, sfcsBwPortPoolLimitsABRLimitFwd=sfcsBwPortPoolLimitsABRLimitFwd, sfcsInterfaceConfigSigStackID=sfcsInterfaceConfigSigStackID, sfcsInterfaceStatsRxErrors=sfcsInterfaceStatsRxErrors, sfcsCTMQueueStatsInterfaceIndex=sfcsCTMQueueStatsInterfaceIndex, sfcsBwPortPoolStatABRAggPCRFwd=sfcsBwPortPoolStatABRAggPCRFwd, sfcsConfigHostCtrlATMAddr=sfcsConfigHostCtrlATMAddr, sfcsCTMQueueConfigQueueSize=sfcsCTMQueueConfigQueueSize, sfcsProxyConfigEntry=sfcsProxyConfigEntry, sfcsBwPortPoolLimitsIndex=sfcsBwPortPoolLimitsIndex, sfcsSysStatusCurrUPCEntries=sfcsSysStatusCurrUPCEntries, sfcsANIMPicTLPcbRevision=sfcsANIMPicTLPcbRevision, sfcsBwPortPoolStatCBRPrevAdverCDV=sfcsBwPortPoolStatCBRPrevAdverCDV, sfcsPacketDiscardEngineTable=sfcsPacketDiscardEngineTable, sfcsCnxStatsCrossConnectLowVpi=sfcsCnxStatsCrossConnectLowVpi, sfcsCnxStatsHiToLoDroppedCells=sfcsCnxStatsHiToLoDroppedCells, sfcsBwPortPoolStatABRConnRejFwd=sfcsBwPortPoolStatABRConnRejFwd, sfcsProxyReadPal=sfcsProxyReadPal, sfcsInterfaceStatsVPILookupInvalidErrors=sfcsInterfaceStatsVPILookupInvalidErrors, sfcsBwPortPoolTrapMgmtCBRAllocBwTholdHiRev=sfcsBwPortPoolTrapMgmtCBRAllocBwTholdHiRev, sfcsBWPortPoolTrapMgmtConnRejThold=sfcsBWPortPoolTrapMgmtConnRejThold, ctsfSwitch=ctsfSwitch, sfcsCnxStatsCrossConnectLowVci=sfcsCnxStatsCrossConnectLowVci, sfcsCTMQueueConfigTable=sfcsCTMQueueConfigTable, sfcsBwPortPoolTrapMgmtABRAllocBwTholdLoRev=sfcsBwPortPoolTrapMgmtABRAllocBwTholdLoRev, sfcsBwPortPoolStatCBRConnCntFwd=sfcsBwPortPoolStatCBRConnCntFwd, sfcsConnectionAPI=sfcsConnectionAPI, sfcsANIMStatsEntry=sfcsANIMStatsEntry, sfcsBwPortPoolStatUBRPrevAdverMAXCTD=sfcsBwPortPoolStatUBRPrevAdverMAXCTD, sfcsProxyReadMode=sfcsProxyReadMode, sfcsCTMInterfacePeakBufferUseage=sfcsCTMInterfacePeakBufferUseage, sfcsProxyTransVCI=sfcsProxyTransVCI, ctSFCS=ctSFCS, sfcsCnxCfgCrossConnectHighVpi=sfcsCnxCfgCrossConnectHighVpi, sfcsProxyTransPTI=sfcsProxyTransPTI, sfcsBwPortPoolStatPeakBwRev=sfcsBwPortPoolStatPeakBwRev, sfcsCTMInterfaceStatsInterfaceIndex=sfcsCTMInterfaceStatsInterfaceIndex, sfcsQueueConfigQueueIndex=sfcsQueueConfigQueueIndex, sfcsBwPortPoolTrapMgmtVBRAllocBwTholdLoFwd=sfcsBwPortPoolTrapMgmtVBRAllocBwTholdLoFwd, sfcsBwPortPoolTrapMgmtVBRAllocBwTholdLoRev=sfcsBwPortPoolTrapMgmtVBRAllocBwTholdLoRev, sfcsSysConfigPnniAddessingAdmnStatus=sfcsSysConfigPnniAddessingAdmnStatus, sfcsBWNimsBuffCount=sfcsBWNimsBuffCount, sfcsCnxCfgStatsTableCounterSizes=sfcsCnxCfgStatsTableCounterSizes, sfcsCTMQueueConfigClpDropThreshold=sfcsCTMQueueConfigClpDropThreshold, sfcsANIMPicTLRevisionCode=sfcsANIMPicTLRevisionCode, sfcsCTMInterfaceStatsVPILookupInvalidErrors=sfcsCTMInterfaceStatsVPILookupInvalidErrors, sfcsProxyReadInLengthMismatchError=sfcsProxyReadInLengthMismatchError, sfcsBwPortPoolStatUBRConnRejRev=sfcsBwPortPoolStatUBRConnRejRev, sfcsStatusEntry=sfcsStatusEntry, sfcsBwPortPoolStatCBRConnCntRev=sfcsBwPortPoolStatCBRConnCntRev, sfcsBWPortPoolTrapMgmtBuffUpThold=sfcsBWPortPoolTrapMgmtBuffUpThold, sfcsBwPortPoolStatVBRAllocBwRev=sfcsBwPortPoolStatVBRAllocBwRev, sfcsBwPortPoolTrapMgmtAllocBwTholdLoRev=sfcsBwPortPoolTrapMgmtAllocBwTholdLoRev, sfcsProxyReadDataLength=sfcsProxyReadDataLength, sfcsANIMPicMfgRevisionCode=sfcsANIMPicMfgRevisionCode, sfcsQueueConfigEPDThreshold=sfcsQueueConfigEPDThreshold, sfcsBuffPrioEntry=sfcsBuffPrioEntry, sfcsBwPortPoolTrapMgmtTable=sfcsBwPortPoolTrapMgmtTable, sfcsANIMPicMacAddr=sfcsANIMPicMacAddr, sfcsBwPortsZone=sfcsBwPortsZone, sfcsPacketDiscardEngineOperStatus=sfcsPacketDiscardEngineOperStatus, sfcsBWPortPoolTrapMgmtBuffLoThold=sfcsBWPortPoolTrapMgmtBuffLoThold, sfcsPacketDiscardEngine=sfcsPacketDiscardEngine, sfcsProxyReadInCellReadError=sfcsProxyReadInCellReadError, sfcsBwPortPoolStatUBRConnCntFwd=sfcsBwPortPoolStatUBRConnCntFwd, sfcsSysConfigSwitchCapacity=sfcsSysConfigSwitchCapacity, sfcsProxyReadData=sfcsProxyReadData, sfcsCnxErrorTable=sfcsCnxErrorTable, sfcsProxyReadInCRCError=sfcsProxyReadInCRCError, sfcsBwPortPoolStatUBRPrevAdverCDV=sfcsBwPortPoolStatUBRPrevAdverCDV, sfcsSysConfigVcSize=sfcsSysConfigVcSize, sfcsBwPortsTable=sfcsBwPortsTable, sfcsBwPortPoolStatUBRAllocBwFwd=sfcsBwPortPoolStatUBRAllocBwFwd, sfcsCnxStatsCrossConnectLowIfIndex=sfcsCnxStatsCrossConnectLowIfIndex, sfcsProxyReadInTooBigError=sfcsProxyReadInTooBigError, sfcsStatusSlotIndex=sfcsStatusSlotIndex, sfcsQueueStatsQueue=sfcsQueueStatsQueue, sfcsANIMPicSlot=sfcsANIMPicSlot, sfcsANIMConfigANIMIndex=sfcsANIMConfigANIMIndex, sfcsBwPortPoolStatPrevAdverAvailCRRev=sfcsBwPortPoolStatPrevAdverAvailCRRev, sfcsSysStatusCurrCnxEntries=sfcsSysStatusCurrCnxEntries, sfcsBwPortPoolStatVBRPrevAdverMAXCTD=sfcsBwPortPoolStatVBRPrevAdverMAXCTD, sfcsQueueConfig=sfcsQueueConfig, sfcsInterfaceConfigTable=sfcsInterfaceConfigTable, sfcsConfigMaxStatEntries=sfcsConfigMaxStatEntries, sfcsBwPortPoolTrapMgmtCBRAllocBwTholdLoRev=sfcsBwPortPoolTrapMgmtCBRAllocBwTholdLoRev, sfcsProxyTransPayloadData=sfcsProxyTransPayloadData, sfcsCnxStatsCrossConnectHighVci=sfcsCnxStatsCrossConnectHighVci, sfcsSysSystemCfgEnt=sfcsSysSystemCfgEnt, sfcsANIMPicDcDcConverterType=sfcsANIMPicDcDcConverterType, sfcsANIMStatsTable=sfcsANIMStatsTable, sfcsANIM=sfcsANIM, sfcsCTMInterfaceConfigSigStackID=sfcsCTMInterfaceConfigSigStackID, sfcsSysConfigATOMPersistance=sfcsSysConfigATOMPersistance, sfcsCnxStatsLoToHiTaggedCells=sfcsCnxStatsLoToHiTaggedCells, sfcsCnxStatsLoToHiDroppedCells=sfcsCnxStatsLoToHiDroppedCells, sfcsBwPortPoolLimitsPoolIndex=sfcsBwPortPoolLimitsPoolIndex, sfcsANIMPicDcDcConverterInputPower=sfcsANIMPicDcDcConverterInputPower, sfcsBwPortPoolStatVBRConnCntRev=sfcsBwPortPoolStatVBRConnCntRev, sfcsBwPortPoolStatCBRConnRejFwd=sfcsBwPortPoolStatCBRConnRejFwd, sfcsBuffPrioConnRejs=sfcsBuffPrioConnRejs, sfcsQueueConfigEntry=sfcsQueueConfigEntry, sfcsSystem=sfcsSystem, sfcsProxyReadVPI=sfcsProxyReadVPI, sfcsProxyTransMpxMethod=sfcsProxyTransMpxMethod, sfcsBuffPrioTable=sfcsBuffPrioTable, sfcsInterfaceStatsOverflowDropCellCnt=sfcsInterfaceStatsOverflowDropCellCnt, sfcsConfigNumberANIMS=sfcsConfigNumberANIMS, sfcsBWMgr=sfcsBWMgr, sfcsBwPortPoolStatAvailBwFwd=sfcsBwPortPoolStatAvailBwFwd, sfcsInterfaceConfigClockingSource=sfcsInterfaceConfigClockingSource, sfcsInterfaceConfigInterfaceIndex=sfcsInterfaceConfigInterfaceIndex, sfcsPacketDiscardEngineSlotIndex=sfcsPacketDiscardEngineSlotIndex, sfcsProxyTransPayloadLength=sfcsProxyTransPayloadLength, sfcsANIMConfigTable=sfcsANIMConfigTable, sfcsCTMInterfaceStatsOverflowDropCellCnt=sfcsCTMInterfaceStatsOverflowDropCellCnt, cabletron=cabletron, sfcsBwPortPoolTrapMgmtPeakBwTholdFwd=sfcsBwPortPoolTrapMgmtPeakBwTholdFwd, sfcsANIMPicModuleTypeString=sfcsANIMPicModuleTypeString, sfcsANIMPicMfgPartNumb=sfcsANIMPicMfgPartNumb, sfcsCTMQueueConfigRMThreshold=sfcsCTMQueueConfigRMThreshold, sfcsStatsEngineSlotIndex=sfcsStatsEngineSlotIndex, sfcsProxyReadInbyteslosts=sfcsProxyReadInbyteslosts, sfcsCnxStatsEntry=sfcsCnxStatsEntry, sfcsProxyConfigTransmitDone=sfcsProxyConfigTransmitDone, sfcsProxyTransCLP=sfcsProxyTransCLP, sfcsBwPortsEntry=sfcsBwPortsEntry, sfcsConfigAdminReset=sfcsConfigAdminReset, sfcsConfigOperTime=sfcsConfigOperTime, sfcsSysStatusAllocatedBw=sfcsSysStatusAllocatedBw, sfcsPacketDiscardEngineEntry=sfcsPacketDiscardEngineEntry, sfcsANIMConfigMBClockSelect=sfcsANIMConfigMBClockSelect, sfcsANIMPicTLPartNumb=sfcsANIMPicTLPartNumb, sfcsCTMQueueConfigQueueBandwidth=sfcsCTMQueueConfigQueueBandwidth, sfcsQueueConfigCongestionThreshold=sfcsQueueConfigCongestionThreshold, sfcsCnxCfgOwner=sfcsCnxCfgOwner, sfcsCTMQueueConfig=sfcsCTMQueueConfig, sfcsProxyConfigReceiveFifoReset=sfcsProxyConfigReceiveFifoReset, sfcsCnxCfgEntry=sfcsCnxCfgEntry, sfcsStatsEngineEntry=sfcsStatsEngineEntry, sfcsCnxCfgTmType=sfcsCnxCfgTmType, sfcsInterfaceConfigType=sfcsInterfaceConfigType, sfcsCTMQueueStatsQueue=sfcsCTMQueueStatsQueue, sfcsBwPortPoolStatConnCntRev=sfcsBwPortPoolStatConnCntRev, sfcsBwPortPoolTrapMgmtUBRAllocBwTholdHiFwd=sfcsBwPortPoolTrapMgmtUBRAllocBwTholdHiFwd, sfcsBwNims=sfcsBwNims, sfcsBwPortPoolTrapMgmtAllocBwTholdLoFwd=sfcsBwPortPoolTrapMgmtAllocBwTholdLoFwd, sfcsUPCOperTime=sfcsUPCOperTime, sfcsBwPortPoolStatCBRAggPCRRev=sfcsBwPortPoolStatCBRAggPCRRev, sfcsSysConfigPnniNodeLevel=sfcsSysConfigPnniNodeLevel, sfcsBwPortPoolStatCBRAllocBwFwd=sfcsBwPortPoolStatCBRAllocBwFwd, sfcsSysStatusTable=sfcsSysStatusTable, sfcsBwPortsMetric=sfcsBwPortsMetric, sfcsBwPortPoolTrapMgmtVBRConnCntTholdHiRev=sfcsBwPortPoolTrapMgmtVBRConnCntTholdHiRev, sfcsProxyReadInHecError=sfcsProxyReadInHecError, sfcsBwPortPoolTrapMgmtCBRConnCntTholdHiFwd=sfcsBwPortPoolTrapMgmtCBRConnCntTholdHiFwd, sfcsBuffPrioAssignCtl=sfcsBuffPrioAssignCtl, sfcsBwNimsIndex=sfcsBwNimsIndex, sfcsCnxCfgUPCEnable=sfcsCnxCfgUPCEnable, sfcsBwPortPoolTrapMgmtUBRConnCntTholdHiFwd=sfcsBwPortPoolTrapMgmtUBRConnCntTholdHiFwd, sfcsProxyRead=sfcsProxyRead, sfcsSysStatus=sfcsSysStatus, sfcsSysConfigPnniAddessingMode=sfcsSysConfigPnniAddessingMode, sfcsBwPortPoolStatVBRConnRejFwd=sfcsBwPortPoolStatVBRConnRejFwd, sfcsBuffPrioUpTholdTrap=sfcsBuffPrioUpTholdTrap, sfcsBwPortPoolStatABRAllocBwFwd=sfcsBwPortPoolStatABRAllocBwFwd, sfcsBwPortPoolTrapMgmtABRConnCntTholdHiRev=sfcsBwPortPoolTrapMgmtABRConnCntTholdHiRev, sfcsProxyTransTable=sfcsProxyTransTable, sfcsBwPortPoolStatUBRAggPCRFwd=sfcsBwPortPoolStatUBRAggPCRFwd, sfcsBwPortPoolTrapMgmtVBRAllocBwTholdHiRev=sfcsBwPortPoolTrapMgmtVBRAllocBwTholdHiRev, sfcsQueue=sfcsQueue, sfcsBwPortPoolStatCBRConnRejRev=sfcsBwPortPoolStatCBRConnRejRev, sfcsBwPorts=sfcsBwPorts, sfcsBwPortsIndex=sfcsBwPortsIndex, sfcsStatsEngineOperStatus=sfcsStatsEngineOperStatus, sfcsSysStatusCurrStatsEntries=sfcsSysStatusCurrStatsEntries, sfcsBwPortPoolLimitsTable=sfcsBwPortPoolLimitsTable, sfcsBwPortPoolStatCBRPrevAdverMAXCTD=sfcsBwPortPoolStatCBRPrevAdverMAXCTD, sfcsBwPortPoolTrapMgmtHoldDownTime=sfcsBwPortPoolTrapMgmtHoldDownTime, sfcsCnxStatsHiToLoTaggedCells=sfcsCnxStatsHiToLoTaggedCells, sfcsStatisticsEngine=sfcsStatisticsEngine, sfcsSysConfigPolicingSupport=sfcsSysConfigPolicingSupport, sfcsBwPortPoolTrapMgmtCBRAllocBwTholdLoFwd=sfcsBwPortPoolTrapMgmtCBRAllocBwTholdLoFwd, sfcsANIMStatistics=sfcsANIMStatistics, sfcsConnectionStatistics=sfcsConnectionStatistics, sfcsCnxStatsCrossConnectHighVpi=sfcsCnxStatsCrossConnectHighVpi, sfcsSysBPTable=sfcsSysBPTable, sfcsBwPortPoolStatsIndex=sfcsBwPortPoolStatsIndex, sfcsCTMQueueStatistics=sfcsCTMQueueStatistics, sfcsInterfaceStatsTable=sfcsInterfaceStatsTable, sfcsCnxStatsCrossConnectIndex=sfcsCnxStatsCrossConnectIndex, sfcsQueueConfigQueueSize=sfcsQueueConfigQueueSize, sfcsProxyConfigTable=sfcsProxyConfigTable, sfcsStatsEngineReset=sfcsStatsEngineReset, sfcsSysConfigAdminReset=sfcsSysConfigAdminReset, sfcsCTMQueueConfigQueueIndex=sfcsCTMQueueConfigQueueIndex, sfcsUPCTable=sfcsUPCTable, sfcsBwPortPoolTrapMgmtCBRConnCntTholdLoFwd=sfcsBwPortPoolTrapMgmtCBRConnCntTholdLoFwd, sfcsInterfaceStatsEntry=sfcsInterfaceStatsEntry, sfcsBuffPrioPeakAlloc=sfcsBuffPrioPeakAlloc, sfcsConfigTable=sfcsConfigTable, sfcsInterfaceConfig=sfcsInterfaceConfig, sfcsProxyTransVPI=sfcsProxyTransVPI, sfcsCTMInterfaceConfig=sfcsCTMInterfaceConfig, sfcsProxyReadEntry=sfcsProxyReadEntry, sfcsANIMPicVersion=sfcsANIMPicVersion, sfcsInterfacePeakBufferUseage=sfcsInterfacePeakBufferUseage, sfcsBwPortPoolStatABRAllocBwRev=sfcsBwPortPoolStatABRAllocBwRev, sfcsSysConfigMaxUpcEntries=sfcsSysConfigMaxUpcEntries, sfcsANIMPicNumbRsvdAddrs=sfcsANIMPicNumbRsvdAddrs, sfcsCTMInterfaceStatsTable=sfcsCTMInterfaceStatsTable, sfcsCTMInterfaceStatistics=sfcsCTMInterfaceStatistics, sfcsPacketDiscardEngineEPDPercentage=sfcsPacketDiscardEngineEPDPercentage, sfcsCTMInterfaceStatsTxCellCnt=sfcsCTMInterfaceStatsTxCellCnt, sfcsBuffPrioAllocated=sfcsBuffPrioAllocated, sfcsStatusCurrCnxEntries=sfcsStatusCurrCnxEntries, sfcsANIMPicModuleType=sfcsANIMPicModuleType, sfcsQueueConfigQueueBandwidth=sfcsQueueConfigQueueBandwidth, sfcsCnxStatsCrossConnectHighIfIndex=sfcsCnxStatsCrossConnectHighIfIndex, sfcsCTMInterfaceConfigClocking=sfcsCTMInterfaceConfigClocking, sfcsBwPortPools=sfcsBwPortPools, sfcsCnxCfgCrossConnectLowVci=sfcsCnxCfgCrossConnectLowVci, sfcsProxyConfigTxFifoReset=sfcsProxyConfigTxFifoReset, sfcsInterfaceStatsRxCnxLookupInvalidErrors=sfcsInterfaceStatsRxCnxLookupInvalidErrors, sfcsBwPortPoolLimitsBwAllocStrat=sfcsBwPortPoolLimitsBwAllocStrat, sfcsConfigLastChange=sfcsConfigLastChange, sfcsBwPortPoolStatVBRAllocBwFwd=sfcsBwPortPoolStatVBRAllocBwFwd, sfcsBwPortPoolLimitsVBRLimitRev=sfcsBwPortPoolLimitsVBRLimitRev, sfcsBwPortPoolStatABRPrevAdverMAXCTD=sfcsBwPortPoolStatABRPrevAdverMAXCTD, sfcsBwPortPoolStatPrevAdverMAXCRRev=sfcsBwPortPoolStatPrevAdverMAXCRRev, sfcsBwPortPoolTrapMgmtABRConnCntTholdHiFwd=sfcsBwPortPoolTrapMgmtABRConnCntTholdHiFwd, sfcsBwPortPoolLimitsVBRLimitFwd=sfcsBwPortPoolLimitsVBRLimitFwd, sfcsBwPortPoolLimitsBwConstant=sfcsBwPortPoolLimitsBwConstant, sfcsConfigMibRev=sfcsConfigMibRev, sfcsBwPortPoolTrapMgmtAllocBwTholdHiRev=sfcsBwPortPoolTrapMgmtAllocBwTholdHiRev)
mibBuilder.exportSymbols("CTRON-SFCS-MIB", sfcsANIMPicTLSerialNumb=sfcsANIMPicTLSerialNumb, sfcsSysSystemCfgTable=sfcsSysSystemCfgTable, sfcsSysStatusTdmUtilization=sfcsSysStatusTdmUtilization, sfcsPacketDiscardEngineOperTime=sfcsPacketDiscardEngineOperTime, sfcsBwPortPoolStatAllocBwRev=sfcsBwPortPoolStatAllocBwRev, sfcsSysConfigPowerUpDiags=sfcsSysConfigPowerUpDiags, sfcsInterfaceStatistics=sfcsInterfaceStatistics, sfcsANIMStatsTxCells=sfcsANIMStatsTxCells, sfcsCnxCfgCrossConnectLowIfIndex=sfcsCnxCfgCrossConnectLowIfIndex, sfcsCTMQueueStatsTable=sfcsCTMQueueStatsTable, sfcsBuffPools=sfcsBuffPools, sfcsStatsEngineAdminStatus=sfcsStatsEngineAdminStatus, sfcsBwPortPoolStatVBRAggPCRFwd=sfcsBwPortPoolStatVBRAggPCRFwd, sfcsSysConfigMaxCnxEntries=sfcsSysConfigMaxCnxEntries, sfcsANIMPicMfgMfgLocation=sfcsANIMPicMfgMfgLocation, sfcsBwPortPoolStatVBRConnRejRev=sfcsBwPortPoolStatVBRConnRejRev, sfcsBwPortPoolTrapMgmtUBRAllocBwTholdHiRev=sfcsBwPortPoolTrapMgmtUBRAllocBwTholdHiRev, sfcsBwPortPoolTrapMgmtVBRAllocBwTholdHiFwd=sfcsBwPortPoolTrapMgmtVBRAllocBwTholdHiFwd, sfcsInterface=sfcsInterface, sfcsSysConfigOperStatus=sfcsSysConfigOperStatus, sfcsBwPortPoolTrapMgmtABRConnCntTholdLoRev=sfcsBwPortPoolTrapMgmtABRConnCntTholdLoRev, sfcsConfigOperStatus=sfcsConfigOperStatus, sfcsSysConfigPnniNsapPrefix=sfcsSysConfigPnniNsapPrefix, sfcsSysBPClkSelect=sfcsSysBPClkSelect, sfcsCTMInterfaceConfigNextVCI=sfcsCTMInterfaceConfigNextVCI, sfcsProxyTrans=sfcsProxyTrans, sfcsSysConfigEnt=sfcsSysConfigEnt, sfcsQueueConfigEFCILowThreshold=sfcsQueueConfigEFCILowThreshold, sfcsCTMQueueConfigEntry=sfcsCTMQueueConfigEntry, sfcsBwNimsAdminStatus=sfcsBwNimsAdminStatus, sfcsBwPortsPhysBwRev=sfcsBwPortsPhysBwRev, sfcsBuffPrioConnRejThold=sfcsBuffPrioConnRejThold, sfcsStatusCurrCtmAgent=sfcsStatusCurrCtmAgent, sfcsProxy=sfcsProxy, sfcsProxyConfig=sfcsProxyConfig, sfcsBwPortPoolTrapMgmtABRConnCntTholdLoFwd=sfcsBwPortPoolTrapMgmtABRConnCntTholdLoFwd, sfcsConfigAdminStatus=sfcsConfigAdminStatus, sfcsUPCEngine=sfcsUPCEngine, sfcsQueueStatsQueuePeakLevel=sfcsQueueStatsQueuePeakLevel, sfcsBwPortPoolStatUBRConnCntRev=sfcsBwPortPoolStatUBRConnCntRev, sfcsConfigVersion=sfcsConfigVersion, sfcsBuffPrioPortIndex=sfcsBuffPrioPortIndex, sfcsSysConfigMaxfreecva=sfcsSysConfigMaxfreecva, sfcsBwPortPoolLimitsUBRConnLimitFwd=sfcsBwPortPoolLimitsUBRConnLimitFwd, sfcsANIMConfigAdminStatus=sfcsANIMConfigAdminStatus, sfcsProxyConfigTxMemSize=sfcsProxyConfigTxMemSize, sfcsProxyConfigReceiveFifoState=sfcsProxyConfigReceiveFifoState, sfcsANIMPicTLDateCode=sfcsANIMPicTLDateCode, sfcsANIMPicStatus=sfcsANIMPicStatus, sfcsBwPortPoolStatAvailBwRev=sfcsBwPortPoolStatAvailBwRev, sfcsSysConfigInterfaceCapability=sfcsSysConfigInterfaceCapability, sfcsANIMPicMfgSN=sfcsANIMPicMfgSN, sfcsConfigMaxUpcEntries=sfcsConfigMaxUpcEntries, sfcsSysConfigMaxStatEntries=sfcsSysConfigMaxStatEntries, sfcsPacketDiscardEngineReset=sfcsPacketDiscardEngineReset, sfcsUPCReset=sfcsUPCReset, sfcsANIMPicTLReworkLocation=sfcsANIMPicTLReworkLocation, sfcsProxyTransGumbo=sfcsProxyTransGumbo, sfcsANIMConfigLineRate=sfcsANIMConfigLineRate, sfcsCTMQueueStatsQueuePeakLevel=sfcsCTMQueueStatsQueuePeakLevel, sfcsConfigMasterClock2Standby=sfcsConfigMasterClock2Standby, sfcsBwPortPoolTrapMgmtPoolIndex=sfcsBwPortPoolTrapMgmtPoolIndex, sfcsBwPortPoolTrapMgmtAllocBwTholdHiFwd=sfcsBwPortPoolTrapMgmtAllocBwTholdHiFwd, sfcsStatusTdmCellCount=sfcsStatusTdmCellCount, sfcsConfigBwCapability=sfcsConfigBwCapability, sfcsCnxStatsHiToLoHTxCells=sfcsCnxStatsHiToLoHTxCells, sfcsSysConfigNumberANIMS=sfcsSysConfigNumberANIMS, sfcsBwPortPoolStatVBRPrevAdverCDV=sfcsBwPortPoolStatVBRPrevAdverCDV, sfcsBwPortPoolStatUBRAllocBwRev=sfcsBwPortPoolStatUBRAllocBwRev, sfcsUPCAdminStatus=sfcsUPCAdminStatus, sfcsSysStatusEnt=sfcsSysStatusEnt, sfcsProxyReadInTotalCells=sfcsProxyReadInTotalCells, sfcsSysConfigLastChange=sfcsSysConfigLastChange, sfcsBwPortPoolLimitsMaxAllocBwRev=sfcsBwPortPoolLimitsMaxAllocBwRev, sfcsProxyConfigANIMIndex=sfcsProxyConfigANIMIndex, sfcsConnection=sfcsConnection, sfcsInterfaceConfigEntry=sfcsInterfaceConfigEntry, sfcsANIMPicMfgReworkLocation=sfcsANIMPicMfgReworkLocation, sfcsBwPortPoolTrapMgmtUBRConnCntTholdHiRev=sfcsBwPortPoolTrapMgmtUBRConnCntTholdHiRev, sfcsCTMQueueConfigEFCILowThreshold=sfcsCTMQueueConfigEFCILowThreshold, sfcsInterfaceStatsRxCellCnt=sfcsInterfaceStatsRxCellCnt, sfcsBwPortPoolLimitsCBRLimitRev=sfcsBwPortPoolLimitsCBRLimitRev, sfcsBwPortPoolTrapMgmtCBRConnCntTholdLoRev=sfcsBwPortPoolTrapMgmtCBRConnCntTholdLoRev, sfcsQueueStatistics=sfcsQueueStatistics, sfcsBwNimsEntry=sfcsBwNimsEntry, sfcsProxyConfigLoad=sfcsProxyConfigLoad, sfcsCnxCfgCrossConnectIndex=sfcsCnxCfgCrossConnectIndex, sfcsANIMPicSmb1PromVersion=sfcsANIMPicSmb1PromVersion, sfcsBwPortPoolLimitsCBRLimitFwd=sfcsBwPortPoolLimitsCBRLimitFwd, sfcsCnxCfgCrossConnectLowVpi=sfcsCnxCfgCrossConnectLowVpi, sfcsCTMInterfaceConfigType=sfcsCTMInterfaceConfigType, sfcsCTMInterfaceStatsRxCnxLookupInvalidErrors=sfcsCTMInterfaceStatsRxCnxLookupInvalidErrors, sfcsANIMStatsANIMIndex=sfcsANIMStatsANIMIndex, sfcsQueueStatsInterfaceIndex=sfcsQueueStatsInterfaceIndex, sfcsBuffPrioAvailable=sfcsBuffPrioAvailable, sfcsProxyTransControl=sfcsProxyTransControl, sfcsCnxErrorCode=sfcsCnxErrorCode, sfcsBwPortPoolLimitsUBRConnLimitRev=sfcsBwPortPoolLimitsUBRConnLimitRev, sfcsBwPortPoolTrapMgmtABRAllocBwTholdHiRev=sfcsBwPortPoolTrapMgmtABRAllocBwTholdHiRev, sfcsANIMPicTLMfgLocation=sfcsANIMPicTLMfgLocation, sfcsProxyConfigReceiveMode=sfcsProxyConfigReceiveMode, sfcsBwPortPoolLimitsEntry=sfcsBwPortPoolLimitsEntry, sfcsCnxErrorTimeStamp=sfcsCnxErrorTimeStamp, sfcsANIMPicMfgSerialNumb=sfcsANIMPicMfgSerialNumb, sfcsBwPortPoolStatVBRAggPCRRev=sfcsBwPortPoolStatVBRAggPCRRev, sfcsConnectionError=sfcsConnectionError, sfcsANIMConfigOperStatus=sfcsANIMConfigOperStatus, sfcsProxyConfigCaptureMode=sfcsProxyConfigCaptureMode, sfcsProxyTransPayloadType=sfcsProxyTransPayloadType, sfcsPacketDiscardEngineAdminStatus=sfcsPacketDiscardEngineAdminStatus, sfcsCnxCfgCrossConnectHighIfIndex=sfcsCnxCfgCrossConnectHighIfIndex, sfcsProxyTransCount=sfcsProxyTransCount, sfcsUPCSlotIndex=sfcsUPCSlotIndex, sfcsBwPortPoolStatPeakBwFwd=sfcsBwPortPoolStatPeakBwFwd, sfcsStatusCurrUPCEntries=sfcsStatusCurrUPCEntries, sfcsConfigMasterClock1Source=sfcsConfigMasterClock1Source, sfcsBwPortPoolTrapMgmtUBRAllocBwTholdLoRev=sfcsBwPortPoolTrapMgmtUBRAllocBwTholdLoRev, ctSwitch=ctSwitch, sfcsANIMPicTLPN=sfcsANIMPicTLPN, sfcsQueueStatsTxClpCellsDiscarded=sfcsQueueStatsTxClpCellsDiscarded, sfcsSysStatusTdmCellCount=sfcsSysStatusTdmCellCount, sfcsBwPortPoolStatRejConnRev=sfcsBwPortPoolStatRejConnRev, sfcsProxyReadInError=sfcsProxyReadInError, sfcsBwPortPoolStatUBRAggPCRRev=sfcsBwPortPoolStatUBRAggPCRRev, sfcsSysBPEnt=sfcsSysBPEnt, sfcsProxyTransANIMIndex=sfcsProxyTransANIMIndex, sfcsCTMInterfaceConfigTable=sfcsCTMInterfaceConfigTable, sfcsANIMPicLocation=sfcsANIMPicLocation, sfcsProxyReadGumbo=sfcsProxyReadGumbo, sfcsBwPortPoolStatTable=sfcsBwPortPoolStatTable, sfcsStatus=sfcsStatus, sfcsQueueStatsTable=sfcsQueueStatsTable, sfcsConfigSwitchCapacity=sfcsConfigSwitchCapacity, sfcsSysConfigTypeofSwitch=sfcsSysConfigTypeofSwitch, sfcsQueueStatsTxCellCnt=sfcsQueueStatsTxCellCnt, sfcsBwPortPoolTrapMgmtUBRConnCntTholdLoFwd=sfcsBwPortPoolTrapMgmtUBRConnCntTholdLoFwd, sfcsBwPortPoolStatRejConnFwd=sfcsBwPortPoolStatRejConnFwd, sfcsBuffPrioAssigned=sfcsBuffPrioAssigned, sfcsProxyConfigNUMPORTS=sfcsProxyConfigNUMPORTS, sfcsEngine=sfcsEngine, sfcsCTMInterfaceStatsRxErrors=sfcsCTMInterfaceStatsRxErrors, sfcsProxyReadTable=sfcsProxyReadTable, sfcsSysConfig=sfcsSysConfig, sfcsStatsEngineOperTime=sfcsStatsEngineOperTime, sfcsStatusTable=sfcsStatusTable, sfcsSysConfigAdminStatus=sfcsSysConfigAdminStatus, sfcsBwPortPoolTrapMgmtABRAllocBwTholdHiFwd=sfcsBwPortPoolTrapMgmtABRAllocBwTholdHiFwd, sfcsProxyReadInCells=sfcsProxyReadInCells, sfcsSysBPCfg=sfcsSysBPCfg, sfcsANIMPicMfgDateCode=sfcsANIMPicMfgDateCode, sfcsANIMPic=sfcsANIMPic, sfcsSysConfigTable=sfcsSysConfigTable, sfcsCTMInterfaceStatsEntry=sfcsCTMInterfaceStatsEntry, sfcsCTMInterfaceConfigNumberOfQueues=sfcsCTMInterfaceConfigNumberOfQueues, sfcsBwPortsPhysBwFwd=sfcsBwPortsPhysBwFwd, sfcsProxyConfigBandWidth=sfcsProxyConfigBandWidth, sfcsCnxCfgStatsEnable=sfcsCnxCfgStatsEnable, sfcsUPCEntry=sfcsUPCEntry, sfcsBwPortPoolStatVBRConnCntFwd=sfcsBwPortPoolStatVBRConnCntFwd, sfcsBwPortPoolStatsPoolIndex=sfcsBwPortPoolStatsPoolIndex, sfcsProxyReadNewPdu=sfcsProxyReadNewPdu, sfcsQueueConfigInterfaceIndex=sfcsQueueConfigInterfaceIndex, sfcsProxyTransPayloadAdaptionLayer=sfcsProxyTransPayloadAdaptionLayer, sfcsStatusCurrStatsEntries=sfcsStatusCurrStatsEntries, sfcsQueueConfigClpDropThreshold=sfcsQueueConfigClpDropThreshold, sfcsBwPortPoolStatConnCntFwd=sfcsBwPortPoolStatConnCntFwd, sfcsANIMConfigANIMType=sfcsANIMConfigANIMType, sfcsCnxErrorRowStatus=sfcsCnxErrorRowStatus, sfcsBwPortPoolStatABRAggPCRRev=sfcsBwPortPoolStatABRAggPCRRev, sfcsCTMInterfaceConfigNextVPI=sfcsCTMInterfaceConfigNextVPI, sfcsANIMConfigNumInterfaces=sfcsANIMConfigNumInterfaces, sfcsBwPortPoolStatABRConnCntFwd=sfcsBwPortPoolStatABRConnCntFwd, sfcsProxyReadVCI=sfcsProxyReadVCI, sfcsBwNimsTable=sfcsBwNimsTable, sfcsBwPortPoolStatPrevAdverMAXCRFwd=sfcsBwPortPoolStatPrevAdverMAXCRFwd, sfcsBwPortPoolStatCBRAllocBwRev=sfcsBwPortPoolStatCBRAllocBwRev, sfcsBwPortsAdminStatus=sfcsBwPortsAdminStatus, sfcsBwPortPoolStatCBRAggPCRFwd=sfcsBwPortPoolStatCBRAggPCRFwd, sfcsConfig=sfcsConfig, sfcsCTMInterfaceConfigInterfaceIndex=sfcsCTMInterfaceConfigInterfaceIndex, sfcsInterfaceStatsInterfaceIndex=sfcsInterfaceStatsInterfaceIndex, sfcsBwPortPoolStatAllocBwFwd=sfcsBwPortPoolStatAllocBwFwd, sfcsProxyReadPTI=sfcsProxyReadPTI, sfcsBwPortPoolStatPrevAdverAvailCRFwd=sfcsBwPortPoolStatPrevAdverAvailCRFwd, sfcsBwPortPoolStatABRConnRejRev=sfcsBwPortPoolStatABRConnRejRev, sfcsBWNimsPortCount=sfcsBWNimsPortCount, sfcsSysConfigOperTime=sfcsSysConfigOperTime, sfcsSysConfigUBR=sfcsSysConfigUBR, sfcsBwPortPoolTrapMgmtVBRConnCntTholdHiFwd=sfcsBwPortPoolTrapMgmtVBRConnCntTholdHiFwd, sfcsBuffPrioLoTholdTrap=sfcsBuffPrioLoTholdTrap, sfcsBwPortPoolLimitsABRLimitRev=sfcsBwPortPoolLimitsABRLimitRev, sfcsSysSystemCfg=sfcsSysSystemCfg, sfcsBwPortPoolTrapMgmtIndex=sfcsBwPortPoolTrapMgmtIndex, sfcsProxyConfigInitPort=sfcsProxyConfigInitPort, sfcsBwPortPoolStatUBRConnRejFwd=sfcsBwPortPoolStatUBRConnRejFwd, sfcsProxyConfigGumbo=sfcsProxyConfigGumbo, sfcsQueueConfigTable=sfcsQueueConfigTable, sfcsBWNimsPrioCount=sfcsBWNimsPrioCount, sfcsBwPortPoolStatABRConnCntRev=sfcsBwPortPoolStatABRConnCntRev, sfcsBwPortPoolTrapMgmtEntry=sfcsBwPortPoolTrapMgmtEntry, sfcsBwPortPoolLimitsUBRLimitRev=sfcsBwPortPoolLimitsUBRLimitRev, sfcsUPCOperStatus=sfcsUPCOperStatus, sfcsCTMInterfaceConfigEntry=sfcsCTMInterfaceConfigEntry, sfcsBwPortPoolTrapMgmtCBRAllocBwTholdHiFwd=sfcsBwPortPoolTrapMgmtCBRAllocBwTholdHiFwd, sfcsQueueStatsEntry=sfcsQueueStatsEntry, sfcsCTMQueueStatsTxCellCnt=sfcsCTMQueueStatsTxCellCnt, sfcsProxyConfigRxMaxPduSize=sfcsProxyConfigRxMaxPduSize, sfcsCTMQueueStatsTxClpCellsDiscarded=sfcsCTMQueueStatsTxClpCellsDiscarded, sfcsStatusTdmUtilization=sfcsStatusTdmUtilization, sfcsCnxStatsLoToHiHTxCells=sfcsCnxStatsLoToHiHTxCells, sfcsStatsEngineTable=sfcsStatsEngineTable, sfcsConfigSlotIndex=sfcsConfigSlotIndex, sfcsBwPortPoolStatABRPrevAdverCDV=sfcsBwPortPoolStatABRPrevAdverCDV, sfcsBwPortPoolTrapMgmtVBRConnCntTholdLoRev=sfcsBwPortPoolTrapMgmtVBRConnCntTholdLoRev, sfcsBwPortPoolTrapMgmtCBRConnCntTholdHiRev=sfcsBwPortPoolTrapMgmtCBRConnCntTholdHiRev, sfcsANIMPicBoardLevelRevision=sfcsANIMPicBoardLevelRevision, sfcsANIMPicTLSN=sfcsANIMPicTLSN, sfcsBwPortPoolLimitsMaxAllocBwFwd=sfcsBwPortPoolLimitsMaxAllocBwFwd, sfcsBwPortPoolTrapMgmtVBRConnCntTholdLoFwd=sfcsBwPortPoolTrapMgmtVBRConnCntTholdLoFwd, mibs=mibs, sfcsConfigMaxCnxEntries=sfcsConfigMaxCnxEntries, sfcsANIMPicEntry=sfcsANIMPicEntry, sfcsANIMPicTable=sfcsANIMPicTable, sfcsCnxStatsTable=sfcsCnxStatsTable, sfcsProxyReadANIMIndex=sfcsProxyReadANIMIndex, sfcsSysConfigCTMSlotMask=sfcsSysConfigCTMSlotMask, sfcsConfigMasterClock2Source=sfcsConfigMasterClock2Source, sfcsANIMConfig=sfcsANIMConfig, sfcsCTMQueueStatsEntry=sfcsCTMQueueStatsEntry, sfcsBwPortPoolStatEntry=sfcsBwPortPoolStatEntry, sfcsBuffPrioPriority=sfcsBuffPrioPriority, sfcsCnxCfgTable=sfcsCnxCfgTable, sfcsBwPortPoolTrapMgmtUBRConnCntTholdLoRev=sfcsBwPortPoolTrapMgmtUBRConnCntTholdLoRev, sfcsProxyTransEncodeNewPdu=sfcsProxyTransEncodeNewPdu, sfcsCTM=sfcsCTM, sfcsANIMConfigEntry=sfcsANIMConfigEntry, sfcsBwPortPoolTrapMgmtUBRAllocBwTholdLoFwd=sfcsBwPortPoolTrapMgmtUBRAllocBwTholdLoFwd, sfcsBwPortPoolLimitsUBRLimitFwd=sfcsBwPortPoolLimitsUBRLimitFwd, sfcsCTMQueueConfigInterfaceIndex=sfcsCTMQueueConfigInterfaceIndex, sfcsProxyReadCLP=sfcsProxyReadCLP, sfcsCTMInterfaceStatsRxCellCnt=sfcsCTMInterfaceStatsRxCellCnt, sfcsConfigEntry=sfcsConfigEntry, sfcsANIMPicIndex=sfcsANIMPicIndex, sfcsCnxCfgCrossConnectHighVci=sfcsCnxCfgCrossConnectHighVci, sfcsProxyConfigPortTransmitMode=sfcsProxyConfigPortTransmitMode, sfcsBwPortPoolTrapMgmtPeakBwTholdRev=sfcsBwPortPoolTrapMgmtPeakBwTholdRev, sfcsSysConfigFMVer=sfcsSysConfigFMVer)

#
# PySNMP MIB module Nortel-MsCarrier-MscPassport-AtmPnniMIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/Nortel-MsCarrier-MscPassport-AtmPnniMIB
# Produced by pysmi-0.3.4 at Wed May  1 14:29:08 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsUnion, ValueSizeConstraint, ValueRangeConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsUnion", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsIntersection")
mscAtmIfVptIndex, mscAtmIfIndex, mscAtmIfVpt, mscAtmIf = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex", "mscAtmIfIndex", "mscAtmIfVpt", "mscAtmIf")
Unsigned32, StorageType, DisplayString, RowStatus, Counter32, Integer32, Gauge32 = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-StandardTextualConventionsMIB", "Unsigned32", "StorageType", "DisplayString", "RowStatus", "Counter32", "Integer32", "Gauge32")
HexString, NonReplicated, Hex, AsciiStringIndex, FixedPoint1 = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-TextualConventionsMIB", "HexString", "NonReplicated", "Hex", "AsciiStringIndex", "FixedPoint1")
mscPassportMIBs, = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-UsefulDefinitionsMIB", "mscPassportMIBs")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
ObjectIdentity, Unsigned32, NotificationType, IpAddress, Gauge32, iso, MibScalar, MibTable, MibTableRow, MibTableColumn, MibIdentifier, Counter32, Counter64, TimeTicks, ModuleIdentity, Integer32, Bits = mibBuilder.importSymbols("SNMPv2-SMI", "ObjectIdentity", "Unsigned32", "NotificationType", "IpAddress", "Gauge32", "iso", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "MibIdentifier", "Counter32", "Counter64", "TimeTicks", "ModuleIdentity", "Integer32", "Bits")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
atmPnniMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 72))
mscAtmIfVptPnni = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7))
mscAtmIfVptPnniRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 1), )
if mibBuilder.loadTexts: mscAtmIfVptPnniRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfVptPnni components.')
mscAtmIfVptPnniRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfVptPnniIndex"))
if mibBuilder.loadTexts: mscAtmIfVptPnniRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfVptPnni component.')
mscAtmIfVptPnniRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptPnniRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfVptPnni components. These components can be added and deleted.')
mscAtmIfVptPnniComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptPnniComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfVptPnniStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptPnniStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniStorageType.setDescription('This variable represents the storage type value for the mscAtmIfVptPnni tables.')
mscAtmIfVptPnniIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscAtmIfVptPnniIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniIndex.setDescription('This variable represents the index for the mscAtmIfVptPnni tables.')
mscAtmIfVptPnniProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 10), )
if mibBuilder.loadTexts: mscAtmIfVptPnniProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniProvTable.setDescription('This group contains the provisionable attributes for the Pnni component.')
mscAtmIfVptPnniProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfVptPnniIndex"))
if mibBuilder.loadTexts: mscAtmIfVptPnniProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniProvEntry.setDescription('An entry in the mscAtmIfVptPnniProvTable.')
mscAtmIfVptPnniSoftPvcRetryPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(20, 999999)).clone(60)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptPnniSoftPvcRetryPeriod.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptPnniSoftPvcRetryPeriod.setDescription('This attribute represents the time in seconds to wait between call setup retries. The resolution is to the nearest 10 seconds. This attribute has been obsoleted and is replaced by the softPvpAndPvcRetryPeriod attribute.')
mscAtmIfVptPnniSoftPvpAndPvcRetryPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(20, 999999)).clone(60)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptPnniSoftPvpAndPvcRetryPeriod.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniSoftPvpAndPvcRetryPeriod.setDescription('This attribute represents the time in seconds to wait between soft PVP or soft PVC call setup retries. The resolution is to the nearest 10 seconds.')
mscAtmIfVptPnniSoftPvpAndPvcHoldOffTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(50, 20000), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptPnniSoftPvpAndPvcHoldOffTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniSoftPvpAndPvcHoldOffTime.setDescription('This attribute specifies how long to hold off retries following a release or the connection. The resolution is to the nearest 50 ms.')
mscAtmIfVptPnniAdminWeightsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 11), )
if mibBuilder.loadTexts: mscAtmIfVptPnniAdminWeightsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniAdminWeightsTable.setDescription('This group contains the provisionable administrative weights for the Pnni component. These weights will be used by Generic Connection Admission Control (GCAC) if administrative weight is the selected optimization criterion.')
mscAtmIfVptPnniAdminWeightsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfVptPnniIndex"))
if mibBuilder.loadTexts: mscAtmIfVptPnniAdminWeightsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniAdminWeightsEntry.setDescription('An entry in the mscAtmIfVptPnniAdminWeightsTable.')
mscAtmIfVptPnniCbrWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 11, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(5040)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptPnniCbrWeight.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniCbrWeight.setDescription('This attribute specifies the administrative weight assigned for setting up switched calls with a service category of Constant Bit Rate (CBR) for this PNNI interface. The value specified will be used by Generic Connection Admission Control (GCAC) if administrative weight is the selected optimization criterion; the higher the value, the less desirable the link will be in path selection.')
mscAtmIfVptPnniRtVbrWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 11, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(5040)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptPnniRtVbrWeight.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniRtVbrWeight.setDescription('This attribute specifies the administrative weight assigned for setting up switched calls with a service category of Real-Time Variable Bit Rate (RT-VBR) for this PNNI interface. The value specified will be used by Generic Connection Admission Control (GCAC) if administrative weight is the selected optimization criterion; the higher the value, the less desirable the link will be in path selection.')
mscAtmIfVptPnniNrtVbrWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(5040)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptPnniNrtVbrWeight.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniNrtVbrWeight.setDescription('This attribute specifies the administrative weight assigned for setting up switched calls with a service category of Non Real-Time Variable Bit Rate (NRT-VBR) for this PNNI interface. The value specified will be used by Generic Connection Admission Control (GCAC) if administrative weight is the selected optimization criterion; the higher the value, the less desirable the link will be in path selection.')
mscAtmIfVptPnniUbrWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 11, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(5040)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptPnniUbrWeight.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniUbrWeight.setDescription('This attribute specifies the administrative weight assigned for setting up switched calls with a service category of Unspecified Bit Rate (UBR) for this PNNI interface. The value specified will be used by Generic Connection Admission Control (GCAC) if administrative weight is the selected optimization criterion; the higher the value, the less desirable the link will be in path selection.')
mscAtmIfVptPnniAcctOptTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 12), )
if mibBuilder.loadTexts: mscAtmIfVptPnniAcctOptTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniAcctOptTable.setDescription('This group contains the provisionable attributes for accounting.')
mscAtmIfVptPnniAcctOptEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfVptPnniIndex"))
if mibBuilder.loadTexts: mscAtmIfVptPnniAcctOptEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniAcctOptEntry.setDescription('An entry in the mscAtmIfVptPnniAcctOptTable.')
mscAtmIfVptPnniAccountCollection = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 12, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptPnniAccountCollection.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniAccountCollection.setDescription('This attribute is used to turn accounting on or off for SVC and SPVC connections. It also specifies the reason(s) for which accounting data is collected: billing, test, study, audit, or force. If the set of reasons is not empty then accounting records will be generated by this interface in the following situations: - on a TODA changeover if TODA is enabled; - every 12 hours (per connection) if TODA is disabled; - on every call clear (a call record with final cell counts). If none of the reasons is present, then accounting will be suppressed. The reason for collection is recorded in the accounting record, in the attribute callingCollectReason or calledCollectReason as appropriate. Description of bits: bill(0) test(1) study(2) audit(3) force(4)')
mscAtmIfVptPnniAccountConnectionType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("origTerm", 0), ("intermediate", 1))).clone('intermediate')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptPnniAccountConnectionType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniAccountConnectionType.setDescription('This attribute specifies whether accounting records generated by this interface should be marked as originating, terminating or intermediate. This attribute, in combination with the direction of the call, determines the value of attribute connPointType of the accounting record and may be used by downstream accounting processes to correlate the records. If the value is origTerm then records generated for incoming calls will be marked as originating and records generated for outgoing calls will be marked as terminating. If the value is intermediate then records generated for all calls will be marked as intermediate.')
mscAtmIfVptPnniAccountClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 12, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptPnniAccountClass.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniAccountClass.setDescription('This attribute specifies the accounting class associated with the interface. Its meaning is determined by the network operator. Its value is simply recorded in the accounting records generated by this interface, in the attribute callingServiceType or calledServiceType as appropriate.')
mscAtmIfVptPnniServiceExchange = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 12, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptPnniServiceExchange.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniServiceExchange.setDescription('This attribute specifies the data service exchange associated with this interface. Its meaning is determined by the network operator. Its value is simply recorded in the accounting records generated by this interface, in the attribute callingDse or calledDse as appropriate.')
mscAtmIfVptPnniOperationalTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 13), )
if mibBuilder.loadTexts: mscAtmIfVptPnniOperationalTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniOperationalTable.setDescription('This group contains the operational attributes for a Pnni component.')
mscAtmIfVptPnniOperationalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfVptPnniIndex"))
if mibBuilder.loadTexts: mscAtmIfVptPnniOperationalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniOperationalEntry.setDescription('An entry in the mscAtmIfVptPnniOperationalTable.')
mscAtmIfVptPnniPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 13, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptPnniPortId.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniPortId.setDescription("This attribute indicates the port id of the PNNI interface, which is the parent AtmIf's instance number.")
mscAtmIfVptPnniVProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 14), )
if mibBuilder.loadTexts: mscAtmIfVptPnniVProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniVProvTable.setDescription('This group contains the provisionable attributes for the Pnni component which are specific to virtual PNNI interfaces.')
mscAtmIfVptPnniVProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 14, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfVptPnniIndex"))
if mibBuilder.loadTexts: mscAtmIfVptPnniVProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniVProvEntry.setDescription('An entry in the mscAtmIfVptPnniVProvTable.')
mscAtmIfVptPnniVpci = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 14, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptPnniVpci.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniVpci.setDescription('This attribute specifies the Virtual Path Connection Identifier (VPCI) to be used between this signalling entity and its peer. The VPCI of the peer virtual PNNI must have the same value for switched connections to be set up across the interface.')
mscAtmIfVptPnniSig = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 2))
mscAtmIfVptPnniSigRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 2, 1), )
if mibBuilder.loadTexts: mscAtmIfVptPnniSigRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniSigRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfVptPnniSig components.')
mscAtmIfVptPnniSigRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfVptPnniIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfVptPnniSigIndex"))
if mibBuilder.loadTexts: mscAtmIfVptPnniSigRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniSigRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfVptPnniSig component.')
mscAtmIfVptPnniSigRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptPnniSigRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniSigRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfVptPnniSig components. These components cannot be added nor deleted.')
mscAtmIfVptPnniSigComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptPnniSigComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniSigComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfVptPnniSigStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptPnniSigStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniSigStorageType.setDescription('This variable represents the storage type value for the mscAtmIfVptPnniSig tables.')
mscAtmIfVptPnniSigIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscAtmIfVptPnniSigIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniSigIndex.setDescription('This variable represents the index for the mscAtmIfVptPnniSig tables.')
mscAtmIfVptPnniSigProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 2, 10), )
if mibBuilder.loadTexts: mscAtmIfVptPnniSigProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniSigProvTable.setDescription('This attribute group contains the provisionable attributes for the Signalling component.')
mscAtmIfVptPnniSigProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfVptPnniIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfVptPnniSigIndex"))
if mibBuilder.loadTexts: mscAtmIfVptPnniSigProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniSigProvEntry.setDescription('An entry in the mscAtmIfVptPnniSigProvTable.')
mscAtmIfVptPnniSigVci = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 2, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptPnniSigVci.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniSigVci.setDescription('This attribute specifies the signalling channel number.')
mscAtmIfVptPnniSigAddressConversion = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 2, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("none", 0), ("nativeE164", 1), ("nsap", 2))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptPnniSigAddressConversion.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniSigAddressConversion.setDescription('This attribute specifies the address conversion on the outgoing signalling PDUs. The options are none, nativeE164, or nsap. The none option is the default and if this option is chosen then nothing is done to the address information element (IE) in the outgoing signalling message. If nativeE164 option is chosen, then only NSAP encapsulated E.164 addresses with zeros in the ESI are converted to native E.164 format in the outgoing signalling message. If the NSAP address is not encapsulated E.164 or the ESI field is not zeros and the nativeE164 option is chosen, then the call is cleared. If the nsap option is chosen, then native E.164 addresses are converted to NSAP E.164 with zeros in the ESI field; otherwise the address is in NSAP format and is not changed.')
mscAtmIfVptPnniSigOperatingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 2, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("normal", 0), ("provisionedOnly", 1))).clone('normal')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptPnniSigOperatingMode.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniSigOperatingMode.setDescription('This attribute specifies the operating mode of the signaling channel. provisionedOnly indicates that only SPVCs and SPVPs are supported on the interface and SVCs are not supported. This value is permitted only on UNI interfaces. normal indicates that SVCs, SPVCs, and SPVPs are supported on the interface.')
mscAtmIfVptPnniSigStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 2, 11), )
if mibBuilder.loadTexts: mscAtmIfVptPnniSigStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniSigStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscAtmIfVptPnniSigStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 2, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfVptPnniIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfVptPnniSigIndex"))
if mibBuilder.loadTexts: mscAtmIfVptPnniSigStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniSigStateEntry.setDescription('An entry in the mscAtmIfVptPnniSigStateTable.')
mscAtmIfVptPnniSigAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 2, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptPnniSigAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniSigAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscAtmIfVptPnniSigOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 2, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptPnniSigOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniSigOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscAtmIfVptPnniSigUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 2, 11, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptPnniSigUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniSigUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscAtmIfVptPnniSigOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 2, 12), )
if mibBuilder.loadTexts: mscAtmIfVptPnniSigOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniSigOperTable.setDescription('This attribute contains the operational attributes for the AtmSignalling component.')
mscAtmIfVptPnniSigOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 2, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfVptPnniIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfVptPnniSigIndex"))
if mibBuilder.loadTexts: mscAtmIfVptPnniSigOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniSigOperEntry.setDescription('An entry in the mscAtmIfVptPnniSigOperTable.')
mscAtmIfVptPnniSigLastTxCauseCode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 2, 12, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptPnniSigLastTxCauseCode.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniSigLastTxCauseCode.setDescription('This attribute indicates the cause code in the last transmitted signalling message that contains the CAUSE information element. The cause code is used to describe the reason for generating certain signalling messages.')
mscAtmIfVptPnniSigLastTxDiagCode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 2, 12, 1, 2), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptPnniSigLastTxDiagCode.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniSigLastTxDiagCode.setDescription('This attribute contains the diagnostic code in the last transmitted signalling message. The diagnostic code is contained in the CAUSE information element and identifies an information element type or timer type. The diagnostic code is present only if a procedural error is detected by the signalling protocol. A diagnostic code is always accompanied by the cause code. If there is no failure, this attribute is set to 0.')
mscAtmIfVptPnniSigLastRxCauseCode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 2, 12, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptPnniSigLastRxCauseCode.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniSigLastRxCauseCode.setDescription('This attribute contains the cause code in the last received signalling message that contains the CAUSE information element. The cause code is used to describe the reason for generating certain signalling messages.')
mscAtmIfVptPnniSigLastRxDiagCode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 2, 12, 1, 4), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptPnniSigLastRxDiagCode.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniSigLastRxDiagCode.setDescription('This attribute contains the diagnostic code in the last received signalling message. The diagnostic code is contained in the CAUSE information element and identifies an information element type or timer type. The diagnostic code is present only if a procedural error is detected by the signalling protocol. A diagnostic code is always accompanied by the cause code. If there is no failure, this attribute is set to 0.')
mscAtmIfVptPnniSigStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 2, 13), )
if mibBuilder.loadTexts: mscAtmIfVptPnniSigStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniSigStatsTable.setDescription('This attribute group contains the statistics associated with the AtmSignalling component.')
mscAtmIfVptPnniSigStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 2, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfVptPnniIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfVptPnniSigIndex"))
if mibBuilder.loadTexts: mscAtmIfVptPnniSigStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniSigStatsEntry.setDescription('An entry in the mscAtmIfVptPnniSigStatsTable.')
mscAtmIfVptPnniSigCurrentConnections = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 2, 13, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptPnniSigCurrentConnections.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptPnniSigCurrentConnections.setDescription('This attribute indicates the total number of currently active connections.')
mscAtmIfVptPnniSigPeakConnections = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 2, 13, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptPnniSigPeakConnections.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniSigPeakConnections.setDescription('This attribute indicates the high water mark of active point-to- point and point-to-multipoint connections.')
mscAtmIfVptPnniSigSuccessfulConnections = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 2, 13, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptPnniSigSuccessfulConnections.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniSigSuccessfulConnections.setDescription('This attribute counts the total number of switched point-to- point and point-to-multipoint connections that were successfully established. The counter wraps to 0 when the maximum value is exceeded.')
mscAtmIfVptPnniSigFailedConnections = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 2, 13, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptPnniSigFailedConnections.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniSigFailedConnections.setDescription('This attribute counts the total number of switched connections that were not successfully established.The counter wraps to 0 when the maximum value is exceeded.')
mscAtmIfVptPnniSigTxPdus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 2, 13, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptPnniSigTxPdus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniSigTxPdus.setDescription('This attribute counts the number of transmitted signalling PDUs.The counter wraps to 0 when the maximum value is exceeded.')
mscAtmIfVptPnniSigRxPdus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 2, 13, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptPnniSigRxPdus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniSigRxPdus.setDescription('This attribute counts the number of received signalling PDUs.The counter wraps to 0 when the maximum value is exceeded.')
mscAtmIfVptPnniSigCurrentPmpConnections = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 2, 13, 1, 7), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptPnniSigCurrentPmpConnections.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniSigCurrentPmpConnections.setDescription('This attribute indicates the number of currently active point-to- multipoint connections.')
mscAtmIfVptPnniSigPeakPmpConnections = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 2, 13, 1, 8), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptPnniSigPeakPmpConnections.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniSigPeakPmpConnections.setDescription('This attribute indicates the high water mark of active point-to- multipoint connections.')
mscAtmIfVptPnniSigSuccessfulPmpConnections = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 2, 13, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptPnniSigSuccessfulPmpConnections.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniSigSuccessfulPmpConnections.setDescription('This attribute counts the total number of switched point-to- multipoint connections that were successfully established. The counter wraps to 0 when the maximum value is exceeded.')
mscAtmIfVptPnniSigFailedPmpConnections = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 2, 13, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptPnniSigFailedPmpConnections.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniSigFailedPmpConnections.setDescription('This attribute counts the number of switched point-to- multipoint connections that were not successfully established.The counter wraps to 0 when the maximum value is exceeded.')
mscAtmIfVptPnniSigNewCurrentConnections = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 2, 13, 1, 11), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptPnniSigNewCurrentConnections.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniSigNewCurrentConnections.setDescription('This attribute indicates the total number of currently active point-to- point and point-to-multipoint connections.')
mscAtmIfVptPnniSigVcd = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 2, 2))
mscAtmIfVptPnniSigVcdRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 2, 2, 1), )
if mibBuilder.loadTexts: mscAtmIfVptPnniSigVcdRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniSigVcdRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfVptPnniSigVcd components.')
mscAtmIfVptPnniSigVcdRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 2, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfVptPnniIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfVptPnniSigIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfVptPnniSigVcdIndex"))
if mibBuilder.loadTexts: mscAtmIfVptPnniSigVcdRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniSigVcdRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfVptPnniSigVcd component.')
mscAtmIfVptPnniSigVcdRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 2, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptPnniSigVcdRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniSigVcdRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfVptPnniSigVcd components. These components can be added and deleted.')
mscAtmIfVptPnniSigVcdComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 2, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptPnniSigVcdComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniSigVcdComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfVptPnniSigVcdStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 2, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptPnniSigVcdStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniSigVcdStorageType.setDescription('This variable represents the storage type value for the mscAtmIfVptPnniSigVcd tables.')
mscAtmIfVptPnniSigVcdIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 2, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscAtmIfVptPnniSigVcdIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniSigVcdIndex.setDescription('This variable represents the index for the mscAtmIfVptPnniSigVcd tables.')
mscAtmIfVptPnniSigVcdProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 2, 2, 10), )
if mibBuilder.loadTexts: mscAtmIfVptPnniSigVcdProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniSigVcdProvTable.setDescription('This group contains the provisionable traffic attributes for a control channel.')
mscAtmIfVptPnniSigVcdProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 2, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfVptPnniIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfVptPnniSigIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfVptPnniSigVcdIndex"))
if mibBuilder.loadTexts: mscAtmIfVptPnniSigVcdProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniSigVcdProvEntry.setDescription('An entry in the mscAtmIfVptPnniSigVcdProvTable.')
mscAtmIfVptPnniSigVcdTrafficDescType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 2, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 6, 7, 8))).clone(namedValues=NamedValues(("n3", 3), ("n6", 6), ("n7", 7), ("n8", 8))).clone('n6')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptPnniSigVcdTrafficDescType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniSigVcdTrafficDescType.setDescription('This attribute specifies the type of traffic management which is applied to both the transmit and receive direction of this connection as defined in the ATM Forum. The trafficDescType determines the number and meaning of the parameters in the trafficDescParm attribute.')
mscAtmIfVptPnniSigVcdAtmServiceCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 2, 2, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("unspecifiedBitRate", 0), ("constantBitRate", 1), ("rtVariableBitRate", 2), ("nrtVariableBitRate", 3))).clone('rtVariableBitRate')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptPnniSigVcdAtmServiceCategory.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniSigVcdAtmServiceCategory.setDescription("This attribute specifies the ATM service category for both directions of the connection. The constantBitRate service category is intended for real time applications, that is those requiring tightly constrained delay and delay variation, as would be appropriate for voice and video applications. The consistent availability of a fixed quantity of bandwidth is considered appropriate for CBR service. Cells which are delayed beyond the value specified by CellTransfer Delay are assumed to be of significantly reduce value to the application. The rtVariableBitRate service category is intended for real time applications, that is those requiring tightly constrained delay and delay variation, as would be appropriate for voice and video applications. Sources are expected to transmit at a rate which varies with time. Equivalently, the source can be described as 'bursty'. Cells which are delayed beyond the value specified by CTD are assumed to be of significantly reduced value to the application. Real time VBR service may support statistical multiplexing of real time sources. The nrtVariableBitRate service category is intended for non-real time applications which have bursty traffic characteristics and which can be characterized in terms of a PCR, SCR, and MBS. For those cells which are transferred within the traffic contract, the application expects a low cell loss ratio. For all connections, it expects a bound on the mean cell transfer delay. Non-real time VBR service may support statistical multiplexing of connections. The unspecifiedBitRate service is intended for non-real time applications; that is, those not requiring tightly constrained delay and delay variation. UBR sources are expected to be bursty. UBR service supports a high degree of statistical multiplexing among sources. UBR service does not specify traffic related service guarantees. No numerical commitments are made with respect to the cell loss ratio experienced by a UBR connection, or as to the cell transfer delay experienced by cells on the connection.")
mscAtmIfVptPnniSigVcdWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 2, 2, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 4095), ValueRangeConstraint(65535, 65535), )).clone(65535)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptPnniSigVcdWeight.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniSigVcdWeight.setDescription("This attribute specifies an override for the weight of this unshaped connection. This attribute is ignored for shaped connections, for ABR connections, for connections on a CQC-based ATM FP and basic VPTs. When the value is set to sameAsCa, the weight is determined by the weight policy attribute under the CA service category component for all but standard VPT VCCs. For standard VPT VCCs, the weight is determined by the VCC's service category, when the value is set to sameAsCa. When this attribute is set to a value from 1 to 4095, that value is used for the weight policy of this connection relative to other connections. For all but standard VPT VCCs, weight policy determines the proportion of transit cell opportunities which are allocated to this connection, compared to other connections in the same service category. For standard VPT VCCs, weight policy determines the proportion of transmit cell opportunities which are allocated to this connection, compared to other connections associated with the VPT. When the value is set to upToQueueLimit, the weight policy is limited only by the txQueueLimit. VALUES ( 0 = upToQueueLimit 65535 = sameAsCa )")
mscAtmIfVptPnniSigVcdQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 2, 2, 10, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4))).clone('n2')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptPnniSigVcdQosClass.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniSigVcdQosClass.setDescription('This attribute specifies the quality of service for both the forward and backward direction for this connection. Class 1 supports a QOS that meets Service Class A performance requirements (Circuit emulation, constant bit rate video). Class 2 supports a QOS that meets Service Class B performance requirements (Variable bit rate audio and video). Class 3 supports a QOS that meets Service Class C performance requirements (Connection-Oriented Data Transfer). Class 4 supports a QOS that meets Service Class D performance requirements (Connectionless Data Transfer). Class 0 is the unspecified bit rate QOS class; no objective is specified for the performance parameters.')
mscAtmIfVptPnniSigVcdTrafficShaping = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 2, 2, 10, 1, 50), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("sameAsCa", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptPnniSigVcdTrafficShaping.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniSigVcdTrafficShaping.setDescription("This attribute specifies whether this connection uses traffic shaping when transmitting traffic to the ATM interface. When sameAsCa is selected, traffic shaping for this connection is based on the trafficShaping attribute of the connection's service category component under the AtmIf CA. If the service category has traffic shaping enabled, then traffic shaping is enabled for the connection. Note that enabling traffic shaping may have no effect under certain cases. These cases are listed in the description of the trafficShaping operational attribute, which is under the Vcc Tm and Vpc Tm components. When disabled is selected, traffic shaping for this connection is disabled.")
mscAtmIfVptPnniSigVcdUnshapedTransmitQueueing = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 2, 2, 10, 1, 60), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3))).clone(namedValues=NamedValues(("common", 1), ("sameAsCa", 3))).clone('sameAsCa')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptPnniSigVcdUnshapedTransmitQueueing.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniSigVcdUnshapedTransmitQueueing.setDescription("This attribute only applies when this connection is unshaped. This attribute specifies the transmit queueing method for this connection if it is unshaped. Refer to the unshapedTransmitQueueing attribute under the AtmIf CA service category subcomponent for more details on the meaning of this attribute. When this attribute is set to sameAsCa, the transmit queueing method for the connection is based on the unshapedTransmitQueueing attribute of the connection's service category component under the ConnectionAdministrator. When this attribute is set to common, transmit traffic on this unshaped connection is destined for the common queue. The value sameAsInterface is for migration from previous software releases, but should no longer be used")
mscAtmIfVptPnniSigVcdUsageParameterControl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 2, 2, 10, 1, 70), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("sameAsCa", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptPnniSigVcdUsageParameterControl.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniSigVcdUsageParameterControl.setDescription("This attribute specifies whether this connection enforces usage parameter control when receiving traffic from the ATM interface. When sameAsCa is selected, UPC for the connection is based on the usageParameterControl attribute of the connection's service category component under the ConnectionAdministrator. If the service category has UPC enabled, then UPC is enabled for the connection. Note that enabling UPC may have no effect under certain cases. These cases are listed in the description of the usageParameterControl operational attribute, which is under the Vcc Tm or Vpc Tm component. When disabled is selected, UPC for this connection is disabled. The value sameAsInterface is for migration from previous software releases, but should no longer be used")
mscAtmIfVptPnniSigVcdTdpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 2, 2, 387), )
if mibBuilder.loadTexts: mscAtmIfVptPnniSigVcdTdpTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniSigVcdTdpTable.setDescription('This attribute is a vector of five traffic parameters whose meanings are defined by the trafficDescType attribute. The values of peak cell rate (PCR), sustained cell rate (SCR) and requested shaping rate are expressed in cell/s. Maximum burst size (MBS) is expressed in cells. CDVT is expressed in microseconds. The values of PCR, SCR, MBS and CDVT are used for connection admission control (CAC). The value of CDVT is only used for connections where the atmServiceCategory is constantBitRate. For all other values of atmServiceCategory, CDVT is ignored. The values of PCR, SCR and requested shaping rate are used to determine the actual shaping rate where traffic shaping is enabled. When trafficDescType is 3, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameter 1 must be non-zero. Parameters 2 and 3 must be zero. When trafficDescType is 6, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 and 1 traffic; parameter 3 represents the MBS for CLP equal to 0 and 1 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameters 1, 2, and 3 must be non-zero. Parameter 1 must be greater than or equal to parameter 2. Parameter 5 must either be zero (unused) or greater than or equal to parameter 2. When trafficDescType is 7, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 with cell discard; parameter 3 represents the MBS for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameters 1, 2, and 3 must be non-zero. Parameter 1 must be greater than or equal to parameter 2. Parameter 5 must either be zero (unused) or greater than or equal to parameter 2. When trafficDescType is 8, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell tagging; parameter 3 represents the MBS for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameters 1, 2, and 3 must be non-zero. Parameter 1 must be greater than or equal to parameter 2. Parameter 5 must either be zero (unused) or greater than or equal to parameter 2. Whenever it is valid for PCR to be specified, parameter 5 may also be used to specify a requested shaping rate. A non-zero value in parameter 5 overrides the value in parameter 1 and is used as the peak cell rate in calculations of CAC and shaping rate. For trafficDescType 3 the traffic is shaped at the next rate less than the PCR. For trafficDescType 6, 7, and 8, the traffic is shaped at the highest available rate which is between PCR and SCR. However, if there is no available shaping rate between PCR and SCR, traffic is shaped at the next rate above the PCR.')
mscAtmIfVptPnniSigVcdTdpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 2, 2, 387, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfVptPnniIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfVptPnniSigIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfVptPnniSigVcdIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfVptPnniSigVcdTdpIndex"))
if mibBuilder.loadTexts: mscAtmIfVptPnniSigVcdTdpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniSigVcdTdpEntry.setDescription('An entry in the mscAtmIfVptPnniSigVcdTdpTable.')
mscAtmIfVptPnniSigVcdTdpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 2, 2, 387, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: mscAtmIfVptPnniSigVcdTdpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniSigVcdTdpIndex.setDescription('This variable represents the mscAtmIfVptPnniSigVcdTdpTable specific index for the mscAtmIfVptPnniSigVcdTdpTable.')
mscAtmIfVptPnniSigVcdTdpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 2, 2, 387, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptPnniSigVcdTdpValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniSigVcdTdpValue.setDescription('This variable represents an individual value for the mscAtmIfVptPnniSigVcdTdpTable.')
mscAtmIfVptPnniRcc = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 3))
mscAtmIfVptPnniRccRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 3, 1), )
if mibBuilder.loadTexts: mscAtmIfVptPnniRccRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniRccRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfVptPnniRcc components.')
mscAtmIfVptPnniRccRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 3, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfVptPnniIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfVptPnniRccIndex"))
if mibBuilder.loadTexts: mscAtmIfVptPnniRccRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniRccRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfVptPnniRcc component.')
mscAtmIfVptPnniRccRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 3, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptPnniRccRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniRccRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfVptPnniRcc components. These components cannot be added nor deleted.')
mscAtmIfVptPnniRccComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptPnniRccComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniRccComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfVptPnniRccStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptPnniRccStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniRccStorageType.setDescription('This variable represents the storage type value for the mscAtmIfVptPnniRcc tables.')
mscAtmIfVptPnniRccIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscAtmIfVptPnniRccIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniRccIndex.setDescription('This variable represents the index for the mscAtmIfVptPnniRcc tables.')
mscAtmIfVptPnniRccProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 3, 10), )
if mibBuilder.loadTexts: mscAtmIfVptPnniRccProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniRccProvTable.setDescription('This group contains the generic provisionable attributes of an Rcc component.')
mscAtmIfVptPnniRccProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 3, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfVptPnniIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfVptPnniRccIndex"))
if mibBuilder.loadTexts: mscAtmIfVptPnniRccProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniRccProvEntry.setDescription('An entry in the mscAtmIfVptPnniRccProvTable.')
mscAtmIfVptPnniRccVci = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 3, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(18)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptPnniRccVci.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniRccVci.setDescription('This attribute specifies the VCI for the Routing Control Channel (RCC). It is not recommended that the value be changed from the default of 18 unless absolutely necessary. If a different VCI is specified, ensure that the RCC at the far end is provisioned to use the same VCI, otherwise the RCC will not come up.')
mscAtmIfVptPnniRccHlParmsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 3, 11), )
if mibBuilder.loadTexts: mscAtmIfVptPnniRccHlParmsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniRccHlParmsTable.setDescription('This group contains the provisionable Hello protocol parameters for an Rcc component.')
mscAtmIfVptPnniRccHlParmsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 3, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfVptPnniIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfVptPnniRccIndex"))
if mibBuilder.loadTexts: mscAtmIfVptPnniRccHlParmsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniRccHlParmsEntry.setDescription('An entry in the mscAtmIfVptPnniRccHlParmsTable.')
mscAtmIfVptPnniRccHelloHoldDown = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 3, 11, 1, 1), FixedPoint1().subtype(subtypeSpec=ValueRangeConstraint(0, 655350))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptPnniRccHelloHoldDown.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniRccHelloHoldDown.setDescription('This attribute is used to limit the rate at which this node sends out Hello packets. Specifically, it specifies the minimum time between successive Hellos. A value of 0 specifies that the value provisioned for the helloHoldDown attribute of the ARtg Pnni component should be used.')
mscAtmIfVptPnniRccHelloInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 3, 11, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptPnniRccHelloInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniRccHelloInterval.setDescription('This attribute specifies the duration of the Hello Timer. Every helloInterval seconds, this node will send out a Hello packet to the neighbor node, subject to the helloHoldDown timer having expired at least once since the last Hello packet was sent. A value of 0 specifies that the value provisioned for the helloInterval attribute of the ARtg Pnni component should be used.')
mscAtmIfVptPnniRccHelloInactivityFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 3, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptPnniRccHelloInactivityFactor.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniRccHelloInactivityFactor.setDescription('This attribute specifies the number of Hello intervals allowed to pass without receiving a Hello from the neighbor node, before an attempt is made to re-stage. The hello inactivity timer is enabled in the oneWayInside, twoWayInside, oneWayOutside, twoWayOutside and commonOutside hello states (see the helloState attribute on the Rcc component for a description of these states). Note that the value for the Hello interval used in the calculation is the one specified in the Hello packet from the neighbor node. A value of 0 specifies that the value provisioned for the helloInactivityFactor attribute of the ARtg Pnni component should be used. DESCRIPTION')
mscAtmIfVptPnniRccStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 3, 12), )
if mibBuilder.loadTexts: mscAtmIfVptPnniRccStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniRccStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscAtmIfVptPnniRccStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 3, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfVptPnniIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfVptPnniRccIndex"))
if mibBuilder.loadTexts: mscAtmIfVptPnniRccStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniRccStateEntry.setDescription('An entry in the mscAtmIfVptPnniRccStateTable.')
mscAtmIfVptPnniRccAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 3, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptPnniRccAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniRccAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscAtmIfVptPnniRccOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 3, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptPnniRccOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniRccOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscAtmIfVptPnniRccUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 3, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptPnniRccUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniRccUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscAtmIfVptPnniRccOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 3, 13), )
if mibBuilder.loadTexts: mscAtmIfVptPnniRccOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniRccOperTable.setDescription('This group contains the operational attributes for an Rcc component.')
mscAtmIfVptPnniRccOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 3, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfVptPnniIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfVptPnniRccIndex"))
if mibBuilder.loadTexts: mscAtmIfVptPnniRccOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniRccOperEntry.setDescription('An entry in the mscAtmIfVptPnniRccOperTable.')
mscAtmIfVptPnniRccType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 3, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 0), ("lowestLevelHorizLink", 1), ("lowestLevelOutsideLink", 2), ("horizontalLinkToLGN", 3), ("uplink", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptPnniRccType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniRccType.setDescription('This attribute indicates the role of this link in the PNNI hierarchy. The following values are possible: unknown: the Hello protocol has not yet determined the role of the link. lowestLevelHorizLink: the link is a horizontal link between two lowest level nodes. lowestLevelOutsideLink: the link is an outside link between two border nodes. horizontalLinkToLgn: the link is a horizontal link to a Logical Group Node (LGN). uplink: the link is a uplink to a higher level LGN.')
mscAtmIfVptPnniRccNegotiatedVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 3, 13, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("unsupported", 0), ("version1point0", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptPnniRccNegotiatedVersion.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniRccNegotiatedVersion.setDescription('This attribute indicates the PNNI version negotiated with the neighbor node.')
mscAtmIfVptPnniRccHelloState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 3, 13, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("notApplicable", 0), ("down", 1), ("attempt", 2), ("oneWayInside", 3), ("twoWayInside", 4), ("oneWayOutside", 5), ("twoWayOutside", 6), ("commonOutside", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptPnniRccHelloState.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniRccHelloState.setDescription("This attribute indicates the state of the Hello protocol exchange over this link. The following are the possible values for this attribute: down: the link is down; no PNNI routing packets will be sent over or received over such a link. This is the initial state of the Hello Finite State Machine, and can also be reached when lower-level protocols have indicated that the link is not usable. attempt: no Hello packets or Hello packets, with mismatch information, have been received recently from the neighbor. Attempts are made to contact the neighbor node by sending out Hello packets every helloInterval seconds. oneWayInside: Hello packets have been recently received from the neighbor and it has been established that both nodes are members of the same peer group, but the remote node ID and remote port ID in the neighbor's Hello packets were set to zero. A Hello packet is sent to the neighbor and the Hello timer is restarted. twoWayInside: Bidirectional communication over this link between this node and the neighbor node has been achieved. oneWayOutside: Hello packets have been recently received from the neighbor and it has been established that both nodes are members of a different peer group, but the remote node ID and remote port ID in the neighbor's Hello packets were set to zero. twoWayOutside: Hellos have recently been received from the neighbor indicating that the neighbor node belongs to a different peer group. The correct remote node ID and remote port ID fields were included in the Hello packet, but the nodal hierarchy list did not include any common peer group. This state can also be reached if a hierarchy mismatch occurs while in the commonOutside state. commonOutside: A common level of the routing hierarchy has been found, in addition to achieving full bi-directional communication between the two nodes.")
mscAtmIfVptPnniRccRemoteNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 3, 13, 1, 4), HexString().subtype(subtypeSpec=ValueSizeConstraint(22, 22)).setFixedLength(22)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptPnniRccRemoteNodeId.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniRccRemoteNodeId.setDescription("This attribute indicates the neighbor node's node id.")
mscAtmIfVptPnniRccRemotePortId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 3, 13, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptPnniRccRemotePortId.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniRccRemotePortId.setDescription("This attribute indicates the neighbor node's port id.")
mscAtmIfVptPnniRccStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 3, 14), )
if mibBuilder.loadTexts: mscAtmIfVptPnniRccStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniRccStatsTable.setDescription('This group contains the statistical attributes for an Rcc component.')
mscAtmIfVptPnniRccStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 3, 14, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfVptPnniIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfVptPnniRccIndex"))
if mibBuilder.loadTexts: mscAtmIfVptPnniRccStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniRccStatsEntry.setDescription('An entry in the mscAtmIfVptPnniRccStatsTable.')
mscAtmIfVptPnniRccHelloPacketsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 3, 14, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptPnniRccHelloPacketsRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniRccHelloPacketsRx.setDescription('This attribute counts the total number of Hello packets received across this RCC, including bad and mismatched Hello packets. The counter wraps when it exceeds the maximum value.')
mscAtmIfVptPnniRccHelloPacketsTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 3, 14, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptPnniRccHelloPacketsTx.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniRccHelloPacketsTx.setDescription('This attribute counts the total number of Hello packets transmitted across this RCC. The counter wraps when it exceeds the maximum value.')
mscAtmIfVptPnniRccMismatchedHelloPacketsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 3, 14, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptPnniRccMismatchedHelloPacketsRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniRccMismatchedHelloPacketsRx.setDescription('This attribute counts the total number of mismatched Hello packets received over this RCC. The counter wraps when it exceeds the maximum value.')
mscAtmIfVptPnniRccBadHelloPacketsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 3, 14, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptPnniRccBadHelloPacketsRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniRccBadHelloPacketsRx.setDescription('This attribute counts the total number of bad Hello packets received over this RCC. The counter wraps when it exceeds the maximum value.')
mscAtmIfVptPnniRccVcd = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 3, 2))
mscAtmIfVptPnniRccVcdRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 3, 2, 1), )
if mibBuilder.loadTexts: mscAtmIfVptPnniRccVcdRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniRccVcdRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfVptPnniRccVcd components.')
mscAtmIfVptPnniRccVcdRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 3, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfVptPnniIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfVptPnniRccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfVptPnniRccVcdIndex"))
if mibBuilder.loadTexts: mscAtmIfVptPnniRccVcdRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniRccVcdRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfVptPnniRccVcd component.')
mscAtmIfVptPnniRccVcdRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 3, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptPnniRccVcdRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniRccVcdRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfVptPnniRccVcd components. These components can be added and deleted.')
mscAtmIfVptPnniRccVcdComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 3, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptPnniRccVcdComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniRccVcdComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfVptPnniRccVcdStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 3, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptPnniRccVcdStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniRccVcdStorageType.setDescription('This variable represents the storage type value for the mscAtmIfVptPnniRccVcd tables.')
mscAtmIfVptPnniRccVcdIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 3, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscAtmIfVptPnniRccVcdIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniRccVcdIndex.setDescription('This variable represents the index for the mscAtmIfVptPnniRccVcd tables.')
mscAtmIfVptPnniRccVcdProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 3, 2, 10), )
if mibBuilder.loadTexts: mscAtmIfVptPnniRccVcdProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniRccVcdProvTable.setDescription('This group contains the provisionable traffic attributes for a control channel.')
mscAtmIfVptPnniRccVcdProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 3, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfVptPnniIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfVptPnniRccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfVptPnniRccVcdIndex"))
if mibBuilder.loadTexts: mscAtmIfVptPnniRccVcdProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniRccVcdProvEntry.setDescription('An entry in the mscAtmIfVptPnniRccVcdProvTable.')
mscAtmIfVptPnniRccVcdTrafficDescType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 3, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 6, 7, 8))).clone(namedValues=NamedValues(("n3", 3), ("n6", 6), ("n7", 7), ("n8", 8))).clone('n6')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptPnniRccVcdTrafficDescType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniRccVcdTrafficDescType.setDescription('This attribute specifies the type of traffic management which is applied to both the transmit and receive direction of this connection as defined in the ATM Forum. The trafficDescType determines the number and meaning of the parameters in the trafficDescParm attribute.')
mscAtmIfVptPnniRccVcdAtmServiceCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 3, 2, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("unspecifiedBitRate", 0), ("constantBitRate", 1), ("rtVariableBitRate", 2), ("nrtVariableBitRate", 3))).clone('rtVariableBitRate')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptPnniRccVcdAtmServiceCategory.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniRccVcdAtmServiceCategory.setDescription("This attribute specifies the ATM service category for both directions of the connection. The constantBitRate service category is intended for real time applications, that is those requiring tightly constrained delay and delay variation, as would be appropriate for voice and video applications. The consistent availability of a fixed quantity of bandwidth is considered appropriate for CBR service. Cells which are delayed beyond the value specified by CellTransfer Delay are assumed to be of significantly reduce value to the application. The rtVariableBitRate service category is intended for real time applications, that is those requiring tightly constrained delay and delay variation, as would be appropriate for voice and video applications. Sources are expected to transmit at a rate which varies with time. Equivalently, the source can be described as 'bursty'. Cells which are delayed beyond the value specified by CTD are assumed to be of significantly reduced value to the application. Real time VBR service may support statistical multiplexing of real time sources. The nrtVariableBitRate service category is intended for non-real time applications which have bursty traffic characteristics and which can be characterized in terms of a PCR, SCR, and MBS. For those cells which are transferred within the traffic contract, the application expects a low cell loss ratio. For all connections, it expects a bound on the mean cell transfer delay. Non-real time VBR service may support statistical multiplexing of connections. The unspecifiedBitRate service is intended for non-real time applications; that is, those not requiring tightly constrained delay and delay variation. UBR sources are expected to be bursty. UBR service supports a high degree of statistical multiplexing among sources. UBR service does not specify traffic related service guarantees. No numerical commitments are made with respect to the cell loss ratio experienced by a UBR connection, or as to the cell transfer delay experienced by cells on the connection.")
mscAtmIfVptPnniRccVcdWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 3, 2, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 4095), ValueRangeConstraint(65535, 65535), )).clone(65535)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptPnniRccVcdWeight.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniRccVcdWeight.setDescription("This attribute specifies an override for the weight of this unshaped connection. This attribute is ignored for shaped connections, for ABR connections, for connections on a CQC-based ATM FP and basic VPTs. When the value is set to sameAsCa, the weight is determined by the weight policy attribute under the CA service category component for all but standard VPT VCCs. For standard VPT VCCs, the weight is determined by the VCC's service category, when the value is set to sameAsCa. When this attribute is set to a value from 1 to 4095, that value is used for the weight policy of this connection relative to other connections. For all but standard VPT VCCs, weight policy determines the proportion of transit cell opportunities which are allocated to this connection, compared to other connections in the same service category. For standard VPT VCCs, weight policy determines the proportion of transmit cell opportunities which are allocated to this connection, compared to other connections associated with the VPT. When the value is set to upToQueueLimit, the weight policy is limited only by the txQueueLimit. VALUES ( 0 = upToQueueLimit 65535 = sameAsCa )")
mscAtmIfVptPnniRccVcdQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 3, 2, 10, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4))).clone('n2')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptPnniRccVcdQosClass.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniRccVcdQosClass.setDescription('This attribute specifies the quality of service for both the forward and backward direction for this connection. Class 1 supports a QOS that meets Service Class A performance requirements (Circuit emulation, constant bit rate video). Class 2 supports a QOS that meets Service Class B performance requirements (Variable bit rate audio and video). Class 3 supports a QOS that meets Service Class C performance requirements (Connection-Oriented Data Transfer). Class 4 supports a QOS that meets Service Class D performance requirements (Connectionless Data Transfer). Class 0 is the unspecified bit rate QOS class; no objective is specified for the performance parameters.')
mscAtmIfVptPnniRccVcdTrafficShaping = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 3, 2, 10, 1, 50), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("sameAsCa", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptPnniRccVcdTrafficShaping.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniRccVcdTrafficShaping.setDescription("This attribute specifies whether this connection uses traffic shaping when transmitting traffic to the ATM interface. When sameAsCa is selected, traffic shaping for this connection is based on the trafficShaping attribute of the connection's service category component under the AtmIf CA. If the service category has traffic shaping enabled, then traffic shaping is enabled for the connection. Note that enabling traffic shaping may have no effect under certain cases. These cases are listed in the description of the trafficShaping operational attribute, which is under the Vcc Tm and Vpc Tm components. When disabled is selected, traffic shaping for this connection is disabled.")
mscAtmIfVptPnniRccVcdUnshapedTransmitQueueing = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 3, 2, 10, 1, 60), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3))).clone(namedValues=NamedValues(("common", 1), ("sameAsCa", 3))).clone('sameAsCa')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptPnniRccVcdUnshapedTransmitQueueing.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniRccVcdUnshapedTransmitQueueing.setDescription("This attribute only applies when this connection is unshaped. This attribute specifies the transmit queueing method for this connection if it is unshaped. Refer to the unshapedTransmitQueueing attribute under the AtmIf CA service category subcomponent for more details on the meaning of this attribute. When this attribute is set to sameAsCa, the transmit queueing method for the connection is based on the unshapedTransmitQueueing attribute of the connection's service category component under the ConnectionAdministrator. When this attribute is set to common, transmit traffic on this unshaped connection is destined for the common queue. The value sameAsInterface is for migration from previous software releases, but should no longer be used")
mscAtmIfVptPnniRccVcdUsageParameterControl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 3, 2, 10, 1, 70), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("sameAsCa", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptPnniRccVcdUsageParameterControl.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniRccVcdUsageParameterControl.setDescription("This attribute specifies whether this connection enforces usage parameter control when receiving traffic from the ATM interface. When sameAsCa is selected, UPC for the connection is based on the usageParameterControl attribute of the connection's service category component under the ConnectionAdministrator. If the service category has UPC enabled, then UPC is enabled for the connection. Note that enabling UPC may have no effect under certain cases. These cases are listed in the description of the usageParameterControl operational attribute, which is under the Vcc Tm or Vpc Tm component. When disabled is selected, UPC for this connection is disabled. The value sameAsInterface is for migration from previous software releases, but should no longer be used")
mscAtmIfVptPnniRccVcdTdpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 3, 2, 387), )
if mibBuilder.loadTexts: mscAtmIfVptPnniRccVcdTdpTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniRccVcdTdpTable.setDescription('This attribute is a vector of five traffic parameters whose meanings are defined by the trafficDescType attribute. The values of peak cell rate (PCR), sustained cell rate (SCR) and requested shaping rate are expressed in cell/s. Maximum burst size (MBS) is expressed in cells. CDVT is expressed in microseconds. The values of PCR, SCR, MBS and CDVT are used for connection admission control (CAC). The value of CDVT is only used for connections where the atmServiceCategory is constantBitRate. For all other values of atmServiceCategory, CDVT is ignored. The values of PCR, SCR and requested shaping rate are used to determine the actual shaping rate where traffic shaping is enabled. When trafficDescType is 3, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameter 1 must be non-zero. Parameters 2 and 3 must be zero. When trafficDescType is 6, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 and 1 traffic; parameter 3 represents the MBS for CLP equal to 0 and 1 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameters 1, 2, and 3 must be non-zero. Parameter 1 must be greater than or equal to parameter 2. Parameter 5 must either be zero (unused) or greater than or equal to parameter 2. When trafficDescType is 7, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 with cell discard; parameter 3 represents the MBS for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameters 1, 2, and 3 must be non-zero. Parameter 1 must be greater than or equal to parameter 2. Parameter 5 must either be zero (unused) or greater than or equal to parameter 2. When trafficDescType is 8, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell tagging; parameter 3 represents the MBS for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameters 1, 2, and 3 must be non-zero. Parameter 1 must be greater than or equal to parameter 2. Parameter 5 must either be zero (unused) or greater than or equal to parameter 2. Whenever it is valid for PCR to be specified, parameter 5 may also be used to specify a requested shaping rate. A non-zero value in parameter 5 overrides the value in parameter 1 and is used as the peak cell rate in calculations of CAC and shaping rate. For trafficDescType 3 the traffic is shaped at the next rate less than the PCR. For trafficDescType 6, 7, and 8, the traffic is shaped at the highest available rate which is between PCR and SCR. However, if there is no available shaping rate between PCR and SCR, traffic is shaped at the next rate above the PCR.')
mscAtmIfVptPnniRccVcdTdpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 3, 2, 387, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfVptPnniIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfVptPnniRccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfVptPnniRccVcdIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfVptPnniRccVcdTdpIndex"))
if mibBuilder.loadTexts: mscAtmIfVptPnniRccVcdTdpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniRccVcdTdpEntry.setDescription('An entry in the mscAtmIfVptPnniRccVcdTdpTable.')
mscAtmIfVptPnniRccVcdTdpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 3, 2, 387, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: mscAtmIfVptPnniRccVcdTdpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniRccVcdTdpIndex.setDescription('This variable represents the mscAtmIfVptPnniRccVcdTdpTable specific index for the mscAtmIfVptPnniRccVcdTdpTable.')
mscAtmIfVptPnniRccVcdTdpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 3, 2, 387, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptPnniRccVcdTdpValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniRccVcdTdpValue.setDescription('This variable represents an individual value for the mscAtmIfVptPnniRccVcdTdpTable.')
mscAtmIfVptPnniAddr = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 4))
mscAtmIfVptPnniAddrRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 4, 1), )
if mibBuilder.loadTexts: mscAtmIfVptPnniAddrRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniAddrRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfVptPnniAddr components.')
mscAtmIfVptPnniAddrRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 4, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfVptPnniIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfVptPnniAddrAddressIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfVptPnniAddrAddressTypeIndex"))
if mibBuilder.loadTexts: mscAtmIfVptPnniAddrRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniAddrRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfVptPnniAddr component.')
mscAtmIfVptPnniAddrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 4, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptPnniAddrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniAddrRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfVptPnniAddr components. These components can be added and deleted.')
mscAtmIfVptPnniAddrComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptPnniAddrComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniAddrComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfVptPnniAddrStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptPnniAddrStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniAddrStorageType.setDescription('This variable represents the storage type value for the mscAtmIfVptPnniAddr tables.')
mscAtmIfVptPnniAddrAddressIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 4, 1, 1, 10), AsciiStringIndex().subtype(subtypeSpec=ValueSizeConstraint(1, 40)))
if mibBuilder.loadTexts: mscAtmIfVptPnniAddrAddressIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniAddrAddressIndex.setDescription('This variable represents an index for the mscAtmIfVptPnniAddr tables.')
mscAtmIfVptPnniAddrAddressTypeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 4, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("primary", 0), ("alternate", 1), ("registered", 2), ("default", 3))))
if mibBuilder.loadTexts: mscAtmIfVptPnniAddrAddressTypeIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniAddrAddressTypeIndex.setDescription('This variable represents an index for the mscAtmIfVptPnniAddr tables.')
mscAtmIfVptPnniAddrOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 4, 10), )
if mibBuilder.loadTexts: mscAtmIfVptPnniAddrOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniAddrOperTable.setDescription('This attribute group contains the operational attributes for the Address component.')
mscAtmIfVptPnniAddrOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 4, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfVptPnniIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfVptPnniAddrAddressIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfVptPnniAddrAddressTypeIndex"))
if mibBuilder.loadTexts: mscAtmIfVptPnniAddrOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniAddrOperEntry.setDescription('An entry in the mscAtmIfVptPnniAddrOperTable.')
mscAtmIfVptPnniAddrScope = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 4, 10, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 104))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptPnniAddrScope.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniAddrScope.setDescription('This attribute indicates the scope of the ATM address, which is the highest level to which this address will be advertised in the PNNI hierarchy. If no PnniInfo subcomponent has been provisioned, then the scope will default to the level of this node in the PNNI hierarchy. If this node does not participate in a PNNI hierarchy, then this attribute will have the value of -1.')
mscAtmIfVptPnniAddrReachability = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 4, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("internal", 0), ("exterior", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptPnniAddrReachability.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniAddrReachability.setDescription('This attribute indicates whether the address is internal or exterior. An internal reachable address is an address of a destination that is directly attached to the logical node advertising the address. An exterior reachable address is an address that can be reached through a PNNI routing domain, but which is not located in that PNNI routing domain.')
mscAtmIfVptPnniAddrTermSP = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 4, 2))
mscAtmIfVptPnniAddrTermSPRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 4, 2, 1), )
if mibBuilder.loadTexts: mscAtmIfVptPnniAddrTermSPRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniAddrTermSPRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfVptPnniAddrTermSP components.')
mscAtmIfVptPnniAddrTermSPRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 4, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfVptPnniIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfVptPnniAddrAddressIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfVptPnniAddrAddressTypeIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfVptPnniAddrTermSPIndex"))
if mibBuilder.loadTexts: mscAtmIfVptPnniAddrTermSPRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniAddrTermSPRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfVptPnniAddrTermSP component.')
mscAtmIfVptPnniAddrTermSPRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 4, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptPnniAddrTermSPRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniAddrTermSPRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfVptPnniAddrTermSP components. These components can be added and deleted.')
mscAtmIfVptPnniAddrTermSPComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 4, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptPnniAddrTermSPComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniAddrTermSPComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfVptPnniAddrTermSPStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 4, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptPnniAddrTermSPStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniAddrTermSPStorageType.setDescription('This variable represents the storage type value for the mscAtmIfVptPnniAddrTermSP tables.')
mscAtmIfVptPnniAddrTermSPIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 4, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscAtmIfVptPnniAddrTermSPIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniAddrTermSPIndex.setDescription('This variable represents the index for the mscAtmIfVptPnniAddrTermSP tables.')
mscAtmIfVptPnniAddrPnniInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 4, 3))
mscAtmIfVptPnniAddrPnniInfoRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 4, 3, 1), )
if mibBuilder.loadTexts: mscAtmIfVptPnniAddrPnniInfoRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniAddrPnniInfoRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfVptPnniAddrPnniInfo components.')
mscAtmIfVptPnniAddrPnniInfoRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 4, 3, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfVptPnniIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfVptPnniAddrAddressIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfVptPnniAddrAddressTypeIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfVptPnniAddrPnniInfoIndex"))
if mibBuilder.loadTexts: mscAtmIfVptPnniAddrPnniInfoRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniAddrPnniInfoRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfVptPnniAddrPnniInfo component.')
mscAtmIfVptPnniAddrPnniInfoRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 4, 3, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptPnniAddrPnniInfoRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniAddrPnniInfoRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfVptPnniAddrPnniInfo components. These components can be added and deleted.')
mscAtmIfVptPnniAddrPnniInfoComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 4, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptPnniAddrPnniInfoComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniAddrPnniInfoComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfVptPnniAddrPnniInfoStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 4, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptPnniAddrPnniInfoStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniAddrPnniInfoStorageType.setDescription('This variable represents the storage type value for the mscAtmIfVptPnniAddrPnniInfo tables.')
mscAtmIfVptPnniAddrPnniInfoIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 4, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscAtmIfVptPnniAddrPnniInfoIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniAddrPnniInfoIndex.setDescription('This variable represents the index for the mscAtmIfVptPnniAddrPnniInfo tables.')
mscAtmIfVptPnniAddrPnniInfoProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 4, 3, 10), )
if mibBuilder.loadTexts: mscAtmIfVptPnniAddrPnniInfoProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniAddrPnniInfoProvTable.setDescription('This attribute group contains the provisioned attributes relating to PNNI for a PnniInfo component.')
mscAtmIfVptPnniAddrPnniInfoProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 4, 3, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfVptPnniIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfVptPnniAddrAddressIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfVptPnniAddrAddressTypeIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfVptPnniAddrPnniInfoIndex"))
if mibBuilder.loadTexts: mscAtmIfVptPnniAddrPnniInfoProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniAddrPnniInfoProvEntry.setDescription('An entry in the mscAtmIfVptPnniAddrPnniInfoProvTable.')
mscAtmIfVptPnniAddrPnniInfoScope = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 4, 3, 10, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 104)).clone(-1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptPnniAddrPnniInfoScope.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniAddrPnniInfoScope.setDescription('This attribute specifies the scope of the ATM address, which is the highest level up to which this address will be advertised in the PNNI hierarchy. The scope must be set to a value numerically less than or equal to the level of the lowest level peer group containing this node. Setting the scope to 0 will cause the address to be advertised globally within this PNNI routing domain.')
mscAtmIfVptPnniAddrPnniInfoReachability = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 7, 4, 3, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("internal", 0), ("exterior", 1))).clone('internal')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptPnniAddrPnniInfoReachability.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptPnniAddrPnniInfoReachability.setDescription('This attribute indicates whether the address is internal or exterior. An internal reachable address is an address of a destination that is directly attached to the logical node advertising the address. An exterior reachable address is an address that can be reached through a PNNI routing domain, but which is not located in that PNNI routing domain.')
mscAtmIfPnni = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96))
mscAtmIfPnniRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 1), )
if mibBuilder.loadTexts: mscAtmIfPnniRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfPnni components.')
mscAtmIfPnniRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfPnniIndex"))
if mibBuilder.loadTexts: mscAtmIfPnniRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfPnni component.')
mscAtmIfPnniRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfPnniRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfPnni components. These components can be added and deleted.')
mscAtmIfPnniComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfPnniComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfPnniStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfPnniStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniStorageType.setDescription('This variable represents the storage type value for the mscAtmIfPnni tables.')
mscAtmIfPnniIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscAtmIfPnniIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniIndex.setDescription('This variable represents the index for the mscAtmIfPnni tables.')
mscAtmIfPnniProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 10), )
if mibBuilder.loadTexts: mscAtmIfPnniProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniProvTable.setDescription('This group contains the provisionable attributes for the Pnni component.')
mscAtmIfPnniProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfPnniIndex"))
if mibBuilder.loadTexts: mscAtmIfPnniProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniProvEntry.setDescription('An entry in the mscAtmIfPnniProvTable.')
mscAtmIfPnniSoftPvcRetryPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(20, 999999)).clone(60)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfPnniSoftPvcRetryPeriod.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfPnniSoftPvcRetryPeriod.setDescription('This attribute represents the time in seconds to wait between call setup retries. The resolution is to the nearest 10 seconds. This attribute has been obsoleted and is replaced by the softPvpAndPvcRetryPeriod attribute.')
mscAtmIfPnniSoftPvpAndPvcRetryPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(20, 999999)).clone(60)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfPnniSoftPvpAndPvcRetryPeriod.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniSoftPvpAndPvcRetryPeriod.setDescription('This attribute represents the time in seconds to wait between soft PVP or soft PVC call setup retries. The resolution is to the nearest 10 seconds.')
mscAtmIfPnniSoftPvpAndPvcHoldOffTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(50, 20000), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfPnniSoftPvpAndPvcHoldOffTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniSoftPvpAndPvcHoldOffTime.setDescription('This attribute specifies how long to hold off retries following a release or the connection. The resolution is to the nearest 50 ms.')
mscAtmIfPnniAdminWeightsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 11), )
if mibBuilder.loadTexts: mscAtmIfPnniAdminWeightsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniAdminWeightsTable.setDescription('This group contains the provisionable administrative weights for the Pnni component. These weights will be used by Generic Connection Admission Control (GCAC) if administrative weight is the selected optimization criterion.')
mscAtmIfPnniAdminWeightsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfPnniIndex"))
if mibBuilder.loadTexts: mscAtmIfPnniAdminWeightsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniAdminWeightsEntry.setDescription('An entry in the mscAtmIfPnniAdminWeightsTable.')
mscAtmIfPnniCbrWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 11, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(5040)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfPnniCbrWeight.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniCbrWeight.setDescription('This attribute specifies the administrative weight assigned for setting up switched calls with a service category of Constant Bit Rate (CBR) for this PNNI interface. The value specified will be used by Generic Connection Admission Control (GCAC) if administrative weight is the selected optimization criterion; the higher the value, the less desirable the link will be in path selection.')
mscAtmIfPnniRtVbrWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 11, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(5040)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfPnniRtVbrWeight.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniRtVbrWeight.setDescription('This attribute specifies the administrative weight assigned for setting up switched calls with a service category of Real-Time Variable Bit Rate (RT-VBR) for this PNNI interface. The value specified will be used by Generic Connection Admission Control (GCAC) if administrative weight is the selected optimization criterion; the higher the value, the less desirable the link will be in path selection.')
mscAtmIfPnniNrtVbrWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(5040)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfPnniNrtVbrWeight.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniNrtVbrWeight.setDescription('This attribute specifies the administrative weight assigned for setting up switched calls with a service category of Non Real-Time Variable Bit Rate (NRT-VBR) for this PNNI interface. The value specified will be used by Generic Connection Admission Control (GCAC) if administrative weight is the selected optimization criterion; the higher the value, the less desirable the link will be in path selection.')
mscAtmIfPnniUbrWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 11, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(5040)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfPnniUbrWeight.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniUbrWeight.setDescription('This attribute specifies the administrative weight assigned for setting up switched calls with a service category of Unspecified Bit Rate (UBR) for this PNNI interface. The value specified will be used by Generic Connection Admission Control (GCAC) if administrative weight is the selected optimization criterion; the higher the value, the less desirable the link will be in path selection.')
mscAtmIfPnniAcctOptTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 12), )
if mibBuilder.loadTexts: mscAtmIfPnniAcctOptTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniAcctOptTable.setDescription('This group contains the provisionable attributes for accounting.')
mscAtmIfPnniAcctOptEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfPnniIndex"))
if mibBuilder.loadTexts: mscAtmIfPnniAcctOptEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniAcctOptEntry.setDescription('An entry in the mscAtmIfPnniAcctOptTable.')
mscAtmIfPnniAccountCollection = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 12, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfPnniAccountCollection.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniAccountCollection.setDescription('This attribute is used to turn accounting on or off for SVC and SPVC connections. It also specifies the reason(s) for which accounting data is collected: billing, test, study, audit, or force. If the set of reasons is not empty then accounting records will be generated by this interface in the following situations: - on a TODA changeover if TODA is enabled; - every 12 hours (per connection) if TODA is disabled; - on every call clear (a call record with final cell counts). If none of the reasons is present, then accounting will be suppressed. The reason for collection is recorded in the accounting record, in the attribute callingCollectReason or calledCollectReason as appropriate. Description of bits: bill(0) test(1) study(2) audit(3) force(4)')
mscAtmIfPnniAccountConnectionType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("origTerm", 0), ("intermediate", 1))).clone('intermediate')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfPnniAccountConnectionType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniAccountConnectionType.setDescription('This attribute specifies whether accounting records generated by this interface should be marked as originating, terminating or intermediate. This attribute, in combination with the direction of the call, determines the value of attribute connPointType of the accounting record and may be used by downstream accounting processes to correlate the records. If the value is origTerm then records generated for incoming calls will be marked as originating and records generated for outgoing calls will be marked as terminating. If the value is intermediate then records generated for all calls will be marked as intermediate.')
mscAtmIfPnniAccountClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 12, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfPnniAccountClass.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniAccountClass.setDescription('This attribute specifies the accounting class associated with the interface. Its meaning is determined by the network operator. Its value is simply recorded in the accounting records generated by this interface, in the attribute callingServiceType or calledServiceType as appropriate.')
mscAtmIfPnniServiceExchange = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 12, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfPnniServiceExchange.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniServiceExchange.setDescription('This attribute specifies the data service exchange associated with this interface. Its meaning is determined by the network operator. Its value is simply recorded in the accounting records generated by this interface, in the attribute callingDse or calledDse as appropriate.')
mscAtmIfPnniOperationalTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 13), )
if mibBuilder.loadTexts: mscAtmIfPnniOperationalTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniOperationalTable.setDescription('This group contains the operational attributes for a Pnni component.')
mscAtmIfPnniOperationalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfPnniIndex"))
if mibBuilder.loadTexts: mscAtmIfPnniOperationalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniOperationalEntry.setDescription('An entry in the mscAtmIfPnniOperationalTable.')
mscAtmIfPnniPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 13, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfPnniPortId.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniPortId.setDescription("This attribute indicates the port id of the PNNI interface, which is the parent AtmIf's instance number.")
mscAtmIfPnniSig = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 2))
mscAtmIfPnniSigRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 2, 1), )
if mibBuilder.loadTexts: mscAtmIfPnniSigRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniSigRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfPnniSig components.')
mscAtmIfPnniSigRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfPnniIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfPnniSigIndex"))
if mibBuilder.loadTexts: mscAtmIfPnniSigRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniSigRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfPnniSig component.')
mscAtmIfPnniSigRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfPnniSigRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniSigRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfPnniSig components. These components cannot be added nor deleted.')
mscAtmIfPnniSigComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfPnniSigComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniSigComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfPnniSigStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfPnniSigStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniSigStorageType.setDescription('This variable represents the storage type value for the mscAtmIfPnniSig tables.')
mscAtmIfPnniSigIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscAtmIfPnniSigIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniSigIndex.setDescription('This variable represents the index for the mscAtmIfPnniSig tables.')
mscAtmIfPnniSigProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 2, 10), )
if mibBuilder.loadTexts: mscAtmIfPnniSigProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniSigProvTable.setDescription('This attribute group contains the provisionable attributes for the Signalling component.')
mscAtmIfPnniSigProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfPnniIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfPnniSigIndex"))
if mibBuilder.loadTexts: mscAtmIfPnniSigProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniSigProvEntry.setDescription('An entry in the mscAtmIfPnniSigProvTable.')
mscAtmIfPnniSigVci = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 2, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfPnniSigVci.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniSigVci.setDescription('This attribute specifies the signalling channel number.')
mscAtmIfPnniSigAddressConversion = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 2, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("none", 0), ("nativeE164", 1), ("nsap", 2))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfPnniSigAddressConversion.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniSigAddressConversion.setDescription('This attribute specifies the address conversion on the outgoing signalling PDUs. The options are none, nativeE164, or nsap. The none option is the default and if this option is chosen then nothing is done to the address information element (IE) in the outgoing signalling message. If nativeE164 option is chosen, then only NSAP encapsulated E.164 addresses with zeros in the ESI are converted to native E.164 format in the outgoing signalling message. If the NSAP address is not encapsulated E.164 or the ESI field is not zeros and the nativeE164 option is chosen, then the call is cleared. If the nsap option is chosen, then native E.164 addresses are converted to NSAP E.164 with zeros in the ESI field; otherwise the address is in NSAP format and is not changed.')
mscAtmIfPnniSigOperatingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 2, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("normal", 0), ("provisionedOnly", 1))).clone('normal')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfPnniSigOperatingMode.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniSigOperatingMode.setDescription('This attribute specifies the operating mode of the signaling channel. provisionedOnly indicates that only SPVCs and SPVPs are supported on the interface and SVCs are not supported. This value is permitted only on UNI interfaces. normal indicates that SVCs, SPVCs, and SPVPs are supported on the interface.')
mscAtmIfPnniSigStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 2, 11), )
if mibBuilder.loadTexts: mscAtmIfPnniSigStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniSigStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscAtmIfPnniSigStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 2, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfPnniIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfPnniSigIndex"))
if mibBuilder.loadTexts: mscAtmIfPnniSigStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniSigStateEntry.setDescription('An entry in the mscAtmIfPnniSigStateTable.')
mscAtmIfPnniSigAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 2, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfPnniSigAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniSigAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscAtmIfPnniSigOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 2, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfPnniSigOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniSigOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscAtmIfPnniSigUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 2, 11, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfPnniSigUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniSigUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscAtmIfPnniSigOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 2, 12), )
if mibBuilder.loadTexts: mscAtmIfPnniSigOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniSigOperTable.setDescription('This attribute contains the operational attributes for the AtmSignalling component.')
mscAtmIfPnniSigOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 2, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfPnniIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfPnniSigIndex"))
if mibBuilder.loadTexts: mscAtmIfPnniSigOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniSigOperEntry.setDescription('An entry in the mscAtmIfPnniSigOperTable.')
mscAtmIfPnniSigLastTxCauseCode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 2, 12, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfPnniSigLastTxCauseCode.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniSigLastTxCauseCode.setDescription('This attribute indicates the cause code in the last transmitted signalling message that contains the CAUSE information element. The cause code is used to describe the reason for generating certain signalling messages.')
mscAtmIfPnniSigLastTxDiagCode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 2, 12, 1, 2), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfPnniSigLastTxDiagCode.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniSigLastTxDiagCode.setDescription('This attribute contains the diagnostic code in the last transmitted signalling message. The diagnostic code is contained in the CAUSE information element and identifies an information element type or timer type. The diagnostic code is present only if a procedural error is detected by the signalling protocol. A diagnostic code is always accompanied by the cause code. If there is no failure, this attribute is set to 0.')
mscAtmIfPnniSigLastRxCauseCode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 2, 12, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfPnniSigLastRxCauseCode.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniSigLastRxCauseCode.setDescription('This attribute contains the cause code in the last received signalling message that contains the CAUSE information element. The cause code is used to describe the reason for generating certain signalling messages.')
mscAtmIfPnniSigLastRxDiagCode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 2, 12, 1, 4), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfPnniSigLastRxDiagCode.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniSigLastRxDiagCode.setDescription('This attribute contains the diagnostic code in the last received signalling message. The diagnostic code is contained in the CAUSE information element and identifies an information element type or timer type. The diagnostic code is present only if a procedural error is detected by the signalling protocol. A diagnostic code is always accompanied by the cause code. If there is no failure, this attribute is set to 0.')
mscAtmIfPnniSigStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 2, 13), )
if mibBuilder.loadTexts: mscAtmIfPnniSigStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniSigStatsTable.setDescription('This attribute group contains the statistics associated with the AtmSignalling component.')
mscAtmIfPnniSigStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 2, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfPnniIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfPnniSigIndex"))
if mibBuilder.loadTexts: mscAtmIfPnniSigStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniSigStatsEntry.setDescription('An entry in the mscAtmIfPnniSigStatsTable.')
mscAtmIfPnniSigCurrentConnections = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 2, 13, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfPnniSigCurrentConnections.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfPnniSigCurrentConnections.setDescription('This attribute indicates the total number of currently active connections.')
mscAtmIfPnniSigPeakConnections = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 2, 13, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfPnniSigPeakConnections.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniSigPeakConnections.setDescription('This attribute indicates the high water mark of active point-to- point and point-to-multipoint connections.')
mscAtmIfPnniSigSuccessfulConnections = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 2, 13, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfPnniSigSuccessfulConnections.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniSigSuccessfulConnections.setDescription('This attribute counts the total number of switched point-to- point and point-to-multipoint connections that were successfully established. The counter wraps to 0 when the maximum value is exceeded.')
mscAtmIfPnniSigFailedConnections = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 2, 13, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfPnniSigFailedConnections.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniSigFailedConnections.setDescription('This attribute counts the total number of switched connections that were not successfully established.The counter wraps to 0 when the maximum value is exceeded.')
mscAtmIfPnniSigTxPdus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 2, 13, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfPnniSigTxPdus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniSigTxPdus.setDescription('This attribute counts the number of transmitted signalling PDUs.The counter wraps to 0 when the maximum value is exceeded.')
mscAtmIfPnniSigRxPdus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 2, 13, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfPnniSigRxPdus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniSigRxPdus.setDescription('This attribute counts the number of received signalling PDUs.The counter wraps to 0 when the maximum value is exceeded.')
mscAtmIfPnniSigCurrentPmpConnections = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 2, 13, 1, 7), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfPnniSigCurrentPmpConnections.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniSigCurrentPmpConnections.setDescription('This attribute indicates the number of currently active point-to- multipoint connections.')
mscAtmIfPnniSigPeakPmpConnections = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 2, 13, 1, 8), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfPnniSigPeakPmpConnections.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniSigPeakPmpConnections.setDescription('This attribute indicates the high water mark of active point-to- multipoint connections.')
mscAtmIfPnniSigSuccessfulPmpConnections = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 2, 13, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfPnniSigSuccessfulPmpConnections.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniSigSuccessfulPmpConnections.setDescription('This attribute counts the total number of switched point-to- multipoint connections that were successfully established. The counter wraps to 0 when the maximum value is exceeded.')
mscAtmIfPnniSigFailedPmpConnections = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 2, 13, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfPnniSigFailedPmpConnections.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniSigFailedPmpConnections.setDescription('This attribute counts the number of switched point-to- multipoint connections that were not successfully established.The counter wraps to 0 when the maximum value is exceeded.')
mscAtmIfPnniSigNewCurrentConnections = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 2, 13, 1, 11), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfPnniSigNewCurrentConnections.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniSigNewCurrentConnections.setDescription('This attribute indicates the total number of currently active point-to- point and point-to-multipoint connections.')
mscAtmIfPnniSigVcd = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 2, 2))
mscAtmIfPnniSigVcdRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 2, 2, 1), )
if mibBuilder.loadTexts: mscAtmIfPnniSigVcdRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniSigVcdRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfPnniSigVcd components.')
mscAtmIfPnniSigVcdRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 2, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfPnniIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfPnniSigIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfPnniSigVcdIndex"))
if mibBuilder.loadTexts: mscAtmIfPnniSigVcdRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniSigVcdRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfPnniSigVcd component.')
mscAtmIfPnniSigVcdRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 2, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfPnniSigVcdRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniSigVcdRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfPnniSigVcd components. These components can be added and deleted.')
mscAtmIfPnniSigVcdComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 2, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfPnniSigVcdComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniSigVcdComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfPnniSigVcdStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 2, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfPnniSigVcdStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniSigVcdStorageType.setDescription('This variable represents the storage type value for the mscAtmIfPnniSigVcd tables.')
mscAtmIfPnniSigVcdIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 2, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscAtmIfPnniSigVcdIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniSigVcdIndex.setDescription('This variable represents the index for the mscAtmIfPnniSigVcd tables.')
mscAtmIfPnniSigVcdProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 2, 2, 10), )
if mibBuilder.loadTexts: mscAtmIfPnniSigVcdProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniSigVcdProvTable.setDescription('This group contains the provisionable traffic attributes for a control channel.')
mscAtmIfPnniSigVcdProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 2, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfPnniIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfPnniSigIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfPnniSigVcdIndex"))
if mibBuilder.loadTexts: mscAtmIfPnniSigVcdProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniSigVcdProvEntry.setDescription('An entry in the mscAtmIfPnniSigVcdProvTable.')
mscAtmIfPnniSigVcdTrafficDescType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 2, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 6, 7, 8))).clone(namedValues=NamedValues(("n3", 3), ("n6", 6), ("n7", 7), ("n8", 8))).clone('n6')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfPnniSigVcdTrafficDescType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniSigVcdTrafficDescType.setDescription('This attribute specifies the type of traffic management which is applied to both the transmit and receive direction of this connection as defined in the ATM Forum. The trafficDescType determines the number and meaning of the parameters in the trafficDescParm attribute.')
mscAtmIfPnniSigVcdAtmServiceCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 2, 2, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("unspecifiedBitRate", 0), ("constantBitRate", 1), ("rtVariableBitRate", 2), ("nrtVariableBitRate", 3))).clone('rtVariableBitRate')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfPnniSigVcdAtmServiceCategory.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniSigVcdAtmServiceCategory.setDescription("This attribute specifies the ATM service category for both directions of the connection. The constantBitRate service category is intended for real time applications, that is those requiring tightly constrained delay and delay variation, as would be appropriate for voice and video applications. The consistent availability of a fixed quantity of bandwidth is considered appropriate for CBR service. Cells which are delayed beyond the value specified by CellTransfer Delay are assumed to be of significantly reduce value to the application. The rtVariableBitRate service category is intended for real time applications, that is those requiring tightly constrained delay and delay variation, as would be appropriate for voice and video applications. Sources are expected to transmit at a rate which varies with time. Equivalently, the source can be described as 'bursty'. Cells which are delayed beyond the value specified by CTD are assumed to be of significantly reduced value to the application. Real time VBR service may support statistical multiplexing of real time sources. The nrtVariableBitRate service category is intended for non-real time applications which have bursty traffic characteristics and which can be characterized in terms of a PCR, SCR, and MBS. For those cells which are transferred within the traffic contract, the application expects a low cell loss ratio. For all connections, it expects a bound on the mean cell transfer delay. Non-real time VBR service may support statistical multiplexing of connections. The unspecifiedBitRate service is intended for non-real time applications; that is, those not requiring tightly constrained delay and delay variation. UBR sources are expected to be bursty. UBR service supports a high degree of statistical multiplexing among sources. UBR service does not specify traffic related service guarantees. No numerical commitments are made with respect to the cell loss ratio experienced by a UBR connection, or as to the cell transfer delay experienced by cells on the connection.")
mscAtmIfPnniSigVcdWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 2, 2, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 4095), ValueRangeConstraint(65535, 65535), )).clone(65535)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfPnniSigVcdWeight.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniSigVcdWeight.setDescription("This attribute specifies an override for the weight of this unshaped connection. This attribute is ignored for shaped connections, for ABR connections, for connections on a CQC-based ATM FP and basic VPTs. When the value is set to sameAsCa, the weight is determined by the weight policy attribute under the CA service category component for all but standard VPT VCCs. For standard VPT VCCs, the weight is determined by the VCC's service category, when the value is set to sameAsCa. When this attribute is set to a value from 1 to 4095, that value is used for the weight policy of this connection relative to other connections. For all but standard VPT VCCs, weight policy determines the proportion of transit cell opportunities which are allocated to this connection, compared to other connections in the same service category. For standard VPT VCCs, weight policy determines the proportion of transmit cell opportunities which are allocated to this connection, compared to other connections associated with the VPT. When the value is set to upToQueueLimit, the weight policy is limited only by the txQueueLimit. VALUES ( 0 = upToQueueLimit 65535 = sameAsCa )")
mscAtmIfPnniSigVcdQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 2, 2, 10, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4))).clone('n2')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfPnniSigVcdQosClass.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniSigVcdQosClass.setDescription('This attribute specifies the quality of service for both the forward and backward direction for this connection. Class 1 supports a QOS that meets Service Class A performance requirements (Circuit emulation, constant bit rate video). Class 2 supports a QOS that meets Service Class B performance requirements (Variable bit rate audio and video). Class 3 supports a QOS that meets Service Class C performance requirements (Connection-Oriented Data Transfer). Class 4 supports a QOS that meets Service Class D performance requirements (Connectionless Data Transfer). Class 0 is the unspecified bit rate QOS class; no objective is specified for the performance parameters.')
mscAtmIfPnniSigVcdTrafficShaping = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 2, 2, 10, 1, 50), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("sameAsCa", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfPnniSigVcdTrafficShaping.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniSigVcdTrafficShaping.setDescription("This attribute specifies whether this connection uses traffic shaping when transmitting traffic to the ATM interface. When sameAsCa is selected, traffic shaping for this connection is based on the trafficShaping attribute of the connection's service category component under the AtmIf CA. If the service category has traffic shaping enabled, then traffic shaping is enabled for the connection. Note that enabling traffic shaping may have no effect under certain cases. These cases are listed in the description of the trafficShaping operational attribute, which is under the Vcc Tm and Vpc Tm components. When disabled is selected, traffic shaping for this connection is disabled.")
mscAtmIfPnniSigVcdUnshapedTransmitQueueing = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 2, 2, 10, 1, 60), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3))).clone(namedValues=NamedValues(("common", 1), ("sameAsCa", 3))).clone('sameAsCa')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfPnniSigVcdUnshapedTransmitQueueing.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniSigVcdUnshapedTransmitQueueing.setDescription("This attribute only applies when this connection is unshaped. This attribute specifies the transmit queueing method for this connection if it is unshaped. Refer to the unshapedTransmitQueueing attribute under the AtmIf CA service category subcomponent for more details on the meaning of this attribute. When this attribute is set to sameAsCa, the transmit queueing method for the connection is based on the unshapedTransmitQueueing attribute of the connection's service category component under the ConnectionAdministrator. When this attribute is set to common, transmit traffic on this unshaped connection is destined for the common queue. The value sameAsInterface is for migration from previous software releases, but should no longer be used")
mscAtmIfPnniSigVcdUsageParameterControl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 2, 2, 10, 1, 70), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("sameAsCa", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfPnniSigVcdUsageParameterControl.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniSigVcdUsageParameterControl.setDescription("This attribute specifies whether this connection enforces usage parameter control when receiving traffic from the ATM interface. When sameAsCa is selected, UPC for the connection is based on the usageParameterControl attribute of the connection's service category component under the ConnectionAdministrator. If the service category has UPC enabled, then UPC is enabled for the connection. Note that enabling UPC may have no effect under certain cases. These cases are listed in the description of the usageParameterControl operational attribute, which is under the Vcc Tm or Vpc Tm component. When disabled is selected, UPC for this connection is disabled. The value sameAsInterface is for migration from previous software releases, but should no longer be used")
mscAtmIfPnniSigVcdTdpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 2, 2, 387), )
if mibBuilder.loadTexts: mscAtmIfPnniSigVcdTdpTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniSigVcdTdpTable.setDescription('This attribute is a vector of five traffic parameters whose meanings are defined by the trafficDescType attribute. The values of peak cell rate (PCR), sustained cell rate (SCR) and requested shaping rate are expressed in cell/s. Maximum burst size (MBS) is expressed in cells. CDVT is expressed in microseconds. The values of PCR, SCR, MBS and CDVT are used for connection admission control (CAC). The value of CDVT is only used for connections where the atmServiceCategory is constantBitRate. For all other values of atmServiceCategory, CDVT is ignored. The values of PCR, SCR and requested shaping rate are used to determine the actual shaping rate where traffic shaping is enabled. When trafficDescType is 3, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameter 1 must be non-zero. Parameters 2 and 3 must be zero. When trafficDescType is 6, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 and 1 traffic; parameter 3 represents the MBS for CLP equal to 0 and 1 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameters 1, 2, and 3 must be non-zero. Parameter 1 must be greater than or equal to parameter 2. Parameter 5 must either be zero (unused) or greater than or equal to parameter 2. When trafficDescType is 7, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 with cell discard; parameter 3 represents the MBS for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameters 1, 2, and 3 must be non-zero. Parameter 1 must be greater than or equal to parameter 2. Parameter 5 must either be zero (unused) or greater than or equal to parameter 2. When trafficDescType is 8, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell tagging; parameter 3 represents the MBS for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameters 1, 2, and 3 must be non-zero. Parameter 1 must be greater than or equal to parameter 2. Parameter 5 must either be zero (unused) or greater than or equal to parameter 2. Whenever it is valid for PCR to be specified, parameter 5 may also be used to specify a requested shaping rate. A non-zero value in parameter 5 overrides the value in parameter 1 and is used as the peak cell rate in calculations of CAC and shaping rate. For trafficDescType 3 the traffic is shaped at the next rate less than the PCR. For trafficDescType 6, 7, and 8, the traffic is shaped at the highest available rate which is between PCR and SCR. However, if there is no available shaping rate between PCR and SCR, traffic is shaped at the next rate above the PCR.')
mscAtmIfPnniSigVcdTdpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 2, 2, 387, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfPnniIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfPnniSigIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfPnniSigVcdIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfPnniSigVcdTdpIndex"))
if mibBuilder.loadTexts: mscAtmIfPnniSigVcdTdpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniSigVcdTdpEntry.setDescription('An entry in the mscAtmIfPnniSigVcdTdpTable.')
mscAtmIfPnniSigVcdTdpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 2, 2, 387, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: mscAtmIfPnniSigVcdTdpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniSigVcdTdpIndex.setDescription('This variable represents the mscAtmIfPnniSigVcdTdpTable specific index for the mscAtmIfPnniSigVcdTdpTable.')
mscAtmIfPnniSigVcdTdpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 2, 2, 387, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfPnniSigVcdTdpValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniSigVcdTdpValue.setDescription('This variable represents an individual value for the mscAtmIfPnniSigVcdTdpTable.')
mscAtmIfPnniRcc = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 3))
mscAtmIfPnniRccRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 3, 1), )
if mibBuilder.loadTexts: mscAtmIfPnniRccRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniRccRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfPnniRcc components.')
mscAtmIfPnniRccRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 3, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfPnniIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfPnniRccIndex"))
if mibBuilder.loadTexts: mscAtmIfPnniRccRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniRccRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfPnniRcc component.')
mscAtmIfPnniRccRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 3, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfPnniRccRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniRccRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfPnniRcc components. These components cannot be added nor deleted.')
mscAtmIfPnniRccComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfPnniRccComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniRccComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfPnniRccStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfPnniRccStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniRccStorageType.setDescription('This variable represents the storage type value for the mscAtmIfPnniRcc tables.')
mscAtmIfPnniRccIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscAtmIfPnniRccIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniRccIndex.setDescription('This variable represents the index for the mscAtmIfPnniRcc tables.')
mscAtmIfPnniRccProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 3, 10), )
if mibBuilder.loadTexts: mscAtmIfPnniRccProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniRccProvTable.setDescription('This group contains the generic provisionable attributes of an Rcc component.')
mscAtmIfPnniRccProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 3, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfPnniIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfPnniRccIndex"))
if mibBuilder.loadTexts: mscAtmIfPnniRccProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniRccProvEntry.setDescription('An entry in the mscAtmIfPnniRccProvTable.')
mscAtmIfPnniRccVci = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 3, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(18)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfPnniRccVci.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniRccVci.setDescription('This attribute specifies the VCI for the Routing Control Channel (RCC). It is not recommended that the value be changed from the default of 18 unless absolutely necessary. If a different VCI is specified, ensure that the RCC at the far end is provisioned to use the same VCI, otherwise the RCC will not come up.')
mscAtmIfPnniRccHlParmsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 3, 11), )
if mibBuilder.loadTexts: mscAtmIfPnniRccHlParmsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniRccHlParmsTable.setDescription('This group contains the provisionable Hello protocol parameters for an Rcc component.')
mscAtmIfPnniRccHlParmsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 3, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfPnniIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfPnniRccIndex"))
if mibBuilder.loadTexts: mscAtmIfPnniRccHlParmsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniRccHlParmsEntry.setDescription('An entry in the mscAtmIfPnniRccHlParmsTable.')
mscAtmIfPnniRccHelloHoldDown = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 3, 11, 1, 1), FixedPoint1().subtype(subtypeSpec=ValueRangeConstraint(0, 655350))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfPnniRccHelloHoldDown.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniRccHelloHoldDown.setDescription('This attribute is used to limit the rate at which this node sends out Hello packets. Specifically, it specifies the minimum time between successive Hellos. A value of 0 specifies that the value provisioned for the helloHoldDown attribute of the ARtg Pnni component should be used.')
mscAtmIfPnniRccHelloInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 3, 11, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfPnniRccHelloInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniRccHelloInterval.setDescription('This attribute specifies the duration of the Hello Timer. Every helloInterval seconds, this node will send out a Hello packet to the neighbor node, subject to the helloHoldDown timer having expired at least once since the last Hello packet was sent. A value of 0 specifies that the value provisioned for the helloInterval attribute of the ARtg Pnni component should be used.')
mscAtmIfPnniRccHelloInactivityFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 3, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfPnniRccHelloInactivityFactor.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniRccHelloInactivityFactor.setDescription('This attribute specifies the number of Hello intervals allowed to pass without receiving a Hello from the neighbor node, before an attempt is made to re-stage. The hello inactivity timer is enabled in the oneWayInside, twoWayInside, oneWayOutside, twoWayOutside and commonOutside hello states (see the helloState attribute on the Rcc component for a description of these states). Note that the value for the Hello interval used in the calculation is the one specified in the Hello packet from the neighbor node. A value of 0 specifies that the value provisioned for the helloInactivityFactor attribute of the ARtg Pnni component should be used. DESCRIPTION')
mscAtmIfPnniRccStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 3, 12), )
if mibBuilder.loadTexts: mscAtmIfPnniRccStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniRccStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscAtmIfPnniRccStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 3, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfPnniIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfPnniRccIndex"))
if mibBuilder.loadTexts: mscAtmIfPnniRccStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniRccStateEntry.setDescription('An entry in the mscAtmIfPnniRccStateTable.')
mscAtmIfPnniRccAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 3, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfPnniRccAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniRccAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscAtmIfPnniRccOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 3, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfPnniRccOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniRccOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscAtmIfPnniRccUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 3, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfPnniRccUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniRccUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscAtmIfPnniRccOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 3, 13), )
if mibBuilder.loadTexts: mscAtmIfPnniRccOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniRccOperTable.setDescription('This group contains the operational attributes for an Rcc component.')
mscAtmIfPnniRccOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 3, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfPnniIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfPnniRccIndex"))
if mibBuilder.loadTexts: mscAtmIfPnniRccOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniRccOperEntry.setDescription('An entry in the mscAtmIfPnniRccOperTable.')
mscAtmIfPnniRccType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 3, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 0), ("lowestLevelHorizLink", 1), ("lowestLevelOutsideLink", 2), ("horizontalLinkToLGN", 3), ("uplink", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfPnniRccType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniRccType.setDescription('This attribute indicates the role of this link in the PNNI hierarchy. The following values are possible: unknown: the Hello protocol has not yet determined the role of the link. lowestLevelHorizLink: the link is a horizontal link between two lowest level nodes. lowestLevelOutsideLink: the link is an outside link between two border nodes. horizontalLinkToLgn: the link is a horizontal link to a Logical Group Node (LGN). uplink: the link is a uplink to a higher level LGN.')
mscAtmIfPnniRccNegotiatedVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 3, 13, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("unsupported", 0), ("version1point0", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfPnniRccNegotiatedVersion.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniRccNegotiatedVersion.setDescription('This attribute indicates the PNNI version negotiated with the neighbor node.')
mscAtmIfPnniRccHelloState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 3, 13, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("notApplicable", 0), ("down", 1), ("attempt", 2), ("oneWayInside", 3), ("twoWayInside", 4), ("oneWayOutside", 5), ("twoWayOutside", 6), ("commonOutside", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfPnniRccHelloState.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniRccHelloState.setDescription("This attribute indicates the state of the Hello protocol exchange over this link. The following are the possible values for this attribute: down: the link is down; no PNNI routing packets will be sent over or received over such a link. This is the initial state of the Hello Finite State Machine, and can also be reached when lower-level protocols have indicated that the link is not usable. attempt: no Hello packets or Hello packets, with mismatch information, have been received recently from the neighbor. Attempts are made to contact the neighbor node by sending out Hello packets every helloInterval seconds. oneWayInside: Hello packets have been recently received from the neighbor and it has been established that both nodes are members of the same peer group, but the remote node ID and remote port ID in the neighbor's Hello packets were set to zero. A Hello packet is sent to the neighbor and the Hello timer is restarted. twoWayInside: Bidirectional communication over this link between this node and the neighbor node has been achieved. oneWayOutside: Hello packets have been recently received from the neighbor and it has been established that both nodes are members of a different peer group, but the remote node ID and remote port ID in the neighbor's Hello packets were set to zero. twoWayOutside: Hellos have recently been received from the neighbor indicating that the neighbor node belongs to a different peer group. The correct remote node ID and remote port ID fields were included in the Hello packet, but the nodal hierarchy list did not include any common peer group. This state can also be reached if a hierarchy mismatch occurs while in the commonOutside state. commonOutside: A common level of the routing hierarchy has been found, in addition to achieving full bi-directional communication between the two nodes.")
mscAtmIfPnniRccRemoteNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 3, 13, 1, 4), HexString().subtype(subtypeSpec=ValueSizeConstraint(22, 22)).setFixedLength(22)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfPnniRccRemoteNodeId.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniRccRemoteNodeId.setDescription("This attribute indicates the neighbor node's node id.")
mscAtmIfPnniRccRemotePortId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 3, 13, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfPnniRccRemotePortId.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniRccRemotePortId.setDescription("This attribute indicates the neighbor node's port id.")
mscAtmIfPnniRccStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 3, 14), )
if mibBuilder.loadTexts: mscAtmIfPnniRccStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniRccStatsTable.setDescription('This group contains the statistical attributes for an Rcc component.')
mscAtmIfPnniRccStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 3, 14, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfPnniIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfPnniRccIndex"))
if mibBuilder.loadTexts: mscAtmIfPnniRccStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniRccStatsEntry.setDescription('An entry in the mscAtmIfPnniRccStatsTable.')
mscAtmIfPnniRccHelloPacketsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 3, 14, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfPnniRccHelloPacketsRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniRccHelloPacketsRx.setDescription('This attribute counts the total number of Hello packets received across this RCC, including bad and mismatched Hello packets. The counter wraps when it exceeds the maximum value.')
mscAtmIfPnniRccHelloPacketsTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 3, 14, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfPnniRccHelloPacketsTx.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniRccHelloPacketsTx.setDescription('This attribute counts the total number of Hello packets transmitted across this RCC. The counter wraps when it exceeds the maximum value.')
mscAtmIfPnniRccMismatchedHelloPacketsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 3, 14, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfPnniRccMismatchedHelloPacketsRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniRccMismatchedHelloPacketsRx.setDescription('This attribute counts the total number of mismatched Hello packets received over this RCC. The counter wraps when it exceeds the maximum value.')
mscAtmIfPnniRccBadHelloPacketsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 3, 14, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfPnniRccBadHelloPacketsRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniRccBadHelloPacketsRx.setDescription('This attribute counts the total number of bad Hello packets received over this RCC. The counter wraps when it exceeds the maximum value.')
mscAtmIfPnniRccVcd = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 3, 2))
mscAtmIfPnniRccVcdRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 3, 2, 1), )
if mibBuilder.loadTexts: mscAtmIfPnniRccVcdRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniRccVcdRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfPnniRccVcd components.')
mscAtmIfPnniRccVcdRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 3, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfPnniIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfPnniRccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfPnniRccVcdIndex"))
if mibBuilder.loadTexts: mscAtmIfPnniRccVcdRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniRccVcdRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfPnniRccVcd component.')
mscAtmIfPnniRccVcdRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 3, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfPnniRccVcdRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniRccVcdRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfPnniRccVcd components. These components can be added and deleted.')
mscAtmIfPnniRccVcdComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 3, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfPnniRccVcdComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniRccVcdComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfPnniRccVcdStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 3, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfPnniRccVcdStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniRccVcdStorageType.setDescription('This variable represents the storage type value for the mscAtmIfPnniRccVcd tables.')
mscAtmIfPnniRccVcdIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 3, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscAtmIfPnniRccVcdIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniRccVcdIndex.setDescription('This variable represents the index for the mscAtmIfPnniRccVcd tables.')
mscAtmIfPnniRccVcdProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 3, 2, 10), )
if mibBuilder.loadTexts: mscAtmIfPnniRccVcdProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniRccVcdProvTable.setDescription('This group contains the provisionable traffic attributes for a control channel.')
mscAtmIfPnniRccVcdProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 3, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfPnniIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfPnniRccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfPnniRccVcdIndex"))
if mibBuilder.loadTexts: mscAtmIfPnniRccVcdProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniRccVcdProvEntry.setDescription('An entry in the mscAtmIfPnniRccVcdProvTable.')
mscAtmIfPnniRccVcdTrafficDescType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 3, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 6, 7, 8))).clone(namedValues=NamedValues(("n3", 3), ("n6", 6), ("n7", 7), ("n8", 8))).clone('n6')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfPnniRccVcdTrafficDescType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniRccVcdTrafficDescType.setDescription('This attribute specifies the type of traffic management which is applied to both the transmit and receive direction of this connection as defined in the ATM Forum. The trafficDescType determines the number and meaning of the parameters in the trafficDescParm attribute.')
mscAtmIfPnniRccVcdAtmServiceCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 3, 2, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("unspecifiedBitRate", 0), ("constantBitRate", 1), ("rtVariableBitRate", 2), ("nrtVariableBitRate", 3))).clone('rtVariableBitRate')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfPnniRccVcdAtmServiceCategory.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniRccVcdAtmServiceCategory.setDescription("This attribute specifies the ATM service category for both directions of the connection. The constantBitRate service category is intended for real time applications, that is those requiring tightly constrained delay and delay variation, as would be appropriate for voice and video applications. The consistent availability of a fixed quantity of bandwidth is considered appropriate for CBR service. Cells which are delayed beyond the value specified by CellTransfer Delay are assumed to be of significantly reduce value to the application. The rtVariableBitRate service category is intended for real time applications, that is those requiring tightly constrained delay and delay variation, as would be appropriate for voice and video applications. Sources are expected to transmit at a rate which varies with time. Equivalently, the source can be described as 'bursty'. Cells which are delayed beyond the value specified by CTD are assumed to be of significantly reduced value to the application. Real time VBR service may support statistical multiplexing of real time sources. The nrtVariableBitRate service category is intended for non-real time applications which have bursty traffic characteristics and which can be characterized in terms of a PCR, SCR, and MBS. For those cells which are transferred within the traffic contract, the application expects a low cell loss ratio. For all connections, it expects a bound on the mean cell transfer delay. Non-real time VBR service may support statistical multiplexing of connections. The unspecifiedBitRate service is intended for non-real time applications; that is, those not requiring tightly constrained delay and delay variation. UBR sources are expected to be bursty. UBR service supports a high degree of statistical multiplexing among sources. UBR service does not specify traffic related service guarantees. No numerical commitments are made with respect to the cell loss ratio experienced by a UBR connection, or as to the cell transfer delay experienced by cells on the connection.")
mscAtmIfPnniRccVcdWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 3, 2, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 4095), ValueRangeConstraint(65535, 65535), )).clone(65535)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfPnniRccVcdWeight.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniRccVcdWeight.setDescription("This attribute specifies an override for the weight of this unshaped connection. This attribute is ignored for shaped connections, for ABR connections, for connections on a CQC-based ATM FP and basic VPTs. When the value is set to sameAsCa, the weight is determined by the weight policy attribute under the CA service category component for all but standard VPT VCCs. For standard VPT VCCs, the weight is determined by the VCC's service category, when the value is set to sameAsCa. When this attribute is set to a value from 1 to 4095, that value is used for the weight policy of this connection relative to other connections. For all but standard VPT VCCs, weight policy determines the proportion of transit cell opportunities which are allocated to this connection, compared to other connections in the same service category. For standard VPT VCCs, weight policy determines the proportion of transmit cell opportunities which are allocated to this connection, compared to other connections associated with the VPT. When the value is set to upToQueueLimit, the weight policy is limited only by the txQueueLimit. VALUES ( 0 = upToQueueLimit 65535 = sameAsCa )")
mscAtmIfPnniRccVcdQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 3, 2, 10, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4))).clone('n2')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfPnniRccVcdQosClass.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniRccVcdQosClass.setDescription('This attribute specifies the quality of service for both the forward and backward direction for this connection. Class 1 supports a QOS that meets Service Class A performance requirements (Circuit emulation, constant bit rate video). Class 2 supports a QOS that meets Service Class B performance requirements (Variable bit rate audio and video). Class 3 supports a QOS that meets Service Class C performance requirements (Connection-Oriented Data Transfer). Class 4 supports a QOS that meets Service Class D performance requirements (Connectionless Data Transfer). Class 0 is the unspecified bit rate QOS class; no objective is specified for the performance parameters.')
mscAtmIfPnniRccVcdTrafficShaping = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 3, 2, 10, 1, 50), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("sameAsCa", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfPnniRccVcdTrafficShaping.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniRccVcdTrafficShaping.setDescription("This attribute specifies whether this connection uses traffic shaping when transmitting traffic to the ATM interface. When sameAsCa is selected, traffic shaping for this connection is based on the trafficShaping attribute of the connection's service category component under the AtmIf CA. If the service category has traffic shaping enabled, then traffic shaping is enabled for the connection. Note that enabling traffic shaping may have no effect under certain cases. These cases are listed in the description of the trafficShaping operational attribute, which is under the Vcc Tm and Vpc Tm components. When disabled is selected, traffic shaping for this connection is disabled.")
mscAtmIfPnniRccVcdUnshapedTransmitQueueing = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 3, 2, 10, 1, 60), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3))).clone(namedValues=NamedValues(("common", 1), ("sameAsCa", 3))).clone('sameAsCa')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfPnniRccVcdUnshapedTransmitQueueing.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniRccVcdUnshapedTransmitQueueing.setDescription("This attribute only applies when this connection is unshaped. This attribute specifies the transmit queueing method for this connection if it is unshaped. Refer to the unshapedTransmitQueueing attribute under the AtmIf CA service category subcomponent for more details on the meaning of this attribute. When this attribute is set to sameAsCa, the transmit queueing method for the connection is based on the unshapedTransmitQueueing attribute of the connection's service category component under the ConnectionAdministrator. When this attribute is set to common, transmit traffic on this unshaped connection is destined for the common queue. The value sameAsInterface is for migration from previous software releases, but should no longer be used")
mscAtmIfPnniRccVcdUsageParameterControl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 3, 2, 10, 1, 70), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("sameAsCa", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfPnniRccVcdUsageParameterControl.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniRccVcdUsageParameterControl.setDescription("This attribute specifies whether this connection enforces usage parameter control when receiving traffic from the ATM interface. When sameAsCa is selected, UPC for the connection is based on the usageParameterControl attribute of the connection's service category component under the ConnectionAdministrator. If the service category has UPC enabled, then UPC is enabled for the connection. Note that enabling UPC may have no effect under certain cases. These cases are listed in the description of the usageParameterControl operational attribute, which is under the Vcc Tm or Vpc Tm component. When disabled is selected, UPC for this connection is disabled. The value sameAsInterface is for migration from previous software releases, but should no longer be used")
mscAtmIfPnniRccVcdTdpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 3, 2, 387), )
if mibBuilder.loadTexts: mscAtmIfPnniRccVcdTdpTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniRccVcdTdpTable.setDescription('This attribute is a vector of five traffic parameters whose meanings are defined by the trafficDescType attribute. The values of peak cell rate (PCR), sustained cell rate (SCR) and requested shaping rate are expressed in cell/s. Maximum burst size (MBS) is expressed in cells. CDVT is expressed in microseconds. The values of PCR, SCR, MBS and CDVT are used for connection admission control (CAC). The value of CDVT is only used for connections where the atmServiceCategory is constantBitRate. For all other values of atmServiceCategory, CDVT is ignored. The values of PCR, SCR and requested shaping rate are used to determine the actual shaping rate where traffic shaping is enabled. When trafficDescType is 3, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameter 1 must be non-zero. Parameters 2 and 3 must be zero. When trafficDescType is 6, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 and 1 traffic; parameter 3 represents the MBS for CLP equal to 0 and 1 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameters 1, 2, and 3 must be non-zero. Parameter 1 must be greater than or equal to parameter 2. Parameter 5 must either be zero (unused) or greater than or equal to parameter 2. When trafficDescType is 7, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 with cell discard; parameter 3 represents the MBS for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameters 1, 2, and 3 must be non-zero. Parameter 1 must be greater than or equal to parameter 2. Parameter 5 must either be zero (unused) or greater than or equal to parameter 2. When trafficDescType is 8, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell tagging; parameter 3 represents the MBS for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameters 1, 2, and 3 must be non-zero. Parameter 1 must be greater than or equal to parameter 2. Parameter 5 must either be zero (unused) or greater than or equal to parameter 2. Whenever it is valid for PCR to be specified, parameter 5 may also be used to specify a requested shaping rate. A non-zero value in parameter 5 overrides the value in parameter 1 and is used as the peak cell rate in calculations of CAC and shaping rate. For trafficDescType 3 the traffic is shaped at the next rate less than the PCR. For trafficDescType 6, 7, and 8, the traffic is shaped at the highest available rate which is between PCR and SCR. However, if there is no available shaping rate between PCR and SCR, traffic is shaped at the next rate above the PCR.')
mscAtmIfPnniRccVcdTdpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 3, 2, 387, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfPnniIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfPnniRccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfPnniRccVcdIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfPnniRccVcdTdpIndex"))
if mibBuilder.loadTexts: mscAtmIfPnniRccVcdTdpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniRccVcdTdpEntry.setDescription('An entry in the mscAtmIfPnniRccVcdTdpTable.')
mscAtmIfPnniRccVcdTdpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 3, 2, 387, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: mscAtmIfPnniRccVcdTdpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniRccVcdTdpIndex.setDescription('This variable represents the mscAtmIfPnniRccVcdTdpTable specific index for the mscAtmIfPnniRccVcdTdpTable.')
mscAtmIfPnniRccVcdTdpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 3, 2, 387, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfPnniRccVcdTdpValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniRccVcdTdpValue.setDescription('This variable represents an individual value for the mscAtmIfPnniRccVcdTdpTable.')
mscAtmIfPnniAddr = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 4))
mscAtmIfPnniAddrRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 4, 1), )
if mibBuilder.loadTexts: mscAtmIfPnniAddrRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniAddrRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfPnniAddr components.')
mscAtmIfPnniAddrRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 4, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfPnniIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfPnniAddrAddressIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfPnniAddrAddressTypeIndex"))
if mibBuilder.loadTexts: mscAtmIfPnniAddrRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniAddrRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfPnniAddr component.')
mscAtmIfPnniAddrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 4, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfPnniAddrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniAddrRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfPnniAddr components. These components can be added and deleted.')
mscAtmIfPnniAddrComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfPnniAddrComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniAddrComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfPnniAddrStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfPnniAddrStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniAddrStorageType.setDescription('This variable represents the storage type value for the mscAtmIfPnniAddr tables.')
mscAtmIfPnniAddrAddressIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 4, 1, 1, 10), AsciiStringIndex().subtype(subtypeSpec=ValueSizeConstraint(1, 40)))
if mibBuilder.loadTexts: mscAtmIfPnniAddrAddressIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniAddrAddressIndex.setDescription('This variable represents an index for the mscAtmIfPnniAddr tables.')
mscAtmIfPnniAddrAddressTypeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 4, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("primary", 0), ("alternate", 1), ("registered", 2), ("default", 3))))
if mibBuilder.loadTexts: mscAtmIfPnniAddrAddressTypeIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniAddrAddressTypeIndex.setDescription('This variable represents an index for the mscAtmIfPnniAddr tables.')
mscAtmIfPnniAddrOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 4, 10), )
if mibBuilder.loadTexts: mscAtmIfPnniAddrOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniAddrOperTable.setDescription('This attribute group contains the operational attributes for the Address component.')
mscAtmIfPnniAddrOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 4, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfPnniIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfPnniAddrAddressIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfPnniAddrAddressTypeIndex"))
if mibBuilder.loadTexts: mscAtmIfPnniAddrOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniAddrOperEntry.setDescription('An entry in the mscAtmIfPnniAddrOperTable.')
mscAtmIfPnniAddrScope = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 4, 10, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 104))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfPnniAddrScope.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniAddrScope.setDescription('This attribute indicates the scope of the ATM address, which is the highest level to which this address will be advertised in the PNNI hierarchy. If no PnniInfo subcomponent has been provisioned, then the scope will default to the level of this node in the PNNI hierarchy. If this node does not participate in a PNNI hierarchy, then this attribute will have the value of -1.')
mscAtmIfPnniAddrReachability = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 4, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("internal", 0), ("exterior", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfPnniAddrReachability.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniAddrReachability.setDescription('This attribute indicates whether the address is internal or exterior. An internal reachable address is an address of a destination that is directly attached to the logical node advertising the address. An exterior reachable address is an address that can be reached through a PNNI routing domain, but which is not located in that PNNI routing domain.')
mscAtmIfPnniAddrTermSP = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 4, 2))
mscAtmIfPnniAddrTermSPRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 4, 2, 1), )
if mibBuilder.loadTexts: mscAtmIfPnniAddrTermSPRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniAddrTermSPRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfPnniAddrTermSP components.')
mscAtmIfPnniAddrTermSPRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 4, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfPnniIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfPnniAddrAddressIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfPnniAddrAddressTypeIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfPnniAddrTermSPIndex"))
if mibBuilder.loadTexts: mscAtmIfPnniAddrTermSPRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniAddrTermSPRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfPnniAddrTermSP component.')
mscAtmIfPnniAddrTermSPRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 4, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfPnniAddrTermSPRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniAddrTermSPRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfPnniAddrTermSP components. These components can be added and deleted.')
mscAtmIfPnniAddrTermSPComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 4, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfPnniAddrTermSPComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniAddrTermSPComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfPnniAddrTermSPStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 4, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfPnniAddrTermSPStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniAddrTermSPStorageType.setDescription('This variable represents the storage type value for the mscAtmIfPnniAddrTermSP tables.')
mscAtmIfPnniAddrTermSPIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 4, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscAtmIfPnniAddrTermSPIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniAddrTermSPIndex.setDescription('This variable represents the index for the mscAtmIfPnniAddrTermSP tables.')
mscAtmIfPnniAddrPnniInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 4, 3))
mscAtmIfPnniAddrPnniInfoRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 4, 3, 1), )
if mibBuilder.loadTexts: mscAtmIfPnniAddrPnniInfoRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniAddrPnniInfoRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfPnniAddrPnniInfo components.')
mscAtmIfPnniAddrPnniInfoRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 4, 3, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfPnniIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfPnniAddrAddressIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfPnniAddrAddressTypeIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfPnniAddrPnniInfoIndex"))
if mibBuilder.loadTexts: mscAtmIfPnniAddrPnniInfoRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniAddrPnniInfoRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfPnniAddrPnniInfo component.')
mscAtmIfPnniAddrPnniInfoRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 4, 3, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfPnniAddrPnniInfoRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniAddrPnniInfoRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfPnniAddrPnniInfo components. These components can be added and deleted.')
mscAtmIfPnniAddrPnniInfoComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 4, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfPnniAddrPnniInfoComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniAddrPnniInfoComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfPnniAddrPnniInfoStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 4, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfPnniAddrPnniInfoStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniAddrPnniInfoStorageType.setDescription('This variable represents the storage type value for the mscAtmIfPnniAddrPnniInfo tables.')
mscAtmIfPnniAddrPnniInfoIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 4, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscAtmIfPnniAddrPnniInfoIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniAddrPnniInfoIndex.setDescription('This variable represents the index for the mscAtmIfPnniAddrPnniInfo tables.')
mscAtmIfPnniAddrPnniInfoProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 4, 3, 10), )
if mibBuilder.loadTexts: mscAtmIfPnniAddrPnniInfoProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniAddrPnniInfoProvTable.setDescription('This attribute group contains the provisioned attributes relating to PNNI for a PnniInfo component.')
mscAtmIfPnniAddrPnniInfoProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 4, 3, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfPnniIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfPnniAddrAddressIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfPnniAddrAddressTypeIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmPnniMIB", "mscAtmIfPnniAddrPnniInfoIndex"))
if mibBuilder.loadTexts: mscAtmIfPnniAddrPnniInfoProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniAddrPnniInfoProvEntry.setDescription('An entry in the mscAtmIfPnniAddrPnniInfoProvTable.')
mscAtmIfPnniAddrPnniInfoScope = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 4, 3, 10, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 104)).clone(-1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfPnniAddrPnniInfoScope.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniAddrPnniInfoScope.setDescription('This attribute specifies the scope of the ATM address, which is the highest level up to which this address will be advertised in the PNNI hierarchy. The scope must be set to a value numerically less than or equal to the level of the lowest level peer group containing this node. Setting the scope to 0 will cause the address to be advertised globally within this PNNI routing domain.')
mscAtmIfPnniAddrPnniInfoReachability = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 96, 4, 3, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("internal", 0), ("exterior", 1))).clone('internal')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfPnniAddrPnniInfoReachability.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPnniAddrPnniInfoReachability.setDescription('This attribute indicates whether the address is internal or exterior. An internal reachable address is an address of a destination that is directly attached to the logical node advertising the address. An exterior reachable address is an address that can be reached through a PNNI routing domain, but which is not located in that PNNI routing domain.')
atmPnniGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 72, 1))
atmPnniGroupCA = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 72, 1, 1))
atmPnniGroupCA02 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 72, 1, 1, 3))
atmPnniGroupCA02A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 72, 1, 1, 3, 2))
atmPnniCapabilities = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 72, 3))
atmPnniCapabilitiesCA = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 72, 3, 1))
atmPnniCapabilitiesCA02 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 72, 3, 1, 3))
atmPnniCapabilitiesCA02A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 72, 3, 1, 3, 2))
mibBuilder.exportSymbols("Nortel-MsCarrier-MscPassport-AtmPnniMIB", mscAtmIfPnniRccVcdProvEntry=mscAtmIfPnniRccVcdProvEntry, mscAtmIfVptPnniRccRemoteNodeId=mscAtmIfVptPnniRccRemoteNodeId, mscAtmIfPnniAddrRowStatusTable=mscAtmIfPnniAddrRowStatusTable, mscAtmIfVptPnniOperationalTable=mscAtmIfVptPnniOperationalTable, mscAtmIfVptPnniRccHelloState=mscAtmIfVptPnniRccHelloState, mscAtmIfPnniRccVcdTrafficDescType=mscAtmIfPnniRccVcdTrafficDescType, mscAtmIfVptPnniProvTable=mscAtmIfVptPnniProvTable, mscAtmIfPnniAddr=mscAtmIfPnniAddr, mscAtmIfVptPnniSigVcdStorageType=mscAtmIfVptPnniSigVcdStorageType, atmPnniMIB=atmPnniMIB, mscAtmIfVptPnniRccStateEntry=mscAtmIfVptPnniRccStateEntry, mscAtmIfPnniRccOperEntry=mscAtmIfPnniRccOperEntry, mscAtmIfPnniRccVcdTdpValue=mscAtmIfPnniRccVcdTdpValue, mscAtmIfVptPnniAddrReachability=mscAtmIfVptPnniAddrReachability, mscAtmIfPnniPortId=mscAtmIfPnniPortId, mscAtmIfPnniRccVcd=mscAtmIfPnniRccVcd, mscAtmIfVptPnniSigVcdIndex=mscAtmIfVptPnniSigVcdIndex, mscAtmIfVptPnniRccVcdIndex=mscAtmIfVptPnniRccVcdIndex, mscAtmIfVptPnniPortId=mscAtmIfVptPnniPortId, mscAtmIfPnniSigVcdTrafficDescType=mscAtmIfPnniSigVcdTrafficDescType, mscAtmIfVptPnniRowStatusEntry=mscAtmIfVptPnniRowStatusEntry, mscAtmIfVptPnniAddrPnniInfoComponentName=mscAtmIfVptPnniAddrPnniInfoComponentName, mscAtmIfPnniSigLastRxCauseCode=mscAtmIfPnniSigLastRxCauseCode, mscAtmIfPnniSigLastTxCauseCode=mscAtmIfPnniSigLastTxCauseCode, mscAtmIfPnniAccountConnectionType=mscAtmIfPnniAccountConnectionType, mscAtmIfPnniAddrPnniInfoRowStatusEntry=mscAtmIfPnniAddrPnniInfoRowStatusEntry, mscAtmIfVptPnniSigLastTxCauseCode=mscAtmIfVptPnniSigLastTxCauseCode, mscAtmIfPnniAcctOptTable=mscAtmIfPnniAcctOptTable, mscAtmIfPnniRccStatsTable=mscAtmIfPnniRccStatsTable, mscAtmIfVptPnniSigProvTable=mscAtmIfVptPnniSigProvTable, mscAtmIfVptPnniAddrTermSP=mscAtmIfVptPnniAddrTermSP, mscAtmIfVptPnniRccHelloPacketsRx=mscAtmIfVptPnniRccHelloPacketsRx, mscAtmIfVptPnniRowStatus=mscAtmIfVptPnniRowStatus, mscAtmIfPnniAdminWeightsEntry=mscAtmIfPnniAdminWeightsEntry, mscAtmIfVptPnniSigPeakConnections=mscAtmIfVptPnniSigPeakConnections, atmPnniGroupCA=atmPnniGroupCA, mscAtmIfVptPnniIndex=mscAtmIfVptPnniIndex, mscAtmIfPnniSigPeakConnections=mscAtmIfPnniSigPeakConnections, mscAtmIfVptPnniSigAdminState=mscAtmIfVptPnniSigAdminState, mscAtmIfPnniSigAdminState=mscAtmIfPnniSigAdminState, mscAtmIfVptPnniSigVcdTdpTable=mscAtmIfVptPnniSigVcdTdpTable, atmPnniCapabilitiesCA02A=atmPnniCapabilitiesCA02A, mscAtmIfVptPnniRccVcdAtmServiceCategory=mscAtmIfVptPnniRccVcdAtmServiceCategory, mscAtmIfVptPnniAddrOperTable=mscAtmIfVptPnniAddrOperTable, mscAtmIfPnniRccVcdWeight=mscAtmIfPnniRccVcdWeight, mscAtmIfVptPnniSigVcdQosClass=mscAtmIfVptPnniSigVcdQosClass, mscAtmIfPnniAddrTermSPIndex=mscAtmIfPnniAddrTermSPIndex, mscAtmIfVptPnniSigOperationalState=mscAtmIfVptPnniSigOperationalState, mscAtmIfPnniAddrOperEntry=mscAtmIfPnniAddrOperEntry, mscAtmIfPnniAddrPnniInfoProvEntry=mscAtmIfPnniAddrPnniInfoProvEntry, mscAtmIfPnniSigVcdTdpIndex=mscAtmIfPnniSigVcdTdpIndex, mscAtmIfVptPnniRowStatusTable=mscAtmIfVptPnniRowStatusTable, mscAtmIfVptPnniAddrTermSPRowStatusEntry=mscAtmIfVptPnniAddrTermSPRowStatusEntry, mscAtmIfVptPnniRccOperationalState=mscAtmIfVptPnniRccOperationalState, mscAtmIfPnniSigProvTable=mscAtmIfPnniSigProvTable, mscAtmIfVptPnniSigVcdComponentName=mscAtmIfVptPnniSigVcdComponentName, mscAtmIfPnniSigRowStatusEntry=mscAtmIfPnniSigRowStatusEntry, mscAtmIfVptPnniSigVcdTrafficDescType=mscAtmIfVptPnniSigVcdTrafficDescType, mscAtmIfPnniAddrTermSP=mscAtmIfPnniAddrTermSP, mscAtmIfPnniRccRemotePortId=mscAtmIfPnniRccRemotePortId, mscAtmIfPnniSigProvEntry=mscAtmIfPnniSigProvEntry, mscAtmIfPnniRccVci=mscAtmIfPnniRccVci, mscAtmIfPnniRccIndex=mscAtmIfPnniRccIndex, mscAtmIfVptPnniRccHlParmsEntry=mscAtmIfVptPnniRccHlParmsEntry, mscAtmIfVptPnniSigVcd=mscAtmIfVptPnniSigVcd, mscAtmIfPnniRowStatusEntry=mscAtmIfPnniRowStatusEntry, mscAtmIfPnniRccHelloState=mscAtmIfPnniRccHelloState, mscAtmIfPnniRccHlParmsEntry=mscAtmIfPnniRccHlParmsEntry, mscAtmIfPnniSigVcdQosClass=mscAtmIfPnniSigVcdQosClass, mscAtmIfPnniRccVcdTrafficShaping=mscAtmIfPnniRccVcdTrafficShaping, mscAtmIfVptPnniAddrAddressIndex=mscAtmIfVptPnniAddrAddressIndex, mscAtmIfVptPnniSigFailedPmpConnections=mscAtmIfVptPnniSigFailedPmpConnections, mscAtmIfVptPnniRccHelloInterval=mscAtmIfVptPnniRccHelloInterval, mscAtmIfPnniAddrAddressTypeIndex=mscAtmIfPnniAddrAddressTypeIndex, mscAtmIfVptPnniSigLastTxDiagCode=mscAtmIfVptPnniSigLastTxDiagCode, mscAtmIfVptPnniAddrPnniInfo=mscAtmIfVptPnniAddrPnniInfo, mscAtmIfPnniAddrPnniInfoComponentName=mscAtmIfPnniAddrPnniInfoComponentName, mscAtmIfPnniRccVcdProvTable=mscAtmIfPnniRccVcdProvTable, mscAtmIfVptPnniSigRowStatusEntry=mscAtmIfVptPnniSigRowStatusEntry, mscAtmIfPnniSigVcdTdpTable=mscAtmIfPnniSigVcdTdpTable, mscAtmIfPnniSigVcdTdpValue=mscAtmIfPnniSigVcdTdpValue, mscAtmIfPnniProvEntry=mscAtmIfPnniProvEntry, mscAtmIfPnniSigVcdProvTable=mscAtmIfPnniSigVcdProvTable, mscAtmIfPnniAddrTermSPComponentName=mscAtmIfPnniAddrTermSPComponentName, mscAtmIfVptPnniSigOperTable=mscAtmIfVptPnniSigOperTable, mscAtmIfVptPnniAddrTermSPComponentName=mscAtmIfVptPnniAddrTermSPComponentName, mscAtmIfVptPnniRccRowStatusEntry=mscAtmIfVptPnniRccRowStatusEntry, mscAtmIfVptPnniSigComponentName=mscAtmIfVptPnniSigComponentName, mscAtmIfPnniAddrPnniInfo=mscAtmIfPnniAddrPnniInfo, mscAtmIfVptPnniSigIndex=mscAtmIfVptPnniSigIndex, mscAtmIfPnniAddrRowStatus=mscAtmIfPnniAddrRowStatus, atmPnniGroupCA02A=atmPnniGroupCA02A, mscAtmIfVptPnniSigOperatingMode=mscAtmIfVptPnniSigOperatingMode, mscAtmIfPnniSigIndex=mscAtmIfPnniSigIndex, mscAtmIfPnniRccHelloPacketsRx=mscAtmIfPnniRccHelloPacketsRx, mscAtmIfPnniRccVcdAtmServiceCategory=mscAtmIfPnniRccVcdAtmServiceCategory, mscAtmIfPnniSigStorageType=mscAtmIfPnniSigStorageType, mscAtmIfPnniRccStatsEntry=mscAtmIfPnniRccStatsEntry, mscAtmIfPnniIndex=mscAtmIfPnniIndex, mscAtmIfVptPnniRccStatsEntry=mscAtmIfVptPnniRccStatsEntry, mscAtmIfVptPnniAddrPnniInfoReachability=mscAtmIfVptPnniAddrPnniInfoReachability, mscAtmIfPnniRcc=mscAtmIfPnniRcc, mscAtmIfVptPnniSigVci=mscAtmIfVptPnniSigVci, mscAtmIfVptPnniRccRemotePortId=mscAtmIfVptPnniRccRemotePortId, mscAtmIfVptPnniSigVcdRowStatusEntry=mscAtmIfVptPnniSigVcdRowStatusEntry, mscAtmIfVptPnniNrtVbrWeight=mscAtmIfVptPnniNrtVbrWeight, mscAtmIfVptPnniVProvTable=mscAtmIfVptPnniVProvTable, mscAtmIfPnniAddrPnniInfoIndex=mscAtmIfPnniAddrPnniInfoIndex, mscAtmIfPnniRccVcdIndex=mscAtmIfPnniRccVcdIndex, mscAtmIfVptPnniRccVcdStorageType=mscAtmIfVptPnniRccVcdStorageType, mscAtmIfVptPnniRccVci=mscAtmIfVptPnniRccVci, mscAtmIfVptPnniVpci=mscAtmIfVptPnniVpci, mscAtmIfPnniSigVcdUnshapedTransmitQueueing=mscAtmIfPnniSigVcdUnshapedTransmitQueueing, mscAtmIfVptPnniRccHelloHoldDown=mscAtmIfVptPnniRccHelloHoldDown, mscAtmIfVptPnniRccVcdTdpValue=mscAtmIfVptPnniRccVcdTdpValue, mscAtmIfVptPnniSig=mscAtmIfVptPnniSig, mscAtmIfVptPnniRccAdminState=mscAtmIfVptPnniRccAdminState, mscAtmIfPnniSigVcdRowStatus=mscAtmIfPnniSigVcdRowStatus, mscAtmIfVptPnniSigCurrentConnections=mscAtmIfVptPnniSigCurrentConnections, mscAtmIfVptPnniRccIndex=mscAtmIfVptPnniRccIndex, mscAtmIfVptPnniSigVcdUsageParameterControl=mscAtmIfVptPnniSigVcdUsageParameterControl, mscAtmIfVptPnniSoftPvpAndPvcRetryPeriod=mscAtmIfVptPnniSoftPvpAndPvcRetryPeriod, mscAtmIfVptPnniRccOperEntry=mscAtmIfVptPnniRccOperEntry, mscAtmIfPnniSigRxPdus=mscAtmIfPnniSigRxPdus, mscAtmIfVptPnniRccHelloInactivityFactor=mscAtmIfVptPnniRccHelloInactivityFactor, mscAtmIfVptPnniRccOperTable=mscAtmIfVptPnniRccOperTable, mscAtmIfPnniSigStatsTable=mscAtmIfPnniSigStatsTable, mscAtmIfPnniSigVcdProvEntry=mscAtmIfPnniSigVcdProvEntry, mscAtmIfVptPnniSigVcdUnshapedTransmitQueueing=mscAtmIfVptPnniSigVcdUnshapedTransmitQueueing, mscAtmIfPnniSigVcdWeight=mscAtmIfPnniSigVcdWeight, mscAtmIfVptPnniSigTxPdus=mscAtmIfVptPnniSigTxPdus, mscAtmIfPnniSigSuccessfulConnections=mscAtmIfPnniSigSuccessfulConnections, mscAtmIfPnniAddrScope=mscAtmIfPnniAddrScope, mscAtmIfPnniRowStatus=mscAtmIfPnniRowStatus, mscAtmIfVptPnniSigVcdWeight=mscAtmIfVptPnniSigVcdWeight, mscAtmIfPnniAddrPnniInfoRowStatusTable=mscAtmIfPnniAddrPnniInfoRowStatusTable, mscAtmIfPnniSigStatsEntry=mscAtmIfPnniSigStatsEntry, mscAtmIfVptPnniAddrPnniInfoRowStatusEntry=mscAtmIfVptPnniAddrPnniInfoRowStatusEntry, mscAtmIfPnniRccStateTable=mscAtmIfPnniRccStateTable, mscAtmIfVptPnniRccVcdProvEntry=mscAtmIfVptPnniRccVcdProvEntry, mscAtmIfVptPnniRccBadHelloPacketsRx=mscAtmIfVptPnniRccBadHelloPacketsRx, mscAtmIfPnniRccVcdQosClass=mscAtmIfPnniRccVcdQosClass, mscAtmIfVptPnniUbrWeight=mscAtmIfVptPnniUbrWeight, mscAtmIfVptPnniAddrOperEntry=mscAtmIfVptPnniAddrOperEntry, mscAtmIfPnniRccMismatchedHelloPacketsRx=mscAtmIfPnniRccMismatchedHelloPacketsRx, atmPnniCapabilities=atmPnniCapabilities, mscAtmIfPnniSigOperatingMode=mscAtmIfPnniSigOperatingMode, mscAtmIfVptPnniOperationalEntry=mscAtmIfVptPnniOperationalEntry, mscAtmIfVptPnni=mscAtmIfVptPnni, mscAtmIfPnniSigVci=mscAtmIfPnniSigVci, mscAtmIfPnniComponentName=mscAtmIfPnniComponentName, mscAtmIfPnniRtVbrWeight=mscAtmIfPnniRtVbrWeight, mscAtmIfPnniNrtVbrWeight=mscAtmIfPnniNrtVbrWeight, mscAtmIfPnniRccVcdStorageType=mscAtmIfPnniRccVcdStorageType, mscAtmIfVptPnniAddrAddressTypeIndex=mscAtmIfVptPnniAddrAddressTypeIndex, mscAtmIfVptPnniSigLastRxDiagCode=mscAtmIfVptPnniSigLastRxDiagCode, mscAtmIfVptPnniSigVcdProvEntry=mscAtmIfVptPnniSigVcdProvEntry, mscAtmIfPnniSigVcd=mscAtmIfPnniSigVcd, mscAtmIfVptPnniSigProvEntry=mscAtmIfVptPnniSigProvEntry, mscAtmIfVptPnniSoftPvcRetryPeriod=mscAtmIfVptPnniSoftPvcRetryPeriod, mscAtmIfPnniRccHelloPacketsTx=mscAtmIfPnniRccHelloPacketsTx, mscAtmIfPnniAccountClass=mscAtmIfPnniAccountClass, mscAtmIfVptPnniAddrStorageType=mscAtmIfVptPnniAddrStorageType, mscAtmIfVptPnniSigVcdTdpValue=mscAtmIfVptPnniSigVcdTdpValue, mscAtmIfPnniRowStatusTable=mscAtmIfPnniRowStatusTable, mscAtmIfPnniRccHlParmsTable=mscAtmIfPnniRccHlParmsTable, mscAtmIfVptPnniAddrTermSPRowStatus=mscAtmIfVptPnniAddrTermSPRowStatus, mscAtmIfPnniRccVcdTdpIndex=mscAtmIfPnniRccVcdTdpIndex, mscAtmIfVptPnniRccVcdWeight=mscAtmIfVptPnniRccVcdWeight, mscAtmIfVptPnniAddrComponentName=mscAtmIfVptPnniAddrComponentName, mscAtmIfPnniRccHelloInterval=mscAtmIfPnniRccHelloInterval, mscAtmIfVptPnniRccComponentName=mscAtmIfVptPnniRccComponentName, mscAtmIfVptPnniAddrScope=mscAtmIfVptPnniAddrScope, atmPnniCapabilitiesCA=atmPnniCapabilitiesCA, mscAtmIfVptPnniSigVcdRowStatusTable=mscAtmIfVptPnniSigVcdRowStatusTable, mscAtmIfPnniSigVcdComponentName=mscAtmIfPnniSigVcdComponentName, mscAtmIfVptPnniStorageType=mscAtmIfVptPnniStorageType, mscAtmIfVptPnniRccHlParmsTable=mscAtmIfVptPnniRccHlParmsTable, mscAtmIfPnniAddrOperTable=mscAtmIfPnniAddrOperTable, mscAtmIfVptPnniRccProvEntry=mscAtmIfVptPnniRccProvEntry, mscAtmIfPnniRccVcdRowStatus=mscAtmIfPnniRccVcdRowStatus, mscAtmIfVptPnniSigStorageType=mscAtmIfVptPnniSigStorageType, atmPnniCapabilitiesCA02=atmPnniCapabilitiesCA02, mscAtmIfPnniSigVcdTdpEntry=mscAtmIfPnniSigVcdTdpEntry, mscAtmIfPnniSig=mscAtmIfPnniSig, mscAtmIfPnniUbrWeight=mscAtmIfPnniUbrWeight, mscAtmIfPnniSigFailedPmpConnections=mscAtmIfPnniSigFailedPmpConnections, mscAtmIfVptPnniAddrRowStatus=mscAtmIfVptPnniAddrRowStatus, mscAtmIfPnniSoftPvcRetryPeriod=mscAtmIfPnniSoftPvcRetryPeriod, mscAtmIfVptPnniRccVcdQosClass=mscAtmIfVptPnniRccVcdQosClass, mscAtmIfPnniRccVcdUnshapedTransmitQueueing=mscAtmIfPnniRccVcdUnshapedTransmitQueueing, mscAtmIfPnniRccHelloHoldDown=mscAtmIfPnniRccHelloHoldDown, mscAtmIfPnniRccOperTable=mscAtmIfPnniRccOperTable, mscAtmIfPnniAddrTermSPRowStatusEntry=mscAtmIfPnniAddrTermSPRowStatusEntry, mscAtmIfPnniStorageType=mscAtmIfPnniStorageType, mscAtmIfVptPnniSigVcdTdpIndex=mscAtmIfVptPnniSigVcdTdpIndex, mscAtmIfVptPnniRccStatsTable=mscAtmIfVptPnniRccStatsTable, mscAtmIfPnniAddrPnniInfoRowStatus=mscAtmIfPnniAddrPnniInfoRowStatus, mscAtmIfVptPnniRccVcdTdpTable=mscAtmIfVptPnniRccVcdTdpTable, mscAtmIfPnniSigPeakPmpConnections=mscAtmIfPnniSigPeakPmpConnections, mscAtmIfPnni=mscAtmIfPnni, mscAtmIfPnniAddrAddressIndex=mscAtmIfPnniAddrAddressIndex, mscAtmIfVptPnniServiceExchange=mscAtmIfVptPnniServiceExchange, mscAtmIfVptPnniRccStorageType=mscAtmIfVptPnniRccStorageType, mscAtmIfPnniAdminWeightsTable=mscAtmIfPnniAdminWeightsTable, mscAtmIfPnniRccRowStatusTable=mscAtmIfPnniRccRowStatusTable, mscAtmIfVptPnniVProvEntry=mscAtmIfVptPnniVProvEntry, mscAtmIfPnniRccVcdTdpEntry=mscAtmIfPnniRccVcdTdpEntry, mscAtmIfVptPnniSigRowStatus=mscAtmIfVptPnniSigRowStatus, mscAtmIfPnniRccHelloInactivityFactor=mscAtmIfPnniRccHelloInactivityFactor, mscAtmIfPnniRccBadHelloPacketsRx=mscAtmIfPnniRccBadHelloPacketsRx, mscAtmIfPnniAddrRowStatusEntry=mscAtmIfPnniAddrRowStatusEntry, mscAtmIfPnniRccVcdRowStatusEntry=mscAtmIfPnniRccVcdRowStatusEntry, mscAtmIfPnniSigVcdIndex=mscAtmIfPnniSigVcdIndex, mscAtmIfPnniOperationalTable=mscAtmIfPnniOperationalTable, mscAtmIfPnniSigComponentName=mscAtmIfPnniSigComponentName, mscAtmIfVptPnniRccRowStatusTable=mscAtmIfVptPnniRccRowStatusTable, mscAtmIfPnniSigStateEntry=mscAtmIfPnniSigStateEntry, mscAtmIfPnniSigUsageState=mscAtmIfPnniSigUsageState, mscAtmIfVptPnniSigVcdTdpEntry=mscAtmIfVptPnniSigVcdTdpEntry, mscAtmIfVptPnniAddrPnniInfoIndex=mscAtmIfVptPnniAddrPnniInfoIndex, mscAtmIfVptPnniAddrTermSPStorageType=mscAtmIfVptPnniAddrTermSPStorageType, mscAtmIfPnniRccType=mscAtmIfPnniRccType, mscAtmIfVptPnniSigLastRxCauseCode=mscAtmIfVptPnniSigLastRxCauseCode, mscAtmIfVptPnniAddrPnniInfoRowStatus=mscAtmIfVptPnniAddrPnniInfoRowStatus, mscAtmIfPnniRccProvEntry=mscAtmIfPnniRccProvEntry, mscAtmIfPnniSigNewCurrentConnections=mscAtmIfPnniSigNewCurrentConnections, mscAtmIfPnniAddrPnniInfoReachability=mscAtmIfPnniAddrPnniInfoReachability, mscAtmIfPnniSigLastTxDiagCode=mscAtmIfPnniSigLastTxDiagCode, mscAtmIfPnniRccVcdUsageParameterControl=mscAtmIfPnniRccVcdUsageParameterControl, mscAtmIfPnniProvTable=mscAtmIfPnniProvTable, mscAtmIfPnniRccUsageState=mscAtmIfPnniRccUsageState, mscAtmIfPnniRccStorageType=mscAtmIfPnniRccStorageType, mscAtmIfVptPnniAddrTermSPRowStatusTable=mscAtmIfVptPnniAddrTermSPRowStatusTable, mscAtmIfPnniSigRowStatusTable=mscAtmIfPnniSigRowStatusTable, mscAtmIfVptPnniRccUsageState=mscAtmIfVptPnniRccUsageState, mscAtmIfPnniSigFailedConnections=mscAtmIfPnniSigFailedConnections, mscAtmIfVptPnniSigSuccessfulConnections=mscAtmIfVptPnniSigSuccessfulConnections, mscAtmIfPnniSigVcdTrafficShaping=mscAtmIfPnniSigVcdTrafficShaping, mscAtmIfPnniAddrReachability=mscAtmIfPnniAddrReachability, mscAtmIfVptPnniAddrPnniInfoProvEntry=mscAtmIfVptPnniAddrPnniInfoProvEntry, mscAtmIfVptPnniRccProvTable=mscAtmIfVptPnniRccProvTable, mscAtmIfVptPnniSigSuccessfulPmpConnections=mscAtmIfVptPnniSigSuccessfulPmpConnections, mscAtmIfPnniSigVcdRowStatusEntry=mscAtmIfPnniSigVcdRowStatusEntry, mscAtmIfVptPnniSigStatsTable=mscAtmIfVptPnniSigStatsTable, mscAtmIfVptPnniRccVcdTrafficDescType=mscAtmIfVptPnniRccVcdTrafficDescType, mscAtmIfPnniSigLastRxDiagCode=mscAtmIfPnniSigLastRxDiagCode, mscAtmIfVptPnniRccVcdUsageParameterControl=mscAtmIfVptPnniRccVcdUsageParameterControl, mscAtmIfVptPnniRtVbrWeight=mscAtmIfVptPnniRtVbrWeight, mscAtmIfVptPnniAdminWeightsEntry=mscAtmIfVptPnniAdminWeightsEntry, mscAtmIfVptPnniSigVcdRowStatus=mscAtmIfVptPnniSigVcdRowStatus, mscAtmIfVptPnniSigRowStatusTable=mscAtmIfVptPnniSigRowStatusTable, mscAtmIfPnniSigTxPdus=mscAtmIfPnniSigTxPdus, mscAtmIfVptPnniSigRxPdus=mscAtmIfVptPnniSigRxPdus)
mibBuilder.exportSymbols("Nortel-MsCarrier-MscPassport-AtmPnniMIB", mscAtmIfVptPnniRccMismatchedHelloPacketsRx=mscAtmIfVptPnniRccMismatchedHelloPacketsRx, mscAtmIfVptPnniProvEntry=mscAtmIfVptPnniProvEntry, mscAtmIfPnniSigVcdStorageType=mscAtmIfPnniSigVcdStorageType, mscAtmIfVptPnniCbrWeight=mscAtmIfVptPnniCbrWeight, mscAtmIfVptPnniSigOperEntry=mscAtmIfVptPnniSigOperEntry, mscAtmIfPnniRccRowStatus=mscAtmIfPnniRccRowStatus, mscAtmIfPnniServiceExchange=mscAtmIfPnniServiceExchange, mscAtmIfPnniOperationalEntry=mscAtmIfPnniOperationalEntry, mscAtmIfVptPnniAcctOptEntry=mscAtmIfVptPnniAcctOptEntry, mscAtmIfPnniAccountCollection=mscAtmIfPnniAccountCollection, mscAtmIfPnniSigVcdRowStatusTable=mscAtmIfPnniSigVcdRowStatusTable, mscAtmIfPnniAddrStorageType=mscAtmIfPnniAddrStorageType, mscAtmIfVptPnniAddrRowStatusTable=mscAtmIfVptPnniAddrRowStatusTable, mscAtmIfPnniRccOperationalState=mscAtmIfPnniRccOperationalState, mscAtmIfVptPnniSigNewCurrentConnections=mscAtmIfVptPnniSigNewCurrentConnections, mscAtmIfPnniRccStateEntry=mscAtmIfPnniRccStateEntry, mscAtmIfVptPnniRccStateTable=mscAtmIfVptPnniRccStateTable, mscAtmIfVptPnniAddr=mscAtmIfVptPnniAddr, mscAtmIfPnniSigStateTable=mscAtmIfPnniSigStateTable, atmPnniGroupCA02=atmPnniGroupCA02, mscAtmIfVptPnniSigVcdTrafficShaping=mscAtmIfVptPnniSigVcdTrafficShaping, mscAtmIfPnniSigOperEntry=mscAtmIfPnniSigOperEntry, mscAtmIfPnniRccRemoteNodeId=mscAtmIfPnniRccRemoteNodeId, mscAtmIfVptPnniAccountCollection=mscAtmIfVptPnniAccountCollection, mscAtmIfPnniRccRowStatusEntry=mscAtmIfPnniRccRowStatusEntry, mscAtmIfVptPnniRccNegotiatedVersion=mscAtmIfVptPnniRccNegotiatedVersion, mscAtmIfPnniRccAdminState=mscAtmIfPnniRccAdminState, mscAtmIfVptPnniRccRowStatus=mscAtmIfVptPnniRccRowStatus, mscAtmIfVptPnniSigAddressConversion=mscAtmIfVptPnniSigAddressConversion, mscAtmIfVptPnniRccVcdTdpIndex=mscAtmIfVptPnniRccVcdTdpIndex, mscAtmIfVptPnniSigStateEntry=mscAtmIfVptPnniSigStateEntry, mscAtmIfPnniSigOperationalState=mscAtmIfPnniSigOperationalState, mscAtmIfPnniSigRowStatus=mscAtmIfPnniSigRowStatus, mscAtmIfPnniRccComponentName=mscAtmIfPnniRccComponentName, mscAtmIfPnniAddrComponentName=mscAtmIfPnniAddrComponentName, mscAtmIfVptPnniRccHelloPacketsTx=mscAtmIfVptPnniRccHelloPacketsTx, mscAtmIfVptPnniRccVcdUnshapedTransmitQueueing=mscAtmIfVptPnniRccVcdUnshapedTransmitQueueing, mscAtmIfPnniRccNegotiatedVersion=mscAtmIfPnniRccNegotiatedVersion, mscAtmIfVptPnniAddrRowStatusEntry=mscAtmIfVptPnniAddrRowStatusEntry, mscAtmIfVptPnniAccountConnectionType=mscAtmIfVptPnniAccountConnectionType, mscAtmIfVptPnniComponentName=mscAtmIfVptPnniComponentName, mscAtmIfPnniAcctOptEntry=mscAtmIfPnniAcctOptEntry, mscAtmIfPnniRccVcdTdpTable=mscAtmIfPnniRccVcdTdpTable, mscAtmIfVptPnniSigUsageState=mscAtmIfVptPnniSigUsageState, mscAtmIfVptPnniSigVcdAtmServiceCategory=mscAtmIfVptPnniSigVcdAtmServiceCategory, mscAtmIfVptPnniSigCurrentPmpConnections=mscAtmIfVptPnniSigCurrentPmpConnections, mscAtmIfVptPnniAddrPnniInfoProvTable=mscAtmIfVptPnniAddrPnniInfoProvTable, mscAtmIfPnniSigAddressConversion=mscAtmIfPnniSigAddressConversion, mscAtmIfVptPnniRccVcd=mscAtmIfVptPnniRccVcd, mscAtmIfPnniCbrWeight=mscAtmIfPnniCbrWeight, mscAtmIfPnniRccProvTable=mscAtmIfPnniRccProvTable, mscAtmIfPnniAddrPnniInfoProvTable=mscAtmIfPnniAddrPnniInfoProvTable, mscAtmIfVptPnniAddrTermSPIndex=mscAtmIfVptPnniAddrTermSPIndex, mscAtmIfPnniAddrTermSPRowStatusTable=mscAtmIfPnniAddrTermSPRowStatusTable, mscAtmIfVptPnniAccountClass=mscAtmIfVptPnniAccountClass, mscAtmIfVptPnniRccType=mscAtmIfVptPnniRccType, mscAtmIfVptPnniAcctOptTable=mscAtmIfVptPnniAcctOptTable, mscAtmIfVptPnniRccVcdRowStatusTable=mscAtmIfVptPnniRccVcdRowStatusTable, mscAtmIfVptPnniAddrPnniInfoStorageType=mscAtmIfVptPnniAddrPnniInfoStorageType, mscAtmIfVptPnniRccVcdTdpEntry=mscAtmIfVptPnniRccVcdTdpEntry, mscAtmIfPnniSigCurrentConnections=mscAtmIfPnniSigCurrentConnections, mscAtmIfPnniRccVcdComponentName=mscAtmIfPnniRccVcdComponentName, mscAtmIfVptPnniRccVcdTrafficShaping=mscAtmIfVptPnniRccVcdTrafficShaping, mscAtmIfPnniSigVcdUsageParameterControl=mscAtmIfPnniSigVcdUsageParameterControl, mscAtmIfPnniSoftPvpAndPvcHoldOffTime=mscAtmIfPnniSoftPvpAndPvcHoldOffTime, mscAtmIfPnniAddrTermSPRowStatus=mscAtmIfPnniAddrTermSPRowStatus, mscAtmIfVptPnniRccVcdRowStatus=mscAtmIfVptPnniRccVcdRowStatus, mscAtmIfVptPnniSigStateTable=mscAtmIfVptPnniSigStateTable, mscAtmIfVptPnniSoftPvpAndPvcHoldOffTime=mscAtmIfVptPnniSoftPvpAndPvcHoldOffTime, mscAtmIfPnniAddrPnniInfoScope=mscAtmIfPnniAddrPnniInfoScope, mscAtmIfVptPnniSigPeakPmpConnections=mscAtmIfVptPnniSigPeakPmpConnections, mscAtmIfVptPnniRccVcdProvTable=mscAtmIfVptPnniRccVcdProvTable, mscAtmIfPnniAddrPnniInfoStorageType=mscAtmIfPnniAddrPnniInfoStorageType, mscAtmIfVptPnniSigFailedConnections=mscAtmIfVptPnniSigFailedConnections, atmPnniGroup=atmPnniGroup, mscAtmIfPnniSigSuccessfulPmpConnections=mscAtmIfPnniSigSuccessfulPmpConnections, mscAtmIfVptPnniAddrPnniInfoScope=mscAtmIfVptPnniAddrPnniInfoScope, mscAtmIfVptPnniRcc=mscAtmIfVptPnniRcc, mscAtmIfVptPnniRccVcdComponentName=mscAtmIfVptPnniRccVcdComponentName, mscAtmIfPnniSoftPvpAndPvcRetryPeriod=mscAtmIfPnniSoftPvpAndPvcRetryPeriod, mscAtmIfVptPnniSigStatsEntry=mscAtmIfVptPnniSigStatsEntry, mscAtmIfVptPnniSigVcdProvTable=mscAtmIfVptPnniSigVcdProvTable, mscAtmIfPnniSigVcdAtmServiceCategory=mscAtmIfPnniSigVcdAtmServiceCategory, mscAtmIfVptPnniAdminWeightsTable=mscAtmIfVptPnniAdminWeightsTable, mscAtmIfVptPnniRccVcdRowStatusEntry=mscAtmIfVptPnniRccVcdRowStatusEntry, mscAtmIfPnniRccVcdRowStatusTable=mscAtmIfPnniRccVcdRowStatusTable, mscAtmIfPnniAddrTermSPStorageType=mscAtmIfPnniAddrTermSPStorageType, mscAtmIfPnniSigOperTable=mscAtmIfPnniSigOperTable, mscAtmIfVptPnniAddrPnniInfoRowStatusTable=mscAtmIfVptPnniAddrPnniInfoRowStatusTable, mscAtmIfPnniSigCurrentPmpConnections=mscAtmIfPnniSigCurrentPmpConnections)

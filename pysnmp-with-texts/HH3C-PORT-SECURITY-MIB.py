#
# PySNMP MIB module HH3C-PORT-SECURITY-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/HH3C-PORT-SECURITY-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:28:58 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ConstraintsUnion, ValueSizeConstraint, SingleValueConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ConstraintsUnion", "ValueSizeConstraint", "SingleValueConstraint", "ConstraintsIntersection")
hh3cPortSecurity, = mibBuilder.importSymbols("HH3C-OID-MIB", "hh3cPortSecurity")
dot1xAuthSessionTerminateCause, dot1xAuthSessionUserName, dot1xPaePortNumber, dot1xAuthSessionAuthenticMethod = mibBuilder.importSymbols("IEEE8021-PAE-MIB", "dot1xAuthSessionTerminateCause", "dot1xAuthSessionUserName", "dot1xPaePortNumber", "dot1xAuthSessionAuthenticMethod")
ifAdminStatus, ifIndex = mibBuilder.importSymbols("IF-MIB", "ifAdminStatus", "ifIndex")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
TimeTicks, ObjectIdentity, Counter64, IpAddress, MibScalar, MibTable, MibTableRow, MibTableColumn, Integer32, NotificationType, iso, Bits, Unsigned32, MibIdentifier, Gauge32, Counter32, ModuleIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "TimeTicks", "ObjectIdentity", "Counter64", "IpAddress", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Integer32", "NotificationType", "iso", "Bits", "Unsigned32", "MibIdentifier", "Gauge32", "Counter32", "ModuleIdentity")
TruthValue, MacAddress, DisplayString, RowStatus, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "TruthValue", "MacAddress", "DisplayString", "RowStatus", "TextualConvention")
hh3cPortSecurityMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 25506, 2, 26, 1))
hh3cPortSecurityMIB.setRevisions(('2004-11-24 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: hh3cPortSecurityMIB.setRevisionsDescriptions(('The Initial Version of hh3cPortSecurityMIB',))
if mibBuilder.loadTexts: hh3cPortSecurityMIB.setLastUpdated('200411240000Z')
if mibBuilder.loadTexts: hh3cPortSecurityMIB.setOrganization('Hangzhou H3C Tech. Co., Ltd.')
if mibBuilder.loadTexts: hh3cPortSecurityMIB.setContactInfo('Platform Team Hangzhou H3C Tech. Co., Ltd. Hai-Dian District Beijing P.R. China http://www.h3c.com Zip:100085 ')
if mibBuilder.loadTexts: hh3cPortSecurityMIB.setDescription('The MIB module is used for managing port security.')
hh3cPortSecurityLeaf = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 26, 1, 1))
hh3cSecurePortSecurityControl = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 26, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cSecurePortSecurityControl.setStatus('current')
if mibBuilder.loadTexts: hh3cSecurePortSecurityControl.setDescription('This attribute controls the system wide operation of network access control. The configured port security options only become operational when this attribute is set to enabled.')
hh3cSecurePortVlanMembershipList = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 26, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hh3cSecurePortVlanMembershipList.setStatus('current')
if mibBuilder.loadTexts: hh3cSecurePortVlanMembershipList.setDescription("This is a dummy MIB object referenced by the hh3csecureLogon and hh3csecureLogoff traps. This object contains a comma separated list of the VLAN identifiers (0-4095) assigned to a port. A tagged VLAN has a 'T' suffix after the VLAN number and an untagged VLAN may have an optional 'U' suffix.")
hh3cSecureRalmObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 26, 1, 1, 4))
hh3cSecureRalmDefaultSessionTime = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 26, 1, 1, 4, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cSecureRalmDefaultSessionTime.setStatus('current')
if mibBuilder.loadTexts: hh3cSecureRalmDefaultSessionTime.setDescription('Specifies the default session lifetime in seconds before a forwarding MAC address is re-authenticated. The default time is 1800 seconds.')
hh3cSecureRalmHoldoffTime = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 26, 1, 1, 4, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cSecureRalmHoldoffTime.setStatus('current')
if mibBuilder.loadTexts: hh3cSecureRalmHoldoffTime.setDescription('Specifies the time in seconds before a blocked (denied) MAC address can be re-authenticated. The default time is 60 seconds.')
hh3cSecureRalmReauthenticate = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 26, 1, 1, 4, 3), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cSecureRalmReauthenticate.setStatus('current')
if mibBuilder.loadTexts: hh3cSecureRalmReauthenticate.setDescription('Writing a MAC address to this object causes an immediate RALM re-authentication of this address (can be on any port). If the MAC address not currently known to RALM, it silently ignores the write.')
hh3cSecureRalmAuthMode = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 26, 1, 1, 4, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("papUsernameAsMacAddress", 1), ("papUsernameFixed", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cSecureRalmAuthMode.setStatus('current')
if mibBuilder.loadTexts: hh3cSecureRalmAuthMode.setDescription("This controls how MAC addresses are authenticated. papUsernameAsMacAddress(1) Authentication uses the RADIUS server by sending a PAP request with Username and Password both equal to the MAC address being authenticated. This is the default. papUsernameFixed(2) Authentication uses the RADIUS server by sending a PAP request with Username and Password coming from the hh3cSecureRalmAuthUsername and hh3cSecureRalmAuthPassword MIB objects. In this mode the RADIUS server would normally take into account the request's calling-station-id attribute, which is the MAC address of the host being authenticated.")
hh3cSecureRalmAuthUsername = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 26, 1, 1, 4, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cSecureRalmAuthUsername.setStatus('current')
if mibBuilder.loadTexts: hh3cSecureRalmAuthUsername.setDescription("This is the username used for authentication requests where hh3cSecureRalmAuthMode is papUsernameFixed. Default shall be 'mac'.")
hh3cSecureRalmAuthPassword = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 26, 1, 1, 4, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cSecureRalmAuthPassword.setStatus('current')
if mibBuilder.loadTexts: hh3cSecureRalmAuthPassword.setDescription('This is the password used for authentication requests where hh3cSecureRalmAuthMode is papUsernameFixed. Default shall be a null string.')
hh3cSecureRalmAuthDomain = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 26, 1, 1, 4, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 24))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cSecureRalmAuthDomain.setStatus('current')
if mibBuilder.loadTexts: hh3cSecureRalmAuthDomain.setDescription('MAC-authentication users may be configured in a specific domain, which excludes 802.1x and other authentication users. This specifies the domain of all MAC-authentication users.')
hh3cSecureRalmAuthOfflineTime = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 26, 1, 1, 4, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(300)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cSecureRalmAuthOfflineTime.setStatus('current')
if mibBuilder.loadTexts: hh3cSecureRalmAuthOfflineTime.setDescription("Switch isn't informed when online user is offline, so switch should be able to detect offline and inform radius server to stop accounting when there is no traffic of the user. This attribute configures the timer interval of offline-detect. The default time is 300 seconds.")
hh3cSecureRalmAuthServerTimeoutTime = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 26, 1, 1, 4, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cSecureRalmAuthServerTimeoutTime.setStatus('current')
if mibBuilder.loadTexts: hh3cSecureRalmAuthServerTimeoutTime.setDescription('When switch sends request packets (include connecting request and offline request, etc) to radius server and there is no response, switch will terminate the authentication process. This attribute configures the timer interval of server-timeout. The default time is 100 seconds.')
hh3cSecureMacControl = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 26, 1, 1, 4, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cSecureMacControl.setStatus('current')
if mibBuilder.loadTexts: hh3cSecureMacControl.setDescription('This attribute controls the system wide operation of mac-authentication. The system-wide mac-authentication options become non-operational when this attribute is set to disabled. This is required for hh3cSecurePortSecurityControl to be enabled.')
hh3cPortSecurityTables = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 26, 1, 2))
hh3cSecurePortTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 26, 1, 2, 1), )
if mibBuilder.loadTexts: hh3cSecurePortTable.setStatus('current')
if mibBuilder.loadTexts: hh3cSecurePortTable.setDescription('This table defines the security status of each secure port. Each port can have a number of authorised MAC addresses, and these are stored in the hh3cSecureAddressTable.')
hh3cSecurePortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 26, 1, 2, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: hh3cSecurePortEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cSecurePortEntry.setDescription('There is a row in this table for each secure port, and allows repeater ports to be configured for security on a per port basis. It is indexed using the object ifIndex in RFC1213-MIB.')
hh3cSecurePortMode = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 26, 1, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))).clone(namedValues=NamedValues(("noRestrictions", 1), ("continuousLearning", 2), ("autoLearn", 3), ("secure", 4), ("userLogin", 5), ("userLoginSecure", 6), ("userLoginWithOUI", 7), ("macAddressWithRadius", 8), ("macAddressOrUserLoginSecure", 9), ("macAddressElseUserLoginSecure", 10), ("userLoginSecureExt", 11), ("macAddressOrUserLoginSecureExt", 12), ("macAddressElseUserLoginSecureExt", 13), ("macAddressAndUserLoginSecure", 14), ("macAddressAndUserLoginSecureExt", 15)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cSecurePortMode.setStatus('current')
if mibBuilder.loadTexts: hh3cSecurePortMode.setDescription('Determines the learning and security modes of the port. See hh3cSecureNeedToKnowMode and hh3cSecureIntrusionAction to configure Need To Know and Intrusion Action on each port. (When in a learning mode, hh3cSecureNumberAddresses determines the maximum number of addresses that can be learned on the port. This is set by the user.) noRestrictions(1) All of the security features are disabled. continuousLearning(2) Addresses are learned continually. If more addresses are learned than are permitted on the port, then one of the older entries will be aged out. Need To Know and Intrusion Action depends on hh3cSecureNeedToKnowMode and hh3cSecureIntrusionAction respectively. autoLearn(3) All addresses for this port are deleted, and then addresses are learned up to the number permitted. hh3cSecurePortMode is then set to secure. Need To Know and Intrusion Action depends on hh3cSecureNeedToKnowMode and hh3cSecureIntrusionAction respectively. secure(4) Learning is disabled. Need To Know and Intrusion Action depends on hh3cSecureNeedToKnowMode and hh3cSecureIntrusionAction respectively. userLogin(5) Access to the port is denied until the port client is authorised (by 802.1X or other authentication mechanism). Once authorised, traffic will be accepted from any MAC address. The Need To Know and Intrusion Action are ignored. userLoginSecure(6) Access to the port is denied until the port client is authorised (by 802.1X or other authentication mechanism). When the client is authorised, the MAC address is added to the Secure Address Table. The hh3cSecureMaximumAddresses is set to one automatically when this mode is entered. Any existing MAC addresses in the Secure Address Table are deleted. Need To Know and Intrusion Action depends on hh3cSecureNeedToKnowMode and hh3cSecureIntrusionAction respectively. Learning is disabled. userLoginWithOUI(7) This mode is similar to the userLoginSecure mode except that a second MAC address may be placed in the Secure Address Table. This second address is authorised based on the MAC address OUI value. If a new device with an authorised OUI value is discovered, the previous entry is deleted. Traffic from the OUI authorised device will be accepted even if the user has not been authenticated. Need To Know and Intrusion Action depends on hh3cSecureNeedToKnowMode and hh3cSecureIntrusionAction respectively. macAddressWithRadius(8) This selects the RADIUS Authenticated Login using MAC-address (RALM) security mode on the port. This feature controls network access of a host based on authenticating its MAC address. Once authorised, the host is allowed access to the network. If unauthorised, the port can be configured to deny access to this MAC address or to allow some access depending upon the port VLAN and QoS configuration. Where access is allowed, the MAC address is added to the Secure Address Table. macAddressOrUserLoginSecure(9) This selects both the macAddressWithRadius and userLoginSecure modes together such that either or both are allowed to authorised access. Where both authorised access, userLoginSecure takes precedence. macAddressElseUserLoginSecure(10) This selects both the macAddressWithRadius and userLoginSecure modes together such that the MAC address is first authenticated and only if this fails does the userLoginSecure then attempt user authentication. userLoginSecureExt(11) Access to the port is denied until the port client is authorised (by 802.1X or other authentication mechanism). When the client is authorised, the MAC address is added to the Secure Address Table. The hh3cSecureNumberAddresses is restricted by the value of hh3cSecureMaximumAddresses automatically when this mode is entered. Any existing MAC addresses in the Secure Address Table are deleted. Need To Know and Intrusion Action depends on hh3cSecureNeedToKnowMode and hh3cSecureIntrusionAction respectively. Learning is disabled. macAddressOrUserLoginSecureExt(12) This selects both the macAddressWithRadius and userLoginSecureExt modes together such that either or both are allowed to authorised access. Where both authorised access, userLoginSecure takes precedence. macAddressElseUserLoginSecureExt(13) This selects both the macAddressWithRadius and userLoginSecureExt modes together such that the MAC address is first authenticated and only if this fails does the userLoginSecure then attempt user authentication. macAddressAndUserLoginSecure(14) This selects both the macAddressWithRadius and userLoginSecure modes together such that the MAC address is first authenticated and only if this succeeds does the userLoginSecure then attempt user authentication. macAddressAndUserLoginSecureExt(15) This selects both the macAddressWithRadius and userLoginSecureExt modes together such that the MAC address is first authenticated and only if this succeeds does the userLoginSecure then attempt user authentication. ')
hh3cSecureNeedToKnowMode = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 26, 1, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("notAvailable", 1), ("disabled", 2), ("needToKnowOnly", 3), ("needToKnowWithBroadcastsAllowed", 4), ("needToKnowWithMulticastsAllowed", 5), ("permanentNeedToKnowOnly", 6), ("permanentNeedToKnowWithBroadcastsAllowed", 7), ("permanentNeedToKnowWithMulticastsAllowed", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cSecureNeedToKnowMode.setStatus('current')
if mibBuilder.loadTexts: hh3cSecureNeedToKnowMode.setDescription('Attribute to determine which frames are to be forwarded to this port intact. 1 - Need To Know is not available. 2 - All frames. 3 - Frames addressed to the authorised devices only. 4 - Frames addressed to the authorised devices, plus all broadcast frames. 5 - Frames addressed to the authorised devices, plus all broadcast and multicast frames. 6 - As 3 and cannot be changed. 7 - As 4 and cannot be changed. 8 - As 5 and cannot be changed. If this object returns 1,6,7 or 8, it means that the Need To Know configuration cannot be changed, and any attempt to write to this object will cause an error.')
hh3cSecureIntrusionAction = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 26, 1, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("notAvailable", 1), ("noAction", 2), ("disablePort", 3), ("disablePortTemporarily", 4), ("allowDefaultAccess", 5), ("blockMacAddress", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cSecureIntrusionAction.setStatus('current')
if mibBuilder.loadTexts: hh3cSecureIntrusionAction.setDescription('Attribute to determine the action if an unauthorised device transmits on this port.')
hh3cSecureNumberAddresses = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 26, 1, 2, 1, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cSecureNumberAddresses.setStatus('current')
if mibBuilder.loadTexts: hh3cSecureNumberAddresses.setDescription('The maximum number of addresses that the port can learn or store. Reducing this number may cause some addresses to be deleted. This value is set by the user and cannot be automatically changed by the agent. The maximum number will not include and limit the number of static mac addresses that configured by manager. The following relationship must be preserved. hh3cSecureNumberAddressesStored <= hh3cSecureNumberAddresses <= hh3cSecureMaximumAddresses ')
hh3cSecureNumberAddressesStored = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 26, 1, 2, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cSecureNumberAddressesStored.setStatus('current')
if mibBuilder.loadTexts: hh3cSecureNumberAddressesStored.setDescription('The number of addresses that are currently in the AddressTable for this port. If this object has the same value as hh3cSecureNumberAddresses, then no more addresses can be authorised on this port. The number will not include and limit the number of static mac addresses that configured by manager. Those objects are bound by the relationship: hh3cSecureNumberAddressesStored <= hh3cSecureNumberAddresses <= hh3cSecureMaximumAddresses ')
hh3cSecureMaximumAddresses = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 26, 1, 2, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cSecureMaximumAddresses.setStatus('current')
if mibBuilder.loadTexts: hh3cSecureMaximumAddresses.setDescription('This indicates the maximum value that hh3cSecureNumberAddresses can be set to. It is dependent on the resources available so may change, eg. if resources are shared between ports, then this value can both increase and decrease. This object must be read before setting hh3cSecureNumberAddresses. Those objects are bound by the relationship: hh3cSecureNumberAddressesStored <= hh3cSecureNumberAddresses <= hh3cSecureMaximumAddresses ')
hh3cSecureAddressTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 26, 1, 2, 2), )
if mibBuilder.loadTexts: hh3cSecureAddressTable.setStatus('current')
if mibBuilder.loadTexts: hh3cSecureAddressTable.setDescription('This table stores the MAC addresses assigned to each port. This table can be written to by the agent as well as the management station.')
hh3cSecureAddressEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 26, 1, 2, 2, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "HH3C-PORT-SECURITY-MIB", "hh3cSecureAddrMAC"), (0, "HH3C-PORT-SECURITY-MIB", "hh3cSecureAddrVlanID"))
if mibBuilder.loadTexts: hh3cSecureAddressEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cSecureAddressEntry.setDescription('This table allows multiple addresses to be assigned to each secure port. It is indexed using the objects ifIndex, hh3cSecureAddrMAC and hh3cSecureVlanID.')
hh3cSecureAddrMAC = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 26, 1, 2, 2, 1, 1), MacAddress()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hh3cSecureAddrMAC.setStatus('current')
if mibBuilder.loadTexts: hh3cSecureAddrMAC.setDescription('The MAC address of a station assigned to this port. This is the second index into the hh3cSecureAddressTable.')
hh3cSecureAddrVlanID = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 26, 1, 2, 2, 1, 2), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cSecureAddrVlanID.setStatus('current')
if mibBuilder.loadTexts: hh3cSecureAddrVlanID.setDescription('The Vlan ID associate with the port and the MAC address. This is the third index into the hh3cSecureAddressTable.')
hh3cSecureAddrMACStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 26, 1, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("addressBlackhole", 1), ("addressUserConfig", 2), ("addressDot1xAuth", 3), ("addressRALM", 4)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cSecureAddrMACStatus.setStatus('current')
if mibBuilder.loadTexts: hh3cSecureAddrMACStatus.setDescription('The state of the mac address assigned to this port. addressBlackhole (1) the mac address is a blackhole address, Each packet whose source address is equal to this address will be dropped by the agent. addressUserConfig (2) the mac address configed by user with this state are preserved across power cycles and resets. addressDot1xAuth (3) the mac address is authorized by 802.1x authenticator, User can not configure this mac address. This value is used for GET and GETNEXT operation. addressRALM (4) the mac address is authorized by RALM authenticator, User can not configure this mac address. This value is used for GET and GETNEXT operation. ')
hh3cSecureAddrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 26, 1, 2, 2, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cSecureAddrRowStatus.setStatus('current')
if mibBuilder.loadTexts: hh3cSecureAddrRowStatus.setDescription('This manages the creation and deletion or rows, and shows the current status of the indexed MAC address. This object has the following values. active(1) The indexed MAC address is authorised on this port. notInService(2) Not Supported. notReady(3) Not Supported. createAndGo(4) Assign a new MAC address to the port and authorise immediately. createAndWait(5) Not Supported. destroy(6) Delete this entry. When creating a new entry, index a new row and use createAndGo(4). When reading this object, only active(1) will be returned. ')
hh3cSecureOUITable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 26, 1, 2, 3), )
if mibBuilder.loadTexts: hh3cSecureOUITable.setStatus('current')
if mibBuilder.loadTexts: hh3cSecureOUITable.setDescription('This table stores the OUI values for OUI based authentication.')
hh3cSecureOUIEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 26, 1, 2, 3, 1), ).setIndexNames((0, "HH3C-PORT-SECURITY-MIB", "hh3cSecureOUIIndex"))
if mibBuilder.loadTexts: hh3cSecureOUIEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cSecureOUIEntry.setDescription('This is a row in the hh3cSecureOUITable.')
hh3cSecureOUIIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 26, 1, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024)))
if mibBuilder.loadTexts: hh3cSecureOUIIndex.setStatus('current')
if mibBuilder.loadTexts: hh3cSecureOUIIndex.setDescription('The index number. This is the first index into the hh3cSecureOUITable.')
hh3cSecureOUI = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 26, 1, 2, 3, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(3, 3)).setFixedLength(3)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cSecureOUI.setStatus('current')
if mibBuilder.loadTexts: hh3cSecureOUI.setDescription('The OUI value for an authorised device.')
hh3cSecureOUIRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 26, 1, 2, 3, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cSecureOUIRowStatus.setStatus('current')
if mibBuilder.loadTexts: hh3cSecureOUIRowStatus.setDescription('This manages the creation and deletion of rows, and shows the current status of the entry. active(1) The indexed OUI value is authorised. notInService(2) Not Supported. notReady(3) Not Supported. createAndGo(4) Assign a new OUI to the unit and authorise immediately. createAndWait(5) Not Supported. destroy(6) Delete this entry. When creating a new entry, index a new row and use createAndGo(4) . When reading this object, only active(1) will be returned. ')
hh3cSecureBindingTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 26, 1, 2, 4), )
if mibBuilder.loadTexts: hh3cSecureBindingTable.setStatus('current')
if mibBuilder.loadTexts: hh3cSecureBindingTable.setDescription('This table stores the elements of binding rules include the MAC addresses, the IP address and the port. Only the frame exactly matching the binding rules can be forwarded. This table can be written to by the agent as well as the management station.')
hh3cSecureBindingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 26, 1, 2, 4, 1), ).setIndexNames((0, "HH3C-PORT-SECURITY-MIB", "hh3cSecureBindingIndex"))
if mibBuilder.loadTexts: hh3cSecureBindingEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cSecureBindingEntry.setDescription('This table allows multiple binding rules. It is indexed using the object hh3cSecureBindingIndex.')
hh3cSecureBindingIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 26, 1, 2, 4, 1, 1), Integer32())
if mibBuilder.loadTexts: hh3cSecureBindingIndex.setStatus('current')
if mibBuilder.loadTexts: hh3cSecureBindingIndex.setDescription('The index number. This is the first index into the hh3cSecureBindingTable.')
hh3cSecureBindingPort = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 26, 1, 2, 4, 1, 2), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cSecureBindingPort.setStatus('current')
if mibBuilder.loadTexts: hh3cSecureBindingPort.setDescription('The port number of the port bound with the IP address and the MAC address.')
hh3cSecureBindingAddrMAC = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 26, 1, 2, 4, 1, 3), MacAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cSecureBindingAddrMAC.setStatus('current')
if mibBuilder.loadTexts: hh3cSecureBindingAddrMAC.setDescription('The MAC address bound with the port and the IP address.')
hh3cSecureBindingAddrIp = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 26, 1, 2, 4, 1, 4), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cSecureBindingAddrIp.setStatus('current')
if mibBuilder.loadTexts: hh3cSecureBindingAddrIp.setDescription('The IP address bound with the port and the MAC address.')
hh3cSecureBindingRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 26, 1, 2, 4, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cSecureBindingRowStatus.setStatus('current')
if mibBuilder.loadTexts: hh3cSecureBindingRowStatus.setDescription('This manages the creation and deletion or rows, and shows status of the entry. This object has the following values. active(1) The indexed MAC address is authorised on this port. notInService(2) Not Supported. notReady(3) Not Supported. createAndGo(4) Assign a new MAC address to the port and authorise immediately. createAndWait(5) Not Supported. destroy(6) Delete this entry. When creating a new entry, index a new row and use createAndGo(4). When reading this object, only active(1) will be returned. ')
hh3cSecureAssignTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 26, 1, 2, 5), )
if mibBuilder.loadTexts: hh3cSecureAssignTable.setStatus('current')
if mibBuilder.loadTexts: hh3cSecureAssignTable.setDescription('Table of port assignment management information about authorised user.')
hh3cSecureAssignEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 26, 1, 2, 5, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: hh3cSecureAssignEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cSecureAssignEntry.setDescription('An entry (conceptual row) representing information about port assignment about authorised user.')
hh3cSecureAssignEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 26, 1, 2, 5, 1, 1), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cSecureAssignEnable.setStatus('current')
if mibBuilder.loadTexts: hh3cSecureAssignEnable.setDescription('The user-based port configuration control. Setting this attribute TRUE causes the port to be configured with any configuration parameters supplied by the authentication server. Setting this attribute to FALSE causes any configuration parameters supplied by the authentication server to be ignored.')
hh3cSecureVlanAssignment = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 26, 1, 2, 5, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cSecureVlanAssignment.setStatus('current')
if mibBuilder.loadTexts: hh3cSecureVlanAssignment.setDescription('The VLAN membership assigned to the port for the authorised user. This contains the actual value received from the authentication server. This object will contain a null value if there is no user authorised to access the port or if the authorised user was not assigned a VLAN membership.')
hh3cPortSecurityNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 26, 1, 3))
hh3cSecureAddressLearned = NotificationType((1, 3, 6, 1, 4, 1, 25506, 2, 26, 1, 3, 1)).setObjects(("IF-MIB", "ifIndex"), ("HH3C-PORT-SECURITY-MIB", "hh3cSecureAddrMAC"))
if mibBuilder.loadTexts: hh3cSecureAddressLearned.setStatus('current')
if mibBuilder.loadTexts: hh3cSecureAddressLearned.setDescription('This trap is sent when a new station has been learned. The port on which the address was received is the first object, and the MAC address of the learned station is in the second object.')
hh3cSecureViolation = NotificationType((1, 3, 6, 1, 4, 1, 25506, 2, 26, 1, 3, 2)).setObjects(("IF-MIB", "ifIndex"), ("HH3C-PORT-SECURITY-MIB", "hh3cSecureAddrMAC"), ("IF-MIB", "ifAdminStatus"))
if mibBuilder.loadTexts: hh3cSecureViolation.setStatus('current')
if mibBuilder.loadTexts: hh3cSecureViolation.setDescription('This trap is sent whenever a security violation has occurred. The port on which the violation occured is the first object, and the MAC address of the offending station is in the second object. ifAdminStatus indicates if the port has been disabled because of the violation. The implementation may not send violation traps from the same port at intervals of less than 5 seconds.')
hh3cSecureLoginFailure = NotificationType((1, 3, 6, 1, 4, 1, 25506, 2, 26, 1, 3, 3)).setObjects(("IF-MIB", "ifIndex"), ("HH3C-PORT-SECURITY-MIB", "hh3cSecureAddrMAC"), ("IEEE8021-PAE-MIB", "dot1xAuthSessionUserName"))
if mibBuilder.loadTexts: hh3cSecureLoginFailure.setStatus('current')
if mibBuilder.loadTexts: hh3cSecureLoginFailure.setDescription('This trap is sent whenever a user network access authentication has failed. The port on which the violation occured is the first object, and the MAC address of the offending station is in the second object. The dot1xAuthSessionUserName is the identity supplied during the user authentication.')
hh3cSecureLogon = NotificationType((1, 3, 6, 1, 4, 1, 25506, 2, 26, 1, 3, 4)).setObjects(("IF-MIB", "ifIndex"), ("HH3C-PORT-SECURITY-MIB", "hh3cSecureAddrMAC"), ("IEEE8021-PAE-MIB", "dot1xAuthSessionUserName"), ("IEEE8021-PAE-MIB", "dot1xAuthSessionAuthenticMethod"), ("HH3C-PORT-SECURITY-MIB", "hh3cSecurePortVlanMembershipList"))
if mibBuilder.loadTexts: hh3cSecureLogon.setStatus('current')
if mibBuilder.loadTexts: hh3cSecureLogon.setDescription('This trap is sent when a new session is started for an authorised port user. The port on which the violation occured is the first object, and the MAC address of the offending station is in the second object. The dot1xAuthSessionUserName is the identity supplied during the user authentication. The dot1xAuthSessionAuthenticMethod indicates how the user was authorised. The hh3cSecurePortVlanMembershipList object identifies the VLAN membership assigned to the port on session activation.')
hh3cSecureLogoff = NotificationType((1, 3, 6, 1, 4, 1, 25506, 2, 26, 1, 3, 5)).setObjects(("IF-MIB", "ifIndex"), ("HH3C-PORT-SECURITY-MIB", "hh3cSecureAddrMAC"), ("IEEE8021-PAE-MIB", "dot1xAuthSessionUserName"), ("IEEE8021-PAE-MIB", "dot1xAuthSessionTerminateCause"), ("HH3C-PORT-SECURITY-MIB", "hh3cSecurePortVlanMembershipList"))
if mibBuilder.loadTexts: hh3cSecureLogoff.setStatus('current')
if mibBuilder.loadTexts: hh3cSecureLogoff.setDescription('This trap is sent when a user session is terminated. The port on which the violation occured is the first object, and the MAC address of the offending station is in the second object. The dot1xAuthSessionUserName is the identity supplied during the user authentication. The dot1xAuthSessionTerminateCause indicates the reason why the session was terminated. The hh3cSecurePortVlanMembershipList object identifies the VLAN membership assigned to the port on session termination.')
hh3cSecureRalmLoginFailure = NotificationType((1, 3, 6, 1, 4, 1, 25506, 2, 26, 1, 3, 6)).setObjects(("IF-MIB", "ifIndex"), ("HH3C-PORT-SECURITY-MIB", "hh3cSecureAddrMAC"), ("HH3C-PORT-SECURITY-MIB", "hh3cSecureRalmAuthMode"), ("HH3C-PORT-SECURITY-MIB", "hh3cSecureRalmAuthUsername"))
if mibBuilder.loadTexts: hh3cSecureRalmLoginFailure.setStatus('current')
if mibBuilder.loadTexts: hh3cSecureRalmLoginFailure.setDescription('This trap is sent whenever a user network access authentication has failed. The port on which the violation occured is the first object, and the MAC address of the offending station is in the second object. The authentication mode indicates how the user was authorised. The hh3cSecureRalmAuthUsername is the identity supplied during the user authentication.')
hh3cSecureRalmLogon = NotificationType((1, 3, 6, 1, 4, 1, 25506, 2, 26, 1, 3, 7)).setObjects(("IF-MIB", "ifIndex"), ("HH3C-PORT-SECURITY-MIB", "hh3cSecureAddrMAC"), ("HH3C-PORT-SECURITY-MIB", "hh3cSecureRalmAuthMode"), ("HH3C-PORT-SECURITY-MIB", "hh3cSecureRalmAuthUsername"), ("HH3C-PORT-SECURITY-MIB", "hh3cSecurePortVlanMembershipList"))
if mibBuilder.loadTexts: hh3cSecureRalmLogon.setStatus('current')
if mibBuilder.loadTexts: hh3cSecureRalmLogon.setDescription('This trap is sent when a new session is started for an authorised port user. The port on which the violation occured is the first object, and the MAC address of the offending station is in the second object. The authentication mode indicates how the user was authorised. The hh3cSecureRalmAuthUsername is the identity supplied during the user authentication. The hh3cSecurePortVlanMembershipList object identifies the VLAN membership assigned to the port on session activation.')
hh3cSecureRalmLogoff = NotificationType((1, 3, 6, 1, 4, 1, 25506, 2, 26, 1, 3, 8)).setObjects(("IF-MIB", "ifIndex"), ("HH3C-PORT-SECURITY-MIB", "hh3cSecureAddrMAC"), ("HH3C-PORT-SECURITY-MIB", "hh3cSecureRalmAuthMode"), ("HH3C-PORT-SECURITY-MIB", "hh3cSecureRalmAuthUsername"), ("HH3C-PORT-SECURITY-MIB", "hh3cSecurePortVlanMembershipList"))
if mibBuilder.loadTexts: hh3cSecureRalmLogoff.setStatus('current')
if mibBuilder.loadTexts: hh3cSecureRalmLogoff.setDescription('This trap is sent when a new session is started for an authorised port user. The port on which the violation occured is the first object, and the MAC address of the offending station is in the second object. The authentication mode indicates how the user was authorised. The hh3cSecureRalmAuthUsername is the identity supplied during the user authentication. The hh3cSecurePortVlanMembershipList object identifies the VLAN membership assigned to the port on session activation.')
mibBuilder.exportSymbols("HH3C-PORT-SECURITY-MIB", hh3cPortSecurityTables=hh3cPortSecurityTables, hh3cSecurePortEntry=hh3cSecurePortEntry, hh3cSecureAddrVlanID=hh3cSecureAddrVlanID, hh3cSecureAddrMAC=hh3cSecureAddrMAC, hh3cSecureOUITable=hh3cSecureOUITable, hh3cSecureRalmAuthOfflineTime=hh3cSecureRalmAuthOfflineTime, hh3cSecureBindingTable=hh3cSecureBindingTable, hh3cSecureRalmReauthenticate=hh3cSecureRalmReauthenticate, PYSNMP_MODULE_ID=hh3cPortSecurityMIB, hh3cSecurePortSecurityControl=hh3cSecurePortSecurityControl, hh3cSecureRalmLogon=hh3cSecureRalmLogon, hh3cSecureBindingAddrMAC=hh3cSecureBindingAddrMAC, hh3cSecureBindingPort=hh3cSecureBindingPort, hh3cPortSecurityMIB=hh3cPortSecurityMIB, hh3cSecureLogoff=hh3cSecureLogoff, hh3cSecureRalmHoldoffTime=hh3cSecureRalmHoldoffTime, hh3cSecureBindingIndex=hh3cSecureBindingIndex, hh3cSecureNeedToKnowMode=hh3cSecureNeedToKnowMode, hh3cSecurePortMode=hh3cSecurePortMode, hh3cSecureOUIIndex=hh3cSecureOUIIndex, hh3cSecureViolation=hh3cSecureViolation, hh3cSecureAddressEntry=hh3cSecureAddressEntry, hh3cSecureOUIRowStatus=hh3cSecureOUIRowStatus, hh3cPortSecurityLeaf=hh3cPortSecurityLeaf, hh3cSecureIntrusionAction=hh3cSecureIntrusionAction, hh3cSecureAssignTable=hh3cSecureAssignTable, hh3cSecureRalmObjects=hh3cSecureRalmObjects, hh3cSecureAddrMACStatus=hh3cSecureAddrMACStatus, hh3cSecureAssignEnable=hh3cSecureAssignEnable, hh3cSecureLoginFailure=hh3cSecureLoginFailure, hh3cSecurePortVlanMembershipList=hh3cSecurePortVlanMembershipList, hh3cSecureNumberAddressesStored=hh3cSecureNumberAddressesStored, hh3cSecureLogon=hh3cSecureLogon, hh3cSecureMaximumAddresses=hh3cSecureMaximumAddresses, hh3cSecureRalmLoginFailure=hh3cSecureRalmLoginFailure, hh3cSecureOUI=hh3cSecureOUI, hh3cSecureBindingAddrIp=hh3cSecureBindingAddrIp, hh3cSecureRalmAuthDomain=hh3cSecureRalmAuthDomain, hh3cSecureNumberAddresses=hh3cSecureNumberAddresses, hh3cSecureAddrRowStatus=hh3cSecureAddrRowStatus, hh3cSecureOUIEntry=hh3cSecureOUIEntry, hh3cPortSecurityNotifications=hh3cPortSecurityNotifications, hh3cSecureRalmAuthPassword=hh3cSecureRalmAuthPassword, hh3cSecurePortTable=hh3cSecurePortTable, hh3cSecureBindingEntry=hh3cSecureBindingEntry, hh3cSecureRalmDefaultSessionTime=hh3cSecureRalmDefaultSessionTime, hh3cSecureBindingRowStatus=hh3cSecureBindingRowStatus, hh3cSecureAddressTable=hh3cSecureAddressTable, hh3cSecureRalmAuthServerTimeoutTime=hh3cSecureRalmAuthServerTimeoutTime, hh3cSecureRalmAuthMode=hh3cSecureRalmAuthMode, hh3cSecureMacControl=hh3cSecureMacControl, hh3cSecureRalmLogoff=hh3cSecureRalmLogoff, hh3cSecureAssignEntry=hh3cSecureAssignEntry, hh3cSecureAddressLearned=hh3cSecureAddressLearned, hh3cSecureVlanAssignment=hh3cSecureVlanAssignment, hh3cSecureRalmAuthUsername=hh3cSecureRalmAuthUsername)

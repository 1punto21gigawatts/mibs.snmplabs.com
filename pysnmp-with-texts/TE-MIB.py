#
# PySNMP MIB module TE-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/TE-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:15:42 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ValueRangeConstraint, SingleValueConstraint, ConstraintsUnion, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsUnion", "ValueSizeConstraint")
MplsBitRate, TeHopAddress, TeHopAddressType = mibBuilder.importSymbols("MPLS-TC-STD-MIB", "MplsBitRate", "TeHopAddress", "TeHopAddressType")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
NotificationGroup, ObjectGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ObjectGroup", "ModuleCompliance")
Integer32, Gauge32, Counter32, ObjectIdentity, iso, ModuleIdentity, NotificationType, Unsigned32, Bits, MibScalar, MibTable, MibTableRow, MibTableColumn, IpAddress, TimeTicks, MibIdentifier, Counter64, mib_2 = mibBuilder.importSymbols("SNMPv2-SMI", "Integer32", "Gauge32", "Counter32", "ObjectIdentity", "iso", "ModuleIdentity", "NotificationType", "Unsigned32", "Bits", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "IpAddress", "TimeTicks", "MibIdentifier", "Counter64", "mib-2")
TimeStamp, StorageType, RowStatus, TruthValue, TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TimeStamp", "StorageType", "RowStatus", "TruthValue", "TextualConvention", "DisplayString")
teMIB = ModuleIdentity((1, 3, 6, 1, 2, 1, 122))
teMIB.setRevisions(('2005-01-04 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: teMIB.setRevisionsDescriptions(('Initial version, published as RFC 3970.',))
if mibBuilder.loadTexts: teMIB.setLastUpdated('200501040000Z')
if mibBuilder.loadTexts: teMIB.setOrganization('IETF Traffic Engineering Working Group')
if mibBuilder.loadTexts: teMIB.setContactInfo(' Editor: Kireeti Kompella Postal: Juniper Networks, Inc. 1194 Mathilda Ave Sunnyvale, CA 94089 Tel: +1 408 745 2000 E-mail: kireeti@juniper.net The IETF Traffic Engineering Working Group is chaired by Jim Boyle and Ed Kern. WG Mailing List information: General Discussion: te-wg@ops.ietf.org To Subscribe: te-wg-request@ops.ietf.org In Body: subscribe Archive: ftp://ops.ietf.org/pub/lists Comments on the MIB module should be sent to the mailing list. The archives for this mailing list should be consulted for previous discussion on this MIB. ')
if mibBuilder.loadTexts: teMIB.setDescription('The Traffic Engineering MIB module. Copyright (C) The Internet Society (2005). This version of this MIB module is part of RFC 3970; see the RFC itself for full legal notices. ')
teMIBNotifications = MibIdentifier((1, 3, 6, 1, 2, 1, 122, 0))
teMIBObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 122, 1))
teMIBConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 122, 2))
teInfo = MibIdentifier((1, 3, 6, 1, 2, 1, 122, 1, 1))
teDistProtocol = MibScalar((1, 3, 6, 1, 2, 1, 122, 1, 1, 1), Bits().clone(namedValues=NamedValues(("other", 0), ("isis", 1), ("ospf", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: teDistProtocol.setStatus('current')
if mibBuilder.loadTexts: teDistProtocol.setDescription('IGP used to distribute Traffic Engineering information and topology to each device for the purpose of automatic path computation. More than one IGP may be used to distribute TE information. ')
teSignalingProto = MibScalar((1, 3, 6, 1, 2, 1, 122, 1, 1, 2), Bits().clone(namedValues=NamedValues(("other", 0), ("rsvpte", 1), ("crldp", 2), ("static", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: teSignalingProto.setReference('For a description of RSVP-TE, see RFC 3209; for CR-LDP, see RFC 3212. ')
if mibBuilder.loadTexts: teSignalingProto.setStatus('current')
if mibBuilder.loadTexts: teSignalingProto.setDescription('Traffic Engineering signaling protocols supported by this device. More than one protocol may be supported. ')
teNotificationEnable = MibScalar((1, 3, 6, 1, 2, 1, 122, 1, 1, 3), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: teNotificationEnable.setStatus('current')
if mibBuilder.loadTexts: teNotificationEnable.setDescription('If this object is true, then it enables the generation of notifications from this MIB module. Otherwise notifications are not generated. ')
teNextTunnelIndex = MibScalar((1, 3, 6, 1, 2, 1, 122, 1, 1, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: teNextTunnelIndex.setStatus('current')
if mibBuilder.loadTexts: teNextTunnelIndex.setDescription('An integer that may be used as a new Index in the teTunnelTable. The special value of 0 indicates that no more new entries can be created in that table. When this MIB module is used for configuration, this object always contains a legal value (if non-zero) for an index that is not currently used in that table. The Command Generator (Network Management Application) reads this variable and uses the (non-zero) value read when creating a new row with an SNMP SET. When the SET is performed, the Command Responder (agent) must determine whether the value is indeed still unused; Two Network Management Applications may attempt to create a row (configuration entry) simultaneously and use the same value. If it is currently unused, the SET succeeds, and the Command Responder (agent) changes the value of this object according to an implementation-specific algorithm. If the value is in use, however, the SET fails. The Network Management Application must then re-read this variable to obtain a new usable value. ')
teNextPathHopIndex = MibScalar((1, 3, 6, 1, 2, 1, 122, 1, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: teNextPathHopIndex.setStatus('current')
if mibBuilder.loadTexts: teNextPathHopIndex.setDescription('An integer that may be used as a new Index in the tePathHopTable. The special value of 0 indicates that no more new entries can be created in that table. When this MIB module is used for configuration, this object always contains a legal value (if non-zero) for an index that is not currently used in that table. The Command Generator (Network Management Application) reads this variable and uses the (non-zero) value read when creating a new row with an SNMP SET. When the SET is performed, the Command Responder (agent) must determine whether the value is indeed still unused; Two Network Management Applications may attempt to create a row (configuration entry) simultaneously and use the same value. If it is currently unused, the SET succeeds, and the Command Responder (agent) changes the value of this object according to an implementation-specific algorithm. If the value is in use, however, the SET fails. The Network Management Application must then re-read this variable to obtain a new usable value. ')
teConfiguredTunnels = MibScalar((1, 3, 6, 1, 2, 1, 122, 1, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: teConfiguredTunnels.setStatus('current')
if mibBuilder.loadTexts: teConfiguredTunnels.setDescription('Number of currently configured Tunnels.')
teActiveTunnels = MibScalar((1, 3, 6, 1, 2, 1, 122, 1, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: teActiveTunnels.setStatus('current')
if mibBuilder.loadTexts: teActiveTunnels.setDescription('Number of currently active Tunnels.')
tePrimaryTunnels = MibScalar((1, 3, 6, 1, 2, 1, 122, 1, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tePrimaryTunnels.setStatus('current')
if mibBuilder.loadTexts: tePrimaryTunnels.setDescription('Number of currently active Tunnels running on their primary paths. ')
teAdminGroupTable = MibTable((1, 3, 6, 1, 2, 1, 122, 1, 1, 9), )
if mibBuilder.loadTexts: teAdminGroupTable.setStatus('current')
if mibBuilder.loadTexts: teAdminGroupTable.setDescription('A mapping of configured administrative groups. Each entry represents an Administrative Group and provides a name and index for the group. Administrative groups are used to label links in the Traffic Engineering topology in order to place constraints (include and exclude) on Tunnel paths. A groupName can only be linked to one group number. The groupNumber is the number assigned to the administrative group used in constraints, such as tePathIncludeAny or tePathIncludeAll. ')
teAdminGroupEntry = MibTableRow((1, 3, 6, 1, 2, 1, 122, 1, 1, 9, 1), ).setIndexNames((0, "TE-MIB", "teAdminGroupNumber"))
if mibBuilder.loadTexts: teAdminGroupEntry.setStatus('current')
if mibBuilder.loadTexts: teAdminGroupEntry.setDescription('A mapping between a configured group number and its human-readable name. The group number should be between 1 and 32, inclusive. Group number n represents bit number (n-1) in the bit vector for Include/Exclude constraints. All entries in this table MUST be kept in stable storage so that they will re-appear in case of a restart/reboot. ')
teAdminGroupNumber = MibTableColumn((1, 3, 6, 1, 2, 1, 122, 1, 1, 9, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32)))
if mibBuilder.loadTexts: teAdminGroupNumber.setStatus('current')
if mibBuilder.loadTexts: teAdminGroupNumber.setDescription('Index of the administrative group.')
teAdminGroupName = MibTableColumn((1, 3, 6, 1, 2, 1, 122, 1, 1, 9, 1, 2), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: teAdminGroupName.setStatus('current')
if mibBuilder.loadTexts: teAdminGroupName.setDescription('Name of the administrative group.')
teAdminGroupRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 122, 1, 1, 9, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: teAdminGroupRowStatus.setStatus('current')
if mibBuilder.loadTexts: teAdminGroupRowStatus.setDescription('The status of this conceptual row. The value of this object has no effect on whether other objects in this conceptual row can be modified. ')
teTunnelTable = MibTable((1, 3, 6, 1, 2, 1, 122, 1, 2), )
if mibBuilder.loadTexts: teTunnelTable.setStatus('current')
if mibBuilder.loadTexts: teTunnelTable.setDescription('Table of Configured Traffic Tunnels.')
teTunnelEntry = MibTableRow((1, 3, 6, 1, 2, 1, 122, 1, 2, 1), ).setIndexNames((0, "TE-MIB", "teTunnelIndex"))
if mibBuilder.loadTexts: teTunnelEntry.setStatus('current')
if mibBuilder.loadTexts: teTunnelEntry.setDescription('Entry containing information about a particular Traffic Tunnel. ')
teTunnelIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 122, 1, 2, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: teTunnelIndex.setStatus('current')
if mibBuilder.loadTexts: teTunnelIndex.setDescription('A unique index that identifies a Tunnel. If the TE Tunnel is considered an interface, then this index must match the interface index of the corresponding interface. Otherwise, this index must be at least 2^24, so that it does not overlap with any existing interface index. ')
teTunnelName = MibTableColumn((1, 3, 6, 1, 2, 1, 122, 1, 2, 1, 2), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: teTunnelName.setStatus('current')
if mibBuilder.loadTexts: teTunnelName.setDescription("Name of the Traffic Tunnel. Note that the name of a Tunnel MUST be unique. When a SET request contains a name that is already in use for another entry, then the implementation must return an inconsistentValue error. The value of this object cannot be changed if the if the value of the corresponding teTunnelRowStatus object is 'active'. ")
teTunnelNextPathIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 122, 1, 2, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: teTunnelNextPathIndex.setStatus('current')
if mibBuilder.loadTexts: teTunnelNextPathIndex.setDescription('An integer that may be used as a new Index for the next Path in this Tunnel. The special value of 0 indicates that no more Paths can be created for this Tunnel, or that no more new entries can be created in tePathTable. When this MIB module is used for configuration, this object always contains a legal value (if non-zero) for an index that is not currently used in that table. The Command Generator (Network Management Application) reads this variable and uses the (non-zero) value read when creating a new row with an SNMP SET. When the SET is performed, the Command Responder (agent) must determine whether the value is indeed still unused; Two Network Management Applications may attempt to create a row (configuration entry) simultaneously and use the same value. If it is currently unused, the SET succeeds, and the Command Responder (agent) changes the value of this object according to an implementation-specific algorithm. If the value is in use, however, the SET fails. The Network Management Application must then re-read this variable to obtain a new usable value. ')
teTunnelRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 122, 1, 2, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: teTunnelRowStatus.setStatus('current')
if mibBuilder.loadTexts: teTunnelRowStatus.setDescription("The status of this conceptual row. When the value of this object is 'active', then the values for the corresponding objects teTunnelName, teTunnelSourceAddressType, teTunnelSourceAddress, teTunnelDestinationAddressType, and teTunnelDestinationAddress cannot be changed. ")
teTunnelStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 122, 1, 2, 1, 5), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: teTunnelStorageType.setStatus('current')
if mibBuilder.loadTexts: teTunnelStorageType.setDescription("The storage type for this conceptual row. Conceptual rows having the value 'permanent' need not allow write-access to any columnar objects in the row. ")
teTunnelSourceAddressType = MibTableColumn((1, 3, 6, 1, 2, 1, 122, 1, 2, 1, 6), TeHopAddressType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: teTunnelSourceAddressType.setStatus('current')
if mibBuilder.loadTexts: teTunnelSourceAddressType.setDescription("The type of Traffic Engineered Tunnel hop address for the source of this Tunnel. Typically, this address type is IPv4 or IPv6, with a prefix length of 32 or 128, respectively. If the TE Tunnel path is being computed by a path computation server, however, it is possible to use more flexible source address types, such as AS numbers or prefix lengths less than host address lengths. The value of this object cannot be changed if the value of the corresponding teTunnelRowStatus object is 'active'. ")
teTunnelSourceAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 122, 1, 2, 1, 7), TeHopAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: teTunnelSourceAddress.setStatus('current')
if mibBuilder.loadTexts: teTunnelSourceAddress.setDescription("The Source Traffic Engineered Tunnel hop address of this Tunnel. The type of this address is determined by the value of the corresponding teTunnelSourceAddressType. Note that the source and destination addresses of a Tunnel can be different address types. The value of this object cannot be changed if the value of the corresponding teTunnelRowStatus object is 'active'. ")
teTunnelDestinationAddressType = MibTableColumn((1, 3, 6, 1, 2, 1, 122, 1, 2, 1, 8), TeHopAddressType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: teTunnelDestinationAddressType.setStatus('current')
if mibBuilder.loadTexts: teTunnelDestinationAddressType.setDescription("The type of Traffic Engineered Tunnel hop address for the destination of this Tunnel. The value of this object cannot be changed if the value of the corresponding teTunnelRowStatus object is 'active'. ")
teTunnelDestinationAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 122, 1, 2, 1, 9), TeHopAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: teTunnelDestinationAddress.setStatus('current')
if mibBuilder.loadTexts: teTunnelDestinationAddress.setDescription("The Destination Traffic Engineered Tunnel hop address of this Tunnel. The type of this address is determined by the value of the corresponding teTunnelDestinationAddressType. Note that source and destination addresses of a Tunnel can be different address types. The value of this object cannot be changed if the value of the corresponding teTunnelRowStatus object is 'active'. ")
teTunnelState = MibTableColumn((1, 3, 6, 1, 2, 1, 122, 1, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("up", 2), ("down", 3), ("testing", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: teTunnelState.setStatus('current')
if mibBuilder.loadTexts: teTunnelState.setDescription('The operational state of the Tunnel.')
teTunnelDiscontinuityTimer = MibTableColumn((1, 3, 6, 1, 2, 1, 122, 1, 2, 1, 11), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: teTunnelDiscontinuityTimer.setStatus('current')
if mibBuilder.loadTexts: teTunnelDiscontinuityTimer.setDescription("The value of sysUpTime on the most recent occasion at which any one or more of this tunnel's counters suffered a discontinuity. The relevant counters are teTunnelOctets, teTunnelPackets, teTunnelLPOctets, and teTunnelLPPackets. If no such discontinuities have occurred since the last re-initialization of the local management subsystem then this object contains a zero value. ")
teTunnelOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 122, 1, 2, 1, 12), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: teTunnelOctets.setStatus('current')
if mibBuilder.loadTexts: teTunnelOctets.setDescription('The number of octets that have been forwarded over the Tunnel. Discontinuities in the value of this counter can occur at re-initialization of the management system, and at other times, as indicated by the value of teTunnelDiscontinuityTimer. ')
teTunnelPackets = MibTableColumn((1, 3, 6, 1, 2, 1, 122, 1, 2, 1, 13), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: teTunnelPackets.setStatus('current')
if mibBuilder.loadTexts: teTunnelPackets.setDescription('The number of packets that have been forwarded over the Tunnel. Discontinuities in the value of this counter can occur at re-initialization of the management system and at other times, as indicated by the value of teTunnelDiscontinuityTimer. ')
teTunnelLPOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 122, 1, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: teTunnelLPOctets.setStatus('current')
if mibBuilder.loadTexts: teTunnelLPOctets.setDescription('The number of octets that have been forwarded over the Tunnel. Discontinuities in the value of this counter can occur at re-initialization of the management system and at other times, as indicated by the value of teTunnelDiscontinuityTimer. ')
teTunnelLPPackets = MibTableColumn((1, 3, 6, 1, 2, 1, 122, 1, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: teTunnelLPPackets.setStatus('current')
if mibBuilder.loadTexts: teTunnelLPPackets.setDescription('The number of packets that have been forwarded over the Tunnel. Discontinuities in the value of this counter can occur at re-initialization of the management system and at other times, as indicated by the value of teTunnelDiscontinuityTimer. ')
teTunnelAge = MibTableColumn((1, 3, 6, 1, 2, 1, 122, 1, 2, 1, 16), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: teTunnelAge.setStatus('current')
if mibBuilder.loadTexts: teTunnelAge.setDescription('The age (i.e., time from creation of this conceptual row till now) of this Tunnel in hundredths of a second. Note that because TimeTicks wrap in about 16 months, this value is best used in interval measurements. ')
teTunnelTimeUp = MibTableColumn((1, 3, 6, 1, 2, 1, 122, 1, 2, 1, 17), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: teTunnelTimeUp.setStatus('current')
if mibBuilder.loadTexts: teTunnelTimeUp.setDescription('The total time in hundredths of a second that this Tunnel has been operational. Note that because TimeTicks wrap in about 16 months, this value is best used in interval measurements. An example of usage of this object would be to compute the percentage up time over a period of time by obtaining values of teTunnelAge and teTunnelTimeUp at two points in time and computing the following ratio: ((teTunnelTimeUp2 - teTunnelTimeUp1)/ (teTunnelAge2 - teTunnelAge1)) * 100 %. In doing so, the management station must account for wrapping of the values of teTunnelAge and teTunnelTimeUp between the two measurements. ')
teTunnelPrimaryTimeUp = MibTableColumn((1, 3, 6, 1, 2, 1, 122, 1, 2, 1, 18), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: teTunnelPrimaryTimeUp.setStatus('current')
if mibBuilder.loadTexts: teTunnelPrimaryTimeUp.setDescription("The total time in hundredths of a second that this Tunnel's primary path has been operational. Note that because TimeTicks wrap in about 16 months, this value is best used in interval measurements. An example of usage of this field would be to compute what percentage of time that a TE Tunnel was on the primary path over a period of time by computing ((teTunnelPrimaryTimeUp2 - teTunnelPrimaryTimeUp1)/ (teTunnelTimeUp2 - teTunnelTimeUp1))*100 %. In doing so, the management station must account for wrapping of the values of teTunnelPrimaryTimeUp and teTunnelTimeUp between the two measurements. ")
teTunnelTransitions = MibTableColumn((1, 3, 6, 1, 2, 1, 122, 1, 2, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: teTunnelTransitions.setStatus('current')
if mibBuilder.loadTexts: teTunnelTransitions.setDescription('The number of operational state transitions (up -> down and down -> up) this Tunnel has undergone. ')
teTunnelLastTransition = MibTableColumn((1, 3, 6, 1, 2, 1, 122, 1, 2, 1, 20), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: teTunnelLastTransition.setStatus('current')
if mibBuilder.loadTexts: teTunnelLastTransition.setDescription('The time in hundredths of a second since the last operational state transition occurred on this Tunnel. Note that if the last transition was over 16 months ago, this value will be inaccurate. ')
teTunnelPathChanges = MibTableColumn((1, 3, 6, 1, 2, 1, 122, 1, 2, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: teTunnelPathChanges.setStatus('current')
if mibBuilder.loadTexts: teTunnelPathChanges.setDescription('The number of path changes this Tunnel has had.')
teTunnelLastPathChange = MibTableColumn((1, 3, 6, 1, 2, 1, 122, 1, 2, 1, 22), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: teTunnelLastPathChange.setStatus('current')
if mibBuilder.loadTexts: teTunnelLastPathChange.setDescription('The time in hundredths of a second since the last path change occurred on this Tunnel. Note that if the last transition was over 16 months ago, this value will be inaccurate. Path changes may be caused by network events or by reconfiguration that affects the path. ')
teTunnelConfiguredPaths = MibTableColumn((1, 3, 6, 1, 2, 1, 122, 1, 2, 1, 23), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: teTunnelConfiguredPaths.setStatus('current')
if mibBuilder.loadTexts: teTunnelConfiguredPaths.setDescription('The number of paths configured for this Tunnel.')
teTunnelStandbyPaths = MibTableColumn((1, 3, 6, 1, 2, 1, 122, 1, 2, 1, 24), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: teTunnelStandbyPaths.setStatus('current')
if mibBuilder.loadTexts: teTunnelStandbyPaths.setDescription('The number of standby paths configured for this Tunnel. ')
teTunnelOperationalPaths = MibTableColumn((1, 3, 6, 1, 2, 1, 122, 1, 2, 1, 25), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: teTunnelOperationalPaths.setStatus('current')
if mibBuilder.loadTexts: teTunnelOperationalPaths.setDescription('The number of operational paths for this Tunnel. This includes the path currently active, as well as operational standby paths. ')
tePathTable = MibTable((1, 3, 6, 1, 2, 1, 122, 1, 3), )
if mibBuilder.loadTexts: tePathTable.setStatus('current')
if mibBuilder.loadTexts: tePathTable.setDescription('Table of Configured Traffic Tunnels.')
tePathEntry = MibTableRow((1, 3, 6, 1, 2, 1, 122, 1, 3, 1), ).setIndexNames((0, "TE-MIB", "teTunnelIndex"), (0, "TE-MIB", "tePathIndex"))
if mibBuilder.loadTexts: tePathEntry.setStatus('current')
if mibBuilder.loadTexts: tePathEntry.setDescription('Entry containing information about a particular Traffic Tunnel. Each Traffic Tunnel can have zero or more Traffic Paths. As a Traffic Path can only exist over an existing Traffic Tunnel, all tePathEntries with a value of n for teTunnelIndex MUST be removed by the implementation when the corresponding teTunnelEntry with a value of n for teTunnelIndex is removed. ')
tePathIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 122, 1, 3, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: tePathIndex.setStatus('current')
if mibBuilder.loadTexts: tePathIndex.setDescription('An index that uniquely identifies a path within a Tunnel. The combination of <teTunnelIndex, tePathIndex> thus uniquely identifies a path among all paths on this router. ')
tePathName = MibTableColumn((1, 3, 6, 1, 2, 1, 122, 1, 3, 1, 2), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tePathName.setStatus('current')
if mibBuilder.loadTexts: tePathName.setDescription("The name of this path. A pathName must be unique within the set of paths over a single tunnel. If a SET request is received with a duplicate name, then the implementation MUST return an inconsistentValue error. The value of this object cannot be changed if the value of the corresponding teTunnelRowStatus object is 'active'. ")
tePathRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 122, 1, 3, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tePathRowStatus.setStatus('current')
if mibBuilder.loadTexts: tePathRowStatus.setDescription("The status of this conceptual row. When the value of this object is 'active', then the value of tePathName cannot be changed. All other writable objects may be changed; however, these changes may affect traffic going over the TE tunnel or require the path to be computed and/or re-signaled. ")
tePathStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 122, 1, 3, 1, 4), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tePathStorageType.setStatus('current')
if mibBuilder.loadTexts: tePathStorageType.setDescription("The storage type for this conceptual row. Conceptual rows having the value 'permanent' need not allow write-access to any columnar objects in the row. ")
tePathType = MibTableColumn((1, 3, 6, 1, 2, 1, 122, 1, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("primary", 2), ("standby", 3), ("secondary", 4)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tePathType.setStatus('current')
if mibBuilder.loadTexts: tePathType.setDescription('The type for this PathEntry; i.e., whether this path is a primary path, a standby path, or a secondary path. ')
tePathConfiguredRoute = MibTableColumn((1, 3, 6, 1, 2, 1, 122, 1, 3, 1, 6), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tePathConfiguredRoute.setStatus('current')
if mibBuilder.loadTexts: tePathConfiguredRoute.setDescription('The route that this TE path is configured to follow; i.e., an ordered list of hops. The value of this object gives the primary index into the Hop Table. The secondary index is the hop count in the path, so to get the route, one could get the first hop with index <tePathConfiguredRoute, 1> in the Hop Table and do a getnext to get subsequent hops. ')
tePathBandwidth = MibTableColumn((1, 3, 6, 1, 2, 1, 122, 1, 3, 1, 7), MplsBitRate()).setUnits('Kilobits per second').setMaxAccess("readcreate")
if mibBuilder.loadTexts: tePathBandwidth.setStatus('current')
if mibBuilder.loadTexts: tePathBandwidth.setDescription('The configured bandwidth for this Tunnel, in units of thousands of bits per second (Kbps). ')
tePathIncludeAny = MibTableColumn((1, 3, 6, 1, 2, 1, 122, 1, 3, 1, 8), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tePathIncludeAny.setStatus('current')
if mibBuilder.loadTexts: tePathIncludeAny.setDescription('This is a configured set of administrative groups specified as a bit vector (i.e., bit n is 1 if group n is in the set, where n = 0 is the LSB). For each link that this path goes through, the link must have at least one of the groups specified in IncludeAny to be acceptable. If IncludeAny is zero, all links are acceptable. ')
tePathIncludeAll = MibTableColumn((1, 3, 6, 1, 2, 1, 122, 1, 3, 1, 9), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tePathIncludeAll.setStatus('current')
if mibBuilder.loadTexts: tePathIncludeAll.setDescription('This is a configured set of administrative groups specified as a bit vector (i.e., bit n is 1 if group n is in the set, where n = 0 is the LSB). For each link that this path goes through, the link must have all of the groups specified in IncludeAll to be acceptable. If IncludeAll is zero, all links are acceptable. ')
tePathExclude = MibTableColumn((1, 3, 6, 1, 2, 1, 122, 1, 3, 1, 10), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tePathExclude.setStatus('current')
if mibBuilder.loadTexts: tePathExclude.setDescription("This is a configured set of administrative groups specified as a bit vector (i.e., bit n is 1 if group n is in the set, where n = 0 is the LSB). For each link that this path goes through, the link MUST have groups associated with it, and the intersection of the link's groups and the 'exclude' set MUST be null. ")
tePathSetupPriority = MibTableColumn((1, 3, 6, 1, 2, 1, 122, 1, 3, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7)).clone(7)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tePathSetupPriority.setStatus('current')
if mibBuilder.loadTexts: tePathSetupPriority.setDescription('The setup priority configured for this path, with 0 as the highest priority and 7 as the lowest. ')
tePathHoldPriority = MibTableColumn((1, 3, 6, 1, 2, 1, 122, 1, 3, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tePathHoldPriority.setStatus('current')
if mibBuilder.loadTexts: tePathHoldPriority.setDescription('The hold priority configured for this path, with 0 as the highest priority and 7 as the lowest. ')
tePathProperties = MibTableColumn((1, 3, 6, 1, 2, 1, 122, 1, 3, 1, 13), Bits().clone(namedValues=NamedValues(("recordRoute", 0), ("cspf", 1), ("makeBeforeBreak", 2), ("mergeable", 3), ("fastReroute", 4), ("protected", 5)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tePathProperties.setStatus('current')
if mibBuilder.loadTexts: tePathProperties.setDescription("The set of configured properties for this path, expressed as a bit map. For example, if the path supports 'make before break', then bit 2 is set. ")
tePathOperStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 122, 1, 3, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unknown", 0), ("down", 1), ("testing", 2), ("dormant", 3), ("ready", 4), ("operational", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tePathOperStatus.setStatus('current')
if mibBuilder.loadTexts: tePathOperStatus.setDescription('The operational status of the path: unknown: down: Signaling failed. testing: Administratively set aside for testing. dormant: Not signaled (for a backup tunnel). ready: Signaled but not yet carrying traffic. operational: Signaled and carrying traffic. ')
tePathAdminStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 122, 1, 3, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normal", 1), ("testing", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tePathAdminStatus.setStatus('current')
if mibBuilder.loadTexts: tePathAdminStatus.setDescription('The operational status of the path: normal: Used normally for forwarding. testing: Administratively set aside for testing. ')
tePathComputedRoute = MibTableColumn((1, 3, 6, 1, 2, 1, 122, 1, 3, 1, 16), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tePathComputedRoute.setStatus('current')
if mibBuilder.loadTexts: tePathComputedRoute.setDescription('The route computed for this path, perhaps using some form of Constraint-based Routing. The algorithm is implementation dependent. This object returns the computed route as an ordered list of hops. The value of this object gives the primary index into the Hop Table. The secondary index is the hop count in the path, so to get the route, one could get the first hop with index <tePathComputedRoute, 1> in the Hop Table and do a getnext to get subsequent hops. A value of zero (0) means there is no computedRoute. ')
tePathRecordedRoute = MibTableColumn((1, 3, 6, 1, 2, 1, 122, 1, 3, 1, 17), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tePathRecordedRoute.setStatus('current')
if mibBuilder.loadTexts: tePathRecordedRoute.setDescription('The route actually used for this path, as recorded by the signaling protocol. This is again an ordered list of hops; each hop is expected to be strict. The value of this object gives the primary index into the Hop Table. The secondary index is the hop count in the path, so to get the route, one can get the first hop with index <tePathRecordedRoute, 1> in the Hop Table and do a getnext to get subsequent hops. A value of zero (0) means there is no recordedRoute. ')
tePathHopTable = MibTable((1, 3, 6, 1, 2, 1, 122, 1, 4), )
if mibBuilder.loadTexts: tePathHopTable.setStatus('current')
if mibBuilder.loadTexts: tePathHopTable.setDescription('Table of Tunnel Path Hops.')
tePathHopEntry = MibTableRow((1, 3, 6, 1, 2, 1, 122, 1, 4, 1), ).setIndexNames((0, "TE-MIB", "teHopListIndex"), (0, "TE-MIB", "tePathHopIndex"))
if mibBuilder.loadTexts: tePathHopEntry.setStatus('current')
if mibBuilder.loadTexts: tePathHopEntry.setDescription('Entry containing information about a particular hop. ')
teHopListIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 122, 1, 4, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: teHopListIndex.setStatus('current')
if mibBuilder.loadTexts: teHopListIndex.setDescription('An index that identifies a list of hops. This is the primary index to access hops. ')
tePathHopIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 122, 1, 4, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: tePathHopIndex.setStatus('current')
if mibBuilder.loadTexts: tePathHopIndex.setDescription('An index that identifies a particular hop among the list of hops for a path. An index of i identifies the ith hop. This is the secondary index for a hop entry. ')
tePathHopRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 122, 1, 4, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tePathHopRowStatus.setStatus('current')
if mibBuilder.loadTexts: tePathHopRowStatus.setDescription("The status of this conceptual row. Any field in this table can be changed, even if the value of this object is 'active'. However, such a change may cause traffic to be rerouted or even disrupted. ")
tePathHopStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 122, 1, 4, 1, 4), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tePathHopStorageType.setStatus('current')
if mibBuilder.loadTexts: tePathHopStorageType.setDescription("The storage type for this conceptual row. Conceptual rows having the value 'permanent' need not allow write-access to any columnar objects in the row. ")
tePathHopAddrType = MibTableColumn((1, 3, 6, 1, 2, 1, 122, 1, 4, 1, 5), TeHopAddressType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tePathHopAddrType.setStatus('current')
if mibBuilder.loadTexts: tePathHopAddrType.setDescription("The type of Traffic Engineered Tunnel hop Address of this hop. The value of this object cannot be changed if the value of the corresponding tePathRowStatus object is 'active'. ")
tePathHopAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 122, 1, 4, 1, 6), TeHopAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tePathHopAddress.setStatus('current')
if mibBuilder.loadTexts: tePathHopAddress.setDescription("The Traffic Engineered Tunnel hop Address of this hop. The type of this address is determined by the value of the corresponding tePathHopAddressType. The value of this object cannot be changed if the value of the corresponding teTunnelRowStatus object is 'active'. ")
tePathHopType = MibTableColumn((1, 3, 6, 1, 2, 1, 122, 1, 4, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("unknown", 0), ("loose", 1), ("strict", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tePathHopType.setStatus('current')
if mibBuilder.loadTexts: tePathHopType.setDescription('The type of hop: unknown: loose: This hop is a LOOSE hop. strict: This hop is a STRICT hop. ')
teTunnelUp = NotificationType((1, 3, 6, 1, 2, 1, 122, 0, 1)).setObjects(("TE-MIB", "teTunnelName"), ("TE-MIB", "tePathName"))
if mibBuilder.loadTexts: teTunnelUp.setStatus('current')
if mibBuilder.loadTexts: teTunnelUp.setDescription("A teTunnelUp notification is generated when the Tunnel indexed by teTunnelName transitions to the 'up' state. A tunnel is up when at least one of its paths is up. The tePathName is the name of the path whose transition to up made the tunnel go up. This notification MUST be limited to at most one every minute, in case the tunnel flaps up and down. ")
teTunnelDown = NotificationType((1, 3, 6, 1, 2, 1, 122, 0, 2)).setObjects(("TE-MIB", "teTunnelName"), ("TE-MIB", "tePathName"))
if mibBuilder.loadTexts: teTunnelDown.setStatus('current')
if mibBuilder.loadTexts: teTunnelDown.setDescription("A teTunnelDown notification is generated when the Tunnel indexed by teTunnelName transitions to the 'down' state. A tunnel is up when at least one of its paths is up. The tePathName is the name of the path whose transition to down made the tunnel go down. This notification MUST be limited to at most one every minute, in case the tunnel flaps up and down. ")
teTunnelChanged = NotificationType((1, 3, 6, 1, 2, 1, 122, 0, 3)).setObjects(("TE-MIB", "teTunnelName"), ("TE-MIB", "tePathName"))
if mibBuilder.loadTexts: teTunnelChanged.setStatus('current')
if mibBuilder.loadTexts: teTunnelChanged.setDescription('A teTunnelChanged notification is generated when an active path on the Tunnel indexed by teTunnelName changes or a new path becomes active. The value of tePathName is the new active path. This notification MUST be limited to at most one every minute, in case the tunnel changes quickly. ')
teTunnelRerouted = NotificationType((1, 3, 6, 1, 2, 1, 122, 0, 4)).setObjects(("TE-MIB", "teTunnelName"), ("TE-MIB", "tePathName"))
if mibBuilder.loadTexts: teTunnelRerouted.setStatus('current')
if mibBuilder.loadTexts: teTunnelRerouted.setDescription('A teTunnelRerouted notification is generated when an active path for the Tunnel indexed by teTunnelName stays the same, but its route changes. This notification MUST be limited to at most one every minute, in case the tunnel reroutes quickly. ')
teGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 122, 2, 1))
teModuleCompliance = MibIdentifier((1, 3, 6, 1, 2, 1, 122, 2, 2))
teTrafficEngineeringGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 122, 2, 1, 1)).setObjects(("TE-MIB", "teTunnelName"), ("TE-MIB", "teTunnelNextPathIndex"), ("TE-MIB", "teTunnelRowStatus"), ("TE-MIB", "teTunnelStorageType"), ("TE-MIB", "teTunnelSourceAddressType"), ("TE-MIB", "teTunnelSourceAddress"), ("TE-MIB", "teTunnelDestinationAddressType"), ("TE-MIB", "teTunnelDestinationAddress"), ("TE-MIB", "teTunnelState"), ("TE-MIB", "teTunnelDiscontinuityTimer"), ("TE-MIB", "teTunnelOctets"), ("TE-MIB", "teTunnelPackets"), ("TE-MIB", "teTunnelLPOctets"), ("TE-MIB", "teTunnelLPPackets"), ("TE-MIB", "teTunnelAge"), ("TE-MIB", "teTunnelTimeUp"), ("TE-MIB", "teTunnelPrimaryTimeUp"), ("TE-MIB", "teTunnelTransitions"), ("TE-MIB", "teTunnelLastTransition"), ("TE-MIB", "teTunnelPathChanges"), ("TE-MIB", "teTunnelLastPathChange"), ("TE-MIB", "teTunnelConfiguredPaths"), ("TE-MIB", "teTunnelStandbyPaths"), ("TE-MIB", "teTunnelOperationalPaths"), ("TE-MIB", "tePathBandwidth"), ("TE-MIB", "tePathIncludeAny"), ("TE-MIB", "tePathIncludeAll"), ("TE-MIB", "tePathExclude"), ("TE-MIB", "tePathSetupPriority"), ("TE-MIB", "tePathHoldPriority"), ("TE-MIB", "tePathProperties"), ("TE-MIB", "tePathOperStatus"), ("TE-MIB", "tePathAdminStatus"), ("TE-MIB", "tePathComputedRoute"), ("TE-MIB", "tePathRecordedRoute"), ("TE-MIB", "teDistProtocol"), ("TE-MIB", "teSignalingProto"), ("TE-MIB", "teNotificationEnable"), ("TE-MIB", "teNextTunnelIndex"), ("TE-MIB", "teNextPathHopIndex"), ("TE-MIB", "teAdminGroupName"), ("TE-MIB", "teAdminGroupRowStatus"), ("TE-MIB", "teConfiguredTunnels"), ("TE-MIB", "teActiveTunnels"), ("TE-MIB", "tePrimaryTunnels"), ("TE-MIB", "tePathName"), ("TE-MIB", "tePathType"), ("TE-MIB", "tePathRowStatus"), ("TE-MIB", "tePathStorageType"), ("TE-MIB", "tePathConfiguredRoute"), ("TE-MIB", "tePathHopRowStatus"), ("TE-MIB", "tePathHopStorageType"), ("TE-MIB", "tePathHopAddrType"), ("TE-MIB", "tePathHopAddress"), ("TE-MIB", "tePathHopType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    teTrafficEngineeringGroup = teTrafficEngineeringGroup.setStatus('current')
if mibBuilder.loadTexts: teTrafficEngineeringGroup.setDescription('Objects for Traffic Engineering in this MIB module.')
teNotificationGroup = NotificationGroup((1, 3, 6, 1, 2, 1, 122, 2, 1, 2)).setObjects(("TE-MIB", "teTunnelUp"), ("TE-MIB", "teTunnelDown"), ("TE-MIB", "teTunnelChanged"), ("TE-MIB", "teTunnelRerouted"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    teNotificationGroup = teNotificationGroup.setStatus('current')
if mibBuilder.loadTexts: teNotificationGroup.setDescription('Notifications specified in this MIB module.')
teModuleReadOnlyCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 122, 2, 2, 1)).setObjects(("TE-MIB", "teTrafficEngineeringGroup"), ("TE-MIB", "teNotificationGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    teModuleReadOnlyCompliance = teModuleReadOnlyCompliance.setStatus('current')
if mibBuilder.loadTexts: teModuleReadOnlyCompliance.setDescription('When this MIB module is implemented without support for read-create (i.e., in read-only mode), then such an implementation can claim read-only compliance. Such a device can be monitored but cannot be configured with this MIB module. ')
teModuleFullCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 122, 2, 2, 2)).setObjects(("TE-MIB", "teTrafficEngineeringGroup"), ("TE-MIB", "teNotificationGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    teModuleFullCompliance = teModuleFullCompliance.setStatus('current')
if mibBuilder.loadTexts: teModuleFullCompliance.setDescription('When this MIB module is implemented with support for read-create, then the implementation can claim full compliance. Such devices can be both monitored and configured with this MIB module. ')
teModuleServerReadOnlyCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 122, 2, 2, 3)).setObjects(("TE-MIB", "teTrafficEngineeringGroup"), ("TE-MIB", "teNotificationGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    teModuleServerReadOnlyCompliance = teModuleServerReadOnlyCompliance.setStatus('current')
if mibBuilder.loadTexts: teModuleServerReadOnlyCompliance.setDescription('When this MIB module is implemented by a path computation server without support for read-create (i.e., in read-only mode), then the implementation can claim read-only compliance. Such a device can be monitored but cannot be configured with this MIB module. ')
teModuleServerFullCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 122, 2, 2, 4)).setObjects(("TE-MIB", "teTrafficEngineeringGroup"), ("TE-MIB", "teNotificationGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    teModuleServerFullCompliance = teModuleServerFullCompliance.setStatus('current')
if mibBuilder.loadTexts: teModuleServerFullCompliance.setDescription('When this MIB module is implemented by a path computation server with support for read-create, then the implementation can claim full compliance. ')
mibBuilder.exportSymbols("TE-MIB", teMIBObjects=teMIBObjects, teNotificationEnable=teNotificationEnable, tePathConfiguredRoute=tePathConfiguredRoute, tePathRowStatus=tePathRowStatus, teMIBConformance=teMIBConformance, tePathOperStatus=tePathOperStatus, teTunnelStandbyPaths=teTunnelStandbyPaths, teAdminGroupName=teAdminGroupName, teSignalingProto=teSignalingProto, teTunnelLPOctets=teTunnelLPOctets, teTunnelDestinationAddress=teTunnelDestinationAddress, teAdminGroupNumber=teAdminGroupNumber, tePathHopAddrType=tePathHopAddrType, teTunnelDestinationAddressType=teTunnelDestinationAddressType, teTunnelDown=teTunnelDown, teMIB=teMIB, teTunnelTimeUp=teTunnelTimeUp, tePathIncludeAll=tePathIncludeAll, teMIBNotifications=teMIBNotifications, teTunnelChanged=teTunnelChanged, teTunnelUp=teTunnelUp, tePathName=tePathName, teModuleServerReadOnlyCompliance=teModuleServerReadOnlyCompliance, tePathSetupPriority=tePathSetupPriority, tePathBandwidth=tePathBandwidth, teModuleServerFullCompliance=teModuleServerFullCompliance, tePathProperties=tePathProperties, teAdminGroupTable=teAdminGroupTable, tePathHopEntry=tePathHopEntry, tePathAdminStatus=tePathAdminStatus, tePathHoldPriority=tePathHoldPriority, teTunnelNextPathIndex=teTunnelNextPathIndex, teGroups=teGroups, teTunnelRowStatus=teTunnelRowStatus, teTunnelOperationalPaths=teTunnelOperationalPaths, teInfo=teInfo, teTunnelState=teTunnelState, teModuleCompliance=teModuleCompliance, teTunnelOctets=teTunnelOctets, teTunnelPathChanges=teTunnelPathChanges, tePathStorageType=tePathStorageType, teModuleReadOnlyCompliance=teModuleReadOnlyCompliance, teConfiguredTunnels=teConfiguredTunnels, teTunnelDiscontinuityTimer=teTunnelDiscontinuityTimer, teTunnelIndex=teTunnelIndex, teTunnelEntry=teTunnelEntry, tePathIncludeAny=tePathIncludeAny, tePathHopStorageType=tePathHopStorageType, teAdminGroupEntry=teAdminGroupEntry, tePathHopTable=tePathHopTable, tePrimaryTunnels=tePrimaryTunnels, tePathHopIndex=tePathHopIndex, teTrafficEngineeringGroup=teTrafficEngineeringGroup, teTunnelLastTransition=teTunnelLastTransition, tePathComputedRoute=tePathComputedRoute, tePathExclude=tePathExclude, teTunnelRerouted=teTunnelRerouted, teDistProtocol=teDistProtocol, teNextTunnelIndex=teNextTunnelIndex, teTunnelName=teTunnelName, tePathIndex=tePathIndex, teActiveTunnels=teActiveTunnels, teHopListIndex=teHopListIndex, teModuleFullCompliance=teModuleFullCompliance, teTunnelTransitions=teTunnelTransitions, tePathRecordedRoute=tePathRecordedRoute, teTunnelAge=teTunnelAge, tePathHopAddress=tePathHopAddress, PYSNMP_MODULE_ID=teMIB, tePathType=tePathType, tePathEntry=tePathEntry, teNextPathHopIndex=teNextPathHopIndex, teTunnelLPPackets=teTunnelLPPackets, teNotificationGroup=teNotificationGroup, teTunnelSourceAddress=teTunnelSourceAddress, tePathHopRowStatus=tePathHopRowStatus, teTunnelConfiguredPaths=teTunnelConfiguredPaths, teTunnelPrimaryTimeUp=teTunnelPrimaryTimeUp, teTunnelLastPathChange=teTunnelLastPathChange, teTunnelTable=teTunnelTable, teAdminGroupRowStatus=teAdminGroupRowStatus, tePathTable=tePathTable, teTunnelSourceAddressType=teTunnelSourceAddressType, tePathHopType=tePathHopType, teTunnelStorageType=teTunnelStorageType, teTunnelPackets=teTunnelPackets)

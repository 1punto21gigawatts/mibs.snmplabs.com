#
# PySNMP MIB module XYLAN-BACKUP-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/XYLAN-BACKUP-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:44:54 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ValueRangeConstraint, ConstraintsIntersection, SingleValueConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsIntersection", "SingleValueConstraint", "ConstraintsUnion")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
ObjectIdentity, IpAddress, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn, Gauge32, TimeTicks, Unsigned32, Counter32, Integer32, Counter64, ModuleIdentity, iso, Bits, MibIdentifier = mibBuilder.importSymbols("SNMPv2-SMI", "ObjectIdentity", "IpAddress", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Gauge32", "TimeTicks", "Unsigned32", "Counter32", "Integer32", "Counter64", "ModuleIdentity", "iso", "Bits", "MibIdentifier")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
xylanBackupArch, = mibBuilder.importSymbols("XYLAN-BASE-MIB", "xylanBackupArch")
backupxConfigGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 16, 1))
backupxConfigTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 16, 1, 1), )
if mibBuilder.loadTexts: backupxConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: backupxConfigTable.setDescription('A table of Backup Services configuration information.')
backupxConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 16, 1, 1, 1), ).setIndexNames((0, "XYLAN-BACKUP-MIB", "backupxConfigID"))
if mibBuilder.loadTexts: backupxConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: backupxConfigEntry.setDescription('An entry in the Backup Service Entity Configuration table, containing information about a backup service.')
backupxConfigID = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 16, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: backupxConfigID.setStatus('mandatory')
if mibBuilder.loadTexts: backupxConfigID.setDescription('The Backup Service ID. This is used as a unique ID to identify a backup service entity.')
backupxConfigDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 16, 1, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: backupxConfigDescription.setStatus('mandatory')
if mibBuilder.loadTexts: backupxConfigDescription.setDescription('A description for this Backup Service.')
backupxConfigAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 16, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("delete", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: backupxConfigAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: backupxConfigAdminStatus.setDescription('This object controls the Administrative Status of this Backup Service. Enabled will allow the Backup Service to operate. Disabled will disable the service without deleting it. Delete will disable the backup and delete the backup service configuration record.')
backupxConfigPrimaryType = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 16, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("physicalPort", 1), ("frameRelayPvcDlci", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: backupxConfigPrimaryType.setStatus('mandatory')
if mibBuilder.loadTexts: backupxConfigPrimaryType.setDescription('This object controls the type of entity to be backed up in case of failure.')
backupxConfigPrimaryIndex1 = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 16, 1, 1, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: backupxConfigPrimaryIndex1.setStatus('mandatory')
if mibBuilder.loadTexts: backupxConfigPrimaryIndex1.setDescription('This object controls the first Index object to use to identify the Primary entity to backup based on type: Physical Port: slot Frame Relay PVC: slot')
backupxConfigPrimaryIndex2 = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 16, 1, 1, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: backupxConfigPrimaryIndex2.setStatus('mandatory')
if mibBuilder.loadTexts: backupxConfigPrimaryIndex2.setDescription('This object controls the first Index object to use to identify the Primary entity to backup based on type: Physical Port: port Frame Relay PVC: port')
backupxConfigPrimaryIndex3 = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 16, 1, 1, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: backupxConfigPrimaryIndex3.setStatus('mandatory')
if mibBuilder.loadTexts: backupxConfigPrimaryIndex3.setDescription('This object controls the first Index object to use to identify the Primary entity to backup based on type: Physical Port: 0 Frame Relay PVC: DLCI number')
backupxConfigBackupType = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 16, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("pppPeer", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: backupxConfigBackupType.setStatus('mandatory')
if mibBuilder.loadTexts: backupxConfigBackupType.setDescription('This object controls the type of entity to use to back up the primary entity in case of failure.')
backupxConfigBackupIndex1 = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 16, 1, 1, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: backupxConfigBackupIndex1.setStatus('mandatory')
if mibBuilder.loadTexts: backupxConfigBackupIndex1.setDescription('This object controls the first Index object to use to identify the backup entity based on type: PPP Peer: Peer ID')
backupxConfigBackupIndex2 = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 16, 1, 1, 1, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: backupxConfigBackupIndex2.setStatus('mandatory')
if mibBuilder.loadTexts: backupxConfigBackupIndex2.setDescription('This object controls the second Index object to use to identify the backup entity: This object is currently reserved for possible future use.')
backupxConfigBackupIndex3 = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 16, 1, 1, 1, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: backupxConfigBackupIndex3.setStatus('mandatory')
if mibBuilder.loadTexts: backupxConfigBackupIndex3.setDescription('This object controls the third Index object to use to identify the backup entity: This object is currently reserved for possible future use.')
backupxConfigStartupTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 16, 1, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: backupxConfigStartupTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: backupxConfigStartupTimeout.setDescription('This object controls the time in seconds after system startup to wait for the Primary entity to come up before activating the backup entity.')
backupxConfigActivateTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 16, 1, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: backupxConfigActivateTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: backupxConfigActivateTimeout.setDescription('This object controls the time in seconds after the Primary entity enters and stays in a Failed state before activating the backup entity.')
backupxConfigRestoreTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 16, 1, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: backupxConfigRestoreTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: backupxConfigRestoreTimeout.setDescription('This object controls the time in seconds after the Primary entity enters and stays in a Operational state before deactivating the backup entity.')
mibBuilder.exportSymbols("XYLAN-BACKUP-MIB", backupxConfigBackupIndex3=backupxConfigBackupIndex3, backupxConfigActivateTimeout=backupxConfigActivateTimeout, backupxConfigPrimaryType=backupxConfigPrimaryType, backupxConfigStartupTimeout=backupxConfigStartupTimeout, backupxConfigPrimaryIndex3=backupxConfigPrimaryIndex3, backupxConfigEntry=backupxConfigEntry, backupxConfigDescription=backupxConfigDescription, backupxConfigTable=backupxConfigTable, backupxConfigBackupIndex2=backupxConfigBackupIndex2, backupxConfigGroup=backupxConfigGroup, backupxConfigRestoreTimeout=backupxConfigRestoreTimeout, backupxConfigPrimaryIndex1=backupxConfigPrimaryIndex1, backupxConfigBackupType=backupxConfigBackupType, backupxConfigPrimaryIndex2=backupxConfigPrimaryIndex2, backupxConfigID=backupxConfigID, backupxConfigBackupIndex1=backupxConfigBackupIndex1, backupxConfigAdminStatus=backupxConfigAdminStatus)

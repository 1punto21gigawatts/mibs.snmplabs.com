#
# PySNMP MIB module ESWITCH-MIB-V3-0 (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/ESWITCH-MIB-V3-0
# Produced by pysmi-0.3.4 at Wed May  1 13:06:40 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ConstraintsUnion, ConstraintsIntersection, ValueSizeConstraint, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ConstraintsUnion", "ConstraintsIntersection", "ValueSizeConstraint", "SingleValueConstraint")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
MibScalar, MibTable, MibTableRow, MibTableColumn, Unsigned32, Bits, IpAddress, iso, Counter64, Gauge32, MibIdentifier, Counter32, enterprises, ObjectIdentity, ModuleIdentity, NotificationType, Integer32, TimeTicks = mibBuilder.importSymbols("SNMPv2-SMI", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Unsigned32", "Bits", "IpAddress", "iso", "Counter64", "Gauge32", "MibIdentifier", "Counter32", "enterprises", "ObjectIdentity", "ModuleIdentity", "NotificationType", "Integer32", "TimeTicks")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
dec = MibIdentifier((1, 3, 6, 1, 4, 1, 36))
ema = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2))
decMIBextension = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18))
decHub900 = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11))
eSwitch = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 7))
eSwitchIf = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 7, 1))
eSwitchIfTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 7, 1, 1), )
if mibBuilder.loadTexts: eSwitchIfTable.setStatus('mandatory')
if mibBuilder.loadTexts: eSwitchIfTable.setDescription('A table that contains information about various characteristics associated with each interface on the switch.')
eSwitchIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 7, 1, 1, 1), ).setIndexNames((0, "ESWITCH-MIB-V3-0", "eSwitchIfIndex"))
if mibBuilder.loadTexts: eSwitchIfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: eSwitchIfEntry.setDescription('A list that contains the interface number and various characteristics associated with the interface.')
eSwitchIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 7, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: eSwitchIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: eSwitchIfIndex.setDescription('An index value that identifies the interface for which this entry defines various characteristics. The interface identified by a particular value of this index is the same interface as identified by the same value of ifIndex.')
eSwitchIfPresent = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 7, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("present", 1), ("not-present", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: eSwitchIfPresent.setStatus('mandatory')
if mibBuilder.loadTexts: eSwitchIfPresent.setDescription('This object assumes the value present(1), if the corresponding interface is present; it assumes a value of not-present(2), otherwise. An interface may not be present, for instance, if it is modular and not installed.')
eSwitchPort = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 7, 2))
eSwitchPortTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 7, 2, 1), )
if mibBuilder.loadTexts: eSwitchPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: eSwitchPortTable.setDescription('A table that contains information about and that may be used to configure various characteristics associated with each port on the switch.')
eSwitchPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 7, 2, 1, 1), ).setIndexNames((0, "ESWITCH-MIB-V3-0", "eSwitchPortIndex"))
if mibBuilder.loadTexts: eSwitchPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: eSwitchPortEntry.setDescription('A list that contains the port number and various characteristics associated with the port.')
eSwitchPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 7, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: eSwitchPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: eSwitchPortIndex.setDescription('The port number of the switch port for which this entry defines various characteristics.')
eSwitchPortFailed = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 7, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("failed", 2), ("not-failed", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: eSwitchPortFailed.setStatus('mandatory')
if mibBuilder.loadTexts: eSwitchPortFailed.setDescription('This object assumes the value failed(2), if the corresponding port is present, but has been determined to be faulty and has been declared failed; otherwise, the value not-failed(3) is returned, if the port is present. A value of unknown(1) is returned if the port is not present.')
eSwitchPortStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 7, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("undefined", 1), ("connected", 2), ("disconnected", 3), ("shutdown", 4), ("isolated", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: eSwitchPortStatus.setStatus('mandatory')
if mibBuilder.loadTexts: eSwitchPortStatus.setDescription('When read, this object returns the current status of this port. This object may also be used to shut down a port that is currently connected(2), disconnected(3), or isolated(5), by setting this object to the value shut-down(4). A port that has been shut down due to security violations, or by management, may be brought back up by setting this object to connected(2). Any other values for this object are rejected for a set operation. All traffic (including in-band management traffic addressed to the switch, if any) on a port that has been shut down is filtered, no counters are incremented, and no frames are transmitted or forwarded on such a port.')
eSwitchPortShutDownReason = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 7, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("none", 1), ("other", 2), ("mgmt", 3), ("security", 4), ("internal", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: eSwitchPortShutDownReason.setStatus('mandatory')
if mibBuilder.loadTexts: eSwitchPortShutDownReason.setDescription('The reason why this port is currently shut down. A value of none(1) is returned, if the port is not currently shutdown. A value of mgmt(3) is returned, if the port has been shut down due to a request from network management. A value of security(3) is returned if the port has been shut down due to a detected security violation. A value of internal(5) is returned, when the firmware determines that the port should be shut down at this time for proper operation of the device. For example, if the port has been configured to point to the hub or stack backplane, but has been shut down in order to wait for a backplane connection to be established by management, this value is returned.')
eSwitchPortSwitchingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 7, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("standard", 1), ("workgroup", 2), ("backbone", 3), ("manual", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: eSwitchPortSwitchingMode.setStatus('mandatory')
if mibBuilder.loadTexts: eSwitchPortSwitchingMode.setDescription('This object defines the switching mode in which this port operates. The switching mode of a port determines whether or not it learns station location information from source addresses of packets received on the port; the switching mode also determines whether or not packets with unknown destination addresses received on other ports are flooded out this port. The following notation is used in the switching mode definitions that follow: LRN: station location information is learned from source addresses of packets received on port. !LRN: station location information is NOT learned from source addresses of packets received on port. FUD: packets with unknown destination addresses received on other ports are flooded out this port. !FUD: packets with unknown destination addresses received on other ports are NOT flooded out this port. A port may be configured to operate in one of the following switching modes: standard(1): LRN & FUD This is the mode in which all ports of a 802.1D-compliant standard switch operates. workgroup(2): LRN & !FUD This is the mode in which workgroup side ports of a workgroup switch operates. backbone(3): !LRN & FUD This is the mode in which the backbone port of a workgroup switch operates. manual(4): !LRN & !FUD In this mode, forwarding out this port is fully determined by management-specified filters. When learning is disabled on a port (i.e., mode is changed to backbone(3) or manual(4)), whether addresses previously learned on the port are purged immediately or allowed to age out naturally is implementation dependent. Note that all ports may be configured to operate in the manual(4) switching mode with a single operation, viz. by enabling(2) the manual mode switch defined by the following object: eSwitchAddrFdbManualMode.')
eSwitchFdb = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 7, 3))
eSwitchAddrFdb = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 7, 3, 1))
eSwitchAddrFdbMaxEntries = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 7, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eSwitchAddrFdbMaxEntries.setStatus('mandatory')
if mibBuilder.loadTexts: eSwitchAddrFdbMaxEntries.setDescription('The maximum number of address entries that can be accommodated in the filtering database of the switch. This number includes learned entries, static entries (entries in the RFC 1493 dot1dStaticTable), and entries that may be used by the switch for other purposes (e.g., security).')
eSwitchAddrFdbMaxStaticEntries = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 7, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eSwitchAddrFdbMaxStaticEntries.setStatus('mandatory')
if mibBuilder.loadTexts: eSwitchAddrFdbMaxStaticEntries.setDescription('The maximum number of static address entries that may be installed by management in the filtering database of the switch. This number is identical to the maximum number of entries supported in the dot1dStaticTable (RFC 1493).')
eSwitchAddrFdbMaxNVStaticEntries = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 7, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eSwitchAddrFdbMaxNVStaticEntries.setStatus('mandatory')
if mibBuilder.loadTexts: eSwitchAddrFdbMaxNVStaticEntries.setDescription("The maximum number of static address entries in the filtering database of the switch, that can be accommodated in non-volatile memory. Entries stored in non-volatile memory will be restored after a power cycle. This number is identical to the maximum number of entries that may have a status of 'permanent' in the dot1dStaticTable (RFC1493).")
eSwitchAddrFdbDynamicEntries = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 7, 3, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eSwitchAddrFdbDynamicEntries.setStatus('mandatory')
if mibBuilder.loadTexts: eSwitchAddrFdbDynamicEntries.setDescription('The current number of dynamic address entries (i.e., entries that were learnt) in the filtering database of the switch.')
eSwitchAddrFdbStaticEntries = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 7, 3, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eSwitchAddrFdbStaticEntries.setStatus('mandatory')
if mibBuilder.loadTexts: eSwitchAddrFdbStaticEntries.setDescription('The current number of static entries in the filtering database of the switch. This number is identical to the current number of entries in the dot1dStaticTable (RFC 1493).')
eSwitchAddrFdbNVStaticEntries = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 7, 3, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eSwitchAddrFdbNVStaticEntries.setStatus('mandatory')
if mibBuilder.loadTexts: eSwitchAddrFdbNVStaticEntries.setDescription("The number of static address entries in the filtering database of the switch, that are currently stored in non-volatile memory. Entries stored in non-volatile memory will be restored after a power cycle. This number is identical to the current number of entries in the dot1dStaticTable (RFC 1493) that have a status of 'permanent'.")
eSwitchAddrFdbPurgeStaticEntries = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 7, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("purge", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: eSwitchAddrFdbPurgeStaticEntries.setStatus('mandatory')
if mibBuilder.loadTexts: eSwitchAddrFdbPurgeStaticEntries.setDescription("This object when set to purge(1) causes all static address entries in the filtering database to be deleted both from volatile and non-volatile memory. The 'purge' action deletes only those entries in the address filtering database that are also in the dot1dStaticTable (RFC 1493).")
eSwitchStorm = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 7, 4))
eSwitchStormFrameTypeRegulated = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 7, 4, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("broadcast", 2), ("multicast", 3), ("broadcastAndMulticast", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: eSwitchStormFrameTypeRegulated.setStatus('mandatory')
if mibBuilder.loadTexts: eSwitchStormFrameTypeRegulated.setDescription('Specifies what types of frames with group destination addresses are currently being regulated. Only the specified class of traffic is considered in detecting the presence of storms, and only this class of traffic is regulated when a storm is detected. The value none(1) specifies that storm control is disabled. The value broadcast(2) specifies that only broadcast storms are regulated. The value multicast(3) specifies that only multicast storms are regulated. The value broadcastAndMulticast specifies that storms involving a mixture of broadcast and multicast traffic are regulated.')
eSwitchStormPollingInterval = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 7, 4, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 360000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: eSwitchStormPollingInterval.setStatus('mandatory')
if mibBuilder.loadTexts: eSwitchStormPollingInterval.setDescription('The length of the interval in 10 millisecond units between successive instants when the storm control process examines the broadcast/multicast received frame counters to detect the presence or end of a storm. ')
eSwitchStormRateLimit = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 7, 4, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: eSwitchStormRateLimit.setStatus('mandatory')
if mibBuilder.loadTexts: eSwitchStormRateLimit.setDescription('The maximum number of regulated group address frames (broadcast, multicast, or a mixture of both - see eSwitchStormFrameTypeRegulated) that may be received on a port during a polling interval before the storm control process decides that storm conditions exist on the port. This object may not be set to a value below 1 packet per polling interval.')
eSwitchStormControlAction = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 7, 4, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("frame-suppression", 1), ("port-isolation", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: eSwitchStormControlAction.setStatus('mandatory')
if mibBuilder.loadTexts: eSwitchStormControlAction.setDescription('The action that the storm control process should take when storm conditions are detected on a port. Frame suppression consists of suspending the forwarding of regulated frames (broadcast, multicast, or both, depending on the value of the MIB object eSwitchStormFrameTypeRegulated) received on the port on which the storm is detected. Port isolation consists of disabling an offending port in a manner that will cause all frames received on that port to be discarded, while allowing receive packet counters to be maintained. ')
eSwitchStormResumptionPolicy = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 7, 4, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("continue-control", 1), ("auto-interval", 2), ("rate-limit", 3), ("responsive-rate-limit", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: eSwitchStormResumptionPolicy.setStatus('mandatory')
if mibBuilder.loadTexts: eSwitchStormResumptionPolicy.setDescription("The policy used by the storm control process to resume normal operation, once storm control action has been initiated. If continue-control(1) is specified, the storm control action continues to be in effect, until the user modifies one of the following storm control parameters: eSwitchStormFrameTypeRegulated, eSwitchStormControlAction, eSwitchStormResumptionPolicy. If auto-interval(2) is specified, normal operation is automatically resumed on the offending port after a time interval specified by the MIB object eSwitchStormAutoInterval. If rate-limit(3) is specified, the storm control action continues for the next p polling intervals, where p is the number of polling intervals that the control has to remain in effect in order to ensure that the long term average of the regulated traffic is less than the user specified rate limit. For example, if the user-specified rate limit is 500 packets/polling interval, and 5000 multicast packets were received during the last polling interval, the storm control action continues to be in effect for the next 9 polling intervals. This ensures that no more than 5000 multicast packets are forwarded out of the offending port in 10 polling intervals. Thus the long term multicast traffic average is maintained at 500 packets/polling interval. The responsive-rate-limit(4) resumption policy is identical to the rate-limit(3) policy, except for the following difference. Once storm control action has been initiated, if the switch determines that the storm has subsided (for example, less than 500 packets were received during the last polling interval), normal operation is immediately resumed, instead of waiting for 'p' polling intervals to complete.")
eSwitchStormAutoInterval = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 7, 4, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: eSwitchStormAutoInterval.setStatus('mandatory')
if mibBuilder.loadTexts: eSwitchStormAutoInterval.setDescription('This parameter is used when the eSwitchStormResumptionPolicy specified is auto -interval(2). Normal operation is automatically resumed on the offending port after a length of time (in seconds) specified by this object. The minimum value allowed for this object is 1 second.')
eSwitchStormFramesLost = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 7, 4, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eSwitchStormFramesLost.setStatus('mandatory')
if mibBuilder.loadTexts: eSwitchStormFramesLost.setDescription('The number of regulated frames (broadcast, multicast or both, depending on the value of the object: eSwitchStormFrameTypeRegulated) received on any port that were dropped by the switch as a result of storm control action.')
eSwitchStormActionsInitiated = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 7, 4, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eSwitchStormActionsInitiated.setStatus('mandatory')
if mibBuilder.loadTexts: eSwitchStormActionsInitiated.setDescription('The number of times that storm control action was initiated on any port on the switch.')
eSwitchStormPortTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 7, 4, 9), )
if mibBuilder.loadTexts: eSwitchStormPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: eSwitchStormPortTable.setDescription('A table that contains storm status information for every port on the switch.')
eSwitchStormPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 7, 4, 9, 1), ).setIndexNames((0, "ESWITCH-MIB-V3-0", "eSwitchStormPortIndex"))
if mibBuilder.loadTexts: eSwitchStormPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: eSwitchStormPortEntry.setDescription('A list of storm control related information items for every port on the switch.')
eSwitchStormPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 7, 4, 9, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: eSwitchStormPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: eSwitchStormPortIndex.setDescription('The port number of the switch port for which this entry contains storm control related information.')
eSwitchStormPortControlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 7, 4, 9, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("inactive", 1), ("active", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: eSwitchStormPortControlStatus.setStatus('mandatory')
if mibBuilder.loadTexts: eSwitchStormPortControlStatus.setDescription('The current status of storm control on the port. The value inactive(1) indicates that no storm control action is currently in effect on the port. The value active(2) indicates that some storm control action is in effect on the port.')
eSwitchStormPortFramesLost = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 7, 4, 9, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eSwitchStormPortFramesLost.setStatus('mandatory')
if mibBuilder.loadTexts: eSwitchStormPortFramesLost.setDescription('The number of regulated frames (broadcast, multicast or both, depending on the value of the object: eSwitchStormFrameTypeRegulated) received on this port that were dropped by the switch as a result of storm control action.')
eSwitchStormPortActionsInitiated = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 7, 4, 9, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eSwitchStormPortActionsInitiated.setStatus('mandatory')
if mibBuilder.loadTexts: eSwitchStormPortActionsInitiated.setDescription('The number of times that storm control action was initiated on this port on the switch.')
eSwitchSecurity = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 7, 5))
eSwitchSecurityViolationsDetected = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 7, 5, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eSwitchSecurityViolationsDetected.setStatus('mandatory')
if mibBuilder.loadTexts: eSwitchSecurityViolationsDetected.setDescription('The total number of security violations detected on all the ports on this switch, since the switch was last reset. Depending on the implementation, a switch may not be able to count every security violation. This number therefore represents only a lower limit on the actual number of security violations that occured.')
eSwitchSecurityPortTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 7, 5, 2), )
if mibBuilder.loadTexts: eSwitchSecurityPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: eSwitchSecurityPortTable.setDescription('A table that contains information about the type of secure mode currently in effect on each port of the switch.')
eSwitchSecurityPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 7, 5, 2, 1), ).setIndexNames((0, "ESWITCH-MIB-V3-0", "eSwitchSecurityPortIndex"))
if mibBuilder.loadTexts: eSwitchSecurityPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: eSwitchSecurityPortEntry.setDescription('A list that contains the port number and the type of security mode currently in effect on the port for a switch port.')
eSwitchSecurityPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 7, 5, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: eSwitchSecurityPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: eSwitchSecurityPortIndex.setDescription('The port number of the switch port for which this entry defines the type of secure mode.')
eSwitchSecurityPortMode = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 7, 5, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("manual-authorize", 2), ("auto-authorize", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: eSwitchSecurityPortMode.setStatus('mandatory')
if mibBuilder.loadTexts: eSwitchSecurityPortMode.setDescription("The type of security currently in effect on the switch port. A value of none(1) indicates that the port is not currently in the secure mode of operation. A value of manual-authorize(2) indicates that any packet, whose source addresse does not match one of the addresses authorized on the port by management via the eSwitchSecurityPortAuthTable, is discarded upon receipt. A value of auto-authorize(3) indicates that upto a maximum of N addresses will be added by the switch to the eSwitchSecurityPortAuthTable automatically, when a packet with a source address corresponding to one of these addresses is seen on the port. 'N' is a user-settable value that may be configured through the following object: eSwitchSecurityPortMaxAutoAuthAddr Further, any packet with a source address that does not match one of the addresses in the eSwitchSecurityAuthTable is discared upon receipt. Depending on the implementation, a station may have to send 1 or more frames before its address gets 'auto-authorized' on the port. The policy used to select stations for authorization (e.g., FCFS, random, etc.) is left to individual implementations. The N authorized addresses may be read by management from the following object: eSwitchSecurityPortAuthorizedAddressTable. All authorized addresses on the port are purged whenever the value of this object is modified.")
eSwitchSecurityPortViolationsDetected = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 7, 5, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eSwitchSecurityPortViolationsDetected.setStatus('mandatory')
if mibBuilder.loadTexts: eSwitchSecurityPortViolationsDetected.setDescription('The number of security violations detected on this port, since the port entered its current mode of security. Depending on the implementation, a switch may not be able to count every security violation. This number therefore represents only a lower limit on the actual number of security violations that occured.')
eSwitchSecurityPortViolationResponse = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 7, 5, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("filter", 1), ("filter-and-log", 2), ("shutdown-and-log", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: eSwitchSecurityPortViolationResponse.setStatus('mandatory')
if mibBuilder.loadTexts: eSwitchSecurityPortViolationResponse.setDescription('The policy for dealing with security violations on this switch port. A security violation is deemed to have occured, when a frame with an unauthorized source address is received on a port. A value of filter(1) indicates that frame with source addresses that are not authorized on the port will be silently filtered. If this object is set to the filter-and-log(2), frames with unauthorized source addresses will be filtered, and the security violation logged in the following table: eSwitchSecurityLogTable. If this object is set to the value shutdown-and-log(3), the port is entirely shut down when a frame with an unauthorized source address is received on the port. The port remains shut down until management brings up the port by setting the following MIB object to the value connected(1): eSwitchPortStatus.')
eSwitchSecurityPortMaxAuthAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 7, 5, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eSwitchSecurityPortMaxAuthAddr.setStatus('mandatory')
if mibBuilder.loadTexts: eSwitchSecurityPortMaxAuthAddr.setDescription('The maximum number of addresses that may be authorized on this port, when the port is in the manual-authorize(2) secure mode. When the port is in the auto-authorize(3) secure mode, the maximum number of addresses that may be authorized on this port is the smaller of the values of this and the following object: eSwitchSecurityPortMaxAutoAuthAddr.')
eSwitchSecurityPortMaxAutoAuthAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 7, 5, 2, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: eSwitchSecurityPortMaxAutoAuthAddr.setStatus('mandatory')
if mibBuilder.loadTexts: eSwitchSecurityPortMaxAutoAuthAddr.setDescription('The maximum number of addresses that may be authorized on this port, when the port is in the auto-authorize(3) secure mode. The value of this object may not exceed the value of the following object: eSwitchSecurityPortMaxAuthAddr If the port is currently in the auto-authorize secure mode, any addresses already authorized on this port are purged whenever the value of this object is decreased from its current value.')
eSwitchSecurityPortCurrAuthAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 7, 5, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eSwitchSecurityPortCurrAuthAddr.setStatus('mandatory')
if mibBuilder.loadTexts: eSwitchSecurityPortCurrAuthAddr.setDescription('The number of addresses currently authorized on this port. If the current type of secure mode on this port as given by the corresponding instance of eSwitchSecurityPortType is none(1), this has a value of 0; otherwise this object may have any INTEGER value smaller than the value of the following object: eSwitchSecurityPortMaxAuthAddr.')
eSwitchSecurityPortPurgeAuthAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 7, 5, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("trigger", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: eSwitchSecurityPortPurgeAuthAddr.setStatus('mandatory')
if mibBuilder.loadTexts: eSwitchSecurityPortPurgeAuthAddr.setDescription('This object when set to the value trigger(1) causes all the currently authorized addresses on the port to be purged.')
eSwitchSecurityAuthTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 7, 5, 3), )
if mibBuilder.loadTexts: eSwitchSecurityAuthTable.setStatus('mandatory')
if mibBuilder.loadTexts: eSwitchSecurityAuthTable.setDescription('A table that lists the set of addresses that are authorized on a port for each port of the switch.')
eSwitchSecurityAuthEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 7, 5, 3, 1), ).setIndexNames((0, "ESWITCH-MIB-V3-0", "eSwitchSecurityAuthPort"), (0, "ESWITCH-MIB-V3-0", "eSwitchSecurityAuthAddress"))
if mibBuilder.loadTexts: eSwitchSecurityAuthEntry.setStatus('mandatory')
if mibBuilder.loadTexts: eSwitchSecurityAuthEntry.setDescription('An address authorization entry that consists of a port and an address authorized on the port.')
eSwitchSecurityAuthPort = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 7, 5, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: eSwitchSecurityAuthPort.setStatus('mandatory')
if mibBuilder.loadTexts: eSwitchSecurityAuthPort.setDescription('The port number of the switch port for which this entry defines an authorized address.')
eSwitchSecurityAuthAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 7, 5, 3, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: eSwitchSecurityAuthAddress.setStatus('mandatory')
if mibBuilder.loadTexts: eSwitchSecurityAuthAddress.setDescription('The address that this entry authorizes on the port specified by the corresponding instance of the object eSwitchSecurityAuthPort.')
eSwitchSecurityAuthStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 7, 5, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("invalid", 1), ("active", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: eSwitchSecurityAuthStatus.setStatus('mandatory')
if mibBuilder.loadTexts: eSwitchSecurityAuthStatus.setDescription('This object when set to the value invalid(1) deletes the corresponding authorized address entry, i.e., the address is no longer authorized on the port associated with the entry. When read, this object returns active(2) for any entry that is currently in the authorized address table. It is upto individual implementations to allow or disallow the same address from being authorized on more than one port at the same time.')
eSwitchSecurityLog = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 7, 5, 4))
eSwitchSecurityLogMaxEntries = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 7, 5, 4, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eSwitchSecurityLogMaxEntries.setStatus('mandatory')
if mibBuilder.loadTexts: eSwitchSecurityLogMaxEntries.setDescription('The maximum number of security violation entries that will be retained in the security log table: eSwitchSecurityLogTable. If more security violations than this number occur, then later entries will overwrite earlier entries, the earliest recorded entries being replaced first.')
eSwitchSecurityLogTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 7, 5, 4, 2), )
if mibBuilder.loadTexts: eSwitchSecurityLogTable.setStatus('mandatory')
if mibBuilder.loadTexts: eSwitchSecurityLogTable.setDescription('A table that contains a log of security violations indexed by violating address and violated port.')
eSwitchSecurityLogEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 7, 5, 4, 2, 1), ).setIndexNames((0, "ESWITCH-MIB-V3-0", "eSwitchSecurityLogIndex"))
if mibBuilder.loadTexts: eSwitchSecurityLogEntry.setStatus('mandatory')
if mibBuilder.loadTexts: eSwitchSecurityLogEntry.setDescription('A security log entry that consists of a violating address, the port on which this address was seen, and the sysUpTime at the time the violation was detected.')
eSwitchSecurityLogIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 7, 5, 4, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: eSwitchSecurityLogIndex.setStatus('mandatory')
if mibBuilder.loadTexts: eSwitchSecurityLogIndex.setDescription('The index corresponding to this log entry. The earliest recorded entry has the smallest value. This object ranges in value from 1 to the value of the following object: eSwitchSecurityLogMaxEntries.')
eSwitchSecurityLogPort = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 7, 5, 4, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eSwitchSecurityLogPort.setStatus('mandatory')
if mibBuilder.loadTexts: eSwitchSecurityLogPort.setDescription('The port number of the switch port on which this violation occured.')
eSwitchSecurityLogAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 7, 5, 4, 2, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: eSwitchSecurityLogAddress.setStatus('mandatory')
if mibBuilder.loadTexts: eSwitchSecurityLogAddress.setDescription('The violating address that caused this entry to be logged.')
eSwitchSecurityLogResetNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 7, 5, 4, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: eSwitchSecurityLogResetNumber.setStatus('mandatory')
if mibBuilder.loadTexts: eSwitchSecurityLogResetNumber.setDescription('The value of pcomErrLogResetNumber at the time this entry was logged.')
eSwitchSecurityLogTime = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 7, 5, 4, 2, 1, 5), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eSwitchSecurityLogTime.setStatus('mandatory')
if mibBuilder.loadTexts: eSwitchSecurityLogTime.setDescription('The time in 10 millisecond clock ticks since the switch was last reset, at which the violation recorded by this entry occured.')
mibBuilder.exportSymbols("ESWITCH-MIB-V3-0", eSwitchStorm=eSwitchStorm, eSwitchAddrFdbDynamicEntries=eSwitchAddrFdbDynamicEntries, eSwitchSecurityPortTable=eSwitchSecurityPortTable, eSwitchAddrFdbStaticEntries=eSwitchAddrFdbStaticEntries, eSwitchSecurityPortMaxAutoAuthAddr=eSwitchSecurityPortMaxAutoAuthAddr, eSwitchSecurityLogTable=eSwitchSecurityLogTable, ema=ema, eSwitchSecurityLog=eSwitchSecurityLog, eSwitchStormControlAction=eSwitchStormControlAction, eSwitchSecurityLogEntry=eSwitchSecurityLogEntry, eSwitchStormFramesLost=eSwitchStormFramesLost, eSwitchSecurityViolationsDetected=eSwitchSecurityViolationsDetected, eSwitchAddrFdbNVStaticEntries=eSwitchAddrFdbNVStaticEntries, eSwitchPortEntry=eSwitchPortEntry, eSwitchStormFrameTypeRegulated=eSwitchStormFrameTypeRegulated, eSwitchFdb=eSwitchFdb, eSwitchIfEntry=eSwitchIfEntry, eSwitchStormPortControlStatus=eSwitchStormPortControlStatus, eSwitchSecurity=eSwitchSecurity, eSwitchSecurityLogMaxEntries=eSwitchSecurityLogMaxEntries, eSwitchAddrFdbMaxEntries=eSwitchAddrFdbMaxEntries, eSwitchAddrFdbPurgeStaticEntries=eSwitchAddrFdbPurgeStaticEntries, eSwitchAddrFdbMaxStaticEntries=eSwitchAddrFdbMaxStaticEntries, eSwitchAddrFdb=eSwitchAddrFdb, eSwitchStormPollingInterval=eSwitchStormPollingInterval, decMIBextension=decMIBextension, eSwitchSecurityAuthEntry=eSwitchSecurityAuthEntry, eSwitchIfPresent=eSwitchIfPresent, eSwitch=eSwitch, eSwitchIfTable=eSwitchIfTable, eSwitchPortSwitchingMode=eSwitchPortSwitchingMode, eSwitchSecurityLogPort=eSwitchSecurityLogPort, eSwitchSecurityLogResetNumber=eSwitchSecurityLogResetNumber, eSwitchSecurityPortMaxAuthAddr=eSwitchSecurityPortMaxAuthAddr, eSwitchSecurityAuthTable=eSwitchSecurityAuthTable, eSwitchSecurityLogTime=eSwitchSecurityLogTime, eSwitchSecurityAuthStatus=eSwitchSecurityAuthStatus, eSwitchIf=eSwitchIf, eSwitchStormAutoInterval=eSwitchStormAutoInterval, eSwitchSecurityPortViolationResponse=eSwitchSecurityPortViolationResponse, eSwitchSecurityAuthPort=eSwitchSecurityAuthPort, eSwitchSecurityAuthAddress=eSwitchSecurityAuthAddress, eSwitchStormResumptionPolicy=eSwitchStormResumptionPolicy, eSwitchPortTable=eSwitchPortTable, eSwitchSecurityLogIndex=eSwitchSecurityLogIndex, eSwitchSecurityPortMode=eSwitchSecurityPortMode, eSwitchStormPortEntry=eSwitchStormPortEntry, eSwitchSecurityPortCurrAuthAddr=eSwitchSecurityPortCurrAuthAddr, eSwitchStormPortActionsInitiated=eSwitchStormPortActionsInitiated, eSwitchSecurityPortViolationsDetected=eSwitchSecurityPortViolationsDetected, eSwitchSecurityLogAddress=eSwitchSecurityLogAddress, eSwitchStormPortTable=eSwitchStormPortTable, eSwitchPortFailed=eSwitchPortFailed, eSwitchPort=eSwitchPort, eSwitchPortStatus=eSwitchPortStatus, dec=dec, eSwitchIfIndex=eSwitchIfIndex, eSwitchPortIndex=eSwitchPortIndex, eSwitchPortShutDownReason=eSwitchPortShutDownReason, eSwitchStormRateLimit=eSwitchStormRateLimit, eSwitchStormPortFramesLost=eSwitchStormPortFramesLost, eSwitchStormActionsInitiated=eSwitchStormActionsInitiated, eSwitchSecurityPortPurgeAuthAddr=eSwitchSecurityPortPurgeAuthAddr, eSwitchStormPortIndex=eSwitchStormPortIndex, eSwitchSecurityPortEntry=eSwitchSecurityPortEntry, eSwitchSecurityPortIndex=eSwitchSecurityPortIndex, decHub900=decHub900, eSwitchAddrFdbMaxNVStaticEntries=eSwitchAddrFdbMaxNVStaticEntries)

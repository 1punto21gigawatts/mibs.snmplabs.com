#
# PySNMP MIB module IPSEC-SA-MON-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/IPSEC-SA-MON-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:56:30 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ConstraintsIntersection, SingleValueConstraint, ValueRangeConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ConstraintsIntersection", "SingleValueConstraint", "ValueRangeConstraint", "ConstraintsUnion")
ifIndex, = mibBuilder.importSymbols("IF-MIB", "ifIndex")
IpsecDoiEncapsulationMode, IpsecDoiAuthAlgorithm, IpsecDoiAhTransform, IpsecDoiEspTransform, IpsecDoiIpcompTransform, IpsecDoiSecProtocolId, IpsecDoiIdentType = mibBuilder.importSymbols("IPSEC-ISAKMP-IKE-DOI-TC", "IpsecDoiEncapsulationMode", "IpsecDoiAuthAlgorithm", "IpsecDoiAhTransform", "IpsecDoiEspTransform", "IpsecDoiIpcompTransform", "IpsecDoiSecProtocolId", "IpsecDoiIdentType")
NotificationGroup, ModuleCompliance, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance", "ObjectGroup")
ModuleIdentity, NotificationType, Counter64, Bits, TimeTicks, MibIdentifier, Integer32, ObjectIdentity, experimental, Unsigned32, MibScalar, MibTable, MibTableRow, MibTableColumn, IpAddress, Gauge32, Counter32, iso = mibBuilder.importSymbols("SNMPv2-SMI", "ModuleIdentity", "NotificationType", "Counter64", "Bits", "TimeTicks", "MibIdentifier", "Integer32", "ObjectIdentity", "experimental", "Unsigned32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "IpAddress", "Gauge32", "Counter32", "iso")
DisplayString, TextualConvention, TruthValue = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention", "TruthValue")
ipsecSaMonModule = ModuleIdentity((1, 3, 6, 1, 3, 98))
ipsecSaMonModule.setRevisions(('1999-06-03 12:00', '1999-06-25 12:00', '1999-10-21 12:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ipsecSaMonModule.setRevisionsDescriptions(('Initial revision.', 'Add module compliance requirements. Added common textual conventions. Other minor edits and clarifications.', 'Group and compliance statements added. OID value under experimental tree added. Authentication algorithm key length values added.',))
if mibBuilder.loadTexts: ipsecSaMonModule.setLastUpdated('9910211200Z')
if mibBuilder.loadTexts: ipsecSaMonModule.setOrganization('IETF IPsec Working Group')
if mibBuilder.loadTexts: ipsecSaMonModule.setContactInfo(' Tim Jenkins TimeStep Corporation 362 Terry Fox Drive Kanata, ON K0A 2H0 Canada +1 (613) 599-3610 tjenkins@timestep.com John Shriver Intel Corporation 28 Crosby Drive Bedford, MA 01730 +1 (781) 687-1329 John.Shriver@intel.com ')
if mibBuilder.loadTexts: ipsecSaMonModule.setDescription('The MIB module to describe generic IPsec objects, and entity level objects and events for those types.')
class IpsecSaCreatorIdent(TextualConvention, Integer32):
    description = 'A value indicating how an SA was created.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))
    namedValues = NamedValues(("unknown", 0), ("static", 1), ("ike", 2), ("other", 3))

class IpsecIpv6Address(TextualConvention, OctetString):
    reference = 'RFC 2373 sections 2.2 and 2.5.4'
    description = "This data type is used to model IPv6 addresses. This is a binary string of 16 octets in network byte-order. For implementations that do not support IPv6, this address should appear as the 'IPv4-mapped IPv6 address' as defined in Section 2.5.4 of [IPV6AA]. Specifically, the prefix '0000:0000:0000:0000:0000:FFFF::/96' is used for IPv4 addresses."
    status = 'current'
    displayHint = '2x:2x:2x:2x:2x:2x:1d.1d.1d.1d'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(16, 16)
    fixedLength = 16

class IpsecRawId(TextualConvention, OctetString):
    description = 'This data type is used to model the ID values used by entities that have negotiated and created SAs. The values are taken directly from any payloads exchanged, independent of the type of ID transmitted. In some cases, the payload may be truncated. Note also that some IDs have human readable forms that are not used by this textual convention.'
    status = 'current'
    displayHint = 'x'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 255)

ipsecSaMonitorMIB = ObjectIdentity((1, 3, 6, 1, 3, 98, 1))
if mibBuilder.loadTexts: ipsecSaMonitorMIB.setStatus('current')
if mibBuilder.loadTexts: ipsecSaMonitorMIB.setDescription('This is the base object identifier for all IPsec branches.')
saTables = ObjectIdentity((1, 3, 6, 1, 3, 98, 1, 1))
if mibBuilder.loadTexts: saTables.setStatus('current')
if mibBuilder.loadTexts: saTables.setDescription('This is the base object identifier for all SA tables.')
saStatistics = ObjectIdentity((1, 3, 6, 1, 3, 98, 1, 2))
if mibBuilder.loadTexts: saStatistics.setStatus('current')
if mibBuilder.loadTexts: saStatistics.setDescription('This is the base object identifier for all objects which are global counters for IPsec security associations.')
saErrors = ObjectIdentity((1, 3, 6, 1, 3, 98, 1, 3))
if mibBuilder.loadTexts: saErrors.setStatus('current')
if mibBuilder.loadTexts: saErrors.setDescription('This is the base object identifier for all objects which are global error counters for IPsec security associations.')
saTraps = ObjectIdentity((1, 3, 6, 1, 3, 98, 1, 4))
if mibBuilder.loadTexts: saTraps.setStatus('current')
if mibBuilder.loadTexts: saTraps.setDescription('This is the base object identifier for all objects which are traps for IPsec security associations.')
saTrapObjects = ObjectIdentity((1, 3, 6, 1, 3, 98, 1, 5))
if mibBuilder.loadTexts: saTrapObjects.setStatus('current')
if mibBuilder.loadTexts: saTrapObjects.setDescription('This is the base object identifier for objects which are used as part of traps.')
saTrapControl = ObjectIdentity((1, 3, 6, 1, 3, 98, 1, 6))
if mibBuilder.loadTexts: saTrapControl.setStatus('current')
if mibBuilder.loadTexts: saTrapControl.setDescription('This is the base object identifier for all objects which are trap controls for IPsec security associations.')
saGroups = ObjectIdentity((1, 3, 6, 1, 3, 98, 1, 7))
if mibBuilder.loadTexts: saGroups.setStatus('current')
if mibBuilder.loadTexts: saGroups.setDescription('This is the base object identifier for all objects which describe the groups in this MIB.')
saConformance = ObjectIdentity((1, 3, 6, 1, 3, 98, 1, 8))
if mibBuilder.loadTexts: saConformance.setStatus('current')
if mibBuilder.loadTexts: saConformance.setDescription('This is the base object identifier for all objects which describe the conformance for this MIB.')
ipsecSaEspInTable = MibTable((1, 3, 6, 1, 3, 98, 1, 1, 1), )
if mibBuilder.loadTexts: ipsecSaEspInTable.setStatus('current')
if mibBuilder.loadTexts: ipsecSaEspInTable.setDescription('The (conceptual) table containing information on IPsec inbound ESP SAs. There should be one row for every inbound ESP security association that exists in the entity. The maximum number of rows is implementation dependent.')
ipsecSaEspInEntry = MibTableRow((1, 3, 6, 1, 3, 98, 1, 1, 1, 1), ).setIndexNames((0, "IPSEC-SA-MON-MIB", "ipsecSaEspInAddress"), (0, "IPSEC-SA-MON-MIB", "ipsecSaEspInSpi"))
if mibBuilder.loadTexts: ipsecSaEspInEntry.setStatus('current')
if mibBuilder.loadTexts: ipsecSaEspInEntry.setDescription('An entry (conceptual row) containing the information on a particular IPsec inbound ESP SA. A row in this table cannot be created or deleted by SNMP operations on columns of the table.')
ipsecSaEspInAddress = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 1, 1, 1), IpsecIpv6Address()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaEspInAddress.setStatus('current')
if mibBuilder.loadTexts: ipsecSaEspInAddress.setDescription("The destination address of the SA. IPv4 entities will prefix the IP address with '0000:0000:0000:0000:0000:FFFF::'.")
ipsecSaEspInSpi = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 1, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaEspInSpi.setReference('RFC 2406 Section 2.1')
if mibBuilder.loadTexts: ipsecSaEspInSpi.setStatus('current')
if mibBuilder.loadTexts: ipsecSaEspInSpi.setDescription('The security parameters index of the SA.')
ipsecSaEspInDestId = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 1, 1, 3), IpsecRawId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaEspInDestId.setStatus('current')
if mibBuilder.loadTexts: ipsecSaEspInDestId.setDescription('The destination identifier of the SA. It may be 0 if unknown or if the SA uses transport mode encapsulation. This value is taken directly from the optional ID payloads that are exchanged during SA creation negotiation.')
ipsecSaEspInDestIdType = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 1, 1, 4), IpsecDoiIdentType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaEspInDestIdType.setStatus('current')
if mibBuilder.loadTexts: ipsecSaEspInDestIdType.setDescription("The type of identifier presented by 'ipsecSaEspInDestId'. It may be 0 if unknown or if the SA uses transport mode encapsulation.")
ipsecSaEspInSourceId = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 1, 1, 5), IpsecRawId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaEspInSourceId.setStatus('current')
if mibBuilder.loadTexts: ipsecSaEspInSourceId.setDescription('The source identifier of the SA. It may be 0 if unknown or if the SA uses transport mode encapsulation. This value is taken directly from the optional ID payloads that are exchanged during SA creation negotiation.')
ipsecSaEspInSourceIdType = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 1, 1, 6), IpsecDoiIdentType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaEspInSourceIdType.setStatus('current')
if mibBuilder.loadTexts: ipsecSaEspInSourceIdType.setDescription("The type of identifier presented by 'ipsecSaEspInSourceId'. It may be 0 if unknown or if the SA uses transport mode encapsulation.")
ipsecSaEspInProtocol = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaEspInProtocol.setReference('RFC 2401 section 4.4.2')
if mibBuilder.loadTexts: ipsecSaEspInProtocol.setStatus('current')
if mibBuilder.loadTexts: ipsecSaEspInProtocol.setDescription('The transport-layer protocol number that this SA carries, or 0 if it carries any protocol.')
ipsecSaEspInDestPort = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaEspInDestPort.setReference('RFC 2401 section 4.4.2')
if mibBuilder.loadTexts: ipsecSaEspInDestPort.setStatus('current')
if mibBuilder.loadTexts: ipsecSaEspInDestPort.setDescription('The destination port number of the protocol that this SA carries, or 0 if it carries any port number.')
ipsecSaEspInSourcePort = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaEspInSourcePort.setReference('RFC 2401 section 4.4.2')
if mibBuilder.loadTexts: ipsecSaEspInSourcePort.setStatus('current')
if mibBuilder.loadTexts: ipsecSaEspInSourcePort.setDescription('The source port number of the protocol that this SA carries, or 0 if it carries any port number.')
ipsecSaEspInCreator = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 1, 1, 10), IpsecSaCreatorIdent()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaEspInCreator.setStatus('current')
if mibBuilder.loadTexts: ipsecSaEspInCreator.setDescription('The creator of this SA. This MIB makes no assumptions about how the SAs are created. They may be created statically, or by a key exchange protocol such as IKE, or by some other method.')
ipsecSaEspInEncapsulation = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 1, 1, 11), IpsecDoiEncapsulationMode()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaEspInEncapsulation.setStatus('current')
if mibBuilder.loadTexts: ipsecSaEspInEncapsulation.setDescription('The type of encapsulation used by this SA.')
ipsecSaEspInEncAlg = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 1, 1, 12), IpsecDoiEspTransform()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaEspInEncAlg.setStatus('current')
if mibBuilder.loadTexts: ipsecSaEspInEncAlg.setDescription('A unique value representing the encryption algorithm applied to traffic or 0 if there is no encryption used.')
ipsecSaEspInEncKeyLength = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 1, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65531))).setUnits('bits').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaEspInEncKeyLength.setStatus('current')
if mibBuilder.loadTexts: ipsecSaEspInEncKeyLength.setDescription("The length of the encryption key in bits used for the algorithm specified in the 'ipsecSaEspInEncAlg' object. It may be 0 if the key length is implicit in the specified algorithm or there is no encryption specified.")
ipsecSaEspInAuthAlg = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 1, 1, 14), IpsecDoiAuthAlgorithm()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaEspInAuthAlg.setStatus('current')
if mibBuilder.loadTexts: ipsecSaEspInAuthAlg.setDescription('A unique value representing the hash algorithm applied to traffic or 0 if there is no authentication used.')
ipsecSaEspInAuthKeyLength = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 1, 1, 15), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65531))).setUnits('bits').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaEspInAuthKeyLength.setStatus('current')
if mibBuilder.loadTexts: ipsecSaEspInAuthKeyLength.setDescription("The length of the authentication key in bits used for the algorithm specified in the 'ipsecSaEspInAuthAlg'. It may be 0 if the key length is implicit in the specified algorithm or there is no authentication specified.")
ipsecSaEspInRepWinSize = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 1, 1, 16), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaEspInRepWinSize.setReference('Section 3.4.3 of RFC 2406')
if mibBuilder.loadTexts: ipsecSaEspInRepWinSize.setStatus('current')
if mibBuilder.loadTexts: ipsecSaEspInRepWinSize.setDescription('The size of the anti-replay window used by this SA, or 0 if anti-replay checking is not being done.')
ipsecSaEspInLimitSeconds = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 1, 1, 17), Unsigned32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaEspInLimitSeconds.setStatus('current')
if mibBuilder.loadTexts: ipsecSaEspInLimitSeconds.setDescription('The maximum lifetime in seconds of the SA, or 0 if there is no time constraint on its expiration. The display value is limited to 4294967295 seconds (more than 136 years); values greater than that value will be truncated.')
ipsecSaEspInLimitKbytes = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 1, 1, 18), Unsigned32()).setUnits('kilobytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaEspInLimitKbytes.setStatus('current')
if mibBuilder.loadTexts: ipsecSaEspInLimitKbytes.setDescription('The maximum traffic in kilobytes that the SA is allowed to process, or 0 if there is no traffic constraint on its expiration. The display value is limited to 4294967295 kilobytes; values greater than that value will be truncated.')
ipsecSaEspInAccSeconds = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 1, 1, 19), Counter32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaEspInAccSeconds.setStatus('current')
if mibBuilder.loadTexts: ipsecSaEspInAccSeconds.setDescription("The number of seconds accumulated against the SA's expiration by time. This is also the number of seconds that the SA has existed.")
ipsecSaEspInAccKbytes = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 1, 1, 20), Counter32()).setUnits('kilobytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaEspInAccKbytes.setStatus('current')
if mibBuilder.loadTexts: ipsecSaEspInAccKbytes.setDescription("The amount of traffic accumulated that counts against the SA's expiration by traffic limitation, measured in kilobytes. This value may be 0 if the SA does not expire based on traffic.")
ipsecSaEspInUserOctets = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 1, 1, 21), Counter64()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaEspInUserOctets.setStatus('current')
if mibBuilder.loadTexts: ipsecSaEspInUserOctets.setDescription('The amount of user level traffic measured in bytes handled by the SA. This is the number of bytes of the decrypted IP packet, including the original IP header of that decrypted packet. This is not necessarily the same as the amount of traffic applied against the traffic expiration limit due to padding or other protocol specific overhead.')
ipsecSaEspInPackets = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 1, 1, 22), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaEspInPackets.setStatus('current')
if mibBuilder.loadTexts: ipsecSaEspInPackets.setDescription('The number of packets handled by the SA.')
ipsecSaEspInDecryptErrors = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 1, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaEspInDecryptErrors.setStatus('current')
if mibBuilder.loadTexts: ipsecSaEspInDecryptErrors.setDescription('The number of packets discarded by the SA due to detectable decryption errors. Not all decryption errors are detectable within SA processing, so this count should not be considered definitive.')
ipsecSaEspInAuthErrors = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 1, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaEspInAuthErrors.setStatus('current')
if mibBuilder.loadTexts: ipsecSaEspInAuthErrors.setDescription('The number of packets discarded by the SA due to authentication errors.')
ipsecSaEspInReplayErrors = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 1, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaEspInReplayErrors.setStatus('current')
if mibBuilder.loadTexts: ipsecSaEspInReplayErrors.setDescription('The number of packets discarded by the SA due to replay errors.')
ipsecSaEspInPolicyErrors = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 1, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaEspInPolicyErrors.setStatus('current')
if mibBuilder.loadTexts: ipsecSaEspInPolicyErrors.setDescription('The number of packets discarded by the SA due to policy errors. This includes packets where the next protocol is invalid.')
ipsecSaEspInPadErrors = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 1, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaEspInPadErrors.setReference('RFC 2406 section 2.4')
if mibBuilder.loadTexts: ipsecSaEspInPadErrors.setStatus('current')
if mibBuilder.loadTexts: ipsecSaEspInPadErrors.setDescription('The number of packets discarded by the SA due to pad value errors. Implementations that do not check this must not support this object.')
ipsecSaEspInOtherReceiveErrors = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 1, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaEspInOtherReceiveErrors.setStatus('current')
if mibBuilder.loadTexts: ipsecSaEspInOtherReceiveErrors.setDescription('The number of packets discarded by the SA due to errors other than decryption, authentication, replay errors or, when supported, invalid padding errors. This may include packets dropped due to a lack of receive buffers, and may include packets dropped due to congestion at the decryption element.')
ipsecSaAhInTable = MibTable((1, 3, 6, 1, 3, 98, 1, 1, 2), )
if mibBuilder.loadTexts: ipsecSaAhInTable.setStatus('current')
if mibBuilder.loadTexts: ipsecSaAhInTable.setDescription('The (conceptual) table containing information on IPsec inbound AH SAs. There should be one row for every inbound AH security association that exists in the entity. The maximum number of rows is implementation dependent.')
ipsecSaAhInEntry = MibTableRow((1, 3, 6, 1, 3, 98, 1, 1, 2, 1), ).setIndexNames((0, "IPSEC-SA-MON-MIB", "ipsecSaAhInAddress"), (0, "IPSEC-SA-MON-MIB", "ipsecSaAhInSpi"))
if mibBuilder.loadTexts: ipsecSaAhInEntry.setStatus('current')
if mibBuilder.loadTexts: ipsecSaAhInEntry.setDescription('An entry (conceptual row) containing the information on a particular IPsec inbound AH SA. A row in this table cannot be created or deleted by SNMP operations on columns of the table.')
ipsecSaAhInAddress = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 2, 1, 1), IpsecIpv6Address()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaAhInAddress.setStatus('current')
if mibBuilder.loadTexts: ipsecSaAhInAddress.setDescription("The destination address of the SA. IPv4 entities will prefix the IP address with '0000:0000:0000:0000:0000:FFFF::'.")
ipsecSaAhInSpi = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 2, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaAhInSpi.setReference('RFC 2402 Section 2.4')
if mibBuilder.loadTexts: ipsecSaAhInSpi.setStatus('current')
if mibBuilder.loadTexts: ipsecSaAhInSpi.setDescription('The security parameters index of the SA.')
ipsecSaAhInDestId = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 2, 1, 3), IpsecRawId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaAhInDestId.setStatus('current')
if mibBuilder.loadTexts: ipsecSaAhInDestId.setDescription('The destination identifier of the SA. It may be 0 if unknown or if the SA uses transport mode encapsulation. This value is taken directly from the optional ID payloads that are exchanged during SA creation negotiation, or the equivalent process.')
ipsecSaAhInDestIdType = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 2, 1, 4), IpsecDoiIdentType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaAhInDestIdType.setStatus('current')
if mibBuilder.loadTexts: ipsecSaAhInDestIdType.setDescription("The type of identifier presented by 'ipsecSaAhInDestId'. It may be 0 if unknown or if the SA uses transport mode encapsulation.")
ipsecSaAhInSourceId = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 2, 1, 5), IpsecRawId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaAhInSourceId.setStatus('current')
if mibBuilder.loadTexts: ipsecSaAhInSourceId.setDescription('The source identifier of the SA. It may be 0 if unknown or if the SA uses transport mode encapsulation. This value is taken directly from the optional ID payloads that are exchanged during SA creation negotiation or the equivelant process.')
ipsecSaAhInSourceIdType = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 2, 1, 6), IpsecDoiIdentType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaAhInSourceIdType.setStatus('current')
if mibBuilder.loadTexts: ipsecSaAhInSourceIdType.setDescription("The type of identifier presented by 'ipsecSaAhInSourceId'. It may be 0 if unknown or if the SA uses transport mode encapsulation.")
ipsecSaAhInProtocol = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaAhInProtocol.setReference('RFC 2401 section 4.4.2')
if mibBuilder.loadTexts: ipsecSaAhInProtocol.setStatus('current')
if mibBuilder.loadTexts: ipsecSaAhInProtocol.setDescription('The transport-layer protocol number that this SA carries, or 0 if it carries any protocol.')
ipsecSaAhInDestPort = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaAhInDestPort.setReference('RFC 2401 section 4.4.2')
if mibBuilder.loadTexts: ipsecSaAhInDestPort.setStatus('current')
if mibBuilder.loadTexts: ipsecSaAhInDestPort.setDescription('The destination port number of the protocol that this SA carries, or 0 if it carries any port number.')
ipsecSaAhInSourcePort = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaAhInSourcePort.setReference('RFC 2401 section 4.4.2')
if mibBuilder.loadTexts: ipsecSaAhInSourcePort.setStatus('current')
if mibBuilder.loadTexts: ipsecSaAhInSourcePort.setDescription('The source port number of the protocol that this SA carries, or 0 if it carries any port number.')
ipsecSaAhInCreator = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 2, 1, 10), IpsecSaCreatorIdent()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaAhInCreator.setStatus('current')
if mibBuilder.loadTexts: ipsecSaAhInCreator.setDescription('The creator of this SA. This MIB makes no assumptions about how the SAs are created. They may be created statically, or by a key exchange protocol such as IKE, or by some other method.')
ipsecSaAhInEncapsulation = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 2, 1, 11), IpsecDoiEncapsulationMode()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaAhInEncapsulation.setStatus('current')
if mibBuilder.loadTexts: ipsecSaAhInEncapsulation.setDescription('The type of encapsulation used by this SA.')
ipsecSaAhInAuthAlg = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 2, 1, 12), IpsecDoiAhTransform()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaAhInAuthAlg.setStatus('current')
if mibBuilder.loadTexts: ipsecSaAhInAuthAlg.setDescription('A unique value representing the hash algorithm applied to traffic carried by this SA.')
ipsecSaAhInAuthKeyLength = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 2, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65531))).setUnits('bits').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaAhInAuthKeyLength.setStatus('current')
if mibBuilder.loadTexts: ipsecSaAhInAuthKeyLength.setDescription("The length of the authentication key in bits used for the algorithm specified in the 'ipsecSaAhInAuthAlg' object. It may be 0 if the key length is implicit in the specified algorithm.")
ipsecSaAhInRepWinSize = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 2, 1, 14), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaAhInRepWinSize.setReference('Section 3.4.3 of RFC 2402')
if mibBuilder.loadTexts: ipsecSaAhInRepWinSize.setStatus('current')
if mibBuilder.loadTexts: ipsecSaAhInRepWinSize.setDescription('The size of the anti-replay window used by this SA, or 0 if anti-replay checking is not being done.')
ipsecSaAhInLimitSeconds = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 2, 1, 15), Unsigned32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaAhInLimitSeconds.setStatus('current')
if mibBuilder.loadTexts: ipsecSaAhInLimitSeconds.setDescription('The maximum lifetime in seconds of the SA, or 0 if there is no time constraint on its expiration. The display value is limited to 4294967295 seconds (more than 136 years); values greater than that value will be truncated.')
ipsecSaAhInLimitKbytes = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 2, 1, 16), Unsigned32()).setUnits('kilobytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaAhInLimitKbytes.setStatus('current')
if mibBuilder.loadTexts: ipsecSaAhInLimitKbytes.setDescription('The maximum traffic in bytes that the SA is allowed to process, or 0 if there is no traffic constraint on its expiration. The display value is limited to 4294967295 kilobytes; values greater than that value will be truncated.')
ipsecSaAhInAccSeconds = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 2, 1, 17), Counter32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaAhInAccSeconds.setStatus('current')
if mibBuilder.loadTexts: ipsecSaAhInAccSeconds.setDescription("The number of seconds accumulated against the SA's expiration by time. This is also the number of seconds that the SA has existed.")
ipsecSaAhInAccKbytes = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 2, 1, 18), Counter32()).setUnits('kilobytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaAhInAccKbytes.setStatus('current')
if mibBuilder.loadTexts: ipsecSaAhInAccKbytes.setDescription("The amount of traffic accumulated that counts against the SA's expiration by traffic limitation, measured in kilobytes. This value may be 0 if the SA does not expire based on traffic.")
ipsecSaAhInUserOctets = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 2, 1, 19), Counter64()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaAhInUserOctets.setStatus('current')
if mibBuilder.loadTexts: ipsecSaAhInUserOctets.setDescription('The amount of user level traffic measured in bytes handled by the SA. This is the number of bytes of the de-processed IP packet, including the original IP header of that de- processed packet. This is not necessarily the same as the amount of traffic applied against the traffic expiration limit due to padding or other protocol specific overhead.')
ipsecSaAhInPackets = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 2, 1, 20), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaAhInPackets.setStatus('current')
if mibBuilder.loadTexts: ipsecSaAhInPackets.setDescription('The number of packets handled by the SA.')
ipsecSaAhInAuthErrors = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 2, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaAhInAuthErrors.setStatus('current')
if mibBuilder.loadTexts: ipsecSaAhInAuthErrors.setDescription('The number of packets discarded by the SA due to authentication errors.')
ipsecSaAhInReplayErrors = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 2, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaAhInReplayErrors.setStatus('current')
if mibBuilder.loadTexts: ipsecSaAhInReplayErrors.setDescription('The number of packets discarded by the SA due to replay errors.')
ipsecSaAhInPolicyErrors = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 2, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaAhInPolicyErrors.setStatus('current')
if mibBuilder.loadTexts: ipsecSaAhInPolicyErrors.setDescription('The number of packets discarded by the SA due to policy errors. This includes packets where the next protocol is invalid.')
ipsecSaAhInOtherReceiveErrors = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 2, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaAhInOtherReceiveErrors.setStatus('current')
if mibBuilder.loadTexts: ipsecSaAhInOtherReceiveErrors.setDescription('The number of packets discarded by the SA due to errors other than decryption, authentication or replay errors. This may include packets dropped due to a lack of receive buffers, and may include packets dropped due to congestion at the authentication element.')
ipsecSaIpcompInTable = MibTable((1, 3, 6, 1, 3, 98, 1, 1, 3), )
if mibBuilder.loadTexts: ipsecSaIpcompInTable.setStatus('current')
if mibBuilder.loadTexts: ipsecSaIpcompInTable.setDescription('The (conceptual) table containing information on IPsec inbound IPcomp SAs. There should be one row for every inbound IPcomp (security) association that exists in the entity. The maximum number of rows is implementation dependent.')
ipsecSaIpcompInEntry = MibTableRow((1, 3, 6, 1, 3, 98, 1, 1, 3, 1), ).setIndexNames((0, "IPSEC-SA-MON-MIB", "ipsecSaIpcompInAddress"), (0, "IPSEC-SA-MON-MIB", "ipsecSaIpcompInCpi"))
if mibBuilder.loadTexts: ipsecSaIpcompInEntry.setStatus('current')
if mibBuilder.loadTexts: ipsecSaIpcompInEntry.setDescription('An entry (conceptual row) containing the information on a particular IPsec inbound IPcomp SA. A row in this table cannot be created or deleted by SNMP operations on columns of the table.')
ipsecSaIpcompInAddress = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 3, 1, 1), IpsecIpv6Address()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaIpcompInAddress.setStatus('current')
if mibBuilder.loadTexts: ipsecSaIpcompInAddress.setDescription("The destination address of the SA. IPv4 entities will prefix the IP address with '0000:0000:0000:0000:0000:FFFF::'.")
ipsecSaIpcompInCpi = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 3, 1, 2), IpsecDoiIpcompTransform()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaIpcompInCpi.setReference('RFC 2393 Section 3.3')
if mibBuilder.loadTexts: ipsecSaIpcompInCpi.setStatus('current')
if mibBuilder.loadTexts: ipsecSaIpcompInCpi.setDescription('The CPI of the SA. Since the lower values of CPIs are reserved to be the same as the algorithm, the syntax for this object is the same as the transform.')
ipsecSaIpcompInDestId = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 3, 1, 3), IpsecRawId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaIpcompInDestId.setStatus('current')
if mibBuilder.loadTexts: ipsecSaIpcompInDestId.setDescription('The destination identifier of the SA. It may be 0 if unknown or if the SA uses transport mode, or 0 if this SA is used with multiple SAs in security association suites. This value, if non-zero, is taken directly from the optional ID payloads that are exchanged during SA creation negotiation, or the equivalent process.')
ipsecSaIpcompInDestIdType = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 3, 1, 4), IpsecDoiIdentType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaIpcompInDestIdType.setStatus('current')
if mibBuilder.loadTexts: ipsecSaIpcompInDestIdType.setDescription("The type of identifier presented by 'ipsecSaIpcompInDestId'. It may be 0 if unknown or if the SA uses transport mode, or if this SA is used with multiple SAs in security association suites.")
ipsecSaIpcompInSourceId = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 3, 1, 5), IpsecRawId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaIpcompInSourceId.setStatus('current')
if mibBuilder.loadTexts: ipsecSaIpcompInSourceId.setDescription('The source identifier of the SA. It may be 0 if unknown or if the SA uses transport mode encapsulation, or 0 if this SA is used with multiple SAs in security association suites. This value, if non-zero, is taken directly from the optional ID payloads that are exchanged during SA creation negotiation, or the equivalent process.')
ipsecSaIpcompInSourceIdType = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 3, 1, 6), IpsecDoiIdentType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaIpcompInSourceIdType.setStatus('current')
if mibBuilder.loadTexts: ipsecSaIpcompInSourceIdType.setDescription("The type of identifier presented by 'ipsecSaIpcompInSourceId'. It may be 0 if unknown or if the SA uses transport mode encapsulation, or if this SA is used with multiple SAs in security association suites.")
ipsecSaIpcompInProtocol = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 3, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaIpcompInProtocol.setReference('RFC 2401 section 4.4.2')
if mibBuilder.loadTexts: ipsecSaIpcompInProtocol.setStatus('current')
if mibBuilder.loadTexts: ipsecSaIpcompInProtocol.setDescription('The transport-layer protocol number that this SA carries, or 0 if it carries any protocol.')
ipsecSaIpcompInDestPort = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 3, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaIpcompInDestPort.setReference('RFC 2401 section 4.4.2')
if mibBuilder.loadTexts: ipsecSaIpcompInDestPort.setStatus('current')
if mibBuilder.loadTexts: ipsecSaIpcompInDestPort.setDescription('The destination port number of the protocol that this SA carries, or 0 if it carries any port number.')
ipsecSaIpcompInSourcePort = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 3, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaIpcompInSourcePort.setReference('RFC 2401 section 4.4.2')
if mibBuilder.loadTexts: ipsecSaIpcompInSourcePort.setStatus('current')
if mibBuilder.loadTexts: ipsecSaIpcompInSourcePort.setDescription('The source port number of the protocol that this SA carries, or 0 if it carries any port number.')
ipsecSaIpcompInCreator = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 3, 1, 10), IpsecSaCreatorIdent()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaIpcompInCreator.setStatus('current')
if mibBuilder.loadTexts: ipsecSaIpcompInCreator.setDescription('The creator of this SA. This MIB makes no assumptions about how the SAs are created. They may be created statically, or by a key exchange protocol such as IKE, or by some other method.')
ipsecSaIpcompInEncapsulation = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 3, 1, 11), IpsecDoiEncapsulationMode()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaIpcompInEncapsulation.setStatus('current')
if mibBuilder.loadTexts: ipsecSaIpcompInEncapsulation.setDescription('The type of encapsulation used by this SA.')
ipsecSaIpcompInDecompAlg = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 3, 1, 12), IpsecDoiIpcompTransform()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaIpcompInDecompAlg.setStatus('current')
if mibBuilder.loadTexts: ipsecSaIpcompInDecompAlg.setDescription('A unique value representing the decompression algorithm applied to traffic.')
ipsecSaIpcompInSeconds = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 3, 1, 13), Counter32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaIpcompInSeconds.setStatus('current')
if mibBuilder.loadTexts: ipsecSaIpcompInSeconds.setDescription('The number of seconds that the SA has existed.')
ipsecSaIpcompInUserOctets = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 3, 1, 14), Counter64()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaIpcompInUserOctets.setStatus('current')
if mibBuilder.loadTexts: ipsecSaIpcompInUserOctets.setDescription('The amount of user level traffic measured in bytes handled by the SA. This is the number of bytes of the uncompressed IP packet, including the original IP header of that uncompressed packet. Packets which are not decompressed by the SA are not counted in this total.')
ipsecSaIpcompInPackets = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 3, 1, 15), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaIpcompInPackets.setStatus('current')
if mibBuilder.loadTexts: ipsecSaIpcompInPackets.setDescription('The number of packets handled by the SA.')
ipsecSaIpcompInDecompErrors = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 3, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaIpcompInDecompErrors.setStatus('current')
if mibBuilder.loadTexts: ipsecSaIpcompInDecompErrors.setDescription('The number of packets discarded by the SA due to decompression errors.')
ipsecSaIpcompInOtherReceiveErrors = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 3, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaIpcompInOtherReceiveErrors.setStatus('current')
if mibBuilder.loadTexts: ipsecSaIpcompInOtherReceiveErrors.setDescription('The number of packets discarded by the SA due to errors other than decompression errors. This may include packets dropped due to a lack of receive buffers, and packets dropped due to congestion at the decompression element.')
ipsecSaEspOutTable = MibTable((1, 3, 6, 1, 3, 98, 1, 1, 4), )
if mibBuilder.loadTexts: ipsecSaEspOutTable.setStatus('current')
if mibBuilder.loadTexts: ipsecSaEspOutTable.setDescription('The (conceptual) table containing information on IPsec Outbound ESP SAs. There should be one row for every outbound ESP security association that exists in the entity. The maximum number of rows is implementation dependent.')
ipsecSaEspOutEntry = MibTableRow((1, 3, 6, 1, 3, 98, 1, 1, 4, 1), ).setIndexNames((0, "IPSEC-SA-MON-MIB", "ipsecSaEspOutAddress"), (0, "IPSEC-SA-MON-MIB", "ipsecSaEspOutSpi"))
if mibBuilder.loadTexts: ipsecSaEspOutEntry.setStatus('current')
if mibBuilder.loadTexts: ipsecSaEspOutEntry.setDescription('An entry (conceptual row) containing the information on a particular IPsec Outbound ESP SA. A row in this table cannot be created or deleted by SNMP operations on columns of the table.')
ipsecSaEspOutAddress = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 4, 1, 1), IpsecIpv6Address()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaEspOutAddress.setStatus('current')
if mibBuilder.loadTexts: ipsecSaEspOutAddress.setDescription("The destination address of the SA. IPv4 entities will prefix the IP address with '0000:0000:0000:0000:0000:FFFF::'.")
ipsecSaEspOutSpi = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 4, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaEspOutSpi.setReference('RFC 2406 Section 2.1')
if mibBuilder.loadTexts: ipsecSaEspOutSpi.setStatus('current')
if mibBuilder.loadTexts: ipsecSaEspOutSpi.setDescription('The security parameters index of the SA.')
ipsecSaEspOutSourceId = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 4, 1, 3), IpsecRawId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaEspOutSourceId.setStatus('current')
if mibBuilder.loadTexts: ipsecSaEspOutSourceId.setDescription('The source identifier of the SA. It may be 0 if unknown or if the SA uses transport mode encapsulation. This value is taken directly from the optional ID payloads that are exchanged during phase 2 negotiations, or the equivalent process.')
ipsecSaEspOutSourceIdType = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 4, 1, 4), IpsecDoiIdentType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaEspOutSourceIdType.setStatus('current')
if mibBuilder.loadTexts: ipsecSaEspOutSourceIdType.setDescription("The type of identifier presented by 'ipsecSaEspOutSourceId'. It may be 0 if unknown or if the SA uses transport mode encapsulation.")
ipsecSaEspOutDestId = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 4, 1, 5), IpsecRawId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaEspOutDestId.setStatus('current')
if mibBuilder.loadTexts: ipsecSaEspOutDestId.setDescription('The destination identifier of the SA. It may be 0 if unknown or if the SA uses transport mode encapsulation. This value is taken directly from the optional ID payloads that are exchanged during phase 2 negotiations or the equivalent process.')
ipsecSaEspOutDestIdType = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 4, 1, 6), IpsecDoiIdentType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaEspOutDestIdType.setStatus('current')
if mibBuilder.loadTexts: ipsecSaEspOutDestIdType.setDescription("The type of identifier presented by 'ipsecSaEspOutDestId'. It may be 0 if unknown or if the SA uses transport mode encapsulation.")
ipsecSaEspOutProtocol = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 4, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaEspOutProtocol.setReference('RFC 2401 section 4.4.2')
if mibBuilder.loadTexts: ipsecSaEspOutProtocol.setStatus('current')
if mibBuilder.loadTexts: ipsecSaEspOutProtocol.setDescription('The transport-layer protocol number that this SA carries, or 0 if it carries any protocol.')
ipsecSaEspOutSourcePort = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 4, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaEspOutSourcePort.setReference('RFC 2401 section 4.4.2')
if mibBuilder.loadTexts: ipsecSaEspOutSourcePort.setStatus('current')
if mibBuilder.loadTexts: ipsecSaEspOutSourcePort.setDescription('The source port number of the protocol that this SA carries, or 0 if it carries any port number.')
ipsecSaEspOutDestPort = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 4, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaEspOutDestPort.setReference('RFC 2401 section 4.4.2')
if mibBuilder.loadTexts: ipsecSaEspOutDestPort.setStatus('current')
if mibBuilder.loadTexts: ipsecSaEspOutDestPort.setDescription('The destination port number of the protocol that this SA carries, or 0 if it carries any port number.')
ipsecSaEspOutCreator = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 4, 1, 10), IpsecSaCreatorIdent()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaEspOutCreator.setStatus('current')
if mibBuilder.loadTexts: ipsecSaEspOutCreator.setDescription('The creator of this SA. This MIB makes no assumptions about how the SAs are created. They may be created statically, or by a key exchange protocol such as IKE, or by some other method.')
ipsecSaEspOutEncapsulation = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 4, 1, 11), IpsecDoiEncapsulationMode()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaEspOutEncapsulation.setStatus('current')
if mibBuilder.loadTexts: ipsecSaEspOutEncapsulation.setDescription('The type of encapsulation used by this SA.')
ipsecSaEspOutEncAlg = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 4, 1, 12), IpsecDoiEspTransform()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaEspOutEncAlg.setStatus('current')
if mibBuilder.loadTexts: ipsecSaEspOutEncAlg.setDescription('A unique value representing the encryption algorithm applied to traffic or 0 if there is no encryption used.')
ipsecSaEspOutEncKeyLength = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 4, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65531))).setUnits('bits').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaEspOutEncKeyLength.setStatus('current')
if mibBuilder.loadTexts: ipsecSaEspOutEncKeyLength.setDescription("The length of the encryption key in bits used for the algorithm specified in the 'ipsecSaEspOutEncAlg' object. It may be 0 if the key length is implicit in the specified algorithm or there is no encryption specified.")
ipsecSaEspOutAuthAlg = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 4, 1, 14), IpsecDoiAuthAlgorithm()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaEspOutAuthAlg.setStatus('current')
if mibBuilder.loadTexts: ipsecSaEspOutAuthAlg.setDescription('A unique value representing the hash algorithm applied to traffic or 0 if there is no authentication used.')
ipsecSaEspOutAuthKeyLength = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 4, 1, 15), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65531))).setUnits('bits').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaEspOutAuthKeyLength.setStatus('current')
if mibBuilder.loadTexts: ipsecSaEspOutAuthKeyLength.setDescription("The length of the authentication key in bits used for the algorithm specified in the 'ipsecSaEspOutAuthAlg' object. It may be 0 if the key length is implicit in the specified algorithm or there is no authentication specified.")
ipsecSaEspOutLimitSeconds = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 4, 1, 16), Unsigned32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaEspOutLimitSeconds.setStatus('current')
if mibBuilder.loadTexts: ipsecSaEspOutLimitSeconds.setDescription('The maximum lifetime in seconds of the SA, or 0 if there is no time constraint on its expiration. The display value is limited to 4294967295 seconds (more than 136 years); values greater than that value will be truncated.')
ipsecSaEspOutLimitKbytes = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 4, 1, 17), Unsigned32()).setUnits('kilobytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaEspOutLimitKbytes.setStatus('current')
if mibBuilder.loadTexts: ipsecSaEspOutLimitKbytes.setDescription('The maximum traffic in bytes that the SA is allowed to process, or 0 if there is no traffic constraint on its expiration. The display value is limited to 4294967295 kilobytes; values greater than that value will be truncated.')
ipsecSaEspOutAccSeconds = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 4, 1, 18), Counter32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaEspOutAccSeconds.setStatus('current')
if mibBuilder.loadTexts: ipsecSaEspOutAccSeconds.setDescription("The number of seconds accumulated against the SA's expiration by time. This is also the number of seconds that the SA has existed.")
ipsecSaEspOutAccKbytes = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 4, 1, 19), Counter32()).setUnits('kilobytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaEspOutAccKbytes.setStatus('current')
if mibBuilder.loadTexts: ipsecSaEspOutAccKbytes.setDescription("The amount of traffic accumulated that counts against the SA's expiration by traffic limitation, measured in kilobytes. This value may be 0 if the SA does not expire based on traffic.")
ipsecSaEspOutUserOctets = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 4, 1, 20), Counter64()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaEspOutUserOctets.setStatus('current')
if mibBuilder.loadTexts: ipsecSaEspOutUserOctets.setDescription('The amount of user level traffic measured in bytes handled by the SA. This is the number of bytes of the unencrypted IP packet, including the original IP header of that unencrypted packet. This is not necessarily the same as the amount of traffic applied against the traffic expiration limit due to padding or other protocol specific overhead.')
ipsecSaEspOutPackets = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 4, 1, 21), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaEspOutPackets.setStatus('current')
if mibBuilder.loadTexts: ipsecSaEspOutPackets.setDescription('The number of packets handled by the SA.')
ipsecSaEspOutSendErrors = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 4, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaEspOutSendErrors.setStatus('current')
if mibBuilder.loadTexts: ipsecSaEspOutSendErrors.setDescription('The number of packets discarded by the SA due to any error. This may include errors due to a lack of transmit buffers.')
ipsecSaAhOutTable = MibTable((1, 3, 6, 1, 3, 98, 1, 1, 5), )
if mibBuilder.loadTexts: ipsecSaAhOutTable.setStatus('current')
if mibBuilder.loadTexts: ipsecSaAhOutTable.setDescription('The (conceptual) table containing information on IPsec Outbound AH SAs. There should be one row for every outbound AH security association that exists in the entity. The maximum number of rows is implementation dependent.')
ipsecSaAhOutEntry = MibTableRow((1, 3, 6, 1, 3, 98, 1, 1, 5, 1), ).setIndexNames((0, "IPSEC-SA-MON-MIB", "ipsecSaAhOutAddress"), (0, "IPSEC-SA-MON-MIB", "ipsecSaAhOutSpi"))
if mibBuilder.loadTexts: ipsecSaAhOutEntry.setStatus('current')
if mibBuilder.loadTexts: ipsecSaAhOutEntry.setDescription('An entry (conceptual row) containing the information on a particular IPsec Outbound AH SA. A row in this table cannot be created or deleted by SNMP operations on columns of the table.')
ipsecSaAhOutAddress = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 5, 1, 1), IpsecIpv6Address()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaAhOutAddress.setStatus('current')
if mibBuilder.loadTexts: ipsecSaAhOutAddress.setDescription("The destination address of the SA. IPv4 entities will prefix the IP address with '0000:0000:0000:0000:0000:FFFF::'.")
ipsecSaAhOutSpi = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 5, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaAhOutSpi.setReference('RFC 2402 Section 2.4')
if mibBuilder.loadTexts: ipsecSaAhOutSpi.setStatus('current')
if mibBuilder.loadTexts: ipsecSaAhOutSpi.setDescription('The security parameters index of the SA.')
ipsecSaAhOutSourceId = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 5, 1, 3), IpsecRawId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaAhOutSourceId.setStatus('current')
if mibBuilder.loadTexts: ipsecSaAhOutSourceId.setDescription('The source identifier of the SA. It may be 0 if unknown or if the SA uses transport mode encapsulation. This value is taken directly from the optional ID payloads that are exchanged during phase 2 negotiations, or the equivalent process.')
ipsecSaAhOutSourceIdType = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 5, 1, 4), IpsecDoiIdentType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaAhOutSourceIdType.setStatus('current')
if mibBuilder.loadTexts: ipsecSaAhOutSourceIdType.setDescription("The type of identifier presented by 'ipsecSaAhOutSourceId'. It may be 0 if unknown or if the SA uses transport mode encapsulation.")
ipsecSaAhOutDestId = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 5, 1, 5), IpsecRawId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaAhOutDestId.setStatus('current')
if mibBuilder.loadTexts: ipsecSaAhOutDestId.setDescription('The destination identifier of the SA. It may be 0 if unknown or if the SA uses transport mode encapsulation. This value is taken directly from the optional ID payloads that are exchanged during phase 2 negotiations, or the equivalent process.')
ipsecSaAhOutDestIdType = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 5, 1, 6), IpsecDoiIdentType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaAhOutDestIdType.setStatus('current')
if mibBuilder.loadTexts: ipsecSaAhOutDestIdType.setDescription("The type of identifier presented by 'ipsecSaAhOutDestId'. It may be 0 if unknown or if the SA uses transport mode encapsulation.")
ipsecSaAhOutProtocol = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 5, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaAhOutProtocol.setReference('RFC 2401 section 4.4.2')
if mibBuilder.loadTexts: ipsecSaAhOutProtocol.setStatus('current')
if mibBuilder.loadTexts: ipsecSaAhOutProtocol.setDescription('The transport-layer protocol number that this SA carries, or 0 if it carries any protocol.')
ipsecSaAhOutSourcePort = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 5, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaAhOutSourcePort.setReference('RFC 2401 section 4.4.2')
if mibBuilder.loadTexts: ipsecSaAhOutSourcePort.setStatus('current')
if mibBuilder.loadTexts: ipsecSaAhOutSourcePort.setDescription('The source port number of the protocol that this SA carries, or 0 if it carries any port number.')
ipsecSaAhOutDestPort = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 5, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaAhOutDestPort.setReference('RFC 2401 section 4.4.2')
if mibBuilder.loadTexts: ipsecSaAhOutDestPort.setStatus('current')
if mibBuilder.loadTexts: ipsecSaAhOutDestPort.setDescription('The destination port number of the protocol that this SA carries, or 0 if it carries any port number.')
ipsecSaAhOutCreator = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 5, 1, 10), IpsecSaCreatorIdent()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaAhOutCreator.setStatus('current')
if mibBuilder.loadTexts: ipsecSaAhOutCreator.setDescription('The creator of this SA. This MIB makes no assumptions about how the SAs are created. They may be created statically, or by a key exchange protocol such as IKE, or by some other method.')
ipsecSaAhOutEncapsulation = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 5, 1, 11), IpsecDoiEncapsulationMode()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaAhOutEncapsulation.setStatus('current')
if mibBuilder.loadTexts: ipsecSaAhOutEncapsulation.setDescription('The type of encapsulation used by this SA.')
ipsecSaAhOutAuthAlg = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 5, 1, 12), IpsecDoiAhTransform()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaAhOutAuthAlg.setStatus('current')
if mibBuilder.loadTexts: ipsecSaAhOutAuthAlg.setDescription('A unique value representing the hash algorithm applied to traffic carried by this SA.')
ipsecSaAhOutAuthKeyLength = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 5, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65531))).setUnits('bits').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaAhOutAuthKeyLength.setStatus('current')
if mibBuilder.loadTexts: ipsecSaAhOutAuthKeyLength.setDescription("The length of the authentication key in bits used for the algorithm specified in the 'ipsecSaAhOutAuthAlg' object. It may be 0 if the key length is implicit in the specified algorithm.")
ipsecSaAhOutLimitSeconds = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 5, 1, 14), Unsigned32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaAhOutLimitSeconds.setStatus('current')
if mibBuilder.loadTexts: ipsecSaAhOutLimitSeconds.setDescription('The maximum lifetime in seconds of the SA, or 0 if there is no time constraint on its expiration. The display value is limited to 4294967295 seconds (more than 136 years); values greater than that value will be truncated.')
ipsecSaAhOutLimitKbytes = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 5, 1, 15), Unsigned32()).setUnits('kilobytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaAhOutLimitKbytes.setStatus('current')
if mibBuilder.loadTexts: ipsecSaAhOutLimitKbytes.setDescription('The maximum traffic in bytes that the SA is allowed to process, or 0 if there is no traffic constraint on its expiration. The display value is limited to 4294967295 kilobytes; values greater than that value will be truncated.')
ipsecSaAhOutAccSeconds = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 5, 1, 16), Counter32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaAhOutAccSeconds.setStatus('current')
if mibBuilder.loadTexts: ipsecSaAhOutAccSeconds.setDescription("The number of seconds accumulated against the SA's expiration by time. This is also the number of seconds that the SA has existed.")
ipsecSaAhOutAccKbytes = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 5, 1, 17), Counter32()).setUnits('kilobytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaAhOutAccKbytes.setStatus('current')
if mibBuilder.loadTexts: ipsecSaAhOutAccKbytes.setDescription("The amount of traffic accumulated that counts against the SA's expiration by traffic limitation, measured in kilobytes. This value may be 0 if the SA does not expire based on traffic.")
ipsecSaAhOutUserOctets = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 5, 1, 18), Counter64()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaAhOutUserOctets.setStatus('current')
if mibBuilder.loadTexts: ipsecSaAhOutUserOctets.setDescription('The amount of user level traffic measured in bytes handled by the SA. This is the number of bytes of the unprocessed IP packet, including the original IP header of that unprocessed packet. This is not necessarily the same as the amount of traffic applied against the traffic expiration limit due to padding or other protocol specific overhead.')
ipsecSaAhOutPackets = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 5, 1, 19), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaAhOutPackets.setStatus('current')
if mibBuilder.loadTexts: ipsecSaAhOutPackets.setDescription('The number of packets handled by the SA.')
ipsecSaAhOutSendErrors = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 5, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaAhOutSendErrors.setStatus('current')
if mibBuilder.loadTexts: ipsecSaAhOutSendErrors.setDescription('The number of packets discarded by the SA due to any error. This may include errors due to a lack of transmit buffers.')
ipsecSaIpcompOutTable = MibTable((1, 3, 6, 1, 3, 98, 1, 1, 6), )
if mibBuilder.loadTexts: ipsecSaIpcompOutTable.setStatus('current')
if mibBuilder.loadTexts: ipsecSaIpcompOutTable.setDescription('The (conceptual) table containing information on IPsec Outbound IPcomp SAs. There should be one row for every outbound IPcomp (security) association that exists in the entity. The maximum number of rows is implementation dependent.')
ipsecSaIpcompOutEntry = MibTableRow((1, 3, 6, 1, 3, 98, 1, 1, 6, 1), ).setIndexNames((0, "IPSEC-SA-MON-MIB", "ipsecSaIpcompOutAddress"), (0, "IPSEC-SA-MON-MIB", "ipsecSaIpcompOutCpi"))
if mibBuilder.loadTexts: ipsecSaIpcompOutEntry.setStatus('current')
if mibBuilder.loadTexts: ipsecSaIpcompOutEntry.setDescription('An entry (conceptual row) containing the information on a particular IPsec Outbound IPcomp SA. A row in this table cannot be created or deleted by SNMP operations on columns of the table.')
ipsecSaIpcompOutAddress = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 6, 1, 1), IpsecIpv6Address()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaIpcompOutAddress.setStatus('current')
if mibBuilder.loadTexts: ipsecSaIpcompOutAddress.setDescription("The destination address of the SA. If the IPcomp SA is shared across multiple SAs in security association suites, this value may be 0. IPv4 entities will prefix the IP address with '0000:0000:0000:0000:0000:FFFF::'.")
ipsecSaIpcompOutCpi = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 6, 1, 2), IpsecDoiIpcompTransform()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaIpcompOutCpi.setReference('RFC 2393 Section 3.3')
if mibBuilder.loadTexts: ipsecSaIpcompOutCpi.setStatus('current')
if mibBuilder.loadTexts: ipsecSaIpcompOutCpi.setDescription('The CPI of the SA. Since the lower values of CPIs are reserved to be the same as the algorithm, the syntax for this object is the same as the transform.')
ipsecSaIpcompOutSourceId = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 6, 1, 3), IpsecRawId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaIpcompOutSourceId.setStatus('current')
if mibBuilder.loadTexts: ipsecSaIpcompOutSourceId.setDescription('The source identifier of the SA. It may be 0 if unknown or if the SA uses transport mode encapsulation, or if this SA is used with multiple SAs in security association suites. This value, if non-zero, is taken directly from the optional ID payloads that are exchange during phase 2 negotiations or the equivalent process.')
ipsecSaIpcompOutSourceIdType = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 6, 1, 4), IpsecDoiIdentType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaIpcompOutSourceIdType.setStatus('current')
if mibBuilder.loadTexts: ipsecSaIpcompOutSourceIdType.setDescription("The type of identifier presented by 'ipsecSaIpcompOutSourceId'. It may be 0 if unknown or if the SA uses transport mode encapsulation, or if this SA is used with multiple SAs in security association suites.")
ipsecSaIpcompOutDestId = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 6, 1, 5), IpsecRawId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaIpcompOutDestId.setStatus('current')
if mibBuilder.loadTexts: ipsecSaIpcompOutDestId.setDescription('The destination identifier of the SA. It may be 0 if unknown or if the SA uses transport mode encapsulation, or if this SA is used with multiple SAs in security association suites. This value, if non-zero, is taken directly from the optional ID payloads that are exchange during phase 2 negotiations or the equivalent process.')
ipsecSaIpcompOutDestIdType = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 6, 1, 6), IpsecDoiIdentType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaIpcompOutDestIdType.setStatus('current')
if mibBuilder.loadTexts: ipsecSaIpcompOutDestIdType.setDescription("The type of identifier presented by 'ipsecSaIpcompOutDestId', or 0 if unknown or if the SA uses transport mode encapsulation, or 0 if this SA is used with multiple SAs in security association suites.")
ipsecSaIpcompOutProtocol = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 6, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaIpcompOutProtocol.setReference('RFC 2401 section 4.4.2')
if mibBuilder.loadTexts: ipsecSaIpcompOutProtocol.setStatus('current')
if mibBuilder.loadTexts: ipsecSaIpcompOutProtocol.setDescription('The transport-layer protocol number that this SA carries, or 0 if it carries any protocol.')
ipsecSaIpcompOutSourcePort = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 6, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaIpcompOutSourcePort.setReference('RFC 2401 section 4.4.2')
if mibBuilder.loadTexts: ipsecSaIpcompOutSourcePort.setStatus('current')
if mibBuilder.loadTexts: ipsecSaIpcompOutSourcePort.setDescription('The source port number of the protocol that this SA carries, or 0 if it carries any port number.')
ipsecSaIpcompOutDestPort = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 6, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaIpcompOutDestPort.setReference('RFC 2401 section 4.4.2')
if mibBuilder.loadTexts: ipsecSaIpcompOutDestPort.setStatus('current')
if mibBuilder.loadTexts: ipsecSaIpcompOutDestPort.setDescription('The destination port number of the protocol that this SA carries, or 0 if it carries any port number.')
ipsecSaIpcompOutCreator = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 6, 1, 10), IpsecSaCreatorIdent()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaIpcompOutCreator.setStatus('current')
if mibBuilder.loadTexts: ipsecSaIpcompOutCreator.setDescription('The creator of this SA. This MIB makes no assumptions about how the SAs are created. They may be created statically, or by a key exchange protocol such as IKE, or by some other method.')
ipsecSaIpcompOutEncapsulation = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 6, 1, 11), IpsecDoiEncapsulationMode()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaIpcompOutEncapsulation.setStatus('current')
if mibBuilder.loadTexts: ipsecSaIpcompOutEncapsulation.setDescription('The type of encapsulation used by this SA.')
ipsecSaIpcompOutCompAlg = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 6, 1, 12), IpsecDoiIpcompTransform()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaIpcompOutCompAlg.setStatus('current')
if mibBuilder.loadTexts: ipsecSaIpcompOutCompAlg.setDescription('A unique value representing the compression algorithm applied to traffic.')
ipsecSaIpcompOutSeconds = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 6, 1, 13), Counter32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaIpcompOutSeconds.setStatus('current')
if mibBuilder.loadTexts: ipsecSaIpcompOutSeconds.setDescription('The number of seconds that the SA has existed.')
ipsecSaIpcompOutUserOctets = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 6, 1, 14), Counter64()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaIpcompOutUserOctets.setStatus('current')
if mibBuilder.loadTexts: ipsecSaIpcompOutUserOctets.setDescription('The amount of user level traffic measured in bytes handled by the SA. This is the number of bytes of the decompressed IP packet, including the original IP header of that decompressed packet.')
ipsecSaIpcompOutOutputOctets = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 6, 1, 15), Counter64()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaIpcompOutOutputOctets.setStatus('current')
if mibBuilder.loadTexts: ipsecSaIpcompOutOutputOctets.setDescription("The amount of traffic measured in bytes output by the SA. This includes byte counts from packets compressed by the SA and also packets not modified by the SA. This object can be divided into the 'ipsecSaIpcompOutUserOctets' object to get a compression performance metric for the SA.")
ipsecSaIpcompOutPackets = MibTableColumn((1, 3, 6, 1, 3, 98, 1, 1, 6, 1, 16), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaIpcompOutPackets.setStatus('current')
if mibBuilder.loadTexts: ipsecSaIpcompOutPackets.setDescription('The number of packets handled by the SA. This includes packets that were both compressed and not compressed.')
ipsecEspCurrentInboundSAs = MibScalar((1, 3, 6, 1, 3, 98, 1, 2, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecEspCurrentInboundSAs.setStatus('current')
if mibBuilder.loadTexts: ipsecEspCurrentInboundSAs.setDescription('The current number of inbound ESP SAs in the entity.')
ipsecEspTotalInboundSAs = MibScalar((1, 3, 6, 1, 3, 98, 1, 2, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecEspTotalInboundSAs.setStatus('current')
if mibBuilder.loadTexts: ipsecEspTotalInboundSAs.setDescription('The total number of inbound ESP SAs created in the entity since boot time.')
ipsecEspCurrentOutboundSAs = MibScalar((1, 3, 6, 1, 3, 98, 1, 2, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecEspCurrentOutboundSAs.setStatus('current')
if mibBuilder.loadTexts: ipsecEspCurrentOutboundSAs.setDescription('The current number of outbound ESP SAs in the entity.')
ipsecEspTotalOutboundSAs = MibScalar((1, 3, 6, 1, 3, 98, 1, 2, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecEspTotalOutboundSAs.setStatus('current')
if mibBuilder.loadTexts: ipsecEspTotalOutboundSAs.setDescription('The total number of outbound ESP SAs created in the entity since boot time.')
ipsecAhCurrentInboundSAs = MibScalar((1, 3, 6, 1, 3, 98, 1, 2, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecAhCurrentInboundSAs.setStatus('current')
if mibBuilder.loadTexts: ipsecAhCurrentInboundSAs.setDescription('The current number of inbound AH SAs in the entity.')
ipsecAhTotalInboundSAs = MibScalar((1, 3, 6, 1, 3, 98, 1, 2, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecAhTotalInboundSAs.setStatus('current')
if mibBuilder.loadTexts: ipsecAhTotalInboundSAs.setDescription('The total number of inbound AH SAs created in the entity since boot time.')
ipsecAhCurrentOutboundSAs = MibScalar((1, 3, 6, 1, 3, 98, 1, 2, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecAhCurrentOutboundSAs.setStatus('current')
if mibBuilder.loadTexts: ipsecAhCurrentOutboundSAs.setDescription('The current number of outbound AH SAs in the entity.')
ipsecAhTotalOutboundSAs = MibScalar((1, 3, 6, 1, 3, 98, 1, 2, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecAhTotalOutboundSAs.setStatus('current')
if mibBuilder.loadTexts: ipsecAhTotalOutboundSAs.setDescription('The total number of outbound AH SAs created in the entity since boot time.')
ipsecIpcompCurrentInboundSAs = MibScalar((1, 3, 6, 1, 3, 98, 1, 2, 9), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIpcompCurrentInboundSAs.setStatus('current')
if mibBuilder.loadTexts: ipsecIpcompCurrentInboundSAs.setDescription('The current number of inbound IPcomp SAs in the entity.')
ipsecIpcompTotalInboundSAs = MibScalar((1, 3, 6, 1, 3, 98, 1, 2, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIpcompTotalInboundSAs.setStatus('current')
if mibBuilder.loadTexts: ipsecIpcompTotalInboundSAs.setDescription('The total number of inbound IPcomp SAs created in the entity since boot time.')
ipsecIpcompCurrentOutboundSAs = MibScalar((1, 3, 6, 1, 3, 98, 1, 2, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIpcompCurrentOutboundSAs.setStatus('current')
if mibBuilder.loadTexts: ipsecIpcompCurrentOutboundSAs.setDescription('The current number of outbound IPcomp SAs in the entity.')
ipsecIpcompTotalOutboundSAs = MibScalar((1, 3, 6, 1, 3, 98, 1, 2, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIpcompTotalOutboundSAs.setStatus('current')
if mibBuilder.loadTexts: ipsecIpcompTotalOutboundSAs.setDescription('The total number of outbound IPcomp SAs created in the entity since boot time.')
ipsecDecryptionErrors = MibScalar((1, 3, 6, 1, 3, 98, 1, 3, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecDecryptionErrors.setStatus('current')
if mibBuilder.loadTexts: ipsecDecryptionErrors.setDescription('The total number of packets received by the entity in SAs since boot time with detectable decryption errors. Not all decryption errors are detectable within SA processing, so this count should not be considered definitive.')
ipsecAuthenticationErrors = MibScalar((1, 3, 6, 1, 3, 98, 1, 3, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecAuthenticationErrors.setStatus('current')
if mibBuilder.loadTexts: ipsecAuthenticationErrors.setDescription('The total number of packets received by the entity in SAs since boot time with authentication errors. This includes all packets in which the hash value is determined to be invalid, for both ESP and AH SAs.')
ipsecReplayErrors = MibScalar((1, 3, 6, 1, 3, 98, 1, 3, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecReplayErrors.setStatus('current')
if mibBuilder.loadTexts: ipsecReplayErrors.setDescription('The total number of packets received by the entity in SAs since boot time with replay errors.')
ipsecPolicyErrors = MibScalar((1, 3, 6, 1, 3, 98, 1, 3, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecPolicyErrors.setStatus('current')
if mibBuilder.loadTexts: ipsecPolicyErrors.setDescription('The total number of packets received by the entity in SAs since boot time and discarded due to policy errors. This includes packets that had selectors that were invalid for the SA that carried them, and also includes packets that arrived at the entity in the clear and that should have been protected by IPsec or should have been dropped.')
ipsecOtherReceiveErrors = MibScalar((1, 3, 6, 1, 3, 98, 1, 3, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecOtherReceiveErrors.setStatus('current')
if mibBuilder.loadTexts: ipsecOtherReceiveErrors.setDescription('The total number of packets received by the entity in SAs since boot time and discarded due to errors not due to decryption, authentication, replay or policy.')
ipsecSendErrors = MibScalar((1, 3, 6, 1, 3, 98, 1, 3, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSendErrors.setStatus('current')
if mibBuilder.loadTexts: ipsecSendErrors.setDescription('The total number of packets to be sent by the entity in SAs since boot time and discarded due to errors.')
ipsecUnknownSpiErrors = MibScalar((1, 3, 6, 1, 3, 98, 1, 3, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecUnknownSpiErrors.setStatus('current')
if mibBuilder.loadTexts: ipsecUnknownSpiErrors.setDescription('The total number of packets received by the entity since boot time with SPIs or CPIs that were not valid.')
ipsecSecurityProtocol = MibScalar((1, 3, 6, 1, 3, 98, 1, 5, 1), IpsecDoiSecProtocolId()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: ipsecSecurityProtocol.setStatus('current')
if mibBuilder.loadTexts: ipsecSecurityProtocol.setDescription('A security protocol associated with the trap.')
ipsecSPI = MibScalar((1, 3, 6, 1, 3, 98, 1, 5, 2), Unsigned32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: ipsecSPI.setStatus('current')
if mibBuilder.loadTexts: ipsecSPI.setDescription('An SPI associated with a trap. Where the security protocol associated with the trap is IPcomp, this value has a maximum of 65535.')
ipsecLocalAddress = MibScalar((1, 3, 6, 1, 3, 98, 1, 5, 3), IpsecIpv6Address()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: ipsecLocalAddress.setStatus('current')
if mibBuilder.loadTexts: ipsecLocalAddress.setDescription("A local IP address associated with the trap. IPv4 entities will prefix the IP address with '0000:0000:0000:0000:0000:FFFF::'.")
ipsecPeerAddress = MibScalar((1, 3, 6, 1, 3, 98, 1, 5, 4), IpsecIpv6Address()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: ipsecPeerAddress.setStatus('current')
if mibBuilder.loadTexts: ipsecPeerAddress.setDescription("A peer IP address associated with the trap. IPv4 entities will prefix the IP address with '0000:0000:0000:0000:0000:FFFF::'.")
espAuthFailureTrapEnable = MibScalar((1, 3, 6, 1, 3, 98, 1, 6, 1), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: espAuthFailureTrapEnable.setStatus('current')
if mibBuilder.loadTexts: espAuthFailureTrapEnable.setDescription('Indicates whether espAuthFailureTrap traps should be generated.')
ahAuthFailureTrapEnable = MibScalar((1, 3, 6, 1, 3, 98, 1, 6, 2), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ahAuthFailureTrapEnable.setStatus('current')
if mibBuilder.loadTexts: ahAuthFailureTrapEnable.setDescription('Indicates whether ahAuthFailureTrap traps should be generated.')
espReplayFailureTrapEnable = MibScalar((1, 3, 6, 1, 3, 98, 1, 6, 3), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: espReplayFailureTrapEnable.setStatus('current')
if mibBuilder.loadTexts: espReplayFailureTrapEnable.setDescription('Indicates whether espReplayFailureTrap traps should be generated.')
ahReplayFailureTrapEnable = MibScalar((1, 3, 6, 1, 3, 98, 1, 6, 4), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ahReplayFailureTrapEnable.setStatus('current')
if mibBuilder.loadTexts: ahReplayFailureTrapEnable.setDescription('Indicates whether ahReplayFailureTrap traps should be generated.')
espPolicyFailureTrapEnable = MibScalar((1, 3, 6, 1, 3, 98, 1, 6, 5), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: espPolicyFailureTrapEnable.setStatus('current')
if mibBuilder.loadTexts: espPolicyFailureTrapEnable.setDescription('Indicates whether espPolicyFailureTrap traps should be generated.')
ahPolicyFailureTrapEnable = MibScalar((1, 3, 6, 1, 3, 98, 1, 6, 6), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ahPolicyFailureTrapEnable.setStatus('current')
if mibBuilder.loadTexts: ahPolicyFailureTrapEnable.setDescription('Indicates whether ahPolicyFailureTrap traps should be generated.')
invalidSpiTrapEnable = MibScalar((1, 3, 6, 1, 3, 98, 1, 6, 7), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: invalidSpiTrapEnable.setStatus('current')
if mibBuilder.loadTexts: invalidSpiTrapEnable.setDescription('Indicates whether invalidSpiTrap traps should be generated.')
otherPolicyFailureTrapEnable = MibScalar((1, 3, 6, 1, 3, 98, 1, 6, 8), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: otherPolicyFailureTrapEnable.setStatus('current')
if mibBuilder.loadTexts: otherPolicyFailureTrapEnable.setDescription('Indicates whether otherPolicyFailureTrap traps should be generated.')
espAuthFailureTrap = NotificationType((1, 3, 6, 1, 3, 98, 1, 4, 0, 1)).setObjects(("IPSEC-SA-MON-MIB", "ipsecSaEspInAuthErrors"))
if mibBuilder.loadTexts: espAuthFailureTrap.setStatus('current')
if mibBuilder.loadTexts: espAuthFailureTrap.setDescription("IPsec packets with invalid hashes were found in an inbound ESP SA. The total number of authentication errors accumulated is sent for the specific row of the 'ipsecSaEspInTable' table for the SA; this provides the identity of the SA in which the error occurred. Implementations SHOULD send one trap per SA (within a reasonable time period), rather than sending one trap per packet.")
ahAuthFailureTrap = NotificationType((1, 3, 6, 1, 3, 98, 1, 4, 0, 2)).setObjects(("IPSEC-SA-MON-MIB", "ipsecSaAhInAuthErrors"))
if mibBuilder.loadTexts: ahAuthFailureTrap.setStatus('current')
if mibBuilder.loadTexts: ahAuthFailureTrap.setDescription("IPsec packets with invalid hashes were found in an inbound AH SA. The total number of authentication errors accumulated is sent for the specific row of the 'ipsecSaAhInTable' table for the SA; this provides the identity of the SA in which the error occurred. Implementations SHOULD send one trap per SA (within a reasonable time period), rather than sending one trap per packet.")
espReplayFailureTrap = NotificationType((1, 3, 6, 1, 3, 98, 1, 4, 0, 3)).setObjects(("IPSEC-SA-MON-MIB", "ipsecSaEspInReplayErrors"))
if mibBuilder.loadTexts: espReplayFailureTrap.setStatus('current')
if mibBuilder.loadTexts: espReplayFailureTrap.setDescription("IPsec packets with invalid sequence numbers were found in an inbound ESP SA. The total number of replay errors accumulated is sent for the specific row of the 'ipsecSaEspInTable' table for the SA; this provides the identity of the SA in which the error occurred. Implementations SHOULD send one trap per SA (within a reasonable time period), rather than sending one trap per packet.")
ahReplayFailureTrap = NotificationType((1, 3, 6, 1, 3, 98, 1, 4, 0, 4)).setObjects(("IPSEC-SA-MON-MIB", "ipsecSaAhInReplayErrors"))
if mibBuilder.loadTexts: ahReplayFailureTrap.setStatus('current')
if mibBuilder.loadTexts: ahReplayFailureTrap.setDescription("IPsec packets with invalid sequence numbers were found in the specified AH SA. The total number of replay errors accumulated is sent for the specific row of the 'ipsecSaAhInTable' table for the SA; this provides the identity of the SA in which the error occurred. Implementations SHOULD send one trap per SA (within a reasonable time period), rather than sending one trap per packet.")
espPolicyFailureTrap = NotificationType((1, 3, 6, 1, 3, 98, 1, 4, 0, 5)).setObjects(("IPSEC-SA-MON-MIB", "ipsecSaEspInPolicyErrors"))
if mibBuilder.loadTexts: espPolicyFailureTrap.setStatus('current')
if mibBuilder.loadTexts: espPolicyFailureTrap.setDescription("IPsec packets carrying packets with invalid selectors for the specified ESP SA were found. The total number of policy errors accumulated is sent for the specific row of the 'ipsecSaEspInTable' table for the SA; this provides the identity of the SA in which the error occurred. Implementations SHOULD send one trap per SA (within a reasonable time period), rather than sending one trap per packet.")
ahPolicyFailureTrap = NotificationType((1, 3, 6, 1, 3, 98, 1, 4, 0, 6)).setObjects(("IPSEC-SA-MON-MIB", "ipsecSaAhInPolicyErrors"))
if mibBuilder.loadTexts: ahPolicyFailureTrap.setStatus('current')
if mibBuilder.loadTexts: ahPolicyFailureTrap.setDescription("IPsec packets carrying packets with invalid selectors for the specified AH SA were found. The total number of policy errors accumulated is sent for the specific row of the 'ipsecSaAhInTable' table for the SA; this provides the identity of the SA in which the error occurred. Implementations SHOULD send one trap per SA (within a reasonable time period), rather than sending one trap per packet.")
espInvalidSpiTrap = NotificationType((1, 3, 6, 1, 3, 98, 1, 4, 0, 7)).setObjects(("IPSEC-SA-MON-MIB", "ipsecLocalAddress"), ("IPSEC-SA-MON-MIB", "ipsecSecurityProtocol"), ("IPSEC-SA-MON-MIB", "ipsecPeerAddress"), ("IPSEC-SA-MON-MIB", "ipsecSPI"), ("IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: espInvalidSpiTrap.setStatus('current')
if mibBuilder.loadTexts: espInvalidSpiTrap.setDescription("A packet with an unknown SPI was detected from the specified peer with the specified SPI using the specified protocol. The destination address of the received packet is specified by 'ipsecLocalAddress'. The value 'ifIndex' may be 0 if this optional linkage is unsupported. If the object 'ipsecSecurityProtocol' has the value for IPcomp, then the 'ipsecSPI' object is the CPI of the packet. Implementations SHOULD send one trap per peer (within a reasonable time period), rather than sending one trap per packet.")
otherPolicyFailureTrap = NotificationType((1, 3, 6, 1, 3, 98, 1, 4, 0, 8)).setObjects(("IPSEC-SA-MON-MIB", "ipsecPolicyErrors"), ("IPSEC-SA-MON-MIB", "ipsecPeerAddress"), ("IPSEC-SA-MON-MIB", "ipsecLocalAddress"))
if mibBuilder.loadTexts: otherPolicyFailureTrap.setStatus('current')
if mibBuilder.loadTexts: otherPolicyFailureTrap.setDescription('Clear packets were found that should not have been sent to the entity in the clear. The total number of policy errors accumulated by the entity is sent, along with the source and destination addresses of the packet that triggered the trap. Implementations SHOULD send one trap per source address pair (within a reasonable time period), rather than sending one trap per packet.')
ipsecSaEspGroup = ObjectGroup((1, 3, 6, 1, 3, 98, 1, 7, 1)).setObjects(("IPSEC-SA-MON-MIB", "ipsecSaEspInAddress"), ("IPSEC-SA-MON-MIB", "ipsecSaEspInSpi"), ("IPSEC-SA-MON-MIB", "ipsecSaEspInDestId"), ("IPSEC-SA-MON-MIB", "ipsecSaEspInDestIdType"), ("IPSEC-SA-MON-MIB", "ipsecSaEspInSourceId"), ("IPSEC-SA-MON-MIB", "ipsecSaEspInSourceIdType"), ("IPSEC-SA-MON-MIB", "ipsecSaEspInProtocol"), ("IPSEC-SA-MON-MIB", "ipsecSaEspInDestPort"), ("IPSEC-SA-MON-MIB", "ipsecSaEspInSourcePort"), ("IPSEC-SA-MON-MIB", "ipsecSaEspInCreator"), ("IPSEC-SA-MON-MIB", "ipsecSaEspInEncapsulation"), ("IPSEC-SA-MON-MIB", "ipsecSaEspInEncAlg"), ("IPSEC-SA-MON-MIB", "ipsecSaEspInEncKeyLength"), ("IPSEC-SA-MON-MIB", "ipsecSaEspInAuthAlg"), ("IPSEC-SA-MON-MIB", "ipsecSaEspInAuthKeyLength"), ("IPSEC-SA-MON-MIB", "ipsecSaEspInRepWinSize"), ("IPSEC-SA-MON-MIB", "ipsecSaEspInLimitSeconds"), ("IPSEC-SA-MON-MIB", "ipsecSaEspInLimitKbytes"), ("IPSEC-SA-MON-MIB", "ipsecSaEspInAccSeconds"), ("IPSEC-SA-MON-MIB", "ipsecSaEspInAccKbytes"), ("IPSEC-SA-MON-MIB", "ipsecSaEspInUserOctets"), ("IPSEC-SA-MON-MIB", "ipsecSaEspInPackets"), ("IPSEC-SA-MON-MIB", "ipsecSaEspInDecryptErrors"), ("IPSEC-SA-MON-MIB", "ipsecSaEspInAuthErrors"), ("IPSEC-SA-MON-MIB", "ipsecSaEspInReplayErrors"), ("IPSEC-SA-MON-MIB", "ipsecSaEspInPolicyErrors"), ("IPSEC-SA-MON-MIB", "ipsecSaEspInPadErrors"), ("IPSEC-SA-MON-MIB", "ipsecSaEspInOtherReceiveErrors"), ("IPSEC-SA-MON-MIB", "ipsecSaEspOutAddress"), ("IPSEC-SA-MON-MIB", "ipsecSaEspOutSpi"), ("IPSEC-SA-MON-MIB", "ipsecSaEspOutSourceId"), ("IPSEC-SA-MON-MIB", "ipsecSaEspOutSourceIdType"), ("IPSEC-SA-MON-MIB", "ipsecSaEspOutDestId"), ("IPSEC-SA-MON-MIB", "ipsecSaEspOutDestIdType"), ("IPSEC-SA-MON-MIB", "ipsecSaEspOutProtocol"), ("IPSEC-SA-MON-MIB", "ipsecSaEspOutSourcePort"), ("IPSEC-SA-MON-MIB", "ipsecSaEspOutDestPort"), ("IPSEC-SA-MON-MIB", "ipsecSaEspOutCreator"), ("IPSEC-SA-MON-MIB", "ipsecSaEspOutEncapsulation"), ("IPSEC-SA-MON-MIB", "ipsecSaEspOutEncAlg"), ("IPSEC-SA-MON-MIB", "ipsecSaEspOutAuthKeyLength"), ("IPSEC-SA-MON-MIB", "ipsecSaEspOutEncKeyLength"), ("IPSEC-SA-MON-MIB", "ipsecSaEspOutAuthAlg"), ("IPSEC-SA-MON-MIB", "ipsecSaEspOutLimitSeconds"), ("IPSEC-SA-MON-MIB", "ipsecSaEspOutLimitKbytes"), ("IPSEC-SA-MON-MIB", "ipsecSaEspOutAccSeconds"), ("IPSEC-SA-MON-MIB", "ipsecSaEspOutAccKbytes"), ("IPSEC-SA-MON-MIB", "ipsecSaEspOutUserOctets"), ("IPSEC-SA-MON-MIB", "ipsecSaEspOutPackets"), ("IPSEC-SA-MON-MIB", "ipsecSaEspOutSendErrors"), ("IPSEC-SA-MON-MIB", "ipsecEspCurrentInboundSAs"), ("IPSEC-SA-MON-MIB", "ipsecEspTotalInboundSAs"), ("IPSEC-SA-MON-MIB", "ipsecEspCurrentOutboundSAs"), ("IPSEC-SA-MON-MIB", "ipsecEspTotalOutboundSAs"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ipsecSaEspGroup = ipsecSaEspGroup.setStatus('current')
if mibBuilder.loadTexts: ipsecSaEspGroup.setDescription('A collection of objects that describe the state of the security associations of the ESP protocol.')
ipsecSaAhGroup = ObjectGroup((1, 3, 6, 1, 3, 98, 1, 7, 2)).setObjects(("IPSEC-SA-MON-MIB", "ipsecSaAhInAddress"), ("IPSEC-SA-MON-MIB", "ipsecSaAhInSpi"), ("IPSEC-SA-MON-MIB", "ipsecSaAhInDestId"), ("IPSEC-SA-MON-MIB", "ipsecSaAhInDestIdType"), ("IPSEC-SA-MON-MIB", "ipsecSaAhInSourceId"), ("IPSEC-SA-MON-MIB", "ipsecSaAhInSourceIdType"), ("IPSEC-SA-MON-MIB", "ipsecSaAhInProtocol"), ("IPSEC-SA-MON-MIB", "ipsecSaAhInDestPort"), ("IPSEC-SA-MON-MIB", "ipsecSaAhInSourcePort"), ("IPSEC-SA-MON-MIB", "ipsecSaAhInCreator"), ("IPSEC-SA-MON-MIB", "ipsecSaAhInEncapsulation"), ("IPSEC-SA-MON-MIB", "ipsecSaAhInAuthAlg"), ("IPSEC-SA-MON-MIB", "ipsecSaAhInAuthKeyLength"), ("IPSEC-SA-MON-MIB", "ipsecSaAhInRepWinSize"), ("IPSEC-SA-MON-MIB", "ipsecSaAhInLimitSeconds"), ("IPSEC-SA-MON-MIB", "ipsecSaAhInLimitKbytes"), ("IPSEC-SA-MON-MIB", "ipsecSaAhInAccSeconds"), ("IPSEC-SA-MON-MIB", "ipsecSaAhInAccKbytes"), ("IPSEC-SA-MON-MIB", "ipsecSaAhInUserOctets"), ("IPSEC-SA-MON-MIB", "ipsecSaAhInPackets"), ("IPSEC-SA-MON-MIB", "ipsecSaAhInAuthErrors"), ("IPSEC-SA-MON-MIB", "ipsecSaAhInReplayErrors"), ("IPSEC-SA-MON-MIB", "ipsecSaAhInPolicyErrors"), ("IPSEC-SA-MON-MIB", "ipsecSaAhInOtherReceiveErrors"), ("IPSEC-SA-MON-MIB", "ipsecSaAhOutAddress"), ("IPSEC-SA-MON-MIB", "ipsecSaAhOutSpi"), ("IPSEC-SA-MON-MIB", "ipsecSaAhOutSourceId"), ("IPSEC-SA-MON-MIB", "ipsecSaAhOutSourceIdType"), ("IPSEC-SA-MON-MIB", "ipsecSaAhOutDestId"), ("IPSEC-SA-MON-MIB", "ipsecSaAhOutDestIdType"), ("IPSEC-SA-MON-MIB", "ipsecSaAhOutProtocol"), ("IPSEC-SA-MON-MIB", "ipsecSaAhOutSourcePort"), ("IPSEC-SA-MON-MIB", "ipsecSaAhOutDestPort"), ("IPSEC-SA-MON-MIB", "ipsecSaAhOutCreator"), ("IPSEC-SA-MON-MIB", "ipsecSaAhOutEncapsulation"), ("IPSEC-SA-MON-MIB", "ipsecSaAhOutAuthAlg"), ("IPSEC-SA-MON-MIB", "ipsecSaAhOutAuthKeyLength"), ("IPSEC-SA-MON-MIB", "ipsecSaAhOutLimitSeconds"), ("IPSEC-SA-MON-MIB", "ipsecSaAhOutLimitKbytes"), ("IPSEC-SA-MON-MIB", "ipsecSaAhOutAccSeconds"), ("IPSEC-SA-MON-MIB", "ipsecSaAhOutAccKbytes"), ("IPSEC-SA-MON-MIB", "ipsecSaAhOutUserOctets"), ("IPSEC-SA-MON-MIB", "ipsecSaAhOutPackets"), ("IPSEC-SA-MON-MIB", "ipsecSaAhOutSendErrors"), ("IPSEC-SA-MON-MIB", "ipsecAhCurrentInboundSAs"), ("IPSEC-SA-MON-MIB", "ipsecAhTotalInboundSAs"), ("IPSEC-SA-MON-MIB", "ipsecAhCurrentOutboundSAs"), ("IPSEC-SA-MON-MIB", "ipsecAhTotalOutboundSAs"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ipsecSaAhGroup = ipsecSaAhGroup.setStatus('current')
if mibBuilder.loadTexts: ipsecSaAhGroup.setDescription('A collection of objects that describe the state of the security associations of the AH protocol.')
ipsecSaIpcompGroup = ObjectGroup((1, 3, 6, 1, 3, 98, 1, 7, 3)).setObjects(("IPSEC-SA-MON-MIB", "ipsecSaIpcompInAddress"), ("IPSEC-SA-MON-MIB", "ipsecSaIpcompInCpi"), ("IPSEC-SA-MON-MIB", "ipsecSaIpcompInDestId"), ("IPSEC-SA-MON-MIB", "ipsecSaIpcompInDestIdType"), ("IPSEC-SA-MON-MIB", "ipsecSaIpcompInSourceId"), ("IPSEC-SA-MON-MIB", "ipsecSaIpcompInSourceIdType"), ("IPSEC-SA-MON-MIB", "ipsecSaIpcompInProtocol"), ("IPSEC-SA-MON-MIB", "ipsecSaIpcompInDestPort"), ("IPSEC-SA-MON-MIB", "ipsecSaIpcompInSourcePort"), ("IPSEC-SA-MON-MIB", "ipsecSaIpcompInCreator"), ("IPSEC-SA-MON-MIB", "ipsecSaIpcompInEncapsulation"), ("IPSEC-SA-MON-MIB", "ipsecSaIpcompInDecompAlg"), ("IPSEC-SA-MON-MIB", "ipsecSaIpcompInSeconds"), ("IPSEC-SA-MON-MIB", "ipsecSaIpcompInUserOctets"), ("IPSEC-SA-MON-MIB", "ipsecSaIpcompInPackets"), ("IPSEC-SA-MON-MIB", "ipsecSaIpcompInDecompErrors"), ("IPSEC-SA-MON-MIB", "ipsecSaIpcompInOtherReceiveErrors"), ("IPSEC-SA-MON-MIB", "ipsecSaIpcompOutAddress"), ("IPSEC-SA-MON-MIB", "ipsecSaIpcompOutCpi"), ("IPSEC-SA-MON-MIB", "ipsecSaIpcompOutSourceId"), ("IPSEC-SA-MON-MIB", "ipsecSaIpcompOutSourceIdType"), ("IPSEC-SA-MON-MIB", "ipsecSaIpcompOutDestId"), ("IPSEC-SA-MON-MIB", "ipsecSaIpcompOutDestIdType"), ("IPSEC-SA-MON-MIB", "ipsecSaIpcompOutProtocol"), ("IPSEC-SA-MON-MIB", "ipsecSaIpcompOutSourcePort"), ("IPSEC-SA-MON-MIB", "ipsecSaIpcompOutDestPort"), ("IPSEC-SA-MON-MIB", "ipsecSaIpcompOutCreator"), ("IPSEC-SA-MON-MIB", "ipsecSaIpcompOutEncapsulation"), ("IPSEC-SA-MON-MIB", "ipsecSaIpcompOutCompAlg"), ("IPSEC-SA-MON-MIB", "ipsecSaIpcompOutSeconds"), ("IPSEC-SA-MON-MIB", "ipsecSaIpcompOutUserOctets"), ("IPSEC-SA-MON-MIB", "ipsecSaIpcompOutOutputOctets"), ("IPSEC-SA-MON-MIB", "ipsecSaIpcompOutPackets"), ("IPSEC-SA-MON-MIB", "ipsecIpcompCurrentInboundSAs"), ("IPSEC-SA-MON-MIB", "ipsecIpcompTotalInboundSAs"), ("IPSEC-SA-MON-MIB", "ipsecIpcompCurrentOutboundSAs"), ("IPSEC-SA-MON-MIB", "ipsecIpcompTotalOutboundSAs"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ipsecSaIpcompGroup = ipsecSaIpcompGroup.setStatus('current')
if mibBuilder.loadTexts: ipsecSaIpcompGroup.setDescription('A collection of objects that describe the state of the security associations of the IPComp protocol.')
ipsecSaErrorsGroup = ObjectGroup((1, 3, 6, 1, 3, 98, 1, 7, 4)).setObjects(("IPSEC-SA-MON-MIB", "ipsecDecryptionErrors"), ("IPSEC-SA-MON-MIB", "ipsecAuthenticationErrors"), ("IPSEC-SA-MON-MIB", "ipsecReplayErrors"), ("IPSEC-SA-MON-MIB", "ipsecPolicyErrors"), ("IPSEC-SA-MON-MIB", "ipsecOtherReceiveErrors"), ("IPSEC-SA-MON-MIB", "ipsecUnknownSpiErrors"), ("IPSEC-SA-MON-MIB", "ipsecSendErrors"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ipsecSaErrorsGroup = ipsecSaErrorsGroup.setStatus('current')
if mibBuilder.loadTexts: ipsecSaErrorsGroup.setDescription('A collection of objects providing global IPsec error counters.')
ipsecSaFailureTrapEnableGroup = ObjectGroup((1, 3, 6, 1, 3, 98, 1, 7, 5)).setObjects(("IPSEC-SA-MON-MIB", "espAuthFailureTrapEnable"), ("IPSEC-SA-MON-MIB", "ahAuthFailureTrapEnable"), ("IPSEC-SA-MON-MIB", "espReplayFailureTrapEnable"), ("IPSEC-SA-MON-MIB", "ahReplayFailureTrapEnable"), ("IPSEC-SA-MON-MIB", "espPolicyFailureTrapEnable"), ("IPSEC-SA-MON-MIB", "ahPolicyFailureTrapEnable"), ("IPSEC-SA-MON-MIB", "invalidSpiTrapEnable"), ("IPSEC-SA-MON-MIB", "otherPolicyFailureTrapEnable"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ipsecSaFailureTrapEnableGroup = ipsecSaFailureTrapEnableGroup.setStatus('current')
if mibBuilder.loadTexts: ipsecSaFailureTrapEnableGroup.setDescription('A collection of objects providing control over trap generation.')
ipsecSaTrapArgumentGroup = ObjectGroup((1, 3, 6, 1, 3, 98, 1, 7, 6)).setObjects(("IPSEC-SA-MON-MIB", "ipsecSecurityProtocol"), ("IPSEC-SA-MON-MIB", "ipsecSPI"), ("IPSEC-SA-MON-MIB", "ipsecLocalAddress"), ("IPSEC-SA-MON-MIB", "ipsecPeerAddress"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ipsecSaTrapArgumentGroup = ipsecSaTrapArgumentGroup.setStatus('current')
if mibBuilder.loadTexts: ipsecSaTrapArgumentGroup.setDescription('A collection of objects used only as arguments in traps.')
ipsecSaFailureTrapGroup = NotificationGroup((1, 3, 6, 1, 3, 98, 1, 7, 7)).setObjects(("IPSEC-SA-MON-MIB", "espAuthFailureTrap"), ("IPSEC-SA-MON-MIB", "ahAuthFailureTrap"), ("IPSEC-SA-MON-MIB", "espReplayFailureTrap"), ("IPSEC-SA-MON-MIB", "ahReplayFailureTrap"), ("IPSEC-SA-MON-MIB", "espPolicyFailureTrap"), ("IPSEC-SA-MON-MIB", "ahPolicyFailureTrap"), ("IPSEC-SA-MON-MIB", "espInvalidSpiTrap"), ("IPSEC-SA-MON-MIB", "otherPolicyFailureTrap"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ipsecSaFailureTrapGroup = ipsecSaFailureTrapGroup.setStatus('current')
if mibBuilder.loadTexts: ipsecSaFailureTrapGroup.setDescription('A collection of traps.')
ipsecSaMonitorCompliance = ModuleCompliance((1, 3, 6, 1, 3, 98, 1, 8, 1)).setObjects(("IPSEC-SA-MON-MIB", "ipsecSaEspGroup"), ("IPSEC-SA-MON-MIB", "ipsecSaAhGroup"), ("IPSEC-SA-MON-MIB", "ipsecSaErrorsGroup"), ("IPSEC-SA-MON-MIB", "ipsecSaFailureTrapEnableGroup"), ("IPSEC-SA-MON-MIB", "ipsecSaFailureTrapGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ipsecSaMonitorCompliance = ipsecSaMonitorCompliance.setStatus('current')
if mibBuilder.loadTexts: ipsecSaMonitorCompliance.setDescription('The compliance statement for SNMPv2 entities which implement the IPsec Monitoring MIB.')
mibBuilder.exportSymbols("IPSEC-SA-MON-MIB", ipsecEspTotalInboundSAs=ipsecEspTotalInboundSAs, ipsecSaAhOutDestIdType=ipsecSaAhOutDestIdType, ipsecLocalAddress=ipsecLocalAddress, ahPolicyFailureTrap=ahPolicyFailureTrap, ipsecSaEspInEncAlg=ipsecSaEspInEncAlg, ipsecSaEspInDecryptErrors=ipsecSaEspInDecryptErrors, saConformance=saConformance, saStatistics=saStatistics, ipsecSaEspOutPackets=ipsecSaEspOutPackets, ipsecSaEspOutTable=ipsecSaEspOutTable, ipsecSaAhOutCreator=ipsecSaAhOutCreator, ipsecAhCurrentOutboundSAs=ipsecAhCurrentOutboundSAs, ipsecSaEspInUserOctets=ipsecSaEspInUserOctets, ipsecSaIpcompInAddress=ipsecSaIpcompInAddress, ipsecSaEspInSpi=ipsecSaEspInSpi, ipsecSaEspInTable=ipsecSaEspInTable, ipsecSaAhOutUserOctets=ipsecSaAhOutUserOctets, ipsecSaIpcompOutDestId=ipsecSaIpcompOutDestId, ipsecSaAhInSpi=ipsecSaAhInSpi, ipsecSaAhOutSpi=ipsecSaAhOutSpi, saTraps=saTraps, ipsecSaAhInAuthErrors=ipsecSaAhInAuthErrors, ipsecSaEspInAddress=ipsecSaEspInAddress, ipsecSaEspInAccKbytes=ipsecSaEspInAccKbytes, espAuthFailureTrap=espAuthFailureTrap, ipsecSaIpcompInDestId=ipsecSaIpcompInDestId, ipsecSaIpcompOutEntry=ipsecSaIpcompOutEntry, ipsecAuthenticationErrors=ipsecAuthenticationErrors, ipsecSaIpcompOutPackets=ipsecSaIpcompOutPackets, ipsecEspCurrentOutboundSAs=ipsecEspCurrentOutboundSAs, ipsecSaIpcompOutEncapsulation=ipsecSaIpcompOutEncapsulation, ipsecSaEspOutDestPort=ipsecSaEspOutDestPort, ipsecSaEspOutAccSeconds=ipsecSaEspOutAccSeconds, ipsecSaEspOutSourceId=ipsecSaEspOutSourceId, ipsecSaIpcompOutDestIdType=ipsecSaIpcompOutDestIdType, ipsecSaAhOutProtocol=ipsecSaAhOutProtocol, ipsecSaMonitorMIB=ipsecSaMonitorMIB, ipsecSaAhOutAccKbytes=ipsecSaAhOutAccKbytes, ipsecSaIpcompInUserOctets=ipsecSaIpcompInUserOctets, ipsecSaFailureTrapEnableGroup=ipsecSaFailureTrapEnableGroup, ipsecOtherReceiveErrors=ipsecOtherReceiveErrors, ipsecSaEspInEncapsulation=ipsecSaEspInEncapsulation, ipsecSaIpcompInEncapsulation=ipsecSaIpcompInEncapsulation, ipsecSaAhOutEntry=ipsecSaAhOutEntry, ipsecSaAhOutPackets=ipsecSaAhOutPackets, ipsecSaAhInDestPort=ipsecSaAhInDestPort, ipsecSaIpcompInCreator=ipsecSaIpcompInCreator, ipsecSaEspOutEntry=ipsecSaEspOutEntry, saTrapObjects=saTrapObjects, ipsecSaIpcompInSourceId=ipsecSaIpcompInSourceId, ipsecSaEspOutDestId=ipsecSaEspOutDestId, ipsecSaEspGroup=ipsecSaEspGroup, ipsecSaEspInPackets=ipsecSaEspInPackets, ipsecIpcompCurrentOutboundSAs=ipsecIpcompCurrentOutboundSAs, ipsecSaIpcompInDecompAlg=ipsecSaIpcompInDecompAlg, ipsecSaAhInSourcePort=ipsecSaAhInSourcePort, ipsecSaAhInAccKbytes=ipsecSaAhInAccKbytes, ipsecSaEspOutAccKbytes=ipsecSaEspOutAccKbytes, ipsecUnknownSpiErrors=ipsecUnknownSpiErrors, ipsecSaAhGroup=ipsecSaAhGroup, ipsecSaAhInDestIdType=ipsecSaAhInDestIdType, ipsecSaEspInRepWinSize=ipsecSaEspInRepWinSize, ipsecSaAhOutDestPort=ipsecSaAhOutDestPort, ipsecSaEspInAuthErrors=ipsecSaEspInAuthErrors, ipsecSaIpcompOutCompAlg=ipsecSaIpcompOutCompAlg, ipsecSaEspOutAuthKeyLength=ipsecSaEspOutAuthKeyLength, ipsecSaErrorsGroup=ipsecSaErrorsGroup, ipsecSaAhInDestId=ipsecSaAhInDestId, ipsecSaAhInEncapsulation=ipsecSaAhInEncapsulation, ahAuthFailureTrap=ahAuthFailureTrap, saErrors=saErrors, ipsecSaEspInCreator=ipsecSaEspInCreator, ipsecSaEspOutUserOctets=ipsecSaEspOutUserOctets, ipsecSaAhInAddress=ipsecSaAhInAddress, ipsecSaIpcompOutUserOctets=ipsecSaIpcompOutUserOctets, ipsecSaAhInLimitSeconds=ipsecSaAhInLimitSeconds, ipsecSaEspOutEncapsulation=ipsecSaEspOutEncapsulation, ipsecSaFailureTrapGroup=ipsecSaFailureTrapGroup, ipsecSaMonitorCompliance=ipsecSaMonitorCompliance, ipsecSaEspInDestId=ipsecSaEspInDestId, ipsecDecryptionErrors=ipsecDecryptionErrors, espReplayFailureTrap=espReplayFailureTrap, invalidSpiTrapEnable=invalidSpiTrapEnable, ipsecSaIpcompOutCpi=ipsecSaIpcompOutCpi, ipsecSaMonModule=ipsecSaMonModule, ipsecSaAhInSourceId=ipsecSaAhInSourceId, ipsecSaAhInSourceIdType=ipsecSaAhInSourceIdType, ipsecSPI=ipsecSPI, ipsecSaEspInPolicyErrors=ipsecSaEspInPolicyErrors, ipsecSecurityProtocol=ipsecSecurityProtocol, ipsecSaAhInAuthAlg=ipsecSaAhInAuthAlg, ipsecSaAhOutSourceId=ipsecSaAhOutSourceId, ipsecSaIpcompOutSourceIdType=ipsecSaIpcompOutSourceIdType, ipsecSaEspInProtocol=ipsecSaEspInProtocol, ipsecSaAhOutAccSeconds=ipsecSaAhOutAccSeconds, saGroups=saGroups, IpsecSaCreatorIdent=IpsecSaCreatorIdent, ipsecSaEspOutAddress=ipsecSaEspOutAddress, ipsecPolicyErrors=ipsecPolicyErrors, ipsecSaAhOutDestId=ipsecSaAhOutDestId, ipsecSaEspOutProtocol=ipsecSaEspOutProtocol, ipsecSaAhInCreator=ipsecSaAhInCreator, ipsecSaAhInPackets=ipsecSaAhInPackets, ipsecIpcompCurrentInboundSAs=ipsecIpcompCurrentInboundSAs, espPolicyFailureTrap=espPolicyFailureTrap, ipsecSaIpcompInSourcePort=ipsecSaIpcompInSourcePort, ipsecSaAhOutSourcePort=ipsecSaAhOutSourcePort, ipsecSaEspInPadErrors=ipsecSaEspInPadErrors, ipsecSaEspInDestIdType=ipsecSaEspInDestIdType, ipsecSaIpcompInDestPort=ipsecSaIpcompInDestPort, ipsecSaIpcompInSeconds=ipsecSaIpcompInSeconds, ipsecSaIpcompOutProtocol=ipsecSaIpcompOutProtocol, ipsecSendErrors=ipsecSendErrors, espAuthFailureTrapEnable=espAuthFailureTrapEnable, ahAuthFailureTrapEnable=ahAuthFailureTrapEnable, ipsecSaIpcompInProtocol=ipsecSaIpcompInProtocol, ipsecSaEspOutLimitSeconds=ipsecSaEspOutLimitSeconds, ipsecIpcompTotalInboundSAs=ipsecIpcompTotalInboundSAs, ipsecReplayErrors=ipsecReplayErrors, ipsecSaAhInTable=ipsecSaAhInTable, ipsecSaEspInSourcePort=ipsecSaEspInSourcePort, ipsecSaIpcompOutAddress=ipsecSaIpcompOutAddress, ipsecSaEspInLimitSeconds=ipsecSaEspInLimitSeconds, ipsecSaEspOutEncAlg=ipsecSaEspOutEncAlg, ipsecSaIpcompInCpi=ipsecSaIpcompInCpi, ahReplayFailureTrap=ahReplayFailureTrap, ahReplayFailureTrapEnable=ahReplayFailureTrapEnable, otherPolicyFailureTrapEnable=otherPolicyFailureTrapEnable, ipsecSaEspInEncKeyLength=ipsecSaEspInEncKeyLength, ipsecPeerAddress=ipsecPeerAddress, ipsecSaAhOutLimitKbytes=ipsecSaAhOutLimitKbytes, ipsecSaAhOutAuthKeyLength=ipsecSaAhOutAuthKeyLength, ipsecSaAhInPolicyErrors=ipsecSaAhInPolicyErrors, ipsecSaEspInLimitKbytes=ipsecSaEspInLimitKbytes, ipsecSaAhInAuthKeyLength=ipsecSaAhInAuthKeyLength, ipsecSaEspOutSourceIdType=ipsecSaEspOutSourceIdType, ipsecSaAhInUserOctets=ipsecSaAhInUserOctets, ipsecSaTrapArgumentGroup=ipsecSaTrapArgumentGroup, ipsecSaEspInAuthKeyLength=ipsecSaEspInAuthKeyLength, ipsecSaEspInAuthAlg=ipsecSaEspInAuthAlg, espInvalidSpiTrap=espInvalidSpiTrap, ipsecSaEspOutSpi=ipsecSaEspOutSpi, ipsecSaEspOutLimitKbytes=ipsecSaEspOutLimitKbytes, ipsecEspCurrentInboundSAs=ipsecEspCurrentInboundSAs, ipsecSaIpcompOutSourcePort=ipsecSaIpcompOutSourcePort, ipsecAhCurrentInboundSAs=ipsecAhCurrentInboundSAs, ipsecSaAhOutLimitSeconds=ipsecSaAhOutLimitSeconds, saTables=saTables, ipsecAhTotalInboundSAs=ipsecAhTotalInboundSAs, otherPolicyFailureTrap=otherPolicyFailureTrap, ipsecSaAhInReplayErrors=ipsecSaAhInReplayErrors, ipsecSaEspOutDestIdType=ipsecSaEspOutDestIdType, ipsecSaIpcompOutSeconds=ipsecSaIpcompOutSeconds, ipsecSaAhInEntry=ipsecSaAhInEntry, ipsecSaAhOutAuthAlg=ipsecSaAhOutAuthAlg, ipsecSaEspOutSendErrors=ipsecSaEspOutSendErrors, ipsecSaAhOutSourceIdType=ipsecSaAhOutSourceIdType, ipsecSaIpcompInDecompErrors=ipsecSaIpcompInDecompErrors, ipsecSaAhInOtherReceiveErrors=ipsecSaAhInOtherReceiveErrors, ipsecSaIpcompInOtherReceiveErrors=ipsecSaIpcompInOtherReceiveErrors, ipsecSaIpcompInSourceIdType=ipsecSaIpcompInSourceIdType, ipsecSaAhInLimitKbytes=ipsecSaAhInLimitKbytes, ipsecSaEspOutAuthAlg=ipsecSaEspOutAuthAlg, ipsecSaIpcompInTable=ipsecSaIpcompInTable, espReplayFailureTrapEnable=espReplayFailureTrapEnable, ipsecSaIpcompOutDestPort=ipsecSaIpcompOutDestPort, ipsecSaIpcompOutCreator=ipsecSaIpcompOutCreator, ipsecSaEspInEntry=ipsecSaEspInEntry, ipsecSaEspOutEncKeyLength=ipsecSaEspOutEncKeyLength, ipsecSaEspOutCreator=ipsecSaEspOutCreator, PYSNMP_MODULE_ID=ipsecSaMonModule, saTrapControl=saTrapControl, ipsecSaIpcompInPackets=ipsecSaIpcompInPackets, ipsecSaAhOutAddress=ipsecSaAhOutAddress, IpsecRawId=IpsecRawId, ipsecSaIpcompInEntry=ipsecSaIpcompInEntry, ipsecSaEspInDestPort=ipsecSaEspInDestPort, espPolicyFailureTrapEnable=espPolicyFailureTrapEnable, ipsecSaEspInSourceId=ipsecSaEspInSourceId, ipsecAhTotalOutboundSAs=ipsecAhTotalOutboundSAs, IpsecIpv6Address=IpsecIpv6Address, ipsecSaEspInAccSeconds=ipsecSaEspInAccSeconds, ipsecSaIpcompOutTable=ipsecSaIpcompOutTable, ipsecSaEspInReplayErrors=ipsecSaEspInReplayErrors, ahPolicyFailureTrapEnable=ahPolicyFailureTrapEnable, ipsecSaEspInSourceIdType=ipsecSaEspInSourceIdType, ipsecSaEspInOtherReceiveErrors=ipsecSaEspInOtherReceiveErrors, ipsecSaAhOutSendErrors=ipsecSaAhOutSendErrors, ipsecSaAhInAccSeconds=ipsecSaAhInAccSeconds, ipsecSaAhInProtocol=ipsecSaAhInProtocol, ipsecEspTotalOutboundSAs=ipsecEspTotalOutboundSAs, ipsecSaAhOutTable=ipsecSaAhOutTable, ipsecSaIpcompInDestIdType=ipsecSaIpcompInDestIdType, ipsecSaIpcompOutSourceId=ipsecSaIpcompOutSourceId, ipsecSaAhOutEncapsulation=ipsecSaAhOutEncapsulation, ipsecIpcompTotalOutboundSAs=ipsecIpcompTotalOutboundSAs, ipsecSaIpcompOutOutputOctets=ipsecSaIpcompOutOutputOctets, ipsecSaEspOutSourcePort=ipsecSaEspOutSourcePort, ipsecSaIpcompGroup=ipsecSaIpcompGroup, ipsecSaAhInRepWinSize=ipsecSaAhInRepWinSize)

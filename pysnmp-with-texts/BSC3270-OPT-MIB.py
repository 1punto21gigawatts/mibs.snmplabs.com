#
# PySNMP MIB module BSC3270-OPT-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/BSC3270-OPT-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:41:30 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsUnion, ValueSizeConstraint, ConstraintsIntersection, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsUnion", "ValueSizeConstraint", "ConstraintsIntersection", "ValueRangeConstraint")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
TimeTicks, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn, IpAddress, Gauge32, ObjectIdentity, MibIdentifier, Counter32, ModuleIdentity, Unsigned32, Counter64, enterprises, Bits, iso, Integer32 = mibBuilder.importSymbols("SNMPv2-SMI", "TimeTicks", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "IpAddress", "Gauge32", "ObjectIdentity", "MibIdentifier", "Counter32", "ModuleIdentity", "Unsigned32", "Counter64", "enterprises", "Bits", "iso", "Integer32")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
codex = MibIdentifier((1, 3, 6, 1, 4, 1, 449))
cdxProductSpecific = MibIdentifier((1, 3, 6, 1, 4, 1, 449, 2))
cdx6500 = MibIdentifier((1, 3, 6, 1, 4, 1, 449, 2, 1))
cdx6500Configuration = MibIdentifier((1, 3, 6, 1, 4, 1, 449, 2, 1, 2))
cdx6500CfgProtocolGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1))
cdx6500PCTPortProtocolGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 1))
cdx6500PCTBSC3270DeviceGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 4))
cdx6500Statistics = MibIdentifier((1, 3, 6, 1, 4, 1, 449, 2, 1, 3))
cdx6500StatProtocolGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 1))
cdx6500PSTPortProtocolGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 1, 1))
cdx6500Controls = MibIdentifier((1, 3, 6, 1, 4, 1, 449, 2, 1, 4))
class DisplayString(OctetString):
    pass

cdx6500PPCTBSC3270PortTable = MibTable((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 1, 10), )
if mibBuilder.loadTexts: cdx6500PPCTBSC3270PortTable.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PPCTBSC3270PortTable.setDescription('A table of BSC3270 Port configuration entries.')
cdx6500PPCTBSC3270PortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 1, 10, 1), ).setIndexNames((0, "BSC3270-OPT-MIB", "cdx6500BSC3270PortNumber"))
if mibBuilder.loadTexts: cdx6500PPCTBSC3270PortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PPCTBSC3270PortEntry.setDescription('A BSC3270 Port Configuration Table entry. Each entry contains the configuration parameters for a single BSC3270 port.')
cdx6500BSC3270PortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 1, 10, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 54))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500BSC3270PortNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500BSC3270PortNumber.setDescription('The BSC3270 port number described by this entry.')
cdx6500BSC3270PADType = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 1, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 50))).clone(namedValues=NamedValues(("tpad", 0), ("hpad", 1), ("newvalTpad", 50)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500BSC3270PADType.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500BSC3270PADType.setDescription("Indicates whether the port is functioning as a Terminal PAD (tpad) or a Host PAD (hpad). newvalTpad - same functionality as 'tpad', new enumeration introduced for RFC1155 compatibility.")
cdx6500BSC3270ClockSource = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 1, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 50))).clone(namedValues=NamedValues(("int", 0), ("ext", 1), ("newvalInt", 50)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500BSC3270ClockSource.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500BSC3270ClockSource.setDescription("int - internal clock source. ext - external clock source. newvalInt - same functionality as 'int', new enumeration introduced for RFC1155 compatibility.")
cdx6500BSC3270ClockSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 1, 10, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1200, 19200))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500BSC3270ClockSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500BSC3270ClockSpeed.setDescription('This is the speed of the port in bits per second, when using internal clocking.')
cdx6500BSC3270Contention = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 1, 10, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 50))).clone(namedValues=NamedValues(("hdx", 0), ("fdx", 1), ("newvalHdx", 50)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500BSC3270Contention.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500BSC3270Contention.setDescription("Indicates whether Half Duplex (hdx) or Full Duplex (fdx) modem signals are being generated. Full Duplex indicates communication is occuring in both directions simultaneously between devices. Half Duplex indicates transmission is occuring in both directions, but only in one direction at a time. newvalHdx : same functionality as 'hdx', new enumeration introduced for RFC1155 compatibility.")
cdx6500BSC3270NumDevices = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 1, 10, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500BSC3270NumDevices.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500BSC3270NumDevices.setDescription('Specifies the number of physical devices on this line.')
cdx6500BSC3270ServTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 1, 10, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 60))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500BSC3270ServTimer.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500BSC3270ServTimer.setDescription('The Service Timer specifies the interval of time in seconds between periodic servicing. Such servicing includes intervals between the time the PAD will attempt to poll devices that previously failed to respond and intervals between failures in attempts to establish a connection from a device configured for Autocall.')
cdx6500BSC3270ErrThreshCount = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 1, 10, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500BSC3270ErrThreshCount.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500BSC3270ErrThreshCount.setDescription('Indicates number of consecutive errors that can occur before a device is considered down.')
cdx6500BSC3270ResponseTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 1, 10, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500BSC3270ResponseTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500BSC3270ResponseTimeout.setDescription('Specifies the amount of time in seconds that the TPAD will wait for a response from a device before it attempts to re-poll the non-responding device. The TPAD will continue to re-poll the device until the Error Threshold Count is reached. The device will then be polled based on the value of the Service Timer. For a Host PAD it specifies the amount of time in seconds that the HPAD will wait for a Host response before it requests a response retransmission.')
cdx6500BSC3270HostPADTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 1, 10, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500BSC3270HostPADTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500BSC3270HostPADTimeout.setDescription('Specifies the amount of time in seconds that the HPAD will wait for the host to poll a device. If the time limit is exceeded, the HPAD will consider the device to be inactive, and will not permit any physical device on a TPAD to establish a call to that address on the HPAD.')
cdx6500BSC3270InterBuffTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 1, 10, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500BSC3270InterBuffTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500BSC3270InterBuffTimeout.setDescription('Specifies the maximum amount of time in seconds the PAD will wait for the end of a multi-packet message from the network. If this time limit is exceeded, the PAD will abort the entire message and request retransmission.')
cdx6500BSC3270IdleDevTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 1, 10, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500BSC3270IdleDevTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500BSC3270IdleDevTimeout.setDescription('Specifies the amount of time in minutes that the TPAD will wait for user data from a device after an X.25 call has been established, before disconnecting the call. The parameter is applicable to devices configured as Originators. This parameter will not bring down a call established in Autocall mode. It is recommended that relatively inactive devices that are configured for Autocall be reconfigured for Fast Connect.')
cdx6500BSC3270PrintDisconTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 1, 10, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500BSC3270PrintDisconTimer.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500BSC3270PrintDisconTimer.setDescription('Specifies the amount of time in seconds that an X.25 call to a Printer device is disconnected after a period of inactivity.')
cdx6500BSC3270SignonKey = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 1, 10, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(241, 242, 243, 244, 245, 246, 247, 248, 249, 122, 123, 124, 193, 194, 195, 196, 197, 198, 199, 200, 201, 74, 75, 76))).clone(namedValues=NamedValues(("pf1", 241), ("pf2", 242), ("pf3", 243), ("pf4", 244), ("pf5", 245), ("pf6", 246), ("pf7", 247), ("pf8", 248), ("pf9", 249), ("pf10", 122), ("pf11", 123), ("pf12", 124), ("pf13", 193), ("pf14", 194), ("pf15", 195), ("pf16", 196), ("pf17", 197), ("pf18", 198), ("pf19", 199), ("pf20", 200), ("pf21", 201), ("pf22", 74), ("pf23", 75), ("pf24", 76)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500BSC3270SignonKey.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500BSC3270SignonKey.setDescription('This parameter assignes a Function Key that will be used to generate a connection. This parameter is applicable to a TPAD port only. This parameter is not applicable for devices configured for Autocall. Valid decimal codes are : pf1 - 241 pf9 - 249 pf17 - 197 pf2 - 242 pf10 - 122 pf18 - 198 pf3 - 243 pf11 - 123 pf19 - 199 pf4 - 244 pf12 - 124 pf20 - 200 pf5 - 245 pf13 - 193 pf21 - 201 pf6 - 246 pf14 - 194 pf22 - 74 pf7 - 247 pf15 - 195 pf23 - 75 pf8 - 248 pf16 - 196 pf24 - 76 Any other value will cause error.')
cdx6500BSC3270DiscKey = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 1, 10, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(241, 242, 243, 244, 245, 246, 247, 248, 249, 122, 123, 124, 193, 194, 195, 196, 197, 198, 199, 200, 201, 74, 75, 76))).clone(namedValues=NamedValues(("pf1", 241), ("pf2", 242), ("pf3", 243), ("pf4", 244), ("pf5", 245), ("pf6", 246), ("pf7", 247), ("pf8", 248), ("pf9", 249), ("pf10", 122), ("pf11", 123), ("pf12", 124), ("pf13", 193), ("pf14", 194), ("pf15", 195), ("pf16", 196), ("pf17", 197), ("pf18", 198), ("pf19", 199), ("pf20", 200), ("pf21", 201), ("pf22", 74), ("pf23", 75), ("pf24", 76)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500BSC3270DiscKey.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500BSC3270DiscKey.setDescription('This parameter allows assignment of the Function Key needed to clear the current session. This parameter is applicable to a TPAD port only. This parameter is not applicable for devices configured for Autocall. Valid decimal codes are : pf1 - 241 pf9 - 249 pf17 - 197 pf2 - 242 pf10 - 122 pf18 - 198 pf3 - 243 pf11 - 123 pf19 - 199 pf4 - 244 pf12 - 124 pf20 - 200 pf5 - 245 pf13 - 193 pf21 - 201 pf6 - 246 pf14 - 194 pf22 - 74 pf7 - 247 pf15 - 195 pf23 - 75 pf8 - 248 pf16 - 196 pf24 - 76 Any other value will cause error.')
cdx6500BSC3270CharSet = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 1, 10, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 50))).clone(namedValues=NamedValues(("ascii", 0), ("ebcdic", 1), ("newvalAscii", 50)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500BSC3270CharSet.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500BSC3270CharSet.setDescription("Indicates whether Terminal/Printer devices on this port support an ascii or ebcdic character set. newvalAscii : same functionality as 'ascii', new enumeration introduced for RFC1155 compatibility.")
cdx6500BSC3270PortSubAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 1, 10, 1, 17), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500BSC3270PortSubAddr.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500BSC3270PortSubAddr.setDescription('Calls addressed to this node and with this subaddress will be routed to this port.')
cdx6500BSC3270PortOptions = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 1, 10, 1, 18), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(4, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500BSC3270PortOptions.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500BSC3270PortOptions.setDescription('Select options on this BSC3270 port as follows: NONE - no option specified CESS - Turn the polling cessation option ON. In the HPAD, a G-POLL will not be responded to if none of the terminals configured on that controller are in a connected state (ie. no SVC in place) and there are no printers configured on that controller. A S-POLL or SELECT or a data message to a terminal will not be responded to if that device is not in a connected state. In the TPAD, devices that are configured for AUTO+ORG will be polled only once per service timer interval until the connection (SVC) to the remote HPAD is established. SINGLE - Turn single message delivery option ON. The Hpad will transmit only one complete message (single or multiple block message) when responding to a Specific or a General Poll. This option applies only to Hpad ports. Any combination of above specified by summing (eg. CESS+SINGLE).')
cdx6500BSC3270RestrictConnDest = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 1, 10, 1, 19), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500BSC3270RestrictConnDest.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500BSC3270RestrictConnDest.setDescription('All calls originating from this port will be routed to the destination specified in this parameter, irrespective of route selection table entries. For example, to route calls to port 1, use P1. To route calls to port 2, station 4, use P2S4. Blank this field to disable this function.')
cdx6500bsc3270ElectricalInterfaceType = MibScalar((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 1, 10, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("v24", 1), ("v35", 2), ("v36", 3), ("x21", 4), ("none", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500bsc3270ElectricalInterfaceType.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500bsc3270ElectricalInterfaceType.setDescription('Specify the Electrical Interface Type: V.24 - V.24 Electrical Interface Type V.35 - V.35 Electrical Interface Type V.36 - V.36 Electrical Interface Type X.21 - X.21 Electrical Interface Type NONE - Electrically disabled')
cdx6500bsc3270V24ElectricalInterfaceOption = MibScalar((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 1, 10, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ri", 1), ("tm", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500bsc3270V24ElectricalInterfaceOption.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500bsc3270V24ElectricalInterfaceOption.setDescription('Specify the Pin 22 option: RI - V.24 uses Pin 22 for Ring Indicator output signal TM - V.24 uses Pin 22 for Test Mode input signal')
cdx6500bsc3270HighSpeedElectricalInterfaceOption = MibScalar((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 1, 10, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("none", 1), ("xover", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500bsc3270HighSpeedElectricalInterfaceOption.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500bsc3270HighSpeedElectricalInterfaceOption.setDescription('Specify the cable type: NONE - V.35/V.36/X.21 DCE with straight through cable XOVER - V.35/V.36/X.21 DCE with crossover adapter cable')
cdx6500PBCTBSC3270DevTable = MibTable((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 4, 1), )
if mibBuilder.loadTexts: cdx6500PBCTBSC3270DevTable.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PBCTBSC3270DevTable.setDescription('A table of BSC3270 device configuration entries.')
cdx6500PBCTBSC3270DevEntry = MibTableRow((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 4, 1, 1), ).setIndexNames((0, "BSC3270-OPT-MIB", "cdx6500BSC3270DevPortNumber"), (0, "BSC3270-OPT-MIB", "cdx6500BSC3270DevEntry"))
if mibBuilder.loadTexts: cdx6500PBCTBSC3270DevEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PBCTBSC3270DevEntry.setDescription('A BSC3270 Device Configuration Table entry. Each entry contains the configuration parameters for a single BSC3270 device. ')
cdx6500BSC3270DevPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 54))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500BSC3270DevPortNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500BSC3270DevPortNumber.setDescription('The BSC3270 port accessing this device.')
cdx6500BSC3270DevEntry = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500BSC3270DevEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500BSC3270DevEntry.setDescription('The unique number for this specific port, 1 ... 32.')
cdx6500BSC3270BSCControlUnitAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 4, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500BSC3270BSCControlUnitAddr.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500BSC3270BSCControlUnitAddr.setDescription('This is the Poll address of the Control Unit that supports this device. It consists of two hexadecimal digits. Valid ranges depend on device Character Set as follows: EBCDIC: 40,C1,C2,C3,C4,C5,C6,C7,C8,C9,4A,4B,4C,4D,4E,4F, 50,D1,D2,D3,D4,D5,D6,D7,D8,D9,5A,5B,5C,5D,5E,5F ASCII : 20,41,42,43,44,45,46,47,48,49,5B,2E,3C,28,2B,21, 26,4A,4B,4C,4D,4E,4F,50,51,52,5D,24,2A,29,3B,5E')
cdx6500BSC3270BSCDevAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 4, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500BSC3270BSCDevAddr.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500BSC3270BSCDevAddr.setDescription('This is the Poll/Select address of this device. It consists of two hexadecimal digits. Valid ranges depend on device Character Set as follows: EBCDIC: 40,C1,C2,C3,C4,C5,C6,C7,C8,C9,4A,4B,4C,4D,4E,4F, 50,D1,D2,D3,D4,D5,D6,D7,D8,D9,5A,5B,5C,5D,5E,5F ASCII : 20,41,42,43,44,45,46,47,48,49,5B,2E,3C,28,2B,21, 26,4A,4B,4C,4D,4E,4F,50,51,52,5D,24,2A,29,3B,5E')
cdx6500BSC3270DSPDevType = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 4, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 50))).clone(namedValues=NamedValues(("term", 0), ("prin", 1), ("newvalTerm", 50)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500BSC3270DSPDevType.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500BSC3270DSPDevType.setDescription("term - device is a terminal. prin - device is a printer. newvalTerm - same functionality as 'term', new enumeration introduced for RFC1155 compatibility.")
cdx6500BSC3270DSPControl = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 4, 1, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 30))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500BSC3270DSPControl.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500BSC3270DSPControl.setDescription('Specifies device call control. Values AUTO and FAST should not be simultaneously chosen: NONE - device will not be a call originator and will be enabled ORG - call originator AUTO - if originator, automatically connect to pre-configured host FAST - a TPAD establishes a call to a pre-configured host using a pre-configured function key. Not applicable to HPAD ACK - requires DSP acknowledgement for all messages DISABLE - stops polling and clears X.25 calls Any combination of above specified by summing (eg. ORG+AUTO).')
cdx6500BSC3270DevControl = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 4, 1, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500BSC3270DevControl.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500BSC3270DevControl.setDescription('Specifies device control parameters: NONE - no device control parameter set. GPOLL- disables specific polling of a device. The device will only be polled by general polls. (TPAD only) SPOLL- forces specific polling of a device. (TPAD only) NSERV- no service messages will be sent to the device. (TPAD only) NSTAT- disables the generation of dummy DEVICE END status message. (HPAD only) RVI - forces TPAD to send RVI as an ACK for terminal text/status messages terminated with ETB or ETX. (TPAD only) Any combination of above specified by summing (e.g. GPOLL+NSERV). Configuration Notes: GPOLL overrides SPOLL if both are selected, this is not recommended. Devices under a COMMON CU ADDRESS must have identical Polling methods (e.g. CU 40 has 4 devices, all devices must be GPOLL, SPOLL or neither.)')
cdx6500BSC3270DSPDevCharacteristics = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 4, 1, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(4, 21))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500BSC3270DSPDevCharacteristics.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500BSC3270DSPDevCharacteristics.setDescription('NONE - no option XPAR - device supports transparency COLOR - device supports color PRINa - printer is attached to a terminal device Any combination of above specified by summing (eg. COLOR+PRINa).')
cdx6500BSC3270DSPDevFormatSize = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 4, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 50))).clone(namedValues=NamedValues(("format480", 0), ("format960", 1), ("format1920", 2), ("format2650", 3), ("format3440", 4), ("format3564", 5), ("newvalFormat480", 50)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500BSC3270DSPDevFormatSize.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500BSC3270DSPDevFormatSize.setDescription("Specifies maximum size of the terminal or printer message. newvalFormat480 - same functionality as 'format480', new enumeration introduced for RFC1155 compatibility.")
cdx6500BSC3270DSPCharSetCapability = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 4, 1, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 13))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500BSC3270DSPCharSetCapability.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500BSC3270DSPCharSetCapability.setDescription('Indicates device capability: NONE - no indication of capability APL - APL capability TEXT - Text capability Any combination of above specified by summing (eg. APL+TEXT).')
cdx6500BSC3270ConnReqMode = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 4, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500BSC3270ConnReqMode.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500BSC3270ConnReqMode.setDescription('Specifies which DSP Connection Request Mode (CRM) to use. There are three modes of connection as follow: 1 - fixed class CRM, connects a call to the device on a control unit with addresses that match the addresses of the call originator. 2 - specific class CRM, connects to a specific device as indicated in the destination control unit and device address. 3 - non-specific class CRM, connects to any device as indicated in the destination control unit address.')
cdx6500BSC3270DestControlUnitAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 4, 1, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500BSC3270DestControlUnitAddr.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500BSC3270DestControlUnitAddr.setDescription('Specifies control unit address on remote PAD. Used with Connection Request Mode = 2 or 3.')
cdx6500BSC3270DestDevAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 4, 1, 1, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500BSC3270DestDevAddr.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500BSC3270DestDevAddr.setDescription('Specifies device address on remote PAD. Used with Connection Request Mode = 2 or 3.')
cdx6500BSC3270AutocallMnemonic = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 4, 1, 1, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500BSC3270AutocallMnemonic.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500BSC3270AutocallMnemonic.setDescription('This mnemonic name is used if this device is configured for AUTO or FAST calling.')
cdx6500BSC3270DSPApplicationIdent = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 4, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500BSC3270DSPApplicationIdent.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500BSC3270DSPApplicationIdent.setDescription('Specifies the target application to which this device would be connected. This should match with the application ID of the Host DSP device.')
cdx6500BSC3270DSPCompatibility = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 4, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 50))).clone(namedValues=NamedValues(("no", 0), ("yes", 1), ("newvalNo", 50)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500BSC3270DSPCompatibility.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500BSC3270DSPCompatibility.setDescription("Select yes if the device connects to a DSP host or if it connects to a Codex 6507/6525 node with 2.13 or higher software revision. Select no if the device connects to 6507/6525 with pre-2.13 release. newvalNo - same functionality as 'no', new enumeration introduced for RFC1155 compatibility.")
cdx6500BSC3270BillRec = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 4, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 50))).clone(namedValues=NamedValues(("off", 0), ("on", 1), ("newvalOff", 50)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500BSC3270BillRec.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500BSC3270BillRec.setDescription("This controls whether billing (accounting) records will be created for calls on this Device. newvalOff - same functionality as 'off', new enumeration introduced for RFC1155 compatibility.")
cdx6500BSC3270TrafficPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 4, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 50))).clone(namedValues=NamedValues(("lowPriority", 0), ("medPriority", 1), ("hiPriority", 2), ("xpPriority", 3), ("newvalLowPriority", 50)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500BSC3270TrafficPriority.setStatus('optional')
if mibBuilder.loadTexts: cdx6500BSC3270TrafficPriority.setDescription("This is the traffic priority of the 3270 device; low, medium, high, or expedite. newvalLowPriority - same functionality as 'lowpriority', new enumeration introduced for RFC1155 compatibility.")
cdx6500PPSTBSC3270PortTable = MibTable((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 1, 1, 10), )
if mibBuilder.loadTexts: cdx6500PPSTBSC3270PortTable.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PPSTBSC3270PortTable.setDescription('A table of BSC3270 port statistics entries.')
cdx6500PPSTBSC3270PortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 1, 1, 10, 1), ).setIndexNames((0, "BSC3270-OPT-MIB", "cdx6500BSC3270StatPortNumber"))
if mibBuilder.loadTexts: cdx6500PPSTBSC3270PortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PPSTBSC3270PortEntry.setDescription('A BSC3270 Port Statistic Table entry. Each entry contains the statistics for a single BSC3270 port.')
cdx6500BSC3270StatPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 1, 1, 10, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 54))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500BSC3270StatPortNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500BSC3270StatPortNumber.setDescription('The BSC3270 port number described by this entry.')
cdx6500BSC3270PortStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 1, 1, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 50))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("busyOut", 2), ("up", 3), ("down", 4), ("newvalDisabled", 50)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500BSC3270PortStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500BSC3270PortStatus.setDescription("Port Status indicates whether or not the port is switched on and is ready for operation. This value may be one of : up - Port is up and running down - port is down disabled - port has been disabled enabled - port has been enabled, but is not yet Up busyOut - port has been set to be disabled as soon as last active session is disestablished. No new sessions will be established. newvalDisabled - same functionality as 'disabled', new enumeration introduced for RFC1155 compatibility.")
cdx6500BSC3270PortState = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 1, 1, 10, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(4, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500BSC3270PortState.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500BSC3270PortState.setDescription('Port State indicates what the port is actually in the process of doing. This value may be one of : INACTIVE - H/TPAD port inactive entered during boot WTPOLSERVE - TPAD is waiting for response to a poll WTSELRESP - TPAD is waiting for the response to a select WTDATARESP - H/TPAD is waiting for data to be acknowledged DATA - H/TPAD is in the process of sending/receiving data SEL/POL - TPAD is about to select or poll a controller. This is the most common state for a TPAD SELECT - TPAD is about to select a device POLL - TPAD is about to poll a device WTENQRESP - H/TPAD is waiting for a NAK response to an ENQ sent IDLE - HPAD is waiting for the host to send commands. This is the most common state of the HPAD WTEOT - HPAD is waiting for an expected EOT from the host FLUSHINGDATA - HPAD encountered an error in the message received from the host. As a result, the data is being flushed WTLCM - HPAD received a read/modify and is waiting for the response from the TPAD.')
cdx6500BSC3270PortSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 1, 1, 10, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500BSC3270PortSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500BSC3270PortSpeed.setDescription('This is the speed of the port if clock is internal. If clock is external, this is the detected clock speed. If Port Speed is 0, clock is external, but clocking is not being received from attatched device.')
cdx6500BSC3270PortUtilIn = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 1, 1, 10, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500BSC3270PortUtilIn.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500BSC3270PortUtilIn.setDescription('Pertcentage of Port input bandwidth in use.')
cdx6500BSC3270PortUtilOut = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 1, 1, 10, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500BSC3270PortUtilOut.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500BSC3270PortUtilOut.setDescription('Pertcentage of Port output bandwidth in use.')
cdx6500BSC3270InMsgs = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 1, 1, 10, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500BSC3270InMsgs.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500BSC3270InMsgs.setDescription('Number of message received since last node, port, or statistics reset.')
cdx6500BSC3270OutMsgs = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 1, 1, 10, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500BSC3270OutMsgs.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500BSC3270OutMsgs.setDescription('Number of message sent since last node, port, or statistics reset.')
cdx6500BSC3270InChars = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 1, 1, 10, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500BSC3270InChars.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500BSC3270InChars.setDescription('Number of characters received since last node, port, or statistics reset.')
cdx6500BSC3270OutChars = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 1, 1, 10, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500BSC3270OutChars.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500BSC3270OutChars.setDescription('Number of characters sent since last node, port, or statistics reset.')
cdx6500BSC3270CharRateIn = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 1, 1, 10, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500BSC3270CharRateIn.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500BSC3270CharRateIn.setDescription('Number of characters received per second.')
cdx6500BSC3270CharRateOut = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 1, 1, 10, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500BSC3270CharRateOut.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500BSC3270CharRateOut.setDescription('Number of characters sent per second.')
cdx6500BSC3270CrcBccErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 1, 1, 10, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500BSC3270CrcBccErrs.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500BSC3270CrcBccErrs.setDescription('Number of CRC errors since last node, port, or statistics reset.')
cdx6500BSC3270InPosAcks = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 1, 1, 10, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500BSC3270InPosAcks.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500BSC3270InPosAcks.setDescription('Number of ACKs received since last node, port, or statistics reset.')
cdx6500BSC3270OutPosAcks = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 1, 1, 10, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500BSC3270OutPosAcks.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500BSC3270OutPosAcks.setDescription('Number of ACKs sent since last node, port, or statistics reset.')
cdx6500BSC3270InNegAcks = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 1, 1, 10, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500BSC3270InNegAcks.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500BSC3270InNegAcks.setDescription('Number of NAKs received since last node, port, or statistics reset.')
cdx6500BSC3270OutNegAcks = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 1, 1, 10, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500BSC3270OutNegAcks.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500BSC3270OutNegAcks.setDescription('Number of NAKs sent since last node, port, or statistics reset.')
cdx6500BSC3270MsgRateIn = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 1, 1, 10, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500BSC3270MsgRateIn.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500BSC3270MsgRateIn.setDescription('Number of messages received per second.')
cdx6500BSC3270MsgRateOut = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 1, 1, 10, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500BSC3270MsgRateOut.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500BSC3270MsgRateOut.setDescription('Number of messages sent per second.')
cdx6500BSC3270InEnq = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 1, 1, 10, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500BSC3270InEnq.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500BSC3270InEnq.setDescription('Number of ENQs received since last node, port, or statistics reset.')
cdx6500BSC3270OutEnq = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 1, 1, 10, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500BSC3270OutEnq.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500BSC3270OutEnq.setDescription('Number of ENQs sent since last node, port, or statistics reset.')
cdx6500BSC3270NumRetran = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 1, 1, 10, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500BSC3270NumRetran.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500BSC3270NumRetran.setDescription('Number of messages retransmitted since last node, port, or statistics reset.')
mibBuilder.exportSymbols("BSC3270-OPT-MIB", cdx6500PBCTBSC3270DevTable=cdx6500PBCTBSC3270DevTable, cdx6500BSC3270PortSubAddr=cdx6500BSC3270PortSubAddr, cdx6500BSC3270HostPADTimeout=cdx6500BSC3270HostPADTimeout, cdx6500BSC3270DSPDevCharacteristics=cdx6500BSC3270DSPDevCharacteristics, cdx6500bsc3270V24ElectricalInterfaceOption=cdx6500bsc3270V24ElectricalInterfaceOption, cdx6500BSC3270IdleDevTimeout=cdx6500BSC3270IdleDevTimeout, cdx6500BSC3270DiscKey=cdx6500BSC3270DiscKey, cdx6500PCTBSC3270DeviceGroup=cdx6500PCTBSC3270DeviceGroup, cdx6500BSC3270DSPDevType=cdx6500BSC3270DSPDevType, cdx6500BSC3270OutNegAcks=cdx6500BSC3270OutNegAcks, cdx6500Controls=cdx6500Controls, cdx6500BSC3270StatPortNumber=cdx6500BSC3270StatPortNumber, cdx6500BSC3270PortUtilIn=cdx6500BSC3270PortUtilIn, cdx6500BSC3270NumDevices=cdx6500BSC3270NumDevices, cdx6500BSC3270TrafficPriority=cdx6500BSC3270TrafficPriority, cdx6500PPCTBSC3270PortTable=cdx6500PPCTBSC3270PortTable, cdx6500BSC3270ClockSpeed=cdx6500BSC3270ClockSpeed, cdx6500BSC3270PADType=cdx6500BSC3270PADType, cdx6500BSC3270BSCControlUnitAddr=cdx6500BSC3270BSCControlUnitAddr, cdx6500PPSTBSC3270PortEntry=cdx6500PPSTBSC3270PortEntry, cdx6500PBCTBSC3270DevEntry=cdx6500PBCTBSC3270DevEntry, cdx6500BSC3270PrintDisconTimer=cdx6500BSC3270PrintDisconTimer, cdx6500BSC3270NumRetran=cdx6500BSC3270NumRetran, cdx6500BSC3270MsgRateIn=cdx6500BSC3270MsgRateIn, cdx6500BSC3270PortState=cdx6500BSC3270PortState, cdx6500BSC3270ResponseTimeout=cdx6500BSC3270ResponseTimeout, cdx6500BSC3270InPosAcks=cdx6500BSC3270InPosAcks, cdx6500BSC3270BSCDevAddr=cdx6500BSC3270BSCDevAddr, cdx6500BSC3270DSPApplicationIdent=cdx6500BSC3270DSPApplicationIdent, cdx6500BSC3270PortNumber=cdx6500BSC3270PortNumber, cdx6500BSC3270PortStatus=cdx6500BSC3270PortStatus, cdx6500BSC3270PortUtilOut=cdx6500BSC3270PortUtilOut, cdx6500Configuration=cdx6500Configuration, cdx6500BSC3270CrcBccErrs=cdx6500BSC3270CrcBccErrs, cdx6500BSC3270InMsgs=cdx6500BSC3270InMsgs, cdx6500CfgProtocolGroup=cdx6500CfgProtocolGroup, cdx6500BSC3270InEnq=cdx6500BSC3270InEnq, cdx6500Statistics=cdx6500Statistics, cdx6500BSC3270CharRateIn=cdx6500BSC3270CharRateIn, cdx6500PPSTBSC3270PortTable=cdx6500PPSTBSC3270PortTable, cdx6500BSC3270ConnReqMode=cdx6500BSC3270ConnReqMode, cdx6500BSC3270InterBuffTimeout=cdx6500BSC3270InterBuffTimeout, cdx6500BSC3270InChars=cdx6500BSC3270InChars, cdx6500BSC3270SignonKey=cdx6500BSC3270SignonKey, cdx6500BSC3270DSPCharSetCapability=cdx6500BSC3270DSPCharSetCapability, cdx6500BSC3270ServTimer=cdx6500BSC3270ServTimer, cdx6500BSC3270DevControl=cdx6500BSC3270DevControl, cdx6500BSC3270OutMsgs=cdx6500BSC3270OutMsgs, cdx6500BSC3270OutEnq=cdx6500BSC3270OutEnq, cdx6500BSC3270Contention=cdx6500BSC3270Contention, cdx6500BSC3270DevPortNumber=cdx6500BSC3270DevPortNumber, codex=codex, cdx6500bsc3270HighSpeedElectricalInterfaceOption=cdx6500bsc3270HighSpeedElectricalInterfaceOption, cdx6500BSC3270CharSet=cdx6500BSC3270CharSet, cdx6500BSC3270DSPControl=cdx6500BSC3270DSPControl, cdx6500BSC3270DSPCompatibility=cdx6500BSC3270DSPCompatibility, cdx6500BSC3270CharRateOut=cdx6500BSC3270CharRateOut, cdx6500BSC3270DestControlUnitAddr=cdx6500BSC3270DestControlUnitAddr, cdx6500BSC3270DevEntry=cdx6500BSC3270DevEntry, cdx6500BSC3270PortSpeed=cdx6500BSC3270PortSpeed, cdx6500StatProtocolGroup=cdx6500StatProtocolGroup, cdx6500BSC3270ErrThreshCount=cdx6500BSC3270ErrThreshCount, cdx6500BSC3270DSPDevFormatSize=cdx6500BSC3270DSPDevFormatSize, cdx6500BSC3270OutChars=cdx6500BSC3270OutChars, cdx6500PSTPortProtocolGroup=cdx6500PSTPortProtocolGroup, cdx6500PCTPortProtocolGroup=cdx6500PCTPortProtocolGroup, cdx6500BSC3270BillRec=cdx6500BSC3270BillRec, cdx6500PPCTBSC3270PortEntry=cdx6500PPCTBSC3270PortEntry, cdx6500=cdx6500, cdx6500BSC3270InNegAcks=cdx6500BSC3270InNegAcks, cdx6500BSC3270RestrictConnDest=cdx6500BSC3270RestrictConnDest, DisplayString=DisplayString, cdx6500BSC3270AutocallMnemonic=cdx6500BSC3270AutocallMnemonic, cdx6500BSC3270OutPosAcks=cdx6500BSC3270OutPosAcks, cdx6500bsc3270ElectricalInterfaceType=cdx6500bsc3270ElectricalInterfaceType, cdx6500BSC3270MsgRateOut=cdx6500BSC3270MsgRateOut, cdx6500BSC3270DestDevAddr=cdx6500BSC3270DestDevAddr, cdx6500BSC3270ClockSource=cdx6500BSC3270ClockSource, cdxProductSpecific=cdxProductSpecific, cdx6500BSC3270PortOptions=cdx6500BSC3270PortOptions)
